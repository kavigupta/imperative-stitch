{"setup.py": "#!/usr/bin/env python3\n\nfrom setuptools import setup\n\nsetup()\n", "jwt/exceptions.py": "class PyJWTError(Exception):\n    \"\"\"\n    Base class for all exceptions\n    \"\"\"\n\n    pass\n\n\nclass InvalidTokenError(PyJWTError):\n    pass\n\n\nclass DecodeError(InvalidTokenError):\n    pass\n\n\nclass InvalidSignatureError(DecodeError):\n    pass\n\n\nclass ExpiredSignatureError(InvalidTokenError):\n    pass\n\n\nclass InvalidAudienceError(InvalidTokenError):\n    pass\n\n\nclass InvalidIssuerError(InvalidTokenError):\n    pass\n\n\nclass InvalidIssuedAtError(InvalidTokenError):\n    pass\n\n\nclass ImmatureSignatureError(InvalidTokenError):\n    pass\n\n\nclass InvalidKeyError(PyJWTError):\n    pass\n\n\nclass InvalidAlgorithmError(InvalidTokenError):\n    pass\n\n\nclass MissingRequiredClaimError(InvalidTokenError):\n    def __init__(self, claim: str) -> None:\n        self.claim = claim\n\n    def __str__(self) -> str:\n        return f'Token is missing the \"{self.claim}\" claim'\n\n\nclass PyJWKError(PyJWTError):\n    pass\n\n\nclass PyJWKSetError(PyJWTError):\n    pass\n\n\nclass PyJWKClientError(PyJWTError):\n    pass\n\n\nclass PyJWKClientConnectionError(PyJWKClientError):\n    pass\n", "jwt/algorithms.py": "from __future__ import annotations\n\nimport hashlib\nimport hmac\nimport json\nfrom abc import ABC, abstractmethod\nfrom typing import TYPE_CHECKING, Any, ClassVar, Literal, NoReturn, cast, overload\n\nfrom .exceptions import InvalidKeyError\nfrom .types import HashlibHash, JWKDict\nfrom .utils import (\n    base64url_decode,\n    base64url_encode,\n    der_to_raw_signature,\n    force_bytes,\n    from_base64url_uint,\n    is_pem_format,\n    is_ssh_key,\n    raw_to_der_signature,\n    to_base64url_uint,\n)\n\ntry:\n    from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm\n    from cryptography.hazmat.backends import default_backend\n    from cryptography.hazmat.primitives import hashes\n    from cryptography.hazmat.primitives.asymmetric import padding\n    from cryptography.hazmat.primitives.asymmetric.ec import (\n        ECDSA,\n        SECP256K1,\n        SECP256R1,\n        SECP384R1,\n        SECP521R1,\n        EllipticCurve,\n        EllipticCurvePrivateKey,\n        EllipticCurvePrivateNumbers,\n        EllipticCurvePublicKey,\n        EllipticCurvePublicNumbers,\n    )\n    from cryptography.hazmat.primitives.asymmetric.ed448 import (\n        Ed448PrivateKey,\n        Ed448PublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.ed25519 import (\n        Ed25519PrivateKey,\n        Ed25519PublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.rsa import (\n        RSAPrivateKey,\n        RSAPrivateNumbers,\n        RSAPublicKey,\n        RSAPublicNumbers,\n        rsa_crt_dmp1,\n        rsa_crt_dmq1,\n        rsa_crt_iqmp,\n        rsa_recover_prime_factors,\n    )\n    from cryptography.hazmat.primitives.serialization import (\n        Encoding,\n        NoEncryption,\n        PrivateFormat,\n        PublicFormat,\n        load_pem_private_key,\n        load_pem_public_key,\n        load_ssh_public_key,\n    )\n\n    has_crypto = True\nexcept ModuleNotFoundError:\n    has_crypto = False\n\n\nif TYPE_CHECKING:\n    # Type aliases for convenience in algorithms method signatures\n    AllowedRSAKeys = RSAPrivateKey | RSAPublicKey\n    AllowedECKeys = EllipticCurvePrivateKey | EllipticCurvePublicKey\n    AllowedOKPKeys = (\n        Ed25519PrivateKey | Ed25519PublicKey | Ed448PrivateKey | Ed448PublicKey\n    )\n    AllowedKeys = AllowedRSAKeys | AllowedECKeys | AllowedOKPKeys\n    AllowedPrivateKeys = (\n        RSAPrivateKey | EllipticCurvePrivateKey | Ed25519PrivateKey | Ed448PrivateKey\n    )\n    AllowedPublicKeys = (\n        RSAPublicKey | EllipticCurvePublicKey | Ed25519PublicKey | Ed448PublicKey\n    )\n\n\nrequires_cryptography = {\n    \"RS256\",\n    \"RS384\",\n    \"RS512\",\n    \"ES256\",\n    \"ES256K\",\n    \"ES384\",\n    \"ES521\",\n    \"ES512\",\n    \"PS256\",\n    \"PS384\",\n    \"PS512\",\n    \"EdDSA\",\n}\n\n\ndef get_default_algorithms() -> dict[str, Algorithm]:\n    \"\"\"\n    Returns the algorithms that are implemented by the library.\n    \"\"\"\n    default_algorithms = {\n        \"none\": NoneAlgorithm(),\n        \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),\n        \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),\n        \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),\n    }\n\n    if has_crypto:\n        default_algorithms.update(\n            {\n                \"RS256\": RSAAlgorithm(RSAAlgorithm.SHA256),\n                \"RS384\": RSAAlgorithm(RSAAlgorithm.SHA384),\n                \"RS512\": RSAAlgorithm(RSAAlgorithm.SHA512),\n                \"ES256\": ECAlgorithm(ECAlgorithm.SHA256),\n                \"ES256K\": ECAlgorithm(ECAlgorithm.SHA256),\n                \"ES384\": ECAlgorithm(ECAlgorithm.SHA384),\n                \"ES521\": ECAlgorithm(ECAlgorithm.SHA512),\n                \"ES512\": ECAlgorithm(\n                    ECAlgorithm.SHA512\n                ),  # Backward compat for #219 fix\n                \"PS256\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),\n                \"PS384\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),\n                \"PS512\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),\n                \"EdDSA\": OKPAlgorithm(),\n            }\n        )\n\n    return default_algorithms\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    The interface for an algorithm used to sign and verify tokens.\n    \"\"\"\n\n    def compute_hash_digest(self, bytestr: bytes) -> bytes:\n        \"\"\"\n        Compute a hash digest using the specified algorithm's hash algorithm.\n\n        If there is no hash algorithm, raises a NotImplementedError.\n        \"\"\"\n        # lookup self.hash_alg if defined in a way that mypy can understand\n        hash_alg = getattr(self, \"hash_alg\", None)\n        if hash_alg is None:\n            raise NotImplementedError\n\n        if (\n            has_crypto\n            and isinstance(hash_alg, type)\n            and issubclass(hash_alg, hashes.HashAlgorithm)\n        ):\n            digest = hashes.Hash(hash_alg(), backend=default_backend())\n            digest.update(bytestr)\n            return bytes(digest.finalize())\n        else:\n            return bytes(hash_alg(bytestr).digest())\n\n    @abstractmethod\n    def prepare_key(self, key: Any) -> Any:\n        \"\"\"\n        Performs necessary validation and conversions on the key and returns\n        the key value in the proper format for sign() and verify().\n        \"\"\"\n\n    @abstractmethod\n    def sign(self, msg: bytes, key: Any) -> bytes:\n        \"\"\"\n        Returns a digital signature for the specified message\n        using the specified key value.\n        \"\"\"\n\n    @abstractmethod\n    def verify(self, msg: bytes, key: Any, sig: bytes) -> bool:\n        \"\"\"\n        Verifies that the specified digital signature is valid\n        for the specified message and key values.\n        \"\"\"\n\n    @overload\n    @staticmethod\n    @abstractmethod\n    def to_jwk(key_obj, as_dict: Literal[True]) -> JWKDict: ...  # pragma: no cover\n\n    @overload\n    @staticmethod\n    @abstractmethod\n    def to_jwk(key_obj, as_dict: Literal[False] = False) -> str: ...  # pragma: no cover\n\n    @staticmethod\n    @abstractmethod\n    def to_jwk(key_obj, as_dict: bool = False) -> JWKDict | str:\n        \"\"\"\n        Serializes a given key into a JWK\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def from_jwk(jwk: str | JWKDict) -> Any:\n        \"\"\"\n        Deserializes a given key from JWK back into a key object\n        \"\"\"\n\n\nclass NoneAlgorithm(Algorithm):\n    \"\"\"\n    Placeholder for use when no signing or verification\n    operations are required.\n    \"\"\"\n\n    def prepare_key(self, key: str | None) -> None:\n        if key == \"\":\n            key = None\n\n        if key is not None:\n            raise InvalidKeyError('When alg = \"none\", key value must be None.')\n\n        return key\n\n    def sign(self, msg: bytes, key: None) -> bytes:\n        return b\"\"\n\n    def verify(self, msg: bytes, key: None, sig: bytes) -> bool:\n        return False\n\n    @staticmethod\n    def to_jwk(key_obj: Any, as_dict: bool = False) -> NoReturn:\n        raise NotImplementedError()\n\n    @staticmethod\n    def from_jwk(jwk: str | JWKDict) -> NoReturn:\n        raise NotImplementedError()\n\n\nclass HMACAlgorithm(Algorithm):\n    \"\"\"\n    Performs signing and verification operations using HMAC\n    and the specified hash function.\n    \"\"\"\n\n    SHA256: ClassVar[HashlibHash] = hashlib.sha256\n    SHA384: ClassVar[HashlibHash] = hashlib.sha384\n    SHA512: ClassVar[HashlibHash] = hashlib.sha512\n\n    def __init__(self, hash_alg: HashlibHash) -> None:\n        self.hash_alg = hash_alg\n\n    def prepare_key(self, key: str | bytes) -> bytes:\n        key_bytes = force_bytes(key)\n\n        if is_pem_format(key_bytes) or is_ssh_key(key_bytes):\n            raise InvalidKeyError(\n                \"The specified key is an asymmetric key or x509 certificate and\"\n                \" should not be used as an HMAC secret.\"\n            )\n\n        return key_bytes\n\n    @overload\n    @staticmethod\n    def to_jwk(\n        key_obj: str | bytes, as_dict: Literal[True]\n    ) -> JWKDict: ...  # pragma: no cover\n\n    @overload\n    @staticmethod\n    def to_jwk(\n        key_obj: str | bytes, as_dict: Literal[False] = False\n    ) -> str: ...  # pragma: no cover\n\n    @staticmethod\n    def to_jwk(key_obj: str | bytes, as_dict: bool = False) -> JWKDict | str:\n        jwk = {\n            \"k\": base64url_encode(force_bytes(key_obj)).decode(),\n            \"kty\": \"oct\",\n        }\n\n        if as_dict:\n            return jwk\n        else:\n            return json.dumps(jwk)\n\n    @staticmethod\n    def from_jwk(jwk: str | JWKDict) -> bytes:\n        try:\n            if isinstance(jwk, str):\n                obj: JWKDict = json.loads(jwk)\n            elif isinstance(jwk, dict):\n                obj = jwk\n            else:\n                raise ValueError\n        except ValueError:\n            raise InvalidKeyError(\"Key is not valid JSON\")\n\n        if obj.get(\"kty\") != \"oct\":\n            raise InvalidKeyError(\"Not an HMAC key\")\n\n        return base64url_decode(obj[\"k\"])\n\n    def sign(self, msg: bytes, key: bytes) -> bytes:\n        return hmac.new(key, msg, self.hash_alg).digest()\n\n    def verify(self, msg: bytes, key: bytes, sig: bytes) -> bool:\n        return hmac.compare_digest(sig, self.sign(msg, key))\n\n\nif has_crypto:\n\n    class RSAAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using\n        RSASSA-PKCS-v1_5 and the specified hash function.\n        \"\"\"\n\n        SHA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256\n        SHA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384\n        SHA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512\n\n        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:\n            self.hash_alg = hash_alg\n\n        def prepare_key(self, key: AllowedRSAKeys | str | bytes) -> AllowedRSAKeys:\n            if isinstance(key, (RSAPrivateKey, RSAPublicKey)):\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            try:\n                if key_bytes.startswith(b\"ssh-rsa\"):\n                    return cast(RSAPublicKey, load_ssh_public_key(key_bytes))\n                else:\n                    return cast(\n                        RSAPrivateKey, load_pem_private_key(key_bytes, password=None)\n                    )\n            except ValueError:\n                try:\n                    return cast(RSAPublicKey, load_pem_public_key(key_bytes))\n                except (ValueError, UnsupportedAlgorithm):\n                    raise InvalidKeyError(\"Could not parse the provided public key.\")\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedRSAKeys, as_dict: Literal[True]\n        ) -> JWKDict: ...  # pragma: no cover\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedRSAKeys, as_dict: Literal[False] = False\n        ) -> str: ...  # pragma: no cover\n\n        @staticmethod\n        def to_jwk(key_obj: AllowedRSAKeys, as_dict: bool = False) -> JWKDict | str:\n            obj: dict[str, Any] | None = None\n\n            if hasattr(key_obj, \"private_numbers\"):\n                # Private key\n                numbers = key_obj.private_numbers()\n\n                obj = {\n                    \"kty\": \"RSA\",\n                    \"key_ops\": [\"sign\"],\n                    \"n\": to_base64url_uint(numbers.public_numbers.n).decode(),\n                    \"e\": to_base64url_uint(numbers.public_numbers.e).decode(),\n                    \"d\": to_base64url_uint(numbers.d).decode(),\n                    \"p\": to_base64url_uint(numbers.p).decode(),\n                    \"q\": to_base64url_uint(numbers.q).decode(),\n                    \"dp\": to_base64url_uint(numbers.dmp1).decode(),\n                    \"dq\": to_base64url_uint(numbers.dmq1).decode(),\n                    \"qi\": to_base64url_uint(numbers.iqmp).decode(),\n                }\n\n            elif hasattr(key_obj, \"verify\"):\n                # Public key\n                numbers = key_obj.public_numbers()\n\n                obj = {\n                    \"kty\": \"RSA\",\n                    \"key_ops\": [\"verify\"],\n                    \"n\": to_base64url_uint(numbers.n).decode(),\n                    \"e\": to_base64url_uint(numbers.e).decode(),\n                }\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n            if as_dict:\n                return obj\n            else:\n                return json.dumps(obj)\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedRSAKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\")\n\n            if obj.get(\"kty\") != \"RSA\":\n                raise InvalidKeyError(\"Not an RSA key\")\n\n            if \"d\" in obj and \"e\" in obj and \"n\" in obj:\n                # Private key\n                if \"oth\" in obj:\n                    raise InvalidKeyError(\n                        \"Unsupported RSA private key: > 2 primes not supported\"\n                    )\n\n                other_props = [\"p\", \"q\", \"dp\", \"dq\", \"qi\"]\n                props_found = [prop in obj for prop in other_props]\n                any_props_found = any(props_found)\n\n                if any_props_found and not all(props_found):\n                    raise InvalidKeyError(\n                        \"RSA key must include all parameters if any are present besides d\"\n                    )\n\n                public_numbers = RSAPublicNumbers(\n                    from_base64url_uint(obj[\"e\"]),\n                    from_base64url_uint(obj[\"n\"]),\n                )\n\n                if any_props_found:\n                    numbers = RSAPrivateNumbers(\n                        d=from_base64url_uint(obj[\"d\"]),\n                        p=from_base64url_uint(obj[\"p\"]),\n                        q=from_base64url_uint(obj[\"q\"]),\n                        dmp1=from_base64url_uint(obj[\"dp\"]),\n                        dmq1=from_base64url_uint(obj[\"dq\"]),\n                        iqmp=from_base64url_uint(obj[\"qi\"]),\n                        public_numbers=public_numbers,\n                    )\n                else:\n                    d = from_base64url_uint(obj[\"d\"])\n                    p, q = rsa_recover_prime_factors(\n                        public_numbers.n, d, public_numbers.e\n                    )\n\n                    numbers = RSAPrivateNumbers(\n                        d=d,\n                        p=p,\n                        q=q,\n                        dmp1=rsa_crt_dmp1(d, p),\n                        dmq1=rsa_crt_dmq1(d, q),\n                        iqmp=rsa_crt_iqmp(p, q),\n                        public_numbers=public_numbers,\n                    )\n\n                return numbers.private_key()\n            elif \"n\" in obj and \"e\" in obj:\n                # Public key\n                return RSAPublicNumbers(\n                    from_base64url_uint(obj[\"e\"]),\n                    from_base64url_uint(obj[\"n\"]),\n                ).public_key()\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n        def sign(self, msg: bytes, key: RSAPrivateKey) -> bytes:\n            return key.sign(msg, padding.PKCS1v15(), self.hash_alg())\n\n        def verify(self, msg: bytes, key: RSAPublicKey, sig: bytes) -> bool:\n            try:\n                key.verify(sig, msg, padding.PKCS1v15(), self.hash_alg())\n                return True\n            except InvalidSignature:\n                return False\n\n    class ECAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using\n        ECDSA and the specified hash function\n        \"\"\"\n\n        SHA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256\n        SHA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384\n        SHA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512\n\n        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:\n            self.hash_alg = hash_alg\n\n        def prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:\n            if isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            # Attempt to load key. We don't know if it's\n            # a Signing Key or a Verifying Key, so we try\n            # the Verifying Key first.\n            try:\n                if key_bytes.startswith(b\"ecdsa-sha2-\"):\n                    crypto_key = load_ssh_public_key(key_bytes)\n                else:\n                    crypto_key = load_pem_public_key(key_bytes)  # type: ignore[assignment]\n            except ValueError:\n                crypto_key = load_pem_private_key(key_bytes, password=None)  # type: ignore[assignment]\n\n            # Explicit check the key to prevent confusing errors from cryptography\n            if not isinstance(\n                crypto_key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)\n            ):\n                raise InvalidKeyError(\n                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for ECDSA algorithms\"\n                )\n\n            return crypto_key\n\n        def sign(self, msg: bytes, key: EllipticCurvePrivateKey) -> bytes:\n            der_sig = key.sign(msg, ECDSA(self.hash_alg()))\n\n            return der_to_raw_signature(der_sig, key.curve)\n\n        def verify(self, msg: bytes, key: AllowedECKeys, sig: bytes) -> bool:\n            try:\n                der_sig = raw_to_der_signature(sig, key.curve)\n            except ValueError:\n                return False\n\n            try:\n                public_key = (\n                    key.public_key()\n                    if isinstance(key, EllipticCurvePrivateKey)\n                    else key\n                )\n                public_key.verify(der_sig, msg, ECDSA(self.hash_alg()))\n                return True\n            except InvalidSignature:\n                return False\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedECKeys, as_dict: Literal[True]\n        ) -> JWKDict: ...  # pragma: no cover\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedECKeys, as_dict: Literal[False] = False\n        ) -> str: ...  # pragma: no cover\n\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: bool = False) -> JWKDict | str:\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                public_numbers = key_obj.public_key().public_numbers()\n            elif isinstance(key_obj, EllipticCurvePublicKey):\n                public_numbers = key_obj.public_numbers()\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n            if isinstance(key_obj.curve, SECP256R1):\n                crv = \"P-256\"\n            elif isinstance(key_obj.curve, SECP384R1):\n                crv = \"P-384\"\n            elif isinstance(key_obj.curve, SECP521R1):\n                crv = \"P-521\"\n            elif isinstance(key_obj.curve, SECP256K1):\n                crv = \"secp256k1\"\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {key_obj.curve}\")\n\n            obj: dict[str, Any] = {\n                \"kty\": \"EC\",\n                \"crv\": crv,\n                \"x\": to_base64url_uint(public_numbers.x).decode(),\n                \"y\": to_base64url_uint(public_numbers.y).decode(),\n            }\n\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                obj[\"d\"] = to_base64url_uint(\n                    key_obj.private_numbers().private_value\n                ).decode()\n\n            if as_dict:\n                return obj\n            else:\n                return json.dumps(obj)\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedECKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\")\n\n            if obj.get(\"kty\") != \"EC\":\n                raise InvalidKeyError(\"Not an Elliptic curve key\")\n\n            if \"x\" not in obj or \"y\" not in obj:\n                raise InvalidKeyError(\"Not an Elliptic curve key\")\n\n            x = base64url_decode(obj.get(\"x\"))\n            y = base64url_decode(obj.get(\"y\"))\n\n            curve = obj.get(\"crv\")\n            curve_obj: EllipticCurve\n\n            if curve == \"P-256\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256R1()\n                else:\n                    raise InvalidKeyError(\"Coords should be 32 bytes for curve P-256\")\n            elif curve == \"P-384\":\n                if len(x) == len(y) == 48:\n                    curve_obj = SECP384R1()\n                else:\n                    raise InvalidKeyError(\"Coords should be 48 bytes for curve P-384\")\n            elif curve == \"P-521\":\n                if len(x) == len(y) == 66:\n                    curve_obj = SECP521R1()\n                else:\n                    raise InvalidKeyError(\"Coords should be 66 bytes for curve P-521\")\n            elif curve == \"secp256k1\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256K1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 32 bytes for curve secp256k1\"\n                    )\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {curve}\")\n\n            public_numbers = EllipticCurvePublicNumbers(\n                x=int.from_bytes(x, byteorder=\"big\"),\n                y=int.from_bytes(y, byteorder=\"big\"),\n                curve=curve_obj,\n            )\n\n            if \"d\" not in obj:\n                return public_numbers.public_key()\n\n            d = base64url_decode(obj.get(\"d\"))\n            if len(d) != len(x):\n                raise InvalidKeyError(\n                    \"D should be {} bytes for curve {}\", len(x), curve\n                )\n\n            return EllipticCurvePrivateNumbers(\n                int.from_bytes(d, byteorder=\"big\"), public_numbers\n            ).private_key()\n\n    class RSAPSSAlgorithm(RSAAlgorithm):\n        \"\"\"\n        Performs a signature using RSASSA-PSS with MGF1\n        \"\"\"\n\n        def sign(self, msg: bytes, key: RSAPrivateKey) -> bytes:\n            return key.sign(\n                msg,\n                padding.PSS(\n                    mgf=padding.MGF1(self.hash_alg()),\n                    salt_length=self.hash_alg().digest_size,\n                ),\n                self.hash_alg(),\n            )\n\n        def verify(self, msg: bytes, key: RSAPublicKey, sig: bytes) -> bool:\n            try:\n                key.verify(\n                    sig,\n                    msg,\n                    padding.PSS(\n                        mgf=padding.MGF1(self.hash_alg()),\n                        salt_length=self.hash_alg().digest_size,\n                    ),\n                    self.hash_alg(),\n                )\n                return True\n            except InvalidSignature:\n                return False\n\n    class OKPAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using EdDSA\n\n        This class requires ``cryptography>=2.6`` to be installed.\n        \"\"\"\n\n        def __init__(self, **kwargs: Any) -> None:\n            pass\n\n        def prepare_key(self, key: AllowedOKPKeys | str | bytes) -> AllowedOKPKeys:\n            if isinstance(key, (bytes, str)):\n                key_str = key.decode(\"utf-8\") if isinstance(key, bytes) else key\n                key_bytes = key.encode(\"utf-8\") if isinstance(key, str) else key\n\n                if \"-----BEGIN PUBLIC\" in key_str:\n                    key = load_pem_public_key(key_bytes)  # type: ignore[assignment]\n                elif \"-----BEGIN PRIVATE\" in key_str:\n                    key = load_pem_private_key(key_bytes, password=None)  # type: ignore[assignment]\n                elif key_str[0:4] == \"ssh-\":\n                    key = load_ssh_public_key(key_bytes)  # type: ignore[assignment]\n\n            # Explicit check the key to prevent confusing errors from cryptography\n            if not isinstance(\n                key,\n                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),\n            ):\n                raise InvalidKeyError(\n                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for EdDSA algorithms\"\n                )\n\n            return key\n\n        def sign(\n            self, msg: str | bytes, key: Ed25519PrivateKey | Ed448PrivateKey\n        ) -> bytes:\n            \"\"\"\n            Sign a message ``msg`` using the EdDSA private key ``key``\n            :param str|bytes msg: Message to sign\n            :param Ed25519PrivateKey}Ed448PrivateKey key: A :class:`.Ed25519PrivateKey`\n                or :class:`.Ed448PrivateKey` isinstance\n            :return bytes signature: The signature, as bytes\n            \"\"\"\n            msg_bytes = msg.encode(\"utf-8\") if isinstance(msg, str) else msg\n            return key.sign(msg_bytes)\n\n        def verify(\n            self, msg: str | bytes, key: AllowedOKPKeys, sig: str | bytes\n        ) -> bool:\n            \"\"\"\n            Verify a given ``msg`` against a signature ``sig`` using the EdDSA key ``key``\n\n            :param str|bytes sig: EdDSA signature to check ``msg`` against\n            :param str|bytes msg: Message to sign\n            :param Ed25519PrivateKey|Ed25519PublicKey|Ed448PrivateKey|Ed448PublicKey key:\n                A private or public EdDSA key instance\n            :return bool verified: True if signature is valid, False if not.\n            \"\"\"\n            try:\n                msg_bytes = msg.encode(\"utf-8\") if isinstance(msg, str) else msg\n                sig_bytes = sig.encode(\"utf-8\") if isinstance(sig, str) else sig\n\n                public_key = (\n                    key.public_key()\n                    if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey))\n                    else key\n                )\n                public_key.verify(sig_bytes, msg_bytes)\n                return True  # If no exception was raised, the signature is valid.\n            except InvalidSignature:\n                return False\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key: AllowedOKPKeys, as_dict: Literal[True]\n        ) -> JWKDict: ...  # pragma: no cover\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key: AllowedOKPKeys, as_dict: Literal[False] = False\n        ) -> str: ...  # pragma: no cover\n\n        @staticmethod\n        def to_jwk(key: AllowedOKPKeys, as_dict: bool = False) -> JWKDict | str:\n            if isinstance(key, (Ed25519PublicKey, Ed448PublicKey)):\n                x = key.public_bytes(\n                    encoding=Encoding.Raw,\n                    format=PublicFormat.Raw,\n                )\n                crv = \"Ed25519\" if isinstance(key, Ed25519PublicKey) else \"Ed448\"\n\n                obj = {\n                    \"x\": base64url_encode(force_bytes(x)).decode(),\n                    \"kty\": \"OKP\",\n                    \"crv\": crv,\n                }\n\n                if as_dict:\n                    return obj\n                else:\n                    return json.dumps(obj)\n\n            if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):\n                d = key.private_bytes(\n                    encoding=Encoding.Raw,\n                    format=PrivateFormat.Raw,\n                    encryption_algorithm=NoEncryption(),\n                )\n\n                x = key.public_key().public_bytes(\n                    encoding=Encoding.Raw,\n                    format=PublicFormat.Raw,\n                )\n\n                crv = \"Ed25519\" if isinstance(key, Ed25519PrivateKey) else \"Ed448\"\n                obj = {\n                    \"x\": base64url_encode(force_bytes(x)).decode(),\n                    \"d\": base64url_encode(force_bytes(d)).decode(),\n                    \"kty\": \"OKP\",\n                    \"crv\": crv,\n                }\n\n                if as_dict:\n                    return obj\n                else:\n                    return json.dumps(obj)\n\n            raise InvalidKeyError(\"Not a public or private key\")\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedOKPKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\")\n\n            if obj.get(\"kty\") != \"OKP\":\n                raise InvalidKeyError(\"Not an Octet Key Pair\")\n\n            curve = obj.get(\"crv\")\n            if curve != \"Ed25519\" and curve != \"Ed448\":\n                raise InvalidKeyError(f\"Invalid curve: {curve}\")\n\n            if \"x\" not in obj:\n                raise InvalidKeyError('OKP should have \"x\" parameter')\n            x = base64url_decode(obj.get(\"x\"))\n\n            try:\n                if \"d\" not in obj:\n                    if curve == \"Ed25519\":\n                        return Ed25519PublicKey.from_public_bytes(x)\n                    return Ed448PublicKey.from_public_bytes(x)\n                d = base64url_decode(obj.get(\"d\"))\n                if curve == \"Ed25519\":\n                    return Ed25519PrivateKey.from_private_bytes(d)\n                return Ed448PrivateKey.from_private_bytes(d)\n            except ValueError as err:\n                raise InvalidKeyError(\"Invalid key parameter\") from err\n", "jwt/utils.py": "import base64\nimport binascii\nimport re\nfrom typing import Union\n\ntry:\n    from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurve\n    from cryptography.hazmat.primitives.asymmetric.utils import (\n        decode_dss_signature,\n        encode_dss_signature,\n    )\nexcept ModuleNotFoundError:\n    pass\n\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    if isinstance(value, str):\n        return value.encode(\"utf-8\")\n    elif isinstance(value, bytes):\n        return value\n    else:\n        raise TypeError(\"Expected a string value\")\n\n\ndef base64url_decode(input: Union[bytes, str]) -> bytes:\n    input_bytes = force_bytes(input)\n\n    rem = len(input_bytes) % 4\n\n    if rem > 0:\n        input_bytes += b\"=\" * (4 - rem)\n\n    return base64.urlsafe_b64decode(input_bytes)\n\n\ndef base64url_encode(input: bytes) -> bytes:\n    return base64.urlsafe_b64encode(input).replace(b\"=\", b\"\")\n\n\ndef to_base64url_uint(val: int) -> bytes:\n    if val < 0:\n        raise ValueError(\"Must be a positive integer\")\n\n    int_bytes = bytes_from_int(val)\n\n    if len(int_bytes) == 0:\n        int_bytes = b\"\\x00\"\n\n    return base64url_encode(int_bytes)\n\n\ndef from_base64url_uint(val: Union[bytes, str]) -> int:\n    data = base64url_decode(force_bytes(val))\n    return int.from_bytes(data, byteorder=\"big\")\n\n\ndef number_to_bytes(num: int, num_bytes: int) -> bytes:\n    padded_hex = \"%0*x\" % (2 * num_bytes, num)\n    return binascii.a2b_hex(padded_hex.encode(\"ascii\"))\n\n\ndef bytes_to_number(string: bytes) -> int:\n    return int(binascii.b2a_hex(string), 16)\n\n\ndef bytes_from_int(val: int) -> bytes:\n    remaining = val\n    byte_length = 0\n\n    while remaining != 0:\n        remaining >>= 8\n        byte_length += 1\n\n    return val.to_bytes(byte_length, \"big\", signed=False)\n\n\ndef der_to_raw_signature(der_sig: bytes, curve: \"EllipticCurve\") -> bytes:\n    num_bits = curve.key_size\n    num_bytes = (num_bits + 7) // 8\n\n    r, s = decode_dss_signature(der_sig)\n\n    return number_to_bytes(r, num_bytes) + number_to_bytes(s, num_bytes)\n\n\ndef raw_to_der_signature(raw_sig: bytes, curve: \"EllipticCurve\") -> bytes:\n    num_bits = curve.key_size\n    num_bytes = (num_bits + 7) // 8\n\n    if len(raw_sig) != 2 * num_bytes:\n        raise ValueError(\"Invalid signature\")\n\n    r = bytes_to_number(raw_sig[:num_bytes])\n    s = bytes_to_number(raw_sig[num_bytes:])\n\n    return bytes(encode_dss_signature(r, s))\n\n\n# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252\n_PEMS = {\n    b\"CERTIFICATE\",\n    b\"TRUSTED CERTIFICATE\",\n    b\"PRIVATE KEY\",\n    b\"PUBLIC KEY\",\n    b\"ENCRYPTED PRIVATE KEY\",\n    b\"OPENSSH PRIVATE KEY\",\n    b\"DSA PRIVATE KEY\",\n    b\"RSA PRIVATE KEY\",\n    b\"RSA PUBLIC KEY\",\n    b\"EC PRIVATE KEY\",\n    b\"DH PARAMETERS\",\n    b\"NEW CERTIFICATE REQUEST\",\n    b\"CERTIFICATE REQUEST\",\n    b\"SSH2 PUBLIC KEY\",\n    b\"SSH2 ENCRYPTED PRIVATE KEY\",\n    b\"X509 CRL\",\n}\n\n_PEM_RE = re.compile(\n    b\"----[- ]BEGIN (\"\n    + b\"|\".join(_PEMS)\n    + b\"\"\")[- ]----\\r?\n.+?\\r?\n----[- ]END \\\\1[- ]----\\r?\\n?\"\"\",\n    re.DOTALL,\n)\n\n\ndef is_pem_format(key: bytes) -> bool:\n    return bool(_PEM_RE.search(key))\n\n\n# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46\n_SSH_KEY_FORMATS = (\n    b\"ssh-ed25519\",\n    b\"ssh-rsa\",\n    b\"ssh-dss\",\n    b\"ecdsa-sha2-nistp256\",\n    b\"ecdsa-sha2-nistp384\",\n    b\"ecdsa-sha2-nistp521\",\n)\n\n\ndef is_ssh_key(key: bytes) -> bool:\n    return key.startswith(_SSH_KEY_FORMATS)\n", "jwt/jwks_client.py": "import json\nimport urllib.request\nfrom functools import lru_cache\nfrom ssl import SSLContext\nfrom typing import Any, Dict, List, Optional\nfrom urllib.error import URLError\n\nfrom .api_jwk import PyJWK, PyJWKSet\nfrom .api_jwt import decode_complete as decode_token\nfrom .exceptions import PyJWKClientConnectionError, PyJWKClientError\nfrom .jwk_set_cache import JWKSetCache\n\n\nclass PyJWKClient:\n    def __init__(\n        self,\n        uri: str,\n        cache_keys: bool = False,\n        max_cached_keys: int = 16,\n        cache_jwk_set: bool = True,\n        lifespan: int = 300,\n        headers: Optional[Dict[str, Any]] = None,\n        timeout: int = 30,\n        ssl_context: Optional[SSLContext] = None,\n    ):\n        if headers is None:\n            headers = {}\n        self.uri = uri\n        self.jwk_set_cache: Optional[JWKSetCache] = None\n        self.headers = headers\n        self.timeout = timeout\n        self.ssl_context = ssl_context\n\n        if cache_jwk_set:\n            # Init jwt set cache with default or given lifespan.\n            # Default lifespan is 300 seconds (5 minutes).\n            if lifespan <= 0:\n                raise PyJWKClientError(\n                    f'Lifespan must be greater than 0, the input is \"{lifespan}\"'\n                )\n            self.jwk_set_cache = JWKSetCache(lifespan)\n        else:\n            self.jwk_set_cache = None\n\n        if cache_keys:\n            # Cache signing keys\n            # Ignore mypy (https://github.com/python/mypy/issues/2427)\n            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(self.get_signing_key)  # type: ignore\n\n    def fetch_data(self) -> Any:\n        jwk_set: Any = None\n        try:\n            r = urllib.request.Request(url=self.uri, headers=self.headers)\n            with urllib.request.urlopen(\n                r, timeout=self.timeout, context=self.ssl_context\n            ) as response:\n                jwk_set = json.load(response)\n        except (URLError, TimeoutError) as e:\n            raise PyJWKClientConnectionError(\n                f'Fail to fetch data from the url, err: \"{e}\"'\n            )\n        else:\n            return jwk_set\n        finally:\n            if self.jwk_set_cache is not None:\n                self.jwk_set_cache.put(jwk_set)\n\n    def get_jwk_set(self, refresh: bool = False) -> PyJWKSet:\n        data = None\n        if self.jwk_set_cache is not None and not refresh:\n            data = self.jwk_set_cache.get()\n\n        if data is None:\n            data = self.fetch_data()\n\n        if not isinstance(data, dict):\n            raise PyJWKClientError(\"The JWKS endpoint did not return a JSON object\")\n\n        return PyJWKSet.from_dict(data)\n\n    def get_signing_keys(self, refresh: bool = False) -> List[PyJWK]:\n        jwk_set = self.get_jwk_set(refresh)\n        signing_keys = [\n            jwk_set_key\n            for jwk_set_key in jwk_set.keys\n            if jwk_set_key.public_key_use in [\"sig\", None] and jwk_set_key.key_id\n        ]\n\n        if not signing_keys:\n            raise PyJWKClientError(\"The JWKS endpoint did not contain any signing keys\")\n\n        return signing_keys\n\n    def get_signing_key(self, kid: str) -> PyJWK:\n        signing_keys = self.get_signing_keys()\n        signing_key = self.match_kid(signing_keys, kid)\n\n        if not signing_key:\n            # If no matching signing key from the jwk set, refresh the jwk set and try again.\n            signing_keys = self.get_signing_keys(refresh=True)\n            signing_key = self.match_kid(signing_keys, kid)\n\n            if not signing_key:\n                raise PyJWKClientError(\n                    f'Unable to find a signing key that matches: \"{kid}\"'\n                )\n\n        return signing_key\n\n    def get_signing_key_from_jwt(self, token: str) -> PyJWK:\n        unverified = decode_token(token, options={\"verify_signature\": False})\n        header = unverified[\"header\"]\n        return self.get_signing_key(header.get(\"kid\"))\n\n    @staticmethod\n    def match_kid(signing_keys: List[PyJWK], kid: str) -> Optional[PyJWK]:\n        signing_key = None\n\n        for key in signing_keys:\n            if key.key_id == kid:\n                signing_key = key\n                break\n\n        return signing_key\n", "jwt/jwk_set_cache.py": "import time\nfrom typing import Optional\n\nfrom .api_jwk import PyJWKSet, PyJWTSetWithTimestamp\n\n\nclass JWKSetCache:\n    def __init__(self, lifespan: int) -> None:\n        self.jwk_set_with_timestamp: Optional[PyJWTSetWithTimestamp] = None\n        self.lifespan = lifespan\n\n    def put(self, jwk_set: PyJWKSet) -> None:\n        if jwk_set is not None:\n            self.jwk_set_with_timestamp = PyJWTSetWithTimestamp(jwk_set)\n        else:\n            # clear cache\n            self.jwk_set_with_timestamp = None\n\n    def get(self) -> Optional[PyJWKSet]:\n        if self.jwk_set_with_timestamp is None or self.is_expired():\n            return None\n\n        return self.jwk_set_with_timestamp.get_jwk_set()\n\n    def is_expired(self) -> bool:\n        return (\n            self.jwk_set_with_timestamp is not None\n            and self.lifespan > -1\n            and time.monotonic()\n            > self.jwk_set_with_timestamp.get_timestamp() + self.lifespan\n        )\n", "jwt/warnings.py": "class RemovedInPyjwt3Warning(DeprecationWarning):\n    pass\n", "jwt/types.py": "from typing import Any, Callable, Dict\n\nJWKDict = Dict[str, Any]\n\nHashlibHash = Callable[..., Any]\n", "jwt/api_jwt.py": "from __future__ import annotations\n\nimport json\nimport warnings\nfrom calendar import timegm\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta, timezone\nfrom typing import TYPE_CHECKING, Any, List\n\nfrom . import api_jws\nfrom .exceptions import (\n    DecodeError,\n    ExpiredSignatureError,\n    ImmatureSignatureError,\n    InvalidAudienceError,\n    InvalidIssuedAtError,\n    InvalidIssuerError,\n    MissingRequiredClaimError,\n)\nfrom .warnings import RemovedInPyjwt3Warning\n\nif TYPE_CHECKING:\n    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys\n    from .api_jwk import PyJWK\n\n\nclass PyJWT:\n    def __init__(self, options: dict[str, Any] | None = None) -> None:\n        if options is None:\n            options = {}\n        self.options: dict[str, Any] = {**self._get_default_options(), **options}\n\n    @staticmethod\n    def _get_default_options() -> dict[str, bool | list[str]]:\n        return {\n            \"verify_signature\": True,\n            \"verify_exp\": True,\n            \"verify_nbf\": True,\n            \"verify_iat\": True,\n            \"verify_aud\": True,\n            \"verify_iss\": True,\n            \"require\": [],\n        }\n\n    def encode(\n        self,\n        payload: dict[str, Any],\n        key: AllowedPrivateKeys | str | bytes,\n        algorithm: str | None = \"HS256\",\n        headers: dict[str, Any] | None = None,\n        json_encoder: type[json.JSONEncoder] | None = None,\n        sort_headers: bool = True,\n    ) -> str:\n        # Check that we get a dict\n        if not isinstance(payload, dict):\n            raise TypeError(\n                \"Expecting a dict object, as JWT only supports \"\n                \"JSON objects as payloads.\"\n            )\n\n        # Payload\n        payload = payload.copy()\n        for time_claim in [\"exp\", \"iat\", \"nbf\"]:\n            # Convert datetime to a intDate value in known time-format claims\n            if isinstance(payload.get(time_claim), datetime):\n                payload[time_claim] = timegm(payload[time_claim].utctimetuple())\n\n        json_payload = self._encode_payload(\n            payload,\n            headers=headers,\n            json_encoder=json_encoder,\n        )\n\n        return api_jws.encode(\n            json_payload,\n            key,\n            algorithm,\n            headers,\n            json_encoder,\n            sort_headers=sort_headers,\n        )\n\n    def _encode_payload(\n        self,\n        payload: dict[str, Any],\n        headers: dict[str, Any] | None = None,\n        json_encoder: type[json.JSONEncoder] | None = None,\n    ) -> bytes:\n        \"\"\"\n        Encode a given payload to the bytes to be signed.\n\n        This method is intended to be overridden by subclasses that need to\n        encode the payload in a different way, e.g. compress the payload.\n        \"\"\"\n        return json.dumps(\n            payload,\n            separators=(\",\", \":\"),\n            cls=json_encoder,\n        ).encode(\"utf-8\")\n\n    def decode_complete(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        # deprecated arg, remove in pyjwt3\n        verify: bool | None = None,\n        # could be used as passthrough to api_jws, consider removal in pyjwt3\n        detached_payload: bytes | None = None,\n        # passthrough arguments to _validate_claims\n        # consider putting in options\n        audience: str | Iterable[str] | None = None,\n        issuer: str | List[str] | None = None,\n        leeway: float | timedelta = 0,\n        # kwargs\n        **kwargs: Any,\n    ) -> dict[str, Any]:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode_complete() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        options = dict(options or {})  # shallow-copy or initialize an empty dict\n        options.setdefault(\"verify_signature\", True)\n\n        # If the user has set the legacy `verify` argument, and it doesn't match\n        # what the relevant `options` entry for the argument is, inform the user\n        # that they're likely making a mistake.\n        if verify is not None and verify != options[\"verify_signature\"]:\n            warnings.warn(\n                \"The `verify` argument to `decode` does nothing in PyJWT 2.0 and newer. \"\n                \"The equivalent is setting `verify_signature` to False in the `options` dictionary. \"\n                \"This invocation has a mismatch between the kwarg and the option entry.\",\n                category=DeprecationWarning,\n            )\n\n        if not options[\"verify_signature\"]:\n            options.setdefault(\"verify_exp\", False)\n            options.setdefault(\"verify_nbf\", False)\n            options.setdefault(\"verify_iat\", False)\n            options.setdefault(\"verify_aud\", False)\n            options.setdefault(\"verify_iss\", False)\n\n        if options[\"verify_signature\"] and not algorithms:\n            raise DecodeError(\n                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            )\n\n        decoded = api_jws.decode_complete(\n            jwt,\n            key=key,\n            algorithms=algorithms,\n            options=options,\n            detached_payload=detached_payload,\n        )\n\n        payload = self._decode_payload(decoded)\n\n        merged_options = {**self.options, **options}\n        self._validate_claims(\n            payload, merged_options, audience=audience, issuer=issuer, leeway=leeway\n        )\n\n        decoded[\"payload\"] = payload\n        return decoded\n\n    def _decode_payload(self, decoded: dict[str, Any]) -> Any:\n        \"\"\"\n        Decode the payload from a JWS dictionary (payload, signature, header).\n\n        This method is intended to be overridden by subclasses that need to\n        decode the payload in a different way, e.g. decompress compressed\n        payloads.\n        \"\"\"\n        try:\n            payload = json.loads(decoded[\"payload\"])\n        except ValueError as e:\n            raise DecodeError(f\"Invalid payload string: {e}\")\n        if not isinstance(payload, dict):\n            raise DecodeError(\"Invalid payload string: must be a json object\")\n        return payload\n\n    def decode(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        # deprecated arg, remove in pyjwt3\n        verify: bool | None = None,\n        # could be used as passthrough to api_jws, consider removal in pyjwt3\n        detached_payload: bytes | None = None,\n        # passthrough arguments to _validate_claims\n        # consider putting in options\n        audience: str | Iterable[str] | None = None,\n        issuer: str | List[str] | None = None,\n        leeway: float | timedelta = 0,\n        # kwargs\n        **kwargs: Any,\n    ) -> Any:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        decoded = self.decode_complete(\n            jwt,\n            key,\n            algorithms,\n            options,\n            verify=verify,\n            detached_payload=detached_payload,\n            audience=audience,\n            issuer=issuer,\n            leeway=leeway,\n        )\n        return decoded[\"payload\"]\n\n    def _validate_claims(\n        self,\n        payload: dict[str, Any],\n        options: dict[str, Any],\n        audience=None,\n        issuer=None,\n        leeway: float | timedelta = 0,\n    ) -> None:\n        if isinstance(leeway, timedelta):\n            leeway = leeway.total_seconds()\n\n        if audience is not None and not isinstance(audience, (str, Iterable)):\n            raise TypeError(\"audience must be a string, iterable or None\")\n\n        self._validate_required_claims(payload, options)\n\n        now = datetime.now(tz=timezone.utc).timestamp()\n\n        if \"iat\" in payload and options[\"verify_iat\"]:\n            self._validate_iat(payload, now, leeway)\n\n        if \"nbf\" in payload and options[\"verify_nbf\"]:\n            self._validate_nbf(payload, now, leeway)\n\n        if \"exp\" in payload and options[\"verify_exp\"]:\n            self._validate_exp(payload, now, leeway)\n\n        if options[\"verify_iss\"]:\n            self._validate_iss(payload, issuer)\n\n        if options[\"verify_aud\"]:\n            self._validate_aud(\n                payload, audience, strict=options.get(\"strict_aud\", False)\n            )\n\n    def _validate_required_claims(\n        self,\n        payload: dict[str, Any],\n        options: dict[str, Any],\n    ) -> None:\n        for claim in options[\"require\"]:\n            if payload.get(claim) is None:\n                raise MissingRequiredClaimError(claim)\n\n    def _validate_iat(\n        self,\n        payload: dict[str, Any],\n        now: float,\n        leeway: float,\n    ) -> None:\n        try:\n            iat = int(payload[\"iat\"])\n        except ValueError:\n            raise InvalidIssuedAtError(\"Issued At claim (iat) must be an integer.\")\n        if iat > (now + leeway):\n            raise ImmatureSignatureError(\"The token is not yet valid (iat)\")\n\n    def _validate_nbf(\n        self,\n        payload: dict[str, Any],\n        now: float,\n        leeway: float,\n    ) -> None:\n        try:\n            nbf = int(payload[\"nbf\"])\n        except ValueError:\n            raise DecodeError(\"Not Before claim (nbf) must be an integer.\")\n\n        if nbf > (now + leeway):\n            raise ImmatureSignatureError(\"The token is not yet valid (nbf)\")\n\n    def _validate_exp(\n        self,\n        payload: dict[str, Any],\n        now: float,\n        leeway: float,\n    ) -> None:\n        try:\n            exp = int(payload[\"exp\"])\n        except ValueError:\n            raise DecodeError(\"Expiration Time claim (exp) must be an integer.\")\n\n        if exp <= (now - leeway):\n            raise ExpiredSignatureError(\"Signature has expired\")\n\n    def _validate_aud(\n        self,\n        payload: dict[str, Any],\n        audience: str | Iterable[str] | None,\n        *,\n        strict: bool = False,\n    ) -> None:\n        if audience is None:\n            if \"aud\" not in payload or not payload[\"aud\"]:\n                return\n            # Application did not specify an audience, but\n            # the token has the 'aud' claim\n            raise InvalidAudienceError(\"Invalid audience\")\n\n        if \"aud\" not in payload or not payload[\"aud\"]:\n            # Application specified an audience, but it could not be\n            # verified since the token does not contain a claim.\n            raise MissingRequiredClaimError(\"aud\")\n\n        audience_claims = payload[\"aud\"]\n\n        # In strict mode, we forbid list matching: the supplied audience\n        # must be a string, and it must exactly match the audience claim.\n        if strict:\n            # Only a single audience is allowed in strict mode.\n            if not isinstance(audience, str):\n                raise InvalidAudienceError(\"Invalid audience (strict)\")\n\n            # Only a single audience claim is allowed in strict mode.\n            if not isinstance(audience_claims, str):\n                raise InvalidAudienceError(\"Invalid claim format in token (strict)\")\n\n            if audience != audience_claims:\n                raise InvalidAudienceError(\"Audience doesn't match (strict)\")\n\n            return\n\n        if isinstance(audience_claims, str):\n            audience_claims = [audience_claims]\n        if not isinstance(audience_claims, list):\n            raise InvalidAudienceError(\"Invalid claim format in token\")\n        if any(not isinstance(c, str) for c in audience_claims):\n            raise InvalidAudienceError(\"Invalid claim format in token\")\n\n        if isinstance(audience, str):\n            audience = [audience]\n\n        if all(aud not in audience_claims for aud in audience):\n            raise InvalidAudienceError(\"Audience doesn't match\")\n\n    def _validate_iss(self, payload: dict[str, Any], issuer: Any) -> None:\n        if issuer is None:\n            return\n\n        if \"iss\" not in payload:\n            raise MissingRequiredClaimError(\"iss\")\n\n        if isinstance(issuer, list):\n            if payload[\"iss\"] not in issuer:\n                raise InvalidIssuerError(\"Invalid issuer\")\n        else:\n            if payload[\"iss\"] != issuer:\n                raise InvalidIssuerError(\"Invalid issuer\")\n\n\n_jwt_global_obj = PyJWT()\nencode = _jwt_global_obj.encode\ndecode_complete = _jwt_global_obj.decode_complete\ndecode = _jwt_global_obj.decode\n", "jwt/api_jws.py": "from __future__ import annotations\n\nimport binascii\nimport json\nimport warnings\nfrom typing import TYPE_CHECKING, Any\n\nfrom .algorithms import (\n    Algorithm,\n    get_default_algorithms,\n    has_crypto,\n    requires_cryptography,\n)\nfrom .api_jwk import PyJWK\nfrom .exceptions import (\n    DecodeError,\n    InvalidAlgorithmError,\n    InvalidSignatureError,\n    InvalidTokenError,\n)\nfrom .utils import base64url_decode, base64url_encode\nfrom .warnings import RemovedInPyjwt3Warning\n\nif TYPE_CHECKING:\n    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys\n\n\nclass PyJWS:\n    header_typ = \"JWT\"\n\n    def __init__(\n        self,\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n    ) -> None:\n        self._algorithms = get_default_algorithms()\n        self._valid_algs = (\n            set(algorithms) if algorithms is not None else set(self._algorithms)\n        )\n\n        # Remove algorithms that aren't on the whitelist\n        for key in list(self._algorithms.keys()):\n            if key not in self._valid_algs:\n                del self._algorithms[key]\n\n        if options is None:\n            options = {}\n        self.options = {**self._get_default_options(), **options}\n\n    @staticmethod\n    def _get_default_options() -> dict[str, bool]:\n        return {\"verify_signature\": True}\n\n    def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -> None:\n        \"\"\"\n        Registers a new Algorithm for use when creating and verifying tokens.\n        \"\"\"\n        if alg_id in self._algorithms:\n            raise ValueError(\"Algorithm already has a handler.\")\n\n        if not isinstance(alg_obj, Algorithm):\n            raise TypeError(\"Object is not of type `Algorithm`\")\n\n        self._algorithms[alg_id] = alg_obj\n        self._valid_algs.add(alg_id)\n\n    def unregister_algorithm(self, alg_id: str) -> None:\n        \"\"\"\n        Unregisters an Algorithm for use when creating and verifying tokens\n        Throws KeyError if algorithm is not registered.\n        \"\"\"\n        if alg_id not in self._algorithms:\n            raise KeyError(\n                \"The specified algorithm could not be removed\"\n                \" because it is not registered.\"\n            )\n\n        del self._algorithms[alg_id]\n        self._valid_algs.remove(alg_id)\n\n    def get_algorithms(self) -> list[str]:\n        \"\"\"\n        Returns a list of supported values for the 'alg' parameter.\n        \"\"\"\n        return list(self._valid_algs)\n\n    def get_algorithm_by_name(self, alg_name: str) -> Algorithm:\n        \"\"\"\n        For a given string name, return the matching Algorithm object.\n\n        Example usage:\n\n        >>> jws_obj.get_algorithm_by_name(\"RS256\")\n        \"\"\"\n        try:\n            return self._algorithms[alg_name]\n        except KeyError as e:\n            if not has_crypto and alg_name in requires_cryptography:\n                raise NotImplementedError(\n                    f\"Algorithm '{alg_name}' could not be found. Do you have cryptography installed?\"\n                ) from e\n            raise NotImplementedError(\"Algorithm not supported\") from e\n\n    def encode(\n        self,\n        payload: bytes,\n        key: AllowedPrivateKeys | str | bytes,\n        algorithm: str | None = \"HS256\",\n        headers: dict[str, Any] | None = None,\n        json_encoder: type[json.JSONEncoder] | None = None,\n        is_payload_detached: bool = False,\n        sort_headers: bool = True,\n    ) -> str:\n        segments = []\n\n        # declare a new var to narrow the type for type checkers\n        algorithm_: str = algorithm if algorithm is not None else \"none\"\n\n        # Prefer headers values if present to function parameters.\n        if headers:\n            headers_alg = headers.get(\"alg\")\n            if headers_alg:\n                algorithm_ = headers[\"alg\"]\n\n            headers_b64 = headers.get(\"b64\")\n            if headers_b64 is False:\n                is_payload_detached = True\n\n        # Header\n        header: dict[str, Any] = {\"typ\": self.header_typ, \"alg\": algorithm_}\n\n        if headers:\n            self._validate_headers(headers)\n            header.update(headers)\n\n        if not header[\"typ\"]:\n            del header[\"typ\"]\n\n        if is_payload_detached:\n            header[\"b64\"] = False\n        elif \"b64\" in header:\n            # True is the standard value for b64, so no need for it\n            del header[\"b64\"]\n\n        json_header = json.dumps(\n            header, separators=(\",\", \":\"), cls=json_encoder, sort_keys=sort_headers\n        ).encode()\n\n        segments.append(base64url_encode(json_header))\n\n        if is_payload_detached:\n            msg_payload = payload\n        else:\n            msg_payload = base64url_encode(payload)\n        segments.append(msg_payload)\n\n        # Segments\n        signing_input = b\".\".join(segments)\n\n        alg_obj = self.get_algorithm_by_name(algorithm_)\n        key = alg_obj.prepare_key(key)\n        signature = alg_obj.sign(signing_input, key)\n\n        segments.append(base64url_encode(signature))\n\n        # Don't put the payload content inside the encoded token when detached\n        if is_payload_detached:\n            segments[1] = b\"\"\n        encoded_string = b\".\".join(segments)\n\n        return encoded_string.decode(\"utf-8\")\n\n    def decode_complete(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        detached_payload: bytes | None = None,\n        **kwargs,\n    ) -> dict[str, Any]:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode_complete() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        if options is None:\n            options = {}\n        merged_options = {**self.options, **options}\n        verify_signature = merged_options[\"verify_signature\"]\n\n        if verify_signature and not algorithms and not isinstance(key, PyJWK):\n            raise DecodeError(\n                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            )\n\n        payload, signing_input, header, signature = self._load(jwt)\n\n        if header.get(\"b64\", True) is False:\n            if detached_payload is None:\n                raise DecodeError(\n                    'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'\n                )\n            payload = detached_payload\n            signing_input = b\".\".join([signing_input.rsplit(b\".\", 1)[0], payload])\n\n        if verify_signature:\n            self._verify_signature(signing_input, header, signature, key, algorithms)\n\n        return {\n            \"payload\": payload,\n            \"header\": header,\n            \"signature\": signature,\n        }\n\n    def decode(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        detached_payload: bytes | None = None,\n        **kwargs,\n    ) -> Any:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        decoded = self.decode_complete(\n            jwt, key, algorithms, options, detached_payload=detached_payload\n        )\n        return decoded[\"payload\"]\n\n    def get_unverified_header(self, jwt: str | bytes) -> dict[str, Any]:\n        \"\"\"Returns back the JWT header parameters as a dict()\n\n        Note: The signature is not verified so the header parameters\n        should not be fully trusted until signature verification is complete\n        \"\"\"\n        headers = self._load(jwt)[2]\n        self._validate_headers(headers)\n\n        return headers\n\n    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:\n        if isinstance(jwt, str):\n            jwt = jwt.encode(\"utf-8\")\n\n        if not isinstance(jwt, bytes):\n            raise DecodeError(f\"Invalid token type. Token must be a {bytes}\")\n\n        try:\n            signing_input, crypto_segment = jwt.rsplit(b\".\", 1)\n            header_segment, payload_segment = signing_input.split(b\".\", 1)\n        except ValueError as err:\n            raise DecodeError(\"Not enough segments\") from err\n\n        try:\n            header_data = base64url_decode(header_segment)\n        except (TypeError, binascii.Error) as err:\n            raise DecodeError(\"Invalid header padding\") from err\n\n        try:\n            header = json.loads(header_data)\n        except ValueError as e:\n            raise DecodeError(f\"Invalid header string: {e}\") from e\n\n        if not isinstance(header, dict):\n            raise DecodeError(\"Invalid header string: must be a json object\")\n\n        try:\n            payload = base64url_decode(payload_segment)\n        except (TypeError, binascii.Error) as err:\n            raise DecodeError(\"Invalid payload padding\") from err\n\n        try:\n            signature = base64url_decode(crypto_segment)\n        except (TypeError, binascii.Error) as err:\n            raise DecodeError(\"Invalid crypto padding\") from err\n\n        return (payload, signing_input, header, signature)\n\n    def _verify_signature(\n        self,\n        signing_input: bytes,\n        header: dict[str, Any],\n        signature: bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n    ) -> None:\n        if algorithms is None and isinstance(key, PyJWK):\n            algorithms = [key.algorithm_name]\n        try:\n            alg = header[\"alg\"]\n        except KeyError:\n            raise InvalidAlgorithmError(\"Algorithm not specified\")\n\n        if not alg or (algorithms is not None and alg not in algorithms):\n            raise InvalidAlgorithmError(\"The specified alg value is not allowed\")\n\n        if isinstance(key, PyJWK):\n            alg_obj = key.Algorithm\n            prepared_key = key.key\n        else:\n            try:\n                alg_obj = self.get_algorithm_by_name(alg)\n            except NotImplementedError as e:\n                raise InvalidAlgorithmError(\"Algorithm not supported\") from e\n            prepared_key = alg_obj.prepare_key(key)\n\n        if not alg_obj.verify(signing_input, prepared_key, signature):\n            raise InvalidSignatureError(\"Signature verification failed\")\n\n    def _validate_headers(self, headers: dict[str, Any]) -> None:\n        if \"kid\" in headers:\n            self._validate_kid(headers[\"kid\"])\n\n    def _validate_kid(self, kid: Any) -> None:\n        if not isinstance(kid, str):\n            raise InvalidTokenError(\"Key ID header parameter must be a string\")\n\n\n_jws_global_obj = PyJWS()\nencode = _jws_global_obj.encode\ndecode_complete = _jws_global_obj.decode_complete\ndecode = _jws_global_obj.decode\nregister_algorithm = _jws_global_obj.register_algorithm\nunregister_algorithm = _jws_global_obj.unregister_algorithm\nget_algorithm_by_name = _jws_global_obj.get_algorithm_by_name\nget_unverified_header = _jws_global_obj.get_unverified_header\n", "jwt/help.py": "import json\nimport platform\nimport sys\nfrom typing import Dict\n\nfrom . import __version__ as pyjwt_version\n\ntry:\n    import cryptography\n\n    cryptography_version = cryptography.__version__\nexcept ModuleNotFoundError:\n    cryptography_version = \"\"\n\n\ndef info() -> Dict[str, Dict[str, str]]:\n    \"\"\"\n    Generate information for a bug report.\n    Based on the requests package help utility module.\n    \"\"\"\n    try:\n        platform_info = {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n        }\n    except OSError:\n        platform_info = {\"system\": \"Unknown\", \"release\": \"Unknown\"}\n\n    implementation = platform.python_implementation()\n\n    if implementation == \"CPython\":\n        implementation_version = platform.python_version()\n    elif implementation == \"PyPy\":\n        pypy_version_info = sys.pypy_version_info  # type: ignore[attr-defined]\n        implementation_version = (\n            f\"{pypy_version_info.major}.\"\n            f\"{pypy_version_info.minor}.\"\n            f\"{pypy_version_info.micro}\"\n        )\n        if pypy_version_info.releaselevel != \"final\":\n            implementation_version = \"\".join(\n                [implementation_version, pypy_version_info.releaselevel]\n            )\n    else:\n        implementation_version = \"Unknown\"\n\n    return {\n        \"platform\": platform_info,\n        \"implementation\": {\n            \"name\": implementation,\n            \"version\": implementation_version,\n        },\n        \"cryptography\": {\"version\": cryptography_version},\n        \"pyjwt\": {\"version\": pyjwt_version},\n    }\n\n\ndef main() -> None:\n    \"\"\"Pretty-print the bug information as JSON.\"\"\"\n    print(json.dumps(info(), sort_keys=True, indent=2))\n\n\nif __name__ == \"__main__\":\n    main()\n", "jwt/__init__.py": "from .api_jwk import PyJWK, PyJWKSet\nfrom .api_jws import (\n    PyJWS,\n    get_algorithm_by_name,\n    get_unverified_header,\n    register_algorithm,\n    unregister_algorithm,\n)\nfrom .api_jwt import PyJWT, decode, encode\nfrom .exceptions import (\n    DecodeError,\n    ExpiredSignatureError,\n    ImmatureSignatureError,\n    InvalidAlgorithmError,\n    InvalidAudienceError,\n    InvalidIssuedAtError,\n    InvalidIssuerError,\n    InvalidKeyError,\n    InvalidSignatureError,\n    InvalidTokenError,\n    MissingRequiredClaimError,\n    PyJWKClientConnectionError,\n    PyJWKClientError,\n    PyJWKError,\n    PyJWKSetError,\n    PyJWTError,\n)\nfrom .jwks_client import PyJWKClient\n\n__version__ = \"2.8.0\"\n\n__title__ = \"PyJWT\"\n__description__ = \"JSON Web Token implementation in Python\"\n__url__ = \"https://pyjwt.readthedocs.io\"\n__uri__ = __url__\n__doc__ = f\"{__description__} <{__uri__}>\"\n\n__author__ = \"Jos\u00e9 Padilla\"\n__email__ = \"hello@jpadilla.com\"\n\n__license__ = \"MIT\"\n__copyright__ = \"Copyright 2015-2022 Jos\u00e9 Padilla\"\n\n\n__all__ = [\n    \"PyJWS\",\n    \"PyJWT\",\n    \"PyJWKClient\",\n    \"PyJWK\",\n    \"PyJWKSet\",\n    \"decode\",\n    \"encode\",\n    \"get_unverified_header\",\n    \"register_algorithm\",\n    \"unregister_algorithm\",\n    \"get_algorithm_by_name\",\n    # Exceptions\n    \"DecodeError\",\n    \"ExpiredSignatureError\",\n    \"ImmatureSignatureError\",\n    \"InvalidAlgorithmError\",\n    \"InvalidAudienceError\",\n    \"InvalidIssuedAtError\",\n    \"InvalidIssuerError\",\n    \"InvalidKeyError\",\n    \"InvalidSignatureError\",\n    \"InvalidTokenError\",\n    \"MissingRequiredClaimError\",\n    \"PyJWKClientConnectionError\",\n    \"PyJWKClientError\",\n    \"PyJWKError\",\n    \"PyJWKSetError\",\n    \"PyJWTError\",\n]\n", "jwt/api_jwk.py": "from __future__ import annotations\n\nimport json\nimport time\nfrom typing import Any\n\nfrom .algorithms import get_default_algorithms, has_crypto, requires_cryptography\nfrom .exceptions import InvalidKeyError, PyJWKError, PyJWKSetError, PyJWTError\nfrom .types import JWKDict\n\n\nclass PyJWK:\n    def __init__(self, jwk_data: JWKDict, algorithm: str | None = None) -> None:\n        self._algorithms = get_default_algorithms()\n        self._jwk_data = jwk_data\n\n        kty = self._jwk_data.get(\"kty\", None)\n        if not kty:\n            raise InvalidKeyError(f\"kty is not found: {self._jwk_data}\")\n\n        if not algorithm and isinstance(self._jwk_data, dict):\n            algorithm = self._jwk_data.get(\"alg\", None)\n\n        if not algorithm:\n            # Determine alg with kty (and crv).\n            crv = self._jwk_data.get(\"crv\", None)\n            if kty == \"EC\":\n                if crv == \"P-256\" or not crv:\n                    algorithm = \"ES256\"\n                elif crv == \"P-384\":\n                    algorithm = \"ES384\"\n                elif crv == \"P-521\":\n                    algorithm = \"ES512\"\n                elif crv == \"secp256k1\":\n                    algorithm = \"ES256K\"\n                else:\n                    raise InvalidKeyError(f\"Unsupported crv: {crv}\")\n            elif kty == \"RSA\":\n                algorithm = \"RS256\"\n            elif kty == \"oct\":\n                algorithm = \"HS256\"\n            elif kty == \"OKP\":\n                if not crv:\n                    raise InvalidKeyError(f\"crv is not found: {self._jwk_data}\")\n                if crv == \"Ed25519\":\n                    algorithm = \"EdDSA\"\n                else:\n                    raise InvalidKeyError(f\"Unsupported crv: {crv}\")\n            else:\n                raise InvalidKeyError(f\"Unsupported kty: {kty}\")\n\n        if not has_crypto and algorithm in requires_cryptography:\n            raise PyJWKError(f\"{algorithm} requires 'cryptography' to be installed.\")\n\n        self.algorithm_name = algorithm\n\n        if algorithm in self._algorithms:\n            self.Algorithm = self._algorithms[algorithm]\n        else:\n            raise PyJWKError(f\"Unable to find an algorithm for key: {self._jwk_data}\")\n\n        self.key = self.Algorithm.from_jwk(self._jwk_data)\n\n    @staticmethod\n    def from_dict(obj: JWKDict, algorithm: str | None = None) -> PyJWK:\n        return PyJWK(obj, algorithm)\n\n    @staticmethod\n    def from_json(data: str, algorithm: None = None) -> PyJWK:\n        obj = json.loads(data)\n        return PyJWK.from_dict(obj, algorithm)\n\n    @property\n    def key_type(self) -> str | None:\n        return self._jwk_data.get(\"kty\", None)\n\n    @property\n    def key_id(self) -> str | None:\n        return self._jwk_data.get(\"kid\", None)\n\n    @property\n    def public_key_use(self) -> str | None:\n        return self._jwk_data.get(\"use\", None)\n\n\nclass PyJWKSet:\n    def __init__(self, keys: list[JWKDict]) -> None:\n        self.keys = []\n\n        if not keys:\n            raise PyJWKSetError(\"The JWK Set did not contain any keys\")\n\n        if not isinstance(keys, list):\n            raise PyJWKSetError(\"Invalid JWK Set value\")\n\n        for key in keys:\n            try:\n                self.keys.append(PyJWK(key))\n            except PyJWTError:\n                # skip unusable keys\n                continue\n\n        if len(self.keys) == 0:\n            raise PyJWKSetError(\n                \"The JWK Set did not contain any usable keys. Perhaps 'cryptography' is not installed?\"\n            )\n\n    @staticmethod\n    def from_dict(obj: dict[str, Any]) -> PyJWKSet:\n        keys = obj.get(\"keys\", [])\n        return PyJWKSet(keys)\n\n    @staticmethod\n    def from_json(data: str) -> PyJWKSet:\n        obj = json.loads(data)\n        return PyJWKSet.from_dict(obj)\n\n    def __getitem__(self, kid: str) -> PyJWK:\n        for key in self.keys:\n            if key.key_id == kid:\n                return key\n        raise KeyError(f\"keyset has no key for kid: {kid}\")\n\n\nclass PyJWTSetWithTimestamp:\n    def __init__(self, jwk_set: PyJWKSet):\n        self.jwk_set = jwk_set\n        self.timestamp = time.monotonic()\n\n    def get_jwk_set(self) -> PyJWKSet:\n        return self.jwk_set\n\n    def get_timestamp(self) -> float:\n        return self.timestamp\n", "docs/conf.py": "import os\nimport re\n\nimport sphinx_rtd_theme\n\n\ndef read(*parts) -> str:\n    \"\"\"\n    Build an absolute path from *parts* and and return the contents of the\n    resulting file.  Assume UTF-8 encoding.\n    \"\"\"\n    here = os.path.abspath(os.path.dirname(__file__))\n    with open(os.path.join(here, *parts), encoding=\"utf-8\") as f:\n        return f.read()\n\n\ndef find_version(*file_paths) -> str:\n    \"\"\"\n    Build a path from *file_paths* and search for a ``__version__``\n    string inside.\n    \"\"\"\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\n\n# -- General configuration ------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.todo\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = \".rst\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"PyJWT\"\ncopyright = \"2015-2022, Jos\u00e9 Padilla\"\nauthor = \"Jos\u00e9 Padilla\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The full version, including alpha/beta/rc tags.\nrelease = find_version(\"../jwt/__init__.py\")\n\n# The short X.Y version.\nversion = release.rsplit(\".\", 1)[0]\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\n# language = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n# Intersphinx extension.\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3/\", None),\n}\n\n# -- Options for HTML output ----------------------------------------------\n\n\nhtml_theme = \"sphinx_rtd_theme\"\n\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\nhtml_context = {\n    \"extra_css_files\": [\n        # override wide tables in RTD theme\n        \"_static/theme_overrides.css\"\n    ]\n}\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"PyJWTdoc\"\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, \"pyjwt\", \"PyJWT Documentation\", [author], 1)]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        \"PyJWT\",\n        \"PyJWT Documentation\",\n        author,\n        \"PyJWT\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    )\n]\n", "tests/test_jwks_client.py": "import contextlib\nimport json\nimport ssl\nimport time\nfrom unittest import mock\nfrom urllib.error import URLError\n\nimport pytest\n\nimport jwt\nfrom jwt import PyJWKClient\nfrom jwt.api_jwk import PyJWK\nfrom jwt.exceptions import PyJWKClientConnectionError, PyJWKClientError\n\nfrom .utils import crypto_required\n\nRESPONSE_DATA_WITH_MATCHING_KID = {\n    \"keys\": [\n        {\n            \"alg\": \"RS256\",\n            \"kty\": \"RSA\",\n            \"use\": \"sig\",\n            \"n\": \"0wtlJRY9-ru61LmOgieeI7_rD1oIna9QpBMAOWw8wTuoIhFQFwcIi7MFB7IEfelCPj08vkfLsuFtR8cG07EE4uvJ78bAqRjMsCvprWp4e2p7hqPnWcpRpDEyHjzirEJle1LPpjLLVaSWgkbrVaOD0lkWkP1T1TkrOset_Obh8BwtO-Ww-UfrEwxTyz1646AGkbT2nL8PX0trXrmira8GnrCkFUgTUS61GoTdb9bCJ19PLX9Gnxw7J0BtR0GubopXq8KlI0ThVql6ZtVGN2dvmrCPAVAZleM5TVB61m0VSXvGWaF6_GeOhbFoyWcyUmFvzWhBm8Q38vWgsSI7oHTkEw\",\n            \"e\": \"AQAB\",\n            \"kid\": \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\",\n            \"x5t\": \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\",\n            \"x5c\": [\n                \"MIIDBzCCAe+gAwIBAgIJNtD9Ozi6j2jJMA0GCSqGSIb3DQEBCwUAMCExHzAdBgNVBAMTFmRldi04N2V2eDlydS5hdXRoMC5jb20wHhcNMTkwNjIwMTU0NDU4WhcNMzMwMjI2MTU0NDU4WjAhMR8wHQYDVQQDExZkZXYtODdldng5cnUuYXV0aDAuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0wtlJRY9+ru61LmOgieeI7/rD1oIna9QpBMAOWw8wTuoIhFQFwcIi7MFB7IEfelCPj08vkfLsuFtR8cG07EE4uvJ78bAqRjMsCvprWp4e2p7hqPnWcpRpDEyHjzirEJle1LPpjLLVaSWgkbrVaOD0lkWkP1T1TkrOset/Obh8BwtO+Ww+UfrEwxTyz1646AGkbT2nL8PX0trXrmira8GnrCkFUgTUS61GoTdb9bCJ19PLX9Gnxw7J0BtR0GubopXq8KlI0ThVql6ZtVGN2dvmrCPAVAZleM5TVB61m0VSXvGWaF6/GeOhbFoyWcyUmFvzWhBm8Q38vWgsSI7oHTkEwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQlGXpmYaXFB7Q3eG69Uhjd4cFp/jAOBgNVHQ8BAf8EBAMCAoQwDQYJKoZIhvcNAQELBQADggEBAIzQOF/h4T5WWAdjhcIwdNS7hS2Deq+UxxkRv+uavj6O9mHLuRG1q5onvSFShjECXaYT6OGibn7Ufw/JSm3+86ZouMYjBEqGh4OvWRkwARy1YTWUVDGpT2HAwtIq3lfYvhe8P4VfZByp1N4lfn6X2NcJflG+Q+mfXNmRFyyft3Oq51PCZyyAkU7bTun9FmMOyBtmJvQjZ8RXgBLvu9nUcZB8yTVoeUEg4cLczQlli/OkiFXhWgrhVr8uF0/9klslMFXtm78iYSgR8/oC+k1pSNd1+ESSt7n6+JiAQ2Co+ZNKta7LTDGAjGjNDymyoCrZpeuYQwwnHYEHu/0khjAxhXo=\"\n            ],\n        }\n    ]\n}\n\nRESPONSE_DATA_NO_MATCHING_KID = {\n    \"keys\": [\n        {\n            \"alg\": \"RS256\",\n            \"kty\": \"RSA\",\n            \"use\": \"sig\",\n            \"n\": \"39SJ39VgrQ0qMNK74CaueUBlyYsUyuA7yWlHYZ-jAj6tlFKugEVUTBUVbhGF44uOr99iL_cwmr-srqQDEi-jFHdkS6WFkYyZ03oyyx5dtBMtzrXPieFipSGfQ5EGUGloaKDjL-Ry9tiLnysH2VVWZ5WDDN-DGHxuCOWWjiBNcTmGfnj5_NvRHNUh2iTLuiJpHbGcPzWc5-lc4r-_ehw9EFfp2XsxE9xvtbMZ4SouJCiv9xnrnhe2bdpWuu34hXZCrQwE8DjRY3UR8LjyMxHHPLzX2LWNMHjfN3nAZMteS-Ok11VYDFI-4qCCVGo_WesBCAeqCjPLRyZoV27x1YGsUQ\",\n            \"e\": \"AQAB\",\n            \"kid\": \"MLYHNMMhwCNXw9roHIILFsK4nLs=\",\n        }\n    ]\n}\n\n\n@contextlib.contextmanager\ndef mocked_success_response(data):\n    with mock.patch(\"urllib.request.urlopen\") as urlopen_mock:\n        response = mock.Mock()\n        response.__enter__ = mock.Mock(return_value=response)\n        response.__exit__ = mock.Mock()\n        response.read.side_effect = [json.dumps(data)]\n        urlopen_mock.return_value = response\n        yield urlopen_mock\n\n\n@contextlib.contextmanager\ndef mocked_failed_response():\n    with mock.patch(\"urllib.request.urlopen\") as urlopen_mock:\n        urlopen_mock.side_effect = URLError(\"Fail to process the request.\")\n        yield urlopen_mock\n\n\n@contextlib.contextmanager\ndef mocked_first_call_wrong_kid_second_call_correct_kid(\n    response_data_one, response_data_two\n):\n    with mock.patch(\"urllib.request.urlopen\") as urlopen_mock:\n        response = mock.Mock()\n        response.__enter__ = mock.Mock(return_value=response)\n        response.__exit__ = mock.Mock()\n        response.read.side_effect = [\n            json.dumps(response_data_one),\n            json.dumps(response_data_two),\n        ]\n        urlopen_mock.return_value = response\n        yield urlopen_mock\n\n\n@contextlib.contextmanager\ndef mocked_timeout():\n    with mock.patch(\"urllib.request.urlopen\") as urlopen_mock:\n        urlopen_mock.side_effect = TimeoutError(\"timed out\")\n        yield urlopen_mock\n\n\n@crypto_required\nclass TestPyJWKClient:\n    def test_fetch_data_forwards_headers_to_correct_url(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID) as mock_request:\n            custom_headers = {\"User-agent\": \"my-custom-agent\"}\n            jwks_client = PyJWKClient(url, headers=custom_headers)\n            jwk_set = jwks_client.get_jwk_set()\n            request_params = mock_request.call_args[0][0]\n            assert request_params.full_url == url\n            assert request_params.headers == custom_headers\n\n        assert len(jwk_set.keys) == 1\n\n    def test_get_jwk_set(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client = PyJWKClient(url)\n            jwk_set = jwks_client.get_jwk_set()\n\n        assert len(jwk_set.keys) == 1\n\n    def test_get_signing_keys(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client = PyJWKClient(url)\n            signing_keys = jwks_client.get_signing_keys()\n\n        assert len(signing_keys) == 1\n        assert isinstance(signing_keys[0], PyJWK)\n\n    def test_get_signing_keys_if_no_use_provided(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        mocked_key = RESPONSE_DATA_WITH_MATCHING_KID[\"keys\"][0].copy()\n        del mocked_key[\"use\"]\n        response = {\"keys\": [mocked_key]}\n\n        with mocked_success_response(response):\n            jwks_client = PyJWKClient(url)\n            signing_keys = jwks_client.get_signing_keys()\n\n        assert len(signing_keys) == 1\n        assert isinstance(signing_keys[0], PyJWK)\n\n    def test_get_signing_keys_raises_if_none_found(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        mocked_key = RESPONSE_DATA_WITH_MATCHING_KID[\"keys\"][0].copy()\n        mocked_key[\"use\"] = \"enc\"\n        response = {\"keys\": [mocked_key]}\n        with mocked_success_response(response):\n            jwks_client = PyJWKClient(url)\n\n            with pytest.raises(PyJWKClientError) as exc:\n                jwks_client.get_signing_keys()\n\n        assert \"The JWKS endpoint did not contain any signing keys\" in str(exc.value)\n\n    def test_get_signing_key(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        kid = \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\"\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client = PyJWKClient(url)\n            signing_key = jwks_client.get_signing_key(kid)\n\n        assert isinstance(signing_key, PyJWK)\n        assert signing_key.key_type == \"RSA\"\n        assert signing_key.key_id == kid\n        assert signing_key.public_key_use == \"sig\"\n\n    def test_get_signing_key_caches_result(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        kid = \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\"\n\n        jwks_client = PyJWKClient(url, cache_keys=True)\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client.get_signing_key(kid)\n\n        # mocked_response does not allow urllib.request.urlopen to be called twice\n        # so a second mock is needed\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID) as repeated_call:\n            jwks_client.get_signing_key(kid)\n\n        assert repeated_call.call_count == 0\n\n    def test_get_signing_key_does_not_cache_opt_out(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        kid = \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\"\n\n        jwks_client = PyJWKClient(url, cache_jwk_set=False)\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client.get_signing_key(kid)\n\n        # mocked_response does not allow urllib.request.urlopen to be called twice\n        # so a second mock is needed\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID) as repeated_call:\n            jwks_client.get_signing_key(kid)\n\n        assert repeated_call.call_count == 1\n\n    def test_get_signing_key_from_jwt(self):\n        token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRdyJ9.eyJpc3MiOiJodHRwczovL2Rldi04N2V2eDlydS5hdXRoMC5jb20vIiwic3ViIjoiYVc0Q2NhNzl4UmVMV1V6MGFFMkg2a0QwTzNjWEJWdENAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vZXhwZW5zZXMtYXBpIiwiaWF0IjoxNTcyMDA2OTU0LCJleHAiOjE1NzIwMDY5NjQsImF6cCI6ImFXNENjYTc5eFJlTFdVejBhRTJINmtEME8zY1hCVnRDIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.PUxE7xn52aTCohGiWoSdMBZGiYAHwE5FYie0Y1qUT68IHSTXwXVd6hn02HTah6epvHHVKA2FqcFZ4GGv5VTHEvYpeggiiZMgbxFrmTEY0csL6VNkX1eaJGcuehwQCRBKRLL3zKmA5IKGy5GeUnIbpPHLHDxr-GXvgFzsdsyWlVQvPX2xjeaQ217r2PtxDeqjlf66UYl6oY6AqNS8DH3iryCvIfCcybRZkc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA\"\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client = PyJWKClient(url)\n            signing_key = jwks_client.get_signing_key_from_jwt(token)\n\n        data = jwt.decode(\n            token,\n            signing_key.key,\n            algorithms=[\"RS256\"],\n            audience=\"https://expenses-api\",\n            options={\"verify_exp\": False},\n        )\n\n        assert data == {\n            \"iss\": \"https://dev-87evx9ru.auth0.com/\",\n            \"sub\": \"aW4Cca79xReLWUz0aE2H6kD0O3cXBVtC@clients\",\n            \"aud\": \"https://expenses-api\",\n            \"iat\": 1572006954,\n            \"exp\": 1572006964,\n            \"azp\": \"aW4Cca79xReLWUz0aE2H6kD0O3cXBVtC\",\n            \"gty\": \"client-credentials\",\n        }\n\n    def test_get_jwk_set_caches_result(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        jwks_client = PyJWKClient(url)\n        assert jwks_client.jwk_set_cache is not None\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client.get_jwk_set()\n\n        # mocked_response does not allow urllib.request.urlopen to be called twice\n        # so a second mock is needed\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID) as repeated_call:\n            jwks_client.get_jwk_set()\n\n        assert repeated_call.call_count == 0\n\n    def test_get_jwt_set_cache_expired_result(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        jwks_client = PyJWKClient(url, lifespan=1)\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client.get_jwk_set()\n\n        time.sleep(2)\n\n        # mocked_response does not allow urllib.request.urlopen to be called twice\n        # so a second mock is needed\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID) as repeated_call:\n            jwks_client.get_jwk_set()\n\n        assert repeated_call.call_count == 1\n\n    def test_get_jwt_set_cache_disabled(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        jwks_client = PyJWKClient(url, cache_jwk_set=False)\n        assert jwks_client.jwk_set_cache is None\n\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client.get_jwk_set()\n\n        assert jwks_client.jwk_set_cache is None\n\n        time.sleep(2)\n\n        # mocked_response does not allow urllib.request.urlopen to be called twice\n        # so a second mock is needed\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID) as repeated_call:\n            jwks_client.get_jwk_set()\n\n        assert repeated_call.call_count == 1\n\n    def test_get_jwt_set_failed_request_should_clear_cache(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        jwks_client = PyJWKClient(url)\n        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):\n            jwks_client.get_jwk_set()\n\n        with pytest.raises(PyJWKClientError):\n            with mocked_failed_response():\n                jwks_client.get_jwk_set(refresh=True)\n\n            assert jwks_client.jwk_set_cache is None\n\n    def test_failed_request_should_raise_connection_error(self):\n        token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRdyJ9.eyJpc3MiOiJodHRwczovL2Rldi04N2V2eDlydS5hdXRoMC5jb20vIiwic3ViIjoiYVc0Q2NhNzl4UmVMV1V6MGFFMkg2a0QwTzNjWEJWdENAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vZXhwZW5zZXMtYXBpIiwiaWF0IjoxNTcyMDA2OTU0LCJleHAiOjE1NzIwMDY5NjQsImF6cCI6ImFXNENjYTc5eFJlTFdVejBhRTJINmtEME8zY1hCVnRDIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.PUxE7xn52aTCohGiWoSdMBZGiYAHwE5FYie0Y1qUT68IHSTXwXVd6hn02HTah6epvHHVKA2FqcFZ4GGv5VTHEvYpeggiiZMgbxFrmTEY0csL6VNkX1eaJGcuehwQCRBKRLL3zKmA5IKGy5GeUnIbpPHLHDxr-GXvgFzsdsyWlVQvPX2xjeaQ217r2PtxDeqjlf66UYl6oY6AqNS8DH3iryCvIfCcybRZkc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA\"\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        jwks_client = PyJWKClient(url)\n        with pytest.raises(PyJWKClientConnectionError):\n            with mocked_failed_response():\n                jwks_client.get_signing_key_from_jwt(token)\n\n    def test_get_jwt_set_refresh_cache(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        jwks_client = PyJWKClient(url)\n\n        kid = \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\"\n\n        # The first call will return response with no matching kid,\n        # the function should make another call to try to refresh the cache.\n        with mocked_first_call_wrong_kid_second_call_correct_kid(\n            RESPONSE_DATA_NO_MATCHING_KID, RESPONSE_DATA_WITH_MATCHING_KID\n        ) as call_data:\n            jwks_client.get_signing_key(kid)\n\n        assert call_data.call_count == 2\n\n    def test_get_jwt_set_no_matching_kid_after_second_attempt(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        jwks_client = PyJWKClient(url)\n\n        kid = \"NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw\"\n\n        with pytest.raises(PyJWKClientError):\n            with mocked_first_call_wrong_kid_second_call_correct_kid(\n                RESPONSE_DATA_NO_MATCHING_KID, RESPONSE_DATA_NO_MATCHING_KID\n            ):\n                jwks_client.get_signing_key(kid)\n\n    def test_get_jwt_set_invalid_lifespan(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n\n        with pytest.raises(PyJWKClientError):\n            jwks_client = PyJWKClient(url, lifespan=-1)\n            assert jwks_client is None\n\n    def test_get_jwt_set_timeout(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        jwks_client = PyJWKClient(url, timeout=5)\n\n        with pytest.raises(PyJWKClientError) as exc:\n            with mocked_timeout():\n                jwks_client.get_jwk_set()\n\n        assert 'Fail to fetch data from the url, err: \"timed out\"' in str(exc.value)\n\n    def test_get_jwt_set_sslcontext_default(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        jwks_client = PyJWKClient(url, ssl_context=ssl.create_default_context())\n\n        jwk_set = jwks_client.get_jwk_set()\n\n        assert jwk_set is not None\n\n    def test_get_jwt_set_sslcontext_no_ca(self):\n        url = \"https://dev-87evx9ru.auth0.com/.well-known/jwks.json\"\n        jwks_client = PyJWKClient(\n            url, ssl_context=ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_CLIENT)\n        )\n\n        with pytest.raises(PyJWKClientError):\n            jwks_client.get_jwk_set()\n\n        assert \"Failed to get an expected error\"\n", "tests/utils.py": "import os\nfrom calendar import timegm\nfrom datetime import datetime, timezone\n\nimport pytest\n\nfrom jwt.algorithms import has_crypto\n\n\ndef utc_timestamp():\n    return timegm(datetime.now(tz=timezone.utc).utctimetuple())\n\n\ndef key_path(key_name):\n    return os.path.join(os.path.dirname(os.path.realpath(__file__)), \"keys\", key_name)\n\n\ndef no_crypto_required(class_or_func):\n    decorator = pytest.mark.skipif(\n        has_crypto,\n        reason=\"Requires cryptography library not installed\",\n    )\n    return decorator(class_or_func)\n\n\ndef crypto_required(class_or_func):\n    decorator = pytest.mark.skipif(\n        not has_crypto, reason=\"Requires cryptography library installed\"\n    )\n    return decorator(class_or_func)\n", "tests/test_api_jws.py": "import json\nfrom decimal import Decimal\n\nimport pytest\n\nfrom jwt.algorithms import NoneAlgorithm, has_crypto\nfrom jwt.api_jwk import PyJWK\nfrom jwt.api_jws import PyJWS\nfrom jwt.exceptions import (\n    DecodeError,\n    InvalidAlgorithmError,\n    InvalidSignatureError,\n    InvalidTokenError,\n)\nfrom jwt.utils import base64url_decode\nfrom jwt.warnings import RemovedInPyjwt3Warning\n\nfrom .utils import crypto_required, key_path, no_crypto_required\n\ntry:\n    from cryptography.hazmat.primitives.serialization import (\n        load_pem_private_key,\n        load_pem_public_key,\n        load_ssh_public_key,\n    )\nexcept ModuleNotFoundError:\n    pass\n\n\n@pytest.fixture\ndef jws():\n    return PyJWS()\n\n\n@pytest.fixture\ndef payload():\n    \"\"\"Creates a sample jws claimset for use as a payload during tests\"\"\"\n    return b\"hello world\"\n\n\nclass TestJWS:\n    def test_register_algo_does_not_allow_duplicate_registration(self, jws):\n        jws.register_algorithm(\"AAA\", NoneAlgorithm())\n\n        with pytest.raises(ValueError):\n            jws.register_algorithm(\"AAA\", NoneAlgorithm())\n\n    def test_register_algo_rejects_non_algorithm_obj(self, jws):\n        with pytest.raises(TypeError):\n            jws.register_algorithm(\"AAA123\", {})\n\n    def test_unregister_algo_removes_algorithm(self, jws):\n        supported = jws.get_algorithms()\n        assert \"none\" in supported\n        assert \"HS256\" in supported\n\n        jws.unregister_algorithm(\"HS256\")\n\n        supported = jws.get_algorithms()\n        assert \"HS256\" not in supported\n\n    def test_unregister_algo_throws_error_if_not_registered(self, jws):\n        with pytest.raises(KeyError):\n            jws.unregister_algorithm(\"AAA\")\n\n    def test_algo_parameter_removes_alg_from_algorithms_list(self, jws):\n        assert \"none\" in jws.get_algorithms()\n        assert \"HS256\" in jws.get_algorithms()\n\n        jws = PyJWS(algorithms=[\"HS256\"])\n        assert \"none\" not in jws.get_algorithms()\n        assert \"HS256\" in jws.get_algorithms()\n\n    def test_override_options(self):\n        jws = PyJWS(options={\"verify_signature\": False})\n\n        assert not jws.options[\"verify_signature\"]\n\n    def test_non_object_options_dont_persist(self, jws, payload):\n        token = jws.encode(payload, \"secret\")\n\n        jws.decode(token, \"secret\", options={\"verify_signature\": False})\n\n        assert jws.options[\"verify_signature\"]\n\n    def test_options_must_be_dict(self):\n        pytest.raises(TypeError, PyJWS, options=object())\n        pytest.raises((TypeError, ValueError), PyJWS, options=(\"something\"))\n\n    def test_encode_decode(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(payload, secret, algorithm=\"HS256\")\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decode_fails_when_alg_is_not_on_method_algorithms_param(\n        self, jws, payload\n    ):\n        secret = \"secret\"\n        jws_token = jws.encode(payload, secret, algorithm=\"HS256\")\n        jws.decode(jws_token, secret, algorithms=[\"HS256\"])\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(jws_token, secret, algorithms=[\"HS384\"])\n\n    def test_decode_works_with_unicode_token(self, jws):\n        secret = \"secret\"\n        unicode_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        jws.decode(unicode_jws, secret, algorithms=[\"HS256\"])\n\n    def test_decode_missing_segments_throws_exception(self, jws):\n        secret = \"secret\"\n        example_jws = \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9\"  # Missing segment\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Not enough segments\"\n\n    def test_decode_invalid_token_type_is_none(self, jws):\n        example_jws = None\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert \"Invalid token type\" in str(exception)\n\n    def test_decode_invalid_token_type_is_int(self, jws):\n        example_jws = 123\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert \"Invalid token type\" in str(exception)\n\n    def test_decode_with_non_mapping_header_throws_exception(self, jws):\n        secret = \"secret\"\n        example_jws = (\n            \"MQ\"  # == 1\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        with pytest.raises(DecodeError) as context:\n            jws.decode(example_jws, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Invalid header string: must be a json object\"\n\n    def test_encode_algorithm_param_should_be_case_sensitive(self, jws, payload):\n        jws.encode(payload, \"secret\", algorithm=\"HS256\")\n\n        with pytest.raises(NotImplementedError) as context:\n            jws.encode(payload, None, algorithm=\"hs256\")\n\n        exception = context.value\n        assert str(exception) == \"Algorithm not supported\"\n\n    def test_encode_with_headers_alg_none(self, jws, payload):\n        msg = jws.encode(payload, key=None, headers={\"alg\": \"none\"})\n        with pytest.raises(DecodeError) as context:\n            jws.decode(msg, algorithms=[\"none\"])\n        assert str(context.value) == \"Signature verification failed\"\n\n    @crypto_required\n    def test_encode_with_headers_alg_es256(self, jws, payload):\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_key = load_pem_public_key(ec_pub_file.read())\n\n        msg = jws.encode(payload, priv_key, headers={\"alg\": \"ES256\"})\n        assert b\"hello world\" == jws.decode(msg, pub_key, algorithms=[\"ES256\"])\n\n    @crypto_required\n    def test_encode_with_alg_hs256_and_headers_alg_es256(self, jws, payload):\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_key = load_pem_public_key(ec_pub_file.read())\n\n        msg = jws.encode(payload, priv_key, algorithm=\"HS256\", headers={\"alg\": \"ES256\"})\n        assert b\"hello world\" == jws.decode(msg, pub_key, algorithms=[\"ES256\"])\n\n    def test_decode_algorithm_param_should_be_case_sensitive(self, jws):\n        example_jws = (\n            \"eyJhbGciOiJoczI1NiIsInR5cCI6IkpXVCJ9\"  # alg = hs256\n            \".eyJoZWxsbyI6IndvcmxkIn0\"\n            \".5R_FEPE7SW2dT9GgIxPgZATjFGXfUDOSwo7TtO_Kd_g\"\n        )\n\n        with pytest.raises(InvalidAlgorithmError) as context:\n            jws.decode(example_jws, \"secret\", algorithms=[\"hs256\"])\n\n        exception = context.value\n        assert str(exception) == \"Algorithm not supported\"\n\n    def test_bad_secret(self, jws, payload):\n        right_secret = \"foo\"\n        bad_secret = \"bar\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError) as excinfo:\n            # Backward compat for ticket #315\n            jws.decode(jws_message, bad_secret, algorithms=[\"HS256\"])\n        assert \"Signature verification failed\" == str(excinfo.value)\n\n        with pytest.raises(InvalidSignatureError) as excinfo:\n            jws.decode(jws_message, bad_secret, algorithms=[\"HS256\"])\n        assert \"Signature verification failed\" == str(excinfo.value)\n\n    def test_decodes_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decodes_complete_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded = jws.decode_complete(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": payload,\n            \"signature\": (\n                b\"\\x80E\\xb4\\xa5\\xd58\\x93\\x13\\xed\\x86;^\\x85\\x87a\\xc4\"\n                b\"\\x1ff0\\xe1\\x9a\\x8e\\xddq\\x08\\xa9F\\x19p\\xc9\\xf0\\xf3\"\n            ),\n        }\n\n    def test_decodes_with_jwk(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, jwk, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_decodes_with_jwk_and_no_algorithm(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS256\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        decoded_payload = jws.decode(example_jws, jwk)\n\n        assert decoded_payload == payload\n\n    def test_decodes_with_jwk_and_mismatched_algorithm(self, jws, payload):\n        jwk = PyJWK(\n            {\n                \"kty\": \"oct\",\n                \"alg\": \"HS512\",\n                \"k\": \"c2VjcmV0\",  # \"secret\"\n            }\n        )\n        example_jws = (\n            b\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"gEW0pdU4kxPthjtehYdhxB9mMOGajt1xCKlGGXDJ8PM\"\n        )\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(example_jws, jwk)\n\n    # 'Control' Elliptic Curve jws created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_es384_jws(self, jws):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_ec.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jws = (\n            b\"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"eyJoZWxsbyI6IndvcmxkIn0.TORyNQab_MoXM7DvNKaTwbrJr4UY\"\n            b\"d2SsX8hhlnWelQFmPFSf_JzC2EbLnar92t-bXsDovzxp25ExazrVHkfPkQ\"\n        )\n        decoded_payload = jws.decode(example_jws, example_pubkey, algorithms=[\"ES256\"])\n        json_payload = json.loads(decoded_payload)\n\n        assert json_payload == example_payload\n\n    # 'Control' RSA jws created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_rs384_jws(self, jws):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_rsa.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jws = (\n            b\"eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9\"\n            b\".eyJoZWxsbyI6IndvcmxkIn0\"\n            b\".yNQ3nI9vEDs7lEh-Cp81McPuiQ4ZRv6FL4evTYYAh1X\"\n            b\"lRTTR3Cz8pPA9Stgso8Ra9xGB4X3rlra1c8Jz10nTUju\"\n            b\"O06OMm7oXdrnxp1KIiAJDerWHkQ7l3dlizIk1bmMA457\"\n            b\"W2fNzNfHViuED5ISM081dgf_a71qBwJ_yShMMrSOfxDx\"\n            b\"mX9c4DjRogRJG8SM5PvpLqI_Cm9iQPGMvmYK7gzcq2cJ\"\n            b\"urHRJDJHTqIdpLWXkY7zVikeen6FhuGyn060Dz9gYq9t\"\n            b\"uwmrtSWCBUjiN8sqJ00CDgycxKqHfUndZbEAOjcCAhBr\"\n            b\"qWW3mSVivUfubsYbwUdUG3fSRPjaUPcpe8A\"\n        )\n        decoded_payload = jws.decode(example_jws, example_pubkey, algorithms=[\"RS384\"])\n        json_payload = json.loads(decoded_payload)\n\n        assert json_payload == example_payload\n\n    def test_load_verify_valid_jws(self, jws, payload):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        decoded_payload = jws.decode(\n            example_jws, key=example_secret, algorithms=[\"HS256\"]\n        )\n        assert decoded_payload == payload\n\n    def test_allow_skip_verification(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n        decoded_payload = jws.decode(jws_message, options={\"verify_signature\": False})\n\n        assert decoded_payload == payload\n\n    def test_decode_with_optional_algorithms(self, jws):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, key=example_secret)\n\n        assert (\n            'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            in str(exc.value)\n        )\n\n    def test_decode_no_algorithms_verify_signature_false(self, jws):\n        example_secret = \"secret\"\n        example_jws = (\n            b\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"aGVsbG8gd29ybGQ.\"\n            b\"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI\"\n        )\n\n        jws.decode(\n            example_jws,\n            key=example_secret,\n            options={\"verify_signature\": False},\n        )\n\n    def test_load_no_verification(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        decoded_payload = jws.decode(\n            jws_message,\n            key=None,\n            algorithms=[\"HS256\"],\n            options={\"verify_signature\": False},\n        )\n\n        assert decoded_payload == payload\n\n    def test_no_secret(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError):\n            jws.decode(jws_message, algorithms=[\"HS256\"])\n\n    def test_verify_signature_with_no_secret(self, jws, payload):\n        right_secret = \"foo\"\n        jws_message = jws.encode(payload, right_secret)\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(jws_message, algorithms=[\"HS256\"])\n\n        assert \"Signature verification\" in str(exc.value)\n\n    def test_verify_signature_with_no_algo_header_throws_exception(self, jws, payload):\n        example_jws = b\"e30.eyJhIjo1fQ.KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY\"\n\n        with pytest.raises(InvalidAlgorithmError):\n            jws.decode(example_jws, \"secret\", algorithms=[\"HS256\"])\n\n    def test_invalid_crypto_alg(self, jws, payload):\n        with pytest.raises(NotImplementedError):\n            jws.encode(payload, \"secret\", algorithm=\"HS1024\")\n\n    @no_crypto_required\n    def test_missing_crypto_library_better_error_messages(self, jws, payload):\n        with pytest.raises(NotImplementedError) as excinfo:\n            jws.encode(payload, \"secret\", algorithm=\"RS256\")\n            assert \"cryptography\" in str(excinfo.value)\n\n    def test_unicode_secret(self, jws, payload):\n        secret = \"\\xc2\"\n        jws_message = jws.encode(payload, secret)\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_nonascii_secret(self, jws, payload):\n        secret = \"\\xc2\"  # char value that ascii codec cannot decode\n        jws_message = jws.encode(payload, secret)\n\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    def test_bytes_secret(self, jws, payload):\n        secret = b\"\\xc2\"  # char value that ascii codec cannot decode\n        jws_message = jws.encode(payload, secret)\n\n        decoded_payload = jws.decode(jws_message, secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == payload\n\n    @pytest.mark.parametrize(\"sort_headers\", (False, True))\n    def test_sorting_of_headers(self, jws, payload, sort_headers):\n        jws_message = jws.encode(\n            payload,\n            key=\"\\xc2\",\n            headers={\"b\": \"1\", \"a\": \"2\"},\n            sort_headers=sort_headers,\n        )\n        header_json = base64url_decode(jws_message.split(\".\")[0])\n        assert sort_headers == (header_json.index(b'\"a\"') < header_json.index(b'\"b\"'))\n\n    def test_decode_invalid_header_padding(self, jws):\n        example_jws = (\n            \"aeyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"header padding\" in str(exc.value)\n\n    def test_decode_invalid_header_string(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTbpIiwgInR5cCI6ICJKV1QifQ==\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid header\" in str(exc.value)\n\n    def test_decode_invalid_payload_padding(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".aeyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid payload padding\" in str(exc.value)\n\n    def test_decode_invalid_crypto_padding(self, jws):\n        example_jws = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".aatvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid crypto padding\" in str(exc.value)\n\n    def test_decode_with_algo_none_should_fail(self, jws, payload):\n        jws_message = jws.encode(payload, key=None, algorithm=None)\n\n        with pytest.raises(DecodeError):\n            jws.decode(jws_message, algorithms=[\"none\"])\n\n    def test_decode_with_algo_none_and_verify_false_should_pass(self, jws, payload):\n        jws_message = jws.encode(payload, key=None, algorithm=None)\n        jws.decode(jws_message, options={\"verify_signature\": False})\n\n    def test_get_unverified_header_returns_header_values(self, jws, payload):\n        jws_message = jws.encode(\n            payload,\n            key=\"secret\",\n            algorithm=\"HS256\",\n            headers={\"kid\": \"toomanysecrets\"},\n        )\n\n        header = jws.get_unverified_header(jws_message)\n\n        assert \"kid\" in header\n        assert header[\"kid\"] == \"toomanysecrets\"\n\n    def test_get_unverified_header_fails_on_bad_header_types(self, jws, payload):\n        # Contains a bad kid value (int 123 instead of string)\n        example_jws = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6MTIzfQ\"\n            \".eyJzdWIiOiIxMjM0NTY3ODkwIn0\"\n            \".vs2WY54jfpKP3JGC73Vq5YlMsqM5oTZ1ZydT77SiZSk\"\n        )\n\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.get_unverified_header(example_jws)\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n    @pytest.mark.parametrize(\n        \"algo\",\n        [\n            \"RS256\",\n            \"RS384\",\n            \"RS512\",\n        ],\n    )\n    @crypto_required\n    def test_encode_decode_rsa_related_algorithms(self, jws, payload, algo):\n        # PEM-formatted RSA key\n        with open(key_path(\"testkey_rsa.priv\"), \"rb\") as rsa_priv_file:\n            priv_rsakey = load_pem_private_key(rsa_priv_file.read(), password=None)\n            jws_message = jws.encode(payload, priv_rsakey, algorithm=algo)\n\n        with open(key_path(\"testkey_rsa.pub\"), \"rb\") as rsa_pub_file:\n            pub_rsakey = load_ssh_public_key(rsa_pub_file.read())\n            jws.decode(jws_message, pub_rsakey, algorithms=[algo])\n\n        # string-formatted key\n        with open(key_path(\"testkey_rsa.priv\")) as rsa_priv_file:\n            priv_rsakey = rsa_priv_file.read()  # type: ignore[assignment]\n            jws_message = jws.encode(payload, priv_rsakey, algorithm=algo)\n\n        with open(key_path(\"testkey_rsa.pub\")) as rsa_pub_file:\n            pub_rsakey = rsa_pub_file.read()  # type: ignore[assignment]\n            jws.decode(jws_message, pub_rsakey, algorithms=[algo])\n\n    def test_rsa_related_algorithms(self, jws):\n        jws = PyJWS()\n        jws_algorithms = jws.get_algorithms()\n\n        if has_crypto:\n            assert \"RS256\" in jws_algorithms\n            assert \"RS384\" in jws_algorithms\n            assert \"RS512\" in jws_algorithms\n            assert \"PS256\" in jws_algorithms\n            assert \"PS384\" in jws_algorithms\n            assert \"PS512\" in jws_algorithms\n\n        else:\n            assert \"RS256\" not in jws_algorithms\n            assert \"RS384\" not in jws_algorithms\n            assert \"RS512\" not in jws_algorithms\n            assert \"PS256\" not in jws_algorithms\n            assert \"PS384\" not in jws_algorithms\n            assert \"PS512\" not in jws_algorithms\n\n    @pytest.mark.parametrize(\n        \"algo\",\n        [\n            \"ES256\",\n            \"ES256K\",\n            \"ES384\",\n            \"ES512\",\n        ],\n    )\n    @crypto_required\n    def test_encode_decode_ecdsa_related_algorithms(self, jws, payload, algo):\n        # PEM-formatted EC key\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_priv_file:\n            priv_eckey = load_pem_private_key(ec_priv_file.read(), password=None)\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(\"testkey_ec.pub\"), \"rb\") as ec_pub_file:\n            pub_eckey = load_pem_public_key(ec_pub_file.read())\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])\n\n        # string-formatted key\n        with open(key_path(\"testkey_ec.priv\")) as ec_priv_file:\n            priv_eckey = ec_priv_file.read()  # type: ignore[assignment]\n            jws_message = jws.encode(payload, priv_eckey, algorithm=algo)\n\n        with open(key_path(\"testkey_ec.pub\")) as ec_pub_file:\n            pub_eckey = ec_pub_file.read()  # type: ignore[assignment]\n            jws.decode(jws_message, pub_eckey, algorithms=[algo])\n\n    def test_ecdsa_related_algorithms(self, jws):\n        jws = PyJWS()\n        jws_algorithms = jws.get_algorithms()\n\n        if has_crypto:\n            assert \"ES256\" in jws_algorithms\n            assert \"ES256K\" in jws_algorithms\n            assert \"ES384\" in jws_algorithms\n            assert \"ES512\" in jws_algorithms\n        else:\n            assert \"ES256\" not in jws_algorithms\n            assert \"ES256K\" not in jws_algorithms\n            assert \"ES384\" not in jws_algorithms\n            assert \"ES512\" not in jws_algorithms\n\n    def test_skip_check_signature(self, jws):\n        token = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n            \".eyJzb21lIjoicGF5bG9hZCJ9\"\n            \".4twFt5NiznN84AWoo1d7KO1T_yoc0Z6XOpOVswacPZA\"\n        )\n        jws.decode(token, \"secret\", options={\"verify_signature\": False})\n\n    def test_decode_options_must_be_dict(self, jws, payload):\n        token = jws.encode(payload, \"secret\")\n\n        with pytest.raises(TypeError):\n            jws.decode(token, \"secret\", options=object())\n\n        with pytest.raises((TypeError, ValueError)):\n            jws.decode(token, \"secret\", options=\"something\")\n\n    def test_custom_json_encoder(self, jws, payload):\n        class CustomJSONEncoder(json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, Decimal):\n                    return \"it worked\"\n                return super().default(o)\n\n        data = {\"some_decimal\": Decimal(\"2.2\")}\n\n        with pytest.raises(TypeError):\n            jws.encode(payload, \"secret\", headers=data)\n\n        token = jws.encode(\n            payload, \"secret\", headers=data, json_encoder=CustomJSONEncoder\n        )\n\n        header, *_ = token.split(\".\")\n        header = json.loads(base64url_decode(header))\n\n        assert \"some_decimal\" in header\n        assert header[\"some_decimal\"] == \"it worked\"\n\n    def test_encode_headers_parameter_adds_headers(self, jws, payload):\n        headers = {\"testheader\": True}\n        token = jws.encode(payload, \"secret\", headers=headers)\n\n        if not isinstance(token, str):\n            token = token.decode()\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n\n        if not isinstance(header, str):\n            header = header.decode()\n\n        header_obj = json.loads(header)\n\n        assert \"testheader\" in header_obj\n        assert header_obj[\"testheader\"] == headers[\"testheader\"]\n\n    def test_encode_with_typ(self, jws):\n        payload = \"\"\"\n        {\n          \"iss\": \"https://scim.example.com\",\n          \"iat\": 1458496404,\n          \"jti\": \"4d3559ec67504aaba65d40b0363faad8\",\n          \"aud\": [\n            \"https://scim.example.com/Feeds/98d52461fa5bbc879593b7754\",\n            \"https://scim.example.com/Feeds/5d7604516b1d08641d7676ee7\"\n          ],\n          \"events\": {\n            \"urn:ietf:params:scim:event:create\": {\n              \"ref\":\n                  \"https://scim.example.com/Users/44f6142df96bd6ab61e7521d9\",\n              \"attributes\": [\"id\", \"name\", \"userName\", \"password\", \"emails\"]\n            }\n          }\n        }\n        \"\"\"\n        token = jws.encode(\n            payload.encode(\"utf-8\"), \"secret\", headers={\"typ\": \"secevent+jwt\"}\n        )\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" in header_obj\n        assert header_obj[\"typ\"] == \"secevent+jwt\"\n\n    def test_encode_with_typ_empty_string(self, jws, payload):\n        token = jws.encode(payload, \"secret\", headers={\"typ\": \"\"})\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" not in header_obj\n\n    def test_encode_with_typ_none(self, jws, payload):\n        token = jws.encode(payload, \"secret\", headers={\"typ\": None})\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" not in header_obj\n\n    def test_encode_with_typ_without_keywords(self, jws, payload):\n        headers = {\"foo\": \"bar\"}\n        token = jws.encode(payload, \"secret\", \"HS256\", headers, None)\n\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"foo\" in header_obj\n        assert header_obj[\"foo\"] == \"bar\"\n\n    def test_encode_fails_on_invalid_kid_types(self, jws, payload):\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.encode(payload, \"secret\", headers={\"kid\": 123})\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n        with pytest.raises(InvalidTokenError) as exc:\n            jws.encode(payload, \"secret\", headers={\"kid\": None})\n\n        assert \"Key ID header parameter must be a string\" == str(exc.value)\n\n    def test_encode_decode_with_detached_content(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        jws.decode(jws_message, secret, algorithms=[\"HS256\"], detached_payload=payload)\n\n    def test_encode_detached_content_with_b64_header(self, jws, payload):\n        secret = \"secret\"\n\n        # Check that detached content is automatically detected when b64 is false\n        headers = {\"b64\": False}\n        token = jws.encode(payload, secret, \"HS256\", headers)\n\n        msg_header, msg_payload, _ = token.split(\".\")\n        msg_header = base64url_decode(msg_header.encode())\n        msg_header_obj = json.loads(msg_header)\n\n        assert \"b64\" in msg_header_obj\n        assert msg_header_obj[\"b64\"] is False\n        # Check that the payload is not inside the token\n        assert not msg_payload\n\n        # Check that content is not detached and b64 header removed when b64 is true\n        headers = {\"b64\": True}\n        token = jws.encode(payload, secret, \"HS256\", headers)\n\n        msg_header, msg_payload, _ = token.split(\".\")\n        msg_header = base64url_decode(msg_header.encode())\n        msg_header_obj = json.loads(msg_header)\n\n        assert \"b64\" not in msg_header_obj\n        assert msg_payload\n\n    def test_decode_detached_content_without_proper_argument(self, jws):\n        example_jws = (\n            \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2V9\"\n            \".\"\n            \".65yNkX_ZH4A_6pHaTL_eI84OXOHtfl4K0k5UnlXZ8f4\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jws.decode(example_jws, example_secret, algorithms=[\"HS256\"])\n\n        assert (\n            'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'\n            in str(exc.value)\n        )\n\n    def test_decode_warns_on_unsupported_kwarg(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jws.decode(\n                jws_message,\n                secret,\n                algorithms=[\"HS256\"],\n                detached_payload=payload,\n                foo=\"bar\",\n            )\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)\n\n    def test_decode_complete_warns_on_unuspported_kwarg(self, jws, payload):\n        secret = \"secret\"\n        jws_message = jws.encode(\n            payload, secret, algorithm=\"HS256\", is_payload_detached=True\n        )\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jws.decode_complete(\n                jws_message,\n                secret,\n                algorithms=[\"HS256\"],\n                detached_payload=payload,\n                foo=\"bar\",\n            )\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)\n", "tests/test_algorithms.py": "import base64\nimport json\nfrom typing import Any, cast\n\nimport pytest\n\nfrom jwt.algorithms import HMACAlgorithm, NoneAlgorithm, has_crypto\nfrom jwt.exceptions import InvalidKeyError\nfrom jwt.utils import base64url_decode\n\nfrom .keys import load_ec_pub_key_p_521, load_hmac_key, load_rsa_pub_key\nfrom .utils import crypto_required, key_path\n\nif has_crypto:\n    from cryptography.hazmat.primitives.asymmetric.ec import (\n        EllipticCurvePrivateKey,\n        EllipticCurvePublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.ed448 import (\n        Ed448PrivateKey,\n        Ed448PublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.ed25519 import (\n        Ed25519PrivateKey,\n        Ed25519PublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.rsa import (\n        RSAPrivateKey,\n        RSAPublicKey,\n    )\n\n    from jwt.algorithms import ECAlgorithm, OKPAlgorithm, RSAAlgorithm, RSAPSSAlgorithm\n\n\nclass TestAlgorithms:\n    def test_none_algorithm_should_throw_exception_if_key_is_not_none(self):\n        algo = NoneAlgorithm()\n\n        with pytest.raises(InvalidKeyError):\n            algo.prepare_key(\"123\")\n\n    def test_none_algorithm_should_throw_exception_on_to_jwk(self):\n        algo = NoneAlgorithm()\n\n        with pytest.raises(NotImplementedError):\n            algo.to_jwk(\"dummy\")  # Using a dummy argument as is it not relevant\n\n    def test_none_algorithm_should_throw_exception_on_from_jwk(self):\n        algo = NoneAlgorithm()\n\n        with pytest.raises(NotImplementedError):\n            algo.from_jwk({})  # Using a dummy argument as is it not relevant\n\n    def test_hmac_should_reject_nonstring_key(self):\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n\n        with pytest.raises(TypeError) as context:\n            algo.prepare_key(object())  # type: ignore[arg-type]\n\n        exception = context.value\n        assert str(exception) == \"Expected a string value\"\n\n    def test_hmac_should_accept_unicode_key(self):\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n\n        algo.prepare_key(\"awesome\")\n\n    @pytest.mark.parametrize(\n        \"key\",\n        [\n            \"testkey2_rsa.pub.pem\",\n            \"testkey2_rsa.pub.pem\",\n            \"testkey_pkcs1.pub.pem\",\n            \"testkey_rsa.cer\",\n            \"testkey_rsa.pub\",\n        ],\n    )\n    def test_hmac_should_throw_exception(self, key):\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n\n        with pytest.raises(InvalidKeyError):\n            with open(key_path(key)) as keyfile:\n                algo.prepare_key(keyfile.read())\n\n    def test_hmac_jwk_should_parse_and_verify(self):\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_hmac.json\")) as keyfile:\n            key = algo.from_jwk(keyfile.read())\n\n        signature = algo.sign(b\"Hello World!\", key)\n        assert algo.verify(b\"Hello World!\", key, signature)\n\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_hmac_to_jwk_returns_correct_values(self, as_dict):\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n        key: Any = algo.to_jwk(\"secret\", as_dict=as_dict)\n\n        if not as_dict:\n            key = json.loads(key)\n\n        assert key == {\"kty\": \"oct\", \"k\": \"c2VjcmV0\"}\n\n    def test_hmac_from_jwk_should_raise_exception_if_not_hmac_key(self):\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                algo.from_jwk(keyfile.read())\n\n    @crypto_required\n    def test_rsa_should_parse_pem_public_key(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey2_rsa.pub.pem\")) as pem_key:\n            algo.prepare_key(pem_key.read())\n\n    @crypto_required\n    def test_rsa_should_accept_pem_private_key_bytes(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_rsa.priv\"), \"rb\") as pem_key:\n            algo.prepare_key(pem_key.read())\n\n    @crypto_required\n    def test_rsa_should_accept_unicode_key(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_rsa.priv\")) as rsa_key:\n            algo.prepare_key(rsa_key.read())\n\n    @crypto_required\n    def test_rsa_should_reject_non_string_key(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with pytest.raises(TypeError):\n            algo.prepare_key(None)  # type: ignore[arg-type]\n\n    @crypto_required\n    def test_rsa_verify_should_return_false_if_signature_invalid(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        message = b\"Hello World!\"\n\n        sig = base64.b64decode(\n            b\"yS6zk9DBkuGTtcBzLUzSpo9gGJxJFOGvUqN01iLhWHrzBQ9ZEz3+Ae38AXp\"\n            b\"10RWwscp42ySC85Z6zoN67yGkLNWnfmCZSEv+xqELGEvBJvciOKsrhiObUl\"\n            b\"2mveSc1oeO/2ujkGDkkkJ2epn0YliacVjZF5+/uDmImUfAAj8lzjnHlzYix\"\n            b\"sn5jGz1H07jYYbi9diixN8IUhXeTafwFg02IcONhum29V40Wu6O5tAKWlJX\"\n            b\"fHJnNUzAEUOXS0WahHVb57D30pcgIji9z923q90p5c7E2cU8V+E1qe8NdCA\"\n            b\"APCDzZZ9zQ/dgcMVaBrGrgimrcLbPjueOKFgSO+SSjIElKA==\"\n        )\n\n        sig += b\"123\"  # Signature is now invalid\n\n        with open(key_path(\"testkey_rsa.pub\")) as keyfile:\n            pub_key = cast(RSAPublicKey, algo.prepare_key(keyfile.read()))\n\n        result = algo.verify(message, pub_key, sig)\n        assert not result\n\n    @crypto_required\n    def test_ec_jwk_public_and_private_keys_should_parse_and_verify(self):\n        tests = {\n            \"P-256\": ECAlgorithm.SHA256,\n            \"P-384\": ECAlgorithm.SHA384,\n            \"P-521\": ECAlgorithm.SHA512,\n            \"secp256k1\": ECAlgorithm.SHA256,\n        }\n        for curve, hash in tests.items():\n            algo = ECAlgorithm(hash)\n\n            with open(key_path(f\"jwk_ec_pub_{curve}.json\")) as keyfile:\n                pub_key = cast(EllipticCurvePublicKey, algo.from_jwk(keyfile.read()))\n\n            with open(key_path(f\"jwk_ec_key_{curve}.json\")) as keyfile:\n                priv_key = cast(EllipticCurvePrivateKey, algo.from_jwk(keyfile.read()))\n\n            signature = algo.sign(b\"Hello World!\", priv_key)\n            assert algo.verify(b\"Hello World!\", pub_key, signature)\n\n    @crypto_required\n    def test_ec_jwk_fails_on_invalid_json(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA512)\n\n        valid_points = {\n            \"P-256\": {\n                \"x\": \"PTTjIY84aLtaZCxLTrG_d8I0G6YKCV7lg8M4xkKfwQ4\",\n                \"y\": \"ank6KA34vv24HZLXlChVs85NEGlpg2sbqNmR_BcgyJU\",\n            },\n            \"P-384\": {\n                \"x\": \"IDC-5s6FERlbC4Nc_4JhKW8sd51AhixtMdNUtPxhRFP323QY6cwWeIA3leyZhz-J\",\n                \"y\": \"eovmN9ocANS8IJxDAGSuC1FehTq5ZFLJU7XSPg36zHpv4H2byKGEcCBiwT4sFJsy\",\n            },\n            \"P-521\": {\n                \"x\": \"AHKZLLOsCOzz5cY97ewNUajB957y-C-U88c3v13nmGZx6sYl_oJXu9A5RkTKqjqvjyekWF-7ytDyRXYgCF5cj0Kt\",\n                \"y\": \"AdymlHvOiLxXkEhayXQnNCvDX4h9htZaCJN34kfmC6pV5OhQHiraVySsUdaQkAgDPrwQrJmbnX9cwlGfP-HqHZR1\",\n            },\n            \"secp256k1\": {\n                \"x\": \"MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs\",\n                \"y\": \"7r8d-xF7QAgT5kSRdly6M8xeg4Jz83Gs_CQPQRH65QI\",\n            },\n        }\n\n        # Invalid JSON\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(\"<this isn't json>\")\n\n        # Bad key type\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"RSA\"}')\n\n        # Missing data\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"EC\"}')\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"EC\", \"x\": \"1\"}')\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"EC\", \"y\": \"1\"}')\n\n        # Missing curve\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"EC\", \"x\": \"dGVzdA==\", \"y\": \"dGVzdA==\"}')\n\n        # EC coordinates not equally long\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"EC\", \"x\": \"dGVzdHRlc3Q=\", \"y\": \"dGVzdA==\"}')\n\n        # EC coordinates length invalid\n        for curve in (\"P-256\", \"P-384\", \"P-521\", \"secp256k1\"):\n            with pytest.raises(InvalidKeyError):\n                algo.from_jwk(\n                    f'{{\"kty\": \"EC\", \"crv\": \"{curve}\", \"x\": \"dGVzdA==\", \"y\": \"dGVzdA==\"}}'\n                )\n\n        # EC private key length invalid\n        for curve, point in valid_points.items():\n            with pytest.raises(InvalidKeyError):\n                algo.from_jwk(\n                    f'{{\"kty\": \"EC\", \"crv\": \"{curve}\", \"x\": \"{point[\"x\"]}\", \"y\": \"{point[\"y\"]}\", \"d\": \"dGVzdA==\"}}'\n                )\n\n    @crypto_required\n    def test_ec_private_key_to_jwk_works_with_from_jwk(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec.priv\")) as ec_key:\n            orig_key = cast(EllipticCurvePrivateKey, algo.prepare_key(ec_key.read()))\n\n        parsed_key = cast(EllipticCurvePrivateKey, algo.from_jwk(algo.to_jwk(orig_key)))\n        assert parsed_key.private_numbers() == orig_key.private_numbers()\n        assert (\n            parsed_key.private_numbers().public_numbers\n            == orig_key.private_numbers().public_numbers\n        )\n\n    @crypto_required\n    def test_ec_public_key_to_jwk_works_with_from_jwk(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec.pub\")) as ec_key:\n            orig_key = cast(EllipticCurvePublicKey, algo.prepare_key(ec_key.read()))\n\n        parsed_key = cast(EllipticCurvePublicKey, algo.from_jwk(algo.to_jwk(orig_key)))\n        assert parsed_key.public_numbers() == orig_key.public_numbers()\n\n    @crypto_required\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_ec_to_jwk_returns_correct_values_for_public_key(self, as_dict):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec.pub\")) as keyfile:\n            pub_key = algo.prepare_key(keyfile.read())\n\n        key: Any = algo.to_jwk(pub_key, as_dict=as_dict)\n\n        if not as_dict:\n            key = json.loads(key)\n\n        expected = {\n            \"kty\": \"EC\",\n            \"crv\": \"P-256\",\n            \"x\": \"HzAcUWSlGBHcuf3y3RiNrWI-pE6-dD2T7fIzg9t6wEc\",\n            \"y\": \"t2G02kbWiOqimYfQAfnARdp2CTycsJPhwA8rn1Cn0SQ\",\n        }\n\n        assert key == expected\n\n    @crypto_required\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_ec_to_jwk_returns_correct_values_for_private_key(self, as_dict):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec.priv\")) as keyfile:\n            priv_key = algo.prepare_key(keyfile.read())\n\n        key: Any = algo.to_jwk(priv_key, as_dict=as_dict)\n\n        if not as_dict:\n            key = json.loads(key)\n\n        expected = {\n            \"kty\": \"EC\",\n            \"crv\": \"P-256\",\n            \"x\": \"HzAcUWSlGBHcuf3y3RiNrWI-pE6-dD2T7fIzg9t6wEc\",\n            \"y\": \"t2G02kbWiOqimYfQAfnARdp2CTycsJPhwA8rn1Cn0SQ\",\n            \"d\": \"2nninfu2jMHDwAbn9oERUhRADS6duQaJEadybLaa0YQ\",\n        }\n\n        assert key == expected\n\n    @crypto_required\n    def test_ec_to_jwk_raises_exception_on_invalid_key(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with pytest.raises(InvalidKeyError):\n            algo.to_jwk({\"not\": \"a valid key\"})  # type: ignore[call-overload]\n\n    @crypto_required\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_ec_to_jwk_with_valid_curves(self, as_dict):\n        tests = {\n            \"P-256\": ECAlgorithm.SHA256,\n            \"P-384\": ECAlgorithm.SHA384,\n            \"P-521\": ECAlgorithm.SHA512,\n            \"secp256k1\": ECAlgorithm.SHA256,\n        }\n        for curve, hash in tests.items():\n            algo = ECAlgorithm(hash)\n\n            with open(key_path(f\"jwk_ec_pub_{curve}.json\")) as keyfile:\n                pub_key = algo.from_jwk(keyfile.read())\n                jwk: Any = algo.to_jwk(pub_key, as_dict=as_dict)\n\n                if not as_dict:\n                    jwk = json.loads(jwk)\n\n                assert jwk[\"crv\"] == curve\n\n            with open(key_path(f\"jwk_ec_key_{curve}.json\")) as keyfile:\n                priv_key = algo.from_jwk(keyfile.read())\n                jwk = algo.to_jwk(priv_key, as_dict=as_dict)\n\n                if not as_dict:\n                    jwk = json.loads(jwk)\n\n                assert jwk[\"crv\"] == curve\n\n    @crypto_required\n    def test_ec_to_jwk_with_invalid_curve(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec_secp192r1.priv\")) as keyfile:\n            priv_key = algo.prepare_key(keyfile.read())\n\n        with pytest.raises(InvalidKeyError):\n            algo.to_jwk(priv_key)\n\n    @crypto_required\n    def test_rsa_jwk_public_and_private_keys_should_parse_and_verify(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            pub_key = cast(RSAPublicKey, algo.from_jwk(keyfile.read()))\n\n        with open(key_path(\"jwk_rsa_key.json\")) as keyfile:\n            priv_key = cast(RSAPrivateKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", priv_key)\n        assert algo.verify(b\"Hello World!\", pub_key, signature)\n\n    @crypto_required\n    def test_rsa_private_key_to_jwk_works_with_from_jwk(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_rsa.priv\")) as rsa_key:\n            orig_key = cast(RSAPrivateKey, algo.prepare_key(rsa_key.read()))\n\n        parsed_key = cast(RSAPrivateKey, algo.from_jwk(algo.to_jwk(orig_key)))\n        assert parsed_key.private_numbers() == orig_key.private_numbers()\n        assert (\n            parsed_key.private_numbers().public_numbers\n            == orig_key.private_numbers().public_numbers\n        )\n\n    @crypto_required\n    def test_rsa_public_key_to_jwk_works_with_from_jwk(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_rsa.pub\")) as rsa_key:\n            orig_key = cast(RSAPublicKey, algo.prepare_key(rsa_key.read()))\n\n        parsed_key = cast(RSAPublicKey, algo.from_jwk(algo.to_jwk(orig_key)))\n        assert parsed_key.public_numbers() == orig_key.public_numbers()\n\n    @crypto_required\n    def test_rsa_jwk_private_key_with_other_primes_is_invalid(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_key.json\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                keydata = json.loads(keyfile.read())\n                keydata[\"oth\"] = []\n\n                algo.from_jwk(json.dumps(keydata))\n\n    @crypto_required\n    def test_rsa_jwk_private_key_with_missing_values_is_invalid(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_key.json\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                keydata = json.loads(keyfile.read())\n                del keydata[\"p\"]\n\n                algo.from_jwk(json.dumps(keydata))\n\n    @crypto_required\n    def test_rsa_jwk_private_key_can_recover_prime_factors(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_key.json\")) as keyfile:\n            keybytes = keyfile.read()\n            control_key = cast(RSAPrivateKey, algo.from_jwk(keybytes)).private_numbers()\n\n            keydata = json.loads(keybytes)\n            delete_these = [\"p\", \"q\", \"dp\", \"dq\", \"qi\"]\n            for field in delete_these:\n                del keydata[field]\n\n            parsed_key = cast(\n                RSAPrivateKey, algo.from_jwk(json.dumps(keydata))\n            ).private_numbers()\n\n        assert control_key.d == parsed_key.d\n        assert control_key.p == parsed_key.p\n        assert control_key.q == parsed_key.q\n        assert control_key.dmp1 == parsed_key.dmp1\n        assert control_key.dmq1 == parsed_key.dmq1\n        assert control_key.iqmp == parsed_key.iqmp\n\n    @crypto_required\n    def test_rsa_jwk_private_key_with_missing_required_values_is_invalid(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_key.json\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                keydata = json.loads(keyfile.read())\n                del keydata[\"p\"]\n\n                algo.from_jwk(json.dumps(keydata))\n\n    @crypto_required\n    def test_rsa_jwk_raises_exception_if_not_a_valid_key(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        # Invalid JSON\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(\"{not-a-real-key\")\n\n        # Missing key parts\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk('{\"kty\": \"RSA\"}')\n\n    @crypto_required\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_rsa_to_jwk_returns_correct_values_for_public_key(self, as_dict):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_rsa.pub\")) as keyfile:\n            pub_key = algo.prepare_key(keyfile.read())\n\n        key: Any = algo.to_jwk(pub_key, as_dict=as_dict)\n\n        if not as_dict:\n            key = json.loads(key)\n\n        expected = {\n            \"e\": \"AQAB\",\n            \"key_ops\": [\"verify\"],\n            \"kty\": \"RSA\",\n            \"n\": (\n                \"1HgzBfJv2cOjQryCwe8NEelriOTNFWKZUivevUrRhlqcmZJdCvuCJRr-xCN-\"\n                \"OmO8qwgJJR98feNujxVg-J9Ls3_UOA4HcF9nYH6aqVXELAE8Hk_ALvxi96ms\"\n                \"1DDuAvQGaYZ-lANxlvxeQFOZSbjkz_9mh8aLeGKwqJLp3p-OhUBQpwvAUAPg\"\n                \"82-OUtgTW3nSljjeFr14B8qAneGSc_wl0ni--1SRZUXFSovzcqQOkla3W27r\"\n                \"rLfrD6LXgj_TsDs4vD1PnIm1zcVenKT7TfYI17bsG_O_Wecwz2Nl19pL7gDo\"\n                \"sNruF3ogJWNq1Lyn_ijPQnkPLpZHyhvuiycYcI3DiQ\"\n            ),\n        }\n        assert key == expected\n\n    @crypto_required\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_rsa_to_jwk_returns_correct_values_for_private_key(self, as_dict):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_rsa.priv\")) as keyfile:\n            priv_key = algo.prepare_key(keyfile.read())\n\n        key: Any = algo.to_jwk(priv_key, as_dict=as_dict)\n\n        if not as_dict:\n            key = json.loads(key)\n\n        expected = {\n            \"key_ops\": [\"sign\"],\n            \"kty\": \"RSA\",\n            \"e\": \"AQAB\",\n            \"n\": (\n                \"1HgzBfJv2cOjQryCwe8NEelriOTNFWKZUivevUrRhlqcmZJdCvuCJRr-xCN-\"\n                \"OmO8qwgJJR98feNujxVg-J9Ls3_UOA4HcF9nYH6aqVXELAE8Hk_ALvxi96ms\"\n                \"1DDuAvQGaYZ-lANxlvxeQFOZSbjkz_9mh8aLeGKwqJLp3p-OhUBQpwvAUAPg\"\n                \"82-OUtgTW3nSljjeFr14B8qAneGSc_wl0ni--1SRZUXFSovzcqQOkla3W27r\"\n                \"rLfrD6LXgj_TsDs4vD1PnIm1zcVenKT7TfYI17bsG_O_Wecwz2Nl19pL7gDo\"\n                \"sNruF3ogJWNq1Lyn_ijPQnkPLpZHyhvuiycYcI3DiQ\"\n            ),\n            \"d\": (\n                \"rfbs8AWdB1RkLJRlC51LukrAvYl5UfU1TE6XRa4o-DTg2-03OXLNEMyVpMr\"\n                \"a47weEnu14StypzC8qXL7vxXOyd30SSFTffLfleaTg-qxgMZSDw-Fb_M-pU\"\n                \"HMPMEDYG-lgGma4l4fd1yTX2ATtoUo9BVOQgWS1LMZqi0ASEOkUfzlBgL04\"\n                \"UoaLhPSuDdLygdlDzgruVPnec0t1uOEObmrcWIkhwU2CGQzeLtuzX6OVgPh\"\n                \"k7xcnjbDurTTVpWH0R0gbZ5ukmQ2P-YuCX8T9iWNMGjPNSkb7h02s2Oe9ZR\"\n                \"zP007xQ0VF-Z7xyLuxk6ASmoX1S39ujSbk2WF0eXNPRgFwQ\"\n            ),\n            \"q\": (\n                \"47hlW2f1ARuWYJf9Dl6MieXjdj2dGx9PL2UH0unVzJYInd56nqXNPrQrc5k\"\n                \"ZU65KApC9n9oKUwIxuqwAAbh8oGNEQDqnuTj-powCkdC6bwA8KH1Y-wotpq\"\n                \"_GSjxkNzjWRm2GArJSzZc6Fb8EuObOrAavKJ285-zMPCEfus1WZG0\"\n            ),\n            \"p\": (\n                \"7tr0z929Lp4OHIRJjIKM_rDrWMPtRgnV-51pgWsN6qdpDzns_PgFwrHcoyY\"\n                \"sWIO-4yCdVWPxFOgEZ8xXTM_uwOe4VEmdZhw55Tx7axYZtmZYZbO_RIP4CG\"\n                \"mlJlOFTiYnxpr-2Cx6kIeQmd-hf7fA3tL018aEzwYMbFMcnAGnEg0\"\n            ),\n            \"qi\": (\n                \"djo95mB0LVYikNPa-NgyDwLotLqrueb9IviMmn6zKHCwiOXReqXDX9slB8\"\n                \"RA15uv56bmN04O__NyVFcgJ2ef169GZHiRFIgIy0Pl8LYkMhCYKKhyqM7g\"\n                \"xN-SqGqDTKDC22j00S7jcvCaa1qadn1qbdfukZ4NXv7E2d_LO0Y2Kkc\"\n            ),\n            \"dp\": (\n                \"tgZ2-tJpEdWxu1m1EzeKa644LHVjpTRptk7H0LDc8i6SieADEuWQvkb9df\"\n                \"fpY6tDFaQNQr3fQ6dtdAztmsP7l1b_ynwvT1nDZUcqZvl4ruBgDWFmKbjI\"\n                \"lOCt0v9jX6MEPP5xqBx9axdkw18BnGtUuHrbzHSlUX-yh_rumpVH1SE\"\n            ),\n            \"dq\": (\n                \"xxCIuhD0YlWFbUcwFgGdBWcLIm_WCMGj7SB6aGu1VDTLr4Wu10TFWM0TNu\"\n                \"hc9YPker2gpj5qzAmdAzwcfWSSvXpJTYR43jfulBTMoj8-2o3wCM0anclW\"\n                \"AuKhin-kc4mh9ssDXRQZwlMymZP0QtaxUDw_nlfVrUCZgO7L1_ZsUTk\"\n            ),\n        }\n        assert key == expected\n\n    @crypto_required\n    def test_rsa_to_jwk_raises_exception_on_invalid_key(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with pytest.raises(InvalidKeyError):\n            algo.to_jwk({\"not\": \"a valid key\"})  # type: ignore[call-overload]\n\n    @crypto_required\n    def test_rsa_from_jwk_raises_exception_on_invalid_key(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_hmac.json\")) as keyfile:\n            with pytest.raises(InvalidKeyError):\n                algo.from_jwk(keyfile.read())\n\n    @crypto_required\n    def test_ec_should_reject_non_string_key(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with pytest.raises(TypeError):\n            algo.prepare_key(None)  # type: ignore[arg-type]\n\n    @crypto_required\n    def test_ec_should_accept_pem_private_key_bytes(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec.priv\"), \"rb\") as ec_key:\n            algo.prepare_key(ec_key.read())\n\n    @crypto_required\n    def test_ec_should_accept_ssh_public_key_bytes(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with open(key_path(\"testkey_ec_ssh.pub\")) as ec_key:\n            algo.prepare_key(ec_key.read())\n\n    @crypto_required\n    def test_ec_verify_should_return_false_if_signature_invalid(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        message = b\"Hello World!\"\n\n        # Mess up the signature by replacing a known byte\n        sig = base64.b64decode(\n            b\"AC+m4Jf/xI3guAC6w0w37t5zRpSCF6F4udEz5LiMiTIjCS4vcVe6dDOxK+M\"\n            b\"mvkF8PxJuvqxP2CO3TR3okDPCl/NjATTO1jE+qBZ966CRQSSzcCM+tzcHzw\"\n            b\"LZS5kbvKu0Acd/K6Ol2/W3B1NeV5F/gjvZn/jOwaLgWEUYsg0o4XVrAg65\".replace(\n                b\"r\", b\"s\"\n            )\n        )\n\n        with open(key_path(\"testkey_ec.pub\")) as keyfile:\n            pub_key = algo.prepare_key(keyfile.read())\n\n        result = algo.verify(message, pub_key, sig)\n        assert not result\n\n    @crypto_required\n    def test_ec_verify_should_return_false_if_signature_wrong_length(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        message = b\"Hello World!\"\n\n        sig = base64.b64decode(b\"AC+m4Jf/xI3guAC6w0w3\")\n\n        with open(key_path(\"testkey_ec.pub\")) as keyfile:\n            pub_key = algo.prepare_key(keyfile.read())\n\n        result = algo.verify(message, pub_key, sig)\n        assert not result\n\n    @crypto_required\n    def test_ec_should_throw_exception_on_wrong_key(self):\n        algo = ECAlgorithm(ECAlgorithm.SHA256)\n\n        with pytest.raises(InvalidKeyError):\n            with open(key_path(\"testkey_rsa.priv\")) as keyfile:\n                algo.prepare_key(keyfile.read())\n\n        with pytest.raises(InvalidKeyError):\n            with open(key_path(\"testkey2_rsa.pub.pem\")) as pem_key:\n                algo.prepare_key(pem_key.read())\n\n    @crypto_required\n    def test_rsa_pss_sign_then_verify_should_return_true(self):\n        algo = RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256)\n\n        message = b\"Hello World!\"\n\n        with open(key_path(\"testkey_rsa.priv\")) as keyfile:\n            priv_key = cast(RSAPrivateKey, algo.prepare_key(keyfile.read()))\n            sig = algo.sign(message, priv_key)\n\n        with open(key_path(\"testkey_rsa.pub\")) as keyfile:\n            pub_key = cast(RSAPublicKey, algo.prepare_key(keyfile.read()))\n\n        result = algo.verify(message, pub_key, sig)\n        assert result\n\n    @crypto_required\n    def test_rsa_pss_verify_should_return_false_if_signature_invalid(self):\n        algo = RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256)\n\n        jwt_message = b\"Hello World!\"\n\n        jwt_sig = base64.b64decode(\n            b\"ywKAUGRIDC//6X+tjvZA96yEtMqpOrSppCNfYI7NKyon3P7doud5v65oWNu\"\n            b\"vQsz0fzPGfF7mQFGo9Cm9Vn0nljm4G6PtqZRbz5fXNQBH9k10gq34AtM02c\"\n            b\"/cveqACQ8gF3zxWh6qr9jVqIpeMEaEBIkvqG954E0HT9s9ybHShgHX9mlWk\"\n            b\"186/LopP4xe5c/hxOQjwhv6yDlTiwJFiqjNCvj0GyBKsc4iECLGIIO+4mC4\"\n            b\"daOCWqbpZDuLb1imKpmm8Nsm56kAxijMLZnpCcnPgyb7CqG+B93W9GHglA5\"\n            b\"drUeR1gRtO7vqbZMsCAQ4bpjXxwbYyjQlEVuMl73UL6sOWg==\"\n        )\n\n        jwt_sig += b\"123\"  # Signature is now invalid\n\n        with open(key_path(\"testkey_rsa.pub\")) as keyfile:\n            jwt_pub_key = cast(RSAPublicKey, algo.prepare_key(keyfile.read()))\n\n        result = algo.verify(jwt_message, jwt_pub_key, jwt_sig)\n        assert not result\n\n\nclass TestAlgorithmsRFC7520:\n    \"\"\"\n    These test vectors were taken from RFC 7520\n    (https://tools.ietf.org/html/rfc7520)\n    \"\"\"\n\n    def test_hmac_verify_should_return_true_for_test_vector(self):\n        \"\"\"\n        This test verifies that HMAC verification works with a known good\n        signature and key.\n\n        Reference: https://tools.ietf.org/html/rfc7520#section-4.4\n        \"\"\"\n        signing_input = (\n            b\"eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOWItNDcxYi1iZmQ2LWVlZ\"\n            b\"jMxNGJjNzAzNyJ9.SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ\"\n            b\"29pbmcgb3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIG\"\n            b\"lmIHlvdSBkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmc\"\n            b\"gd2hlcmUgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4\"\n        )\n\n        signature = base64url_decode(b\"s0h6KThzkfBBBkLspW1h84VsJZFTsPPqMDA7g1Md7p0\")\n\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n        key = algo.prepare_key(load_hmac_key())\n\n        result = algo.verify(signing_input, key, signature)\n        assert result\n\n    @crypto_required\n    def test_rsa_verify_should_return_true_for_test_vector(self):\n        \"\"\"\n        This test verifies that RSA PKCS v1.5 verification works with a known\n        good signature and key.\n\n        Reference: https://tools.ietf.org/html/rfc7520#section-4.1\n        \"\"\"\n        signing_input = (\n            b\"eyJhbGciOiJSUzI1NiIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZXhhb\"\n            b\"XBsZSJ9.SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb\"\n            b\"3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdS\"\n            b\"Bkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcmU\"\n            b\"geW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4\"\n        )\n\n        signature = base64url_decode(\n            b\"MRjdkly7_-oTPTS3AXP41iQIGKa80A0ZmTuV5MEaHoxnW2e5CZ5NlKtainoFmKZop\"\n            b\"dHM1O2U4mwzJdQx996ivp83xuglII7PNDi84wnB-BDkoBwA78185hX-Es4JIwmDLJ\"\n            b\"K3lfWRa-XtL0RnltuYv746iYTh_qHRD68BNt1uSNCrUCTJDt5aAE6x8wW1Kt9eRo4\"\n            b\"QPocSadnHXFxnt8Is9UzpERV0ePPQdLuW3IS_de3xyIrDaLGdjluPxUAhb6L2aXic\"\n            b\"1U12podGU0KLUQSE_oI-ZnmKJ3F4uOZDnd6QZWJushZ41Axf_fcIe8u9ipH84ogor\"\n            b\"ee7vjbU5y18kDquDg\"\n        )\n\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n        key = cast(RSAPublicKey, algo.prepare_key(load_rsa_pub_key()))\n\n        result = algo.verify(signing_input, key, signature)\n        assert result\n\n    @crypto_required\n    def test_rsapss_verify_should_return_true_for_test_vector(self):\n        \"\"\"\n        This test verifies that RSA-PSS verification works with a known good\n        signature and key.\n\n        Reference: https://tools.ietf.org/html/rfc7520#section-4.2\n        \"\"\"\n        signing_input = (\n            b\"eyJhbGciOiJQUzM4NCIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZXhhb\"\n            b\"XBsZSJ9.SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb\"\n            b\"3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdS\"\n            b\"Bkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcmU\"\n            b\"geW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4\"\n        )\n\n        signature = base64url_decode(\n            b\"cu22eBqkYDKgIlTpzDXGvaFfz6WGoz7fUDcfT0kkOy42miAh2qyBzk1xEsnk2IpN6\"\n            b\"-tPid6VrklHkqsGqDqHCdP6O8TTB5dDDItllVo6_1OLPpcbUrhiUSMxbbXUvdvWXz\"\n            b\"g-UD8biiReQFlfz28zGWVsdiNAUf8ZnyPEgVFn442ZdNqiVJRmBqrYRXe8P_ijQ7p\"\n            b\"8Vdz0TTrxUeT3lm8d9shnr2lfJT8ImUjvAA2Xez2Mlp8cBE5awDzT0qI0n6uiP1aC\"\n            b\"N_2_jLAeQTlqRHtfa64QQSUmFAAjVKPbByi7xho0uTOcbH510a6GYmJUAfmWjwZ6o\"\n            b\"D4ifKo8DYM-X72Eaw\"\n        )\n\n        algo = RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384)\n        key = cast(RSAPublicKey, algo.prepare_key(load_rsa_pub_key()))\n\n        result = algo.verify(signing_input, key, signature)\n        assert result\n\n    @crypto_required\n    def test_ec_verify_should_return_true_for_test_vector(self):\n        \"\"\"\n        This test verifies that ECDSA verification works with a known good\n        signature and key.\n\n        Reference: https://tools.ietf.org/html/rfc7520#section-4.3\n        \"\"\"\n        signing_input = (\n            b\"eyJhbGciOiJFUzUxMiIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZXhhb\"\n            b\"XBsZSJ9.SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb\"\n            b\"3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdS\"\n            b\"Bkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcmU\"\n            b\"geW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4\"\n        )\n\n        signature = base64url_decode(\n            b\"AE_R_YZCChjn4791jSQCrdPZCNYqHXCTZH0-JZGYNlaAjP2kqaluUIIUnC9qvbu9P\"\n            b\"lon7KRTzoNEuT4Va2cmL1eJAQy3mtPBu_u_sDDyYjnAMDxXPn7XrT0lw-kvAD890j\"\n            b\"l8e2puQens_IEKBpHABlsbEPX6sFY8OcGDqoRuBomu9xQ2\"\n        )\n\n        algo = ECAlgorithm(ECAlgorithm.SHA512)\n        key = algo.prepare_key(load_ec_pub_key_p_521())\n\n        result = algo.verify(signing_input, key, signature)\n        assert result\n\n        # private key can also be used.\n        with open(key_path(\"jwk_ec_key_P-521.json\")) as keyfile:\n            private_key = algo.from_jwk(keyfile.read())\n\n        result = algo.verify(signing_input, private_key, signature)\n        assert result\n\n\n@crypto_required\nclass TestOKPAlgorithms:\n    hello_world_sig = b\"Qxa47mk/azzUgmY2StAOguAd4P7YBLpyCfU3JdbaiWnXM4o4WibXwmIHvNYgN3frtE2fcyd8OYEaOiD/KiwkCg==\"\n    hello_world = b\"Hello World!\"\n\n    def test_okp_ed25519_should_reject_non_string_key(self):\n        algo = OKPAlgorithm()\n\n        with pytest.raises(InvalidKeyError):\n            algo.prepare_key(None)  # type: ignore[arg-type]\n\n        with open(key_path(\"testkey_ed25519\")) as keyfile:\n            algo.prepare_key(keyfile.read())\n\n        with open(key_path(\"testkey_ed25519.pub\")) as keyfile:\n            algo.prepare_key(keyfile.read())\n\n    def test_okp_ed25519_sign_should_generate_correct_signature_value(self):\n        algo = OKPAlgorithm()\n\n        jwt_message = self.hello_world\n\n        expected_sig = base64.b64decode(self.hello_world_sig)\n\n        with open(key_path(\"testkey_ed25519\")) as keyfile:\n            jwt_key = cast(Ed25519PrivateKey, algo.prepare_key(keyfile.read()))\n\n        with open(key_path(\"testkey_ed25519.pub\")) as keyfile:\n            jwt_pub_key = cast(Ed25519PublicKey, algo.prepare_key(keyfile.read()))\n\n        algo.sign(jwt_message, jwt_key)\n        result = algo.verify(jwt_message, jwt_pub_key, expected_sig)\n        assert result\n\n    def test_okp_ed25519_verify_should_return_false_if_signature_invalid(self):\n        algo = OKPAlgorithm()\n\n        jwt_message = self.hello_world\n        jwt_sig = base64.b64decode(self.hello_world_sig)\n\n        jwt_sig += b\"123\"  # Signature is now invalid\n\n        with open(key_path(\"testkey_ed25519.pub\")) as keyfile:\n            jwt_pub_key = algo.prepare_key(keyfile.read())\n\n        result = algo.verify(jwt_message, jwt_pub_key, jwt_sig)\n        assert not result\n\n    def test_okp_ed25519_verify_should_return_true_if_signature_valid(self):\n        algo = OKPAlgorithm()\n\n        jwt_message = self.hello_world\n        jwt_sig = base64.b64decode(self.hello_world_sig)\n\n        with open(key_path(\"testkey_ed25519.pub\")) as keyfile:\n            jwt_pub_key = algo.prepare_key(keyfile.read())\n\n        result = algo.verify(jwt_message, jwt_pub_key, jwt_sig)\n        assert result\n\n    def test_okp_ed25519_prepare_key_should_be_idempotent(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"testkey_ed25519.pub\")) as keyfile:\n            jwt_pub_key_first = algo.prepare_key(keyfile.read())\n            jwt_pub_key_second = algo.prepare_key(jwt_pub_key_first)\n\n        assert jwt_pub_key_first == jwt_pub_key_second\n\n    def test_okp_ed25519_jwk_private_key_should_parse_and_verify(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed25519.json\")) as keyfile:\n            key = cast(Ed25519PrivateKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", key)\n        assert algo.verify(b\"Hello World!\", key.public_key(), signature)\n\n    def test_okp_ed25519_jwk_private_key_should_parse_and_verify_with_private_key_as_is(\n        self,\n    ):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed25519.json\")) as keyfile:\n            key = cast(Ed25519PrivateKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", key)\n        assert algo.verify(b\"Hello World!\", key, signature)\n\n    def test_okp_ed25519_jwk_public_key_should_parse_and_verify(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed25519.json\")) as keyfile:\n            priv_key = cast(Ed25519PrivateKey, algo.from_jwk(keyfile.read()))\n\n        with open(key_path(\"jwk_okp_pub_Ed25519.json\")) as keyfile:\n            pub_key = cast(Ed25519PublicKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", priv_key)\n        assert algo.verify(b\"Hello World!\", pub_key, signature)\n\n    def test_okp_ed25519_jwk_fails_on_invalid_json(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_pub_Ed25519.json\")) as keyfile:\n            valid_pub = json.loads(keyfile.read())\n        with open(key_path(\"jwk_okp_key_Ed25519.json\")) as keyfile:\n            valid_key = json.loads(keyfile.read())\n\n        # Invalid instance type\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(123)  # type: ignore[arg-type]\n\n        # Invalid JSON\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(\"<this isn't json>\")\n\n        # Invalid kty, not \"OKP\"\n        v = valid_pub.copy()\n        v[\"kty\"] = \"oct\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid crv, not \"Ed25519\"\n        v = valid_pub.copy()\n        v[\"crv\"] = \"P-256\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid crv, \"Ed448\"\n        v = valid_pub.copy()\n        v[\"crv\"] = \"Ed448\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Missing x\n        v = valid_pub.copy()\n        del v[\"x\"]\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid x\n        v = valid_pub.copy()\n        v[\"x\"] = \"123\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid d\n        v = valid_key.copy()\n        v[\"d\"] = \"123\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_okp_ed25519_to_jwk_works_with_from_jwk(self, as_dict):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed25519.json\")) as keyfile:\n            priv_key_1 = cast(Ed25519PrivateKey, algo.from_jwk(keyfile.read()))\n\n        with open(key_path(\"jwk_okp_pub_Ed25519.json\")) as keyfile:\n            pub_key_1 = cast(Ed25519PublicKey, algo.from_jwk(keyfile.read()))\n\n        pub = algo.to_jwk(pub_key_1, as_dict=as_dict)\n        pub_key_2 = algo.from_jwk(pub)\n        pri = algo.to_jwk(priv_key_1, as_dict=as_dict)\n        priv_key_2 = cast(Ed25519PrivateKey, algo.from_jwk(pri))\n\n        signature_1 = algo.sign(b\"Hello World!\", priv_key_1)\n        signature_2 = algo.sign(b\"Hello World!\", priv_key_2)\n        assert algo.verify(b\"Hello World!\", pub_key_2, signature_1)\n        assert algo.verify(b\"Hello World!\", pub_key_2, signature_2)\n\n    def test_okp_to_jwk_raises_exception_on_invalid_key(self):\n        algo = OKPAlgorithm()\n\n        with pytest.raises(InvalidKeyError):\n            algo.to_jwk({\"not\": \"a valid key\"})  # type: ignore[call-overload]\n\n    def test_okp_ed448_jwk_private_key_should_parse_and_verify(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed448.json\")) as keyfile:\n            key = cast(Ed448PrivateKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", key)\n        assert algo.verify(b\"Hello World!\", key.public_key(), signature)\n\n    def test_okp_ed448_jwk_private_key_should_parse_and_verify_with_private_key_as_is(\n        self,\n    ):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed448.json\")) as keyfile:\n            key = cast(Ed448PrivateKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", key)\n        assert algo.verify(b\"Hello World!\", key, signature)\n\n    def test_okp_ed448_jwk_public_key_should_parse_and_verify(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed448.json\")) as keyfile:\n            priv_key = cast(Ed448PrivateKey, algo.from_jwk(keyfile.read()))\n\n        with open(key_path(\"jwk_okp_pub_Ed448.json\")) as keyfile:\n            pub_key = cast(Ed448PublicKey, algo.from_jwk(keyfile.read()))\n\n        signature = algo.sign(b\"Hello World!\", priv_key)\n        assert algo.verify(b\"Hello World!\", pub_key, signature)\n\n    def test_okp_ed448_jwk_fails_on_invalid_json(self):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_pub_Ed448.json\")) as keyfile:\n            valid_pub = json.loads(keyfile.read())\n        with open(key_path(\"jwk_okp_key_Ed448.json\")) as keyfile:\n            valid_key = json.loads(keyfile.read())\n\n        # Invalid instance type\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(123)  # type: ignore[arg-type]\n\n        # Invalid JSON\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(\"<this isn't json>\")\n\n        # Invalid kty, not \"OKP\"\n        v = valid_pub.copy()\n        v[\"kty\"] = \"oct\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid crv, not \"Ed448\"\n        v = valid_pub.copy()\n        v[\"crv\"] = \"P-256\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid crv, \"Ed25519\"\n        v = valid_pub.copy()\n        v[\"crv\"] = \"Ed25519\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Missing x\n        v = valid_pub.copy()\n        del v[\"x\"]\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid x\n        v = valid_pub.copy()\n        v[\"x\"] = \"123\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n        # Invalid d\n        v = valid_key.copy()\n        v[\"d\"] = \"123\"\n        with pytest.raises(InvalidKeyError):\n            algo.from_jwk(v)\n\n    @pytest.mark.parametrize(\"as_dict\", (False, True))\n    def test_okp_ed448_to_jwk_works_with_from_jwk(self, as_dict):\n        algo = OKPAlgorithm()\n\n        with open(key_path(\"jwk_okp_key_Ed448.json\")) as keyfile:\n            priv_key_1 = cast(Ed448PrivateKey, algo.from_jwk(keyfile.read()))\n\n        with open(key_path(\"jwk_okp_pub_Ed448.json\")) as keyfile:\n            pub_key_1 = cast(Ed448PublicKey, algo.from_jwk(keyfile.read()))\n\n        pub = algo.to_jwk(pub_key_1, as_dict=as_dict)\n        pub_key_2 = algo.from_jwk(pub)\n        pri = algo.to_jwk(priv_key_1, as_dict=as_dict)\n        priv_key_2 = cast(Ed448PrivateKey, algo.from_jwk(pri))\n\n        signature_1 = algo.sign(b\"Hello World!\", priv_key_1)\n        signature_2 = algo.sign(b\"Hello World!\", priv_key_2)\n        assert algo.verify(b\"Hello World!\", pub_key_2, signature_1)\n        assert algo.verify(b\"Hello World!\", pub_key_2, signature_2)\n\n    @crypto_required\n    def test_rsa_can_compute_digest(self):\n        # this is the well-known sha256 hash of \"foo\"\n        foo_hash = base64.b64decode(b\"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564=\")\n\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n        computed_hash = algo.compute_hash_digest(b\"foo\")\n        assert computed_hash == foo_hash\n\n    def test_hmac_can_compute_digest(self):\n        # this is the well-known sha256 hash of \"foo\"\n        foo_hash = base64.b64decode(b\"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564=\")\n\n        algo = HMACAlgorithm(HMACAlgorithm.SHA256)\n        computed_hash = algo.compute_hash_digest(b\"foo\")\n        assert computed_hash == foo_hash\n\n    @crypto_required\n    def test_rsa_prepare_key_raises_invalid_key_error_on_invalid_pem(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n        invalid_key = \"invalid key\"\n\n        with pytest.raises(InvalidKeyError) as excinfo:\n            algo.prepare_key(invalid_key)\n\n        # Check that the exception message is correct\n        assert \"Could not parse the provided public key.\" in str(excinfo.value)\n", "tests/test_exceptions.py": "from jwt.exceptions import MissingRequiredClaimError\n\n\ndef test_missing_required_claim_error_has_proper_str():\n    exc = MissingRequiredClaimError(\"abc\")\n\n    assert str(exc) == 'Token is missing the \"abc\" claim'\n", "tests/test_compressed_jwt.py": "import json\nimport zlib\n\nfrom jwt import PyJWT\n\n\nclass CompressedPyJWT(PyJWT):\n    def _decode_payload(self, decoded):\n        return json.loads(\n            # wbits=-15 has zlib not worry about headers of crc's\n            zlib.decompress(decoded[\"payload\"], wbits=-15).decode(\"utf-8\")\n        )\n\n\ndef test_decodes_complete_valid_jwt_with_compressed_payload():\n    # Test case from https://github.com/jpadilla/pyjwt/pull/753/files\n    example_payload = {\"hello\": \"world\"}\n    example_secret = \"secret\"\n    # payload made with the pako (https://nodeca.github.io/pako/) library in Javascript:\n    # Buffer.from(pako.deflateRaw('{\"hello\": \"world\"}')).toString('base64')\n    example_jwt = (\n        b\"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n        b\".q1bKSM3JyVeyUlAqzy/KSVGqBQA=\"\n        b\".08wHYeuh1rJXmcBcMrz6NxmbxAnCQp2rGTKfRNIkxiw=\"\n    )\n    decoded = CompressedPyJWT().decode_complete(\n        example_jwt, example_secret, algorithms=[\"HS256\"]\n    )\n\n    assert decoded == {\n        \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n        \"payload\": example_payload,\n        \"signature\": (\n            b\"\\xd3\\xcc\\x07a\\xeb\\xa1\\xd6\\xb2W\\x99\\xc0\\\\2\\xbc\\xfa7\"\n            b\"\\x19\\x9b\\xc4\\t\\xc2B\\x9d\\xab\\x192\\x9fD\\xd2$\\xc6,\"\n        ),\n    }\n", "tests/test_jwt.py": "import jwt\n\nfrom .utils import utc_timestamp\n\n\ndef test_encode_decode():\n    \"\"\"\n    This test exists primarily to ensure that calls to jwt.encode and\n    jwt.decode don't explode. Most functionality is tested by the PyJWT class\n    tests. This is primarily a sanity check to make sure we don't break the\n    public global functions.\n    \"\"\"\n    payload = {\"iss\": \"jeff\", \"exp\": utc_timestamp() + 15, \"claim\": \"insanity\"}\n\n    secret = \"secret\"\n    jwt_message = jwt.encode(payload, secret, algorithm=\"HS256\")\n    decoded_payload = jwt.decode(jwt_message, secret, algorithms=[\"HS256\"])\n\n    assert decoded_payload == payload\n", "tests/__init__.py": "", "tests/test_api_jwk.py": "import json\n\nimport pytest\n\nfrom jwt.algorithms import has_crypto\nfrom jwt.api_jwk import PyJWK, PyJWKSet\nfrom jwt.exceptions import InvalidKeyError, PyJWKError, PyJWKSetError\n\nfrom .utils import crypto_required, key_path, no_crypto_required\n\nif has_crypto:\n    from jwt.algorithms import ECAlgorithm, HMACAlgorithm, OKPAlgorithm, RSAAlgorithm\n\n\nclass TestPyJWK:\n    @crypto_required\n    def test_should_load_key_from_jwk_data_dict(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            pub_key = algo.from_jwk(keyfile.read())\n\n        key_data_str = algo.to_jwk(pub_key)\n        key_data = json.loads(key_data_str)\n\n        # TODO Should `to_jwk` set these?\n        key_data[\"alg\"] = \"RS256\"\n        key_data[\"use\"] = \"sig\"\n        key_data[\"kid\"] = \"keyid-abc123\"\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"RSA\"\n        assert jwk.key_id == \"keyid-abc123\"\n        assert jwk.public_key_use == \"sig\"\n\n    @crypto_required\n    def test_should_load_key_from_jwk_data_json_string(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            pub_key = algo.from_jwk(keyfile.read())\n\n        key_data_str = algo.to_jwk(pub_key)\n        key_data = json.loads(key_data_str)\n\n        # TODO Should `to_jwk` set these?\n        key_data[\"alg\"] = \"RS256\"\n        key_data[\"use\"] = \"sig\"\n        key_data[\"kid\"] = \"keyid-abc123\"\n\n        jwk = PyJWK.from_json(json.dumps(key_data))\n\n        assert jwk.key_type == \"RSA\"\n        assert jwk.key_id == \"keyid-abc123\"\n        assert jwk.public_key_use == \"sig\"\n\n    @crypto_required\n    def test_should_load_key_without_alg_from_dict(self):\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"RSA\"\n        assert isinstance(jwk.Algorithm, RSAAlgorithm)\n        assert jwk.Algorithm.hash_alg == RSAAlgorithm.SHA256\n        assert jwk.algorithm_name == \"RS256\"\n\n    @crypto_required\n    def test_should_load_key_from_dict_with_algorithm(self):\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data, algorithm=\"RS256\")\n\n        assert jwk.key_type == \"RSA\"\n        assert isinstance(jwk.Algorithm, RSAAlgorithm)\n        assert jwk.Algorithm.hash_alg == RSAAlgorithm.SHA256\n        assert jwk.algorithm_name == \"RS256\"\n\n    @crypto_required\n    def test_should_load_key_ec_p256_from_dict(self):\n        with open(key_path(\"jwk_ec_pub_P-256.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"EC\"\n        assert isinstance(jwk.Algorithm, ECAlgorithm)\n        assert jwk.Algorithm.hash_alg == ECAlgorithm.SHA256\n        assert jwk.algorithm_name == \"ES256\"\n\n    @crypto_required\n    def test_should_load_key_ec_p384_from_dict(self):\n        with open(key_path(\"jwk_ec_pub_P-384.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"EC\"\n        assert isinstance(jwk.Algorithm, ECAlgorithm)\n        assert jwk.Algorithm.hash_alg == ECAlgorithm.SHA384\n        assert jwk.algorithm_name == \"ES384\"\n\n    @crypto_required\n    def test_should_load_key_ec_p521_from_dict(self):\n        with open(key_path(\"jwk_ec_pub_P-521.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"EC\"\n        assert isinstance(jwk.Algorithm, ECAlgorithm)\n        assert jwk.Algorithm.hash_alg == ECAlgorithm.SHA512\n        assert jwk.algorithm_name == \"ES512\"\n\n    @crypto_required\n    def test_should_load_key_ec_secp256k1_from_dict(self):\n        with open(key_path(\"jwk_ec_pub_secp256k1.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"EC\"\n        assert isinstance(jwk.Algorithm, ECAlgorithm)\n        assert jwk.Algorithm.hash_alg == ECAlgorithm.SHA256\n        assert jwk.algorithm_name == \"ES256K\"\n\n    @crypto_required\n    def test_should_load_key_hmac_from_dict(self):\n        with open(key_path(\"jwk_hmac.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"oct\"\n        assert isinstance(jwk.Algorithm, HMACAlgorithm)\n        assert jwk.Algorithm.hash_alg == HMACAlgorithm.SHA256\n        assert jwk.algorithm_name == \"HS256\"\n\n    @crypto_required\n    def test_should_load_key_hmac_without_alg_from_dict(self):\n        with open(key_path(\"jwk_hmac.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        del key_data[\"alg\"]\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"oct\"\n        assert isinstance(jwk.Algorithm, HMACAlgorithm)\n        assert jwk.Algorithm.hash_alg == HMACAlgorithm.SHA256\n        assert jwk.algorithm_name == \"HS256\"\n\n    @crypto_required\n    def test_should_load_key_okp_without_alg_from_dict(self):\n        with open(key_path(\"jwk_okp_pub_Ed25519.json\")) as keyfile:\n            key_data = json.loads(keyfile.read())\n\n        jwk = PyJWK.from_dict(key_data)\n\n        assert jwk.key_type == \"OKP\"\n        assert isinstance(jwk.Algorithm, OKPAlgorithm)\n        assert jwk.algorithm_name == \"EdDSA\"\n\n    @crypto_required\n    def test_from_dict_should_throw_exception_if_arg_is_invalid(self):\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            valid_rsa_pub = json.loads(keyfile.read())\n        with open(key_path(\"jwk_ec_pub_P-256.json\")) as keyfile:\n            valid_ec_pub = json.loads(keyfile.read())\n        with open(key_path(\"jwk_okp_pub_Ed25519.json\")) as keyfile:\n            valid_okp_pub = json.loads(keyfile.read())\n\n        # Unknown algorithm\n        with pytest.raises(PyJWKError):\n            PyJWK.from_dict(valid_rsa_pub, algorithm=\"unknown\")\n\n        # Missing kty\n        v = valid_rsa_pub.copy()\n        del v[\"kty\"]\n        with pytest.raises(InvalidKeyError):\n            PyJWK.from_dict(v)\n\n        # Unknown kty\n        v = valid_rsa_pub.copy()\n        v[\"kty\"] = \"unknown\"\n        with pytest.raises(InvalidKeyError):\n            PyJWK.from_dict(v)\n\n        # Unknown EC crv\n        v = valid_ec_pub.copy()\n        v[\"crv\"] = \"unknown\"\n        with pytest.raises(InvalidKeyError):\n            PyJWK.from_dict(v)\n\n        # Unknown OKP crv\n        v = valid_okp_pub.copy()\n        v[\"crv\"] = \"unknown\"\n        with pytest.raises(InvalidKeyError):\n            PyJWK.from_dict(v)\n\n        # Missing OKP crv\n        v = valid_okp_pub.copy()\n        del v[\"crv\"]\n        with pytest.raises(InvalidKeyError):\n            PyJWK.from_dict(v)\n\n    @no_crypto_required\n    def test_missing_crypto_library_good_error_message(self):\n        with pytest.raises(PyJWKError) as exc:\n            PyJWK({\"kty\": \"dummy\"}, algorithm=\"RS256\")\n            assert \"cryptography\" in str(exc.value)\n\n\n@crypto_required\nclass TestPyJWKSet:\n    def test_should_load_keys_from_jwk_data_dict(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            pub_key = algo.from_jwk(keyfile.read())\n\n        key_data_str = algo.to_jwk(pub_key)\n        key_data = json.loads(key_data_str)\n\n        # TODO Should `to_jwk` set these?\n        key_data[\"alg\"] = \"RS256\"\n        key_data[\"use\"] = \"sig\"\n        key_data[\"kid\"] = \"keyid-abc123\"\n\n        jwk_set = PyJWKSet.from_dict({\"keys\": [key_data]})\n        jwk = jwk_set.keys[0]\n\n        assert jwk.key_type == \"RSA\"\n        assert jwk.key_id == \"keyid-abc123\"\n        assert jwk.public_key_use == \"sig\"\n\n    def test_should_load_keys_from_jwk_data_json_string(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            pub_key = algo.from_jwk(keyfile.read())\n\n        key_data_str = algo.to_jwk(pub_key)\n        key_data = json.loads(key_data_str)\n\n        # TODO Should `to_jwk` set these?\n        key_data[\"alg\"] = \"RS256\"\n        key_data[\"use\"] = \"sig\"\n        key_data[\"kid\"] = \"keyid-abc123\"\n\n        jwk_set = PyJWKSet.from_json(json.dumps({\"keys\": [key_data]}))\n        jwk = jwk_set.keys[0]\n\n        assert jwk.key_type == \"RSA\"\n        assert jwk.key_id == \"keyid-abc123\"\n        assert jwk.public_key_use == \"sig\"\n\n    def test_keyset_should_index_by_kid(self):\n        algo = RSAAlgorithm(RSAAlgorithm.SHA256)\n\n        with open(key_path(\"jwk_rsa_pub.json\")) as keyfile:\n            pub_key = algo.from_jwk(keyfile.read())\n\n        key_data_str = algo.to_jwk(pub_key)\n        key_data = json.loads(key_data_str)\n\n        # TODO Should `to_jwk` set these?\n        key_data[\"alg\"] = \"RS256\"\n        key_data[\"use\"] = \"sig\"\n        key_data[\"kid\"] = \"keyid-abc123\"\n\n        jwk_set = PyJWKSet.from_dict({\"keys\": [key_data]})\n\n        jwk = jwk_set.keys[0]\n        assert jwk == jwk_set[\"keyid-abc123\"]\n\n        with pytest.raises(KeyError):\n            _ = jwk_set[\"this-kid-does-not-exist\"]\n\n    def test_keyset_with_unknown_alg(self):\n        # first keyset with unusable key and usable key\n        with open(key_path(\"jwk_keyset_with_unknown_alg.json\")) as keyfile:\n            jwks_text = keyfile.read()\n        jwks = json.loads(jwks_text)\n        assert len(jwks.get(\"keys\")) == 2\n        keyset = PyJWKSet.from_json(jwks_text)\n        assert len(keyset.keys) == 1\n\n        # second keyset with only unusable key -> catch exception\n        with open(key_path(\"jwk_keyset_only_unknown_alg.json\")) as keyfile:\n            jwks_text = keyfile.read()\n            jwks = json.loads(jwks_text)\n            assert len(jwks.get(\"keys\")) == 1\n            with pytest.raises(PyJWKSetError):\n                _ = PyJWKSet.from_json(jwks_text)\n\n    def test_invalid_keys_list(self):\n        with pytest.raises(PyJWKSetError) as err:\n            PyJWKSet(keys=\"string\")  # type: ignore\n        assert str(err.value) == \"Invalid JWK Set value\"\n\n    def test_empty_keys_list(self):\n        with pytest.raises(PyJWKSetError) as err:\n            PyJWKSet(keys=[])\n        assert str(err.value) == \"The JWK Set did not contain any keys\"\n", "tests/test_api_jwt.py": "import json\nimport time\nfrom calendar import timegm\nfrom datetime import datetime, timedelta, timezone\nfrom decimal import Decimal\n\nimport pytest\n\nfrom jwt.api_jwt import PyJWT\nfrom jwt.exceptions import (\n    DecodeError,\n    ExpiredSignatureError,\n    ImmatureSignatureError,\n    InvalidAudienceError,\n    InvalidIssuedAtError,\n    InvalidIssuerError,\n    MissingRequiredClaimError,\n)\nfrom jwt.utils import base64url_decode\nfrom jwt.warnings import RemovedInPyjwt3Warning\n\nfrom .utils import crypto_required, key_path, utc_timestamp\n\n\n@pytest.fixture\ndef jwt():\n    return PyJWT()\n\n\n@pytest.fixture\ndef payload():\n    \"\"\"Creates a sample JWT claimset for use as a payload during tests\"\"\"\n    return {\"iss\": \"jeff\", \"exp\": utc_timestamp() + 15, \"claim\": \"insanity\"}\n\n\nclass TestJWT:\n    def test_decodes_valid_jwt(self, jwt):\n        example_payload = {\"hello\": \"world\"}\n        example_secret = \"secret\"\n        example_jwt = (\n            b\"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            b\".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            b\".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        decoded_payload = jwt.decode(example_jwt, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded_payload == example_payload\n\n    def test_decodes_complete_valid_jwt(self, jwt):\n        example_payload = {\"hello\": \"world\"}\n        example_secret = \"secret\"\n        example_jwt = (\n            b\"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            b\".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            b\".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n        decoded = jwt.decode_complete(example_jwt, example_secret, algorithms=[\"HS256\"])\n\n        assert decoded == {\n            \"header\": {\"alg\": \"HS256\", \"typ\": \"JWT\"},\n            \"payload\": example_payload,\n            \"signature\": (\n                b'\\xb6\\xf6\\xa0,2\\xe8j\"J\\xc4\\xe2\\xaa\\xa4\\x15\\xd2'\n                b\"\\x10l\\xbbI\\x84\\xa2}\\x98c\\x9e\\xd8&\\xf5\\xcbi\\xca?\"\n            ),\n        }\n\n    def test_load_verify_valid_jwt(self, jwt):\n        example_payload = {\"hello\": \"world\"}\n        example_secret = \"secret\"\n        example_jwt = (\n            b\"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            b\".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            b\".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        decoded_payload = jwt.decode(\n            example_jwt, key=example_secret, algorithms=[\"HS256\"]\n        )\n\n        assert decoded_payload == example_payload\n\n    def test_decode_invalid_payload_string(self, jwt):\n        example_jwt = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.aGVsb\"\n            \"G8gd29ybGQ.SIr03zM64awWRdPrAM_61QWsZchAtgDV\"\n            \"3pphfHPPWkI\"\n        )\n        example_secret = \"secret\"\n\n        with pytest.raises(DecodeError) as exc:\n            jwt.decode(example_jwt, example_secret, algorithms=[\"HS256\"])\n\n        assert \"Invalid payload string\" in str(exc.value)\n\n    def test_decode_with_non_mapping_payload_throws_exception(self, jwt):\n        secret = \"secret\"\n        example_jwt = (\n            \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            \"MQ.\"  # == 1\n            \"AbcSR3DWum91KOgfKxUHm78rLs_DrrZ1CrDgpUFFzls\"\n        )\n\n        with pytest.raises(DecodeError) as context:\n            jwt.decode(example_jwt, secret, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"Invalid payload string: must be a json object\"\n\n    def test_decode_with_invalid_audience_param_throws_exception(self, jwt):\n        secret = \"secret\"\n        example_jwt = (\n            \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9\"\n            \".eyJoZWxsbyI6ICJ3b3JsZCJ9\"\n            \".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\"\n        )\n\n        with pytest.raises(TypeError) as context:\n            jwt.decode(example_jwt, secret, audience=1, algorithms=[\"HS256\"])\n\n        exception = context.value\n        assert str(exception) == \"audience must be a string, iterable or None\"\n\n    def test_decode_with_nonlist_aud_claim_throws_exception(self, jwt):\n        secret = \"secret\"\n        example_jwt = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n            \".eyJoZWxsbyI6IndvcmxkIiwiYXVkIjoxfQ\"  # aud = 1\n            \".Rof08LBSwbm8Z_bhA2N3DFY-utZR1Gi9rbIS5Zthnnc\"\n        )\n\n        with pytest.raises(InvalidAudienceError) as context:\n            jwt.decode(\n                example_jwt,\n                secret,\n                audience=\"my_audience\",\n                algorithms=[\"HS256\"],\n            )\n\n        exception = context.value\n        assert str(exception) == \"Invalid claim format in token\"\n\n    def test_decode_with_invalid_aud_list_member_throws_exception(self, jwt):\n        secret = \"secret\"\n        example_jwt = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n            \".eyJoZWxsbyI6IndvcmxkIiwiYXVkIjpbMV19\"\n            \".iQgKpJ8shetwNMIosNXWBPFB057c2BHs-8t1d2CCM2A\"\n        )\n\n        with pytest.raises(InvalidAudienceError) as context:\n            jwt.decode(\n                example_jwt,\n                secret,\n                audience=\"my_audience\",\n                algorithms=[\"HS256\"],\n            )\n\n        exception = context.value\n        assert str(exception) == \"Invalid claim format in token\"\n\n    def test_encode_bad_type(self, jwt):\n        types = [\"string\", tuple(), list(), 42, set()]\n\n        for t in types:\n            pytest.raises(\n                TypeError,\n                lambda: jwt.encode(t, \"secret\", algorithms=[\"HS256\"]),\n            )\n\n    def test_encode_with_typ(self, jwt):\n        payload = {\n            \"iss\": \"https://scim.example.com\",\n            \"iat\": 1458496404,\n            \"jti\": \"4d3559ec67504aaba65d40b0363faad8\",\n            \"aud\": [\n                \"https://scim.example.com/Feeds/98d52461fa5bbc879593b7754\",\n                \"https://scim.example.com/Feeds/5d7604516b1d08641d7676ee7\",\n            ],\n            \"events\": {\n                \"urn:ietf:params:scim:event:create\": {\n                    \"ref\": \"https://scim.example.com/Users/44f6142df96bd6ab61e7521d9\",\n                    \"attributes\": [\"id\", \"name\", \"userName\", \"password\", \"emails\"],\n                }\n            },\n        }\n        token = jwt.encode(\n            payload, \"secret\", algorithm=\"HS256\", headers={\"typ\": \"secevent+jwt\"}\n        )\n        header = token[0 : token.index(\".\")].encode()\n        header = base64url_decode(header)\n        header_obj = json.loads(header)\n\n        assert \"typ\" in header_obj\n        assert header_obj[\"typ\"] == \"secevent+jwt\"\n\n    def test_decode_raises_exception_if_exp_is_not_int(self, jwt):\n        # >>> jwt.encode({'exp': 'not-an-int'}, 'secret')\n        example_jwt = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            \"eyJleHAiOiJub3QtYW4taW50In0.\"\n            \"P65iYgoHtBqB07PMtBSuKNUEIPPPfmjfJG217cEE66s\"\n        )\n\n        with pytest.raises(DecodeError) as exc:\n            jwt.decode(example_jwt, \"secret\", algorithms=[\"HS256\"])\n\n        assert \"exp\" in str(exc.value)\n\n    def test_decode_raises_exception_if_iat_is_not_int(self, jwt):\n        # >>> jwt.encode({'iat': 'not-an-int'}, 'secret')\n        example_jwt = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            \"eyJpYXQiOiJub3QtYW4taW50In0.\"\n            \"H1GmcQgSySa5LOKYbzGm--b1OmRbHFkyk8pq811FzZM\"\n        )\n\n        with pytest.raises(InvalidIssuedAtError):\n            jwt.decode(example_jwt, \"secret\", algorithms=[\"HS256\"])\n\n    def test_decode_raises_exception_if_iat_is_greater_than_now(self, jwt, payload):\n        payload[\"iat\"] = utc_timestamp() + 10\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.raises(ImmatureSignatureError):\n            jwt.decode(jwt_message, secret, algorithms=[\"HS256\"])\n\n    def test_decode_works_if_iat_is_str_of_a_number(self, jwt, payload):\n        payload[\"iat\"] = \"1638202770\"\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n        data = jwt.decode(jwt_message, secret, algorithms=[\"HS256\"])\n        assert data[\"iat\"] == \"1638202770\"\n\n    def test_decode_raises_exception_if_nbf_is_not_int(self, jwt):\n        # >>> jwt.encode({'nbf': 'not-an-int'}, 'secret')\n        example_jwt = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            \"eyJuYmYiOiJub3QtYW4taW50In0.\"\n            \"c25hldC8G2ZamC8uKpax9sYMTgdZo3cxrmzFHaAAluw\"\n        )\n\n        with pytest.raises(DecodeError):\n            jwt.decode(example_jwt, \"secret\", algorithms=[\"HS256\"])\n\n    def test_decode_raises_exception_if_aud_is_none(self, jwt):\n        # >>> jwt.encode({'aud': None}, 'secret')\n        example_jwt = (\n            \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\"\n            \"eyJhdWQiOm51bGx9.\"\n            \"-Peqc-pTugGvrc5C8Bnl0-X1V_5fv-aVb_7y7nGBVvQ\"\n        )\n        decoded = jwt.decode(example_jwt, \"secret\", algorithms=[\"HS256\"])\n        assert decoded[\"aud\"] is None\n\n    def test_encode_datetime(self, jwt):\n        secret = \"secret\"\n        current_datetime = datetime.now(tz=timezone.utc)\n        payload = {\n            \"exp\": current_datetime,\n            \"iat\": current_datetime,\n            \"nbf\": current_datetime,\n        }\n        jwt_message = jwt.encode(payload, secret)\n        decoded_payload = jwt.decode(\n            jwt_message, secret, leeway=1, algorithms=[\"HS256\"]\n        )\n\n        assert decoded_payload[\"exp\"] == timegm(current_datetime.utctimetuple())\n        assert decoded_payload[\"iat\"] == timegm(current_datetime.utctimetuple())\n        assert decoded_payload[\"nbf\"] == timegm(current_datetime.utctimetuple())\n        # payload is not mutated.\n        assert payload == {\n            \"exp\": current_datetime,\n            \"iat\": current_datetime,\n            \"nbf\": current_datetime,\n        }\n\n    # 'Control' Elliptic Curve JWT created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_es256_jwt(self, jwt):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_ec.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jwt = (\n            b\"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.\"\n            b\"eyJoZWxsbyI6IndvcmxkIn0.TORyNQab_MoXM7DvNKaTwbrJr4UY\"\n            b\"d2SsX8hhlnWelQFmPFSf_JzC2EbLnar92t-bXsDovzxp25ExazrVHkfPkQ\"\n        )\n\n        decoded_payload = jwt.decode(example_jwt, example_pubkey, algorithms=[\"ES256\"])\n        assert decoded_payload == example_payload\n\n    # 'Control' RSA JWT created by another library.\n    # Used to test for regressions that could affect both\n    # encoding / decoding operations equally (causing tests\n    # to still pass).\n    @crypto_required\n    def test_decodes_valid_rs384_jwt(self, jwt):\n        example_payload = {\"hello\": \"world\"}\n        with open(key_path(\"testkey_rsa.pub\")) as fp:\n            example_pubkey = fp.read()\n        example_jwt = (\n            b\"eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9\"\n            b\".eyJoZWxsbyI6IndvcmxkIn0\"\n            b\".yNQ3nI9vEDs7lEh-Cp81McPuiQ4ZRv6FL4evTYYAh1X\"\n            b\"lRTTR3Cz8pPA9Stgso8Ra9xGB4X3rlra1c8Jz10nTUju\"\n            b\"O06OMm7oXdrnxp1KIiAJDerWHkQ7l3dlizIk1bmMA457\"\n            b\"W2fNzNfHViuED5ISM081dgf_a71qBwJ_yShMMrSOfxDx\"\n            b\"mX9c4DjRogRJG8SM5PvpLqI_Cm9iQPGMvmYK7gzcq2cJ\"\n            b\"urHRJDJHTqIdpLWXkY7zVikeen6FhuGyn060Dz9gYq9t\"\n            b\"uwmrtSWCBUjiN8sqJ00CDgycxKqHfUndZbEAOjcCAhBr\"\n            b\"qWW3mSVivUfubsYbwUdUG3fSRPjaUPcpe8A\"\n        )\n        decoded_payload = jwt.decode(example_jwt, example_pubkey, algorithms=[\"RS384\"])\n\n        assert decoded_payload == example_payload\n\n    def test_decode_with_expiration(self, jwt, payload):\n        payload[\"exp\"] = utc_timestamp() - 1\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.raises(ExpiredSignatureError):\n            jwt.decode(jwt_message, secret, algorithms=[\"HS256\"])\n\n    def test_decode_with_notbefore(self, jwt, payload):\n        payload[\"nbf\"] = utc_timestamp() + 10\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.raises(ImmatureSignatureError):\n            jwt.decode(jwt_message, secret, algorithms=[\"HS256\"])\n\n    def test_decode_skip_expiration_verification(self, jwt, payload):\n        payload[\"exp\"] = time.time() - 1\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        jwt.decode(\n            jwt_message,\n            secret,\n            algorithms=[\"HS256\"],\n            options={\"verify_exp\": False},\n        )\n\n    def test_decode_skip_notbefore_verification(self, jwt, payload):\n        payload[\"nbf\"] = time.time() + 10\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        jwt.decode(\n            jwt_message,\n            secret,\n            algorithms=[\"HS256\"],\n            options={\"verify_nbf\": False},\n        )\n\n    def test_decode_with_expiration_with_leeway(self, jwt, payload):\n        payload[\"exp\"] = utc_timestamp() - 2\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        # With 5 seconds leeway, should be ok\n        for leeway in (5, timedelta(seconds=5)):\n            decoded = jwt.decode(\n                jwt_message, secret, leeway=leeway, algorithms=[\"HS256\"]\n            )\n            assert decoded == payload\n\n        # With 1 seconds, should fail\n        for leeway in (1, timedelta(seconds=1)):\n            with pytest.raises(ExpiredSignatureError):\n                jwt.decode(jwt_message, secret, leeway=leeway, algorithms=[\"HS256\"])\n\n    def test_decode_with_notbefore_with_leeway(self, jwt, payload):\n        payload[\"nbf\"] = utc_timestamp() + 10\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        # With 13 seconds leeway, should be ok\n        jwt.decode(jwt_message, secret, leeway=13, algorithms=[\"HS256\"])\n\n        with pytest.raises(ImmatureSignatureError):\n            jwt.decode(jwt_message, secret, leeway=1, algorithms=[\"HS256\"])\n\n    def test_check_audience_when_valid(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": \"urn:me\"}\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(token, \"secret\", audience=\"urn:me\", algorithms=[\"HS256\"])\n\n    def test_check_audience_list_when_valid(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": \"urn:me\"}\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(\n            token,\n            \"secret\",\n            audience=[\"urn:you\", \"urn:me\"],\n            algorithms=[\"HS256\"],\n        )\n\n    def test_check_audience_none_specified(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": \"urn:me\"}\n        token = jwt.encode(payload, \"secret\")\n        with pytest.raises(InvalidAudienceError):\n            jwt.decode(token, \"secret\", algorithms=[\"HS256\"])\n\n    def test_raise_exception_invalid_audience_list(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": \"urn:me\"}\n        token = jwt.encode(payload, \"secret\")\n        with pytest.raises(InvalidAudienceError):\n            jwt.decode(\n                token,\n                \"secret\",\n                audience=[\"urn:you\", \"urn:him\"],\n                algorithms=[\"HS256\"],\n            )\n\n    def test_check_audience_in_array_when_valid(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": [\"urn:me\", \"urn:someone-else\"]}\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(token, \"secret\", audience=\"urn:me\", algorithms=[\"HS256\"])\n\n    def test_raise_exception_invalid_audience(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": \"urn:someone-else\"}\n\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(InvalidAudienceError):\n            jwt.decode(token, \"secret\", audience=\"urn-me\", algorithms=[\"HS256\"])\n\n    def test_raise_exception_audience_as_bytes(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": [\"urn:me\", \"urn:someone-else\"]}\n        token = jwt.encode(payload, \"secret\")\n        with pytest.raises(InvalidAudienceError):\n            jwt.decode(token, \"secret\", audience=b\"urn:me\", algorithms=[\"HS256\"])\n\n    def test_raise_exception_invalid_audience_in_array(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            \"aud\": [\"urn:someone\", \"urn:someone-else\"],\n        }\n\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(InvalidAudienceError):\n            jwt.decode(token, \"secret\", audience=\"urn:me\", algorithms=[\"HS256\"])\n\n    def test_raise_exception_token_without_issuer(self, jwt):\n        issuer = \"urn:wrong\"\n\n        payload = {\"some\": \"payload\"}\n\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(MissingRequiredClaimError) as exc:\n            jwt.decode(token, \"secret\", issuer=issuer, algorithms=[\"HS256\"])\n\n        assert exc.value.claim == \"iss\"\n\n    def test_raise_exception_token_without_audience(self, jwt):\n        payload = {\"some\": \"payload\"}\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(MissingRequiredClaimError) as exc:\n            jwt.decode(token, \"secret\", audience=\"urn:me\", algorithms=[\"HS256\"])\n\n        assert exc.value.claim == \"aud\"\n\n    def test_raise_exception_token_with_aud_none_and_without_audience(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": None}\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(MissingRequiredClaimError) as exc:\n            jwt.decode(token, \"secret\", audience=\"urn:me\", algorithms=[\"HS256\"])\n\n        assert exc.value.claim == \"aud\"\n\n    def test_check_issuer_when_valid(self, jwt):\n        issuer = \"urn:foo\"\n        payload = {\"some\": \"payload\", \"iss\": \"urn:foo\"}\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(token, \"secret\", issuer=issuer, algorithms=[\"HS256\"])\n\n    def test_check_issuer_list_when_valid(self, jwt):\n        issuer = [\"urn:foo\", \"urn:bar\"]\n        payload = {\"some\": \"payload\", \"iss\": \"urn:foo\"}\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(token, \"secret\", issuer=issuer, algorithms=[\"HS256\"])\n\n    def test_raise_exception_invalid_issuer(self, jwt):\n        issuer = \"urn:wrong\"\n\n        payload = {\"some\": \"payload\", \"iss\": \"urn:foo\"}\n\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(InvalidIssuerError):\n            jwt.decode(token, \"secret\", issuer=issuer, algorithms=[\"HS256\"])\n\n    def test_raise_exception_invalid_issuer_list(self, jwt):\n        issuer = [\"urn:wrong\", \"urn:bar\", \"urn:baz\"]\n\n        payload = {\"some\": \"payload\", \"iss\": \"urn:foo\"}\n\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(InvalidIssuerError):\n            jwt.decode(token, \"secret\", issuer=issuer, algorithms=[\"HS256\"])\n\n    def test_skip_check_audience(self, jwt):\n        payload = {\"some\": \"payload\", \"aud\": \"urn:me\"}\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(\n            token,\n            \"secret\",\n            options={\"verify_aud\": False},\n            algorithms=[\"HS256\"],\n        )\n\n    def test_skip_check_exp(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            \"exp\": datetime.now(tz=timezone.utc) - timedelta(days=1),\n        }\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(\n            token,\n            \"secret\",\n            options={\"verify_exp\": False},\n            algorithms=[\"HS256\"],\n        )\n\n    def test_decode_should_raise_error_if_exp_required_but_not_present(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            # exp not present\n        }\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(MissingRequiredClaimError) as exc:\n            jwt.decode(\n                token,\n                \"secret\",\n                options={\"require\": [\"exp\"]},\n                algorithms=[\"HS256\"],\n            )\n\n        assert exc.value.claim == \"exp\"\n\n    def test_decode_should_raise_error_if_iat_required_but_not_present(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            # iat not present\n        }\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(MissingRequiredClaimError) as exc:\n            jwt.decode(\n                token,\n                \"secret\",\n                options={\"require\": [\"iat\"]},\n                algorithms=[\"HS256\"],\n            )\n\n        assert exc.value.claim == \"iat\"\n\n    def test_decode_should_raise_error_if_nbf_required_but_not_present(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            # nbf not present\n        }\n        token = jwt.encode(payload, \"secret\")\n\n        with pytest.raises(MissingRequiredClaimError) as exc:\n            jwt.decode(\n                token,\n                \"secret\",\n                options={\"require\": [\"nbf\"]},\n                algorithms=[\"HS256\"],\n            )\n\n        assert exc.value.claim == \"nbf\"\n\n    def test_skip_check_signature(self, jwt):\n        token = (\n            \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n            \".eyJzb21lIjoicGF5bG9hZCJ9\"\n            \".4twFt5NiznN84AWoo1d7KO1T_yoc0Z6XOpOVswacPZA\"\n        )\n        jwt.decode(\n            token,\n            \"secret\",\n            options={\"verify_signature\": False},\n            algorithms=[\"HS256\"],\n        )\n\n    def test_skip_check_iat(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            \"iat\": datetime.now(tz=timezone.utc) + timedelta(days=1),\n        }\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(\n            token,\n            \"secret\",\n            options={\"verify_iat\": False},\n            algorithms=[\"HS256\"],\n        )\n\n    def test_skip_check_nbf(self, jwt):\n        payload = {\n            \"some\": \"payload\",\n            \"nbf\": datetime.now(tz=timezone.utc) + timedelta(days=1),\n        }\n        token = jwt.encode(payload, \"secret\")\n        jwt.decode(\n            token,\n            \"secret\",\n            options={\"verify_nbf\": False},\n            algorithms=[\"HS256\"],\n        )\n\n    def test_custom_json_encoder(self, jwt):\n        class CustomJSONEncoder(json.JSONEncoder):\n            def default(self, o):\n                if isinstance(o, Decimal):\n                    return \"it worked\"\n                return super().default(o)\n\n        data = {\"some_decimal\": Decimal(\"2.2\")}\n\n        with pytest.raises(TypeError):\n            jwt.encode(data, \"secret\", algorithms=[\"HS256\"])\n\n        token = jwt.encode(data, \"secret\", json_encoder=CustomJSONEncoder)\n        payload = jwt.decode(token, \"secret\", algorithms=[\"HS256\"])\n\n        assert payload == {\"some_decimal\": \"it worked\"}\n\n    def test_decode_with_verify_exp_option(self, jwt, payload):\n        payload[\"exp\"] = utc_timestamp() - 1\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        jwt.decode(\n            jwt_message,\n            secret,\n            algorithms=[\"HS256\"],\n            options={\"verify_exp\": False},\n        )\n\n        with pytest.raises(ExpiredSignatureError):\n            jwt.decode(\n                jwt_message,\n                secret,\n                algorithms=[\"HS256\"],\n                options={\"verify_exp\": True},\n            )\n\n    def test_decode_with_verify_exp_option_and_signature_off(self, jwt, payload):\n        payload[\"exp\"] = utc_timestamp() - 1\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        jwt.decode(\n            jwt_message,\n            options={\"verify_signature\": False},\n        )\n\n        with pytest.raises(ExpiredSignatureError):\n            jwt.decode(\n                jwt_message,\n                options={\"verify_signature\": False, \"verify_exp\": True},\n            )\n\n    def test_decode_with_optional_algorithms(self, jwt, payload):\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.raises(DecodeError) as exc:\n            jwt.decode(jwt_message, secret)\n\n        assert (\n            'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            in str(exc.value)\n        )\n\n    def test_decode_no_algorithms_verify_signature_false(self, jwt, payload):\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        jwt.decode(jwt_message, secret, options={\"verify_signature\": False})\n\n    def test_decode_legacy_verify_warning(self, jwt, payload):\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.deprecated_call():\n            # The implicit default for options.verify_signature is True,\n            # but the user sets verify to False.\n            jwt.decode(jwt_message, secret, verify=False, algorithms=[\"HS256\"])\n\n        with pytest.deprecated_call():\n            # The user explicitly sets verify=True,\n            # but contradicts it in verify_signature.\n            jwt.decode(\n                jwt_message, secret, verify=True, options={\"verify_signature\": False}\n            )\n\n    def test_decode_no_options_mutation(self, jwt, payload):\n        options = {\"verify_signature\": True}\n        orig_options = options.copy()\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n        jwt.decode(jwt_message, secret, options=options, algorithms=[\"HS256\"])\n        assert options == orig_options\n\n    def test_decode_warns_on_unsupported_kwarg(self, jwt, payload):\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jwt.decode(jwt_message, secret, algorithms=[\"HS256\"], foo=\"bar\")\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)\n\n    def test_decode_complete_warns_on_unsupported_kwarg(self, jwt, payload):\n        secret = \"secret\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.warns(RemovedInPyjwt3Warning) as record:\n            jwt.decode_complete(jwt_message, secret, algorithms=[\"HS256\"], foo=\"bar\")\n        assert len(record) == 1\n        assert \"foo\" in str(record[0].message)\n\n    def test_decode_strict_aud_forbids_list_audience(self, jwt, payload):\n        secret = \"secret\"\n        payload[\"aud\"] = \"urn:foo\"\n        jwt_message = jwt.encode(payload, secret)\n\n        # Decodes without `strict_aud`.\n        jwt.decode(\n            jwt_message,\n            secret,\n            audience=[\"urn:foo\", \"urn:bar\"],\n            options={\"strict_aud\": False},\n            algorithms=[\"HS256\"],\n        )\n\n        # Fails with `strict_aud`.\n        with pytest.raises(InvalidAudienceError, match=r\"Invalid audience \\(strict\\)\"):\n            jwt.decode(\n                jwt_message,\n                secret,\n                audience=[\"urn:foo\", \"urn:bar\"],\n                options={\"strict_aud\": True},\n                algorithms=[\"HS256\"],\n            )\n\n    def test_decode_strict_aud_forbids_list_claim(self, jwt, payload):\n        secret = \"secret\"\n        payload[\"aud\"] = [\"urn:foo\", \"urn:bar\"]\n        jwt_message = jwt.encode(payload, secret)\n\n        # Decodes without `strict_aud`.\n        jwt.decode(\n            jwt_message,\n            secret,\n            audience=\"urn:foo\",\n            options={\"strict_aud\": False},\n            algorithms=[\"HS256\"],\n        )\n\n        # Fails with `strict_aud`.\n        with pytest.raises(\n            InvalidAudienceError, match=r\"Invalid claim format in token \\(strict\\)\"\n        ):\n            jwt.decode(\n                jwt_message,\n                secret,\n                audience=\"urn:foo\",\n                options={\"strict_aud\": True},\n                algorithms=[\"HS256\"],\n            )\n\n    def test_decode_strict_aud_does_not_match(self, jwt, payload):\n        secret = \"secret\"\n        payload[\"aud\"] = \"urn:foo\"\n        jwt_message = jwt.encode(payload, secret)\n\n        with pytest.raises(\n            InvalidAudienceError, match=r\"Audience doesn't match \\(strict\\)\"\n        ):\n            jwt.decode(\n                jwt_message,\n                secret,\n                audience=\"urn:bar\",\n                options={\"strict_aud\": True},\n                algorithms=[\"HS256\"],\n            )\n\n    def test_decode_strict_ok(self, jwt, payload):\n        secret = \"secret\"\n        payload[\"aud\"] = \"urn:foo\"\n        jwt_message = jwt.encode(payload, secret)\n\n        jwt.decode(\n            jwt_message,\n            secret,\n            audience=\"urn:foo\",\n            options={\"strict_aud\": True},\n            algorithms=[\"HS256\"],\n        )\n", "tests/test_advisory.py": "import pytest\n\nimport jwt\nfrom jwt.algorithms import get_default_algorithms\nfrom jwt.exceptions import InvalidKeyError\n\nfrom .utils import crypto_required\n\npriv_key_bytes = b\"\"\"-----BEGIN PRIVATE KEY-----\nMC4CAQAwBQYDK2VwBCIEIIbBhdo2ah7X32i50GOzrCr4acZTe6BezUdRIixjTAdL\n-----END PRIVATE KEY-----\"\"\"\n\npub_key_bytes = (\n    b\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPL1I9oiq+B8crkmuV4YViiUnhdLjCp3hvy1bNGuGfNL\"\n)\n\nssh_priv_key_bytes = b\"\"\"-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIOWc7RbaNswMtNtc+n6WZDlUblMr2FBPo79fcGXsJlGQoAoGCCqGSM49\nAwEHoUQDQgAElcy2RSSSgn2RA/xCGko79N+7FwoLZr3Z0ij/ENjow2XpUDwwKEKk\nAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\n-----END EC PRIVATE KEY-----\"\"\"\n\nssh_key_bytes = b\"\"\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJXMtkUkkoJ9kQP8QhpKO/TfuxcKC2a92dIo/xDY6MNl6VA8MChCpAJN0w1wvVPJ4qTJRnGO7A6V6dl8oRxDPkc=\"\"\"\n\n\nclass TestAdvisory:\n    @crypto_required\n    def test_ghsa_ffqj_6fqr_9h24(self):\n        # Generate ed25519 private key\n        # private_key = ed25519.Ed25519PrivateKey.generate()\n\n        # Get private key bytes as they would be stored in a file\n        # priv_key_bytes = private_key.private_bytes(\n        #     encoding=serialization.Encoding.PEM,\n        #     format=serialization.PrivateFormat.PKCS8,\n        #     encryption_algorithm=serialization.NoEncryption(),\n        # )\n\n        # Get public key bytes as they would be stored in a file\n        # pub_key_bytes = private_key.public_key().public_bytes(\n        #     encoding=serialization.Encoding.OpenSSH,\n        #     format=serialization.PublicFormat.OpenSSH,\n        # )\n\n        # Making a good jwt token that should work by signing it\n        # with the private key\n        # encoded_good = jwt.encode({\"test\": 1234}, priv_key_bytes, algorithm=\"EdDSA\")\n        encoded_good = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSJ9.eyJ0ZXN0IjoxMjM0fQ.M5y1EEavZkHSlj9i8yi9nXKKyPBSAUhDRTOYZi3zZY11tZItDaR3qwAye8pc74_lZY3Ogt9KPNFbVOSGnUBHDg\"\n\n        # Using HMAC with the public key to trick the receiver to think that the\n        # public key is a HMAC secret\n        encoded_bad = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ.6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4\"\n\n        algorithm_names = list(get_default_algorithms())\n\n        # Both of the jwt tokens are validated as valid\n        jwt.decode(\n            encoded_good,\n            pub_key_bytes,\n            algorithms=algorithm_names,\n        )\n\n        with pytest.raises(InvalidKeyError):\n            jwt.decode(\n                encoded_bad,\n                pub_key_bytes,\n                algorithms=algorithm_names,\n            )\n\n        # Of course the receiver should specify ed25519 algorithm to be used if\n        # they specify ed25519 public key. However, if other algorithms are used,\n        # the POC does not work\n        # HMAC specifies illegal strings for the HMAC secret in jwt/algorithms.py\n        #\n        #        invalid_str ings = [\n        #            b\"-----BEGIN PUBLIC KEY-----\",\n        #            b\"-----BEGIN CERTIFICATE-----\",\n        #            b\"-----BEGIN RSA PUBLIC KEY-----\",\n        #            b\"ssh-rsa\",\n        #        ]\n        #\n        # However, OKPAlgorithm (ed25519) accepts the following in  jwt/algorithms.py:\n        #\n        #                if \"-----BEGIN PUBLIC\" in str_key:\n        #                    return load_pem_public_key(key)\n        #                if \"-----BEGIN PRIVATE\" in str_key:\n        #                    return load_pem_private_key(key, password=None)\n        #                if str_key[0:4] == \"ssh-\":\n        #                    return load_ssh_public_key(key)\n        #\n        # These should most likely made to match each other to prevent this behavior\n\n        # POC for the ecdsa-sha2-nistp256 format.\n        # openssl ecparam -genkey -name prime256v1 -noout -out ec256-key-priv.pem\n        # openssl ec -in ec256-key-priv.pem -pubout > ec256-key-pub.pem\n        # ssh-keygen -y -f ec256-key-priv.pem > ec256-key-ssh.pub\n\n        # Making a good jwt token that should work by signing it with the private key\n        # encoded_good = jwt.encode({\"test\": 1234}, ssh_priv_key_bytes, algorithm=\"ES256\")\n        encoded_good = \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoxMjM0fQ.NX42mS8cNqYoL3FOW9ZcKw8Nfq2mb6GqJVADeMA1-kyHAclilYo_edhdM_5eav9tBRQTlL0XMeu_WFE_mz3OXg\"\n\n        # Using HMAC with the ssh public key to trick the receiver to think that the public key is a HMAC secret\n        # encoded_bad = jwt.encode({\"test\": 1234}, ssh_key_bytes, algorithm=\"HS256\")\n        encoded_bad = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoxMjM0fQ.5eYfbrbeGYmWfypQ6rMWXNZ8bdHcqKng5GPr9MJZITU\"\n\n        algorithm_names = list(get_default_algorithms())\n        # Both of the jwt tokens are validated as valid\n        jwt.decode(\n            encoded_good,\n            ssh_key_bytes,\n            algorithms=algorithm_names,\n        )\n\n        with pytest.raises(InvalidKeyError):\n            jwt.decode(\n                encoded_bad,\n                ssh_key_bytes,\n                algorithms=algorithm_names,\n            )\n", "tests/test_utils.py": "import pytest\n\nfrom jwt.utils import force_bytes, from_base64url_uint, is_ssh_key, to_base64url_uint\n\n\n@pytest.mark.parametrize(\n    \"inputval,expected\",\n    [\n        (0, b\"AA\"),\n        (1, b\"AQ\"),\n        (255, b\"_w\"),\n        (65537, b\"AQAB\"),\n        (123456789, b\"B1vNFQ\"),\n        pytest.param(-1, \"\", marks=pytest.mark.xfail(raises=ValueError)),\n    ],\n)\ndef test_to_base64url_uint(inputval, expected):\n    actual = to_base64url_uint(inputval)\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\n    \"inputval,expected\",\n    [\n        (b\"AA\", 0),\n        (b\"AQ\", 1),\n        (b\"_w\", 255),\n        (b\"AQAB\", 65537),\n        (b\"B1vNFQ\", 123456789),\n    ],\n)\ndef test_from_base64url_uint(inputval, expected):\n    actual = from_base64url_uint(inputval)\n    assert actual == expected\n\n\ndef test_force_bytes_raises_error_on_invalid_object():\n    with pytest.raises(TypeError):\n        force_bytes({})  # type: ignore[arg-type]\n\n\n@pytest.mark.parametrize(\n    \"key_format\",\n    (\n        b\"ssh-ed25519\",\n        b\"ssh-rsa\",\n        b\"ssh-dss\",\n        b\"ecdsa-sha2-nistp256\",\n        b\"ecdsa-sha2-nistp384\",\n        b\"ecdsa-sha2-nistp521\",\n    ),\n)\ndef test_is_ssh_key(key_format):\n    assert is_ssh_key(key_format + b\" any\") is True\n    assert is_ssh_key(b\"not a ssh key\") is False\n", "tests/keys/__init__.py": "import json\nimport os\n\nfrom jwt.algorithms import has_crypto\nfrom jwt.utils import base64url_decode\n\ntry:\n    from cryptography.hazmat.primitives.asymmetric import ec\nexcept ModuleNotFoundError:\n    pass\n\nif has_crypto:\n    from jwt.algorithms import RSAAlgorithm\n\nBASE_PATH = os.path.dirname(os.path.abspath(__file__))\n\n\ndef decode_value(val):\n    decoded = base64url_decode(val)\n    return int.from_bytes(decoded, byteorder=\"big\")\n\n\ndef load_hmac_key():\n    with open(os.path.join(BASE_PATH, \"jwk_hmac.json\")) as infile:\n        keyobj = json.load(infile)\n\n    return base64url_decode(keyobj[\"k\"])\n\n\ndef load_rsa_key():\n    with open(os.path.join(BASE_PATH, \"jwk_rsa_key.json\")) as infile:\n        return RSAAlgorithm.from_jwk(infile.read())\n\n\ndef load_rsa_pub_key():\n    with open(os.path.join(BASE_PATH, \"jwk_rsa_pub.json\")) as infile:\n        return RSAAlgorithm.from_jwk(infile.read())\n\n\ndef load_ec_key():\n    with open(os.path.join(BASE_PATH, \"jwk_ec_key.json\")) as infile:\n        keyobj = json.load(infile)\n\n    return ec.EllipticCurvePrivateNumbers(\n        private_value=decode_value(keyobj[\"d\"]),\n        public_numbers=load_ec_pub_key_p_521().public_numbers(),\n    )\n\n\ndef load_ec_pub_key_p_521():\n    with open(os.path.join(BASE_PATH, \"jwk_ec_pub_P-521.json\")) as infile:\n        keyobj = json.load(infile)\n\n    return ec.EllipticCurvePublicNumbers(\n        x=decode_value(keyobj[\"x\"]),\n        y=decode_value(keyobj[\"y\"]),\n        curve=ec.SECP521R1(),\n    ).public_key()\n"}