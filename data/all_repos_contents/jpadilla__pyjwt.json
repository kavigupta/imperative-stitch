{"setup.py": "#!/usr/bin/env python3\n\nfrom setuptools import setup\n\nsetup()\n", "jwt/exceptions.py": "class PyJWTError(Exception):\n    \"\"\"\n    Base class for all exceptions\n    \"\"\"\n\n    pass\n\n\nclass InvalidTokenError(PyJWTError):\n    pass\n\n\nclass DecodeError(InvalidTokenError):\n    pass\n\n\nclass InvalidSignatureError(DecodeError):\n    pass\n\n\nclass ExpiredSignatureError(InvalidTokenError):\n    pass\n\n\nclass InvalidAudienceError(InvalidTokenError):\n    pass\n\n\nclass InvalidIssuerError(InvalidTokenError):\n    pass\n\n\nclass InvalidIssuedAtError(InvalidTokenError):\n    pass\n\n\nclass ImmatureSignatureError(InvalidTokenError):\n    pass\n\n\nclass InvalidKeyError(PyJWTError):\n    pass\n\n\nclass InvalidAlgorithmError(InvalidTokenError):\n    pass\n\n\nclass MissingRequiredClaimError(InvalidTokenError):\n    def __init__(self, claim: str) -> None:\n        self.claim = claim\n\n    def __str__(self) -> str:\n        return f'Token is missing the \"{self.claim}\" claim'\n\n\nclass PyJWKError(PyJWTError):\n    pass\n\n\nclass PyJWKSetError(PyJWTError):\n    pass\n\n\nclass PyJWKClientError(PyJWTError):\n    pass\n\n\nclass PyJWKClientConnectionError(PyJWKClientError):\n    pass\n", "jwt/algorithms.py": "from __future__ import annotations\n\nimport hashlib\nimport hmac\nimport json\nfrom abc import ABC, abstractmethod\nfrom typing import TYPE_CHECKING, Any, ClassVar, Literal, NoReturn, cast, overload\n\nfrom .exceptions import InvalidKeyError\nfrom .types import HashlibHash, JWKDict\nfrom .utils import (\n    base64url_decode,\n    base64url_encode,\n    der_to_raw_signature,\n    force_bytes,\n    from_base64url_uint,\n    is_pem_format,\n    is_ssh_key,\n    raw_to_der_signature,\n    to_base64url_uint,\n)\n\ntry:\n    from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm\n    from cryptography.hazmat.backends import default_backend\n    from cryptography.hazmat.primitives import hashes\n    from cryptography.hazmat.primitives.asymmetric import padding\n    from cryptography.hazmat.primitives.asymmetric.ec import (\n        ECDSA,\n        SECP256K1,\n        SECP256R1,\n        SECP384R1,\n        SECP521R1,\n        EllipticCurve,\n        EllipticCurvePrivateKey,\n        EllipticCurvePrivateNumbers,\n        EllipticCurvePublicKey,\n        EllipticCurvePublicNumbers,\n    )\n    from cryptography.hazmat.primitives.asymmetric.ed448 import (\n        Ed448PrivateKey,\n        Ed448PublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.ed25519 import (\n        Ed25519PrivateKey,\n        Ed25519PublicKey,\n    )\n    from cryptography.hazmat.primitives.asymmetric.rsa import (\n        RSAPrivateKey,\n        RSAPrivateNumbers,\n        RSAPublicKey,\n        RSAPublicNumbers,\n        rsa_crt_dmp1,\n        rsa_crt_dmq1,\n        rsa_crt_iqmp,\n        rsa_recover_prime_factors,\n    )\n    from cryptography.hazmat.primitives.serialization import (\n        Encoding,\n        NoEncryption,\n        PrivateFormat,\n        PublicFormat,\n        load_pem_private_key,\n        load_pem_public_key,\n        load_ssh_public_key,\n    )\n\n    has_crypto = True\nexcept ModuleNotFoundError:\n    has_crypto = False\n\n\nif TYPE_CHECKING:\n    # Type aliases for convenience in algorithms method signatures\n    AllowedRSAKeys = RSAPrivateKey | RSAPublicKey\n    AllowedECKeys = EllipticCurvePrivateKey | EllipticCurvePublicKey\n    AllowedOKPKeys = (\n        Ed25519PrivateKey | Ed25519PublicKey | Ed448PrivateKey | Ed448PublicKey\n    )\n    AllowedKeys = AllowedRSAKeys | AllowedECKeys | AllowedOKPKeys\n    AllowedPrivateKeys = (\n        RSAPrivateKey | EllipticCurvePrivateKey | Ed25519PrivateKey | Ed448PrivateKey\n    )\n    AllowedPublicKeys = (\n        RSAPublicKey | EllipticCurvePublicKey | Ed25519PublicKey | Ed448PublicKey\n    )\n\n\nrequires_cryptography = {\n    \"RS256\",\n    \"RS384\",\n    \"RS512\",\n    \"ES256\",\n    \"ES256K\",\n    \"ES384\",\n    \"ES521\",\n    \"ES512\",\n    \"PS256\",\n    \"PS384\",\n    \"PS512\",\n    \"EdDSA\",\n}\n\n\ndef get_default_algorithms() -> dict[str, Algorithm]:\n    \"\"\"\n    Returns the algorithms that are implemented by the library.\n    \"\"\"\n    default_algorithms = {\n        \"none\": NoneAlgorithm(),\n        \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),\n        \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),\n        \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),\n    }\n\n    if has_crypto:\n        default_algorithms.update(\n            {\n                \"RS256\": RSAAlgorithm(RSAAlgorithm.SHA256),\n                \"RS384\": RSAAlgorithm(RSAAlgorithm.SHA384),\n                \"RS512\": RSAAlgorithm(RSAAlgorithm.SHA512),\n                \"ES256\": ECAlgorithm(ECAlgorithm.SHA256),\n                \"ES256K\": ECAlgorithm(ECAlgorithm.SHA256),\n                \"ES384\": ECAlgorithm(ECAlgorithm.SHA384),\n                \"ES521\": ECAlgorithm(ECAlgorithm.SHA512),\n                \"ES512\": ECAlgorithm(\n                    ECAlgorithm.SHA512\n                ),  # Backward compat for #219 fix\n                \"PS256\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),\n                \"PS384\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),\n                \"PS512\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),\n                \"EdDSA\": OKPAlgorithm(),\n            }\n        )\n\n    return default_algorithms\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    The interface for an algorithm used to sign and verify tokens.\n    \"\"\"\n\n    def compute_hash_digest(self, bytestr: bytes) -> bytes:\n        \"\"\"\n        Compute a hash digest using the specified algorithm's hash algorithm.\n\n        If there is no hash algorithm, raises a NotImplementedError.\n        \"\"\"\n        # lookup self.hash_alg if defined in a way that mypy can understand\n        hash_alg = getattr(self, \"hash_alg\", None)\n        if hash_alg is None:\n            raise NotImplementedError\n\n        if (\n            has_crypto\n            and isinstance(hash_alg, type)\n            and issubclass(hash_alg, hashes.HashAlgorithm)\n        ):\n            digest = hashes.Hash(hash_alg(), backend=default_backend())\n            digest.update(bytestr)\n            return bytes(digest.finalize())\n        else:\n            return bytes(hash_alg(bytestr).digest())\n\n    @abstractmethod\n    def prepare_key(self, key: Any) -> Any:\n        \"\"\"\n        Performs necessary validation and conversions on the key and returns\n        the key value in the proper format for sign() and verify().\n        \"\"\"\n\n    @abstractmethod\n    def sign(self, msg: bytes, key: Any) -> bytes:\n        \"\"\"\n        Returns a digital signature for the specified message\n        using the specified key value.\n        \"\"\"\n\n    @abstractmethod\n    def verify(self, msg: bytes, key: Any, sig: bytes) -> bool:\n        \"\"\"\n        Verifies that the specified digital signature is valid\n        for the specified message and key values.\n        \"\"\"\n\n    @overload\n    @staticmethod\n    @abstractmethod\n    def to_jwk(key_obj, as_dict: Literal[True]) -> JWKDict: ...  # pragma: no cover\n\n    @overload\n    @staticmethod\n    @abstractmethod\n    def to_jwk(key_obj, as_dict: Literal[False] = False) -> str: ...  # pragma: no cover\n\n    @staticmethod\n    @abstractmethod\n    def to_jwk(key_obj, as_dict: bool = False) -> JWKDict | str:\n        \"\"\"\n        Serializes a given key into a JWK\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def from_jwk(jwk: str | JWKDict) -> Any:\n        \"\"\"\n        Deserializes a given key from JWK back into a key object\n        \"\"\"\n\n\nclass NoneAlgorithm(Algorithm):\n    \"\"\"\n    Placeholder for use when no signing or verification\n    operations are required.\n    \"\"\"\n\n    def prepare_key(self, key: str | None) -> None:\n        if key == \"\":\n            key = None\n\n        if key is not None:\n            raise InvalidKeyError('When alg = \"none\", key value must be None.')\n\n        return key\n\n    def sign(self, msg: bytes, key: None) -> bytes:\n        return b\"\"\n\n    def verify(self, msg: bytes, key: None, sig: bytes) -> bool:\n        return False\n\n    @staticmethod\n    def to_jwk(key_obj: Any, as_dict: bool = False) -> NoReturn:\n        raise NotImplementedError()\n\n    @staticmethod\n    def from_jwk(jwk: str | JWKDict) -> NoReturn:\n        raise NotImplementedError()\n\n\nclass HMACAlgorithm(Algorithm):\n    \"\"\"\n    Performs signing and verification operations using HMAC\n    and the specified hash function.\n    \"\"\"\n\n    SHA256: ClassVar[HashlibHash] = hashlib.sha256\n    SHA384: ClassVar[HashlibHash] = hashlib.sha384\n    SHA512: ClassVar[HashlibHash] = hashlib.sha512\n\n    def __init__(self, hash_alg: HashlibHash) -> None:\n        self.hash_alg = hash_alg\n\n    def prepare_key(self, key: str | bytes) -> bytes:\n        key_bytes = force_bytes(key)\n\n        if is_pem_format(key_bytes) or is_ssh_key(key_bytes):\n            raise InvalidKeyError(\n                \"The specified key is an asymmetric key or x509 certificate and\"\n                \" should not be used as an HMAC secret.\"\n            )\n\n        return key_bytes\n\n    @overload\n    @staticmethod\n    def to_jwk(\n        key_obj: str | bytes, as_dict: Literal[True]\n    ) -> JWKDict: ...  # pragma: no cover\n\n    @overload\n    @staticmethod\n    def to_jwk(\n        key_obj: str | bytes, as_dict: Literal[False] = False\n    ) -> str: ...  # pragma: no cover\n\n    @staticmethod\n    def to_jwk(key_obj: str | bytes, as_dict: bool = False) -> JWKDict | str:\n        jwk = {\n            \"k\": base64url_encode(force_bytes(key_obj)).decode(),\n            \"kty\": \"oct\",\n        }\n\n        if as_dict:\n            return jwk\n        else:\n            return json.dumps(jwk)\n\n    @staticmethod\n    def from_jwk(jwk: str | JWKDict) -> bytes:\n        try:\n            if isinstance(jwk, str):\n                obj: JWKDict = json.loads(jwk)\n            elif isinstance(jwk, dict):\n                obj = jwk\n            else:\n                raise ValueError\n        except ValueError:\n            raise InvalidKeyError(\"Key is not valid JSON\")\n\n        if obj.get(\"kty\") != \"oct\":\n            raise InvalidKeyError(\"Not an HMAC key\")\n\n        return base64url_decode(obj[\"k\"])\n\n    def sign(self, msg: bytes, key: bytes) -> bytes:\n        return hmac.new(key, msg, self.hash_alg).digest()\n\n    def verify(self, msg: bytes, key: bytes, sig: bytes) -> bool:\n        return hmac.compare_digest(sig, self.sign(msg, key))\n\n\nif has_crypto:\n\n    class RSAAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using\n        RSASSA-PKCS-v1_5 and the specified hash function.\n        \"\"\"\n\n        SHA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256\n        SHA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384\n        SHA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512\n\n        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:\n            self.hash_alg = hash_alg\n\n        def prepare_key(self, key: AllowedRSAKeys | str | bytes) -> AllowedRSAKeys:\n            if isinstance(key, (RSAPrivateKey, RSAPublicKey)):\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            try:\n                if key_bytes.startswith(b\"ssh-rsa\"):\n                    return cast(RSAPublicKey, load_ssh_public_key(key_bytes))\n                else:\n                    return cast(\n                        RSAPrivateKey, load_pem_private_key(key_bytes, password=None)\n                    )\n            except ValueError:\n                try:\n                    return cast(RSAPublicKey, load_pem_public_key(key_bytes))\n                except (ValueError, UnsupportedAlgorithm):\n                    raise InvalidKeyError(\"Could not parse the provided public key.\")\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedRSAKeys, as_dict: Literal[True]\n        ) -> JWKDict: ...  # pragma: no cover\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedRSAKeys, as_dict: Literal[False] = False\n        ) -> str: ...  # pragma: no cover\n\n        @staticmethod\n        def to_jwk(key_obj: AllowedRSAKeys, as_dict: bool = False) -> JWKDict | str:\n            obj: dict[str, Any] | None = None\n\n            if hasattr(key_obj, \"private_numbers\"):\n                # Private key\n                numbers = key_obj.private_numbers()\n\n                obj = {\n                    \"kty\": \"RSA\",\n                    \"key_ops\": [\"sign\"],\n                    \"n\": to_base64url_uint(numbers.public_numbers.n).decode(),\n                    \"e\": to_base64url_uint(numbers.public_numbers.e).decode(),\n                    \"d\": to_base64url_uint(numbers.d).decode(),\n                    \"p\": to_base64url_uint(numbers.p).decode(),\n                    \"q\": to_base64url_uint(numbers.q).decode(),\n                    \"dp\": to_base64url_uint(numbers.dmp1).decode(),\n                    \"dq\": to_base64url_uint(numbers.dmq1).decode(),\n                    \"qi\": to_base64url_uint(numbers.iqmp).decode(),\n                }\n\n            elif hasattr(key_obj, \"verify\"):\n                # Public key\n                numbers = key_obj.public_numbers()\n\n                obj = {\n                    \"kty\": \"RSA\",\n                    \"key_ops\": [\"verify\"],\n                    \"n\": to_base64url_uint(numbers.n).decode(),\n                    \"e\": to_base64url_uint(numbers.e).decode(),\n                }\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n            if as_dict:\n                return obj\n            else:\n                return json.dumps(obj)\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedRSAKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\")\n\n            if obj.get(\"kty\") != \"RSA\":\n                raise InvalidKeyError(\"Not an RSA key\")\n\n            if \"d\" in obj and \"e\" in obj and \"n\" in obj:\n                # Private key\n                if \"oth\" in obj:\n                    raise InvalidKeyError(\n                        \"Unsupported RSA private key: > 2 primes not supported\"\n                    )\n\n                other_props = [\"p\", \"q\", \"dp\", \"dq\", \"qi\"]\n                props_found = [prop in obj for prop in other_props]\n                any_props_found = any(props_found)\n\n                if any_props_found and not all(props_found):\n                    raise InvalidKeyError(\n                        \"RSA key must include all parameters if any are present besides d\"\n                    )\n\n                public_numbers = RSAPublicNumbers(\n                    from_base64url_uint(obj[\"e\"]),\n                    from_base64url_uint(obj[\"n\"]),\n                )\n\n                if any_props_found:\n                    numbers = RSAPrivateNumbers(\n                        d=from_base64url_uint(obj[\"d\"]),\n                        p=from_base64url_uint(obj[\"p\"]),\n                        q=from_base64url_uint(obj[\"q\"]),\n                        dmp1=from_base64url_uint(obj[\"dp\"]),\n                        dmq1=from_base64url_uint(obj[\"dq\"]),\n                        iqmp=from_base64url_uint(obj[\"qi\"]),\n                        public_numbers=public_numbers,\n                    )\n                else:\n                    d = from_base64url_uint(obj[\"d\"])\n                    p, q = rsa_recover_prime_factors(\n                        public_numbers.n, d, public_numbers.e\n                    )\n\n                    numbers = RSAPrivateNumbers(\n                        d=d,\n                        p=p,\n                        q=q,\n                        dmp1=rsa_crt_dmp1(d, p),\n                        dmq1=rsa_crt_dmq1(d, q),\n                        iqmp=rsa_crt_iqmp(p, q),\n                        public_numbers=public_numbers,\n                    )\n\n                return numbers.private_key()\n            elif \"n\" in obj and \"e\" in obj:\n                # Public key\n                return RSAPublicNumbers(\n                    from_base64url_uint(obj[\"e\"]),\n                    from_base64url_uint(obj[\"n\"]),\n                ).public_key()\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n        def sign(self, msg: bytes, key: RSAPrivateKey) -> bytes:\n            return key.sign(msg, padding.PKCS1v15(), self.hash_alg())\n\n        def verify(self, msg: bytes, key: RSAPublicKey, sig: bytes) -> bool:\n            try:\n                key.verify(sig, msg, padding.PKCS1v15(), self.hash_alg())\n                return True\n            except InvalidSignature:\n                return False\n\n    class ECAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using\n        ECDSA and the specified hash function\n        \"\"\"\n\n        SHA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256\n        SHA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384\n        SHA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512\n\n        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:\n            self.hash_alg = hash_alg\n\n        def prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:\n            if isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):\n                return key\n\n            if not isinstance(key, (bytes, str)):\n                raise TypeError(\"Expecting a PEM-formatted key.\")\n\n            key_bytes = force_bytes(key)\n\n            # Attempt to load key. We don't know if it's\n            # a Signing Key or a Verifying Key, so we try\n            # the Verifying Key first.\n            try:\n                if key_bytes.startswith(b\"ecdsa-sha2-\"):\n                    crypto_key = load_ssh_public_key(key_bytes)\n                else:\n                    crypto_key = load_pem_public_key(key_bytes)  # type: ignore[assignment]\n            except ValueError:\n                crypto_key = load_pem_private_key(key_bytes, password=None)  # type: ignore[assignment]\n\n            # Explicit check the key to prevent confusing errors from cryptography\n            if not isinstance(\n                crypto_key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)\n            ):\n                raise InvalidKeyError(\n                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for ECDSA algorithms\"\n                )\n\n            return crypto_key\n\n        def sign(self, msg: bytes, key: EllipticCurvePrivateKey) -> bytes:\n            der_sig = key.sign(msg, ECDSA(self.hash_alg()))\n\n            return der_to_raw_signature(der_sig, key.curve)\n\n        def verify(self, msg: bytes, key: AllowedECKeys, sig: bytes) -> bool:\n            try:\n                der_sig = raw_to_der_signature(sig, key.curve)\n            except ValueError:\n                return False\n\n            try:\n                public_key = (\n                    key.public_key()\n                    if isinstance(key, EllipticCurvePrivateKey)\n                    else key\n                )\n                public_key.verify(der_sig, msg, ECDSA(self.hash_alg()))\n                return True\n            except InvalidSignature:\n                return False\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedECKeys, as_dict: Literal[True]\n        ) -> JWKDict: ...  # pragma: no cover\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key_obj: AllowedECKeys, as_dict: Literal[False] = False\n        ) -> str: ...  # pragma: no cover\n\n        @staticmethod\n        def to_jwk(key_obj: AllowedECKeys, as_dict: bool = False) -> JWKDict | str:\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                public_numbers = key_obj.public_key().public_numbers()\n            elif isinstance(key_obj, EllipticCurvePublicKey):\n                public_numbers = key_obj.public_numbers()\n            else:\n                raise InvalidKeyError(\"Not a public or private key\")\n\n            if isinstance(key_obj.curve, SECP256R1):\n                crv = \"P-256\"\n            elif isinstance(key_obj.curve, SECP384R1):\n                crv = \"P-384\"\n            elif isinstance(key_obj.curve, SECP521R1):\n                crv = \"P-521\"\n            elif isinstance(key_obj.curve, SECP256K1):\n                crv = \"secp256k1\"\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {key_obj.curve}\")\n\n            obj: dict[str, Any] = {\n                \"kty\": \"EC\",\n                \"crv\": crv,\n                \"x\": to_base64url_uint(public_numbers.x).decode(),\n                \"y\": to_base64url_uint(public_numbers.y).decode(),\n            }\n\n            if isinstance(key_obj, EllipticCurvePrivateKey):\n                obj[\"d\"] = to_base64url_uint(\n                    key_obj.private_numbers().private_value\n                ).decode()\n\n            if as_dict:\n                return obj\n            else:\n                return json.dumps(obj)\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedECKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\")\n\n            if obj.get(\"kty\") != \"EC\":\n                raise InvalidKeyError(\"Not an Elliptic curve key\")\n\n            if \"x\" not in obj or \"y\" not in obj:\n                raise InvalidKeyError(\"Not an Elliptic curve key\")\n\n            x = base64url_decode(obj.get(\"x\"))\n            y = base64url_decode(obj.get(\"y\"))\n\n            curve = obj.get(\"crv\")\n            curve_obj: EllipticCurve\n\n            if curve == \"P-256\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256R1()\n                else:\n                    raise InvalidKeyError(\"Coords should be 32 bytes for curve P-256\")\n            elif curve == \"P-384\":\n                if len(x) == len(y) == 48:\n                    curve_obj = SECP384R1()\n                else:\n                    raise InvalidKeyError(\"Coords should be 48 bytes for curve P-384\")\n            elif curve == \"P-521\":\n                if len(x) == len(y) == 66:\n                    curve_obj = SECP521R1()\n                else:\n                    raise InvalidKeyError(\"Coords should be 66 bytes for curve P-521\")\n            elif curve == \"secp256k1\":\n                if len(x) == len(y) == 32:\n                    curve_obj = SECP256K1()\n                else:\n                    raise InvalidKeyError(\n                        \"Coords should be 32 bytes for curve secp256k1\"\n                    )\n            else:\n                raise InvalidKeyError(f\"Invalid curve: {curve}\")\n\n            public_numbers = EllipticCurvePublicNumbers(\n                x=int.from_bytes(x, byteorder=\"big\"),\n                y=int.from_bytes(y, byteorder=\"big\"),\n                curve=curve_obj,\n            )\n\n            if \"d\" not in obj:\n                return public_numbers.public_key()\n\n            d = base64url_decode(obj.get(\"d\"))\n            if len(d) != len(x):\n                raise InvalidKeyError(\n                    \"D should be {} bytes for curve {}\", len(x), curve\n                )\n\n            return EllipticCurvePrivateNumbers(\n                int.from_bytes(d, byteorder=\"big\"), public_numbers\n            ).private_key()\n\n    class RSAPSSAlgorithm(RSAAlgorithm):\n        \"\"\"\n        Performs a signature using RSASSA-PSS with MGF1\n        \"\"\"\n\n        def sign(self, msg: bytes, key: RSAPrivateKey) -> bytes:\n            return key.sign(\n                msg,\n                padding.PSS(\n                    mgf=padding.MGF1(self.hash_alg()),\n                    salt_length=self.hash_alg().digest_size,\n                ),\n                self.hash_alg(),\n            )\n\n        def verify(self, msg: bytes, key: RSAPublicKey, sig: bytes) -> bool:\n            try:\n                key.verify(\n                    sig,\n                    msg,\n                    padding.PSS(\n                        mgf=padding.MGF1(self.hash_alg()),\n                        salt_length=self.hash_alg().digest_size,\n                    ),\n                    self.hash_alg(),\n                )\n                return True\n            except InvalidSignature:\n                return False\n\n    class OKPAlgorithm(Algorithm):\n        \"\"\"\n        Performs signing and verification operations using EdDSA\n\n        This class requires ``cryptography>=2.6`` to be installed.\n        \"\"\"\n\n        def __init__(self, **kwargs: Any) -> None:\n            pass\n\n        def prepare_key(self, key: AllowedOKPKeys | str | bytes) -> AllowedOKPKeys:\n            if isinstance(key, (bytes, str)):\n                key_str = key.decode(\"utf-8\") if isinstance(key, bytes) else key\n                key_bytes = key.encode(\"utf-8\") if isinstance(key, str) else key\n\n                if \"-----BEGIN PUBLIC\" in key_str:\n                    key = load_pem_public_key(key_bytes)  # type: ignore[assignment]\n                elif \"-----BEGIN PRIVATE\" in key_str:\n                    key = load_pem_private_key(key_bytes, password=None)  # type: ignore[assignment]\n                elif key_str[0:4] == \"ssh-\":\n                    key = load_ssh_public_key(key_bytes)  # type: ignore[assignment]\n\n            # Explicit check the key to prevent confusing errors from cryptography\n            if not isinstance(\n                key,\n                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),\n            ):\n                raise InvalidKeyError(\n                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for EdDSA algorithms\"\n                )\n\n            return key\n\n        def sign(\n            self, msg: str | bytes, key: Ed25519PrivateKey | Ed448PrivateKey\n        ) -> bytes:\n            \"\"\"\n            Sign a message ``msg`` using the EdDSA private key ``key``\n            :param str|bytes msg: Message to sign\n            :param Ed25519PrivateKey}Ed448PrivateKey key: A :class:`.Ed25519PrivateKey`\n                or :class:`.Ed448PrivateKey` isinstance\n            :return bytes signature: The signature, as bytes\n            \"\"\"\n            msg_bytes = msg.encode(\"utf-8\") if isinstance(msg, str) else msg\n            return key.sign(msg_bytes)\n\n        def verify(\n            self, msg: str | bytes, key: AllowedOKPKeys, sig: str | bytes\n        ) -> bool:\n            \"\"\"\n            Verify a given ``msg`` against a signature ``sig`` using the EdDSA key ``key``\n\n            :param str|bytes sig: EdDSA signature to check ``msg`` against\n            :param str|bytes msg: Message to sign\n            :param Ed25519PrivateKey|Ed25519PublicKey|Ed448PrivateKey|Ed448PublicKey key:\n                A private or public EdDSA key instance\n            :return bool verified: True if signature is valid, False if not.\n            \"\"\"\n            try:\n                msg_bytes = msg.encode(\"utf-8\") if isinstance(msg, str) else msg\n                sig_bytes = sig.encode(\"utf-8\") if isinstance(sig, str) else sig\n\n                public_key = (\n                    key.public_key()\n                    if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey))\n                    else key\n                )\n                public_key.verify(sig_bytes, msg_bytes)\n                return True  # If no exception was raised, the signature is valid.\n            except InvalidSignature:\n                return False\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key: AllowedOKPKeys, as_dict: Literal[True]\n        ) -> JWKDict: ...  # pragma: no cover\n\n        @overload\n        @staticmethod\n        def to_jwk(\n            key: AllowedOKPKeys, as_dict: Literal[False] = False\n        ) -> str: ...  # pragma: no cover\n\n        @staticmethod\n        def to_jwk(key: AllowedOKPKeys, as_dict: bool = False) -> JWKDict | str:\n            if isinstance(key, (Ed25519PublicKey, Ed448PublicKey)):\n                x = key.public_bytes(\n                    encoding=Encoding.Raw,\n                    format=PublicFormat.Raw,\n                )\n                crv = \"Ed25519\" if isinstance(key, Ed25519PublicKey) else \"Ed448\"\n\n                obj = {\n                    \"x\": base64url_encode(force_bytes(x)).decode(),\n                    \"kty\": \"OKP\",\n                    \"crv\": crv,\n                }\n\n                if as_dict:\n                    return obj\n                else:\n                    return json.dumps(obj)\n\n            if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):\n                d = key.private_bytes(\n                    encoding=Encoding.Raw,\n                    format=PrivateFormat.Raw,\n                    encryption_algorithm=NoEncryption(),\n                )\n\n                x = key.public_key().public_bytes(\n                    encoding=Encoding.Raw,\n                    format=PublicFormat.Raw,\n                )\n\n                crv = \"Ed25519\" if isinstance(key, Ed25519PrivateKey) else \"Ed448\"\n                obj = {\n                    \"x\": base64url_encode(force_bytes(x)).decode(),\n                    \"d\": base64url_encode(force_bytes(d)).decode(),\n                    \"kty\": \"OKP\",\n                    \"crv\": crv,\n                }\n\n                if as_dict:\n                    return obj\n                else:\n                    return json.dumps(obj)\n\n            raise InvalidKeyError(\"Not a public or private key\")\n\n        @staticmethod\n        def from_jwk(jwk: str | JWKDict) -> AllowedOKPKeys:\n            try:\n                if isinstance(jwk, str):\n                    obj = json.loads(jwk)\n                elif isinstance(jwk, dict):\n                    obj = jwk\n                else:\n                    raise ValueError\n            except ValueError:\n                raise InvalidKeyError(\"Key is not valid JSON\")\n\n            if obj.get(\"kty\") != \"OKP\":\n                raise InvalidKeyError(\"Not an Octet Key Pair\")\n\n            curve = obj.get(\"crv\")\n            if curve != \"Ed25519\" and curve != \"Ed448\":\n                raise InvalidKeyError(f\"Invalid curve: {curve}\")\n\n            if \"x\" not in obj:\n                raise InvalidKeyError('OKP should have \"x\" parameter')\n            x = base64url_decode(obj.get(\"x\"))\n\n            try:\n                if \"d\" not in obj:\n                    if curve == \"Ed25519\":\n                        return Ed25519PublicKey.from_public_bytes(x)\n                    return Ed448PublicKey.from_public_bytes(x)\n                d = base64url_decode(obj.get(\"d\"))\n                if curve == \"Ed25519\":\n                    return Ed25519PrivateKey.from_private_bytes(d)\n                return Ed448PrivateKey.from_private_bytes(d)\n            except ValueError as err:\n                raise InvalidKeyError(\"Invalid key parameter\") from err\n", "jwt/utils.py": "import base64\nimport binascii\nimport re\nfrom typing import Union\n\ntry:\n    from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurve\n    from cryptography.hazmat.primitives.asymmetric.utils import (\n        decode_dss_signature,\n        encode_dss_signature,\n    )\nexcept ModuleNotFoundError:\n    pass\n\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    if isinstance(value, str):\n        return value.encode(\"utf-8\")\n    elif isinstance(value, bytes):\n        return value\n    else:\n        raise TypeError(\"Expected a string value\")\n\n\ndef base64url_decode(input: Union[bytes, str]) -> bytes:\n    input_bytes = force_bytes(input)\n\n    rem = len(input_bytes) % 4\n\n    if rem > 0:\n        input_bytes += b\"=\" * (4 - rem)\n\n    return base64.urlsafe_b64decode(input_bytes)\n\n\ndef base64url_encode(input: bytes) -> bytes:\n    return base64.urlsafe_b64encode(input).replace(b\"=\", b\"\")\n\n\ndef to_base64url_uint(val: int) -> bytes:\n    if val < 0:\n        raise ValueError(\"Must be a positive integer\")\n\n    int_bytes = bytes_from_int(val)\n\n    if len(int_bytes) == 0:\n        int_bytes = b\"\\x00\"\n\n    return base64url_encode(int_bytes)\n\n\ndef from_base64url_uint(val: Union[bytes, str]) -> int:\n    data = base64url_decode(force_bytes(val))\n    return int.from_bytes(data, byteorder=\"big\")\n\n\ndef number_to_bytes(num: int, num_bytes: int) -> bytes:\n    padded_hex = \"%0*x\" % (2 * num_bytes, num)\n    return binascii.a2b_hex(padded_hex.encode(\"ascii\"))\n\n\ndef bytes_to_number(string: bytes) -> int:\n    return int(binascii.b2a_hex(string), 16)\n\n\ndef bytes_from_int(val: int) -> bytes:\n    remaining = val\n    byte_length = 0\n\n    while remaining != 0:\n        remaining >>= 8\n        byte_length += 1\n\n    return val.to_bytes(byte_length, \"big\", signed=False)\n\n\ndef der_to_raw_signature(der_sig: bytes, curve: \"EllipticCurve\") -> bytes:\n    num_bits = curve.key_size\n    num_bytes = (num_bits + 7) // 8\n\n    r, s = decode_dss_signature(der_sig)\n\n    return number_to_bytes(r, num_bytes) + number_to_bytes(s, num_bytes)\n\n\ndef raw_to_der_signature(raw_sig: bytes, curve: \"EllipticCurve\") -> bytes:\n    num_bits = curve.key_size\n    num_bytes = (num_bits + 7) // 8\n\n    if len(raw_sig) != 2 * num_bytes:\n        raise ValueError(\"Invalid signature\")\n\n    r = bytes_to_number(raw_sig[:num_bytes])\n    s = bytes_to_number(raw_sig[num_bytes:])\n\n    return bytes(encode_dss_signature(r, s))\n\n\n# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252\n_PEMS = {\n    b\"CERTIFICATE\",\n    b\"TRUSTED CERTIFICATE\",\n    b\"PRIVATE KEY\",\n    b\"PUBLIC KEY\",\n    b\"ENCRYPTED PRIVATE KEY\",\n    b\"OPENSSH PRIVATE KEY\",\n    b\"DSA PRIVATE KEY\",\n    b\"RSA PRIVATE KEY\",\n    b\"RSA PUBLIC KEY\",\n    b\"EC PRIVATE KEY\",\n    b\"DH PARAMETERS\",\n    b\"NEW CERTIFICATE REQUEST\",\n    b\"CERTIFICATE REQUEST\",\n    b\"SSH2 PUBLIC KEY\",\n    b\"SSH2 ENCRYPTED PRIVATE KEY\",\n    b\"X509 CRL\",\n}\n\n_PEM_RE = re.compile(\n    b\"----[- ]BEGIN (\"\n    + b\"|\".join(_PEMS)\n    + b\"\"\")[- ]----\\r?\n.+?\\r?\n----[- ]END \\\\1[- ]----\\r?\\n?\"\"\",\n    re.DOTALL,\n)\n\n\ndef is_pem_format(key: bytes) -> bool:\n    return bool(_PEM_RE.search(key))\n\n\n# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46\n_SSH_KEY_FORMATS = (\n    b\"ssh-ed25519\",\n    b\"ssh-rsa\",\n    b\"ssh-dss\",\n    b\"ecdsa-sha2-nistp256\",\n    b\"ecdsa-sha2-nistp384\",\n    b\"ecdsa-sha2-nistp521\",\n)\n\n\ndef is_ssh_key(key: bytes) -> bool:\n    return key.startswith(_SSH_KEY_FORMATS)\n", "jwt/jwks_client.py": "import json\nimport urllib.request\nfrom functools import lru_cache\nfrom ssl import SSLContext\nfrom typing import Any, Dict, List, Optional\nfrom urllib.error import URLError\n\nfrom .api_jwk import PyJWK, PyJWKSet\nfrom .api_jwt import decode_complete as decode_token\nfrom .exceptions import PyJWKClientConnectionError, PyJWKClientError\nfrom .jwk_set_cache import JWKSetCache\n\n\nclass PyJWKClient:\n    def __init__(\n        self,\n        uri: str,\n        cache_keys: bool = False,\n        max_cached_keys: int = 16,\n        cache_jwk_set: bool = True,\n        lifespan: int = 300,\n        headers: Optional[Dict[str, Any]] = None,\n        timeout: int = 30,\n        ssl_context: Optional[SSLContext] = None,\n    ):\n        if headers is None:\n            headers = {}\n        self.uri = uri\n        self.jwk_set_cache: Optional[JWKSetCache] = None\n        self.headers = headers\n        self.timeout = timeout\n        self.ssl_context = ssl_context\n\n        if cache_jwk_set:\n            # Init jwt set cache with default or given lifespan.\n            # Default lifespan is 300 seconds (5 minutes).\n            if lifespan <= 0:\n                raise PyJWKClientError(\n                    f'Lifespan must be greater than 0, the input is \"{lifespan}\"'\n                )\n            self.jwk_set_cache = JWKSetCache(lifespan)\n        else:\n            self.jwk_set_cache = None\n\n        if cache_keys:\n            # Cache signing keys\n            # Ignore mypy (https://github.com/python/mypy/issues/2427)\n            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(self.get_signing_key)  # type: ignore\n\n    def fetch_data(self) -> Any:\n        jwk_set: Any = None\n        try:\n            r = urllib.request.Request(url=self.uri, headers=self.headers)\n            with urllib.request.urlopen(\n                r, timeout=self.timeout, context=self.ssl_context\n            ) as response:\n                jwk_set = json.load(response)\n        except (URLError, TimeoutError) as e:\n            raise PyJWKClientConnectionError(\n                f'Fail to fetch data from the url, err: \"{e}\"'\n            )\n        else:\n            return jwk_set\n        finally:\n            if self.jwk_set_cache is not None:\n                self.jwk_set_cache.put(jwk_set)\n\n    def get_jwk_set(self, refresh: bool = False) -> PyJWKSet:\n        data = None\n        if self.jwk_set_cache is not None and not refresh:\n            data = self.jwk_set_cache.get()\n\n        if data is None:\n            data = self.fetch_data()\n\n        if not isinstance(data, dict):\n            raise PyJWKClientError(\"The JWKS endpoint did not return a JSON object\")\n\n        return PyJWKSet.from_dict(data)\n\n    def get_signing_keys(self, refresh: bool = False) -> List[PyJWK]:\n        jwk_set = self.get_jwk_set(refresh)\n        signing_keys = [\n            jwk_set_key\n            for jwk_set_key in jwk_set.keys\n            if jwk_set_key.public_key_use in [\"sig\", None] and jwk_set_key.key_id\n        ]\n\n        if not signing_keys:\n            raise PyJWKClientError(\"The JWKS endpoint did not contain any signing keys\")\n\n        return signing_keys\n\n    def get_signing_key(self, kid: str) -> PyJWK:\n        signing_keys = self.get_signing_keys()\n        signing_key = self.match_kid(signing_keys, kid)\n\n        if not signing_key:\n            # If no matching signing key from the jwk set, refresh the jwk set and try again.\n            signing_keys = self.get_signing_keys(refresh=True)\n            signing_key = self.match_kid(signing_keys, kid)\n\n            if not signing_key:\n                raise PyJWKClientError(\n                    f'Unable to find a signing key that matches: \"{kid}\"'\n                )\n\n        return signing_key\n\n    def get_signing_key_from_jwt(self, token: str) -> PyJWK:\n        unverified = decode_token(token, options={\"verify_signature\": False})\n        header = unverified[\"header\"]\n        return self.get_signing_key(header.get(\"kid\"))\n\n    @staticmethod\n    def match_kid(signing_keys: List[PyJWK], kid: str) -> Optional[PyJWK]:\n        signing_key = None\n\n        for key in signing_keys:\n            if key.key_id == kid:\n                signing_key = key\n                break\n\n        return signing_key\n", "jwt/jwk_set_cache.py": "import time\nfrom typing import Optional\n\nfrom .api_jwk import PyJWKSet, PyJWTSetWithTimestamp\n\n\nclass JWKSetCache:\n    def __init__(self, lifespan: int) -> None:\n        self.jwk_set_with_timestamp: Optional[PyJWTSetWithTimestamp] = None\n        self.lifespan = lifespan\n\n    def put(self, jwk_set: PyJWKSet) -> None:\n        if jwk_set is not None:\n            self.jwk_set_with_timestamp = PyJWTSetWithTimestamp(jwk_set)\n        else:\n            # clear cache\n            self.jwk_set_with_timestamp = None\n\n    def get(self) -> Optional[PyJWKSet]:\n        if self.jwk_set_with_timestamp is None or self.is_expired():\n            return None\n\n        return self.jwk_set_with_timestamp.get_jwk_set()\n\n    def is_expired(self) -> bool:\n        return (\n            self.jwk_set_with_timestamp is not None\n            and self.lifespan > -1\n            and time.monotonic()\n            > self.jwk_set_with_timestamp.get_timestamp() + self.lifespan\n        )\n", "jwt/warnings.py": "class RemovedInPyjwt3Warning(DeprecationWarning):\n    pass\n", "jwt/types.py": "from typing import Any, Callable, Dict\n\nJWKDict = Dict[str, Any]\n\nHashlibHash = Callable[..., Any]\n", "jwt/api_jwt.py": "from __future__ import annotations\n\nimport json\nimport warnings\nfrom calendar import timegm\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta, timezone\nfrom typing import TYPE_CHECKING, Any, List\n\nfrom . import api_jws\nfrom .exceptions import (\n    DecodeError,\n    ExpiredSignatureError,\n    ImmatureSignatureError,\n    InvalidAudienceError,\n    InvalidIssuedAtError,\n    InvalidIssuerError,\n    MissingRequiredClaimError,\n)\nfrom .warnings import RemovedInPyjwt3Warning\n\nif TYPE_CHECKING:\n    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys\n    from .api_jwk import PyJWK\n\n\nclass PyJWT:\n    def __init__(self, options: dict[str, Any] | None = None) -> None:\n        if options is None:\n            options = {}\n        self.options: dict[str, Any] = {**self._get_default_options(), **options}\n\n    @staticmethod\n    def _get_default_options() -> dict[str, bool | list[str]]:\n        return {\n            \"verify_signature\": True,\n            \"verify_exp\": True,\n            \"verify_nbf\": True,\n            \"verify_iat\": True,\n            \"verify_aud\": True,\n            \"verify_iss\": True,\n            \"require\": [],\n        }\n\n    def encode(\n        self,\n        payload: dict[str, Any],\n        key: AllowedPrivateKeys | str | bytes,\n        algorithm: str | None = \"HS256\",\n        headers: dict[str, Any] | None = None,\n        json_encoder: type[json.JSONEncoder] | None = None,\n        sort_headers: bool = True,\n    ) -> str:\n        # Check that we get a dict\n        if not isinstance(payload, dict):\n            raise TypeError(\n                \"Expecting a dict object, as JWT only supports \"\n                \"JSON objects as payloads.\"\n            )\n\n        # Payload\n        payload = payload.copy()\n        for time_claim in [\"exp\", \"iat\", \"nbf\"]:\n            # Convert datetime to a intDate value in known time-format claims\n            if isinstance(payload.get(time_claim), datetime):\n                payload[time_claim] = timegm(payload[time_claim].utctimetuple())\n\n        json_payload = self._encode_payload(\n            payload,\n            headers=headers,\n            json_encoder=json_encoder,\n        )\n\n        return api_jws.encode(\n            json_payload,\n            key,\n            algorithm,\n            headers,\n            json_encoder,\n            sort_headers=sort_headers,\n        )\n\n    def _encode_payload(\n        self,\n        payload: dict[str, Any],\n        headers: dict[str, Any] | None = None,\n        json_encoder: type[json.JSONEncoder] | None = None,\n    ) -> bytes:\n        \"\"\"\n        Encode a given payload to the bytes to be signed.\n\n        This method is intended to be overridden by subclasses that need to\n        encode the payload in a different way, e.g. compress the payload.\n        \"\"\"\n        return json.dumps(\n            payload,\n            separators=(\",\", \":\"),\n            cls=json_encoder,\n        ).encode(\"utf-8\")\n\n    def decode_complete(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        # deprecated arg, remove in pyjwt3\n        verify: bool | None = None,\n        # could be used as passthrough to api_jws, consider removal in pyjwt3\n        detached_payload: bytes | None = None,\n        # passthrough arguments to _validate_claims\n        # consider putting in options\n        audience: str | Iterable[str] | None = None,\n        issuer: str | List[str] | None = None,\n        leeway: float | timedelta = 0,\n        # kwargs\n        **kwargs: Any,\n    ) -> dict[str, Any]:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode_complete() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        options = dict(options or {})  # shallow-copy or initialize an empty dict\n        options.setdefault(\"verify_signature\", True)\n\n        # If the user has set the legacy `verify` argument, and it doesn't match\n        # what the relevant `options` entry for the argument is, inform the user\n        # that they're likely making a mistake.\n        if verify is not None and verify != options[\"verify_signature\"]:\n            warnings.warn(\n                \"The `verify` argument to `decode` does nothing in PyJWT 2.0 and newer. \"\n                \"The equivalent is setting `verify_signature` to False in the `options` dictionary. \"\n                \"This invocation has a mismatch between the kwarg and the option entry.\",\n                category=DeprecationWarning,\n            )\n\n        if not options[\"verify_signature\"]:\n            options.setdefault(\"verify_exp\", False)\n            options.setdefault(\"verify_nbf\", False)\n            options.setdefault(\"verify_iat\", False)\n            options.setdefault(\"verify_aud\", False)\n            options.setdefault(\"verify_iss\", False)\n\n        if options[\"verify_signature\"] and not algorithms:\n            raise DecodeError(\n                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            )\n\n        decoded = api_jws.decode_complete(\n            jwt,\n            key=key,\n            algorithms=algorithms,\n            options=options,\n            detached_payload=detached_payload,\n        )\n\n        payload = self._decode_payload(decoded)\n\n        merged_options = {**self.options, **options}\n        self._validate_claims(\n            payload, merged_options, audience=audience, issuer=issuer, leeway=leeway\n        )\n\n        decoded[\"payload\"] = payload\n        return decoded\n\n    def _decode_payload(self, decoded: dict[str, Any]) -> Any:\n        \"\"\"\n        Decode the payload from a JWS dictionary (payload, signature, header).\n\n        This method is intended to be overridden by subclasses that need to\n        decode the payload in a different way, e.g. decompress compressed\n        payloads.\n        \"\"\"\n        try:\n            payload = json.loads(decoded[\"payload\"])\n        except ValueError as e:\n            raise DecodeError(f\"Invalid payload string: {e}\")\n        if not isinstance(payload, dict):\n            raise DecodeError(\"Invalid payload string: must be a json object\")\n        return payload\n\n    def decode(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        # deprecated arg, remove in pyjwt3\n        verify: bool | None = None,\n        # could be used as passthrough to api_jws, consider removal in pyjwt3\n        detached_payload: bytes | None = None,\n        # passthrough arguments to _validate_claims\n        # consider putting in options\n        audience: str | Iterable[str] | None = None,\n        issuer: str | List[str] | None = None,\n        leeway: float | timedelta = 0,\n        # kwargs\n        **kwargs: Any,\n    ) -> Any:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        decoded = self.decode_complete(\n            jwt,\n            key,\n            algorithms,\n            options,\n            verify=verify,\n            detached_payload=detached_payload,\n            audience=audience,\n            issuer=issuer,\n            leeway=leeway,\n        )\n        return decoded[\"payload\"]\n\n    def _validate_claims(\n        self,\n        payload: dict[str, Any],\n        options: dict[str, Any],\n        audience=None,\n        issuer=None,\n        leeway: float | timedelta = 0,\n    ) -> None:\n        if isinstance(leeway, timedelta):\n            leeway = leeway.total_seconds()\n\n        if audience is not None and not isinstance(audience, (str, Iterable)):\n            raise TypeError(\"audience must be a string, iterable or None\")\n\n        self._validate_required_claims(payload, options)\n\n        now = datetime.now(tz=timezone.utc).timestamp()\n\n        if \"iat\" in payload and options[\"verify_iat\"]:\n            self._validate_iat(payload, now, leeway)\n\n        if \"nbf\" in payload and options[\"verify_nbf\"]:\n            self._validate_nbf(payload, now, leeway)\n\n        if \"exp\" in payload and options[\"verify_exp\"]:\n            self._validate_exp(payload, now, leeway)\n\n        if options[\"verify_iss\"]:\n            self._validate_iss(payload, issuer)\n\n        if options[\"verify_aud\"]:\n            self._validate_aud(\n                payload, audience, strict=options.get(\"strict_aud\", False)\n            )\n\n    def _validate_required_claims(\n        self,\n        payload: dict[str, Any],\n        options: dict[str, Any],\n    ) -> None:\n        for claim in options[\"require\"]:\n            if payload.get(claim) is None:\n                raise MissingRequiredClaimError(claim)\n\n    def _validate_iat(\n        self,\n        payload: dict[str, Any],\n        now: float,\n        leeway: float,\n    ) -> None:\n        try:\n            iat = int(payload[\"iat\"])\n        except ValueError:\n            raise InvalidIssuedAtError(\"Issued At claim (iat) must be an integer.\")\n        if iat > (now + leeway):\n            raise ImmatureSignatureError(\"The token is not yet valid (iat)\")\n\n    def _validate_nbf(\n        self,\n        payload: dict[str, Any],\n        now: float,\n        leeway: float,\n    ) -> None:\n        try:\n            nbf = int(payload[\"nbf\"])\n        except ValueError:\n            raise DecodeError(\"Not Before claim (nbf) must be an integer.\")\n\n        if nbf > (now + leeway):\n            raise ImmatureSignatureError(\"The token is not yet valid (nbf)\")\n\n    def _validate_exp(\n        self,\n        payload: dict[str, Any],\n        now: float,\n        leeway: float,\n    ) -> None:\n        try:\n            exp = int(payload[\"exp\"])\n        except ValueError:\n            raise DecodeError(\"Expiration Time claim (exp) must be an integer.\")\n\n        if exp <= (now - leeway):\n            raise ExpiredSignatureError(\"Signature has expired\")\n\n    def _validate_aud(\n        self,\n        payload: dict[str, Any],\n        audience: str | Iterable[str] | None,\n        *,\n        strict: bool = False,\n    ) -> None:\n        if audience is None:\n            if \"aud\" not in payload or not payload[\"aud\"]:\n                return\n            # Application did not specify an audience, but\n            # the token has the 'aud' claim\n            raise InvalidAudienceError(\"Invalid audience\")\n\n        if \"aud\" not in payload or not payload[\"aud\"]:\n            # Application specified an audience, but it could not be\n            # verified since the token does not contain a claim.\n            raise MissingRequiredClaimError(\"aud\")\n\n        audience_claims = payload[\"aud\"]\n\n        # In strict mode, we forbid list matching: the supplied audience\n        # must be a string, and it must exactly match the audience claim.\n        if strict:\n            # Only a single audience is allowed in strict mode.\n            if not isinstance(audience, str):\n                raise InvalidAudienceError(\"Invalid audience (strict)\")\n\n            # Only a single audience claim is allowed in strict mode.\n            if not isinstance(audience_claims, str):\n                raise InvalidAudienceError(\"Invalid claim format in token (strict)\")\n\n            if audience != audience_claims:\n                raise InvalidAudienceError(\"Audience doesn't match (strict)\")\n\n            return\n\n        if isinstance(audience_claims, str):\n            audience_claims = [audience_claims]\n        if not isinstance(audience_claims, list):\n            raise InvalidAudienceError(\"Invalid claim format in token\")\n        if any(not isinstance(c, str) for c in audience_claims):\n            raise InvalidAudienceError(\"Invalid claim format in token\")\n\n        if isinstance(audience, str):\n            audience = [audience]\n\n        if all(aud not in audience_claims for aud in audience):\n            raise InvalidAudienceError(\"Audience doesn't match\")\n\n    def _validate_iss(self, payload: dict[str, Any], issuer: Any) -> None:\n        if issuer is None:\n            return\n\n        if \"iss\" not in payload:\n            raise MissingRequiredClaimError(\"iss\")\n\n        if isinstance(issuer, list):\n            if payload[\"iss\"] not in issuer:\n                raise InvalidIssuerError(\"Invalid issuer\")\n        else:\n            if payload[\"iss\"] != issuer:\n                raise InvalidIssuerError(\"Invalid issuer\")\n\n\n_jwt_global_obj = PyJWT()\nencode = _jwt_global_obj.encode\ndecode_complete = _jwt_global_obj.decode_complete\ndecode = _jwt_global_obj.decode\n", "jwt/api_jws.py": "from __future__ import annotations\n\nimport binascii\nimport json\nimport warnings\nfrom typing import TYPE_CHECKING, Any\n\nfrom .algorithms import (\n    Algorithm,\n    get_default_algorithms,\n    has_crypto,\n    requires_cryptography,\n)\nfrom .api_jwk import PyJWK\nfrom .exceptions import (\n    DecodeError,\n    InvalidAlgorithmError,\n    InvalidSignatureError,\n    InvalidTokenError,\n)\nfrom .utils import base64url_decode, base64url_encode\nfrom .warnings import RemovedInPyjwt3Warning\n\nif TYPE_CHECKING:\n    from .algorithms import AllowedPrivateKeys, AllowedPublicKeys\n\n\nclass PyJWS:\n    header_typ = \"JWT\"\n\n    def __init__(\n        self,\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n    ) -> None:\n        self._algorithms = get_default_algorithms()\n        self._valid_algs = (\n            set(algorithms) if algorithms is not None else set(self._algorithms)\n        )\n\n        # Remove algorithms that aren't on the whitelist\n        for key in list(self._algorithms.keys()):\n            if key not in self._valid_algs:\n                del self._algorithms[key]\n\n        if options is None:\n            options = {}\n        self.options = {**self._get_default_options(), **options}\n\n    @staticmethod\n    def _get_default_options() -> dict[str, bool]:\n        return {\"verify_signature\": True}\n\n    def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -> None:\n        \"\"\"\n        Registers a new Algorithm for use when creating and verifying tokens.\n        \"\"\"\n        if alg_id in self._algorithms:\n            raise ValueError(\"Algorithm already has a handler.\")\n\n        if not isinstance(alg_obj, Algorithm):\n            raise TypeError(\"Object is not of type `Algorithm`\")\n\n        self._algorithms[alg_id] = alg_obj\n        self._valid_algs.add(alg_id)\n\n    def unregister_algorithm(self, alg_id: str) -> None:\n        \"\"\"\n        Unregisters an Algorithm for use when creating and verifying tokens\n        Throws KeyError if algorithm is not registered.\n        \"\"\"\n        if alg_id not in self._algorithms:\n            raise KeyError(\n                \"The specified algorithm could not be removed\"\n                \" because it is not registered.\"\n            )\n\n        del self._algorithms[alg_id]\n        self._valid_algs.remove(alg_id)\n\n    def get_algorithms(self) -> list[str]:\n        \"\"\"\n        Returns a list of supported values for the 'alg' parameter.\n        \"\"\"\n        return list(self._valid_algs)\n\n    def get_algorithm_by_name(self, alg_name: str) -> Algorithm:\n        \"\"\"\n        For a given string name, return the matching Algorithm object.\n\n        Example usage:\n\n        >>> jws_obj.get_algorithm_by_name(\"RS256\")\n        \"\"\"\n        try:\n            return self._algorithms[alg_name]\n        except KeyError as e:\n            if not has_crypto and alg_name in requires_cryptography:\n                raise NotImplementedError(\n                    f\"Algorithm '{alg_name}' could not be found. Do you have cryptography installed?\"\n                ) from e\n            raise NotImplementedError(\"Algorithm not supported\") from e\n\n    def encode(\n        self,\n        payload: bytes,\n        key: AllowedPrivateKeys | str | bytes,\n        algorithm: str | None = \"HS256\",\n        headers: dict[str, Any] | None = None,\n        json_encoder: type[json.JSONEncoder] | None = None,\n        is_payload_detached: bool = False,\n        sort_headers: bool = True,\n    ) -> str:\n        segments = []\n\n        # declare a new var to narrow the type for type checkers\n        algorithm_: str = algorithm if algorithm is not None else \"none\"\n\n        # Prefer headers values if present to function parameters.\n        if headers:\n            headers_alg = headers.get(\"alg\")\n            if headers_alg:\n                algorithm_ = headers[\"alg\"]\n\n            headers_b64 = headers.get(\"b64\")\n            if headers_b64 is False:\n                is_payload_detached = True\n\n        # Header\n        header: dict[str, Any] = {\"typ\": self.header_typ, \"alg\": algorithm_}\n\n        if headers:\n            self._validate_headers(headers)\n            header.update(headers)\n\n        if not header[\"typ\"]:\n            del header[\"typ\"]\n\n        if is_payload_detached:\n            header[\"b64\"] = False\n        elif \"b64\" in header:\n            # True is the standard value for b64, so no need for it\n            del header[\"b64\"]\n\n        json_header = json.dumps(\n            header, separators=(\",\", \":\"), cls=json_encoder, sort_keys=sort_headers\n        ).encode()\n\n        segments.append(base64url_encode(json_header))\n\n        if is_payload_detached:\n            msg_payload = payload\n        else:\n            msg_payload = base64url_encode(payload)\n        segments.append(msg_payload)\n\n        # Segments\n        signing_input = b\".\".join(segments)\n\n        alg_obj = self.get_algorithm_by_name(algorithm_)\n        key = alg_obj.prepare_key(key)\n        signature = alg_obj.sign(signing_input, key)\n\n        segments.append(base64url_encode(signature))\n\n        # Don't put the payload content inside the encoded token when detached\n        if is_payload_detached:\n            segments[1] = b\"\"\n        encoded_string = b\".\".join(segments)\n\n        return encoded_string.decode(\"utf-8\")\n\n    def decode_complete(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        detached_payload: bytes | None = None,\n        **kwargs,\n    ) -> dict[str, Any]:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode_complete() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        if options is None:\n            options = {}\n        merged_options = {**self.options, **options}\n        verify_signature = merged_options[\"verify_signature\"]\n\n        if verify_signature and not algorithms and not isinstance(key, PyJWK):\n            raise DecodeError(\n                'It is required that you pass in a value for the \"algorithms\" argument when calling decode().'\n            )\n\n        payload, signing_input, header, signature = self._load(jwt)\n\n        if header.get(\"b64\", True) is False:\n            if detached_payload is None:\n                raise DecodeError(\n                    'It is required that you pass in a value for the \"detached_payload\" argument to decode a message having the b64 header set to false.'\n                )\n            payload = detached_payload\n            signing_input = b\".\".join([signing_input.rsplit(b\".\", 1)[0], payload])\n\n        if verify_signature:\n            self._verify_signature(signing_input, header, signature, key, algorithms)\n\n        return {\n            \"payload\": payload,\n            \"header\": header,\n            \"signature\": signature,\n        }\n\n    def decode(\n        self,\n        jwt: str | bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n        options: dict[str, Any] | None = None,\n        detached_payload: bytes | None = None,\n        **kwargs,\n    ) -> Any:\n        if kwargs:\n            warnings.warn(\n                \"passing additional kwargs to decode() is deprecated \"\n                \"and will be removed in pyjwt version 3. \"\n                f\"Unsupported kwargs: {tuple(kwargs.keys())}\",\n                RemovedInPyjwt3Warning,\n            )\n        decoded = self.decode_complete(\n            jwt, key, algorithms, options, detached_payload=detached_payload\n        )\n        return decoded[\"payload\"]\n\n    def get_unverified_header(self, jwt: str | bytes) -> dict[str, Any]:\n        \"\"\"Returns back the JWT header parameters as a dict()\n\n        Note: The signature is not verified so the header parameters\n        should not be fully trusted until signature verification is complete\n        \"\"\"\n        headers = self._load(jwt)[2]\n        self._validate_headers(headers)\n\n        return headers\n\n    def _load(self, jwt: str | bytes) -> tuple[bytes, bytes, dict[str, Any], bytes]:\n        if isinstance(jwt, str):\n            jwt = jwt.encode(\"utf-8\")\n\n        if not isinstance(jwt, bytes):\n            raise DecodeError(f\"Invalid token type. Token must be a {bytes}\")\n\n        try:\n            signing_input, crypto_segment = jwt.rsplit(b\".\", 1)\n            header_segment, payload_segment = signing_input.split(b\".\", 1)\n        except ValueError as err:\n            raise DecodeError(\"Not enough segments\") from err\n\n        try:\n            header_data = base64url_decode(header_segment)\n        except (TypeError, binascii.Error) as err:\n            raise DecodeError(\"Invalid header padding\") from err\n\n        try:\n            header = json.loads(header_data)\n        except ValueError as e:\n            raise DecodeError(f\"Invalid header string: {e}\") from e\n\n        if not isinstance(header, dict):\n            raise DecodeError(\"Invalid header string: must be a json object\")\n\n        try:\n            payload = base64url_decode(payload_segment)\n        except (TypeError, binascii.Error) as err:\n            raise DecodeError(\"Invalid payload padding\") from err\n\n        try:\n            signature = base64url_decode(crypto_segment)\n        except (TypeError, binascii.Error) as err:\n            raise DecodeError(\"Invalid crypto padding\") from err\n\n        return (payload, signing_input, header, signature)\n\n    def _verify_signature(\n        self,\n        signing_input: bytes,\n        header: dict[str, Any],\n        signature: bytes,\n        key: AllowedPublicKeys | PyJWK | str | bytes = \"\",\n        algorithms: list[str] | None = None,\n    ) -> None:\n        if algorithms is None and isinstance(key, PyJWK):\n            algorithms = [key.algorithm_name]\n        try:\n            alg = header[\"alg\"]\n        except KeyError:\n            raise InvalidAlgorithmError(\"Algorithm not specified\")\n\n        if not alg or (algorithms is not None and alg not in algorithms):\n            raise InvalidAlgorithmError(\"The specified alg value is not allowed\")\n\n        if isinstance(key, PyJWK):\n            alg_obj = key.Algorithm\n            prepared_key = key.key\n        else:\n            try:\n                alg_obj = self.get_algorithm_by_name(alg)\n            except NotImplementedError as e:\n                raise InvalidAlgorithmError(\"Algorithm not supported\") from e\n            prepared_key = alg_obj.prepare_key(key)\n\n        if not alg_obj.verify(signing_input, prepared_key, signature):\n            raise InvalidSignatureError(\"Signature verification failed\")\n\n    def _validate_headers(self, headers: dict[str, Any]) -> None:\n        if \"kid\" in headers:\n            self._validate_kid(headers[\"kid\"])\n\n    def _validate_kid(self, kid: Any) -> None:\n        if not isinstance(kid, str):\n            raise InvalidTokenError(\"Key ID header parameter must be a string\")\n\n\n_jws_global_obj = PyJWS()\nencode = _jws_global_obj.encode\ndecode_complete = _jws_global_obj.decode_complete\ndecode = _jws_global_obj.decode\nregister_algorithm = _jws_global_obj.register_algorithm\nunregister_algorithm = _jws_global_obj.unregister_algorithm\nget_algorithm_by_name = _jws_global_obj.get_algorithm_by_name\nget_unverified_header = _jws_global_obj.get_unverified_header\n", "jwt/help.py": "import json\nimport platform\nimport sys\nfrom typing import Dict\n\nfrom . import __version__ as pyjwt_version\n\ntry:\n    import cryptography\n\n    cryptography_version = cryptography.__version__\nexcept ModuleNotFoundError:\n    cryptography_version = \"\"\n\n\ndef info() -> Dict[str, Dict[str, str]]:\n    \"\"\"\n    Generate information for a bug report.\n    Based on the requests package help utility module.\n    \"\"\"\n    try:\n        platform_info = {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n        }\n    except OSError:\n        platform_info = {\"system\": \"Unknown\", \"release\": \"Unknown\"}\n\n    implementation = platform.python_implementation()\n\n    if implementation == \"CPython\":\n        implementation_version = platform.python_version()\n    elif implementation == \"PyPy\":\n        pypy_version_info = sys.pypy_version_info  # type: ignore[attr-defined]\n        implementation_version = (\n            f\"{pypy_version_info.major}.\"\n            f\"{pypy_version_info.minor}.\"\n            f\"{pypy_version_info.micro}\"\n        )\n        if pypy_version_info.releaselevel != \"final\":\n            implementation_version = \"\".join(\n                [implementation_version, pypy_version_info.releaselevel]\n            )\n    else:\n        implementation_version = \"Unknown\"\n\n    return {\n        \"platform\": platform_info,\n        \"implementation\": {\n            \"name\": implementation,\n            \"version\": implementation_version,\n        },\n        \"cryptography\": {\"version\": cryptography_version},\n        \"pyjwt\": {\"version\": pyjwt_version},\n    }\n\n\ndef main() -> None:\n    \"\"\"Pretty-print the bug information as JSON.\"\"\"\n    print(json.dumps(info(), sort_keys=True, indent=2))\n\n\nif __name__ == \"__main__\":\n    main()\n", "jwt/__init__.py": "from .api_jwk import PyJWK, PyJWKSet\nfrom .api_jws import (\n    PyJWS,\n    get_algorithm_by_name,\n    get_unverified_header,\n    register_algorithm,\n    unregister_algorithm,\n)\nfrom .api_jwt import PyJWT, decode, encode\nfrom .exceptions import (\n    DecodeError,\n    ExpiredSignatureError,\n    ImmatureSignatureError,\n    InvalidAlgorithmError,\n    InvalidAudienceError,\n    InvalidIssuedAtError,\n    InvalidIssuerError,\n    InvalidKeyError,\n    InvalidSignatureError,\n    InvalidTokenError,\n    MissingRequiredClaimError,\n    PyJWKClientConnectionError,\n    PyJWKClientError,\n    PyJWKError,\n    PyJWKSetError,\n    PyJWTError,\n)\nfrom .jwks_client import PyJWKClient\n\n__version__ = \"2.8.0\"\n\n__title__ = \"PyJWT\"\n__description__ = \"JSON Web Token implementation in Python\"\n__url__ = \"https://pyjwt.readthedocs.io\"\n__uri__ = __url__\n__doc__ = f\"{__description__} <{__uri__}>\"\n\n__author__ = \"Jos\u00e9 Padilla\"\n__email__ = \"hello@jpadilla.com\"\n\n__license__ = \"MIT\"\n__copyright__ = \"Copyright 2015-2022 Jos\u00e9 Padilla\"\n\n\n__all__ = [\n    \"PyJWS\",\n    \"PyJWT\",\n    \"PyJWKClient\",\n    \"PyJWK\",\n    \"PyJWKSet\",\n    \"decode\",\n    \"encode\",\n    \"get_unverified_header\",\n    \"register_algorithm\",\n    \"unregister_algorithm\",\n    \"get_algorithm_by_name\",\n    # Exceptions\n    \"DecodeError\",\n    \"ExpiredSignatureError\",\n    \"ImmatureSignatureError\",\n    \"InvalidAlgorithmError\",\n    \"InvalidAudienceError\",\n    \"InvalidIssuedAtError\",\n    \"InvalidIssuerError\",\n    \"InvalidKeyError\",\n    \"InvalidSignatureError\",\n    \"InvalidTokenError\",\n    \"MissingRequiredClaimError\",\n    \"PyJWKClientConnectionError\",\n    \"PyJWKClientError\",\n    \"PyJWKError\",\n    \"PyJWKSetError\",\n    \"PyJWTError\",\n]\n", "jwt/api_jwk.py": "from __future__ import annotations\n\nimport json\nimport time\nfrom typing import Any\n\nfrom .algorithms import get_default_algorithms, has_crypto, requires_cryptography\nfrom .exceptions import InvalidKeyError, PyJWKError, PyJWKSetError, PyJWTError\nfrom .types import JWKDict\n\n\nclass PyJWK:\n    def __init__(self, jwk_data: JWKDict, algorithm: str | None = None) -> None:\n        self._algorithms = get_default_algorithms()\n        self._jwk_data = jwk_data\n\n        kty = self._jwk_data.get(\"kty\", None)\n        if not kty:\n            raise InvalidKeyError(f\"kty is not found: {self._jwk_data}\")\n\n        if not algorithm and isinstance(self._jwk_data, dict):\n            algorithm = self._jwk_data.get(\"alg\", None)\n\n        if not algorithm:\n            # Determine alg with kty (and crv).\n            crv = self._jwk_data.get(\"crv\", None)\n            if kty == \"EC\":\n                if crv == \"P-256\" or not crv:\n                    algorithm = \"ES256\"\n                elif crv == \"P-384\":\n                    algorithm = \"ES384\"\n                elif crv == \"P-521\":\n                    algorithm = \"ES512\"\n                elif crv == \"secp256k1\":\n                    algorithm = \"ES256K\"\n                else:\n                    raise InvalidKeyError(f\"Unsupported crv: {crv}\")\n            elif kty == \"RSA\":\n                algorithm = \"RS256\"\n            elif kty == \"oct\":\n                algorithm = \"HS256\"\n            elif kty == \"OKP\":\n                if not crv:\n                    raise InvalidKeyError(f\"crv is not found: {self._jwk_data}\")\n                if crv == \"Ed25519\":\n                    algorithm = \"EdDSA\"\n                else:\n                    raise InvalidKeyError(f\"Unsupported crv: {crv}\")\n            else:\n                raise InvalidKeyError(f\"Unsupported kty: {kty}\")\n\n        if not has_crypto and algorithm in requires_cryptography:\n            raise PyJWKError(f\"{algorithm} requires 'cryptography' to be installed.\")\n\n        self.algorithm_name = algorithm\n\n        if algorithm in self._algorithms:\n            self.Algorithm = self._algorithms[algorithm]\n        else:\n            raise PyJWKError(f\"Unable to find an algorithm for key: {self._jwk_data}\")\n\n        self.key = self.Algorithm.from_jwk(self._jwk_data)\n\n    @staticmethod\n    def from_dict(obj: JWKDict, algorithm: str | None = None) -> PyJWK:\n        return PyJWK(obj, algorithm)\n\n    @staticmethod\n    def from_json(data: str, algorithm: None = None) -> PyJWK:\n        obj = json.loads(data)\n        return PyJWK.from_dict(obj, algorithm)\n\n    @property\n    def key_type(self) -> str | None:\n        return self._jwk_data.get(\"kty\", None)\n\n    @property\n    def key_id(self) -> str | None:\n        return self._jwk_data.get(\"kid\", None)\n\n    @property\n    def public_key_use(self) -> str | None:\n        return self._jwk_data.get(\"use\", None)\n\n\nclass PyJWKSet:\n    def __init__(self, keys: list[JWKDict]) -> None:\n        self.keys = []\n\n        if not keys:\n            raise PyJWKSetError(\"The JWK Set did not contain any keys\")\n\n        if not isinstance(keys, list):\n            raise PyJWKSetError(\"Invalid JWK Set value\")\n\n        for key in keys:\n            try:\n                self.keys.append(PyJWK(key))\n            except PyJWTError:\n                # skip unusable keys\n                continue\n\n        if len(self.keys) == 0:\n            raise PyJWKSetError(\n                \"The JWK Set did not contain any usable keys. Perhaps 'cryptography' is not installed?\"\n            )\n\n    @staticmethod\n    def from_dict(obj: dict[str, Any]) -> PyJWKSet:\n        keys = obj.get(\"keys\", [])\n        return PyJWKSet(keys)\n\n    @staticmethod\n    def from_json(data: str) -> PyJWKSet:\n        obj = json.loads(data)\n        return PyJWKSet.from_dict(obj)\n\n    def __getitem__(self, kid: str) -> PyJWK:\n        for key in self.keys:\n            if key.key_id == kid:\n                return key\n        raise KeyError(f\"keyset has no key for kid: {kid}\")\n\n\nclass PyJWTSetWithTimestamp:\n    def __init__(self, jwk_set: PyJWKSet):\n        self.jwk_set = jwk_set\n        self.timestamp = time.monotonic()\n\n    def get_jwk_set(self) -> PyJWKSet:\n        return self.jwk_set\n\n    def get_timestamp(self) -> float:\n        return self.timestamp\n"}