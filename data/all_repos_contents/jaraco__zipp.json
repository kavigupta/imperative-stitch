{"zipp/glob.py": "import os\nimport re\n\n\n_default_seps = os.sep + str(os.altsep) * bool(os.altsep)\n\n\nclass Translator:\n    \"\"\"\n    >>> Translator('xyz')\n    Traceback (most recent call last):\n    ...\n    AssertionError: Invalid separators\n\n    >>> Translator('')\n    Traceback (most recent call last):\n    ...\n    AssertionError: Invalid separators\n    \"\"\"\n\n    seps: str\n\n    def __init__(self, seps: str = _default_seps):\n        assert seps and set(seps) <= set(_default_seps), \"Invalid separators\"\n        self.seps = seps\n\n    def translate(self, pattern):\n        \"\"\"\n        Given a glob pattern, produce a regex that matches it.\n        \"\"\"\n        return self.extend(self.translate_core(pattern))\n\n    def extend(self, pattern):\n        r\"\"\"\n        Extend regex for pattern-wide concerns.\n\n        Apply '(?s:)' to create a non-matching group that\n        matches newlines (valid on Unix).\n\n        Append '\\Z' to imply fullmatch even when match is used.\n        \"\"\"\n        return rf'(?s:{pattern})\\Z'\n\n    def translate_core(self, pattern):\n        r\"\"\"\n        Given a glob pattern, produce a regex that matches it.\n\n        >>> t = Translator()\n        >>> t.translate_core('*.txt').replace('\\\\\\\\', '')\n        '[^/]*\\\\.txt'\n        >>> t.translate_core('a?txt')\n        'a[^/]txt'\n        >>> t.translate_core('**/*').replace('\\\\\\\\', '')\n        '.*/[^/][^/]*'\n        \"\"\"\n        self.restrict_rglob(pattern)\n        return ''.join(map(self.replace, separate(self.star_not_empty(pattern))))\n\n    def replace(self, match):\n        \"\"\"\n        Perform the replacements for a match from :func:`separate`.\n        \"\"\"\n        return match.group('set') or (\n            re.escape(match.group(0))\n            .replace('\\\\*\\\\*', r'.*')\n            .replace('\\\\*', rf'[^{re.escape(self.seps)}]*')\n            .replace('\\\\?', r'[^/]')\n        )\n\n    def restrict_rglob(self, pattern):\n        \"\"\"\n        Raise ValueError if ** appears in anything but a full path segment.\n\n        >>> Translator().translate('**foo')\n        Traceback (most recent call last):\n        ...\n        ValueError: ** must appear alone in a path segment\n        \"\"\"\n        seps_pattern = rf'[{re.escape(self.seps)}]+'\n        segments = re.split(seps_pattern, pattern)\n        if any('**' in segment and segment != '**' for segment in segments):\n            raise ValueError(\"** must appear alone in a path segment\")\n\n    def star_not_empty(self, pattern):\n        \"\"\"\n        Ensure that * will not match an empty segment.\n        \"\"\"\n\n        def handle_segment(match):\n            segment = match.group(0)\n            return '?*' if segment == '*' else segment\n\n        not_seps_pattern = rf'[^{re.escape(self.seps)}]+'\n        return re.sub(not_seps_pattern, handle_segment, pattern)\n\n\ndef separate(pattern):\n    \"\"\"\n    Separate out character sets to avoid translating their contents.\n\n    >>> [m.group(0) for m in separate('*.txt')]\n    ['*.txt']\n    >>> [m.group(0) for m in separate('a[?]txt')]\n    ['a', '[?]', 'txt']\n    \"\"\"\n    return re.finditer(r'([^\\[]+)|(?P<set>[\\[].*?[\\]])|([\\[][^\\]]*$)', pattern)\n", "zipp/__init__.py": "import io\nimport posixpath\nimport zipfile\nimport itertools\nimport contextlib\nimport pathlib\nimport re\nimport stat\nimport sys\n\nfrom .compat.py310 import text_encoding\nfrom .glob import Translator\n\n\n__all__ = ['Path']\n\n\ndef _parents(path):\n    \"\"\"\n    Given a path with elements separated by\n    posixpath.sep, generate all parents of that path.\n\n    >>> list(_parents('b/d'))\n    ['b']\n    >>> list(_parents('/b/d/'))\n    ['/b']\n    >>> list(_parents('b/d/f/'))\n    ['b/d', 'b']\n    >>> list(_parents('b'))\n    []\n    >>> list(_parents(''))\n    []\n    \"\"\"\n    return itertools.islice(_ancestry(path), 1, None)\n\n\ndef _ancestry(path):\n    \"\"\"\n    Given a path with elements separated by\n    posixpath.sep, generate all elements of that path\n\n    >>> list(_ancestry('b/d'))\n    ['b/d', 'b']\n    >>> list(_ancestry('/b/d/'))\n    ['/b/d', '/b']\n    >>> list(_ancestry('b/d/f/'))\n    ['b/d/f', 'b/d', 'b']\n    >>> list(_ancestry('b'))\n    ['b']\n    >>> list(_ancestry(''))\n    []\n    \"\"\"\n    path = path.rstrip(posixpath.sep)\n    while path and path != posixpath.sep:\n        yield path\n        path, tail = posixpath.split(path)\n\n\n_dedupe = dict.fromkeys\n\"\"\"Deduplicate an iterable in original order\"\"\"\n\n\ndef _difference(minuend, subtrahend):\n    \"\"\"\n    Return items in minuend not in subtrahend, retaining order\n    with O(1) lookup.\n    \"\"\"\n    return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n\n\nclass InitializedState:\n    \"\"\"\n    Mix-in to save the initialization state for pickling.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self.__args = args\n        self.__kwargs = kwargs\n        super().__init__(*args, **kwargs)\n\n    def __getstate__(self):\n        return self.__args, self.__kwargs\n\n    def __setstate__(self, state):\n        args, kwargs = state\n        super().__init__(*args, **kwargs)\n\n\nclass SanitizedNames:\n    \"\"\"\n    ZipFile mix-in to ensure names are sanitized.\n    \"\"\"\n\n    def namelist(self):\n        return list(map(self._sanitize, super().namelist()))\n\n    @staticmethod\n    def _sanitize(name):\n        r\"\"\"\n        Ensure a relative path with posix separators and no dot names.\n\n        Modeled after\n        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n        but provides consistent cross-platform behavior.\n\n        >>> san = SanitizedNames._sanitize\n        >>> san('/foo/bar')\n        'foo/bar'\n        >>> san('//foo.txt')\n        'foo.txt'\n        >>> san('foo/.././bar.txt')\n        'foo/bar.txt'\n        >>> san('foo../.bar.txt')\n        'foo../.bar.txt'\n        >>> san('\\\\foo\\\\bar.txt')\n        'foo/bar.txt'\n        >>> san('D:\\\\foo.txt')\n        'D/foo.txt'\n        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n        'server/share/file.txt'\n        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n        '?/GLOBALROOT/Volume3'\n        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n        'PhysicalDrive1/root'\n\n        Retain any trailing slash.\n        >>> san('abc/')\n        'abc/'\n\n        Raises a ValueError if the result is empty.\n        >>> san('../..')\n        Traceback (most recent call last):\n        ...\n        ValueError: Empty filename\n        \"\"\"\n\n        def allowed(part):\n            return part and part not in {'..', '.'}\n\n        # Remove the drive letter.\n        # Don't use ntpath.splitdrive, because that also strips UNC paths\n        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n        clean = bare.replace('\\\\', '/')\n        parts = clean.split('/')\n        joined = '/'.join(filter(allowed, parts))\n        if not joined:\n            raise ValueError(\"Empty filename\")\n        return joined + '/' * name.endswith('/')\n\n\nclass CompleteDirs(InitializedState, SanitizedNames, zipfile.ZipFile):\n    \"\"\"\n    A ZipFile subclass that ensures that implied directories\n    are always included in the namelist.\n\n    >>> list(CompleteDirs._implied_dirs(['foo/bar.txt', 'foo/bar/baz.txt']))\n    ['foo/', 'foo/bar/']\n    >>> list(CompleteDirs._implied_dirs(['foo/bar.txt', 'foo/bar/baz.txt', 'foo/bar/']))\n    ['foo/']\n    \"\"\"\n\n    @staticmethod\n    def _implied_dirs(names):\n        parents = itertools.chain.from_iterable(map(_parents, names))\n        as_dirs = (p + posixpath.sep for p in parents)\n        return _dedupe(_difference(as_dirs, names))\n\n    def namelist(self):\n        names = super().namelist()\n        return names + list(self._implied_dirs(names))\n\n    def _name_set(self):\n        return set(self.namelist())\n\n    def resolve_dir(self, name):\n        \"\"\"\n        If the name represents a directory, return that name\n        as a directory (with the trailing slash).\n        \"\"\"\n        names = self._name_set()\n        dirname = name + '/'\n        dir_match = name not in names and dirname in names\n        return dirname if dir_match else name\n\n    def getinfo(self, name):\n        \"\"\"\n        Supplement getinfo for implied dirs.\n        \"\"\"\n        try:\n            return super().getinfo(name)\n        except KeyError:\n            if not name.endswith('/') or name not in self._name_set():\n                raise\n            return zipfile.ZipInfo(filename=name)\n\n    @classmethod\n    def make(cls, source):\n        \"\"\"\n        Given a source (filename or zipfile), return an\n        appropriate CompleteDirs subclass.\n        \"\"\"\n        if isinstance(source, CompleteDirs):\n            return source\n\n        if not isinstance(source, zipfile.ZipFile):\n            return cls(source)\n\n        # Only allow for FastLookup when supplied zipfile is read-only\n        if 'r' not in source.mode:\n            cls = CompleteDirs\n\n        source.__class__ = cls\n        return source\n\n    @classmethod\n    def inject(cls, zf: zipfile.ZipFile) -> zipfile.ZipFile:\n        \"\"\"\n        Given a writable zip file zf, inject directory entries for\n        any directories implied by the presence of children.\n        \"\"\"\n        for name in cls._implied_dirs(zf.namelist()):\n            zf.writestr(name, b\"\")\n        return zf\n\n\nclass FastLookup(CompleteDirs):\n    \"\"\"\n    ZipFile subclass to ensure implicit\n    dirs exist and are resolved rapidly.\n    \"\"\"\n\n    def namelist(self):\n        with contextlib.suppress(AttributeError):\n            return self.__names\n        self.__names = super().namelist()\n        return self.__names\n\n    def _name_set(self):\n        with contextlib.suppress(AttributeError):\n            return self.__lookup\n        self.__lookup = super()._name_set()\n        return self.__lookup\n\n\ndef _extract_text_encoding(encoding=None, *args, **kwargs):\n    # compute stack level so that the caller of the caller sees any warning.\n    is_pypy = sys.implementation.name == 'pypy'\n    stack_level = 3 + is_pypy\n    return text_encoding(encoding, stack_level), args, kwargs\n\n\nclass Path:\n    \"\"\"\n    A :class:`importlib.resources.abc.Traversable` interface for zip files.\n\n    Implements many of the features users enjoy from\n    :class:`pathlib.Path`.\n\n    Consider a zip file with this structure::\n\n        .\n        \u251c\u2500\u2500 a.txt\n        \u2514\u2500\u2500 b\n            \u251c\u2500\u2500 c.txt\n            \u2514\u2500\u2500 d\n                \u2514\u2500\u2500 e.txt\n\n    >>> data = io.BytesIO()\n    >>> zf = zipfile.ZipFile(data, 'w')\n    >>> zf.writestr('a.txt', 'content of a')\n    >>> zf.writestr('b/c.txt', 'content of c')\n    >>> zf.writestr('b/d/e.txt', 'content of e')\n    >>> zf.filename = 'mem/abcde.zip'\n\n    Path accepts the zipfile object itself or a filename\n\n    >>> path = Path(zf)\n\n    From there, several path operations are available.\n\n    Directory iteration (including the zip file itself):\n\n    >>> a, b = path.iterdir()\n    >>> a\n    Path('mem/abcde.zip', 'a.txt')\n    >>> b\n    Path('mem/abcde.zip', 'b/')\n\n    name property:\n\n    >>> b.name\n    'b'\n\n    join with divide operator:\n\n    >>> c = b / 'c.txt'\n    >>> c\n    Path('mem/abcde.zip', 'b/c.txt')\n    >>> c.name\n    'c.txt'\n\n    Read text:\n\n    >>> c.read_text(encoding='utf-8')\n    'content of c'\n\n    existence:\n\n    >>> c.exists()\n    True\n    >>> (b / 'missing.txt').exists()\n    False\n\n    Coercion to string:\n\n    >>> import os\n    >>> str(c).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip/b/c.txt'\n\n    At the root, ``name``, ``filename``, and ``parent``\n    resolve to the zipfile.\n\n    >>> str(path)\n    'mem/abcde.zip/'\n    >>> path.name\n    'abcde.zip'\n    >>> path.filename == pathlib.Path('mem/abcde.zip')\n    True\n    >>> str(path.parent)\n    'mem'\n\n    If the zipfile has no filename, such \ufeffattributes are not\n    valid and accessing them will raise an Exception.\n\n    >>> zf.filename = None\n    >>> path.name\n    Traceback (most recent call last):\n    ...\n    TypeError: ...\n\n    >>> path.filename\n    Traceback (most recent call last):\n    ...\n    TypeError: ...\n\n    >>> path.parent\n    Traceback (most recent call last):\n    ...\n    TypeError: ...\n\n    # workaround python/cpython#106763\n    >>> pass\n    \"\"\"\n\n    __repr = \"{self.__class__.__name__}({self.root.filename!r}, {self.at!r})\"\n\n    def __init__(self, root, at=\"\"):\n        \"\"\"\n        Construct a Path from a ZipFile or filename.\n\n        Note: When the source is an existing ZipFile object,\n        its type (__class__) will be mutated to a\n        specialized type. If the caller wishes to retain the\n        original type, the caller should either create a\n        separate ZipFile object or pass a filename.\n        \"\"\"\n        self.root = FastLookup.make(root)\n        self.at = at\n\n    def __eq__(self, other):\n        \"\"\"\n        >>> Path(zipfile.ZipFile(io.BytesIO(), 'w')) == 'foo'\n        False\n        \"\"\"\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return (self.root, self.at) == (other.root, other.at)\n\n    def __hash__(self):\n        return hash((self.root, self.at))\n\n    def open(self, mode='r', *args, pwd=None, **kwargs):\n        \"\"\"\n        Open this entry as text or binary following the semantics\n        of ``pathlib.Path.open()`` by passing arguments through\n        to io.TextIOWrapper().\n        \"\"\"\n        if self.is_dir():\n            raise IsADirectoryError(self)\n        zip_mode = mode[0]\n        if not self.exists() and zip_mode == 'r':\n            raise FileNotFoundError(self)\n        stream = self.root.open(self.at, zip_mode, pwd=pwd)\n        if 'b' in mode:\n            if args or kwargs:\n                raise ValueError(\"encoding args invalid for binary operation\")\n            return stream\n        # Text mode:\n        encoding, args, kwargs = _extract_text_encoding(*args, **kwargs)\n        return io.TextIOWrapper(stream, encoding, *args, **kwargs)\n\n    def _base(self):\n        return pathlib.PurePosixPath(self.at or self.root.filename)\n\n    @property\n    def name(self):\n        return self._base().name\n\n    @property\n    def suffix(self):\n        return self._base().suffix\n\n    @property\n    def suffixes(self):\n        return self._base().suffixes\n\n    @property\n    def stem(self):\n        return self._base().stem\n\n    @property\n    def filename(self):\n        return pathlib.Path(self.root.filename).joinpath(self.at)\n\n    def read_text(self, *args, **kwargs):\n        encoding, args, kwargs = _extract_text_encoding(*args, **kwargs)\n        with self.open('r', encoding, *args, **kwargs) as strm:\n            return strm.read()\n\n    def read_bytes(self):\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def _is_child(self, path):\n        return posixpath.dirname(path.at.rstrip(\"/\")) == self.at.rstrip(\"/\")\n\n    def _next(self, at):\n        return self.__class__(self.root, at)\n\n    def is_dir(self):\n        return not self.at or self.at.endswith(\"/\")\n\n    def is_file(self):\n        return self.exists() and not self.is_dir()\n\n    def exists(self):\n        return self.at in self.root._name_set()\n\n    def iterdir(self):\n        if not self.is_dir():\n            raise ValueError(\"Can't listdir a file\")\n        subs = map(self._next, self.root.namelist())\n        return filter(self._is_child, subs)\n\n    def match(self, path_pattern):\n        return pathlib.PurePosixPath(self.at).match(path_pattern)\n\n    def is_symlink(self):\n        \"\"\"\n        Return whether this path is a symlink.\n        \"\"\"\n        info = self.root.getinfo(self.at)\n        mode = info.external_attr >> 16\n        return stat.S_ISLNK(mode)\n\n    def glob(self, pattern):\n        if not pattern:\n            raise ValueError(f\"Unacceptable pattern: {pattern!r}\")\n\n        prefix = re.escape(self.at)\n        tr = Translator(seps='/')\n        matches = re.compile(prefix + tr.translate(pattern)).fullmatch\n        names = (data.filename for data in self.root.filelist)\n        return map(self._next, filter(matches, names))\n\n    def rglob(self, pattern):\n        return self.glob(f'**/{pattern}')\n\n    def relative_to(self, other, *extra):\n        return posixpath.relpath(str(self), str(other.joinpath(*extra)))\n\n    def __str__(self):\n        return posixpath.join(self.root.filename, self.at)\n\n    def __repr__(self):\n        return self.__repr.format(self=self)\n\n    def joinpath(self, *other):\n        next = posixpath.join(self.at, *other)\n        return self._next(self.root.resolve_dir(next))\n\n    __truediv__ = joinpath\n\n    @property\n    def parent(self):\n        if not self.at:\n            return self.filename.parent\n        parent_at = posixpath.dirname(self.at.rstrip('/'))\n        if parent_at:\n            parent_at += '/'\n        return self._next(parent_at)\n", "zipp/compat/py310.py": "import sys\nimport io\n\n\ndef _text_encoding(encoding, stacklevel=2, /):  # pragma: no cover\n    return encoding\n\n\ntext_encoding = (\n    io.text_encoding if sys.version_info > (3, 10) else _text_encoding  # type: ignore\n)\n", "zipp/compat/__init__.py": ""}