{"colorama/win32.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# from winbase.h\nSTDOUT = -11\nSTDERR = -12\n\nENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004\n\ntry:\n    import ctypes\n    from ctypes import LibraryLoader\n    windll = LibraryLoader(ctypes.WinDLL)\n    from ctypes import wintypes\nexcept (AttributeError, ImportError):\n    windll = None\n    SetConsoleTextAttribute = lambda *_: None\n    winapi_test = lambda *_: None\nelse:\n    from ctypes import byref, Structure, c_char, POINTER\n\n    COORD = wintypes._COORD\n\n    class CONSOLE_SCREEN_BUFFER_INFO(Structure):\n        \"\"\"struct in wincon.h.\"\"\"\n        _fields_ = [\n            (\"dwSize\", COORD),\n            (\"dwCursorPosition\", COORD),\n            (\"wAttributes\", wintypes.WORD),\n            (\"srWindow\", wintypes.SMALL_RECT),\n            (\"dwMaximumWindowSize\", COORD),\n        ]\n        def __str__(self):\n            return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (\n                self.dwSize.Y, self.dwSize.X\n                , self.dwCursorPosition.Y, self.dwCursorPosition.X\n                , self.wAttributes\n                , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right\n                , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X\n            )\n\n    _GetStdHandle = windll.kernel32.GetStdHandle\n    _GetStdHandle.argtypes = [\n        wintypes.DWORD,\n    ]\n    _GetStdHandle.restype = wintypes.HANDLE\n\n    _GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo\n    _GetConsoleScreenBufferInfo.argtypes = [\n        wintypes.HANDLE,\n        POINTER(CONSOLE_SCREEN_BUFFER_INFO),\n    ]\n    _GetConsoleScreenBufferInfo.restype = wintypes.BOOL\n\n    _SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute\n    _SetConsoleTextAttribute.argtypes = [\n        wintypes.HANDLE,\n        wintypes.WORD,\n    ]\n    _SetConsoleTextAttribute.restype = wintypes.BOOL\n\n    _SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition\n    _SetConsoleCursorPosition.argtypes = [\n        wintypes.HANDLE,\n        COORD,\n    ]\n    _SetConsoleCursorPosition.restype = wintypes.BOOL\n\n    _FillConsoleOutputCharacterA = windll.kernel32.FillConsoleOutputCharacterA\n    _FillConsoleOutputCharacterA.argtypes = [\n        wintypes.HANDLE,\n        c_char,\n        wintypes.DWORD,\n        COORD,\n        POINTER(wintypes.DWORD),\n    ]\n    _FillConsoleOutputCharacterA.restype = wintypes.BOOL\n\n    _FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute\n    _FillConsoleOutputAttribute.argtypes = [\n        wintypes.HANDLE,\n        wintypes.WORD,\n        wintypes.DWORD,\n        COORD,\n        POINTER(wintypes.DWORD),\n    ]\n    _FillConsoleOutputAttribute.restype = wintypes.BOOL\n\n    _SetConsoleTitleW = windll.kernel32.SetConsoleTitleW\n    _SetConsoleTitleW.argtypes = [\n        wintypes.LPCWSTR\n    ]\n    _SetConsoleTitleW.restype = wintypes.BOOL\n\n    _GetConsoleMode = windll.kernel32.GetConsoleMode\n    _GetConsoleMode.argtypes = [\n        wintypes.HANDLE,\n        POINTER(wintypes.DWORD)\n    ]\n    _GetConsoleMode.restype = wintypes.BOOL\n\n    _SetConsoleMode = windll.kernel32.SetConsoleMode\n    _SetConsoleMode.argtypes = [\n        wintypes.HANDLE,\n        wintypes.DWORD\n    ]\n    _SetConsoleMode.restype = wintypes.BOOL\n\n    def _winapi_test(handle):\n        csbi = CONSOLE_SCREEN_BUFFER_INFO()\n        success = _GetConsoleScreenBufferInfo(\n            handle, byref(csbi))\n        return bool(success)\n\n    def winapi_test():\n        return any(_winapi_test(h) for h in\n                   (_GetStdHandle(STDOUT), _GetStdHandle(STDERR)))\n\n    def GetConsoleScreenBufferInfo(stream_id=STDOUT):\n        handle = _GetStdHandle(stream_id)\n        csbi = CONSOLE_SCREEN_BUFFER_INFO()\n        success = _GetConsoleScreenBufferInfo(\n            handle, byref(csbi))\n        return csbi\n\n    def SetConsoleTextAttribute(stream_id, attrs):\n        handle = _GetStdHandle(stream_id)\n        return _SetConsoleTextAttribute(handle, attrs)\n\n    def SetConsoleCursorPosition(stream_id, position, adjust=True):\n        position = COORD(*position)\n        # If the position is out of range, do nothing.\n        if position.Y <= 0 or position.X <= 0:\n            return\n        # Adjust for Windows' SetConsoleCursorPosition:\n        #    1. being 0-based, while ANSI is 1-based.\n        #    2. expecting (x,y), while ANSI uses (y,x).\n        adjusted_position = COORD(position.Y - 1, position.X - 1)\n        if adjust:\n            # Adjust for viewport's scroll position\n            sr = GetConsoleScreenBufferInfo(STDOUT).srWindow\n            adjusted_position.Y += sr.Top\n            adjusted_position.X += sr.Left\n        # Resume normal processing\n        handle = _GetStdHandle(stream_id)\n        return _SetConsoleCursorPosition(handle, adjusted_position)\n\n    def FillConsoleOutputCharacter(stream_id, char, length, start):\n        handle = _GetStdHandle(stream_id)\n        char = c_char(char.encode())\n        length = wintypes.DWORD(length)\n        num_written = wintypes.DWORD(0)\n        # Note that this is hard-coded for ANSI (vs wide) bytes.\n        success = _FillConsoleOutputCharacterA(\n            handle, char, length, start, byref(num_written))\n        return num_written.value\n\n    def FillConsoleOutputAttribute(stream_id, attr, length, start):\n        ''' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )'''\n        handle = _GetStdHandle(stream_id)\n        attribute = wintypes.WORD(attr)\n        length = wintypes.DWORD(length)\n        num_written = wintypes.DWORD(0)\n        # Note that this is hard-coded for ANSI (vs wide) bytes.\n        return _FillConsoleOutputAttribute(\n            handle, attribute, length, start, byref(num_written))\n\n    def SetConsoleTitle(title):\n        return _SetConsoleTitleW(title)\n\n    def GetConsoleMode(handle):\n        mode = wintypes.DWORD()\n        success = _GetConsoleMode(handle, byref(mode))\n        if not success:\n            raise ctypes.WinError()\n        return mode.value\n\n    def SetConsoleMode(handle, mode):\n        success = _SetConsoleMode(handle, mode)\n        if not success:\n            raise ctypes.WinError()\n", "colorama/ansitowin32.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nimport re\nimport sys\nimport os\n\nfrom .ansi import AnsiFore, AnsiBack, AnsiStyle, Style, BEL\nfrom .winterm import enable_vt_processing, WinTerm, WinColor, WinStyle\nfrom .win32 import windll, winapi_test\n\n\nwinterm = None\nif windll is not None:\n    winterm = WinTerm()\n\n\nclass StreamWrapper(object):\n    '''\n    Wraps a stream (such as stdout), acting as a transparent proxy for all\n    attribute access apart from method 'write()', which is delegated to our\n    Converter instance.\n    '''\n    def __init__(self, wrapped, converter):\n        # double-underscore everything to prevent clashes with names of\n        # attributes on the wrapped stream object.\n        self.__wrapped = wrapped\n        self.__convertor = converter\n\n    def __getattr__(self, name):\n        return getattr(self.__wrapped, name)\n\n    def __enter__(self, *args, **kwargs):\n        # special method lookup bypasses __getattr__/__getattribute__, see\n        # https://stackoverflow.com/questions/12632894/why-doesnt-getattr-work-with-exit\n        # thus, contextlib magic methods are not proxied via __getattr__\n        return self.__wrapped.__enter__(*args, **kwargs)\n\n    def __exit__(self, *args, **kwargs):\n        return self.__wrapped.__exit__(*args, **kwargs)\n\n    def __setstate__(self, state):\n        self.__dict__ = state\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def write(self, text):\n        self.__convertor.write(text)\n\n    def isatty(self):\n        stream = self.__wrapped\n        if 'PYCHARM_HOSTED' in os.environ:\n            if stream is not None and (stream is sys.__stdout__ or stream is sys.__stderr__):\n                return True\n        try:\n            stream_isatty = stream.isatty\n        except AttributeError:\n            return False\n        else:\n            return stream_isatty()\n\n    @property\n    def closed(self):\n        stream = self.__wrapped\n        try:\n            return stream.closed\n        # AttributeError in the case that the stream doesn't support being closed\n        # ValueError for the case that the stream has already been detached when atexit runs\n        except (AttributeError, ValueError):\n            return True\n\n\nclass AnsiToWin32(object):\n    '''\n    Implements a 'write()' method which, on Windows, will strip ANSI character\n    sequences from the text, and if outputting to a tty, will convert them into\n    win32 function calls.\n    '''\n    ANSI_CSI_RE = re.compile('\\001?\\033\\\\[((?:\\\\d|;)*)([a-zA-Z])\\002?')   # Control Sequence Introducer\n    ANSI_OSC_RE = re.compile('\\001?\\033\\\\]([^\\a]*)(\\a)\\002?')             # Operating System Command\n\n    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):\n        # The wrapped stream (normally sys.stdout or sys.stderr)\n        self.wrapped = wrapped\n\n        # should we reset colors to defaults after every .write()\n        self.autoreset = autoreset\n\n        # create the proxy wrapping our output stream\n        self.stream = StreamWrapper(wrapped, self)\n\n        on_windows = os.name == 'nt'\n        # We test if the WinAPI works, because even if we are on Windows\n        # we may be using a terminal that doesn't support the WinAPI\n        # (e.g. Cygwin Terminal). In this case it's up to the terminal\n        # to support the ANSI codes.\n        conversion_supported = on_windows and winapi_test()\n        try:\n            fd = wrapped.fileno()\n        except Exception:\n            fd = -1\n        system_has_native_ansi = not on_windows or enable_vt_processing(fd)\n        have_tty = not self.stream.closed and self.stream.isatty()\n        need_conversion = conversion_supported and not system_has_native_ansi\n\n        # should we strip ANSI sequences from our output?\n        if strip is None:\n            strip = need_conversion or not have_tty\n        self.strip = strip\n\n        # should we should convert ANSI sequences into win32 calls?\n        if convert is None:\n            convert = need_conversion and have_tty\n        self.convert = convert\n\n        # dict of ansi codes to win32 functions and parameters\n        self.win32_calls = self.get_win32_calls()\n\n        # are we wrapping stderr?\n        self.on_stderr = self.wrapped is sys.stderr\n\n    def should_wrap(self):\n        '''\n        True if this class is actually needed. If false, then the output\n        stream will not be affected, nor will win32 calls be issued, so\n        wrapping stdout is not actually required. This will generally be\n        False on non-Windows platforms, unless optional functionality like\n        autoreset has been requested using kwargs to init()\n        '''\n        return self.convert or self.strip or self.autoreset\n\n    def get_win32_calls(self):\n        if self.convert and winterm:\n            return {\n                AnsiStyle.RESET_ALL: (winterm.reset_all, ),\n                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),\n                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),\n                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),\n                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),\n                AnsiFore.RED: (winterm.fore, WinColor.RED),\n                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),\n                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),\n                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),\n                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),\n                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),\n                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),\n                AnsiFore.RESET: (winterm.fore, ),\n                AnsiFore.LIGHTBLACK_EX: (winterm.fore, WinColor.BLACK, True),\n                AnsiFore.LIGHTRED_EX: (winterm.fore, WinColor.RED, True),\n                AnsiFore.LIGHTGREEN_EX: (winterm.fore, WinColor.GREEN, True),\n                AnsiFore.LIGHTYELLOW_EX: (winterm.fore, WinColor.YELLOW, True),\n                AnsiFore.LIGHTBLUE_EX: (winterm.fore, WinColor.BLUE, True),\n                AnsiFore.LIGHTMAGENTA_EX: (winterm.fore, WinColor.MAGENTA, True),\n                AnsiFore.LIGHTCYAN_EX: (winterm.fore, WinColor.CYAN, True),\n                AnsiFore.LIGHTWHITE_EX: (winterm.fore, WinColor.GREY, True),\n                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),\n                AnsiBack.RED: (winterm.back, WinColor.RED),\n                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),\n                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),\n                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),\n                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),\n                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),\n                AnsiBack.WHITE: (winterm.back, WinColor.GREY),\n                AnsiBack.RESET: (winterm.back, ),\n                AnsiBack.LIGHTBLACK_EX: (winterm.back, WinColor.BLACK, True),\n                AnsiBack.LIGHTRED_EX: (winterm.back, WinColor.RED, True),\n                AnsiBack.LIGHTGREEN_EX: (winterm.back, WinColor.GREEN, True),\n                AnsiBack.LIGHTYELLOW_EX: (winterm.back, WinColor.YELLOW, True),\n                AnsiBack.LIGHTBLUE_EX: (winterm.back, WinColor.BLUE, True),\n                AnsiBack.LIGHTMAGENTA_EX: (winterm.back, WinColor.MAGENTA, True),\n                AnsiBack.LIGHTCYAN_EX: (winterm.back, WinColor.CYAN, True),\n                AnsiBack.LIGHTWHITE_EX: (winterm.back, WinColor.GREY, True),\n            }\n        return dict()\n\n    def write(self, text):\n        if self.strip or self.convert:\n            self.write_and_convert(text)\n        else:\n            self.wrapped.write(text)\n            self.wrapped.flush()\n        if self.autoreset:\n            self.reset_all()\n\n\n    def reset_all(self):\n        if self.convert:\n            self.call_win32('m', (0,))\n        elif not self.strip and not self.stream.closed:\n            self.wrapped.write(Style.RESET_ALL)\n\n\n    def write_and_convert(self, text):\n        '''\n        Write the given text to our wrapped stream, stripping any ANSI\n        sequences from the text, and optionally converting them into win32\n        calls.\n        '''\n        cursor = 0\n        text = self.convert_osc(text)\n        for match in self.ANSI_CSI_RE.finditer(text):\n            start, end = match.span()\n            self.write_plain_text(text, cursor, start)\n            self.convert_ansi(*match.groups())\n            cursor = end\n        self.write_plain_text(text, cursor, len(text))\n\n\n    def write_plain_text(self, text, start, end):\n        if start < end:\n            self.wrapped.write(text[start:end])\n            self.wrapped.flush()\n\n\n    def convert_ansi(self, paramstring, command):\n        if self.convert:\n            params = self.extract_params(command, paramstring)\n            self.call_win32(command, params)\n\n\n    def extract_params(self, command, paramstring):\n        if command in 'Hf':\n            params = tuple(int(p) if len(p) != 0 else 1 for p in paramstring.split(';'))\n            while len(params) < 2:\n                # defaults:\n                params = params + (1,)\n        else:\n            params = tuple(int(p) for p in paramstring.split(';') if len(p) != 0)\n            if len(params) == 0:\n                # defaults:\n                if command in 'JKm':\n                    params = (0,)\n                elif command in 'ABCD':\n                    params = (1,)\n\n        return params\n\n\n    def call_win32(self, command, params):\n        if command == 'm':\n            for param in params:\n                if param in self.win32_calls:\n                    func_args = self.win32_calls[param]\n                    func = func_args[0]\n                    args = func_args[1:]\n                    kwargs = dict(on_stderr=self.on_stderr)\n                    func(*args, **kwargs)\n        elif command in 'J':\n            winterm.erase_screen(params[0], on_stderr=self.on_stderr)\n        elif command in 'K':\n            winterm.erase_line(params[0], on_stderr=self.on_stderr)\n        elif command in 'Hf':     # cursor position - absolute\n            winterm.set_cursor_position(params, on_stderr=self.on_stderr)\n        elif command in 'ABCD':   # cursor position - relative\n            n = params[0]\n            # A - up, B - down, C - forward, D - back\n            x, y = {'A': (0, -n), 'B': (0, n), 'C': (n, 0), 'D': (-n, 0)}[command]\n            winterm.cursor_adjust(x, y, on_stderr=self.on_stderr)\n\n\n    def convert_osc(self, text):\n        for match in self.ANSI_OSC_RE.finditer(text):\n            start, end = match.span()\n            text = text[:start] + text[end:]\n            paramstring, command = match.groups()\n            if command == BEL:\n                if paramstring.count(\";\") == 1:\n                    params = paramstring.split(\";\")\n                    # 0 - change title and icon (we will only change title)\n                    # 1 - change icon (we don't support this)\n                    # 2 - change title\n                    if params[0] in '02':\n                        winterm.set_title(params[1])\n        return text\n\n\n    def flush(self):\n        self.wrapped.flush()\n", "colorama/ansi.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n'''\nThis module generates ANSI character codes to printing colors to terminals.\nSee: http://en.wikipedia.org/wiki/ANSI_escape_code\n'''\n\nCSI = '\\033['\nOSC = '\\033]'\nBEL = '\\a'\n\n\ndef code_to_chars(code):\n    return CSI + str(code) + 'm'\n\ndef set_title(title):\n    return OSC + '2;' + title + BEL\n\ndef clear_screen(mode=2):\n    return CSI + str(mode) + 'J'\n\ndef clear_line(mode=2):\n    return CSI + str(mode) + 'K'\n\n\nclass AnsiCodes(object):\n    def __init__(self):\n        # the subclasses declare class attributes which are numbers.\n        # Upon instantiation we define instance attributes, which are the same\n        # as the class attributes but wrapped with the ANSI escape sequence\n        for name in dir(self):\n            if not name.startswith('_'):\n                value = getattr(self, name)\n                setattr(self, name, code_to_chars(value))\n\n\nclass AnsiCursor(object):\n    def UP(self, n=1):\n        return CSI + str(n) + 'A'\n    def DOWN(self, n=1):\n        return CSI + str(n) + 'B'\n    def FORWARD(self, n=1):\n        return CSI + str(n) + 'C'\n    def BACK(self, n=1):\n        return CSI + str(n) + 'D'\n    def POS(self, x=1, y=1):\n        return CSI + str(y) + ';' + str(x) + 'H'\n\n\nclass AnsiFore(AnsiCodes):\n    BLACK           = 30\n    RED             = 31\n    GREEN           = 32\n    YELLOW          = 33\n    BLUE            = 34\n    MAGENTA         = 35\n    CYAN            = 36\n    WHITE           = 37\n    RESET           = 39\n\n    # These are fairly well supported, but not part of the standard.\n    LIGHTBLACK_EX   = 90\n    LIGHTRED_EX     = 91\n    LIGHTGREEN_EX   = 92\n    LIGHTYELLOW_EX  = 93\n    LIGHTBLUE_EX    = 94\n    LIGHTMAGENTA_EX = 95\n    LIGHTCYAN_EX    = 96\n    LIGHTWHITE_EX   = 97\n\n\nclass AnsiBack(AnsiCodes):\n    BLACK           = 40\n    RED             = 41\n    GREEN           = 42\n    YELLOW          = 43\n    BLUE            = 44\n    MAGENTA         = 45\n    CYAN            = 46\n    WHITE           = 47\n    RESET           = 49\n\n    # These are fairly well supported, but not part of the standard.\n    LIGHTBLACK_EX   = 100\n    LIGHTRED_EX     = 101\n    LIGHTGREEN_EX   = 102\n    LIGHTYELLOW_EX  = 103\n    LIGHTBLUE_EX    = 104\n    LIGHTMAGENTA_EX = 105\n    LIGHTCYAN_EX    = 106\n    LIGHTWHITE_EX   = 107\n\n\nclass AnsiStyle(AnsiCodes):\n    BRIGHT    = 1\n    DIM       = 2\n    NORMAL    = 22\n    RESET_ALL = 0\n\nFore   = AnsiFore()\nBack   = AnsiBack()\nStyle  = AnsiStyle()\nCursor = AnsiCursor()\n", "colorama/winterm.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\ntry:\n    from msvcrt import get_osfhandle\nexcept ImportError:\n    def get_osfhandle(_):\n        raise OSError(\"This isn't windows!\")\n\n\nfrom . import win32\n\n# from wincon.h\nclass WinColor(object):\n    BLACK   = 0\n    BLUE    = 1\n    GREEN   = 2\n    CYAN    = 3\n    RED     = 4\n    MAGENTA = 5\n    YELLOW  = 6\n    GREY    = 7\n\n# from wincon.h\nclass WinStyle(object):\n    NORMAL              = 0x00 # dim text, dim background\n    BRIGHT              = 0x08 # bright text, dim background\n    BRIGHT_BACKGROUND   = 0x80 # dim text, bright background\n\nclass WinTerm(object):\n\n    def __init__(self):\n        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes\n        self.set_attrs(self._default)\n        self._default_fore = self._fore\n        self._default_back = self._back\n        self._default_style = self._style\n        # In order to emulate LIGHT_EX in windows, we borrow the BRIGHT style.\n        # So that LIGHT_EX colors and BRIGHT style do not clobber each other,\n        # we track them separately, since LIGHT_EX is overwritten by Fore/Back\n        # and BRIGHT is overwritten by Style codes.\n        self._light = 0\n\n    def get_attrs(self):\n        return self._fore + self._back * 16 + (self._style | self._light)\n\n    def set_attrs(self, value):\n        self._fore = value & 7\n        self._back = (value >> 4) & 7\n        self._style = value & (WinStyle.BRIGHT | WinStyle.BRIGHT_BACKGROUND)\n\n    def reset_all(self, on_stderr=None):\n        self.set_attrs(self._default)\n        self.set_console(attrs=self._default)\n        self._light = 0\n\n    def fore(self, fore=None, light=False, on_stderr=False):\n        if fore is None:\n            fore = self._default_fore\n        self._fore = fore\n        # Emulate LIGHT_EX with BRIGHT Style\n        if light:\n            self._light |= WinStyle.BRIGHT\n        else:\n            self._light &= ~WinStyle.BRIGHT\n        self.set_console(on_stderr=on_stderr)\n\n    def back(self, back=None, light=False, on_stderr=False):\n        if back is None:\n            back = self._default_back\n        self._back = back\n        # Emulate LIGHT_EX with BRIGHT_BACKGROUND Style\n        if light:\n            self._light |= WinStyle.BRIGHT_BACKGROUND\n        else:\n            self._light &= ~WinStyle.BRIGHT_BACKGROUND\n        self.set_console(on_stderr=on_stderr)\n\n    def style(self, style=None, on_stderr=False):\n        if style is None:\n            style = self._default_style\n        self._style = style\n        self.set_console(on_stderr=on_stderr)\n\n    def set_console(self, attrs=None, on_stderr=False):\n        if attrs is None:\n            attrs = self.get_attrs()\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleTextAttribute(handle, attrs)\n\n    def get_position(self, handle):\n        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition\n        # Because Windows coordinates are 0-based,\n        # and win32.SetConsoleCursorPosition expects 1-based.\n        position.X += 1\n        position.Y += 1\n        return position\n\n    def set_cursor_position(self, position=None, on_stderr=False):\n        if position is None:\n            # I'm not currently tracking the position, so there is no default.\n            # position = self.get_position()\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleCursorPosition(handle, position)\n\n    def cursor_adjust(self, x, y, on_stderr=False):\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        position = self.get_position(handle)\n        adjusted_position = (position.Y + y, position.X + x)\n        win32.SetConsoleCursorPosition(handle, adjusted_position, adjust=False)\n\n    def erase_screen(self, mode=0, on_stderr=False):\n        # 0 should clear from the cursor to the end of the screen.\n        # 1 should clear from the cursor to the beginning of the screen.\n        # 2 should clear the entire screen, and move cursor to (1,1)\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        # get the number of character cells in the current buffer\n        cells_in_screen = csbi.dwSize.X * csbi.dwSize.Y\n        # get number of character cells before current cursor position\n        cells_before_cursor = csbi.dwSize.X * csbi.dwCursorPosition.Y + csbi.dwCursorPosition.X\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = cells_in_screen - cells_before_cursor\n        elif mode == 1:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_before_cursor\n        elif mode == 2:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_in_screen\n        else:\n            # invalid mode\n            return\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n        if mode == 2:\n            # put the cursor where needed\n            win32.SetConsoleCursorPosition(handle, (1, 1))\n\n    def erase_line(self, mode=0, on_stderr=False):\n        # 0 should clear from the cursor to the end of the line.\n        # 1 should clear from the cursor to the beginning of the line.\n        # 2 should clear the entire line.\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = csbi.dwSize.X - csbi.dwCursorPosition.X\n        elif mode == 1:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwCursorPosition.X\n        elif mode == 2:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwSize.X\n        else:\n            # invalid mode\n            return\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n\n    def set_title(self, title):\n        win32.SetConsoleTitle(title)\n\n\ndef enable_vt_processing(fd):\n    if win32.windll is None or not win32.winapi_test():\n        return False\n\n    try:\n        handle = get_osfhandle(fd)\n        mode = win32.GetConsoleMode(handle)\n        win32.SetConsoleMode(\n            handle,\n            mode | win32.ENABLE_VIRTUAL_TERMINAL_PROCESSING,\n        )\n\n        mode = win32.GetConsoleMode(handle)\n        if mode & win32.ENABLE_VIRTUAL_TERMINAL_PROCESSING:\n            return True\n    # Can get TypeError in testsuite where 'fd' is a Mock() and IOError in python2.7\n    except (IOError, OSError, TypeError):\n        return False\n", "colorama/initialise.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nimport atexit\nimport contextlib\nimport sys\n\nfrom .ansitowin32 import AnsiToWin32\n\n\ndef _wipe_internal_state_for_tests():\n    global orig_stdout, orig_stderr\n    orig_stdout = None\n    orig_stderr = None\n\n    global wrapped_stdout, wrapped_stderr\n    wrapped_stdout = None\n    wrapped_stderr = None\n\n    global atexit_done\n    atexit_done = False\n\n    global fixed_windows_console\n    fixed_windows_console = False\n\n    try:\n        # no-op if it wasn't registered\n        atexit.unregister(reset_all)\n    except AttributeError:\n        # python 2: no atexit.unregister. Oh well, we did our best.\n        pass\n\n\ndef reset_all():\n    if AnsiToWin32 is not None:    # Issue #74: objects might become None at exit\n        AnsiToWin32(orig_stdout).reset_all()\n\n\ndef init(autoreset=False, convert=None, strip=None, wrap=True):\n\n    if not wrap and any([autoreset, convert, strip]):\n        raise ValueError('wrap=False conflicts with any other arg=True')\n\n    global wrapped_stdout, wrapped_stderr\n    global orig_stdout, orig_stderr\n\n    orig_stdout = sys.stdout\n    orig_stderr = sys.stderr\n\n    if sys.stdout is None:\n        wrapped_stdout = None\n    else:\n        sys.stdout = wrapped_stdout = \\\n            wrap_stream(orig_stdout, convert, strip, autoreset, wrap)\n    if sys.stderr is None:\n        wrapped_stderr = None\n    else:\n        sys.stderr = wrapped_stderr = \\\n            wrap_stream(orig_stderr, convert, strip, autoreset, wrap)\n\n    global atexit_done\n    if not atexit_done:\n        atexit.register(reset_all)\n        atexit_done = True\n\n\ndef deinit():\n    if orig_stdout is not None:\n        sys.stdout = orig_stdout\n    if orig_stderr is not None:\n        sys.stderr = orig_stderr\n\n\ndef just_fix_windows_console():\n    global fixed_windows_console\n\n    if sys.platform != \"win32\":\n        return\n    if fixed_windows_console:\n        return\n    if wrapped_stdout is not None or wrapped_stderr is not None:\n        # Someone already ran init() and it did stuff, so we won't second-guess them\n        return\n\n    # On newer versions of Windows, AnsiToWin32.__init__ will implicitly enable the\n    # native ANSI support in the console as a side-effect. We only need to actually\n    # replace sys.stdout/stderr if we're in the old-style conversion mode.\n    new_stdout = AnsiToWin32(sys.stdout, convert=None, strip=None, autoreset=False)\n    if new_stdout.convert:\n        sys.stdout = new_stdout\n    new_stderr = AnsiToWin32(sys.stderr, convert=None, strip=None, autoreset=False)\n    if new_stderr.convert:\n        sys.stderr = new_stderr\n\n    fixed_windows_console = True\n\n@contextlib.contextmanager\ndef colorama_text(*args, **kwargs):\n    init(*args, **kwargs)\n    try:\n        yield\n    finally:\n        deinit()\n\n\ndef reinit():\n    if wrapped_stdout is not None:\n        sys.stdout = wrapped_stdout\n    if wrapped_stderr is not None:\n        sys.stderr = wrapped_stderr\n\n\ndef wrap_stream(stream, convert, strip, autoreset, wrap):\n    if wrap:\n        wrapper = AnsiToWin32(stream,\n            convert=convert, strip=strip, autoreset=autoreset)\n        if wrapper.should_wrap():\n            stream = wrapper.stream\n    return stream\n\n\n# Use this for initial setup as well, to reduce code duplication\n_wipe_internal_state_for_tests()\n", "colorama/__init__.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom .initialise import init, deinit, reinit, colorama_text, just_fix_windows_console\nfrom .ansi import Fore, Back, Style, Cursor\nfrom .ansitowin32 import AnsiToWin32\n\n__version__ = '0.4.7dev1'\n\n", "demos/demo09.py": "# https://www.youtube.com/watch?v=F5a8RLY2N8M&list=PL1_riyn9sOjcKIAYzo7f8drxD-Yg9La-D&index=61\n# Generic colorama demo using command line arguments\n# By George Ogden\nfrom colorama import Fore, Back, Style, init\nimport argparse\nparser = argparse.ArgumentParser(\"colorama demo\")\n\ndef format(module):\n    return list(map(lambda x: x.lower(),module.__dict__.keys()))\n\ndef find(module,item):\n    return module.__dict__[item.upper()]\n\nparser.add_argument(\"-c\",\"--colour\",choices=format(Fore),default=\"RESET\")\nparser.add_argument(\"-b\",\"--background\",choices=format(Back),default=\"RESET\")\nparser.add_argument(\"-s\",\"--style\",choices=format(Style),default=\"RESET_ALL\")\nparser.add_argument(\"-t\",\"--text\",default=\"Lorem ipsum dolor sit amet\")\n\nargs = parser.parse_args()\n\nprint(find(Style,args.style) + find(Fore,args.colour) + find(Back,args.background) + args.text + Style.RESET_ALL)", "demos/demo05.py": "#!/usr/bin/python\n# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# Demonstrate the difference between colorama initialized with wrapping on and off.\n# The point of the demonstration is to show how the ANSI wrapping on Windows can be disabled.\n# The unwrapped cases will be interpreted with ANSI on Unix, but not on Windows.\n\nfrom __future__ import print_function\nimport sys\nimport fixpath\nfrom colorama import AnsiToWin32, init, Fore\n\ninit()\nprint('%sWrapped yellow going to stdout, via the default print function.' % Fore.YELLOW)\n\ninit(wrap=False)\nprint('%sUnwrapped CYAN going to stdout, via the default print function.' % Fore.CYAN)\nprint('%sUnwrapped CYAN, using the file parameter to write via colorama the AnsiToWin32 function.' % Fore.CYAN, file=AnsiToWin32(sys.stdout))\nprint('%sUnwrapped RED going to stdout, via the default print function.' % Fore.RED)\n\ninit()\nprint('%sWrapped RED going to stdout, via the default print function.' % Fore.RED)\n", "demos/demo01.py": "#!/usr/bin/python\n# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# print grid of all colors and brightnesses\n# uses stdout.write to write chars with no newline nor spaces between them\n# This should run more-or-less identically on Windows and Unix.\nfrom __future__ import print_function\nimport sys\n\n# Add parent dir to sys path, so the following 'import colorama' always finds\n# the local source in preference to any installed version of colorama.\nimport fixpath\nfrom colorama import just_fix_windows_console, Fore, Back, Style\n\njust_fix_windows_console()\n\n# Fore, Back and Style are convenience classes for the constant ANSI strings that set\n#     the foreground, background and style. The don't have any magic of their own.\nFORES = [ Fore.BLACK, Fore.RED, Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN, Fore.WHITE ]\nBACKS = [ Back.BLACK, Back.RED, Back.GREEN, Back.YELLOW, Back.BLUE, Back.MAGENTA, Back.CYAN, Back.WHITE ]\nSTYLES = [ Style.DIM, Style.NORMAL, Style.BRIGHT ]\n\nNAMES = {\n    Fore.BLACK: 'black', Fore.RED: 'red', Fore.GREEN: 'green', Fore.YELLOW: 'yellow', Fore.BLUE: 'blue', Fore.MAGENTA: 'magenta', Fore.CYAN: 'cyan', Fore.WHITE: 'white'\n    , Fore.RESET: 'reset',\n    Back.BLACK: 'black', Back.RED: 'red', Back.GREEN: 'green', Back.YELLOW: 'yellow', Back.BLUE: 'blue', Back.MAGENTA: 'magenta', Back.CYAN: 'cyan', Back.WHITE: 'white',\n    Back.RESET: 'reset'\n}\n\n# show the color names\nsys.stdout.write('        ')\nfor foreground in FORES:\n    sys.stdout.write('%s%-7s' % (foreground, NAMES[foreground]))\nprint()\n\n# make a row for each background color\nfor background in BACKS:\n    sys.stdout.write('%s%-7s%s %s' % (background, NAMES[background], Back.RESET, background))\n    # make a column for each foreground color\n    for foreground in FORES:\n        sys.stdout.write(foreground)\n        # show dim, normal bright\n        for brightness in STYLES:\n            sys.stdout.write('%sX ' % brightness)\n        sys.stdout.write(Style.RESET_ALL + ' ' + background)\n    print(Style.RESET_ALL)\n\nprint()\n", "demos/demo02.py": "#!/usr/bin/python\n# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# Simple demo of changing foreground, background and brightness.\n\nfrom __future__ import print_function\nimport fixpath\nfrom colorama import just_fix_windows_console, Fore, Back, Style\n\njust_fix_windows_console()\n\nprint(Fore.GREEN + 'green, '\n    + Fore.RED + 'red, '\n    + Fore.RESET + 'normal, '\n    , end='')\nprint(Back.GREEN + 'green, '\n    + Back.RED + 'red, '\n    + Back.RESET + 'normal, '\n    , end='')\nprint(Style.DIM + 'dim, '\n    + Style.BRIGHT + 'bright, '\n    + Style.NORMAL + 'normal'\n    , end=' ')\nprint()\n", "demos/demo06.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom __future__ import print_function\nimport fixpath\nimport colorama\nfrom colorama import Fore, Back, Style, Cursor\nfrom random import randint, choice\nfrom string import printable\n\n# Demonstrate printing colored, random characters at random positions on the screen\n\n# Fore, Back and Style are convenience classes for the constant ANSI strings that set\n#     the foreground, background and style. They don't have any magic of their own.\nFORES = [ Fore.BLACK, Fore.RED, Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN, Fore.WHITE ]\nBACKS = [ Back.BLACK, Back.RED, Back.GREEN, Back.YELLOW, Back.BLUE, Back.MAGENTA, Back.CYAN, Back.WHITE ]\nSTYLES = [ Style.DIM, Style.NORMAL, Style.BRIGHT ]\n\n# This assumes your terminal is 80x24. Ansi minimum coordinate is (1,1).\nMINY, MAXY = 1, 24\nMINX, MAXX = 1, 80\n\n# set of printable ASCII characters, including a space.\nCHARS = ' ' + printable.strip()\n\nPASSES = 1000\n\ndef main():\n    colorama.just_fix_windows_console()\n    pos = lambda y, x: Cursor.POS(x, y)\n    # draw a white border.\n    print(Back.WHITE, end='')\n    print('%s%s' % (pos(MINY, MINX), ' '*MAXX), end='')\n    for y in range(MINY, 1+MAXY):\n        print('%s %s ' % (pos(y, MINX), pos(y, MAXX)), end='')\n    print('%s%s' % (pos(MAXY, MINX), ' '*MAXX), end='')\n    # draw some blinky lights for a while.\n    for i in range(PASSES):\n        print('%s%s%s%s%s' % (pos(randint(1+MINY,MAXY-1), randint(1+MINX,MAXX-1)), choice(FORES), choice(BACKS), choice(STYLES), choice(CHARS)), end='')\n    # put cursor to top, left, and set color to white-on-black with normal brightness.\n    print('%s%s%s%s' % (pos(MINY, MINX), Fore.WHITE, Back.BLACK, Style.NORMAL), end='')\n\nif __name__ == '__main__':\n    main()\n", "demos/fixpath.py": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# Add demo dir's parent to sys path, so that 'import colorama' always finds\n# the local source in preference to any installed version of colorama.\nimport sys\nfrom os.path import normpath, dirname, join\nlocal_colorama_module = normpath(join(dirname(__file__), '..'))\nsys.path.insert(0, local_colorama_module)\n", "demos/demo04.py": "#!/usr/bin/python\n# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# check that stripped ANSI in redirected stderr does not affect stdout\nfrom __future__ import print_function\nimport sys\nimport fixpath\nfrom colorama import init, Fore\n\ninit()\nprint(Fore.GREEN + 'GREEN set on stdout. ', end='')\nprint(Fore.RED + 'RED redirected stderr', file=sys.stderr)\nprint('Further stdout should be GREEN, i.e., the stderr redirection should not affect stdout.')\n", "demos/demo08.py": "from __future__ import print_function\nimport fixpath\nfrom colorama import colorama_text, Fore\n\n\ndef main():\n    \"\"\"automatically reset stdout\"\"\"\n    with colorama_text():\n        print(Fore.GREEN + 'text is green')\n        print(Fore.RESET + 'text is back to normal')\n\n    print('text is back to stdout')\n\nif __name__ == '__main__':\n    main()\n", "demos/demo07.py": "from __future__ import print_function\nimport fixpath\nimport colorama\n\n# Demonstrate cursor relative movement: UP, DOWN, FORWARD, and BACK in colorama.CURSOR\n\nup = colorama.Cursor.UP\ndown = colorama.Cursor.DOWN\nforward = colorama.Cursor.FORWARD\nback = colorama.Cursor.BACK\n\ndef main():\n    \"\"\"\n    expected output:\n    1a2\n    aba\n    3a4\n    \"\"\"\n    colorama.just_fix_windows_console()\n    print(\"aaa\")\n    print(\"aaa\")\n    print(\"aaa\")\n    print(forward() + up(2) + \"b\" + up() + back(2) + \"1\" + forward() + \"2\" + back(3) + down(2) + \"3\" + forward() + \"4\")\n\n\nif __name__ == '__main__':\n    main()\n", "demos/demo03.py": "#!/usr/bin/python\n# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\n\n# Demonstrate the different behavior when autoreset is True and False.\n\nfrom __future__ import print_function\nimport fixpath\nfrom colorama import init, Fore, Back, Style\n\ninit(autoreset=True)\nprint(Fore.CYAN + Back.MAGENTA + Style.BRIGHT + 'Line 1: colored, with autoreset=True')\nprint('Line 2: When auto reset is True, the color settings need to be set with every print.')\n\ninit(autoreset=False)\nprint(Fore.YELLOW + Back.BLUE + Style.BRIGHT + 'Line 3: colored, with autoreset=False')\nprint('Line 4: When autoreset=False, the prior color settings linger (this is the default behavior).')\n"}