{"src/wheel/bdist_wheel.py": "\"\"\"\nCreate a wheel (.whl) distribution.\n\nA wheel is a built archive format.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport shutil\nimport stat\nimport struct\nimport sys\nimport sysconfig\nimport warnings\nfrom email.generator import BytesGenerator, Generator\nfrom email.policy import EmailPolicy\nfrom glob import iglob\nfrom shutil import rmtree\nfrom typing import TYPE_CHECKING, Callable, Iterable, Literal, Sequence, cast\nfrom zipfile import ZIP_DEFLATED, ZIP_STORED\n\nimport setuptools\nfrom setuptools import Command\n\nfrom . import __version__ as wheel_version\nfrom .metadata import pkginfo_to_metadata\nfrom .util import log\nfrom .vendored.packaging import tags\nfrom .vendored.packaging import version as _packaging_version\nfrom .wheelfile import WheelFile\n\nif TYPE_CHECKING:\n    import types\n\n\ndef safe_name(name: str) -> str:\n    \"\"\"Convert an arbitrary string to a standard distribution name\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub(\"[^A-Za-z0-9.]+\", \"-\", name)\n\n\ndef safe_version(version: str) -> str:\n    \"\"\"\n    Convert an arbitrary string to a standard version string\n    \"\"\"\n    try:\n        # normalize the version\n        return str(_packaging_version.Version(version))\n    except _packaging_version.InvalidVersion:\n        version = version.replace(\" \", \".\")\n        return re.sub(\"[^A-Za-z0-9.]+\", \"-\", version)\n\n\nsetuptools_major_version = int(setuptools.__version__.split(\".\")[0])\n\nPY_LIMITED_API_PATTERN = r\"cp3\\d\"\n\n\ndef _is_32bit_interpreter() -> bool:\n    return struct.calcsize(\"P\") == 4\n\n\ndef python_tag() -> str:\n    return f\"py{sys.version_info[0]}\"\n\n\ndef get_platform(archive_root: str | None) -> str:\n    \"\"\"Return our platform name 'win32', 'linux_x86_64'\"\"\"\n    result = sysconfig.get_platform()\n    if result.startswith(\"macosx\") and archive_root is not None:\n        from .macosx_libfile import calculate_macosx_platform_tag\n\n        result = calculate_macosx_platform_tag(archive_root, result)\n    elif _is_32bit_interpreter():\n        if result == \"linux-x86_64\":\n            # pip pull request #3497\n            result = \"linux-i686\"\n        elif result == \"linux-aarch64\":\n            # packaging pull request #234\n            # TODO armv8l, packaging pull request #690 => this did not land\n            # in pip/packaging yet\n            result = \"linux-armv7l\"\n\n    return result.replace(\"-\", \"_\")\n\n\ndef get_flag(\n    var: str, fallback: bool, expected: bool = True, warn: bool = True\n) -> bool:\n    \"\"\"Use a fallback value for determining SOABI flags if the needed config\n    var is unset or unavailable.\"\"\"\n    val = sysconfig.get_config_var(var)\n    if val is None:\n        if warn:\n            warnings.warn(\n                f\"Config variable '{var}' is unset, Python ABI tag may be incorrect\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        return fallback\n    return val == expected\n\n\ndef get_abi_tag() -> str | None:\n    \"\"\"Return the ABI tag based on SOABI (if available) or emulate SOABI (PyPy2).\"\"\"\n    soabi: str = sysconfig.get_config_var(\"SOABI\")\n    impl = tags.interpreter_name()\n    if not soabi and impl in (\"cp\", \"pp\") and hasattr(sys, \"maxunicode\"):\n        d = \"\"\n        m = \"\"\n        u = \"\"\n        if get_flag(\"Py_DEBUG\", hasattr(sys, \"gettotalrefcount\"), warn=(impl == \"cp\")):\n            d = \"d\"\n\n        if get_flag(\n            \"WITH_PYMALLOC\",\n            impl == \"cp\",\n            warn=(impl == \"cp\" and sys.version_info < (3, 8)),\n        ) and sys.version_info < (3, 8):\n            m = \"m\"\n\n        abi = f\"{impl}{tags.interpreter_version()}{d}{m}{u}\"\n    elif soabi and impl == \"cp\" and soabi.startswith(\"cpython\"):\n        # non-Windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi and impl == \"cp\" and soabi.startswith(\"cp\"):\n        # Windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi and impl == \"pp\":\n        # we want something like pypy36-pp73\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n        abi = abi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    elif soabi and impl == \"graalpy\":\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n        abi = abi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    elif soabi:\n        abi = soabi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    else:\n        abi = None\n\n    return abi\n\n\ndef safer_name(name: str) -> str:\n    return safe_name(name).replace(\"-\", \"_\")\n\n\ndef safer_version(version: str) -> str:\n    return safe_version(version).replace(\"-\", \"_\")\n\n\ndef remove_readonly(\n    func: Callable[..., object],\n    path: str,\n    excinfo: tuple[type[Exception], Exception, types.TracebackType],\n) -> None:\n    remove_readonly_exc(func, path, excinfo[1])\n\n\ndef remove_readonly_exc(func: Callable[..., object], path: str, exc: Exception) -> None:\n    os.chmod(path, stat.S_IWRITE)\n    func(path)\n\n\nclass bdist_wheel(Command):\n    description = \"create a wheel distribution\"\n\n    supported_compressions = {\n        \"stored\": ZIP_STORED,\n        \"deflated\": ZIP_DEFLATED,\n    }\n\n    user_options = [\n        (\"bdist-dir=\", \"b\", \"temporary directory for creating the distribution\"),\n        (\n            \"plat-name=\",\n            \"p\",\n            \"platform name to embed in generated filenames \"\n            f\"(default: {get_platform(None)})\",\n        ),\n        (\n            \"keep-temp\",\n            \"k\",\n            \"keep the pseudo-installation tree around after \"\n            \"creating the distribution archive\",\n        ),\n        (\"dist-dir=\", \"d\", \"directory to put final built distributions in\"),\n        (\"skip-build\", None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            \"relative\",\n            None,\n            \"build the archive using relative paths (default: false)\",\n        ),\n        (\n            \"owner=\",\n            \"u\",\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            \"group=\",\n            \"g\",\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n        (\"universal\", None, \"make a universal wheel (default: false)\"),\n        (\n            \"compression=\",\n            None,\n            \"zipfile compression (one of: {}) (default: 'deflated')\".format(\n                \", \".join(supported_compressions)\n            ),\n        ),\n        (\n            \"python-tag=\",\n            None,\n            f\"Python implementation compatibility tag (default: '{python_tag()}')\",\n        ),\n        (\n            \"build-number=\",\n            None,\n            \"Build number for this particular version. \"\n            \"As specified in PEP-0427, this must start with a digit. \"\n            \"[default: None]\",\n        ),\n        (\n            \"py-limited-api=\",\n            None,\n            \"Python tag (cp32|cp33|cpNN) for abi3 wheel tag (default: false)\",\n        ),\n    ]\n\n    boolean_options = [\"keep-temp\", \"skip-build\", \"relative\", \"universal\"]\n\n    def initialize_options(self):\n        self.bdist_dir: str = None\n        self.data_dir = None\n        self.plat_name: str | None = None\n        self.plat_tag = None\n        self.format = \"zip\"\n        self.keep_temp = False\n        self.dist_dir: str | None = None\n        self.egginfo_dir = None\n        self.root_is_pure: bool | None = None\n        self.skip_build = None\n        self.relative = False\n        self.owner = None\n        self.group = None\n        self.universal: bool = False\n        self.compression: str | int = \"deflated\"\n        self.python_tag: str = python_tag()\n        self.build_number: str | None = None\n        self.py_limited_api: str | Literal[False] = False\n        self.plat_name_supplied = False\n\n    def finalize_options(self):\n        if self.bdist_dir is None:\n            bdist_base = self.get_finalized_command(\"bdist\").bdist_base\n            self.bdist_dir = os.path.join(bdist_base, \"wheel\")\n\n        egg_info = self.distribution.get_command_obj(\"egg_info\")\n        egg_info.ensure_finalized()  # needed for correct `wheel_dist_name`\n\n        self.data_dir = self.wheel_dist_name + \".data\"\n        self.plat_name_supplied = self.plat_name is not None\n\n        try:\n            self.compression = self.supported_compressions[self.compression]\n        except KeyError:\n            raise ValueError(f\"Unsupported compression: {self.compression}\") from None\n\n        need_options = (\"dist_dir\", \"plat_name\", \"skip_build\")\n\n        self.set_undefined_options(\"bdist\", *zip(need_options, need_options))\n\n        self.root_is_pure = not (\n            self.distribution.has_ext_modules() or self.distribution.has_c_libraries()\n        )\n\n        if self.py_limited_api and not re.match(\n            PY_LIMITED_API_PATTERN, self.py_limited_api\n        ):\n            raise ValueError(f\"py-limited-api must match '{PY_LIMITED_API_PATTERN}'\")\n\n        # Support legacy [wheel] section for setting universal\n        wheel = self.distribution.get_option_dict(\"wheel\")\n        if \"universal\" in wheel:\n            # please don't define this in your global configs\n            log.warning(\n                \"The [wheel] section is deprecated. Use [bdist_wheel] instead.\",\n            )\n            val = wheel[\"universal\"][1].strip()\n            if val.lower() in (\"1\", \"true\", \"yes\"):\n                self.universal = True\n\n        if self.build_number is not None and not self.build_number[:1].isdigit():\n            raise ValueError(\"Build tag (build-number) must start with a digit.\")\n\n    @property\n    def wheel_dist_name(self):\n        \"\"\"Return distribution full name with - replaced with _\"\"\"\n        components = (\n            safer_name(self.distribution.get_name()),\n            safer_version(self.distribution.get_version()),\n        )\n        if self.build_number:\n            components += (self.build_number,)\n        return \"-\".join(components)\n\n    def get_tag(self) -> tuple[str, str, str]:\n        # bdist sets self.plat_name if unset, we should only use it for purepy\n        # wheels if the user supplied it.\n        if self.plat_name_supplied:\n            plat_name = cast(str, self.plat_name)\n        elif self.root_is_pure:\n            plat_name = \"any\"\n        else:\n            # macosx contains system version in platform name so need special handle\n            if self.plat_name and not self.plat_name.startswith(\"macosx\"):\n                plat_name = self.plat_name\n            else:\n                # on macosx always limit the platform name to comply with any\n                # c-extension modules in bdist_dir, since the user can specify\n                # a higher MACOSX_DEPLOYMENT_TARGET via tools like CMake\n\n                # on other platforms, and on macosx if there are no c-extension\n                # modules, use the default platform name.\n                plat_name = get_platform(self.bdist_dir)\n\n            if _is_32bit_interpreter():\n                if plat_name in (\"linux-x86_64\", \"linux_x86_64\"):\n                    plat_name = \"linux_i686\"\n                if plat_name in (\"linux-aarch64\", \"linux_aarch64\"):\n                    # TODO armv8l, packaging pull request #690 => this did not land\n                    # in pip/packaging yet\n                    plat_name = \"linux_armv7l\"\n\n        plat_name = (\n            plat_name.lower().replace(\"-\", \"_\").replace(\".\", \"_\").replace(\" \", \"_\")\n        )\n\n        if self.root_is_pure:\n            if self.universal:\n                impl = \"py2.py3\"\n            else:\n                impl = self.python_tag\n            tag = (impl, \"none\", plat_name)\n        else:\n            impl_name = tags.interpreter_name()\n            impl_ver = tags.interpreter_version()\n            impl = impl_name + impl_ver\n            # We don't work on CPython 3.1, 3.0.\n            if self.py_limited_api and (impl_name + impl_ver).startswith(\"cp3\"):\n                impl = self.py_limited_api\n                abi_tag = \"abi3\"\n            else:\n                abi_tag = str(get_abi_tag()).lower()\n            tag = (impl, abi_tag, plat_name)\n            # issue gh-374: allow overriding plat_name\n            supported_tags = [\n                (t.interpreter, t.abi, plat_name) for t in tags.sys_tags()\n            ]\n            assert (\n                tag in supported_tags\n            ), f\"would build wheel with unsupported tag {tag}\"\n        return tag\n\n    def run(self):\n        build_scripts = self.reinitialize_command(\"build_scripts\")\n        build_scripts.executable = \"python\"\n        build_scripts.force = True\n\n        build_ext = self.reinitialize_command(\"build_ext\")\n        build_ext.inplace = False\n\n        if not self.skip_build:\n            self.run_command(\"build\")\n\n        install = self.reinitialize_command(\"install\", reinit_subcommands=True)\n        install.root = self.bdist_dir\n        install.compile = False\n        install.skip_build = self.skip_build\n        install.warn_dir = False\n\n        # A wheel without setuptools scripts is more cross-platform.\n        # Use the (undocumented) `no_ep` option to setuptools'\n        # install_scripts command to avoid creating entry point scripts.\n        install_scripts = self.reinitialize_command(\"install_scripts\")\n        install_scripts.no_ep = True\n\n        # Use a custom scheme for the archive, because we have to decide\n        # at installation time which scheme to use.\n        for key in (\"headers\", \"scripts\", \"data\", \"purelib\", \"platlib\"):\n            setattr(install, \"install_\" + key, os.path.join(self.data_dir, key))\n\n        basedir_observed = \"\"\n\n        if os.name == \"nt\":\n            # win32 barfs if any of these are ''; could be '.'?\n            # (distutils.command.install:change_roots bug)\n            basedir_observed = os.path.normpath(os.path.join(self.data_dir, \"..\"))\n            self.install_libbase = self.install_lib = basedir_observed\n\n        setattr(\n            install,\n            \"install_purelib\" if self.root_is_pure else \"install_platlib\",\n            basedir_observed,\n        )\n\n        log.info(f\"installing to {self.bdist_dir}\")\n\n        self.run_command(\"install\")\n\n        impl_tag, abi_tag, plat_tag = self.get_tag()\n        archive_basename = f\"{self.wheel_dist_name}-{impl_tag}-{abi_tag}-{plat_tag}\"\n        if not self.relative:\n            archive_root = self.bdist_dir\n        else:\n            archive_root = os.path.join(\n                self.bdist_dir, self._ensure_relative(install.install_base)\n            )\n\n        self.set_undefined_options(\"install_egg_info\", (\"target\", \"egginfo_dir\"))\n        distinfo_dirname = (\n            f\"{safer_name(self.distribution.get_name())}-\"\n            f\"{safer_version(self.distribution.get_version())}.dist-info\"\n        )\n        distinfo_dir = os.path.join(self.bdist_dir, distinfo_dirname)\n        self.egg2dist(self.egginfo_dir, distinfo_dir)\n\n        self.write_wheelfile(distinfo_dir)\n\n        # Make the archive\n        if not os.path.exists(self.dist_dir):\n            os.makedirs(self.dist_dir)\n\n        wheel_path = os.path.join(self.dist_dir, archive_basename + \".whl\")\n        with WheelFile(wheel_path, \"w\", self.compression) as wf:\n            wf.write_files(archive_root)\n\n        # Add to 'Distribution.dist_files' so that the \"upload\" command works\n        getattr(self.distribution, \"dist_files\", []).append(\n            (\n                \"bdist_wheel\",\n                \"{}.{}\".format(*sys.version_info[:2]),  # like 3.7\n                wheel_path,\n            )\n        )\n\n        if not self.keep_temp:\n            log.info(f\"removing {self.bdist_dir}\")\n            if not self.dry_run:\n                if sys.version_info < (3, 12):\n                    rmtree(self.bdist_dir, onerror=remove_readonly)\n                else:\n                    rmtree(self.bdist_dir, onexc=remove_readonly_exc)\n\n    def write_wheelfile(\n        self, wheelfile_base: str, generator: str = f\"bdist_wheel ({wheel_version})\"\n    ):\n        from email.message import Message\n\n        msg = Message()\n        msg[\"Wheel-Version\"] = \"1.0\"  # of the spec\n        msg[\"Generator\"] = generator\n        msg[\"Root-Is-Purelib\"] = str(self.root_is_pure).lower()\n        if self.build_number is not None:\n            msg[\"Build\"] = self.build_number\n\n        # Doesn't work for bdist_wininst\n        impl_tag, abi_tag, plat_tag = self.get_tag()\n        for impl in impl_tag.split(\".\"):\n            for abi in abi_tag.split(\".\"):\n                for plat in plat_tag.split(\".\"):\n                    msg[\"Tag\"] = \"-\".join((impl, abi, plat))\n\n        wheelfile_path = os.path.join(wheelfile_base, \"WHEEL\")\n        log.info(f\"creating {wheelfile_path}\")\n        with open(wheelfile_path, \"wb\") as f:\n            BytesGenerator(f, maxheaderlen=0).flatten(msg)\n\n    def _ensure_relative(self, path: str) -> str:\n        # copied from dir_util, deleted\n        drive, path = os.path.splitdrive(path)\n        if path[0:1] == os.sep:\n            path = drive + path[1:]\n        return path\n\n    @property\n    def license_paths(self) -> Iterable[str]:\n        if setuptools_major_version >= 57:\n            # Setuptools has resolved any patterns to actual file names\n            return self.distribution.metadata.license_files or ()\n\n        files: set[str] = set()\n        metadata = self.distribution.get_option_dict(\"metadata\")\n        if setuptools_major_version >= 42:\n            # Setuptools recognizes the license_files option but does not do globbing\n            patterns = cast(Sequence[str], self.distribution.metadata.license_files)\n        else:\n            # Prior to those, wheel is entirely responsible for handling license files\n            if \"license_files\" in metadata:\n                patterns = metadata[\"license_files\"][1].split()\n            else:\n                patterns = ()\n\n        if \"license_file\" in metadata:\n            warnings.warn(\n                'The \"license_file\" option is deprecated. Use \"license_files\" instead.',\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            files.add(metadata[\"license_file\"][1])\n\n        if not files and not patterns and not isinstance(patterns, list):\n            patterns = (\"LICEN[CS]E*\", \"COPYING*\", \"NOTICE*\", \"AUTHORS*\")\n\n        for pattern in patterns:\n            for path in iglob(pattern):\n                if path.endswith(\"~\"):\n                    log.debug(\n                        f'ignoring license file \"{path}\" as it looks like a backup'\n                    )\n                    continue\n\n                if path not in files and os.path.isfile(path):\n                    log.info(\n                        f'adding license file \"{path}\" (matched pattern \"{pattern}\")'\n                    )\n                    files.add(path)\n\n        return files\n\n    def egg2dist(self, egginfo_path: str, distinfo_path: str):\n        \"\"\"Convert an .egg-info directory into a .dist-info directory\"\"\"\n\n        def adios(p: str) -> None:\n            \"\"\"Appropriately delete directory, file or link.\"\"\"\n            if os.path.exists(p) and not os.path.islink(p) and os.path.isdir(p):\n                shutil.rmtree(p)\n            elif os.path.exists(p):\n                os.unlink(p)\n\n        adios(distinfo_path)\n\n        if not os.path.exists(egginfo_path):\n            # There is no egg-info. This is probably because the egg-info\n            # file/directory is not named matching the distribution name used\n            # to name the archive file. Check for this case and report\n            # accordingly.\n            import glob\n\n            pat = os.path.join(os.path.dirname(egginfo_path), \"*.egg-info\")\n            possible = glob.glob(pat)\n            err = f\"Egg metadata expected at {egginfo_path} but not found\"\n            if possible:\n                alt = os.path.basename(possible[0])\n                err += f\" ({alt} found - possible misnamed archive file?)\"\n\n            raise ValueError(err)\n\n        if os.path.isfile(egginfo_path):\n            # .egg-info is a single file\n            pkg_info = pkginfo_to_metadata(egginfo_path, egginfo_path)\n            os.mkdir(distinfo_path)\n        else:\n            # .egg-info is a directory\n            pkginfo_path = os.path.join(egginfo_path, \"PKG-INFO\")\n            pkg_info = pkginfo_to_metadata(egginfo_path, pkginfo_path)\n\n            # ignore common egg metadata that is useless to wheel\n            shutil.copytree(\n                egginfo_path,\n                distinfo_path,\n                ignore=lambda x, y: {\n                    \"PKG-INFO\",\n                    \"requires.txt\",\n                    \"SOURCES.txt\",\n                    \"not-zip-safe\",\n                },\n            )\n\n            # delete dependency_links if it is only whitespace\n            dependency_links_path = os.path.join(distinfo_path, \"dependency_links.txt\")\n            with open(dependency_links_path, encoding=\"utf-8\") as dependency_links_file:\n                dependency_links = dependency_links_file.read().strip()\n            if not dependency_links:\n                adios(dependency_links_path)\n\n        pkg_info_path = os.path.join(distinfo_path, \"METADATA\")\n        serialization_policy = EmailPolicy(\n            utf8=True,\n            mangle_from_=False,\n            max_line_length=0,\n        )\n        with open(pkg_info_path, \"w\", encoding=\"utf-8\") as out:\n            Generator(out, policy=serialization_policy).flatten(pkg_info)\n\n        for license_path in self.license_paths:\n            filename = os.path.basename(license_path)\n            shutil.copy(license_path, os.path.join(distinfo_path, filename))\n\n        adios(egginfo_path)\n", "src/wheel/wheelfile.py": "from __future__ import annotations\n\nimport csv\nimport hashlib\nimport os.path\nimport re\nimport stat\nimport time\nfrom io import StringIO, TextIOWrapper\nfrom typing import IO, TYPE_CHECKING, Literal\nfrom zipfile import ZIP_DEFLATED, ZipFile, ZipInfo\n\nfrom wheel.cli import WheelError\nfrom wheel.util import log, urlsafe_b64decode, urlsafe_b64encode\n\nif TYPE_CHECKING:\n    from typing import Protocol, Sized, Union\n\n    from typing_extensions import Buffer\n\n    StrPath = Union[str, os.PathLike[str]]\n\n    class SizedBuffer(Sized, Buffer, Protocol): ...\n\n\n# Non-greedy matching of an optional build number may be too clever (more\n# invalid wheel filenames will match). Separate regex for .dist-info?\nWHEEL_INFO_RE = re.compile(\n    r\"\"\"^(?P<namever>(?P<name>[^\\s-]+?)-(?P<ver>[^\\s-]+?))(-(?P<build>\\d[^\\s-]*))?\n     -(?P<pyver>[^\\s-]+?)-(?P<abi>[^\\s-]+?)-(?P<plat>\\S+)\\.whl$\"\"\",\n    re.VERBOSE,\n)\nMINIMUM_TIMESTAMP = 315532800  # 1980-01-01 00:00:00 UTC\n\n\ndef get_zipinfo_datetime(timestamp: float | None = None):\n    # Some applications need reproducible .whl files, but they can't do this without\n    # forcing the timestamp of the individual ZipInfo objects. See issue #143.\n    timestamp = int(os.environ.get(\"SOURCE_DATE_EPOCH\", timestamp or time.time()))\n    timestamp = max(timestamp, MINIMUM_TIMESTAMP)\n    return time.gmtime(timestamp)[0:6]\n\n\nclass WheelFile(ZipFile):\n    \"\"\"A ZipFile derivative class that also reads SHA-256 hashes from\n    .dist-info/RECORD and checks any read files against those.\n    \"\"\"\n\n    _default_algorithm = hashlib.sha256\n\n    def __init__(\n        self,\n        file: StrPath,\n        mode: Literal[\"r\", \"w\", \"x\", \"a\"] = \"r\",\n        compression: int = ZIP_DEFLATED,\n    ):\n        basename = os.path.basename(file)\n        self.parsed_filename = WHEEL_INFO_RE.match(basename)\n        if not basename.endswith(\".whl\") or self.parsed_filename is None:\n            raise WheelError(f\"Bad wheel filename {basename!r}\")\n\n        ZipFile.__init__(self, file, mode, compression=compression, allowZip64=True)\n\n        self.dist_info_path = \"{}.dist-info\".format(\n            self.parsed_filename.group(\"namever\")\n        )\n        self.record_path = self.dist_info_path + \"/RECORD\"\n        self._file_hashes: dict[str, tuple[None, None] | tuple[int, bytes]] = {}\n        self._file_sizes = {}\n        if mode == \"r\":\n            # Ignore RECORD and any embedded wheel signatures\n            self._file_hashes[self.record_path] = None, None\n            self._file_hashes[self.record_path + \".jws\"] = None, None\n            self._file_hashes[self.record_path + \".p7s\"] = None, None\n\n            # Fill in the expected hashes by reading them from RECORD\n            try:\n                record = self.open(self.record_path)\n            except KeyError:\n                raise WheelError(f\"Missing {self.record_path} file\") from None\n\n            with record:\n                for line in csv.reader(\n                    TextIOWrapper(record, newline=\"\", encoding=\"utf-8\")\n                ):\n                    path, hash_sum, size = line\n                    if not hash_sum:\n                        continue\n\n                    algorithm, hash_sum = hash_sum.split(\"=\")\n                    try:\n                        hashlib.new(algorithm)\n                    except ValueError:\n                        raise WheelError(\n                            f\"Unsupported hash algorithm: {algorithm}\"\n                        ) from None\n\n                    if algorithm.lower() in {\"md5\", \"sha1\"}:\n                        raise WheelError(\n                            f\"Weak hash algorithm ({algorithm}) is not permitted by \"\n                            f\"PEP 427\"\n                        )\n\n                    self._file_hashes[path] = (\n                        algorithm,\n                        urlsafe_b64decode(hash_sum.encode(\"ascii\")),\n                    )\n\n    def open(\n        self,\n        name_or_info: str | ZipInfo,\n        mode: Literal[\"r\", \"w\"] = \"r\",\n        pwd: bytes | None = None,\n    ) -> IO[bytes]:\n        def _update_crc(newdata: bytes) -> None:\n            eof = ef._eof\n            update_crc_orig(newdata)\n            running_hash.update(newdata)\n            if eof and running_hash.digest() != expected_hash:\n                raise WheelError(f\"Hash mismatch for file '{ef_name}'\")\n\n        ef_name = (\n            name_or_info.filename if isinstance(name_or_info, ZipInfo) else name_or_info\n        )\n        if (\n            mode == \"r\"\n            and not ef_name.endswith(\"/\")\n            and ef_name not in self._file_hashes\n        ):\n            raise WheelError(f\"No hash found for file '{ef_name}'\")\n\n        ef = ZipFile.open(self, name_or_info, mode, pwd)\n        if mode == \"r\" and not ef_name.endswith(\"/\"):\n            algorithm, expected_hash = self._file_hashes[ef_name]\n            if expected_hash is not None:\n                # Monkey patch the _update_crc method to also check for the hash from\n                # RECORD\n                running_hash = hashlib.new(algorithm)\n                update_crc_orig, ef._update_crc = ef._update_crc, _update_crc\n\n        return ef\n\n    def write_files(self, base_dir: str):\n        log.info(f\"creating '{self.filename}' and adding '{base_dir}' to it\")\n        deferred: list[tuple[str, str]] = []\n        for root, dirnames, filenames in os.walk(base_dir):\n            # Sort the directory names so that `os.walk` will walk them in a\n            # defined order on the next iteration.\n            dirnames.sort()\n            for name in sorted(filenames):\n                path = os.path.normpath(os.path.join(root, name))\n                if os.path.isfile(path):\n                    arcname = os.path.relpath(path, base_dir).replace(os.path.sep, \"/\")\n                    if arcname == self.record_path:\n                        pass\n                    elif root.endswith(\".dist-info\"):\n                        deferred.append((path, arcname))\n                    else:\n                        self.write(path, arcname)\n\n        deferred.sort()\n        for path, arcname in deferred:\n            self.write(path, arcname)\n\n    def write(\n        self,\n        filename: str,\n        arcname: str | None = None,\n        compress_type: int | None = None,\n    ) -> None:\n        with open(filename, \"rb\") as f:\n            st = os.fstat(f.fileno())\n            data = f.read()\n\n        zinfo = ZipInfo(\n            arcname or filename, date_time=get_zipinfo_datetime(st.st_mtime)\n        )\n        zinfo.external_attr = (stat.S_IMODE(st.st_mode) | stat.S_IFMT(st.st_mode)) << 16\n        zinfo.compress_type = compress_type or self.compression\n        self.writestr(zinfo, data, compress_type)\n\n    def writestr(\n        self,\n        zinfo_or_arcname: str | ZipInfo,\n        data: SizedBuffer | str,\n        compress_type: int | None = None,\n    ):\n        if isinstance(zinfo_or_arcname, str):\n            zinfo_or_arcname = ZipInfo(\n                zinfo_or_arcname, date_time=get_zipinfo_datetime()\n            )\n            zinfo_or_arcname.compress_type = self.compression\n            zinfo_or_arcname.external_attr = (0o664 | stat.S_IFREG) << 16\n\n        if isinstance(data, str):\n            data = data.encode(\"utf-8\")\n\n        ZipFile.writestr(self, zinfo_or_arcname, data, compress_type)\n        fname = (\n            zinfo_or_arcname.filename\n            if isinstance(zinfo_or_arcname, ZipInfo)\n            else zinfo_or_arcname\n        )\n        log.info(f\"adding '{fname}'\")\n        if fname != self.record_path:\n            hash_ = self._default_algorithm(data)\n            self._file_hashes[fname] = (\n                hash_.name,\n                urlsafe_b64encode(hash_.digest()).decode(\"ascii\"),\n            )\n            self._file_sizes[fname] = len(data)\n\n    def close(self):\n        # Write RECORD\n        if self.fp is not None and self.mode == \"w\" and self._file_hashes:\n            data = StringIO()\n            writer = csv.writer(data, delimiter=\",\", quotechar='\"', lineterminator=\"\\n\")\n            writer.writerows(\n                (\n                    (fname, algorithm + \"=\" + hash_, self._file_sizes[fname])\n                    for fname, (algorithm, hash_) in self._file_hashes.items()\n                )\n            )\n            writer.writerow((format(self.record_path), \"\", \"\"))\n            self.writestr(self.record_path, data.getvalue())\n\n        ZipFile.close(self)\n", "src/wheel/util.py": "from __future__ import annotations\n\nimport base64\nimport logging\n\nlog = logging.getLogger(\"wheel\")\n\n# ensure Python logging is configured\ntry:\n    __import__(\"setuptools.logging\")\nexcept ImportError:\n    # setuptools < ??\n    from . import _setuptools_logging\n\n    _setuptools_logging.configure()\n\n\ndef urlsafe_b64encode(data: bytes) -> bytes:\n    \"\"\"urlsafe_b64encode without padding\"\"\"\n    return base64.urlsafe_b64encode(data).rstrip(b\"=\")\n\n\ndef urlsafe_b64decode(data: bytes) -> bytes:\n    \"\"\"urlsafe_b64decode without padding\"\"\"\n    pad = b\"=\" * (4 - (len(data) & 3))\n    return base64.urlsafe_b64decode(data + pad)\n", "src/wheel/__main__.py": "\"\"\"\nWheel command line tool (enable python -m wheel syntax)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\n\ndef main():  # needed for console script\n    if __package__ == \"\":\n        # To be able to run 'python wheel-0.9.whl/wheel':\n        import os.path\n\n        path = os.path.dirname(os.path.dirname(__file__))\n        sys.path[0:0] = [path]\n    import wheel.cli\n\n    sys.exit(wheel.cli.main())\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "src/wheel/__init__.py": "from __future__ import annotations\n\n__version__ = \"0.43.0\"\n", "src/wheel/_setuptools_logging.py": "# copied from setuptools.logging, omitting monkeypatching\nfrom __future__ import annotations\n\nimport logging\nimport sys\n\n\ndef _not_warning(record: logging.LogRecord) -> bool:\n    return record.levelno < logging.WARNING\n\n\ndef configure() -> None:\n    \"\"\"\n    Configure logging to emit warning and above to stderr\n    and everything else to stdout. This behavior is provided\n    for compatibility with distutils.log but may change in\n    the future.\n    \"\"\"\n    err_handler = logging.StreamHandler()\n    err_handler.setLevel(logging.WARNING)\n    out_handler = logging.StreamHandler(sys.stdout)\n    out_handler.addFilter(_not_warning)\n    handlers = err_handler, out_handler\n    logging.basicConfig(\n        format=\"{message}\", style=\"{\", handlers=handlers, level=logging.DEBUG\n    )\n", "src/wheel/macosx_libfile.py": "\"\"\"\nThis module contains function to analyse dynamic library\nheaders to extract system information\n\nCurrently only for MacOSX\n\nLibrary file on macosx system starts with Mach-O or Fat field.\nThis can be distinguish by first 32 bites and it is called magic number.\nProper value of magic number is with suffix _MAGIC. Suffix _CIGAM means\nreversed bytes order.\nBoth fields can occur in two types: 32 and 64 bytes.\n\nFAT field inform that this library contains few version of library\n(typically for different types version). It contains\ninformation where Mach-O headers starts.\n\nEach section started with Mach-O header contains one library\n(So if file starts with this field it contains only one version).\n\nAfter filed Mach-O there are section fields.\nEach of them starts with two fields:\ncmd - magic number for this command\ncmdsize - total size occupied by this section information.\n\nIn this case only sections LC_VERSION_MIN_MACOSX (for macosx 10.13 and earlier)\nand LC_BUILD_VERSION (for macosx 10.14 and newer) are interesting,\nbecause them contains information about minimal system version.\n\nImportant remarks:\n- For fat files this implementation looks for maximum number version.\n  It not check if it is 32 or 64 and do not compare it with currently built package.\n  So it is possible to false report higher version that needed.\n- All structures signatures are taken form macosx header files.\n- I think that binary format will be more stable than `otool` output.\n  and if apple introduce some changes both implementation will need to be updated.\n- The system compile will set the deployment target no lower than\n  11.0 for arm64 builds. For \"Universal 2\" builds use the x86_64 deployment\n  target when the arm64 target is 11.0.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ctypes\nimport os\nimport sys\nfrom io import BufferedIOBase\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Union\n\n    StrPath = Union[str, os.PathLike[str]]\n\n\"\"\"here the needed const and struct from mach-o header files\"\"\"\n\nFAT_MAGIC = 0xCAFEBABE\nFAT_CIGAM = 0xBEBAFECA\nFAT_MAGIC_64 = 0xCAFEBABF\nFAT_CIGAM_64 = 0xBFBAFECA\nMH_MAGIC = 0xFEEDFACE\nMH_CIGAM = 0xCEFAEDFE\nMH_MAGIC_64 = 0xFEEDFACF\nMH_CIGAM_64 = 0xCFFAEDFE\n\nLC_VERSION_MIN_MACOSX = 0x24\nLC_BUILD_VERSION = 0x32\n\nCPU_TYPE_ARM64 = 0x0100000C\n\nmach_header_fields = [\n    (\"magic\", ctypes.c_uint32),\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"filetype\", ctypes.c_uint32),\n    (\"ncmds\", ctypes.c_uint32),\n    (\"sizeofcmds\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct mach_header {\n    uint32_t\tmagic;\t\t/* mach magic number identifier */\n    cpu_type_t\tcputype;\t/* cpu specifier */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier */\n    uint32_t\tfiletype;\t/* type of file */\n    uint32_t\tncmds;\t\t/* number of load commands */\n    uint32_t\tsizeofcmds;\t/* the size of all the load commands */\n    uint32_t\tflags;\t\t/* flags */\n};\ntypedef integer_t cpu_type_t;\ntypedef integer_t cpu_subtype_t;\n\"\"\"\n\nmach_header_fields_64 = mach_header_fields + [(\"reserved\", ctypes.c_uint32)]\n\"\"\"\nstruct mach_header_64 {\n    uint32_t\tmagic;\t\t/* mach magic number identifier */\n    cpu_type_t\tcputype;\t/* cpu specifier */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier */\n    uint32_t\tfiletype;\t/* type of file */\n    uint32_t\tncmds;\t\t/* number of load commands */\n    uint32_t\tsizeofcmds;\t/* the size of all the load commands */\n    uint32_t\tflags;\t\t/* flags */\n    uint32_t\treserved;\t/* reserved */\n};\n\"\"\"\n\nfat_header_fields = [(\"magic\", ctypes.c_uint32), (\"nfat_arch\", ctypes.c_uint32)]\n\"\"\"\nstruct fat_header {\n    uint32_t\tmagic;\t\t/* FAT_MAGIC or FAT_MAGIC_64 */\n    uint32_t\tnfat_arch;\t/* number of structs that follow */\n};\n\"\"\"\n\nfat_arch_fields = [\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"offset\", ctypes.c_uint32),\n    (\"size\", ctypes.c_uint32),\n    (\"align\", ctypes.c_uint32),\n]\n\"\"\"\nstruct fat_arch {\n    cpu_type_t\tcputype;\t/* cpu specifier (int) */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\n    uint32_t\toffset;\t\t/* file offset to this object file */\n    uint32_t\tsize;\t\t/* size of this object file */\n    uint32_t\talign;\t\t/* alignment as a power of 2 */\n};\n\"\"\"\n\nfat_arch_64_fields = [\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"offset\", ctypes.c_uint64),\n    (\"size\", ctypes.c_uint64),\n    (\"align\", ctypes.c_uint32),\n    (\"reserved\", ctypes.c_uint32),\n]\n\"\"\"\nstruct fat_arch_64 {\n    cpu_type_t\tcputype;\t/* cpu specifier (int) */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\n    uint64_t\toffset;\t\t/* file offset to this object file */\n    uint64_t\tsize;\t\t/* size of this object file */\n    uint32_t\talign;\t\t/* alignment as a power of 2 */\n    uint32_t\treserved;\t/* reserved */\n};\n\"\"\"\n\nsegment_base_fields = [(\"cmd\", ctypes.c_uint32), (\"cmdsize\", ctypes.c_uint32)]\n\"\"\"base for reading segment info\"\"\"\n\nsegment_command_fields = [\n    (\"cmd\", ctypes.c_uint32),\n    (\"cmdsize\", ctypes.c_uint32),\n    (\"segname\", ctypes.c_char * 16),\n    (\"vmaddr\", ctypes.c_uint32),\n    (\"vmsize\", ctypes.c_uint32),\n    (\"fileoff\", ctypes.c_uint32),\n    (\"filesize\", ctypes.c_uint32),\n    (\"maxprot\", ctypes.c_int),\n    (\"initprot\", ctypes.c_int),\n    (\"nsects\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct segment_command { /* for 32-bit architectures */\n    uint32_t\tcmd;\t\t/* LC_SEGMENT */\n    uint32_t\tcmdsize;\t/* includes sizeof section structs */\n    char\t\tsegname[16];\t/* segment name */\n    uint32_t\tvmaddr;\t\t/* memory address of this segment */\n    uint32_t\tvmsize;\t\t/* memory size of this segment */\n    uint32_t\tfileoff;\t/* file offset of this segment */\n    uint32_t\tfilesize;\t/* amount to map from the file */\n    vm_prot_t\tmaxprot;\t/* maximum VM protection */\n    vm_prot_t\tinitprot;\t/* initial VM protection */\n    uint32_t\tnsects;\t\t/* number of sections in segment */\n    uint32_t\tflags;\t\t/* flags */\n};\ntypedef int vm_prot_t;\n\"\"\"\n\nsegment_command_fields_64 = [\n    (\"cmd\", ctypes.c_uint32),\n    (\"cmdsize\", ctypes.c_uint32),\n    (\"segname\", ctypes.c_char * 16),\n    (\"vmaddr\", ctypes.c_uint64),\n    (\"vmsize\", ctypes.c_uint64),\n    (\"fileoff\", ctypes.c_uint64),\n    (\"filesize\", ctypes.c_uint64),\n    (\"maxprot\", ctypes.c_int),\n    (\"initprot\", ctypes.c_int),\n    (\"nsects\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct segment_command_64 { /* for 64-bit architectures */\n    uint32_t\tcmd;\t\t/* LC_SEGMENT_64 */\n    uint32_t\tcmdsize;\t/* includes sizeof section_64 structs */\n    char\t\tsegname[16];\t/* segment name */\n    uint64_t\tvmaddr;\t\t/* memory address of this segment */\n    uint64_t\tvmsize;\t\t/* memory size of this segment */\n    uint64_t\tfileoff;\t/* file offset of this segment */\n    uint64_t\tfilesize;\t/* amount to map from the file */\n    vm_prot_t\tmaxprot;\t/* maximum VM protection */\n    vm_prot_t\tinitprot;\t/* initial VM protection */\n    uint32_t\tnsects;\t\t/* number of sections in segment */\n    uint32_t\tflags;\t\t/* flags */\n};\n\"\"\"\n\nversion_min_command_fields = segment_base_fields + [\n    (\"version\", ctypes.c_uint32),\n    (\"sdk\", ctypes.c_uint32),\n]\n\"\"\"\nstruct version_min_command {\n    uint32_t\tcmd;\t\t/* LC_VERSION_MIN_MACOSX or\n                               LC_VERSION_MIN_IPHONEOS or\n                               LC_VERSION_MIN_WATCHOS or\n                               LC_VERSION_MIN_TVOS */\n    uint32_t\tcmdsize;\t/* sizeof(struct min_version_command) */\n    uint32_t\tversion;\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tsdk;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n};\n\"\"\"\n\nbuild_version_command_fields = segment_base_fields + [\n    (\"platform\", ctypes.c_uint32),\n    (\"minos\", ctypes.c_uint32),\n    (\"sdk\", ctypes.c_uint32),\n    (\"ntools\", ctypes.c_uint32),\n]\n\"\"\"\nstruct build_version_command {\n    uint32_t\tcmd;\t\t/* LC_BUILD_VERSION */\n    uint32_t\tcmdsize;\t/* sizeof(struct build_version_command) plus */\n                                /* ntools * sizeof(struct build_tool_version) */\n    uint32_t\tplatform;\t/* platform */\n    uint32_t\tminos;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tsdk;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tntools;\t\t/* number of tool entries following this */\n};\n\"\"\"\n\n\ndef swap32(x: int) -> int:\n    return (\n        ((x << 24) & 0xFF000000)\n        | ((x << 8) & 0x00FF0000)\n        | ((x >> 8) & 0x0000FF00)\n        | ((x >> 24) & 0x000000FF)\n    )\n\n\ndef get_base_class_and_magic_number(\n    lib_file: BufferedIOBase,\n    seek: int | None = None,\n) -> tuple[type[ctypes.Structure], int]:\n    if seek is None:\n        seek = lib_file.tell()\n    else:\n        lib_file.seek(seek)\n    magic_number = ctypes.c_uint32.from_buffer_copy(\n        lib_file.read(ctypes.sizeof(ctypes.c_uint32))\n    ).value\n\n    # Handle wrong byte order\n    if magic_number in [FAT_CIGAM, FAT_CIGAM_64, MH_CIGAM, MH_CIGAM_64]:\n        if sys.byteorder == \"little\":\n            BaseClass = ctypes.BigEndianStructure\n        else:\n            BaseClass = ctypes.LittleEndianStructure\n\n        magic_number = swap32(magic_number)\n    else:\n        BaseClass = ctypes.Structure\n\n    lib_file.seek(seek)\n    return BaseClass, magic_number\n\n\ndef read_data(struct_class: type[ctypes.Structure], lib_file: BufferedIOBase):\n    return struct_class.from_buffer_copy(lib_file.read(ctypes.sizeof(struct_class)))\n\n\ndef extract_macosx_min_system_version(path_to_lib: str):\n    with open(path_to_lib, \"rb\") as lib_file:\n        BaseClass, magic_number = get_base_class_and_magic_number(lib_file, 0)\n        if magic_number not in [FAT_MAGIC, FAT_MAGIC_64, MH_MAGIC, MH_MAGIC_64]:\n            return\n\n        if magic_number in [FAT_MAGIC, FAT_CIGAM_64]:\n\n            class FatHeader(BaseClass):\n                _fields_ = fat_header_fields\n\n            fat_header = read_data(FatHeader, lib_file)\n            if magic_number == FAT_MAGIC:\n\n                class FatArch(BaseClass):\n                    _fields_ = fat_arch_fields\n\n            else:\n\n                class FatArch(BaseClass):\n                    _fields_ = fat_arch_64_fields\n\n            fat_arch_list = [\n                read_data(FatArch, lib_file) for _ in range(fat_header.nfat_arch)\n            ]\n\n            versions_list: list[tuple[int, int, int]] = []\n            for el in fat_arch_list:\n                try:\n                    version = read_mach_header(lib_file, el.offset)\n                    if version is not None:\n                        if el.cputype == CPU_TYPE_ARM64 and len(fat_arch_list) != 1:\n                            # Xcode will not set the deployment target below 11.0.0\n                            # for the arm64 architecture. Ignore the arm64 deployment\n                            # in fat binaries when the target is 11.0.0, that way\n                            # the other architectures can select a lower deployment\n                            # target.\n                            # This is safe because there is no arm64 variant for\n                            # macOS 10.15 or earlier.\n                            if version == (11, 0, 0):\n                                continue\n                        versions_list.append(version)\n                except ValueError:\n                    pass\n\n            if len(versions_list) > 0:\n                return max(versions_list)\n            else:\n                return None\n\n        else:\n            try:\n                return read_mach_header(lib_file, 0)\n            except ValueError:\n                \"\"\"when some error during read library files\"\"\"\n                return None\n\n\ndef read_mach_header(\n    lib_file: BufferedIOBase,\n    seek: int | None = None,\n) -> tuple[int, int, int] | None:\n    \"\"\"\n    This function parses a Mach-O header and extracts\n    information about the minimal macOS version.\n\n    :param lib_file: reference to opened library file with pointer\n    \"\"\"\n    base_class, magic_number = get_base_class_and_magic_number(lib_file, seek)\n    arch = \"32\" if magic_number == MH_MAGIC else \"64\"\n\n    class SegmentBase(base_class):\n        _fields_ = segment_base_fields\n\n    if arch == \"32\":\n\n        class MachHeader(base_class):\n            _fields_ = mach_header_fields\n\n    else:\n\n        class MachHeader(base_class):\n            _fields_ = mach_header_fields_64\n\n    mach_header = read_data(MachHeader, lib_file)\n    for _i in range(mach_header.ncmds):\n        pos = lib_file.tell()\n        segment_base = read_data(SegmentBase, lib_file)\n        lib_file.seek(pos)\n        if segment_base.cmd == LC_VERSION_MIN_MACOSX:\n\n            class VersionMinCommand(base_class):\n                _fields_ = version_min_command_fields\n\n            version_info = read_data(VersionMinCommand, lib_file)\n            return parse_version(version_info.version)\n        elif segment_base.cmd == LC_BUILD_VERSION:\n\n            class VersionBuild(base_class):\n                _fields_ = build_version_command_fields\n\n            version_info = read_data(VersionBuild, lib_file)\n            return parse_version(version_info.minos)\n        else:\n            lib_file.seek(pos + segment_base.cmdsize)\n            continue\n\n\ndef parse_version(version: int) -> tuple[int, int, int]:\n    x = (version & 0xFFFF0000) >> 16\n    y = (version & 0x0000FF00) >> 8\n    z = version & 0x000000FF\n    return x, y, z\n\n\ndef calculate_macosx_platform_tag(archive_root: StrPath, platform_tag: str) -> str:\n    \"\"\"\n    Calculate proper macosx platform tag basing on files which are included to wheel\n\n    Example platform tag `macosx-10.14-x86_64`\n    \"\"\"\n    prefix, base_version, suffix = platform_tag.split(\"-\")\n    base_version = tuple(int(x) for x in base_version.split(\".\"))\n    base_version = base_version[:2]\n    if base_version[0] > 10:\n        base_version = (base_version[0], 0)\n    assert len(base_version) == 2\n    if \"MACOSX_DEPLOYMENT_TARGET\" in os.environ:\n        deploy_target = tuple(\n            int(x) for x in os.environ[\"MACOSX_DEPLOYMENT_TARGET\"].split(\".\")\n        )\n        deploy_target = deploy_target[:2]\n        if deploy_target[0] > 10:\n            deploy_target = (deploy_target[0], 0)\n        if deploy_target < base_version:\n            sys.stderr.write(\n                \"[WARNING] MACOSX_DEPLOYMENT_TARGET is set to a lower value ({}) than \"\n                \"the version on which the Python interpreter was compiled ({}), and \"\n                \"will be ignored.\\n\".format(\n                    \".\".join(str(x) for x in deploy_target),\n                    \".\".join(str(x) for x in base_version),\n                )\n            )\n        else:\n            base_version = deploy_target\n\n    assert len(base_version) == 2\n    start_version = base_version\n    versions_dict: dict[str, tuple[int, int]] = {}\n    for dirpath, _dirnames, filenames in os.walk(archive_root):\n        for filename in filenames:\n            if filename.endswith(\".dylib\") or filename.endswith(\".so\"):\n                lib_path = os.path.join(dirpath, filename)\n                min_ver = extract_macosx_min_system_version(lib_path)\n                if min_ver is not None:\n                    min_ver = min_ver[0:2]\n                    if min_ver[0] > 10:\n                        min_ver = (min_ver[0], 0)\n                    versions_dict[lib_path] = min_ver\n\n    if len(versions_dict) > 0:\n        base_version = max(base_version, max(versions_dict.values()))\n\n    # macosx platform tag do not support minor bugfix release\n    fin_base_version = \"_\".join([str(x) for x in base_version])\n    if start_version < base_version:\n        problematic_files = [k for k, v in versions_dict.items() if v > start_version]\n        problematic_files = \"\\n\".join(problematic_files)\n        if len(problematic_files) == 1:\n            files_form = \"this file\"\n        else:\n            files_form = \"these files\"\n        error_message = (\n            \"[WARNING] This wheel needs a higher macOS version than {}  \"\n            \"To silence this warning, set MACOSX_DEPLOYMENT_TARGET to at least \"\n            + fin_base_version\n            + \" or recreate \"\n            + files_form\n            + \" with lower \"\n            \"MACOSX_DEPLOYMENT_TARGET:  \\n\" + problematic_files\n        )\n\n        if \"MACOSX_DEPLOYMENT_TARGET\" in os.environ:\n            error_message = error_message.format(\n                \"is set in MACOSX_DEPLOYMENT_TARGET variable.\"\n            )\n        else:\n            error_message = error_message.format(\n                \"the version your Python interpreter is compiled against.\"\n            )\n\n        sys.stderr.write(error_message)\n\n    platform_tag = prefix + \"_\" + fin_base_version + \"_\" + suffix\n    return platform_tag\n", "src/wheel/cli/pack.py": "from __future__ import annotations\n\nimport email.policy\nimport os.path\nimport re\nfrom email.generator import BytesGenerator\nfrom email.parser import BytesParser\n\nfrom wheel.cli import WheelError\nfrom wheel.wheelfile import WheelFile\n\nDIST_INFO_RE = re.compile(r\"^(?P<namever>(?P<name>.+?)-(?P<ver>\\d.*?))\\.dist-info$\")\n\n\ndef pack(directory: str, dest_dir: str, build_number: str | None) -> None:\n    \"\"\"Repack a previously unpacked wheel directory into a new wheel file.\n\n    The .dist-info/WHEEL file must contain one or more tags so that the target\n    wheel file name can be determined.\n\n    :param directory: The unpacked wheel directory\n    :param dest_dir: Destination directory (defaults to the current directory)\n    \"\"\"\n    # Find the .dist-info directory\n    dist_info_dirs = [\n        fn\n        for fn in os.listdir(directory)\n        if os.path.isdir(os.path.join(directory, fn)) and DIST_INFO_RE.match(fn)\n    ]\n    if len(dist_info_dirs) > 1:\n        raise WheelError(f\"Multiple .dist-info directories found in {directory}\")\n    elif not dist_info_dirs:\n        raise WheelError(f\"No .dist-info directories found in {directory}\")\n\n    # Determine the target wheel filename\n    dist_info_dir = dist_info_dirs[0]\n    name_version = DIST_INFO_RE.match(dist_info_dir).group(\"namever\")\n\n    # Read the tags and the existing build number from .dist-info/WHEEL\n    wheel_file_path = os.path.join(directory, dist_info_dir, \"WHEEL\")\n    with open(wheel_file_path, \"rb\") as f:\n        info = BytesParser(policy=email.policy.compat32).parse(f)\n        tags: list[str] = info.get_all(\"Tag\", [])\n        existing_build_number = info.get(\"Build\")\n\n        if not tags:\n            raise WheelError(\n                f\"No tags present in {dist_info_dir}/WHEEL; cannot determine target \"\n                f\"wheel filename\"\n            )\n\n    # Set the wheel file name and add/replace/remove the Build tag in .dist-info/WHEEL\n    build_number = build_number if build_number is not None else existing_build_number\n    if build_number is not None:\n        del info[\"Build\"]\n        if build_number:\n            info[\"Build\"] = build_number\n            name_version += \"-\" + build_number\n\n        if build_number != existing_build_number:\n            with open(wheel_file_path, \"wb\") as f:\n                BytesGenerator(f, maxheaderlen=0).flatten(info)\n\n    # Reassemble the tags for the wheel file\n    tagline = compute_tagline(tags)\n\n    # Repack the wheel\n    wheel_path = os.path.join(dest_dir, f\"{name_version}-{tagline}.whl\")\n    with WheelFile(wheel_path, \"w\") as wf:\n        print(f\"Repacking wheel as {wheel_path}...\", end=\"\", flush=True)\n        wf.write_files(directory)\n\n    print(\"OK\")\n\n\ndef compute_tagline(tags: list[str]) -> str:\n    \"\"\"Compute a tagline from a list of tags.\n\n    :param tags: A list of tags\n    :return: A tagline\n    \"\"\"\n    impls = sorted({tag.split(\"-\")[0] for tag in tags})\n    abivers = sorted({tag.split(\"-\")[1] for tag in tags})\n    platforms = sorted({tag.split(\"-\")[2] for tag in tags})\n    return \"-\".join([\".\".join(impls), \".\".join(abivers), \".\".join(platforms)])\n", "src/wheel/cli/tags.py": "from __future__ import annotations\n\nimport email.policy\nimport itertools\nimport os\nfrom collections.abc import Iterable\nfrom email.parser import BytesParser\n\nfrom ..wheelfile import WheelFile\n\n\ndef _compute_tags(original_tags: Iterable[str], new_tags: str | None) -> set[str]:\n    \"\"\"Add or replace tags. Supports dot-separated tags\"\"\"\n    if new_tags is None:\n        return set(original_tags)\n\n    if new_tags.startswith(\"+\"):\n        return {*original_tags, *new_tags[1:].split(\".\")}\n\n    if new_tags.startswith(\"-\"):\n        return set(original_tags) - set(new_tags[1:].split(\".\"))\n\n    return set(new_tags.split(\".\"))\n\n\ndef tags(\n    wheel: str,\n    python_tags: str | None = None,\n    abi_tags: str | None = None,\n    platform_tags: str | None = None,\n    build_tag: str | None = None,\n    remove: bool = False,\n) -> str:\n    \"\"\"Change the tags on a wheel file.\n\n    The tags are left unchanged if they are not specified. To specify \"none\",\n    use [\"none\"]. To append to the previous tags, a tag should start with a\n    \"+\".  If a tag starts with \"-\", it will be removed from existing tags.\n    Processing is done left to right.\n\n    :param wheel: The paths to the wheels\n    :param python_tags: The Python tags to set\n    :param abi_tags: The ABI tags to set\n    :param platform_tags: The platform tags to set\n    :param build_tag: The build tag to set\n    :param remove: Remove the original wheel\n    \"\"\"\n    with WheelFile(wheel, \"r\") as f:\n        assert f.filename, f\"{f.filename} must be available\"\n\n        wheel_info = f.read(f.dist_info_path + \"/WHEEL\")\n        info = BytesParser(policy=email.policy.compat32).parsebytes(wheel_info)\n\n        original_wheel_name = os.path.basename(f.filename)\n        namever = f.parsed_filename.group(\"namever\")\n        build = f.parsed_filename.group(\"build\")\n        original_python_tags = f.parsed_filename.group(\"pyver\").split(\".\")\n        original_abi_tags = f.parsed_filename.group(\"abi\").split(\".\")\n        original_plat_tags = f.parsed_filename.group(\"plat\").split(\".\")\n\n    tags: list[str] = info.get_all(\"Tag\", [])\n    existing_build_tag = info.get(\"Build\")\n\n    impls = {tag.split(\"-\")[0] for tag in tags}\n    abivers = {tag.split(\"-\")[1] for tag in tags}\n    platforms = {tag.split(\"-\")[2] for tag in tags}\n\n    if impls != set(original_python_tags):\n        msg = f\"Wheel internal tags {impls!r} != filename tags {original_python_tags!r}\"\n        raise AssertionError(msg)\n\n    if abivers != set(original_abi_tags):\n        msg = f\"Wheel internal tags {abivers!r} != filename tags {original_abi_tags!r}\"\n        raise AssertionError(msg)\n\n    if platforms != set(original_plat_tags):\n        msg = (\n            f\"Wheel internal tags {platforms!r} != filename tags {original_plat_tags!r}\"\n        )\n        raise AssertionError(msg)\n\n    if existing_build_tag != build:\n        msg = (\n            f\"Incorrect filename '{build}' \"\n            f\"& *.dist-info/WHEEL '{existing_build_tag}' build numbers\"\n        )\n        raise AssertionError(msg)\n\n    # Start changing as needed\n    if build_tag is not None:\n        build = build_tag\n\n    final_python_tags = sorted(_compute_tags(original_python_tags, python_tags))\n    final_abi_tags = sorted(_compute_tags(original_abi_tags, abi_tags))\n    final_plat_tags = sorted(_compute_tags(original_plat_tags, platform_tags))\n\n    final_tags = [\n        namever,\n        \".\".join(final_python_tags),\n        \".\".join(final_abi_tags),\n        \".\".join(final_plat_tags),\n    ]\n    if build:\n        final_tags.insert(1, build)\n\n    final_wheel_name = \"-\".join(final_tags) + \".whl\"\n\n    if original_wheel_name != final_wheel_name:\n        del info[\"Tag\"], info[\"Build\"]\n        for a, b, c in itertools.product(\n            final_python_tags, final_abi_tags, final_plat_tags\n        ):\n            info[\"Tag\"] = f\"{a}-{b}-{c}\"\n        if build:\n            info[\"Build\"] = build\n\n        original_wheel_path = os.path.join(\n            os.path.dirname(f.filename), original_wheel_name\n        )\n        final_wheel_path = os.path.join(os.path.dirname(f.filename), final_wheel_name)\n\n        with WheelFile(original_wheel_path, \"r\") as fin, WheelFile(\n            final_wheel_path, \"w\"\n        ) as fout:\n            fout.comment = fin.comment  # preserve the comment\n            for item in fin.infolist():\n                if item.is_dir():\n                    continue\n                if item.filename == f.dist_info_path + \"/RECORD\":\n                    continue\n                if item.filename == f.dist_info_path + \"/WHEEL\":\n                    fout.writestr(item, info.as_bytes())\n                else:\n                    fout.writestr(item, fin.read(item))\n\n        if remove:\n            os.remove(original_wheel_path)\n\n    return final_wheel_name\n", "src/wheel/cli/unpack.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nfrom ..wheelfile import WheelFile\n\n\ndef unpack(path: str, dest: str = \".\") -> None:\n    \"\"\"Unpack a wheel.\n\n    Wheel content will be unpacked to {dest}/{name}-{ver}, where {name}\n    is the package name and {ver} its version.\n\n    :param path: The path to the wheel.\n    :param dest: Destination directory (default to current directory).\n    \"\"\"\n    with WheelFile(path) as wf:\n        namever = wf.parsed_filename.group(\"namever\")\n        destination = Path(dest) / namever\n        print(f\"Unpacking to: {destination}...\", end=\"\", flush=True)\n        for zinfo in wf.filelist:\n            wf.extract(zinfo, destination)\n\n            # Set permissions to the same values as they were set in the archive\n            # We have to do this manually due to\n            # https://github.com/python/cpython/issues/59999\n            permissions = zinfo.external_attr >> 16 & 0o777\n            destination.joinpath(zinfo.filename).chmod(permissions)\n\n    print(\"OK\")\n", "src/wheel/cli/convert.py": "from __future__ import annotations\n\nimport os.path\nimport re\nimport shutil\nimport tempfile\nimport zipfile\nfrom glob import iglob\n\nfrom ..bdist_wheel import bdist_wheel\nfrom ..wheelfile import WheelFile\nfrom . import WheelError\n\ntry:\n    from setuptools import Distribution\nexcept ImportError:\n    from distutils.dist import Distribution\n\negg_info_re = re.compile(\n    r\"\"\"\n    (?P<name>.+?)-(?P<ver>.+?)\n    (-(?P<pyver>py\\d\\.\\d+)\n     (-(?P<arch>.+?))?\n    )?.egg$\"\"\",\n    re.VERBOSE,\n)\n\n\nclass _bdist_wheel_tag(bdist_wheel):\n    # allow the client to override the default generated wheel tag\n    # The default bdist_wheel implementation uses python and abi tags\n    # of the running python process. This is not suitable for\n    # generating/repackaging prebuild binaries.\n\n    full_tag_supplied = False\n    full_tag = None  # None or a (pytag, soabitag, plattag) triple\n\n    def get_tag(self):\n        if self.full_tag_supplied and self.full_tag is not None:\n            return self.full_tag\n        else:\n            return bdist_wheel.get_tag(self)\n\n\ndef egg2wheel(egg_path: str, dest_dir: str) -> None:\n    filename = os.path.basename(egg_path)\n    match = egg_info_re.match(filename)\n    if not match:\n        raise WheelError(f\"Invalid egg file name: {filename}\")\n\n    egg_info = match.groupdict()\n    dir = tempfile.mkdtemp(suffix=\"_e2w\")\n    if os.path.isfile(egg_path):\n        # assume we have a bdist_egg otherwise\n        with zipfile.ZipFile(egg_path) as egg:\n            egg.extractall(dir)\n    else:\n        # support buildout-style installed eggs directories\n        for pth in os.listdir(egg_path):\n            src = os.path.join(egg_path, pth)\n            if os.path.isfile(src):\n                shutil.copy2(src, dir)\n            else:\n                shutil.copytree(src, os.path.join(dir, pth))\n\n    pyver = egg_info[\"pyver\"]\n    if pyver:\n        pyver = egg_info[\"pyver\"] = pyver.replace(\".\", \"\")\n\n    arch = (egg_info[\"arch\"] or \"any\").replace(\".\", \"_\").replace(\"-\", \"_\")\n\n    # assume all binary eggs are for CPython\n    abi = \"cp\" + pyver[2:] if arch != \"any\" else \"none\"\n\n    root_is_purelib = egg_info[\"arch\"] is None\n    if root_is_purelib:\n        bw = bdist_wheel(Distribution())\n    else:\n        bw = _bdist_wheel_tag(Distribution())\n\n    bw.root_is_pure = root_is_purelib\n    bw.python_tag = pyver\n    bw.plat_name_supplied = True\n    bw.plat_name = egg_info[\"arch\"] or \"any\"\n    if not root_is_purelib:\n        bw.full_tag_supplied = True\n        bw.full_tag = (pyver, abi, arch)\n\n    dist_info_dir = os.path.join(dir, \"{name}-{ver}.dist-info\".format(**egg_info))\n    bw.egg2dist(os.path.join(dir, \"EGG-INFO\"), dist_info_dir)\n    bw.write_wheelfile(dist_info_dir, generator=\"egg2wheel\")\n    wheel_name = \"{name}-{ver}-{pyver}-{}-{}.whl\".format(abi, arch, **egg_info)\n    with WheelFile(os.path.join(dest_dir, wheel_name), \"w\") as wf:\n        wf.write_files(dir)\n\n    shutil.rmtree(dir)\n\n\ndef parse_wininst_info(wininfo_name: str, egginfo_name: str | None):\n    \"\"\"Extract metadata from filenames.\n\n    Extracts the 4 metadataitems needed (name, version, pyversion, arch) from\n    the installer filename and the name of the egg-info directory embedded in\n    the zipfile (if any).\n\n    The egginfo filename has the format::\n\n        name-ver(-pyver)(-arch).egg-info\n\n    The installer filename has the format::\n\n        name-ver.arch(-pyver).exe\n\n    Some things to note:\n\n    1. The installer filename is not definitive. An installer can be renamed\n       and work perfectly well as an installer. So more reliable data should\n       be used whenever possible.\n    2. The egg-info data should be preferred for the name and version, because\n       these come straight from the distutils metadata, and are mandatory.\n    3. The pyver from the egg-info data should be ignored, as it is\n       constructed from the version of Python used to build the installer,\n       which is irrelevant - the installer filename is correct here (even to\n       the point that when it's not there, any version is implied).\n    4. The architecture must be taken from the installer filename, as it is\n       not included in the egg-info data.\n    5. Architecture-neutral installers still have an architecture because the\n       installer format itself (being executable) is architecture-specific. We\n       should therefore ignore the architecture if the content is pure-python.\n    \"\"\"\n\n    egginfo = None\n    if egginfo_name:\n        egginfo = egg_info_re.search(egginfo_name)\n        if not egginfo:\n            raise ValueError(f\"Egg info filename {egginfo_name} is not valid\")\n\n    # Parse the wininst filename\n    # 1. Distribution name (up to the first '-')\n    w_name, sep, rest = wininfo_name.partition(\"-\")\n    if not sep:\n        raise ValueError(f\"Installer filename {wininfo_name} is not valid\")\n\n    # Strip '.exe'\n    rest = rest[:-4]\n    # 2. Python version (from the last '-', must start with 'py')\n    rest2, sep, w_pyver = rest.rpartition(\"-\")\n    if sep and w_pyver.startswith(\"py\"):\n        rest = rest2\n        w_pyver = w_pyver.replace(\".\", \"\")\n    else:\n        # Not version specific - use py2.py3. While it is possible that\n        # pure-Python code is not compatible with both Python 2 and 3, there\n        # is no way of knowing from the wininst format, so we assume the best\n        # here (the user can always manually rename the wheel to be more\n        # restrictive if needed).\n        w_pyver = \"py2.py3\"\n    # 3. Version and architecture\n    w_ver, sep, w_arch = rest.rpartition(\".\")\n    if not sep:\n        raise ValueError(f\"Installer filename {wininfo_name} is not valid\")\n\n    if egginfo:\n        w_name = egginfo.group(\"name\")\n        w_ver = egginfo.group(\"ver\")\n\n    return {\"name\": w_name, \"ver\": w_ver, \"arch\": w_arch, \"pyver\": w_pyver}\n\n\ndef wininst2wheel(path: str, dest_dir: str) -> None:\n    with zipfile.ZipFile(path) as bdw:\n        # Search for egg-info in the archive\n        egginfo_name = None\n        for filename in bdw.namelist():\n            if \".egg-info\" in filename:\n                egginfo_name = filename\n                break\n\n        info = parse_wininst_info(os.path.basename(path), egginfo_name)\n\n        root_is_purelib = True\n        for zipinfo in bdw.infolist():\n            if zipinfo.filename.startswith(\"PLATLIB\"):\n                root_is_purelib = False\n                break\n        if root_is_purelib:\n            paths = {\"purelib\": \"\"}\n        else:\n            paths = {\"platlib\": \"\"}\n\n        dist_info = \"{name}-{ver}\".format(**info)\n        datadir = f\"{dist_info}.data/\"\n\n        # rewrite paths to trick ZipFile into extracting an egg\n        # XXX grab wininst .ini - between .exe, padding, and first zip file.\n        members: list[str] = []\n        egginfo_name = \"\"\n        for zipinfo in bdw.infolist():\n            key, basename = zipinfo.filename.split(\"/\", 1)\n            key = key.lower()\n            basepath = paths.get(key, None)\n            if basepath is None:\n                basepath = datadir + key.lower() + \"/\"\n            oldname = zipinfo.filename\n            newname = basepath + basename\n            zipinfo.filename = newname\n            del bdw.NameToInfo[oldname]\n            bdw.NameToInfo[newname] = zipinfo\n            # Collect member names, but omit '' (from an entry like \"PLATLIB/\"\n            if newname:\n                members.append(newname)\n            # Remember egg-info name for the egg2dist call below\n            if not egginfo_name:\n                if newname.endswith(\".egg-info\"):\n                    egginfo_name = newname\n                elif \".egg-info/\" in newname:\n                    egginfo_name, sep, _ = newname.rpartition(\"/\")\n        dir = tempfile.mkdtemp(suffix=\"_b2w\")\n        bdw.extractall(dir, members)\n\n    # egg2wheel\n    abi = \"none\"\n    pyver = info[\"pyver\"]\n    arch = (info[\"arch\"] or \"any\").replace(\".\", \"_\").replace(\"-\", \"_\")\n    # Wininst installers always have arch even if they are not\n    # architecture-specific (because the format itself is).\n    # So, assume the content is architecture-neutral if root is purelib.\n    if root_is_purelib:\n        arch = \"any\"\n    # If the installer is architecture-specific, it's almost certainly also\n    # CPython-specific.\n    if arch != \"any\":\n        pyver = pyver.replace(\"py\", \"cp\")\n    wheel_name = \"-\".join((dist_info, pyver, abi, arch))\n    if root_is_purelib:\n        bw = bdist_wheel(Distribution())\n    else:\n        bw = _bdist_wheel_tag(Distribution())\n\n    bw.root_is_pure = root_is_purelib\n    bw.python_tag = pyver\n    bw.plat_name_supplied = True\n    bw.plat_name = info[\"arch\"] or \"any\"\n\n    if not root_is_purelib:\n        bw.full_tag_supplied = True\n        bw.full_tag = (pyver, abi, arch)\n\n    dist_info_dir = os.path.join(dir, f\"{dist_info}.dist-info\")\n    bw.egg2dist(os.path.join(dir, egginfo_name), dist_info_dir)\n    bw.write_wheelfile(dist_info_dir, generator=\"wininst2wheel\")\n\n    wheel_path = os.path.join(dest_dir, wheel_name)\n    with WheelFile(wheel_path, \"w\") as wf:\n        wf.write_files(dir)\n\n    shutil.rmtree(dir)\n\n\ndef convert(files: list[str], dest_dir: str, verbose: bool) -> None:\n    for pat in files:\n        for installer in iglob(pat):\n            if os.path.splitext(installer)[1] == \".egg\":\n                conv = egg2wheel\n            else:\n                conv = wininst2wheel\n\n            if verbose:\n                print(f\"{installer}... \", flush=True)\n\n            conv(installer, dest_dir)\n            if verbose:\n                print(\"OK\")\n", "src/wheel/cli/__init__.py": "\"\"\"\nWheel command-line utility.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom argparse import ArgumentTypeError\n\n\nclass WheelError(Exception):\n    pass\n\n\ndef unpack_f(args: argparse.Namespace) -> None:\n    from .unpack import unpack\n\n    unpack(args.wheelfile, args.dest)\n\n\ndef pack_f(args: argparse.Namespace) -> None:\n    from .pack import pack\n\n    pack(args.directory, args.dest_dir, args.build_number)\n\n\ndef convert_f(args: argparse.Namespace) -> None:\n    from .convert import convert\n\n    convert(args.files, args.dest_dir, args.verbose)\n\n\ndef tags_f(args: argparse.Namespace) -> None:\n    from .tags import tags\n\n    names = (\n        tags(\n            wheel,\n            args.python_tag,\n            args.abi_tag,\n            args.platform_tag,\n            args.build,\n            args.remove,\n        )\n        for wheel in args.wheel\n    )\n\n    for name in names:\n        print(name)\n\n\ndef version_f(args: argparse.Namespace) -> None:\n    from .. import __version__\n\n    print(f\"wheel {__version__}\")\n\n\ndef parse_build_tag(build_tag: str) -> str:\n    if build_tag and not build_tag[0].isdigit():\n        raise ArgumentTypeError(\"build tag must begin with a digit\")\n    elif \"-\" in build_tag:\n        raise ArgumentTypeError(\"invalid character ('-') in build tag\")\n\n    return build_tag\n\n\nTAGS_HELP = \"\"\"\\\nMake a new wheel with given tags. Any tags unspecified will remain the same.\nStarting the tags with a \"+\" will append to the existing tags. Starting with a\n\"-\" will remove a tag (use --option=-TAG syntax). Multiple tags can be\nseparated by \".\". The original file will remain unless --remove is given.  The\noutput filename(s) will be displayed on stdout for further processing.\n\"\"\"\n\n\ndef parser():\n    p = argparse.ArgumentParser()\n    s = p.add_subparsers(help=\"commands\")\n\n    unpack_parser = s.add_parser(\"unpack\", help=\"Unpack wheel\")\n    unpack_parser.add_argument(\n        \"--dest\", \"-d\", help=\"Destination directory\", default=\".\"\n    )\n    unpack_parser.add_argument(\"wheelfile\", help=\"Wheel file\")\n    unpack_parser.set_defaults(func=unpack_f)\n\n    repack_parser = s.add_parser(\"pack\", help=\"Repack wheel\")\n    repack_parser.add_argument(\"directory\", help=\"Root directory of the unpacked wheel\")\n    repack_parser.add_argument(\n        \"--dest-dir\",\n        \"-d\",\n        default=os.path.curdir,\n        help=\"Directory to store the wheel (default %(default)s)\",\n    )\n    repack_parser.add_argument(\n        \"--build-number\", help=\"Build tag to use in the wheel name\"\n    )\n    repack_parser.set_defaults(func=pack_f)\n\n    convert_parser = s.add_parser(\"convert\", help=\"Convert egg or wininst to wheel\")\n    convert_parser.add_argument(\"files\", nargs=\"*\", help=\"Files to convert\")\n    convert_parser.add_argument(\n        \"--dest-dir\",\n        \"-d\",\n        default=os.path.curdir,\n        help=\"Directory to store wheels (default %(default)s)\",\n    )\n    convert_parser.add_argument(\"--verbose\", \"-v\", action=\"store_true\")\n    convert_parser.set_defaults(func=convert_f)\n\n    tags_parser = s.add_parser(\n        \"tags\", help=\"Add or replace the tags on a wheel\", description=TAGS_HELP\n    )\n    tags_parser.add_argument(\"wheel\", nargs=\"*\", help=\"Existing wheel(s) to retag\")\n    tags_parser.add_argument(\n        \"--remove\",\n        action=\"store_true\",\n        help=\"Remove the original files, keeping only the renamed ones\",\n    )\n    tags_parser.add_argument(\n        \"--python-tag\", metavar=\"TAG\", help=\"Specify an interpreter tag(s)\"\n    )\n    tags_parser.add_argument(\"--abi-tag\", metavar=\"TAG\", help=\"Specify an ABI tag(s)\")\n    tags_parser.add_argument(\n        \"--platform-tag\", metavar=\"TAG\", help=\"Specify a platform tag(s)\"\n    )\n    tags_parser.add_argument(\n        \"--build\", type=parse_build_tag, metavar=\"BUILD\", help=\"Specify a build tag\"\n    )\n    tags_parser.set_defaults(func=tags_f)\n\n    version_parser = s.add_parser(\"version\", help=\"Print version and exit\")\n    version_parser.set_defaults(func=version_f)\n\n    help_parser = s.add_parser(\"help\", help=\"Show this help\")\n    help_parser.set_defaults(func=lambda args: p.print_help())\n\n    return p\n\n\ndef main():\n    p = parser()\n    args = p.parse_args()\n    if not hasattr(args, \"func\"):\n        p.print_help()\n    else:\n        try:\n            args.func(args)\n            return 0\n        except WheelError as e:\n            print(e, file=sys.stderr)\n\n    return 1\n", "src/wheel/vendored/__init__.py": "", "src/wheel/vendored/packaging/tags.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Dict,\n    FrozenSet,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> FrozenSet[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> Union[int, str, None]:\n    value: Union[int, str, None] = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: List[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> List[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: Optional[PythonVersion] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                interpreter = \"cp{version}\".format(\n                    version=_version_nodot((python_version[0], minor_version))\n                )\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> List[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: Optional[str] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: Optional[PythonVersion] = None,\n    interpreter: Optional[str] = None,\n    platforms: Optional[Iterable[str]] = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: MacVersion, cpu_arch: str) -> List[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: Optional[MacVersion] = None, arch: Optional[str] = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        for minor_version in range(version[1], -1, -1):\n            compat_version = 10, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=10, minor=minor_version, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, 0\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=major_version, minor=0, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                        major=compat_version[0],\n                        minor=compat_version[1],\n                        binary_format=binary_format,\n                    )\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_format = \"universal2\"\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=compat_version[0],\n                    minor=compat_version[1],\n                    binary_format=binary_format,\n                )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n", "src/wheel/vendored/packaging/_musllinux.py": "\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Optional, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache\ndef _get_musl_version(executable: str) -> Optional[_MuslVersion]:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n", "src/wheel/vendored/packaging/_manylinux.py": "import collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Dict, Generator, Iterator, NamedTuple, Optional, Sequence, Tuple\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: Dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: Optional[str] = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> Optional[str]:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> Optional[str]:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> Tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache\ndef _get_glibc_version() -> Tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n", "src/wheel/vendored/packaging/_tokenizer.py": "import contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Dict, Iterator, NoReturn, Optional, Tuple, Union\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: Tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: \"Dict[str, Union[str, re.Pattern[str]]]\" = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: \"Dict[str, Union[str, re.Pattern[str]]]\",\n    ) -> None:\n        self.source = source\n        self.rules: Dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Optional[Token] = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: Optional[int] = None,\n        span_end: Optional[int] = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n", "src/wheel/vendored/packaging/_structures.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n", "src/wheel/vendored/packaging/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport re\nfrom typing import FrozenSet, NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)\n        except InvalidVersion:\n            # Legacy versions cannot be normalized\n            return version\n    else:\n        parsed = version\n\n    parts = []\n\n    # Epoch\n    if parsed.epoch != 0:\n        parts.append(f\"{parsed.epoch}!\")\n\n    # Release segment\n    release_segment = \".\".join(str(x) for x in parsed.release)\n    if strip_trailing_zero:\n        # NB: This strips trailing '.0's to normalize\n        release_segment = re.sub(r\"(\\.0)+$\", \"\", release_segment)\n    parts.append(release_segment)\n\n    # Pre-release\n    if parsed.pre is not None:\n        parts.append(\"\".join(str(x) for x in parsed.pre))\n\n    # Post-release\n    if parsed.post is not None:\n        parts.append(f\".post{parsed.post}\")\n\n    # Development release\n    if parsed.dev is not None:\n        parts.append(f\".dev{parsed.dev}\")\n\n    # Local version segment\n    if parsed.local is not None:\n        parts.append(f\"+{parsed.local}\")\n\n    return \"\".join(parts)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in '{filename}'\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename}\"\n        ) from e\n\n    return (name, version)\n", "src/wheel/vendored/packaging/version.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.version import parse, Version\n\"\"\"\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, Optional, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: Tuple[int, ...]\n    dev: Optional[Tuple[str, int]]\n    pre: Optional[Tuple[str, int]]\n    post: Optional[Tuple[str, int]]\n    local: Optional[LocalType]\n\n\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: Tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: '{version}'\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be rounded-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> Tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> Optional[Tuple[str, int]]:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> Optional[int]:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> Optional[int]:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> Optional[str]:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc.dev1\").public\n        '1.2.3'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3+abc.dev1\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\ndef _parse_letter_version(\n    letter: Optional[str], number: Union[str, bytes, SupportsInt, None]\n) -> Optional[Tuple[str, int]]:\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n    if not letter and number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: Optional[str]) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: Tuple[int, ...],\n    pre: Optional[Tuple[str, int]],\n    post: Optional[Tuple[str, int]],\n    dev: Optional[Tuple[str, int]],\n    local: Optional[LocalType],\n) -> CmpKey:\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n", "src/wheel/vendored/packaging/_elffile.py": "\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nimport enum\nimport os\nimport struct\nfrom typing import IO, Optional, Tuple\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            )\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> Tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> Optional[str]:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n", "src/wheel/vendored/packaging/requirements.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom typing import Any, Iterator, Optional, Set\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: Optional[str] = parsed.url or None\n        self.extras: Set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Optional[Marker] = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n", "src/wheel/vendored/packaging/_parser.py": "\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains EBNF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nimport ast\nfrom typing import Any, List, NamedTuple, Optional, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> Tuple[str, str, Optional[MarkerList]]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: List[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n", "src/wheel/vendored/packaging/__init__.py": "", "src/wheel/vendored/packaging/specifiers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n\"\"\"\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, List, Optional, Tuple, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> Optional[bool]:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: Optional[bool] = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: Optional[bool] = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: '{spec}'\")\n\n        self._spec: Tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> Tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: Union[str, Version]) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self, item: UnparsedVersion, prereleases: Optional[bool] = None\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> List[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: List[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: List[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        # Split on `,` to break each individual specifier into it's own item, and\n        # strip each item to remove leading/trailing whitespace.\n        split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n        # Make each individual specifier a Specifier and save in a frozen set for later.\n        self._specs = frozenset(map(Specifier, split_specifiers))\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> Optional[bool]:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: Union[\"SpecifierSet\", str]) -> \"SpecifierSet\":\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: Optional[bool] = None,\n        installed: Optional[bool] = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: List[UnparsedVersionVar] = []\n            found_prereleases: List[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n", "src/wheel/vendored/packaging/markers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\nfrom ._parser import (\n    MarkerAtom,\n    MarkerList,\n    Op,\n    Value,\n    Variable,\n)\nfrom ._parser import (\n    parse_marker as _parse_marker,\n)\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: Union[List[str], MarkerAtom, str], first: Optional[bool] = True\n) -> str:\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: Dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Optional[Operator] = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> Tuple[str, ...]:\n    # PEP 685 \u2013 Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: Dict[str, str]) -> bool:\n    groups: List[List[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: \"sys._version_info\") -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: Optional[Dict[str, str]] = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = default_environment()\n        current_environment[\"extra\"] = \"\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(self._markers, current_environment)\n"}