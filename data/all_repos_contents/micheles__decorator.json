{"setup.py": "from setuptools import setup\n\ndic = dict(__file__=None)\nexec(open('src/decorator.py').read(), dic)  # extract the __version__\nVERSION = dic['__version__']\n\n\nif __name__ == '__main__':\n    setup(name='decorator',\n          version=VERSION,\n          description='Decorators for Humans',\n          long_description=open('README.rst').read(),\n          author='Michele Simionato',\n          author_email='michele.simionato@gmail.com',\n          url='https://github.com/micheles/decorator',\n          license=\"new BSD License\",\n          package_dir={'': 'src'},\n          py_modules=['decorator'],\n          keywords=\"decorators generic utility\",\n          platforms=[\"All\"],\n          python_requires='>=3.7',\n          classifiers=['Development Status :: 5 - Production/Stable',\n                       'Intended Audience :: Developers',\n                       'License :: OSI Approved :: BSD License',\n                       'Natural Language :: English',\n                       'Operating System :: OS Independent',\n                       'Programming Language :: Python',\n                       'Programming Language :: Python :: 3.7',\n                       'Programming Language :: Python :: 3.8',\n                       'Programming Language :: Python :: 3.9',\n                       'Programming Language :: Python :: 3.10',\n                       'Programming Language :: Python :: 3.11',\n                       'Programming Language :: Python :: 3.12',\n                       'Programming Language :: Python :: Implementation :: CPython',\n                       'Topic :: Software Development :: Libraries',\n                       'Topic :: Utilities'],\n          test_suite='tests',\n          zip_safe=False)\n", "src/decorator.py": "# #########################     LICENSE     ############################ #\n\n# Copyright (c) 2005-2021, Michele Simionato\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#   Redistributions of source code must retain the above copyright\n#   notice, this list of conditions and the following disclaimer.\n#   Redistributions in bytecode form must reproduce the above copyright\n#   notice, this list of conditions and the following disclaimer in\n#   the documentation and/or other materials provided with the\n#   distribution.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n# DAMAGE.\n\n\"\"\"\nDecorator module, see\nhttps://github.com/micheles/decorator/blob/master/docs/documentation.md\nfor the documentation.\n\"\"\"\nimport re\nimport sys\nimport inspect\nimport operator\nimport itertools\nfrom contextlib import _GeneratorContextManager\nfrom inspect import getfullargspec, iscoroutinefunction, isgeneratorfunction\n\n__version__ = '5.1.1'\n\nDEF = re.compile(r'\\s*def\\s*([_\\w][_\\w\\d]*)\\s*\\(')\nPOS = inspect.Parameter.POSITIONAL_OR_KEYWORD\nEMPTY = inspect.Parameter.empty\n\n\n# this is not used anymore in the core, but kept for backward compatibility\nclass FunctionMaker(object):\n    \"\"\"\n    An object with the ability to create functions with a given signature.\n    It has attributes name, doc, module, signature, defaults, dict and\n    methods update and make.\n    \"\"\"\n\n    # Atomic get-and-increment provided by the GIL\n    _compile_count = itertools.count()\n\n    # make pylint happy\n    args = varargs = varkw = defaults = kwonlyargs = kwonlydefaults = ()\n\n    def __init__(self, func=None, name=None, signature=None,\n                 defaults=None, doc=None, module=None, funcdict=None):\n        self.shortsignature = signature\n        if func:\n            # func can be a class or a callable, but not an instance method\n            self.name = func.__name__\n            if self.name == '<lambda>':  # small hack for lambda functions\n                self.name = '_lambda_'\n            self.doc = func.__doc__\n            self.module = func.__module__\n            if inspect.isroutine(func):\n                argspec = getfullargspec(func)\n                self.annotations = getattr(func, '__annotations__', {})\n                for a in ('args', 'varargs', 'varkw', 'defaults', 'kwonlyargs',\n                          'kwonlydefaults'):\n                    setattr(self, a, getattr(argspec, a))\n                for i, arg in enumerate(self.args):\n                    setattr(self, 'arg%d' % i, arg)\n                allargs = list(self.args)\n                allshortargs = list(self.args)\n                if self.varargs:\n                    allargs.append('*' + self.varargs)\n                    allshortargs.append('*' + self.varargs)\n                elif self.kwonlyargs:\n                    allargs.append('*')  # single star syntax\n                for a in self.kwonlyargs:\n                    allargs.append('%s=None' % a)\n                    allshortargs.append('%s=%s' % (a, a))\n                if self.varkw:\n                    allargs.append('**' + self.varkw)\n                    allshortargs.append('**' + self.varkw)\n                self.signature = ', '.join(allargs)\n                self.shortsignature = ', '.join(allshortargs)\n                self.dict = func.__dict__.copy()\n        # func=None happens when decorating a caller\n        if name:\n            self.name = name\n        if signature is not None:\n            self.signature = signature\n        if defaults:\n            self.defaults = defaults\n        if doc:\n            self.doc = doc\n        if module:\n            self.module = module\n        if funcdict:\n            self.dict = funcdict\n        # check existence required attributes\n        assert hasattr(self, 'name')\n        if not hasattr(self, 'signature'):\n            raise TypeError('You are decorating a non function: %s' % func)\n\n    def update(self, func, **kw):\n        \"\"\"\n        Update the signature of func with the data in self\n        \"\"\"\n        func.__name__ = self.name\n        func.__doc__ = getattr(self, 'doc', None)\n        func.__dict__ = getattr(self, 'dict', {})\n        func.__defaults__ = self.defaults\n        func.__kwdefaults__ = self.kwonlydefaults or None\n        func.__annotations__ = getattr(self, 'annotations', None)\n        try:\n            frame = sys._getframe(3)\n        except AttributeError:  # for IronPython and similar implementations\n            callermodule = '?'\n        else:\n            callermodule = frame.f_globals.get('__name__', '?')\n        func.__module__ = getattr(self, 'module', callermodule)\n        func.__dict__.update(kw)\n\n    def make(self, src_templ, evaldict=None, addsource=False, **attrs):\n        \"\"\"\n        Make a new function from a given template and update the signature\n        \"\"\"\n        src = src_templ % vars(self)  # expand name and signature\n        evaldict = evaldict or {}\n        mo = DEF.search(src)\n        if mo is None:\n            raise SyntaxError('not a valid function template\\n%s' % src)\n        name = mo.group(1)  # extract the function name\n        names = set([name] + [arg.strip(' *') for arg in\n                              self.shortsignature.split(',')])\n        for n in names:\n            if n in ('_func_', '_call_'):\n                raise NameError('%s is overridden in\\n%s' % (n, src))\n\n        if not src.endswith('\\n'):  # add a newline for old Pythons\n            src += '\\n'\n\n        # Ensure each generated function has a unique filename for profilers\n        # (such as cProfile) that depend on the tuple of (<filename>,\n        # <definition line>, <function name>) being unique.\n        filename = '<decorator-gen-%d>' % next(self._compile_count)\n        try:\n            code = compile(src, filename, 'single')\n            exec(code, evaldict)\n        except Exception:\n            print('Error in generated code:', file=sys.stderr)\n            print(src, file=sys.stderr)\n            raise\n        func = evaldict[name]\n        if addsource:\n            attrs['__source__'] = src\n        self.update(func, **attrs)\n        return func\n\n    @classmethod\n    def create(cls, obj, body, evaldict, defaults=None,\n               doc=None, module=None, addsource=True, **attrs):\n        \"\"\"\n        Create a function from the strings name, signature and body.\n        evaldict is the evaluation dictionary. If addsource is true an\n        attribute __source__ is added to the result. The attributes attrs\n        are added, if any.\n        \"\"\"\n        if isinstance(obj, str):  # \"name(signature)\"\n            name, rest = obj.strip().split('(', 1)\n            signature = rest[:-1]  # strip a right parens\n            func = None\n        else:  # a function\n            name = None\n            signature = None\n            func = obj\n        self = cls(func, name, signature, defaults, doc, module)\n        ibody = '\\n'.join('    ' + line for line in body.splitlines())\n        caller = evaldict.get('_call_')  # when called from `decorate`\n        if caller and iscoroutinefunction(caller):\n            body = ('async def %(name)s(%(signature)s):\\n' + ibody).replace(\n                'return', 'return await')\n        else:\n            body = 'def %(name)s(%(signature)s):\\n' + ibody\n        return self.make(body, evaldict, addsource, **attrs)\n\n\ndef fix(args, kwargs, sig):\n    \"\"\"\n    Fix args and kwargs to be consistent with the signature\n    \"\"\"\n    ba = sig.bind(*args, **kwargs)\n    ba.apply_defaults()  # needed for test_dan_schult\n    return ba.args, ba.kwargs\n\n\ndef decorate(func, caller, extras=(), kwsyntax=False):\n    \"\"\"\n    Decorates a function/generator/coroutine using a caller.\n    If kwsyntax is True calling the decorated functions with keyword\n    syntax will pass the named arguments inside the ``kw`` dictionary,\n    even if such argument are positional, similarly to what functools.wraps\n    does. By default kwsyntax is False and the the arguments are untouched.\n    \"\"\"\n    sig = inspect.signature(func)\n    if iscoroutinefunction(caller):\n        async def fun(*args, **kw):\n            if not kwsyntax:\n                args, kw = fix(args, kw, sig)\n            return await caller(func, *(extras + args), **kw)\n    elif isgeneratorfunction(caller):\n        def fun(*args, **kw):\n            if not kwsyntax:\n                args, kw = fix(args, kw, sig)\n            for res in caller(func, *(extras + args), **kw):\n                yield res\n    else:\n        def fun(*args, **kw):\n            if not kwsyntax:\n                args, kw = fix(args, kw, sig)\n            return caller(func, *(extras + args), **kw)\n    fun.__name__ = func.__name__\n    fun.__doc__ = func.__doc__\n    fun.__wrapped__ = func\n    fun.__signature__ = sig\n    fun.__qualname__ = func.__qualname__\n    # builtin functions like defaultdict.__setitem__ lack many attributes\n    try:\n        fun.__defaults__ = func.__defaults__\n    except AttributeError:\n        pass\n    try:\n        fun.__kwdefaults__ = func.__kwdefaults__\n    except AttributeError:\n        pass\n    try:\n        fun.__annotations__ = func.__annotations__\n    except AttributeError:\n        pass\n    try:\n        fun.__module__ = func.__module__\n    except AttributeError:\n        pass\n    try:\n        fun.__dict__.update(func.__dict__)\n    except AttributeError:\n        pass\n    return fun\n\n\ndef decoratorx(caller):\n    \"\"\"\n    A version of \"decorator\" implemented via \"exec\" and not via the\n    Signature object. Use this if you are want to preserve the `.__code__`\n    object properties (https://github.com/micheles/decorator/issues/129).\n    \"\"\"\n    def dec(func):\n        return FunctionMaker.create(\n            func,\n            \"return _call_(_func_, %(shortsignature)s)\",\n            dict(_call_=caller, _func_=func),\n            __wrapped__=func, __qualname__=func.__qualname__)\n    return dec\n\n\ndef decorator(caller, _func=None, kwsyntax=False):\n    \"\"\"\n    decorator(caller) converts a caller function into a decorator\n    \"\"\"\n    if _func is not None:  # return a decorated function\n        # this is obsolete behavior; you should use decorate instead\n        return decorate(_func, caller, (), kwsyntax)\n    # else return a decorator function\n    sig = inspect.signature(caller)\n    dec_params = [p for p in sig.parameters.values() if p.kind is POS]\n\n    def dec(func=None, *args, **kw):\n        na = len(args) + 1\n        extras = args + tuple(kw.get(p.name, p.default)\n                              for p in dec_params[na:]\n                              if p.default is not EMPTY)\n        if func is None:\n            return lambda func: decorate(func, caller, extras, kwsyntax)\n        else:\n            return decorate(func, caller, extras, kwsyntax)\n    dec.__signature__ = sig.replace(parameters=dec_params)\n    dec.__name__ = caller.__name__\n    dec.__doc__ = caller.__doc__\n    dec.__wrapped__ = caller\n    dec.__qualname__ = caller.__qualname__\n    dec.__kwdefaults__ = getattr(caller, '__kwdefaults__', None)\n    dec.__dict__.update(caller.__dict__)\n    return dec\n\n\n# ####################### contextmanager ####################### #\n\n\nclass ContextManager(_GeneratorContextManager):\n    def __init__(self, g, *a, **k):\n        _GeneratorContextManager.__init__(self, g, a, k)\n\n    def __call__(self, func):\n        def caller(f, *a, **k):\n            with self.__class__(self.func, *self.args, **self.kwds):\n                return f(*a, **k)\n        return decorate(func, caller)\n\n\n_contextmanager = decorator(ContextManager)\n\n\ndef contextmanager(func):\n    # Enable Pylint config: contextmanager-decorators=decorator.contextmanager\n    return _contextmanager(func)\n\n\n# ############################ dispatch_on ############################ #\n\ndef append(a, vancestors):\n    \"\"\"\n    Append ``a`` to the list of the virtual ancestors, unless it is already\n    included.\n    \"\"\"\n    add = True\n    for j, va in enumerate(vancestors):\n        if issubclass(va, a):\n            add = False\n            break\n        if issubclass(a, va):\n            vancestors[j] = a\n            add = False\n    if add:\n        vancestors.append(a)\n\n\n# inspired from simplegeneric by P.J. Eby and functools.singledispatch\ndef dispatch_on(*dispatch_args):\n    \"\"\"\n    Factory of decorators turning a function into a generic function\n    dispatching on the given arguments.\n    \"\"\"\n    assert dispatch_args, 'No dispatch args passed'\n    dispatch_str = '(%s,)' % ', '.join(dispatch_args)\n\n    def check(arguments, wrong=operator.ne, msg=''):\n        \"\"\"Make sure one passes the expected number of arguments\"\"\"\n        if wrong(len(arguments), len(dispatch_args)):\n            raise TypeError('Expected %d arguments, got %d%s' %\n                            (len(dispatch_args), len(arguments), msg))\n\n    def gen_func_dec(func):\n        \"\"\"Decorator turning a function into a generic function\"\"\"\n\n        # first check the dispatch arguments\n        argset = set(getfullargspec(func).args)\n        if not set(dispatch_args) <= argset:\n            raise NameError('Unknown dispatch arguments %s' % dispatch_str)\n\n        typemap = {}\n\n        def vancestors(*types):\n            \"\"\"\n            Get a list of sets of virtual ancestors for the given types\n            \"\"\"\n            check(types)\n            ras = [[] for _ in range(len(dispatch_args))]\n            for types_ in typemap:\n                for t, type_, ra in zip(types, types_, ras):\n                    if issubclass(t, type_) and type_ not in t.mro():\n                        append(type_, ra)\n            return [set(ra) for ra in ras]\n\n        def ancestors(*types):\n            \"\"\"\n            Get a list of virtual MROs, one for each type\n            \"\"\"\n            check(types)\n            lists = []\n            for t, vas in zip(types, vancestors(*types)):\n                n_vas = len(vas)\n                if n_vas > 1:\n                    raise RuntimeError(\n                        'Ambiguous dispatch for %s: %s' % (t, vas))\n                elif n_vas == 1:\n                    va, = vas\n                    mro = type('t', (t, va), {}).mro()[1:]\n                else:\n                    mro = t.mro()\n                lists.append(mro[:-1])  # discard t and object\n            return lists\n\n        def register(*types):\n            \"\"\"\n            Decorator to register an implementation for the given types\n            \"\"\"\n            check(types)\n\n            def dec(f):\n                check(getfullargspec(f).args, operator.lt, ' in ' + f.__name__)\n                typemap[types] = f\n                return f\n            return dec\n\n        def dispatch_info(*types):\n            \"\"\"\n            An utility to introspect the dispatch algorithm\n            \"\"\"\n            check(types)\n            lst = []\n            for anc in itertools.product(*ancestors(*types)):\n                lst.append(tuple(a.__name__ for a in anc))\n            return lst\n\n        def _dispatch(dispatch_args, *args, **kw):\n            types = tuple(type(arg) for arg in dispatch_args)\n            try:  # fast path\n                f = typemap[types]\n            except KeyError:\n                pass\n            else:\n                return f(*args, **kw)\n            combinations = itertools.product(*ancestors(*types))\n            next(combinations)  # the first one has been already tried\n            for types_ in combinations:\n                f = typemap.get(types_)\n                if f is not None:\n                    return f(*args, **kw)\n\n            # else call the default implementation\n            return func(*args, **kw)\n\n        return FunctionMaker.create(\n            func, 'return _f_(%s, %%(shortsignature)s)' % dispatch_str,\n            dict(_f_=_dispatch), register=register, default=func,\n            typemap=typemap, vancestors=vancestors, ancestors=ancestors,\n            dispatch_info=dispatch_info, __wrapped__=func)\n\n    gen_func_dec.__name__ = 'dispatch_on' + dispatch_str\n    return gen_func_dec\n"}