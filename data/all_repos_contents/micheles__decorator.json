{"setup.py": "from setuptools import setup\n\ndic = dict(__file__=None)\nexec(open('src/decorator.py').read(), dic)  # extract the __version__\nVERSION = dic['__version__']\n\n\nif __name__ == '__main__':\n    setup(name='decorator',\n          version=VERSION,\n          description='Decorators for Humans',\n          long_description=open('README.rst').read(),\n          author='Michele Simionato',\n          author_email='michele.simionato@gmail.com',\n          url='https://github.com/micheles/decorator',\n          license=\"new BSD License\",\n          package_dir={'': 'src'},\n          py_modules=['decorator'],\n          keywords=\"decorators generic utility\",\n          platforms=[\"All\"],\n          python_requires='>=3.7',\n          classifiers=['Development Status :: 5 - Production/Stable',\n                       'Intended Audience :: Developers',\n                       'License :: OSI Approved :: BSD License',\n                       'Natural Language :: English',\n                       'Operating System :: OS Independent',\n                       'Programming Language :: Python',\n                       'Programming Language :: Python :: 3.7',\n                       'Programming Language :: Python :: 3.8',\n                       'Programming Language :: Python :: 3.9',\n                       'Programming Language :: Python :: 3.10',\n                       'Programming Language :: Python :: 3.11',\n                       'Programming Language :: Python :: 3.12',\n                       'Programming Language :: Python :: Implementation :: CPython',\n                       'Topic :: Software Development :: Libraries',\n                       'Topic :: Utilities'],\n          test_suite='tests',\n          zip_safe=False)\n", "docs/conf.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# decorator documentation build configuration file, created by\n# sphinx-quickstart on Sun Jul 23 17:11:44 2017.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nfrom decorator import __version__\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.viewcode',\n    'myst_parser'\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = 'decorator'\ncopyright = '2005-2020, Michele Simionato'\nauthor = 'Michele Simionato'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = release = __version__\n# The full version, including alpha/beta/rc tags.\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'alabaster'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'\n#html_search_language = 'en'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n#html_search_options = {'type': 'default'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = 'scorer.js'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'decoratordoc'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n\n# Latex figure (float) alignment\n#'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, 'decorator.tex', 'decorator Documentation',\n     'Michele Simionato', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'decorator', 'decorator Documentation',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'decorator', 'decorator Documentation',\n     author, 'decorator', 'One line description of project.',\n     'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\n\n\n# -- Options for Epub output ----------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\nepub_author = author\nepub_publisher = author\nepub_copyright = copyright\n\n# The basename for the epub file. It defaults to the project name.\n#epub_basename = project\n\n# The HTML theme for the epub output. Since the default themes are not\n# optimized for small screen space, using the same theme for HTML and epub\n# output is usually not wise. This defaults to 'epub', a theme designed to save\n# visual space.\n#epub_theme = 'epub'\n\n# The language of the text. It defaults to the language option\n# or 'en' if the language is not set.\n#epub_language = ''\n\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''\n\n# A unique identification for the text.\n#epub_uid = ''\n\n# A tuple containing the cover image and cover page html template filenames.\n#epub_cover = ()\n\n# A sequence of (type, uri, title) tuples for the guide element of content.opf.\n#epub_guide = ()\n\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n\n# HTML files that should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = ['search.html']\n\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n\n# Allow duplicate toc entries.\n#epub_tocdup = True\n\n# Choose between 'default' and 'includehidden'.\n#epub_tocscope = 'default'\n\n# Fix unsupported image types using the Pillow.\n#epub_fix_images = False\n\n# Scale large images.\n#epub_max_image_width = 0\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#epub_show_urls = 'inline'\n\n# If false, no index is generated.\n#epub_use_index = True\n", "src/decorator.py": "# #########################     LICENSE     ############################ #\n\n# Copyright (c) 2005-2021, Michele Simionato\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#   Redistributions of source code must retain the above copyright\n#   notice, this list of conditions and the following disclaimer.\n#   Redistributions in bytecode form must reproduce the above copyright\n#   notice, this list of conditions and the following disclaimer in\n#   the documentation and/or other materials provided with the\n#   distribution.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n# DAMAGE.\n\n\"\"\"\nDecorator module, see\nhttps://github.com/micheles/decorator/blob/master/docs/documentation.md\nfor the documentation.\n\"\"\"\nimport re\nimport sys\nimport inspect\nimport operator\nimport itertools\nfrom contextlib import _GeneratorContextManager\nfrom inspect import getfullargspec, iscoroutinefunction, isgeneratorfunction\n\n__version__ = '5.1.1'\n\nDEF = re.compile(r'\\s*def\\s*([_\\w][_\\w\\d]*)\\s*\\(')\nPOS = inspect.Parameter.POSITIONAL_OR_KEYWORD\nEMPTY = inspect.Parameter.empty\n\n\n# this is not used anymore in the core, but kept for backward compatibility\nclass FunctionMaker(object):\n    \"\"\"\n    An object with the ability to create functions with a given signature.\n    It has attributes name, doc, module, signature, defaults, dict and\n    methods update and make.\n    \"\"\"\n\n    # Atomic get-and-increment provided by the GIL\n    _compile_count = itertools.count()\n\n    # make pylint happy\n    args = varargs = varkw = defaults = kwonlyargs = kwonlydefaults = ()\n\n    def __init__(self, func=None, name=None, signature=None,\n                 defaults=None, doc=None, module=None, funcdict=None):\n        self.shortsignature = signature\n        if func:\n            # func can be a class or a callable, but not an instance method\n            self.name = func.__name__\n            if self.name == '<lambda>':  # small hack for lambda functions\n                self.name = '_lambda_'\n            self.doc = func.__doc__\n            self.module = func.__module__\n            if inspect.isroutine(func):\n                argspec = getfullargspec(func)\n                self.annotations = getattr(func, '__annotations__', {})\n                for a in ('args', 'varargs', 'varkw', 'defaults', 'kwonlyargs',\n                          'kwonlydefaults'):\n                    setattr(self, a, getattr(argspec, a))\n                for i, arg in enumerate(self.args):\n                    setattr(self, 'arg%d' % i, arg)\n                allargs = list(self.args)\n                allshortargs = list(self.args)\n                if self.varargs:\n                    allargs.append('*' + self.varargs)\n                    allshortargs.append('*' + self.varargs)\n                elif self.kwonlyargs:\n                    allargs.append('*')  # single star syntax\n                for a in self.kwonlyargs:\n                    allargs.append('%s=None' % a)\n                    allshortargs.append('%s=%s' % (a, a))\n                if self.varkw:\n                    allargs.append('**' + self.varkw)\n                    allshortargs.append('**' + self.varkw)\n                self.signature = ', '.join(allargs)\n                self.shortsignature = ', '.join(allshortargs)\n                self.dict = func.__dict__.copy()\n        # func=None happens when decorating a caller\n        if name:\n            self.name = name\n        if signature is not None:\n            self.signature = signature\n        if defaults:\n            self.defaults = defaults\n        if doc:\n            self.doc = doc\n        if module:\n            self.module = module\n        if funcdict:\n            self.dict = funcdict\n        # check existence required attributes\n        assert hasattr(self, 'name')\n        if not hasattr(self, 'signature'):\n            raise TypeError('You are decorating a non function: %s' % func)\n\n    def update(self, func, **kw):\n        \"\"\"\n        Update the signature of func with the data in self\n        \"\"\"\n        func.__name__ = self.name\n        func.__doc__ = getattr(self, 'doc', None)\n        func.__dict__ = getattr(self, 'dict', {})\n        func.__defaults__ = self.defaults\n        func.__kwdefaults__ = self.kwonlydefaults or None\n        func.__annotations__ = getattr(self, 'annotations', None)\n        try:\n            frame = sys._getframe(3)\n        except AttributeError:  # for IronPython and similar implementations\n            callermodule = '?'\n        else:\n            callermodule = frame.f_globals.get('__name__', '?')\n        func.__module__ = getattr(self, 'module', callermodule)\n        func.__dict__.update(kw)\n\n    def make(self, src_templ, evaldict=None, addsource=False, **attrs):\n        \"\"\"\n        Make a new function from a given template and update the signature\n        \"\"\"\n        src = src_templ % vars(self)  # expand name and signature\n        evaldict = evaldict or {}\n        mo = DEF.search(src)\n        if mo is None:\n            raise SyntaxError('not a valid function template\\n%s' % src)\n        name = mo.group(1)  # extract the function name\n        names = set([name] + [arg.strip(' *') for arg in\n                              self.shortsignature.split(',')])\n        for n in names:\n            if n in ('_func_', '_call_'):\n                raise NameError('%s is overridden in\\n%s' % (n, src))\n\n        if not src.endswith('\\n'):  # add a newline for old Pythons\n            src += '\\n'\n\n        # Ensure each generated function has a unique filename for profilers\n        # (such as cProfile) that depend on the tuple of (<filename>,\n        # <definition line>, <function name>) being unique.\n        filename = '<decorator-gen-%d>' % next(self._compile_count)\n        try:\n            code = compile(src, filename, 'single')\n            exec(code, evaldict)\n        except Exception:\n            print('Error in generated code:', file=sys.stderr)\n            print(src, file=sys.stderr)\n            raise\n        func = evaldict[name]\n        if addsource:\n            attrs['__source__'] = src\n        self.update(func, **attrs)\n        return func\n\n    @classmethod\n    def create(cls, obj, body, evaldict, defaults=None,\n               doc=None, module=None, addsource=True, **attrs):\n        \"\"\"\n        Create a function from the strings name, signature and body.\n        evaldict is the evaluation dictionary. If addsource is true an\n        attribute __source__ is added to the result. The attributes attrs\n        are added, if any.\n        \"\"\"\n        if isinstance(obj, str):  # \"name(signature)\"\n            name, rest = obj.strip().split('(', 1)\n            signature = rest[:-1]  # strip a right parens\n            func = None\n        else:  # a function\n            name = None\n            signature = None\n            func = obj\n        self = cls(func, name, signature, defaults, doc, module)\n        ibody = '\\n'.join('    ' + line for line in body.splitlines())\n        caller = evaldict.get('_call_')  # when called from `decorate`\n        if caller and iscoroutinefunction(caller):\n            body = ('async def %(name)s(%(signature)s):\\n' + ibody).replace(\n                'return', 'return await')\n        else:\n            body = 'def %(name)s(%(signature)s):\\n' + ibody\n        return self.make(body, evaldict, addsource, **attrs)\n\n\ndef fix(args, kwargs, sig):\n    \"\"\"\n    Fix args and kwargs to be consistent with the signature\n    \"\"\"\n    ba = sig.bind(*args, **kwargs)\n    ba.apply_defaults()  # needed for test_dan_schult\n    return ba.args, ba.kwargs\n\n\ndef decorate(func, caller, extras=(), kwsyntax=False):\n    \"\"\"\n    Decorates a function/generator/coroutine using a caller.\n    If kwsyntax is True calling the decorated functions with keyword\n    syntax will pass the named arguments inside the ``kw`` dictionary,\n    even if such argument are positional, similarly to what functools.wraps\n    does. By default kwsyntax is False and the the arguments are untouched.\n    \"\"\"\n    sig = inspect.signature(func)\n    if iscoroutinefunction(caller):\n        async def fun(*args, **kw):\n            if not kwsyntax:\n                args, kw = fix(args, kw, sig)\n            return await caller(func, *(extras + args), **kw)\n    elif isgeneratorfunction(caller):\n        def fun(*args, **kw):\n            if not kwsyntax:\n                args, kw = fix(args, kw, sig)\n            for res in caller(func, *(extras + args), **kw):\n                yield res\n    else:\n        def fun(*args, **kw):\n            if not kwsyntax:\n                args, kw = fix(args, kw, sig)\n            return caller(func, *(extras + args), **kw)\n    fun.__name__ = func.__name__\n    fun.__doc__ = func.__doc__\n    fun.__wrapped__ = func\n    fun.__signature__ = sig\n    fun.__qualname__ = func.__qualname__\n    # builtin functions like defaultdict.__setitem__ lack many attributes\n    try:\n        fun.__defaults__ = func.__defaults__\n    except AttributeError:\n        pass\n    try:\n        fun.__kwdefaults__ = func.__kwdefaults__\n    except AttributeError:\n        pass\n    try:\n        fun.__annotations__ = func.__annotations__\n    except AttributeError:\n        pass\n    try:\n        fun.__module__ = func.__module__\n    except AttributeError:\n        pass\n    try:\n        fun.__dict__.update(func.__dict__)\n    except AttributeError:\n        pass\n    return fun\n\n\ndef decoratorx(caller):\n    \"\"\"\n    A version of \"decorator\" implemented via \"exec\" and not via the\n    Signature object. Use this if you are want to preserve the `.__code__`\n    object properties (https://github.com/micheles/decorator/issues/129).\n    \"\"\"\n    def dec(func):\n        return FunctionMaker.create(\n            func,\n            \"return _call_(_func_, %(shortsignature)s)\",\n            dict(_call_=caller, _func_=func),\n            __wrapped__=func, __qualname__=func.__qualname__)\n    return dec\n\n\ndef decorator(caller, _func=None, kwsyntax=False):\n    \"\"\"\n    decorator(caller) converts a caller function into a decorator\n    \"\"\"\n    if _func is not None:  # return a decorated function\n        # this is obsolete behavior; you should use decorate instead\n        return decorate(_func, caller, (), kwsyntax)\n    # else return a decorator function\n    sig = inspect.signature(caller)\n    dec_params = [p for p in sig.parameters.values() if p.kind is POS]\n\n    def dec(func=None, *args, **kw):\n        na = len(args) + 1\n        extras = args + tuple(kw.get(p.name, p.default)\n                              for p in dec_params[na:]\n                              if p.default is not EMPTY)\n        if func is None:\n            return lambda func: decorate(func, caller, extras, kwsyntax)\n        else:\n            return decorate(func, caller, extras, kwsyntax)\n    dec.__signature__ = sig.replace(parameters=dec_params)\n    dec.__name__ = caller.__name__\n    dec.__doc__ = caller.__doc__\n    dec.__wrapped__ = caller\n    dec.__qualname__ = caller.__qualname__\n    dec.__kwdefaults__ = getattr(caller, '__kwdefaults__', None)\n    dec.__dict__.update(caller.__dict__)\n    return dec\n\n\n# ####################### contextmanager ####################### #\n\n\nclass ContextManager(_GeneratorContextManager):\n    def __init__(self, g, *a, **k):\n        _GeneratorContextManager.__init__(self, g, a, k)\n\n    def __call__(self, func):\n        def caller(f, *a, **k):\n            with self.__class__(self.func, *self.args, **self.kwds):\n                return f(*a, **k)\n        return decorate(func, caller)\n\n\n_contextmanager = decorator(ContextManager)\n\n\ndef contextmanager(func):\n    # Enable Pylint config: contextmanager-decorators=decorator.contextmanager\n    return _contextmanager(func)\n\n\n# ############################ dispatch_on ############################ #\n\ndef append(a, vancestors):\n    \"\"\"\n    Append ``a`` to the list of the virtual ancestors, unless it is already\n    included.\n    \"\"\"\n    add = True\n    for j, va in enumerate(vancestors):\n        if issubclass(va, a):\n            add = False\n            break\n        if issubclass(a, va):\n            vancestors[j] = a\n            add = False\n    if add:\n        vancestors.append(a)\n\n\n# inspired from simplegeneric by P.J. Eby and functools.singledispatch\ndef dispatch_on(*dispatch_args):\n    \"\"\"\n    Factory of decorators turning a function into a generic function\n    dispatching on the given arguments.\n    \"\"\"\n    assert dispatch_args, 'No dispatch args passed'\n    dispatch_str = '(%s,)' % ', '.join(dispatch_args)\n\n    def check(arguments, wrong=operator.ne, msg=''):\n        \"\"\"Make sure one passes the expected number of arguments\"\"\"\n        if wrong(len(arguments), len(dispatch_args)):\n            raise TypeError('Expected %d arguments, got %d%s' %\n                            (len(dispatch_args), len(arguments), msg))\n\n    def gen_func_dec(func):\n        \"\"\"Decorator turning a function into a generic function\"\"\"\n\n        # first check the dispatch arguments\n        argset = set(getfullargspec(func).args)\n        if not set(dispatch_args) <= argset:\n            raise NameError('Unknown dispatch arguments %s' % dispatch_str)\n\n        typemap = {}\n\n        def vancestors(*types):\n            \"\"\"\n            Get a list of sets of virtual ancestors for the given types\n            \"\"\"\n            check(types)\n            ras = [[] for _ in range(len(dispatch_args))]\n            for types_ in typemap:\n                for t, type_, ra in zip(types, types_, ras):\n                    if issubclass(t, type_) and type_ not in t.mro():\n                        append(type_, ra)\n            return [set(ra) for ra in ras]\n\n        def ancestors(*types):\n            \"\"\"\n            Get a list of virtual MROs, one for each type\n            \"\"\"\n            check(types)\n            lists = []\n            for t, vas in zip(types, vancestors(*types)):\n                n_vas = len(vas)\n                if n_vas > 1:\n                    raise RuntimeError(\n                        'Ambiguous dispatch for %s: %s' % (t, vas))\n                elif n_vas == 1:\n                    va, = vas\n                    mro = type('t', (t, va), {}).mro()[1:]\n                else:\n                    mro = t.mro()\n                lists.append(mro[:-1])  # discard t and object\n            return lists\n\n        def register(*types):\n            \"\"\"\n            Decorator to register an implementation for the given types\n            \"\"\"\n            check(types)\n\n            def dec(f):\n                check(getfullargspec(f).args, operator.lt, ' in ' + f.__name__)\n                typemap[types] = f\n                return f\n            return dec\n\n        def dispatch_info(*types):\n            \"\"\"\n            An utility to introspect the dispatch algorithm\n            \"\"\"\n            check(types)\n            lst = []\n            for anc in itertools.product(*ancestors(*types)):\n                lst.append(tuple(a.__name__ for a in anc))\n            return lst\n\n        def _dispatch(dispatch_args, *args, **kw):\n            types = tuple(type(arg) for arg in dispatch_args)\n            try:  # fast path\n                f = typemap[types]\n            except KeyError:\n                pass\n            else:\n                return f(*args, **kw)\n            combinations = itertools.product(*ancestors(*types))\n            next(combinations)  # the first one has been already tried\n            for types_ in combinations:\n                f = typemap.get(types_)\n                if f is not None:\n                    return f(*args, **kw)\n\n            # else call the default implementation\n            return func(*args, **kw)\n\n        return FunctionMaker.create(\n            func, 'return _f_(%s, %%(shortsignature)s)' % dispatch_str,\n            dict(_f_=_dispatch), register=register, default=func,\n            typemap=typemap, vancestors=vancestors, ancestors=ancestors,\n            dispatch_info=dispatch_info, __wrapped__=func)\n\n    gen_func_dec.__name__ = 'dispatch_on' + dispatch_str\n    return gen_func_dec\n", "src/tests/documentation.py": "import inspect\nimport threading\nimport time\nimport functools\nimport itertools\nimport collections\nimport collections.abc as c\nfrom decorator import (decorator, decorate, FunctionMaker,\n                       dispatch_on, __version__)\n\ndoc = r\"\"\"# Decorators for Humans\n\n|Author | Michele Simionato|\n|---|---|\n|E-mail | michele.simionato@gmail.com|\n|Version| $VERSION ($DATE)|\n|Supports| Python 3.7, 3.8, 3.9, 3.10, 3.11, 3.12|\n|Download page| https://pypi.org/project/decorator/$VERSION|\n|Installation| ``pip install decorator``|\n|License | BSD license|\n\n## Introduction\n\nThe ``decorator`` module is over ten years old, but still alive and\nkicking. It is used by several frameworks (IPython, scipy, authkit,\npylons, pycuda, sugar, ...) and has been stable for a *long* time. It\nis your best option if you want to preserve the signature of decorated\nfunctions in a consistent way across Python releases. Versions 5.X\nsupports Python versions greater than 3.4, versions 4.X supports Python\nversions back to 2.6; versions 3.X are able to support even Python 2.5 and\n2.4.\n\n## What's New in version 5\n\nVersion 5 of the decorator module features a major simplification of\nthe code base made possible by dropping support for Python releases\nolder than 3.5. From that version the ``Signature`` object works well\nenough that it is possible to fix the signature of a decorated\nfunction without resorting to ``exec`` tricks. The simplification\nhas a very neat advantage: in case of exceptions raised in decorated\nfunctions the traceback is nicer than it used to be. Moreover, it is\nnow possible to mimic the behavior of decorators defined with\n``functool.wraps``: see the section about the ``kwsyntax`` flag below.\n\n## What's New in version 4\n\n- **New documentation**\n  There is now a single manual for all Python versions, so I took the\n  opportunity to overhaul the documentation.\n  Even if you are a long-time user, you may want to revisit the docs, since\n  several examples have been improved.\n\n- **Packaging improvements**\n  The code is now also available in wheel format. Integration with\n  setuptools has improved and you can run the tests with the command\n  ``python setup.py test`` too.\n\n- **Code changes**\n  A new utility function ``decorate(func, caller)`` has been added.\n  It does the same job that was performed by the older\n  ``decorator(caller, func)``. The old functionality is now deprecated\n  and no longer documented, but still available for now.\n\n- **Multiple dispatch**\n  The decorator module now includes an implementation of generic\n  functions (sometimes called \"multiple dispatch functions\").\n  The API is designed to mimic ``functools.singledispatch`` (added\n  in Python 3.4), but the implementation is much simpler.\n  Moreover, all decorators involved preserve the signature of the\n  decorated functions. For now, this exists mostly to demonstrate\n  the power of the module. In the future it could be enhanced/optimized.\n  In any case, it is very short and compact (less then 100 lines), so you\n  can extract it for your own use. Take it as food for thought.\n\n- **Python 3.5 coroutines**\n  From version 4.1 it is possible to decorate coroutines, i.e. functions\n  defined with the `async def` syntax, and to maintain the\n  `inspect.iscoroutinefunction` check working for the decorated function.\n\n- **Decorator factories**\n  From version 4.2 there is facility to define factories of decorators in\n  a simple way, a feature requested by the users since a long time.\n\n## Usefulness of decorators\n\nPython decorators are an interesting example of why syntactic sugar\nmatters. In principle, their introduction in Python 2.4 changed\nnothing, since they did not provide any new functionality which was not\nalready present in the language. In practice, their introduction has\nsignificantly changed the way we structure our programs.\nI believe the change is for the best, and that decorators are a great\nidea since:\n\n* decorators help reducing boilerplate code;\n* decorators help separation of concerns;\n* decorators enhance readability and maintenability;\n* decorators are explicit.\n\nStill, as of now, writing custom decorators correctly requires\nsome experience and it is not as easy as it could be. For instance,\ntypical implementations of decorators involve nested functions, and\nwe all know that flat is better than nested.\n\nThe aim of the ``decorator`` module it to simplify the usage of\ndecorators for the average programmer, and to popularize decorators by\nshowing various non-trivial examples. Of course, as all techniques,\ndecorators can be abused (I have seen that) and you should not try to\nsolve every problem with a decorator, just because you can.\n\nYou may find the source code for all the examples\ndiscussed here in the ``documentation.py`` file, which contains\nthe documentation you are reading in the form of doctests.\n\n## Definitions\n\nTechnically speaking, any Python object which can be called with one argument\ncan be used as a decorator. However, this definition is somewhat too large\nto be really useful. It is more convenient to split the generic class of\ndecorators in two subclasses:\n\n1. **signature-preserving decorators**, callable objects which accept\n    a function as input and return a function as output, *with the\n    same signature*\n\n2. **signature-changing** decorators, i.e. decorators\n    which change the signature of their input function, or decorators\n    that return non-callable objects\n\nSignature-changing decorators have their use: for instance, the\nbuiltin classes ``staticmethod`` and ``classmethod`` are in this\ngroup. They take functions and return descriptor objects which\nare neither functions, nor callables.\n\nStill, signature-preserving decorators are more common, and easier\nto reason about. In particular, they can be composed together,\nwhereas other decorators generally cannot.\n\nWriting signature-preserving decorators from scratch is not that\nobvious, especially if one wants to define proper decorators that\ncan accept functions with any signature. A simple example will clarify\nthe issue.\n\n## Statement of the problem\n\nA very common use case for decorators is the memoization of functions.\nA ``memoize`` decorator works by caching\nthe result of the function call in a dictionary, so that the next time\nthe function is called with the same input parameters the result is retrieved\nfrom the cache and not recomputed.\n\nThere are many implementations of ``memoize`` in\nhttp://www.python.org/moin/PythonDecoratorLibrary,\nbut they do not preserve the signature. In recent versions of\nPython you can find a sophisticated ``lru_cache`` decorator\nin the standard library's ``functools``. Here I am just\ninterested in giving an example.\n\nConsider the following simple implementation (note that it is\ngenerally impossible to *correctly* memoize something\nthat depends on non-hashable arguments):\n\n$$memoize_uw\n\nHere I used the functools.update_wrapper_ utility, which was added\nin Python 2.5 to simplify the writing of decorators.\n(Previously, you needed to manually copy the function attributes\n``__name__``, ``__doc__``, ``__module__``, and ``__dict__``\nto the decorated function by hand).\n\nThis works insofar as the decorator accepts functions with generic signatures.\nUnfortunately, it is *not* a signature-preserving decorator, since\n``memoize_uw`` generally returns a function with a *different signature*\nfrom the original.\n\nConsider for instance the following case:\n\n$$f1\n\nHere, the original function takes a single argument named ``x``,\nbut the decorated function takes any number of arguments and\nkeyword arguments:\n\n```python\n>>> from inspect import getfullargspec\n>>> print(getfullargspec(f1))\nFullArgSpec(args=[], varargs='args', varkw='kw', defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={})\n\n```\n\nThis means that introspection tools like ``getfullargspec`` will give\nyou false information about the signature of ``f1`` This is pretty bad:\n``getfullargspec`` says that the function accepts the generic\nsignature ``*args, **kw``, but calling the function with more than one\nargument raises an error:\n\n```python\n>>> f1(0, 1) # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n   ...\nTypeError: f1() takes exactly 1 positional argument (2 given)\n\n```\n\nNotice that ``pydoc`` will give the right signature, but only in Python\nversions greater than 3.5.\n\n## The solution\n\nThe solution is to provide a generic factory of generators, which\nhides the complexity of making signature-preserving decorators\nfrom the application programmer. The ``decorate`` function in\nthe ``decorator`` module is such a factory:\n\n```python\n>>> from decorator import decorate\n\n```\n\n``decorate`` takes two arguments:\n\n1. a caller function describing the functionality of the decorator, and\n\n2. a function to be decorated.\n\nThe caller function must have signature ``(f, *args, **kw)``, and it\nmust call the original function ``f`` with arguments ``args`` and ``kw``,\nimplementing the wanted capability (in this case, memoization):\n\n$$_memoize\n\nNow, you can define your decorator as follows:\n\n$$memoize\n\nThe difference from the nested function approach of ``memoize_uw``\nis that the decorator module forces you to lift the inner function\nto the outer level. Moreover, you are forced to explicitly pass the\nfunction you want to decorate; there are no closures.\n\nHere is a test of usage:\n\n```python\n>>> @memoize\n... def heavy_computation():\n...     time.sleep(2)\n...     return \"done\"\n\n>>> print(heavy_computation()) # the first time it will take 2 seconds\ndone\n\n>>> print(heavy_computation()) # the second time it will be instantaneous\ndone\n\n```\n\nThe signature of ``heavy_computation`` is the one you would expect:\n\n```python\n>>> print(getfullargspec(heavy_computation))\nFullArgSpec(args=[], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={})\n\n```\n\n## A ``trace`` decorator\n\nHere is an example of how to define a simple ``trace`` decorator,\nwhich prints a message whenever the traced function is called:\n\n$$_trace\n\n$$trace\n\nHere is an example of usage:\n\n```python\n>>> @trace\n... def f1(x):\n...     pass\n\n```\n\nIt is immediate to verify that ``f1`` works...\n\n```python\n>>> f1(0)\ncalling f1 with args (0,), {}\n\n```\n\n...and it that it has the correct signature:\n\n```python\n>>> print(getfullargspec(f1))\nFullArgSpec(args=['x'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={})\n\n```\n\nThe decorator works with functions of any signature:\n\n```python\n>>> @trace\n... def f(x, y=1, *args, **kw):\n...     pass\n\n>>> f(0, 3)\ncalling f with args (0, 3), {}\n\n>>> print(getfullargspec(f))\nFullArgSpec(args=['x', 'y'], varargs='args', varkw='kw', defaults=(1,), kwonlyargs=[], kwonlydefaults=None, annotations={})\n\n```\n\n## Function annotations\n\nPython 3 introduced the concept of [function annotations](\nhttp://www.python.org/dev/peps/pep-3107/): the ability\nto annotate the signature of a function with additional information,\nstored in a dictionary named ``__annotations__``. The ``decorator`` module\n(starting from release 3.3) will understand and preserve these annotations.\n\nHere is an example:\n\n```python\n>>> @trace\n... def f(x: 'the first argument', y: 'default argument'=1, z=2,\n...       *args: 'varargs', **kw: 'kwargs'):\n...     pass\n\n```\n\nIn order to introspect functions with annotations, one needs\n``inspect.getfullargspec`` (introduced in Python 3, then\ndeprecated in Python 3.5, then undeprecated in Python 3.6):\n\n```python\n>>> from inspect import getfullargspec\n>>> argspec = getfullargspec(f)\n>>> argspec.args\n['x', 'y', 'z']\n>>> argspec.varargs\n'args'\n>>> argspec.varkw\n'kw'\n>>> argspec.defaults\n(1, 2)\n>>> argspec.kwonlyargs\n[]\n>>> argspec.kwonlydefaults\n\n```\n\nYou can check that the ``__annotations__`` dictionary is preserved:\n\n```python\n>>> f.__annotations__ is f.__wrapped__.__annotations__\nTrue\n\n```\n\nHere ``f.__wrapped__`` is the original undecorated function.\nThis attribute exists for consistency with the behavior of\n``functools.update_wrapper``.\n\nAnother attribute copied from the original function is ``__qualname__``,\nthe qualified name. This attribute was introduced in Python 3.3.\n\n## ``decorator.decorator``\n\nIt can become tedious to write a caller function (like the above\n``_trace`` example) and then a trivial wrapper\n(``def trace(f): return decorate(f, _trace)``) every time.\nNot to worry!  The ``decorator`` module provides an easy shortcut\nto convert the caller function into a signature-preserving decorator.\n\nIt is the ``decorator`` function:\n\n```python\n>>> from decorator import decorator\n\n```\nThe ``decorator`` function can be used as a signature-changing\ndecorator, just like ``classmethod`` and ``staticmethod``.\nBut ``classmethod`` and ``staticmethod`` return generic\nobjects which are not callable. Instead, ``decorator`` returns\nsignature-preserving decorators (i.e. functions with a single argument).\n\nFor instance, you can write:\n\n```python\n>>> @decorator\n... def trace(f, *args, **kw):\n...     kwstr = ', '.join('%r: %r' % (k, kw[k]) for k in sorted(kw))\n...     print(\"calling %s with args %s, {%s}\" % (f.__name__, args, kwstr))\n...     return f(*args, **kw)\n\n```\n\nAnd ``trace`` is now a decorator!\n\n```python\n>>> trace # doctest: +ELLIPSIS\n<function trace at 0x...>\n\n```\n\nHere is an example of usage:\n\n```python\n>>> @trace\n... def func(): pass\n\n>>> func()\ncalling func with args (), {}\n\n```\n\n## Mimicking the behavior of functools.wrap\n\nOften people are confused by the decorator module since, contrarily\nto ``functools.wraps`` in the standard library, it tries very hard\nto keep the semantics of the arguments: in particular, positional arguments\nstay positional even if they are called with the keyword argument syntax.\nAn example will make the issue clear. Here is a simple caller\n\n$$chatty\n\nand here is a function to decorate:\n\n$$printsum\n\nIn this example ``x`` and ``y`` are positional arguments (with\ndefaults). From the caller perspective, it does not matter if the user\ncalls them as named arguments, they will stay inside the ``args``\ntuple and not inside the ``kwargs`` dictionary:\n\n```python\n>>> printsum(y=2, x=1)\n(1, 2) []\n3\n\n```\n\nThis is quite different from the behavior of ``functools.wraps``; if you\ndefine the decorator as follows\n\n$$chattywrapper\n\nyou will see that calling ``printsum`` with named arguments will pass\nsuch arguments to ``kwargs``, while ``args`` will be the empty tuple.\nSince version 5 of the decorator module it is possible to mimic that\nbehavior by using the ``kwsyntax`` flag:\n\n$$printsum2\n\nHere is how it works:\n\n```python\n>>> printsum2(y=2, x=1)\n() [('x', 1), ('y', 2)]\n3\n\n```\n\nThis is exactly what the ``chattywrapper`` decorator would print:\npositional arguments are seen as keyword arguments, but only if the\nclient code calls them with the keyword syntax. Otherwise they stay\npositional, i.e. they belongs to the ``args`` tuple and not to ``kwargs``:\n\n```python\n>>> printsum2(1, 2)\n(1, 2) []\n3\n\n```\n\n## Decorator factories\n\nThe `decorator` function can also be used to define factories of decorators,\ni.e. functions returning decorators. In general you can just write something\nlike this:\n\n```python\ndef decfactory(param1, param2, ...):\n    def caller(f, *args, **kw):\n        return somefunc(f, param1, param2, .., *args, **kw)\n    return decorator(caller)\n```\n\nThis is fully general but requires an additional level of nesting. For this\nreason since version 4.2 there is a facility to build decorator factories by\nusing a single caller with default arguments:\n\n```python\ndef caller(f, param1=default1, param2=default2, ..., *args, **kw):\n    return somefunc(f, param1, param2, *args, **kw)\ndecfactory = decorator(caller)\n```\n\nNotice that this simplified approach *only works with default arguments*,\ni.e. `param1`, `param2` etc must have known defaults. Thanks to this\nrestriction, there exists an unique default decorator, i.e. the member\nof the family which uses the default values for all parameters. Such\ndecorator can be written as ``decfactory()`` with no parameters specified;\nmoreover, as a shortcut, it is also possible to elide the parenthesis,\na feature much requested by the users. For years I have been opposing\nthe request, since having explicit parenthesis to me is more clear\nand less magic; however once this feature entered in decorators of\nthe Python standard library (I am referring to the [dataclass decorator](\nhttps://www.python.org/dev/peps/pep-0557/)) I finally gave up.\n\nThe example below shows how it works in practice. The goal is to\nconvert a function relying on a blocking resource into a function\nreturning a \"busy\" message if the resource is not available.\nThis can be accomplished with a suitable family of decorators\nparameterize by a string, the busy message:\n\n$$blocking\n\nFunctions decorated with ``blocking`` will return a busy message if\nthe resource is unavailable, and the intended result if the resource is\navailable. For instance:\n\n```python\n>>> @blocking(msg=\"Please wait ...\")\n... def read_data():\n...     time.sleep(3) # simulate a blocking resource\n...     return \"some data\"\n\n>>> print(read_data())  # data is not available yet\nPlease wait ...\n\n>>> time.sleep(1)\n>>> print(read_data())  # data is not available yet\nPlease wait ...\n\n>>> time.sleep(1)\n>>> print(read_data())  # data is not available yet\nPlease wait ...\n\n>>> time.sleep(1.1)  # after 3.1 seconds, data is available\n>>> print(read_data())\nsome data\n\n```\n\nDecorator factories are most useful to framework builders. Here is an example\nthat gives an idea of how you could manage permissions in a framework:\n\n$$Action\n\nwhere ``restricted`` is a decorator factory defined as follows\n\n$$restricted\n\nNotice that if you forget to use the keyword argument notation, i.e. if you\nwrite ``restricted(User)`` instead of ``restricted(user_class=User)`` you\nwill get an error\n\n```python\nTypeError: You are decorating a non function: <class '__main__.User'>\n\n```\n\nBe careful!\n\n## ``decorator(cls)``\n\nThe ``decorator`` facility can also produce a decorator starting\nfrom a class with the signature of a caller. In such a case the\nproduced generator is able to convert functions into factories\nto create instances of that class.\n\nAs an example, here is a decorator which can convert a\nblocking function into an asynchronous function. When\nthe function is called, it is executed in a separate thread.\n\n(This is similar to the approach used in the ``concurrent.futures`` package.\nBut I don't recommend that you implement futures this way; this is just an\nexample.)\n\n$$Future\n\nThe decorated function returns a ``Future`` object. It has a ``.result()``\nmethod which blocks until the underlying thread finishes and returns\nthe final result.\n\nHere is the minimalistic usage:\n\n```python\n>>> @decorator(Future)\n... def long_running(x):\n...     time.sleep(.5)\n...     return x\n\n>>> fut1 = long_running(1)\n>>> fut2 = long_running(2)\n>>> fut1.result() + fut2.result()\n3\n\n```\n\n## contextmanager\n\nPython's standard library has the ``contextmanager`` decorator,\nwhich converts a generator function into a ``GeneratorContextManager``\nfactory. For instance, if you write this...\n\n```python\n>>> from contextlib import contextmanager\n>>> @contextmanager\n... def before_after(before, after):\n...     print(before)\n...     yield\n...     print(after)\n\n```\n\n...then ``before_after`` is a factory function that returns\n``GeneratorContextManager`` objects, usable with the ``with`` statement:\n\n```python\n>>> with before_after('BEFORE', 'AFTER'):\n...     print('hello')\nBEFORE\nhello\nAFTER\n\n```\n\nBasically, it is as if the content of the ``with`` block was executed\nin the place of the ``yield`` expression in the generator function.\n\nIn Python 3.2, ``GeneratorContextManager`` objects were enhanced with\na ``__call__`` method, so that they can be used as decorators, like so:\n\n```python\n>>> ba = before_after('BEFORE', 'AFTER')\n>>>\n>>> @ba\n... def hello():\n...     print('hello')\n...\n>>> hello()\nBEFORE\nhello\nAFTER\n\n```\n\nThe ``ba`` decorator basically inserts a ``with ba:`` block\ninside the function.\n\nHowever ``GeneratorContextManager`` objects do not preserve the signature of\nthe decorated functions. The decorated ``hello`` function above will\nhave the generic signature ``hello(*args, **kwargs)``, but fails if\ncalled with more than zero arguments.\n\nFor these reasons, the `decorator` module, starting from release 3.4, offers a\n``decorator.contextmanager`` decorator that solves both problems,\n*and* works in all supported Python versions.  Its usage is identical,\nand factories decorated with ``decorator.contextmanager`` will return\ninstances of ``ContextManager``, a subclass of the standard library's\n``contextlib.GeneratorContextManager`` class. The subclass includes\nan improved ``__call__`` method, which acts as a signature-preserving\ndecorator.\n\n## The ``FunctionMaker`` class\n\nThe ``decorator`` module also provides a ``FunctionMaker`` class, which\nis able to generate on-the-fly functions\nwith a given name and signature from a function template\npassed as a string.\n\nIf you're just writing ordinary decorators, then you probably won't\nneed to use ``FunctionMaker``. But in some circumstances, it\ncan be handy. You will see an example shortly--in\nthe implementation of a cool decorator utility (``decorator_apply``).\n\n``FunctionMaker`` provides the ``.create`` classmethod, which\naccepts the *name*, *signature*, and *body* of the function\nyou want to generate, as well as the execution environment\nwhere the function is generated by ``exec``.\n\nHere's an example:\n\n```python\n>>> def f(*args, **kw): # a function with a generic signature\n...     print(args, kw)\n\n>>> f1 = FunctionMaker.create('f1(a, b)', 'f(a, b)', dict(f=f))\n>>> f1(1,2)\n(1, 2) {}\n\n```\n\nIt is important to notice that the function body is interpolated\nbefore being executed; **be careful** with the ``%`` sign!\n\n``FunctionMaker.create`` also accepts keyword arguments.\nThe keyword arguments are attached to the generated function.\nThis is useful if you want to set some function attributes\n(e.g., the docstring ``__doc__``).\n\nFor debugging/introspection purposes, it may be useful to see\nthe source code of the generated function. To do this, just\npass ``addsource=True``, and the generated function will get\na ``__source__`` attribute:\n\n```python\n>>> f1 = FunctionMaker.create(\n...     'f1(a, b)', 'f(a, b)', dict(f=f), addsource=True)\n>>> print(f1.__source__)\ndef f1(a, b):\n    f(a, b)\n<BLANKLINE>\n\n```\n\nThe first argument to ``FunctionMaker.create`` can be a string (as above),\nor a function. This is the most common usage, since you typically decorate\npre-existing functions.\n\nIf you're writing a framework, however, you may want to use\n``FunctionMaker.create`` directly, rather than ``decorator``, because it gives\nyou direct access to the body of the generated function.\n\nFor instance, suppose you want to instrument the ``__init__`` methods of a\nset of classes, by preserving their signature.\n(This use case is not made up. This is done by SQAlchemy, and other frameworks,\ntoo.)\nHere is what happens:\n\n- If first argument of ``FunctionMaker.create`` is a function,\n  an instance of ``FunctionMaker`` is created with the attributes\n  ``args``, ``varargs``, ``keywords``, and ``defaults``\n  (these mirror the return values of the standard library's\n  ``inspect.getfullargspec``).\n\n- For each item in ``args`` (a list of strings of the names of all required\n  arguments), an attribute ``arg0``, ``arg1``, ..., ``argN`` is also generated.\n\n- Finally, there is a ``signature`` attribute, which is a string with the\n  signature of the original function.\n\n**NOTE:** You should not pass signature strings with default arguments\n(e.g., something like ``'f1(a, b=None)'``). Just pass ``'f1(a, b)'``,\nfollowed by a tuple of defaults:\n\n```python\n>>> f1 = FunctionMaker.create(\n...     'f1(a, b)', 'f(a, b)', dict(f=f), addsource=True, defaults=(None,))\n>>> print(getfullargspec(f1))\nFullArgSpec(args=['a', 'b'], varargs=None, varkw=None, defaults=(None,), kwonlyargs=[], kwonlydefaults=None, annotations={})\n\n```\n\n## Getting the source code\n\nInternally, ``FunctionMaker.create`` uses ``exec`` to generate the\ndecorated function. Therefore ``inspect.getsource`` will not work for\ndecorated functions. In IPython, this means that the usual ``??`` trick\nwill give you the (right on the spot) message ``Dynamically generated\nfunction. No source code available``.\nHowever, there is a workaround. The decorated function has the ``__wrapped__``\nattribute, pointing to the original function. The simplest way to get the\nsource code is to call ``inspect.getsource`` on the undecorated function:\n\n```python\n>>> print(inspect.getsource(factorial.__wrapped__))\n@tail_recursive\ndef factorial(n, acc=1):\n    \"The good old factorial\"\n    if n == 0:\n        return acc\n    return factorial(n-1, n*acc)\n<BLANKLINE>\n\n```\n\n## Dealing with third-party decorators\n\nSometimes on the net you find some cool decorator that you would\nlike to include in your code. However, more often than not, the cool\ndecorator is not signature-preserving. What you need is an easy way to\nupgrade third party decorators to signature-preserving decorators...\n*without* having to rewrite them in terms of ``decorator``.\n\nYou can use a ``FunctionMaker`` to implement that functionality as follows:\n\n$$decorator_apply\n\n``decorator_apply`` sets the generated function's ``__wrapped__`` attribute\nto the original function, so you can get the right source code.\nIf you are using a Python later than 3.2, you should also set the\n``__qualname__`` attribute to preserve the qualified name of the original\nfunction.\n\nNotice that I am not providing this functionality in the ``decorator``\nmodule directly, since I think it is best to rewrite the decorator instead\nof adding another level of indirection. However, practicality\nbeats purity, so you can add ``decorator_apply`` to your toolbox and\nuse it if you need to.\n\nTo give a good example for ``decorator_apply``, I will show a pretty slick\ndecorator that converts a tail-recursive function into an iterative function.\nI have shamelessly stolen the core concept from Kay Schluehr's recipe\nin the Python Cookbook,\nhttp://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691.\n\n$$TailRecursive\n\nHere the decorator is implemented as a class returning callable\nobjects.\n\n$$tail_recursive\n\nHere is how you apply the upgraded decorator to the good old factorial:\n\n$$factorial\n\n```python\n>>> print(factorial(4))\n24\n\n```\n\nThis decorator is pretty impressive, and should give you some food for\nthought! ;)\n\nNotice that there is no recursion limit now; you can easily compute\n``factorial(1001)`` (or larger) without filling the stack frame.\n\nNotice also that the decorator will *not* work on functions which\nare not tail recursive, such as the following:\n\n$$fact\n\n**Reminder:** A function is *tail recursive* if it does either of the\nfollowing:\n\n- returns a value without making a recursive call; or,\n- returns directly the result of a recursive call.\n\n## Python 3.5 coroutines\n\nI am personally not using Python 3.5 coroutines yet. However, some\nusers requested support for coroutines and since version 4.1 the\ndecorator module has it.  You should consider the support experimental\nand kindly report issues if you find any.\n\nHere I will give a single example of usage. Suppose you want to log the moment\na coroutine starts and the moment it stops for debugging purposes. You could\nwrite code like the following:\n\n```python\nimport time\nimport logging\nfrom asyncio import get_event_loop, sleep, wait\nfrom decorator import decorator\n\n@decorator\nasync def log_start_stop(coro, *args, **kwargs):\n    logging.info('Starting %s%s', coro.__name__, args)\n    t0 = time.time()\n    await coro(*args, **kwargs)\n    dt = time.time() - t0\n    logging.info('Ending %s%s after %d seconds', coro.__name__, args, dt)\n\n@log_start_stop\nasync def make_task(n):\n    for i in range(n):\n        await sleep(1)\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    tasks = [make_task(3), make_task(2), make_task(1)]\n    get_event_loop().run_until_complete(wait(tasks))\n```\n\nand you will get an output like this:\n\n```bash\nINFO:root:Starting make_task(1,)\nINFO:root:Starting make_task(3,)\nINFO:root:Starting make_task(2,)\nINFO:root:Ending make_task(1,) after 1 seconds\nINFO:root:Ending make_task(2,) after 2 seconds\nINFO:root:Ending make_task(3,) after 3 seconds\n```\n\nThis may be handy if you have trouble understanding what it going on\nwith a particularly complex chain of coroutines. With a single line you\ncan decorate the troubling coroutine function, understand what happens, fix the\nissue and then remove the decorator (or keep it if continuous monitoring\nof the coroutines makes sense). Notice that\n``inspect.iscoroutinefunction(make_task)``\nwill return the right answer (i.e. ``True``).\n\nIt is also possible to define decorators converting coroutine functions\ninto regular functions, such as the following:\n\n```python\n@decorator\ndef coro_to_func(coro, *args, **kw):\n    \"Convert a coroutine into a function\"\n     return get_event_loop().run_until_complete(coro(*args, **kw))\n```\n\nNotice the difference: the caller in ``log_start_stop`` was a coroutine\nfunction and the associate decorator was converting coroutines in coroutines;\nthe caller in ``coro_to_func`` is a regular function and converts\ncoroutines -> functions.\n\n## Multiple dispatch\n\nThere has been talk of implementing multiple dispatch functions\n(i.e. \"generic functions\") in Python for over ten years. Last year,\nsomething concrete was done for the first time. As of Python 3.4,\nwe have the decorator ``functools.singledispatch`` to implement generic\nfunctions!\n\nAs its name implies, it is limited to *single dispatch*; in other words,\nit is able to dispatch on the first argument of the function only.\n\nThe ``decorator`` module provides the decorator factory ``dispatch_on``,\nwhich can be used to implement generic functions dispatching on *any* argument.\nMoreover, it can manage dispatching on more than one argument.\n(And, of course, it is signature-preserving.)\n\nHere is a concrete example (from a real-life use case) where it is desiderable\nto dispatch on the second argument.\n\nSuppose you have an ``XMLWriter`` class, which is instantiated\nwith some configuration parameters, and has the ``.write`` method which\nserializes objects to XML:\n\n$$XMLWriter\n\nHere, you want to dispatch on the *second* argument; the first is already\ntaken by ``self``. The ``dispatch_on`` decorator factory allows you to specify\nthe dispatch argument simply by passing its name as a string. (Note\nthat if you misspell the name you will get an error.)\n\nThe decorated function `write` is turned into a generic function (\n`write` is a function at the idea it is decorated; it will be turned\ninto a method later, at class instantiation time),\nand it is called if there are no more specialized implementations.\n\nUsually, default functions should raise a ``NotImplementedError``, thus\nforcing people to register some implementation.\nYou can perform the registration with a decorator:\n\n$$writefloat\n\nNow ``XMLWriter`` can serialize floats:\n\n```python\n>>> writer = XMLWriter()\n>>> writer.write(2.3)\n'<float>2.3</float>'\n\n```\n\nI could give a down-to-earth example of situations in which it is desiderable\nto dispatch on more than one argument--for instance, I once implemented\na database-access library where the first dispatching argument was the\nthe database driver, and the second was the database record--but here\nI will follow tradition, and show the time-honored Rock-Paper-Scissors example:\n\n$$Rock\n$$Paper\n$$Scissors\n\nI have added an ordinal to the Rock-Paper-Scissors classes to simplify\nthe implementation. The idea is to define a generic function (``win(a,\nb)``) of two arguments corresponding to the *moves* of the first and\nsecond players. The *moves* are instances of the classes\nRock, Paper, and Scissors:\n\n- Paper wins over Rock\n- Scissors wins over Paper\n- Rock wins over Scissors\n\nThe function will return +1 for a win, -1 for a loss, and 0 for parity.\nThere are 9 combinations, but combinations with the same ordinal\n(i.e. the same class) return 0. Moreover, by exchanging the order of the\narguments, the sign of the result changes. Therefore, it is sufficient to\ndirectly specify only 3 implementations:\n\n$$win\n$$winRockPaper\n$$winPaperScissors\n$$winRockScissors\n\nHere is the result:\n\n```python\n>>> win(Paper(), Rock())\n1\n>>> win(Scissors(), Paper())\n1\n>>> win(Rock(), Scissors())\n1\n>>> win(Paper(), Paper())\n0\n>>> win(Rock(), Rock())\n0\n>>> win(Scissors(), Scissors())\n0\n>>> win(Rock(), Paper())\n-1\n>>> win(Paper(), Scissors())\n-1\n>>> win(Scissors(), Rock())\n-1\n\n```\n\nThe point of generic functions is that they play well with subclassing.\nFor instance, suppose we define a ``StrongRock``, which does not lose against\nPaper:\n\n$$StrongRock\n$$winStrongRockPaper\n\nThen you do not need to define other implementations; they are\ninherited from the parent:\n\n```python\n>>> win(StrongRock(), Scissors())\n1\n\n```\n\nYou can introspect the precedence used by the dispatch algorithm by\ncalling ``.dispatch_info(*types)``:\n\n```python\n>>> win.dispatch_info(StrongRock, Scissors)\n[('StrongRock', 'Scissors'), ('Rock', 'Scissors')]\n\n```\n\nSince there is no direct implementation for (``StrongRock``, ``Scissors``),\nthe dispatcher will look at the implementation for (``Rock``, ``Scissors``)\nwhich is available. Internally, the algorithm is doing a cross\nproduct of the class precedence lists (or *Method Resolution Orders*,\n[MRO](http://www.python.org/2.3/mro.html) for short) of ``StrongRock``\n and ``Scissors``, respectively.\n\n## Generic functions and virtual ancestors\n\nIn Python, generic functions are complicated by the existence of\n\"virtual ancestors\": superclasses which are not in the class hierarchy.\n\nConsider this class:\n\n$$WithLength\n\nThis class defines a ``__len__`` method, and is therefore\nconsidered to be a subclass of the abstract base class\n``collections.abc.Sized`` (``collections.Sized`` on Python 2):\n\n```python\n>>> issubclass(WithLength, collections.abc.Sized)\nTrue\n\n```\n\nHowever, ``collections.abc.Sized`` is not in the MRO_ of ``WithLength``; it\nis not a true ancestor. Any implementation of generic functions (even\nwith single dispatch) must go through some contorsion to take into\naccount the virtual ancestors.\n\nIn particular, if we define a generic function...\n\n$$get_length\n\n...implemented on all classes with a length...\n\n$$get_length_sized\n\n...then ``get_length`` must be defined on ``WithLength`` instances...\n\n```python\n>>> get_length(WithLength())\n0\n\n```\n\n...even if ``collections.abc.Sized`` is not a true ancestor of ``WithLength``.\n\nOf course, this is a contrived example--you could just use the\nbuiltin ``len``--but you should get the idea.\n\nSince in Python it is possible to consider any instance of ``ABCMeta``\nas a virtual ancestor of any other class (it is enough to register it\nas ``ancestor.register(cls)``), any implementation of generic functions\nmust be aware of the registration mechanism.\n\nFor example, suppose you are using a third-party set-like class, like\nthe following:\n\n$$SomeSet\n\nHere, the author of ``SomeSet`` made a mistake by inheriting from\n``collections.abc.Sized`` (instead of ``collections.abc.Set``).\n\nThis is not a problem. You can register *a posteriori*\n``collections.abc.Set`` as a virtual ancestor of ``SomeSet``:\n\n```python\n>>> _ = collections.abc.Set.register(SomeSet)\n>>> issubclass(SomeSet, collections.abc.Set)\nTrue\n\n```\n\nNow, let's define an implementation of ``get_length`` specific to set:\n\n$$get_length_set\n\nThe current implementation (and ``functools.singledispatch`` too)\nis able to discern that a ``Set`` is a ``Sized`` object, by looking at\nthe class registry, so it uses the more specific implementation for ``Set``:\n\n```python\n>>> get_length(SomeSet())  # NB: the implementation for Sized would give 0\n1\n\n```\n\nSometimes it is not clear how to dispatch. For instance, consider a\nclass ``C`` registered both as ``collections.abc.Iterable`` and\n``collections.abc.Sized``, and defines a generic function ``g`` with\nimplementations for both ``collections.abc.Iterable`` *and*\n``collections.abc.Sized``:\n\n$$singledispatch_example1\n\nIt is impossible to decide which implementation to use, since the ancestors\nare independent. The following function will raise a ``RuntimeError``\nwhen called. This is consistent with the \"refuse the temptation to guess\"\nphilosophy. ``functools.singledispatch`` would raise a similar error.\n\nIt would be easy to rely on the order of registration to decide the\nprecedence order. This is reasonable, but also fragile:\n\n- if, during some refactoring, you change the registration order by mistake,\n  a different implementation could be taken;\n- if implementations of the generic functions are distributed across modules,\n  and you change the import order, a different implementation could be taken.\n\nSo the ``decorator`` module prefers to raise an error in the face of ambiguity.\nThis is the same approach taken by the standard library.\n\nHowever, it should be noted that the *dispatch algorithm* used by the decorator\nmodule is different from the one used by the standard library, so in certain\ncases you will get different answers. The difference is that\n``functools.singledispatch`` tries to insert the virtual ancestors *before* the\nbase classes, whereas ``decorator.dispatch_on`` tries to insert them *after*\nthe base classes.\n\nHere's an example that shows the difference:\n\n$$singledispatch_example2\n\nIf you play with this example and replace the ``singledispatch`` definition\nwith ``functools.singledispatch``, the assertion will break: ``g`` will return\n``\"container\"`` instead of ``\"s\"``, because ``functools.singledispatch``\nwill insert the ``Container`` class right before ``S``.\n\nNotice that here I am not making any bold claim such as \"the standard\nlibrary algorithm is wrong and my algorithm is right\" or vice versa. It\njust point out that there are some subtle differences. The only way to\nunderstand what is really happening here is to scratch your head by\nlooking at the implementations. I will just notice that\n``.dispatch_info`` is quite essential to see the class precedence\nlist used by algorithm:\n\n```python\n>>> g, V = singledispatch_example2()\n>>> g.dispatch_info(V)\n[('V',), ('Sized',), ('S',), ('Container',)]\n\n```\n\nThe current implementation does not implement any kind of cooperation\nbetween implementations. In other words, nothing is akin either to\ncall-next-method in Lisp, or to ``super`` in Python.\n\nFinally, let me notice that the decorator module implementation does\nnot use any cache, whereas the ``singledispatch`` implementation does.\n\n## Caveats and limitations\n\nIn the present implementation, decorators generated by ``decorator``\ncan only be used on user-defined Python functions, methods or coroutines.\nI have no interest in decorating generic callable objects. If you want to\ndecorate things like classmethods/staticmethods and general callables -\nwhich I will never support in the decorator module - I suggest you\nto look at the [wrapt](https://wrapt.readthedocs.io/en/latest/)\nproject by Graeme Dumpleton.\n\nSince version 5 the ``decorator`` module uses the ``inspect.Signature``\nobject in the standard library. Unfortunately, for legacy reasons, some\napplications introspect decorated functions by using low-level entities like\nthe ``__code__`` object and not signature objects. An example will make\nthe issue clear:\n\n```python\n>>> def f(a, b): pass\n>>> f_dec = decorator(_trace)(f)\n>>> f_dec.__code__.co_argcount\n0\n>>> f_dec.__code__.co_varnames\n('args', 'kw')\n\n```\nThis is not what one would expect: the `argcount` should be 2 since\nthe original functions has two arguments and the `varnames` should be\n`a` and `b`. The only way to fix the issue is to go back to an implementation\nof the decorator using ``exec``, which is provided for convenience since\nversion 5.1:\n\n```python\n>>> from decorator import decoratorx\n>>> f_dec = decoratorx(_trace)(f)\n>>> f_dec.__code__.co_argcount\n2\n>>> f_dec.__code__.co_varnames\n('a', 'b')\n\n```\nRather than using `decoratorx`, you should fix your introspection\nroutines to use ``inspect.Signature`` without fiddling with the\n``__code__`` object.\n\nThere is a strange quirk when decorating functions with keyword\narguments, if one of the arguments has the same name used in the\ncaller function for the first argument. The quirk was reported by\nDavid Goldstein.\n\nHere is an example where it is manifest:\n\n```python\n>>> @memoize\n... def getkeys(**kw):\n...     return kw.keys()\n\n>>> getkeys(func='a') # doctest: +ELLIPSIS\nTraceback (most recent call last):\n ...\nTypeError: _memoize() got multiple values for ... 'func'\n\n```\n\nThe error message looks really strange... until you realize that\nthe caller function `_memoize` uses `func` as first argument,\nso there is a confusion between the positional argument and the\nkeyword arguments.\n\nThe solution is to change the name of the first argument in `_memoize`,\nor to change the implementation like so:\n\n```python\n\ndef _memoize(*all_args, **kw):\n    func = all_args[0]\n    args = all_args[1:]\n    if kw:  # frozenset is used to ensure hashability\n        key = args, frozenset(kw.items())\n    else:\n        key = args\n    cache = func.cache  # attribute added by memoize\n    if key not in cache:\n        cache[key] = func(*args, **kw)\n    return cache[key]\n```\n\nThis avoids the need to name the first argument, so the problem\nsimply disappears. This is a technique that you should keep in mind\nwhen writing decorators for functions with keyword arguments. Also,\nnotice that lately I have come to believe that decorating functions with\nkeyword arguments is not such a good idea, and you may want not to do\nthat.\n\nThe implementation is such that the decorated function makes\na (shallow) copy of the original function dictionary:\n\n```python\n>>> def f(): pass # the original function\n>>> f.attr1 = \"something\" # setting an attribute\n>>> f.attr2 = \"something else\" # setting another attribute\n\n>>> traced_f = trace(f) # the decorated function\n\n>>> traced_f.attr1\n'something'\n>>> traced_f.attr2 = \"something different\" # setting attr\n>>> f.attr2 # the original attribute did not change\n'something else'\n\n```\n\nFinally, you should be aware of the performance penalty of decorators.\nThe worse case is shown by the following example:\n\n```bash\n $ cat performance.sh\n python3 -m timeit -s \"\n from decorator import decorator\n\n @decorator\n def do_nothing(func, *args, **kw):\n     return func(*args, **kw)\n\n @do_nothing\n def f():\n     pass\n \" \"f()\"\n\n python3 -m timeit -s \"\n def f():\n     pass\n \" \"f()\"\n\n```\nOn my laptop, using the ``do_nothing`` decorator instead of the\nplain function is five times slower:\n\n```bash\n $ bash performance.sh\n 1000000 loops, best of 3: 1.39 usec per loop\n 1000000 loops, best of 3: 0.278 usec per loop\n```\n\nOf course, a real life function probably does something more useful\nthan the function ``f`` here, so the real life performance penalty\n*could* be negligible.  As always, the only way to know if there is a\npenalty in your specific use case is to measure it.\n\n## LICENSE (2-clause BSD)\n\nCopyright (c) 2005-2020, Michele Simionato\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n  Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n  Redistributions in bytecode form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in\n  the documentation and/or other materials provided with the\n  distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\nOF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nIf you use this software and you are happy with it, consider sending me a\nnote, just to gratify my ego. On the other hand, if you use this software and\nyou are unhappy with it, send me a patch!\n\"\"\"\n\ntoday = time.strftime('%Y-%m-%d')\n\n__doc__ = doc.replace('$VERSION', __version__).replace('$DATE', today)\n\n\ndef decorator_apply(dec, func):\n    \"\"\"\n    Decorate a function by preserving the signature even if dec\n    is not a signature-preserving decorator.\n    \"\"\"\n    return FunctionMaker.create(\n        func, 'return decfunc(%(shortsignature)s)',\n        dict(decfunc=dec(func)), __wrapped__=func)\n\n\ndef _trace(f, *args, **kw):\n    kwstr = ', '.join('%r: %r' % (k, kw[k]) for k in sorted(kw))\n    print(\"calling %s with args %s, {%s}\" % (f.__name__, args, kwstr))\n    return f(*args, **kw)\n\n\ndef trace(f):\n    return decorate(f, _trace)\n\n\nclass Future(threading.Thread):\n    \"\"\"\n    A class converting blocking functions into asynchronous\n    functions by using threads.\n    \"\"\"\n    def __init__(self, func, *args, **kw):\n        try:\n            counter = func.counter\n        except AttributeError:  # instantiate the counter at the first call\n            counter = func.counter = itertools.count(1)\n        name = '%s-%s' % (func.__name__, next(counter))\n\n        def func_wrapper():\n            self._result = func(*args, **kw)\n        super(Future, self).__init__(target=func_wrapper, name=name)\n        self.start()\n\n    def result(self):\n        self.join()\n        return self._result\n\n\ndef identity_dec(func):\n    def wrapper(*args, **kw):\n        return func(*args, **kw)\n    return wrapper\n\n\n@identity_dec\ndef example():\n    pass\n\n\ndef memoize_uw(func):\n    func.cache = {}\n\n    def memoize(*args, **kw):\n        if kw:  # frozenset is used to ensure hashability\n            key = args, frozenset(kw.items())\n        else:\n            key = args\n        if key not in func.cache:\n            func.cache[key] = func(*args, **kw)\n        return func.cache[key]\n    return functools.update_wrapper(memoize, func)\n\n\n@memoize_uw\ndef f1(x):\n    \"Simulate some long computation\"\n    time.sleep(1)\n    return x\n\n\ndef _memoize(func, *args, **kw):\n    if kw:  # frozenset is used to ensure hashability\n        key = args, frozenset(kw.items())\n    else:\n        key = args\n    cache = func.cache  # attribute added by memoize\n    if key not in cache:\n        cache[key] = func(*args, **kw)\n    return cache[key]\n\n\ndef memoize(f):\n    \"\"\"\n    A simple memoize implementation. It works by adding a .cache dictionary\n    to the decorated function. The cache will grow indefinitely, so it is\n    your responsibility to clear it, if needed.\n    \"\"\"\n    f.cache = {}\n    return decorate(f, _memoize)\n\n\n@decorator\ndef blocking(f, msg='blocking', *args, **kw):\n    if not hasattr(f, \"thread\"):  # no thread running\n        def set_result():\n            f.result = f(*args, **kw)\n        f.thread = threading.Thread(None, set_result)\n        f.thread.start()\n        return msg\n    elif f.thread.is_alive():\n        return msg\n    else:  # the thread is ended, return the stored result\n        del f.thread\n        return f.result\n\n\nclass User(object):\n    \"Will just be able to see a page\"\n\n\nclass PowerUser(User):\n    \"Will be able to add new pages too\"\n\n\nclass Admin(PowerUser):\n    \"Will be able to delete pages too\"\n\n\nclass PermissionError(Exception):\n    \"\"\"\n    >>> a = Action()\n    >>> a.user = User()\n    >>> a.view() # ok\n    >>> a.insert() # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n       ...\n    PermissionError: User does not have the permission to run insert!\n    \"\"\"\n\n\n@decorator\ndef restricted(func, user_class=User, *args, **kw):\n    \"Restrict access to a given class of users\"\n    self = args[0]\n    if isinstance(self.user, user_class):\n        return func(*args, **kw)\n    else:\n        raise PermissionError(\n            '%s does not have the permission to run %s!'\n            % (self.user, func.__name__))\n\n\nclass Action(object):\n    @restricted(user_class=User)\n    def view(self):\n        \"Any user can view objects\"\n\n    @restricted(user_class=PowerUser)\n    def insert(self):\n        \"Only power users can insert objects\"\n\n    @restricted(user_class=Admin)\n    def delete(self):\n        \"Only the admin can delete objects\"\n\n\nclass TailRecursive(object):\n    \"\"\"\n    tail_recursive decorator based on Kay Schluehr's recipe\n    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691\n    with improvements by me and George Sakkis.\n    \"\"\"\n\n    def __init__(self, func):\n        self.func = func\n        self.firstcall = True\n        self.CONTINUE = object()  # sentinel\n\n    def __call__(self, *args, **kwd):\n        CONTINUE = self.CONTINUE\n        if self.firstcall:\n            func = self.func\n            self.firstcall = False\n            try:\n                while True:\n                    result = func(*args, **kwd)\n                    if result is CONTINUE:  # update arguments\n                        args, kwd = self.argskwd\n                    else:  # last call\n                        return result\n            finally:\n                self.firstcall = True\n        else:  # return the arguments of the tail call\n            self.argskwd = args, kwd\n            return CONTINUE\n\n\ndef tail_recursive(func):\n    return decorator_apply(TailRecursive, func)\n\n\n@tail_recursive\ndef factorial(n, acc=1):\n    \"The good old factorial\"\n    if n == 0:\n        return acc\n    return factorial(n-1, n*acc)\n\n\ndef fact(n):  # this is not tail-recursive\n    if n == 0:\n        return 1\n    return n * fact(n-1)\n\n\ndef a_test_for_pylons():\n    \"\"\"\n    In version 3.1.0 decorator(caller) returned a nameless partial\n    object, thus breaking Pylons. That must not happen again.\n\n    >>> decorator(_memoize).__name__\n    '_memoize'\n\n    Here is another bug of version 3.1.1 missing the docstring:\n\n    >>> factorial.__doc__\n    'The good old factorial'\n    \"\"\"\n\n\ndef test_kwonlydefaults():\n    \"\"\"\n    >>> @trace\n    ... def f(arg, defarg=1, *args, kwonly=2): pass\n    ...\n    >>> f.__kwdefaults__\n    {'kwonly': 2}\n    \"\"\"\n\n\ndef test_kwonlyargs():\n    \"\"\"\n    >>> @trace\n    ... def func(a, b, *args, y=2, z=3, **kwargs):\n    ...     return y, z\n    ...\n    >>> func('a', 'b', 'c', 'd', 'e', y='y', z='z', cat='dog')\n    calling func with args ('a', 'b', 'c', 'd', 'e'), {'cat': 'dog', 'y': 'y', 'z': 'z'}\n    ('y', 'z')\n    \"\"\"\n\n\ndef test_kwonly_no_args():\n    \"\"\"# this was broken with decorator 3.3.3\n    >>> @trace\n    ... def f(**kw): pass\n    ...\n    >>> f()\n    calling f with args (), {}\n    \"\"\"\n\n\ndef test_kwonly_star_notation():\n    \"\"\"\n    >>> @trace\n    ... def f(*, a=1, **kw): pass\n    ...\n    >>> import inspect\n    >>> inspect.getfullargspec(f)\n    FullArgSpec(args=[], varargs=None, varkw='kw', defaults=None, kwonlyargs=['a'], kwonlydefaults={'a': 1}, annotations={})\n    \"\"\"\n\n# #######################  multiple dispatch ############################ #\n\n\nclass XMLWriter(object):\n    def __init__(self, **config):\n        self.cfg = config\n\n    @dispatch_on('obj')\n    def write(self, obj):\n        raise NotImplementedError(type(obj))\n\n\n@XMLWriter.write.register(float)\ndef writefloat(self, obj):\n    return '<float>%s</float>' % obj\n\n\nclass Rock(object):\n    ordinal = 0\n\n\nclass Paper(object):\n    ordinal = 1\n\n\nclass Scissors(object):\n    ordinal = 2\n\n\nclass StrongRock(Rock):\n    pass\n\n\n@dispatch_on('a', 'b')\ndef win(a, b):\n    if a.ordinal == b.ordinal:\n        return 0\n    elif a.ordinal > b.ordinal:\n        return -win(b, a)\n    raise NotImplementedError((type(a), type(b)))\n\n\n@win.register(Rock, Paper)\ndef winRockPaper(a, b):\n    return -1\n\n\n@win.register(Rock, Scissors)\ndef winRockScissors(a, b):\n    return 1\n\n\n@win.register(Paper, Scissors)\ndef winPaperScissors(a, b):\n    return -1\n\n\n@win.register(StrongRock, Paper)\ndef winStrongRockPaper(a, b):\n    return 0\n\n\nclass WithLength(object):\n    def __len__(self):\n        return 0\n\n\nclass SomeSet(collections.abc.Sized):\n    # methods that make SomeSet set-like\n    # not shown ...\n    def __len__(self):\n        return 0\n\n\n@dispatch_on('obj')\ndef get_length(obj):\n    raise NotImplementedError(type(obj))\n\n\n@get_length.register(collections.abc.Sized)\ndef get_length_sized(obj):\n    return len(obj)\n\n\n@get_length.register(collections.abc.Set)\ndef get_length_set(obj):\n    return 1\n\n\nclass C(object):\n    \"Registered as Sized and Iterable\"\n\n\ncollections.abc.Sized.register(C)\ncollections.abc.Iterable.register(C)\n\n\ndef singledispatch_example1():\n    singledispatch = dispatch_on('obj')\n\n    @singledispatch\n    def g(obj):\n        raise NotImplementedError(type(g))\n\n    @g.register(collections.abc.Sized)\n    def g_sized(object):\n        return \"sized\"\n\n    @g.register(collections.abc.Iterable)\n    def g_iterable(object):\n        return \"iterable\"\n\n    g(C())  # RuntimeError: Ambiguous dispatch: Iterable or Sized?\n\n\ndef singledispatch_example2():\n    # adapted from functools.singledispatch test case\n    singledispatch = dispatch_on('arg')\n\n    class S(object):\n        pass\n\n    class V(c.Sized, S):\n        def __len__(self):\n            return 0\n\n    @singledispatch\n    def g(arg):\n        return \"base\"\n\n    @g.register(S)\n    def g_s(arg):\n        return \"s\"\n\n    @g.register(c.Container)\n    def g_container(arg):\n        return \"container\"\n\n    v = V()\n    assert g(v) == \"s\"\n    c.Container.register(V)  # add c.Container to the virtual mro of V\n    assert g(v) == \"s\"  # since the virtual mro is V, Sized, S, Container\n    return g, V\n\n\n@decorator\ndef warn_slow(func, duration=0, *args, **kwargs):\n    t0 = time.time()\n    res = func(*args, **kwargs)\n    dt = time.time() - t0\n    if dt >= duration:\n        print('%s is slow' % func.__name__)\n    return res\n\n\n@warn_slow()  # with parens\ndef operation1():\n    \"\"\"\n    >>> operation1()\n    operation1 is slow\n    \"\"\"\n    time.sleep(.1)\n\n\n@warn_slow  # without parens\ndef operation2():\n    \"\"\"\n    >>> operation2()\n    operation2 is slow\n    \"\"\"\n    time.sleep(.1)\n\n\ndef chatty(func, *args, **kwargs):\n    print(args, sorted(kwargs.items()))\n    return func(*args, **kwargs)\n\n\n@decorator(chatty)\ndef printsum(x=1, y=2):\n    print(x + y)\n\n\n@decorator(chatty, kwsyntax=True)\ndef printsum2(x=1, y=2):\n    print(x + y)\n\n\ndef chattywrapper(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(args, kwargs)\n        return func(*args, **kwargs)\n    return functools.wraps(wrapper)\n\n# #######################  changing the signature ########################## #\n\n\n# see https://github.com/micheles/decorator/pull/85\ndef to_method(f):\n    \"\"\"\n    Takes a function with signature (..., context) and returns a new\n    function with signature (self, ...) to be used a a method in a\n    class with a .context attribute.\n    \"\"\"\n    sig = inspect.signature(f)\n    params = list(sig.parameters.values())\n    assert params[-1].name == 'context'\n    self = inspect.Parameter('self', inspect.Parameter.POSITIONAL_OR_KEYWORD)\n    params.insert(0, self)  # insert self\n    del params[-1]  # remove context\n    newsig = '%s%s' % (f.__name__, sig.replace(parameters=params))\n    return FunctionMaker.create(\n        newsig, 'context = self.context; return _func_%s' % sig,\n        dict(_func_=f))\n\n\ndef foo(x, context=None):\n    return x\n\n\ndef bar(x, y, context):\n    return x + y\n\n\nclass Client:\n    def __init__(self, context):\n        self.context = context\n\n\ndef test_change_sig():\n    \"\"\"\n    >>> Client.foo = to_method(foo)\n    >>> Client.bar = to_method(bar)\n    >>> c = Client(None)\n    >>> assert c.foo(1) == 1\n    >>> assert c.bar(1, 2) == 3\n    \"\"\"\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n", "src/tests/__init__.py": "", "src/tests/test.py": "import sys\nimport doctest\nimport unittest\nimport decimal\nimport inspect\nfrom asyncio import get_event_loop\nfrom collections import defaultdict, ChainMap, abc as c\nfrom decorator import dispatch_on, contextmanager, decorator\ntry:\n    from . import documentation as doc  # good with pytest\nexcept ImportError:\n    import documentation as doc  # good with `python src/tests/test.py`\n\n\n@contextmanager\ndef assertRaises(etype):\n    \"\"\"This works in Python 2.6 too\"\"\"\n    try:\n        yield\n    except etype:\n        pass\n    else:\n        raise Exception('Expected %s' % etype.__name__)\n\n\n@decorator\nasync def before_after(coro, *args, **kwargs):\n    return \"<before>\" + (await coro(*args, **kwargs)) + \"<after>\"\n\n\n@decorator\ndef coro_to_func(coro, *args, **kw):\n    return get_event_loop().run_until_complete(coro(*args, **kw))\n\n\nclass CoroutineTestCase(unittest.TestCase):\n    def test_before_after(self):\n        @before_after\n        async def coro(x):\n            return x\n        self.assertTrue(inspect.iscoroutinefunction(coro))\n        out = get_event_loop().run_until_complete(coro('x'))\n        self.assertEqual(out, '<before>x<after>')\n\n    def test_coro_to_func(self):\n        @coro_to_func\n        async def coro(x):\n            return x\n        self.assertFalse(inspect.iscoroutinefunction(coro))\n        self.assertEqual(coro('x'), 'x')\n\n\ndef gen123():\n    yield 1\n    yield 2\n    yield 3\n\n\nclass GeneratorCallerTestCase(unittest.TestCase):\n    def test_gen123(self):\n        @decorator\n        def square(func, *args, **kw):\n            for x in gen123():\n                yield x * x\n        new = square(gen123)\n        self.assertTrue(inspect.isgeneratorfunction(new))\n        self.assertEqual(list(new()), [1, 4, 9])\n\n\nclass DocumentationTestCase(unittest.TestCase):\n    def test(self):\n        err = doctest.testmod(doc)[0]\n        self.assertEqual(err, 0)\n\n    def test_copy_dunder_attrs(self):\n        traced = doc.trace(doc.foo)\n        self.assertIn('documentation', traced.__module__)\n        self.assertEqual(traced.__annotations__, {})\n        self.assertEqual(traced.__defaults__, (None,))\n\n    def test_singledispatch1(self):\n        with assertRaises(RuntimeError):\n            doc.singledispatch_example1()\n\n    def test_singledispatch2(self):\n        doc.singledispatch_example2()\n\n    def test_context_manager(self):\n\n        @contextmanager\n        def before_after(before, after):\n            print(before)\n            yield\n            print(after)\n\n        @before_after('BEFORE', 'AFTER')\n        def hello_user(user):\n            print('hello %s' % user)\n\n        argspec = inspect.getfullargspec(hello_user)\n        self.assertEqual(argspec.args, ['user'])\n\n\nclass ExtraTestCase(unittest.TestCase):\n    def test_qualname(self):\n        self.assertEqual(doc.operation1.__qualname__, 'operation1')\n\n    def test_signature(self):\n        sig = inspect.signature(doc.f1)\n        self.assertEqual(str(sig), '(x)')\n\n    def test_unique_filenames(self):\n        @decorator\n        def d1(f, *args, **kwargs):\n            return f(*args, **kwargs)\n\n        @decorator\n        def d2(f, *args, **kwargs):\n            return f(*args, **kwargs)\n\n        @d1\n        def f1(x, y, z):\n            pass\n\n        @d2\n        def f2(x, y, z):\n            pass\n\n        f1_orig = f1\n\n        @d1\n        def f1(x, y, z):\n            pass\n\n        self.assertEqual(d1.__code__.co_filename,\n                         d2.__code__.co_filename)\n        self.assertEqual(f1.__code__.co_filename,\n                         f2.__code__.co_filename)\n        self.assertEqual(f1_orig.__code__.co_filename,\n                         f1.__code__.co_filename)\n\n    def test_no_first_arg(self):\n        @decorator\n        def example(*args, **kw):\n            return args[0](*args[1:], **kw)\n\n        @example\n        def func(**kw):\n            \"Docstring\"\n            return kw\n\n        # there is no confusion when passing args as a keyword argument\n        self.assertEqual(func(args='a'), {'args': 'a'})\n        self.assertEqual(func.__doc__, \"Docstring\")\n\n    def test_decorator_factory(self):\n        # similar to what IPython is doing in traitlets.config.application\n        @decorator\n        def catch_config_error(method, app, *args, **kwargs):\n            return method(app)\n        catch_config_error(lambda app, **kw: None)(1)\n\n    def test_add1(self):\n        # similar to what IPython is doing in traitlets.config.application\n        @decorator\n        def add(func, const=1, *args, **kwargs):\n            return const + func(*args, **kwargs)\n\n        def f(x):\n            return x\n        self.assertEqual(add(f, 2)(0), 2)\n\n    def test_dan_schult(self):\n        # see https://github.com/micheles/decorator/issues/120\n        @decorator\n        def prnt(func, index=0, *args, **kw):\n            print(args[index])\n            return func(*args, **kw)\n\n        @prnt(index=2)  # print the value of the third argument\n        def f(a, b, c=None):\n            return [a, b, c]\n\n        self.assertEqual(f(0, 1), [0, 1, None])\n\n    def test_slow_wrapper(self):\n        # see https://github.com/micheles/decorator/issues/123\n        dd = defaultdict(list)\n        doc.trace(defaultdict.__setitem__)(dd, 'x', [1])\n        self.assertEqual(dd['x'], [1])\n        doc.trace(defaultdict.__delitem__)(dd, 'x')\n        self.assertEqual(dd['x'], [])\n        # NB: defaultdict.__getitem__ has no signature and cannot be\n        # decorated in CPython, while it is regular in PyPy\n\n\n# ################### test dispatch_on ############################# #\n# adapted from test_functools in Python 3.5\nsingledispatch = dispatch_on('obj')\n\n\nclass TestSingleDispatch(unittest.TestCase):\n    def test_simple_overloads(self):\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        @g.register(int)\n        def g_int(i):\n            return \"integer\"\n\n        self.assertEqual(g(\"str\"), \"base\")\n        self.assertEqual(g(1), \"integer\")\n        self.assertEqual(g([1, 2, 3]), \"base\")\n\n    def test_mro(self):\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        class A(object):\n            pass\n\n        class C(A):\n            pass\n\n        class B(A):\n            pass\n\n        class D(C, B):\n            pass\n\n        @g.register(A)\n        def g_A(a):\n            return \"A\"\n\n        @g.register(B)\n        def g_B(b):\n            return \"B\"\n\n        self.assertEqual(g(A()), \"A\")\n        self.assertEqual(g(B()), \"B\")\n        self.assertEqual(g(C()), \"A\")\n        self.assertEqual(g(D()), \"B\")\n\n    def test_register_decorator(self):\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        @g.register(int)\n        def g_int(i):\n            return \"int %s\" % (i,)\n        self.assertEqual(g(\"\"), \"base\")\n        self.assertEqual(g(12), \"int 12\")\n\n    def test_register_error(self):\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        with assertRaises(TypeError):\n            # wrong number of arguments\n            @g.register(int)\n            def g_int():\n                return \"int\"\n\n    def test_wrapping_attributes(self):\n        @singledispatch\n        def g(obj):\n            \"Simple test\"\n            return \"Test\"\n        self.assertEqual(g.__name__, \"g\")\n        if sys.flags.optimize < 2:\n            self.assertEqual(g.__doc__, \"Simple test\")\n\n    def test_c_classes(self):\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        @g.register(decimal.DecimalException)\n        def _(obj):\n            return obj.args\n        subn = decimal.Subnormal(\"Exponent < Emin\")\n        rnd = decimal.Rounded(\"Number got rounded\")\n        self.assertEqual(g(subn), (\"Exponent < Emin\",))\n        self.assertEqual(g(rnd), (\"Number got rounded\",))\n\n        @g.register(decimal.Subnormal)\n        def _g(obj):\n            return \"Too small to care.\"\n        self.assertEqual(g(subn), \"Too small to care.\")\n        self.assertEqual(g(rnd), (\"Number got rounded\",))\n\n    def test_register_abc(self):\n        d = {\"a\": \"b\"}\n        l = [1, 2, 3]\n        s = set([object(), None])\n        f = frozenset(s)\n        t = (1, 2, 3)\n\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        self.assertEqual(g(d), \"base\")\n        self.assertEqual(g(l), \"base\")\n        self.assertEqual(g(s), \"base\")\n        self.assertEqual(g(f), \"base\")\n        self.assertEqual(g(t), \"base\")\n\n        g.register(c.Sized)(lambda obj: \"sized\")\n        self.assertEqual(g(d), \"sized\")\n        self.assertEqual(g(l), \"sized\")\n        self.assertEqual(g(s), \"sized\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sized\")\n\n        g.register(c.MutableMapping)(lambda obj: \"mutablemapping\")\n        self.assertEqual(g(d), \"mutablemapping\")\n        self.assertEqual(g(l), \"sized\")\n        self.assertEqual(g(s), \"sized\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sized\")\n\n        g.register(ChainMap)(lambda obj: \"chainmap\")\n        # irrelevant ABCs registered\n        self.assertEqual(g(d), \"mutablemapping\")\n        self.assertEqual(g(l), \"sized\")\n        self.assertEqual(g(s), \"sized\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sized\")\n\n        g.register(c.MutableSequence)(lambda obj: \"mutablesequence\")\n        self.assertEqual(g(d), \"mutablemapping\")\n        self.assertEqual(g(l), \"mutablesequence\")\n        self.assertEqual(g(s), \"sized\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sized\")\n\n        g.register(c.MutableSet)(lambda obj: \"mutableset\")\n        self.assertEqual(g(d), \"mutablemapping\")\n        self.assertEqual(g(l), \"mutablesequence\")\n        self.assertEqual(g(s), \"mutableset\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sized\")\n\n        g.register(c.Mapping)(lambda obj: \"mapping\")\n        self.assertEqual(g(d), \"mutablemapping\")  # not specific enough\n        self.assertEqual(g(l), \"mutablesequence\")\n        self.assertEqual(g(s), \"mutableset\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sized\")\n\n        g.register(c.Sequence)(lambda obj: \"sequence\")\n        self.assertEqual(g(d), \"mutablemapping\")\n        self.assertEqual(g(l), \"mutablesequence\")\n        self.assertEqual(g(s), \"mutableset\")\n        self.assertEqual(g(f), \"sized\")\n        self.assertEqual(g(t), \"sequence\")\n\n        g.register(c.Set)(lambda obj: \"set\")\n        self.assertEqual(g(d), \"mutablemapping\")\n        self.assertEqual(g(l), \"mutablesequence\")\n        self.assertEqual(g(s), \"mutableset\")\n        self.assertEqual(g(f), \"set\")\n        self.assertEqual(g(t), \"sequence\")\n\n        g.register(dict)(lambda obj: \"dict\")\n        self.assertEqual(g(d), \"dict\")\n        self.assertEqual(g(l), \"mutablesequence\")\n        self.assertEqual(g(s), \"mutableset\")\n        self.assertEqual(g(f), \"set\")\n        self.assertEqual(g(t), \"sequence\")\n\n        g.register(list)(lambda obj: \"list\")\n        self.assertEqual(g(d), \"dict\")\n        self.assertEqual(g(l), \"list\")\n        self.assertEqual(g(s), \"mutableset\")\n        self.assertEqual(g(f), \"set\")\n        self.assertEqual(g(t), \"sequence\")\n\n        g.register(set)(lambda obj: \"concrete-set\")\n        self.assertEqual(g(d), \"dict\")\n        self.assertEqual(g(l), \"list\")\n        self.assertEqual(g(s), \"concrete-set\")\n        self.assertEqual(g(f), \"set\")\n        self.assertEqual(g(t), \"sequence\")\n\n        g.register(frozenset)(lambda obj: \"frozen-set\")\n        self.assertEqual(g(d), \"dict\")\n        self.assertEqual(g(l), \"list\")\n        self.assertEqual(g(s), \"concrete-set\")\n        self.assertEqual(g(f), \"frozen-set\")\n        self.assertEqual(g(t), \"sequence\")\n\n        g.register(tuple)(lambda obj: \"tuple\")\n        self.assertEqual(g(d), \"dict\")\n        self.assertEqual(g(l), \"list\")\n        self.assertEqual(g(s), \"concrete-set\")\n        self.assertEqual(g(f), \"frozen-set\")\n        self.assertEqual(g(t), \"tuple\")\n\n    def test_mro_conflicts(self):\n        @singledispatch\n        def g(obj):\n            return \"base\"\n\n        class O(c.Sized):\n            def __len__(self):\n                return 0\n        o = O()\n        self.assertEqual(g(o), \"base\")\n        g.register(c.Iterable)(lambda arg: \"iterable\")\n        g.register(c.Container)(lambda arg: \"container\")\n        g.register(c.Sized)(lambda arg: \"sized\")\n        g.register(c.Set)(lambda arg: \"set\")\n        self.assertEqual(g(o), \"sized\")\n        c.Iterable.register(O)\n        self.assertEqual(g(o), \"sized\")\n        c.Container.register(O)\n        with assertRaises(RuntimeError):  # was \"sized\" because in mro\n            self.assertEqual(g(o), \"sized\")\n        c.Set.register(O)\n        self.assertEqual(g(o), \"set\")\n\n        class P(object):\n            pass\n        p = P()\n        self.assertEqual(g(p), \"base\")\n        c.Iterable.register(P)\n        self.assertEqual(g(p), \"iterable\")\n        c.Container.register(P)\n\n        with assertRaises(RuntimeError):\n            self.assertEqual(g(p), \"iterable\")\n\n        class Q(c.Sized):\n            def __len__(self):\n                return 0\n        q = Q()\n        self.assertEqual(g(q), \"sized\")\n        c.Iterable.register(Q)\n        self.assertEqual(g(q), \"sized\")\n        c.Set.register(Q)\n        self.assertEqual(g(q), \"set\")\n        # because c.Set is a subclass of c.Sized and c.Iterable\n\n        @singledispatch\n        def h(obj):\n            return \"base\"\n\n        @h.register(c.Sized)\n        def h_sized(arg):\n            return \"sized\"\n\n        @h.register(c.Container)\n        def h_container(arg):\n            return \"container\"\n        # Even though Sized and Container are explicit bases of MutableMapping,\n        # this ABC is implicitly registered on defaultdict which makes all of\n        # MutableMapping's bases implicit as well from defaultdict's\n        # perspective.\n        with assertRaises(RuntimeError):\n            self.assertEqual(h(defaultdict(lambda: 0)), \"sized\")\n\n        class R(defaultdict):\n            pass\n        c.MutableSequence.register(R)\n\n        @singledispatch\n        def i(obj):\n            return \"base\"\n\n        @i.register(c.MutableMapping)\n        def i_mapping(arg):\n            return \"mapping\"\n\n        @i.register(c.MutableSequence)\n        def i_sequence(arg):\n            return \"sequence\"\n        r = R()\n        with assertRaises(RuntimeError):  # was no error\n            self.assertEqual(i(r), \"sequence\")\n\n        class S(object):\n            pass\n\n        class T(S, c.Sized):\n            def __len__(self):\n                return 0\n        t = T()\n        self.assertEqual(h(t), \"sized\")\n        c.Container.register(T)\n        self.assertEqual(h(t), \"sized\")   # because it's explicitly in the MRO\n\n        class U(object):\n            def __len__(self):\n                return 0\n        u = U()\n        self.assertEqual(h(u), \"sized\")\n        # implicit Sized subclass inferred\n        # from the existence of __len__()\n\n        c.Container.register(U)\n        # There is no preference for registered versus inferred ABCs.\n        with assertRaises(RuntimeError):\n            h(u)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}