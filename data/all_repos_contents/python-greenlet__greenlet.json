{"setup.py": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nimport sys\nimport os\nimport glob\nimport platform\n\n# distutils is deprecated and vendored into setuptools now.\nfrom setuptools import setup\nfrom setuptools import Extension\nfrom setuptools import find_packages\n\n# Extra compiler arguments passed to *all* extensions.\nglobal_compile_args = []\n\n# Extra compiler arguments passed to C++ extensions\ncpp_compile_args = []\n\n# Extra linker arguments passed to C++ extensions\ncpp_link_args = []\n\n# Extra compiler arguments passed to the main extension\nmain_compile_args = []\n\nis_win = sys.platform.startswith(\"win\")\n\n# workaround segfaults on openbsd and RHEL 3 / CentOS 3 . see\n# https://bitbucket.org/ambroff/greenlet/issue/11/segfault-on-openbsd-i386\n# https://github.com/python-greenlet/greenlet/issues/4\n# https://github.com/python-greenlet/greenlet/issues/94\n# pylint:disable=too-many-boolean-expressions\nis_linux = sys.platform.startswith('linux') # could be linux or linux2\nplat_platform = platform.platform()\nplat_machine = platform.machine()\nplat_compiler = platform.python_compiler()\ntry:\n    # (sysname, nodename, release, version, machine)\n    unam_machine = os.uname()[-1]\nexcept AttributeError:\n    unam_machine = ''\nif (\n       (sys.platform == \"openbsd4\" and unam_machine == \"i386\")\n    or (\"-with-redhat-3.\" in plat_platform and plat_machine == 'i686')\n    or (sys.platform == \"sunos5\" and unam_machine == \"sun4v\") # SysV-based Solaris\n    or (\"SunOS\" in plat_platform and plat_machine == \"sun4v\") # Old BSD-based SunOS\n    or (is_linux and plat_machine == \"ppc\")\n    # https://github.com/python-greenlet/greenlet/pull/300: When compiling for RISC-V the command\n    # ``riscv64-linux-gnu-gcc -pthread -fno-strict-aliasing -Wdate-time \\\n    #   -D_FORTIFY_SOURCE=2 -g -ffile-prefix-map=/build/python2.7-7GU7VT/python2.7-2.7.18=. \\\n    #   -fstack-protector-strong -Wformat -Werror=format-security -fPIC \\\n    #   -I/usr/include/python2.7\n    #   -c src/greenlet/greenlet.cpp  -o build/temp.linux-riscv64-2.7/src/greenlet/greenlet.o``\n    #\n    # fails with:\n    #\n    # src/greenlet/platform/switch_riscv_unix.h:30:1: error: s0 cannot be used in 'asm' here\n    #\n    # Adding the -Os flag fixes the problem.\n    or (is_linux and plat_machine == \"riscv64\")\n):\n    global_compile_args.append(\"-Os\")\n\n\nif sys.platform == 'darwin' or 'clang' in plat_compiler:\n    # The clang compiler doesn't use --std=c++11 by default\n    cpp_compile_args.append(\"--std=gnu++11\")\nelif is_win and \"MSC\" in plat_compiler:\n    # Older versions of MSVC (Python 2.7) don't handle C++ exceptions\n    # correctly by default. While newer versions do handle exceptions\n    # by default, they don't do it fully correctly (\"By default....the\n    # compiler generates code that only partially supports C++\n    # exceptions.\"). So we need an argument on all versions.\n\n    #\"/EH\" == exception handling.\n    #    \"s\" == standard C++,\n    #    \"c\" == extern C functions don't throw\n    # OR\n    #   \"a\" == standard C++, and Windows SEH; anything may throw, compiler optimizations\n    #          around try blocks are less aggressive. Because this catches SEH,\n    #          which Windows uses internally, the MS docs say this can be a security issue.\n    #          DO NOT USE.\n    # /EHsc is suggested, and /EHa isn't supposed to be linked to other things not built\n    # with it. Leaving off the \"c\" should just result in slower, safer code.\n    # Other options:\n    #    \"r\" == Always generate standard confirming checks for noexcept blocks, terminating\n    #           if violated. IMPORTANT: We rely on this.\n    # See https://docs.microsoft.com/en-us/cpp/build/reference/eh-exception-handling-model?view=msvc-170\n    handler = \"/EHsr\"\n    cpp_compile_args.append(handler)\n    # To disable most optimizations:\n    #cpp_compile_args.append('/Od')\n\n    # To enable assertions:\n    #cpp_compile_args.append('/UNDEBUG')\n\n    # To enable more compile-time warnings (/Wall produces a mountain of output).\n    #cpp_compile_args.append('/W4')\n\n    # To link with the debug C runtime...except we can't because we need\n    # the Python debug lib too, and they're not around by default\n    # cpp_compile_args.append('/MDd')\n\n    # Support fiber-safe thread-local storage: \"the compiler mustn't\n    # cache the address of the TLS array, or optimize it as a common\n    # subexpression across a function call.\" This would probably solve\n    # some of the issues we had with MSVC caching the thread local\n    # variables on the stack, leading to having to split some\n    # functions up. Revisit those.\n    cpp_compile_args.append(\"/GT\")\n\ndef readfile(filename):\n    with open(filename, 'r') as f: # pylint:disable=unspecified-encoding\n        return f.read()\n\nGREENLET_SRC_DIR = 'src/greenlet/'\nGREENLET_HEADER_DIR = GREENLET_SRC_DIR\nGREENLET_HEADER = GREENLET_HEADER_DIR + 'greenlet.h'\nGREENLET_TEST_DIR = 'src/greenlet/tests/'\n# The location of the platform specific assembly files\n# for switching.\nGREENLET_PLATFORM_DIR = GREENLET_SRC_DIR + 'platform/'\n\ndef _find_platform_headers():\n    return glob.glob(GREENLET_PLATFORM_DIR + \"switch_*.h\")\n\ndef _find_impl_headers():\n    return glob.glob(GREENLET_SRC_DIR + \"*.hpp\") + glob.glob(GREENLET_SRC_DIR + \"*.cpp\")\n\nif hasattr(sys, \"pypy_version_info\"):\n    ext_modules = []\n    headers = []\nelse:\n\n    headers = [GREENLET_HEADER]\n\n    if is_win and '64 bit' in sys.version:\n        # this works when building with msvc, not with 64 bit gcc\n        # switch_<platform>_masm.obj can be created with setup_switch_<platform>_masm.cmd\n        obj_fn = 'switch_arm64_masm.obj' if plat_machine == 'ARM64' else 'switch_x64_masm.obj'\n        extra_objects = [os.path.join(GREENLET_PLATFORM_DIR, obj_fn)]\n    else:\n        extra_objects = []\n\n    if is_win and os.environ.get('GREENLET_STATIC_RUNTIME') in ('1', 'yes'):\n        main_compile_args.append('/MT')\n    elif unam_machine in ('ppc64el', 'ppc64le'):\n        main_compile_args.append('-fno-tree-dominator-opts')\n\n    ext_modules = [\n        Extension(\n            name='greenlet._greenlet',\n            sources=[\n                GREENLET_SRC_DIR + 'greenlet.cpp',\n            ],\n            language='c++',\n            extra_objects=extra_objects,\n            extra_compile_args=global_compile_args + main_compile_args + cpp_compile_args,\n            extra_link_args=cpp_link_args,\n            depends=[\n                GREENLET_HEADER,\n                GREENLET_SRC_DIR + 'slp_platformselect.h',\n            ] + _find_platform_headers() + _find_impl_headers(),\n            define_macros=[\n            ] + ([\n                ('WIN32', '1'),\n            ] if is_win else [\n            ])\n        ),\n        # Test extensions.\n        #\n        # We used to try hard to not include these in built\n        # distributions, because we only distributed ``greenlet.so``.\n        # That's really not important, now we have a clean layout with\n        # the test directory nested inside a greenlet directory. See\n        # https://github.com/python-greenlet/greenlet/issues/184 and\n        # 189\n        Extension(\n            name='greenlet.tests._test_extension',\n            sources=[GREENLET_TEST_DIR + '_test_extension.c'],\n            include_dirs=[GREENLET_HEADER_DIR],\n            extra_compile_args=global_compile_args,\n        ),\n        Extension(\n            name='greenlet.tests._test_extension_cpp',\n            sources=[GREENLET_TEST_DIR + '_test_extension_cpp.cpp'],\n            language=\"c++\",\n            include_dirs=[GREENLET_HEADER_DIR],\n            extra_compile_args=global_compile_args + cpp_compile_args,\n            extra_link_args=cpp_link_args,\n        ),\n    ]\n\n\ndef get_greenlet_version():\n    with open('src/greenlet/__init__.py') as f: # pylint:disable=unspecified-encoding\n        looking_for = '__version__ = \\''\n        for line in f:\n            if line.startswith(looking_for):\n                version = line[len(looking_for):-2]\n                return version\n    raise ValueError(\"Unable to find version\")\n\n\nsetup(\n    name=\"greenlet\",\n    version=get_greenlet_version(),\n    description='Lightweight in-process concurrent programming',\n    long_description=readfile(\"README.rst\"),\n    long_description_content_type=\"text/x-rst\",\n    url=\"https://greenlet.readthedocs.io/\",\n    keywords=\"greenlet coroutine concurrency threads cooperative\",\n    author=\"Alexey Borzenkov\",\n    author_email=\"snaury@gmail.com\",\n    maintainer='Jason Madden',\n    maintainer_email='jason@seecoresoftware.com',\n    project_urls={\n        'Bug Tracker': 'https://github.com/python-greenlet/greenlet/issues',\n        'Source Code': 'https://github.com/python-greenlet/greenlet/',\n        'Documentation': 'https://greenlet.readthedocs.io/',\n    },\n    license=\"MIT License\",\n    platforms=['any'],\n    package_dir={'': 'src'},\n    packages=find_packages('src'),\n    include_package_data=True,\n    headers=headers,\n    ext_modules=ext_modules,\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Natural Language :: English',\n        'Programming Language :: C',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Operating System :: OS Independent',\n        'Topic :: Software Development :: Libraries :: Python Modules'\n    ],\n    extras_require={\n        'docs': [\n            'Sphinx',\n            'furo',\n        ],\n        'test': [\n            'objgraph',\n            'psutil',\n        ],\n    },\n    python_requires=\">=3.7\",\n    zip_safe=False,\n)\n", "docs/conf.py": "# -*- coding: utf-8 -*-\n#\n# greenlet documentation build configuration file, created by\n# sphinx-quickstart on Tue Dec 27 22:58:53 2011.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath('.'))\nsys.path.append(os.path.abspath('../src/'))\ntry:\n    from importlib import metadata\nexcept ImportError:\n    # Building the docs on 3.7. Which we don't do,\n    # except for running doctests.\n    glet_version = '0.0.0'\nelse:\n    glet_version = metadata.version('greenlet')\n\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.doctest',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.todo',\n    'sphinx.ext.extlinks',\n    'sphinx.ext.ifconfig',\n    'sphinx.ext.viewcode',\n ]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = []  # ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'greenlet'\ncopyright = u'2011, Armin Rigo, Christian Tismer'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = glet_version\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\ndefault_role = \"obj\"\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n\nhtml_theme = \"furo\"\nhtml_css_files = [\n    'custom.css',\n]\n\nhtml_theme_options = {\n    \"sidebar_hide_name\": True, # Because we show a logo\n\n    'light_css_variables': {\n        \"color-brand-primary\": \"#7c9a5e\",\n        \"color-brand-content\": \"#7c9a5e\",\n        \"color-foreground-border\": \"#b7d897\",\n        'font-stack': '\"SF Pro\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        'font-stack--monospace': '\"JetBrainsMono\", \"JetBrains Mono\", \"JetBrains Mono Regular\", \"JetBrainsMono-Regular\", ui-monospace, profont, monospace',\n    },\n}\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'greenletdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('index', 'greenlet.tex', u'greenlet Documentation',\n   u'Armin Rigo, Christian Tismer', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'greenlet', u'greenlet Documentation',\n     [u'Armin Rigo, Christian Tismer'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'greenlet', u'greenlet Documentation',\n   u'Armin Rigo, Christian Tismer', 'greenlet', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\nintersphinx_mapping = {\n    'python': ('https://docs.python.org/', None),\n    'gevent': ('https://www.gevent.org/', None),\n\n}\n\n\n# Sphinx 1.8+ prefers this to `autodoc_default_flags`. It's documented that\n# either True or None mean the same thing as just setting the flag, but\n# only None works in 1.8 (True works in 2.0)\nautodoc_default_options = {\n    # Our only type with members is ``greenlet``, and it\n    # currently contains malformed ReST\n    #'members': None,\n    'show-inheritance': None,\n}\nautodoc_member_order = 'groupwise'\nautoclass_content = 'both'\n\nextlinks = {\n    'issue': ('https://github.com/python-greenlet/greenlet/issues/%s',\n              'issue #%s'),\n    'pr': ('https://github.com/python-greenlet/greenlet/pull/%s',\n           'pull request #%s')\n}\n", "benchmarks/chain.py": "#!/usr/bin/env python\n\"\"\"\nCreate a chain of coroutines and pass a value from one end to the\nother, where each coroutine will increment the value before passing it\nalong.\n\"\"\"\n\nimport os\nimport pyperf\nimport greenlet\n\n# This is obsolete now, we always expose frames for Python 3.12.\n# See https://github.com/python-greenlet/greenlet/pull/393/\n# for a complete discussion of performance.\nEXPOSE_FRAMES = 'EXPOSE_FRAMES' in os.environ\n\n# Exposing\n# 100 frames Mean +- std dev: 5.62 us +- 0.10 us\n# 200 frames Mean +- std dev: 14.0 us +- 0.6 us\n# 300 frames Mean +- std dev: 22.7 us +- 0.4 us\n#\n# Non-exposing\n# 100 frames Mean +- std dev: 3.64 us +- 0.06 us -> 1.54/1.98us\n# 200 frames Mean +- std dev: 9.49 us +- 0.13 us -> 1.47/4.51us\n# 300 frames Mean +- std dev: 15.7 us +- 0.3 us  -> 1.45/7us\n\ndef link(next_greenlet):\n    value = greenlet.getcurrent().parent.switch()\n    next_greenlet.switch(value + 1)\n\n\nCHAIN_GREENLET_COUNT = 100000\n\ndef bm_chain(loops):\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n        start_node = greenlet.getcurrent()\n        for _ in range(CHAIN_GREENLET_COUNT):\n            g = greenlet.greenlet(link)\n            g.gr_frames_always_exposed = EXPOSE_FRAMES\n            g.switch(start_node)\n            start_node = g\n        x = start_node.switch(0)\n        assert x == CHAIN_GREENLET_COUNT\n    end = pyperf.perf_counter()\n    return end - begin\n\nGETCURRENT_INNER_LOOPS = 10\ndef bm_getcurrent(loops):\n    getcurrent = greenlet.getcurrent\n    getcurrent() # Factor out the overhead of creating the initial main greenlet\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n        # Manual unroll\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n    end = pyperf.perf_counter()\n    return end - begin\n\nSWITCH_INNER_LOOPS = 10000\ndef bm_switch_shallow(loops):\n    # pylint:disable=attribute-defined-outside-init\n    class G(greenlet.greenlet):\n        other = None\n        def run(self):\n            o = self.other\n            for _ in range(SWITCH_INNER_LOOPS):\n                o.switch()\n\n    begin = pyperf.perf_counter()\n\n    for _ in range(loops):\n        gl1 = G()\n        gl2 = G()\n        gl1.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl2.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl1.other = gl2\n        gl2.other = gl1\n        gl1.switch()\n\n        gl1.switch()\n        gl2.switch()\n        gl1.other = gl2.other = None\n        assert gl1.dead\n        assert gl2.dead\n\n    end = pyperf.perf_counter()\n    return end - begin\n\ndef bm_switch_deep(loops, _MAX_DEPTH=200):\n    # pylint:disable=attribute-defined-outside-init\n    class G(greenlet.greenlet):\n        other = None\n        def run(self):\n            for _ in range(SWITCH_INNER_LOOPS):\n                self.recur_then_switch()\n\n        def recur_then_switch(self, depth=_MAX_DEPTH):\n            if not depth:\n                self.other.switch()\n            else:\n                self.recur_then_switch(depth - 1)\n\n    begin = pyperf.perf_counter()\n\n    for _ in range(loops):\n        gl1 = G()\n        gl2 = G()\n        gl1.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl2.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl1.other = gl2\n        gl2.other = gl1\n        gl1.switch()\n\n        gl1.switch()\n        gl2.switch()\n        gl1.other = gl2.other = None\n        assert gl1.dead\n        assert gl2.dead\n\n    end = pyperf.perf_counter()\n    return end - begin\n\ndef bm_switch_deeper(loops):\n    return bm_switch_deep(loops, 400)\n\n\nCREATE_INNER_LOOPS = 10\ndef bm_create(loops):\n    gl = greenlet.greenlet\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n    end = pyperf.perf_counter()\n    return end - begin\n\n\n\n\ndef _bm_recur_frame(loops, RECUR_DEPTH):\n\n    def recur(depth):\n        if not depth:\n            return greenlet.getcurrent().parent.switch(greenlet.getcurrent())\n        return recur(depth - 1)\n\n\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n\n        for _ in range(CHAIN_GREENLET_COUNT):\n            g = greenlet.greenlet(recur)\n            g.gr_frames_always_exposed = EXPOSE_FRAMES\n            g2 = g.switch(RECUR_DEPTH)\n            assert g2 is g, (g2, g)\n            f = g2.gr_frame\n            assert f is not None, \"frame is none\"\n            count = 0\n            while f:\n                count += 1\n                f = f.f_back\n            # This assertion fails with the released versions of greenlet\n            # on Python 3.12\n            #assert count == RECUR_DEPTH + 1, (count, RECUR_DEPTH)\n            # Switch back so it can be collected; otherwise they build\n            # up forever.\n            g.switch()\n            # fall off the end of it and back to us.\n            del g\n            del g2\n            del f\n\n\n    end = pyperf.perf_counter()\n    return end - begin\n\ndef bm_recur_frame_2(loops):\n    return _bm_recur_frame(loops, 2)\n\ndef bm_recur_frame_20(loops):\n    return _bm_recur_frame(loops, 20)\n\ndef bm_recur_frame_200(loops):\n    return _bm_recur_frame(loops, 200)\n\nif __name__ == '__main__':\n    runner = pyperf.Runner()\n\n    runner.bench_time_func(\n        'create a greenlet',\n        bm_create,\n        inner_loops=CREATE_INNER_LOOPS\n    )\n\n    runner.bench_time_func(\n        'switch between two greenlets (shallow)',\n        bm_switch_shallow,\n        inner_loops=SWITCH_INNER_LOOPS\n    )\n\n    runner.bench_time_func(\n        'switch between two greenlets (deep)',\n        bm_switch_deep,\n        inner_loops=SWITCH_INNER_LOOPS\n    )\n\n    runner.bench_time_func(\n        'switch between two greenlets (deeper)',\n        bm_switch_deeper,\n        inner_loops=SWITCH_INNER_LOOPS\n    )\n    runner.bench_time_func(\n        'getcurrent single thread',\n        bm_getcurrent,\n        inner_loops=GETCURRENT_INNER_LOOPS\n    )\n    runner.bench_time_func(\n        'chain(%s)' % CHAIN_GREENLET_COUNT,\n        bm_chain,\n    )\n\n    runner.bench_time_func(\n        'read 2 nested frames',\n        bm_recur_frame_2,\n    )\n\n    runner.bench_time_func(\n        'read 20 nested frames',\n        bm_recur_frame_20,\n    )\n    runner.bench_time_func(\n        'read 200 nested frames',\n        bm_recur_frame_200,\n    )\n", "src/greenlet/__init__.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThe root of the greenlet package.\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n__all__ = [\n    '__version__',\n    '_C_API',\n\n    'GreenletExit',\n    'error',\n\n    'getcurrent',\n    'greenlet',\n\n    'gettrace',\n    'settrace',\n]\n\n# pylint:disable=no-name-in-module\n\n###\n# Metadata\n###\n__version__ = '3.0.4.dev0'\nfrom ._greenlet import _C_API # pylint:disable=no-name-in-module\n\n###\n# Exceptions\n###\nfrom ._greenlet import GreenletExit\nfrom ._greenlet import error\n\n###\n# greenlets\n###\nfrom ._greenlet import getcurrent\nfrom ._greenlet import greenlet\n\n###\n# tracing\n###\ntry:\n    from ._greenlet import gettrace\n    from ._greenlet import settrace\nexcept ImportError:\n    # Tracing wasn't supported.\n    # XXX: The option to disable it was removed in 1.0,\n    # so this branch should be dead code.\n    pass\n\n###\n# Constants\n# These constants aren't documented and aren't recommended.\n# In 1.0, USE_GC and USE_TRACING are always true, and USE_CONTEXT_VARS\n# is the same as ``sys.version_info[:2] >= 3.7``\n###\nfrom ._greenlet import GREENLET_USE_CONTEXT_VARS # pylint:disable=unused-import\nfrom ._greenlet import GREENLET_USE_GC # pylint:disable=unused-import\nfrom ._greenlet import GREENLET_USE_TRACING # pylint:disable=unused-import\n\n# Controlling the use of the gc module. Provisional API for this greenlet\n# implementation in 2.0.\nfrom ._greenlet import CLOCKS_PER_SEC # pylint:disable=unused-import\nfrom ._greenlet import enable_optional_cleanup # pylint:disable=unused-import\nfrom ._greenlet import get_clocks_used_doing_optional_cleanup # pylint:disable=unused-import\n\n# Other APIS in the _greenlet module are for test support.\n", "src/greenlet/platform/__init__.py": "", "src/greenlet/tests/test_stack_saved.py": "import greenlet\nfrom . import TestCase\n\n\nclass Test(TestCase):\n\n    def test_stack_saved(self):\n        main = greenlet.getcurrent()\n        self.assertEqual(main._stack_saved, 0)\n\n        def func():\n            main.switch(main._stack_saved)\n\n        g = greenlet.greenlet(func)\n        x = g.switch()\n        self.assertGreater(x, 0)\n        self.assertGreater(g._stack_saved, 0)\n        g.switch()\n        self.assertEqual(g._stack_saved, 0)\n", "src/greenlet/tests/test_tracing.py": "from __future__ import print_function\nimport sys\nimport greenlet\nimport unittest\n\nfrom . import TestCase\nfrom . import PY312\n\n# https://discuss.python.org/t/cpython-3-12-greenlet-and-tracing-profiling-how-to-not-crash-and-get-correct-results/33144/2\nDEBUG_BUILD_PY312 = (\n    PY312 and hasattr(sys, 'gettotalrefcount'),\n    \"Broken on debug builds of Python 3.12\"\n)\n\nclass SomeError(Exception):\n    pass\n\nclass GreenletTracer(object):\n    oldtrace = None\n\n    def __init__(self, error_on_trace=False):\n        self.actions = []\n        self.error_on_trace = error_on_trace\n\n    def __call__(self, *args):\n        self.actions.append(args)\n        if self.error_on_trace:\n            raise SomeError\n\n    def __enter__(self):\n        self.oldtrace = greenlet.settrace(self)\n        return self.actions\n\n    def __exit__(self, *args):\n        greenlet.settrace(self.oldtrace)\n\n\nclass TestGreenletTracing(TestCase):\n    \"\"\"\n    Tests of ``greenlet.settrace()``\n    \"\"\"\n\n    def test_a_greenlet_tracing(self):\n        main = greenlet.getcurrent()\n        def dummy():\n            pass\n        def dummyexc():\n            raise SomeError()\n\n        with GreenletTracer() as actions:\n            g1 = greenlet.greenlet(dummy)\n            g1.switch()\n            g2 = greenlet.greenlet(dummyexc)\n            self.assertRaises(SomeError, g2.switch)\n\n        self.assertEqual(actions, [\n            ('switch', (main, g1)),\n            ('switch', (g1, main)),\n            ('switch', (main, g2)),\n            ('throw', (g2, main)),\n        ])\n\n    def test_b_exception_disables_tracing(self):\n        main = greenlet.getcurrent()\n        def dummy():\n            main.switch()\n        g = greenlet.greenlet(dummy)\n        g.switch()\n        with GreenletTracer(error_on_trace=True) as actions:\n            self.assertRaises(SomeError, g.switch)\n            self.assertEqual(greenlet.gettrace(), None)\n\n        self.assertEqual(actions, [\n            ('switch', (main, g)),\n        ])\n\n    def test_set_same_tracer_twice(self):\n        # https://github.com/python-greenlet/greenlet/issues/332\n        # Our logic in asserting that the tracefunction should\n        # gain a reference was incorrect if the same tracefunction was set\n        # twice.\n        tracer = GreenletTracer()\n        with tracer:\n            greenlet.settrace(tracer)\n\n\nclass PythonTracer(object):\n    oldtrace = None\n\n    def __init__(self):\n        self.actions = []\n\n    def __call__(self, frame, event, arg):\n        # Record the co_name so we have an idea what function we're in.\n        self.actions.append((event, frame.f_code.co_name))\n\n    def __enter__(self):\n        self.oldtrace = sys.setprofile(self)\n        return self.actions\n\n    def __exit__(self, *args):\n        sys.setprofile(self.oldtrace)\n\ndef tpt_callback():\n    return 42\n\nclass TestPythonTracing(TestCase):\n    \"\"\"\n    Tests of the interaction of ``sys.settrace()``\n    with greenlet facilities.\n\n    NOTE: Most of this is probably CPython specific.\n    \"\"\"\n\n    maxDiff = None\n\n    def test_trace_events_trivial(self):\n        with PythonTracer() as actions:\n            tpt_callback()\n        # If we use the sys.settrace instead of setprofile, we get\n        # this:\n\n        # self.assertEqual(actions, [\n        #     ('call', 'tpt_callback'),\n        #     ('call', '__exit__'),\n        # ])\n\n        self.assertEqual(actions, [\n            ('return', '__enter__'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('call', '__exit__'),\n            ('c_call', '__exit__'),\n        ])\n\n    def _trace_switch(self, glet):\n        with PythonTracer() as actions:\n            glet.switch()\n        return actions\n\n    def _check_trace_events_func_already_set(self, glet):\n        actions = self._trace_switch(glet)\n        self.assertEqual(actions, [\n            ('return', '__enter__'),\n            ('c_call', '_trace_switch'),\n            ('call', 'run'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('return', 'run'),\n            ('c_return', '_trace_switch'),\n            ('call', '__exit__'),\n            ('c_call', '__exit__'),\n        ])\n\n    def test_trace_events_into_greenlet_func_already_set(self):\n        def run():\n            return tpt_callback()\n\n        self._check_trace_events_func_already_set(greenlet.greenlet(run))\n\n    def test_trace_events_into_greenlet_subclass_already_set(self):\n        class X(greenlet.greenlet):\n            def run(self):\n                return tpt_callback()\n        self._check_trace_events_func_already_set(X())\n\n    def _check_trace_events_from_greenlet_sets_profiler(self, g, tracer):\n        g.switch()\n        tpt_callback()\n        tracer.__exit__()\n        self.assertEqual(tracer.actions, [\n            ('return', '__enter__'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('return', 'run'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('call', '__exit__'),\n            ('c_call', '__exit__'),\n        ])\n\n\n    def test_trace_events_from_greenlet_func_sets_profiler(self):\n        tracer = PythonTracer()\n        def run():\n            tracer.__enter__()\n            return tpt_callback()\n\n        self._check_trace_events_from_greenlet_sets_profiler(greenlet.greenlet(run),\n                                                             tracer)\n\n    def test_trace_events_from_greenlet_subclass_sets_profiler(self):\n        tracer = PythonTracer()\n        class X(greenlet.greenlet):\n            def run(self):\n                tracer.__enter__()\n                return tpt_callback()\n\n        self._check_trace_events_from_greenlet_sets_profiler(X(), tracer)\n\n    @unittest.skipIf(*DEBUG_BUILD_PY312)\n    def test_trace_events_multiple_greenlets_switching(self):\n        tracer = PythonTracer()\n\n        g1 = None\n        g2 = None\n\n        def g1_run():\n            tracer.__enter__()\n            tpt_callback()\n            g2.switch()\n            tpt_callback()\n            return 42\n\n        def g2_run():\n            tpt_callback()\n            tracer.__exit__()\n            tpt_callback()\n            g1.switch()\n\n        g1 = greenlet.greenlet(g1_run)\n        g2 = greenlet.greenlet(g2_run)\n\n        x = g1.switch()\n        self.assertEqual(x, 42)\n        tpt_callback() # ensure not in the trace\n        self.assertEqual(tracer.actions, [\n            ('return', '__enter__'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('c_call', 'g1_run'),\n            ('call', 'g2_run'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('call', '__exit__'),\n            ('c_call', '__exit__'),\n        ])\n\n    @unittest.skipIf(*DEBUG_BUILD_PY312)\n    def test_trace_events_multiple_greenlets_switching_siblings(self):\n        # Like the first version, but get both greenlets running first\n        # as \"siblings\" and then establish the tracing.\n        tracer = PythonTracer()\n\n        g1 = None\n        g2 = None\n\n        def g1_run():\n            greenlet.getcurrent().parent.switch()\n            tracer.__enter__()\n            tpt_callback()\n            g2.switch()\n            tpt_callback()\n            return 42\n\n        def g2_run():\n            greenlet.getcurrent().parent.switch()\n\n            tpt_callback()\n            tracer.__exit__()\n            tpt_callback()\n            g1.switch()\n\n        g1 = greenlet.greenlet(g1_run)\n        g2 = greenlet.greenlet(g2_run)\n\n        # Start g1\n        g1.switch()\n        # And it immediately returns control to us.\n        # Start g2\n        g2.switch()\n        # Which also returns. Now kick of the real part of the\n        # test.\n        x = g1.switch()\n        self.assertEqual(x, 42)\n\n        tpt_callback() # ensure not in the trace\n        self.assertEqual(tracer.actions, [\n            ('return', '__enter__'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('c_call', 'g1_run'),\n            ('call', 'tpt_callback'),\n            ('return', 'tpt_callback'),\n            ('call', '__exit__'),\n            ('c_call', '__exit__'),\n        ])\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/greenlet/tests/fail_switch_two_greenlets.py": "\"\"\"\nUses a trace function to switch greenlets at unexpected times.\n\nIn the trace function, we switch from the current greenlet to another\ngreenlet, which switches\n\"\"\"\nimport greenlet\n\ng1 = None\ng2 = None\n\nswitch_to_g2 = False\n\ndef tracefunc(*args):\n    print('TRACE', *args)\n    global switch_to_g2\n    if switch_to_g2:\n        switch_to_g2 = False\n        g2.switch()\n    print('\\tLEAVE TRACE', *args)\n\ndef g1_run():\n    print('In g1_run')\n    global switch_to_g2\n    switch_to_g2 = True\n    greenlet.getcurrent().parent.switch()\n    print('Return to g1_run')\n    print('Falling off end of g1_run')\n\ndef g2_run():\n    g1.switch()\n    print('Falling off end of g2')\n\ngreenlet.settrace(tracefunc)\n\ng1 = greenlet.greenlet(g1_run)\ng2 = greenlet.greenlet(g2_run)\n\ng1.switch()\nprint('Falling off end of main')\ng2.switch()\n", "src/greenlet/tests/test_weakref.py": "import gc\nimport weakref\n\n\nimport greenlet\nfrom . import TestCase\n\nclass WeakRefTests(TestCase):\n    def test_dead_weakref(self):\n        def _dead_greenlet():\n            g = greenlet.greenlet(lambda: None)\n            g.switch()\n            return g\n        o = weakref.ref(_dead_greenlet())\n        gc.collect()\n        self.assertEqual(o(), None)\n\n    def test_inactive_weakref(self):\n        o = weakref.ref(greenlet.greenlet())\n        gc.collect()\n        self.assertEqual(o(), None)\n\n    def test_dealloc_weakref(self):\n        seen = []\n        def worker():\n            try:\n                greenlet.getcurrent().parent.switch()\n            finally:\n                seen.append(g())\n        g = greenlet.greenlet(worker)\n        g.switch()\n        g2 = greenlet.greenlet(lambda: None, g)\n        g = weakref.ref(g2)\n        g2 = None\n        self.assertEqual(seen, [None])\n", "src/greenlet/tests/fail_switch_three_greenlets.py": "\"\"\"\nUses a trace function to switch greenlets at unexpected times.\n\nIn the trace function, we switch from the current greenlet to another\ngreenlet, which switches\n\"\"\"\nimport greenlet\n\ng1 = None\ng2 = None\n\nswitch_to_g2 = False\n\ndef tracefunc(*args):\n    print('TRACE', *args)\n    global switch_to_g2\n    if switch_to_g2:\n        switch_to_g2 = False\n        g2.switch()\n    print('\\tLEAVE TRACE', *args)\n\ndef g1_run():\n    print('In g1_run')\n    global switch_to_g2\n    switch_to_g2 = True\n    from_parent = greenlet.getcurrent().parent.switch()\n    print('Return to g1_run')\n    print('From parent', from_parent)\n\ndef g2_run():\n    #g1.switch()\n    greenlet.getcurrent().parent.switch()\n\ngreenlet.settrace(tracefunc)\n\ng1 = greenlet.greenlet(g1_run)\ng2 = greenlet.greenlet(g2_run)\n\n# This switch didn't actually finish!\n# And if it did, it would raise TypeError\n# because g1_run() doesn't take any arguments.\ng1.switch(1)\nprint('Back in main')\ng1.switch(2)\n", "src/greenlet/tests/test_cpp.py": "from __future__ import print_function\nfrom __future__ import absolute_import\n\nimport subprocess\nimport unittest\n\nimport greenlet\nfrom . import _test_extension_cpp\nfrom . import TestCase\nfrom . import WIN\n\nclass CPPTests(TestCase):\n    def test_exception_switch(self):\n        greenlets = []\n        for i in range(4):\n            g = greenlet.greenlet(_test_extension_cpp.test_exception_switch)\n            g.switch(i)\n            greenlets.append(g)\n        for i, g in enumerate(greenlets):\n            self.assertEqual(g.switch(), i)\n\n    def _do_test_unhandled_exception(self, target):\n        import os\n        import sys\n        script = os.path.join(\n            os.path.dirname(__file__),\n            'fail_cpp_exception.py',\n        )\n        args = [sys.executable, script, target.__name__ if not isinstance(target, str) else target]\n        __traceback_info__ = args\n        with self.assertRaises(subprocess.CalledProcessError) as exc:\n            subprocess.check_output(\n                args,\n                encoding='utf-8',\n                stderr=subprocess.STDOUT\n            )\n\n        ex = exc.exception\n        expected_exit = self.get_expected_returncodes_for_aborted_process()\n        self.assertIn(ex.returncode, expected_exit)\n        self.assertIn('fail_cpp_exception is running', ex.output)\n        return ex.output\n\n\n    def test_unhandled_nonstd_exception_aborts(self):\n        # verify that plain unhandled throw aborts\n        self._do_test_unhandled_exception(_test_extension_cpp.test_exception_throw_nonstd)\n\n    def test_unhandled_std_exception_aborts(self):\n        # verify that plain unhandled throw aborts\n        self._do_test_unhandled_exception(_test_extension_cpp.test_exception_throw_std)\n\n    @unittest.skipIf(WIN, \"XXX: This does not crash on Windows\")\n    # Meaning the exception is getting lost somewhere...\n    def test_unhandled_std_exception_as_greenlet_function_aborts(self):\n        # verify that plain unhandled throw aborts\n        output = self._do_test_unhandled_exception('run_as_greenlet_target')\n        self.assertIn(\n            # We really expect this to be prefixed with \"greenlet: Unhandled C++ exception:\"\n            # as added by our handler for std::exception (see TUserGreenlet.cpp), but\n            # that's not correct everywhere --- our handler never runs before std::terminate\n            # gets called (for example, on arm32).\n            'Thrown from an extension.',\n            output\n        )\n\n    def test_unhandled_exception_in_greenlet_aborts(self):\n        # verify that unhandled throw called in greenlet aborts too\n        self._do_test_unhandled_exception('run_unhandled_exception_in_greenlet_aborts')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/greenlet/tests/test_extension_interface.py": "from __future__ import print_function\nfrom __future__ import absolute_import\n\nimport sys\n\nimport greenlet\nfrom . import _test_extension\nfrom . import TestCase\n\n# pylint:disable=c-extension-no-member\n\nclass CAPITests(TestCase):\n    def test_switch(self):\n        self.assertEqual(\n            50, _test_extension.test_switch(greenlet.greenlet(lambda: 50)))\n\n    def test_switch_kwargs(self):\n        def adder(x, y):\n            return x * y\n        g = greenlet.greenlet(adder)\n        self.assertEqual(6, _test_extension.test_switch_kwargs(g, x=3, y=2))\n\n    def test_setparent(self):\n        # pylint:disable=disallowed-name\n        def foo():\n            def bar():\n                greenlet.getcurrent().parent.switch()\n\n                # This final switch should go back to the main greenlet, since\n                # the test_setparent() function in the C extension should have\n                # reparented this greenlet.\n                greenlet.getcurrent().parent.switch()\n                raise AssertionError(\"Should never have reached this code\")\n            child = greenlet.greenlet(bar)\n            child.switch()\n            greenlet.getcurrent().parent.switch(child)\n            greenlet.getcurrent().parent.throw(\n                AssertionError(\"Should never reach this code\"))\n        foo_child = greenlet.greenlet(foo).switch()\n        self.assertEqual(None, _test_extension.test_setparent(foo_child))\n\n    def test_getcurrent(self):\n        _test_extension.test_getcurrent()\n\n    def test_new_greenlet(self):\n        self.assertEqual(-15, _test_extension.test_new_greenlet(lambda: -15))\n\n    def test_raise_greenlet_dead(self):\n        self.assertRaises(\n            greenlet.GreenletExit, _test_extension.test_raise_dead_greenlet)\n\n    def test_raise_greenlet_error(self):\n        self.assertRaises(\n            greenlet.error, _test_extension.test_raise_greenlet_error)\n\n    def test_throw(self):\n        seen = []\n\n        def foo():         # pylint:disable=disallowed-name\n            try:\n                greenlet.getcurrent().parent.switch()\n            except ValueError:\n                seen.append(sys.exc_info()[1])\n            except greenlet.GreenletExit:\n                raise AssertionError\n        g = greenlet.greenlet(foo)\n        g.switch()\n        _test_extension.test_throw(g)\n        self.assertEqual(len(seen), 1)\n        self.assertTrue(\n            isinstance(seen[0], ValueError),\n            \"ValueError was not raised in foo()\")\n        self.assertEqual(\n            str(seen[0]),\n            'take that sucka!',\n            \"message doesn't match\")\n\n    def test_non_traceback_param(self):\n        with self.assertRaises(TypeError) as exc:\n            _test_extension.test_throw_exact(\n                greenlet.getcurrent(),\n                Exception,\n                Exception(),\n                self\n            )\n        self.assertEqual(str(exc.exception),\n                         \"throw() third argument must be a traceback object\")\n\n    def test_instance_of_wrong_type(self):\n        with self.assertRaises(TypeError) as exc:\n            _test_extension.test_throw_exact(\n                greenlet.getcurrent(),\n                Exception(),\n                BaseException(),\n                None,\n            )\n\n        self.assertEqual(str(exc.exception),\n                         \"instance exception may not have a separate value\")\n\n    def test_not_throwable(self):\n        with self.assertRaises(TypeError) as exc:\n            _test_extension.test_throw_exact(\n                greenlet.getcurrent(),\n                \"abc\",\n                None,\n                None,\n            )\n        self.assertEqual(str(exc.exception),\n                         \"exceptions must be classes, or instances, not str\")\n\n\nif __name__ == '__main__':\n    import unittest\n    unittest.main()\n", "src/greenlet/tests/test_version.py": "#! /usr/bin/env python\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n\nimport sys\nimport os\nfrom unittest import TestCase as NonLeakingTestCase\n\nimport greenlet\n\n# No reason to run this multiple times under leakchecks,\n# it doesn't do anything.\nclass VersionTests(NonLeakingTestCase):\n    def test_version(self):\n        def find_dominating_file(name):\n            if os.path.exists(name):\n                return name\n\n            tried = []\n            here = os.path.abspath(os.path.dirname(__file__))\n            for i in range(10):\n                up = ['..'] * i\n                path = [here] + up + [name]\n                fname = os.path.join(*path)\n                fname = os.path.abspath(fname)\n                tried.append(fname)\n                if os.path.exists(fname):\n                    return fname\n            raise AssertionError(\"Could not find file \" + name + \"; checked \" + str(tried))\n\n        try:\n            setup_py = find_dominating_file('setup.py')\n        except AssertionError as e:\n            self.skipTest(\"Unable to find setup.py; must be out of tree. \" + str(e))\n\n\n        invoke_setup = \"%s %s --version\" % (sys.executable, setup_py)\n        with os.popen(invoke_setup) as f:\n            sversion = f.read().strip()\n\n        self.assertEqual(sversion, greenlet.__version__)\n", "src/greenlet/tests/test_contextvars.py": "from __future__ import print_function\n\nimport gc\nimport sys\nimport unittest\n\nfrom functools import partial\nfrom unittest import skipUnless\nfrom unittest import skipIf\n\nfrom greenlet import greenlet\nfrom greenlet import getcurrent\nfrom . import TestCase\n\n\ntry:\n    from contextvars import Context\n    from contextvars import ContextVar\n    from contextvars import copy_context\n    # From the documentation:\n    #\n    # Important: Context Variables should be created at the top module\n    # level and never in closures. Context objects hold strong\n    # references to context variables which prevents context variables\n    # from being properly garbage collected.\n    ID_VAR = ContextVar(\"id\", default=None)\n    VAR_VAR = ContextVar(\"var\", default=None)\n    ContextVar = None\nexcept ImportError:\n    Context = ContextVar = copy_context = None\n\n# We don't support testing if greenlet's built-in context var support is disabled.\n@skipUnless(Context is not None, \"ContextVar not supported\")\nclass ContextVarsTests(TestCase):\n    def _new_ctx_run(self, *args, **kwargs):\n        return copy_context().run(*args, **kwargs)\n\n    def _increment(self, greenlet_id, callback, counts, expect):\n        ctx_var = ID_VAR\n        if expect is None:\n            self.assertIsNone(ctx_var.get())\n        else:\n            self.assertEqual(ctx_var.get(), expect)\n        ctx_var.set(greenlet_id)\n        for _ in range(2):\n            counts[ctx_var.get()] += 1\n            callback()\n\n    def _test_context(self, propagate_by):\n        # pylint:disable=too-many-branches\n        ID_VAR.set(0)\n\n        callback = getcurrent().switch\n        counts = dict((i, 0) for i in range(5))\n\n        lets = [\n            greenlet(partial(\n                partial(\n                    copy_context().run,\n                    self._increment\n                ) if propagate_by == \"run\" else self._increment,\n                greenlet_id=i,\n                callback=callback,\n                counts=counts,\n                expect=(\n                    i - 1 if propagate_by == \"share\" else\n                    0 if propagate_by in (\"set\", \"run\") else None\n                )\n            ))\n            for i in range(1, 5)\n        ]\n\n        for let in lets:\n            if propagate_by == \"set\":\n                let.gr_context = copy_context()\n            elif propagate_by == \"share\":\n                let.gr_context = getcurrent().gr_context\n\n        for i in range(2):\n            counts[ID_VAR.get()] += 1\n            for let in lets:\n                let.switch()\n\n        if propagate_by == \"run\":\n            # Must leave each context.run() in reverse order of entry\n            for let in reversed(lets):\n                let.switch()\n        else:\n            # No context.run(), so fine to exit in any order.\n            for let in lets:\n                let.switch()\n\n        for let in lets:\n            self.assertTrue(let.dead)\n            # When using run(), we leave the run() as the greenlet dies,\n            # and there's no context \"underneath\". When not using run(),\n            # gr_context still reflects the context the greenlet was\n            # running in.\n            if propagate_by == 'run':\n                self.assertIsNone(let.gr_context)\n            else:\n                self.assertIsNotNone(let.gr_context)\n\n\n        if propagate_by == \"share\":\n            self.assertEqual(counts, {0: 1, 1: 1, 2: 1, 3: 1, 4: 6})\n        else:\n            self.assertEqual(set(counts.values()), set([2]))\n\n    def test_context_propagated_by_context_run(self):\n        self._new_ctx_run(self._test_context, \"run\")\n\n    def test_context_propagated_by_setting_attribute(self):\n        self._new_ctx_run(self._test_context, \"set\")\n\n    def test_context_not_propagated(self):\n        self._new_ctx_run(self._test_context, None)\n\n    def test_context_shared(self):\n        self._new_ctx_run(self._test_context, \"share\")\n\n    def test_break_ctxvars(self):\n        let1 = greenlet(copy_context().run)\n        let2 = greenlet(copy_context().run)\n        let1.switch(getcurrent().switch)\n        let2.switch(getcurrent().switch)\n        # Since let2 entered the current context and let1 exits its own, the\n        # interpreter emits:\n        # RuntimeError: cannot exit context: thread state references a different context object\n        let1.switch()\n\n    def test_not_broken_if_using_attribute_instead_of_context_run(self):\n        let1 = greenlet(getcurrent().switch)\n        let2 = greenlet(getcurrent().switch)\n        let1.gr_context = copy_context()\n        let2.gr_context = copy_context()\n        let1.switch()\n        let2.switch()\n        let1.switch()\n        let2.switch()\n\n    def test_context_assignment_while_running(self):\n        # pylint:disable=too-many-statements\n        ID_VAR.set(None)\n\n        def target():\n            self.assertIsNone(ID_VAR.get())\n            self.assertIsNone(gr.gr_context)\n\n            # Context is created on first use\n            ID_VAR.set(1)\n            self.assertIsInstance(gr.gr_context, Context)\n            self.assertEqual(ID_VAR.get(), 1)\n            self.assertEqual(gr.gr_context[ID_VAR], 1)\n\n            # Clearing the context makes it get re-created as another\n            # empty context when next used\n            old_context = gr.gr_context\n            gr.gr_context = None  # assign None while running\n            self.assertIsNone(ID_VAR.get())\n            self.assertIsNone(gr.gr_context)\n            ID_VAR.set(2)\n            self.assertIsInstance(gr.gr_context, Context)\n            self.assertEqual(ID_VAR.get(), 2)\n            self.assertEqual(gr.gr_context[ID_VAR], 2)\n\n            new_context = gr.gr_context\n            getcurrent().parent.switch((old_context, new_context))\n            # parent switches us back to old_context\n\n            self.assertEqual(ID_VAR.get(), 1)\n            gr.gr_context = new_context  # assign non-None while running\n            self.assertEqual(ID_VAR.get(), 2)\n\n            getcurrent().parent.switch()\n            # parent switches us back to no context\n            self.assertIsNone(ID_VAR.get())\n            self.assertIsNone(gr.gr_context)\n            gr.gr_context = old_context\n            self.assertEqual(ID_VAR.get(), 1)\n\n            getcurrent().parent.switch()\n            # parent switches us back to no context\n            self.assertIsNone(ID_VAR.get())\n            self.assertIsNone(gr.gr_context)\n\n        gr = greenlet(target)\n\n        with self.assertRaisesRegex(AttributeError, \"can't delete context attribute\"):\n            del gr.gr_context\n\n        self.assertIsNone(gr.gr_context)\n        old_context, new_context = gr.switch()\n        self.assertIs(new_context, gr.gr_context)\n        self.assertEqual(old_context[ID_VAR], 1)\n        self.assertEqual(new_context[ID_VAR], 2)\n        self.assertEqual(new_context.run(ID_VAR.get), 2)\n        gr.gr_context = old_context  # assign non-None while suspended\n        gr.switch()\n        self.assertIs(gr.gr_context, new_context)\n        gr.gr_context = None  # assign None while suspended\n        gr.switch()\n        self.assertIs(gr.gr_context, old_context)\n        gr.gr_context = None\n        gr.switch()\n        self.assertIsNone(gr.gr_context)\n\n        # Make sure there are no reference leaks\n        gr = None\n        gc.collect()\n        self.assertEqual(sys.getrefcount(old_context), 2)\n        self.assertEqual(sys.getrefcount(new_context), 2)\n\n    def test_context_assignment_different_thread(self):\n        import threading\n        VAR_VAR.set(None)\n        ctx = Context()\n\n        is_running = threading.Event()\n        should_suspend = threading.Event()\n        did_suspend = threading.Event()\n        should_exit = threading.Event()\n        holder = []\n\n        def greenlet_in_thread_fn():\n            VAR_VAR.set(1)\n            is_running.set()\n            should_suspend.wait(10)\n            VAR_VAR.set(2)\n            getcurrent().parent.switch()\n            holder.append(VAR_VAR.get())\n\n        def thread_fn():\n            gr = greenlet(greenlet_in_thread_fn)\n            gr.gr_context = ctx\n            holder.append(gr)\n            gr.switch()\n            did_suspend.set()\n            should_exit.wait(10)\n            gr.switch()\n            del gr\n            greenlet() # trigger cleanup\n\n        thread = threading.Thread(target=thread_fn, daemon=True)\n        thread.start()\n        is_running.wait(10)\n        gr = holder[0]\n\n        # Can't access or modify context if the greenlet is running\n        # in a different thread\n        with self.assertRaisesRegex(ValueError, \"running in a different\"):\n            getattr(gr, 'gr_context')\n        with self.assertRaisesRegex(ValueError, \"running in a different\"):\n            gr.gr_context = None\n\n        should_suspend.set()\n        did_suspend.wait(10)\n\n        # OK to access and modify context if greenlet is suspended\n        self.assertIs(gr.gr_context, ctx)\n        self.assertEqual(gr.gr_context[VAR_VAR], 2)\n        gr.gr_context = None\n\n        should_exit.set()\n        thread.join(10)\n\n        self.assertEqual(holder, [gr, None])\n\n        # Context can still be accessed/modified when greenlet is dead:\n        self.assertIsNone(gr.gr_context)\n        gr.gr_context = ctx\n        self.assertIs(gr.gr_context, ctx)\n\n        # Otherwise we leak greenlets on some platforms.\n        # XXX: Should be able to do this automatically\n        del holder[:]\n        gr = None\n        thread = None\n\n    def test_context_assignment_wrong_type(self):\n        g = greenlet()\n        with self.assertRaisesRegex(TypeError,\n                                    \"greenlet context must be a contextvars.Context or None\"):\n            g.gr_context = self\n\n\n@skipIf(Context is not None, \"ContextVar supported\")\nclass NoContextVarsTests(TestCase):\n    def test_contextvars_errors(self):\n        let1 = greenlet(getcurrent().switch)\n        self.assertFalse(hasattr(let1, 'gr_context'))\n        with self.assertRaises(AttributeError):\n            getattr(let1, 'gr_context')\n\n        with self.assertRaises(AttributeError):\n            let1.gr_context = None\n\n        let1.switch()\n\n        with self.assertRaises(AttributeError):\n            getattr(let1, 'gr_context')\n\n        with self.assertRaises(AttributeError):\n            let1.gr_context = None\n\n        del let1\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/greenlet/tests/test_greenlet_trash.py": "# -*- coding: utf-8 -*-\n\"\"\"\nTests for greenlets interacting with the CPython trash can API.\n\nThe CPython trash can API is not designed to be re-entered from a\nsingle thread. But this can happen using greenlets, if something\nduring the object deallocation process switches greenlets, and this second\ngreenlet then causes the trash can to get entered again. Here, we do this\nvery explicitly, but in other cases (like gevent) it could be arbitrarily more\ncomplicated: for example, a weakref callback might try to acquire a lock that's\nalready held by another greenlet; that would allow a greenlet switch to occur.\n\nSee https://github.com/gevent/gevent/issues/1909\n\nThis test is fragile and relies on details of the CPython\nimplementation (like most of the rest of this package):\n\n    - We enter the trashcan and deferred deallocation after\n      ``_PyTrash_UNWIND_LEVEL`` calls. This constant, defined in\n      CPython's object.c, is generally 50. That's basically how many objects are required to\n      get us into the deferred deallocation situation.\n\n    - The test fails by hitting an ``assert()`` in object.c; if the\n      build didn't enable assert, then we don't catch this.\n\n    - If the test fails in that way, the interpreter crashes.\n\"\"\"\nfrom __future__ import print_function, absolute_import, division\n\nimport unittest\n\nclass TestTrashCanReEnter(unittest.TestCase):\n\n    def test_it(self):\n        # Try several times to trigger it, because it isn't 100%\n        # reliable.\n        for _ in range(10):\n            self.check_it()\n\n    def check_it(self): # pylint:disable=too-many-statements\n        import greenlet\n        from greenlet._greenlet import get_tstate_trash_delete_nesting # pylint:disable=no-name-in-module\n\n        main = greenlet.getcurrent()\n\n        assert get_tstate_trash_delete_nesting() == 0\n\n        # We expect to be in deferred deallocation after this many\n        # deallocations have occurred. TODO: I wish we had a better way to do\n        # this --- that was before get_tstate_trash_delete_nesting; perhaps\n        # we can use that API to do better?\n        TRASH_UNWIND_LEVEL = 50\n        # How many objects to put in a container; it's the container that\n        # queues objects for deferred deallocation.\n        OBJECTS_PER_CONTAINER = 500\n\n        class Dealloc: # define the class here because we alter class variables each time we run.\n            \"\"\"\n            An object with a ``__del__`` method. When it starts getting deallocated\n            from a deferred trash can run, it switches greenlets, allocates more objects\n            which then also go in the trash can. If we don't save state appropriately,\n            nesting gets out of order and we can crash the interpreter.\n            \"\"\"\n\n            #: Has our deallocation actually run and switched greenlets?\n            #: When it does, this will be set to the current greenlet. This should\n            #: be happening in the main greenlet, so we check that down below.\n            SPAWNED = False\n\n            #: Has the background greenlet run?\n            BG_RAN = False\n\n            BG_GLET = None\n\n            #: How many of these things have ever been allocated.\n            CREATED = 0\n\n            #: How many of these things have ever been deallocated.\n            DESTROYED = 0\n\n            #: How many were destroyed not in the main greenlet. There should always\n            #: be some.\n            #: If the test is broken or things change in the trashcan implementation,\n            #: this may not be correct.\n            DESTROYED_BG = 0\n\n            def __init__(self, sequence_number):\n                \"\"\"\n                :param sequence_number: The ordinal of this object during\n                   one particular creation run. This is used to detect (guess, really)\n                   when we have entered the trash can's deferred deallocation.\n                \"\"\"\n                self.i = sequence_number\n                Dealloc.CREATED += 1\n\n            def __del__(self):\n                if self.i == TRASH_UNWIND_LEVEL and not self.SPAWNED:\n                    Dealloc.SPAWNED = greenlet.getcurrent()\n                    other = Dealloc.BG_GLET = greenlet.greenlet(background_greenlet)\n                    x = other.switch()\n                    assert x == 42\n                    # It's important that we don't switch back to the greenlet,\n                    # we leave it hanging there in an incomplete state. But we don't let it\n                    # get collected, either. If we complete it now, while we're still\n                    # in the scope of the initial trash can, things work out and we\n                    # don't see the problem. We need this greenlet to complete\n                    # at some point in the future, after we've exited this trash can invocation.\n                    del other\n                elif self.i == 40 and greenlet.getcurrent() is not main:\n                    Dealloc.BG_RAN = True\n                    try:\n                        main.switch(42)\n                    except greenlet.GreenletExit as ex:\n                        # We expect this; all references to us go away\n                        # while we're still running, and we need to finish deleting\n                        # ourself.\n                        Dealloc.BG_RAN = type(ex)\n                        del ex\n\n                # Record the fact that we're dead last of all. This ensures that\n                # we actually get returned too.\n                Dealloc.DESTROYED += 1\n                if greenlet.getcurrent() is not main:\n                    Dealloc.DESTROYED_BG += 1\n\n\n        def background_greenlet():\n            # We direct through a second function, instead of\n            # directly calling ``make_some()``, so that we have complete\n            # control over when these objects are destroyed: we need them\n            # to be destroyed in the context of the background greenlet\n            t = make_some()\n            del t # Triggere deletion.\n\n        def make_some():\n            t = ()\n            i = OBJECTS_PER_CONTAINER\n            while i:\n                # Nest the tuples; it's the recursion that gets us\n                # into trash.\n                t = (Dealloc(i), t)\n                i -= 1\n            return t\n\n\n        some = make_some()\n        self.assertEqual(Dealloc.CREATED, OBJECTS_PER_CONTAINER)\n        self.assertEqual(Dealloc.DESTROYED, 0)\n\n        # If we're going to crash, it should be on the following line.\n        # We only crash if ``assert()`` is enabled, of course.\n        del some\n\n        # For non-debug builds of CPython, we won't crash. The best we can do is check\n        # the nesting level explicitly.\n        self.assertEqual(0, get_tstate_trash_delete_nesting())\n\n        # Discard this, raising GreenletExit into where it is waiting.\n        Dealloc.BG_GLET = None\n        # The same nesting level maintains.\n        self.assertEqual(0, get_tstate_trash_delete_nesting())\n\n        # We definitely cleaned some up in the background\n        self.assertGreater(Dealloc.DESTROYED_BG, 0)\n\n        # Make sure all the cleanups happened.\n        self.assertIs(Dealloc.SPAWNED, main)\n        self.assertTrue(Dealloc.BG_RAN)\n        self.assertEqual(Dealloc.BG_RAN, greenlet.GreenletExit)\n        self.assertEqual(Dealloc.CREATED, Dealloc.DESTROYED )\n        self.assertEqual(Dealloc.CREATED, OBJECTS_PER_CONTAINER * 2)\n\n        import gc\n        gc.collect()\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/greenlet/tests/fail_clearing_run_switches.py": "# -*- coding: utf-8 -*-\n\"\"\"\nIf we have a run callable passed to the constructor or set as an\nattribute, but we don't actually use that (because ``__getattribute__``\nor the like interferes), then when we clear callable before beginning\nto run, there's an opportunity for Python code to run.\n\n\"\"\"\nimport greenlet\n\ng = None\nmain = greenlet.getcurrent()\n\nresults = []\n\nclass RunCallable:\n\n    def __del__(self):\n        results.append(('RunCallable', '__del__'))\n        main.switch('from RunCallable')\n\n\nclass G(greenlet.greenlet):\n\n    def __getattribute__(self, name):\n        if name == 'run':\n            results.append(('G.__getattribute__', 'run'))\n            return run_func\n        return object.__getattribute__(self, name)\n\n\ndef run_func():\n    results.append(('run_func', 'enter'))\n\n\ng = G(RunCallable())\n# Try to start G. It will get to the point where it deletes\n# its run callable C++ variable in inner_bootstrap. That triggers\n# the __del__ method, which switches back to main before g\n# actually even starts running.\nx = g.switch()\nresults.append(('main: g.switch()', x))\n# In the C++ code, this results in g->g_switch() appearing to return, even though\n# it has yet to run.\nprint('In main with', x, flush=True)\ng.switch()\nprint('RESULTS', results)\n", "src/greenlet/tests/fail_cpp_exception.py": "# -*- coding: utf-8 -*-\n\"\"\"\nHelper for testing a C++ exception throw aborts the process.\n\nTakes one argument, the name of the function in :mod:`_test_extension_cpp` to call.\n\"\"\"\nimport sys\nimport greenlet\nfrom greenlet.tests import _test_extension_cpp\nprint('fail_cpp_exception is running')\n\ndef run_unhandled_exception_in_greenlet_aborts():\n    def _():\n        _test_extension_cpp.test_exception_switch_and_do_in_g2(\n            _test_extension_cpp.test_exception_throw_nonstd\n        )\n    g1 = greenlet.greenlet(_)\n    g1.switch()\n\n\nfunc_name = sys.argv[1]\ntry:\n    func = getattr(_test_extension_cpp, func_name)\nexcept AttributeError:\n    if func_name == run_unhandled_exception_in_greenlet_aborts.__name__:\n        func = run_unhandled_exception_in_greenlet_aborts\n    elif func_name == 'run_as_greenlet_target':\n        g = greenlet.greenlet(_test_extension_cpp.test_exception_throw_std)\n        func = g.switch\n    else:\n        raise\nprint('raising', func, flush=True)\nfunc()\n", "src/greenlet/tests/test_generator.py": "\nfrom greenlet import greenlet\n\nfrom . import TestCase\n\nclass genlet(greenlet):\n    parent = None\n    def __init__(self, *args, **kwds):\n        self.args = args\n        self.kwds = kwds\n\n    def run(self):\n        fn, = self.fn\n        fn(*self.args, **self.kwds)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.parent = greenlet.getcurrent()\n        result = self.switch()\n        if self:\n            return result\n\n        raise StopIteration\n\n    next = __next__\n\n\ndef Yield(value):\n    g = greenlet.getcurrent()\n    while not isinstance(g, genlet):\n        if g is None:\n            raise RuntimeError('yield outside a genlet')\n        g = g.parent\n    g.parent.switch(value)\n\n\ndef generator(func):\n    class Generator(genlet):\n        fn = (func,)\n    return Generator\n\n# ____________________________________________________________\n\n\nclass GeneratorTests(TestCase):\n    def test_generator(self):\n        seen = []\n\n        def g(n):\n            for i in range(n):\n                seen.append(i)\n                Yield(i)\n        g = generator(g)\n        for _ in range(3):\n            for j in g(5):\n                seen.append(j)\n        self.assertEqual(seen, 3 * [0, 0, 1, 1, 2, 2, 3, 3, 4, 4])\n", "src/greenlet/tests/test_leaks.py": "# -*- coding: utf-8 -*-\n\"\"\"\nTesting scenarios that may have leaked.\n\"\"\"\nfrom __future__ import print_function, absolute_import, division\n\nimport sys\nimport gc\n\nimport time\nimport weakref\nimport threading\n\n\nimport greenlet\nfrom . import TestCase\nfrom .leakcheck import fails_leakcheck\nfrom .leakcheck import ignores_leakcheck\nfrom .leakcheck import RUNNING_ON_MANYLINUX\n\n# pylint:disable=protected-access\n\nassert greenlet.GREENLET_USE_GC # Option to disable this was removed in 1.0\n\nclass HasFinalizerTracksInstances(object):\n    EXTANT_INSTANCES = set()\n    def __init__(self, msg):\n        self.msg = sys.intern(msg)\n        self.EXTANT_INSTANCES.add(id(self))\n    def __del__(self):\n        self.EXTANT_INSTANCES.remove(id(self))\n    def __repr__(self):\n        return \"<HasFinalizerTracksInstances at 0x%x %r>\" % (\n            id(self), self.msg\n        )\n    @classmethod\n    def reset(cls):\n        cls.EXTANT_INSTANCES.clear()\n\n\nclass TestLeaks(TestCase):\n\n    def test_arg_refs(self):\n        args = ('a', 'b', 'c')\n        refcount_before = sys.getrefcount(args)\n        # pylint:disable=unnecessary-lambda\n        g = greenlet.greenlet(\n            lambda *args: greenlet.getcurrent().parent.switch(*args))\n        for _ in range(100):\n            g.switch(*args)\n        self.assertEqual(sys.getrefcount(args), refcount_before)\n\n    def test_kwarg_refs(self):\n        kwargs = {}\n        # pylint:disable=unnecessary-lambda\n        g = greenlet.greenlet(\n            lambda **kwargs: greenlet.getcurrent().parent.switch(**kwargs))\n        for _ in range(100):\n            g.switch(**kwargs)\n        self.assertEqual(sys.getrefcount(kwargs), 2)\n\n\n    @staticmethod\n    def __recycle_threads():\n        # By introducing a thread that does sleep we allow other threads,\n        # that have triggered their __block condition, but did not have a\n        # chance to deallocate their thread state yet, to finally do so.\n        # The way it works is by requiring a GIL switch (different thread),\n        # which does a GIL release (sleep), which might do a GIL switch\n        # to finished threads and allow them to clean up.\n        def worker():\n            time.sleep(0.001)\n        t = threading.Thread(target=worker)\n        t.start()\n        time.sleep(0.001)\n        t.join(10)\n\n    def test_threaded_leak(self):\n        gg = []\n        def worker():\n            # only main greenlet present\n            gg.append(weakref.ref(greenlet.getcurrent()))\n        for _ in range(2):\n            t = threading.Thread(target=worker)\n            t.start()\n            t.join(10)\n            del t\n        greenlet.getcurrent() # update ts_current\n        self.__recycle_threads()\n        greenlet.getcurrent() # update ts_current\n        gc.collect()\n        greenlet.getcurrent() # update ts_current\n        for g in gg:\n            self.assertIsNone(g())\n\n    def test_threaded_adv_leak(self):\n        gg = []\n        def worker():\n            # main and additional *finished* greenlets\n            ll = greenlet.getcurrent().ll = []\n            def additional():\n                ll.append(greenlet.getcurrent())\n            for _ in range(2):\n                greenlet.greenlet(additional).switch()\n            gg.append(weakref.ref(greenlet.getcurrent()))\n        for _ in range(2):\n            t = threading.Thread(target=worker)\n            t.start()\n            t.join(10)\n            del t\n        greenlet.getcurrent() # update ts_current\n        self.__recycle_threads()\n        greenlet.getcurrent() # update ts_current\n        gc.collect()\n        greenlet.getcurrent() # update ts_current\n        for g in gg:\n            self.assertIsNone(g())\n\n    def assertClocksUsed(self):\n        used = greenlet._greenlet.get_clocks_used_doing_optional_cleanup()\n        self.assertGreaterEqual(used, 0)\n        # we don't lose the value\n        greenlet._greenlet.enable_optional_cleanup(True)\n        used2 = greenlet._greenlet.get_clocks_used_doing_optional_cleanup()\n        self.assertEqual(used, used2)\n        self.assertGreater(greenlet._greenlet.CLOCKS_PER_SEC, 1)\n\n    def _check_issue251(self,\n                        manually_collect_background=True,\n                        explicit_reference_to_switch=False):\n        # See https://github.com/python-greenlet/greenlet/issues/251\n        # Killing a greenlet (probably not the main one)\n        # in one thread from another thread would\n        # result in leaking a list (the ts_delkey list).\n        # We no longer use lists to hold that stuff, though.\n\n        # For the test to be valid, even empty lists have to be tracked by the\n        # GC\n\n        assert gc.is_tracked([])\n        HasFinalizerTracksInstances.reset()\n        greenlet.getcurrent()\n        greenlets_before = self.count_objects(greenlet.greenlet, exact_kind=False)\n\n        background_glet_running = threading.Event()\n        background_glet_killed = threading.Event()\n        background_greenlets = []\n\n        # XXX: Switching this to a greenlet subclass that overrides\n        # run results in all callers failing the leaktest; that\n        # greenlet instance is leaked. There's a bound method for\n        # run() living on the stack of the greenlet in g_initialstub,\n        # and since we don't manually switch back to the background\n        # greenlet to let it \"fall off the end\" and exit the\n        # g_initialstub function, it never gets cleaned up. Making the\n        # garbage collector aware of this bound method (making it an\n        # attribute of the greenlet structure and traversing into it)\n        # doesn't help, for some reason.\n        def background_greenlet():\n            # Throw control back to the main greenlet.\n            jd = HasFinalizerTracksInstances(\"DELETING STACK OBJECT\")\n            greenlet._greenlet.set_thread_local(\n                'test_leaks_key',\n                HasFinalizerTracksInstances(\"DELETING THREAD STATE\"))\n            # Explicitly keeping 'switch' in a local variable\n            # breaks this test in all versions\n            if explicit_reference_to_switch:\n                s = greenlet.getcurrent().parent.switch\n                s([jd])\n            else:\n                greenlet.getcurrent().parent.switch([jd])\n\n        bg_main_wrefs = []\n\n        def background_thread():\n            glet = greenlet.greenlet(background_greenlet)\n            bg_main_wrefs.append(weakref.ref(glet.parent))\n\n            background_greenlets.append(glet)\n            glet.switch() # Be sure it's active.\n            # Control is ours again.\n            del glet # Delete one reference from the thread it runs in.\n            background_glet_running.set()\n            background_glet_killed.wait(10)\n\n            # To trigger the background collection of the dead\n            # greenlet, thus clearing out the contents of the list, we\n            # need to run some APIs. See issue 252.\n            if manually_collect_background:\n                greenlet.getcurrent()\n\n\n        t = threading.Thread(target=background_thread)\n        t.start()\n        background_glet_running.wait(10)\n        greenlet.getcurrent()\n        lists_before = self.count_objects(list, exact_kind=True)\n\n        assert len(background_greenlets) == 1\n        self.assertFalse(background_greenlets[0].dead)\n        # Delete the last reference to the background greenlet\n        # from a different thread. This puts it in the background thread's\n        # ts_delkey list.\n        del background_greenlets[:]\n        background_glet_killed.set()\n\n        # Now wait for the background thread to die.\n        t.join(10)\n        del t\n        # As part of the fix for 252, we need to cycle the ceval.c\n        # interpreter loop to be sure it has had a chance to process\n        # the pending call.\n        self.wait_for_pending_cleanups()\n\n        lists_after = self.count_objects(list, exact_kind=True)\n        greenlets_after = self.count_objects(greenlet.greenlet, exact_kind=False)\n\n        # On 2.7, we observe that lists_after is smaller than\n        # lists_before. No idea what lists got cleaned up. All the\n        # Python 3 versions match exactly.\n        self.assertLessEqual(lists_after, lists_before)\n        # On versions after 3.6, we've successfully cleaned up the\n        # greenlet references thanks to the internal \"vectorcall\"\n        # protocol; prior to that, there is a reference path through\n        # the ``greenlet.switch`` method still on the stack that we\n        # can't reach to clean up. The C code goes through terrific\n        # lengths to clean that up.\n        if not explicit_reference_to_switch \\\n           and greenlet._greenlet.get_clocks_used_doing_optional_cleanup() is not None:\n            # If cleanup was disabled, though, we may not find it.\n            self.assertEqual(greenlets_after, greenlets_before)\n            if manually_collect_background:\n                # TODO: Figure out how to make this work!\n                # The one on the stack is still leaking somehow\n                # in the non-manually-collect state.\n                self.assertEqual(HasFinalizerTracksInstances.EXTANT_INSTANCES, set())\n        else:\n            # The explicit reference prevents us from collecting it\n            # and it isn't always found by the GC either for some\n            # reason. The entire frame is leaked somehow, on some\n            # platforms (e.g., MacPorts builds of Python (all\n            # versions!)), but not on other platforms (the linux and\n            # windows builds on GitHub actions and Appveyor). So we'd\n            # like to write a test that proves that the main greenlet\n            # sticks around, and we can on my machine (macOS 11.6,\n            # MacPorts builds of everything) but we can't write that\n            # same test on other platforms. However, hopefully iteration\n            # done by leakcheck will find it.\n            pass\n\n        if greenlet._greenlet.get_clocks_used_doing_optional_cleanup() is not None:\n            self.assertClocksUsed()\n\n    def test_issue251_killing_cross_thread_leaks_list(self):\n        self._check_issue251()\n\n    def test_issue251_with_cleanup_disabled(self):\n        greenlet._greenlet.enable_optional_cleanup(False)\n        try:\n            self._check_issue251()\n        finally:\n            greenlet._greenlet.enable_optional_cleanup(True)\n\n    @fails_leakcheck\n    def test_issue251_issue252_need_to_collect_in_background(self):\n        # Between greenlet 1.1.2 and the next version, this was still\n        # failing because the leak of the list still exists when we\n        # don't call a greenlet API before exiting the thread. The\n        # proximate cause is that neither of the two greenlets from\n        # the background thread are actually being destroyed, even\n        # though the GC is in fact visiting both objects. It's not\n        # clear where that leak is? For some reason the thread-local\n        # dict holding it isn't being cleaned up.\n        #\n        # The leak, I think, is in the CPYthon internal function that\n        # calls into green_switch(). The argument tuple is still on\n        # the C stack somewhere and can't be reached? That doesn't\n        # make sense, because the tuple should be collectable when\n        # this object goes away.\n        #\n        # Note that this test sometimes spuriously passes on Linux,\n        # for some reason, but I've never seen it pass on macOS.\n        self._check_issue251(manually_collect_background=False)\n\n    @fails_leakcheck\n    def test_issue251_issue252_need_to_collect_in_background_cleanup_disabled(self):\n        self.expect_greenlet_leak = True\n        greenlet._greenlet.enable_optional_cleanup(False)\n        try:\n            self._check_issue251(manually_collect_background=False)\n        finally:\n            greenlet._greenlet.enable_optional_cleanup(True)\n\n    @fails_leakcheck\n    def test_issue251_issue252_explicit_reference_not_collectable(self):\n        self._check_issue251(\n            manually_collect_background=False,\n            explicit_reference_to_switch=True)\n\n    UNTRACK_ATTEMPTS = 100\n\n    def _only_test_some_versions(self):\n        # We're only looking for this problem specifically on 3.11,\n        # and this set of tests is relatively fragile, depending on\n        # OS and memory management details. So we want to run it on 3.11+\n        # (obviously) but not every older 3.x version in order to reduce\n        # false negatives. At the moment, those false results seem to have\n        # resolved, so we are actually running this on 3.8+\n        assert sys.version_info[0] >= 3\n        if sys.version_info[:2] < (3, 8):\n            self.skipTest('Only observed on 3.11')\n        if RUNNING_ON_MANYLINUX:\n            self.skipTest(\"Slow and not worth repeating here\")\n\n    @ignores_leakcheck\n    # Because we're just trying to track raw memory, not objects, and running\n    # the leakcheck makes an already slow test slower.\n    def test_untracked_memory_doesnt_increase(self):\n        # See https://github.com/gevent/gevent/issues/1924\n        # and https://github.com/python-greenlet/greenlet/issues/328\n        self._only_test_some_versions()\n        def f():\n            return 1\n\n        ITER = 10000\n        def run_it():\n            for _ in range(ITER):\n                greenlet.greenlet(f).switch()\n\n        # Establish baseline\n        for _ in range(3):\n            run_it()\n\n        # uss: (Linux, macOS, Windows): aka \"Unique Set Size\", this is\n        # the memory which is unique to a process and which would be\n        # freed if the process was terminated right now.\n        uss_before = self.get_process_uss()\n\n        for count in range(self.UNTRACK_ATTEMPTS):\n            uss_before = max(uss_before, self.get_process_uss())\n            run_it()\n\n            uss_after = self.get_process_uss()\n            if uss_after <= uss_before and count > 1:\n                break\n\n        self.assertLessEqual(uss_after, uss_before)\n\n    def _check_untracked_memory_thread(self, deallocate_in_thread=True):\n        self._only_test_some_versions()\n        # Like the above test, but what if there are a bunch of\n        # unfinished greenlets in a thread that dies?\n        # Does it matter if we deallocate in the thread or not?\n        EXIT_COUNT = [0]\n\n        def f():\n            try:\n                greenlet.getcurrent().parent.switch()\n            except greenlet.GreenletExit:\n                EXIT_COUNT[0] += 1\n                raise\n            return 1\n\n        ITER = 10000\n        def run_it():\n            glets = []\n            for _ in range(ITER):\n                # Greenlet starts, switches back to us.\n                # We keep a strong reference to the greenlet though so it doesn't\n                # get a GreenletExit exception.\n                g = greenlet.greenlet(f)\n                glets.append(g)\n                g.switch()\n\n            return glets\n\n        test = self\n\n        class ThreadFunc:\n            uss_before = uss_after = 0\n            glets = ()\n            ITER = 2\n            def __call__(self):\n                self.uss_before = test.get_process_uss()\n\n                for _ in range(self.ITER):\n                    self.glets += tuple(run_it())\n\n                for g in self.glets:\n                    test.assertIn('suspended active', str(g))\n                # Drop them.\n                if deallocate_in_thread:\n                    self.glets = ()\n                self.uss_after = test.get_process_uss()\n\n        # Establish baseline\n        uss_before = uss_after = None\n        for count in range(self.UNTRACK_ATTEMPTS):\n            EXIT_COUNT[0] = 0\n            thread_func = ThreadFunc()\n            t = threading.Thread(target=thread_func)\n            t.start()\n            t.join(30)\n            self.assertFalse(t.is_alive())\n\n            if uss_before is None:\n                uss_before = thread_func.uss_before\n\n            uss_before = max(uss_before, thread_func.uss_before)\n            if deallocate_in_thread:\n                self.assertEqual(thread_func.glets, ())\n                self.assertEqual(EXIT_COUNT[0], ITER * thread_func.ITER)\n\n            del thread_func # Deallocate the greenlets; but this won't raise into them\n            del t\n            if not deallocate_in_thread:\n                self.assertEqual(EXIT_COUNT[0], 0)\n            if deallocate_in_thread:\n                self.wait_for_pending_cleanups()\n\n            uss_after = self.get_process_uss()\n            # See if we achieve a non-growth state at some point. Break when we do.\n            if uss_after <= uss_before and count > 1:\n                break\n\n        self.wait_for_pending_cleanups()\n        uss_after = self.get_process_uss()\n        self.assertLessEqual(uss_after, uss_before, \"after attempts %d\" % (count,))\n\n    @ignores_leakcheck\n    # Because we're just trying to track raw memory, not objects, and running\n    # the leakcheck makes an already slow test slower.\n    def test_untracked_memory_doesnt_increase_unfinished_thread_dealloc_in_thread(self):\n        self._check_untracked_memory_thread(deallocate_in_thread=True)\n\n    @ignores_leakcheck\n    # Because the main greenlets from the background threads do not exit in a timely fashion,\n    # we fail the object-based leakchecks.\n    def test_untracked_memory_doesnt_increase_unfinished_thread_dealloc_in_main(self):\n        self._check_untracked_memory_thread(deallocate_in_thread=False)\n\nif __name__ == '__main__':\n    __import__('unittest').main()\n", "src/greenlet/tests/fail_switch_three_greenlets2.py": "\"\"\"\nLike fail_switch_three_greenlets, but the call into g1_run would actually be\nvalid.\n\"\"\"\nimport greenlet\n\ng1 = None\ng2 = None\n\nswitch_to_g2 = True\n\nresults = []\n\ndef tracefunc(*args):\n    results.append(('trace', args[0]))\n    print('TRACE', *args)\n    global switch_to_g2\n    if switch_to_g2:\n        switch_to_g2 = False\n        g2.switch('g2 from tracefunc')\n    print('\\tLEAVE TRACE', *args)\n\ndef g1_run(arg):\n    results.append(('g1 arg', arg))\n    print('In g1_run')\n    from_parent = greenlet.getcurrent().parent.switch('from g1_run')\n    results.append(('g1 from parent', from_parent))\n    return 'g1 done'\n\ndef g2_run(arg):\n    #g1.switch()\n    results.append(('g2 arg', arg))\n    parent = greenlet.getcurrent().parent.switch('from g2_run')\n    global switch_to_g2\n    switch_to_g2 = False\n    results.append(('g2 from parent', parent))\n    return 'g2 done'\n\n\ngreenlet.settrace(tracefunc)\n\ng1 = greenlet.greenlet(g1_run)\ng2 = greenlet.greenlet(g2_run)\n\nx = g1.switch('g1 from main')\nresults.append(('main g1', x))\nprint('Back in main', x)\nx = g1.switch('g2 from main')\nresults.append(('main g2', x))\nprint('back in amain again', x)\nx = g1.switch('g1 from main 2')\nresults.append(('main g1.2', x))\nx = g2.switch()\nresults.append(('main g2.2', x))\nprint(\"RESULTS:\", results)\n", "src/greenlet/tests/test_generator_nested.py": "\nfrom greenlet import greenlet\nfrom . import TestCase\nfrom .leakcheck import fails_leakcheck\n\nclass genlet(greenlet):\n    parent = None\n    def __init__(self, *args, **kwds):\n        self.args = args\n        self.kwds = kwds\n        self.child = None\n\n    def run(self):\n        # Note the function is packed in a tuple\n        # to avoid creating a bound method for it.\n        fn, = self.fn\n        fn(*self.args, **self.kwds)\n\n    def __iter__(self):\n        return self\n\n    def set_child(self, child):\n        self.child = child\n\n    def __next__(self):\n        if self.child:\n            child = self.child\n            while child.child:\n                tmp = child\n                child = child.child\n                tmp.child = None\n\n            result = child.switch()\n        else:\n            self.parent = greenlet.getcurrent()\n            result = self.switch()\n\n        if self:\n            return result\n\n        raise StopIteration\n\n    next = __next__\n\ndef Yield(value, level=1):\n    g = greenlet.getcurrent()\n\n    while level != 0:\n        if not isinstance(g, genlet):\n            raise RuntimeError('yield outside a genlet')\n        if level > 1:\n            g.parent.set_child(g)\n        g = g.parent\n        level -= 1\n\n    g.switch(value)\n\n\ndef Genlet(func):\n    class TheGenlet(genlet):\n        fn = (func,)\n    return TheGenlet\n\n# ____________________________________________________________\n\n\ndef g1(n, seen):\n    for i in range(n):\n        seen.append(i + 1)\n        yield i\n\n\ndef g2(n, seen):\n    for i in range(n):\n        seen.append(i + 1)\n        Yield(i)\n\ng2 = Genlet(g2)\n\n\ndef nested(i):\n    Yield(i)\n\n\ndef g3(n, seen):\n    for i in range(n):\n        seen.append(i + 1)\n        nested(i)\ng3 = Genlet(g3)\n\n\ndef a(n):\n    if n == 0:\n        return\n    for ii in ax(n - 1):\n        Yield(ii)\n    Yield(n)\nax = Genlet(a)\n\n\ndef perms(l):\n    if len(l) > 1:\n        for e in l:\n            # No syntactical sugar for generator expressions\n            x = [Yield([e] + p) for p in perms([x for x in l if x != e])]\n            assert x\n    else:\n        Yield(l)\nperms = Genlet(perms)\n\n\ndef gr1(n):\n    for ii in range(1, n):\n        Yield(ii)\n        Yield(ii * ii, 2)\n\ngr1 = Genlet(gr1)\n\n\ndef gr2(n, seen):\n    for ii in gr1(n):\n        seen.append(ii)\n\ngr2 = Genlet(gr2)\n\n\nclass NestedGeneratorTests(TestCase):\n    def test_layered_genlets(self):\n        seen = []\n        for ii in gr2(5, seen):\n            seen.append(ii)\n        self.assertEqual(seen, [1, 1, 2, 4, 3, 9, 4, 16])\n\n    @fails_leakcheck\n    def test_permutations(self):\n        gen_perms = perms(list(range(4)))\n        permutations = list(gen_perms)\n        self.assertEqual(len(permutations), 4 * 3 * 2 * 1)\n        self.assertIn([0, 1, 2, 3], permutations)\n        self.assertIn([3, 2, 1, 0], permutations)\n        res = []\n        for ii in zip(perms(list(range(4))), perms(list(range(3)))):\n            res.append(ii)\n        self.assertEqual(\n            res,\n            [([0, 1, 2, 3], [0, 1, 2]), ([0, 1, 3, 2], [0, 2, 1]),\n             ([0, 2, 1, 3], [1, 0, 2]), ([0, 2, 3, 1], [1, 2, 0]),\n             ([0, 3, 1, 2], [2, 0, 1]), ([0, 3, 2, 1], [2, 1, 0])])\n        # XXX Test to make sure we are working as a generator expression\n\n    def test_genlet_simple(self):\n        for g in g1, g2, g3:\n            seen = []\n            for _ in range(3):\n                for j in g(5, seen):\n                    seen.append(j)\n            self.assertEqual(seen, 3 * [1, 0, 2, 1, 3, 2, 4, 3, 5, 4])\n\n    def test_genlet_bad(self):\n        try:\n            Yield(10)\n        except RuntimeError:\n            pass\n\n    def test_nested_genlets(self):\n        seen = []\n        for ii in ax(5):\n            seen.append(ii)\n", "src/greenlet/tests/fail_slp_switch.py": "# -*- coding: utf-8 -*-\n\"\"\"\nA test helper for seeing what happens when slp_switch()\nfails.\n\"\"\"\n# pragma: no cover\n\nimport greenlet\n\n\nprint('fail_slp_switch is running', flush=True)\n\nruns = []\ndef func():\n    runs.append(1)\n    greenlet.getcurrent().parent.switch()\n    runs.append(2)\n    greenlet.getcurrent().parent.switch()\n    runs.append(3)\n\ng = greenlet._greenlet.UnswitchableGreenlet(func)\ng.switch()\nassert runs == [1]\ng.switch()\nassert runs == [1, 2]\ng.force_slp_switch_error = True\n\n# This should crash.\ng.switch()\n", "src/greenlet/tests/test_throw.py": "import sys\n\n\nfrom greenlet import greenlet\nfrom . import TestCase\n\ndef switch(*args):\n    return greenlet.getcurrent().parent.switch(*args)\n\n\nclass ThrowTests(TestCase):\n    def test_class(self):\n        def f():\n            try:\n                switch(\"ok\")\n            except RuntimeError:\n                switch(\"ok\")\n                return\n            switch(\"fail\")\n        g = greenlet(f)\n        res = g.switch()\n        self.assertEqual(res, \"ok\")\n        res = g.throw(RuntimeError)\n        self.assertEqual(res, \"ok\")\n\n    def test_val(self):\n        def f():\n            try:\n                switch(\"ok\")\n            except RuntimeError:\n                val = sys.exc_info()[1]\n                if str(val) == \"ciao\":\n                    switch(\"ok\")\n                    return\n            switch(\"fail\")\n\n        g = greenlet(f)\n        res = g.switch()\n        self.assertEqual(res, \"ok\")\n        res = g.throw(RuntimeError(\"ciao\"))\n        self.assertEqual(res, \"ok\")\n\n        g = greenlet(f)\n        res = g.switch()\n        self.assertEqual(res, \"ok\")\n        res = g.throw(RuntimeError, \"ciao\")\n        self.assertEqual(res, \"ok\")\n\n    def test_kill(self):\n        def f():\n            switch(\"ok\")\n            switch(\"fail\")\n        g = greenlet(f)\n        res = g.switch()\n        self.assertEqual(res, \"ok\")\n        res = g.throw()\n        self.assertTrue(isinstance(res, greenlet.GreenletExit))\n        self.assertTrue(g.dead)\n        res = g.throw()    # immediately eaten by the already-dead greenlet\n        self.assertTrue(isinstance(res, greenlet.GreenletExit))\n\n    def test_throw_goes_to_original_parent(self):\n        main = greenlet.getcurrent()\n\n        def f1():\n            try:\n                main.switch(\"f1 ready to catch\")\n            except IndexError:\n                return \"caught\"\n            return \"normal exit\"\n\n        def f2():\n            main.switch(\"from f2\")\n\n        g1 = greenlet(f1)\n        g2 = greenlet(f2, parent=g1)\n        with self.assertRaises(IndexError):\n            g2.throw(IndexError)\n        self.assertTrue(g2.dead)\n        self.assertTrue(g1.dead)\n\n        g1 = greenlet(f1)\n        g2 = greenlet(f2, parent=g1)\n        res = g1.switch()\n        self.assertEqual(res, \"f1 ready to catch\")\n        res = g2.throw(IndexError)\n        self.assertEqual(res, \"caught\")\n        self.assertTrue(g2.dead)\n        self.assertTrue(g1.dead)\n\n        g1 = greenlet(f1)\n        g2 = greenlet(f2, parent=g1)\n        res = g1.switch()\n        self.assertEqual(res, \"f1 ready to catch\")\n        res = g2.switch()\n        self.assertEqual(res, \"from f2\")\n        res = g2.throw(IndexError)\n        self.assertEqual(res, \"caught\")\n        self.assertTrue(g2.dead)\n        self.assertTrue(g1.dead)\n\n    def test_non_traceback_param(self):\n        with self.assertRaises(TypeError) as exc:\n            greenlet.getcurrent().throw(\n                Exception,\n                Exception(),\n                self\n            )\n        self.assertEqual(str(exc.exception),\n                         \"throw() third argument must be a traceback object\")\n\n    def test_instance_of_wrong_type(self):\n        with self.assertRaises(TypeError) as exc:\n            greenlet.getcurrent().throw(\n                Exception(),\n                BaseException()\n            )\n\n        self.assertEqual(str(exc.exception),\n                         \"instance exception may not have a separate value\")\n\n    def test_not_throwable(self):\n        with self.assertRaises(TypeError) as exc:\n            greenlet.getcurrent().throw(\n                \"abc\"\n            )\n        self.assertEqual(str(exc.exception),\n                         \"exceptions must be classes, or instances, not str\")\n", "src/greenlet/tests/test_greenlet.py": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport gc\nimport sys\nimport time\nimport threading\n\nfrom abc import ABCMeta, abstractmethod\n\nimport greenlet\nfrom greenlet import greenlet as RawGreenlet\nfrom . import TestCase\nfrom .leakcheck import fails_leakcheck\n\n\n# We manually manage locks in many tests\n# pylint:disable=consider-using-with\n# pylint:disable=too-many-public-methods\n# This module is quite large.\n# TODO: Refactor into separate test files. For example,\n# put all the regression tests that used to produce\n# crashes in test_greenlet_no_crash; put tests that DO deliberately crash\n# the interpreter into test_greenlet_crash.\n# pylint:disable=too-many-lines\n\nclass SomeError(Exception):\n    pass\n\n\ndef fmain(seen):\n    try:\n        greenlet.getcurrent().parent.switch()\n    except:\n        seen.append(sys.exc_info()[0])\n        raise\n    raise SomeError\n\n\ndef send_exception(g, exc):\n    # note: send_exception(g, exc)  can be now done with  g.throw(exc).\n    # the purpose of this test is to explicitly check the propagation rules.\n    def crasher(exc):\n        raise exc\n    g1 = RawGreenlet(crasher, parent=g)\n    g1.switch(exc)\n\n\nclass TestGreenlet(TestCase):\n\n    def _do_simple_test(self):\n        lst = []\n\n        def f():\n            lst.append(1)\n            greenlet.getcurrent().parent.switch()\n            lst.append(3)\n        g = RawGreenlet(f)\n        lst.append(0)\n        g.switch()\n        lst.append(2)\n        g.switch()\n        lst.append(4)\n        self.assertEqual(lst, list(range(5)))\n\n    def test_simple(self):\n        self._do_simple_test()\n\n    def test_switch_no_run_raises_AttributeError(self):\n        g = RawGreenlet()\n        with self.assertRaises(AttributeError) as exc:\n            g.switch()\n\n        self.assertIn(\"run\", str(exc.exception))\n\n    def test_throw_no_run_raises_AttributeError(self):\n        g = RawGreenlet()\n        with self.assertRaises(AttributeError) as exc:\n            g.throw(SomeError)\n\n        self.assertIn(\"run\", str(exc.exception))\n\n    def test_parent_equals_None(self):\n        g = RawGreenlet(parent=None)\n        self.assertIsNotNone(g)\n        self.assertIs(g.parent, greenlet.getcurrent())\n\n    def test_run_equals_None(self):\n        g = RawGreenlet(run=None)\n        self.assertIsNotNone(g)\n        self.assertIsNone(g.run)\n\n    def test_two_children(self):\n        lst = []\n\n        def f():\n            lst.append(1)\n            greenlet.getcurrent().parent.switch()\n            lst.extend([1, 1])\n        g = RawGreenlet(f)\n        h = RawGreenlet(f)\n        g.switch()\n        self.assertEqual(len(lst), 1)\n        h.switch()\n        self.assertEqual(len(lst), 2)\n        h.switch()\n        self.assertEqual(len(lst), 4)\n        self.assertEqual(h.dead, True)\n        g.switch()\n        self.assertEqual(len(lst), 6)\n        self.assertEqual(g.dead, True)\n\n    def test_two_recursive_children(self):\n        lst = []\n\n        def f():\n            lst.append('b')\n            greenlet.getcurrent().parent.switch()\n\n        def g():\n            lst.append('a')\n            g = RawGreenlet(f)\n            g.switch()\n            lst.append('c')\n\n        g = RawGreenlet(g)\n        self.assertEqual(sys.getrefcount(g), 2)\n        g.switch()\n        self.assertEqual(lst, ['a', 'b', 'c'])\n        # Just the one in this frame, plus the one on the stack we pass to the function\n        self.assertEqual(sys.getrefcount(g), 2)\n\n    def test_threads(self):\n        success = []\n\n        def f():\n            self._do_simple_test()\n            success.append(True)\n        ths = [threading.Thread(target=f) for i in range(10)]\n        for th in ths:\n            th.start()\n        for th in ths:\n            th.join(10)\n        self.assertEqual(len(success), len(ths))\n\n    def test_exception(self):\n        seen = []\n        g1 = RawGreenlet(fmain)\n        g2 = RawGreenlet(fmain)\n        g1.switch(seen)\n        g2.switch(seen)\n        g2.parent = g1\n\n        self.assertEqual(seen, [])\n        #with self.assertRaises(SomeError):\n        #    p(\"***Switching back\")\n        #    g2.switch()\n        # Creating this as a bound method can reveal bugs that\n        # are hidden on newer versions of Python that avoid creating\n        # bound methods for direct expressions; IOW, don't use the `with`\n        # form!\n        self.assertRaises(SomeError, g2.switch)\n        self.assertEqual(seen, [SomeError])\n\n        value = g2.switch()\n        self.assertEqual(value, ())\n        self.assertEqual(seen, [SomeError])\n\n        value = g2.switch(25)\n        self.assertEqual(value, 25)\n        self.assertEqual(seen, [SomeError])\n\n\n    def test_send_exception(self):\n        seen = []\n        g1 = RawGreenlet(fmain)\n        g1.switch(seen)\n        self.assertRaises(KeyError, send_exception, g1, KeyError)\n        self.assertEqual(seen, [KeyError])\n\n    def test_dealloc(self):\n        seen = []\n        g1 = RawGreenlet(fmain)\n        g2 = RawGreenlet(fmain)\n        g1.switch(seen)\n        g2.switch(seen)\n        self.assertEqual(seen, [])\n        del g1\n        gc.collect()\n        self.assertEqual(seen, [greenlet.GreenletExit])\n        del g2\n        gc.collect()\n        self.assertEqual(seen, [greenlet.GreenletExit, greenlet.GreenletExit])\n\n    def test_dealloc_catches_GreenletExit_throws_other(self):\n        def run():\n            try:\n                greenlet.getcurrent().parent.switch()\n            except greenlet.GreenletExit:\n                raise SomeError from None\n\n        g = RawGreenlet(run)\n        g.switch()\n        # Destroying the only reference to the greenlet causes it\n        # to get GreenletExit; when it in turn raises, even though we're the parent\n        # we don't get the exception, it just gets printed.\n        # When we run on 3.8 only, we can use sys.unraisablehook\n        oldstderr = sys.stderr\n        try:\n            from cStringIO import StringIO\n        except ImportError:\n            from io import StringIO\n        stderr = sys.stderr = StringIO()\n        try:\n            del g\n        finally:\n            sys.stderr = oldstderr\n\n        v = stderr.getvalue()\n        self.assertIn(\"Exception\", v)\n        self.assertIn('ignored', v)\n        self.assertIn(\"SomeError\", v)\n\n\n    def test_dealloc_other_thread(self):\n        seen = []\n        someref = []\n\n        bg_glet_created_running_and_no_longer_ref_in_bg = threading.Event()\n        fg_ref_released = threading.Event()\n        bg_should_be_clear = threading.Event()\n        ok_to_exit_bg_thread = threading.Event()\n\n        def f():\n            g1 = RawGreenlet(fmain)\n            g1.switch(seen)\n            someref.append(g1)\n            del g1\n            gc.collect()\n\n            bg_glet_created_running_and_no_longer_ref_in_bg.set()\n            fg_ref_released.wait(3)\n\n            RawGreenlet()   # trigger release\n            bg_should_be_clear.set()\n            ok_to_exit_bg_thread.wait(3)\n            RawGreenlet() # One more time\n\n        t = threading.Thread(target=f)\n        t.start()\n        bg_glet_created_running_and_no_longer_ref_in_bg.wait(10)\n\n        self.assertEqual(seen, [])\n        self.assertEqual(len(someref), 1)\n        del someref[:]\n        gc.collect()\n        # g1 is not released immediately because it's from another thread\n        self.assertEqual(seen, [])\n        fg_ref_released.set()\n        bg_should_be_clear.wait(3)\n        try:\n            self.assertEqual(seen, [greenlet.GreenletExit])\n        finally:\n            ok_to_exit_bg_thread.set()\n            t.join(10)\n            del seen[:]\n            del someref[:]\n\n    def test_frame(self):\n        def f1():\n            f = sys._getframe(0) # pylint:disable=protected-access\n            self.assertEqual(f.f_back, None)\n            greenlet.getcurrent().parent.switch(f)\n            return \"meaning of life\"\n        g = RawGreenlet(f1)\n        frame = g.switch()\n        self.assertTrue(frame is g.gr_frame)\n        self.assertTrue(g)\n\n        from_g = g.switch()\n        self.assertFalse(g)\n        self.assertEqual(from_g, 'meaning of life')\n        self.assertEqual(g.gr_frame, None)\n\n    def test_thread_bug(self):\n        def runner(x):\n            g = RawGreenlet(lambda: time.sleep(x))\n            g.switch()\n        t1 = threading.Thread(target=runner, args=(0.2,))\n        t2 = threading.Thread(target=runner, args=(0.3,))\n        t1.start()\n        t2.start()\n        t1.join(10)\n        t2.join(10)\n\n    def test_switch_kwargs(self):\n        def run(a, b):\n            self.assertEqual(a, 4)\n            self.assertEqual(b, 2)\n            return 42\n        x = RawGreenlet(run).switch(a=4, b=2)\n        self.assertEqual(x, 42)\n\n    def test_switch_kwargs_to_parent(self):\n        def run(x):\n            greenlet.getcurrent().parent.switch(x=x)\n            greenlet.getcurrent().parent.switch(2, x=3)\n            return x, x ** 2\n        g = RawGreenlet(run)\n        self.assertEqual({'x': 3}, g.switch(3))\n        self.assertEqual(((2,), {'x': 3}), g.switch())\n        self.assertEqual((3, 9), g.switch())\n\n    def test_switch_to_another_thread(self):\n        data = {}\n        created_event = threading.Event()\n        done_event = threading.Event()\n\n        def run():\n            data['g'] = RawGreenlet(lambda: None)\n            created_event.set()\n            done_event.wait(10)\n        thread = threading.Thread(target=run)\n        thread.start()\n        created_event.wait(10)\n        with self.assertRaises(greenlet.error):\n            data['g'].switch()\n        done_event.set()\n        thread.join(10)\n        # XXX: Should handle this automatically\n        data.clear()\n\n    def test_exc_state(self):\n        def f():\n            try:\n                raise ValueError('fun')\n            except: # pylint:disable=bare-except\n                exc_info = sys.exc_info()\n                RawGreenlet(h).switch()\n                self.assertEqual(exc_info, sys.exc_info())\n\n        def h():\n            self.assertEqual(sys.exc_info(), (None, None, None))\n\n        RawGreenlet(f).switch()\n\n    def test_instance_dict(self):\n        def f():\n            greenlet.getcurrent().test = 42\n        def deldict(g):\n            del g.__dict__\n        def setdict(g, value):\n            g.__dict__ = value\n        g = RawGreenlet(f)\n        self.assertEqual(g.__dict__, {})\n        g.switch()\n        self.assertEqual(g.test, 42)\n        self.assertEqual(g.__dict__, {'test': 42})\n        g.__dict__ = g.__dict__\n        self.assertEqual(g.__dict__, {'test': 42})\n        self.assertRaises(TypeError, deldict, g)\n        self.assertRaises(TypeError, setdict, g, 42)\n\n    def test_running_greenlet_has_no_run(self):\n        has_run = []\n        def func():\n            has_run.append(\n                hasattr(greenlet.getcurrent(), 'run')\n            )\n\n        g = RawGreenlet(func)\n        g.switch()\n        self.assertEqual(has_run, [False])\n\n    def test_deepcopy(self):\n        import copy\n        self.assertRaises(TypeError, copy.copy, RawGreenlet())\n        self.assertRaises(TypeError, copy.deepcopy, RawGreenlet())\n\n    def test_parent_restored_on_kill(self):\n        hub = RawGreenlet(lambda: None)\n        main = greenlet.getcurrent()\n        result = []\n        def worker():\n            try:\n                # Wait to be killed by going back to the test.\n                main.switch()\n            except greenlet.GreenletExit:\n                # Resurrect and switch to parent\n                result.append(greenlet.getcurrent().parent)\n                result.append(greenlet.getcurrent())\n                hub.switch()\n        g = RawGreenlet(worker, parent=hub)\n        g.switch()\n        # delete the only reference, thereby raising GreenletExit\n        del g\n        self.assertTrue(result)\n        self.assertIs(result[0], main)\n        self.assertIs(result[1].parent, hub)\n        # Delete them, thereby breaking the cycle between the greenlet\n        # and the frame, which otherwise would never be collectable\n        # XXX: We should be able to automatically fix this.\n        del result[:]\n        hub = None\n        main = None\n\n    def test_parent_return_failure(self):\n        # No run causes AttributeError on switch\n        g1 = RawGreenlet()\n        # Greenlet that implicitly switches to parent\n        g2 = RawGreenlet(lambda: None, parent=g1)\n        # AttributeError should propagate to us, no fatal errors\n        with self.assertRaises(AttributeError):\n            g2.switch()\n\n    def test_throw_exception_not_lost(self):\n        class mygreenlet(RawGreenlet):\n            def __getattribute__(self, name):\n                try:\n                    raise Exception # pylint:disable=broad-exception-raised\n                except: # pylint:disable=bare-except\n                    pass\n                return RawGreenlet.__getattribute__(self, name)\n        g = mygreenlet(lambda: None)\n        self.assertRaises(SomeError, g.throw, SomeError())\n\n    @fails_leakcheck\n    def _do_test_throw_to_dead_thread_doesnt_crash(self, wait_for_cleanup=False):\n        result = []\n        def worker():\n            greenlet.getcurrent().parent.switch()\n\n        def creator():\n            g = RawGreenlet(worker)\n            g.switch()\n            result.append(g)\n            if wait_for_cleanup:\n                # Let this greenlet eventually be cleaned up.\n                g.switch()\n                greenlet.getcurrent()\n        t = threading.Thread(target=creator)\n        t.start()\n        t.join(10)\n        del t\n        # But, depending on the operating system, the thread\n        # deallocator may not actually have run yet! So we can't be\n        # sure about the error message unless we wait.\n        if wait_for_cleanup:\n            self.wait_for_pending_cleanups()\n        with self.assertRaises(greenlet.error) as exc:\n            result[0].throw(SomeError)\n\n        if not wait_for_cleanup:\n            self.assertIn(\n                str(exc.exception), [\n                    \"cannot switch to a different thread (which happens to have exited)\",\n                    \"cannot switch to a different thread\"\n                ]\n            )\n        else:\n            self.assertEqual(\n                str(exc.exception),\n                \"cannot switch to a different thread (which happens to have exited)\",\n            )\n\n        if hasattr(result[0].gr_frame, 'clear'):\n            # The frame is actually executing (it thinks), we can't clear it.\n            with self.assertRaises(RuntimeError):\n                result[0].gr_frame.clear()\n        # Unfortunately, this doesn't actually clear the references, they're in the\n        # fast local array.\n        if not wait_for_cleanup:\n            result[0].gr_frame.f_locals.clear()\n        else:\n            self.assertIsNone(result[0].gr_frame)\n\n        del creator\n        worker = None\n        del result[:]\n        # XXX: we ought to be able to automatically fix this.\n        # See issue 252\n        self.expect_greenlet_leak = True # direct us not to wait for it to go away\n\n    @fails_leakcheck\n    def test_throw_to_dead_thread_doesnt_crash(self):\n        self._do_test_throw_to_dead_thread_doesnt_crash()\n\n    def test_throw_to_dead_thread_doesnt_crash_wait(self):\n        self._do_test_throw_to_dead_thread_doesnt_crash(True)\n\n    @fails_leakcheck\n    def test_recursive_startup(self):\n        class convoluted(RawGreenlet):\n            def __init__(self):\n                RawGreenlet.__init__(self)\n                self.count = 0\n            def __getattribute__(self, name):\n                if name == 'run' and self.count == 0:\n                    self.count = 1\n                    self.switch(43)\n                return RawGreenlet.__getattribute__(self, name)\n            def run(self, value):\n                while True:\n                    self.parent.switch(value)\n        g = convoluted()\n        self.assertEqual(g.switch(42), 43)\n        # Exits the running greenlet, otherwise it leaks\n        # XXX: We should be able to automatically fix this\n        #g.throw(greenlet.GreenletExit)\n        #del g\n        self.expect_greenlet_leak = True\n\n    def test_threaded_updatecurrent(self):\n        # released when main thread should execute\n        lock1 = threading.Lock()\n        lock1.acquire()\n        # released when another thread should execute\n        lock2 = threading.Lock()\n        lock2.acquire()\n        class finalized(object):\n            def __del__(self):\n                # happens while in green_updatecurrent() in main greenlet\n                # should be very careful not to accidentally call it again\n                # at the same time we must make sure another thread executes\n                lock2.release()\n                lock1.acquire()\n                # now ts_current belongs to another thread\n        def deallocator():\n            greenlet.getcurrent().parent.switch()\n        def fthread():\n            lock2.acquire()\n            greenlet.getcurrent()\n            del g[0]\n            lock1.release()\n            lock2.acquire()\n            greenlet.getcurrent()\n            lock1.release()\n        main = greenlet.getcurrent()\n        g = [RawGreenlet(deallocator)]\n        g[0].bomb = finalized()\n        g[0].switch()\n        t = threading.Thread(target=fthread)\n        t.start()\n        # let another thread grab ts_current and deallocate g[0]\n        lock2.release()\n        lock1.acquire()\n        # this is the corner stone\n        # getcurrent() will notice that ts_current belongs to another thread\n        # and start the update process, which would notice that g[0] should\n        # be deallocated, and that will execute an object's finalizer. Now,\n        # that object will let another thread run so it can grab ts_current\n        # again, which would likely crash the interpreter if there's no\n        # check for this case at the end of green_updatecurrent(). This test\n        # passes if getcurrent() returns correct result, but it's likely\n        # to randomly crash if it's not anyway.\n        self.assertEqual(greenlet.getcurrent(), main)\n        # wait for another thread to complete, just in case\n        t.join(10)\n\n    def test_dealloc_switch_args_not_lost(self):\n        seen = []\n        def worker():\n            # wait for the value\n            value = greenlet.getcurrent().parent.switch()\n            # delete all references to ourself\n            del worker[0]\n            initiator.parent = greenlet.getcurrent().parent\n            # switch to main with the value, but because\n            # ts_current is the last reference to us we\n            # return here immediately, where we resurrect ourself.\n            try:\n                greenlet.getcurrent().parent.switch(value)\n            finally:\n                seen.append(greenlet.getcurrent())\n        def initiator():\n            return 42 # implicitly falls thru to parent\n\n        worker = [RawGreenlet(worker)]\n\n        worker[0].switch() # prime worker\n        initiator = RawGreenlet(initiator, worker[0])\n        value = initiator.switch()\n        self.assertTrue(seen)\n        self.assertEqual(value, 42)\n\n    def test_tuple_subclass(self):\n        # The point of this test is to see what happens when a custom\n        # tuple subclass is used as an object passed directly to the C\n        # function ``green_switch``; part of ``green_switch`` checks\n        # the ``len()`` of the ``args`` tuple, and that can call back\n        # into Python. Here, when it calls back into Python, we\n        # recursively enter ``green_switch`` again.\n\n        # This test is really only relevant on Python 2. The builtin\n        # `apply` function directly passes the given args tuple object\n        # to the underlying function, whereas the Python 3 version\n        # unpacks and repacks into an actual tuple. This could still\n        # happen using the C API on Python 3 though. We should write a\n        # builtin version of apply() ourself.\n        def _apply(func, a, k):\n            func(*a, **k)\n\n        class mytuple(tuple):\n            def __len__(self):\n                greenlet.getcurrent().switch()\n                return tuple.__len__(self)\n        args = mytuple()\n        kwargs = dict(a=42)\n        def switchapply():\n            _apply(greenlet.getcurrent().parent.switch, args, kwargs)\n        g = RawGreenlet(switchapply)\n        self.assertEqual(g.switch(), kwargs)\n\n    def test_abstract_subclasses(self):\n        AbstractSubclass = ABCMeta(\n            'AbstractSubclass',\n            (RawGreenlet,),\n            {'run': abstractmethod(lambda self: None)})\n\n        class BadSubclass(AbstractSubclass):\n            pass\n\n        class GoodSubclass(AbstractSubclass):\n            def run(self):\n                pass\n\n        GoodSubclass() # should not raise\n        self.assertRaises(TypeError, BadSubclass)\n\n    def test_implicit_parent_with_threads(self):\n        if not gc.isenabled():\n            return # cannot test with disabled gc\n        N = gc.get_threshold()[0]\n        if N < 50:\n            return # cannot test with such a small N\n        def attempt():\n            lock1 = threading.Lock()\n            lock1.acquire()\n            lock2 = threading.Lock()\n            lock2.acquire()\n            recycled = [False]\n            def another_thread():\n                lock1.acquire() # wait for gc\n                greenlet.getcurrent() # update ts_current\n                lock2.release() # release gc\n            t = threading.Thread(target=another_thread)\n            t.start()\n            class gc_callback(object):\n                def __del__(self):\n                    lock1.release()\n                    lock2.acquire()\n                    recycled[0] = True\n            class garbage(object):\n                def __init__(self):\n                    self.cycle = self\n                    self.callback = gc_callback()\n            l = []\n            x = range(N*2)\n            current = greenlet.getcurrent()\n            g = garbage()\n            for _ in x:\n                g = None # lose reference to garbage\n                if recycled[0]:\n                    # gc callback called prematurely\n                    t.join(10)\n                    return False\n                last = RawGreenlet()\n                if recycled[0]:\n                    break # yes! gc called in green_new\n                l.append(last) # increase allocation counter\n            else:\n                # gc callback not called when expected\n                gc.collect()\n                if recycled[0]:\n                    t.join(10)\n                return False\n            self.assertEqual(last.parent, current)\n            for g in l:\n                self.assertEqual(g.parent, current)\n            return True\n        for _ in range(5):\n            if attempt():\n                break\n\n    def test_issue_245_reference_counting_subclass_no_threads(self):\n        # https://github.com/python-greenlet/greenlet/issues/245\n        # Before the fix, this crashed pretty reliably on\n        # Python 3.10, at least on macOS; but much less reliably on other\n        # interpreters (memory layout must have changed).\n        # The threaded test crashed more reliably on more interpreters.\n        from greenlet import getcurrent\n        from greenlet import GreenletExit\n\n        class Greenlet(RawGreenlet):\n            pass\n\n        initial_refs = sys.getrefcount(Greenlet)\n        # This has to be an instance variable because\n        # Python 2 raises a SyntaxError if we delete a local\n        # variable referenced in an inner scope.\n        self.glets = [] # pylint:disable=attribute-defined-outside-init\n\n        def greenlet_main():\n            try:\n                getcurrent().parent.switch()\n            except GreenletExit:\n                self.glets.append(getcurrent())\n\n        # Before the\n        for _ in range(10):\n            Greenlet(greenlet_main).switch()\n\n        del self.glets\n        self.assertEqual(sys.getrefcount(Greenlet), initial_refs)\n\n    def test_issue_245_reference_counting_subclass_threads(self):\n        # https://github.com/python-greenlet/greenlet/issues/245\n        from threading import Thread\n        from threading import Event\n\n        from greenlet import getcurrent\n\n        class MyGreenlet(RawGreenlet):\n            pass\n\n        glets = []\n        ref_cleared = Event()\n\n        def greenlet_main():\n            getcurrent().parent.switch()\n\n        def thread_main(greenlet_running_event):\n            mine = MyGreenlet(greenlet_main)\n            glets.append(mine)\n            # The greenlets being deleted must be active\n            mine.switch()\n            # Don't keep any reference to it in this thread\n            del mine\n            # Let main know we published our greenlet.\n            greenlet_running_event.set()\n            # Wait for main to let us know the references are\n            # gone and the greenlet objects no longer reachable\n            ref_cleared.wait(10)\n            # The creating thread must call getcurrent() (or a few other\n            # greenlet APIs) because that's when the thread-local list of dead\n            # greenlets gets cleared.\n            getcurrent()\n\n        # We start with 3 references to the subclass:\n        # - This module\n        # - Its __mro__\n        # - The __subclassess__ attribute of greenlet\n        # - (If we call gc.get_referents(), we find four entries, including\n        #   some other tuple ``(greenlet)`` that I'm not sure about but must be part\n        #   of the machinery.)\n        #\n        # On Python 3.10 it's often enough to just run 3 threads; on Python 2.7,\n        # more threads are needed, and the results are still\n        # non-deterministic. Presumably the memory layouts are different\n        initial_refs = sys.getrefcount(MyGreenlet)\n        thread_ready_events = []\n        for _ in range(\n                initial_refs + 45\n        ):\n            event = Event()\n            thread = Thread(target=thread_main, args=(event,))\n            thread_ready_events.append(event)\n            thread.start()\n\n\n        for done_event in thread_ready_events:\n            done_event.wait(10)\n\n\n        del glets[:]\n        ref_cleared.set()\n        # Let any other thread run; it will crash the interpreter\n        # if not fixed (or silently corrupt memory and we possibly crash\n        # later).\n        self.wait_for_pending_cleanups()\n        self.assertEqual(sys.getrefcount(MyGreenlet), initial_refs)\n\n    def test_falling_off_end_switches_to_unstarted_parent_raises_error(self):\n        def no_args():\n            return 13\n\n        parent_never_started = RawGreenlet(no_args)\n\n        def leaf():\n            return 42\n\n        child = RawGreenlet(leaf, parent_never_started)\n\n        # Because the run function takes to arguments\n        with self.assertRaises(TypeError):\n            child.switch()\n\n    def test_falling_off_end_switches_to_unstarted_parent_works(self):\n        def one_arg(x):\n            return (x, 24)\n\n        parent_never_started = RawGreenlet(one_arg)\n\n        def leaf():\n            return 42\n\n        child = RawGreenlet(leaf, parent_never_started)\n\n        result = child.switch()\n        self.assertEqual(result, (42, 24))\n\n    def test_switch_to_dead_greenlet_with_unstarted_perverse_parent(self):\n        class Parent(RawGreenlet):\n            def __getattribute__(self, name):\n                if name == 'run':\n                    raise SomeError\n\n\n        parent_never_started = Parent()\n        seen = []\n        child = RawGreenlet(lambda: seen.append(42), parent_never_started)\n        # Because we automatically start the parent when the child is\n        # finished\n        with self.assertRaises(SomeError):\n            child.switch()\n\n        self.assertEqual(seen, [42])\n\n        with self.assertRaises(SomeError):\n            child.switch()\n        self.assertEqual(seen, [42])\n\n    def test_switch_to_dead_greenlet_reparent(self):\n        seen = []\n        parent_never_started = RawGreenlet(lambda: seen.append(24))\n        child = RawGreenlet(lambda: seen.append(42))\n\n        child.switch()\n        self.assertEqual(seen, [42])\n\n        child.parent = parent_never_started\n        # This actually is the same as switching to the parent.\n        result = child.switch()\n        self.assertIsNone(result)\n        self.assertEqual(seen, [42, 24])\n\n    def test_can_access_f_back_of_suspended_greenlet(self):\n        # This tests our frame rewriting to work around Python 3.12+ having\n        # some interpreter frames on the C stack. It will crash in the absence\n        # of that logic.\n        main = greenlet.getcurrent()\n\n        def outer():\n            inner()\n\n        def inner():\n            main.switch(sys._getframe(0))\n\n        hub = RawGreenlet(outer)\n        # start it\n        hub.switch()\n\n        # start another greenlet to make sure we aren't relying on\n        # anything in `hub` still being on the C stack\n        unrelated = RawGreenlet(lambda: None)\n        unrelated.switch()\n\n        # now it is suspended\n        self.assertIsNotNone(hub.gr_frame)\n        self.assertEqual(hub.gr_frame.f_code.co_name, \"inner\")\n        self.assertIsNotNone(hub.gr_frame.f_back)\n        self.assertEqual(hub.gr_frame.f_back.f_code.co_name, \"outer\")\n        # The next line is what would crash\n        self.assertIsNone(hub.gr_frame.f_back.f_back)\n\n    def test_get_stack_with_nested_c_calls(self):\n        from functools import partial\n        from . import _test_extension_cpp\n\n        def recurse(v):\n            if v > 0:\n                return v * _test_extension_cpp.test_call(partial(recurse, v - 1))\n            return greenlet.getcurrent().parent.switch()\n\n        gr = RawGreenlet(recurse)\n        gr.switch(5)\n        frame = gr.gr_frame\n        for i in range(5):\n            self.assertEqual(frame.f_locals[\"v\"], i)\n            frame = frame.f_back\n        self.assertEqual(frame.f_locals[\"v\"], 5)\n        self.assertIsNone(frame.f_back)\n        self.assertEqual(gr.switch(10), 1200)  # 1200 = 5! * 10\n\n    def test_frames_always_exposed(self):\n        # On Python 3.12 this will crash if we don't set the\n        # gr_frames_always_exposed attribute. More background:\n        # https://github.com/python-greenlet/greenlet/issues/388\n        main = greenlet.getcurrent()\n\n        def outer():\n            inner(sys._getframe(0))\n\n        def inner(frame):\n            main.switch(frame)\n\n        gr = RawGreenlet(outer)\n        frame = gr.switch()\n\n        # Do something else to clobber the part of the C stack used by `gr`,\n        # so we can't skate by on \"it just happened to still be there\"\n        unrelated = RawGreenlet(lambda: None)\n        unrelated.switch()\n\n        self.assertEqual(frame.f_code.co_name, \"outer\")\n        # The next line crashes on 3.12 if we haven't exposed the frames.\n        self.assertIsNone(frame.f_back)\n\n\nclass TestGreenletSetParentErrors(TestCase):\n    def test_threaded_reparent(self):\n        data = {}\n        created_event = threading.Event()\n        done_event = threading.Event()\n\n        def run():\n            data['g'] = RawGreenlet(lambda: None)\n            created_event.set()\n            done_event.wait(10)\n\n        def blank():\n            greenlet.getcurrent().parent.switch()\n\n        thread = threading.Thread(target=run)\n        thread.start()\n        created_event.wait(10)\n        g = RawGreenlet(blank)\n        g.switch()\n        with self.assertRaises(ValueError) as exc:\n            g.parent = data['g']\n        done_event.set()\n        thread.join(10)\n\n        self.assertEqual(str(exc.exception), \"parent cannot be on a different thread\")\n\n    def test_unexpected_reparenting(self):\n        another = []\n        def worker():\n            g = RawGreenlet(lambda: None)\n            another.append(g)\n            g.switch()\n        t = threading.Thread(target=worker)\n        t.start()\n        t.join(10)\n        # The first time we switch (running g_initialstub(), which is\n        # when we look up the run attribute) we attempt to change the\n        # parent to one from another thread (which also happens to be\n        # dead). ``g_initialstub()`` should detect this and raise a\n        # greenlet error.\n        #\n        # EXCEPT: With the fix for #252, this is actually detected\n        # sooner, when setting the parent itself. Prior to that fix,\n        # the main greenlet from the background thread kept a valid\n        # value for ``run_info``, and appeared to be a valid parent\n        # until we actually started the greenlet. But now that it's\n        # cleared, this test is catching whether ``green_setparent``\n        # can detect the dead thread.\n        #\n        # Further refactoring once again changes this back to a greenlet.error\n        #\n        # We need to wait for the cleanup to happen, but we're\n        # deliberately leaking a main greenlet here.\n        self.wait_for_pending_cleanups(initial_main_greenlets=self.main_greenlets_before_test + 1)\n\n        class convoluted(RawGreenlet):\n            def __getattribute__(self, name):\n                if name == 'run':\n                    self.parent = another[0] # pylint:disable=attribute-defined-outside-init\n                return RawGreenlet.__getattribute__(self, name)\n        g = convoluted(lambda: None)\n        with self.assertRaises(greenlet.error) as exc:\n            g.switch()\n        self.assertEqual(str(exc.exception),\n                         \"cannot switch to a different thread (which happens to have exited)\")\n        del another[:]\n\n    def test_unexpected_reparenting_thread_running(self):\n        # Like ``test_unexpected_reparenting``, except the background thread is\n        # actually still alive.\n        another = []\n        switched_to_greenlet = threading.Event()\n        keep_main_alive = threading.Event()\n        def worker():\n            g = RawGreenlet(lambda: None)\n            another.append(g)\n            g.switch()\n            switched_to_greenlet.set()\n            keep_main_alive.wait(10)\n        class convoluted(RawGreenlet):\n            def __getattribute__(self, name):\n                if name == 'run':\n                    self.parent = another[0] # pylint:disable=attribute-defined-outside-init\n                return RawGreenlet.__getattribute__(self, name)\n\n        t = threading.Thread(target=worker)\n        t.start()\n\n        switched_to_greenlet.wait(10)\n        try:\n            g = convoluted(lambda: None)\n\n            with self.assertRaises(greenlet.error) as exc:\n                g.switch()\n            self.assertEqual(str(exc.exception), \"cannot switch to a different thread\")\n        finally:\n            keep_main_alive.set()\n            t.join(10)\n            # XXX: Should handle this automatically.\n            del another[:]\n\n    def test_cannot_delete_parent(self):\n        worker = RawGreenlet(lambda: None)\n        self.assertIs(worker.parent, greenlet.getcurrent())\n\n        with self.assertRaises(AttributeError) as exc:\n            del worker.parent\n        self.assertEqual(str(exc.exception), \"can't delete attribute\")\n\n    def test_cannot_delete_parent_of_main(self):\n        with self.assertRaises(AttributeError) as exc:\n            del greenlet.getcurrent().parent\n        self.assertEqual(str(exc.exception), \"can't delete attribute\")\n\n\n    def test_main_greenlet_parent_is_none(self):\n        # assuming we're in a main greenlet here.\n        self.assertIsNone(greenlet.getcurrent().parent)\n\n    def test_set_parent_wrong_types(self):\n        def bg():\n            # Go back to main.\n            greenlet.getcurrent().parent.switch()\n\n        def check(glet):\n            for p in None, 1, self, \"42\":\n                with self.assertRaises(TypeError) as exc:\n                    glet.parent = p\n\n                self.assertEqual(\n                    str(exc.exception),\n                    \"GreenletChecker: Expected any type of greenlet, not \" + type(p).__name__)\n\n        # First, not running\n        g = RawGreenlet(bg)\n        self.assertFalse(g)\n        check(g)\n\n        # Then when running.\n        g.switch()\n        self.assertTrue(g)\n        check(g)\n\n        # Let it finish\n        g.switch()\n\n\n    def test_trivial_cycle(self):\n        glet = RawGreenlet(lambda: None)\n        with self.assertRaises(ValueError) as exc:\n            glet.parent = glet\n        self.assertEqual(str(exc.exception), \"cyclic parent chain\")\n\n    def test_trivial_cycle_main(self):\n        # This used to produce a ValueError, but we catch it earlier than that now.\n        with self.assertRaises(AttributeError) as exc:\n            greenlet.getcurrent().parent = greenlet.getcurrent()\n        self.assertEqual(str(exc.exception), \"cannot set the parent of a main greenlet\")\n\n    def test_deeper_cycle(self):\n        g1 = RawGreenlet(lambda: None)\n        g2 = RawGreenlet(lambda: None)\n        g3 = RawGreenlet(lambda: None)\n\n        g1.parent = g2\n        g2.parent = g3\n        with self.assertRaises(ValueError) as exc:\n            g3.parent = g1\n        self.assertEqual(str(exc.exception), \"cyclic parent chain\")\n\n\nclass TestRepr(TestCase):\n\n    def assertEndsWith(self, got, suffix):\n        self.assertTrue(got.endswith(suffix), (got, suffix))\n\n    def test_main_while_running(self):\n        r = repr(greenlet.getcurrent())\n        self.assertEndsWith(r, \" current active started main>\")\n\n    def test_main_in_background(self):\n        main = greenlet.getcurrent()\n        def run():\n            return repr(main)\n\n        g = RawGreenlet(run)\n        r = g.switch()\n        self.assertEndsWith(r, ' suspended active started main>')\n\n    def test_initial(self):\n        r = repr(RawGreenlet())\n        self.assertEndsWith(r, ' pending>')\n\n    def test_main_from_other_thread(self):\n        main = greenlet.getcurrent()\n\n        class T(threading.Thread):\n            original_main = thread_main = None\n            main_glet = None\n            def run(self):\n                self.original_main = repr(main)\n                self.main_glet = greenlet.getcurrent()\n                self.thread_main = repr(self.main_glet)\n\n        t = T()\n        t.start()\n        t.join(10)\n\n        self.assertEndsWith(t.original_main, ' suspended active started main>')\n        self.assertEndsWith(t.thread_main, ' current active started main>')\n        # give the machinery time to notice the death of the thread,\n        # and clean it up. Note that we don't use\n        # ``expect_greenlet_leak`` or wait_for_pending_cleanups,\n        # because at this point we know we have an extra greenlet\n        # still reachable.\n        for _ in range(3):\n            time.sleep(0.001)\n\n        # In the past, main greenlets, even from dead threads, never\n        # really appear dead. We have fixed that, and we also report\n        # that the thread is dead in the repr. (Do this multiple times\n        # to make sure that we don't self-modify and forget our state\n        # in the C++ code).\n        for _ in range(3):\n            self.assertTrue(t.main_glet.dead)\n            r = repr(t.main_glet)\n            self.assertEndsWith(r, ' (thread exited) dead>')\n\n    def test_dead(self):\n        g = RawGreenlet(lambda: None)\n        g.switch()\n        self.assertEndsWith(repr(g), ' dead>')\n        self.assertNotIn('suspended', repr(g))\n        self.assertNotIn('started', repr(g))\n        self.assertNotIn('active', repr(g))\n\n    def test_formatting_produces_native_str(self):\n        # https://github.com/python-greenlet/greenlet/issues/218\n        # %s formatting on Python 2 was producing unicode, not str.\n\n        g_dead = RawGreenlet(lambda: None)\n        g_not_started = RawGreenlet(lambda: None)\n        g_cur = greenlet.getcurrent()\n\n        for g in g_dead, g_not_started, g_cur:\n\n            self.assertIsInstance(\n                '%s' % (g,),\n                str\n            )\n            self.assertIsInstance(\n                '%r' % (g,),\n                str,\n            )\n\n\nclass TestMainGreenlet(TestCase):\n    # Tests some implementation details, and relies on some\n    # implementation details.\n\n    def _check_current_is_main(self):\n        # implementation detail\n        assert 'main' in repr(greenlet.getcurrent())\n\n        t = type(greenlet.getcurrent())\n        assert 'main' not in repr(t)\n        return t\n\n    def test_main_greenlet_type_can_be_subclassed(self):\n        main_type = self._check_current_is_main()\n        subclass = type('subclass', (main_type,), {})\n        self.assertIsNotNone(subclass)\n\n    def test_main_greenlet_is_greenlet(self):\n        self._check_current_is_main()\n        self.assertIsInstance(greenlet.getcurrent(), RawGreenlet)\n\n\n\nclass TestBrokenGreenlets(TestCase):\n    # Tests for things that used to, or still do, terminate the interpreter.\n    # This often means doing unsavory things.\n\n    def test_failed_to_initialstub(self):\n        def func():\n            raise AssertionError(\"Never get here\")\n\n\n        g = greenlet._greenlet.UnswitchableGreenlet(func)\n        g.force_switch_error = True\n\n        with self.assertRaisesRegex(SystemError,\n                                    \"Failed to switch stacks into a greenlet for the first time.\"):\n            g.switch()\n\n    def test_failed_to_switch_into_running(self):\n        runs = []\n        def func():\n            runs.append(1)\n            greenlet.getcurrent().parent.switch()\n            runs.append(2)\n            greenlet.getcurrent().parent.switch()\n            runs.append(3) # pragma: no cover\n\n        g = greenlet._greenlet.UnswitchableGreenlet(func)\n        g.switch()\n        self.assertEqual(runs, [1])\n        g.switch()\n        self.assertEqual(runs, [1, 2])\n        g.force_switch_error = True\n\n        with self.assertRaisesRegex(SystemError,\n                                    \"Failed to switch stacks into a running greenlet.\"):\n            g.switch()\n\n        # If we stopped here, we would fail the leakcheck, because we've left\n        # the ``inner_bootstrap()`` C frame and its descendents hanging around,\n        # which have a bunch of Python references. They'll never get cleaned up\n        # if we don't let the greenlet finish.\n        g.force_switch_error = False\n        g.switch()\n        self.assertEqual(runs, [1, 2, 3])\n\n    def test_failed_to_slp_switch_into_running(self):\n        ex = self.assertScriptRaises('fail_slp_switch.py')\n\n        self.assertIn('fail_slp_switch is running', ex.output)\n        self.assertIn(ex.returncode, self.get_expected_returncodes_for_aborted_process())\n\n    def test_reentrant_switch_two_greenlets(self):\n        # Before we started capturing the arguments in g_switch_finish, this could crash.\n        output = self.run_script('fail_switch_two_greenlets.py')\n        self.assertIn('In g1_run', output)\n        self.assertIn('TRACE', output)\n        self.assertIn('LEAVE TRACE', output)\n        self.assertIn('Falling off end of main', output)\n        self.assertIn('Falling off end of g1_run', output)\n        self.assertIn('Falling off end of g2', output)\n\n    def test_reentrant_switch_three_greenlets(self):\n        # On debug builds of greenlet, this used to crash with an assertion error;\n        # on non-debug versions, it ran fine (which it should not do!).\n        # Now it always crashes correctly with a TypeError\n        ex = self.assertScriptRaises('fail_switch_three_greenlets.py', exitcodes=(1,))\n\n        self.assertIn('TypeError', ex.output)\n        self.assertIn('positional arguments', ex.output)\n\n    def test_reentrant_switch_three_greenlets2(self):\n        # This actually passed on debug and non-debug builds. It\n        # should probably have been triggering some debug assertions\n        # but it didn't.\n        #\n        # I think the fixes for the above test also kicked in here.\n        output = self.run_script('fail_switch_three_greenlets2.py')\n        self.assertIn(\n            \"RESULTS: [('trace', 'switch'), \"\n            \"('trace', 'switch'), ('g2 arg', 'g2 from tracefunc'), \"\n            \"('trace', 'switch'), ('main g1', 'from g2_run'), ('trace', 'switch'), \"\n            \"('g1 arg', 'g1 from main'), ('trace', 'switch'), ('main g2', 'from g1_run'), \"\n            \"('trace', 'switch'), ('g1 from parent', 'g1 from main 2'), ('trace', 'switch'), \"\n            \"('main g1.2', 'g1 done'), ('trace', 'switch'), ('g2 from parent', ()), \"\n            \"('trace', 'switch'), ('main g2.2', 'g2 done')]\",\n            output\n        )\n\n    def test_reentrant_switch_GreenletAlreadyStartedInPython(self):\n        output = self.run_script('fail_initialstub_already_started.py')\n\n        self.assertIn(\n            \"RESULTS: ['Begin C', 'Switch to b from B.__getattribute__ in C', \"\n            \"('Begin B', ()), '_B_run switching to main', ('main from c', 'From B'), \"\n            \"'B.__getattribute__ back from main in C', ('Begin A', (None,)), \"\n            \"('A dead?', True, 'B dead?', True, 'C dead?', False), \"\n            \"'C done', ('main from c.2', None)]\",\n            output\n        )\n\n    def test_reentrant_switch_run_callable_has_del(self):\n        output = self.run_script('fail_clearing_run_switches.py')\n        self.assertIn(\n             \"RESULTS [\"\n            \"('G.__getattribute__', 'run'), ('RunCallable', '__del__'), \"\n            \"('main: g.switch()', 'from RunCallable'), ('run_func', 'enter')\"\n            \"]\",\n            output\n        )\n\nif __name__ == '__main__':\n    import unittest\n    unittest.main()\n", "src/greenlet/tests/__init__.py": "# -*- coding: utf-8 -*-\n\"\"\"\nTests for greenlet.\n\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\nimport unittest\n\nfrom gc import collect\nfrom gc import get_objects\nfrom threading import active_count as active_thread_count\nfrom time import sleep\nfrom time import time\n\nimport psutil\n\nfrom greenlet import greenlet as RawGreenlet\nfrom greenlet import getcurrent\n\nfrom greenlet._greenlet import get_pending_cleanup_count\nfrom greenlet._greenlet import get_total_main_greenlets\n\nfrom . import leakcheck\n\nPY312 = sys.version_info[:2] >= (3, 12)\nWIN = sys.platform.startswith(\"win\")\n\nclass TestCaseMetaClass(type):\n    # wrap each test method with\n    # a) leak checks\n    def __new__(cls, classname, bases, classDict):\n        # pylint and pep8 fight over what this should be called (mcs or cls).\n        # pylint gets it right, but we can't scope disable pep8, so we go with\n        # its convention.\n        # pylint: disable=bad-mcs-classmethod-argument\n        check_totalrefcount = True\n\n        # Python 3: must copy, we mutate the classDict. Interestingly enough,\n        # it doesn't actually error out, but under 3.6 we wind up wrapping\n        # and re-wrapping the same items over and over and over.\n        for key, value in list(classDict.items()):\n            if key.startswith('test') and callable(value):\n                classDict.pop(key)\n                if check_totalrefcount:\n                    value = leakcheck.wrap_refcount(value)\n                classDict[key] = value\n        return type.__new__(cls, classname, bases, classDict)\n\n\nclass TestCase(TestCaseMetaClass(\n        \"NewBase\",\n        (unittest.TestCase,),\n        {})):\n\n    cleanup_attempt_sleep_duration = 0.001\n    cleanup_max_sleep_seconds = 1\n\n    def wait_for_pending_cleanups(self,\n                                  initial_active_threads=None,\n                                  initial_main_greenlets=None):\n        initial_active_threads = initial_active_threads or self.threads_before_test\n        initial_main_greenlets = initial_main_greenlets or self.main_greenlets_before_test\n        sleep_time = self.cleanup_attempt_sleep_duration\n        # NOTE: This is racy! A Python-level thread object may be dead\n        # and gone, but the C thread may not yet have fired its\n        # destructors and added to the queue. There's no particular\n        # way to know that's about to happen. We try to watch the\n        # Python threads to make sure they, at least, have gone away.\n        # Counting the main greenlets, which we can easily do deterministically,\n        # also helps.\n\n        # Always sleep at least once to let other threads run\n        sleep(sleep_time)\n        quit_after = time() + self.cleanup_max_sleep_seconds\n        # TODO: We could add an API that calls us back when a particular main greenlet is deleted?\n        # It would have to drop the GIL\n        while (\n                get_pending_cleanup_count()\n                or active_thread_count() > initial_active_threads\n                or (not self.expect_greenlet_leak\n                    and get_total_main_greenlets() > initial_main_greenlets)):\n            sleep(sleep_time)\n            if time() > quit_after:\n                print(\"Time limit exceeded.\")\n                print(\"Threads: Waiting for only\", initial_active_threads,\n                      \"-->\", active_thread_count())\n                print(\"MGlets : Waiting for only\", initial_main_greenlets,\n                      \"-->\", get_total_main_greenlets())\n                break\n        collect()\n\n    def count_objects(self, kind=list, exact_kind=True):\n        # pylint:disable=unidiomatic-typecheck\n        # Collect the garbage.\n        for _ in range(3):\n            collect()\n        if exact_kind:\n            return sum(\n                1\n                for x in get_objects()\n                if type(x) is kind\n            )\n        # instances\n        return sum(\n            1\n            for x in get_objects()\n            if isinstance(x, kind)\n        )\n\n    greenlets_before_test = 0\n    threads_before_test = 0\n    main_greenlets_before_test = 0\n    expect_greenlet_leak = False\n\n    def count_greenlets(self):\n        \"\"\"\n        Find all the greenlets and subclasses tracked by the GC.\n        \"\"\"\n        return self.count_objects(RawGreenlet, False)\n\n    def setUp(self):\n        # Ensure the main greenlet exists, otherwise the first test\n        # gets a false positive leak\n        super().setUp()\n        getcurrent()\n        self.threads_before_test = active_thread_count()\n        self.main_greenlets_before_test = get_total_main_greenlets()\n        self.wait_for_pending_cleanups(self.threads_before_test, self.main_greenlets_before_test)\n        self.greenlets_before_test = self.count_greenlets()\n\n    def tearDown(self):\n        if getattr(self, 'skipTearDown', False):\n            return\n\n        self.wait_for_pending_cleanups(self.threads_before_test, self.main_greenlets_before_test)\n        super().tearDown()\n\n    def get_expected_returncodes_for_aborted_process(self):\n        import signal\n        # The child should be aborted in an unusual way. On POSIX\n        # platforms, this is done with abort() and signal.SIGABRT,\n        # which is reflected in a negative return value; however, on\n        # Windows, even though we observe the child print \"Fatal\n        # Python error: Aborted\" and in older versions of the C\n        # runtime \"This application has requested the Runtime to\n        # terminate it in an unusual way,\" it always has an exit code\n        # of 3. This is interesting because 3 is the error code for\n        # ERROR_PATH_NOT_FOUND; BUT: the C runtime abort() function\n        # also uses this code.\n        #\n        # If we link to the static C library on Windows, the error\n        # code changes to '0xc0000409' (hex(3221226505)), which\n        # apparently is STATUS_STACK_BUFFER_OVERRUN; but \"What this\n        # means is that nowadays when you get a\n        # STATUS_STACK_BUFFER_OVERRUN, it doesn\u2019t actually mean that\n        # there is a stack buffer overrun. It just means that the\n        # application decided to terminate itself with great haste.\"\n        #\n        #\n        # On windows, we've also seen '0xc0000005' (hex(3221225477)).\n        # That's \"Access Violation\"\n        #\n        # See\n        # https://devblogs.microsoft.com/oldnewthing/20110519-00/?p=10623\n        # and\n        # https://docs.microsoft.com/en-us/previous-versions/k089yyh0(v=vs.140)?redirectedfrom=MSDN\n        # and\n        # https://devblogs.microsoft.com/oldnewthing/20190108-00/?p=100655\n        expected_exit = (\n            -signal.SIGABRT,\n            # But beginning on Python 3.11, the faulthandler\n            # that prints the C backtraces sometimes segfaults after\n            # reporting the exception but before printing the stack.\n            # This has only been seen on linux/gcc.\n            -signal.SIGSEGV,\n        ) if not WIN else (\n            3,\n            0xc0000409,\n            0xc0000005,\n        )\n        return expected_exit\n\n    def get_process_uss(self):\n        \"\"\"\n        Return the current process's USS in bytes.\n\n        uss is available on Linux, macOS, Windows. Also known as\n        \"Unique Set Size\", this is the memory which is unique to a\n        process and which would be freed if the process was terminated\n        right now.\n\n        If this is not supported by ``psutil``, this raises the\n        :exc:`unittest.SkipTest` exception.\n        \"\"\"\n        try:\n            return psutil.Process().memory_full_info().uss\n        except AttributeError as e:\n            raise unittest.SkipTest(\"uss not supported\") from e\n\n    def run_script(self, script_name, show_output=True):\n        import subprocess\n        import os\n        script = os.path.join(\n            os.path.dirname(__file__),\n            script_name,\n        )\n\n        try:\n            return subprocess.check_output([sys.executable, script],\n                                           encoding='utf-8',\n                                           stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as ex:\n            if show_output:\n                print('-----')\n                print('Failed to run script', script)\n                print('~~~~~')\n                print(ex.output)\n                print('------')\n            raise\n\n\n    def assertScriptRaises(self, script_name, exitcodes=None):\n        import subprocess\n        with self.assertRaises(subprocess.CalledProcessError) as exc:\n            output = self.run_script(script_name, show_output=False)\n            __traceback_info__ = output\n            # We're going to fail the assertion if we get here, at least\n            # preserve the output in the traceback.\n\n        if exitcodes is None:\n            exitcodes = self.get_expected_returncodes_for_aborted_process()\n        self.assertIn(exc.exception.returncode, exitcodes)\n        return exc.exception\n", "src/greenlet/tests/leakcheck.py": "# Copyright (c) 2018 gevent community\n# Copyright (c) 2021 greenlet community\n#\n# This was originally part of gevent's test suite. The main author\n# (Jason Madden) vendored a copy of it into greenlet.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\nfrom __future__ import print_function\n\nimport os\nimport sys\nimport gc\n\nfrom functools import wraps\nimport unittest\n\n\nimport objgraph\n\n# graphviz 0.18 (Nov 7 2021), available only on Python 3.6 and newer,\n# has added type hints (sigh). It wants to use ``typing.Literal`` for\n# some stuff, but that's only available on Python 3.9+. If that's not\n# found, it creates a ``unittest.mock.MagicMock`` object and annotates\n# with that. These are GC'able objects, and doing almost *anything*\n# with them results in an explosion of objects. For example, trying to\n# compare them for equality creates new objects. This causes our\n# leakchecks to fail, with reports like:\n#\n# greenlet.tests.leakcheck.LeakCheckError: refcount increased by [337, 1333, 343, 430, 530, 643, 769]\n# _Call          1820      +546\n# dict           4094       +76\n# MagicProxy      585       +73\n# tuple          2693       +66\n# _CallList        24        +3\n# weakref        1441        +1\n# function       5996        +1\n# type            736        +1\n# cell            592        +1\n# MagicMock         8        +1\n#\n# To avoid this, we *could* filter this type of object out early. In\n# principle it could leak, but we don't use mocks in greenlet, so it\n# doesn't leak from us. However, a further issue is that ``MagicMock``\n# objects have subobjects that are also GC'able, like ``_Call``, and\n# those create new mocks of their own too. So we'd have to filter them\n# as well, and they're not public. That's OK, we can workaround the\n# problem by being very careful to never compare by equality or other\n# user-defined operators, only using object identity or other builtin\n# functions.\n\nRUNNING_ON_GITHUB_ACTIONS = os.environ.get('GITHUB_ACTIONS')\nRUNNING_ON_TRAVIS = os.environ.get('TRAVIS') or RUNNING_ON_GITHUB_ACTIONS\nRUNNING_ON_APPVEYOR = os.environ.get('APPVEYOR')\nRUNNING_ON_CI = RUNNING_ON_TRAVIS or RUNNING_ON_APPVEYOR\nRUNNING_ON_MANYLINUX = os.environ.get('GREENLET_MANYLINUX')\nSKIP_LEAKCHECKS = RUNNING_ON_MANYLINUX or os.environ.get('GREENLET_SKIP_LEAKCHECKS')\nSKIP_FAILING_LEAKCHECKS = os.environ.get('GREENLET_SKIP_FAILING_LEAKCHECKS')\nONLY_FAILING_LEAKCHECKS = os.environ.get('GREENLET_ONLY_FAILING_LEAKCHECKS')\n\ndef ignores_leakcheck(func):\n    \"\"\"\n    Ignore the given object during leakchecks.\n\n    Can be applied to a method, in which case the method will run, but\n    will not be subject to leak checks.\n\n    If applied to a class, the entire class will be skipped during leakchecks. This\n    is intended to be used for classes that are very slow and cause problems such as\n    test timeouts; typically it will be used for classes that are subclasses of a base\n    class and specify variants of behaviour (such as pool sizes).\n    \"\"\"\n    func.ignore_leakcheck = True\n    return func\n\ndef fails_leakcheck(func):\n    \"\"\"\n    Mark that the function is known to leak.\n    \"\"\"\n    func.fails_leakcheck = True\n    if SKIP_FAILING_LEAKCHECKS:\n        func = unittest.skip(\"Skipping known failures\")(func)\n    return func\n\nclass LeakCheckError(AssertionError):\n    pass\n\nif hasattr(sys, 'getobjects'):\n    # In a Python build with ``--with-trace-refs``, make objgraph\n    # trace *all* the objects, not just those that are tracked by the\n    # GC\n    class _MockGC(object):\n        def get_objects(self):\n            return sys.getobjects(0) # pylint:disable=no-member\n        def __getattr__(self, name):\n            return getattr(gc, name)\n    objgraph.gc = _MockGC()\n    fails_strict_leakcheck = fails_leakcheck\nelse:\n    def fails_strict_leakcheck(func):\n        \"\"\"\n        Decorator for a function that is known to fail when running\n        strict (``sys.getobjects()``) leakchecks.\n\n        This type of leakcheck finds all objects, even those, such as\n        strings, which are not tracked by the garbage collector.\n        \"\"\"\n        return func\n\nclass ignores_types_in_strict_leakcheck(object):\n    def __init__(self, types):\n        self.types = types\n    def __call__(self, func):\n        func.leakcheck_ignore_types = self.types\n        return func\n\nclass _RefCountChecker(object):\n\n    # Some builtin things that we ignore\n    # XXX: Those things were ignored by gevent, but they're important here,\n    # presumably.\n    IGNORED_TYPES = () #(tuple, dict, types.FrameType, types.TracebackType)\n\n    def __init__(self, testcase, function):\n        self.testcase = testcase\n        self.function = function\n        self.deltas = []\n        self.peak_stats = {}\n        self.ignored_types = ()\n\n        # The very first time we are called, we have already been\n        # self.setUp() by the test runner, so we don't need to do it again.\n        self.needs_setUp = False\n\n    def _include_object_p(self, obj):\n        # pylint:disable=too-many-return-statements\n        #\n        # See the comment block at the top. We must be careful to\n        # avoid invoking user-defined operations.\n        if obj is self:\n            return False\n        kind = type(obj)\n        # ``self._include_object_p == obj`` returns NotImplemented\n        # for non-function objects, which causes the interpreter\n        # to try to reverse the order of arguments...which leads\n        # to the explosion of mock objects. We don't want that, so we implement\n        # the check manually.\n        if kind == type(self._include_object_p):\n            try:\n                # pylint:disable=not-callable\n                exact_method_equals = self._include_object_p.__eq__(obj)\n            except AttributeError:\n                # Python 2.7 methods may only have __cmp__, and that raises a\n                # TypeError for non-method arguments\n                # pylint:disable=no-member\n                exact_method_equals = self._include_object_p.__cmp__(obj) == 0\n\n            if exact_method_equals is not NotImplemented and exact_method_equals:\n                return False\n\n        # Similarly, we need to check identity in our __dict__ to avoid mock explosions.\n        for x in self.__dict__.values():\n            if obj is x:\n                return False\n\n\n        if kind in self.ignored_types or kind in self.IGNORED_TYPES:\n            return False\n\n        return True\n\n    def _growth(self):\n        return objgraph.growth(limit=None, peak_stats=self.peak_stats,\n                               filter=self._include_object_p)\n\n    def _report_diff(self, growth):\n        if not growth:\n            return \"<Unable to calculate growth>\"\n\n        lines = []\n        width = max(len(name) for name, _, _ in growth)\n        for name, count, delta in growth:\n            lines.append('%-*s%9d %+9d' % (width, name, count, delta))\n\n        diff = '\\n'.join(lines)\n        return diff\n\n\n    def _run_test(self, args, kwargs):\n        gc_enabled = gc.isenabled()\n        gc.disable()\n\n        if self.needs_setUp:\n            self.testcase.setUp()\n            self.testcase.skipTearDown = False\n        try:\n            self.function(self.testcase, *args, **kwargs)\n        finally:\n            self.testcase.tearDown()\n            self.testcase.doCleanups()\n            self.testcase.skipTearDown = True\n            self.needs_setUp = True\n            if gc_enabled:\n                gc.enable()\n\n    def _growth_after(self):\n        # Grab post snapshot\n        # pylint:disable=no-member\n        if 'urlparse' in sys.modules:\n            sys.modules['urlparse'].clear_cache()\n        if 'urllib.parse' in sys.modules:\n            sys.modules['urllib.parse'].clear_cache()\n\n        return self._growth()\n\n    def _check_deltas(self, growth):\n        # Return false when we have decided there is no leak,\n        # true if we should keep looping, raises an assertion\n        # if we have decided there is a leak.\n\n        deltas = self.deltas\n        if not deltas:\n            # We haven't run yet, no data, keep looping\n            return True\n\n        if gc.garbage:\n            raise LeakCheckError(\"Generated uncollectable garbage %r\" % (gc.garbage,))\n\n\n        # the following configurations are classified as \"no leak\"\n        # [0, 0]\n        # [x, 0, 0]\n        # [... a, b, c, d]  where a+b+c+d = 0\n        #\n        # the following configurations are classified as \"leak\"\n        # [... z, z, z]  where z > 0\n\n        if deltas[-2:] == [0, 0] and len(deltas) in (2, 3):\n            return False\n\n        if deltas[-3:] == [0, 0, 0]:\n            return False\n\n        if len(deltas) >= 4 and sum(deltas[-4:]) == 0:\n            return False\n\n        if len(deltas) >= 3 and deltas[-1] > 0 and deltas[-1] == deltas[-2] and deltas[-2] == deltas[-3]:\n            diff = self._report_diff(growth)\n            raise LeakCheckError('refcount increased by %r\\n%s' % (deltas, diff))\n\n        # OK, we don't know for sure yet. Let's search for more\n        if sum(deltas[-3:]) <= 0 or sum(deltas[-4:]) <= 0 or deltas[-4:].count(0) >= 2:\n            # this is suspicious, so give a few more runs\n            limit = 11\n        else:\n            limit = 7\n        if len(deltas) >= limit:\n            raise LeakCheckError('refcount increased by %r\\n%s'\n                                 % (deltas,\n                                    self._report_diff(growth)))\n\n        # We couldn't decide yet, keep going\n        return True\n\n    def __call__(self, args, kwargs):\n        for _ in range(3):\n            gc.collect()\n\n        expect_failure = getattr(self.function, 'fails_leakcheck', False)\n        if expect_failure:\n            self.testcase.expect_greenlet_leak = True\n        self.ignored_types = getattr(self.function, \"leakcheck_ignore_types\", ())\n\n        # Capture state before; the incremental will be\n        # updated by each call to _growth_after\n        growth = self._growth()\n\n        try:\n            while self._check_deltas(growth):\n                self._run_test(args, kwargs)\n\n                growth = self._growth_after()\n\n                self.deltas.append(sum((stat[2] for stat in growth)))\n        except LeakCheckError:\n            if not expect_failure:\n                raise\n        else:\n            if expect_failure:\n                raise LeakCheckError(\"Expected %s to leak but it did not.\" % (self.function,))\n\ndef wrap_refcount(method):\n    if getattr(method, 'ignore_leakcheck', False) or SKIP_LEAKCHECKS:\n        return method\n\n    @wraps(method)\n    def wrapper(self, *args, **kwargs): # pylint:disable=too-many-branches\n        if getattr(self, 'ignore_leakcheck', False):\n            raise unittest.SkipTest(\"This class ignored during leakchecks\")\n        if ONLY_FAILING_LEAKCHECKS and not getattr(method, 'fails_leakcheck', False):\n            raise unittest.SkipTest(\"Only running tests that fail leakchecks.\")\n        return _RefCountChecker(self, method)(args, kwargs)\n\n    return wrapper\n", "src/greenlet/tests/fail_initialstub_already_started.py": "\"\"\"\nTesting initialstub throwing an already started exception.\n\"\"\"\n\nimport greenlet\n\na = None\nb = None\nc = None\nmain = greenlet.getcurrent()\n\n# If we switch into a dead greenlet,\n# we go looking for its parents.\n# if a parent is not yet started, we start it.\n\nresults = []\n\ndef a_run(*args):\n    #results.append('A')\n    results.append(('Begin A', args))\n\n\ndef c_run():\n    results.append('Begin C')\n    b.switch('From C')\n    results.append('C done')\n\nclass A(greenlet.greenlet): pass\n\nclass B(greenlet.greenlet):\n    doing_it = False\n    def __getattribute__(self, name):\n        if name == 'run' and not self.doing_it:\n            assert greenlet.getcurrent() is c\n            self.doing_it = True\n            results.append('Switch to b from B.__getattribute__ in '\n                           + type(greenlet.getcurrent()).__name__)\n            b.switch()\n            results.append('B.__getattribute__ back from main in '\n                           + type(greenlet.getcurrent()).__name__)\n        if name == 'run':\n            name = '_B_run'\n        return object.__getattribute__(self, name)\n\n    def _B_run(self, *arg):\n        results.append(('Begin B', arg))\n        results.append('_B_run switching to main')\n        main.switch('From B')\n\nclass C(greenlet.greenlet):\n    pass\na = A(a_run)\nb = B(parent=a)\nc = C(c_run, b)\n\n# Start a child; while running, it will start B,\n# but starting B will ALSO start B.\nresult = c.switch()\nresults.append(('main from c', result))\n\n# Switch back to C, which was in the middle of switching\n# already. This will throw the ``GreenletStartedWhileInPython``\n# exception, which results in parent A getting started (B is finished)\nc.switch()\n\nresults.append(('A dead?', a.dead, 'B dead?', b.dead, 'C dead?', c.dead))\n\n# A and B should both be dead now.\nassert a.dead\nassert b.dead\nassert not c.dead\n\nresult = c.switch()\nresults.append(('main from c.2', result))\n# Now C is dead\nassert c.dead\n\nprint(\"RESULTS:\", results)\n", "src/greenlet/tests/test_gc.py": "import gc\n\nimport weakref\n\nimport greenlet\n\n\nfrom . import TestCase\nfrom .leakcheck import fails_leakcheck\n# These only work with greenlet gc support\n# which is no longer optional.\nassert greenlet.GREENLET_USE_GC\n\nclass GCTests(TestCase):\n    def test_dead_circular_ref(self):\n        o = weakref.ref(greenlet.greenlet(greenlet.getcurrent).switch())\n        gc.collect()\n        if o() is not None:\n            import sys\n            print(\"O IS NOT NONE.\", sys.getrefcount(o()))\n        self.assertIsNone(o())\n        self.assertFalse(gc.garbage, gc.garbage)\n\n    def test_circular_greenlet(self):\n        class circular_greenlet(greenlet.greenlet):\n            self = None\n        o = circular_greenlet()\n        o.self = o\n        o = weakref.ref(o)\n        gc.collect()\n        self.assertIsNone(o())\n        self.assertFalse(gc.garbage, gc.garbage)\n\n    def test_inactive_ref(self):\n        class inactive_greenlet(greenlet.greenlet):\n            def __init__(self):\n                greenlet.greenlet.__init__(self, run=self.run)\n\n            def run(self):\n                pass\n        o = inactive_greenlet()\n        o = weakref.ref(o)\n        gc.collect()\n        self.assertIsNone(o())\n        self.assertFalse(gc.garbage, gc.garbage)\n\n    @fails_leakcheck\n    def test_finalizer_crash(self):\n        # This test is designed to crash when active greenlets\n        # are made garbage collectable, until the underlying\n        # problem is resolved. How does it work:\n        # - order of object creation is important\n        # - array is created first, so it is moved to unreachable first\n        # - we create a cycle between a greenlet and this array\n        # - we create an object that participates in gc, is only\n        #   referenced by a greenlet, and would corrupt gc lists\n        #   on destruction, the easiest is to use an object with\n        #   a finalizer\n        # - because array is the first object in unreachable it is\n        #   cleared first, which causes all references to greenlet\n        #   to disappear and causes greenlet to be destroyed, but since\n        #   it is still live it causes a switch during gc, which causes\n        #   an object with finalizer to be destroyed, which causes stack\n        #   corruption and then a crash\n\n        class object_with_finalizer(object):\n            def __del__(self):\n                pass\n        array = []\n        parent = greenlet.getcurrent()\n        def greenlet_body():\n            greenlet.getcurrent().object = object_with_finalizer()\n            try:\n                parent.switch()\n            except greenlet.GreenletExit:\n                print(\"Got greenlet exit!\")\n            finally:\n                del greenlet.getcurrent().object\n        g = greenlet.greenlet(greenlet_body)\n        g.array = array\n        array.append(g)\n        g.switch()\n        del array\n        del g\n        greenlet.getcurrent()\n        gc.collect()\n"}