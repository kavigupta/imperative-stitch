{"setup.py": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nimport sys\nimport os\nimport glob\nimport platform\n\n# distutils is deprecated and vendored into setuptools now.\nfrom setuptools import setup\nfrom setuptools import Extension\nfrom setuptools import find_packages\n\n# Extra compiler arguments passed to *all* extensions.\nglobal_compile_args = []\n\n# Extra compiler arguments passed to C++ extensions\ncpp_compile_args = []\n\n# Extra linker arguments passed to C++ extensions\ncpp_link_args = []\n\n# Extra compiler arguments passed to the main extension\nmain_compile_args = []\n\nis_win = sys.platform.startswith(\"win\")\n\n# workaround segfaults on openbsd and RHEL 3 / CentOS 3 . see\n# https://bitbucket.org/ambroff/greenlet/issue/11/segfault-on-openbsd-i386\n# https://github.com/python-greenlet/greenlet/issues/4\n# https://github.com/python-greenlet/greenlet/issues/94\n# pylint:disable=too-many-boolean-expressions\nis_linux = sys.platform.startswith('linux') # could be linux or linux2\nplat_platform = platform.platform()\nplat_machine = platform.machine()\nplat_compiler = platform.python_compiler()\ntry:\n    # (sysname, nodename, release, version, machine)\n    unam_machine = os.uname()[-1]\nexcept AttributeError:\n    unam_machine = ''\nif (\n       (sys.platform == \"openbsd4\" and unam_machine == \"i386\")\n    or (\"-with-redhat-3.\" in plat_platform and plat_machine == 'i686')\n    or (sys.platform == \"sunos5\" and unam_machine == \"sun4v\") # SysV-based Solaris\n    or (\"SunOS\" in plat_platform and plat_machine == \"sun4v\") # Old BSD-based SunOS\n    or (is_linux and plat_machine == \"ppc\")\n    # https://github.com/python-greenlet/greenlet/pull/300: When compiling for RISC-V the command\n    # ``riscv64-linux-gnu-gcc -pthread -fno-strict-aliasing -Wdate-time \\\n    #   -D_FORTIFY_SOURCE=2 -g -ffile-prefix-map=/build/python2.7-7GU7VT/python2.7-2.7.18=. \\\n    #   -fstack-protector-strong -Wformat -Werror=format-security -fPIC \\\n    #   -I/usr/include/python2.7\n    #   -c src/greenlet/greenlet.cpp  -o build/temp.linux-riscv64-2.7/src/greenlet/greenlet.o``\n    #\n    # fails with:\n    #\n    # src/greenlet/platform/switch_riscv_unix.h:30:1: error: s0 cannot be used in 'asm' here\n    #\n    # Adding the -Os flag fixes the problem.\n    or (is_linux and plat_machine == \"riscv64\")\n):\n    global_compile_args.append(\"-Os\")\n\n\nif sys.platform == 'darwin' or 'clang' in plat_compiler:\n    # The clang compiler doesn't use --std=c++11 by default\n    cpp_compile_args.append(\"--std=gnu++11\")\nelif is_win and \"MSC\" in plat_compiler:\n    # Older versions of MSVC (Python 2.7) don't handle C++ exceptions\n    # correctly by default. While newer versions do handle exceptions\n    # by default, they don't do it fully correctly (\"By default....the\n    # compiler generates code that only partially supports C++\n    # exceptions.\"). So we need an argument on all versions.\n\n    #\"/EH\" == exception handling.\n    #    \"s\" == standard C++,\n    #    \"c\" == extern C functions don't throw\n    # OR\n    #   \"a\" == standard C++, and Windows SEH; anything may throw, compiler optimizations\n    #          around try blocks are less aggressive. Because this catches SEH,\n    #          which Windows uses internally, the MS docs say this can be a security issue.\n    #          DO NOT USE.\n    # /EHsc is suggested, and /EHa isn't supposed to be linked to other things not built\n    # with it. Leaving off the \"c\" should just result in slower, safer code.\n    # Other options:\n    #    \"r\" == Always generate standard confirming checks for noexcept blocks, terminating\n    #           if violated. IMPORTANT: We rely on this.\n    # See https://docs.microsoft.com/en-us/cpp/build/reference/eh-exception-handling-model?view=msvc-170\n    handler = \"/EHsr\"\n    cpp_compile_args.append(handler)\n    # To disable most optimizations:\n    #cpp_compile_args.append('/Od')\n\n    # To enable assertions:\n    #cpp_compile_args.append('/UNDEBUG')\n\n    # To enable more compile-time warnings (/Wall produces a mountain of output).\n    #cpp_compile_args.append('/W4')\n\n    # To link with the debug C runtime...except we can't because we need\n    # the Python debug lib too, and they're not around by default\n    # cpp_compile_args.append('/MDd')\n\n    # Support fiber-safe thread-local storage: \"the compiler mustn't\n    # cache the address of the TLS array, or optimize it as a common\n    # subexpression across a function call.\" This would probably solve\n    # some of the issues we had with MSVC caching the thread local\n    # variables on the stack, leading to having to split some\n    # functions up. Revisit those.\n    cpp_compile_args.append(\"/GT\")\n\ndef readfile(filename):\n    with open(filename, 'r') as f: # pylint:disable=unspecified-encoding\n        return f.read()\n\nGREENLET_SRC_DIR = 'src/greenlet/'\nGREENLET_HEADER_DIR = GREENLET_SRC_DIR\nGREENLET_HEADER = GREENLET_HEADER_DIR + 'greenlet.h'\nGREENLET_TEST_DIR = 'src/greenlet/tests/'\n# The location of the platform specific assembly files\n# for switching.\nGREENLET_PLATFORM_DIR = GREENLET_SRC_DIR + 'platform/'\n\ndef _find_platform_headers():\n    return glob.glob(GREENLET_PLATFORM_DIR + \"switch_*.h\")\n\ndef _find_impl_headers():\n    return glob.glob(GREENLET_SRC_DIR + \"*.hpp\") + glob.glob(GREENLET_SRC_DIR + \"*.cpp\")\n\nif hasattr(sys, \"pypy_version_info\"):\n    ext_modules = []\n    headers = []\nelse:\n\n    headers = [GREENLET_HEADER]\n\n    if is_win and '64 bit' in sys.version:\n        # this works when building with msvc, not with 64 bit gcc\n        # switch_<platform>_masm.obj can be created with setup_switch_<platform>_masm.cmd\n        obj_fn = 'switch_arm64_masm.obj' if plat_machine == 'ARM64' else 'switch_x64_masm.obj'\n        extra_objects = [os.path.join(GREENLET_PLATFORM_DIR, obj_fn)]\n    else:\n        extra_objects = []\n\n    if is_win and os.environ.get('GREENLET_STATIC_RUNTIME') in ('1', 'yes'):\n        main_compile_args.append('/MT')\n    elif unam_machine in ('ppc64el', 'ppc64le'):\n        main_compile_args.append('-fno-tree-dominator-opts')\n\n    ext_modules = [\n        Extension(\n            name='greenlet._greenlet',\n            sources=[\n                GREENLET_SRC_DIR + 'greenlet.cpp',\n            ],\n            language='c++',\n            extra_objects=extra_objects,\n            extra_compile_args=global_compile_args + main_compile_args + cpp_compile_args,\n            extra_link_args=cpp_link_args,\n            depends=[\n                GREENLET_HEADER,\n                GREENLET_SRC_DIR + 'slp_platformselect.h',\n            ] + _find_platform_headers() + _find_impl_headers(),\n            define_macros=[\n            ] + ([\n                ('WIN32', '1'),\n            ] if is_win else [\n            ])\n        ),\n        # Test extensions.\n        #\n        # We used to try hard to not include these in built\n        # distributions, because we only distributed ``greenlet.so``.\n        # That's really not important, now we have a clean layout with\n        # the test directory nested inside a greenlet directory. See\n        # https://github.com/python-greenlet/greenlet/issues/184 and\n        # 189\n        Extension(\n            name='greenlet.tests._test_extension',\n            sources=[GREENLET_TEST_DIR + '_test_extension.c'],\n            include_dirs=[GREENLET_HEADER_DIR],\n            extra_compile_args=global_compile_args,\n        ),\n        Extension(\n            name='greenlet.tests._test_extension_cpp',\n            sources=[GREENLET_TEST_DIR + '_test_extension_cpp.cpp'],\n            language=\"c++\",\n            include_dirs=[GREENLET_HEADER_DIR],\n            extra_compile_args=global_compile_args + cpp_compile_args,\n            extra_link_args=cpp_link_args,\n        ),\n    ]\n\n\ndef get_greenlet_version():\n    with open('src/greenlet/__init__.py') as f: # pylint:disable=unspecified-encoding\n        looking_for = '__version__ = \\''\n        for line in f:\n            if line.startswith(looking_for):\n                version = line[len(looking_for):-2]\n                return version\n    raise ValueError(\"Unable to find version\")\n\n\nsetup(\n    name=\"greenlet\",\n    version=get_greenlet_version(),\n    description='Lightweight in-process concurrent programming',\n    long_description=readfile(\"README.rst\"),\n    long_description_content_type=\"text/x-rst\",\n    url=\"https://greenlet.readthedocs.io/\",\n    keywords=\"greenlet coroutine concurrency threads cooperative\",\n    author=\"Alexey Borzenkov\",\n    author_email=\"snaury@gmail.com\",\n    maintainer='Jason Madden',\n    maintainer_email='jason@seecoresoftware.com',\n    project_urls={\n        'Bug Tracker': 'https://github.com/python-greenlet/greenlet/issues',\n        'Source Code': 'https://github.com/python-greenlet/greenlet/',\n        'Documentation': 'https://greenlet.readthedocs.io/',\n    },\n    license=\"MIT License\",\n    platforms=['any'],\n    package_dir={'': 'src'},\n    packages=find_packages('src'),\n    include_package_data=True,\n    headers=headers,\n    ext_modules=ext_modules,\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Natural Language :: English',\n        'Programming Language :: C',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Operating System :: OS Independent',\n        'Topic :: Software Development :: Libraries :: Python Modules'\n    ],\n    extras_require={\n        'docs': [\n            'Sphinx',\n            'furo',\n        ],\n        'test': [\n            'objgraph',\n            'psutil',\n        ],\n    },\n    python_requires=\">=3.7\",\n    zip_safe=False,\n)\n", "benchmarks/chain.py": "#!/usr/bin/env python\n\"\"\"\nCreate a chain of coroutines and pass a value from one end to the\nother, where each coroutine will increment the value before passing it\nalong.\n\"\"\"\n\nimport os\nimport pyperf\nimport greenlet\n\n# This is obsolete now, we always expose frames for Python 3.12.\n# See https://github.com/python-greenlet/greenlet/pull/393/\n# for a complete discussion of performance.\nEXPOSE_FRAMES = 'EXPOSE_FRAMES' in os.environ\n\n# Exposing\n# 100 frames Mean +- std dev: 5.62 us +- 0.10 us\n# 200 frames Mean +- std dev: 14.0 us +- 0.6 us\n# 300 frames Mean +- std dev: 22.7 us +- 0.4 us\n#\n# Non-exposing\n# 100 frames Mean +- std dev: 3.64 us +- 0.06 us -> 1.54/1.98us\n# 200 frames Mean +- std dev: 9.49 us +- 0.13 us -> 1.47/4.51us\n# 300 frames Mean +- std dev: 15.7 us +- 0.3 us  -> 1.45/7us\n\ndef link(next_greenlet):\n    value = greenlet.getcurrent().parent.switch()\n    next_greenlet.switch(value + 1)\n\n\nCHAIN_GREENLET_COUNT = 100000\n\ndef bm_chain(loops):\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n        start_node = greenlet.getcurrent()\n        for _ in range(CHAIN_GREENLET_COUNT):\n            g = greenlet.greenlet(link)\n            g.gr_frames_always_exposed = EXPOSE_FRAMES\n            g.switch(start_node)\n            start_node = g\n        x = start_node.switch(0)\n        assert x == CHAIN_GREENLET_COUNT\n    end = pyperf.perf_counter()\n    return end - begin\n\nGETCURRENT_INNER_LOOPS = 10\ndef bm_getcurrent(loops):\n    getcurrent = greenlet.getcurrent\n    getcurrent() # Factor out the overhead of creating the initial main greenlet\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n        # Manual unroll\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n        getcurrent()\n    end = pyperf.perf_counter()\n    return end - begin\n\nSWITCH_INNER_LOOPS = 10000\ndef bm_switch_shallow(loops):\n    # pylint:disable=attribute-defined-outside-init\n    class G(greenlet.greenlet):\n        other = None\n        def run(self):\n            o = self.other\n            for _ in range(SWITCH_INNER_LOOPS):\n                o.switch()\n\n    begin = pyperf.perf_counter()\n\n    for _ in range(loops):\n        gl1 = G()\n        gl2 = G()\n        gl1.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl2.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl1.other = gl2\n        gl2.other = gl1\n        gl1.switch()\n\n        gl1.switch()\n        gl2.switch()\n        gl1.other = gl2.other = None\n        assert gl1.dead\n        assert gl2.dead\n\n    end = pyperf.perf_counter()\n    return end - begin\n\ndef bm_switch_deep(loops, _MAX_DEPTH=200):\n    # pylint:disable=attribute-defined-outside-init\n    class G(greenlet.greenlet):\n        other = None\n        def run(self):\n            for _ in range(SWITCH_INNER_LOOPS):\n                self.recur_then_switch()\n\n        def recur_then_switch(self, depth=_MAX_DEPTH):\n            if not depth:\n                self.other.switch()\n            else:\n                self.recur_then_switch(depth - 1)\n\n    begin = pyperf.perf_counter()\n\n    for _ in range(loops):\n        gl1 = G()\n        gl2 = G()\n        gl1.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl2.gr_frames_always_exposed = EXPOSE_FRAMES\n        gl1.other = gl2\n        gl2.other = gl1\n        gl1.switch()\n\n        gl1.switch()\n        gl2.switch()\n        gl1.other = gl2.other = None\n        assert gl1.dead\n        assert gl2.dead\n\n    end = pyperf.perf_counter()\n    return end - begin\n\ndef bm_switch_deeper(loops):\n    return bm_switch_deep(loops, 400)\n\n\nCREATE_INNER_LOOPS = 10\ndef bm_create(loops):\n    gl = greenlet.greenlet\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n        gl()\n    end = pyperf.perf_counter()\n    return end - begin\n\n\n\n\ndef _bm_recur_frame(loops, RECUR_DEPTH):\n\n    def recur(depth):\n        if not depth:\n            return greenlet.getcurrent().parent.switch(greenlet.getcurrent())\n        return recur(depth - 1)\n\n\n    begin = pyperf.perf_counter()\n    for _ in range(loops):\n\n        for _ in range(CHAIN_GREENLET_COUNT):\n            g = greenlet.greenlet(recur)\n            g.gr_frames_always_exposed = EXPOSE_FRAMES\n            g2 = g.switch(RECUR_DEPTH)\n            assert g2 is g, (g2, g)\n            f = g2.gr_frame\n            assert f is not None, \"frame is none\"\n            count = 0\n            while f:\n                count += 1\n                f = f.f_back\n            # This assertion fails with the released versions of greenlet\n            # on Python 3.12\n            #assert count == RECUR_DEPTH + 1, (count, RECUR_DEPTH)\n            # Switch back so it can be collected; otherwise they build\n            # up forever.\n            g.switch()\n            # fall off the end of it and back to us.\n            del g\n            del g2\n            del f\n\n\n    end = pyperf.perf_counter()\n    return end - begin\n\ndef bm_recur_frame_2(loops):\n    return _bm_recur_frame(loops, 2)\n\ndef bm_recur_frame_20(loops):\n    return _bm_recur_frame(loops, 20)\n\ndef bm_recur_frame_200(loops):\n    return _bm_recur_frame(loops, 200)\n\nif __name__ == '__main__':\n    runner = pyperf.Runner()\n\n    runner.bench_time_func(\n        'create a greenlet',\n        bm_create,\n        inner_loops=CREATE_INNER_LOOPS\n    )\n\n    runner.bench_time_func(\n        'switch between two greenlets (shallow)',\n        bm_switch_shallow,\n        inner_loops=SWITCH_INNER_LOOPS\n    )\n\n    runner.bench_time_func(\n        'switch between two greenlets (deep)',\n        bm_switch_deep,\n        inner_loops=SWITCH_INNER_LOOPS\n    )\n\n    runner.bench_time_func(\n        'switch between two greenlets (deeper)',\n        bm_switch_deeper,\n        inner_loops=SWITCH_INNER_LOOPS\n    )\n    runner.bench_time_func(\n        'getcurrent single thread',\n        bm_getcurrent,\n        inner_loops=GETCURRENT_INNER_LOOPS\n    )\n    runner.bench_time_func(\n        'chain(%s)' % CHAIN_GREENLET_COUNT,\n        bm_chain,\n    )\n\n    runner.bench_time_func(\n        'read 2 nested frames',\n        bm_recur_frame_2,\n    )\n\n    runner.bench_time_func(\n        'read 20 nested frames',\n        bm_recur_frame_20,\n    )\n    runner.bench_time_func(\n        'read 200 nested frames',\n        bm_recur_frame_200,\n    )\n", "src/greenlet/__init__.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThe root of the greenlet package.\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n__all__ = [\n    '__version__',\n    '_C_API',\n\n    'GreenletExit',\n    'error',\n\n    'getcurrent',\n    'greenlet',\n\n    'gettrace',\n    'settrace',\n]\n\n# pylint:disable=no-name-in-module\n\n###\n# Metadata\n###\n__version__ = '3.0.4.dev0'\nfrom ._greenlet import _C_API # pylint:disable=no-name-in-module\n\n###\n# Exceptions\n###\nfrom ._greenlet import GreenletExit\nfrom ._greenlet import error\n\n###\n# greenlets\n###\nfrom ._greenlet import getcurrent\nfrom ._greenlet import greenlet\n\n###\n# tracing\n###\ntry:\n    from ._greenlet import gettrace\n    from ._greenlet import settrace\nexcept ImportError:\n    # Tracing wasn't supported.\n    # XXX: The option to disable it was removed in 1.0,\n    # so this branch should be dead code.\n    pass\n\n###\n# Constants\n# These constants aren't documented and aren't recommended.\n# In 1.0, USE_GC and USE_TRACING are always true, and USE_CONTEXT_VARS\n# is the same as ``sys.version_info[:2] >= 3.7``\n###\nfrom ._greenlet import GREENLET_USE_CONTEXT_VARS # pylint:disable=unused-import\nfrom ._greenlet import GREENLET_USE_GC # pylint:disable=unused-import\nfrom ._greenlet import GREENLET_USE_TRACING # pylint:disable=unused-import\n\n# Controlling the use of the gc module. Provisional API for this greenlet\n# implementation in 2.0.\nfrom ._greenlet import CLOCKS_PER_SEC # pylint:disable=unused-import\nfrom ._greenlet import enable_optional_cleanup # pylint:disable=unused-import\nfrom ._greenlet import get_clocks_used_doing_optional_cleanup # pylint:disable=unused-import\n\n# Other APIS in the _greenlet module are for test support.\n", "src/greenlet/platform/__init__.py": ""}