{"src/platformdirs/windows.py": "\"\"\"Windows.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n\n\nclass Windows(PlatformDirsABC):\n    \"\"\"\n    `MSDN on where to store app data files <https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid>`_.\n\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `appauthor\n    <platformdirs.api.PlatformDirsABC.appauthor>`, `version <platformdirs.api.PlatformDirsABC.version>`, `roaming\n    <platformdirs.api.PlatformDirsABC.roaming>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists\n    <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname`` (not roaming) or\n         ``%USERPROFILE%\\\\AppData\\\\Roaming\\\\$appauthor\\\\$appname`` (roaming)\n        \"\"\"\n        const = \"CSIDL_APPDATA\" if self.roaming else \"CSIDL_LOCAL_APPDATA\"\n        path = os.path.normpath(get_win_folder(const))\n        return self._append_parts(path)\n\n    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:\n        params = []\n        if self.appname:\n            if self.appauthor is not False:\n                author = self.appauthor or self.appname\n                params.append(author)\n            params.append(self.appname)\n            if opinion_value is not None and self.opinion:\n                params.append(opinion_value)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(path, *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\n        \"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_LOCAL_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it\"\"\"\n        path = self.user_data_dir\n        if self.opinion:\n            path = os.path.join(path, \"Logs\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``%USERPROFILE%\\\\Documents``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_PERSONAL\"))\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``%USERPROFILE%\\\\Downloads``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DOWNLOADS\"))\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``%USERPROFILE%\\\\Pictures``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYPICTURES\"))\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``%USERPROFILE%\\\\Videos``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYVIDEO\"))\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``%USERPROFILE%\\\\Music``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYMUSIC\"))\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``%USERPROFILE%\\\\Desktop``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DESKTOPDIRECTORY\"))\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\Temp\\\\$appauthor\\\\$appname``\n        \"\"\"\n        path = os.path.normpath(os.path.join(get_win_folder(\"CSIDL_LOCAL_APPDATA\"), \"Temp\"))  # noqa: PTH118\n        return self._append_parts(path)\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\ndef get_win_folder_from_env_vars(csidl_name: str) -> str:\n    \"\"\"Get folder from environment variables.\"\"\"\n    result = get_win_folder_if_csidl_name_not_env_var(csidl_name)\n    if result is not None:\n        return result\n\n    env_var_name = {\n        \"CSIDL_APPDATA\": \"APPDATA\",\n        \"CSIDL_COMMON_APPDATA\": \"ALLUSERSPROFILE\",\n        \"CSIDL_LOCAL_APPDATA\": \"LOCALAPPDATA\",\n    }.get(csidl_name)\n    if env_var_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    result = os.environ.get(env_var_name)\n    if result is None:\n        msg = f\"Unset environment variable: {env_var_name}\"\n        raise ValueError(msg)\n    return result\n\n\ndef get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:\n    \"\"\"Get a folder for a CSIDL name that does not exist as an environment variable.\"\"\"\n    if csidl_name == \"CSIDL_PERSONAL\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Documents\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Downloads\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYPICTURES\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Pictures\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYVIDEO\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Videos\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYMUSIC\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Music\")  # noqa: PTH118\n    return None\n\n\ndef get_win_folder_from_registry(csidl_name: str) -> str:\n    \"\"\"\n    Get folder from the registry.\n\n    This is a fallback technique at best. I'm not sure if using the registry for these guarantees us the correct answer\n    for all CSIDL_* names.\n\n    \"\"\"\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n        \"CSIDL_PERSONAL\": \"Personal\",\n        \"CSIDL_DOWNLOADS\": \"{374DE290-123F-4565-9164-39C4925E467B}\",\n        \"CSIDL_MYPICTURES\": \"My Pictures\",\n        \"CSIDL_MYVIDEO\": \"My Video\",\n        \"CSIDL_MYMUSIC\": \"My Music\",\n    }.get(csidl_name)\n    if shell_folder_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    if sys.platform != \"win32\":  # only needed for mypy type checker to know that this code runs only on Windows\n        raise NotImplementedError\n    import winreg  # noqa: PLC0415\n\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\")\n    directory, _ = winreg.QueryValueEx(key, shell_folder_name)\n    return str(directory)\n\n\ndef get_win_folder_via_ctypes(csidl_name: str) -> str:\n    \"\"\"Get folder with ctypes.\"\"\"\n    # There is no 'CSIDL_DOWNLOADS'.\n    # Use 'CSIDL_PROFILE' (40) and append the default folder 'Downloads' instead.\n    # https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid\n\n    import ctypes  # noqa: PLC0415\n\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n        \"CSIDL_PERSONAL\": 5,\n        \"CSIDL_MYPICTURES\": 39,\n        \"CSIDL_MYVIDEO\": 14,\n        \"CSIDL_MYMUSIC\": 13,\n        \"CSIDL_DOWNLOADS\": 40,\n        \"CSIDL_DESKTOPDIRECTORY\": 16,\n    }.get(csidl_name)\n    if csidl_const is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n\n    buf = ctypes.create_unicode_buffer(1024)\n    windll = getattr(ctypes, \"windll\")  # noqa: B009 # using getattr to avoid false positive with mypy type checker\n    windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if it has high-bit chars.\n    if any(ord(c) > 255 for c in buf):  # noqa: PLR2004\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(buf.value, \"Downloads\")  # noqa: PTH118\n\n    return buf.value\n\n\ndef _pick_get_win_folder() -> Callable[[str], str]:\n    try:\n        import ctypes  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        if hasattr(ctypes, \"windll\"):\n            return get_win_folder_via_ctypes\n    try:\n        import winreg  # noqa: PLC0415, F401\n    except ImportError:\n        return get_win_folder_from_env_vars\n    else:\n        return get_win_folder_from_registry\n\n\nget_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())\n\n__all__ = [\n    \"Windows\",\n]\n", "src/platformdirs/macos.py": "\"\"\"macOS.\"\"\"\n\nfrom __future__ import annotations\n\nimport os.path\nimport sys\n\nfrom .api import PlatformDirsABC\n\n\nclass MacOS(PlatformDirsABC):\n    \"\"\"\n    Platform directories for the macOS operating system.\n\n    Follows the guidance from\n    `Apple documentation <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Application Support\"))  # noqa: PTH111\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory shared by users, e.g. ``/Library/Application Support/$appname/$version``.\n          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory\n          will be under the Homebrew prefix, e.g. ``/opt/homebrew/share/$appname/$version``.\n          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,\n          the response is a multi-path string separated by \":\", e.g.\n          ``/opt/homebrew/share/$appname/$version:/Library/Application Support/$appname/$version``\n        \"\"\"\n        is_homebrew = sys.prefix.startswith(\"/opt/homebrew\")\n        path_list = [self._append_app_name_and_version(\"/opt/homebrew/share\")] if is_homebrew else []\n        path_list.append(self._append_app_name_and_version(\"/Library/Application Support\"))\n        if self.multipath:\n            return os.pathsep.join(path_list)\n        return path_list[0]\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g. ``~/Library/Caches/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches\"))  # noqa: PTH111\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory shared by users, e.g. ``/Library/Caches/$appname/$version``.\n          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory\n          will be under the Homebrew prefix, e.g. ``/opt/homebrew/var/cache/$appname/$version``.\n          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,\n          the response is a multi-path string separated by \":\", e.g.\n          ``/opt/homebrew/var/cache/$appname/$version:/Library/Caches/$appname/$version``\n        \"\"\"\n        is_homebrew = sys.prefix.startswith(\"/opt/homebrew\")\n        path_list = [self._append_app_name_and_version(\"/opt/homebrew/var/cache\")] if is_homebrew else []\n        path_list.append(self._append_app_name_and_version(\"/Library/Caches\"))\n        if self.multipath:\n            return os.pathsep.join(path_list)\n        return path_list[0]\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, e.g. ``~/Library/Logs/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Logs\"))  # noqa: PTH111\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return os.path.expanduser(\"~/Documents\")  # noqa: PTH111\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user, e.g. ``~/Downloads``\"\"\"\n        return os.path.expanduser(\"~/Downloads\")  # noqa: PTH111\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user, e.g. ``~/Pictures``\"\"\"\n        return os.path.expanduser(\"~/Pictures\")  # noqa: PTH111\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user, e.g. ``~/Movies``\"\"\"\n        return os.path.expanduser(\"~/Movies\")  # noqa: PTH111\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user, e.g. ``~/Music``\"\"\"\n        return os.path.expanduser(\"~/Music\")  # noqa: PTH111\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``~/Desktop``\"\"\"\n        return os.path.expanduser(\"~/Desktop\")  # noqa: PTH111\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user, e.g. ``~/Library/Caches/TemporaryItems/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches/TemporaryItems\"))  # noqa: PTH111\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\n__all__ = [\n    \"MacOS\",\n]\n", "src/platformdirs/api.py": "\"\"\"Base API.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Iterator, Literal\n\n\nclass PlatformDirsABC(ABC):  # noqa: PLR0904\n    \"\"\"Abstract base class for platform directories.\"\"\"\n\n    def __init__(  # noqa: PLR0913, PLR0917\n        self,\n        appname: str | None = None,\n        appauthor: str | None | Literal[False] = None,\n        version: str | None = None,\n        roaming: bool = False,  # noqa: FBT001, FBT002\n        multipath: bool = False,  # noqa: FBT001, FBT002\n        opinion: bool = True,  # noqa: FBT001, FBT002\n        ensure_exists: bool = False,  # noqa: FBT001, FBT002\n    ) -> None:\n        \"\"\"\n        Create a new platform directory.\n\n        :param appname: See `appname`.\n        :param appauthor: See `appauthor`.\n        :param version: See `version`.\n        :param roaming: See `roaming`.\n        :param multipath: See `multipath`.\n        :param opinion: See `opinion`.\n        :param ensure_exists: See `ensure_exists`.\n\n        \"\"\"\n        self.appname = appname  #: The name of application.\n        self.appauthor = appauthor\n        \"\"\"\n        The name of the app author or distributing body for this application.\n\n        Typically, it is the owning company name. Defaults to `appname`. You may pass ``False`` to disable it.\n\n        \"\"\"\n        self.version = version\n        \"\"\"\n        An optional version path element to append to the path.\n\n        You might want to use this if you want multiple versions of your app to be able to run independently. If used,\n        this would typically be ``<major>.<minor>``.\n\n        \"\"\"\n        self.roaming = roaming\n        \"\"\"\n        Whether to use the roaming appdata directory on Windows.\n\n        That means that for users on a Windows network setup for roaming profiles, this user data will be synced on\n        login (see\n        `here <https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>`_).\n\n        \"\"\"\n        self.multipath = multipath\n        \"\"\"\n        An optional parameter which indicates that the entire list of data dirs should be returned.\n\n        By default, the first item would only be returned.\n\n        \"\"\"\n        self.opinion = opinion  #: A flag to indicating to use opinionated values.\n        self.ensure_exists = ensure_exists\n        \"\"\"\n        Optionally create the directory (and any missing parents) upon access if it does not exist.\n\n        By default, no directories are created.\n\n        \"\"\"\n\n    def _append_app_name_and_version(self, *base: str) -> str:\n        params = list(base[1:])\n        if self.appname:\n            params.append(self.appname)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(base[0], *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    def _optionally_create_directory(self, path: str) -> None:\n        if self.ensure_exists:\n            Path(path).mkdir(parents=True, exist_ok=True)\n\n    @property\n    @abstractmethod\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users\"\"\"\n\n    @property\n    def user_data_path(self) -> Path:\n        \"\"\":return: data path tied to the user\"\"\"\n        return Path(self.user_data_dir)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users\"\"\"\n        return Path(self.site_data_dir)\n\n    @property\n    def user_config_path(self) -> Path:\n        \"\"\":return: config path tied to the user\"\"\"\n        return Path(self.user_config_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users\"\"\"\n        return Path(self.site_config_dir)\n\n    @property\n    def user_cache_path(self) -> Path:\n        \"\"\":return: cache path tied to the user\"\"\"\n        return Path(self.user_cache_dir)\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users\"\"\"\n        return Path(self.site_cache_dir)\n\n    @property\n    def user_state_path(self) -> Path:\n        \"\"\":return: state path tied to the user\"\"\"\n        return Path(self.user_state_dir)\n\n    @property\n    def user_log_path(self) -> Path:\n        \"\"\":return: log path tied to the user\"\"\"\n        return Path(self.user_log_dir)\n\n    @property\n    def user_documents_path(self) -> Path:\n        \"\"\":return: documents a path tied to the user\"\"\"\n        return Path(self.user_documents_dir)\n\n    @property\n    def user_downloads_path(self) -> Path:\n        \"\"\":return: downloads path tied to the user\"\"\"\n        return Path(self.user_downloads_dir)\n\n    @property\n    def user_pictures_path(self) -> Path:\n        \"\"\":return: pictures path tied to the user\"\"\"\n        return Path(self.user_pictures_dir)\n\n    @property\n    def user_videos_path(self) -> Path:\n        \"\"\":return: videos path tied to the user\"\"\"\n        return Path(self.user_videos_dir)\n\n    @property\n    def user_music_path(self) -> Path:\n        \"\"\":return: music path tied to the user\"\"\"\n        return Path(self.user_music_dir)\n\n    @property\n    def user_desktop_path(self) -> Path:\n        \"\"\":return: desktop path tied to the user\"\"\"\n        return Path(self.user_desktop_dir)\n\n    @property\n    def user_runtime_path(self) -> Path:\n        \"\"\":return: runtime path tied to the user\"\"\"\n        return Path(self.user_runtime_dir)\n\n    @property\n    def site_runtime_path(self) -> Path:\n        \"\"\":return: runtime path shared by users\"\"\"\n        return Path(self.site_runtime_dir)\n\n    def iter_config_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site configuration directories.\"\"\"\n        yield self.user_config_dir\n        yield self.site_config_dir\n\n    def iter_data_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site data directories.\"\"\"\n        yield self.user_data_dir\n        yield self.site_data_dir\n\n    def iter_cache_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site cache directories.\"\"\"\n        yield self.user_cache_dir\n        yield self.site_cache_dir\n\n    def iter_runtime_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site runtime directories.\"\"\"\n        yield self.user_runtime_dir\n        yield self.site_runtime_dir\n\n    def iter_config_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site configuration paths.\"\"\"\n        for path in self.iter_config_dirs():\n            yield Path(path)\n\n    def iter_data_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site data paths.\"\"\"\n        for path in self.iter_data_dirs():\n            yield Path(path)\n\n    def iter_cache_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site cache paths.\"\"\"\n        for path in self.iter_cache_dirs():\n            yield Path(path)\n\n    def iter_runtime_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site runtime paths.\"\"\"\n        for path in self.iter_runtime_dirs():\n            yield Path(path)\n", "src/platformdirs/unix.py": "\"\"\"Unix.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom configparser import ConfigParser\nfrom pathlib import Path\nfrom typing import Iterator, NoReturn\n\nfrom .api import PlatformDirsABC\n\nif sys.platform == \"win32\":\n\n    def getuid() -> NoReturn:\n        msg = \"should only be used on Unix\"\n        raise RuntimeError(msg)\n\nelse:\n    from os import getuid\n\n\nclass Unix(PlatformDirsABC):  # noqa: PLR0904\n    \"\"\"\n    On Unix/Linux, we follow the `XDG Basedir Spec <https://specifications.freedesktop.org/basedir-spec/basedir-spec-\n    latest.html>`_.\n\n    The spec allows overriding directories with environment variables. The examples shown are the default values,\n    alongside the name of the environment variable that overrides them. Makes use of the `appname\n    <platformdirs.api.PlatformDirsABC.appname>`, `version <platformdirs.api.PlatformDirsABC.version>`, `multipath\n    <platformdirs.api.PlatformDirsABC.multipath>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists\n    <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g. ``~/.local/share/$appname/$version`` or\n         ``$XDG_DATA_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_DATA_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/share\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def _site_data_dirs(self) -> list[str]:\n        path = os.environ.get(\"XDG_DATA_DIRS\", \"\")\n        if not path.strip():\n            path = f\"/usr/local/share{os.pathsep}/usr/share\"\n        return [self._append_app_name_and_version(p) for p in path.split(os.pathsep)]\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>` is\n         enabled and ``XDG_DATA_DIRS`` is set and a multi path the response is also a multi path separated by the\n         OS path separator), e.g. ``/usr/local/share/$appname/$version`` or ``/usr/share/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_DATA_DIRS; only first, if multipath is False\n        dirs = self._site_data_dirs\n        if not self.multipath:\n            return dirs[0]\n        return os.pathsep.join(dirs)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. ``~/.config/$appname/$version`` or\n         ``$XDG_CONFIG_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CONFIG_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.config\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def _site_config_dirs(self) -> list[str]:\n        path = os.environ.get(\"XDG_CONFIG_DIRS\", \"\")\n        if not path.strip():\n            path = \"/etc/xdg\"\n        return [self._append_app_name_and_version(p) for p in path.split(os.pathsep)]\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\"\n        :return: config directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>`\n         is enabled and ``XDG_CONFIG_DIRS`` is set and a multi path the response is also a multi path separated by\n         the OS path separator), e.g. ``/etc/xdg/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_CONFIG_DIRS only first, if multipath is False\n        dirs = self._site_config_dirs\n        if not self.multipath:\n            return dirs[0]\n        return os.pathsep.join(dirs)\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user, e.g. ``~/.cache/$appname/$version`` or\n         ``~/$XDG_CACHE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CACHE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.cache\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``/var/cache/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(\"/var/cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\"\n        :return: state directory tied to the user, e.g. ``~/.local/state/$appname/$version`` or\n         ``$XDG_STATE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_STATE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/state\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_state_dir` if not opinionated else ``log`` in it\"\"\"\n        path = self.user_state_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return _get_user_media_dir(\"XDG_DOCUMENTS_DIR\", \"~/Documents\")\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user, e.g. ``~/Downloads``\"\"\"\n        return _get_user_media_dir(\"XDG_DOWNLOAD_DIR\", \"~/Downloads\")\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user, e.g. ``~/Pictures``\"\"\"\n        return _get_user_media_dir(\"XDG_PICTURES_DIR\", \"~/Pictures\")\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user, e.g. ``~/Videos``\"\"\"\n        return _get_user_media_dir(\"XDG_VIDEOS_DIR\", \"~/Videos\")\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user, e.g. ``~/Music``\"\"\"\n        return _get_user_media_dir(\"XDG_MUSIC_DIR\", \"~/Music\")\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``~/Desktop``\"\"\"\n        return _get_user_media_dir(\"XDG_DESKTOP_DIR\", \"~/Desktop\")\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g. ``/run/user/$(id -u)/$appname/$version`` or\n         ``$XDG_RUNTIME_DIR/$appname/$version``.\n\n         For FreeBSD/OpenBSD/NetBSD, it would return ``/var/run/user/$(id -u)/$appname/$version`` if\n         exists, otherwise ``/tmp/runtime-$(id -u)/$appname/$version``, if``$XDG_RUNTIME_DIR``\n         is not set.\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            if sys.platform.startswith((\"freebsd\", \"openbsd\", \"netbsd\")):\n                path = f\"/var/run/user/{getuid()}\"\n                if not Path(path).exists():\n                    path = f\"/tmp/runtime-{getuid()}\"  # noqa: S108\n            else:\n                path = f\"/run/user/{getuid()}\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory shared by users, e.g. ``/run/$appname/$version`` or \\\n        ``$XDG_RUNTIME_DIR/$appname/$version``.\n\n        Note that this behaves almost exactly like `user_runtime_dir` if ``$XDG_RUNTIME_DIR`` is set, but will\n        fall back to paths associated to the root user instead of a regular logged-in user if it's not set.\n\n        If you wish to ensure that a logged-in root user path is returned e.g. ``/run/user/0``, use `user_runtime_dir`\n        instead.\n\n        For FreeBSD/OpenBSD/NetBSD, it would return ``/var/run/$appname/$version`` if ``$XDG_RUNTIME_DIR`` is not set.\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            if sys.platform.startswith((\"freebsd\", \"openbsd\", \"netbsd\")):\n                path = \"/var/run\"\n            else:\n                path = \"/run\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_data_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users, returns the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_config_dir)\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_cache_dir)\n\n    def _first_item_as_path_if_multipath(self, directory: str) -> Path:\n        if self.multipath:\n            # If multipath is True, the first path is returned.\n            directory = directory.split(os.pathsep)[0]\n        return Path(directory)\n\n    def iter_config_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site configuration directories.\"\"\"\n        yield self.user_config_dir\n        yield from self._site_config_dirs\n\n    def iter_data_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site data directories.\"\"\"\n        yield self.user_data_dir\n        yield from self._site_data_dirs\n\n\ndef _get_user_media_dir(env_var: str, fallback_tilde_path: str) -> str:\n    media_dir = _get_user_dirs_folder(env_var)\n    if media_dir is None:\n        media_dir = os.environ.get(env_var, \"\").strip()\n        if not media_dir:\n            media_dir = os.path.expanduser(fallback_tilde_path)  # noqa: PTH111\n\n    return media_dir\n\n\ndef _get_user_dirs_folder(key: str) -> str | None:\n    \"\"\"\n    Return directory from user-dirs.dirs config file.\n\n    See https://freedesktop.org/wiki/Software/xdg-user-dirs/.\n\n    \"\"\"\n    user_dirs_config_path = Path(Unix().user_config_dir) / \"user-dirs.dirs\"\n    if user_dirs_config_path.exists():\n        parser = ConfigParser()\n\n        with user_dirs_config_path.open() as stream:\n            # Add fake section header, so ConfigParser doesn't complain\n            parser.read_string(f\"[top]\\n{stream.read()}\")\n\n        if key not in parser[\"top\"]:\n            return None\n\n        path = parser[\"top\"][key].strip('\"')\n        # Handle relative home paths\n        return path.replace(\"$HOME\", os.path.expanduser(\"~\"))  # noqa: PTH111\n\n    return None\n\n\n__all__ = [\n    \"Unix\",\n]\n", "src/platformdirs/__main__.py": "\"\"\"Main entry point.\"\"\"\n\nfrom __future__ import annotations\n\nfrom platformdirs import PlatformDirs, __version__\n\nPROPS = (\n    \"user_data_dir\",\n    \"user_config_dir\",\n    \"user_cache_dir\",\n    \"user_state_dir\",\n    \"user_log_dir\",\n    \"user_documents_dir\",\n    \"user_downloads_dir\",\n    \"user_pictures_dir\",\n    \"user_videos_dir\",\n    \"user_music_dir\",\n    \"user_runtime_dir\",\n    \"site_data_dir\",\n    \"site_config_dir\",\n    \"site_cache_dir\",\n    \"site_runtime_dir\",\n)\n\n\ndef main() -> None:\n    \"\"\"Run the main entry point.\"\"\"\n    app_name = \"MyApp\"\n    app_author = \"MyCompany\"\n\n    print(f\"-- platformdirs {__version__} --\")  # noqa: T201\n\n    print(\"-- app dirs (with optional 'version')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, app_author, version=\"1.0\")\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (without optional 'version')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, app_author)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (without optional 'appauthor')\")  # noqa: T201\n    dirs = PlatformDirs(app_name)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (with disabled 'appauthor')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, appauthor=False)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n\nif __name__ == \"__main__\":\n    main()\n", "src/platformdirs/__init__.py": "\"\"\"\nUtilities for determining application-specific dirs.\n\nSee <https://github.com/platformdirs/platformdirs> for details and usage.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\nfrom .version import __version__\nfrom .version import __version_tuple__ as __version_info__\n\nif TYPE_CHECKING:\n    from pathlib import Path\n    from typing import Literal\n\n\ndef _set_platform_dir_class() -> type[PlatformDirsABC]:\n    if sys.platform == \"win32\":\n        from platformdirs.windows import Windows as Result  # noqa: PLC0415\n    elif sys.platform == \"darwin\":\n        from platformdirs.macos import MacOS as Result  # noqa: PLC0415\n    else:\n        from platformdirs.unix import Unix as Result  # noqa: PLC0415\n\n    if os.getenv(\"ANDROID_DATA\") == \"/data\" and os.getenv(\"ANDROID_ROOT\") == \"/system\":\n        if os.getenv(\"SHELL\") or os.getenv(\"PREFIX\"):\n            return Result\n\n        from platformdirs.android import _android_folder  # noqa: PLC0415\n\n        if _android_folder() is not None:\n            from platformdirs.android import Android  # noqa: PLC0415\n\n            return Android  # return to avoid redefinition of a result\n\n    return Result\n\n\nPlatformDirs = _set_platform_dir_class()  #: Currently active platform\nAppDirs = PlatformDirs  #: Backwards compatibility with appdirs\n\n\ndef user_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_data_dir\n\n\ndef site_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data directory shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_data_dir\n\n\ndef user_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_config_dir\n\n\ndef site_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config directory shared by the users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_config_dir\n\n\ndef user_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_cache_dir\n\n\ndef site_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_cache_dir\n\n\ndef user_state_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: state directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_state_dir\n\n\ndef user_log_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: log directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_log_dir\n\n\ndef user_documents_dir() -> str:\n    \"\"\":returns: documents directory tied to the user\"\"\"\n    return PlatformDirs().user_documents_dir\n\n\ndef user_downloads_dir() -> str:\n    \"\"\":returns: downloads directory tied to the user\"\"\"\n    return PlatformDirs().user_downloads_dir\n\n\ndef user_pictures_dir() -> str:\n    \"\"\":returns: pictures directory tied to the user\"\"\"\n    return PlatformDirs().user_pictures_dir\n\n\ndef user_videos_dir() -> str:\n    \"\"\":returns: videos directory tied to the user\"\"\"\n    return PlatformDirs().user_videos_dir\n\n\ndef user_music_dir() -> str:\n    \"\"\":returns: music directory tied to the user\"\"\"\n    return PlatformDirs().user_music_dir\n\n\ndef user_desktop_dir() -> str:\n    \"\"\":returns: desktop directory tied to the user\"\"\"\n    return PlatformDirs().user_desktop_dir\n\n\ndef user_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_runtime_dir\n\n\ndef site_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime directory shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_runtime_dir\n\n\ndef user_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_data_path\n\n\ndef site_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `multipath <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data path shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_data_path\n\n\ndef user_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_config_path\n\n\ndef site_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config path shared by the users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_config_path\n\n\ndef site_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_cache_path\n\n\ndef user_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_cache_path\n\n\ndef user_state_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: state path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_state_path\n\n\ndef user_log_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: log path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_log_path\n\n\ndef user_documents_path() -> Path:\n    \"\"\":returns: documents a path tied to the user\"\"\"\n    return PlatformDirs().user_documents_path\n\n\ndef user_downloads_path() -> Path:\n    \"\"\":returns: downloads path tied to the user\"\"\"\n    return PlatformDirs().user_downloads_path\n\n\ndef user_pictures_path() -> Path:\n    \"\"\":returns: pictures path tied to the user\"\"\"\n    return PlatformDirs().user_pictures_path\n\n\ndef user_videos_path() -> Path:\n    \"\"\":returns: videos path tied to the user\"\"\"\n    return PlatformDirs().user_videos_path\n\n\ndef user_music_path() -> Path:\n    \"\"\":returns: music path tied to the user\"\"\"\n    return PlatformDirs().user_music_path\n\n\ndef user_desktop_path() -> Path:\n    \"\"\":returns: desktop path tied to the user\"\"\"\n    return PlatformDirs().user_desktop_path\n\n\ndef user_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_runtime_path\n\n\ndef site_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime path shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_runtime_path\n\n\n__all__ = [\n    \"AppDirs\",\n    \"PlatformDirs\",\n    \"PlatformDirsABC\",\n    \"__version__\",\n    \"__version_info__\",\n    \"site_cache_dir\",\n    \"site_cache_path\",\n    \"site_config_dir\",\n    \"site_config_path\",\n    \"site_data_dir\",\n    \"site_data_path\",\n    \"site_runtime_dir\",\n    \"site_runtime_path\",\n    \"user_cache_dir\",\n    \"user_cache_path\",\n    \"user_config_dir\",\n    \"user_config_path\",\n    \"user_data_dir\",\n    \"user_data_path\",\n    \"user_desktop_dir\",\n    \"user_desktop_path\",\n    \"user_documents_dir\",\n    \"user_documents_path\",\n    \"user_downloads_dir\",\n    \"user_downloads_path\",\n    \"user_log_dir\",\n    \"user_log_path\",\n    \"user_music_dir\",\n    \"user_music_path\",\n    \"user_pictures_dir\",\n    \"user_pictures_path\",\n    \"user_runtime_dir\",\n    \"user_runtime_path\",\n    \"user_state_dir\",\n    \"user_state_path\",\n    \"user_videos_dir\",\n    \"user_videos_path\",\n]\n", "src/platformdirs/android.py": "\"\"\"Android.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, cast\n\nfrom .api import PlatformDirsABC\n\n\nclass Android(PlatformDirsABC):\n    \"\"\"\n    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_.\n\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `version\n    <platformdirs.api.PlatformDirsABC.version>`, `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"files\")\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. \\\n        ``/data/user/<userid>/<packagename>/shared_prefs/<AppName>``\n        \"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"shared_prefs\")\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `user_config_dir`\"\"\"\n        return self.user_config_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g.,``/data/user/<userid>/<packagename>/cache/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, same as `user_cache_dir`\"\"\"\n        return self.user_cache_dir\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\"\n        :return: log directory tied to the user, same as `user_cache_dir` if not opinionated else ``log`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/log``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")  # noqa: PTH118\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``/storage/emulated/0/Documents``\"\"\"\n        return _android_documents_folder()\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``/storage/emulated/0/Downloads``\"\"\"\n        return _android_downloads_folder()\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``/storage/emulated/0/Pictures``\"\"\"\n        return _android_pictures_folder()\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``/storage/emulated/0/DCIM/Camera``\"\"\"\n        return _android_videos_folder()\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``/storage/emulated/0/Music``\"\"\"\n        return _android_music_folder()\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user e.g. ``/storage/emulated/0/Desktop``\"\"\"\n        return \"/storage/emulated/0/Desktop\"\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, same as `user_cache_dir` if not opinionated else ``tmp`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/tmp``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"tmp\")  # noqa: PTH118\n        return path\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_folder() -> str | None:  # noqa: C901\n    \"\"\":return: base folder for the Android OS or None if it cannot be found\"\"\"\n    result: str | None = None\n    # type checker isn't happy with our \"import android\", just don't do this when type checking see\n    # https://stackoverflow.com/a/61394121\n    if not TYPE_CHECKING:\n        try:\n            # First try to get a path to android app using python4android (if available)...\n            from android import mActivity  # noqa: PLC0415\n\n            context = cast(\"android.content.Context\", mActivity.getApplicationContext())  # noqa: F821\n            result = context.getFilesDir().getParentFile().getAbsolutePath()\n        except Exception:  # noqa: BLE001\n            result = None\n    if result is None:\n        try:\n            # ...and fall back to using plain pyjnius, if python4android isn't available or doesn't deliver any useful\n            # result...\n            from jnius import autoclass  # noqa: PLC0415\n\n            context = autoclass(\"android.content.Context\")\n            result = context.getFilesDir().getParentFile().getAbsolutePath()\n        except Exception:  # noqa: BLE001\n            result = None\n    if result is None:\n        # and if that fails, too, find an android folder looking at path on the sys.path\n        # warning: only works for apps installed under /data, not adopted storage etc.\n        pattern = re.compile(r\"/data/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    if result is None:\n        # one last try: find an android folder looking at path on the sys.path taking adopted storage paths into\n        # account\n        pattern = re.compile(r\"/mnt/expand/[a-fA-F0-9-]{36}/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    return result\n\n\n@lru_cache(maxsize=1)\ndef _android_documents_folder() -> str:\n    \"\"\":return: documents folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        documents_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOCUMENTS).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        documents_dir = \"/storage/emulated/0/Documents\"\n\n    return documents_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_downloads_folder() -> str:\n    \"\"\":return: downloads folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        downloads_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOWNLOADS).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        downloads_dir = \"/storage/emulated/0/Downloads\"\n\n    return downloads_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_pictures_folder() -> str:\n    \"\"\":return: pictures folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        pictures_dir: str = context.getExternalFilesDir(environment.DIRECTORY_PICTURES).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        pictures_dir = \"/storage/emulated/0/Pictures\"\n\n    return pictures_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_videos_folder() -> str:\n    \"\"\":return: videos folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        videos_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DCIM).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        videos_dir = \"/storage/emulated/0/DCIM/Camera\"\n\n    return videos_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_music_folder() -> str:\n    \"\"\":return: music folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        music_dir: str = context.getExternalFilesDir(environment.DIRECTORY_MUSIC).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        music_dir = \"/storage/emulated/0/Music\"\n\n    return music_dir\n\n\n__all__ = [\n    \"Android\",\n]\n"}