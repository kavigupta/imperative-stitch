{"hatch_build.py": "\"\"\"Dynamically define some metadata.\"\"\"\nimport os\n\nfrom hatchling.metadata.plugin.interface import MetadataHookInterface\n\n\ndef get_version_dev_status(root):\n    \"\"\"Get version_info without importing the entire module.\"\"\"\n\n    import importlib.util\n\n    path = os.path.join(root, \"soupsieve\", \"__meta__.py\")\n    spec = importlib.util.spec_from_file_location(\"__meta__\", path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module.__version_info__._get_dev_status()\n\n\nclass CustomMetadataHook(MetadataHookInterface):\n    \"\"\"Our metadata hook.\"\"\"\n\n    def update(self, metadata):\n        \"\"\"See https://ofek.dev/hatch/latest/plugins/metadata-hook/ for more information.\"\"\"\n\n        metadata[\"classifiers\"] = [\n            f\"Development Status :: {get_version_dev_status(self.root)}\",\n            'Environment :: Console',\n            'Intended Audience :: Developers',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: OS Independent',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n            'Topic :: Software Development :: Libraries :: Python Modules',\n            'Typing :: Typed'\n        ]\n", "soupsieve/pretty.py": "\"\"\"\nFormat a pretty string of a `SoupSieve` object for easy debugging.\n\nThis won't necessarily support all types and such, and definitely\nnot support custom outputs.\n\nIt is mainly geared towards our types as the `SelectorList`\nobject is a beast to look at without some indentation and newlines.\nThe format and various output types is fairly known (though it\nhasn't been tested extensively to make sure we aren't missing corners).\n\nExample:\n-------\n```\n>>> import soupsieve as sv\n>>> sv.compile('this > that.class[name=value]').selectors.pretty()\nSelectorList(\n    selectors=(\n        Selector(\n            tag=SelectorTag(\n                name='that',\n                prefix=None),\n            ids=(),\n            classes=(\n                'class',\n                ),\n            attributes=(\n                SelectorAttribute(\n                    attribute='name',\n                    prefix='',\n                    pattern=re.compile(\n                        '^value$'),\n                    xml_type_pattern=None),\n                ),\n            nth=(),\n            selectors=(),\n            relation=SelectorList(\n                selectors=(\n                    Selector(\n                        tag=SelectorTag(\n                            name='this',\n                            prefix=None),\n                        ids=(),\n                        classes=(),\n                        attributes=(),\n                        nth=(),\n                        selectors=(),\n                        relation=SelectorList(\n                            selectors=(),\n                            is_not=False,\n                            is_html=False),\n                        rel_type='>',\n                        contains=(),\n                        lang=(),\n                        flags=0),\n                    ),\n                is_not=False,\n                is_html=False),\n            rel_type=None,\n            contains=(),\n            lang=(),\n            flags=0),\n        ),\n    is_not=False,\n    is_html=False)\n```\n\n\"\"\"\nfrom __future__ import annotations\nimport re\nfrom typing import Any\n\nRE_CLASS = re.compile(r'(?i)[a-z_][_a-z\\d\\.]+\\(')\nRE_PARAM = re.compile(r'(?i)[_a-z][_a-z\\d]+=')\nRE_EMPTY = re.compile(r'\\(\\)|\\[\\]|\\{\\}')\nRE_LSTRT = re.compile(r'\\[')\nRE_DSTRT = re.compile(r'\\{')\nRE_TSTRT = re.compile(r'\\(')\nRE_LEND = re.compile(r'\\]')\nRE_DEND = re.compile(r'\\}')\nRE_TEND = re.compile(r'\\)')\nRE_INT = re.compile(r'\\d+')\nRE_KWORD = re.compile(r'(?i)[_a-z][_a-z\\d]+')\nRE_DQSTR = re.compile(r'\"(?:\\\\.|[^\"\\\\])*\"')\nRE_SQSTR = re.compile(r\"'(?:\\\\.|[^'\\\\])*'\")\nRE_SEP = re.compile(r'\\s*(,)\\s*')\nRE_DSEP = re.compile(r'\\s*(:)\\s*')\n\nTOKENS = {\n    'class': RE_CLASS,\n    'param': RE_PARAM,\n    'empty': RE_EMPTY,\n    'lstrt': RE_LSTRT,\n    'dstrt': RE_DSTRT,\n    'tstrt': RE_TSTRT,\n    'lend': RE_LEND,\n    'dend': RE_DEND,\n    'tend': RE_TEND,\n    'sqstr': RE_SQSTR,\n    'sep': RE_SEP,\n    'dsep': RE_DSEP,\n    'int': RE_INT,\n    'kword': RE_KWORD,\n    'dqstr': RE_DQSTR\n}\n\n\ndef pretty(obj: Any) -> str:  # pragma: no cover\n    \"\"\"Make the object output string pretty.\"\"\"\n\n    sel = str(obj)\n    index = 0\n    end = len(sel) - 1\n    indent = 0\n    output = []\n\n    while index <= end:\n        m = None\n        for k, v in TOKENS.items():\n            m = v.match(sel, index)\n\n            if m:\n                name = k\n                index = m.end(0)\n                if name in ('class', 'lstrt', 'dstrt', 'tstrt'):\n                    indent += 4\n                    output.append(f'{m.group(0)}\\n{\" \" * indent}')\n                elif name in ('param', 'int', 'kword', 'sqstr', 'dqstr', 'empty'):\n                    output.append(m.group(0))\n                elif name in ('lend', 'dend', 'tend'):\n                    indent -= 4\n                    output.append(m.group(0))\n                elif name in ('sep',):\n                    output.append(f'{m.group(1)}\\n{\" \" * indent}')\n                elif name in ('dsep',):\n                    output.append(f'{m.group(1)} ')\n                break\n\n    return ''.join(output)\n", "soupsieve/css_match.py": "\"\"\"CSS matcher.\"\"\"\nfrom __future__ import annotations\nfrom datetime import datetime\nfrom . import util\nimport re\nfrom . import css_types as ct\nimport unicodedata\nimport bs4  # type: ignore[import]\nfrom typing import Iterator, Iterable, Any, Callable, Sequence, cast  # noqa: F401\n\n# Empty tag pattern (whitespace okay)\nRE_NOT_EMPTY = re.compile('[^ \\t\\r\\n\\f]')\n\nRE_NOT_WS = re.compile('[^ \\t\\r\\n\\f]+')\n\n# Relationships\nREL_PARENT = ' '\nREL_CLOSE_PARENT = '>'\nREL_SIBLING = '~'\nREL_CLOSE_SIBLING = '+'\n\n# Relationships for :has() (forward looking)\nREL_HAS_PARENT = ': '\nREL_HAS_CLOSE_PARENT = ':>'\nREL_HAS_SIBLING = ':~'\nREL_HAS_CLOSE_SIBLING = ':+'\n\nNS_XHTML = 'http://www.w3.org/1999/xhtml'\nNS_XML = 'http://www.w3.org/XML/1998/namespace'\n\nDIR_FLAGS = ct.SEL_DIR_LTR | ct.SEL_DIR_RTL\nRANGES = ct.SEL_IN_RANGE | ct.SEL_OUT_OF_RANGE\n\nDIR_MAP = {\n    'ltr': ct.SEL_DIR_LTR,\n    'rtl': ct.SEL_DIR_RTL,\n    'auto': 0\n}\n\nRE_NUM = re.compile(r\"^(?P<value>-?(?:[0-9]{1,}(\\.[0-9]+)?|\\.[0-9]+))$\")\nRE_TIME = re.compile(r'^(?P<hour>[0-9]{2}):(?P<minutes>[0-9]{2})$')\nRE_MONTH = re.compile(r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})$')\nRE_WEEK = re.compile(r'^(?P<year>[0-9]{4,})-W(?P<week>[0-9]{2})$')\nRE_DATE = re.compile(r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})$')\nRE_DATETIME = re.compile(\n    r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})T(?P<hour>[0-9]{2}):(?P<minutes>[0-9]{2})$'\n)\nRE_WILD_STRIP = re.compile(r'(?:(?:-\\*-)(?:\\*(?:-|$))*|-\\*$)')\n\nMONTHS_30 = (4, 6, 9, 11)  # April, June, September, and November\nFEB = 2\nSHORT_MONTH = 30\nLONG_MONTH = 31\nFEB_MONTH = 28\nFEB_LEAP_MONTH = 29\nDAYS_IN_WEEK = 7\n\n\nclass _FakeParent:\n    \"\"\"\n    Fake parent class.\n\n    When we have a fragment with no `BeautifulSoup` document object,\n    we can't evaluate `nth` selectors properly.  Create a temporary\n    fake parent so we can traverse the root element as a child.\n    \"\"\"\n\n    def __init__(self, element: bs4.Tag) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.contents = [element]\n\n    def __len__(self) -> bs4.PageElement:\n        \"\"\"Length.\"\"\"\n\n        return len(self.contents)\n\n\nclass _DocumentNav:\n    \"\"\"Navigate a Beautiful Soup document.\"\"\"\n\n    @classmethod\n    def assert_valid_input(cls, tag: Any) -> None:\n        \"\"\"Check if valid input tag or document.\"\"\"\n\n        # Fail on unexpected types.\n        if not cls.is_tag(tag):\n            raise TypeError(f\"Expected a BeautifulSoup 'Tag', but instead received type {type(tag)}\")\n\n    @staticmethod\n    def is_doc(obj: bs4.Tag) -> bool:\n        \"\"\"Is `BeautifulSoup` object.\"\"\"\n        return isinstance(obj, bs4.BeautifulSoup)\n\n    @staticmethod\n    def is_tag(obj: bs4.PageElement) -> bool:\n        \"\"\"Is tag.\"\"\"\n        return isinstance(obj, bs4.Tag)\n\n    @staticmethod\n    def is_declaration(obj: bs4.PageElement) -> bool:  # pragma: no cover\n        \"\"\"Is declaration.\"\"\"\n        return isinstance(obj, bs4.Declaration)\n\n    @staticmethod\n    def is_cdata(obj: bs4.PageElement) -> bool:\n        \"\"\"Is CDATA.\"\"\"\n        return isinstance(obj, bs4.CData)\n\n    @staticmethod\n    def is_processing_instruction(obj: bs4.PageElement) -> bool:  # pragma: no cover\n        \"\"\"Is processing instruction.\"\"\"\n        return isinstance(obj, bs4.ProcessingInstruction)\n\n    @staticmethod\n    def is_navigable_string(obj: bs4.PageElement) -> bool:\n        \"\"\"Is navigable string.\"\"\"\n        return isinstance(obj, bs4.NavigableString)\n\n    @staticmethod\n    def is_special_string(obj: bs4.PageElement) -> bool:\n        \"\"\"Is special string.\"\"\"\n        return isinstance(obj, (bs4.Comment, bs4.Declaration, bs4.CData, bs4.ProcessingInstruction, bs4.Doctype))\n\n    @classmethod\n    def is_content_string(cls, obj: bs4.PageElement) -> bool:\n        \"\"\"Check if node is content string.\"\"\"\n\n        return cls.is_navigable_string(obj) and not cls.is_special_string(obj)\n\n    @staticmethod\n    def create_fake_parent(el: bs4.Tag) -> _FakeParent:\n        \"\"\"Create fake parent for a given element.\"\"\"\n\n        return _FakeParent(el)\n\n    @staticmethod\n    def is_xml_tree(el: bs4.Tag) -> bool:\n        \"\"\"Check if element (or document) is from a XML tree.\"\"\"\n\n        return bool(el._is_xml)\n\n    def is_iframe(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if element is an `iframe`.\"\"\"\n\n        return bool(\n            ((el.name if self.is_xml_tree(el) else util.lower(el.name)) == 'iframe') and\n            self.is_html_tag(el)  # type: ignore[attr-defined]\n        )\n\n    def is_root(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Return whether element is a root element.\n\n        We check that the element is the root of the tree (which we have already pre-calculated),\n        and we check if it is the root element under an `iframe`.\n        \"\"\"\n\n        root = self.root and self.root is el  # type: ignore[attr-defined]\n        if not root:\n            parent = self.get_parent(el)\n            root = parent is not None and self.is_html and self.is_iframe(parent)  # type: ignore[attr-defined]\n        return root\n\n    def get_contents(self, el: bs4.Tag, no_iframe: bool = False) -> Iterator[bs4.PageElement]:\n        \"\"\"Get contents or contents in reverse.\"\"\"\n        if not no_iframe or not self.is_iframe(el):\n            yield from el.contents\n\n    def get_children(\n        self,\n        el: bs4.Tag,\n        start: int | None = None,\n        reverse: bool = False,\n        tags: bool = True,\n        no_iframe: bool = False\n    ) -> Iterator[bs4.PageElement]:\n        \"\"\"Get children.\"\"\"\n\n        if not no_iframe or not self.is_iframe(el):\n            last = len(el.contents) - 1\n            if start is None:\n                index = last if reverse else 0\n            else:\n                index = start\n            end = -1 if reverse else last + 1\n            incr = -1 if reverse else 1\n\n            if 0 <= index <= last:\n                while index != end:\n                    node = el.contents[index]\n                    index += incr\n                    if not tags or self.is_tag(node):\n                        yield node\n\n    def get_descendants(\n        self,\n        el: bs4.Tag,\n        tags: bool = True,\n        no_iframe: bool = False\n    ) -> Iterator[bs4.PageElement]:\n        \"\"\"Get descendants.\"\"\"\n\n        if not no_iframe or not self.is_iframe(el):\n            next_good = None\n            for child in el.descendants:\n\n                if next_good is not None:\n                    if child is not next_good:\n                        continue\n                    next_good = None\n\n                is_tag = self.is_tag(child)\n\n                if no_iframe and is_tag and self.is_iframe(child):\n                    if child.next_sibling is not None:\n                        next_good = child.next_sibling\n                    else:\n                        last_child = child\n                        while self.is_tag(last_child) and last_child.contents:\n                            last_child = last_child.contents[-1]\n                        next_good = last_child.next_element\n                    yield child\n                    if next_good is None:\n                        break\n                    # Coverage isn't seeing this even though it's executed\n                    continue  # pragma: no cover\n\n                if not tags or is_tag:\n                    yield child\n\n    def get_parent(self, el: bs4.Tag, no_iframe: bool = False) -> bs4.Tag:\n        \"\"\"Get parent.\"\"\"\n\n        parent = el.parent\n        if no_iframe and parent is not None and self.is_iframe(parent):\n            parent = None\n        return parent\n\n    @staticmethod\n    def get_tag_name(el: bs4.Tag) -> str | None:\n        \"\"\"Get tag.\"\"\"\n\n        return cast('str | None', el.name)\n\n    @staticmethod\n    def get_prefix_name(el: bs4.Tag) -> str | None:\n        \"\"\"Get prefix.\"\"\"\n\n        return cast('str | None', el.prefix)\n\n    @staticmethod\n    def get_uri(el: bs4.Tag) -> str | None:\n        \"\"\"Get namespace `URI`.\"\"\"\n\n        return cast('str | None', el.namespace)\n\n    @classmethod\n    def get_next(cls, el: bs4.Tag, tags: bool = True) -> bs4.PageElement:\n        \"\"\"Get next sibling tag.\"\"\"\n\n        sibling = el.next_sibling\n        while tags and not cls.is_tag(sibling) and sibling is not None:\n            sibling = sibling.next_sibling\n        return sibling\n\n    @classmethod\n    def get_previous(cls, el: bs4.Tag, tags: bool = True) -> bs4.PageElement:\n        \"\"\"Get previous sibling tag.\"\"\"\n\n        sibling = el.previous_sibling\n        while tags and not cls.is_tag(sibling) and sibling is not None:\n            sibling = sibling.previous_sibling\n        return sibling\n\n    @staticmethod\n    def has_html_ns(el: bs4.Tag) -> bool:\n        \"\"\"\n        Check if element has an HTML namespace.\n\n        This is a bit different than whether a element is treated as having an HTML namespace,\n        like we do in the case of `is_html_tag`.\n        \"\"\"\n\n        ns = getattr(el, 'namespace') if el else None  # noqa: B009\n        return bool(ns and ns == NS_XHTML)\n\n    @staticmethod\n    def split_namespace(el: bs4.Tag, attr_name: str) -> tuple[str | None, str | None]:\n        \"\"\"Return namespace and attribute name without the prefix.\"\"\"\n\n        return getattr(attr_name, 'namespace', None), getattr(attr_name, 'name', None)\n\n    @classmethod\n    def normalize_value(cls, value: Any) -> str | Sequence[str]:\n        \"\"\"Normalize the value to be a string or list of strings.\"\"\"\n\n        # Treat `None` as empty string.\n        if value is None:\n            return ''\n\n        # Pass through strings\n        if (isinstance(value, str)):\n            return value\n\n        # If it's a byte string, convert it to Unicode, treating it as UTF-8.\n        if isinstance(value, bytes):\n            return value.decode(\"utf8\")\n\n        # BeautifulSoup supports sequences of attribute values, so make sure the children are strings.\n        if isinstance(value, Sequence):\n            new_value = []\n            for v in value:\n                if not isinstance(v, (str, bytes)) and isinstance(v, Sequence):\n                    # This is most certainly a user error and will crash and burn later.\n                    # To keep things working, we'll do what we do with all objects,\n                    # And convert them to strings.\n                    new_value.append(str(v))\n                else:\n                    # Convert the child to a string\n                    new_value.append(cast(str, cls.normalize_value(v)))\n            return new_value\n\n        # Try and make anything else a string\n        return str(value)\n\n    @classmethod\n    def get_attribute_by_name(\n        cls,\n        el: bs4.Tag,\n        name: str,\n        default: str | Sequence[str] | None = None\n    ) -> str | Sequence[str] | None:\n        \"\"\"Get attribute by name.\"\"\"\n\n        value = default\n        if el._is_xml:\n            try:\n                value = cls.normalize_value(el.attrs[name])\n            except KeyError:\n                pass\n        else:\n            for k, v in el.attrs.items():\n                if util.lower(k) == name:\n                    value = cls.normalize_value(v)\n                    break\n        return value\n\n    @classmethod\n    def iter_attributes(cls, el: bs4.Tag) -> Iterator[tuple[str, str | Sequence[str] | None]]:\n        \"\"\"Iterate attributes.\"\"\"\n\n        for k, v in el.attrs.items():\n            yield k, cls.normalize_value(v)\n\n    @classmethod\n    def get_classes(cls, el: bs4.Tag) -> Sequence[str]:\n        \"\"\"Get classes.\"\"\"\n\n        classes = cls.get_attribute_by_name(el, 'class', [])\n        if isinstance(classes, str):\n            classes = RE_NOT_WS.findall(classes)\n        return cast(Sequence[str], classes)\n\n    def get_text(self, el: bs4.Tag, no_iframe: bool = False) -> str:\n        \"\"\"Get text.\"\"\"\n\n        return ''.join(\n            [node for node in self.get_descendants(el, tags=False, no_iframe=no_iframe) if self.is_content_string(node)]\n        )\n\n    def get_own_text(self, el: bs4.Tag, no_iframe: bool = False) -> list[str]:\n        \"\"\"Get Own Text.\"\"\"\n\n        return [node for node in self.get_contents(el, no_iframe=no_iframe) if self.is_content_string(node)]\n\n\nclass Inputs:\n    \"\"\"Class for parsing and validating input items.\"\"\"\n\n    @staticmethod\n    def validate_day(year: int, month: int, day: int) -> bool:\n        \"\"\"Validate day.\"\"\"\n\n        max_days = LONG_MONTH\n        if month == FEB:\n            max_days = FEB_LEAP_MONTH if ((year % 4 == 0) and (year % 100 != 0)) or (year % 400 == 0) else FEB_MONTH\n        elif month in MONTHS_30:\n            max_days = SHORT_MONTH\n        return 1 <= day <= max_days\n\n    @staticmethod\n    def validate_week(year: int, week: int) -> bool:\n        \"\"\"Validate week.\"\"\"\n\n        max_week = datetime.strptime(f\"{12}-{31}-{year}\", \"%m-%d-%Y\").isocalendar()[1]\n        if max_week == 1:\n            max_week = 53\n        return 1 <= week <= max_week\n\n    @staticmethod\n    def validate_month(month: int) -> bool:\n        \"\"\"Validate month.\"\"\"\n\n        return 1 <= month <= 12\n\n    @staticmethod\n    def validate_year(year: int) -> bool:\n        \"\"\"Validate year.\"\"\"\n\n        return 1 <= year\n\n    @staticmethod\n    def validate_hour(hour: int) -> bool:\n        \"\"\"Validate hour.\"\"\"\n\n        return 0 <= hour <= 23\n\n    @staticmethod\n    def validate_minutes(minutes: int) -> bool:\n        \"\"\"Validate minutes.\"\"\"\n\n        return 0 <= minutes <= 59\n\n    @classmethod\n    def parse_value(cls, itype: str, value: str | None) -> tuple[float, ...] | None:\n        \"\"\"Parse the input value.\"\"\"\n\n        parsed = None  # type: tuple[float, ...] | None\n        if value is None:\n            return value\n        if itype == \"date\":\n            m = RE_DATE.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                if cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day):\n                    parsed = (year, month, day)\n        elif itype == \"month\":\n            m = RE_MONTH.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                if cls.validate_year(year) and cls.validate_month(month):\n                    parsed = (year, month)\n        elif itype == \"week\":\n            m = RE_WEEK.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                week = int(m.group('week'), 10)\n                if cls.validate_year(year) and cls.validate_week(year, week):\n                    parsed = (year, week)\n        elif itype == \"time\":\n            m = RE_TIME.match(value)\n            if m:\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if cls.validate_hour(hour) and cls.validate_minutes(minutes):\n                    parsed = (hour, minutes)\n        elif itype == \"datetime-local\":\n            m = RE_DATETIME.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if (\n                    cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day) and\n                    cls.validate_hour(hour) and cls.validate_minutes(minutes)\n                ):\n                    parsed = (year, month, day, hour, minutes)\n        elif itype in (\"number\", \"range\"):\n            m = RE_NUM.match(value)\n            if m:\n                parsed = (float(m.group('value')),)\n        return parsed\n\n\nclass CSSMatch(_DocumentNav):\n    \"\"\"Perform CSS matching.\"\"\"\n\n    def __init__(\n        self,\n        selectors: ct.SelectorList,\n        scope: bs4.Tag,\n        namespaces: ct.Namespaces | None,\n        flags: int\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.assert_valid_input(scope)\n        self.tag = scope\n        self.cached_meta_lang = []  # type: list[tuple[str, str]]\n        self.cached_default_forms = []  # type: list[tuple[bs4.Tag, bs4.Tag]]\n        self.cached_indeterminate_forms = []  # type: list[tuple[bs4.Tag, str, bool]]\n        self.selectors = selectors\n        self.namespaces = {} if namespaces is None else namespaces  # type: ct.Namespaces | dict[str, str]\n        self.flags = flags\n        self.iframe_restrict = False\n\n        # Find the root element for the whole tree\n        doc = scope\n        parent = self.get_parent(doc)\n        while parent:\n            doc = parent\n            parent = self.get_parent(doc)\n        root = None\n        if not self.is_doc(doc):\n            root = doc\n        else:\n            for child in self.get_children(doc):\n                root = child\n                break\n\n        self.root = root\n        self.scope = scope if scope is not doc else root\n        self.has_html_namespace = self.has_html_ns(root)\n\n        # A document can be both XML and HTML (XHTML)\n        self.is_xml = self.is_xml_tree(doc)\n        self.is_html = not self.is_xml or self.has_html_namespace\n\n    def supports_namespaces(self) -> bool:\n        \"\"\"Check if namespaces are supported in the HTML type.\"\"\"\n\n        return self.is_xml or self.has_html_namespace\n\n    def get_tag_ns(self, el: bs4.Tag) -> str:\n        \"\"\"Get tag namespace.\"\"\"\n\n        if self.supports_namespaces():\n            namespace = ''\n            ns = self.get_uri(el)\n            if ns:\n                namespace = ns\n        else:\n            namespace = NS_XHTML\n        return namespace\n\n    def is_html_tag(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if tag is in HTML namespace.\"\"\"\n\n        return self.get_tag_ns(el) == NS_XHTML\n\n    def get_tag(self, el: bs4.Tag) -> str | None:\n        \"\"\"Get tag.\"\"\"\n\n        name = self.get_tag_name(el)\n        return util.lower(name) if name is not None and not self.is_xml else name\n\n    def get_prefix(self, el: bs4.Tag) -> str | None:\n        \"\"\"Get prefix.\"\"\"\n\n        prefix = self.get_prefix_name(el)\n        return util.lower(prefix) if prefix is not None and not self.is_xml else prefix\n\n    def find_bidi(self, el: bs4.Tag) -> int | None:\n        \"\"\"Get directionality from element text.\"\"\"\n\n        for node in self.get_children(el, tags=False):\n\n            # Analyze child text nodes\n            if self.is_tag(node):\n\n                # Avoid analyzing certain elements specified in the specification.\n                direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(node, 'dir', '')), None)\n                if (\n                    self.get_tag(node) in ('bdi', 'script', 'style', 'textarea', 'iframe') or\n                    not self.is_html_tag(node) or\n                    direction is not None\n                ):\n                    continue  # pragma: no cover\n\n                # Check directionality of this node's text\n                value = self.find_bidi(node)\n                if value is not None:\n                    return value\n\n                # Direction could not be determined\n                continue  # pragma: no cover\n\n            # Skip `doctype` comments, etc.\n            if self.is_special_string(node):\n                continue\n\n            # Analyze text nodes for directionality.\n            for c in node:\n                bidi = unicodedata.bidirectional(c)\n                if bidi in ('AL', 'R', 'L'):\n                    return ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n        return None\n\n    def extended_language_filter(self, lang_range: str, lang_tag: str) -> bool:\n        \"\"\"Filter the language tags.\"\"\"\n\n        match = True\n        lang_range = RE_WILD_STRIP.sub('-', lang_range).lower()\n        ranges = lang_range.split('-')\n        subtags = lang_tag.lower().split('-')\n        length = len(ranges)\n        slength = len(subtags)\n        rindex = 0\n        sindex = 0\n        r = ranges[rindex]\n        s = subtags[sindex]\n\n        # Empty specified language should match unspecified language attributes\n        if length == 1 and slength == 1 and not r and r == s:\n            return True\n\n        # Primary tag needs to match\n        if (r != '*' and r != s) or (r == '*' and slength == 1 and not s):\n            match = False\n\n        rindex += 1\n        sindex += 1\n\n        # Match until we run out of ranges\n        while match and rindex < length:\n            r = ranges[rindex]\n            try:\n                s = subtags[sindex]\n            except IndexError:\n                # Ran out of subtags,\n                # but we still have ranges\n                match = False\n                continue\n\n            # Empty range\n            if not r:\n                match = False\n                continue\n\n            # Matched range\n            elif s == r:\n                rindex += 1\n\n            # Implicit wildcard cannot match\n            # singletons\n            elif len(s) == 1:\n                match = False\n                continue\n\n            # Implicitly matched, so grab next subtag\n            sindex += 1\n\n        return match\n\n    def match_attribute_name(\n        self,\n        el: bs4.Tag,\n        attr: str,\n        prefix: str | None\n    ) -> str | Sequence[str] | None:\n        \"\"\"Match attribute name and return value if it exists.\"\"\"\n\n        value = None\n        if self.supports_namespaces():\n            value = None\n            # If we have not defined namespaces, we can't very well find them, so don't bother trying.\n            if prefix:\n                ns = self.namespaces.get(prefix)\n                if ns is None and prefix != '*':\n                    return None\n            else:\n                ns = None\n\n            for k, v in self.iter_attributes(el):\n\n                # Get attribute parts\n                namespace, name = self.split_namespace(el, k)\n\n                # Can't match a prefix attribute as we haven't specified one to match\n                # Try to match it normally as a whole `p:a` as selector may be trying `p\\:a`.\n                if ns is None:\n                    if (self.is_xml and attr == k) or (not self.is_xml and util.lower(attr) == util.lower(k)):\n                        value = v\n                        break\n                    # Coverage is not finding this even though it is executed.\n                    # Adding a print statement before this (and erasing coverage) causes coverage to find the line.\n                    # Ignore the false positive message.\n                    continue  # pragma: no cover\n\n                # We can't match our desired prefix attribute as the attribute doesn't have a prefix\n                if namespace is None or ns != namespace and prefix != '*':\n                    continue\n\n                # The attribute doesn't match.\n                if (util.lower(attr) != util.lower(name)) if not self.is_xml else (attr != name):\n                    continue\n\n                value = v\n                break\n        else:\n            for k, v in self.iter_attributes(el):\n                if util.lower(attr) != util.lower(k):\n                    continue\n                value = v\n                break\n        return value\n\n    def match_namespace(self, el: bs4.Tag, tag: ct.SelectorTag) -> bool:\n        \"\"\"Match the namespace of the element.\"\"\"\n\n        match = True\n        namespace = self.get_tag_ns(el)\n        default_namespace = self.namespaces.get('')\n        tag_ns = '' if tag.prefix is None else self.namespaces.get(tag.prefix)\n        # We must match the default namespace if one is not provided\n        if tag.prefix is None and (default_namespace is not None and namespace != default_namespace):\n            match = False\n        # If we specified `|tag`, we must not have a namespace.\n        elif (tag.prefix is not None and tag.prefix == '' and namespace):\n            match = False\n        # Verify prefix matches\n        elif (\n            tag.prefix and\n            tag.prefix != '*' and (tag_ns is None or namespace != tag_ns)\n        ):\n            match = False\n        return match\n\n    def match_attributes(self, el: bs4.Tag, attributes: tuple[ct.SelectorAttribute, ...]) -> bool:\n        \"\"\"Match attributes.\"\"\"\n\n        match = True\n        if attributes:\n            for a in attributes:\n                temp = self.match_attribute_name(el, a.attribute, a.prefix)\n                pattern = a.xml_type_pattern if self.is_xml and a.xml_type_pattern else a.pattern\n                if temp is None:\n                    match = False\n                    break\n                value = temp if isinstance(temp, str) else ' '.join(temp)\n                if pattern is None:\n                    continue\n                elif pattern.match(value) is None:\n                    match = False\n                    break\n        return match\n\n    def match_tagname(self, el: bs4.Tag, tag: ct.SelectorTag) -> bool:\n        \"\"\"Match tag name.\"\"\"\n\n        name = (util.lower(tag.name) if not self.is_xml and tag.name is not None else tag.name)\n        return not (\n            name is not None and\n            name not in (self.get_tag(el), '*')\n        )\n\n    def match_tag(self, el: bs4.Tag, tag: ct.SelectorTag | None) -> bool:\n        \"\"\"Match the tag.\"\"\"\n\n        match = True\n        if tag is not None:\n            # Verify namespace\n            if not self.match_namespace(el, tag):\n                match = False\n            if not self.match_tagname(el, tag):\n                match = False\n        return match\n\n    def match_past_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match past relationship.\"\"\"\n\n        found = False\n        # I don't think this can ever happen, but it makes `mypy` happy\n        if isinstance(relation[0], ct.SelectorNull):  # pragma: no cover\n            return found\n\n        if relation[0].rel_type == REL_PARENT:\n            parent = self.get_parent(el, no_iframe=self.iframe_restrict)\n            while not found and parent:\n                found = self.match_selectors(parent, relation)\n                parent = self.get_parent(parent, no_iframe=self.iframe_restrict)\n        elif relation[0].rel_type == REL_CLOSE_PARENT:\n            parent = self.get_parent(el, no_iframe=self.iframe_restrict)\n            if parent:\n                found = self.match_selectors(parent, relation)\n        elif relation[0].rel_type == REL_SIBLING:\n            sibling = self.get_previous(el)\n            while not found and sibling:\n                found = self.match_selectors(sibling, relation)\n                sibling = self.get_previous(sibling)\n        elif relation[0].rel_type == REL_CLOSE_SIBLING:\n            sibling = self.get_previous(el)\n            if sibling and self.is_tag(sibling):\n                found = self.match_selectors(sibling, relation)\n        return found\n\n    def match_future_child(self, parent: bs4.Tag, relation: ct.SelectorList, recursive: bool = False) -> bool:\n        \"\"\"Match future child.\"\"\"\n\n        match = False\n        if recursive:\n            children = self.get_descendants  # type: Callable[..., Iterator[bs4.Tag]]\n        else:\n            children = self.get_children\n        for child in children(parent, no_iframe=self.iframe_restrict):\n            match = self.match_selectors(child, relation)\n            if match:\n                break\n        return match\n\n    def match_future_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match future relationship.\"\"\"\n\n        found = False\n        # I don't think this can ever happen, but it makes `mypy` happy\n        if isinstance(relation[0], ct.SelectorNull):  # pragma: no cover\n            return found\n\n        if relation[0].rel_type == REL_HAS_PARENT:\n            found = self.match_future_child(el, relation, True)\n        elif relation[0].rel_type == REL_HAS_CLOSE_PARENT:\n            found = self.match_future_child(el, relation)\n        elif relation[0].rel_type == REL_HAS_SIBLING:\n            sibling = self.get_next(el)\n            while not found and sibling:\n                found = self.match_selectors(sibling, relation)\n                sibling = self.get_next(sibling)\n        elif relation[0].rel_type == REL_HAS_CLOSE_SIBLING:\n            sibling = self.get_next(el)\n            if sibling and self.is_tag(sibling):\n                found = self.match_selectors(sibling, relation)\n        return found\n\n    def match_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match relationship to other elements.\"\"\"\n\n        found = False\n\n        if isinstance(relation[0], ct.SelectorNull) or relation[0].rel_type is None:\n            return found\n\n        if relation[0].rel_type.startswith(':'):\n            found = self.match_future_relations(el, relation)\n        else:\n            found = self.match_past_relations(el, relation)\n\n        return found\n\n    def match_id(self, el: bs4.Tag, ids: tuple[str, ...]) -> bool:\n        \"\"\"Match element's ID.\"\"\"\n\n        found = True\n        for i in ids:\n            if i != self.get_attribute_by_name(el, 'id', ''):\n                found = False\n                break\n        return found\n\n    def match_classes(self, el: bs4.Tag, classes: tuple[str, ...]) -> bool:\n        \"\"\"Match element's classes.\"\"\"\n\n        current_classes = self.get_classes(el)\n        found = True\n        for c in classes:\n            if c not in current_classes:\n                found = False\n                break\n        return found\n\n    def match_root(self, el: bs4.Tag) -> bool:\n        \"\"\"Match element as root.\"\"\"\n\n        is_root = self.is_root(el)\n        if is_root:\n            sibling = self.get_previous(el, tags=False)\n            while is_root and sibling is not None:\n                if (\n                    self.is_tag(sibling) or (self.is_content_string(sibling) and sibling.strip()) or\n                    self.is_cdata(sibling)\n                ):\n                    is_root = False\n                else:\n                    sibling = self.get_previous(sibling, tags=False)\n        if is_root:\n            sibling = self.get_next(el, tags=False)\n            while is_root and sibling is not None:\n                if (\n                    self.is_tag(sibling) or (self.is_content_string(sibling) and sibling.strip()) or\n                    self.is_cdata(sibling)\n                ):\n                    is_root = False\n                else:\n                    sibling = self.get_next(sibling, tags=False)\n        return is_root\n\n    def match_scope(self, el: bs4.Tag) -> bool:\n        \"\"\"Match element as scope.\"\"\"\n\n        return self.scope is el\n\n    def match_nth_tag_type(self, el: bs4.Tag, child: bs4.Tag) -> bool:\n        \"\"\"Match tag type for `nth` matches.\"\"\"\n\n        return (\n            (self.get_tag(child) == self.get_tag(el)) and\n            (self.get_tag_ns(child) == self.get_tag_ns(el))\n        )\n\n    def match_nth(self, el: bs4.Tag, nth: bs4.Tag) -> bool:\n        \"\"\"Match `nth` elements.\"\"\"\n\n        matched = True\n\n        for n in nth:\n            matched = False\n            if n.selectors and not self.match_selectors(el, n.selectors):\n                break\n            parent = self.get_parent(el)\n            if parent is None:\n                parent = self.create_fake_parent(el)\n            last = n.last\n            last_index = len(parent) - 1\n            index = last_index if last else 0\n            relative_index = 0\n            a = n.a\n            b = n.b\n            var = n.n\n            count = 0\n            count_incr = 1\n            factor = -1 if last else 1\n            idx = last_idx = a * count + b if var else a\n\n            # We can only adjust bounds within a variable index\n            if var:\n                # Abort if our nth index is out of bounds and only getting further out of bounds as we increment.\n                # Otherwise, increment to try to get in bounds.\n                adjust = None\n                while idx < 1 or idx > last_index:\n                    if idx < 0:\n                        diff_low = 0 - idx\n                        if adjust is not None and adjust == 1:\n                            break\n                        adjust = -1\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                        diff = 0 - idx\n                        if diff >= diff_low:\n                            break\n                    else:\n                        diff_high = idx - last_index\n                        if adjust is not None and adjust == -1:\n                            break\n                        adjust = 1\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                        diff = idx - last_index\n                        if diff >= diff_high:\n                            break\n                        diff_high = diff\n\n                # If a < 0, our count is working backwards, so floor the index by increasing the count.\n                # Find the count that yields the lowest, in bound value and use that.\n                # Lastly reverse count increment so that we'll increase our index.\n                lowest = count\n                if a < 0:\n                    while idx >= 1:\n                        lowest = count\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                    count_incr = -1\n                count = lowest\n                idx = last_idx = a * count + b if var else a\n\n            # Evaluate elements while our calculated nth index is still in range\n            while 1 <= idx <= last_index + 1:\n                child = None\n                # Evaluate while our child index is still in range.\n                for child in self.get_children(parent, start=index, reverse=factor < 0, tags=False):\n                    index += factor\n                    if not self.is_tag(child):\n                        continue\n                    # Handle `of S` in `nth-child`\n                    if n.selectors and not self.match_selectors(child, n.selectors):\n                        continue\n                    # Handle `of-type`\n                    if n.of_type and not self.match_nth_tag_type(el, child):\n                        continue\n                    relative_index += 1\n                    if relative_index == idx:\n                        if child is el:\n                            matched = True\n                        else:\n                            break\n                    if child is el:\n                        break\n                if child is el:\n                    break\n                last_idx = idx\n                count += count_incr\n                if count < 0:\n                    # Count is counting down and has now ventured into invalid territory.\n                    break\n                idx = a * count + b if var else a\n                if last_idx == idx:\n                    break\n            if not matched:\n                break\n        return matched\n\n    def match_empty(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if element is empty (if requested).\"\"\"\n\n        is_empty = True\n        for child in self.get_children(el, tags=False):\n            if self.is_tag(child):\n                is_empty = False\n                break\n            elif self.is_content_string(child) and RE_NOT_EMPTY.search(child):\n                is_empty = False\n                break\n        return is_empty\n\n    def match_subselectors(self, el: bs4.Tag, selectors: tuple[ct.SelectorList, ...]) -> bool:\n        \"\"\"Match selectors.\"\"\"\n\n        match = True\n        for sel in selectors:\n            if not self.match_selectors(el, sel):\n                match = False\n        return match\n\n    def match_contains(self, el: bs4.Tag, contains: tuple[ct.SelectorContains, ...]) -> bool:\n        \"\"\"Match element if it contains text.\"\"\"\n\n        match = True\n        content = None  # type: str | Sequence[str] | None\n        for contain_list in contains:\n            if content is None:\n                if contain_list.own:\n                    content = self.get_own_text(el, no_iframe=self.is_html)\n                else:\n                    content = self.get_text(el, no_iframe=self.is_html)\n            found = False\n            for text in contain_list.text:\n                if contain_list.own:\n                    for c in content:\n                        if text in c:\n                            found = True\n                            break\n                    if found:\n                        break\n                else:\n                    if text in content:\n                        found = True\n                        break\n            if not found:\n                match = False\n        return match\n\n    def match_default(self, el: bs4.Tag) -> bool:\n        \"\"\"Match default.\"\"\"\n\n        match = False\n\n        # Find this input's form\n        form = None\n        parent = self.get_parent(el, no_iframe=True)\n        while parent and form is None:\n            if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                form = parent\n            else:\n                parent = self.get_parent(parent, no_iframe=True)\n\n        # Look in form cache to see if we've already located its default button\n        found_form = False\n        for f, t in self.cached_default_forms:\n            if f is form:\n                found_form = True\n                if t is el:\n                    match = True\n                break\n\n        # We didn't have the form cached, so look for its default button\n        if not found_form:\n            for child in self.get_descendants(form, no_iframe=True):\n                name = self.get_tag(child)\n                # Can't do nested forms (haven't figured out why we never hit this)\n                if name == 'form':  # pragma: no cover\n                    break\n                if name in ('input', 'button'):\n                    v = self.get_attribute_by_name(child, 'type', '')\n                    if v and util.lower(v) == 'submit':\n                        self.cached_default_forms.append((form, child))\n                        if el is child:\n                            match = True\n                        break\n        return match\n\n    def match_indeterminate(self, el: bs4.Tag) -> bool:\n        \"\"\"Match default.\"\"\"\n\n        match = False\n        name = cast(str, self.get_attribute_by_name(el, 'name'))\n\n        def get_parent_form(el: bs4.Tag) -> bs4.Tag | None:\n            \"\"\"Find this input's form.\"\"\"\n            form = None\n            parent = self.get_parent(el, no_iframe=True)\n            while form is None:\n                if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                    form = parent\n                    break\n                last_parent = parent\n                parent = self.get_parent(parent, no_iframe=True)\n                if parent is None:\n                    form = last_parent\n                    break\n            return form\n\n        form = get_parent_form(el)\n\n        # Look in form cache to see if we've already evaluated that its fellow radio buttons are indeterminate\n        found_form = False\n        for f, n, i in self.cached_indeterminate_forms:\n            if f is form and n == name:\n                found_form = True\n                if i is True:\n                    match = True\n                break\n\n        # We didn't have the form cached, so validate that the radio button is indeterminate\n        if not found_form:\n            checked = False\n            for child in self.get_descendants(form, no_iframe=True):\n                if child is el:\n                    continue\n                tag_name = self.get_tag(child)\n                if tag_name == 'input':\n                    is_radio = False\n                    check = False\n                    has_name = False\n                    for k, v in self.iter_attributes(child):\n                        if util.lower(k) == 'type' and util.lower(v) == 'radio':\n                            is_radio = True\n                        elif util.lower(k) == 'name' and v == name:\n                            has_name = True\n                        elif util.lower(k) == 'checked':\n                            check = True\n                        if is_radio and check and has_name and get_parent_form(child) is form:\n                            checked = True\n                            break\n                if checked:\n                    break\n            if not checked:\n                match = True\n            self.cached_indeterminate_forms.append((form, name, match))\n\n        return match\n\n    def match_lang(self, el: bs4.Tag, langs: tuple[ct.SelectorLang, ...]) -> bool:\n        \"\"\"Match languages.\"\"\"\n\n        match = False\n        has_ns = self.supports_namespaces()\n        root = self.root\n        has_html_namespace = self.has_html_namespace\n\n        # Walk parents looking for `lang` (HTML) or `xml:lang` XML property.\n        parent = el\n        found_lang = None\n        last = None\n        while not found_lang:\n            has_html_ns = self.has_html_ns(parent)\n            for k, v in self.iter_attributes(parent):\n                attr_ns, attr = self.split_namespace(parent, k)\n                if (\n                    ((not has_ns or has_html_ns) and (util.lower(k) if not self.is_xml else k) == 'lang') or\n                    (\n                        has_ns and not has_html_ns and attr_ns == NS_XML and\n                        (util.lower(attr) if not self.is_xml and attr is not None else attr) == 'lang'\n                    )\n                ):\n                    found_lang = v\n                    break\n            last = parent\n            parent = self.get_parent(parent, no_iframe=self.is_html)\n\n            if parent is None:\n                root = last\n                has_html_namespace = self.has_html_ns(root)\n                parent = last\n                break\n\n        # Use cached meta language.\n        if found_lang is None and self.cached_meta_lang:\n            for cache in self.cached_meta_lang:\n                if root is cache[0]:\n                    found_lang = cache[1]\n\n        # If we couldn't find a language, and the document is HTML, look to meta to determine language.\n        if found_lang is None and (not self.is_xml or (has_html_namespace and root.name == 'html')):\n            # Find head\n            found = False\n            for tag in ('html', 'head'):\n                found = False\n                for child in self.get_children(parent, no_iframe=self.is_html):\n                    if self.get_tag(child) == tag and self.is_html_tag(child):\n                        found = True\n                        parent = child\n                        break\n                if not found:  # pragma: no cover\n                    break\n\n            # Search meta tags\n            if found:\n                for child in parent:\n                    if self.is_tag(child) and self.get_tag(child) == 'meta' and self.is_html_tag(parent):\n                        c_lang = False\n                        content = None\n                        for k, v in self.iter_attributes(child):\n                            if util.lower(k) == 'http-equiv' and util.lower(v) == 'content-language':\n                                c_lang = True\n                            if util.lower(k) == 'content':\n                                content = v\n                            if c_lang and content:\n                                found_lang = content\n                                self.cached_meta_lang.append((cast(str, root), cast(str, found_lang)))\n                                break\n                    if found_lang is not None:\n                        break\n                if found_lang is None:\n                    self.cached_meta_lang.append((cast(str, root), ''))\n\n        # If we determined a language, compare.\n        if found_lang is not None:\n            for patterns in langs:\n                match = False\n                for pattern in patterns:\n                    if self.extended_language_filter(pattern, cast(str, found_lang)):\n                        match = True\n                if not match:\n                    break\n\n        return match\n\n    def match_dir(self, el: bs4.Tag, directionality: int) -> bool:\n        \"\"\"Check directionality.\"\"\"\n\n        # If we have to match both left and right, we can't match either.\n        if directionality & ct.SEL_DIR_LTR and directionality & ct.SEL_DIR_RTL:\n            return False\n\n        if el is None or not self.is_html_tag(el):\n            return False\n\n        # Element has defined direction of left to right or right to left\n        direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(el, 'dir', '')), None)\n        if direction not in (None, 0):\n            return direction == directionality\n\n        # Element is the document element (the root) and no direction assigned, assume left to right.\n        is_root = self.is_root(el)\n        if is_root and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # If `input[type=telephone]` and no direction is assigned, assume left to right.\n        name = self.get_tag(el)\n        is_input = name == 'input'\n        is_textarea = name == 'textarea'\n        is_bdi = name == 'bdi'\n        itype = util.lower(self.get_attribute_by_name(el, 'type', '')) if is_input else ''\n        if is_input and itype == 'tel' and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # Auto handling for text inputs\n        if ((is_input and itype in ('text', 'search', 'tel', 'url', 'email')) or is_textarea) and direction == 0:\n            if is_textarea:\n                value = ''.join(node for node in self.get_contents(el, no_iframe=True) if self.is_content_string(node))\n            else:\n                value = cast(str, self.get_attribute_by_name(el, 'value', ''))\n            if value:\n                for c in value:\n                    bidi = unicodedata.bidirectional(c)\n                    if bidi in ('AL', 'R', 'L'):\n                        direction = ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n                        return direction == directionality\n                # Assume left to right\n                return ct.SEL_DIR_LTR == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Auto handling for `bdi` and other non text inputs.\n        if (is_bdi and direction is None) or direction == 0:\n            direction = self.find_bidi(el)\n            if direction is not None:\n                return direction == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Match parents direction\n        return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n    def match_range(self, el: bs4.Tag, condition: int) -> bool:\n        \"\"\"\n        Match range.\n\n        Behavior is modeled after what we see in browsers. Browsers seem to evaluate\n        if the value is out of range, and if not, it is in range. So a missing value\n        will not evaluate out of range; therefore, value is in range. Personally, I\n        feel like this should evaluate as neither in or out of range.\n        \"\"\"\n\n        out_of_range = False\n\n        itype = util.lower(self.get_attribute_by_name(el, 'type'))\n        mn = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'min', None)))\n        mx = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'max', None)))\n\n        # There is no valid min or max, so we cannot evaluate a range\n        if mn is None and mx is None:\n            return False\n\n        value = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'value', None)))\n        if value is not None:\n            if itype in (\"date\", \"datetime-local\", \"month\", \"week\", \"number\", \"range\"):\n                if mn is not None and value < mn:\n                    out_of_range = True\n                if not out_of_range and mx is not None and value > mx:\n                    out_of_range = True\n            elif itype == \"time\":\n                if mn is not None and mx is not None and mn > mx:\n                    # Time is periodic, so this is a reversed/discontinuous range\n                    if value < mn and value > mx:\n                        out_of_range = True\n                else:\n                    if mn is not None and value < mn:\n                        out_of_range = True\n                    if not out_of_range and mx is not None and value > mx:\n                        out_of_range = True\n\n        return not out_of_range if condition & ct.SEL_IN_RANGE else out_of_range\n\n    def match_defined(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Match defined.\n\n        `:defined` is related to custom elements in a browser.\n\n        - If the document is XML (not XHTML), all tags will match.\n        - Tags that are not custom (don't have a hyphen) are marked defined.\n        - If the tag has a prefix (without or without a namespace), it will not match.\n\n        This is of course requires the parser to provide us with the proper prefix and namespace info,\n        if it doesn't, there is nothing we can do.\n        \"\"\"\n\n        name = self.get_tag(el)\n        return (\n            name is not None and (\n                name.find('-') == -1 or\n                name.find(':') != -1 or\n                self.get_prefix(el) is not None\n            )\n        )\n\n    def match_placeholder_shown(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Match placeholder shown according to HTML spec.\n\n        - text area should be checked if they have content. A single newline does not count as content.\n\n        \"\"\"\n\n        match = False\n        content = self.get_text(el)\n        if content in ('', '\\n'):\n            match = True\n\n        return match\n\n    def match_selectors(self, el: bs4.Tag, selectors: ct.SelectorList) -> bool:\n        \"\"\"Check if element matches one of the selectors.\"\"\"\n\n        match = False\n        is_not = selectors.is_not\n        is_html = selectors.is_html\n\n        # Internal selector lists that use the HTML flag, will automatically get the `html` namespace.\n        if is_html:\n            namespaces = self.namespaces\n            iframe_restrict = self.iframe_restrict\n            self.namespaces = {'html': NS_XHTML}\n            self.iframe_restrict = True\n\n        if not is_html or self.is_html:\n            for selector in selectors:\n                match = is_not\n                # We have a un-matchable situation (like `:focus` as you can focus an element in this environment)\n                if isinstance(selector, ct.SelectorNull):\n                    continue\n                # Verify tag matches\n                if not self.match_tag(el, selector.tag):\n                    continue\n                # Verify tag is defined\n                if selector.flags & ct.SEL_DEFINED and not self.match_defined(el):\n                    continue\n                # Verify element is root\n                if selector.flags & ct.SEL_ROOT and not self.match_root(el):\n                    continue\n                # Verify element is scope\n                if selector.flags & ct.SEL_SCOPE and not self.match_scope(el):\n                    continue\n                # Verify element has placeholder shown\n                if selector.flags & ct.SEL_PLACEHOLDER_SHOWN and not self.match_placeholder_shown(el):\n                    continue\n                # Verify `nth` matches\n                if not self.match_nth(el, selector.nth):\n                    continue\n                if selector.flags & ct.SEL_EMPTY and not self.match_empty(el):\n                    continue\n                # Verify id matches\n                if selector.ids and not self.match_id(el, selector.ids):\n                    continue\n                # Verify classes match\n                if selector.classes and not self.match_classes(el, selector.classes):\n                    continue\n                # Verify attribute(s) match\n                if not self.match_attributes(el, selector.attributes):\n                    continue\n                # Verify ranges\n                if selector.flags & RANGES and not self.match_range(el, selector.flags & RANGES):\n                    continue\n                # Verify language patterns\n                if selector.lang and not self.match_lang(el, selector.lang):\n                    continue\n                # Verify pseudo selector patterns\n                if selector.selectors and not self.match_subselectors(el, selector.selectors):\n                    continue\n                # Verify relationship selectors\n                if selector.relation and not self.match_relations(el, selector.relation):\n                    continue\n                # Validate that the current default selector match corresponds to the first submit button in the form\n                if selector.flags & ct.SEL_DEFAULT and not self.match_default(el):\n                    continue\n                # Validate that the unset radio button is among radio buttons with the same name in a form that are\n                # also not set.\n                if selector.flags & ct.SEL_INDETERMINATE and not self.match_indeterminate(el):\n                    continue\n                # Validate element directionality\n                if selector.flags & DIR_FLAGS and not self.match_dir(el, selector.flags & DIR_FLAGS):\n                    continue\n                # Validate that the tag contains the specified text.\n                if selector.contains and not self.match_contains(el, selector.contains):\n                    continue\n                match = not is_not\n                break\n\n        # Restore actual namespaces being used for external selector lists\n        if is_html:\n            self.namespaces = namespaces\n            self.iframe_restrict = iframe_restrict\n\n        return match\n\n    def select(self, limit: int = 0) -> Iterator[bs4.Tag]:\n        \"\"\"Match all tags under the targeted tag.\"\"\"\n\n        lim = None if limit < 1 else limit\n\n        for child in self.get_descendants(self.tag):\n            if self.match(child):\n                yield child\n                if lim is not None:\n                    lim -= 1\n                    if lim < 1:\n                        break\n\n    def closest(self) -> bs4.Tag | None:\n        \"\"\"Match closest ancestor.\"\"\"\n\n        current = self.tag\n        closest = None\n        while closest is None and current is not None:\n            if self.match(current):\n                closest = current\n            else:\n                current = self.get_parent(current)\n        return closest\n\n    def filter(self) -> list[bs4.Tag]:  # noqa A001\n        \"\"\"Filter tag's children.\"\"\"\n\n        return [tag for tag in self.get_contents(self.tag) if not self.is_navigable_string(tag) and self.match(tag)]\n\n    def match(self, el: bs4.Tag) -> bool:\n        \"\"\"Match.\"\"\"\n\n        return not self.is_doc(el) and self.is_tag(el) and self.match_selectors(el, self.selectors)\n\n\nclass SoupSieve(ct.Immutable):\n    \"\"\"Compiled Soup Sieve selector matching object.\"\"\"\n\n    pattern: str\n    selectors: ct.SelectorList\n    namespaces: ct.Namespaces | None\n    custom: dict[str, str]\n    flags: int\n\n    __slots__ = (\"pattern\", \"selectors\", \"namespaces\", \"custom\", \"flags\", \"_hash\")\n\n    def __init__(\n        self,\n        pattern: str,\n        selectors: ct.SelectorList,\n        namespaces: ct.Namespaces | None,\n        custom: ct.CustomSelectors | None,\n        flags: int\n    ):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            pattern=pattern,\n            selectors=selectors,\n            namespaces=namespaces,\n            custom=custom,\n            flags=flags\n        )\n\n    def match(self, tag: bs4.Tag) -> bool:\n        \"\"\"Match.\"\"\"\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).match(tag)\n\n    def closest(self, tag: bs4.Tag) -> bs4.Tag:\n        \"\"\"Match closest ancestor.\"\"\"\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).closest()\n\n    def filter(self, iterable: Iterable[bs4.Tag]) -> list[bs4.Tag]:  # noqa A001\n        \"\"\"\n        Filter.\n\n        `CSSMatch` can cache certain searches for tags of the same document,\n        so if we are given a tag, all tags are from the same document,\n        and we can take advantage of the optimization.\n\n        Any other kind of iterable could have tags from different documents or detached tags,\n        so for those, we use a new `CSSMatch` for each item in the iterable.\n        \"\"\"\n\n        if CSSMatch.is_tag(iterable):\n            return CSSMatch(self.selectors, iterable, self.namespaces, self.flags).filter()\n        else:\n            return [node for node in iterable if not CSSMatch.is_navigable_string(node) and self.match(node)]\n\n    def select_one(self, tag: bs4.Tag) -> bs4.Tag:\n        \"\"\"Select a single tag.\"\"\"\n\n        tags = self.select(tag, limit=1)\n        return tags[0] if tags else None\n\n    def select(self, tag: bs4.Tag, limit: int = 0) -> list[bs4.Tag]:\n        \"\"\"Select the specified tags.\"\"\"\n\n        return list(self.iselect(tag, limit))\n\n    def iselect(self, tag: bs4.Tag, limit: int = 0) -> Iterator[bs4.Tag]:\n        \"\"\"Iterate the specified tags.\"\"\"\n\n        yield from CSSMatch(self.selectors, tag, self.namespaces, self.flags).select(limit)\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        return (\n            f\"SoupSieve(pattern={self.pattern!r}, namespaces={self.namespaces!r}, \"\n            f\"custom={self.custom!r}, flags={self.flags!r})\"\n        )\n\n    __str__ = __repr__\n\n\nct.pickle_register(SoupSieve)\n", "soupsieve/css_types.py": "\"\"\"CSS selector structure items.\"\"\"\nfrom __future__ import annotations\nimport copyreg\nfrom .pretty import pretty\nfrom typing import Any, Iterator, Hashable, Pattern, Iterable, Mapping\n\n__all__ = (\n    'Selector',\n    'SelectorNull',\n    'SelectorTag',\n    'SelectorAttribute',\n    'SelectorContains',\n    'SelectorNth',\n    'SelectorLang',\n    'SelectorList',\n    'Namespaces',\n    'CustomSelectors'\n)\n\n\nSEL_EMPTY = 0x1\nSEL_ROOT = 0x2\nSEL_DEFAULT = 0x4\nSEL_INDETERMINATE = 0x8\nSEL_SCOPE = 0x10\nSEL_DIR_LTR = 0x20\nSEL_DIR_RTL = 0x40\nSEL_IN_RANGE = 0x80\nSEL_OUT_OF_RANGE = 0x100\nSEL_DEFINED = 0x200\nSEL_PLACEHOLDER_SHOWN = 0x400\n\n\nclass Immutable:\n    \"\"\"Immutable.\"\"\"\n\n    __slots__: tuple[str, ...] = ('_hash',)\n\n    _hash: int\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        temp = []\n        for k, v in kwargs.items():\n            temp.append(type(v))\n            temp.append(v)\n            super().__setattr__(k, v)\n        super().__setattr__('_hash', hash(tuple(temp)))\n\n    @classmethod\n    def __base__(cls) -> type[Immutable]:\n        \"\"\"Get base class.\"\"\"\n\n        return cls\n\n    def __eq__(self, other: Any) -> bool:\n        \"\"\"Equal.\"\"\"\n\n        return (\n            isinstance(other, self.__base__()) and\n            all(getattr(other, key) == getattr(self, key) for key in self.__slots__ if key != '_hash')\n        )\n\n    def __ne__(self, other: Any) -> bool:\n        \"\"\"Equal.\"\"\"\n\n        return (\n            not isinstance(other, self.__base__()) or\n            any(getattr(other, key) != getattr(self, key) for key in self.__slots__ if key != '_hash')\n        )\n\n    def __hash__(self) -> int:\n        \"\"\"Hash.\"\"\"\n\n        return self._hash\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        \"\"\"Prevent mutability.\"\"\"\n\n        raise AttributeError(f\"'{self.__class__.__name__}' is immutable\")\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        r = ', '.join([f\"{k}={getattr(self, k)!r}\" for k in self.__slots__[:-1]])\n        return f\"{self.__class__.__name__}({r})\"\n\n    __str__ = __repr__\n\n    def pretty(self) -> None:  # pragma: no cover\n        \"\"\"Pretty print.\"\"\"\n\n        print(pretty(self))\n\n\nclass ImmutableDict(Mapping[Any, Any]):\n    \"\"\"Hashable, immutable dictionary.\"\"\"\n\n    def __init__(\n        self,\n        arg: dict[Any, Any] | Iterable[tuple[Any, Any]]\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self._validate(arg)\n        self._d = dict(arg)\n        self._hash = hash(tuple([(type(x), x, type(y), y) for x, y in sorted(self._d.items())]))\n\n    def _validate(self, arg: dict[Any, Any] | Iterable[tuple[Any, Any]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, Hashable) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, Hashable) and isinstance(v, Hashable) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} values must be hashable')\n\n    def __iter__(self) -> Iterator[Any]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self._d)\n\n    def __len__(self) -> int:\n        \"\"\"Length.\"\"\"\n\n        return len(self._d)\n\n    def __getitem__(self, key: Any) -> Any:\n        \"\"\"Get item: `namespace['key']`.\"\"\"\n\n        return self._d[key]\n\n    def __hash__(self) -> int:\n        \"\"\"Hash.\"\"\"\n\n        return self._hash\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        return f\"{self._d!r}\"\n\n    __str__ = __repr__\n\n\nclass Namespaces(ImmutableDict):\n    \"\"\"Namespaces.\"\"\"\n\n    def __init__(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(arg)\n\n    def _validate(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, str) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, str) and isinstance(v, str) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} keys and values must be Unicode strings')\n\n\nclass CustomSelectors(ImmutableDict):\n    \"\"\"Custom selectors.\"\"\"\n\n    def __init__(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(arg)\n\n    def _validate(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, str) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, str) and isinstance(v, str) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} keys and values must be Unicode strings')\n\n\nclass Selector(Immutable):\n    \"\"\"Selector.\"\"\"\n\n    __slots__ = (\n        'tag', 'ids', 'classes', 'attributes', 'nth', 'selectors',\n        'relation', 'rel_type', 'contains', 'lang', 'flags', '_hash'\n    )\n\n    tag: SelectorTag | None\n    ids: tuple[str, ...]\n    classes: tuple[str, ...]\n    attributes: tuple[SelectorAttribute, ...]\n    nth: tuple[SelectorNth, ...]\n    selectors: tuple[SelectorList, ...]\n    relation: SelectorList\n    rel_type: str | None\n    contains: tuple[SelectorContains, ...]\n    lang: tuple[SelectorLang, ...]\n    flags: int\n\n    def __init__(\n        self,\n        tag: SelectorTag | None,\n        ids: tuple[str, ...],\n        classes: tuple[str, ...],\n        attributes: tuple[SelectorAttribute, ...],\n        nth: tuple[SelectorNth, ...],\n        selectors: tuple[SelectorList, ...],\n        relation: SelectorList,\n        rel_type: str | None,\n        contains: tuple[SelectorContains, ...],\n        lang: tuple[SelectorLang, ...],\n        flags: int\n    ):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            tag=tag,\n            ids=ids,\n            classes=classes,\n            attributes=attributes,\n            nth=nth,\n            selectors=selectors,\n            relation=relation,\n            rel_type=rel_type,\n            contains=contains,\n            lang=lang,\n            flags=flags\n        )\n\n\nclass SelectorNull(Immutable):\n    \"\"\"Null Selector.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__()\n\n\nclass SelectorTag(Immutable):\n    \"\"\"Selector tag.\"\"\"\n\n    __slots__ = (\"name\", \"prefix\", \"_hash\")\n\n    name: str\n    prefix: str | None\n\n    def __init__(self, name: str, prefix: str | None) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(name=name, prefix=prefix)\n\n\nclass SelectorAttribute(Immutable):\n    \"\"\"Selector attribute rule.\"\"\"\n\n    __slots__ = (\"attribute\", \"prefix\", \"pattern\", \"xml_type_pattern\", \"_hash\")\n\n    attribute: str\n    prefix: str\n    pattern: Pattern[str] | None\n    xml_type_pattern: Pattern[str] | None\n\n    def __init__(\n        self,\n        attribute: str,\n        prefix: str,\n        pattern: Pattern[str] | None,\n        xml_type_pattern: Pattern[str] | None\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            attribute=attribute,\n            prefix=prefix,\n            pattern=pattern,\n            xml_type_pattern=xml_type_pattern\n        )\n\n\nclass SelectorContains(Immutable):\n    \"\"\"Selector contains rule.\"\"\"\n\n    __slots__ = (\"text\", \"own\", \"_hash\")\n\n    text: tuple[str, ...]\n    own: bool\n\n    def __init__(self, text: Iterable[str], own: bool) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(text=tuple(text), own=own)\n\n\nclass SelectorNth(Immutable):\n    \"\"\"Selector nth type.\"\"\"\n\n    __slots__ = (\"a\", \"n\", \"b\", \"of_type\", \"last\", \"selectors\", \"_hash\")\n\n    a: int\n    n: bool\n    b: int\n    of_type: bool\n    last: bool\n    selectors: SelectorList\n\n    def __init__(self, a: int, n: bool, b: int, of_type: bool, last: bool, selectors: SelectorList) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            a=a,\n            n=n,\n            b=b,\n            of_type=of_type,\n            last=last,\n            selectors=selectors\n        )\n\n\nclass SelectorLang(Immutable):\n    \"\"\"Selector language rules.\"\"\"\n\n    __slots__ = (\"languages\", \"_hash\",)\n\n    languages: tuple[str, ...]\n\n    def __init__(self, languages: Iterable[str]):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(languages=tuple(languages))\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self.languages)\n\n    def __len__(self) -> int:  # pragma: no cover\n        \"\"\"Length.\"\"\"\n\n        return len(self.languages)\n\n    def __getitem__(self, index: int) -> str:  # pragma: no cover\n        \"\"\"Get item.\"\"\"\n\n        return self.languages[index]\n\n\nclass SelectorList(Immutable):\n    \"\"\"Selector list.\"\"\"\n\n    __slots__ = (\"selectors\", \"is_not\", \"is_html\", \"_hash\")\n\n    selectors: tuple[Selector | SelectorNull, ...]\n    is_not: bool\n    is_html: bool\n\n    def __init__(\n        self,\n        selectors: Iterable[Selector | SelectorNull] | None = None,\n        is_not: bool = False,\n        is_html: bool = False\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            selectors=tuple(selectors) if selectors is not None else (),\n            is_not=is_not,\n            is_html=is_html\n        )\n\n    def __iter__(self) -> Iterator[Selector | SelectorNull]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self.selectors)\n\n    def __len__(self) -> int:\n        \"\"\"Length.\"\"\"\n\n        return len(self.selectors)\n\n    def __getitem__(self, index: int) -> Selector | SelectorNull:\n        \"\"\"Get item.\"\"\"\n\n        return self.selectors[index]\n\n\ndef _pickle(p: Any) -> Any:\n    return p.__base__(), tuple([getattr(p, s) for s in p.__slots__[:-1]])\n\n\ndef pickle_register(obj: Any) -> None:\n    \"\"\"Allow object to be pickled.\"\"\"\n\n    copyreg.pickle(obj, _pickle)\n\n\npickle_register(Selector)\npickle_register(SelectorNull)\npickle_register(SelectorTag)\npickle_register(SelectorAttribute)\npickle_register(SelectorContains)\npickle_register(SelectorNth)\npickle_register(SelectorLang)\npickle_register(SelectorList)\n", "soupsieve/css_parser.py": "\"\"\"CSS selector parser.\"\"\"\nfrom __future__ import annotations\nimport re\nfrom functools import lru_cache\nfrom . import util\nfrom . import css_match as cm\nfrom . import css_types as ct\nfrom .util import SelectorSyntaxError\nimport warnings\nfrom typing import Match, Any, Iterator, cast\n\nUNICODE_REPLACEMENT_CHAR = 0xFFFD\n\n# Simple pseudo classes that take no parameters\nPSEUDO_SIMPLE = {\n    \":any-link\",\n    \":empty\",\n    \":first-child\",\n    \":first-of-type\",\n    \":in-range\",\n    \":out-of-range\",\n    \":last-child\",\n    \":last-of-type\",\n    \":link\",\n    \":only-child\",\n    \":only-of-type\",\n    \":root\",\n    ':checked',\n    ':default',\n    ':disabled',\n    ':enabled',\n    ':indeterminate',\n    ':optional',\n    ':placeholder-shown',\n    ':read-only',\n    ':read-write',\n    ':required',\n    ':scope',\n    ':defined'\n}\n\n# Supported, simple pseudo classes that match nothing in the Soup Sieve environment\nPSEUDO_SIMPLE_NO_MATCH = {\n    ':active',\n    ':current',\n    ':focus',\n    ':focus-visible',\n    ':focus-within',\n    ':future',\n    ':host',\n    ':hover',\n    ':local-link',\n    ':past',\n    ':paused',\n    ':playing',\n    ':target',\n    ':target-within',\n    ':user-invalid',\n    ':visited'\n}\n\n# Complex pseudo classes that take selector lists\nPSEUDO_COMPLEX = {\n    ':contains',\n    ':-soup-contains',\n    ':-soup-contains-own',\n    ':has',\n    ':is',\n    ':matches',\n    ':not',\n    ':where'\n}\n\nPSEUDO_COMPLEX_NO_MATCH = {\n    ':current',\n    ':host',\n    ':host-context'\n}\n\n# Complex pseudo classes that take very specific parameters and are handled special\nPSEUDO_SPECIAL = {\n    ':dir',\n    ':lang',\n    ':nth-child',\n    ':nth-last-child',\n    ':nth-last-of-type',\n    ':nth-of-type'\n}\n\nPSEUDO_SUPPORTED = PSEUDO_SIMPLE | PSEUDO_SIMPLE_NO_MATCH | PSEUDO_COMPLEX | PSEUDO_COMPLEX_NO_MATCH | PSEUDO_SPECIAL\n\n# Sub-patterns parts\n# Whitespace\nNEWLINE = r'(?:\\r\\n|(?!\\r\\n)[\\n\\f\\r])'\nWS = fr'(?:[ \\t]|{NEWLINE})'\n# Comments\nCOMMENTS = r'(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)'\n# Whitespace with comments included\nWSC = fr'(?:{WS}|{COMMENTS})'\n# CSS escapes\nCSS_ESCAPES = fr'(?:\\\\(?:[a-f0-9]{{1,6}}{WS}?|[^\\r\\n\\f]|$))'\nCSS_STRING_ESCAPES = fr'(?:\\\\(?:[a-f0-9]{{1,6}}{WS}?|[^\\r\\n\\f]|$|{NEWLINE}))'\n# CSS Identifier\nIDENTIFIER = fr'''\n(?:(?:-?(?:[^\\x00-\\x2f\\x30-\\x40\\x5B-\\x5E\\x60\\x7B-\\x9f]|{CSS_ESCAPES})+|--)\n(?:[^\\x00-\\x2c\\x2e\\x2f\\x3A-\\x40\\x5B-\\x5E\\x60\\x7B-\\x9f]|{CSS_ESCAPES})*)\n'''\n# `nth` content\nNTH = fr'(?:[-+])?(?:[0-9]+n?|n)(?:(?<=n){WSC}*(?:[-+]){WSC}*(?:[0-9]+))?'\n# Value: quoted string or identifier\nVALUE = fr'''(?:\"(?:\\\\(?:.|{NEWLINE})|[^\\\\\"\\r\\n\\f]+)*?\"|'(?:\\\\(?:.|{NEWLINE})|[^\\\\'\\r\\n\\f]+)*?'|{IDENTIFIER}+)'''\n# Attribute value comparison. `!=` is handled special as it is non-standard.\nATTR = fr'(?:{WSC}*(?P<cmp>[!~^|*$]?=){WSC}*(?P<value>{VALUE})(?:{WSC}*(?P<case>[is]))?)?{WSC}*\\]'\n\n# Selector patterns\n# IDs (`#id`)\nPAT_ID = fr'\\#{IDENTIFIER}'\n# Classes (`.class`)\nPAT_CLASS = fr'\\.{IDENTIFIER}'\n# Prefix:Tag (`prefix|tag`)\nPAT_TAG = fr'(?P<tag_ns>(?:{IDENTIFIER}|\\*)?\\|)?(?P<tag_name>{IDENTIFIER}|\\*)'\n# Attributes (`[attr]`, `[attr=value]`, etc.)\nPAT_ATTR = fr'\\[{WSC}*(?P<attr_ns>(?:{IDENTIFIER}|\\*)?\\|)?(?P<attr_name>{IDENTIFIER}){ATTR}'\n# Pseudo class (`:pseudo-class`, `:pseudo-class(`)\nPAT_PSEUDO_CLASS = fr'(?P<name>:{IDENTIFIER})(?P<open>\\({WSC}*)?'\n# Pseudo class special patterns. Matches `:pseudo-class(` for special case pseudo classes.\nPAT_PSEUDO_CLASS_SPECIAL = fr'(?P<name>:{IDENTIFIER})(?P<open>\\({WSC}*)'\n# Custom pseudo class (`:--custom-pseudo`)\nPAT_PSEUDO_CLASS_CUSTOM = fr'(?P<name>:(?=--){IDENTIFIER})'\n# Closing pseudo group (`)`)\nPAT_PSEUDO_CLOSE = fr'{WSC}*\\)'\n# Pseudo element (`::pseudo-element`)\nPAT_PSEUDO_ELEMENT = fr':{PAT_PSEUDO_CLASS}'\n# At rule (`@page`, etc.) (not supported)\nPAT_AT_RULE = fr'@P{IDENTIFIER}'\n# Pseudo class `nth-child` (`:nth-child(an+b [of S]?)`, `:first-child`, etc.)\nPAT_PSEUDO_NTH_CHILD = fr'''\n(?P<pseudo_nth_child>{PAT_PSEUDO_CLASS_SPECIAL}\n(?P<nth_child>{NTH}|even|odd))(?:{WSC}*\\)|(?P<of>{COMMENTS}*{WS}{WSC}*of{COMMENTS}*{WS}{WSC}*))\n'''\n# Pseudo class `nth-of-type` (`:nth-of-type(an+b)`, `:first-of-type`, etc.)\nPAT_PSEUDO_NTH_TYPE = fr'''\n(?P<pseudo_nth_type>{PAT_PSEUDO_CLASS_SPECIAL}\n(?P<nth_type>{NTH}|even|odd)){WSC}*\\)\n'''\n# Pseudo class language (`:lang(\"*-de\", en)`)\nPAT_PSEUDO_LANG = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<values>{VALUE}(?:{WSC}*,{WSC}*{VALUE})*){WSC}*\\)'\n# Pseudo class direction (`:dir(ltr)`)\nPAT_PSEUDO_DIR = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<dir>ltr|rtl){WSC}*\\)'\n# Combining characters (`>`, `~`, ` `, `+`, `,`)\nPAT_COMBINE = fr'{WSC}*?(?P<relation>[,+>~]|{WS}(?![,+>~])){WSC}*'\n# Extra: Contains (`:contains(text)`)\nPAT_PSEUDO_CONTAINS = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<values>{VALUE}(?:{WSC}*,{WSC}*{VALUE})*){WSC}*\\)'\n\n# Regular expressions\n# CSS escape pattern\nRE_CSS_ESC = re.compile(fr'(?:(\\\\[a-f0-9]{{1,6}}{WSC}?)|(\\\\[^\\r\\n\\f])|(\\\\$))', re.I)\nRE_CSS_STR_ESC = re.compile(fr'(?:(\\\\[a-f0-9]{{1,6}}{WS}?)|(\\\\[^\\r\\n\\f])|(\\\\$)|(\\\\{NEWLINE}))', re.I)\n# Pattern to break up `nth` specifiers\nRE_NTH = re.compile(fr'(?P<s1>[-+])?(?P<a>[0-9]+n?|n)(?:(?<=n){WSC}*(?P<s2>[-+]){WSC}*(?P<b>[0-9]+))?', re.I)\n# Pattern to iterate multiple values.\nRE_VALUES = re.compile(fr'(?:(?P<value>{VALUE})|(?P<split>{WSC}*,{WSC}*))', re.X)\n# Whitespace checks\nRE_WS = re.compile(WS)\nRE_WS_BEGIN = re.compile(fr'^{WSC}*')\nRE_WS_END = re.compile(fr'{WSC}*$')\nRE_CUSTOM = re.compile(fr'^{PAT_PSEUDO_CLASS_CUSTOM}$', re.X)\n\n# Constants\n# List split token\nCOMMA_COMBINATOR = ','\n# Relation token for descendant\nWS_COMBINATOR = \" \"\n\n# Parse flags\nFLG_PSEUDO = 0x01\nFLG_NOT = 0x02\nFLG_RELATIVE = 0x04\nFLG_DEFAULT = 0x08\nFLG_HTML = 0x10\nFLG_INDETERMINATE = 0x20\nFLG_OPEN = 0x40\nFLG_IN_RANGE = 0x80\nFLG_OUT_OF_RANGE = 0x100\nFLG_PLACEHOLDER_SHOWN = 0x200\nFLG_FORGIVE = 0x400\n\n# Maximum cached patterns to store\n_MAXCACHE = 500\n\n\n@lru_cache(maxsize=_MAXCACHE)\ndef _cached_css_compile(\n    pattern: str,\n    namespaces: ct.Namespaces | None,\n    custom: ct.CustomSelectors | None,\n    flags: int\n) -> cm.SoupSieve:\n    \"\"\"Cached CSS compile.\"\"\"\n\n    custom_selectors = process_custom(custom)\n    return cm.SoupSieve(\n        pattern,\n        CSSParser(\n            pattern,\n            custom=custom_selectors,\n            flags=flags\n        ).process_selectors(),\n        namespaces,\n        custom,\n        flags\n    )\n\n\ndef _purge_cache() -> None:\n    \"\"\"Purge the cache.\"\"\"\n\n    _cached_css_compile.cache_clear()\n\n\ndef process_custom(custom: ct.CustomSelectors | None) -> dict[str, str | ct.SelectorList]:\n    \"\"\"Process custom.\"\"\"\n\n    custom_selectors = {}\n    if custom is not None:\n        for key, value in custom.items():\n            name = util.lower(key)\n            if RE_CUSTOM.match(name) is None:\n                raise SelectorSyntaxError(f\"The name '{name}' is not a valid custom pseudo-class name\")\n            if name in custom_selectors:\n                raise KeyError(f\"The custom selector '{name}' has already been registered\")\n            custom_selectors[css_unescape(name)] = value\n    return custom_selectors\n\n\ndef css_unescape(content: str, string: bool = False) -> str:\n    \"\"\"\n    Unescape CSS value.\n\n    Strings allow for spanning the value on multiple strings by escaping a new line.\n    \"\"\"\n\n    def replace(m: Match[str]) -> str:\n        \"\"\"Replace with the appropriate substitute.\"\"\"\n\n        if m.group(1):\n            codepoint = int(m.group(1)[1:], 16)\n            if codepoint == 0:\n                codepoint = UNICODE_REPLACEMENT_CHAR\n            value = chr(codepoint)\n        elif m.group(2):\n            value = m.group(2)[1:]\n        elif m.group(3):\n            value = '\\ufffd'\n        else:\n            value = ''\n\n        return value\n\n    return (RE_CSS_ESC if not string else RE_CSS_STR_ESC).sub(replace, content)\n\n\ndef escape(ident: str) -> str:\n    \"\"\"Escape identifier.\"\"\"\n\n    string = []\n    length = len(ident)\n    start_dash = length > 0 and ident[0] == '-'\n    if length == 1 and start_dash:\n        # Need to escape identifier that is a single `-` with no other characters\n        string.append(f'\\\\{ident}')\n    else:\n        for index, c in enumerate(ident):\n            codepoint = ord(c)\n            if codepoint == 0x00:\n                string.append('\\ufffd')\n            elif (0x01 <= codepoint <= 0x1F) or codepoint == 0x7F:\n                string.append(f'\\\\{codepoint:x} ')\n            elif (index == 0 or (start_dash and index == 1)) and (0x30 <= codepoint <= 0x39):\n                string.append(f'\\\\{codepoint:x} ')\n            elif (\n                codepoint in (0x2D, 0x5F) or codepoint >= 0x80 or (0x30 <= codepoint <= 0x39) or\n                (0x30 <= codepoint <= 0x39) or (0x41 <= codepoint <= 0x5A) or (0x61 <= codepoint <= 0x7A)\n            ):\n                string.append(c)\n            else:\n                string.append(f'\\\\{c}')\n    return ''.join(string)\n\n\nclass SelectorPattern:\n    \"\"\"Selector pattern.\"\"\"\n\n    def __init__(self, name: str, pattern: str) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.name = name\n        self.re_pattern = re.compile(pattern, re.I | re.X | re.U)\n\n    def get_name(self) -> str:\n        \"\"\"Get name.\"\"\"\n\n        return self.name\n\n    def match(self, selector: str, index: int, flags: int) -> Match[str] | None:\n        \"\"\"Match the selector.\"\"\"\n\n        return self.re_pattern.match(selector, index)\n\n\nclass SpecialPseudoPattern(SelectorPattern):\n    \"\"\"Selector pattern.\"\"\"\n\n    def __init__(self, patterns: tuple[tuple[str, tuple[str, ...], str, type[SelectorPattern]], ...]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.patterns = {}\n        for p in patterns:\n            name = p[0]\n            pattern = p[3](name, p[2])\n            for pseudo in p[1]:\n                self.patterns[pseudo] = pattern\n\n        self.matched_name = None  # type: SelectorPattern | None\n        self.re_pseudo_name = re.compile(PAT_PSEUDO_CLASS_SPECIAL, re.I | re.X | re.U)\n\n    def get_name(self) -> str:\n        \"\"\"Get name.\"\"\"\n\n        return '' if self.matched_name is None else self.matched_name.get_name()\n\n    def match(self, selector: str, index: int, flags: int) -> Match[str] | None:\n        \"\"\"Match the selector.\"\"\"\n\n        pseudo = None\n        m = self.re_pseudo_name.match(selector, index)\n        if m:\n            name = util.lower(css_unescape(m.group('name')))\n            pattern = self.patterns.get(name)\n            if pattern:\n                pseudo = pattern.match(selector, index, flags)\n                if pseudo:\n                    self.matched_name = pattern\n\n        return pseudo\n\n\nclass _Selector:\n    \"\"\"\n    Intermediate selector class.\n\n    This stores selector data for a compound selector as we are acquiring them.\n    Once we are done collecting the data for a compound selector, we freeze\n    the data in an object that can be pickled and hashed.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.tag = kwargs.get('tag', None)  # type: ct.SelectorTag | None\n        self.ids = kwargs.get('ids', [])  # type: list[str]\n        self.classes = kwargs.get('classes', [])  # type: list[str]\n        self.attributes = kwargs.get('attributes', [])  # type: list[ct.SelectorAttribute]\n        self.nth = kwargs.get('nth', [])  # type: list[ct.SelectorNth]\n        self.selectors = kwargs.get('selectors', [])  # type: list[ct.SelectorList]\n        self.relations = kwargs.get('relations', [])  # type: list[_Selector]\n        self.rel_type = kwargs.get('rel_type', None)  # type: str | None\n        self.contains = kwargs.get('contains', [])  # type: list[ct.SelectorContains]\n        self.lang = kwargs.get('lang', [])  # type: list[ct.SelectorLang]\n        self.flags = kwargs.get('flags', 0)  # type: int\n        self.no_match = kwargs.get('no_match', False)  # type: bool\n\n    def _freeze_relations(self, relations: list[_Selector]) -> ct.SelectorList:\n        \"\"\"Freeze relation.\"\"\"\n\n        if relations:\n            sel = relations[0]\n            sel.relations.extend(relations[1:])\n            return ct.SelectorList([sel.freeze()])\n        else:\n            return ct.SelectorList()\n\n    def freeze(self) -> ct.Selector | ct.SelectorNull:\n        \"\"\"Freeze self.\"\"\"\n\n        if self.no_match:\n            return ct.SelectorNull()\n        else:\n            return ct.Selector(\n                self.tag,\n                tuple(self.ids),\n                tuple(self.classes),\n                tuple(self.attributes),\n                tuple(self.nth),\n                tuple(self.selectors),\n                self._freeze_relations(self.relations),\n                self.rel_type,\n                tuple(self.contains),\n                tuple(self.lang),\n                self.flags\n            )\n\n    def __str__(self) -> str:  # pragma: no cover\n        \"\"\"String representation.\"\"\"\n\n        return (\n            f'_Selector(tag={self.tag!r}, ids={self.ids!r}, classes={self.classes!r}, attributes={self.attributes!r}, '\n            f'nth={self.nth!r}, selectors={self.selectors!r}, relations={self.relations!r}, '\n            f'rel_type={self.rel_type!r}, contains={self.contains!r}, lang={self.lang!r}, flags={self.flags!r}, '\n            f'no_match={self.no_match!r})'\n        )\n\n    __repr__ = __str__\n\n\nclass CSSParser:\n    \"\"\"Parse CSS selectors.\"\"\"\n\n    css_tokens = (\n        SelectorPattern(\"pseudo_close\", PAT_PSEUDO_CLOSE),\n        SpecialPseudoPattern(\n            (\n                (\n                    \"pseudo_contains\",\n                    (':contains', ':-soup-contains', ':-soup-contains-own'),\n                    PAT_PSEUDO_CONTAINS,\n                    SelectorPattern\n                ),\n                (\"pseudo_nth_child\", (':nth-child', ':nth-last-child'), PAT_PSEUDO_NTH_CHILD, SelectorPattern),\n                (\"pseudo_nth_type\", (':nth-of-type', ':nth-last-of-type'), PAT_PSEUDO_NTH_TYPE, SelectorPattern),\n                (\"pseudo_lang\", (':lang',), PAT_PSEUDO_LANG, SelectorPattern),\n                (\"pseudo_dir\", (':dir',), PAT_PSEUDO_DIR, SelectorPattern)\n            )\n        ),\n        SelectorPattern(\"pseudo_class_custom\", PAT_PSEUDO_CLASS_CUSTOM),\n        SelectorPattern(\"pseudo_class\", PAT_PSEUDO_CLASS),\n        SelectorPattern(\"pseudo_element\", PAT_PSEUDO_ELEMENT),\n        SelectorPattern(\"at_rule\", PAT_AT_RULE),\n        SelectorPattern(\"id\", PAT_ID),\n        SelectorPattern(\"class\", PAT_CLASS),\n        SelectorPattern(\"tag\", PAT_TAG),\n        SelectorPattern(\"attribute\", PAT_ATTR),\n        SelectorPattern(\"combine\", PAT_COMBINE)\n    )\n\n    def __init__(\n        self,\n        selector: str,\n        custom: dict[str, str | ct.SelectorList] | None = None,\n        flags: int = 0\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.pattern = selector.replace('\\x00', '\\ufffd')\n        self.flags = flags\n        self.debug = self.flags & util.DEBUG\n        self.custom = {} if custom is None else custom\n\n    def parse_attribute_selector(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Create attribute selector from the returned regex match.\"\"\"\n\n        inverse = False\n        op = m.group('cmp')\n        case = util.lower(m.group('case')) if m.group('case') else None\n        ns = css_unescape(m.group('attr_ns')[:-1]) if m.group('attr_ns') else ''\n        attr = css_unescape(m.group('attr_name'))\n        is_type = False\n        pattern2 = None\n        value = ''\n\n        if case:\n            flags = (re.I if case == 'i' else 0) | re.DOTALL\n        elif util.lower(attr) == 'type':\n            flags = re.I | re.DOTALL\n            is_type = True\n        else:\n            flags = re.DOTALL\n\n        if op:\n            if m.group('value').startswith(('\"', \"'\")):\n                value = css_unescape(m.group('value')[1:-1], True)\n            else:\n                value = css_unescape(m.group('value'))\n\n        if not op:\n            # Attribute name\n            pattern = None\n        elif op.startswith('^'):\n            # Value start with\n            pattern = re.compile(r'^%s.*' % re.escape(value), flags)\n        elif op.startswith('$'):\n            # Value ends with\n            pattern = re.compile(r'.*?%s$' % re.escape(value), flags)\n        elif op.startswith('*'):\n            # Value contains\n            pattern = re.compile(r'.*?%s.*' % re.escape(value), flags)\n        elif op.startswith('~'):\n            # Value contains word within space separated list\n            # `~=` should match nothing if it is empty or contains whitespace,\n            # so if either of these cases is present, use `[^\\s\\S]` which cannot be matched.\n            value = r'[^\\s\\S]' if not value or RE_WS.search(value) else re.escape(value)\n            pattern = re.compile(r'.*?(?:(?<=^)|(?<=[ \\t\\r\\n\\f]))%s(?=(?:[ \\t\\r\\n\\f]|$)).*' % value, flags)\n        elif op.startswith('|'):\n            # Value starts with word in dash separated list\n            pattern = re.compile(r'^%s(?:-.*)?$' % re.escape(value), flags)\n        else:\n            # Value matches\n            pattern = re.compile(r'^%s$' % re.escape(value), flags)\n            if op.startswith('!'):\n                # Equivalent to `:not([attr=value])`\n                inverse = True\n        if is_type and pattern:\n            pattern2 = re.compile(pattern.pattern)\n\n        # Append the attribute selector\n        sel_attr = ct.SelectorAttribute(attr, ns, pattern, pattern2)\n        if inverse:\n            # If we are using `!=`, we need to nest the pattern under a `:not()`.\n            sub_sel = _Selector()\n            sub_sel.attributes.append(sel_attr)\n            not_list = ct.SelectorList([sub_sel.freeze()], True, False)\n            sel.selectors.append(not_list)\n        else:\n            sel.attributes.append(sel_attr)\n\n        has_selector = True\n        return has_selector\n\n    def parse_tag_pattern(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse tag pattern from regex match.\"\"\"\n\n        prefix = css_unescape(m.group('tag_ns')[:-1]) if m.group('tag_ns') else None\n        tag = css_unescape(m.group('tag_name'))\n        sel.tag = ct.SelectorTag(tag, prefix)\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_class_custom(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"\n        Parse custom pseudo class alias.\n\n        Compile custom selectors as we need them. When compiling a custom selector,\n        set it to `None` in the dictionary so we can avoid an infinite loop.\n        \"\"\"\n\n        pseudo = util.lower(css_unescape(m.group('name')))\n        selector = self.custom.get(pseudo)\n        if selector is None:\n            raise SelectorSyntaxError(\n                f\"Undefined custom selector '{pseudo}' found at position {m.end(0)}\",\n                self.pattern,\n                m.end(0)\n            )\n\n        if not isinstance(selector, ct.SelectorList):\n            del self.custom[pseudo]\n            selector = CSSParser(\n                selector, custom=self.custom, flags=self.flags\n            ).process_selectors(flags=FLG_PSEUDO)\n            self.custom[pseudo] = selector\n\n        sel.selectors.append(selector)\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_class(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]],\n        is_html: bool\n    ) -> tuple[bool, bool]:\n        \"\"\"Parse pseudo class.\"\"\"\n\n        complex_pseudo = False\n        pseudo = util.lower(css_unescape(m.group('name')))\n        if m.group('open'):\n            complex_pseudo = True\n        if complex_pseudo and pseudo in PSEUDO_COMPLEX:\n            has_selector = self.parse_pseudo_open(sel, pseudo, has_selector, iselector, m.end(0))\n        elif not complex_pseudo and pseudo in PSEUDO_SIMPLE:\n            if pseudo == ':root':\n                sel.flags |= ct.SEL_ROOT\n            elif pseudo == ':defined':\n                sel.flags |= ct.SEL_DEFINED\n                is_html = True\n            elif pseudo == ':scope':\n                sel.flags |= ct.SEL_SCOPE\n            elif pseudo == ':empty':\n                sel.flags |= ct.SEL_EMPTY\n            elif pseudo in (':link', ':any-link'):\n                sel.selectors.append(CSS_LINK)\n            elif pseudo == ':checked':\n                sel.selectors.append(CSS_CHECKED)\n            elif pseudo == ':default':\n                sel.selectors.append(CSS_DEFAULT)\n            elif pseudo == ':indeterminate':\n                sel.selectors.append(CSS_INDETERMINATE)\n            elif pseudo == \":disabled\":\n                sel.selectors.append(CSS_DISABLED)\n            elif pseudo == \":enabled\":\n                sel.selectors.append(CSS_ENABLED)\n            elif pseudo == \":required\":\n                sel.selectors.append(CSS_REQUIRED)\n            elif pseudo == \":optional\":\n                sel.selectors.append(CSS_OPTIONAL)\n            elif pseudo == \":read-only\":\n                sel.selectors.append(CSS_READ_ONLY)\n            elif pseudo == \":read-write\":\n                sel.selectors.append(CSS_READ_WRITE)\n            elif pseudo == \":in-range\":\n                sel.selectors.append(CSS_IN_RANGE)\n            elif pseudo == \":out-of-range\":\n                sel.selectors.append(CSS_OUT_OF_RANGE)\n            elif pseudo == \":placeholder-shown\":\n                sel.selectors.append(CSS_PLACEHOLDER_SHOWN)\n            elif pseudo == ':first-child':\n                sel.nth.append(ct.SelectorNth(1, False, 0, False, False, ct.SelectorList()))\n            elif pseudo == ':last-child':\n                sel.nth.append(ct.SelectorNth(1, False, 0, False, True, ct.SelectorList()))\n            elif pseudo == ':first-of-type':\n                sel.nth.append(ct.SelectorNth(1, False, 0, True, False, ct.SelectorList()))\n            elif pseudo == ':last-of-type':\n                sel.nth.append(ct.SelectorNth(1, False, 0, True, True, ct.SelectorList()))\n            elif pseudo == ':only-child':\n                sel.nth.extend(\n                    [\n                        ct.SelectorNth(1, False, 0, False, False, ct.SelectorList()),\n                        ct.SelectorNth(1, False, 0, False, True, ct.SelectorList())\n                    ]\n                )\n            elif pseudo == ':only-of-type':\n                sel.nth.extend(\n                    [\n                        ct.SelectorNth(1, False, 0, True, False, ct.SelectorList()),\n                        ct.SelectorNth(1, False, 0, True, True, ct.SelectorList())\n                    ]\n                )\n            has_selector = True\n        elif complex_pseudo and pseudo in PSEUDO_COMPLEX_NO_MATCH:\n            self.parse_selectors(iselector, m.end(0), FLG_PSEUDO | FLG_OPEN)\n            sel.no_match = True\n            has_selector = True\n        elif not complex_pseudo and pseudo in PSEUDO_SIMPLE_NO_MATCH:\n            sel.no_match = True\n            has_selector = True\n        elif pseudo in PSEUDO_SUPPORTED:\n            raise SelectorSyntaxError(\n                f\"Invalid syntax for pseudo class '{pseudo}'\",\n                self.pattern,\n                m.start(0)\n            )\n        else:\n            raise NotImplementedError(\n                f\"'{pseudo}' pseudo-class is not implemented at this time\"\n            )\n\n        return has_selector, is_html\n\n    def parse_pseudo_nth(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]]\n    ) -> bool:\n        \"\"\"Parse `nth` pseudo.\"\"\"\n\n        mdict = m.groupdict()\n        if mdict.get('pseudo_nth_child'):\n            postfix = '_child'\n        else:\n            postfix = '_type'\n        mdict['name'] = util.lower(css_unescape(mdict['name']))\n        content = util.lower(mdict.get('nth' + postfix))\n        if content == 'even':\n            # 2n\n            s1 = 2\n            s2 = 0\n            var = True\n        elif content == 'odd':\n            # 2n+1\n            s1 = 2\n            s2 = 1\n            var = True\n        else:\n            nth_parts = cast(Match[str], RE_NTH.match(content))\n            _s1 = '-' if nth_parts.group('s1') and nth_parts.group('s1') == '-' else ''\n            a = nth_parts.group('a')\n            var = a.endswith('n')\n            if a.startswith('n'):\n                _s1 += '1'\n            elif var:\n                _s1 += a[:-1]\n            else:\n                _s1 += a\n            _s2 = '-' if nth_parts.group('s2') and nth_parts.group('s2') == '-' else ''\n            if nth_parts.group('b'):\n                _s2 += nth_parts.group('b')\n            else:\n                _s2 = '0'\n            s1 = int(_s1, 10)\n            s2 = int(_s2, 10)\n\n        pseudo_sel = mdict['name']\n        if postfix == '_child':\n            if m.group('of'):\n                # Parse the rest of `of S`.\n                nth_sel = self.parse_selectors(iselector, m.end(0), FLG_PSEUDO | FLG_OPEN)\n            else:\n                # Use default `*|*` for `of S`.\n                nth_sel = CSS_NTH_OF_S_DEFAULT\n            if pseudo_sel == ':nth-child':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, False, False, nth_sel))\n            elif pseudo_sel == ':nth-last-child':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, False, True, nth_sel))\n        else:\n            if pseudo_sel == ':nth-of-type':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, True, False, ct.SelectorList()))\n            elif pseudo_sel == ':nth-last-of-type':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, True, True, ct.SelectorList()))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_open(\n        self,\n        sel: _Selector,\n        name: str,\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]],\n        index: int\n    ) -> bool:\n        \"\"\"Parse pseudo with opening bracket.\"\"\"\n\n        flags = FLG_PSEUDO | FLG_OPEN\n        if name == ':not':\n            flags |= FLG_NOT\n        elif name == ':has':\n            flags |= FLG_RELATIVE\n        elif name in (':where', ':is'):\n            flags |= FLG_FORGIVE\n\n        sel.selectors.append(self.parse_selectors(iselector, index, flags))\n        has_selector = True\n\n        return has_selector\n\n    def parse_has_combinator(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        selectors: list[_Selector],\n        rel_type: str,\n        index: int\n    ) -> tuple[bool, _Selector, str]:\n        \"\"\"Parse combinator tokens.\"\"\"\n\n        combinator = m.group('relation').strip()\n        if not combinator:\n            combinator = WS_COMBINATOR\n        if combinator == COMMA_COMBINATOR:\n            sel.rel_type = rel_type\n            selectors[-1].relations.append(sel)\n            rel_type = \":\" + WS_COMBINATOR\n            selectors.append(_Selector())\n        else:\n            if has_selector:\n                # End the current selector and associate the leading combinator with this selector.\n                sel.rel_type = rel_type\n                selectors[-1].relations.append(sel)\n            elif rel_type[1:] != WS_COMBINATOR:\n                # It's impossible to have two whitespace combinators after each other as the patterns\n                # will gobble up trailing whitespace. It is also impossible to have a whitespace\n                # combinator after any other kind for the same reason. But we could have\n                # multiple non-whitespace combinators. So if the current combinator is not a whitespace,\n                # then we've hit the multiple combinator case, so we should fail.\n                raise SelectorSyntaxError(\n                    f'The multiple combinators at position {index}',\n                    self.pattern,\n                    index\n                )\n\n            # Set the leading combinator for the next selector.\n            rel_type = ':' + combinator\n\n        sel = _Selector()\n        has_selector = False\n        return has_selector, sel, rel_type\n\n    def parse_combinator(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        selectors: list[_Selector],\n        relations: list[_Selector],\n        is_pseudo: bool,\n        is_forgive: bool,\n        index: int\n    ) -> tuple[bool, _Selector]:\n        \"\"\"Parse combinator tokens.\"\"\"\n\n        combinator = m.group('relation').strip()\n        if not combinator:\n            combinator = WS_COMBINATOR\n        if not has_selector:\n            if not is_forgive or combinator != COMMA_COMBINATOR:\n                raise SelectorSyntaxError(\n                    f\"The combinator '{combinator}' at position {index}, must have a selector before it\",\n                    self.pattern,\n                    index\n                )\n\n            # If we are in a forgiving pseudo class, just make the selector a \"no match\"\n            if combinator == COMMA_COMBINATOR:\n                sel.no_match = True\n                del relations[:]\n                selectors.append(sel)\n        else:\n            if combinator == COMMA_COMBINATOR:\n                if not sel.tag and not is_pseudo:\n                    # Implied `*`\n                    sel.tag = ct.SelectorTag('*', None)\n                sel.relations.extend(relations)\n                selectors.append(sel)\n                del relations[:]\n            else:\n                sel.relations.extend(relations)\n                sel.rel_type = combinator\n                del relations[:]\n                relations.append(sel)\n\n        sel = _Selector()\n        has_selector = False\n\n        return has_selector, sel\n\n    def parse_class_id(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse HTML classes and ids.\"\"\"\n\n        selector = m.group(0)\n        if selector.startswith('.'):\n            sel.classes.append(css_unescape(selector[1:]))\n        else:\n            sel.ids.append(css_unescape(selector[1:]))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_contains(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse contains.\"\"\"\n\n        pseudo = util.lower(css_unescape(m.group('name')))\n        if pseudo == \":contains\":\n            warnings.warn(  # noqa: B028\n                \"The pseudo class ':contains' is deprecated, ':-soup-contains' should be used moving forward.\",\n                FutureWarning\n            )\n        contains_own = pseudo == \":-soup-contains-own\"\n        values = css_unescape(m.group('values'))\n        patterns = []\n        for token in RE_VALUES.finditer(values):\n            if token.group('split'):\n                continue\n            value = token.group('value')\n            if value.startswith((\"'\", '\"')):\n                value = css_unescape(value[1:-1], True)\n            else:\n                value = css_unescape(value)\n            patterns.append(value)\n        sel.contains.append(ct.SelectorContains(patterns, contains_own))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_lang(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse pseudo language.\"\"\"\n\n        values = m.group('values')\n        patterns = []\n        for token in RE_VALUES.finditer(values):\n            if token.group('split'):\n                continue\n            value = token.group('value')\n            if value.startswith(('\"', \"'\")):\n                value = css_unescape(value[1:-1], True)\n            else:\n                value = css_unescape(value)\n\n            patterns.append(value)\n\n        sel.lang.append(ct.SelectorLang(patterns))\n        has_selector = True\n\n        return has_selector\n\n    def parse_pseudo_dir(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse pseudo direction.\"\"\"\n\n        value = ct.SEL_DIR_LTR if util.lower(m.group('dir')) == 'ltr' else ct.SEL_DIR_RTL\n        sel.flags |= value\n        has_selector = True\n        return has_selector\n\n    def parse_selectors(\n        self,\n        iselector: Iterator[tuple[str, Match[str]]],\n        index: int = 0,\n        flags: int = 0\n    ) -> ct.SelectorList:\n        \"\"\"Parse selectors.\"\"\"\n\n        # Initialize important variables\n        sel = _Selector()\n        selectors = []\n        has_selector = False\n        closed = False\n        relations = []  # type: list[_Selector]\n        rel_type = \":\" + WS_COMBINATOR\n\n        # Setup various flags\n        is_open = bool(flags & FLG_OPEN)\n        is_pseudo = bool(flags & FLG_PSEUDO)\n        is_relative = bool(flags & FLG_RELATIVE)\n        is_not = bool(flags & FLG_NOT)\n        is_html = bool(flags & FLG_HTML)\n        is_default = bool(flags & FLG_DEFAULT)\n        is_indeterminate = bool(flags & FLG_INDETERMINATE)\n        is_in_range = bool(flags & FLG_IN_RANGE)\n        is_out_of_range = bool(flags & FLG_OUT_OF_RANGE)\n        is_placeholder_shown = bool(flags & FLG_PLACEHOLDER_SHOWN)\n        is_forgive = bool(flags & FLG_FORGIVE)\n\n        # Print out useful debug stuff\n        if self.debug:  # pragma: no cover\n            if is_pseudo:\n                print('    is_pseudo: True')\n            if is_open:\n                print('    is_open: True')\n            if is_relative:\n                print('    is_relative: True')\n            if is_not:\n                print('    is_not: True')\n            if is_html:\n                print('    is_html: True')\n            if is_default:\n                print('    is_default: True')\n            if is_indeterminate:\n                print('    is_indeterminate: True')\n            if is_in_range:\n                print('    is_in_range: True')\n            if is_out_of_range:\n                print('    is_out_of_range: True')\n            if is_placeholder_shown:\n                print('    is_placeholder_shown: True')\n            if is_forgive:\n                print('    is_forgive: True')\n\n        # The algorithm for relative selectors require an initial selector in the selector list\n        if is_relative:\n            selectors.append(_Selector())\n\n        try:\n            while True:\n                key, m = next(iselector)\n\n                # Handle parts\n                if key == \"at_rule\":\n                    raise NotImplementedError(f\"At-rules found at position {m.start(0)}\")\n                elif key == 'pseudo_class_custom':\n                    has_selector = self.parse_pseudo_class_custom(sel, m, has_selector)\n                elif key == 'pseudo_class':\n                    has_selector, is_html = self.parse_pseudo_class(sel, m, has_selector, iselector, is_html)\n                elif key == 'pseudo_element':\n                    raise NotImplementedError(f\"Pseudo-element found at position {m.start(0)}\")\n                elif key == 'pseudo_contains':\n                    has_selector = self.parse_pseudo_contains(sel, m, has_selector)\n                elif key in ('pseudo_nth_type', 'pseudo_nth_child'):\n                    has_selector = self.parse_pseudo_nth(sel, m, has_selector, iselector)\n                elif key == 'pseudo_lang':\n                    has_selector = self.parse_pseudo_lang(sel, m, has_selector)\n                elif key == 'pseudo_dir':\n                    has_selector = self.parse_pseudo_dir(sel, m, has_selector)\n                    # Currently only supports HTML\n                    is_html = True\n                elif key == 'pseudo_close':\n                    if not has_selector:\n                        if not is_forgive:\n                            raise SelectorSyntaxError(\n                                f\"Expected a selector at position {m.start(0)}\",\n                                self.pattern,\n                                m.start(0)\n                            )\n                        sel.no_match = True\n                    if is_open:\n                        closed = True\n                        break\n                    else:\n                        raise SelectorSyntaxError(\n                            f\"Unmatched pseudo-class close at position {m.start(0)}\",\n                            self.pattern,\n                            m.start(0)\n                        )\n                elif key == 'combine':\n                    if is_relative:\n                        has_selector, sel, rel_type = self.parse_has_combinator(\n                            sel, m, has_selector, selectors, rel_type, index\n                        )\n                    else:\n                        has_selector, sel = self.parse_combinator(\n                            sel, m, has_selector, selectors, relations, is_pseudo, is_forgive, index\n                        )\n                elif key == 'attribute':\n                    has_selector = self.parse_attribute_selector(sel, m, has_selector)\n                elif key == 'tag':\n                    if has_selector:\n                        raise SelectorSyntaxError(\n                            f\"Tag name found at position {m.start(0)} instead of at the start\",\n                            self.pattern,\n                            m.start(0)\n                        )\n                    has_selector = self.parse_tag_pattern(sel, m, has_selector)\n                elif key in ('class', 'id'):\n                    has_selector = self.parse_class_id(sel, m, has_selector)\n\n                index = m.end(0)\n        except StopIteration:\n            pass\n\n        # Handle selectors that are not closed\n        if is_open and not closed:\n            raise SelectorSyntaxError(\n                f\"Unclosed pseudo-class at position {index}\",\n                self.pattern,\n                index\n            )\n\n        # Cleanup completed selector piece\n        if has_selector:\n            if not sel.tag and not is_pseudo:\n                # Implied `*`\n                sel.tag = ct.SelectorTag('*', None)\n            if is_relative:\n                sel.rel_type = rel_type\n                selectors[-1].relations.append(sel)\n            else:\n                sel.relations.extend(relations)\n                del relations[:]\n                selectors.append(sel)\n\n        # Forgive empty slots in pseudo-classes that have lists (and are forgiving)\n        elif is_forgive and (not selectors or not relations):\n            # Handle normal pseudo-classes with empty slots like `:is()` etc.\n            sel.no_match = True\n            del relations[:]\n            selectors.append(sel)\n            has_selector = True\n\n        if not has_selector:\n            # We will always need to finish a selector when `:has()` is used as it leads with combining.\n            # May apply to others as well.\n            raise SelectorSyntaxError(\n                f'Expected a selector at position {index}',\n                self.pattern,\n                index\n            )\n\n        # Some patterns require additional logic, such as default. We try to make these the\n        # last pattern, and append the appropriate flag to that selector which communicates\n        # to the matcher what additional logic is required.\n        if is_default:\n            selectors[-1].flags = ct.SEL_DEFAULT\n        if is_indeterminate:\n            selectors[-1].flags = ct.SEL_INDETERMINATE\n        if is_in_range:\n            selectors[-1].flags = ct.SEL_IN_RANGE\n        if is_out_of_range:\n            selectors[-1].flags = ct.SEL_OUT_OF_RANGE\n        if is_placeholder_shown:\n            selectors[-1].flags = ct.SEL_PLACEHOLDER_SHOWN\n\n        # Return selector list\n        return ct.SelectorList([s.freeze() for s in selectors], is_not, is_html)\n\n    def selector_iter(self, pattern: str) -> Iterator[tuple[str, Match[str]]]:\n        \"\"\"Iterate selector tokens.\"\"\"\n\n        # Ignore whitespace and comments at start and end of pattern\n        m = RE_WS_BEGIN.search(pattern)\n        index = m.end(0) if m else 0\n        m = RE_WS_END.search(pattern)\n        end = (m.start(0) - 1) if m else (len(pattern) - 1)\n\n        if self.debug:  # pragma: no cover\n            print(f'## PARSING: {pattern!r}')\n        while index <= end:\n            m = None\n            for v in self.css_tokens:\n                m = v.match(pattern, index, self.flags)\n                if m:\n                    name = v.get_name()\n                    if self.debug:  # pragma: no cover\n                        print(f\"TOKEN: '{name}' --> {m.group(0)!r} at position {m.start(0)}\")\n                    index = m.end(0)\n                    yield name, m\n                    break\n            if m is None:\n                c = pattern[index]\n                # If the character represents the start of one of the known selector types,\n                # throw an exception mentioning that the known selector type is in error;\n                # otherwise, report the invalid character.\n                if c == '[':\n                    msg = f\"Malformed attribute selector at position {index}\"\n                elif c == '.':\n                    msg = f\"Malformed class selector at position {index}\"\n                elif c == '#':\n                    msg = f\"Malformed id selector at position {index}\"\n                elif c == ':':\n                    msg = f\"Malformed pseudo-class selector at position {index}\"\n                else:\n                    msg = f\"Invalid character {c!r} position {index}\"\n                raise SelectorSyntaxError(msg, self.pattern, index)\n        if self.debug:  # pragma: no cover\n            print('## END PARSING')\n\n    def process_selectors(self, index: int = 0, flags: int = 0) -> ct.SelectorList:\n        \"\"\"Process selectors.\"\"\"\n\n        return self.parse_selectors(self.selector_iter(self.pattern), index, flags)\n\n\n# Precompile CSS selector lists for pseudo-classes (additional logic may be required beyond the pattern)\n# A few patterns are order dependent as they use patterns previous compiled.\n\n# CSS pattern for `:link` and `:any-link`\nCSS_LINK = CSSParser(\n    'html|*:is(a, area)[href]'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:checked`\nCSS_CHECKED = CSSParser(\n    '''\n    html|*:is(input[type=checkbox], input[type=radio])[checked], html|option[selected]\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:default` (must compile CSS_CHECKED first)\nCSS_DEFAULT = CSSParser(\n    '''\n    :checked,\n\n    /*\n    This pattern must be at the end.\n    Special logic is applied to the last selector.\n    */\n    html|form html|*:is(button, input)[type=\"submit\"]\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_DEFAULT)\n# CSS pattern for `:indeterminate`\nCSS_INDETERMINATE = CSSParser(\n    '''\n    html|input[type=\"checkbox\"][indeterminate],\n    html|input[type=\"radio\"]:is(:not([name]), [name=\"\"]):not([checked]),\n    html|progress:not([value]),\n\n    /*\n    This pattern must be at the end.\n    Special logic is applied to the last selector.\n    */\n    html|input[type=\"radio\"][name]:not([name='']):not([checked])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_INDETERMINATE)\n# CSS pattern for `:disabled`\nCSS_DISABLED = CSSParser(\n    '''\n    html|*:is(input:not([type=hidden]), button, select, textarea, fieldset, optgroup, option, fieldset)[disabled],\n    html|optgroup[disabled] > html|option,\n    html|fieldset[disabled] > html|*:is(input:not([type=hidden]), button, select, textarea, fieldset),\n    html|fieldset[disabled] >\n        html|*:not(legend:nth-of-type(1)) html|*:is(input:not([type=hidden]), button, select, textarea, fieldset)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:enabled`\nCSS_ENABLED = CSSParser(\n    '''\n    html|*:is(input:not([type=hidden]), button, select, textarea, fieldset, optgroup, option, fieldset):not(:disabled)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:required`\nCSS_REQUIRED = CSSParser(\n    'html|*:is(input, textarea, select)[required]'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:optional`\nCSS_OPTIONAL = CSSParser(\n    'html|*:is(input, textarea, select):not([required])'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:placeholder-shown`\nCSS_PLACEHOLDER_SHOWN = CSSParser(\n    '''\n    html|input:is(\n        :not([type]),\n        [type=\"\"],\n        [type=text],\n        [type=search],\n        [type=url],\n        [type=tel],\n        [type=email],\n        [type=password],\n        [type=number]\n    )[placeholder]:not([placeholder='']):is(:not([value]), [value=\"\"]),\n    html|textarea[placeholder]:not([placeholder=''])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_PLACEHOLDER_SHOWN)\n# CSS pattern default for `:nth-child` \"of S\" feature\nCSS_NTH_OF_S_DEFAULT = CSSParser(\n    '*|*'\n).process_selectors(flags=FLG_PSEUDO)\n# CSS pattern for `:read-write` (CSS_DISABLED must be compiled first)\nCSS_READ_WRITE = CSSParser(\n    '''\n    html|*:is(\n        textarea,\n        input:is(\n            :not([type]),\n            [type=\"\"],\n            [type=text],\n            [type=search],\n            [type=url],\n            [type=tel],\n            [type=email],\n            [type=number],\n            [type=password],\n            [type=date],\n            [type=datetime-local],\n            [type=month],\n            [type=time],\n            [type=week]\n        )\n    ):not([readonly], :disabled),\n    html|*:is([contenteditable=\"\"], [contenteditable=\"true\" i])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:read-only`\nCSS_READ_ONLY = CSSParser(\n    '''\n    html|*:not(:read-write)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:in-range`\nCSS_IN_RANGE = CSSParser(\n    '''\n    html|input:is(\n        [type=\"date\"],\n        [type=\"month\"],\n        [type=\"week\"],\n        [type=\"time\"],\n        [type=\"datetime-local\"],\n        [type=\"number\"],\n        [type=\"range\"]\n    ):is(\n        [min],\n        [max]\n    )\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_IN_RANGE | FLG_HTML)\n# CSS pattern for `:out-of-range`\nCSS_OUT_OF_RANGE = CSSParser(\n    '''\n    html|input:is(\n        [type=\"date\"],\n        [type=\"month\"],\n        [type=\"week\"],\n        [type=\"time\"],\n        [type=\"datetime-local\"],\n        [type=\"number\"],\n        [type=\"range\"]\n    ):is(\n        [min],\n        [max]\n    )\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_OUT_OF_RANGE | FLG_HTML)\n", "soupsieve/__meta__.py": "\"\"\"Meta related things.\"\"\"\nfrom __future__ import annotations\nfrom collections import namedtuple\nimport re\n\nRE_VER = re.compile(\n    r'''(?x)\n    (?P<major>\\d+)(?:\\.(?P<minor>\\d+))?(?:\\.(?P<micro>\\d+))?\n    (?:(?P<type>a|b|rc)(?P<pre>\\d+))?\n    (?:\\.post(?P<post>\\d+))?\n    (?:\\.dev(?P<dev>\\d+))?\n    '''\n)\n\nREL_MAP = {\n    \".dev\": \"\",\n    \".dev-alpha\": \"a\",\n    \".dev-beta\": \"b\",\n    \".dev-candidate\": \"rc\",\n    \"alpha\": \"a\",\n    \"beta\": \"b\",\n    \"candidate\": \"rc\",\n    \"final\": \"\"\n}\n\nDEV_STATUS = {\n    \".dev\": \"2 - Pre-Alpha\",\n    \".dev-alpha\": \"2 - Pre-Alpha\",\n    \".dev-beta\": \"2 - Pre-Alpha\",\n    \".dev-candidate\": \"2 - Pre-Alpha\",\n    \"alpha\": \"3 - Alpha\",\n    \"beta\": \"4 - Beta\",\n    \"candidate\": \"4 - Beta\",\n    \"final\": \"5 - Production/Stable\"\n}\n\nPRE_REL_MAP = {\"a\": 'alpha', \"b\": 'beta', \"rc\": 'candidate'}\n\n\nclass Version(namedtuple(\"Version\", [\"major\", \"minor\", \"micro\", \"release\", \"pre\", \"post\", \"dev\"])):\n    \"\"\"\n    Get the version (PEP 440).\n\n    A biased approach to the PEP 440 semantic version.\n\n    Provides a tuple structure which is sorted for comparisons `v1 > v2` etc.\n      (major, minor, micro, release type, pre-release build, post-release build, development release build)\n    Release types are named in is such a way they are comparable with ease.\n    Accessors to check if a development, pre-release, or post-release build. Also provides accessor to get\n    development status for setup files.\n\n    How it works (currently):\n\n    - You must specify a release type as either `final`, `alpha`, `beta`, or `candidate`.\n    - To define a development release, you can use either `.dev`, `.dev-alpha`, `.dev-beta`, or `.dev-candidate`.\n      The dot is used to ensure all development specifiers are sorted before `alpha`.\n      You can specify a `dev` number for development builds, but do not have to as implicit development releases\n      are allowed.\n    - You must specify a `pre` value greater than zero if using a prerelease as this project (not PEP 440) does not\n      allow implicit prereleases.\n    - You can optionally set `post` to a value greater than zero to make the build a post release. While post releases\n      are technically allowed in prereleases, it is strongly discouraged, so we are rejecting them. It should be\n      noted that we do not allow `post0` even though PEP 440 does not restrict this. This project specifically\n      does not allow implicit post releases.\n    - It should be noted that we do not support epochs `1!` or local versions `+some-custom.version-1`.\n\n    Acceptable version releases:\n\n    ```\n    Version(1, 0, 0, \"final\")                    1.0\n    Version(1, 2, 0, \"final\")                    1.2\n    Version(1, 2, 3, \"final\")                    1.2.3\n    Version(1, 2, 0, \".dev-alpha\", pre=4)        1.2a4\n    Version(1, 2, 0, \".dev-beta\", pre=4)         1.2b4\n    Version(1, 2, 0, \".dev-candidate\", pre=4)    1.2rc4\n    Version(1, 2, 0, \"final\", post=1)            1.2.post1\n    Version(1, 2, 3, \".dev\")                     1.2.3.dev0\n    Version(1, 2, 3, \".dev\", dev=1)              1.2.3.dev1\n    ```\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        major: int, minor: int, micro: int, release: str = \"final\",\n        pre: int = 0, post: int = 0, dev: int = 0\n    ) -> Version:\n        \"\"\"Validate version info.\"\"\"\n\n        # Ensure all parts are positive integers.\n        for value in (major, minor, micro, pre, post):\n            if not (isinstance(value, int) and value >= 0):\n                raise ValueError(\"All version parts except 'release' should be integers.\")\n\n        if release not in REL_MAP:\n            raise ValueError(f\"'{release}' is not a valid release type.\")\n\n        # Ensure valid pre-release (we do not allow implicit pre-releases).\n        if \".dev-candidate\" < release < \"final\":\n            if pre == 0:\n                raise ValueError(\"Implicit pre-releases not allowed.\")\n            elif dev:\n                raise ValueError(\"Version is not a development release.\")\n            elif post:\n                raise ValueError(\"Post-releases are not allowed with pre-releases.\")\n\n        # Ensure valid development or development/pre release\n        elif release < \"alpha\":\n            if release > \".dev\" and pre == 0:\n                raise ValueError(\"Implicit pre-release not allowed.\")\n            elif post:\n                raise ValueError(\"Post-releases are not allowed with pre-releases.\")\n\n        # Ensure a valid normal release\n        else:\n            if pre:\n                raise ValueError(\"Version is not a pre-release.\")\n            elif dev:\n                raise ValueError(\"Version is not a development release.\")\n\n        return super().__new__(cls, major, minor, micro, release, pre, post, dev)\n\n    def _is_pre(self) -> bool:\n        \"\"\"Is prerelease.\"\"\"\n\n        return bool(self.pre > 0)\n\n    def _is_dev(self) -> bool:\n        \"\"\"Is development.\"\"\"\n\n        return bool(self.release < \"alpha\")\n\n    def _is_post(self) -> bool:\n        \"\"\"Is post.\"\"\"\n\n        return bool(self.post > 0)\n\n    def _get_dev_status(self) -> str:  # pragma: no cover\n        \"\"\"Get development status string.\"\"\"\n\n        return DEV_STATUS[self.release]\n\n    def _get_canonical(self) -> str:\n        \"\"\"Get the canonical output string.\"\"\"\n\n        # Assemble major, minor, micro version and append `pre`, `post`, or `dev` if needed..\n        if self.micro == 0:\n            ver = f\"{self.major}.{self.minor}\"\n        else:\n            ver = f\"{self.major}.{self.minor}.{self.micro}\"\n        if self._is_pre():\n            ver += f'{REL_MAP[self.release]}{self.pre}'\n        if self._is_post():\n            ver += f\".post{self.post}\"\n        if self._is_dev():\n            ver += f\".dev{self.dev}\"\n\n        return ver\n\n\ndef parse_version(ver: str) -> Version:\n    \"\"\"Parse version into a comparable Version tuple.\"\"\"\n\n    m = RE_VER.match(ver)\n\n    if m is None:\n        raise ValueError(f\"'{ver}' is not a valid version\")\n\n    # Handle major, minor, micro\n    major = int(m.group('major'))\n    minor = int(m.group('minor')) if m.group('minor') else 0\n    micro = int(m.group('micro')) if m.group('micro') else 0\n\n    # Handle pre releases\n    if m.group('type'):\n        release = PRE_REL_MAP[m.group('type')]\n        pre = int(m.group('pre'))\n    else:\n        release = \"final\"\n        pre = 0\n\n    # Handle development releases\n    dev = m.group('dev') if m.group('dev') else 0\n    if m.group('dev'):\n        dev = int(m.group('dev'))\n        release = '.dev-' + release if pre else '.dev'\n    else:\n        dev = 0\n\n    # Handle post\n    post = int(m.group('post')) if m.group('post') else 0\n\n    return Version(major, minor, micro, release, pre, post, dev)\n\n\n__version_info__ = Version(2, 5, 0, \"final\")\n__version__ = __version_info__._get_canonical()\n", "soupsieve/util.py": "\"\"\"Utility.\"\"\"\nfrom __future__ import annotations\nfrom functools import wraps, lru_cache\nimport warnings\nimport re\nfrom typing import Callable, Any\n\nDEBUG = 0x00001\n\nRE_PATTERN_LINE_SPLIT = re.compile(r'(?:\\r\\n|(?!\\r\\n)[\\n\\r])|$')\n\nUC_A = ord('A')\nUC_Z = ord('Z')\n\n\n@lru_cache(maxsize=512)\ndef lower(string: str) -> str:\n    \"\"\"Lower.\"\"\"\n\n    new_string = []\n    for c in string:\n        o = ord(c)\n        new_string.append(chr(o + 32) if UC_A <= o <= UC_Z else c)\n    return ''.join(new_string)\n\n\nclass SelectorSyntaxError(Exception):\n    \"\"\"Syntax error in a CSS selector.\"\"\"\n\n    def __init__(self, msg: str, pattern: str | None = None, index: int | None = None) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.line = None\n        self.col = None\n        self.context = None\n\n        if pattern is not None and index is not None:\n            # Format pattern to show line and column position\n            self.context, self.line, self.col = get_pattern_context(pattern, index)\n            msg = f'{msg}\\n  line {self.line}:\\n{self.context}'\n\n        super().__init__(msg)\n\n\ndef deprecated(message: str, stacklevel: int = 2) -> Callable[..., Any]:  # pragma: no cover\n    \"\"\"\n    Raise a `DeprecationWarning` when wrapped function/method is called.\n\n    Usage:\n\n        @deprecated(\"This method will be removed in version X; use Y instead.\")\n        def some_method()\"\n            pass\n    \"\"\"\n\n    def _wrapper(func: Callable[..., Any]) -> Callable[..., Any]:\n        @wraps(func)\n        def _deprecated_func(*args: Any, **kwargs: Any) -> Any:\n            warnings.warn(\n                f\"'{func.__name__}' is deprecated. {message}\",\n                category=DeprecationWarning,\n                stacklevel=stacklevel\n            )\n            return func(*args, **kwargs)\n        return _deprecated_func\n    return _wrapper\n\n\ndef warn_deprecated(message: str, stacklevel: int = 2) -> None:  # pragma: no cover\n    \"\"\"Warn deprecated.\"\"\"\n\n    warnings.warn(\n        message,\n        category=DeprecationWarning,\n        stacklevel=stacklevel\n    )\n\n\ndef get_pattern_context(pattern: str, index: int) -> tuple[str, int, int]:\n    \"\"\"Get the pattern context.\"\"\"\n\n    last = 0\n    current_line = 1\n    col = 1\n    text = []  # type: list[str]\n    line = 1\n    offset = None  # type: int | None\n\n    # Split pattern by newline and handle the text before the newline\n    for m in RE_PATTERN_LINE_SPLIT.finditer(pattern):\n        linetext = pattern[last:m.start(0)]\n        if not len(m.group(0)) and not len(text):\n            indent = ''\n            offset = -1\n            col = index - last + 1\n        elif last <= index < m.end(0):\n            indent = '--> '\n            offset = (-1 if index > m.start(0) else 0) + 3\n            col = index - last + 1\n        else:\n            indent = '    '\n            offset = None\n        if len(text):\n            # Regardless of whether we are presented with `\\r\\n`, `\\r`, or `\\n`,\n            # we will render the output with just `\\n`. We will still log the column\n            # correctly though.\n            text.append('\\n')\n        text.append(f'{indent}{linetext}')\n        if offset is not None:\n            text.append('\\n')\n            text.append(' ' * (col + offset) + '^')\n            line = current_line\n\n        current_line += 1\n        last = m.end(0)\n\n    return ''.join(text), line, col\n", "soupsieve/__init__.py": "\"\"\"\nSoup Sieve.\n\nA CSS selector filter for BeautifulSoup4.\n\nMIT License\n\nCopyright (c) 2018 Isaac Muse\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\nfrom __future__ import annotations\nfrom .__meta__ import __version__, __version_info__  # noqa: F401\nfrom . import css_parser as cp\nfrom . import css_match as cm\nfrom . import css_types as ct\nfrom .util import DEBUG, SelectorSyntaxError  # noqa: F401\nimport bs4  # type: ignore[import]\nfrom typing import Any, Iterator, Iterable\n\n__all__ = (\n    'DEBUG', 'SelectorSyntaxError', 'SoupSieve',\n    'closest', 'compile', 'filter', 'iselect',\n    'match', 'select', 'select_one'\n)\n\nSoupSieve = cm.SoupSieve\n\n\ndef compile(  # noqa: A001\n    pattern: str,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> cm.SoupSieve:\n    \"\"\"Compile CSS pattern.\"\"\"\n\n    if isinstance(pattern, SoupSieve):\n        if flags:\n            raise ValueError(\"Cannot process 'flags' argument on a compiled selector list\")\n        elif namespaces is not None:\n            raise ValueError(\"Cannot process 'namespaces' argument on a compiled selector list\")\n        elif custom is not None:\n            raise ValueError(\"Cannot process 'custom' argument on a compiled selector list\")\n        return pattern\n\n    return cp._cached_css_compile(\n        pattern,\n        ct.Namespaces(namespaces) if namespaces is not None else namespaces,\n        ct.CustomSelectors(custom) if custom is not None else custom,\n        flags\n    )\n\n\ndef purge() -> None:\n    \"\"\"Purge cached patterns.\"\"\"\n\n    cp._purge_cache()\n\n\ndef closest(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> bs4.Tag:\n    \"\"\"Match closest ancestor.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).closest(tag)\n\n\ndef match(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> bool:\n    \"\"\"Match node.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).match(tag)\n\n\ndef filter(  # noqa: A001\n    select: str,\n    iterable: Iterable[bs4.Tag],\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> list[bs4.Tag]:\n    \"\"\"Filter list of nodes.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).filter(iterable)\n\n\ndef select_one(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> bs4.Tag:\n    \"\"\"Select a single tag.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).select_one(tag)\n\n\ndef select(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    limit: int = 0,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> list[bs4.Tag]:\n    \"\"\"Select the specified tags.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).select(tag, limit)\n\n\ndef iselect(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    limit: int = 0,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> Iterator[bs4.Tag]:\n    \"\"\"Iterate the specified tags.\"\"\"\n\n    yield from compile(select, namespaces, flags, **kwargs).iselect(tag, limit)\n\n\ndef escape(ident: str) -> str:\n    \"\"\"Escape identifier.\"\"\"\n\n    return cp.escape(ident)\n", "tests/test_quirks.py": "\"\"\"Test quirky behaviors.\"\"\"\nfrom . import util\nfrom bs4 import BeautifulSoup\n\n\nclass TestQuirks(util.TestCase):\n    \"\"\"Test quirky behaviors.\"\"\"\n\n    def test_quirky_user_attrs(self):\n        \"\"\"Test cases where a user creates weird attributes: nested sequences.\"\"\"\n\n        html = \"\"\"\n        <div id=\"test\">test</div>\n        \"\"\"\n\n        soup = BeautifulSoup(html, 'html.parser')\n        soup.div.attrs['user'] = [['a']]\n        print(soup.div.attrs)\n        self.assertTrue(soup.select_one('div[user=\"[\\'a\\']\"]') is not None)\n", "tests/test_versions.py": "\"\"\"Version tests.\"\"\"\nimport unittest\nfrom soupsieve.__meta__ import Version, parse_version\n\n\nclass TestVersion(unittest.TestCase):\n    \"\"\"Test versions.\"\"\"\n\n    def test_version_output(self):\n        \"\"\"Test that versions generate proper strings.\"\"\"\n\n        assert Version(1, 0, 0, \"final\")._get_canonical() == \"1.0\"\n        assert Version(1, 2, 0, \"final\")._get_canonical() == \"1.2\"\n        assert Version(1, 2, 3, \"final\")._get_canonical() == \"1.2.3\"\n        assert Version(1, 2, 0, \"alpha\", pre=4)._get_canonical() == \"1.2a4\"\n        assert Version(1, 2, 0, \"beta\", pre=4)._get_canonical() == \"1.2b4\"\n        assert Version(1, 2, 0, \"candidate\", pre=4)._get_canonical() == \"1.2rc4\"\n        assert Version(1, 2, 0, \"final\", post=1)._get_canonical() == \"1.2.post1\"\n        assert Version(1, 2, 3, \".dev-alpha\", pre=1)._get_canonical() == \"1.2.3a1.dev0\"\n        assert Version(1, 2, 3, \".dev\")._get_canonical() == \"1.2.3.dev0\"\n        assert Version(1, 2, 3, \".dev\", dev=1)._get_canonical() == \"1.2.3.dev1\"\n\n    def test_version_comparison(self):\n        \"\"\"Test that versions compare proper.\"\"\"\n\n        assert Version(1, 0, 0, \"final\") < Version(1, 2, 0, \"final\")\n        assert Version(1, 2, 0, \"alpha\", pre=4) < Version(1, 2, 0, \"final\")\n        assert Version(1, 2, 0, \"final\") < Version(1, 2, 0, \"final\", post=1)\n        assert Version(1, 2, 3, \".dev-beta\", pre=2) < Version(1, 2, 3, \"beta\", pre=2)\n        assert Version(1, 2, 3, \".dev\") < Version(1, 2, 3, \".dev-beta\", pre=2)\n        assert Version(1, 2, 3, \".dev\") < Version(1, 2, 3, \".dev\", dev=1)\n\n    def test_version_parsing(self):\n        \"\"\"Test version parsing.\"\"\"\n\n        assert parse_version(\n            Version(1, 0, 0, \"final\")._get_canonical()\n        ) == Version(1, 0, 0, \"final\")\n        assert parse_version(\n            Version(1, 2, 0, \"final\")._get_canonical()\n        ) == Version(1, 2, 0, \"final\")\n        assert parse_version(\n            Version(1, 2, 3, \"final\")._get_canonical()\n        ) == Version(1, 2, 3, \"final\")\n        assert parse_version(\n            Version(1, 2, 0, \"alpha\", pre=4)._get_canonical()\n        ) == Version(1, 2, 0, \"alpha\", pre=4)\n        assert parse_version(\n            Version(1, 2, 0, \"beta\", pre=4)._get_canonical()\n        ) == Version(1, 2, 0, \"beta\", pre=4)\n        assert parse_version(\n            Version(1, 2, 0, \"candidate\", pre=4)._get_canonical()\n        ) == Version(1, 2, 0, \"candidate\", pre=4)\n        assert parse_version(\n            Version(1, 2, 0, \"final\", post=1)._get_canonical()\n        ) == Version(1, 2, 0, \"final\", post=1)\n        assert parse_version(\n            Version(1, 2, 3, \".dev-alpha\", pre=1)._get_canonical()\n        ) == Version(1, 2, 3, \".dev-alpha\", pre=1)\n        assert parse_version(\n            Version(1, 2, 3, \".dev\")._get_canonical()\n        ) == Version(1, 2, 3, \".dev\")\n        assert parse_version(\n            Version(1, 2, 3, \".dev\", dev=1)._get_canonical()\n        ) == Version(1, 2, 3, \".dev\", dev=1)\n\n    def test_asserts(self):\n        \"\"\"Test asserts.\"\"\"\n\n        with self.assertRaises(ValueError):\n            Version(\"1\", \"2\", \"3\")\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, 1)\n        with self.assertRaises(ValueError):\n            Version(\"1\", \"2\", \"3\")\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, \"bad\")\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, \"alpha\")\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, \"alpha\", pre=1, dev=1)\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, \"alpha\", pre=1, post=1)\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, \".dev-alpha\")\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, \".dev-alpha\", pre=1, post=1)\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, pre=1)\n        with self.assertRaises(ValueError):\n            Version(1, 2, 3, dev=1)\n        with self.assertRaises(ValueError):\n            parse_version('bad&version')\n", "tests/util.py": "\"\"\"Test utilities.\"\"\"\nimport unittest\nimport bs4\nimport textwrap\nimport soupsieve as sv\nimport pytest\n\ntry:\n    from bs4.builder import HTML5TreeBuilder  # noqa: F401\n    HTML5LIB_PRESENT = True\nexcept ImportError:\n    HTML5LIB_PRESENT = False\n\ntry:\n    from bs4.builder import LXMLTreeBuilderForXML, LXMLTreeBuilder  # noqa: F401\n    LXML_PRESENT = True\nexcept ImportError:\n    LXML_PRESENT = False\n\nHTML5 = 0x1\nHTML = 0x2\nXHTML = 0x4\nXML = 0x8\nPYHTML = 0x10\nLXML_HTML = 0x20\n\n\ndef skip_no_lxml(func):\n    \"\"\"Decorator that skips lxml is not available.\"\"\"\n\n    def skip_if(self, *args, **kwargs):\n        \"\"\"Skip conditional wrapper.\"\"\"\n\n        if LXML_PRESENT:\n            return func(self, *args, **kwargs)\n        else:\n            raise pytest.skip('lxml is not found')\n\n\nclass TestCase(unittest.TestCase):\n    \"\"\"Test case.\"\"\"\n\n    def wrap_xhtml(self, html):\n        \"\"\"Wrap HTML content with XHTML header and body.\"\"\"\n\n        return f\"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n            \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n        <head>\n        </head>\n        <body>\n        {html}\n        </body>\n        </html>\n        \"\"\"\n\n    def setUp(self):\n        \"\"\"Setup.\"\"\"\n\n        sv.purge()\n\n    def purge(self):\n        \"\"\"Purge cache.\"\"\"\n\n        sv.purge()\n\n    def compile_pattern(self, selectors, namespaces=None, custom=None, flags=0):\n        \"\"\"Compile pattern.\"\"\"\n\n        print('PATTERN: ', selectors)\n        flags |= sv.DEBUG\n        return sv.compile(selectors, namespaces=namespaces, custom=custom, flags=flags)\n\n    def soup(self, markup, parser):\n        \"\"\"Get soup.\"\"\"\n\n        print('\\n====PARSER: ', parser)\n        return bs4.BeautifulSoup(textwrap.dedent(markup.replace('\\r\\n', '\\n')), parser)\n\n    def get_parsers(self, flags):\n        \"\"\"Get parsers.\"\"\"\n\n        mode = flags & 0x3F\n        if mode == HTML:\n            parsers = ('html5lib', 'lxml', 'html.parser')\n        elif mode == PYHTML:\n            parsers = ('html.parser',)\n        elif mode == LXML_HTML:\n            parsers = ('lxml',)\n        elif mode in (HTML5, 0):\n            parsers = ('html5lib',)\n        elif mode in (XHTML, XML):\n            parsers = ('xml',)\n\n        return parsers\n\n    def assert_raises(self, pattern, exception, namespace=None, custom=None):\n        \"\"\"Assert raises.\"\"\"\n\n        print('----Running Assert Test----')\n        with self.assertRaises(exception):\n            self.compile_pattern(pattern, namespaces=namespace, custom=custom)\n\n    def assert_selector(self, markup, selectors, expected_ids, namespaces=None, custom=None, flags=0):\n        \"\"\"Assert selector.\"\"\"\n\n        if namespaces is None:\n            namespaces = {}\n        parsers = self.get_parsers(flags)\n\n        print('----Running Selector Test----')\n        selector = self.compile_pattern(selectors, namespaces, custom)\n\n        for parser in available_parsers(*parsers):\n            soup = self.soup(markup, parser)\n            # print(soup)\n\n            ids = []\n            for el in selector.select(soup):\n                print('TAG: ', el.name)\n                ids.append(el.attrs['id'])\n            self.assertEqual(sorted(ids), sorted(expected_ids))\n\n\ndef available_parsers(*parsers):\n    \"\"\"\n    Filter a list of parsers, down to the available ones.\n\n    If there are none, report the test as skipped to pytest.\n    \"\"\"\n\n    ran_test = False\n    for parser in parsers:\n        if (\n            (parser in ('xml', 'lxml') and not LXML_PRESENT) or\n            (parser == 'html5lib' and not HTML5LIB_PRESENT)\n        ):\n            print(f'SKIPPED {parser}, not installed')\n        else:\n            ran_test = True\n            yield parser\n    if not ran_test:\n        raise pytest.skip('no available parsers')\n\n\ndef requires_lxml(test):\n    \"\"\"Decorator that marks a test as requiring LXML.\"\"\"\n\n    return pytest.mark.skipif(\n        not LXML_PRESENT, reason='test requires lxml')(test)\n\n\ndef requires_html5lib(test):\n    \"\"\"Decorator that marks a test as requiring html5lib.\"\"\"\n\n    return pytest.mark.skipif(\n        not HTML5LIB_PRESENT, reason='test requires html5lib')(test)\n", "tests/test_bs4_cases.py": "\"\"\"Test that we don't fail the same test cases that Beautiful Soup used to fail prior to Soup Sieve.\"\"\"\nfrom bs4 import BeautifulSoup\nimport unittest\nimport soupsieve as sv\nfrom . import util\n\n\nclass SelectorNthOfTypeBugTest(unittest.TestCase):\n    \"\"\"\n    Original Beautiful soup test html document.\n\n    http://bazaar.launchpad.net/~leonardr/beautifulsoup/bs4/view/head:/bs4/tests/test_tree.py, line 1627.\n    \"\"\"\n\n    HTML = \"\"\"\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n<title>The title</title>\n<link rel=\"stylesheet\" href=\"blah.css\" type=\"text/css\" id=\"l1\">\n</head>\n<body>\n<custom-dashed-tag class=\"dashed\" id=\"dash1\">Hello there.</custom-dashed-tag>\n<div id=\"main\" class=\"fancy\">\n<div id=\"inner\">\n<h1 id=\"header1\">An H1</h1>\n<p>Some text</p>\n<p class=\"onep\" id=\"p1\">Some more text</p>\n<h2 id=\"header2\">An H2</h2>\n<p class=\"class1 class2 class3\" id=\"pmulti\">Another</p>\n<a href=\"http://bob.example.org/\" rel=\"friend met\" id=\"bob\">Bob</a>\n<h2 id=\"header3\">Another H2</h2>\n<a id=\"me\" href=\"http://simonwillison.net/\" rel=\"me\">me</a>\n<span class=\"s1\">\n<a href=\"#\" id=\"s1a1\">span1a1</a>\n<a href=\"#\" id=\"s1a2\">span1a2 <span id=\"s1a2s1\">test</span></a>\n<span class=\"span2\">\n<a href=\"#\" id=\"s2a1\">span2a1</a>\n</span>\n<span class=\"span3\"></span>\n<custom-dashed-tag class=\"dashed\" id=\"dash2\"/>\n<div data-tag=\"dashedvalue\" id=\"data1\"/>\n</span>\n</div>\n<x id=\"xid\">\n<z id=\"zida\"/>\n<z id=\"zidab\"/>\n<z id=\"zidac\"/>\n</x>\n<y id=\"yid\">\n<z id=\"zidb\"/>\n</y>\n<p lang=\"en\" id=\"lang-en\">English</p>\n<p lang=\"en-gb\" id=\"lang-en-gb\">English UK</p>\n<p lang=\"en-us\" id=\"lang-en-us\">English US</p>\n<p lang=\"fr\" id=\"lang-fr\">French</p>\n</div>\n\n<div id=\"footer\">\n</div>\n\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup.\"\"\"\n\n        self.soup = BeautifulSoup(self.HTML, 'html.parser')\n\n    def test_parent_nth_of_type_preconditions(self):\n        \"\"\"Test `nth` type preconditions.\"\"\"\n\n        els = sv.select('div > h1', self.soup)\n        # check that there is a unique selection\n        self.assertEqual(len(els), 1)\n        self.assertEqual(els[0].string, 'An H1')\n\n        # Show that the `h1`'s parent `div#inner` is the first child of type `div` of the grandparent `div#main`.\n        # so that the selector `div:nth-of-type(1) > h1` should also give `h1`.\n        h1 = els[0]\n        div_inner = h1.parent\n        div_main = div_inner.parent\n        div_main_children = list(div_main.children)\n        self.assertEqual(div_main_children[0], '\\n')\n        self.assertEqual(div_main_children[1], div_inner)\n\n    def test_parent_nth_of_type(self):\n        \"\"\"Test parent of `nth` of type.\"\"\"\n\n        els = sv.select('div:nth-of-type(1) > h1', self.soup)\n        self.assertEqual(len(els), 1)\n        self.assertEqual(els[0].string, 'An H1')\n\n\nSIMPLE_XML = \"\"\"<Envelope><Header>...</Header></Envelope>\"\"\"\nNAMESPACE_XML = \"\"\"\n<?xml version=\"1.0\"?>\n<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:a=\"http://www.w3.org/2005/08/addressing\"\n            xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">\n  <a:Action s:mustUnderstand=\"1\">http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue</a:Action>\n  <o:UsernameToken u:Id=\"uuid-00000043-0000-4000-0000-000000000000\">\n</s:Envelope>\n\"\"\".strip()\nNAMESPACES = {\n    'x': \"http://www.w3.org/2003/05/soap-envelope\",\n    'y': \"http://www.w3.org/2005/08/addressing\",\n    'z': \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"\n}\n\n\n@util.requires_lxml\ndef test_simple_xml():\n    \"\"\"Test basic XML.\"\"\"\n    xml = BeautifulSoup(SIMPLE_XML, \"xml\")\n\n    assert xml.select_one(\"Envelope\")\n    assert xml.select_one(\"Envelope Header\")\n    assert xml.select_one(\"Header\")\n\n    assert not xml.select_one(\"envelope\")\n    assert not xml.select_one(\"envelope header\")\n    assert not xml.select_one(\"header\")\n\n\n@util.requires_lxml\ndef test_namespace_xml():\n    \"\"\"Test namespace XML.\"\"\"\n    xml = BeautifulSoup(NAMESPACE_XML, \"xml\")\n\n    assert xml.select_one(\"Envelope\")\n    assert xml.select_one(\"Envelope Action\")\n    assert xml.select_one(\"Action\")\n\n    assert not xml.select_one(\"envelope\")\n    assert not xml.select_one(\"envelope action\")\n    assert not xml.select_one(\"action\")\n\n\n@util.requires_lxml\ndef test_namespace_xml_with_namespace():\n    \"\"\"Test namespace selectors with XML.\"\"\"\n    xml = BeautifulSoup(NAMESPACE_XML, \"xml\")\n\n    assert xml.select_one(\"x|Envelope\", namespaces=NAMESPACES)\n    assert xml.select_one(\"x|Envelope y|Action\", namespaces=NAMESPACES)\n    assert xml.select_one(\"y|Action\", namespaces=NAMESPACES)\n\n    assert not xml.select_one(\"x|envelope\", namespaces=NAMESPACES)\n    assert not xml.select_one(\"x|envelope y|action\", namespaces=NAMESPACES)\n    assert not xml.select_one(\"y|action\", namespaces=NAMESPACES)\n", "tests/test_api.py": "\"\"\"Test Soup Sieve API.\"\"\"\nimport soupsieve as sv\nfrom . import util\nimport copy\nimport random\nimport pytest\nimport pickle\n\n\nclass TestSoupSieve(util.TestCase):\n    \"\"\"Test Soup Sieve.\"\"\"\n\n    def test_select(self):\n        \"\"\"Test select.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [el.attrs['id'] for el in sv.select('span[id]', soup)]\n\n        self.assertEqual(sorted(['5', 'some-id']), sorted(ids))\n\n    def test_select_order(self):\n        \"\"\"Test select order.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [el.attrs['id'] for el in sv.select('[id]', soup.body)]\n\n        self.assertEqual(['1', '2', '3', '4', '5', 'some-id', '6'], ids)\n\n    def test_select_limit(self):\n        \"\"\"Test select limit.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n\n        ids = [el.attrs['id'] for el in sv.select('span[id]', soup, limit=1)]\n\n        self.assertEqual(sorted(['5']), sorted(ids))\n\n    def test_select_one(self):\n        \"\"\"Test select one.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        self.assertEqual(\n            sv.select('span[id]', soup, limit=1)[0].attrs['id'],\n            sv.select_one('span[id]', soup).attrs['id']\n        )\n\n    def test_select_one_none(self):\n        \"\"\"Test select one returns none for no match.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        self.assertEqual(None, sv.select_one('h1', soup))\n\n    def test_iselect(self):\n        \"\"\"Test select iterator.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n\n        ids = [el.attrs['id'] for el in sv.iselect('span[id]', soup)]\n\n        self.assertEqual(sorted(['5', 'some-id']), sorted(ids))\n\n    def test_iselect_order(self):\n        \"\"\"Test select iterator order.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [el.attrs['id'] for el in sv.iselect('[id]', soup)]\n\n        self.assertEqual(['1', '2', '3', '4', '5', 'some-id', '6'], ids)\n\n    def test_match(self):\n        \"\"\"Test matching.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        nodes = sv.select('span[id]', soup)\n        self.assertTrue(sv.match('span#\\\\35', nodes[0]))\n        self.assertFalse(sv.match('span#\\\\35', nodes[1]))\n\n    def test_filter_tag(self):\n        \"\"\"Test filter tag.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        nodes = sv.filter('pre#\\\\36', soup.html.body)\n        self.assertEqual(len(nodes), 1)\n        self.assertEqual(nodes[0].attrs['id'], '6')\n\n    def test_filter_tag_order(self):\n        \"\"\"Test filter tag order.\"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [tag['id'] for tag in sv.filter('[id]', soup.html.body.p)]\n        self.assertEqual(['2', '3'], ids)\n\n    def test_filter_list(self):\n        \"\"\"\n        Test filter list.\n\n        Even if a list is created from the content of a tag, as long as the\n        content is document nodes, filter will still handle it.  It doesn't have\n        to be just tags.\n        \"\"\"\n\n        markup = \"\"\"\n        <!-- before header -->\n        <html>\n        <head>\n        </head>\n        <body>\n        <!-- comment -->\n        <p id=\"1\"><code id=\"2\"></code><img id=\"3\" src=\"./image.png\"/></p>\n        <pre id=\"4\"></pre>\n        <p><span id=\"5\" class=\"some-class\"></span><span id=\"some-id\"></span></p>\n        <pre id=\"6\" class='ignore'>\n            <!-- don't ignore -->\n        </pre>\n        </body>\n        </html>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        nodes = sv.filter('pre#\\\\36', list(soup.html.body.children))\n        self.assertEqual(len(nodes), 1)\n        self.assertEqual(nodes[0].attrs['id'], '6')\n\n    def test_closest_match_parent(self):\n        \"\"\"Test match parent closest.\"\"\"\n\n        markup = \"\"\"\n        <article id=\"article\">\n          <div id=\"div-01\">Here is div-01\n            <div id=\"div-02\">Here is div-02\n              <div id=\"div-04\">Here is div-04</div>\n              <div id=\"div-03\">Here is div-03</div>\n            </div>\n            <div id=\"div-05\">Here is div-05</div>\n          </div>\n        </article>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        el = sv.select_one('#div-03', soup)\n        self.assertTrue(sv.closest('#div-02', el).attrs['id'] == 'div-02')\n\n    def test_closest_match_complex_parent(self):\n        \"\"\"Test closest match complex parent.\"\"\"\n\n        markup = \"\"\"\n        <article id=\"article\">\n          <div id=\"div-01\">Here is div-01\n            <div id=\"div-02\">Here is div-02\n              <div id=\"div-04\">Here is div-04</div>\n              <div id=\"div-03\">Here is div-03</div>\n            </div>\n            <div id=\"div-05\">Here is div-05</div>\n          </div>\n        </article>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        el = sv.select_one('#div-03', soup)\n        self.assertTrue(sv.closest('article > div', el).attrs['id'] == 'div-01')\n        self.assertTrue(sv.closest(':not(div)', el).attrs['id'] == 'article')\n\n    def test_closest_match_self(self):\n        \"\"\"Test closest match self.\"\"\"\n\n        markup = \"\"\"\n        <article id=\"article\">\n          <div id=\"div-01\">Here is div-01\n            <div id=\"div-02\">Here is div-02\n              <div id=\"div-04\">Here is div-04</div>\n              <div id=\"div-03\">Here is div-03</div>\n            </div>\n            <div id=\"div-05\">Here is div-05</div>\n          </div>\n        </article>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        el = sv.select_one('#div-03', soup)\n        self.assertTrue(sv.closest('div div', el).attrs['id'] == 'div-03')\n\n    def test_closest_must_be_parent(self):\n        \"\"\"Test that closest only matches parents or self.\"\"\"\n\n        markup = \"\"\"\n        <article id=\"article\">\n          <div id=\"div-01\">Here is div-01\n            <div id=\"div-02\">Here is div-02\n              <div id=\"div-04\">Here is div-04</div>\n              <div id=\"div-03\">Here is div-03</div>\n            </div>\n            <div id=\"div-05\">Here is div-05</div>\n          </div>\n        </article>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        el = sv.select_one('#div-03', soup)\n        self.assertTrue(sv.closest('div #div-05', el) is None)\n        self.assertTrue(sv.closest('a', el) is None)\n\n    def test_escape_hyphen(self):\n        \"\"\"Test escape hyphen cases.\"\"\"\n\n        self.assertEqual(r'\\-', sv.escape('-'))\n        self.assertEqual(r'--', sv.escape('--'))\n\n    def test_escape_numbers(self):\n        \"\"\"Test escape hyphen cases.\"\"\"\n\n        self.assertEqual(r'\\33 ', sv.escape('3'))\n        self.assertEqual(r'-\\33 ', sv.escape('-3'))\n        self.assertEqual(r'--3', sv.escape('--3'))\n\n    def test_escape_null(self):\n        \"\"\"Test escape null character.\"\"\"\n\n        self.assertEqual('\\ufffdtest', sv.escape('\\x00test'))\n\n    def test_escape_ctrl(self):\n        \"\"\"Test escape control character.\"\"\"\n\n        self.assertEqual(r'\\1 test', sv.escape('\\x01test'))\n\n    def test_escape_special(self):\n        \"\"\"Test escape special character.\"\"\"\n\n        self.assertEqual(r'\\{\\}\\[\\]\\ \\(\\)', sv.escape('{}[] ()'))\n\n    def test_escape_wide_unicode(self):\n        \"\"\"Test handling of wide Unicode.\"\"\"\n\n        self.assertEqual('Emoji\\\\ \\U0001F60D', sv.escape('Emoji \\U0001F60D'))\n\n    def test_copy_pickle(self):\n        \"\"\"Test copy and pickle.\"\"\"\n\n        # Test that we can pickle and unpickle\n        # We force a pattern that contains all custom types:\n        # `Selector`, `NullSelector`, `SelectorTag`, `SelectorAttribute`,\n        # `SelectorNth`, `SelectorLang`, `SelectorList`, `Namespaces`,\n        # `SelectorContains`, and `CustomSelectors`.\n        p1 = sv.compile(\n            'p.class#id[id]:nth-child(2):lang(en):focus:-soup-contains(\"text\", \"other text\")',\n            {'html': 'http://www.w3.org/TR/html4/'},\n            custom={':--header': 'h1, h2, h3, h4, h5, h6'}\n        )\n        sp1 = pickle.dumps(p1)\n        pp1 = pickle.loads(sp1)\n        self.assertTrue(pp1 == p1)\n\n        # Test that we pull the same one from cache\n        p2 = sv.compile(\n            'p.class#id[id]:nth-child(2):lang(en):focus:-soup-contains(\"text\", \"other text\")',\n            {'html': 'http://www.w3.org/TR/html4/'},\n            custom={':--header': 'h1, h2, h3, h4, h5, h6'}\n        )\n        self.assertTrue(p1 is p2)\n\n        # Test that we compile a new one when providing a different flags\n        p3 = sv.compile(\n            'p.class#id[id]:nth-child(2):lang(en):focus:-soup-contains(\"text\", \"other text\")',\n            {'html': 'http://www.w3.org/TR/html4/'},\n            custom={':--header': 'h1, h2, h3, h4, h5, h6'},\n            flags=0x10\n        )\n        self.assertTrue(p1 is not p3)\n        self.assertTrue(p1 != p3)\n\n        # Test that the copy is equivalent, but not same.\n        p4 = copy.copy(p1)\n        self.assertTrue(p4 is not p1)\n        self.assertTrue(p4 == p1)\n\n        p5 = copy.copy(p3)\n        self.assertTrue(p5 is not p3)\n        self.assertTrue(p5 == p3)\n        self.assertTrue(p5 is not p4)\n\n    def test_cache(self):\n        \"\"\"Test cache.\"\"\"\n\n        sv.purge()\n        self.assertEqual(sv.cp._cached_css_compile.cache_info().currsize, 0)\n        for _x in range(1000):\n            value = f'[value=\"{random.randint(1, 10000)!s}\"]'\n            p = sv.compile(value)\n            self.assertTrue(p.pattern == value)\n            self.assertTrue(sv.cp._cached_css_compile.cache_info().currsize > 0)\n        self.assertTrue(sv.cp._cached_css_compile.cache_info().currsize == 500)\n        sv.purge()\n        self.assertEqual(sv.cp._cached_css_compile.cache_info().currsize, 0)\n\n    def test_recompile(self):\n        \"\"\"If you feed through the same object, it should pass through unless you change parameters.\"\"\"\n\n        p1 = sv.compile('p[id]')\n        p2 = sv.compile(p1)\n        self.assertTrue(p1 is p2)\n\n        with pytest.raises(ValueError):\n            sv.compile(p1, flags=sv.DEBUG)\n\n        with pytest.raises(ValueError):\n            sv.compile(p1, namespaces={\"\": \"\"})\n\n        with pytest.raises(ValueError):\n            sv.compile(p1, custom={\":--header\": 'h1, h2, h3, h4, h5, h6'})\n\n    def test_immutable_dict_size(self):\n        \"\"\"Test immutable dictionary.\"\"\"\n\n        idict = sv.ct.ImmutableDict({'a': 'b', 'c': 'd'})\n        self.assertEqual(2, len(idict))\n\n\nclass TestInvalid(util.TestCase):\n    \"\"\"Test invalid.\"\"\"\n\n    def test_immutable_object(self):\n        \"\"\"Test immutable object.\"\"\"\n\n        obj = sv.ct.Immutable()\n\n        with self.assertRaises(AttributeError):\n            obj.member = 3\n\n    def test_immutable_dict_read_only(self):\n        \"\"\"Test immutable dictionary is read only.\"\"\"\n\n        idict = sv.ct.ImmutableDict({'a': 'b', 'c': 'd'})\n        with self.assertRaises(TypeError):\n            idict['a'] = 'f'\n\n    def test_immutable_dict_hashable_value(self):\n        \"\"\"Test immutable dictionary has a hashable value.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.ImmutableDict([[3, {}]])\n\n    def test_immutable_dict_hashable_key(self):\n        \"\"\"Test immutable dictionary has a hashable key.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.ImmutableDict([[{}, 3]])\n\n    def test_immutable_dict_hashable_value_dict(self):\n        \"\"\"Test immutable dictionary has a hashable value.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.ImmutableDict({3: {}})\n\n    def test_invalid_namespace_type(self):\n        \"\"\"Test invalid namespace type.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.Namespaces(((3, 3),))\n\n    def test_invalid_namespace_hashable_value(self):\n        \"\"\"Test namespace has hashable value.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.Namespaces({'a': {}})\n\n    def test_invalid_namespace_hashable_key(self):\n        \"\"\"Test namespace key is hashable.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.Namespaces({{}: 'string'})\n\n    def test_invalid_custom_type(self):\n        \"\"\"Test invalid custom selector type.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.CustomSelectors(((3, 3),))\n\n    def test_invalid_custom_hashable_value(self):\n        \"\"\"Test custom selector has hashable value.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.CustomSelectors({'a': {}})\n\n    def test_invalid_custom_hashable_key(self):\n        \"\"\"Test custom selector key is hashable.\"\"\"\n\n        with self.assertRaises(TypeError):\n            sv.ct.CustomSelectors({{}: 'string'})\n\n    def test_invalid_type_input_match(self):\n        \"\"\"Test bad input into the match API.\"\"\"\n\n        flags = sv.DEBUG\n\n        with self.assertRaises(TypeError):\n            sv.match('div', \"not a tag\", flags=flags)\n\n    def test_invalid_type_input_select(self):\n        \"\"\"Test bad input into the select API.\"\"\"\n\n        flags = sv.DEBUG\n\n        with self.assertRaises(TypeError):\n            sv.select('div', \"not a tag\", flags=flags)\n\n    def test_invalid_type_input_filter(self):\n        \"\"\"Test bad input into the filter API.\"\"\"\n\n        flags = sv.DEBUG\n\n        with self.assertRaises(TypeError):\n            sv.filter('div', \"not a tag\", flags=flags)\n\n\nclass TestSyntaxErrorReporting(util.TestCase):\n    \"\"\"Test reporting of syntax errors.\"\"\"\n\n    def test_syntax_error_has_text_and_position(self):\n        \"\"\"Test that selector syntax errors contain the position.\"\"\"\n\n        with self.assertRaises(sv.SelectorSyntaxError) as cm:\n            sv.compile('input.field[type=42]')\n        e = cm.exception\n        self.assertEqual(e.context, 'input.field[type=42]\\n           ^')\n        self.assertEqual(e.line, 1)\n        self.assertEqual(e.col, 12)\n\n    def test_syntax_error_with_multiple_lines(self):\n        \"\"\"Test that multiline selector errors have the right position.\"\"\"\n\n        with self.assertRaises(sv.SelectorSyntaxError) as cm:\n            sv.compile(\n                'input\\n'\n                '.field[type=42]')\n        e = cm.exception\n        self.assertEqual(e.context, '    input\\n--> .field[type=42]\\n          ^')\n        self.assertEqual(e.line, 2)\n        self.assertEqual(e.col, 7)\n\n    def test_syntax_error_on_third_line(self):\n        \"\"\"Test that multiline selector errors have the right position.\"\"\"\n\n        with self.assertRaises(sv.SelectorSyntaxError) as cm:\n            sv.compile(\n                'input:is(\\n'\n                '  [name=foo]\\n'\n                '  [type=42]\\n'\n                ')\\n'\n            )\n        e = cm.exception\n        self.assertEqual(e.line, 3)\n        self.assertEqual(e.col, 3)\n\n    def test_simple_syntax_error(self):\n        \"\"\"Test a simple syntax error (no context).\"\"\"\n\n        with self.assertRaises(sv.SelectorSyntaxError) as cm:\n            raise sv.SelectorSyntaxError('Syntax Message')\n\n        e = cm.exception\n        self.assertEqual(e.context, None)\n        self.assertEqual(e.line, None)\n        self.assertEqual(e.col, None)\n        self.assertEqual(str(e), 'Syntax Message')\n", "tests/__init__.py": "\"\"\"Tests.\"\"\"\n", "tests/test_extra/test_attribute.py": "\"\"\"Test attribute selectors.\"\"\"\nfrom .. import util\n\n\nclass TestAttribute(util.TestCase):\n    \"\"\"Test attribute selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"pre\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_attribute_not_equal_no_quotes(self):\n        \"\"\"Test attribute with value that does not equal specified value (no quotes).\"\"\"\n\n        # No quotes\n        self.assert_selector(\n            self.MARKUP,\n            'body [id!=\\\\35]',\n            [\"div\", \"0\", \"1\", \"2\", \"3\", \"pre\", \"4\", \"6\"],\n            flags=util.HTML5\n        )\n\n    def test_attribute_not_equal_quotes(self):\n        \"\"\"Test attribute with value that does not equal specified value (quotes).\"\"\"\n\n        # Quotes\n        self.assert_selector(\n            self.MARKUP,\n            \"body [id!='5']\",\n            [\"div\", \"0\", \"1\", \"2\", \"3\", \"pre\", \"4\", \"6\"],\n            flags=util.HTML5\n        )\n\n    def test_attribute_not_equal_double_quotes(self):\n        \"\"\"Test attribute with value that does not equal specified value (double quotes).\"\"\"\n\n        # Double quotes\n        self.assert_selector(\n            self.MARKUP,\n            'body [id!=\"5\"]',\n            [\"div\", \"0\", \"1\", \"2\", \"3\", \"pre\", \"4\", \"6\"],\n            flags=util.HTML5\n        )\n", "tests/test_extra/test_custom.py": "\"\"\"Test custom selector aliases.\"\"\"\nfrom .. import util\nimport soupsieve as sv\n\n\nclass TestCustomSelectors(util.TestCase):\n    \"\"\"Test custom selector aliases.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <h1 id=\"1\">Header 1</h1>\n    <h2 id=\"2\">Header 2</h2>\n    <p id=\"3\"></p>\n    <p id=\"4\"><span>child</span></p>\n    </body>\n    \"\"\"\n\n    def test_custom_selectors(self):\n        \"\"\"Test custom selectors.\"\"\"\n\n        custom_selectors = {\n            \":--headers\": \"h1, h2, h3, h4, h5, h6\",\n            \":--parent\": \":has(> *|*)\"\n        }\n\n        self.assert_selector(\n            self.MARKUP,\n            ':--headers',\n            ['1', '2'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            ':--headers:nth-child(2)',\n            ['2'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            'p:--parent',\n            ['4'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n    def test_custom_escapes(self):\n        \"\"\"Test custom selectors with escapes.\"\"\"\n\n        custom_selectors = {\n            r\":--Header\\s\": \"h1, h2, h3, h4, h5, h6\"\n        }\n\n        self.assert_selector(\n            self.MARKUP,\n            r':--\\HeaderS',\n            ['1', '2'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n    def test_custom_selectors_exotic(self):\n        \"\"\"Test custom selectors.\"\"\"\n\n        custom_selectors = {\":--\": \"h1, h2, h3, h4, h5, h6\"}\n\n        self.assert_selector(\n            self.MARKUP,\n            ':--',\n            ['1', '2'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n    def test_custom_dependency(self):\n        \"\"\"Test custom selector dependency on other custom selectors.\"\"\"\n\n        custom_selectors = {\n            \":--parent\": \":has(> *|*)\",\n            \":--parent-paragraph\": \"p:--parent\"\n        }\n\n        self.assert_selector(\n            self.MARKUP,\n            ':--parent-paragraph',\n            ['4'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n    def test_custom_dependency_out_of_order(self):\n        \"\"\"Test custom selector out of order dependency.\"\"\"\n\n        custom_selectors = {\n            \":--parent-paragraph\": \"p:--parent\",\n            \":--parent\": \":has(> *|*)\"\n        }\n\n        self.assert_selector(\n            self.MARKUP,\n            ':--parent-paragraph',\n            ['4'],\n            custom=custom_selectors,\n            flags=util.HTML\n        )\n\n    def test_custom_dependency_recursion(self):\n        \"\"\"Test that we fail on dependency recursion.\"\"\"\n\n        custom_selectors = {\n            \":--parent-paragraph\": \"p:--parent\",\n            \":--parent\": \"p:--parent-paragraph\"\n        }\n\n        self.assert_raises(':--parent', sv.SelectorSyntaxError, custom=custom_selectors)\n\n    def test_bad_custom(self):\n        \"\"\"Test that a bad custom raises a syntax error.\"\"\"\n\n        custom_selectors = {\n            \":--parent\": \":has(> *|*)\",\n            \":--parent-paragraph\": \"p:--parent\"\n        }\n\n        self.assert_raises(':--wrong', sv.SelectorSyntaxError, custom=custom_selectors)\n\n    def test_bad_custom_syntax(self):\n        \"\"\"Test that a custom selector with bad syntax in its name fails.\"\"\"\n\n        self.assert_raises('div', sv.SelectorSyntaxError, custom={\":--parent.\": \":has(> *|*)\"})\n\n    def test_pseudo_class_collision(self):\n        \"\"\"Test that a custom selector cannot match an already existing pseudo-class name.\"\"\"\n\n        self.assert_raises('div', sv.SelectorSyntaxError, custom={\":hover\": \":has(> *|*)\"})\n\n    def test_custom_collision(self):\n        \"\"\"Test that a custom selector cannot match an already existing custom name.\"\"\"\n\n        self.assert_raises('div', KeyError, custom={\":--parent\": \":has(> *|*)\", \":--PARENT\": \":has(> *|*)\"})\n", "tests/test_extra/test_soup_contains_own.py": "\"\"\"Test contains selectors.\"\"\"\nfrom .. import util\n\n\nclass TestSoupContainsOwn(util.TestCase):\n    \"\"\"Test soup-contains-own selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <div id=\"1\">\n    Testing\n    <span id=\"2\"> that </span>\n    contains works.\n    </div>\n    </body>\n    \"\"\"\n\n    def test_contains_own_descendants(self):\n        \"\"\"Test contains-own won't match text if contained in descendants.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body div:-soup-contains-own(that)',\n            [],\n            flags=util.HTML\n        )\n\n    def test_contains_own(self):\n        \"\"\"Test contains-own.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body *:-soup-contains-own(that)',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_own_cdata_html5(self):\n        \"\"\"Test contains CDATA in HTML5.\"\"\"\n\n        markup = \"\"\"\n        <body><div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div></body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'body *:-soup-contains-own(\"that\")',\n            ['1'],\n            flags=util.HTML5\n        )\n\n    def test_contains_own_cdata_py_html(self):\n        \"\"\"Test contains CDATA in Python HTML parser.\"\"\"\n\n        markup = \"\"\"\n        <body><div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div></body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'body *:-soup-contains-own(\"that\")',\n            ['1'],\n            flags=util.PYHTML\n        )\n\n    @util.skip_no_lxml\n    def test_contains_own_cdata_lxml_html(self):\n        \"\"\"Test contains CDATA in `lxml` HTML.\"\"\"\n\n        from lxml import etree\n        libxml_ver = etree.LIBXML_VERSION\n\n        markup = \"\"\"\n        <body><div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div></body>\n        \"\"\"\n\n        results = ['1', '2'] if libxml_ver >= (2, 9, 11) else ['1']\n        self.assert_selector(\n            markup,\n            'body *:-soup-contains-own(\"that\")',\n            results,\n            flags=util.LXML_HTML\n        )\n\n    def test_contains_own_cdata_xml(self):\n        \"\"\"Test contains-own CDATA in XML.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            '*:-soup-contains-own(\"that\")',\n            ['1', '2'],\n            flags=util.XML\n        )\n\n    def test_contains_own_with_broken_text(self):\n        \"\"\"Test contains-own to see how it matches a broken text.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <div id=\"1\"> A simple test <div id=\"2\"> to </div> show the broken text case. </div>\n        </body>\n        \"\"\"\n        self.assert_selector(\n            markup,\n            'body div:-soup-contains-own(\"test  show\")',\n            [],\n            flags=util.HTML\n        )\n", "tests/test_extra/test_soup_contains.py": "\"\"\"Test contains selectors.\"\"\"\nfrom .. import util\nimport warnings\nimport soupsieve as sv\n\n\nclass TestSoupContains(util.TestCase):\n    \"\"\"Test soup-contains selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <div id=\"1\">\n    Testing\n    <span id=\"2\"> that </span>\n    contains works.\n    </div>\n    </body>\n    \"\"\"\n\n    def test_contains(self):\n        \"\"\"Test contains.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body span:-soup-contains(that)',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_quoted_with_space(self):\n        \"\"\"Test contains quoted with spaces.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body span:-soup-contains(\" that \")',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_quoted_without_space(self):\n        \"\"\"Test contains quoted with spaces.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body :-soup-contains( \"Testing\" )',\n            ['1'],\n            flags=util.HTML\n        )\n\n    def test_contains_quoted_with_escaped_newline(self):\n        \"\"\"Test contains quoted with escaped newline.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body :-soup-contains(\"Test\\\\\\ning\")',\n            ['1'],\n            flags=util.HTML\n        )\n\n    def test_contains_quoted_with_escaped_newline_with_carriage_return(self):\n        \"\"\"Test contains quoted with escaped newline with carriage return.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body :-soup-contains(\"Test\\\\\\r\\ning\")',\n            ['1'],\n            flags=util.HTML\n        )\n\n    def test_contains_list(self):\n        \"\"\"Test contains list.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body span:-soup-contains(\"does not exist\", \"that\")',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_multiple(self):\n        \"\"\"Test contains multiple.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body span:-soup-contains(\"th\"):-soup-contains(\"at\")',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_multiple_not_match(self):\n        \"\"\"Test contains multiple with \"not\" and with a match.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body span:not(:-soup-contains(\"does not exist\")):-soup-contains(\"that\")',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_multiple_not_no_match(self):\n        \"\"\"Test contains multiple with \"not\" and no match.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body span:not(:-soup-contains(\"that\")):-soup-contains(\"that\")',\n            [],\n            flags=util.HTML\n        )\n\n    def test_contains_with_descendants(self):\n        \"\"\"Test that contains returns descendants as well as the top level that contain.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body :-soup-contains(\" that \")',\n            ['1', '2'],\n            flags=util.HTML\n        )\n\n    def test_contains_bad(self):\n        \"\"\"Test contains when it finds no text.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'body :-soup-contains(bad)',\n            [],\n            flags=util.HTML\n        )\n\n    def test_contains_escapes(self):\n        \"\"\"Test contains with escape characters.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <div id=\"1\">Testing<span id=\"2\">\n        that</span>contains works.</div>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            r'body span:-soup-contains(\"\\0a that\")',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_contains_cdata_html5(self):\n        \"\"\"Test contains CDATA in HTML5.\"\"\"\n\n        markup = \"\"\"\n        <body><div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div></body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'body *:-soup-contains(\"that\")',\n            ['1'],\n            flags=util.HTML5\n        )\n\n    def test_contains_cdata_py_html(self):\n        \"\"\"Test contains CDATA in Python HTML parser.\"\"\"\n\n        markup = \"\"\"\n        <body><div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div></body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'body *:-soup-contains(\"that\")',\n            ['1'],\n            flags=util.PYHTML\n        )\n\n    @util.skip_no_lxml\n    def test_contains_cdata_lxml_html(self):\n        \"\"\"Test contains CDATA in `lxml` HTML parser.\"\"\"\n\n        from lxml import etree\n        libxml_ver = etree.LIBXML_VERSION\n\n        markup = \"\"\"\n        <body><div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div></body>\n        \"\"\"\n\n        results = ['1', '2'] if libxml_ver >= (2, 9, 11) else ['1']\n        self.assert_selector(\n            markup,\n            'body *:-soup-contains(\"that\")',\n            results,\n            flags=util.LXML_HTML\n        )\n\n    def test_contains_cdata_xhtml(self):\n        \"\"\"Test contains CDATA in XHTML.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div>\n        \"\"\"\n\n        self.assert_selector(\n            self.wrap_xhtml(markup),\n            'body *:-soup-contains(\"that\")',\n            ['1', '2'],\n            flags=util.XHTML\n        )\n\n    def test_contains_cdata_xml(self):\n        \"\"\"Test contains CDATA in XML.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\">Testing that <span id=\"2\"><![CDATA[that]]></span>contains works.</div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            '*:-soup-contains(\"that\")',\n            ['1', '2'],\n            flags=util.XML\n        )\n\n    def test_contains_iframe(self):\n        \"\"\"Test contains with `iframe`.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\">\n        <p>Testing text</p>\n        <iframe>\n        <html><body>\n        <span id=\"2\">iframe</span>\n        </body></html>\n        </iframe>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'div:-soup-contains(\"iframe\")',\n            [],\n            flags=util.PYHTML\n        )\n\n        self.assert_selector(\n            markup,\n            'div:-soup-contains(\"text\")',\n            ['1'],\n            flags=util.PYHTML\n        )\n\n        self.assert_selector(\n            markup,\n            'span:-soup-contains(\"iframe\")',\n            ['2'],\n            flags=util.PYHTML\n        )\n\n    def test_contains_iframe_xml(self):\n        \"\"\"Test contains with `iframe` which shouldn't matter in XML.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\">\n        <p>Testing text</p>\n        <iframe>\n        <html><body>\n        <span id=\"2\">iframe</span>\n        </body></html>\n        </iframe>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'div:-soup-contains(\"iframe\")',\n            ['1'],\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            markup,\n            'div:-soup-contains(\"text\")',\n            ['1'],\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            markup,\n            'span:-soup-contains(\"iframe\")',\n            ['2'],\n            flags=util.XML\n        )\n\n    def test_contains_warn(self):\n        \"\"\"Test old alias raises a warning.\"\"\"\n\n        sv.purge()\n\n        with warnings.catch_warnings(record=True) as w:\n            # Cause all warnings to always be triggered.\n            warnings.simplefilter(\"always\")\n            # Trigger a warning.\n            self.assert_selector(\n                self.MARKUP,\n                'body span:contains(that)',\n                ['2'],\n                flags=util.HTML\n            )\n            # Verify some things\n            self.assertTrue(len(w) == 1)\n            self.assertTrue(issubclass(w[-1].category, FutureWarning))\n", "tests/test_extra/__init__.py": "\"\"\"Test extra selectors not found in the CSS specifications.\"\"\"\n", "tests/test_level2/test_attribute.py": "\"\"\"Test attribute selector.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\nfrom bs4 import BeautifulSoup\n\n\nclass TestAttribute(util.TestCase):\n    \"\"\"Test attribute selector.\"\"\"\n\n    MARKUP = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"pre\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    MARKUP_CONTAINS = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\" class=\"test1 test2 test3\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"pre\" class=\"test-a test-b\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    # Browsers normally replace NULL with `\\uFFFD`, but some of the parsers\n    # we test just strip out NULL, so we will simulate and just insert `\\uFFFD` directly\n    # to ensure consistent behavior in our tests across parsers.\n    MARKUP_NULL = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"\\ufffdpre\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_attribute(self):\n        \"\"\"Test attribute.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[href]\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_with_spaces(self):\n        \"\"\"Test attribute with spaces.\"\"\"\n\n        # With spaces\n        self.assert_selector(\n            self.MARKUP,\n            \"[   href   ]\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_multi_attribute(self):\n        \"\"\"Test multiple attribute.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div id=\"div\">\n            <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            <span id=\"3\">Direct child</span>\n            <pre id=\"pre\">\n            <span id=\"4\" class=\"test\">Child 1</span>\n            <span id=\"5\" class=\"test\" data-test=\"test\">Child 2</span>\n            <span id=\"6\">Child 3</span>\n            <span id=\"6\">Child 3</span>\n            </pre>\n            </div>\n            \"\"\",\n            \"span[id].test[data-test=test]\",\n            [\"5\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_no_quotes(self):\n        \"\"\"Test attribute with value that equals specified value (with no quotes).\"\"\"\n\n        # No quotes\n        self.assert_selector(\n            self.MARKUP,\n            '[id=\\\\35]',\n            [\"5\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_with_quotes(self):\n        \"\"\"Test attribute with value that equals specified value (with quotes).\"\"\"\n\n        # Single quoted\n        self.assert_selector(\n            self.MARKUP,\n            \"[id='5']\",\n            [\"5\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_with_double_quotes(self):\n        \"\"\"Test attribute with value that equals specified value (with double quotes).\"\"\"\n\n        # Double quoted\n        self.assert_selector(\n            self.MARKUP,\n            '[id=\"5\"]',\n            [\"5\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_quotes_and_spaces(self):\n        \"\"\"Test attribute with value that equals specified value (quotes and spaces).\"\"\"\n\n        # With spaces\n        self.assert_selector(\n            self.MARKUP,\n            '[  id  =  \"5\"  ]',\n            [\"5\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_case_insensitive_attribute(self):\n        \"\"\"Test attribute with value that equals specified value (case insensitive attribute).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            '[ID=\"5\"]',\n            [\"5\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_bad(self):\n        \"\"\"Test attribute with a bad attribute.\"\"\"\n\n        self.assert_selector(\n            '<span bad=\"5\"></span>',\n            '[  id  =  \"5\"  ]',\n            [],\n            flags=util.HTML\n        )\n\n    def test_attribute_escaped_newline(self):\n        \"\"\"Test attribute with escaped new line in quoted string.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            '[id=\"pr\\\\\\ne\"]',\n            [\"pre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_literal_null(self):\n        \"\"\"Test attribute with value that equals specified value with a literal null character.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NULL,\n            '[id=\"\\x00pre\"]',\n            [\"\\ufffdpre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_equal_escaped_null(self):\n        \"\"\"Test attribute with value that equals specified value with an escaped null character.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NULL,\n            r'[id=\"\\0 pre\"]',\n            [\"\\ufffdpre\"],\n            flags=util.HTML\n        )\n\n    def test_invalid_tag(self):\n        \"\"\"\n        Test invalid tag.\n\n        Tag must come first.\n        \"\"\"\n\n        self.assert_raises('[href]p', SelectorSyntaxError)\n\n    def test_malformed(self):\n        \"\"\"Test malformed.\"\"\"\n\n        # Malformed attribute\n        self.assert_raises('div[attr={}]', SelectorSyntaxError)\n\n    def test_attribute_type_html(self):\n        \"\"\"Type is treated as case insensitive in HTML.\"\"\"\n\n        markup = \"\"\"\n        <html>\n        <body>\n        <div id=\"div\">\n        <p type=\"TEST\" id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n        <a type=\"test\" id=\"2\" href=\"http://google.com\">Link</a>\n        <span id=\"3\">Direct child</span>\n        <pre id=\"pre\">\n        <span id=\"4\">Child 1</span>\n        <span id=\"5\">Child 2</span>\n        <span id=\"6\">Child 3</span>\n        </pre>\n        </div>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            '[type=\"test\"]',\n            [\"0\", '2'],\n            flags=util.HTML\n        )\n\n    def test_attribute_type_xml(self):\n        \"\"\"Type is treated as case sensitive in XML.\"\"\"\n\n        markup = \"\"\"\n        <html>\n        <body>\n        <div id=\"div\">\n        <p type=\"TEST\" id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n        <a type=\"test\" id=\"2\" href=\"http://google.com\">Link</a>\n        <span id=\"3\">Direct child</span>\n        <pre id=\"pre\">\n        <span id=\"4\">Child 1</span>\n        <span id=\"5\">Child 2</span>\n        <span id=\"6\">Child 3</span>\n        </pre>\n        </div>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            '[type=\"test\"]',\n            ['2'],\n            flags=util.XML\n        )\n\n    def test_attribute_type_xhtml(self):\n        \"\"\"Type is treated as case insensitive in XHTML.\"\"\"\n\n        markup = \"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n            \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n        <head>\n        </head>\n        <body>\n        <div id=\"div\">\n        <p type=\"TEST\" id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n        <a type=\"test\" id=\"2\" href=\"http://google.com\">Link</a>\n        <span id=\"3\">Direct child</span>\n        <pre id=\"pre\">\n        <span id=\"4\">Child 1</span>\n        <span id=\"5\">Child 2</span>\n        <span id=\"6\">Child 3</span>\n        </pre>\n        </div>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            '[type=\"test\"]',\n            ['2'],\n            flags=util.XHTML\n        )\n\n    def test_attribute_start_dash(self):\n        \"\"\"Test attribute whose dash separated value starts with the specified value.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div id=\"div\">\n            <p id=\"0\" lang=\"en-us\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            <span id=\"3\">Direct child</span>\n            <pre id=\"pre\">\n            <span id=\"4\">Child 1</span>\n            <span id=\"5\">Child 2</span>\n            <span id=\"6\">Child 3</span>\n            </pre>\n            </div>\n            \"\"\",\n            \"[lang|=en]\",\n            [\"0\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_space_middle(self):\n        \"\"\"Test attribute whose space separated list contains the specified value in the middle of the list.\"\"\"\n\n        # Middle of list\n        self.assert_selector(\n            self.MARKUP_CONTAINS,\n            \"[class~=test2]\",\n            [\"0\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_space_start(self):\n        \"\"\"Test attribute whose space separated list contains the specified value at the start of the list.\"\"\"\n\n        # Start of list\n        self.assert_selector(\n            self.MARKUP_CONTAINS,\n            \"[class~=test-a]\",\n            [\"pre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_space_end(self):\n        \"\"\"Test attribute whose space separated list contains the specified value at the end of the list.\"\"\"\n\n        # End of list\n        self.assert_selector(\n            self.MARKUP_CONTAINS,\n            \"[class~=test-b]\",\n            [\"pre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_cannot_have_spaces(self):\n        \"\"\"Test attribute `~=` will match nothing when spaces are included.\"\"\"\n\n        # Shouldn't match anything\n        self.assert_selector(\n            self.MARKUP_CONTAINS,\n            '[class~=\"test1 test2\"]',\n            [],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_cannot_have_empty(self):\n        \"\"\"Test attribute `~=` will match nothing when value is empty.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_CONTAINS,\n            '[class~=\"\"]',\n            [],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_cannot_have_escaped_spaces(self):\n        \"\"\"Test attribute `~=` will match nothing when escaped spaces are included.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_CONTAINS,\n            '[class~=\"test1\\\\ test2\"]',\n            [],\n            flags=util.HTML\n        )\n\n    def test_none_inputs(self):\n        \"\"\"Test weird inputs.\"\"\"\n\n        soup = BeautifulSoup('<span>text</span>', 'html.parser')\n        soup.span['foo'] = None\n        self.assertEqual(len(soup.select('span[foo]')), 1)\n\n    def test_numeric_inputs(self):\n        \"\"\"Test weird inputs.\"\"\"\n\n        soup = BeautifulSoup('<span>text</span>', 'html.parser')\n        soup.span['foo'] = 3\n        self.assertEqual(len(soup.select('span[foo=\"3\"]')), 1)\n        soup.span['foo'] = 3.3\n        self.assertEqual(len(soup.select('span[foo=\"3.3\"]')), 1)\n\n    def test_sequence_inputs(self):\n        \"\"\"Test weird inputs.\"\"\"\n\n        soup = BeautifulSoup('<span>text</span>', 'html.parser')\n        soup.span['foo'] = [3, \"4\"]\n        self.assertEqual(len(soup.select('span[foo=\"3 4\"]')), 1)\n\n    def test_bytes_inputs(self):\n        \"\"\"Test weird inputs.\"\"\"\n\n        soup = BeautifulSoup('<span>text</span>', 'html.parser')\n        soup.span['foo'] = b'test'\n        self.assertEqual(len(soup.select('span[foo=\"test\"]')), 1)\n\n    def test_weird_inputs(self):\n        \"\"\"Test weird inputs.\"\"\"\n\n        soup = BeautifulSoup('<span>text</span>', 'html.parser')\n        soup.span['foo'] = {'3': '4'}\n        self.assertEqual(len(soup.select('span[foo=\"{\\'3\\': \\'4\\'}\"]')), 1)\n\n    def test_nested_sequences(self):\n        \"\"\"Nested sequences will crash and burn due to the way BeautifulSoup handles them.\"\"\"\n\n        # The exact exception is not important as it can fail in various locations for different reasons\n        with self.assertRaises(Exception):  # noqa: B017\n            soup = BeautifulSoup('<span>text</span>', 'html.parser')\n            soup.span['foo'] = [['1']]\n            soup.select(\"span['foo']\")\n", "tests/test_level2/test_child.py": "\"\"\"Test child combinators.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestChild(util.TestCase):\n    \"\"\"Test child combinators.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre>\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_direct_child(self):\n        \"\"\"Test direct child.\"\"\"\n\n        # Spaces\n        self.assert_selector(\n            self.MARKUP,\n            \"div > span\",\n            [\"3\"],\n            flags=util.HTML\n        )\n\n    def test_direct_child_no_spaces(self):\n        \"\"\"Test direct child with no spaces.\"\"\"\n\n        # No spaces\n        self.assert_selector(\n            self.MARKUP,\n            \"div>span\",\n            [\"3\"],\n            flags=util.HTML\n        )\n\n    def test_invalid_double_combinator(self):\n        \"\"\"Test that selectors cannot have double combinators.\"\"\"\n\n        self.assert_raises('div >> p', SelectorSyntaxError)\n        self.assert_raises('>> div > p', SelectorSyntaxError)\n\n    def test_invalid_trailing_combinator(self):\n        \"\"\"Test that selectors cannot have a trailing combinator.\"\"\"\n\n        self.assert_raises('div >', SelectorSyntaxError)\n        self.assert_raises('div >, div', SelectorSyntaxError)\n\n    def test_invalid_combinator(self):\n        \"\"\"Test that we do not allow selectors in selector lists to start with combinators.\"\"\"\n\n        self.assert_raises('> p', SelectorSyntaxError)\n        self.assert_raises('div, > a', SelectorSyntaxError)\n", "tests/test_level2/test_hover.py": "\"\"\"Test hover selector.\"\"\"\nfrom .. import util\n\n\nclass TestHover(util.TestCase):\n    \"\"\"Test hover selector.\"\"\"\n\n    def test_hover(self):\n        \"\"\"Test hover.\"\"\"\n\n        markup = \"\"\"\n        <div>\n        <p>Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n        <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n        <a id=\"3\">Placeholder text.</a>\n        </p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"a:hover\",\n            [],\n            flags=util.HTML\n        )\n", "tests/test_level2/test_focus.py": "\"\"\"Test focus selector.\"\"\"\nfrom .. import util\n\n\nclass TestFocus(util.TestCase):\n    \"\"\"Test focus selector.\"\"\"\n\n    MARKUP = \"\"\"\n    <form action=\"#\">\n      <fieldset id='a' disabled>\n        <legend>\n          Simple fieldset <input type=\"radio\" id=\"1\" checked>\n          <fieldset id='b' disabled>\n            <legend>Simple fieldset <input type=\"radio\" id=\"2\" checked></legend>\n            <input type=\"radio\" id=\"3\" checked>\n            <label for=\"radio\">radio</label>\n          </fieldset>\n        </legend>\n        <fieldset id='c' disabled>\n          <legend>Simple fieldset <input type=\"radio\" id=\"4\" checked></legend>\n          <input type=\"radio\" id=\"5\" checked>\n          <label for=\"radio\">radio</label>\n        </fieldset>\n        <input type=\"radio\" id=\"6\" checked>\n        <label for=\"radio\">radio</label>\n      </fieldset>\n      <optgroup id=\"opt-enable\">\n        <option id=\"7\" disabled>option</option>\n      </optgroup>\n      <optgroup id=\"8\" disabled>\n        <option id=\"9\">option</option>\n      </optgroup>\n      <a href=\"\" id=\"link\">text</a>\n    </form>\n    \"\"\"\n\n    def test_focus(self):\n        \"\"\"Test focus.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"input:focus\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_focus(self):\n        \"\"\"Test not focus.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"input:not(:focus)\",\n            [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"],\n            flags=util.HTML\n        )\n", "tests/test_level2/test_universal_type.py": "\"\"\"Test universal type selector.\"\"\"\nfrom .. import util\n\n\nclass TestUniversal(util.TestCase):\n    \"\"\"Test universal type selector.\"\"\"\n\n    def test_universal_type(self):\n        \"\"\"Test universal type.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <body>\n            <div id=\"div\">\n            <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            <span id=\"3\">Direct child</span>\n            <pre id=\"pre\">\n            <span id=\"4\">Child 1</span>\n            <span id=\"5\">Child 2</span>\n            <span id=\"6\">Child 3</span>\n            </pre>\n            </div>\n            </body>\n            \"\"\",\n            \"body *\",\n            [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"div\", \"pre\"],\n            flags=util.HTML\n        )\n", "tests/test_level2/__init__.py": "\"\"\"Test level 2 selectors.\"\"\"\n", "tests/test_level2/test_lang.py": "\"\"\"Test language selector.\"\"\"\nfrom .. import util\n\n\nclass TestLang(util.TestCase):\n    \"\"\"Test language selector.\"\"\"\n\n    def test_lang(self):\n        \"\"\"Test language.\"\"\"\n\n        markup = \"\"\"\n        <div lang=\"de-DE\">\n            <p id=\"1\"></p>\n        </div>\n        <div lang=\"de-DE-1996\">\n            <p id=\"2\"></p>\n        </div>\n        <div lang=\"de-Latn-DE\">\n            <p id=\"3\"></p>\n        </div>\n        <div lang=\"de-Latf-DE\">\n            <p id=\"4\"></p>\n        </div>\n        <div lang=\"de-Latn-DE-1996\">\n            <p id=\"5\"></p>\n        </div>\n        <p id=\"6\" lang=\"de-DE\"></p>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(de)\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_iframe(self):\n        \"\"\"Test language in `iframe`.\"\"\"\n\n        markup = \"\"\"\n        <html>\n        <body>\n        <div lang=\"de-DE\">\n            <p id=\"1\"></p>\n            <iframe>\n                <html>\n                <body>\n                <p id=\"2\"></p>\n                <p id=\"3\" lang=\"en-US\"></p>\n                </body>\n                </html>\n            </iframe>\n        </div>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(en)\",\n            ['3'],\n            flags=util.PYHTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:lang(de)\",\n            ['1'],\n            flags=util.PYHTML\n        )\n", "tests/test_level2/test_next_sibling.py": "\"\"\"Test next sibling combinators.\"\"\"\nfrom .. import util\n\n\nclass TestNextSibling(util.TestCase):\n    \"\"\"Test next sibling combinators.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre>\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_direct_sibling(self):\n        \"\"\"Test direct sibling.\"\"\"\n\n        # Spaces\n        self.assert_selector(\n            self.MARKUP,\n            \"span + span\",\n            [\"5\", \"6\"],\n            flags=util.HTML\n        )\n\n    def test_direct_sibling_no_spaces(self):\n        \"\"\"Test direct sibling with no spaces.\"\"\"\n\n        # No spaces\n        self.assert_selector(\n            self.MARKUP,\n            \"span+span\",\n            [\"5\", \"6\"],\n            flags=util.HTML\n        )\n\n    def test_complex_direct_siblings(self):\n        \"\"\"Test direct sibling with no spaces.\"\"\"\n\n        # Complex\n        self.assert_selector(\n            self.MARKUP,\n            \"span#\\\\34 + span#\\\\35\",\n            [\"5\"],\n            flags=util.HTML\n        )\n", "tests/test_level2/test_first_child.py": "\"\"\"Test first child selector.\"\"\"\nfrom .. import util\n\n\nclass TestFirstChild(util.TestCase):\n    \"\"\"Test first child selector.\"\"\"\n\n    def test_first_child(self):\n        \"\"\"Test first child.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div id=\"div\">\n            <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            <span id=\"3\">Direct child</span>\n            <pre id=\"pre\">\n            <span id=\"4\">Child 1</span>\n            <span id=\"5\">Child 2</span>\n            <span id=\"6\">Child 3</span>\n            </pre>\n            </div>\n            \"\"\",\n            \"span:first-child\",\n            [\"1\", \"4\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_default.py": "\"\"\"Test default selectors.\"\"\"\nfrom .. import util\n\n\nclass TestDefault(util.TestCase):\n    \"\"\"Test default selectors.\"\"\"\n\n    def test_default(self):\n        \"\"\"Test default.\"\"\"\n\n        markup = \"\"\"\n        <form>\n\n        <input type=\"radio\" name=\"season\" id=\"spring\">\n        <label for=\"spring\">Spring</label>\n\n        <input type=\"radio\" name=\"season\" id=\"summer\" checked>\n        <label for=\"summer\">Summer</label>\n\n        <input type=\"radio\" name=\"season\" id=\"fall\">\n        <label for=\"fall\">Fall</label>\n\n        <input type=\"radio\" name=\"season\" id=\"winter\">\n        <label for=\"winter\">Winter</label>\n\n        <select id=\"pet-select\">\n            <option value=\"\">--Please choose an option--</option>\n            <option id=\"dog\" value=\"dog\">Dog</option>\n            <option id=\"cat\" value=\"cat\">Cat</option>\n            <option id=\"hamster\" value=\"hamster\" selected>Hamster</option>\n            <option id=\"parrot\" value=\"parrot\">Parrot</option>\n            <option id=\"spider\" value=\"spider\">Spider</option>\n            <option id=\"goldfish\" value=\"goldfish\">Goldfish</option>\n        </select>\n\n        <input type=\"checkbox\" name=\"enable\" id=\"enable\" checked>\n        <label for=\"enable\">Enable</label>\n\n        <button type=\"button\">\n        not default\n        </button>\n\n        <button id=\"d1\" type=\"submit\">\n        default1\n        </button>\n\n        <button id=\"d2\" type=\"submit\">\n        default2\n        </button>\n\n        </form>\n\n        <form>\n\n        <div>\n        <button id=\"d3\" type=\"submit\">\n        default3\n        </button>\n        </div>\n\n        <button id=\"d4\" type=\"submit\">\n        default4\n        </button>\n\n        </form>\n\n        <button id=\"d5\" type=\"submit\">\n        default4\n        </button>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":default\",\n            ['summer', 'd1', 'd3', 'hamster', 'enable'],\n            flags=util.HTML\n        )\n\n    def test_iframe(self):\n        \"\"\"Test with `iframe`.\"\"\"\n\n        markup = \"\"\"\n        <html>\n        <body>\n        <form>\n        <button id=\"d1\" type=\"submit\">default1</button>\n        </form>\n\n        <form>\n        <iframe>\n        <html>\n        <body>\n        <button id=\"d2\" type=\"submit\">default2</button>\n        </body>\n        </html>\n        </iframe>\n        <button id=\"d3\" type=\"submit\">default3</button>\n        </form>\n\n        <iframe>\n        <html>\n        <body>\n        <form>\n        <button id=\"d4\" type=\"submit\">default4</button>\n        </form>\n        </body>\n        </html>\n        </iframe>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":default\",\n            ['d1', 'd3', 'd4'],\n            flags=util.PYHTML\n        )\n\n    def test_nested_form(self):\n        \"\"\"\n        Test nested form.\n\n        This is technically invalid use of forms, but browsers will generally evaluate first in the nested forms.\n        \"\"\"\n\n        markup = \"\"\"\n        <form>\n\n        <form>\n        <button id=\"d1\" type=\"submit\">\n        button1\n        </button>\n        </form>\n\n        <button id=\"d2\" type=\"submit\">\n        button2\n        </button>\n        </form>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":default\",\n            ['d1'],\n            flags=util.HTML\n        )\n\n    def test_default_cached(self):\n        \"\"\"\n        Test that we use the cached \"default\".\n\n        For the sake of coverage, we will do this impractical select\n        to ensure we reuse the cached default.\n        \"\"\"\n\n        markup = \"\"\"\n        <form>\n\n        <form>\n        <button id=\"d1\" type=\"submit\">\n        button1\n        </button>\n        </form>\n\n        <button id=\"d2\" type=\"submit\">\n        button2\n        </button>\n        </form>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":default:default\",\n            ['d1'],\n            flags=util.HTML\n        )\n\n    def test_nested_form_fail(self):\n        \"\"\"\n        Test that the search for elements will bail after the first nested form.\n\n        You shouldn't nest forms, but if you do, when a parent form encounters a nested form,\n        we will bail evaluation like browsers do. We should see button 1 getting found for nested\n        form, but button 2 will not be found for parent form.\n        \"\"\"\n\n        markup = \"\"\"\n        <form>\n\n        <form>\n        <span>what</span>\n        </form>\n\n        <button id=\"d2\" type=\"submit\">\n        button2\n        </button>\n        </form>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":default\",\n            [],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_local_link.py": "\"\"\"Test local link selectors.\"\"\"\nfrom .. import util\n\n\nclass TestLocalLink(util.TestCase):\n    \"\"\"Test local link selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <a id=\"1\" href=\"./somelink/index.html\">Link</link>\n    <a id=\"2\" href=\"http://somelink.com/somelink/index.html\">Another link</a>\n    \"\"\"\n\n    def test_local_link(self):\n        \"\"\"Test local link (matches nothing).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"a:local-link\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_local_link(self):\n        \"\"\"Test not local link.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"a:not(:local-link)\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_paused.py": "\"\"\"Test paused selectors.\"\"\"\nfrom .. import util\n\n\nclass TestPaused(util.TestCase):\n    \"\"\"Test paused selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <!DOCTYPE html>\n    <html>\n    <body>\n\n    <video id=\"vid\" width=\"320\" height=\"240\" controls>\n      <source src=\"movie.mp4\" type=\"video/mp4\">\n      <source src=\"movie.ogg\" type=\"video/ogg\">\n      Your browser does not support the video tag.\n    </video>\n\n    </body>\n    </html>\n    \"\"\"\n\n    def test_paused(self):\n        \"\"\"Test paused (matches nothing).\"\"\"\n\n        # Not actually sure how this is used, but it won't match anything anyways\n        self.assert_selector(\n            self.MARKUP,\n            \"video:paused\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_paused(self):\n        \"\"\"Test not paused.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"video:not(:paused)\",\n            [\"vid\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_attribute.py": "\"\"\"Test attribute selectors.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestAttribute(util.TestCase):\n    \"\"\"Test attribute selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p type=\"TEST\" id=\"0\" class=\"somewordshere\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a type=\"test\" id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\" class=\"herewords\">Direct child</span>\n    <pre id=\"pre\" class=\"wordshere\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_attribute_forced_case_insensitive(self):\n        \"\"\"Test attribute value case insensitivity.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[class*=WORDS]\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[class*=WORDS i]\",\n            [\"0\", \"3\", \"pre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_case_insensitive_flag_spacing(self):\n        \"\"\"Test attribute value case insensitivity spacing.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[class*=WORDSi]\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[class*='WORDS'i]\",\n            [\"0\", \"3\", \"pre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_forced_case_insensitive_xml(self):\n        \"\"\"Test that attribute value case insensitivity can be forced in XML.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            '[type=\"test\" i]',\n            ['0', '2'],\n            flags=util.XML\n        )\n\n    def test_attribute_forced_case_insensitive_xhtml(self):\n        \"\"\"Test that attribute value case insensitivity can be forced in XHTML.\"\"\"\n\n        self.assert_selector(\n            self.wrap_xhtml(self.MARKUP),\n            '[type=\"test\" i]',\n            ['0', '2'],\n            flags=util.XML\n        )\n\n    def test_attribute_forced_case_needs_value(self):\n        \"\"\"Test attribute value case insensitivity requires a value.\"\"\"\n\n        self.assert_raises('[id i]', SelectorSyntaxError)\n\n    def test_attribute_type_case_sensitive(self):\n        \"\"\"Type is treated as case insensitive in HTML, so test that we can force the opposite.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            '[type=\"test\" s]',\n            ['2'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_target_within.py": "\"\"\"Test target within selectors.\"\"\"\nfrom .. import util\n\n\nclass TestTargetWithin(util.TestCase):\n    \"\"\"Test target within selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <a href=\"#head-2\">Jump</a>\n    <article id=\"article\">\n    <h2 id=\"head-1\">Header 1</h1>\n    <div><p>content</p></div>\n    <h2 id=\"head-2\">Header 2</h1>\n    <div><p>content</p></div>\n    </article>\n    \"\"\"\n\n    def test_target_within(self):\n        \"\"\"Test target within.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"article:target-within\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_target_within(self):\n        \"\"\"Test inverse of target within.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"article:not(:target-within)\",\n            [\"article\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_host.py": "\"\"\"Test host selectors.\"\"\"\nfrom .. import util\n\n\nclass TestHost(util.TestCase):\n    \"\"\"Test host selectors.\"\"\"\n\n    MARKUP = \"\"\"<h1>header</h1><div><p>some text</p></div>\"\"\"\n\n    def test_host(self):\n        \"\"\"Test host (not supported).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":host\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_host_func(self):\n        \"\"\"Test host function (not supported).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":host(h1)\",\n            [],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_where.py": "\"\"\"Test where selectors.\"\"\"\nfrom .. import util\n\n\nclass TestWhere(util.TestCase):\n    \"\"\"Test where selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\"> in a paragraph</span>.\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_where(self):\n        \"\"\"Test multiple selectors with \"where\".\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":where(span, a)\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_nested_where(self):\n        \"\"\"Test multiple nested selectors with \"where\".\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":where(span, a:where(#\\\\32))\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_placeholder_shown.py": "\"\"\"Test placeholder shown selectors.\"\"\"\nfrom .. import util\n\n\nclass TestPlaceholderShown(util.TestCase):\n    \"\"\"Test placeholder shown selectors.\"\"\"\n\n    def test_placeholder_shown(self):\n        \"\"\"Test placeholder shown.\"\"\"\n\n        markup = \"\"\"\n        <!-- These have a placeholder. -->\n        <input id=\"0\" placeholder=\"This is some text\">\n        <textarea id=\"1\" placeholder=\"This is some text\"></textarea>\n\n        <!-- These do not have a placeholder. -->\n        <input id=\"2\" placeholder=\"\">\n        <input id=\"3\">\n\n        <!-- All types that should register has having a placeholder. -->\n        <input id=\"4\" type=\"email\" placeholder=\"This is some text\">\n        <input id=\"5\" type=\"number\" placeholder=\"This is some text\">\n        <input id=\"6\" type=\"password\" placeholder=\"This is some text\">\n        <input id=\"7\" type=\"search\" placeholder=\"This is some text\">\n        <input id=\"8\" type=\"tel\" placeholder=\"This is some text\">\n        <input id=\"9\" type=\"text\" placeholder=\"This is some text\">\n        <input id=\"10\" type=\"url\" placeholder=\"This is some text\">\n        <input id=\"11\" type=\"\" placeholder=\"This is some text\">\n        <input id=\"12\" type placeholder=\"This is some text\">\n\n        <!-- Types that should not register has having a placeholder. -->\n        <input id=\"13\" type=\"button\" placeholder=\"This is some text\">\n        <input id=\"14\" type=\"checkbox\" placeholder=\"This is some text\">\n        <input id=\"15\" type=\"color\" placeholder=\"This is some text\">\n        <input id=\"16\" type=\"date\" placeholder=\"This is some text\">\n        <input id=\"17\" type=\"datetime-local\" placeholder=\"This is some text\">\n        <input id=\"18\" type=\"file\" placeholder=\"This is some text\">\n        <input id=\"19\" type=\"hidden\" placeholder=\"This is some text\">\n        <input id=\"20\" type=\"image\" placeholder=\"This is some text\">\n        <input id=\"21\" type=\"month\" placeholder=\"This is some text\">\n        <input id=\"22\" type=\"radio\" placeholder=\"This is some text\">\n        <input id=\"23\" type=\"range\" placeholder=\"This is some text\">\n        <input id=\"24\" type=\"reset\" placeholder=\"This is some text\">\n        <input id=\"25\" type=\"submit\" placeholder=\"This is some text\">\n        <input id=\"26\" type=\"time\" placeholder=\"This is some text\">\n        <input id=\"27\" type=\"week\" placeholder=\"This is some text\">\n\n        <!-- Value will not override this instance as value is empty. -->\n        <input id=\"28\" type placeholder=\"This is some text\" value=\"\">\n\n        <!-- Value will override this input -->\n        <input id=\"29\" type placeholder=\"This is some text\" value=\"Actual value\">\n\n        <!-- Text area content overrides the placehold-->\n        <textarea id=\"30\" placeholder=\"This is some text\">Value</textarea>\n        <textarea id=\"31\" placeholder=\"This is some text\">\n\n\n        </textarea>\n\n        <!-- Text area is still considered empty with a single new line (does not include carriage return). -->\n        <textarea id=\"32\" placeholder=\"This is some text\">\n        </textarea>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":placeholder-shown\",\n            ['0', '1', '4', '5', '6', '7', '8', '9', '10', '11', '12', '28', '32'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_defined.py": "\"\"\"Test defined selectors.\"\"\"\nfrom .. import util\n\n\nclass TestDefined(util.TestCase):\n    \"\"\"Test defined selectors.\"\"\"\n\n    def test_defined_html(self):\n        \"\"\"Test defined HTML.\"\"\"\n\n        markup = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        </head>\n        <body>\n        <div id=\"0\"></div>\n        <div-custom id=\"1\"></div-custom>\n        <prefix:div id=\"2\"></prefix:div>\n        <prefix:div-custom id=\"3\"></prefix:div-custom>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'body :defined',\n            ['0', '2', '3'],\n            flags=util.HTML\n        )\n\n    @util.skip_no_lxml\n    def test_defined_xhtml(self):\n        \"\"\"Test defined XHTML.\"\"\"\n\n        markup = \"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n            \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n        <head>\n        </head>\n        <body>\n        <div id=\"0\"></div>\n        <div-custom id=\"1\"></div-custom>\n        <prefix:div id=\"2\"></prefix:div>\n        <!--\n        lxml seems to strip away the prefix in versions less than 4.4.0.\n        This was most likely because prefix with no namespace is not really valid.\n        XML does allow colons in names, but encourages them to be used for namespaces.\n        This is a quirk of LXML, but it appears to be fine in 4.4.0+.\n        -->\n        <prefix:div-custom id=\"3\"></prefix:div-custom>\n        </body>\n        </html>\n        \"\"\"\n\n        from lxml import etree\n\n        self.assert_selector(\n            markup,\n            'body :defined',\n            # We should get 3, but for LXML versions less than 4.4.0 we don't for reasons stated above.\n            ['0', '2'] if etree.LXML_VERSION < (4, 4, 0, 0) else ['0', '1', '2'],\n            flags=util.XHTML\n        )\n\n    def test_defined_xml(self):\n        \"\"\"Test defined HTML.\"\"\"\n\n        markup = \"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <html>\n        <head>\n        </head>\n        <body>\n        <div id=\"0\"></div>\n        <div-custom id=\"1\"></div-custom>\n        <prefix:div id=\"2\"></prefix:div>\n        <prefix:div-custom id=\"3\"></prefix:div-custom>\n        </body>\n        </html>\n        \"\"\"\n\n        # Defined is a browser thing.\n        # XML doesn't care about defined and this will match nothing in XML.\n        self.assert_selector(\n            markup,\n            'body :defined',\n            [],\n            flags=util.XML\n        )\n", "tests/test_level4/test_nth_last_child.py": "\"\"\"Test `nth` last child selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNthLastChild(util.TestCase):\n    \"\"\"Test `nth` last child selectors.\"\"\"\n\n    def test_nth_child_of_s_complex(self):\n        \"\"\"Test `nth` child with selector (complex).\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":nth-last-child(2n + 1 of p[id], span[id])\",\n            ['1', '3', '5', '7', '9', '11'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_optional.py": "\"\"\"Test optional selectors.\"\"\"\nfrom .. import util\n\n\nclass TestOptional(util.TestCase):\n    \"\"\"Test optional selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <form>\n    <input id=\"1\" type=\"name\" required>\n    <input id=\"2\" type=\"checkbox\" required>\n    <input id=\"3\" type=\"email\">\n    <textarea id=\"4\" name=\"name\" cols=\"30\" rows=\"10\"></textarea>\n    <select id=\"5\" name=\"nm\">\n        <!-- options -->\n    </select>\n    </form>\n    \"\"\"\n\n    def test_optional(self):\n        \"\"\"Test optional.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":optional\",\n            ['3', '4', '5'],\n            flags=util.HTML\n        )\n\n    def test_specific_optional(self):\n        \"\"\"Test specific optional.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"input:optional\",\n            ['3'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_focus_visible.py": "\"\"\"Test focus visible selectors.\"\"\"\nfrom .. import util\n\n\nclass TestFocusVisible(util.TestCase):\n    \"\"\"Test focus visible selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <form id=\"form\">\n      <input type=\"text\">\n    </form>\n    \"\"\"\n\n    def test_focus_visible(self):\n        \"\"\"Test focus visible.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"form:focus-visible\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_focus_visible(self):\n        \"\"\"Test inverse of focus visible.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"form:not(:focus-visible)\",\n            [\"form\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_matches.py": "\"\"\"Test matches selectors.\"\"\"\nfrom .. import util\n\n\nclass TestMatches(util.TestCase):\n    \"\"\"Test matches selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\"> in a paragraph</span>.\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_matches(self):\n        \"\"\"Test multiple selectors with \"matches\".\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":matches(span, a)\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_nested_matches(self):\n        \"\"\"Test multiple nested selectors with \"matches\".\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":matches(span, a:matches(#\\\\32))\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_future.py": "\"\"\"Test future selectors.\"\"\"\nfrom .. import util\n\n\nclass TestFuture(util.TestCase):\n    \"\"\"Test future selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n    <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n    <a id=\"3\">Placeholder text.</a>\n    </p>\n    </div>\n    </body>\n    \"\"\"\n\n    def test_future(self):\n        \"\"\"Test future (should match nothing).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:future\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_future(self):\n        \"\"\"Test not future.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:not(:future)\",\n            [\"0\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_user_invalid.py": "\"\"\"Test invalid selectors.\"\"\"\nfrom .. import util\n\n\nclass TestInvalid(util.TestCase):\n    \"\"\"Test invalid selectors.\"\"\"\n\n    def test_user_invalid(self):\n        \"\"\"Test user invalid (matches nothing).\"\"\"\n\n        markup = \"\"\"\n        <form id=\"form\">\n          <input id=\"1\" type=\"text\">\n        </form>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"input:user-invalid\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"input:not(:user-invalid)\",\n            [\"1\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_required.py": "\"\"\"Test required selectors.\"\"\"\nfrom .. import util\n\n\nclass TestRequired(util.TestCase):\n    \"\"\"Test required selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <form>\n    <input id=\"1\" type=\"name\" required>\n    <input id=\"2\" type=\"checkbox\" required>\n    <input id=\"3\" type=\"email\">\n    <textarea id=\"4\" name=\"name\" cols=\"30\" rows=\"10\" required></textarea>\n    <select id=\"5\" name=\"nm\" required>\n        <!-- options -->\n    </select>\n    </form>\n    \"\"\"\n\n    def test_required(self):\n        \"\"\"Test required.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":required\",\n            ['1', '2', '4', '5'],\n            flags=util.HTML\n        )\n\n    def test_specific_required(self):\n        \"\"\"Test specific required.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"input:required\",\n            ['1', '2'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_in_range.py": "\"\"\"Test in range selectors.\"\"\"\nfrom .. import util\n\n\nclass TestInRange(util.TestCase):\n    \"\"\"Test in range selectors.\"\"\"\n\n    def test_in_range_number(self):\n        \"\"\"Test in range number.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"number\" min=\"0\" max=\"10\" value=\"5\">\n        <input id=\"1\" type=\"number\" min=\"-1\" max=\"10\" value=\"5\">\n        <input id=\"2\" type=\"number\" min=\"2.2\" max=\"8.8\" value=\"5.2\">\n        <input id=\"3\" type=\"number\" min=\"2.2\" value=\"5.2\">\n        <input id=\"4\" type=\"number\" max=\"8.8\" value=\"5.2\">\n        <input id=\"5\" type=\"number\" min=\"2.2\" value=\"2.2\">\n        <input id=\"6\" type=\"number\" max=\"8.8\" value=\"8.8\">\n        <input id=\"7\" type=\"number\" max=\"8.8\">\n        <input id=\"8\" type=\"number\" max=\"8.8\" value=\"invalid\">\n\n        <!-- These should not match -->\n        <input id=\"9\" type=\"number\" min=\"0\" max=\"10\" value=\"-1\">\n        <input id=\"10\" type=\"number\" min=\"0\" max=\"10\" value=\"10.1\">\n        <input id=\"11\" type=\"number\" max=\"0\" min=\"10\" value=\"11\">\n\n        <!-- These cannot match -->\n        <input id=\"12\" type=\"number\" value=\"10\">\n        <input id=\"13\" type=\"number\" min=\"invalid\" value=\"10\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6', '7', '8'],\n            flags=util.HTML\n        )\n\n    def test_in_range_range(self):\n        \"\"\"Test in range range.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"range\" min=\"0\" max=\"10\" value=\"5\">\n        <input id=\"1\" type=\"range\" min=\"-1\" max=\"10\" value=\"5\">\n        <input id=\"2\" type=\"range\" min=\"2.2\" max=\"8.8\" value=\"5.2\">\n        <input id=\"3\" type=\"range\" min=\"2.2\" value=\"5.2\">\n        <input id=\"4\" type=\"range\" max=\"8.8\" value=\"5.2\">\n        <input id=\"5\" type=\"range\" min=\"2.2\" value=\"2.2\">\n        <input id=\"6\" type=\"range\" max=\"8.8\" value=\"8.8\">\n        <input id=\"7\" type=\"range\" max=\"8.8\">\n        <input id=\"8\" type=\"range\" max=\"8.8\" value=\"invalid\">\n\n        <!-- These should not match -->\n        <input id=\"9\" type=\"range\" min=\"0\" max=\"10\" value=\"-1\">\n        <input id=\"10\" type=\"range\" min=\"0\" max=\"10\" value=\"10.1\">\n\n        <!-- These cannot match -->\n        <input id=\"11\" type=\"range\" value=\"10\">\n        <input id=\"12\" type=\"range\" min=\"invalid\" value=\"10\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6', '7', '8'],\n            flags=util.HTML\n        )\n\n    def test_in_range_month(self):\n        \"\"\"Test in range month.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\">\n        <input id=\"1\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1980-02\">\n        <input id=\"2\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"2004-08\">\n        <input id=\"3\" type=\"month\" min=\"1980-02\" value=\"1999-05\">\n        <input id=\"4\" type=\"month\" max=\"2004-08\" value=\"1999-05\">\n        <input id=\"5\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-13\">\n        <input id=\"6\" type=\"month\" min=\"1980-02\" max=\"2004-08\">\n\n        <!-- These should not match -->\n        <input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\">\n        <input id=\"8\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1980-01\">\n        <input id=\"9\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"2005-08\">\n        <input id=\"10\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"2004-09\">\n\n        <!-- These cannot match -->\n        <input id=\"11\" type=\"month\" value=\"1999-05\">\n        <input id=\"12\" type=\"month\" min=\"invalid\" value=\"1999-05\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_in_range_week(self):\n        \"\"\"Test in range week.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1999-W05\">\n        <input id=\"1\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1980-W53\">\n        <input id=\"2\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2004-W20\">\n        <input id=\"3\" type=\"week\" min=\"1980-W53\" value=\"1999-W05\">\n        <input id=\"4\" type=\"week\" max=\"2004-W20\" value=\"1999-W05\">\n        <input id=\"5\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2005-W53\">\n        <input id=\"6\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2005-w52\">\n        <input id=\"7\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\">\n\n        <!-- These should not match -->\n        <input id=\"8\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1979-W53\">\n        <input id=\"9\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1980-W52\">\n        <input id=\"10\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2005-W20\">\n        <input id=\"11\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2004-W21\">\n\n        <!-- These cannot match -->\n        <input id=\"12\" type=\"week\" value=\"1999-W05\">\n        <input id=\"13\" type=\"week\" min=\"invalid\" value=\"1999-W05\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6', '7'],\n            flags=util.HTML\n        )\n\n    def test_in_range_date(self):\n        \"\"\"Test in range date.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1999-05-16\">\n        <input id=\"1\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1980-02-20\">\n        <input id=\"2\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2004-08-14\">\n        <input id=\"3\" type=\"date\" min=\"1980-02-20\" value=\"1999-05-16\">\n        <input id=\"4\" type=\"date\" max=\"2004-08-14\" value=\"1999-05-16\">\n        <input id=\"5\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1999-13-16\">\n        <input id=\"6\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\">\n\n        <!-- These should not match -->\n        <input id=\"7\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1979-02-20\">\n        <input id=\"8\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1980-01-20\">\n        <input id=\"9\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1980-02-19\">\n        <input id=\"10\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2005-08-14\">\n        <input id=\"11\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2004-09-14\">\n        <input id=\"12\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2004-09-15\">\n\n        <!-- These cannot match -->\n        <input id=\"13\" type=\"date\" value=\"1999-05-16\">\n        <input id=\"14\" type=\"date\" min=\"invalid\" value=\"1999-05-16\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_in_range_date_time(self):\n        \"\"\"Test in range date_time.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1999-05-16T20:20\">\n        <input id=\"1\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-20T01:30\">\n        <input id=\"2\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-14T18:45\">\n        <input id=\"3\" type=\"datetime-local\" min=\"1980-02-20T01:30\" value=\"1999-05-16T20:20\">\n        <input id=\"4\" type=\"datetime-local\" max=\"2004-08-14T18:45\" value=\"1999-05-16T20:20\">\n        <input id=\"5\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1999-05-16T24:20\">\n        <input id=\"6\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\">\n\n        <!-- These should not match -->\n        <input id=\"7\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1979-02-20T01:30\">\n        <input id=\"8\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-01-20T01:30\">\n        <input id=\"9\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-19T01:30\">\n        <input id=\"10\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-19T00:30\">\n        <input id=\"11\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-19T01:29\">\n        <input id=\"12\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2005-08-14T18:45\">\n        <input id=\"13\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-09-14T18:45\">\n        <input id=\"14\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-15T18:45\">\n        <input id=\"15\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-14T19:45\">\n        <input id=\"16\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-14T18:46\">\n\n        <!-- These cannot match -->\n        <input id=\"17\" type=\"datetime-local\" value=\"1999-05-16T20:20\">\n        <input id=\"18\" type=\"datetime-local\" min=\"invalid\" value=\"1999-05-16T20:20\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_in_range_time(self):\n        \"\"\"Test in range time.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should all match -->\n        <input id=\"0\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"10:20\">\n        <input id=\"1\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"20:20\">\n        <input id=\"2\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"01:30\">\n        <input id=\"3\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"18:45\">\n        <input id=\"4\" type=\"time\" min=\"01:30\" value=\"10:20\">\n        <input id=\"5\" type=\"time\" max=\"18:45\" value=\"10:20\">\n        <input id=\"6\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"24:20\">\n        <input id=\"7\" type=\"time\" min=\"01:30\" max=\"18:45\">\n\n        <!-- These should not match -->\n        <input id=\"8\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"00:30\">\n        <input id=\"9\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"01:29\">\n        <input id=\"10\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"19:45\">\n        <input id=\"11\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"18:46\">\n        <input id=\"12\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"02:30\">\n        <input id=\"13\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"17:45\">\n        <input id=\"14\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"18:44\">\n\n        <!-- These cannot match -->\n        <input id=\"15\" type=\"time\" value=\"10:20\">\n        <input id=\"16\" type=\"time\" min=\"invalid\" value=\"10:20\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":in-range\",\n            ['0', '1', '2', '3', '4', '5', '6', '7'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_focus_within.py": "\"\"\"Test focus within selectors.\"\"\"\nfrom .. import util\n\n\nclass TestFocusWithin(util.TestCase):\n    \"\"\"Test focus within selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <form id=\"form\">\n      <input type=\"text\">\n    </form>\n    \"\"\"\n\n    def test_focus_within(self):\n        \"\"\"Test focus within.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"form:focus-within\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_focus_within(self):\n        \"\"\"Test inverse of focus within.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"form:not(:focus-within)\",\n            [\"form\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_host_context.py": "\"\"\"Test host context selectors.\"\"\"\nfrom .. import util\n\n\nclass TestHostContext(util.TestCase):\n    \"\"\"Test host context selectors.\"\"\"\n\n    def test_host_context(self):\n        \"\"\"Test host context (not supported).\"\"\"\n\n        markup = \"\"\"<h1>header</h1><div><p>some text</p></div>\"\"\"\n\n        self.assert_selector(\n            markup,\n            \":host-context(h1, h2)\",\n            [],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_current.py": "\"\"\"Test current selectors.\"\"\"\nfrom .. import util\n\n\nclass TestCurrent(util.TestCase):\n    \"\"\"Test current selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n    <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n    <a id=\"3\">Placeholder text.</a>\n    </p>\n    </div>\n    </body>\n    \"\"\"\n\n    def test_current(self):\n        \"\"\"Test current (should match nothing).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:current\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_current(self):\n        \"\"\"Test not current.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:not(:current)\",\n            [\"0\"],\n            flags=util.HTML\n        )\n\n    def test_current_func(self):\n        \"\"\"Test the functional form of current (should match nothing).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":current(p, div, a)\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_current_func_nested(self):\n        \"\"\"Test the nested functional form of current (should match nothing).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":current(p, :not(div), a)\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"body :not(:current(p, div, a))\",\n            [\"div\", \"0\", \"1\", \"2\", \"3\"],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"body :not(:current(p, :not(div), a))\",\n            [\"div\", \"0\", \"1\", \"2\", \"3\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_read_write.py": "\"\"\"Test read write selectors.\"\"\"\nfrom .. import util\n\n\nclass TestReadWrite(util.TestCase):\n    \"\"\"Test read write selectors.\"\"\"\n\n    def test_read_write(self):\n        \"\"\"Test read write.\"\"\"\n\n        markup = \"\"\"\n        <input id=\"0\">\n        <textarea id=\"1\"></textarea>\n\n        <input id=\"2\">\n        <input id=\"3\" disabled>\n\n        <input id=\"4\" type=\"email\">\n        <input id=\"5\" type=\"number\">\n        <input id=\"6\" type=\"password\">\n        <input id=\"7\" type=\"search\">\n        <input id=\"8\" type=\"tel\">\n        <input id=\"9\" type=\"text\">\n        <input id=\"10\" type=\"url\">\n        <input id=\"11\" type=\"\">\n        <input id=\"12\" type>\n\n        <input id=\"13\" type=\"button\">\n        <input id=\"14\" type=\"checkbox\">\n        <input id=\"15\" type=\"color\">\n        <input id=\"16\" type=\"date\">\n        <input id=\"17\" type=\"datetime-local\">\n        <input id=\"18\" type=\"file\">\n        <input id=\"19\" type=\"hidden\">\n        <input id=\"20\" type=\"image\">\n        <input id=\"21\" type=\"month\">\n        <input id=\"22\" type=\"radio\">\n        <input id=\"23\" type=\"range\">\n        <input id=\"24\" type=\"reset\">\n        <input id=\"25\" type=\"submit\">\n        <input id=\"26\" type=\"time\">\n        <input id=\"27\" type=\"week\">\n\n        <p id=\"28\" contenteditable=\"\">Text</p>\n        <p id=\"29\" contenteditable=\"true\">Text</p>\n        <p id=\"30\" contenteditable=\"TRUE\">Text</p>\n        <p id=\"31\" contenteditable=\"false\">Text</p>\n        <p id=\"32\">Text</p>\n\n        <input id=\"33\" type=\"number\" readonly>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":read-write\",\n            [\n                '0', '1', '2', '4', '5', '6', '7', '8', '9', '10', '11',\n                '12', '16', '17', '21', '26', '27', '28', '29', '30'\n            ],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_out_of_range.py": "\"\"\"Test out of range selectors.\"\"\"\nfrom .. import util\n\n\nclass TestOutOfRange(util.TestCase):\n    \"\"\"Test out of range selectors.\"\"\"\n\n    def test_out_of_range_number(self):\n        \"\"\"Test in range number.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"number\" min=\"0\" max=\"10\" value=\"5\">\n        <input id=\"1\" type=\"number\" min=\"-1\" max=\"10\" value=\"5\">\n        <input id=\"2\" type=\"number\" min=\"2.2\" max=\"8.8\" value=\"5.2\">\n        <input id=\"3\" type=\"number\" min=\"2.2\" value=\"5.2\">\n        <input id=\"4\" type=\"number\" max=\"8.8\" value=\"5.2\">\n        <input id=\"5\" type=\"number\" min=\"2.2\" value=\"2.2\">\n        <input id=\"6\" type=\"number\" max=\"8.8\" value=\"8.8\">\n        <input id=\"7\" type=\"number\" max=\"8.8\">\n        <input id=\"8\" type=\"number\" max=\"8.8\" value=\"invalid\">\n\n        <!-- These should match -->\n        <input id=\"9\" type=\"number\" min=\"0\" max=\"10\" value=\"-1\">\n        <input id=\"10\" type=\"number\" min=\"0\" max=\"10\" value=\"10.1\">\n        <input id=\"11\" type=\"number\" max=\"0\" min=\"10\" value=\"11\">\n\n        <!-- These cannot match -->\n        <input id=\"12\" type=\"number\" value=\"10\">\n        <input id=\"13\" type=\"number\" min=\"invalid\" value=\"10\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['9', '10', '11'],\n            flags=util.HTML\n        )\n\n    def test_out_of_range_range(self):\n        \"\"\"Test in range range.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"range\" min=\"0\" max=\"10\" value=\"5\">\n        <input id=\"1\" type=\"range\" min=\"-1\" max=\"10\" value=\"5\">\n        <input id=\"2\" type=\"range\" min=\"2.2\" max=\"8.8\" value=\"5.2\">\n        <input id=\"3\" type=\"range\" min=\"2.2\" value=\"5.2\">\n        <input id=\"4\" type=\"range\" max=\"8.8\" value=\"5.2\">\n        <input id=\"5\" type=\"range\" min=\"2.2\" value=\"2.2\">\n        <input id=\"6\" type=\"range\" max=\"8.8\" value=\"8.8\">\n        <input id=\"7\" type=\"range\" max=\"8.8\">\n        <input id=\"8\" type=\"range\" max=\"8.8\" value=\"invalid\">\n\n        <!-- These should match -->\n        <input id=\"9\" type=\"range\" min=\"0\" max=\"10\" value=\"-1\">\n        <input id=\"10\" type=\"range\" min=\"0\" max=\"10\" value=\"10.1\">\n\n        <!-- These cannot match -->\n        <input id=\"11\" type=\"range\" value=\"10\">\n        <input id=\"12\" type=\"range\" min=\"invalid\" value=\"10\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['9', '10'],\n            flags=util.HTML\n        )\n\n    def test_out_of_range_month(self):\n        \"\"\"Test in range month.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\">\n        <input id=\"1\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1980-02\">\n        <input id=\"2\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"2004-08\">\n        <input id=\"3\" type=\"month\" min=\"1980-02\" value=\"1999-05\">\n        <input id=\"4\" type=\"month\" max=\"2004-08\" value=\"1999-05\">\n        <input id=\"5\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-13\">\n        <input id=\"6\" type=\"month\" min=\"1980-02\" max=\"2004-08\">\n\n        <!-- These should match -->\n        <input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\">\n        <input id=\"8\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1980-01\">\n        <input id=\"9\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"2005-08\">\n        <input id=\"10\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"2004-09\">\n\n        <!-- These cannot match -->\n        <input id=\"11\" type=\"month\" value=\"1999-05\">\n        <input id=\"12\" type=\"month\" min=\"invalid\" value=\"1999-05\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['7', '8', '9', '10'],\n            flags=util.HTML\n        )\n\n    def test_out_of_range_week(self):\n        \"\"\"Test in range week.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1999-W05\">\n        <input id=\"1\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1980-W53\">\n        <input id=\"2\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2004-W20\">\n        <input id=\"3\" type=\"week\" min=\"1980-W53\" value=\"1999-W05\">\n        <input id=\"4\" type=\"week\" max=\"2004-W20\" value=\"1999-W05\">\n        <input id=\"5\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2005-W53\">\n        <input id=\"6\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2005-w52\">\n        <input id=\"7\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\">\n\n        <!-- These should match -->\n        <input id=\"8\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1979-W53\">\n        <input id=\"9\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"1980-W52\">\n        <input id=\"10\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2005-W20\">\n        <input id=\"11\" type=\"week\" min=\"1980-W53\" max=\"2004-W20\" value=\"2004-W21\">\n\n        <!-- These cannot match -->\n        <input id=\"12\" type=\"week\" value=\"1999-W05\">\n        <input id=\"13\" type=\"week\" min=\"invalid\" value=\"1999-W05\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['8', '9', '10', '11'],\n            flags=util.HTML\n        )\n\n    def test_out_of_range_date(self):\n        \"\"\"Test in range date.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1999-05-16\">\n        <input id=\"1\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1980-02-20\">\n        <input id=\"2\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2004-08-14\">\n        <input id=\"3\" type=\"date\" min=\"1980-02-20\" value=\"1999-05-16\">\n        <input id=\"4\" type=\"date\" max=\"2004-08-14\" value=\"1999-05-16\">\n        <input id=\"5\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1999-13-16\">\n        <input id=\"6\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\">\n\n        <!-- These should match -->\n        <input id=\"7\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1979-02-20\">\n        <input id=\"8\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1980-01-20\">\n        <input id=\"9\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"1980-02-19\">\n        <input id=\"10\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2005-08-14\">\n        <input id=\"11\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2004-09-14\">\n        <input id=\"12\" type=\"date\" min=\"1980-02-20\" max=\"2004-08-14\" value=\"2004-09-15\">\n\n        <!-- These cannot match -->\n        <input id=\"13\" type=\"date\" value=\"1999-05-16\">\n        <input id=\"14\" type=\"date\" min=\"invalid\" value=\"1999-05-16\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['7', '8', '9', '10', '11', '12'],\n            flags=util.HTML\n        )\n\n    def test_out_of_range_date_time(self):\n        \"\"\"Test in range date time.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1999-05-16T20:20\">\n        <input id=\"1\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-20T01:30\">\n        <input id=\"2\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-14T18:45\">\n        <input id=\"3\" type=\"datetime-local\" min=\"1980-02-20T01:30\" value=\"1999-05-16T20:20\">\n        <input id=\"4\" type=\"datetime-local\" max=\"2004-08-14T18:45\" value=\"1999-05-16T20:20\">\n        <input id=\"5\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1999-05-16T24:20\">\n        <input id=\"6\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\">\n\n        <!-- These should match -->\n        <input id=\"7\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1979-02-20T01:30\">\n        <input id=\"8\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-01-20T01:30\">\n        <input id=\"9\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-19T01:30\">\n        <input id=\"10\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-19T00:30\">\n        <input id=\"11\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"1980-02-19T01:29\">\n        <input id=\"12\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2005-08-14T18:45\">\n        <input id=\"13\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-09-14T18:45\">\n        <input id=\"14\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-15T18:45\">\n        <input id=\"15\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-14T19:45\">\n        <input id=\"16\" type=\"datetime-local\" min=\"1980-02-20T01:30\" max=\"2004-08-14T18:45\" value=\"2004-08-14T18:46\">\n\n        <!-- These cannot match -->\n        <input id=\"17\" type=\"datetime-local\" value=\"1999-05-16T20:20\">\n        <input id=\"18\" type=\"datetime-local\" min=\"invalid\" value=\"1999-05-16T20:20\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['7', '8', '9', '10', '11', '12', '13', '14', '15', '16'],\n            flags=util.HTML\n        )\n\n    def test_out_of_range_time(self):\n        \"\"\"Test in range time.\"\"\"\n\n        markup = \"\"\"\n        <!-- These should not match -->\n        <input id=\"0\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"10:20\">\n        <input id=\"1\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"20:20\">\n        <input id=\"2\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"01:30\">\n        <input id=\"3\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"18:45\">\n        <input id=\"4\" type=\"time\" min=\"01:30\" value=\"10:20\">\n        <input id=\"5\" type=\"time\" max=\"18:45\" value=\"10:20\">\n        <input id=\"6\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"24:20\">\n        <input id=\"7\" type=\"time\" min=\"01:30\" max=\"18:45\">\n\n        <!-- These should match -->\n        <input id=\"8\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"00:30\">\n        <input id=\"9\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"01:29\">\n        <input id=\"10\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"19:45\">\n        <input id=\"11\" type=\"time\" min=\"01:30\" max=\"18:45\" value=\"18:46\">\n        <input id=\"12\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"02:30\">\n        <input id=\"13\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"17:45\">\n        <input id=\"14\" type=\"time\" max=\"01:30\" min=\"18:45\" value=\"18:44\">\n\n        <!-- These cannot match -->\n        <input id=\"15\" type=\"time\" value=\"10:20\">\n        <input id=\"16\" type=\"time\" min=\"invalid\" value=\"10:20\">\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":out-of-range\",\n            ['8', '9', '10', '11', '12', '13', '14'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_indeterminate.py": "\"\"\"Test indeterminate selectors.\"\"\"\nfrom .. import util\n\n\nclass TestIndeterminate(util.TestCase):\n    \"\"\"Test indeterminate selectors.\"\"\"\n\n    def test_indeterminate(self):\n        \"\"\"Test indeterminate.\"\"\"\n\n        markup = \"\"\"\n        <input type=\"radio\" name=\"\" id=\"radio-no-name1\">\n        <label>No name 1</label>\n        <input type=\"radio\" name=\"\" id=\"radio-no-name2\" checked>\n        <label>no name 2</label>\n        <div>\n          <input type=\"checkbox\" id=\"checkbox\" indeterminate>\n          <label for=\"checkbox\">This label starts out lime.</label>\n        </div>\n        <div>\n          <input type=\"radio\" name=\"test\" id=\"radio1\">\n          <label for=\"radio1\">This label starts out lime.</label>\n          <form>\n            <input type=\"radio\" name=\"test\" id=\"radio2\">\n            <label for=\"radio2\">This label starts out lime.</label>\n\n            <input type=\"radio\" name=\"test\" id=\"radio3\" checked>\n            <label for=\"radio3\">This label starts out lime.</label>\n\n            <input type=\"radio\" name=\"other\" id=\"radio4\">\n            <label for=\"radio4\">This label starts out lime.</label>\n\n            <input type=\"radio\" name=\"other\" id=\"radio5\">\n            <label for=\"radio5\">This label starts out lime.</label>\n          </form>\n          <input type=\"radio\" name=\"test\" id=\"radio6\">\n          <label for=\"radio6\">This label starts out lime.</label>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":indeterminate\",\n            ['checkbox', 'radio1', 'radio6', 'radio4', 'radio5', 'radio-no-name1'],\n            flags=util.HTML\n        )\n\n    def test_iframe(self):\n        \"\"\"Test indeterminate when `iframe` is involved.\"\"\"\n\n        markup = \"\"\"\n        <form>\n            <input type=\"radio\" name=\"test\" id=\"radio1\">\n            <label for=\"radio1\">This label starts out lime.</label>\n\n            <iframe>\n            <html>\n            <body>\n            <input type=\"radio\" name=\"test\" id=\"radio2\" checked>\n            <label for=\"radio2\">This label starts out lime.</label>\n\n            <input type=\"radio\" name=\"other\" id=\"radio3\">\n            <label for=\"radio3\">This label starts out lime.</label>\n            </body>\n            </html>\n            </iframe></form>\"\"\"\n\n        self.assert_selector(\n            markup,\n            \":indeterminate\",\n            ['radio1', 'radio3'],\n            flags=util.PYHTML\n        )\n", "tests/test_level4/test_dir.py": "\"\"\"Test direction selectors.\"\"\"\nfrom .. import util\nimport soupsieve as sv\n\n\nclass TestDir(util.TestCase):\n    \"\"\"Test direction selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <html id=\"0\">\n    <head></head>\n    <body>\n    <div id=\"1\" dir=\"rtl\">\n      <span id=\"2\">test1</span>\n      <div id=\"3\" dir=\"ltr\">test2\n        <div id=\"4\" dir=\"auto\"><!-- comment -->\u05e2\u05b4\u05d1\u05b0\u05e8\u05b4\u05d9\u05ea<span id=\"5\" dir=\"auto\">()</span></div>\n        <div id=\"6\" dir=\"auto\"><script></script><b> </b><span id=\"7\"><!-- comment -->\u05e2\u05b4\u05d1\u05b0\u05e8\u05b4\u05d9\u05ea</span></div>\n        <span id=\"8\" dir=\"auto\">test3</span>\n      </div>\n      <input id=\"9\" type=\"tel\" value=\"333-444-5555\" pattern=\"[0-9]{3}-[0-9]{3}-[0-9]{4}\">\n      <input id=\"10\" type=\"tel\" dir=\"auto\" value=\"333-444-5555\" pattern=\"[0-9]{3}-[0-9]{3}-[0-9]{4}\">\n      <input id=\"11\" type=\"email\" dir=\"auto\" value=\"test@mail.com\">\n      <input id=\"12\" type=\"search\" dir=\"auto\" value=\"()\">\n      <input id=\"13\" type=\"url\" dir=\"auto\" value=\"https://test.com\">\n      <input id=\"14\" type=\"search\" dir=\"auto\" value=\"\u05e2\u05b4\u05d1\u05b0\u05e8\u05b4\u05d9\u05ea\">\n      <input id=\"15\" type=\"search\" dir=\"auto\" value=\"\">\n      <input id=\"16\" type=\"search\" dir=\"auto\">\n      <textarea id=\"17\" dir=\"auto\">\u05e2\u05b4\u05d1\u05b0\u05e8\u05b4\u05d9\u05ea</textarea>\n      <textarea id=\"18\" dir=\"auto\"></textarea>\n    </div>\n    </body>\n    </html>\n    \"\"\"\n\n    def test_dir_rtl(self):\n        \"\"\"Test general direction right to left.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"div:dir(rtl)\",\n            [\"1\", \"4\", \"6\"],\n            flags=util.HTML\n        )\n\n    def test_dir_ltr(self):\n        \"\"\"Test general direction left to right.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"div:dir(ltr)\",\n            [\"3\"],\n            flags=util.HTML\n        )\n\n    def test_dir_conflict(self):\n        \"\"\"Test conflicting direction.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"div:dir(ltr):dir(rtl)\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_dir_xml(self):\n        \"\"\"Test direction with XML (not supported).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"div:dir(ltr)\",\n            [],\n            flags=util.XML\n        )\n\n    def test_dir_bidi_detect(self):\n        \"\"\"Test bidirectional detection.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"span:dir(rtl)\",\n            ['2', '5', '7'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"span:dir(ltr)\",\n            ['8'],\n            flags=util.HTML\n        )\n\n    def test_dir_on_input(self):\n        \"\"\"Test input direction rules.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(input, textarea):dir(ltr)\",\n            ['9', '10', '11', '12', '13'],\n            flags=util.HTML5\n        )\n\n    def test_dir_on_root(self):\n        \"\"\"Test that the root is assumed left to right if not explicitly defined.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"html:dir(ltr)\",\n            ['0'],\n            flags=util.HTML\n        )\n\n    def test_dir_auto_root(self):\n        \"\"\"Test that the root is assumed left to right if auto used.\"\"\"\n\n        markup = \"\"\"\n        <html id=\"0\" dir=\"auto\">\n        <head></head>\n        <body>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"html:dir(ltr)\",\n            ['0'],\n            flags=util.HTML\n        )\n\n    def test_dir_on_input_root(self):\n        \"\"\"Test input direction when input is the root.\"\"\"\n\n        markup = \"\"\"<input id=\"1\" type=\"text\" dir=\"auto\">\"\"\"\n        # Input is root\n        for parser in util.available_parsers('html.parser', 'lxml', 'html5lib'):\n            soup = self.soup(markup, parser)\n            fragment = soup.input.extract()\n            self.assertTrue(sv.match(\":root:dir(ltr)\", fragment, flags=sv.DEBUG))\n\n    def test_iframe(self):\n        \"\"\"Test direction in `iframe`.\"\"\"\n\n        markup = \"\"\"\n        <html>\n        <head></head>\n        <body>\n        <div id=\"1\" dir=\"auto\">\n        <iframe>\n        <html>\n        <body>\n        <div id=\"2\" dir=\"auto\">\n        <!-- comment -->\u05e2\u05b4\u05d1\u05b0\u05e8\u05b4\u05d9\u05ea\n        <span id=\"5\" dir=\"auto\">()</span></div>\n        </div>\n        </body>\n        </html>\n        </iframe>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"div:dir(ltr)\",\n            ['1'],\n            flags=util.PYHTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"div:dir(rtl)\",\n            ['2'],\n            flags=util.PYHTML\n        )\n\n    def test_xml_in_html(self):\n        \"\"\"Test cases for when we have XML in HTML.\"\"\"\n\n        markup = \"\"\"\n        <html>\n        <head></head>\n        <body>\n        <div id=\"1\" dir=\"auto\">\n        <math>\n        <!-- comment -->\u05e2\u05b4\u05d1\u05b0\u05e8\u05b4\u05d9\u05ea\n        </math>\n        other text\n        </div>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"div:dir(ltr)\",\n            ['1'],\n            flags=util.HTML5\n        )\n\n        self.assert_selector(\n            markup,\n            \"div:dir(rtl)\",\n            [],\n            flags=util.HTML5\n        )\n\n        self.assert_selector(\n            markup,\n            \"math:dir(rtl)\",\n            [],\n            flags=util.HTML5\n        )\n", "tests/test_level4/test_scope.py": "\"\"\"Test scope selectors.\"\"\"\nfrom .. import util\nimport soupsieve as sv\n\n\nclass TestScope(util.TestCase):\n    \"\"\"Test scope selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <html id=\"root\">\n    <head>\n    </head>\n    <body>\n    <div id=\"div\">\n    <p id=\"0\" class=\"somewordshere\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\" class=\"herewords\">Direct child</span>\n    <pre id=\"pre\" class=\"wordshere\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    </body>\n    </html>\n    \"\"\"\n\n    def test_scope_is_root(self):\n        \"\"\"Test scope is the root when the a specific element is not the target of the select call.\"\"\"\n\n        # Scope is root when applied to a document node\n        self.assert_selector(\n            self.MARKUP,\n            \":scope\",\n            [\"root\"],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \":scope > body > div\",\n            [\"div\"],\n            flags=util.HTML\n        )\n\n    def test_scope_cannot_select_target(self):\n        \"\"\"Test that scope, the element which scope is called on, cannot be selected.\"\"\"\n\n        for parser in util.available_parsers(\n                'html.parser', 'lxml', 'html5lib', 'xml'):\n            soup = self.soup(self.MARKUP, parser)\n            el = soup.html\n\n            # Scope is the element we are applying the select to, and that element is never returned\n            self.assertTrue(len(sv.select(':scope', el, flags=sv.DEBUG)) == 0)\n\n    def test_scope_is_select_target(self):\n        \"\"\"Test that scope is the element which scope is called on.\"\"\"\n\n        for parser in util.available_parsers(\n                'html.parser', 'lxml', 'html5lib', 'xml'):\n            soup = self.soup(self.MARKUP, parser)\n            el = soup.html\n\n            # Scope here means the current element under select\n            ids = [el.attrs['id'] for el in sv.select(':scope div', el, flags=sv.DEBUG)]\n            self.assertEqual(sorted(ids), sorted(['div']))\n\n            el = soup.body\n            ids = [el.attrs['id'] for el in sv.select(':scope div', el, flags=sv.DEBUG)]\n            self.assertEqual(sorted(ids), sorted(['div']))\n\n            # `div` is the current element under select, and it has no `div` elements.\n            el = soup.div\n            ids = [el.attrs['id'] for el in sv.select(':scope div', el, flags=sv.DEBUG)]\n            self.assertEqual(sorted(ids), sorted([]))\n\n            # `div` does have an element with the class `.wordshere`\n            ids = [el.attrs['id'] for el in sv.select(':scope .wordshere', el, flags=sv.DEBUG)]\n            self.assertEqual(sorted(ids), sorted(['pre']))\n", "tests/test_level4/test_has.py": "\"\"\"Test has selectors.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestHas(util.TestCase):\n    \"\"\"Test has selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div id=\"0\" class=\"aaaa\">\n        <p id=\"1\" class=\"bbbb\"></p>\n        <p id=\"2\" class=\"cccc\"></p>\n        <p id=\"3\" class=\"dddd\"></p>\n        <div id=\"4\" class=\"eeee\">\n        <div id=\"5\" class=\"ffff\">\n        <div id=\"6\" class=\"gggg\">\n            <p id=\"7\" class=\"hhhh\"></p>\n            <p id=\"8\" class=\"iiii zzzz\"></p>\n            <p id=\"9\" class=\"jjjj\"></p>\n            <div id=\"10\" class=\"kkkk\">\n                <p id=\"11\" class=\"llll zzzz\"></p>\n            </div>\n        </div>\n        </div>\n        </div>\n    </div>\n    \"\"\"\n\n    MARKUP2 = \"\"\"\n    <div id=\"0\" class=\"aaaa\">\n        <p id=\"1\" class=\"bbbb\"></p>\n    </div>\n    <div id=\"2\" class=\"cccc\">\n        <p id=\"3\" class=\"dddd\"></p>\n    </div>\n    <div id=\"4\" class=\"eeee\">\n        <p id=\"5\" class=\"ffff\"></p>\n    </div>\n    <div id=\"6\" class=\"gggg\">\n        <p id=\"7\" class=\"hhhh\"></p>\n    </div>\n    <div id=\"8\" class=\"iiii\">\n        <p id=\"9\" class=\"jjjj\"></p>\n        <span id=\"10\"></span>\n    </div>\n    \"\"\"\n\n    def test_has_descendant(self):\n        \"\"\"Test has descendant.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'div:not(.aaaa):has(.kkkk > p.llll)',\n            ['4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_has_next_sibling(self):\n        \"\"\"Test has next sibling.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'p:has(+ .dddd:has(+ div .jjjj))',\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_has_subsequent_sibling(self):\n        \"\"\"Test has subsequent sibling.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'p:has(~ .jjjj)',\n            ['7', '8'],\n            flags=util.HTML\n        )\n\n    def test_has_child(self):\n        \"\"\"Test has2.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP2,\n            'div:has(> .bbbb)',\n            ['0'],\n            flags=util.HTML\n        )\n\n    def test_has_case(self):\n        \"\"\"Test has case insensitive.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'div:NOT(.aaaa):HAS(.kkkk > p.llll)',\n            ['4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_has_mixed(self):\n        \"\"\"Test has mixed.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP2,\n            'div:has(> .bbbb, .ffff, .jjjj)',\n            ['0', '4', '8'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP2,\n            'div:has(.ffff, > .bbbb, .jjjj)',\n            ['0', '4', '8'],\n            flags=util.HTML\n        )\n\n    def test_has_nested_pseudo(self):\n        \"\"\"Test has with nested pseudo.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP2,\n            'div:has(> :not(.bbbb, .ffff, .jjjj))',\n            ['2', '6', '8'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP2,\n            'div:not(:has(> .bbbb, .ffff, .jjjj))',\n            ['2', '6'],\n            flags=util.HTML\n        )\n\n    def test_has_no_match(self):\n        \"\"\"Test has with a non-matching selector.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP2,\n            'div:has(:paused)',\n            [],\n            flags=util.HTML\n        )\n\n    def test_has_empty(self):\n        \"\"\"Test has with empty slot due to multiple commas.\"\"\"\n\n        self.assert_raises('div:has()', SelectorSyntaxError)\n\n    def test_invalid_incomplete_has(self):\n        \"\"\"Test `:has()` fails with just a combinator.\"\"\"\n\n        self.assert_raises(':has(>)', SelectorSyntaxError)\n\n    def test_invalid_has_double_combinator(self):\n        \"\"\"Test `:has()` fails with consecutive combinators.\"\"\"\n\n        self.assert_raises(':has(>> has a)', SelectorSyntaxError)\n        self.assert_raises(':has(> has, >> a)', SelectorSyntaxError)\n        self.assert_raises(':has(> has >> a)', SelectorSyntaxError)\n\n    def test_invalid_has_trailing_combinator(self):\n        \"\"\"Test `:has()` fails with trailing combinator.\"\"\"\n\n        self.assert_raises(':has(> has >)', SelectorSyntaxError)\n", "tests/test_level4/test_nth_child.py": "\"\"\"Test `nth` child selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNthChild(util.TestCase):\n    \"\"\"Test `nth` child selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <p id=\"0\"></p>\n    <p id=\"1\"></p>\n    <span id=\"2\" class=\"test\"></span>\n    <span id=\"3\"></span>\n    <span id=\"4\" class=\"test\"></span>\n    <span id=\"5\"></span>\n    <span id=\"6\" class=\"test\"></span>\n    <p id=\"7\"></p>\n    <p id=\"8\" class=\"test\"></p>\n    <p id=\"9\"></p>\n    <p id=\"10\" class=\"test\"></p>\n    <span id=\"11\"></span>\n    \"\"\"\n\n    def test_nth_child_of_s_simple(self):\n        \"\"\"Test `nth` child with selector (simple).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":nth-child(-n+3 of p)\",\n            ['0', '1', '7'],\n            flags=util.HTML\n        )\n\n    def test_nth_child_of_s_complex(self):\n        \"\"\"Test `nth` child with selector (complex).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":nth-child(2n + 1 of :is(p, span).test)\",\n            ['2', '6', '10'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \":nth-child(2n + 1 OF :is(p, span).test)\",\n            ['2', '6', '10'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_not.py": "\"\"\"Test not selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNot(util.TestCase):\n    \"\"\"Test not selectors.\"\"\"\n\n    def test_multi_nested_not(self):\n        \"\"\"Test nested not and multiple selectors.\"\"\"\n\n        markup = \"\"\"\n        <div>\n        <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n        <a id=\"2\" href=\"http://google.com\">Link</a>\n        <span id=\"3\">Direct child</span>\n        <pre id=\"pre\">\n        <span id=\"4\">Child 1</span>\n        <span id=\"5\">Child 2</span>\n        <span id=\"6\">Child 3</span>\n        </pre>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            'div :not(p, :not([id=\\\\35]))',\n            ['5'],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_past.py": "\"\"\"Test past selectors.\"\"\"\nfrom .. import util\n\n\nclass TestPast(util.TestCase):\n    \"\"\"Test past selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n    <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n    <a id=\"3\">Placeholder text.</a>\n    </p>\n    </div>\n    </body>\n    \"\"\"\n\n    def test_past(self):\n        \"\"\"Test past (should match nothing).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:past\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_past(self):\n        \"\"\"Test not past.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:not(:past)\",\n            [\"0\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/__init__.py": "\"\"\"Test level 4 selectors.\"\"\"\n", "tests/test_level4/test_lang.py": "\"\"\"Test language selectors.\"\"\"\nfrom .. import util\n\n\nclass TestLang(util.TestCase):\n    \"\"\"Test language selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div lang=\"de-DE\">\n        <p id=\"1\"></p>\n    </div>\n    <div lang=\"de-DE-1996\">\n        <p id=\"2\"></p>\n    </div>\n    <div lang=\"de-Latn-DE\">\n        <p id=\"3\"></p>\n    </div>\n    <div lang=\"de-Latf-DE\">\n        <p id=\"4\"></p>\n    </div>\n    <div lang=\"de-Latn-DE-1996\">\n        <p id=\"5\"></p>\n    </div>\n    <p id=\"6\" lang=\"de-DE\"></p>\n    <div lang=\"a-DE\">\n        <p id=\"7\"></p>\n    </div>\n    <!-- Singletons don't match implicit wildcards (* not at start are ignored and treated as implicit) -->\n    <div lang=\"a-a-DE\">\n        <p id=\"8\"></p>\n    </div>\n    <div lang=\"en-a-DE\">\n        <p id=\"9\"></p>\n    </div>\n    \"\"\"\n\n    def test_lang(self):\n        \"\"\"Test language and that it uses implicit wildcard.\"\"\"\n\n        # Implicit wild\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang(de-DE)\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_lang_missing_range(self):\n        \"\"\"Test language range with a missing range.\"\"\"\n\n        # Implicit wild\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang(de--DE)\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_explicit_wildcard(self):\n        \"\"\"Test language with explicit wildcard (same as implicit).\"\"\"\n\n        # Explicit wild\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang(de-\\\\*-DE)\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_only_wildcard(self):\n        \"\"\"Test language with only a wildcard.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang('*')\",\n            ['1', '2', '3', '4', '5', '6', '7', '8', '9'],\n            flags=util.HTML\n        )\n\n    def test_wildcard_start_no_match(self):\n        \"\"\"Test language with a wildcard at start, but it matches nothing.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang('*-de-DE')\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_wildcard_start_collapse(self):\n        \"\"\"Test that language with multiple wildcard patterns at start collapse.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang('*-*-*-DE')\",\n            ['1', '2', '3', '4', '5', '6', '7'],\n            flags=util.HTML\n        )\n\n    def test_wildcard_at_start_escaped(self):\n        \"\"\"\n        Test language with wildcard at start (escaped).\n\n        Wildcard in the middle is same as implicit, but at the start, it has specific meaning.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang(\\\\*-DE)\",\n            ['1', '2', '3', '4', '5', '6', '7'],\n            flags=util.HTML\n        )\n\n    def test_language_quoted(self):\n        \"\"\"Test language (quoted).\"\"\"\n\n        # Normal quoted\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang('de-DE')\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_language_quoted_with_escaped_newline(self):\n        \"\"\"Test language (quoted) with escaped new line.\"\"\"\n\n        # Normal quoted\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang('de-\\\\\\nDE')\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_wildcard_at_start_quoted(self):\n        \"\"\"Test language with wildcard at start (quoted).\"\"\"\n\n        # First wild quoted\n        self.assert_selector(\n            self.MARKUP,\n            \"p:lang('*-DE')\",\n            ['1', '2', '3', '4', '5', '6', '7'],\n            flags=util.HTML\n        )\n\n    def test_avoid_implicit_language(self):\n        \"\"\"Test that we can narrow language selection to elements that match and explicitly state language.\"\"\"\n\n        # Target element with language and language attribute\n        self.assert_selector(\n            self.MARKUP,\n            \"p[lang]:lang(de-DE)\",\n            ['6'],\n            flags=util.HTML\n        )\n\n    def test_language_und(self):\n        \"\"\"Test that undefined language can be matched by `*`.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\" lang=\"\"></div>\n        <div id=\"2\" lang=\"und\"></div>\n        <div id=\"3\" lang=>\n            <div id=\"4\"></div>\n        </div>\n        <div id=\"5\"></div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"div:lang('*')\",\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_language_empty_string(self):\n        \"\"\"Test that an empty string language will only match untagged languages `lang=\"\"`.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\" lang=\"\"></div>\n        <div id=\"2\" lang=\"und\"></div>\n        <div id=\"3\" lang=>\n            <div id=\"4\"></div>\n        </div>\n        <div id=\"5\"></div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"div:lang('')\",\n            ['1', '3', '4'],\n            flags=util.HTML\n        )\n\n    def test_language_list(self):\n        \"\"\"Test language list.\"\"\"\n\n        # Multiple languages\n        markup = \"\"\"\n        <div lang=\"de-DE\">\n            <p id=\"1\"></p>\n        </div>\n        <div lang=\"en\">\n            <p id=\"2\"></p>\n        </div>\n        <div lang=\"de-Latn-DE\">\n            <p id=\"3\"></p>\n        </div>\n        <div lang=\"de-Latf-DE\">\n            <p id=\"4\"></p>\n        </div>\n        <div lang=\"en-US\">\n            <p id=\"5\"></p>\n        </div>\n        <p id=\"6\" lang=\"de-DE\"></p>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(de-DE, '*-US')\",\n            ['1', '3', '4', '5', '6'],\n            flags=util.HTML\n        )\n\n    def test_undetermined_language(self):\n        \"\"\"Test undetermined language.\"\"\"\n\n        markup = \"\"\"\n        <div>\n            <p id=\"1\"></p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(en)\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_language_in_header(self):\n        \"\"\"Test that we can find language in header.\"\"\"\n\n        markup = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        <meta http-equiv=\"content-language\" content=\"en-US\">\n        </head>\n        <body>\n        <div>\n            <p id=\"1\"></p>\n        </div>\n        <div>\n            <p id=\"2\"></p>\n        </div>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang('*-US')\",\n            ['1', '2'],\n            flags=util.HTML\n        )\n\n    def test_xml_style_language_in_html5(self):\n        \"\"\"Test XML style language when out of HTML5 namespace.\"\"\"\n\n        markup = \"\"\"\n        <math xml:lang=\"en\">\n            <mtext id=\"1\"></mtext>\n        </math>\n        <div xml:lang=\"en\">\n            <mtext id=\"2\"></mtext>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"mtext:lang(en)\",\n            ['1'],\n            flags=util.HTML5\n        )\n\n    def test_xml_style_language(self):\n        \"\"\"Test XML style language.\"\"\"\n\n        # XML style language\n        markup = \"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <html>\n        <head>\n        </head>\n        <body>\n        <div xml:lang=\"de-DE\">\n            <p id=\"1\"></p>\n        </div>\n        <div xml:lang=\"de-DE-1996\">\n            <p id=\"2\"></p>\n        </div>\n        <div xml:lang=\"de-Latn-DE\">\n            <p id=\"3\"></p>\n        </div>\n        <div xml:lang=\"de-Latf-DE\">\n            <p id=\"4\"></p>\n        </div>\n        <div xml:lang=\"de-Latn-DE-1996\">\n            <p id=\"5\"></p>\n        </div>\n        <p id=\"6\" xml:lang=\"de-DE\"></p>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(de-DE)\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.XML\n        )\n\n    def test_language_in_xhtml(self):\n        \"\"\"Test language in XHTML.\"\"\"\n\n        markup = \"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n            \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n        <head>\n        </head>\n        <body>\n        <div lang=\"de-DE\" xml:lang=\"de-DE\">\n            <p id=\"1\"></p>\n        </div>\n        <div lang=\"de-DE-1996\" xml:lang=\"de-DE-1996\">\n            <p id=\"2\"></p>\n        </div>\n        <div lang=\"de-Latn-DE\" xml:lang=\"de-Latn-DE\">\n            <p id=\"3\"></p>\n        </div>\n        <div lang=\"de-Latf-DE\" xml:lang=\"de-Latf-DE\">\n            <p id=\"4\"></p>\n        </div>\n        <div lang=\"de-Latn-DE-1996\" xml:lang=\"de-Latn-DE-1996\">\n            <p id=\"5\"></p>\n        </div>\n        <p id=\"6\" lang=\"de-DE\" xml:lang=\"de-DE\"></p>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(de-DE)\",\n            ['1', '2', '3', '4', '5', '6'],\n            flags=util.XML\n        )\n\n    def test_language_in_xhtml_without_html_style_lang(self):\n        \"\"\"\n        Test language in XHTML.\n\n        HTML namespace elements must use HTML style language.\n        \"\"\"\n\n        # XHTML language: `lang`\n        markup = \"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n            \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n        <head>\n        </head>\n        <body>\n        <div xml:lang=\"de-DE\">\n            <p id=\"1\"></p>\n        </div>\n        <div xml:lang=\"de-DE-1996\">\n            <p id=\"2\"></p>\n        </div>\n        <div xml:lang=\"de-Latn-DE\">\n            <p id=\"3\"></p>\n        </div>\n        <div xml:lang=\"de-Latf-DE\">\n            <p id=\"4\"></p>\n        </div>\n        <div xml:lang=\"de-Latn-DE-1996\">\n            <p id=\"5\"></p>\n        </div>\n        <p id=\"6\" xml:lang=\"de-DE\"></p>\n        </body>\n        </html>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:lang(de-DE)\",\n            [],\n            flags=util.XHTML\n        )\n", "tests/test_level4/test_playing.py": "\"\"\"Test playing selectors.\"\"\"\nfrom .. import util\n\n\nclass TestPlaying(util.TestCase):\n    \"\"\"Test playing selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <!DOCTYPE html>\n    <html>\n    <body>\n\n    <video id=\"vid\" width=\"320\" height=\"240\" controls>\n      <source src=\"movie.mp4\" type=\"video/mp4\">\n      <source src=\"movie.ogg\" type=\"video/ogg\">\n      Your browser does not support the video tag.\n    </video>\n\n    </body>\n    </html>\n    \"\"\"\n\n    def test_playing(self):\n        \"\"\"Test playing (matches nothing).\"\"\"\n\n        # Not actually sure how this is used, but it won't match anything anyways\n        self.assert_selector(\n            self.MARKUP,\n            \"video:playing\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_playing(self):\n        \"\"\"Test not playing.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"video:not(:playing)\",\n            [\"vid\"],\n            flags=util.HTML\n        )\n", "tests/test_level4/test_any_link.py": "\"\"\"Test any link selectors.\"\"\"\nfrom .. import util\n\n\nclass TestAnyLink(util.TestCase):\n    \"\"\"Test any link selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n    <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n    <a id=\"3\">Placeholder text.</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_anylink(self):\n        \"\"\"Test any link (all links are unvisited).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":any-link\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_anylink_xml(self):\n        \"\"\"Test that any link will not match in XML (all links are unvisited).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"a:any-link\",\n            [],\n            flags=util.XML\n        )\n\n    def test_anylink_xhtml(self):\n        \"\"\"Test that any link will not match in XHTML (all links are unvisited).\"\"\"\n\n        self.assert_selector(\n            self.wrap_xhtml(self.MARKUP),\n            \"a:any-link\",\n            ['2'],\n            flags=util.XHTML\n        )\n\n    def test_not_anylink(self):\n        \"\"\"Test the inverse of any link (all links are unvisited).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":not(a:any-link)\",\n            [\"div\", \"0\", \"1\", \"2\", \"3\"],\n            flags=util.XML\n        )\n", "tests/test_level4/test_is.py": "\"\"\"Test is selectors.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestIs(util.TestCase):\n    \"\"\"Test is selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\"> in a paragraph</span>.\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_is(self):\n        \"\"\"Test multiple selectors with \"is\".\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span, a)\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_is_multi_comma(self):\n        \"\"\"Test multiple selectors but with an empty slot due to multiple commas.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span, , a)\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_is_leading_comma(self):\n        \"\"\"Test multiple selectors but with an empty slot due to leading commas.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(, span, a)\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_is_trailing_comma(self):\n        \"\"\"Test multiple selectors but with an empty slot due to trailing commas.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span, a, )\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_is_empty(self):\n        \"\"\"Test empty `:is()` selector list.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is()\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_nested_is(self):\n        \"\"\"Test multiple nested selectors.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span, a:is(#\\\\32))\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span, a:is(#\\\\32))\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_is_with_other_pseudo(self):\n        \"\"\"Test `:is()` behavior when paired with `:not()`.\"\"\"\n\n        # Each pseudo class is evaluated separately\n        # So this will not match\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span):not(span)\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_multiple_is(self):\n        \"\"\"Test `:is()` behavior when paired with `:not()`.\"\"\"\n\n        # Each pseudo class is evaluated separately\n        # So this will not match\n        self.assert_selector(\n            self.MARKUP,\n            \":is(span):is(div)\",\n            [],\n            flags=util.HTML\n        )\n\n        # Each pseudo class is evaluated separately\n        # So this will match\n        self.assert_selector(\n            self.MARKUP,\n            \":is(a):is(#\\\\32)\",\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_invalid_pseudo_class_start_combinator(self):\n        \"\"\"Test invalid start combinator in pseudo-classes other than `:has()`.\"\"\"\n\n        self.assert_raises(':is(> div)', SelectorSyntaxError)\n        self.assert_raises(':is(div, > div)', SelectorSyntaxError)\n\n    def test_invalid_pseudo_orphan_close(self):\n        \"\"\"Test invalid, orphaned pseudo close.\"\"\"\n\n        self.assert_raises('div)', SelectorSyntaxError)\n\n    def test_invalid_pseudo_open(self):\n        \"\"\"Test invalid pseudo close.\"\"\"\n\n        self.assert_raises(':is(div', SelectorSyntaxError)\n", "tests/test_level4/test_read_only.py": "\"\"\"Test read only selectors.\"\"\"\nfrom .. import util\n\n\nclass TestReadOnly(util.TestCase):\n    \"\"\"Test read only selectors.\"\"\"\n\n    def test_read_only(self):\n        \"\"\"Test read only.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <input id=\"0\">\n        <textarea id=\"1\"></textarea>\n\n        <input id=\"2\">\n        <input id=\"3\" disabled>\n\n        <input id=\"4\" type=\"email\">\n        <input id=\"5\" type=\"number\">\n        <input id=\"6\" type=\"password\">\n        <input id=\"7\" type=\"search\">\n        <input id=\"8\" type=\"tel\">\n        <input id=\"9\" type=\"text\">\n        <input id=\"10\" type=\"url\">\n        <input id=\"11\" type=\"\">\n        <input id=\"12\" type>\n\n        <input id=\"13\" type=\"button\">\n        <input id=\"14\" type=\"checkbox\">\n        <input id=\"15\" type=\"color\">\n        <input id=\"16\" type=\"date\">\n        <input id=\"17\" type=\"datetime-local\">\n        <input id=\"18\" type=\"file\">\n        <input id=\"19\" type=\"hidden\">\n        <input id=\"20\" type=\"image\">\n        <input id=\"21\" type=\"month\">\n        <input id=\"22\" type=\"radio\">\n        <input id=\"23\" type=\"range\">\n        <input id=\"24\" type=\"reset\">\n        <input id=\"25\" type=\"submit\">\n        <input id=\"26\" type=\"time\">\n        <input id=\"27\" type=\"week\">\n\n        <p id=\"28\" contenteditable=\"\">Text</p>\n        <p id=\"29\" contenteditable=\"true\">Text</p>\n        <p id=\"30\" contenteditable=\"TRUE\">Text</p>\n        <p id=\"31\" contenteditable=\"false\">Text</p>\n        <p id=\"32\">Text</p>\n\n        <input id=\"33\" type=\"number\" readonly>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"body :read-only\",\n            [\n                '3', '13', '14', '15', '18', '19', '20', '22',\n                '23', '24', '25', '31', '32', '33'\n            ],\n            flags=util.HTML\n        )\n", "tests/test_level1/test_active.py": "\"\"\"Test active selectors.\"\"\"\nfrom .. import util\n\n\nclass TestActive(util.TestCase):\n    \"\"\"Test active selectors.\"\"\"\n\n    def test_active(self):\n        \"\"\"Test active.\"\"\"\n\n        markup = \"\"\"\n        <div>\n        <p>Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n        <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n        <a id=\"3\">Placeholder text.</a>\n        </p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"a:active\",\n            [],\n            flags=util.HTML\n        )\n", "tests/test_level1/test_link.py": "\"\"\"Test link selectors.\"\"\"\nfrom .. import util\n\n\nclass TestLink(util.TestCase):\n    \"\"\"Test link selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n    <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n    <a id=\"3\">Placeholder text.</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_link(self):\n        \"\"\"Test link (all links are unvisited).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":link\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            r\":\\liNk\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_tag_and_link(self):\n        \"\"\"Test link and tag (all links are unvisited).\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"a:link\",\n            [],\n            flags=util.XML\n        )\n", "tests/test_level1/test_at_rule.py": "\"\"\"Test at-rule cases.\"\"\"\nfrom .. import util\n\n\nclass TestAtRule(util.TestCase):\n    \"\"\"Test at-rules.\"\"\"\n\n    def test_at_rule(self):\n        \"\"\"Test at-rule (not supported).\"\"\"\n\n        self.assert_raises('@page :left', NotImplementedError)\n", "tests/test_level1/test_pseudo_class.py": "\"\"\"Test general pseudo-class cases.\"\"\"\nfrom .. import util\n\n\nclass TestPseudoClass(util.TestCase):\n    \"\"\"Test pseudo-classes.\"\"\"\n\n    def test_pseudo_class_not_implemented(self):\n        \"\"\"Test pseudo-class that is not implemented.\"\"\"\n\n        self.assert_raises(':not-implemented', NotImplementedError)\n\n    def test_unrecognized_pseudo(self):\n        \"\"\"Test unrecognized pseudo class.\"\"\"\n\n        self.assert_raises(':before', NotImplementedError)\n", "tests/test_level1/test_pseudo_element.py": "\"\"\"Test general pseudo-element cases.\"\"\"\nfrom .. import util\n\n\nclass TestPseudoElement(util.TestCase):\n    \"\"\"Test pseudo-elements.\"\"\"\n\n    def test_pseudo_element(self):\n        \"\"\"Test that pseudo elements always fail because they are not supported.\"\"\"\n\n        self.assert_raises('::first-line', NotImplementedError)\n", "tests/test_level1/test_type.py": "\"\"\"Test type selectors.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestType(util.TestCase):\n    \"\"\"Test type selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <Tag id=\"1\">\n    <tag id=\"2\"></tag>\n    <TAG id=\"3\"></TAG>\n    </Tag>\n    \"\"\"\n\n    def test_basic_type(self):\n        \"\"\"Test type.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div>\n            <p>Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            </div>\n            \"\"\",\n            \"span\",\n            [\"1\"],\n            flags=util.HTML\n        )\n\n    def test_type_html(self):\n        \"\"\"Test type for HTML.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"tag\",\n            [\"1\", \"2\", \"3\"],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"Tag\",\n            [\"1\", \"2\", \"3\"],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"TAG\",\n            [\"1\", \"2\", \"3\"],\n            flags=util.HTML\n        )\n\n    def test_type_xhtml(self):\n        \"\"\"Test type for XHTML.\"\"\"\n\n        self.assert_selector(\n            self.wrap_xhtml(self.MARKUP),\n            \"tag\",\n            [\"2\"],\n            flags=util.XHTML\n        )\n\n        self.assert_selector(\n            self.wrap_xhtml(self.MARKUP),\n            \"Tag\",\n            [\"1\"],\n            flags=util.XHTML\n        )\n\n        self.assert_selector(\n            self.wrap_xhtml(self.MARKUP),\n            \"TAG\",\n            [\"3\"],\n            flags=util.XHTML\n        )\n\n    def test_type_xml(self):\n        \"\"\"Test type for XML.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"tag\",\n            [\"2\"],\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"Tag\",\n            [\"1\"],\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"TAG\",\n            [\"3\"],\n            flags=util.XML\n        )\n\n    def test_invalid_syntax(self):\n        \"\"\"Test invalid syntax.\"\"\"\n\n        self.assert_raises('div?', SelectorSyntaxError)\n        self.assert_raises('-', SelectorSyntaxError)\n", "tests/test_level1/test_list.py": "\"\"\"Test selector lists.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestSelectorLists(util.TestCase):\n    \"\"\"Test selector lists.\"\"\"\n\n    def test_multiple_tags(self):\n        \"\"\"Test multiple selectors.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div>\n            <p>Some text <span id=\"1\"> in a paragraph</span>.\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            </p>\n            </div>\n            \"\"\",\n            \"span, a\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_invalid_start_comma(self):\n        \"\"\"Test that selectors cannot start with a comma.\"\"\"\n\n        self.assert_raises(', p', SelectorSyntaxError)\n\n    def test_invalid_end_comma(self):\n        \"\"\"Test that selectors cannot end with a comma.\"\"\"\n\n        self.assert_raises('p,', SelectorSyntaxError)\n\n    def test_invalid_double_comma(self):\n        \"\"\"Test that selectors cannot have double combinators.\"\"\"\n\n        self.assert_raises('div,, a', SelectorSyntaxError)\n", "tests/test_level1/test_escapes.py": "\"\"\"Test escapes.\"\"\"\nfrom .. import util\n\n\nclass TestEscapes(util.TestCase):\n    \"\"\"Test escapes.\"\"\"\n\n    def test_escapes(self):\n        \"\"\"Test escapes.\"\"\"\n\n        markup = \"\"\"\n        <div>\n        <p>Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n        <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n        </p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \".foo\\\\:bar\\\\3a foobar\",\n            [\"1\"],\n            flags=util.HTML\n        )\n", "tests/test_level1/test_descendant.py": "\"\"\"Test descendant combinators.\"\"\"\nfrom .. import util\n\n\nclass TestDescendants(util.TestCase):\n    \"\"\"Test descendant combinators.\"\"\"\n\n    def test_descendants(self):\n        \"\"\"Test descendants.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div>\n            <p>Some text <span id=\"1\"> in a paragraph</span>.\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            </p>\n            </div>\n            \"\"\",\n            \"div span\",\n            [\"1\"],\n            flags=util.HTML\n        )\n", "tests/test_level1/test_id.py": "\"\"\"Test ID selectors.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestId(util.TestCase):\n    \"\"\"Test ID selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\"> in a paragraph</span>.\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_id(self):\n        \"\"\"Test ID.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"#\\\\31\",\n            [\"1\"],\n            flags=util.HTML\n        )\n\n    def test_tag_and_id(self):\n        \"\"\"Test tag and ID.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"a#\\\\32\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_malformed_id(self):\n        \"\"\"Test malformed ID.\"\"\"\n\n        # Malformed id\n        self.assert_raises('td#.some-class', SelectorSyntaxError)\n", "tests/test_level1/test_comments.py": "\"\"\"Test comments.\"\"\"\nfrom .. import util\n\n\nclass TestComments(util.TestCase):\n    \"\"\"Test comments.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre>\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_comments(self):\n        \"\"\"Test comments.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"\"\"\n            /* Start comment */\n            div\n            /* This still works as new lines and whitespace count as descendant combiner.\n               This comment won't be seen. */\n            span#\\\\33\n            /* End comment */\n            \"\"\",\n            ['3'],\n            flags=util.HTML\n        )\n\n    def test_comments_in_pseudo_classes(self):\n        \"\"\"Test comments in pseudo-classes.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"\"\"\n            span:not(\n                /* Comments should basically work like they do in real CSS. */\n                span#\\\\33 /* Don't select id 3 */\n            )\n            \"\"\",\n            ['1', '4', '5', '6'],\n            flags=util.HTML\n        )\n", "tests/test_level1/test_class.py": "\"\"\"Test class selectors.\"\"\"\nfrom .. import util\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestClass(util.TestCase):\n    \"\"\"Test class selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\" class=\"foo\"> in a paragraph</span>.\n    <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n    </p>\n    </div>\n    \"\"\"\n\n    # Browsers normally replace NULL with `\\uFFFD`, but some of the parsers\n    # we test just strip out NULL, so we will simulate and just insert `\\uFFFD` directly\n    # to ensure consistent behavior in our tests across parsers.\n    MARKUP_NULL = \"\"\"\n    <div>\n    <p>Some text <span id=\"1\" class=\"foo\\ufffd\"> in a paragraph</span>.\n    <a id=\"2\" class=\"\\ufffdbar\" href=\"http://google.com\">Link</a>\n    </p>\n    </div>\n    \"\"\"\n\n    def test_class(self):\n        \"\"\"Test class.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \".foo\",\n            [\"1\"],\n            flags=util.HTML\n        )\n\n    def test_type_and_class(self):\n        \"\"\"Test type and class.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"a.bar\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_type_and_class_escaped_null(self):\n        \"\"\"Test type and class with an escaped null character.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NULL,\n            r\"a.\\0 bar\",\n            [\"2\"],\n            flags=util.HTML\n        )\n\n    def test_type_and_class_escaped_eof(self):\n        \"\"\"Test type and class with an escaped EOF.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NULL,\n            \"span.foo\\\\\",\n            [\"1\"],\n            flags=util.HTML\n        )\n\n    def test_malformed_class(self):\n        \"\"\"Test malformed class.\"\"\"\n\n        # Malformed class\n        self.assert_raises('td.+#some-id', SelectorSyntaxError)\n\n    def test_class_xhtml(self):\n        \"\"\"Test tag and class with XHTML since internally classes are stored different for XML.\"\"\"\n\n        self.assert_selector(\n            self.wrap_xhtml(self.MARKUP),\n            \".foo\",\n            [\"1\"],\n            flags=util.XHTML\n        )\n\n    def test_multiple_classes(self):\n        \"\"\"Test multiple classes.\"\"\"\n\n        markup = \"\"\"\n        <div>\n        <p>Some text <span id=\"1\" class=\"foo\"> in a paragraph</span>.\n        <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n        <a id=\"3\" class=\"foo\" href=\"http://google.com\">Link</a>\n        <a id=\"4\" class=\"foo bar\" href=\"http://google.com\">Link</a>\n        </p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"a.foo.bar\",\n            [\"4\"],\n            flags=util.HTML\n        )\n\n    def test_malformed_pseudo_class(self):\n        \"\"\"Test malformed class.\"\"\"\n\n        # Malformed pseudo-class\n        self.assert_raises('td:#id', SelectorSyntaxError)\n", "tests/test_level1/__init__.py": "\"\"\"Test level 1 selectors.\"\"\"\n", "tests/test_level1/test_visited.py": "\"\"\"Test visited selectors.\"\"\"\nfrom .. import util\n\n\nclass TestVisited(util.TestCase):\n    \"\"\"Test visited selectors.\"\"\"\n\n    def test_visited(self):\n        \"\"\"Test visited.\"\"\"\n\n        markup = \"\"\"\n        <div>\n        <p>Some text <span id=\"1\" class=\"foo:bar:foobar\"> in a paragraph</span>.\n        <a id=\"2\" class=\"bar\" href=\"http://google.com\">Link</a>\n        <a id=\"3\">Placeholder text.</a>\n        </p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"a:visited\",\n            [],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_attribute.py": "\"\"\"Test attribute selectors.\"\"\"\nfrom .. import util\n\n\nclass TestAttribute(util.TestCase):\n    \"\"\"Test attribute selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\" class=\"herearesomewords\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"pre\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_attribute_begins(self):\n        \"\"\"Test attribute whose value begins with the specified value.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[class^=here]\",\n            [\"0\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_end(self):\n        \"\"\"Test attribute whose value ends with the specified value.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"[class$=words]\",\n            [\"0\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains(self):\n        \"\"\"Test attribute whose value contains the specified value.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"div\">\n        <p id=\"0\" class=\"somewordshere\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n        <a id=\"2\" href=\"http://google.com\">Link</a>\n        <span id=\"3\" class=\"herewords\">Direct child</span>\n        <pre id=\"pre\" class=\"wordshere\">\n        <span id=\"4\">Child 1</span>\n        <span id=\"5\">Child 2</span>\n        <span id=\"6\">Child 3</span>\n        </pre>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"[class*=words]\",\n            [\"0\", \"3\", \"pre\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_contains_with_newlines(self):\n        \"\"\"Test attribute `*=` will match with new lines.\"\"\"\n\n        self.assert_selector(\n            \"<p><span id='1' title='foo bar'>foo1</span><span id='2' title='foo\\nbar'>foo1</span></p>\",\n            \"span[title*='bar']\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_starts_with_newlines(self):\n        \"\"\"Test attribute `^=` will match with new lines.\"\"\"\n\n        self.assert_selector(\n            \"<p><span id='1' title='foo bar'>foo1</span><span id='2' title='foo\\nbar'>foo1</span></p>\",\n            \"span[title^='foo']\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_ends_with_newlines(self):\n        \"\"\"Test attribute `$=` will match with new lines.\"\"\"\n\n        self.assert_selector(\n            \"<p><span id='1' title='foo bar'>foo1</span><span id='2' title='foo\\nbar'>foo1</span></p>\",\n            \"span[title$='bar']\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_dash_list_with_newlines(self):\n        \"\"\"Test attribute `|=` will match with new lines.\"\"\"\n\n        self.assert_selector(\n            \"<p><span id='1' title='fo-o bar'>foo1</span><span id='2' title='fo-o\\nbar'>foo1</span></p>\",\n            \"span[title|='fo']\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n\n    def test_attribute_space_list_with_newlines(self):\n        \"\"\"Test attribute `~=` will match with new lines.\"\"\"\n\n        self.assert_selector(\n            \"<p><span id='1' title='foo bar baz'>foo1</span><span id='2' title='foo\\nbar baz'>foo1</span></p>\",\n            \"span[title~='baz']\",\n            [\"1\", \"2\"],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_root.py": "\"\"\"Test root selectors.\"\"\"\nfrom .. import util\nimport soupsieve as sv\n\n\nclass TestRoot(util.TestCase):\n    \"\"\"Test root selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <html id=\"root\">\n    <head>\n    </head>\n    <body>\n    <div id=\"div\">\n    <p id=\"0\" class=\"somewordshere\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\" class=\"herewords\">Direct child</span>\n    <pre id=\"pre\" class=\"wordshere\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    </body>\n    </html>\n    \"\"\"\n\n    MARKUP_IFRAME = \"\"\"\n    <html id=\"root\">\n    <head>\n    </head>\n    <body>\n    <div id=\"div\">\n    </div>\n    <iframe src=\"https://something.com\">\n    <html id=\"root2\">\n    <head>\n    </head>\n    <body>\n    <div id=\"div2\">\n    </div>\n    </body>\n    </html>\n    </iframe>\n    <div id=\"other-div\"></div>\n    </body>\n    </html>\n    \"\"\"\n\n    def test_root(self):\n        \"\"\"Test root.\"\"\"\n\n        # Root in HTML is `<html>`\n        self.assert_selector(\n            self.MARKUP,\n            \":root\",\n            [\"root\"],\n            flags=util.HTML\n        )\n\n    def test_root_iframe(self):\n        \"\"\"Test root.\"\"\"\n\n        # Root in HTML is `<html>`\n        self.assert_selector(\n            self.MARKUP_IFRAME,\n            \":root\",\n            [\"root\", \"root2\"],\n            flags=util.PYHTML\n        )\n\n    def test_root_complex(self):\n        \"\"\"Test root within a complex selector.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":root > body > div\",\n            [\"div\"],\n            flags=util.HTML\n        )\n\n    def test_no_iframe(self):\n        \"\"\"Test that we don't count `iframe` as root.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_IFRAME,\n            \":root div\",\n            [\"div\", \"div2\", \"other-div\"],\n            flags=util.PYHTML\n        )\n\n        self.assert_selector(\n            self.MARKUP_IFRAME,\n            \":root > body > div\",\n            [\"div\", \"div2\", \"other-div\"],\n            flags=util.PYHTML\n        )\n\n    def test_iframe(self):\n        \"\"\"\n        Test that we only count `iframe` as root since the scoped element is the root.\n\n        Not all the parsers treat `iframe` content the same. `html5lib` for instance\n        will escape the content in the `iframe`, so we are just going to test the builtin\n        Python parser.\n        \"\"\"\n\n        soup = self.soup(self.MARKUP_IFRAME, 'html.parser')\n\n        ids = [el['id'] for el in sv.select(':root div', soup.iframe.html)]\n        self.assertEqual(sorted(ids), sorted(['div2']))\n\n        ids = [el['id'] for el in sv.select(':root > body > div', soup.iframe.html)]\n        self.assertEqual(sorted(ids), sorted(['div2']))\n\n    def test_no_root_double_tag(self):\n        \"\"\"Test when there is no root due to double root tags.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"1\"></div>\n        <div id=\"2\"></div>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        self.assertEqual(soup.select(':root'), [])\n\n    def test_no_root_text(self):\n        \"\"\"Test when there is no root due to HTML text.\"\"\"\n\n        markup = \"\"\"\n        text\n        <div id=\"1\"></div>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        self.assertEqual(soup.select(':root'), [])\n\n    def test_no_root_cdata(self):\n        \"\"\"Test when there is no root due to CDATA and tag.\"\"\"\n\n        markup = \"\"\"\n        <![CDATA[test]]>\n        <div id=\"1\"></div>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        self.assertEqual(soup.select(':root'), [])\n\n    def test_root_whitespace(self):\n        \"\"\"Test when there is root and white space.\"\"\"\n\n        markup = \"\"\"\n\n        <div id=\"1\"></div>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [el['id'] for el in soup.select(':root')]\n        self.assertEqual(sorted(ids), sorted(['1']))\n\n    def test_root_preprocess(self):\n        \"\"\"Test when there is root and pre-processing statement.\"\"\"\n\n        markup = \"\"\"\n        <?php ?>\n        <div id=\"1\"></div>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [el['id'] for el in soup.select(':root')]\n        self.assertEqual(sorted(ids), sorted(['1']))\n\n    def test_root_doctype(self):\n        \"\"\"Test when there is root and doc type.\"\"\"\n\n        markup = \"\"\"\n        <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n        \"http://www.w3.org/TR/html4/strict.dtd\">\n        <div id=\"1\"></div>\n        \"\"\"\n\n        soup = self.soup(markup, 'html.parser')\n        ids = [el['id'] for el in soup.select(':root')]\n        self.assertEqual(sorted(ids), sorted(['1']))\n", "tests/test_level3/test_first_of_type.py": "\"\"\"Test first of type selectors.\"\"\"\nfrom .. import util\n\n\nclass TestFirstOfType(util.TestCase):\n    \"\"\"Test first of type selectors.\"\"\"\n\n    def test_first_of_type_at_start(self):\n        \"\"\"Test first of type which is also the first sibling.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:first-of-type\",\n            ['0'],\n            flags=util.HTML\n        )\n\n    def test_first_of_type_at_middle(self):\n        \"\"\"Test first of type that is not the first sibling.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"span:first-of-type\",\n            ['2'],\n            flags=util.HTML\n        )\n\n    def test_any_first_of_type(self):\n        \"\"\"Test any first of type.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n        self.assert_selector(\n            markup,\n            \"body :first-of-type\",\n            ['0', '2'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_nth_last_child.py": "\"\"\"Test `nth` last child selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNthLastChild(util.TestCase):\n    \"\"\"Test `nth` last child selectors.\"\"\"\n\n    def test_nth_last_child(self):\n        \"\"\"Test `nth` last child.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-last-child(2)\",\n            ['10'],\n            flags=util.HTML\n        )\n\n    def test_nth_last_child_complex(self):\n        \"\"\"Test `nth` last child complex.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-last-child(2n + 1)\",\n            ['1', '7', '9'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_namespace.py": "\"\"\"Test namespace selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNamespace(util.TestCase):\n    \"\"\"Test namespace selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <tag id=\"root\">\n      <head id=\"0\"></head>\n      <foo:other id=\"1\" xmlns:foo=\"http://me.com/namespaces/foofoo\"\n             xmlns:bar=\"http://me.com/namespaces/foobar\">\n      <foo:head id=\"2\">\n        <foo:title id=\"3\"></foo:title>\n        <bar:title id=\"4\"></bar:title>\n      </foo:head>\n      <body id=\"5\">\n        <foo:e1 id=\"6\"></foo:e1>\n        <bar:e1 id=\"7\"></bar:e1>\n        <e1 id=\"8\"></e1>\n        <foo:e2 id=\"9\"></foo:e2>\n        <bar:e2 id=\"10\"></bar:e2>\n        <e2 id=\"11\"></e2>\n        <foo:e3 id=\"12\"></foo:e3>\n        <bar:e3 id=\"13\"></bar:e3>\n        <e3 id=\"14\"></e3>\n      </body>\n      </foo:other>\n      <other id=\"15\" xmlns=\"http://me.com/namespaces/other\">\n        <e4 id=\"16\">Inherit</er>\n      </other>\n    </tag>\n    \"\"\"\n\n    MARKUP_ATTR = \"\"\"\n    <div>\n      <h1>A contrived example</h1>\n      <svg viewBox=\"0 0 20 32\" class=\"icon icon-1\">\n        <use id=\"0\" xlink:href=\"images/sprites.svg#icon-undo\"></use>\n      </svg>\n      <svg viewBox=\"0 0 30 32\" class=\"icon icon-2\">\n        <use id=\"1\" xlink:href=\"images/sprites.svg#icon-redo\"></use>\n      </svg>\n      <svg viewBox=\"0 0 40 32\" class=\"icon icon-3\">\n        <use id=\"2\" xlink:href=\"images/sprites.svg#icon-forward\"></use>\n      </svg>\n      <svg viewBox=\"0 0 50 32\" class=\"icon icon-4\">\n        <use id=\"3\" xlink:href=\"other/sprites.svg#icon-reply\"></use>\n      </svg>\n      <svg viewBox=\"0 0 50 32\" class=\"icon icon-4\">\n        <use id=\"4\" :href=\"other/sprites.svg#icon-reply\"></use>\n      </svg>\n      <svg viewBox=\"0 0 50 32\" class=\"icon icon-4\">\n        <use id=\"5\" other:href=\"other/sprites.svg#icon-reply\" xlink:other=\"value doesn't match\"></use>\n      </svg>\n    </div>\n    \"\"\"\n\n    def wrap_xlink(self, content, xhtml=False):\n        \"\"\"Wrap with `xlink`.\"\"\"\n\n        xhtml_ns = 'xmlns=\"http://www.w3.org/1999/xhtml\"' if xhtml else ''\n\n        return f\"\"\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n            \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html {xhtml_ns} xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n        <head>\n        </head>\n        <body>\n        {content}\n        </body>\n        </html>\n        \"\"\"\n\n    def test_namespace(self):\n        \"\"\"Test namespace.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"foo|title\",\n            [\"3\"],\n            namespaces={\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_namespace_case(self):\n        \"\"\"Test that namespaces are always case sensitive.\"\"\"\n\n        # These won't match\n        self.assert_selector(\n            self.MARKUP,\n            \"FOO|title\",\n            [],\n            namespaces={\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"foo|title\",\n            [],\n            namespaces={\n                \"FOO\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_namespace_with_universal_tag(self):\n        \"\"\"Test namespace with universal selector for the tag.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"bar|*\",\n            [\"4\", \"7\", \"10\", \"13\"],\n            namespaces={\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_no_namespace(self):\n        \"\"\"Test for tags with no namespace.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"|head\",\n            [\"0\"],\n            namespaces={\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_universal_namespace(self):\n        \"\"\"Test for a tag with a universal namespace selector.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"*|e2\",\n            [\"9\", \"10\", \"11\"],\n            namespaces={\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_namespace_no_default(self):\n        \"\"\"\n        Test for a tag with without specifying a default namespace.\n\n        Because we employ level 4 selectors\n        E, when no default namespace is defined, will be read as *|E.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"e3\",\n            [\"12\", \"13\", \"14\"],\n            namespaces={\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_namespace_with_default(self):\n        \"\"\"Test for a tag with a default namespace.\"\"\"\n\n        # Now that we apply a default namespace. Null space.\n        self.assert_selector(\n            self.MARKUP,\n            \"e3\",\n            [\"14\"],\n            namespaces={\n                \"\": \"\",\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"head\",\n            [\"0\"],\n            namespaces={\n                \"\": \"\",\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\"\n            },\n            flags=util.XML\n        )\n\n    def test_namespace_inherit(self):\n        \"\"\"Test for a tag namespace inheritance.\"\"\"\n\n        # Because no prefix is specified for \"other\" in the above document,\n        # `e4` inherits the other namespace. The prefix in this case doesn't matter.\n        # We specify `other` as prefix in our CSS just so we can use it to target the element.\n        self.assert_selector(\n            self.MARKUP,\n            \"e4\",\n            [],\n            namespaces={\n                \"\": \"\",\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\",\n                \"other\": \"http://me.com/namespaces/other\"\n            },\n            flags=util.XML\n        )\n\n        self.assert_selector(\n            self.MARKUP,\n            \"other|e4\",\n            ['16'],\n            namespaces={\n                \"\": \"\",\n                \"foo\": \"http://me.com/namespaces/foofoo\",\n                \"bar\": \"http://me.com/namespaces/foobar\",\n                \"other\": \"http://me.com/namespaces/other\"\n            },\n            flags=util.XML\n        )\n\n    def test_undefined_namespace(self):\n        \"\"\"Test undefined namespace.\"\"\"\n\n        # Namespaces are defined wrong\n        markup = \"\"\"\n        <tag id=\"1\" xmlns:ns1=http://namespace1/ xmlns:ns2=http://namespace2/>\n            <ns1:el id=\"2\">...</ns1:el>\n            <ns2:el id=\"3\">...</ns2:el>\n        </tag>\n        \"\"\"\n\n        # We are not feeding in the namespaces so they shouldn't be found.\n        self.assert_selector(\n            markup,\n            \"ns1|el, ns2|el\",\n            [],\n            flags=util.XML\n        )\n\n    def test_attribute_namespace(self):\n        \"\"\"Test attribute namespace.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_ATTR,\n            '[xlink|href*=forw],[xlink|href=\"images/sprites.svg#icon-redo\"]',\n            ['1', '2'],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.HTML5\n        )\n\n    def test_attribute_namespace_escapes(self):\n        \"\"\"Test attribute namespace escapes.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_ATTR,\n            '[xlink\\\\:href*=forw]',\n            ['2'],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.HTML5\n        )\n\n        self.assert_selector(\n            self.MARKUP_ATTR,\n            '[\\\\:href]',\n            ['4'],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.HTML5\n        )\n\n    def test_invalid_namespace_attribute(self):\n        \"\"\"Test invalid namespace attributes.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_ATTR,\n            '[xlink\\\\:nomatch*=forw]',\n            [],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.HTML5\n        )\n\n        self.assert_selector(\n            self.MARKUP_ATTR,\n            '[bad|href*=forw]',\n            [],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.HTML5\n        )\n\n    def test_attribute_namespace_xhtml(self):\n        \"\"\"Test attribute namespace in XHTML.\"\"\"\n\n        self.assert_selector(\n            self.wrap_xlink(self.MARKUP_ATTR, True),\n            '[xlink|href*=forw],[xlink|href=\"images/sprites.svg#icon-redo\"]',\n            ['1', '2'],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.XHTML\n        )\n\n    def test_attribute_namespace_xml(self):\n        \"\"\"Test attribute namespace in XML.\"\"\"\n\n        self.assert_selector(\n            self.wrap_xlink(self.MARKUP_ATTR),\n            '[xlink|href*=forw],[xlink|href=\"images/sprites.svg#icon-redo\"]',\n            ['1', '2'],\n            namespaces={\"xlink\": \"http://www.w3.org/1999/xlink\"},\n            flags=util.XHTML\n        )\n", "tests/test_level3/test_empty.py": "\"\"\"Test empty selectors.\"\"\"\nfrom .. import util\n\n\nclass TestEmpty(util.TestCase):\n    \"\"\"Test empty selectors.\"\"\"\n\n    def test_empty(self):\n        \"\"\"Test empty.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <div id=\"div\">\n        <p id=\"0\" class=\"somewordshere\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n        <a id=\"2\" href=\"http://google.com\">Link</a>\n        <span id=\"3\" class=\"herewords\">Direct child</span>\n        <pre id=\"pre\" class=\"wordshere\">\n        <span id=\"4\"> <!-- comment --> </span>\n        <span id=\"5\"> </span>\n        <span id=\"6\"></span>\n        <span id=\"7\"><span id=\"8\"></span></span>\n        </pre>\n        </div>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"body :empty\",\n            [\"4\", \"5\", \"6\", \"8\"],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_nth_last_of_type.py": "\"\"\"Test `nth` last of type selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNthLastOfType(util.TestCase):\n    \"\"\"Test `nth` last of type selectors.\"\"\"\n\n    def test_nth_last_of_type(self):\n        \"\"\"Test `nth` last of type.\"\"\"\n\n        markup = \"\"\"\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-last-of-type(3)\",\n            ['8'],\n            flags=util.HTML\n        )\n\n    def test_nth_last_of_type_complex(self):\n        \"\"\"Test `nth` last of type complex.\"\"\"\n\n        markup = \"\"\"\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-last-of-type(2n + 1)\",\n            ['1', '8', '10'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_checked.py": "\"\"\"Test checked selectors.\"\"\"\nfrom .. import util\n\n\nclass TestChecked(util.TestCase):\n    \"\"\"Test checked selectors.\"\"\"\n\n    def test_checked(self):\n        \"\"\"Test checked.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <div>\n          <input type=\"radio\" name=\"my-input\" id=\"yes\" checked>\n          <label for=\"yes\">Yes</label>\n\n          <input type=\"radio\" name=\"my-input\" id=\"no\">\n          <label for=\"no\">No</label>\n        </div>\n\n        <div>\n          <input type=\"checkbox\" name=\"my-checkbox\" id=\"opt-in\" checked>\n          <label for=\"opt-in\">Check me!</label>\n        </div>\n\n        <select name=\"my-select\" id=\"fruit\">\n          <option id=\"1\" value=\"opt1\">Apples</option>\n          <option id=\"2\" value=\"opt2\" selected>Grapes</option>\n          <option id=\"3\" value=\"opt3\">Pears</option>\n        </select>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \":checked\",\n            ['yes', 'opt-in', '2'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_only_of_type.py": "\"\"\"Test only of type selectors.\"\"\"\nfrom .. import util\n\n\nclass TestOnlyOfType(util.TestCase):\n    \"\"\"Test only of type selectors.\"\"\"\n\n    def test_only_of_type(self):\n        \"\"\"Test only of type.\"\"\"\n\n        markup = \"\"\"\n        <div id=\"0\">\n            <p id=\"1\"></p>\n        </div>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <p id=\"4\"></p>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <div>\n            <p id=\"7\"></p>\n            <p id=\"8\"></p>\n        </div>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:only-of-type\",\n            ['1', '4'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_enabled.py": "\"\"\"Test enabled selectors.\"\"\"\nfrom .. import util\n\n\nclass TestEnabled(util.TestCase):\n    \"\"\"Test enabled selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <form action=\"#\">\n      <fieldset id='a' disabled>\n        <legend>\n          Simple fieldset <input type=\"radio\" id=\"1\" checked>\n          <fieldset id='b' disabled>\n            <legend>Simple fieldset <input type=\"radio\" id=\"2\" checked></legend>\n            <input type=\"radio\" id=\"3\" checked>\n            <label for=\"radio\">radio</label>\n          </fieldset>\n        </legend>\n        <fieldset id='c' disabled>\n          <legend>Simple fieldset <input type=\"radio\" id=\"4\" checked></legend>\n          <input type=\"radio\" id=\"5\" checked>\n          <label for=\"radio\">radio</label>\n        </fieldset>\n        <input type=\"radio\" id=\"6\" checked>\n        <label for=\"radio\">radio</label>\n      </fieldset>\n      <optgroup id=\"opt-enable\">\n        <option id=\"7\" disabled>option</option>\n      </optgroup>\n      <optgroup id=\"8\" disabled>\n        <option id=\"9\">option</option>\n      </optgroup>\n      <a href=\"\" id=\"link\">text</a>\n    </form>\n    </body>\n    \"\"\"\n\n    MAKRUP_NESTED = \"\"\"\n    <body>\n    <form action=\"#\">\n      <fieldset id='a' disabled>\n        <legend>\n          Simple fieldset <input type=\"radio\" id=\"1\" checked>\n          <fieldset id='b'>\n            <legend>Simple fieldset <input type=\"radio\" id=\"2\" checked></legend>\n            <input type=\"radio\" id=\"3\" checked>\n            <label for=\"radio\">radio</label>\n          </fieldset>\n        </legend>\n        <fieldset id='c' disabled>\n          <legend>Simple fieldset <input type=\"radio\" id=\"4\" checked></legend>\n          <input type=\"radio\" id=\"5\" checked>\n          <label for=\"radio\">radio</label>\n        </fieldset>\n        <input type=\"radio\" id=\"6\" checked>\n        <label for=\"radio\">radio</label>\n      </fieldset>\n      <optgroup id=\"opt-enable\">\n        <option id=\"7\" disabled>option</option>\n      </optgroup>\n      <optgroup id=\"8\" disabled>\n        <option id=\"9\">option</option>\n      </optgroup>\n      <a href=\"\" id=\"link\">text</a>\n    </form>\n    </body>\n    \"\"\"\n\n    def test_enable_html5(self):\n        \"\"\"\n        Test enable in the HTML5 parser.\n\n        `:any-link`\n        Form elements that have `disabled`.\n        Form elements that are children of a disabled `fieldset`, but not it's `legend`.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":enabled\",\n            ['1', '2', 'opt-enable'],\n            flags=util.HTML5\n        )\n\n    def test_enable_lxml(self):\n        \"\"\"\n        Test enable in the `lxml` HTML parser.\n\n        `:any-link`\n        Form elements that have `disabled`.\n        Form elements that are children of a disabled `fieldset`, but not it's `legend`.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":enabled\",\n            ['1', 'opt-enable'],\n            flags=util.LXML_HTML\n        )\n\n    def test_enable_python(self):\n        \"\"\"\n        Test enable in the built-in HTML parser.\n\n        `:any-link`\n        Form elements that have `disabled`.\n        Form elements that are children of a disabled `fieldset`, but not it's `legend`.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":enabled\",\n            ['1', '2', 'opt-enable'],\n            flags=util.PYHTML\n        )\n\n    def test_enable_with_nested_disabled_form_html5(self):\n        \"\"\"Test enable in the HTML5 parser.\"\"\"\n\n        self.assert_selector(\n            self.MAKRUP_NESTED,\n            \":enabled\",\n            ['1', '2', 'opt-enable', 'b', '3'],\n            flags=util.HTML5\n        )\n\n    def test_enable_with_nested_disabled_form_lxml(self):\n        \"\"\"Test enable in the `lxml` HTML parser.\"\"\"\n\n        self.assert_selector(\n            self.MAKRUP_NESTED,\n            \":enabled\",\n            ['1', 'opt-enable'],\n            flags=util.LXML_HTML\n        )\n\n    def test_enable_with_nested_disabled_form_python(self):\n        \"\"\"Test enable in the built-in HTML parser.\"\"\"\n\n        self.assert_selector(\n            self.MAKRUP_NESTED,\n            \":enabled\",\n            ['1', '2', 'opt-enable', 'b', '3'],\n            flags=util.PYHTML\n        )\n", "tests/test_level3/test_nth_child.py": "\"\"\"Test `nth` child selectors.\"\"\"\nfrom .. import util\nimport soupsieve as sv\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestNthChild(util.TestCase):\n    \"\"\"Test `nth` child selectors.\"\"\"\n\n    def test_nth_child(self):\n        \"\"\"Test `nth` child.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(-2)\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(2)\",\n            ['1'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:NTH-CHILD(2)\",\n            ['1'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            r\"p:NT\\H-CH\\ILD(2)\",\n            ['1'],\n            flags=util.HTML\n        )\n\n    def test_nth_child_odd(self):\n        \"\"\"Test `nth` child odd.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(odd)\",\n            ['0', '8', '10'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(ODD)\",\n            ['0', '8', '10'],\n            flags=util.HTML\n        )\n\n    def test_nth_child_even(self):\n        \"\"\"Test `nth` child even.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(even)\",\n            ['1', '7', '9'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(EVEN)\",\n            ['1', '7', '9'],\n            flags=util.HTML\n        )\n\n    def test_nth_child_complex(self):\n        \"\"\"Test `nth` child complex.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(2n-5)\",\n            ['0', '8', '10'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(2N-5)\",\n            ['0', '8', '10'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(-2n+20)\",\n            ['1', '7', '9'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(50n-20)\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(-2n-2)\",\n            [],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(9n - 1)\",\n            ['7'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(2n + 1)\",\n            ['0', '8', '10'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"p:nth-child(-n+3)\",\n            ['0', '1'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"span:nth-child(-n+3)\",\n            ['2'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"body *:nth-child(-n+3)\",\n            ['0', '1', '2'],\n            flags=util.HTML\n        )\n\n    def test_nth_child_no_parent(self):\n        \"\"\"Test `nth` child with no parent.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        for parser in util.available_parsers('html.parser', 'lxml', 'html5lib'):\n            # Paragraph is the root. There is no document.\n            markup = \"\"\"<p id=\"1\">text</p>\"\"\"\n            soup = self.soup(markup, parser)\n            fragment = soup.p.extract()\n            self.assertTrue(sv.match(\"p:nth-child(1)\", fragment, flags=sv.DEBUG))\n\n    def test_nth_child_with_bad_parameters(self):\n        \"\"\"Test that pseudo class fails with bad parameters (basically it doesn't match).\"\"\"\n\n        self.assert_raises(':nth-child(a)', SelectorSyntaxError)\n", "tests/test_level3/test_last_of_type.py": "\"\"\"Test last of type selectors.\"\"\"\nfrom .. import util\n\n\nclass TestLastOfType(util.TestCase):\n    \"\"\"Test last of type selectors.\"\"\"\n\n    def test_last_of_type_at_middle(self):\n        \"\"\"Test last of type that is not the last sibling.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:last-of-type\",\n            ['10'],\n            flags=util.HTML\n        )\n\n    def test_last_of_type_at_end(self):\n        \"\"\"Test last of type that is the last sibling.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"span:last-of-type\",\n            ['11'],\n            flags=util.HTML\n        )\n\n    def test_any_last_of_type(self):\n        \"\"\"Test any last of type.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"body :last-of-type\",\n            ['10', '11'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_target.py": "\"\"\"Test target selectors.\"\"\"\nfrom .. import util\n\n\nclass TestTarget(util.TestCase):\n    \"\"\"Test target selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <h2 id=\"head-1\">Header 1</h1>\n    <div><p>content</p></div>\n    <h2 id=\"head-2\">Header 2</h1>\n    <div><p>content</p></div>\n    </div>\n    \"\"\"\n\n    def test_target(self):\n        \"\"\"Test target.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"#head-2:target\",\n            [],\n            flags=util.HTML\n        )\n\n    def test_not_target(self):\n        \"\"\"Test not target.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"#head-2:not(:target)\",\n            [\"head-2\"],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_not.py": "\"\"\"Test not selectors.\"\"\"\nfrom .. import util\nfrom bs4 import BeautifulSoup\nfrom soupsieve import SelectorSyntaxError\n\n\nclass TestNot(util.TestCase):\n    \"\"\"Test not selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div>\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"pre\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_not(self):\n        \"\"\"Test not.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'div :not([id=\"1\"])',\n            [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"pre\"],\n            flags=util.HTML\n        )\n\n    def test_not_and_type(self):\n        \"\"\"Test not with a tag.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'span:not([id=\"1\"])',\n            [\"3\", \"4\", \"5\", \"6\"],\n            flags=util.HTML\n        )\n\n    def test_not_case(self):\n        \"\"\"Test not token case insensitivity.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            'div :NOT([id=\"1\"])',\n            [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"pre\"],\n            flags=util.HTML\n        )\n\n    def test_none_inputs(self):\n        \"\"\"Test weird inputs.\"\"\"\n\n        soup = BeautifulSoup('<span foo=\"something\">text</span>', 'html.parser')\n        soup.span['foo'] = None\n        self.assertEqual(len(soup.select('span:not([foo])')), 0)\n\n    def test_invalid_pseudo_empty(self):\n        \"\"\"Test pseudo class group with empty set.\"\"\"\n\n        self.assert_raises(':not()', SelectorSyntaxError)\n\n    def test_invalid_pseudo_trailing_comma(self):\n        \"\"\"Test pseudo class group with trailing comma.\"\"\"\n\n        self.assert_raises(':not(.class,)', SelectorSyntaxError)\n\n    def test_invalid_pseudo_leading_comma(self):\n        \"\"\"Test pseudo class group with leading comma.\"\"\"\n\n        self.assert_raises(':not(,.class)', SelectorSyntaxError)\n\n    def test_invalid_pseudo_multi_comma(self):\n        \"\"\"Test pseudo class group with multiple commas.\"\"\"\n\n        self.assert_raises(':not(.this,,.that)', SelectorSyntaxError)\n", "tests/test_level3/__init__.py": "\"\"\"Test level 3 selectors.\"\"\"\n", "tests/test_level3/test_only_child.py": "\"\"\"Test only child selectors.\"\"\"\nfrom .. import util\n\n\nclass TestOnlyChild(util.TestCase):\n    \"\"\"Test only child selectors.\"\"\"\n\n    def test_only_child(self):\n        \"\"\"Test only child.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div id=\"div\">\n            <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            <span id=\"3\">Direct child</span>\n            <pre id=\"pre\">\n            <span id=\"4\">Child 1</span>\n            <span id=\"5\">Child 2</span>\n            <span id=\"6\">Child 3</span>\n            </pre>\n            </div>\n            \"\"\",\n            \"span:only-child\",\n            [\"1\"],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_subsequent_sibling.py": "\"\"\"Test subsequent sibling combinator.\"\"\"\nfrom .. import util\n\n\nclass TestSubsequentSibling(util.TestCase):\n    \"\"\"Test subsequent sibling combinator.\"\"\"\n\n    def test_subsequent_sibling(self):\n        \"\"\"Test subsequent sibling.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <div>\n            <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n            <a id=\"2\" href=\"http://google.com\">Link</a>\n            <span id=\"3\">Direct child</span>\n            <pre>\n            <span id=\"4\">Child 1</span>\n            <span id=\"5\">Child 2</span>\n            <span id=\"6\">Child 3</span>\n            </pre>\n            </div>\n            \"\"\",\n            \"p ~ span\",\n            [\"3\"],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_disabled.py": "\"\"\"Test disabled selectors.\"\"\"\nfrom .. import util\n\n\nclass TestDisabled(util.TestCase):\n    \"\"\"Test disabled selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <body>\n    <form action=\"#\">\n      <fieldset id='a' disabled>\n        <legend>\n          Simple fieldset <input type=\"radio\" id=\"1\" checked>\n          <fieldset id='b' disabled>\n            <legend>Simple fieldset <input type=\"radio\" id=\"2\" checked></legend>\n            <input type=\"radio\" id=\"3\" checked>\n            <label for=\"radio\">radio</label>\n          </fieldset>\n        </legend>\n        <fieldset id='c' disabled>\n          <legend>Simple fieldset <input type=\"radio\" id=\"4\" checked></legend>\n          <input type=\"radio\" id=\"5\" checked>\n          <label for=\"radio\">radio</label>\n        </fieldset>\n        <input type=\"radio\" id=\"6\" checked>\n        <label for=\"radio\">radio</label>\n      </fieldset>\n      <optgroup>\n        <option id=\"7\" disabled>option</option>\n      </optgroup>\n      <optgroup id=\"8\" disabled>\n        <option id=\"9\">option</option>\n      </optgroup>\n    </form>\n    </body>\n    \"\"\"\n\n    MARKUP_NESTED = \"\"\"\n    <body>\n    <form action=\"#\">\n      <fieldset id='a' disabled>\n        <legend>\n          Simple fieldset <input type=\"radio\" id=\"1\" checked>\n          <fieldset id='b'>\n            <legend>Simple fieldset <input type=\"radio\" id=\"2\" checked></legend>\n            <input type=\"radio\" id=\"3\" checked>\n            <label for=\"radio\">radio</label>\n          </fieldset>\n        </legend>\n        <fieldset id='c' disabled>\n          <legend>Simple fieldset <input type=\"radio\" id=\"4\" checked></legend>\n          <input type=\"radio\" id=\"5\" checked>\n          <label for=\"radio\">radio</label>\n        </fieldset>\n        <input type=\"radio\" id=\"6\" checked>\n        <label for=\"radio\">radio</label>\n      </fieldset>\n      <optgroup>\n        <option id=\"7\" disabled>option</option>\n      </optgroup>\n      <optgroup id=\"8\" disabled>\n        <option id=\"9\">option</option>\n      </optgroup>\n    </form>\n    </body>\n    \"\"\"\n\n    def test_disabled_html5(self):\n        \"\"\"\n        Test disabled for HTML5 parser.\n\n        Form elements that have `disabled`.\n        `option` that is child of disabled `optgroup`.\n        Form elements that are children of a disabled `fieldset`, but not it's `legend`.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":disabled\",\n            ['3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c'],\n            flags=util.HTML5\n        )\n\n    def test_disabled_lxml(self):\n        \"\"\"\n        Test disabled for `lxml` HTML parser.\n\n        Form elements that have `disabled`.\n        `option` that is child of disabled `optgroup`.\n        Form elements that are children of a disabled `fieldset`, but not it's `legend`.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":disabled\",\n            ['2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c'],\n            flags=util.LXML_HTML\n        )\n\n    def test_disabled_python(self):\n        \"\"\"\n        Test disabled for the built-in HTML parser.\n\n        Form elements that have `disabled`.\n        `option` that is child of disabled `optgroup`.\n        Form elements that are children of a disabled `fieldset`, but not it's `legend`.\n        \"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \":disabled\",\n            ['3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c'],\n            flags=util.PYHTML\n        )\n\n    def test_disabled_with_nested_disabled_form_html5(self):\n        \"\"\"Test disabled (with nested disabled forms) in the built-in HTML parser.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NESTED,\n            \":disabled\",\n            ['4', '5', '6', '7', '8', '9', 'a', 'c'],\n            flags=util.HTML5\n        )\n\n    def test_disabled_with_nested_disabled_form_lxml(self):\n        \"\"\"Test disabled (with nested disabled forms) in the `lxml` HTML parser.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NESTED,\n            \":disabled\",\n            ['2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c'],\n            flags=util.LXML_HTML\n        )\n\n    def test_disabled_with_nested_disabled_form_python(self):\n        \"\"\"Test disabled (with nested disabled forms) the built-in HTML parser.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP_NESTED,\n            \":disabled\",\n            ['4', '5', '6', '7', '8', '9', 'a', 'c'],\n            flags=util.PYHTML\n        )\n\n    def test_disabled_with_nested_optgroup(self):\n        \"\"\"Test `:disabled` only selects `option` elements whose closest `optgroup` parent is disabled.\"\"\"\n\n        self.assert_selector(\n            \"\"\"\n            <optgroup id=\"0\" disabled>\n               <option id=\"1\"></option>\n               <optgroup id=\"3\">\n                   <option id=\"4\"></option>\n               </optgroup>\n            </optgroup>\n            \"\"\",\n            \":disabled\",\n            ['0', '1'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_nth_of_type.py": "\"\"\"Test `nth` of type selectors.\"\"\"\nfrom .. import util\n\n\nclass TestNthOfType(util.TestCase):\n    \"\"\"Test `nth` of type selectors.\"\"\"\n\n    def test_nth_of_type(self):\n        \"\"\"Test `nth` of type.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-of-type(3)\",\n            ['7'],\n            flags=util.HTML\n        )\n\n    def test_nth_of_type_complex(self):\n        \"\"\"Test `nth` of type complex.\"\"\"\n\n        markup = \"\"\"\n        <body>\n        <p id=\"0\"></p>\n        <p id=\"1\"></p>\n        <span id=\"2\"></span>\n        <span id=\"3\"></span>\n        <span id=\"4\"></span>\n        <span id=\"5\"></span>\n        <span id=\"6\"></span>\n        <p id=\"7\"></p>\n        <p id=\"8\"></p>\n        <p id=\"9\"></p>\n        <p id=\"10\"></p>\n        <span id=\"11\"></span>\n        </body>\n        \"\"\"\n\n        self.assert_selector(\n            markup,\n            \"p:nth-of-type(2n + 1)\",\n            ['0', '7', '9'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"span:nth-of-type(2n + 1)\",\n            ['2', '4', '6'],\n            flags=util.HTML\n        )\n\n        self.assert_selector(\n            markup,\n            \"body :nth-of-type(2n + 1)\",\n            ['0', '2', '4', '6', '7', '9'],\n            flags=util.HTML\n        )\n", "tests/test_level3/test_last_child.py": "\"\"\"Test last child selectors.\"\"\"\nfrom .. import util\n\n\nclass TestLastChild(util.TestCase):\n    \"\"\"Test last child selectors.\"\"\"\n\n    MARKUP = \"\"\"\n    <div id=\"div\">\n    <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>.</p>\n    <a id=\"2\" href=\"http://google.com\">Link</a>\n    <span id=\"3\">Direct child</span>\n    <pre id=\"pre\">\n    <span id=\"4\">Child 1</span>\n    <span id=\"5\">Child 2</span>\n    <span id=\"6\">Child 3</span>\n    </pre>\n    </div>\n    \"\"\"\n\n    def test_last_child(self):\n        \"\"\"Test last child.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"span:last-child\",\n            [\"1\", \"6\"],\n            flags=util.HTML\n        )\n\n    def test_last_child_case(self):\n        \"\"\"Test last child token's case insensitivity.\"\"\"\n\n        self.assert_selector(\n            self.MARKUP,\n            \"span:LAST-CHILD\",\n            [\"1\", \"6\"],\n            flags=util.HTML\n        )\n"}