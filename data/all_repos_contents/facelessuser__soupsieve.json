{"hatch_build.py": "\"\"\"Dynamically define some metadata.\"\"\"\nimport os\n\nfrom hatchling.metadata.plugin.interface import MetadataHookInterface\n\n\ndef get_version_dev_status(root):\n    \"\"\"Get version_info without importing the entire module.\"\"\"\n\n    import importlib.util\n\n    path = os.path.join(root, \"soupsieve\", \"__meta__.py\")\n    spec = importlib.util.spec_from_file_location(\"__meta__\", path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module.__version_info__._get_dev_status()\n\n\nclass CustomMetadataHook(MetadataHookInterface):\n    \"\"\"Our metadata hook.\"\"\"\n\n    def update(self, metadata):\n        \"\"\"See https://ofek.dev/hatch/latest/plugins/metadata-hook/ for more information.\"\"\"\n\n        metadata[\"classifiers\"] = [\n            f\"Development Status :: {get_version_dev_status(self.root)}\",\n            'Environment :: Console',\n            'Intended Audience :: Developers',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: OS Independent',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n            'Topic :: Software Development :: Libraries :: Python Modules',\n            'Typing :: Typed'\n        ]\n", "soupsieve/pretty.py": "\"\"\"\nFormat a pretty string of a `SoupSieve` object for easy debugging.\n\nThis won't necessarily support all types and such, and definitely\nnot support custom outputs.\n\nIt is mainly geared towards our types as the `SelectorList`\nobject is a beast to look at without some indentation and newlines.\nThe format and various output types is fairly known (though it\nhasn't been tested extensively to make sure we aren't missing corners).\n\nExample:\n-------\n```\n>>> import soupsieve as sv\n>>> sv.compile('this > that.class[name=value]').selectors.pretty()\nSelectorList(\n    selectors=(\n        Selector(\n            tag=SelectorTag(\n                name='that',\n                prefix=None),\n            ids=(),\n            classes=(\n                'class',\n                ),\n            attributes=(\n                SelectorAttribute(\n                    attribute='name',\n                    prefix='',\n                    pattern=re.compile(\n                        '^value$'),\n                    xml_type_pattern=None),\n                ),\n            nth=(),\n            selectors=(),\n            relation=SelectorList(\n                selectors=(\n                    Selector(\n                        tag=SelectorTag(\n                            name='this',\n                            prefix=None),\n                        ids=(),\n                        classes=(),\n                        attributes=(),\n                        nth=(),\n                        selectors=(),\n                        relation=SelectorList(\n                            selectors=(),\n                            is_not=False,\n                            is_html=False),\n                        rel_type='>',\n                        contains=(),\n                        lang=(),\n                        flags=0),\n                    ),\n                is_not=False,\n                is_html=False),\n            rel_type=None,\n            contains=(),\n            lang=(),\n            flags=0),\n        ),\n    is_not=False,\n    is_html=False)\n```\n\n\"\"\"\nfrom __future__ import annotations\nimport re\nfrom typing import Any\n\nRE_CLASS = re.compile(r'(?i)[a-z_][_a-z\\d\\.]+\\(')\nRE_PARAM = re.compile(r'(?i)[_a-z][_a-z\\d]+=')\nRE_EMPTY = re.compile(r'\\(\\)|\\[\\]|\\{\\}')\nRE_LSTRT = re.compile(r'\\[')\nRE_DSTRT = re.compile(r'\\{')\nRE_TSTRT = re.compile(r'\\(')\nRE_LEND = re.compile(r'\\]')\nRE_DEND = re.compile(r'\\}')\nRE_TEND = re.compile(r'\\)')\nRE_INT = re.compile(r'\\d+')\nRE_KWORD = re.compile(r'(?i)[_a-z][_a-z\\d]+')\nRE_DQSTR = re.compile(r'\"(?:\\\\.|[^\"\\\\])*\"')\nRE_SQSTR = re.compile(r\"'(?:\\\\.|[^'\\\\])*'\")\nRE_SEP = re.compile(r'\\s*(,)\\s*')\nRE_DSEP = re.compile(r'\\s*(:)\\s*')\n\nTOKENS = {\n    'class': RE_CLASS,\n    'param': RE_PARAM,\n    'empty': RE_EMPTY,\n    'lstrt': RE_LSTRT,\n    'dstrt': RE_DSTRT,\n    'tstrt': RE_TSTRT,\n    'lend': RE_LEND,\n    'dend': RE_DEND,\n    'tend': RE_TEND,\n    'sqstr': RE_SQSTR,\n    'sep': RE_SEP,\n    'dsep': RE_DSEP,\n    'int': RE_INT,\n    'kword': RE_KWORD,\n    'dqstr': RE_DQSTR\n}\n\n\ndef pretty(obj: Any) -> str:  # pragma: no cover\n    \"\"\"Make the object output string pretty.\"\"\"\n\n    sel = str(obj)\n    index = 0\n    end = len(sel) - 1\n    indent = 0\n    output = []\n\n    while index <= end:\n        m = None\n        for k, v in TOKENS.items():\n            m = v.match(sel, index)\n\n            if m:\n                name = k\n                index = m.end(0)\n                if name in ('class', 'lstrt', 'dstrt', 'tstrt'):\n                    indent += 4\n                    output.append(f'{m.group(0)}\\n{\" \" * indent}')\n                elif name in ('param', 'int', 'kword', 'sqstr', 'dqstr', 'empty'):\n                    output.append(m.group(0))\n                elif name in ('lend', 'dend', 'tend'):\n                    indent -= 4\n                    output.append(m.group(0))\n                elif name in ('sep',):\n                    output.append(f'{m.group(1)}\\n{\" \" * indent}')\n                elif name in ('dsep',):\n                    output.append(f'{m.group(1)} ')\n                break\n\n    return ''.join(output)\n", "soupsieve/css_match.py": "\"\"\"CSS matcher.\"\"\"\nfrom __future__ import annotations\nfrom datetime import datetime\nfrom . import util\nimport re\nfrom . import css_types as ct\nimport unicodedata\nimport bs4  # type: ignore[import]\nfrom typing import Iterator, Iterable, Any, Callable, Sequence, cast  # noqa: F401\n\n# Empty tag pattern (whitespace okay)\nRE_NOT_EMPTY = re.compile('[^ \\t\\r\\n\\f]')\n\nRE_NOT_WS = re.compile('[^ \\t\\r\\n\\f]+')\n\n# Relationships\nREL_PARENT = ' '\nREL_CLOSE_PARENT = '>'\nREL_SIBLING = '~'\nREL_CLOSE_SIBLING = '+'\n\n# Relationships for :has() (forward looking)\nREL_HAS_PARENT = ': '\nREL_HAS_CLOSE_PARENT = ':>'\nREL_HAS_SIBLING = ':~'\nREL_HAS_CLOSE_SIBLING = ':+'\n\nNS_XHTML = 'http://www.w3.org/1999/xhtml'\nNS_XML = 'http://www.w3.org/XML/1998/namespace'\n\nDIR_FLAGS = ct.SEL_DIR_LTR | ct.SEL_DIR_RTL\nRANGES = ct.SEL_IN_RANGE | ct.SEL_OUT_OF_RANGE\n\nDIR_MAP = {\n    'ltr': ct.SEL_DIR_LTR,\n    'rtl': ct.SEL_DIR_RTL,\n    'auto': 0\n}\n\nRE_NUM = re.compile(r\"^(?P<value>-?(?:[0-9]{1,}(\\.[0-9]+)?|\\.[0-9]+))$\")\nRE_TIME = re.compile(r'^(?P<hour>[0-9]{2}):(?P<minutes>[0-9]{2})$')\nRE_MONTH = re.compile(r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})$')\nRE_WEEK = re.compile(r'^(?P<year>[0-9]{4,})-W(?P<week>[0-9]{2})$')\nRE_DATE = re.compile(r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})$')\nRE_DATETIME = re.compile(\n    r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})T(?P<hour>[0-9]{2}):(?P<minutes>[0-9]{2})$'\n)\nRE_WILD_STRIP = re.compile(r'(?:(?:-\\*-)(?:\\*(?:-|$))*|-\\*$)')\n\nMONTHS_30 = (4, 6, 9, 11)  # April, June, September, and November\nFEB = 2\nSHORT_MONTH = 30\nLONG_MONTH = 31\nFEB_MONTH = 28\nFEB_LEAP_MONTH = 29\nDAYS_IN_WEEK = 7\n\n\nclass _FakeParent:\n    \"\"\"\n    Fake parent class.\n\n    When we have a fragment with no `BeautifulSoup` document object,\n    we can't evaluate `nth` selectors properly.  Create a temporary\n    fake parent so we can traverse the root element as a child.\n    \"\"\"\n\n    def __init__(self, element: bs4.Tag) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.contents = [element]\n\n    def __len__(self) -> bs4.PageElement:\n        \"\"\"Length.\"\"\"\n\n        return len(self.contents)\n\n\nclass _DocumentNav:\n    \"\"\"Navigate a Beautiful Soup document.\"\"\"\n\n    @classmethod\n    def assert_valid_input(cls, tag: Any) -> None:\n        \"\"\"Check if valid input tag or document.\"\"\"\n\n        # Fail on unexpected types.\n        if not cls.is_tag(tag):\n            raise TypeError(f\"Expected a BeautifulSoup 'Tag', but instead received type {type(tag)}\")\n\n    @staticmethod\n    def is_doc(obj: bs4.Tag) -> bool:\n        \"\"\"Is `BeautifulSoup` object.\"\"\"\n        return isinstance(obj, bs4.BeautifulSoup)\n\n    @staticmethod\n    def is_tag(obj: bs4.PageElement) -> bool:\n        \"\"\"Is tag.\"\"\"\n        return isinstance(obj, bs4.Tag)\n\n    @staticmethod\n    def is_declaration(obj: bs4.PageElement) -> bool:  # pragma: no cover\n        \"\"\"Is declaration.\"\"\"\n        return isinstance(obj, bs4.Declaration)\n\n    @staticmethod\n    def is_cdata(obj: bs4.PageElement) -> bool:\n        \"\"\"Is CDATA.\"\"\"\n        return isinstance(obj, bs4.CData)\n\n    @staticmethod\n    def is_processing_instruction(obj: bs4.PageElement) -> bool:  # pragma: no cover\n        \"\"\"Is processing instruction.\"\"\"\n        return isinstance(obj, bs4.ProcessingInstruction)\n\n    @staticmethod\n    def is_navigable_string(obj: bs4.PageElement) -> bool:\n        \"\"\"Is navigable string.\"\"\"\n        return isinstance(obj, bs4.NavigableString)\n\n    @staticmethod\n    def is_special_string(obj: bs4.PageElement) -> bool:\n        \"\"\"Is special string.\"\"\"\n        return isinstance(obj, (bs4.Comment, bs4.Declaration, bs4.CData, bs4.ProcessingInstruction, bs4.Doctype))\n\n    @classmethod\n    def is_content_string(cls, obj: bs4.PageElement) -> bool:\n        \"\"\"Check if node is content string.\"\"\"\n\n        return cls.is_navigable_string(obj) and not cls.is_special_string(obj)\n\n    @staticmethod\n    def create_fake_parent(el: bs4.Tag) -> _FakeParent:\n        \"\"\"Create fake parent for a given element.\"\"\"\n\n        return _FakeParent(el)\n\n    @staticmethod\n    def is_xml_tree(el: bs4.Tag) -> bool:\n        \"\"\"Check if element (or document) is from a XML tree.\"\"\"\n\n        return bool(el._is_xml)\n\n    def is_iframe(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if element is an `iframe`.\"\"\"\n\n        return bool(\n            ((el.name if self.is_xml_tree(el) else util.lower(el.name)) == 'iframe') and\n            self.is_html_tag(el)  # type: ignore[attr-defined]\n        )\n\n    def is_root(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Return whether element is a root element.\n\n        We check that the element is the root of the tree (which we have already pre-calculated),\n        and we check if it is the root element under an `iframe`.\n        \"\"\"\n\n        root = self.root and self.root is el  # type: ignore[attr-defined]\n        if not root:\n            parent = self.get_parent(el)\n            root = parent is not None and self.is_html and self.is_iframe(parent)  # type: ignore[attr-defined]\n        return root\n\n    def get_contents(self, el: bs4.Tag, no_iframe: bool = False) -> Iterator[bs4.PageElement]:\n        \"\"\"Get contents or contents in reverse.\"\"\"\n        if not no_iframe or not self.is_iframe(el):\n            yield from el.contents\n\n    def get_children(\n        self,\n        el: bs4.Tag,\n        start: int | None = None,\n        reverse: bool = False,\n        tags: bool = True,\n        no_iframe: bool = False\n    ) -> Iterator[bs4.PageElement]:\n        \"\"\"Get children.\"\"\"\n\n        if not no_iframe or not self.is_iframe(el):\n            last = len(el.contents) - 1\n            if start is None:\n                index = last if reverse else 0\n            else:\n                index = start\n            end = -1 if reverse else last + 1\n            incr = -1 if reverse else 1\n\n            if 0 <= index <= last:\n                while index != end:\n                    node = el.contents[index]\n                    index += incr\n                    if not tags or self.is_tag(node):\n                        yield node\n\n    def get_descendants(\n        self,\n        el: bs4.Tag,\n        tags: bool = True,\n        no_iframe: bool = False\n    ) -> Iterator[bs4.PageElement]:\n        \"\"\"Get descendants.\"\"\"\n\n        if not no_iframe or not self.is_iframe(el):\n            next_good = None\n            for child in el.descendants:\n\n                if next_good is not None:\n                    if child is not next_good:\n                        continue\n                    next_good = None\n\n                is_tag = self.is_tag(child)\n\n                if no_iframe and is_tag and self.is_iframe(child):\n                    if child.next_sibling is not None:\n                        next_good = child.next_sibling\n                    else:\n                        last_child = child\n                        while self.is_tag(last_child) and last_child.contents:\n                            last_child = last_child.contents[-1]\n                        next_good = last_child.next_element\n                    yield child\n                    if next_good is None:\n                        break\n                    # Coverage isn't seeing this even though it's executed\n                    continue  # pragma: no cover\n\n                if not tags or is_tag:\n                    yield child\n\n    def get_parent(self, el: bs4.Tag, no_iframe: bool = False) -> bs4.Tag:\n        \"\"\"Get parent.\"\"\"\n\n        parent = el.parent\n        if no_iframe and parent is not None and self.is_iframe(parent):\n            parent = None\n        return parent\n\n    @staticmethod\n    def get_tag_name(el: bs4.Tag) -> str | None:\n        \"\"\"Get tag.\"\"\"\n\n        return cast('str | None', el.name)\n\n    @staticmethod\n    def get_prefix_name(el: bs4.Tag) -> str | None:\n        \"\"\"Get prefix.\"\"\"\n\n        return cast('str | None', el.prefix)\n\n    @staticmethod\n    def get_uri(el: bs4.Tag) -> str | None:\n        \"\"\"Get namespace `URI`.\"\"\"\n\n        return cast('str | None', el.namespace)\n\n    @classmethod\n    def get_next(cls, el: bs4.Tag, tags: bool = True) -> bs4.PageElement:\n        \"\"\"Get next sibling tag.\"\"\"\n\n        sibling = el.next_sibling\n        while tags and not cls.is_tag(sibling) and sibling is not None:\n            sibling = sibling.next_sibling\n        return sibling\n\n    @classmethod\n    def get_previous(cls, el: bs4.Tag, tags: bool = True) -> bs4.PageElement:\n        \"\"\"Get previous sibling tag.\"\"\"\n\n        sibling = el.previous_sibling\n        while tags and not cls.is_tag(sibling) and sibling is not None:\n            sibling = sibling.previous_sibling\n        return sibling\n\n    @staticmethod\n    def has_html_ns(el: bs4.Tag) -> bool:\n        \"\"\"\n        Check if element has an HTML namespace.\n\n        This is a bit different than whether a element is treated as having an HTML namespace,\n        like we do in the case of `is_html_tag`.\n        \"\"\"\n\n        ns = getattr(el, 'namespace') if el else None  # noqa: B009\n        return bool(ns and ns == NS_XHTML)\n\n    @staticmethod\n    def split_namespace(el: bs4.Tag, attr_name: str) -> tuple[str | None, str | None]:\n        \"\"\"Return namespace and attribute name without the prefix.\"\"\"\n\n        return getattr(attr_name, 'namespace', None), getattr(attr_name, 'name', None)\n\n    @classmethod\n    def normalize_value(cls, value: Any) -> str | Sequence[str]:\n        \"\"\"Normalize the value to be a string or list of strings.\"\"\"\n\n        # Treat `None` as empty string.\n        if value is None:\n            return ''\n\n        # Pass through strings\n        if (isinstance(value, str)):\n            return value\n\n        # If it's a byte string, convert it to Unicode, treating it as UTF-8.\n        if isinstance(value, bytes):\n            return value.decode(\"utf8\")\n\n        # BeautifulSoup supports sequences of attribute values, so make sure the children are strings.\n        if isinstance(value, Sequence):\n            new_value = []\n            for v in value:\n                if not isinstance(v, (str, bytes)) and isinstance(v, Sequence):\n                    # This is most certainly a user error and will crash and burn later.\n                    # To keep things working, we'll do what we do with all objects,\n                    # And convert them to strings.\n                    new_value.append(str(v))\n                else:\n                    # Convert the child to a string\n                    new_value.append(cast(str, cls.normalize_value(v)))\n            return new_value\n\n        # Try and make anything else a string\n        return str(value)\n\n    @classmethod\n    def get_attribute_by_name(\n        cls,\n        el: bs4.Tag,\n        name: str,\n        default: str | Sequence[str] | None = None\n    ) -> str | Sequence[str] | None:\n        \"\"\"Get attribute by name.\"\"\"\n\n        value = default\n        if el._is_xml:\n            try:\n                value = cls.normalize_value(el.attrs[name])\n            except KeyError:\n                pass\n        else:\n            for k, v in el.attrs.items():\n                if util.lower(k) == name:\n                    value = cls.normalize_value(v)\n                    break\n        return value\n\n    @classmethod\n    def iter_attributes(cls, el: bs4.Tag) -> Iterator[tuple[str, str | Sequence[str] | None]]:\n        \"\"\"Iterate attributes.\"\"\"\n\n        for k, v in el.attrs.items():\n            yield k, cls.normalize_value(v)\n\n    @classmethod\n    def get_classes(cls, el: bs4.Tag) -> Sequence[str]:\n        \"\"\"Get classes.\"\"\"\n\n        classes = cls.get_attribute_by_name(el, 'class', [])\n        if isinstance(classes, str):\n            classes = RE_NOT_WS.findall(classes)\n        return cast(Sequence[str], classes)\n\n    def get_text(self, el: bs4.Tag, no_iframe: bool = False) -> str:\n        \"\"\"Get text.\"\"\"\n\n        return ''.join(\n            [node for node in self.get_descendants(el, tags=False, no_iframe=no_iframe) if self.is_content_string(node)]\n        )\n\n    def get_own_text(self, el: bs4.Tag, no_iframe: bool = False) -> list[str]:\n        \"\"\"Get Own Text.\"\"\"\n\n        return [node for node in self.get_contents(el, no_iframe=no_iframe) if self.is_content_string(node)]\n\n\nclass Inputs:\n    \"\"\"Class for parsing and validating input items.\"\"\"\n\n    @staticmethod\n    def validate_day(year: int, month: int, day: int) -> bool:\n        \"\"\"Validate day.\"\"\"\n\n        max_days = LONG_MONTH\n        if month == FEB:\n            max_days = FEB_LEAP_MONTH if ((year % 4 == 0) and (year % 100 != 0)) or (year % 400 == 0) else FEB_MONTH\n        elif month in MONTHS_30:\n            max_days = SHORT_MONTH\n        return 1 <= day <= max_days\n\n    @staticmethod\n    def validate_week(year: int, week: int) -> bool:\n        \"\"\"Validate week.\"\"\"\n\n        max_week = datetime.strptime(f\"{12}-{31}-{year}\", \"%m-%d-%Y\").isocalendar()[1]\n        if max_week == 1:\n            max_week = 53\n        return 1 <= week <= max_week\n\n    @staticmethod\n    def validate_month(month: int) -> bool:\n        \"\"\"Validate month.\"\"\"\n\n        return 1 <= month <= 12\n\n    @staticmethod\n    def validate_year(year: int) -> bool:\n        \"\"\"Validate year.\"\"\"\n\n        return 1 <= year\n\n    @staticmethod\n    def validate_hour(hour: int) -> bool:\n        \"\"\"Validate hour.\"\"\"\n\n        return 0 <= hour <= 23\n\n    @staticmethod\n    def validate_minutes(minutes: int) -> bool:\n        \"\"\"Validate minutes.\"\"\"\n\n        return 0 <= minutes <= 59\n\n    @classmethod\n    def parse_value(cls, itype: str, value: str | None) -> tuple[float, ...] | None:\n        \"\"\"Parse the input value.\"\"\"\n\n        parsed = None  # type: tuple[float, ...] | None\n        if value is None:\n            return value\n        if itype == \"date\":\n            m = RE_DATE.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                if cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day):\n                    parsed = (year, month, day)\n        elif itype == \"month\":\n            m = RE_MONTH.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                if cls.validate_year(year) and cls.validate_month(month):\n                    parsed = (year, month)\n        elif itype == \"week\":\n            m = RE_WEEK.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                week = int(m.group('week'), 10)\n                if cls.validate_year(year) and cls.validate_week(year, week):\n                    parsed = (year, week)\n        elif itype == \"time\":\n            m = RE_TIME.match(value)\n            if m:\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if cls.validate_hour(hour) and cls.validate_minutes(minutes):\n                    parsed = (hour, minutes)\n        elif itype == \"datetime-local\":\n            m = RE_DATETIME.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if (\n                    cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day) and\n                    cls.validate_hour(hour) and cls.validate_minutes(minutes)\n                ):\n                    parsed = (year, month, day, hour, minutes)\n        elif itype in (\"number\", \"range\"):\n            m = RE_NUM.match(value)\n            if m:\n                parsed = (float(m.group('value')),)\n        return parsed\n\n\nclass CSSMatch(_DocumentNav):\n    \"\"\"Perform CSS matching.\"\"\"\n\n    def __init__(\n        self,\n        selectors: ct.SelectorList,\n        scope: bs4.Tag,\n        namespaces: ct.Namespaces | None,\n        flags: int\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.assert_valid_input(scope)\n        self.tag = scope\n        self.cached_meta_lang = []  # type: list[tuple[str, str]]\n        self.cached_default_forms = []  # type: list[tuple[bs4.Tag, bs4.Tag]]\n        self.cached_indeterminate_forms = []  # type: list[tuple[bs4.Tag, str, bool]]\n        self.selectors = selectors\n        self.namespaces = {} if namespaces is None else namespaces  # type: ct.Namespaces | dict[str, str]\n        self.flags = flags\n        self.iframe_restrict = False\n\n        # Find the root element for the whole tree\n        doc = scope\n        parent = self.get_parent(doc)\n        while parent:\n            doc = parent\n            parent = self.get_parent(doc)\n        root = None\n        if not self.is_doc(doc):\n            root = doc\n        else:\n            for child in self.get_children(doc):\n                root = child\n                break\n\n        self.root = root\n        self.scope = scope if scope is not doc else root\n        self.has_html_namespace = self.has_html_ns(root)\n\n        # A document can be both XML and HTML (XHTML)\n        self.is_xml = self.is_xml_tree(doc)\n        self.is_html = not self.is_xml or self.has_html_namespace\n\n    def supports_namespaces(self) -> bool:\n        \"\"\"Check if namespaces are supported in the HTML type.\"\"\"\n\n        return self.is_xml or self.has_html_namespace\n\n    def get_tag_ns(self, el: bs4.Tag) -> str:\n        \"\"\"Get tag namespace.\"\"\"\n\n        if self.supports_namespaces():\n            namespace = ''\n            ns = self.get_uri(el)\n            if ns:\n                namespace = ns\n        else:\n            namespace = NS_XHTML\n        return namespace\n\n    def is_html_tag(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if tag is in HTML namespace.\"\"\"\n\n        return self.get_tag_ns(el) == NS_XHTML\n\n    def get_tag(self, el: bs4.Tag) -> str | None:\n        \"\"\"Get tag.\"\"\"\n\n        name = self.get_tag_name(el)\n        return util.lower(name) if name is not None and not self.is_xml else name\n\n    def get_prefix(self, el: bs4.Tag) -> str | None:\n        \"\"\"Get prefix.\"\"\"\n\n        prefix = self.get_prefix_name(el)\n        return util.lower(prefix) if prefix is not None and not self.is_xml else prefix\n\n    def find_bidi(self, el: bs4.Tag) -> int | None:\n        \"\"\"Get directionality from element text.\"\"\"\n\n        for node in self.get_children(el, tags=False):\n\n            # Analyze child text nodes\n            if self.is_tag(node):\n\n                # Avoid analyzing certain elements specified in the specification.\n                direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(node, 'dir', '')), None)\n                if (\n                    self.get_tag(node) in ('bdi', 'script', 'style', 'textarea', 'iframe') or\n                    not self.is_html_tag(node) or\n                    direction is not None\n                ):\n                    continue  # pragma: no cover\n\n                # Check directionality of this node's text\n                value = self.find_bidi(node)\n                if value is not None:\n                    return value\n\n                # Direction could not be determined\n                continue  # pragma: no cover\n\n            # Skip `doctype` comments, etc.\n            if self.is_special_string(node):\n                continue\n\n            # Analyze text nodes for directionality.\n            for c in node:\n                bidi = unicodedata.bidirectional(c)\n                if bidi in ('AL', 'R', 'L'):\n                    return ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n        return None\n\n    def extended_language_filter(self, lang_range: str, lang_tag: str) -> bool:\n        \"\"\"Filter the language tags.\"\"\"\n\n        match = True\n        lang_range = RE_WILD_STRIP.sub('-', lang_range).lower()\n        ranges = lang_range.split('-')\n        subtags = lang_tag.lower().split('-')\n        length = len(ranges)\n        slength = len(subtags)\n        rindex = 0\n        sindex = 0\n        r = ranges[rindex]\n        s = subtags[sindex]\n\n        # Empty specified language should match unspecified language attributes\n        if length == 1 and slength == 1 and not r and r == s:\n            return True\n\n        # Primary tag needs to match\n        if (r != '*' and r != s) or (r == '*' and slength == 1 and not s):\n            match = False\n\n        rindex += 1\n        sindex += 1\n\n        # Match until we run out of ranges\n        while match and rindex < length:\n            r = ranges[rindex]\n            try:\n                s = subtags[sindex]\n            except IndexError:\n                # Ran out of subtags,\n                # but we still have ranges\n                match = False\n                continue\n\n            # Empty range\n            if not r:\n                match = False\n                continue\n\n            # Matched range\n            elif s == r:\n                rindex += 1\n\n            # Implicit wildcard cannot match\n            # singletons\n            elif len(s) == 1:\n                match = False\n                continue\n\n            # Implicitly matched, so grab next subtag\n            sindex += 1\n\n        return match\n\n    def match_attribute_name(\n        self,\n        el: bs4.Tag,\n        attr: str,\n        prefix: str | None\n    ) -> str | Sequence[str] | None:\n        \"\"\"Match attribute name and return value if it exists.\"\"\"\n\n        value = None\n        if self.supports_namespaces():\n            value = None\n            # If we have not defined namespaces, we can't very well find them, so don't bother trying.\n            if prefix:\n                ns = self.namespaces.get(prefix)\n                if ns is None and prefix != '*':\n                    return None\n            else:\n                ns = None\n\n            for k, v in self.iter_attributes(el):\n\n                # Get attribute parts\n                namespace, name = self.split_namespace(el, k)\n\n                # Can't match a prefix attribute as we haven't specified one to match\n                # Try to match it normally as a whole `p:a` as selector may be trying `p\\:a`.\n                if ns is None:\n                    if (self.is_xml and attr == k) or (not self.is_xml and util.lower(attr) == util.lower(k)):\n                        value = v\n                        break\n                    # Coverage is not finding this even though it is executed.\n                    # Adding a print statement before this (and erasing coverage) causes coverage to find the line.\n                    # Ignore the false positive message.\n                    continue  # pragma: no cover\n\n                # We can't match our desired prefix attribute as the attribute doesn't have a prefix\n                if namespace is None or ns != namespace and prefix != '*':\n                    continue\n\n                # The attribute doesn't match.\n                if (util.lower(attr) != util.lower(name)) if not self.is_xml else (attr != name):\n                    continue\n\n                value = v\n                break\n        else:\n            for k, v in self.iter_attributes(el):\n                if util.lower(attr) != util.lower(k):\n                    continue\n                value = v\n                break\n        return value\n\n    def match_namespace(self, el: bs4.Tag, tag: ct.SelectorTag) -> bool:\n        \"\"\"Match the namespace of the element.\"\"\"\n\n        match = True\n        namespace = self.get_tag_ns(el)\n        default_namespace = self.namespaces.get('')\n        tag_ns = '' if tag.prefix is None else self.namespaces.get(tag.prefix)\n        # We must match the default namespace if one is not provided\n        if tag.prefix is None and (default_namespace is not None and namespace != default_namespace):\n            match = False\n        # If we specified `|tag`, we must not have a namespace.\n        elif (tag.prefix is not None and tag.prefix == '' and namespace):\n            match = False\n        # Verify prefix matches\n        elif (\n            tag.prefix and\n            tag.prefix != '*' and (tag_ns is None or namespace != tag_ns)\n        ):\n            match = False\n        return match\n\n    def match_attributes(self, el: bs4.Tag, attributes: tuple[ct.SelectorAttribute, ...]) -> bool:\n        \"\"\"Match attributes.\"\"\"\n\n        match = True\n        if attributes:\n            for a in attributes:\n                temp = self.match_attribute_name(el, a.attribute, a.prefix)\n                pattern = a.xml_type_pattern if self.is_xml and a.xml_type_pattern else a.pattern\n                if temp is None:\n                    match = False\n                    break\n                value = temp if isinstance(temp, str) else ' '.join(temp)\n                if pattern is None:\n                    continue\n                elif pattern.match(value) is None:\n                    match = False\n                    break\n        return match\n\n    def match_tagname(self, el: bs4.Tag, tag: ct.SelectorTag) -> bool:\n        \"\"\"Match tag name.\"\"\"\n\n        name = (util.lower(tag.name) if not self.is_xml and tag.name is not None else tag.name)\n        return not (\n            name is not None and\n            name not in (self.get_tag(el), '*')\n        )\n\n    def match_tag(self, el: bs4.Tag, tag: ct.SelectorTag | None) -> bool:\n        \"\"\"Match the tag.\"\"\"\n\n        match = True\n        if tag is not None:\n            # Verify namespace\n            if not self.match_namespace(el, tag):\n                match = False\n            if not self.match_tagname(el, tag):\n                match = False\n        return match\n\n    def match_past_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match past relationship.\"\"\"\n\n        found = False\n        # I don't think this can ever happen, but it makes `mypy` happy\n        if isinstance(relation[0], ct.SelectorNull):  # pragma: no cover\n            return found\n\n        if relation[0].rel_type == REL_PARENT:\n            parent = self.get_parent(el, no_iframe=self.iframe_restrict)\n            while not found and parent:\n                found = self.match_selectors(parent, relation)\n                parent = self.get_parent(parent, no_iframe=self.iframe_restrict)\n        elif relation[0].rel_type == REL_CLOSE_PARENT:\n            parent = self.get_parent(el, no_iframe=self.iframe_restrict)\n            if parent:\n                found = self.match_selectors(parent, relation)\n        elif relation[0].rel_type == REL_SIBLING:\n            sibling = self.get_previous(el)\n            while not found and sibling:\n                found = self.match_selectors(sibling, relation)\n                sibling = self.get_previous(sibling)\n        elif relation[0].rel_type == REL_CLOSE_SIBLING:\n            sibling = self.get_previous(el)\n            if sibling and self.is_tag(sibling):\n                found = self.match_selectors(sibling, relation)\n        return found\n\n    def match_future_child(self, parent: bs4.Tag, relation: ct.SelectorList, recursive: bool = False) -> bool:\n        \"\"\"Match future child.\"\"\"\n\n        match = False\n        if recursive:\n            children = self.get_descendants  # type: Callable[..., Iterator[bs4.Tag]]\n        else:\n            children = self.get_children\n        for child in children(parent, no_iframe=self.iframe_restrict):\n            match = self.match_selectors(child, relation)\n            if match:\n                break\n        return match\n\n    def match_future_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match future relationship.\"\"\"\n\n        found = False\n        # I don't think this can ever happen, but it makes `mypy` happy\n        if isinstance(relation[0], ct.SelectorNull):  # pragma: no cover\n            return found\n\n        if relation[0].rel_type == REL_HAS_PARENT:\n            found = self.match_future_child(el, relation, True)\n        elif relation[0].rel_type == REL_HAS_CLOSE_PARENT:\n            found = self.match_future_child(el, relation)\n        elif relation[0].rel_type == REL_HAS_SIBLING:\n            sibling = self.get_next(el)\n            while not found and sibling:\n                found = self.match_selectors(sibling, relation)\n                sibling = self.get_next(sibling)\n        elif relation[0].rel_type == REL_HAS_CLOSE_SIBLING:\n            sibling = self.get_next(el)\n            if sibling and self.is_tag(sibling):\n                found = self.match_selectors(sibling, relation)\n        return found\n\n    def match_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match relationship to other elements.\"\"\"\n\n        found = False\n\n        if isinstance(relation[0], ct.SelectorNull) or relation[0].rel_type is None:\n            return found\n\n        if relation[0].rel_type.startswith(':'):\n            found = self.match_future_relations(el, relation)\n        else:\n            found = self.match_past_relations(el, relation)\n\n        return found\n\n    def match_id(self, el: bs4.Tag, ids: tuple[str, ...]) -> bool:\n        \"\"\"Match element's ID.\"\"\"\n\n        found = True\n        for i in ids:\n            if i != self.get_attribute_by_name(el, 'id', ''):\n                found = False\n                break\n        return found\n\n    def match_classes(self, el: bs4.Tag, classes: tuple[str, ...]) -> bool:\n        \"\"\"Match element's classes.\"\"\"\n\n        current_classes = self.get_classes(el)\n        found = True\n        for c in classes:\n            if c not in current_classes:\n                found = False\n                break\n        return found\n\n    def match_root(self, el: bs4.Tag) -> bool:\n        \"\"\"Match element as root.\"\"\"\n\n        is_root = self.is_root(el)\n        if is_root:\n            sibling = self.get_previous(el, tags=False)\n            while is_root and sibling is not None:\n                if (\n                    self.is_tag(sibling) or (self.is_content_string(sibling) and sibling.strip()) or\n                    self.is_cdata(sibling)\n                ):\n                    is_root = False\n                else:\n                    sibling = self.get_previous(sibling, tags=False)\n        if is_root:\n            sibling = self.get_next(el, tags=False)\n            while is_root and sibling is not None:\n                if (\n                    self.is_tag(sibling) or (self.is_content_string(sibling) and sibling.strip()) or\n                    self.is_cdata(sibling)\n                ):\n                    is_root = False\n                else:\n                    sibling = self.get_next(sibling, tags=False)\n        return is_root\n\n    def match_scope(self, el: bs4.Tag) -> bool:\n        \"\"\"Match element as scope.\"\"\"\n\n        return self.scope is el\n\n    def match_nth_tag_type(self, el: bs4.Tag, child: bs4.Tag) -> bool:\n        \"\"\"Match tag type for `nth` matches.\"\"\"\n\n        return (\n            (self.get_tag(child) == self.get_tag(el)) and\n            (self.get_tag_ns(child) == self.get_tag_ns(el))\n        )\n\n    def match_nth(self, el: bs4.Tag, nth: bs4.Tag) -> bool:\n        \"\"\"Match `nth` elements.\"\"\"\n\n        matched = True\n\n        for n in nth:\n            matched = False\n            if n.selectors and not self.match_selectors(el, n.selectors):\n                break\n            parent = self.get_parent(el)\n            if parent is None:\n                parent = self.create_fake_parent(el)\n            last = n.last\n            last_index = len(parent) - 1\n            index = last_index if last else 0\n            relative_index = 0\n            a = n.a\n            b = n.b\n            var = n.n\n            count = 0\n            count_incr = 1\n            factor = -1 if last else 1\n            idx = last_idx = a * count + b if var else a\n\n            # We can only adjust bounds within a variable index\n            if var:\n                # Abort if our nth index is out of bounds and only getting further out of bounds as we increment.\n                # Otherwise, increment to try to get in bounds.\n                adjust = None\n                while idx < 1 or idx > last_index:\n                    if idx < 0:\n                        diff_low = 0 - idx\n                        if adjust is not None and adjust == 1:\n                            break\n                        adjust = -1\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                        diff = 0 - idx\n                        if diff >= diff_low:\n                            break\n                    else:\n                        diff_high = idx - last_index\n                        if adjust is not None and adjust == -1:\n                            break\n                        adjust = 1\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                        diff = idx - last_index\n                        if diff >= diff_high:\n                            break\n                        diff_high = diff\n\n                # If a < 0, our count is working backwards, so floor the index by increasing the count.\n                # Find the count that yields the lowest, in bound value and use that.\n                # Lastly reverse count increment so that we'll increase our index.\n                lowest = count\n                if a < 0:\n                    while idx >= 1:\n                        lowest = count\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                    count_incr = -1\n                count = lowest\n                idx = last_idx = a * count + b if var else a\n\n            # Evaluate elements while our calculated nth index is still in range\n            while 1 <= idx <= last_index + 1:\n                child = None\n                # Evaluate while our child index is still in range.\n                for child in self.get_children(parent, start=index, reverse=factor < 0, tags=False):\n                    index += factor\n                    if not self.is_tag(child):\n                        continue\n                    # Handle `of S` in `nth-child`\n                    if n.selectors and not self.match_selectors(child, n.selectors):\n                        continue\n                    # Handle `of-type`\n                    if n.of_type and not self.match_nth_tag_type(el, child):\n                        continue\n                    relative_index += 1\n                    if relative_index == idx:\n                        if child is el:\n                            matched = True\n                        else:\n                            break\n                    if child is el:\n                        break\n                if child is el:\n                    break\n                last_idx = idx\n                count += count_incr\n                if count < 0:\n                    # Count is counting down and has now ventured into invalid territory.\n                    break\n                idx = a * count + b if var else a\n                if last_idx == idx:\n                    break\n            if not matched:\n                break\n        return matched\n\n    def match_empty(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if element is empty (if requested).\"\"\"\n\n        is_empty = True\n        for child in self.get_children(el, tags=False):\n            if self.is_tag(child):\n                is_empty = False\n                break\n            elif self.is_content_string(child) and RE_NOT_EMPTY.search(child):\n                is_empty = False\n                break\n        return is_empty\n\n    def match_subselectors(self, el: bs4.Tag, selectors: tuple[ct.SelectorList, ...]) -> bool:\n        \"\"\"Match selectors.\"\"\"\n\n        match = True\n        for sel in selectors:\n            if not self.match_selectors(el, sel):\n                match = False\n        return match\n\n    def match_contains(self, el: bs4.Tag, contains: tuple[ct.SelectorContains, ...]) -> bool:\n        \"\"\"Match element if it contains text.\"\"\"\n\n        match = True\n        content = None  # type: str | Sequence[str] | None\n        for contain_list in contains:\n            if content is None:\n                if contain_list.own:\n                    content = self.get_own_text(el, no_iframe=self.is_html)\n                else:\n                    content = self.get_text(el, no_iframe=self.is_html)\n            found = False\n            for text in contain_list.text:\n                if contain_list.own:\n                    for c in content:\n                        if text in c:\n                            found = True\n                            break\n                    if found:\n                        break\n                else:\n                    if text in content:\n                        found = True\n                        break\n            if not found:\n                match = False\n        return match\n\n    def match_default(self, el: bs4.Tag) -> bool:\n        \"\"\"Match default.\"\"\"\n\n        match = False\n\n        # Find this input's form\n        form = None\n        parent = self.get_parent(el, no_iframe=True)\n        while parent and form is None:\n            if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                form = parent\n            else:\n                parent = self.get_parent(parent, no_iframe=True)\n\n        # Look in form cache to see if we've already located its default button\n        found_form = False\n        for f, t in self.cached_default_forms:\n            if f is form:\n                found_form = True\n                if t is el:\n                    match = True\n                break\n\n        # We didn't have the form cached, so look for its default button\n        if not found_form:\n            for child in self.get_descendants(form, no_iframe=True):\n                name = self.get_tag(child)\n                # Can't do nested forms (haven't figured out why we never hit this)\n                if name == 'form':  # pragma: no cover\n                    break\n                if name in ('input', 'button'):\n                    v = self.get_attribute_by_name(child, 'type', '')\n                    if v and util.lower(v) == 'submit':\n                        self.cached_default_forms.append((form, child))\n                        if el is child:\n                            match = True\n                        break\n        return match\n\n    def match_indeterminate(self, el: bs4.Tag) -> bool:\n        \"\"\"Match default.\"\"\"\n\n        match = False\n        name = cast(str, self.get_attribute_by_name(el, 'name'))\n\n        def get_parent_form(el: bs4.Tag) -> bs4.Tag | None:\n            \"\"\"Find this input's form.\"\"\"\n            form = None\n            parent = self.get_parent(el, no_iframe=True)\n            while form is None:\n                if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                    form = parent\n                    break\n                last_parent = parent\n                parent = self.get_parent(parent, no_iframe=True)\n                if parent is None:\n                    form = last_parent\n                    break\n            return form\n\n        form = get_parent_form(el)\n\n        # Look in form cache to see if we've already evaluated that its fellow radio buttons are indeterminate\n        found_form = False\n        for f, n, i in self.cached_indeterminate_forms:\n            if f is form and n == name:\n                found_form = True\n                if i is True:\n                    match = True\n                break\n\n        # We didn't have the form cached, so validate that the radio button is indeterminate\n        if not found_form:\n            checked = False\n            for child in self.get_descendants(form, no_iframe=True):\n                if child is el:\n                    continue\n                tag_name = self.get_tag(child)\n                if tag_name == 'input':\n                    is_radio = False\n                    check = False\n                    has_name = False\n                    for k, v in self.iter_attributes(child):\n                        if util.lower(k) == 'type' and util.lower(v) == 'radio':\n                            is_radio = True\n                        elif util.lower(k) == 'name' and v == name:\n                            has_name = True\n                        elif util.lower(k) == 'checked':\n                            check = True\n                        if is_radio and check and has_name and get_parent_form(child) is form:\n                            checked = True\n                            break\n                if checked:\n                    break\n            if not checked:\n                match = True\n            self.cached_indeterminate_forms.append((form, name, match))\n\n        return match\n\n    def match_lang(self, el: bs4.Tag, langs: tuple[ct.SelectorLang, ...]) -> bool:\n        \"\"\"Match languages.\"\"\"\n\n        match = False\n        has_ns = self.supports_namespaces()\n        root = self.root\n        has_html_namespace = self.has_html_namespace\n\n        # Walk parents looking for `lang` (HTML) or `xml:lang` XML property.\n        parent = el\n        found_lang = None\n        last = None\n        while not found_lang:\n            has_html_ns = self.has_html_ns(parent)\n            for k, v in self.iter_attributes(parent):\n                attr_ns, attr = self.split_namespace(parent, k)\n                if (\n                    ((not has_ns or has_html_ns) and (util.lower(k) if not self.is_xml else k) == 'lang') or\n                    (\n                        has_ns and not has_html_ns and attr_ns == NS_XML and\n                        (util.lower(attr) if not self.is_xml and attr is not None else attr) == 'lang'\n                    )\n                ):\n                    found_lang = v\n                    break\n            last = parent\n            parent = self.get_parent(parent, no_iframe=self.is_html)\n\n            if parent is None:\n                root = last\n                has_html_namespace = self.has_html_ns(root)\n                parent = last\n                break\n\n        # Use cached meta language.\n        if found_lang is None and self.cached_meta_lang:\n            for cache in self.cached_meta_lang:\n                if root is cache[0]:\n                    found_lang = cache[1]\n\n        # If we couldn't find a language, and the document is HTML, look to meta to determine language.\n        if found_lang is None and (not self.is_xml or (has_html_namespace and root.name == 'html')):\n            # Find head\n            found = False\n            for tag in ('html', 'head'):\n                found = False\n                for child in self.get_children(parent, no_iframe=self.is_html):\n                    if self.get_tag(child) == tag and self.is_html_tag(child):\n                        found = True\n                        parent = child\n                        break\n                if not found:  # pragma: no cover\n                    break\n\n            # Search meta tags\n            if found:\n                for child in parent:\n                    if self.is_tag(child) and self.get_tag(child) == 'meta' and self.is_html_tag(parent):\n                        c_lang = False\n                        content = None\n                        for k, v in self.iter_attributes(child):\n                            if util.lower(k) == 'http-equiv' and util.lower(v) == 'content-language':\n                                c_lang = True\n                            if util.lower(k) == 'content':\n                                content = v\n                            if c_lang and content:\n                                found_lang = content\n                                self.cached_meta_lang.append((cast(str, root), cast(str, found_lang)))\n                                break\n                    if found_lang is not None:\n                        break\n                if found_lang is None:\n                    self.cached_meta_lang.append((cast(str, root), ''))\n\n        # If we determined a language, compare.\n        if found_lang is not None:\n            for patterns in langs:\n                match = False\n                for pattern in patterns:\n                    if self.extended_language_filter(pattern, cast(str, found_lang)):\n                        match = True\n                if not match:\n                    break\n\n        return match\n\n    def match_dir(self, el: bs4.Tag, directionality: int) -> bool:\n        \"\"\"Check directionality.\"\"\"\n\n        # If we have to match both left and right, we can't match either.\n        if directionality & ct.SEL_DIR_LTR and directionality & ct.SEL_DIR_RTL:\n            return False\n\n        if el is None or not self.is_html_tag(el):\n            return False\n\n        # Element has defined direction of left to right or right to left\n        direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(el, 'dir', '')), None)\n        if direction not in (None, 0):\n            return direction == directionality\n\n        # Element is the document element (the root) and no direction assigned, assume left to right.\n        is_root = self.is_root(el)\n        if is_root and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # If `input[type=telephone]` and no direction is assigned, assume left to right.\n        name = self.get_tag(el)\n        is_input = name == 'input'\n        is_textarea = name == 'textarea'\n        is_bdi = name == 'bdi'\n        itype = util.lower(self.get_attribute_by_name(el, 'type', '')) if is_input else ''\n        if is_input and itype == 'tel' and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # Auto handling for text inputs\n        if ((is_input and itype in ('text', 'search', 'tel', 'url', 'email')) or is_textarea) and direction == 0:\n            if is_textarea:\n                value = ''.join(node for node in self.get_contents(el, no_iframe=True) if self.is_content_string(node))\n            else:\n                value = cast(str, self.get_attribute_by_name(el, 'value', ''))\n            if value:\n                for c in value:\n                    bidi = unicodedata.bidirectional(c)\n                    if bidi in ('AL', 'R', 'L'):\n                        direction = ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n                        return direction == directionality\n                # Assume left to right\n                return ct.SEL_DIR_LTR == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Auto handling for `bdi` and other non text inputs.\n        if (is_bdi and direction is None) or direction == 0:\n            direction = self.find_bidi(el)\n            if direction is not None:\n                return direction == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Match parents direction\n        return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n    def match_range(self, el: bs4.Tag, condition: int) -> bool:\n        \"\"\"\n        Match range.\n\n        Behavior is modeled after what we see in browsers. Browsers seem to evaluate\n        if the value is out of range, and if not, it is in range. So a missing value\n        will not evaluate out of range; therefore, value is in range. Personally, I\n        feel like this should evaluate as neither in or out of range.\n        \"\"\"\n\n        out_of_range = False\n\n        itype = util.lower(self.get_attribute_by_name(el, 'type'))\n        mn = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'min', None)))\n        mx = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'max', None)))\n\n        # There is no valid min or max, so we cannot evaluate a range\n        if mn is None and mx is None:\n            return False\n\n        value = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'value', None)))\n        if value is not None:\n            if itype in (\"date\", \"datetime-local\", \"month\", \"week\", \"number\", \"range\"):\n                if mn is not None and value < mn:\n                    out_of_range = True\n                if not out_of_range and mx is not None and value > mx:\n                    out_of_range = True\n            elif itype == \"time\":\n                if mn is not None and mx is not None and mn > mx:\n                    # Time is periodic, so this is a reversed/discontinuous range\n                    if value < mn and value > mx:\n                        out_of_range = True\n                else:\n                    if mn is not None and value < mn:\n                        out_of_range = True\n                    if not out_of_range and mx is not None and value > mx:\n                        out_of_range = True\n\n        return not out_of_range if condition & ct.SEL_IN_RANGE else out_of_range\n\n    def match_defined(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Match defined.\n\n        `:defined` is related to custom elements in a browser.\n\n        - If the document is XML (not XHTML), all tags will match.\n        - Tags that are not custom (don't have a hyphen) are marked defined.\n        - If the tag has a prefix (without or without a namespace), it will not match.\n\n        This is of course requires the parser to provide us with the proper prefix and namespace info,\n        if it doesn't, there is nothing we can do.\n        \"\"\"\n\n        name = self.get_tag(el)\n        return (\n            name is not None and (\n                name.find('-') == -1 or\n                name.find(':') != -1 or\n                self.get_prefix(el) is not None\n            )\n        )\n\n    def match_placeholder_shown(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Match placeholder shown according to HTML spec.\n\n        - text area should be checked if they have content. A single newline does not count as content.\n\n        \"\"\"\n\n        match = False\n        content = self.get_text(el)\n        if content in ('', '\\n'):\n            match = True\n\n        return match\n\n    def match_selectors(self, el: bs4.Tag, selectors: ct.SelectorList) -> bool:\n        \"\"\"Check if element matches one of the selectors.\"\"\"\n\n        match = False\n        is_not = selectors.is_not\n        is_html = selectors.is_html\n\n        # Internal selector lists that use the HTML flag, will automatically get the `html` namespace.\n        if is_html:\n            namespaces = self.namespaces\n            iframe_restrict = self.iframe_restrict\n            self.namespaces = {'html': NS_XHTML}\n            self.iframe_restrict = True\n\n        if not is_html or self.is_html:\n            for selector in selectors:\n                match = is_not\n                # We have a un-matchable situation (like `:focus` as you can focus an element in this environment)\n                if isinstance(selector, ct.SelectorNull):\n                    continue\n                # Verify tag matches\n                if not self.match_tag(el, selector.tag):\n                    continue\n                # Verify tag is defined\n                if selector.flags & ct.SEL_DEFINED and not self.match_defined(el):\n                    continue\n                # Verify element is root\n                if selector.flags & ct.SEL_ROOT and not self.match_root(el):\n                    continue\n                # Verify element is scope\n                if selector.flags & ct.SEL_SCOPE and not self.match_scope(el):\n                    continue\n                # Verify element has placeholder shown\n                if selector.flags & ct.SEL_PLACEHOLDER_SHOWN and not self.match_placeholder_shown(el):\n                    continue\n                # Verify `nth` matches\n                if not self.match_nth(el, selector.nth):\n                    continue\n                if selector.flags & ct.SEL_EMPTY and not self.match_empty(el):\n                    continue\n                # Verify id matches\n                if selector.ids and not self.match_id(el, selector.ids):\n                    continue\n                # Verify classes match\n                if selector.classes and not self.match_classes(el, selector.classes):\n                    continue\n                # Verify attribute(s) match\n                if not self.match_attributes(el, selector.attributes):\n                    continue\n                # Verify ranges\n                if selector.flags & RANGES and not self.match_range(el, selector.flags & RANGES):\n                    continue\n                # Verify language patterns\n                if selector.lang and not self.match_lang(el, selector.lang):\n                    continue\n                # Verify pseudo selector patterns\n                if selector.selectors and not self.match_subselectors(el, selector.selectors):\n                    continue\n                # Verify relationship selectors\n                if selector.relation and not self.match_relations(el, selector.relation):\n                    continue\n                # Validate that the current default selector match corresponds to the first submit button in the form\n                if selector.flags & ct.SEL_DEFAULT and not self.match_default(el):\n                    continue\n                # Validate that the unset radio button is among radio buttons with the same name in a form that are\n                # also not set.\n                if selector.flags & ct.SEL_INDETERMINATE and not self.match_indeterminate(el):\n                    continue\n                # Validate element directionality\n                if selector.flags & DIR_FLAGS and not self.match_dir(el, selector.flags & DIR_FLAGS):\n                    continue\n                # Validate that the tag contains the specified text.\n                if selector.contains and not self.match_contains(el, selector.contains):\n                    continue\n                match = not is_not\n                break\n\n        # Restore actual namespaces being used for external selector lists\n        if is_html:\n            self.namespaces = namespaces\n            self.iframe_restrict = iframe_restrict\n\n        return match\n\n    def select(self, limit: int = 0) -> Iterator[bs4.Tag]:\n        \"\"\"Match all tags under the targeted tag.\"\"\"\n\n        lim = None if limit < 1 else limit\n\n        for child in self.get_descendants(self.tag):\n            if self.match(child):\n                yield child\n                if lim is not None:\n                    lim -= 1\n                    if lim < 1:\n                        break\n\n    def closest(self) -> bs4.Tag | None:\n        \"\"\"Match closest ancestor.\"\"\"\n\n        current = self.tag\n        closest = None\n        while closest is None and current is not None:\n            if self.match(current):\n                closest = current\n            else:\n                current = self.get_parent(current)\n        return closest\n\n    def filter(self) -> list[bs4.Tag]:  # noqa A001\n        \"\"\"Filter tag's children.\"\"\"\n\n        return [tag for tag in self.get_contents(self.tag) if not self.is_navigable_string(tag) and self.match(tag)]\n\n    def match(self, el: bs4.Tag) -> bool:\n        \"\"\"Match.\"\"\"\n\n        return not self.is_doc(el) and self.is_tag(el) and self.match_selectors(el, self.selectors)\n\n\nclass SoupSieve(ct.Immutable):\n    \"\"\"Compiled Soup Sieve selector matching object.\"\"\"\n\n    pattern: str\n    selectors: ct.SelectorList\n    namespaces: ct.Namespaces | None\n    custom: dict[str, str]\n    flags: int\n\n    __slots__ = (\"pattern\", \"selectors\", \"namespaces\", \"custom\", \"flags\", \"_hash\")\n\n    def __init__(\n        self,\n        pattern: str,\n        selectors: ct.SelectorList,\n        namespaces: ct.Namespaces | None,\n        custom: ct.CustomSelectors | None,\n        flags: int\n    ):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            pattern=pattern,\n            selectors=selectors,\n            namespaces=namespaces,\n            custom=custom,\n            flags=flags\n        )\n\n    def match(self, tag: bs4.Tag) -> bool:\n        \"\"\"Match.\"\"\"\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).match(tag)\n\n    def closest(self, tag: bs4.Tag) -> bs4.Tag:\n        \"\"\"Match closest ancestor.\"\"\"\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).closest()\n\n    def filter(self, iterable: Iterable[bs4.Tag]) -> list[bs4.Tag]:  # noqa A001\n        \"\"\"\n        Filter.\n\n        `CSSMatch` can cache certain searches for tags of the same document,\n        so if we are given a tag, all tags are from the same document,\n        and we can take advantage of the optimization.\n\n        Any other kind of iterable could have tags from different documents or detached tags,\n        so for those, we use a new `CSSMatch` for each item in the iterable.\n        \"\"\"\n\n        if CSSMatch.is_tag(iterable):\n            return CSSMatch(self.selectors, iterable, self.namespaces, self.flags).filter()\n        else:\n            return [node for node in iterable if not CSSMatch.is_navigable_string(node) and self.match(node)]\n\n    def select_one(self, tag: bs4.Tag) -> bs4.Tag:\n        \"\"\"Select a single tag.\"\"\"\n\n        tags = self.select(tag, limit=1)\n        return tags[0] if tags else None\n\n    def select(self, tag: bs4.Tag, limit: int = 0) -> list[bs4.Tag]:\n        \"\"\"Select the specified tags.\"\"\"\n\n        return list(self.iselect(tag, limit))\n\n    def iselect(self, tag: bs4.Tag, limit: int = 0) -> Iterator[bs4.Tag]:\n        \"\"\"Iterate the specified tags.\"\"\"\n\n        yield from CSSMatch(self.selectors, tag, self.namespaces, self.flags).select(limit)\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        return (\n            f\"SoupSieve(pattern={self.pattern!r}, namespaces={self.namespaces!r}, \"\n            f\"custom={self.custom!r}, flags={self.flags!r})\"\n        )\n\n    __str__ = __repr__\n\n\nct.pickle_register(SoupSieve)\n", "soupsieve/css_types.py": "\"\"\"CSS selector structure items.\"\"\"\nfrom __future__ import annotations\nimport copyreg\nfrom .pretty import pretty\nfrom typing import Any, Iterator, Hashable, Pattern, Iterable, Mapping\n\n__all__ = (\n    'Selector',\n    'SelectorNull',\n    'SelectorTag',\n    'SelectorAttribute',\n    'SelectorContains',\n    'SelectorNth',\n    'SelectorLang',\n    'SelectorList',\n    'Namespaces',\n    'CustomSelectors'\n)\n\n\nSEL_EMPTY = 0x1\nSEL_ROOT = 0x2\nSEL_DEFAULT = 0x4\nSEL_INDETERMINATE = 0x8\nSEL_SCOPE = 0x10\nSEL_DIR_LTR = 0x20\nSEL_DIR_RTL = 0x40\nSEL_IN_RANGE = 0x80\nSEL_OUT_OF_RANGE = 0x100\nSEL_DEFINED = 0x200\nSEL_PLACEHOLDER_SHOWN = 0x400\n\n\nclass Immutable:\n    \"\"\"Immutable.\"\"\"\n\n    __slots__: tuple[str, ...] = ('_hash',)\n\n    _hash: int\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        temp = []\n        for k, v in kwargs.items():\n            temp.append(type(v))\n            temp.append(v)\n            super().__setattr__(k, v)\n        super().__setattr__('_hash', hash(tuple(temp)))\n\n    @classmethod\n    def __base__(cls) -> type[Immutable]:\n        \"\"\"Get base class.\"\"\"\n\n        return cls\n\n    def __eq__(self, other: Any) -> bool:\n        \"\"\"Equal.\"\"\"\n\n        return (\n            isinstance(other, self.__base__()) and\n            all(getattr(other, key) == getattr(self, key) for key in self.__slots__ if key != '_hash')\n        )\n\n    def __ne__(self, other: Any) -> bool:\n        \"\"\"Equal.\"\"\"\n\n        return (\n            not isinstance(other, self.__base__()) or\n            any(getattr(other, key) != getattr(self, key) for key in self.__slots__ if key != '_hash')\n        )\n\n    def __hash__(self) -> int:\n        \"\"\"Hash.\"\"\"\n\n        return self._hash\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        \"\"\"Prevent mutability.\"\"\"\n\n        raise AttributeError(f\"'{self.__class__.__name__}' is immutable\")\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        r = ', '.join([f\"{k}={getattr(self, k)!r}\" for k in self.__slots__[:-1]])\n        return f\"{self.__class__.__name__}({r})\"\n\n    __str__ = __repr__\n\n    def pretty(self) -> None:  # pragma: no cover\n        \"\"\"Pretty print.\"\"\"\n\n        print(pretty(self))\n\n\nclass ImmutableDict(Mapping[Any, Any]):\n    \"\"\"Hashable, immutable dictionary.\"\"\"\n\n    def __init__(\n        self,\n        arg: dict[Any, Any] | Iterable[tuple[Any, Any]]\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self._validate(arg)\n        self._d = dict(arg)\n        self._hash = hash(tuple([(type(x), x, type(y), y) for x, y in sorted(self._d.items())]))\n\n    def _validate(self, arg: dict[Any, Any] | Iterable[tuple[Any, Any]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, Hashable) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, Hashable) and isinstance(v, Hashable) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} values must be hashable')\n\n    def __iter__(self) -> Iterator[Any]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self._d)\n\n    def __len__(self) -> int:\n        \"\"\"Length.\"\"\"\n\n        return len(self._d)\n\n    def __getitem__(self, key: Any) -> Any:\n        \"\"\"Get item: `namespace['key']`.\"\"\"\n\n        return self._d[key]\n\n    def __hash__(self) -> int:\n        \"\"\"Hash.\"\"\"\n\n        return self._hash\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        return f\"{self._d!r}\"\n\n    __str__ = __repr__\n\n\nclass Namespaces(ImmutableDict):\n    \"\"\"Namespaces.\"\"\"\n\n    def __init__(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(arg)\n\n    def _validate(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, str) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, str) and isinstance(v, str) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} keys and values must be Unicode strings')\n\n\nclass CustomSelectors(ImmutableDict):\n    \"\"\"Custom selectors.\"\"\"\n\n    def __init__(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(arg)\n\n    def _validate(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, str) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, str) and isinstance(v, str) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} keys and values must be Unicode strings')\n\n\nclass Selector(Immutable):\n    \"\"\"Selector.\"\"\"\n\n    __slots__ = (\n        'tag', 'ids', 'classes', 'attributes', 'nth', 'selectors',\n        'relation', 'rel_type', 'contains', 'lang', 'flags', '_hash'\n    )\n\n    tag: SelectorTag | None\n    ids: tuple[str, ...]\n    classes: tuple[str, ...]\n    attributes: tuple[SelectorAttribute, ...]\n    nth: tuple[SelectorNth, ...]\n    selectors: tuple[SelectorList, ...]\n    relation: SelectorList\n    rel_type: str | None\n    contains: tuple[SelectorContains, ...]\n    lang: tuple[SelectorLang, ...]\n    flags: int\n\n    def __init__(\n        self,\n        tag: SelectorTag | None,\n        ids: tuple[str, ...],\n        classes: tuple[str, ...],\n        attributes: tuple[SelectorAttribute, ...],\n        nth: tuple[SelectorNth, ...],\n        selectors: tuple[SelectorList, ...],\n        relation: SelectorList,\n        rel_type: str | None,\n        contains: tuple[SelectorContains, ...],\n        lang: tuple[SelectorLang, ...],\n        flags: int\n    ):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            tag=tag,\n            ids=ids,\n            classes=classes,\n            attributes=attributes,\n            nth=nth,\n            selectors=selectors,\n            relation=relation,\n            rel_type=rel_type,\n            contains=contains,\n            lang=lang,\n            flags=flags\n        )\n\n\nclass SelectorNull(Immutable):\n    \"\"\"Null Selector.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__()\n\n\nclass SelectorTag(Immutable):\n    \"\"\"Selector tag.\"\"\"\n\n    __slots__ = (\"name\", \"prefix\", \"_hash\")\n\n    name: str\n    prefix: str | None\n\n    def __init__(self, name: str, prefix: str | None) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(name=name, prefix=prefix)\n\n\nclass SelectorAttribute(Immutable):\n    \"\"\"Selector attribute rule.\"\"\"\n\n    __slots__ = (\"attribute\", \"prefix\", \"pattern\", \"xml_type_pattern\", \"_hash\")\n\n    attribute: str\n    prefix: str\n    pattern: Pattern[str] | None\n    xml_type_pattern: Pattern[str] | None\n\n    def __init__(\n        self,\n        attribute: str,\n        prefix: str,\n        pattern: Pattern[str] | None,\n        xml_type_pattern: Pattern[str] | None\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            attribute=attribute,\n            prefix=prefix,\n            pattern=pattern,\n            xml_type_pattern=xml_type_pattern\n        )\n\n\nclass SelectorContains(Immutable):\n    \"\"\"Selector contains rule.\"\"\"\n\n    __slots__ = (\"text\", \"own\", \"_hash\")\n\n    text: tuple[str, ...]\n    own: bool\n\n    def __init__(self, text: Iterable[str], own: bool) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(text=tuple(text), own=own)\n\n\nclass SelectorNth(Immutable):\n    \"\"\"Selector nth type.\"\"\"\n\n    __slots__ = (\"a\", \"n\", \"b\", \"of_type\", \"last\", \"selectors\", \"_hash\")\n\n    a: int\n    n: bool\n    b: int\n    of_type: bool\n    last: bool\n    selectors: SelectorList\n\n    def __init__(self, a: int, n: bool, b: int, of_type: bool, last: bool, selectors: SelectorList) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            a=a,\n            n=n,\n            b=b,\n            of_type=of_type,\n            last=last,\n            selectors=selectors\n        )\n\n\nclass SelectorLang(Immutable):\n    \"\"\"Selector language rules.\"\"\"\n\n    __slots__ = (\"languages\", \"_hash\",)\n\n    languages: tuple[str, ...]\n\n    def __init__(self, languages: Iterable[str]):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(languages=tuple(languages))\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self.languages)\n\n    def __len__(self) -> int:  # pragma: no cover\n        \"\"\"Length.\"\"\"\n\n        return len(self.languages)\n\n    def __getitem__(self, index: int) -> str:  # pragma: no cover\n        \"\"\"Get item.\"\"\"\n\n        return self.languages[index]\n\n\nclass SelectorList(Immutable):\n    \"\"\"Selector list.\"\"\"\n\n    __slots__ = (\"selectors\", \"is_not\", \"is_html\", \"_hash\")\n\n    selectors: tuple[Selector | SelectorNull, ...]\n    is_not: bool\n    is_html: bool\n\n    def __init__(\n        self,\n        selectors: Iterable[Selector | SelectorNull] | None = None,\n        is_not: bool = False,\n        is_html: bool = False\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            selectors=tuple(selectors) if selectors is not None else (),\n            is_not=is_not,\n            is_html=is_html\n        )\n\n    def __iter__(self) -> Iterator[Selector | SelectorNull]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self.selectors)\n\n    def __len__(self) -> int:\n        \"\"\"Length.\"\"\"\n\n        return len(self.selectors)\n\n    def __getitem__(self, index: int) -> Selector | SelectorNull:\n        \"\"\"Get item.\"\"\"\n\n        return self.selectors[index]\n\n\ndef _pickle(p: Any) -> Any:\n    return p.__base__(), tuple([getattr(p, s) for s in p.__slots__[:-1]])\n\n\ndef pickle_register(obj: Any) -> None:\n    \"\"\"Allow object to be pickled.\"\"\"\n\n    copyreg.pickle(obj, _pickle)\n\n\npickle_register(Selector)\npickle_register(SelectorNull)\npickle_register(SelectorTag)\npickle_register(SelectorAttribute)\npickle_register(SelectorContains)\npickle_register(SelectorNth)\npickle_register(SelectorLang)\npickle_register(SelectorList)\n", "soupsieve/css_parser.py": "\"\"\"CSS selector parser.\"\"\"\nfrom __future__ import annotations\nimport re\nfrom functools import lru_cache\nfrom . import util\nfrom . import css_match as cm\nfrom . import css_types as ct\nfrom .util import SelectorSyntaxError\nimport warnings\nfrom typing import Match, Any, Iterator, cast\n\nUNICODE_REPLACEMENT_CHAR = 0xFFFD\n\n# Simple pseudo classes that take no parameters\nPSEUDO_SIMPLE = {\n    \":any-link\",\n    \":empty\",\n    \":first-child\",\n    \":first-of-type\",\n    \":in-range\",\n    \":out-of-range\",\n    \":last-child\",\n    \":last-of-type\",\n    \":link\",\n    \":only-child\",\n    \":only-of-type\",\n    \":root\",\n    ':checked',\n    ':default',\n    ':disabled',\n    ':enabled',\n    ':indeterminate',\n    ':optional',\n    ':placeholder-shown',\n    ':read-only',\n    ':read-write',\n    ':required',\n    ':scope',\n    ':defined'\n}\n\n# Supported, simple pseudo classes that match nothing in the Soup Sieve environment\nPSEUDO_SIMPLE_NO_MATCH = {\n    ':active',\n    ':current',\n    ':focus',\n    ':focus-visible',\n    ':focus-within',\n    ':future',\n    ':host',\n    ':hover',\n    ':local-link',\n    ':past',\n    ':paused',\n    ':playing',\n    ':target',\n    ':target-within',\n    ':user-invalid',\n    ':visited'\n}\n\n# Complex pseudo classes that take selector lists\nPSEUDO_COMPLEX = {\n    ':contains',\n    ':-soup-contains',\n    ':-soup-contains-own',\n    ':has',\n    ':is',\n    ':matches',\n    ':not',\n    ':where'\n}\n\nPSEUDO_COMPLEX_NO_MATCH = {\n    ':current',\n    ':host',\n    ':host-context'\n}\n\n# Complex pseudo classes that take very specific parameters and are handled special\nPSEUDO_SPECIAL = {\n    ':dir',\n    ':lang',\n    ':nth-child',\n    ':nth-last-child',\n    ':nth-last-of-type',\n    ':nth-of-type'\n}\n\nPSEUDO_SUPPORTED = PSEUDO_SIMPLE | PSEUDO_SIMPLE_NO_MATCH | PSEUDO_COMPLEX | PSEUDO_COMPLEX_NO_MATCH | PSEUDO_SPECIAL\n\n# Sub-patterns parts\n# Whitespace\nNEWLINE = r'(?:\\r\\n|(?!\\r\\n)[\\n\\f\\r])'\nWS = fr'(?:[ \\t]|{NEWLINE})'\n# Comments\nCOMMENTS = r'(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)'\n# Whitespace with comments included\nWSC = fr'(?:{WS}|{COMMENTS})'\n# CSS escapes\nCSS_ESCAPES = fr'(?:\\\\(?:[a-f0-9]{{1,6}}{WS}?|[^\\r\\n\\f]|$))'\nCSS_STRING_ESCAPES = fr'(?:\\\\(?:[a-f0-9]{{1,6}}{WS}?|[^\\r\\n\\f]|$|{NEWLINE}))'\n# CSS Identifier\nIDENTIFIER = fr'''\n(?:(?:-?(?:[^\\x00-\\x2f\\x30-\\x40\\x5B-\\x5E\\x60\\x7B-\\x9f]|{CSS_ESCAPES})+|--)\n(?:[^\\x00-\\x2c\\x2e\\x2f\\x3A-\\x40\\x5B-\\x5E\\x60\\x7B-\\x9f]|{CSS_ESCAPES})*)\n'''\n# `nth` content\nNTH = fr'(?:[-+])?(?:[0-9]+n?|n)(?:(?<=n){WSC}*(?:[-+]){WSC}*(?:[0-9]+))?'\n# Value: quoted string or identifier\nVALUE = fr'''(?:\"(?:\\\\(?:.|{NEWLINE})|[^\\\\\"\\r\\n\\f]+)*?\"|'(?:\\\\(?:.|{NEWLINE})|[^\\\\'\\r\\n\\f]+)*?'|{IDENTIFIER}+)'''\n# Attribute value comparison. `!=` is handled special as it is non-standard.\nATTR = fr'(?:{WSC}*(?P<cmp>[!~^|*$]?=){WSC}*(?P<value>{VALUE})(?:{WSC}*(?P<case>[is]))?)?{WSC}*\\]'\n\n# Selector patterns\n# IDs (`#id`)\nPAT_ID = fr'\\#{IDENTIFIER}'\n# Classes (`.class`)\nPAT_CLASS = fr'\\.{IDENTIFIER}'\n# Prefix:Tag (`prefix|tag`)\nPAT_TAG = fr'(?P<tag_ns>(?:{IDENTIFIER}|\\*)?\\|)?(?P<tag_name>{IDENTIFIER}|\\*)'\n# Attributes (`[attr]`, `[attr=value]`, etc.)\nPAT_ATTR = fr'\\[{WSC}*(?P<attr_ns>(?:{IDENTIFIER}|\\*)?\\|)?(?P<attr_name>{IDENTIFIER}){ATTR}'\n# Pseudo class (`:pseudo-class`, `:pseudo-class(`)\nPAT_PSEUDO_CLASS = fr'(?P<name>:{IDENTIFIER})(?P<open>\\({WSC}*)?'\n# Pseudo class special patterns. Matches `:pseudo-class(` for special case pseudo classes.\nPAT_PSEUDO_CLASS_SPECIAL = fr'(?P<name>:{IDENTIFIER})(?P<open>\\({WSC}*)'\n# Custom pseudo class (`:--custom-pseudo`)\nPAT_PSEUDO_CLASS_CUSTOM = fr'(?P<name>:(?=--){IDENTIFIER})'\n# Closing pseudo group (`)`)\nPAT_PSEUDO_CLOSE = fr'{WSC}*\\)'\n# Pseudo element (`::pseudo-element`)\nPAT_PSEUDO_ELEMENT = fr':{PAT_PSEUDO_CLASS}'\n# At rule (`@page`, etc.) (not supported)\nPAT_AT_RULE = fr'@P{IDENTIFIER}'\n# Pseudo class `nth-child` (`:nth-child(an+b [of S]?)`, `:first-child`, etc.)\nPAT_PSEUDO_NTH_CHILD = fr'''\n(?P<pseudo_nth_child>{PAT_PSEUDO_CLASS_SPECIAL}\n(?P<nth_child>{NTH}|even|odd))(?:{WSC}*\\)|(?P<of>{COMMENTS}*{WS}{WSC}*of{COMMENTS}*{WS}{WSC}*))\n'''\n# Pseudo class `nth-of-type` (`:nth-of-type(an+b)`, `:first-of-type`, etc.)\nPAT_PSEUDO_NTH_TYPE = fr'''\n(?P<pseudo_nth_type>{PAT_PSEUDO_CLASS_SPECIAL}\n(?P<nth_type>{NTH}|even|odd)){WSC}*\\)\n'''\n# Pseudo class language (`:lang(\"*-de\", en)`)\nPAT_PSEUDO_LANG = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<values>{VALUE}(?:{WSC}*,{WSC}*{VALUE})*){WSC}*\\)'\n# Pseudo class direction (`:dir(ltr)`)\nPAT_PSEUDO_DIR = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<dir>ltr|rtl){WSC}*\\)'\n# Combining characters (`>`, `~`, ` `, `+`, `,`)\nPAT_COMBINE = fr'{WSC}*?(?P<relation>[,+>~]|{WS}(?![,+>~])){WSC}*'\n# Extra: Contains (`:contains(text)`)\nPAT_PSEUDO_CONTAINS = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<values>{VALUE}(?:{WSC}*,{WSC}*{VALUE})*){WSC}*\\)'\n\n# Regular expressions\n# CSS escape pattern\nRE_CSS_ESC = re.compile(fr'(?:(\\\\[a-f0-9]{{1,6}}{WSC}?)|(\\\\[^\\r\\n\\f])|(\\\\$))', re.I)\nRE_CSS_STR_ESC = re.compile(fr'(?:(\\\\[a-f0-9]{{1,6}}{WS}?)|(\\\\[^\\r\\n\\f])|(\\\\$)|(\\\\{NEWLINE}))', re.I)\n# Pattern to break up `nth` specifiers\nRE_NTH = re.compile(fr'(?P<s1>[-+])?(?P<a>[0-9]+n?|n)(?:(?<=n){WSC}*(?P<s2>[-+]){WSC}*(?P<b>[0-9]+))?', re.I)\n# Pattern to iterate multiple values.\nRE_VALUES = re.compile(fr'(?:(?P<value>{VALUE})|(?P<split>{WSC}*,{WSC}*))', re.X)\n# Whitespace checks\nRE_WS = re.compile(WS)\nRE_WS_BEGIN = re.compile(fr'^{WSC}*')\nRE_WS_END = re.compile(fr'{WSC}*$')\nRE_CUSTOM = re.compile(fr'^{PAT_PSEUDO_CLASS_CUSTOM}$', re.X)\n\n# Constants\n# List split token\nCOMMA_COMBINATOR = ','\n# Relation token for descendant\nWS_COMBINATOR = \" \"\n\n# Parse flags\nFLG_PSEUDO = 0x01\nFLG_NOT = 0x02\nFLG_RELATIVE = 0x04\nFLG_DEFAULT = 0x08\nFLG_HTML = 0x10\nFLG_INDETERMINATE = 0x20\nFLG_OPEN = 0x40\nFLG_IN_RANGE = 0x80\nFLG_OUT_OF_RANGE = 0x100\nFLG_PLACEHOLDER_SHOWN = 0x200\nFLG_FORGIVE = 0x400\n\n# Maximum cached patterns to store\n_MAXCACHE = 500\n\n\n@lru_cache(maxsize=_MAXCACHE)\ndef _cached_css_compile(\n    pattern: str,\n    namespaces: ct.Namespaces | None,\n    custom: ct.CustomSelectors | None,\n    flags: int\n) -> cm.SoupSieve:\n    \"\"\"Cached CSS compile.\"\"\"\n\n    custom_selectors = process_custom(custom)\n    return cm.SoupSieve(\n        pattern,\n        CSSParser(\n            pattern,\n            custom=custom_selectors,\n            flags=flags\n        ).process_selectors(),\n        namespaces,\n        custom,\n        flags\n    )\n\n\ndef _purge_cache() -> None:\n    \"\"\"Purge the cache.\"\"\"\n\n    _cached_css_compile.cache_clear()\n\n\ndef process_custom(custom: ct.CustomSelectors | None) -> dict[str, str | ct.SelectorList]:\n    \"\"\"Process custom.\"\"\"\n\n    custom_selectors = {}\n    if custom is not None:\n        for key, value in custom.items():\n            name = util.lower(key)\n            if RE_CUSTOM.match(name) is None:\n                raise SelectorSyntaxError(f\"The name '{name}' is not a valid custom pseudo-class name\")\n            if name in custom_selectors:\n                raise KeyError(f\"The custom selector '{name}' has already been registered\")\n            custom_selectors[css_unescape(name)] = value\n    return custom_selectors\n\n\ndef css_unescape(content: str, string: bool = False) -> str:\n    \"\"\"\n    Unescape CSS value.\n\n    Strings allow for spanning the value on multiple strings by escaping a new line.\n    \"\"\"\n\n    def replace(m: Match[str]) -> str:\n        \"\"\"Replace with the appropriate substitute.\"\"\"\n\n        if m.group(1):\n            codepoint = int(m.group(1)[1:], 16)\n            if codepoint == 0:\n                codepoint = UNICODE_REPLACEMENT_CHAR\n            value = chr(codepoint)\n        elif m.group(2):\n            value = m.group(2)[1:]\n        elif m.group(3):\n            value = '\\ufffd'\n        else:\n            value = ''\n\n        return value\n\n    return (RE_CSS_ESC if not string else RE_CSS_STR_ESC).sub(replace, content)\n\n\ndef escape(ident: str) -> str:\n    \"\"\"Escape identifier.\"\"\"\n\n    string = []\n    length = len(ident)\n    start_dash = length > 0 and ident[0] == '-'\n    if length == 1 and start_dash:\n        # Need to escape identifier that is a single `-` with no other characters\n        string.append(f'\\\\{ident}')\n    else:\n        for index, c in enumerate(ident):\n            codepoint = ord(c)\n            if codepoint == 0x00:\n                string.append('\\ufffd')\n            elif (0x01 <= codepoint <= 0x1F) or codepoint == 0x7F:\n                string.append(f'\\\\{codepoint:x} ')\n            elif (index == 0 or (start_dash and index == 1)) and (0x30 <= codepoint <= 0x39):\n                string.append(f'\\\\{codepoint:x} ')\n            elif (\n                codepoint in (0x2D, 0x5F) or codepoint >= 0x80 or (0x30 <= codepoint <= 0x39) or\n                (0x30 <= codepoint <= 0x39) or (0x41 <= codepoint <= 0x5A) or (0x61 <= codepoint <= 0x7A)\n            ):\n                string.append(c)\n            else:\n                string.append(f'\\\\{c}')\n    return ''.join(string)\n\n\nclass SelectorPattern:\n    \"\"\"Selector pattern.\"\"\"\n\n    def __init__(self, name: str, pattern: str) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.name = name\n        self.re_pattern = re.compile(pattern, re.I | re.X | re.U)\n\n    def get_name(self) -> str:\n        \"\"\"Get name.\"\"\"\n\n        return self.name\n\n    def match(self, selector: str, index: int, flags: int) -> Match[str] | None:\n        \"\"\"Match the selector.\"\"\"\n\n        return self.re_pattern.match(selector, index)\n\n\nclass SpecialPseudoPattern(SelectorPattern):\n    \"\"\"Selector pattern.\"\"\"\n\n    def __init__(self, patterns: tuple[tuple[str, tuple[str, ...], str, type[SelectorPattern]], ...]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.patterns = {}\n        for p in patterns:\n            name = p[0]\n            pattern = p[3](name, p[2])\n            for pseudo in p[1]:\n                self.patterns[pseudo] = pattern\n\n        self.matched_name = None  # type: SelectorPattern | None\n        self.re_pseudo_name = re.compile(PAT_PSEUDO_CLASS_SPECIAL, re.I | re.X | re.U)\n\n    def get_name(self) -> str:\n        \"\"\"Get name.\"\"\"\n\n        return '' if self.matched_name is None else self.matched_name.get_name()\n\n    def match(self, selector: str, index: int, flags: int) -> Match[str] | None:\n        \"\"\"Match the selector.\"\"\"\n\n        pseudo = None\n        m = self.re_pseudo_name.match(selector, index)\n        if m:\n            name = util.lower(css_unescape(m.group('name')))\n            pattern = self.patterns.get(name)\n            if pattern:\n                pseudo = pattern.match(selector, index, flags)\n                if pseudo:\n                    self.matched_name = pattern\n\n        return pseudo\n\n\nclass _Selector:\n    \"\"\"\n    Intermediate selector class.\n\n    This stores selector data for a compound selector as we are acquiring them.\n    Once we are done collecting the data for a compound selector, we freeze\n    the data in an object that can be pickled and hashed.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.tag = kwargs.get('tag', None)  # type: ct.SelectorTag | None\n        self.ids = kwargs.get('ids', [])  # type: list[str]\n        self.classes = kwargs.get('classes', [])  # type: list[str]\n        self.attributes = kwargs.get('attributes', [])  # type: list[ct.SelectorAttribute]\n        self.nth = kwargs.get('nth', [])  # type: list[ct.SelectorNth]\n        self.selectors = kwargs.get('selectors', [])  # type: list[ct.SelectorList]\n        self.relations = kwargs.get('relations', [])  # type: list[_Selector]\n        self.rel_type = kwargs.get('rel_type', None)  # type: str | None\n        self.contains = kwargs.get('contains', [])  # type: list[ct.SelectorContains]\n        self.lang = kwargs.get('lang', [])  # type: list[ct.SelectorLang]\n        self.flags = kwargs.get('flags', 0)  # type: int\n        self.no_match = kwargs.get('no_match', False)  # type: bool\n\n    def _freeze_relations(self, relations: list[_Selector]) -> ct.SelectorList:\n        \"\"\"Freeze relation.\"\"\"\n\n        if relations:\n            sel = relations[0]\n            sel.relations.extend(relations[1:])\n            return ct.SelectorList([sel.freeze()])\n        else:\n            return ct.SelectorList()\n\n    def freeze(self) -> ct.Selector | ct.SelectorNull:\n        \"\"\"Freeze self.\"\"\"\n\n        if self.no_match:\n            return ct.SelectorNull()\n        else:\n            return ct.Selector(\n                self.tag,\n                tuple(self.ids),\n                tuple(self.classes),\n                tuple(self.attributes),\n                tuple(self.nth),\n                tuple(self.selectors),\n                self._freeze_relations(self.relations),\n                self.rel_type,\n                tuple(self.contains),\n                tuple(self.lang),\n                self.flags\n            )\n\n    def __str__(self) -> str:  # pragma: no cover\n        \"\"\"String representation.\"\"\"\n\n        return (\n            f'_Selector(tag={self.tag!r}, ids={self.ids!r}, classes={self.classes!r}, attributes={self.attributes!r}, '\n            f'nth={self.nth!r}, selectors={self.selectors!r}, relations={self.relations!r}, '\n            f'rel_type={self.rel_type!r}, contains={self.contains!r}, lang={self.lang!r}, flags={self.flags!r}, '\n            f'no_match={self.no_match!r})'\n        )\n\n    __repr__ = __str__\n\n\nclass CSSParser:\n    \"\"\"Parse CSS selectors.\"\"\"\n\n    css_tokens = (\n        SelectorPattern(\"pseudo_close\", PAT_PSEUDO_CLOSE),\n        SpecialPseudoPattern(\n            (\n                (\n                    \"pseudo_contains\",\n                    (':contains', ':-soup-contains', ':-soup-contains-own'),\n                    PAT_PSEUDO_CONTAINS,\n                    SelectorPattern\n                ),\n                (\"pseudo_nth_child\", (':nth-child', ':nth-last-child'), PAT_PSEUDO_NTH_CHILD, SelectorPattern),\n                (\"pseudo_nth_type\", (':nth-of-type', ':nth-last-of-type'), PAT_PSEUDO_NTH_TYPE, SelectorPattern),\n                (\"pseudo_lang\", (':lang',), PAT_PSEUDO_LANG, SelectorPattern),\n                (\"pseudo_dir\", (':dir',), PAT_PSEUDO_DIR, SelectorPattern)\n            )\n        ),\n        SelectorPattern(\"pseudo_class_custom\", PAT_PSEUDO_CLASS_CUSTOM),\n        SelectorPattern(\"pseudo_class\", PAT_PSEUDO_CLASS),\n        SelectorPattern(\"pseudo_element\", PAT_PSEUDO_ELEMENT),\n        SelectorPattern(\"at_rule\", PAT_AT_RULE),\n        SelectorPattern(\"id\", PAT_ID),\n        SelectorPattern(\"class\", PAT_CLASS),\n        SelectorPattern(\"tag\", PAT_TAG),\n        SelectorPattern(\"attribute\", PAT_ATTR),\n        SelectorPattern(\"combine\", PAT_COMBINE)\n    )\n\n    def __init__(\n        self,\n        selector: str,\n        custom: dict[str, str | ct.SelectorList] | None = None,\n        flags: int = 0\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.pattern = selector.replace('\\x00', '\\ufffd')\n        self.flags = flags\n        self.debug = self.flags & util.DEBUG\n        self.custom = {} if custom is None else custom\n\n    def parse_attribute_selector(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Create attribute selector from the returned regex match.\"\"\"\n\n        inverse = False\n        op = m.group('cmp')\n        case = util.lower(m.group('case')) if m.group('case') else None\n        ns = css_unescape(m.group('attr_ns')[:-1]) if m.group('attr_ns') else ''\n        attr = css_unescape(m.group('attr_name'))\n        is_type = False\n        pattern2 = None\n        value = ''\n\n        if case:\n            flags = (re.I if case == 'i' else 0) | re.DOTALL\n        elif util.lower(attr) == 'type':\n            flags = re.I | re.DOTALL\n            is_type = True\n        else:\n            flags = re.DOTALL\n\n        if op:\n            if m.group('value').startswith(('\"', \"'\")):\n                value = css_unescape(m.group('value')[1:-1], True)\n            else:\n                value = css_unescape(m.group('value'))\n\n        if not op:\n            # Attribute name\n            pattern = None\n        elif op.startswith('^'):\n            # Value start with\n            pattern = re.compile(r'^%s.*' % re.escape(value), flags)\n        elif op.startswith('$'):\n            # Value ends with\n            pattern = re.compile(r'.*?%s$' % re.escape(value), flags)\n        elif op.startswith('*'):\n            # Value contains\n            pattern = re.compile(r'.*?%s.*' % re.escape(value), flags)\n        elif op.startswith('~'):\n            # Value contains word within space separated list\n            # `~=` should match nothing if it is empty or contains whitespace,\n            # so if either of these cases is present, use `[^\\s\\S]` which cannot be matched.\n            value = r'[^\\s\\S]' if not value or RE_WS.search(value) else re.escape(value)\n            pattern = re.compile(r'.*?(?:(?<=^)|(?<=[ \\t\\r\\n\\f]))%s(?=(?:[ \\t\\r\\n\\f]|$)).*' % value, flags)\n        elif op.startswith('|'):\n            # Value starts with word in dash separated list\n            pattern = re.compile(r'^%s(?:-.*)?$' % re.escape(value), flags)\n        else:\n            # Value matches\n            pattern = re.compile(r'^%s$' % re.escape(value), flags)\n            if op.startswith('!'):\n                # Equivalent to `:not([attr=value])`\n                inverse = True\n        if is_type and pattern:\n            pattern2 = re.compile(pattern.pattern)\n\n        # Append the attribute selector\n        sel_attr = ct.SelectorAttribute(attr, ns, pattern, pattern2)\n        if inverse:\n            # If we are using `!=`, we need to nest the pattern under a `:not()`.\n            sub_sel = _Selector()\n            sub_sel.attributes.append(sel_attr)\n            not_list = ct.SelectorList([sub_sel.freeze()], True, False)\n            sel.selectors.append(not_list)\n        else:\n            sel.attributes.append(sel_attr)\n\n        has_selector = True\n        return has_selector\n\n    def parse_tag_pattern(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse tag pattern from regex match.\"\"\"\n\n        prefix = css_unescape(m.group('tag_ns')[:-1]) if m.group('tag_ns') else None\n        tag = css_unescape(m.group('tag_name'))\n        sel.tag = ct.SelectorTag(tag, prefix)\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_class_custom(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"\n        Parse custom pseudo class alias.\n\n        Compile custom selectors as we need them. When compiling a custom selector,\n        set it to `None` in the dictionary so we can avoid an infinite loop.\n        \"\"\"\n\n        pseudo = util.lower(css_unescape(m.group('name')))\n        selector = self.custom.get(pseudo)\n        if selector is None:\n            raise SelectorSyntaxError(\n                f\"Undefined custom selector '{pseudo}' found at position {m.end(0)}\",\n                self.pattern,\n                m.end(0)\n            )\n\n        if not isinstance(selector, ct.SelectorList):\n            del self.custom[pseudo]\n            selector = CSSParser(\n                selector, custom=self.custom, flags=self.flags\n            ).process_selectors(flags=FLG_PSEUDO)\n            self.custom[pseudo] = selector\n\n        sel.selectors.append(selector)\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_class(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]],\n        is_html: bool\n    ) -> tuple[bool, bool]:\n        \"\"\"Parse pseudo class.\"\"\"\n\n        complex_pseudo = False\n        pseudo = util.lower(css_unescape(m.group('name')))\n        if m.group('open'):\n            complex_pseudo = True\n        if complex_pseudo and pseudo in PSEUDO_COMPLEX:\n            has_selector = self.parse_pseudo_open(sel, pseudo, has_selector, iselector, m.end(0))\n        elif not complex_pseudo and pseudo in PSEUDO_SIMPLE:\n            if pseudo == ':root':\n                sel.flags |= ct.SEL_ROOT\n            elif pseudo == ':defined':\n                sel.flags |= ct.SEL_DEFINED\n                is_html = True\n            elif pseudo == ':scope':\n                sel.flags |= ct.SEL_SCOPE\n            elif pseudo == ':empty':\n                sel.flags |= ct.SEL_EMPTY\n            elif pseudo in (':link', ':any-link'):\n                sel.selectors.append(CSS_LINK)\n            elif pseudo == ':checked':\n                sel.selectors.append(CSS_CHECKED)\n            elif pseudo == ':default':\n                sel.selectors.append(CSS_DEFAULT)\n            elif pseudo == ':indeterminate':\n                sel.selectors.append(CSS_INDETERMINATE)\n            elif pseudo == \":disabled\":\n                sel.selectors.append(CSS_DISABLED)\n            elif pseudo == \":enabled\":\n                sel.selectors.append(CSS_ENABLED)\n            elif pseudo == \":required\":\n                sel.selectors.append(CSS_REQUIRED)\n            elif pseudo == \":optional\":\n                sel.selectors.append(CSS_OPTIONAL)\n            elif pseudo == \":read-only\":\n                sel.selectors.append(CSS_READ_ONLY)\n            elif pseudo == \":read-write\":\n                sel.selectors.append(CSS_READ_WRITE)\n            elif pseudo == \":in-range\":\n                sel.selectors.append(CSS_IN_RANGE)\n            elif pseudo == \":out-of-range\":\n                sel.selectors.append(CSS_OUT_OF_RANGE)\n            elif pseudo == \":placeholder-shown\":\n                sel.selectors.append(CSS_PLACEHOLDER_SHOWN)\n            elif pseudo == ':first-child':\n                sel.nth.append(ct.SelectorNth(1, False, 0, False, False, ct.SelectorList()))\n            elif pseudo == ':last-child':\n                sel.nth.append(ct.SelectorNth(1, False, 0, False, True, ct.SelectorList()))\n            elif pseudo == ':first-of-type':\n                sel.nth.append(ct.SelectorNth(1, False, 0, True, False, ct.SelectorList()))\n            elif pseudo == ':last-of-type':\n                sel.nth.append(ct.SelectorNth(1, False, 0, True, True, ct.SelectorList()))\n            elif pseudo == ':only-child':\n                sel.nth.extend(\n                    [\n                        ct.SelectorNth(1, False, 0, False, False, ct.SelectorList()),\n                        ct.SelectorNth(1, False, 0, False, True, ct.SelectorList())\n                    ]\n                )\n            elif pseudo == ':only-of-type':\n                sel.nth.extend(\n                    [\n                        ct.SelectorNth(1, False, 0, True, False, ct.SelectorList()),\n                        ct.SelectorNth(1, False, 0, True, True, ct.SelectorList())\n                    ]\n                )\n            has_selector = True\n        elif complex_pseudo and pseudo in PSEUDO_COMPLEX_NO_MATCH:\n            self.parse_selectors(iselector, m.end(0), FLG_PSEUDO | FLG_OPEN)\n            sel.no_match = True\n            has_selector = True\n        elif not complex_pseudo and pseudo in PSEUDO_SIMPLE_NO_MATCH:\n            sel.no_match = True\n            has_selector = True\n        elif pseudo in PSEUDO_SUPPORTED:\n            raise SelectorSyntaxError(\n                f\"Invalid syntax for pseudo class '{pseudo}'\",\n                self.pattern,\n                m.start(0)\n            )\n        else:\n            raise NotImplementedError(\n                f\"'{pseudo}' pseudo-class is not implemented at this time\"\n            )\n\n        return has_selector, is_html\n\n    def parse_pseudo_nth(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]]\n    ) -> bool:\n        \"\"\"Parse `nth` pseudo.\"\"\"\n\n        mdict = m.groupdict()\n        if mdict.get('pseudo_nth_child'):\n            postfix = '_child'\n        else:\n            postfix = '_type'\n        mdict['name'] = util.lower(css_unescape(mdict['name']))\n        content = util.lower(mdict.get('nth' + postfix))\n        if content == 'even':\n            # 2n\n            s1 = 2\n            s2 = 0\n            var = True\n        elif content == 'odd':\n            # 2n+1\n            s1 = 2\n            s2 = 1\n            var = True\n        else:\n            nth_parts = cast(Match[str], RE_NTH.match(content))\n            _s1 = '-' if nth_parts.group('s1') and nth_parts.group('s1') == '-' else ''\n            a = nth_parts.group('a')\n            var = a.endswith('n')\n            if a.startswith('n'):\n                _s1 += '1'\n            elif var:\n                _s1 += a[:-1]\n            else:\n                _s1 += a\n            _s2 = '-' if nth_parts.group('s2') and nth_parts.group('s2') == '-' else ''\n            if nth_parts.group('b'):\n                _s2 += nth_parts.group('b')\n            else:\n                _s2 = '0'\n            s1 = int(_s1, 10)\n            s2 = int(_s2, 10)\n\n        pseudo_sel = mdict['name']\n        if postfix == '_child':\n            if m.group('of'):\n                # Parse the rest of `of S`.\n                nth_sel = self.parse_selectors(iselector, m.end(0), FLG_PSEUDO | FLG_OPEN)\n            else:\n                # Use default `*|*` for `of S`.\n                nth_sel = CSS_NTH_OF_S_DEFAULT\n            if pseudo_sel == ':nth-child':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, False, False, nth_sel))\n            elif pseudo_sel == ':nth-last-child':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, False, True, nth_sel))\n        else:\n            if pseudo_sel == ':nth-of-type':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, True, False, ct.SelectorList()))\n            elif pseudo_sel == ':nth-last-of-type':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, True, True, ct.SelectorList()))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_open(\n        self,\n        sel: _Selector,\n        name: str,\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]],\n        index: int\n    ) -> bool:\n        \"\"\"Parse pseudo with opening bracket.\"\"\"\n\n        flags = FLG_PSEUDO | FLG_OPEN\n        if name == ':not':\n            flags |= FLG_NOT\n        elif name == ':has':\n            flags |= FLG_RELATIVE\n        elif name in (':where', ':is'):\n            flags |= FLG_FORGIVE\n\n        sel.selectors.append(self.parse_selectors(iselector, index, flags))\n        has_selector = True\n\n        return has_selector\n\n    def parse_has_combinator(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        selectors: list[_Selector],\n        rel_type: str,\n        index: int\n    ) -> tuple[bool, _Selector, str]:\n        \"\"\"Parse combinator tokens.\"\"\"\n\n        combinator = m.group('relation').strip()\n        if not combinator:\n            combinator = WS_COMBINATOR\n        if combinator == COMMA_COMBINATOR:\n            sel.rel_type = rel_type\n            selectors[-1].relations.append(sel)\n            rel_type = \":\" + WS_COMBINATOR\n            selectors.append(_Selector())\n        else:\n            if has_selector:\n                # End the current selector and associate the leading combinator with this selector.\n                sel.rel_type = rel_type\n                selectors[-1].relations.append(sel)\n            elif rel_type[1:] != WS_COMBINATOR:\n                # It's impossible to have two whitespace combinators after each other as the patterns\n                # will gobble up trailing whitespace. It is also impossible to have a whitespace\n                # combinator after any other kind for the same reason. But we could have\n                # multiple non-whitespace combinators. So if the current combinator is not a whitespace,\n                # then we've hit the multiple combinator case, so we should fail.\n                raise SelectorSyntaxError(\n                    f'The multiple combinators at position {index}',\n                    self.pattern,\n                    index\n                )\n\n            # Set the leading combinator for the next selector.\n            rel_type = ':' + combinator\n\n        sel = _Selector()\n        has_selector = False\n        return has_selector, sel, rel_type\n\n    def parse_combinator(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        selectors: list[_Selector],\n        relations: list[_Selector],\n        is_pseudo: bool,\n        is_forgive: bool,\n        index: int\n    ) -> tuple[bool, _Selector]:\n        \"\"\"Parse combinator tokens.\"\"\"\n\n        combinator = m.group('relation').strip()\n        if not combinator:\n            combinator = WS_COMBINATOR\n        if not has_selector:\n            if not is_forgive or combinator != COMMA_COMBINATOR:\n                raise SelectorSyntaxError(\n                    f\"The combinator '{combinator}' at position {index}, must have a selector before it\",\n                    self.pattern,\n                    index\n                )\n\n            # If we are in a forgiving pseudo class, just make the selector a \"no match\"\n            if combinator == COMMA_COMBINATOR:\n                sel.no_match = True\n                del relations[:]\n                selectors.append(sel)\n        else:\n            if combinator == COMMA_COMBINATOR:\n                if not sel.tag and not is_pseudo:\n                    # Implied `*`\n                    sel.tag = ct.SelectorTag('*', None)\n                sel.relations.extend(relations)\n                selectors.append(sel)\n                del relations[:]\n            else:\n                sel.relations.extend(relations)\n                sel.rel_type = combinator\n                del relations[:]\n                relations.append(sel)\n\n        sel = _Selector()\n        has_selector = False\n\n        return has_selector, sel\n\n    def parse_class_id(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse HTML classes and ids.\"\"\"\n\n        selector = m.group(0)\n        if selector.startswith('.'):\n            sel.classes.append(css_unescape(selector[1:]))\n        else:\n            sel.ids.append(css_unescape(selector[1:]))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_contains(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse contains.\"\"\"\n\n        pseudo = util.lower(css_unescape(m.group('name')))\n        if pseudo == \":contains\":\n            warnings.warn(  # noqa: B028\n                \"The pseudo class ':contains' is deprecated, ':-soup-contains' should be used moving forward.\",\n                FutureWarning\n            )\n        contains_own = pseudo == \":-soup-contains-own\"\n        values = css_unescape(m.group('values'))\n        patterns = []\n        for token in RE_VALUES.finditer(values):\n            if token.group('split'):\n                continue\n            value = token.group('value')\n            if value.startswith((\"'\", '\"')):\n                value = css_unescape(value[1:-1], True)\n            else:\n                value = css_unescape(value)\n            patterns.append(value)\n        sel.contains.append(ct.SelectorContains(patterns, contains_own))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_lang(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse pseudo language.\"\"\"\n\n        values = m.group('values')\n        patterns = []\n        for token in RE_VALUES.finditer(values):\n            if token.group('split'):\n                continue\n            value = token.group('value')\n            if value.startswith(('\"', \"'\")):\n                value = css_unescape(value[1:-1], True)\n            else:\n                value = css_unescape(value)\n\n            patterns.append(value)\n\n        sel.lang.append(ct.SelectorLang(patterns))\n        has_selector = True\n\n        return has_selector\n\n    def parse_pseudo_dir(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse pseudo direction.\"\"\"\n\n        value = ct.SEL_DIR_LTR if util.lower(m.group('dir')) == 'ltr' else ct.SEL_DIR_RTL\n        sel.flags |= value\n        has_selector = True\n        return has_selector\n\n    def parse_selectors(\n        self,\n        iselector: Iterator[tuple[str, Match[str]]],\n        index: int = 0,\n        flags: int = 0\n    ) -> ct.SelectorList:\n        \"\"\"Parse selectors.\"\"\"\n\n        # Initialize important variables\n        sel = _Selector()\n        selectors = []\n        has_selector = False\n        closed = False\n        relations = []  # type: list[_Selector]\n        rel_type = \":\" + WS_COMBINATOR\n\n        # Setup various flags\n        is_open = bool(flags & FLG_OPEN)\n        is_pseudo = bool(flags & FLG_PSEUDO)\n        is_relative = bool(flags & FLG_RELATIVE)\n        is_not = bool(flags & FLG_NOT)\n        is_html = bool(flags & FLG_HTML)\n        is_default = bool(flags & FLG_DEFAULT)\n        is_indeterminate = bool(flags & FLG_INDETERMINATE)\n        is_in_range = bool(flags & FLG_IN_RANGE)\n        is_out_of_range = bool(flags & FLG_OUT_OF_RANGE)\n        is_placeholder_shown = bool(flags & FLG_PLACEHOLDER_SHOWN)\n        is_forgive = bool(flags & FLG_FORGIVE)\n\n        # Print out useful debug stuff\n        if self.debug:  # pragma: no cover\n            if is_pseudo:\n                print('    is_pseudo: True')\n            if is_open:\n                print('    is_open: True')\n            if is_relative:\n                print('    is_relative: True')\n            if is_not:\n                print('    is_not: True')\n            if is_html:\n                print('    is_html: True')\n            if is_default:\n                print('    is_default: True')\n            if is_indeterminate:\n                print('    is_indeterminate: True')\n            if is_in_range:\n                print('    is_in_range: True')\n            if is_out_of_range:\n                print('    is_out_of_range: True')\n            if is_placeholder_shown:\n                print('    is_placeholder_shown: True')\n            if is_forgive:\n                print('    is_forgive: True')\n\n        # The algorithm for relative selectors require an initial selector in the selector list\n        if is_relative:\n            selectors.append(_Selector())\n\n        try:\n            while True:\n                key, m = next(iselector)\n\n                # Handle parts\n                if key == \"at_rule\":\n                    raise NotImplementedError(f\"At-rules found at position {m.start(0)}\")\n                elif key == 'pseudo_class_custom':\n                    has_selector = self.parse_pseudo_class_custom(sel, m, has_selector)\n                elif key == 'pseudo_class':\n                    has_selector, is_html = self.parse_pseudo_class(sel, m, has_selector, iselector, is_html)\n                elif key == 'pseudo_element':\n                    raise NotImplementedError(f\"Pseudo-element found at position {m.start(0)}\")\n                elif key == 'pseudo_contains':\n                    has_selector = self.parse_pseudo_contains(sel, m, has_selector)\n                elif key in ('pseudo_nth_type', 'pseudo_nth_child'):\n                    has_selector = self.parse_pseudo_nth(sel, m, has_selector, iselector)\n                elif key == 'pseudo_lang':\n                    has_selector = self.parse_pseudo_lang(sel, m, has_selector)\n                elif key == 'pseudo_dir':\n                    has_selector = self.parse_pseudo_dir(sel, m, has_selector)\n                    # Currently only supports HTML\n                    is_html = True\n                elif key == 'pseudo_close':\n                    if not has_selector:\n                        if not is_forgive:\n                            raise SelectorSyntaxError(\n                                f\"Expected a selector at position {m.start(0)}\",\n                                self.pattern,\n                                m.start(0)\n                            )\n                        sel.no_match = True\n                    if is_open:\n                        closed = True\n                        break\n                    else:\n                        raise SelectorSyntaxError(\n                            f\"Unmatched pseudo-class close at position {m.start(0)}\",\n                            self.pattern,\n                            m.start(0)\n                        )\n                elif key == 'combine':\n                    if is_relative:\n                        has_selector, sel, rel_type = self.parse_has_combinator(\n                            sel, m, has_selector, selectors, rel_type, index\n                        )\n                    else:\n                        has_selector, sel = self.parse_combinator(\n                            sel, m, has_selector, selectors, relations, is_pseudo, is_forgive, index\n                        )\n                elif key == 'attribute':\n                    has_selector = self.parse_attribute_selector(sel, m, has_selector)\n                elif key == 'tag':\n                    if has_selector:\n                        raise SelectorSyntaxError(\n                            f\"Tag name found at position {m.start(0)} instead of at the start\",\n                            self.pattern,\n                            m.start(0)\n                        )\n                    has_selector = self.parse_tag_pattern(sel, m, has_selector)\n                elif key in ('class', 'id'):\n                    has_selector = self.parse_class_id(sel, m, has_selector)\n\n                index = m.end(0)\n        except StopIteration:\n            pass\n\n        # Handle selectors that are not closed\n        if is_open and not closed:\n            raise SelectorSyntaxError(\n                f\"Unclosed pseudo-class at position {index}\",\n                self.pattern,\n                index\n            )\n\n        # Cleanup completed selector piece\n        if has_selector:\n            if not sel.tag and not is_pseudo:\n                # Implied `*`\n                sel.tag = ct.SelectorTag('*', None)\n            if is_relative:\n                sel.rel_type = rel_type\n                selectors[-1].relations.append(sel)\n            else:\n                sel.relations.extend(relations)\n                del relations[:]\n                selectors.append(sel)\n\n        # Forgive empty slots in pseudo-classes that have lists (and are forgiving)\n        elif is_forgive and (not selectors or not relations):\n            # Handle normal pseudo-classes with empty slots like `:is()` etc.\n            sel.no_match = True\n            del relations[:]\n            selectors.append(sel)\n            has_selector = True\n\n        if not has_selector:\n            # We will always need to finish a selector when `:has()` is used as it leads with combining.\n            # May apply to others as well.\n            raise SelectorSyntaxError(\n                f'Expected a selector at position {index}',\n                self.pattern,\n                index\n            )\n\n        # Some patterns require additional logic, such as default. We try to make these the\n        # last pattern, and append the appropriate flag to that selector which communicates\n        # to the matcher what additional logic is required.\n        if is_default:\n            selectors[-1].flags = ct.SEL_DEFAULT\n        if is_indeterminate:\n            selectors[-1].flags = ct.SEL_INDETERMINATE\n        if is_in_range:\n            selectors[-1].flags = ct.SEL_IN_RANGE\n        if is_out_of_range:\n            selectors[-1].flags = ct.SEL_OUT_OF_RANGE\n        if is_placeholder_shown:\n            selectors[-1].flags = ct.SEL_PLACEHOLDER_SHOWN\n\n        # Return selector list\n        return ct.SelectorList([s.freeze() for s in selectors], is_not, is_html)\n\n    def selector_iter(self, pattern: str) -> Iterator[tuple[str, Match[str]]]:\n        \"\"\"Iterate selector tokens.\"\"\"\n\n        # Ignore whitespace and comments at start and end of pattern\n        m = RE_WS_BEGIN.search(pattern)\n        index = m.end(0) if m else 0\n        m = RE_WS_END.search(pattern)\n        end = (m.start(0) - 1) if m else (len(pattern) - 1)\n\n        if self.debug:  # pragma: no cover\n            print(f'## PARSING: {pattern!r}')\n        while index <= end:\n            m = None\n            for v in self.css_tokens:\n                m = v.match(pattern, index, self.flags)\n                if m:\n                    name = v.get_name()\n                    if self.debug:  # pragma: no cover\n                        print(f\"TOKEN: '{name}' --> {m.group(0)!r} at position {m.start(0)}\")\n                    index = m.end(0)\n                    yield name, m\n                    break\n            if m is None:\n                c = pattern[index]\n                # If the character represents the start of one of the known selector types,\n                # throw an exception mentioning that the known selector type is in error;\n                # otherwise, report the invalid character.\n                if c == '[':\n                    msg = f\"Malformed attribute selector at position {index}\"\n                elif c == '.':\n                    msg = f\"Malformed class selector at position {index}\"\n                elif c == '#':\n                    msg = f\"Malformed id selector at position {index}\"\n                elif c == ':':\n                    msg = f\"Malformed pseudo-class selector at position {index}\"\n                else:\n                    msg = f\"Invalid character {c!r} position {index}\"\n                raise SelectorSyntaxError(msg, self.pattern, index)\n        if self.debug:  # pragma: no cover\n            print('## END PARSING')\n\n    def process_selectors(self, index: int = 0, flags: int = 0) -> ct.SelectorList:\n        \"\"\"Process selectors.\"\"\"\n\n        return self.parse_selectors(self.selector_iter(self.pattern), index, flags)\n\n\n# Precompile CSS selector lists for pseudo-classes (additional logic may be required beyond the pattern)\n# A few patterns are order dependent as they use patterns previous compiled.\n\n# CSS pattern for `:link` and `:any-link`\nCSS_LINK = CSSParser(\n    'html|*:is(a, area)[href]'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:checked`\nCSS_CHECKED = CSSParser(\n    '''\n    html|*:is(input[type=checkbox], input[type=radio])[checked], html|option[selected]\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:default` (must compile CSS_CHECKED first)\nCSS_DEFAULT = CSSParser(\n    '''\n    :checked,\n\n    /*\n    This pattern must be at the end.\n    Special logic is applied to the last selector.\n    */\n    html|form html|*:is(button, input)[type=\"submit\"]\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_DEFAULT)\n# CSS pattern for `:indeterminate`\nCSS_INDETERMINATE = CSSParser(\n    '''\n    html|input[type=\"checkbox\"][indeterminate],\n    html|input[type=\"radio\"]:is(:not([name]), [name=\"\"]):not([checked]),\n    html|progress:not([value]),\n\n    /*\n    This pattern must be at the end.\n    Special logic is applied to the last selector.\n    */\n    html|input[type=\"radio\"][name]:not([name='']):not([checked])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_INDETERMINATE)\n# CSS pattern for `:disabled`\nCSS_DISABLED = CSSParser(\n    '''\n    html|*:is(input:not([type=hidden]), button, select, textarea, fieldset, optgroup, option, fieldset)[disabled],\n    html|optgroup[disabled] > html|option,\n    html|fieldset[disabled] > html|*:is(input:not([type=hidden]), button, select, textarea, fieldset),\n    html|fieldset[disabled] >\n        html|*:not(legend:nth-of-type(1)) html|*:is(input:not([type=hidden]), button, select, textarea, fieldset)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:enabled`\nCSS_ENABLED = CSSParser(\n    '''\n    html|*:is(input:not([type=hidden]), button, select, textarea, fieldset, optgroup, option, fieldset):not(:disabled)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:required`\nCSS_REQUIRED = CSSParser(\n    'html|*:is(input, textarea, select)[required]'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:optional`\nCSS_OPTIONAL = CSSParser(\n    'html|*:is(input, textarea, select):not([required])'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:placeholder-shown`\nCSS_PLACEHOLDER_SHOWN = CSSParser(\n    '''\n    html|input:is(\n        :not([type]),\n        [type=\"\"],\n        [type=text],\n        [type=search],\n        [type=url],\n        [type=tel],\n        [type=email],\n        [type=password],\n        [type=number]\n    )[placeholder]:not([placeholder='']):is(:not([value]), [value=\"\"]),\n    html|textarea[placeholder]:not([placeholder=''])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_PLACEHOLDER_SHOWN)\n# CSS pattern default for `:nth-child` \"of S\" feature\nCSS_NTH_OF_S_DEFAULT = CSSParser(\n    '*|*'\n).process_selectors(flags=FLG_PSEUDO)\n# CSS pattern for `:read-write` (CSS_DISABLED must be compiled first)\nCSS_READ_WRITE = CSSParser(\n    '''\n    html|*:is(\n        textarea,\n        input:is(\n            :not([type]),\n            [type=\"\"],\n            [type=text],\n            [type=search],\n            [type=url],\n            [type=tel],\n            [type=email],\n            [type=number],\n            [type=password],\n            [type=date],\n            [type=datetime-local],\n            [type=month],\n            [type=time],\n            [type=week]\n        )\n    ):not([readonly], :disabled),\n    html|*:is([contenteditable=\"\"], [contenteditable=\"true\" i])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:read-only`\nCSS_READ_ONLY = CSSParser(\n    '''\n    html|*:not(:read-write)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:in-range`\nCSS_IN_RANGE = CSSParser(\n    '''\n    html|input:is(\n        [type=\"date\"],\n        [type=\"month\"],\n        [type=\"week\"],\n        [type=\"time\"],\n        [type=\"datetime-local\"],\n        [type=\"number\"],\n        [type=\"range\"]\n    ):is(\n        [min],\n        [max]\n    )\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_IN_RANGE | FLG_HTML)\n# CSS pattern for `:out-of-range`\nCSS_OUT_OF_RANGE = CSSParser(\n    '''\n    html|input:is(\n        [type=\"date\"],\n        [type=\"month\"],\n        [type=\"week\"],\n        [type=\"time\"],\n        [type=\"datetime-local\"],\n        [type=\"number\"],\n        [type=\"range\"]\n    ):is(\n        [min],\n        [max]\n    )\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_OUT_OF_RANGE | FLG_HTML)\n", "soupsieve/__meta__.py": "\"\"\"Meta related things.\"\"\"\nfrom __future__ import annotations\nfrom collections import namedtuple\nimport re\n\nRE_VER = re.compile(\n    r'''(?x)\n    (?P<major>\\d+)(?:\\.(?P<minor>\\d+))?(?:\\.(?P<micro>\\d+))?\n    (?:(?P<type>a|b|rc)(?P<pre>\\d+))?\n    (?:\\.post(?P<post>\\d+))?\n    (?:\\.dev(?P<dev>\\d+))?\n    '''\n)\n\nREL_MAP = {\n    \".dev\": \"\",\n    \".dev-alpha\": \"a\",\n    \".dev-beta\": \"b\",\n    \".dev-candidate\": \"rc\",\n    \"alpha\": \"a\",\n    \"beta\": \"b\",\n    \"candidate\": \"rc\",\n    \"final\": \"\"\n}\n\nDEV_STATUS = {\n    \".dev\": \"2 - Pre-Alpha\",\n    \".dev-alpha\": \"2 - Pre-Alpha\",\n    \".dev-beta\": \"2 - Pre-Alpha\",\n    \".dev-candidate\": \"2 - Pre-Alpha\",\n    \"alpha\": \"3 - Alpha\",\n    \"beta\": \"4 - Beta\",\n    \"candidate\": \"4 - Beta\",\n    \"final\": \"5 - Production/Stable\"\n}\n\nPRE_REL_MAP = {\"a\": 'alpha', \"b\": 'beta', \"rc\": 'candidate'}\n\n\nclass Version(namedtuple(\"Version\", [\"major\", \"minor\", \"micro\", \"release\", \"pre\", \"post\", \"dev\"])):\n    \"\"\"\n    Get the version (PEP 440).\n\n    A biased approach to the PEP 440 semantic version.\n\n    Provides a tuple structure which is sorted for comparisons `v1 > v2` etc.\n      (major, minor, micro, release type, pre-release build, post-release build, development release build)\n    Release types are named in is such a way they are comparable with ease.\n    Accessors to check if a development, pre-release, or post-release build. Also provides accessor to get\n    development status for setup files.\n\n    How it works (currently):\n\n    - You must specify a release type as either `final`, `alpha`, `beta`, or `candidate`.\n    - To define a development release, you can use either `.dev`, `.dev-alpha`, `.dev-beta`, or `.dev-candidate`.\n      The dot is used to ensure all development specifiers are sorted before `alpha`.\n      You can specify a `dev` number for development builds, but do not have to as implicit development releases\n      are allowed.\n    - You must specify a `pre` value greater than zero if using a prerelease as this project (not PEP 440) does not\n      allow implicit prereleases.\n    - You can optionally set `post` to a value greater than zero to make the build a post release. While post releases\n      are technically allowed in prereleases, it is strongly discouraged, so we are rejecting them. It should be\n      noted that we do not allow `post0` even though PEP 440 does not restrict this. This project specifically\n      does not allow implicit post releases.\n    - It should be noted that we do not support epochs `1!` or local versions `+some-custom.version-1`.\n\n    Acceptable version releases:\n\n    ```\n    Version(1, 0, 0, \"final\")                    1.0\n    Version(1, 2, 0, \"final\")                    1.2\n    Version(1, 2, 3, \"final\")                    1.2.3\n    Version(1, 2, 0, \".dev-alpha\", pre=4)        1.2a4\n    Version(1, 2, 0, \".dev-beta\", pre=4)         1.2b4\n    Version(1, 2, 0, \".dev-candidate\", pre=4)    1.2rc4\n    Version(1, 2, 0, \"final\", post=1)            1.2.post1\n    Version(1, 2, 3, \".dev\")                     1.2.3.dev0\n    Version(1, 2, 3, \".dev\", dev=1)              1.2.3.dev1\n    ```\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        major: int, minor: int, micro: int, release: str = \"final\",\n        pre: int = 0, post: int = 0, dev: int = 0\n    ) -> Version:\n        \"\"\"Validate version info.\"\"\"\n\n        # Ensure all parts are positive integers.\n        for value in (major, minor, micro, pre, post):\n            if not (isinstance(value, int) and value >= 0):\n                raise ValueError(\"All version parts except 'release' should be integers.\")\n\n        if release not in REL_MAP:\n            raise ValueError(f\"'{release}' is not a valid release type.\")\n\n        # Ensure valid pre-release (we do not allow implicit pre-releases).\n        if \".dev-candidate\" < release < \"final\":\n            if pre == 0:\n                raise ValueError(\"Implicit pre-releases not allowed.\")\n            elif dev:\n                raise ValueError(\"Version is not a development release.\")\n            elif post:\n                raise ValueError(\"Post-releases are not allowed with pre-releases.\")\n\n        # Ensure valid development or development/pre release\n        elif release < \"alpha\":\n            if release > \".dev\" and pre == 0:\n                raise ValueError(\"Implicit pre-release not allowed.\")\n            elif post:\n                raise ValueError(\"Post-releases are not allowed with pre-releases.\")\n\n        # Ensure a valid normal release\n        else:\n            if pre:\n                raise ValueError(\"Version is not a pre-release.\")\n            elif dev:\n                raise ValueError(\"Version is not a development release.\")\n\n        return super().__new__(cls, major, minor, micro, release, pre, post, dev)\n\n    def _is_pre(self) -> bool:\n        \"\"\"Is prerelease.\"\"\"\n\n        return bool(self.pre > 0)\n\n    def _is_dev(self) -> bool:\n        \"\"\"Is development.\"\"\"\n\n        return bool(self.release < \"alpha\")\n\n    def _is_post(self) -> bool:\n        \"\"\"Is post.\"\"\"\n\n        return bool(self.post > 0)\n\n    def _get_dev_status(self) -> str:  # pragma: no cover\n        \"\"\"Get development status string.\"\"\"\n\n        return DEV_STATUS[self.release]\n\n    def _get_canonical(self) -> str:\n        \"\"\"Get the canonical output string.\"\"\"\n\n        # Assemble major, minor, micro version and append `pre`, `post`, or `dev` if needed..\n        if self.micro == 0:\n            ver = f\"{self.major}.{self.minor}\"\n        else:\n            ver = f\"{self.major}.{self.minor}.{self.micro}\"\n        if self._is_pre():\n            ver += f'{REL_MAP[self.release]}{self.pre}'\n        if self._is_post():\n            ver += f\".post{self.post}\"\n        if self._is_dev():\n            ver += f\".dev{self.dev}\"\n\n        return ver\n\n\ndef parse_version(ver: str) -> Version:\n    \"\"\"Parse version into a comparable Version tuple.\"\"\"\n\n    m = RE_VER.match(ver)\n\n    if m is None:\n        raise ValueError(f\"'{ver}' is not a valid version\")\n\n    # Handle major, minor, micro\n    major = int(m.group('major'))\n    minor = int(m.group('minor')) if m.group('minor') else 0\n    micro = int(m.group('micro')) if m.group('micro') else 0\n\n    # Handle pre releases\n    if m.group('type'):\n        release = PRE_REL_MAP[m.group('type')]\n        pre = int(m.group('pre'))\n    else:\n        release = \"final\"\n        pre = 0\n\n    # Handle development releases\n    dev = m.group('dev') if m.group('dev') else 0\n    if m.group('dev'):\n        dev = int(m.group('dev'))\n        release = '.dev-' + release if pre else '.dev'\n    else:\n        dev = 0\n\n    # Handle post\n    post = int(m.group('post')) if m.group('post') else 0\n\n    return Version(major, minor, micro, release, pre, post, dev)\n\n\n__version_info__ = Version(2, 5, 0, \"final\")\n__version__ = __version_info__._get_canonical()\n", "soupsieve/util.py": "\"\"\"Utility.\"\"\"\nfrom __future__ import annotations\nfrom functools import wraps, lru_cache\nimport warnings\nimport re\nfrom typing import Callable, Any\n\nDEBUG = 0x00001\n\nRE_PATTERN_LINE_SPLIT = re.compile(r'(?:\\r\\n|(?!\\r\\n)[\\n\\r])|$')\n\nUC_A = ord('A')\nUC_Z = ord('Z')\n\n\n@lru_cache(maxsize=512)\ndef lower(string: str) -> str:\n    \"\"\"Lower.\"\"\"\n\n    new_string = []\n    for c in string:\n        o = ord(c)\n        new_string.append(chr(o + 32) if UC_A <= o <= UC_Z else c)\n    return ''.join(new_string)\n\n\nclass SelectorSyntaxError(Exception):\n    \"\"\"Syntax error in a CSS selector.\"\"\"\n\n    def __init__(self, msg: str, pattern: str | None = None, index: int | None = None) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.line = None\n        self.col = None\n        self.context = None\n\n        if pattern is not None and index is not None:\n            # Format pattern to show line and column position\n            self.context, self.line, self.col = get_pattern_context(pattern, index)\n            msg = f'{msg}\\n  line {self.line}:\\n{self.context}'\n\n        super().__init__(msg)\n\n\ndef deprecated(message: str, stacklevel: int = 2) -> Callable[..., Any]:  # pragma: no cover\n    \"\"\"\n    Raise a `DeprecationWarning` when wrapped function/method is called.\n\n    Usage:\n\n        @deprecated(\"This method will be removed in version X; use Y instead.\")\n        def some_method()\"\n            pass\n    \"\"\"\n\n    def _wrapper(func: Callable[..., Any]) -> Callable[..., Any]:\n        @wraps(func)\n        def _deprecated_func(*args: Any, **kwargs: Any) -> Any:\n            warnings.warn(\n                f\"'{func.__name__}' is deprecated. {message}\",\n                category=DeprecationWarning,\n                stacklevel=stacklevel\n            )\n            return func(*args, **kwargs)\n        return _deprecated_func\n    return _wrapper\n\n\ndef warn_deprecated(message: str, stacklevel: int = 2) -> None:  # pragma: no cover\n    \"\"\"Warn deprecated.\"\"\"\n\n    warnings.warn(\n        message,\n        category=DeprecationWarning,\n        stacklevel=stacklevel\n    )\n\n\ndef get_pattern_context(pattern: str, index: int) -> tuple[str, int, int]:\n    \"\"\"Get the pattern context.\"\"\"\n\n    last = 0\n    current_line = 1\n    col = 1\n    text = []  # type: list[str]\n    line = 1\n    offset = None  # type: int | None\n\n    # Split pattern by newline and handle the text before the newline\n    for m in RE_PATTERN_LINE_SPLIT.finditer(pattern):\n        linetext = pattern[last:m.start(0)]\n        if not len(m.group(0)) and not len(text):\n            indent = ''\n            offset = -1\n            col = index - last + 1\n        elif last <= index < m.end(0):\n            indent = '--> '\n            offset = (-1 if index > m.start(0) else 0) + 3\n            col = index - last + 1\n        else:\n            indent = '    '\n            offset = None\n        if len(text):\n            # Regardless of whether we are presented with `\\r\\n`, `\\r`, or `\\n`,\n            # we will render the output with just `\\n`. We will still log the column\n            # correctly though.\n            text.append('\\n')\n        text.append(f'{indent}{linetext}')\n        if offset is not None:\n            text.append('\\n')\n            text.append(' ' * (col + offset) + '^')\n            line = current_line\n\n        current_line += 1\n        last = m.end(0)\n\n    return ''.join(text), line, col\n", "soupsieve/__init__.py": "\"\"\"\nSoup Sieve.\n\nA CSS selector filter for BeautifulSoup4.\n\nMIT License\n\nCopyright (c) 2018 Isaac Muse\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\nfrom __future__ import annotations\nfrom .__meta__ import __version__, __version_info__  # noqa: F401\nfrom . import css_parser as cp\nfrom . import css_match as cm\nfrom . import css_types as ct\nfrom .util import DEBUG, SelectorSyntaxError  # noqa: F401\nimport bs4  # type: ignore[import]\nfrom typing import Any, Iterator, Iterable\n\n__all__ = (\n    'DEBUG', 'SelectorSyntaxError', 'SoupSieve',\n    'closest', 'compile', 'filter', 'iselect',\n    'match', 'select', 'select_one'\n)\n\nSoupSieve = cm.SoupSieve\n\n\ndef compile(  # noqa: A001\n    pattern: str,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> cm.SoupSieve:\n    \"\"\"Compile CSS pattern.\"\"\"\n\n    if isinstance(pattern, SoupSieve):\n        if flags:\n            raise ValueError(\"Cannot process 'flags' argument on a compiled selector list\")\n        elif namespaces is not None:\n            raise ValueError(\"Cannot process 'namespaces' argument on a compiled selector list\")\n        elif custom is not None:\n            raise ValueError(\"Cannot process 'custom' argument on a compiled selector list\")\n        return pattern\n\n    return cp._cached_css_compile(\n        pattern,\n        ct.Namespaces(namespaces) if namespaces is not None else namespaces,\n        ct.CustomSelectors(custom) if custom is not None else custom,\n        flags\n    )\n\n\ndef purge() -> None:\n    \"\"\"Purge cached patterns.\"\"\"\n\n    cp._purge_cache()\n\n\ndef closest(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> bs4.Tag:\n    \"\"\"Match closest ancestor.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).closest(tag)\n\n\ndef match(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> bool:\n    \"\"\"Match node.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).match(tag)\n\n\ndef filter(  # noqa: A001\n    select: str,\n    iterable: Iterable[bs4.Tag],\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> list[bs4.Tag]:\n    \"\"\"Filter list of nodes.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).filter(iterable)\n\n\ndef select_one(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> bs4.Tag:\n    \"\"\"Select a single tag.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).select_one(tag)\n\n\ndef select(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    limit: int = 0,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> list[bs4.Tag]:\n    \"\"\"Select the specified tags.\"\"\"\n\n    return compile(select, namespaces, flags, **kwargs).select(tag, limit)\n\n\ndef iselect(\n    select: str,\n    tag: bs4.Tag,\n    namespaces: dict[str, str] | None = None,\n    limit: int = 0,\n    flags: int = 0,\n    *,\n    custom: dict[str, str] | None = None,\n    **kwargs: Any\n) -> Iterator[bs4.Tag]:\n    \"\"\"Iterate the specified tags.\"\"\"\n\n    yield from compile(select, namespaces, flags, **kwargs).iselect(tag, limit)\n\n\ndef escape(ident: str) -> str:\n    \"\"\"Escape identifier.\"\"\"\n\n    return cp.escape(ident)\n"}