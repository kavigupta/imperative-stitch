{"setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport re\n\nfrom setuptools import setup\n\n\n# Get the version\nversion_regex = r'__version__ = [\"\\']([^\"\\']*)[\"\\']'\nwith open(\"requests_oauthlib/__init__.py\", \"r\") as f:\n    text = f.read()\n    match = re.search(version_regex, text)\n\n    if match:\n        VERSION = match.group(1)\n    else:\n        raise RuntimeError(\"No version number found!\")\n\n\nAPP_NAME = \"requests-oauthlib\"\n\n# Publish Helper.\nif sys.argv[-1] == \"publish\":\n    os.system(\"python setup.py sdist upload\")\n    sys.exit()\n\n\ndef readall(path):\n    with open(path) as fp:\n        return fp.read()\n\n\nsetup(\n    name=APP_NAME,\n    version=VERSION,\n    description=\"OAuthlib authentication support for Requests.\",\n    long_description=readall(\"README.rst\") + \"\\n\\n\" + readall(\"HISTORY.rst\"),\n    long_description_content_type=\"text/x-rst\",\n    author=\"Kenneth Reitz\",\n    author_email=\"me@kennethreitz.com\",\n    url=\"https://github.com/requests/requests-oauthlib\",\n    packages=[\"requests_oauthlib\", \"requests_oauthlib.compliance_fixes\"],\n    python_requires=\">=3.7\",\n    install_requires=[\"oauthlib>=3.0.0\", \"requests>=2.0.0\"],\n    extras_require={\"rsa\": [\"oauthlib[signedtoken]>=3.0.0\"]},\n    license=\"ISC\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Natural Language :: English\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n    ],\n    zip_safe=False,\n    tests_require=['mock;python_version<\"3.3\"', \"requests-mock\"],\n    test_suite=\"tests\",\n)\n", "docs/conf.py": "# -*- coding: utf-8 -*-\n#\n# Requests-OAuthlib documentation build configuration file, created by\n# sphinx-quickstart on Fri May 10 11:49:01 2013.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport os\nimport sys\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\"..\"))\nfrom requests_oauthlib import __version__ # noqa: E402\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\"sphinx.ext.autodoc\", \"sphinx.ext.intersphinx\"]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"Requests-OAuthlib\"\ncopyright = \"2014, Kenneth Reitz\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = __version__\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"sphinx_rtd_theme\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = [\"_static\"]\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"Requests-OAuthlibdoc\"\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\n        \"index\",\n        \"Requests-OAuthlib.tex\",\n        \"Requests-OAuthlib Documentation\",\n        \"Requests-OAuthlib Contributors\",\n        \"manual\",\n    )\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\n        \"index\",\n        \"requests-oauthlib\",\n        \"Requests-OAuthlib Documentation\",\n        [\"Requests-OAuthlib Contributors\"],\n        1,\n    )\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        \"index\",\n        \"Requests-OAuthlib\",\n        \"Requests-OAuthlib Documentation\",\n        \"Requests-OAuthlib Contributors\",\n        \"Requests-OAuthlib\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    )\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n# texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    \"python\": (\"https://python.readthedocs.io/en/latest/\", None),\n    \"requests\": (\"https://requests.readthedocs.io/en/latest/\", None),\n    \"oauthlib\": (\"https://oauthlib.readthedocs.io/en/latest/\", None),\n}\n", "docs/examples/native_spa_pkce_auth0.py": "\nclient_id = 'OAUTH_CLIENT_ID'\n\nauthorization_base_url = \"https://OAUTH_IDP_DOMAIN/authorize\"\ntoken_url = \"https://OAUTH_IDP_DOMAIN/oauth/token\"\nscope = [\"openid\"]\n\nfrom requests_oauthlib import OAuth2Session\nredirect_uri = 'http://localhost:8080/callback'\n\nsession = OAuth2Session(client_id, scope=scope, redirect_uri=redirect_uri, pkce=\"S256\")\nauthorization_url, state = session.authorization_url(authorization_base_url,access_type=\"offline\")\n\nprint(\"Please go here and authorize:\")\nprint(authorization_url)\n\nredirect_response = input('Paste the full redirect URL here: ')\n\ntoken = session.fetch_token(token_url, authorization_response=redirect_response, include_client_id=True)\nprint(token)\n", "tests/test_oauth2_auth.py": "import unittest\n\nfrom oauthlib.oauth2 import WebApplicationClient, MobileApplicationClient\nfrom oauthlib.oauth2 import LegacyApplicationClient, BackendApplicationClient\nfrom requests import Request\nfrom requests_oauthlib import OAuth2\n\n\nclass OAuth2AuthTest(unittest.TestCase):\n    def setUp(self):\n        self.token = {\n            \"token_type\": \"Bearer\",\n            \"access_token\": \"asdfoiw37850234lkjsdfsdf\",\n            \"expires_in\": \"3600\",\n        }\n        self.client_id = \"foo\"\n        self.clients = [\n            WebApplicationClient(self.client_id),\n            MobileApplicationClient(self.client_id),\n            LegacyApplicationClient(self.client_id),\n            BackendApplicationClient(self.client_id),\n        ]\n\n    def test_add_token_to_url(self):\n        url = \"https://example.com/resource?foo=bar\"\n        new_url = url + \"&access_token=\" + self.token[\"access_token\"]\n        for client in self.clients:\n            client.default_token_placement = \"query\"\n            auth = OAuth2(client=client, token=self.token)\n            r = Request(\"GET\", url, auth=auth).prepare()\n            self.assertEqual(r.url, new_url)\n\n    def test_add_token_to_headers(self):\n        token = \"Bearer \" + self.token[\"access_token\"]\n        for client in self.clients:\n            auth = OAuth2(client=client, token=self.token)\n            r = Request(\"GET\", \"https://i.b\", auth=auth).prepare()\n            self.assertEqual(r.headers[\"Authorization\"], token)\n\n    def test_add_token_to_body(self):\n        body = \"foo=bar\"\n        new_body = body + \"&access_token=\" + self.token[\"access_token\"]\n        for client in self.clients:\n            client.default_token_placement = \"body\"\n            auth = OAuth2(client=client, token=self.token)\n            r = Request(\"GET\", \"https://i.b\", data=body, auth=auth).prepare()\n            self.assertEqual(r.body, new_body)\n\n    def test_add_nonexisting_token(self):\n        for client in self.clients:\n            auth = OAuth2(client=client)\n            r = Request(\"GET\", \"https://i.b\", auth=auth)\n            self.assertRaises(ValueError, r.prepare)\n", "tests/test_oauth1_session.py": "import unittest\nimport requests\nfrom io import StringIO\nfrom unittest import mock\n\nfrom oauthlib.oauth1 import SIGNATURE_TYPE_QUERY, SIGNATURE_TYPE_BODY\nfrom oauthlib.oauth1 import SIGNATURE_RSA, SIGNATURE_PLAINTEXT\nfrom requests_oauthlib import OAuth1Session\n\ntry:\n    import cryptography\nexcept ImportError:\n    cryptography = None\n\ntry:\n    import jwt\nexcept ImportError:\n    jwt = None\n\n\nTEST_RSA_KEY = (\n    \"-----BEGIN RSA PRIVATE KEY-----\\n\"\n    \"MIIEogIBAAKCAQEApF1JaMSN8TEsh4N4O/5SpEAVLivJyLH+Cgl3OQBPGgJkt8cg\\n\"\n    \"49oasl+5iJS+VdrILxWM9/JCJyURpUuslX4Eb4eUBtQ0x5BaPa8+S2NLdGTaL7nB\\n\"\n    \"OO8o8n0C5FEUU+qlEip79KE8aqOj+OC44VsIquSmOvWIQD26n3fCVlgwoRBD1gzz\\n\"\n    \"sDOeaSyzpKrZR851Kh6rEmF2qjJ8jt6EkxMsRNACmBomzgA4M1TTsisSUO87444p\\n\"\n    \"e35Z4/n5c735o2fZMrGgMwiJNh7rT8SYxtIkxngioiGnwkxGQxQ4NzPAHg+XSY0J\\n\"\n    \"04pNm7KqTkgtxyrqOANJLIjXlR+U9SQ90NjHVQIDAQABAoIBABuBPOKaWcJt3yzC\\n\"\n    \"NGGduoif7KtwSnEaUA+v69KPGa2Zju8uFHPssKD+4dZYRc2qMeunKJLpaGaSjnRh\\n\"\n    \"yHyvvOBJCN1nr3lhz6gY5kzJTfwpUFXCOPJlGy4Q+2Xnp4YvcvYqQ9n5DVovDiZ8\\n\"\n    \"vJOBn16xqpudMPLHIa7D5LJ8SY76HBjE+imTXw1EShdh5TOV9bmPFQqH6JFzowRH\\n\"\n    \"hyH2DPHuyHJj6cl8FyqJw5lVWzG3n6Prvk7bYHsjmGjurN35UsumNAp6VouNyUP1\\n\"\n    \"RAEcUJega49aIs6/FJ0ENJzQjlsAzVbTleHkpez2aIok+wsWJGJ4SVxAjADOWAaZ\\n\"\n    \"uEJPc3UCgYEA1g4ZGrXOuo75p9/MRIepXGpBWxip4V7B9XmO9WzPCv8nMorJntWB\\n\"\n    \"msYV1I01aITxadHatO4Gl2xLniNkDyrEQzJ7w38RQgsVK+CqbnC0K9N77QPbHeC1\\n\"\n    \"YQd9RCNyUohOimKvb7jyv798FBU1GO5QI2eNgfnnfteSVXhD2iOoTOsCgYEAxJJ+\\n\"\n    \"8toxJdnLa0uUsAbql6zeNXGbUBMzu3FomKlyuWuq841jS2kIalaO/TRj5hbnE45j\\n\"\n    \"mCjeLgTVO6Ach3Wfk4zrqajqfFJ0zUg/Wexp49lC3RWiV4icBb85Q6bzeJD9Dn9v\\n\"\n    \"hjpfWVkczf/NeA1fGH/pcgfkT6Dm706GFFttLL8CgYBl/HeXk1H47xAiHO4dJKnb\\n\"\n    \"v0B+X8To/RXamF01r+8BpUoOubOQetdyX7ic+d6deuHu8i6LD/GSCeYJZYFR/KVg\\n\"\n    \"AtiW757QYalnq3ZogkhFrVCZP8IRfTPOFBxp752TlyAcrSI7T9pQ47IBe4094KXM\\n\"\n    \"CJWSfPgAJkOxd0iU0XJpmwKBgGfQxuMTgSlwYRKFlD1zKap5TdID8fbUbVnth0Q5\\n\"\n    \"GbH7vwlp/qrxCdS/aj0n0irOpbOaW9ccnlrHiqY25VpVMLYIkt3DrDOEiNNx+KNR\\n\"\n    \"TItdTwbcSiTYrS4L0/56ydM/H6bsfsXxRjI18hSJqMZiqXqS84OZz2aOn+h7HCzc\\n\"\n    \"LEiZAoGASk20wFvilpRKHq79xxFWiDUPHi0x0pp82dYIEntGQkKUWkbSlhgf3MAi\\n\"\n    \"5NEQTDmXdnB+rVeWIvEi+BXfdnNgdn8eC4zSdtF4sIAhYr5VWZo0WVWDhT7u2ccv\\n\"\n    \"ZBFymiz8lo3gN57wGUCi9pbZqzV1+ZppX6YTNDdDCE0q+KO3Cec=\\n\"\n    \"-----END RSA PRIVATE KEY-----\"\n)\n\nTEST_RSA_OAUTH_SIGNATURE = (\n    \"j8WF8PGjojT82aUDd2EL%2Bz7HCoHInFzWUpiEKMCy%2BJ2cYHWcBS7mXlmFDLgAKV0\"\n    \"P%2FyX4TrpXODYnJ6dRWdfghqwDpi%2FlQmB2jxCiGMdJoYxh3c5zDf26gEbGdP6D7O\"\n    \"Ssp5HUnzH6sNkmVjuE%2FxoJcHJdc23H6GhOs7VJ2LWNdbhKWP%2FMMlTrcoQDn8lz\"\n    \"%2Fb24WsJ6ae1txkUzpFOOlLM8aTdNtGL4OtsubOlRhNqnAFq93FyhXg0KjzUyIZzmMX\"\n    \"9Vx90jTks5QeBGYcLE0Op2iHb2u%2FO%2BEgdwFchgEwE5LgMUyHUI4F3Wglp28yHOAM\"\n    \"jPkI%2FkWMvpxtMrU3Z3KN31WQ%3D%3D\"\n)\n\n\nclass OAuth1SessionTest(unittest.TestCase):\n    def test_signature_types(self):\n        def verify_signature(getter):\n            def fake_send(r, **kwargs):\n                signature = getter(r)\n                if isinstance(signature, bytes):\n                    signature = signature.decode(\"utf-8\")\n                self.assertIn(\"oauth_signature\", signature)\n                resp = mock.MagicMock(spec=requests.Response)\n                resp.cookies = []\n                return resp\n\n            return fake_send\n\n        header = OAuth1Session(\"foo\")\n        header.send = verify_signature(lambda r: r.headers[\"Authorization\"])\n        header.post(\"https://i.b\")\n\n        query = OAuth1Session(\"foo\", signature_type=SIGNATURE_TYPE_QUERY)\n        query.send = verify_signature(lambda r: r.url)\n        query.post(\"https://i.b\")\n\n        body = OAuth1Session(\"foo\", signature_type=SIGNATURE_TYPE_BODY)\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        body.send = verify_signature(lambda r: r.body)\n        body.post(\"https://i.b\", headers=headers, data=\"\")\n\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_timestamp\")\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_nonce\")\n    def test_signature_methods(self, generate_nonce, generate_timestamp):\n        if not cryptography:\n            raise unittest.SkipTest(\"cryptography module is required\")\n        if not jwt:\n            raise unittest.SkipTest(\"pyjwt module is required\")\n\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"123\"\n\n        signature = 'OAuth oauth_nonce=\"abc\", oauth_timestamp=\"123\", oauth_version=\"1.0\", oauth_signature_method=\"HMAC-SHA1\", oauth_consumer_key=\"foo\", oauth_signature=\"h2sRqLArjhlc5p3FTkuNogVHlKE%3D\"'\n        auth = OAuth1Session(\"foo\")\n        auth.send = self.verify_signature(signature)\n        auth.post(\"https://i.b\")\n\n        signature = 'OAuth oauth_nonce=\"abc\", oauth_timestamp=\"123\", oauth_version=\"1.0\", oauth_signature_method=\"PLAINTEXT\", oauth_consumer_key=\"foo\", oauth_signature=\"%26\"'\n        auth = OAuth1Session(\"foo\", signature_method=SIGNATURE_PLAINTEXT)\n        auth.send = self.verify_signature(signature)\n        auth.post(\"https://i.b\")\n\n        signature = (\n            \"OAuth \"\n            'oauth_nonce=\"abc\", oauth_timestamp=\"123\", oauth_version=\"1.0\", '\n            'oauth_signature_method=\"RSA-SHA1\", oauth_consumer_key=\"foo\", '\n            'oauth_signature=\"{sig}\"'\n        ).format(sig=TEST_RSA_OAUTH_SIGNATURE)\n        auth = OAuth1Session(\n            \"foo\", signature_method=SIGNATURE_RSA, rsa_key=TEST_RSA_KEY\n        )\n        auth.send = self.verify_signature(signature)\n        auth.post(\"https://i.b\")\n\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_timestamp\")\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_nonce\")\n    def test_binary_upload(self, generate_nonce, generate_timestamp):\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"123\"\n        fake_xml = StringIO(\"hello world\")\n        headers = {\"Content-Type\": \"application/xml\"}\n        signature = 'OAuth oauth_nonce=\"abc\", oauth_timestamp=\"123\", oauth_version=\"1.0\", oauth_signature_method=\"HMAC-SHA1\", oauth_consumer_key=\"foo\", oauth_signature=\"h2sRqLArjhlc5p3FTkuNogVHlKE%3D\"'\n        auth = OAuth1Session(\"foo\")\n        auth.send = self.verify_signature(signature)\n        auth.post(\"https://i.b\", headers=headers, files=[(\"fake\", fake_xml)])\n\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_timestamp\")\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_nonce\")\n    def test_nonascii(self, generate_nonce, generate_timestamp):\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"123\"\n        signature = 'OAuth oauth_nonce=\"abc\", oauth_timestamp=\"123\", oauth_version=\"1.0\", oauth_signature_method=\"HMAC-SHA1\", oauth_consumer_key=\"foo\", oauth_signature=\"W0haoue5IZAZoaJiYCtfqwMf8x8%3D\"'\n        auth = OAuth1Session(\"foo\")\n        auth.send = self.verify_signature(signature)\n        auth.post(\"https://i.b?cjk=%E5%95%A6%E5%95%A6\")\n\n    def test_authorization_url(self):\n        auth = OAuth1Session(\"foo\")\n        url = \"https://example.comm/authorize\"\n        token = \"asluif023sf\"\n        auth_url = auth.authorization_url(url, request_token=token)\n        self.assertEqual(auth_url, url + \"?oauth_token=\" + token)\n\n    def test_parse_response_url(self):\n        url = \"https://i.b/callback?oauth_token=foo&oauth_verifier=bar\"\n        auth = OAuth1Session(\"foo\")\n        resp = auth.parse_authorization_response(url)\n        self.assertEqual(resp[\"oauth_token\"], \"foo\")\n        self.assertEqual(resp[\"oauth_verifier\"], \"bar\")\n        for k, v in resp.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n    def test_fetch_request_token(self):\n        auth = OAuth1Session(\"foo\")\n        auth.send = self.fake_body(\"oauth_token=foo\")\n        resp = auth.fetch_request_token(\"https://example.com/token\")\n        self.assertEqual(resp[\"oauth_token\"], \"foo\")\n        for k, v in resp.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n    def test_fetch_request_token_with_optional_arguments(self):\n        auth = OAuth1Session(\"foo\")\n        auth.send = self.fake_body(\"oauth_token=foo\")\n        resp = auth.fetch_request_token(\n            \"https://example.com/token\", verify=False, stream=True\n        )\n        self.assertEqual(resp[\"oauth_token\"], \"foo\")\n        for k, v in resp.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n    def test_fetch_access_token(self):\n        auth = OAuth1Session(\"foo\", verifier=\"bar\")\n        auth.send = self.fake_body(\"oauth_token=foo\")\n        resp = auth.fetch_access_token(\"https://example.com/token\")\n        self.assertEqual(resp[\"oauth_token\"], \"foo\")\n        for k, v in resp.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n    def test_fetch_access_token_with_optional_arguments(self):\n        auth = OAuth1Session(\"foo\", verifier=\"bar\")\n        auth.send = self.fake_body(\"oauth_token=foo\")\n        resp = auth.fetch_access_token(\n            \"https://example.com/token\", verify=False, stream=True\n        )\n        self.assertEqual(resp[\"oauth_token\"], \"foo\")\n        for k, v in resp.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n    def _test_fetch_access_token_raises_error(self, auth):\n        \"\"\"Assert that an error is being raised whenever there's no verifier\n        passed in to the client.\n        \"\"\"\n        auth.send = self.fake_body(\"oauth_token=foo\")\n        with self.assertRaises(ValueError) as cm:\n            auth.fetch_access_token(\"https://example.com/token\")\n        self.assertEqual(\"No client verifier has been set.\", str(cm.exception))\n\n    def test_fetch_token_invalid_response(self):\n        auth = OAuth1Session(\"foo\")\n        auth.send = self.fake_body(\"not valid urlencoded response!\")\n        self.assertRaises(\n            ValueError, auth.fetch_request_token, \"https://example.com/token\"\n        )\n\n        for code in (400, 401, 403):\n            auth.send = self.fake_body(\"valid=response\", code)\n            with self.assertRaises(ValueError) as cm:\n                auth.fetch_request_token(\"https://example.com/token\")\n            self.assertEqual(cm.exception.status_code, code)\n            self.assertIsInstance(cm.exception.response, requests.Response)\n\n    def test_fetch_access_token_missing_verifier(self):\n        self._test_fetch_access_token_raises_error(OAuth1Session(\"foo\"))\n\n    def test_fetch_access_token_has_verifier_is_none(self):\n        auth = OAuth1Session(\"foo\")\n        del auth._client.client.verifier\n        self._test_fetch_access_token_raises_error(auth)\n\n    def test_token_proxy_set(self):\n        token = {\n            \"oauth_token\": \"fake-key\",\n            \"oauth_token_secret\": \"fake-secret\",\n            \"oauth_verifier\": \"fake-verifier\",\n        }\n        sess = OAuth1Session(\"foo\")\n        self.assertIsNone(sess._client.client.resource_owner_key)\n        self.assertIsNone(sess._client.client.resource_owner_secret)\n        self.assertIsNone(sess._client.client.verifier)\n        self.assertEqual(sess.token, {})\n\n        sess.token = token\n        self.assertEqual(sess._client.client.resource_owner_key, \"fake-key\")\n        self.assertEqual(sess._client.client.resource_owner_secret, \"fake-secret\")\n        self.assertEqual(sess._client.client.verifier, \"fake-verifier\")\n\n    def test_token_proxy_get(self):\n        token = {\n            \"oauth_token\": \"fake-key\",\n            \"oauth_token_secret\": \"fake-secret\",\n            \"oauth_verifier\": \"fake-verifier\",\n        }\n        sess = OAuth1Session(\n            \"foo\",\n            resource_owner_key=token[\"oauth_token\"],\n            resource_owner_secret=token[\"oauth_token_secret\"],\n            verifier=token[\"oauth_verifier\"],\n        )\n        self.assertEqual(sess.token, token)\n\n        sess._client.client.resource_owner_key = \"different-key\"\n        token[\"oauth_token\"] = \"different-key\"\n\n        self.assertEqual(sess.token, token)\n\n    def test_authorized_false(self):\n        sess = OAuth1Session(\"foo\")\n        self.assertIs(sess.authorized, False)\n\n    def test_authorized_false_rsa(self):\n        signature = (\n            \"OAuth \"\n            'oauth_nonce=\"abc\", oauth_timestamp=\"123\", oauth_version=\"1.0\", '\n            'oauth_signature_method=\"RSA-SHA1\", oauth_consumer_key=\"foo\", '\n            'oauth_signature=\"{sig}\"'\n        ).format(sig=TEST_RSA_OAUTH_SIGNATURE)\n        sess = OAuth1Session(\n            \"foo\", signature_method=SIGNATURE_RSA, rsa_key=TEST_RSA_KEY\n        )\n        sess.send = self.verify_signature(signature)\n        self.assertIs(sess.authorized, False)\n\n    def test_authorized_true(self):\n        sess = OAuth1Session(\"key\", \"secret\", verifier=\"bar\")\n        sess.send = self.fake_body(\"oauth_token=foo&oauth_token_secret=bar\")\n        sess.fetch_access_token(\"https://example.com/token\")\n        self.assertIs(sess.authorized, True)\n\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_timestamp\")\n    @mock.patch(\"oauthlib.oauth1.rfc5849.generate_nonce\")\n    def test_authorized_true_rsa(self, generate_nonce, generate_timestamp):\n        if not cryptography:\n            raise unittest.SkipTest(\"cryptography module is required\")\n        if not jwt:\n            raise unittest.SkipTest(\"pyjwt module is required\")\n\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"123\"\n        sess = OAuth1Session(\n            \"key\",\n            \"secret\",\n            signature_method=SIGNATURE_RSA,\n            rsa_key=TEST_RSA_KEY,\n            verifier=\"bar\",\n        )\n        sess.send = self.fake_body(\"oauth_token=foo&oauth_token_secret=bar\")\n        sess.fetch_access_token(\"https://example.com/token\")\n        self.assertIs(sess.authorized, True)\n\n    def verify_signature(self, signature):\n        def fake_send(r, **kwargs):\n            auth_header = r.headers[\"Authorization\"]\n            if isinstance(auth_header, bytes):\n                auth_header = auth_header.decode(\"utf-8\")\n            self.assertEqual(auth_header, signature)\n            resp = mock.MagicMock(spec=requests.Response)\n            resp.cookies = []\n            return resp\n\n        return fake_send\n\n    def fake_body(self, body, status_code=200):\n        def fake_send(r, **kwargs):\n            resp = mock.MagicMock(spec=requests.Response)\n            resp.cookies = []\n            resp.text = body\n            resp.status_code = status_code\n            return resp\n\n        return fake_send\n", "tests/test_compliance_fixes.py": "from unittest import TestCase\n\nimport requests\nimport requests_mock\nimport time\n\nfrom urllib.parse import urlparse, parse_qs\n\nfrom oauthlib.oauth2.rfc6749.errors import InvalidGrantError\nfrom requests_oauthlib import OAuth2Session\nfrom requests_oauthlib.compliance_fixes import facebook_compliance_fix\nfrom requests_oauthlib.compliance_fixes import fitbit_compliance_fix\nfrom requests_oauthlib.compliance_fixes import mailchimp_compliance_fix\nfrom requests_oauthlib.compliance_fixes import weibo_compliance_fix\nfrom requests_oauthlib.compliance_fixes import slack_compliance_fix\nfrom requests_oauthlib.compliance_fixes import instagram_compliance_fix\nfrom requests_oauthlib.compliance_fixes import plentymarkets_compliance_fix\nfrom requests_oauthlib.compliance_fixes import ebay_compliance_fix\n\n\nclass FacebookComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://graph.facebook.com/oauth/access_token\",\n            text=\"access_token=urlencoded\",\n            headers={\"Content-Type\": \"text/plain\"},\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        facebook = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = facebook_compliance_fix(facebook)\n\n    def test_fetch_access_token(self):\n        token = self.session.fetch_token(\n            \"https://graph.facebook.com/oauth/access_token\",\n            client_secret=\"someclientsecret\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n        self.assertEqual(token, {\"access_token\": \"urlencoded\", \"token_type\": \"Bearer\"})\n\n\nclass FitbitComplianceFixTest(TestCase):\n    def setUp(self):\n        self.mocker = requests_mock.Mocker()\n        self.mocker.post(\n            \"https://api.fitbit.com/oauth2/token\",\n            json={\"errors\": [{\"errorType\": \"invalid_grant\"}]},\n        )\n        self.mocker.start()\n        self.addCleanup(self.mocker.stop)\n\n        fitbit = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = fitbit_compliance_fix(fitbit)\n\n    def test_fetch_access_token(self):\n        self.assertRaises(\n            InvalidGrantError,\n            self.session.fetch_token,\n            \"https://api.fitbit.com/oauth2/token\",\n            client_secret=\"someclientsecret\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n\n        self.mocker.post(\n            \"https://api.fitbit.com/oauth2/token\", json={\"access_token\": \"fitbit\"}\n        )\n\n        token = self.session.fetch_token(\n            \"https://api.fitbit.com/oauth2/token\", client_secret=\"good\"\n        )\n\n        self.assertEqual(token, {\"access_token\": \"fitbit\"})\n\n    def test_refresh_token(self):\n        self.assertRaises(\n            InvalidGrantError,\n            self.session.refresh_token,\n            \"https://api.fitbit.com/oauth2/token\",\n            auth=requests.auth.HTTPBasicAuth(\"someclientid\", \"someclientsecret\"),\n        )\n\n        self.mocker.post(\n            \"https://api.fitbit.com/oauth2/token\",\n            json={\"access_token\": \"access\", \"refresh_token\": \"refresh\"},\n        )\n\n        token = self.session.refresh_token(\n            \"https://api.fitbit.com/oauth2/token\",\n            auth=requests.auth.HTTPBasicAuth(\"someclientid\", \"someclientsecret\"),\n        )\n\n        self.assertEqual(token[\"access_token\"], \"access\")\n        self.assertEqual(token[\"refresh_token\"], \"refresh\")\n\n\nclass MailChimpComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://login.mailchimp.com/oauth2/token\",\n            json={\"access_token\": \"mailchimp\", \"expires_in\": 0, \"scope\": None},\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        mailchimp = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = mailchimp_compliance_fix(mailchimp)\n\n    def test_fetch_access_token(self):\n        token = self.session.fetch_token(\n            \"https://login.mailchimp.com/oauth2/token\",\n            client_secret=\"someclientsecret\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n        # Times should be close\n        approx_expires_at = time.time() + 3600\n        actual_expires_at = token.pop(\"expires_at\")\n        self.assertAlmostEqual(actual_expires_at, approx_expires_at, places=2)\n\n        # Other token values exact\n        self.assertEqual(token, {\"access_token\": \"mailchimp\", \"expires_in\": 3600})\n\n        # And no scope at all\n        self.assertNotIn(\"scope\", token)\n\n\nclass WeiboComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://api.weibo.com/oauth2/access_token\", json={\"access_token\": \"weibo\"}\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        weibo = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = weibo_compliance_fix(weibo)\n\n    def test_fetch_access_token(self):\n        token = self.session.fetch_token(\n            \"https://api.weibo.com/oauth2/access_token\",\n            client_secret=\"someclientsecret\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n        self.assertEqual(token, {\"access_token\": \"weibo\", \"token_type\": \"Bearer\"})\n\n\nclass SlackComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://slack.com/api/oauth.access\",\n            json={\"access_token\": \"xoxt-23984754863-2348975623103\", \"scope\": \"read\"},\n        )\n        for method in (\"GET\", \"POST\"):\n            mocker.request(\n                method=method,\n                url=\"https://slack.com/api/auth.test\",\n                json={\n                    \"ok\": True,\n                    \"url\": \"https://myteam.slack.com/\",\n                    \"team\": \"My Team\",\n                    \"user\": \"cal\",\n                    \"team_id\": \"T12345\",\n                    \"user_id\": \"U12345\",\n                },\n            )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        slack = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = slack_compliance_fix(slack)\n\n    def test_protected_request(self):\n        self.session.token = {\"access_token\": \"dummy-access-token\"}\n        response = self.session.get(\"https://slack.com/api/auth.test\")\n        url = response.request.url\n        query = parse_qs(urlparse(url).query)\n        self.assertNotIn(\"token\", query)\n        body = response.request.body\n        data = parse_qs(body)\n        self.assertEqual(data[\"token\"], [\"dummy-access-token\"])\n\n    def test_protected_request_override_token_get(self):\n        self.session.token = {\"access_token\": \"dummy-access-token\"}\n        response = self.session.get(\n            \"https://slack.com/api/auth.test\", data={\"token\": \"different-token\"}\n        )\n        url = response.request.url\n        query = parse_qs(urlparse(url).query)\n        self.assertNotIn(\"token\", query)\n        body = response.request.body\n        data = parse_qs(body)\n        self.assertEqual(data[\"token\"], [\"different-token\"])\n\n    def test_protected_request_override_token_post(self):\n        self.session.token = {\"access_token\": \"dummy-access-token\"}\n        response = self.session.post(\n            \"https://slack.com/api/auth.test\", data={\"token\": \"different-token\"}\n        )\n        url = response.request.url\n        query = parse_qs(urlparse(url).query)\n        self.assertNotIn(\"token\", query)\n        body = response.request.body\n        data = parse_qs(body)\n        self.assertEqual(data[\"token\"], [\"different-token\"])\n\n    def test_protected_request_override_token_url(self):\n        self.session.token = {\"access_token\": \"dummy-access-token\"}\n        response = self.session.get(\n            \"https://slack.com/api/auth.test?token=different-token\"\n        )\n        url = response.request.url\n        query = parse_qs(urlparse(url).query)\n        self.assertEqual(query[\"token\"], [\"different-token\"])\n        self.assertIsNone(response.request.body)\n\n\nclass InstagramComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.request(\n            method=\"GET\",\n            url=\"https://api.instagram.com/v1/users/self\",\n            json={\n                \"data\": {\n                    \"id\": \"1574083\",\n                    \"username\": \"snoopdogg\",\n                    \"full_name\": \"Snoop Dogg\",\n                    \"profile_picture\": \"http://distillery.s3.amazonaws.com/profiles/profile_1574083_75sq_1295469061.jpg\",\n                    \"bio\": \"This is my bio\",\n                    \"website\": \"http://snoopdogg.com\",\n                    \"is_business\": False,\n                    \"counts\": {\"media\": 1320, \"follows\": 420, \"followed_by\": 3410},\n                }\n            },\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        instagram = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = instagram_compliance_fix(instagram)\n\n    def test_protected_request(self):\n        self.session.token = {\"access_token\": \"dummy-access-token\"}\n        response = self.session.get(\"https://api.instagram.com/v1/users/self\")\n        url = response.request.url\n        query = parse_qs(urlparse(url).query)\n        self.assertIn(\"access_token\", query)\n        self.assertEqual(query[\"access_token\"], [\"dummy-access-token\"])\n\n    def test_protected_request_dont_override(self):\n        \"\"\"check that if the access_token param\n        already exist we don't override it\"\"\"\n        self.session.token = {\"access_token\": \"dummy-access-token\"}\n        response = self.session.get(\n            \"https://api.instagram.com/v1/users/self?access_token=correct-access-token\"\n        )\n        url = response.request.url\n        query = parse_qs(urlparse(url).query)\n        self.assertIn(\"access_token\", query)\n        self.assertEqual(query[\"access_token\"], [\"correct-access-token\"])\n\n\nclass PlentymarketsComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://shop.plentymarkets-cloud02.com\",\n            json={\n                \"accessToken\": \"ecUN1r8KhJewMCdLAmpHOdZ4O0ofXKB9zf6CXK61\",\n                \"tokenType\": \"Bearer\",\n                \"expiresIn\": 86400,\n                \"refreshToken\": \"iG2kBGIjcXaRE4xmTVUnv7xwxX7XMcWCHqJmFaSX\",\n            },\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        plentymarkets = OAuth2Session(\"someclientid\", redirect_uri=\"https://i.b\")\n        self.session = plentymarkets_compliance_fix(plentymarkets)\n\n    def test_fetch_access_token(self):\n        token = self.session.fetch_token(\n            \"https://shop.plentymarkets-cloud02.com\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n\n        approx_expires_at = time.time() + 86400\n        actual_expires_at = token.pop(\"expires_at\")\n        self.assertAlmostEqual(actual_expires_at, approx_expires_at, places=2)\n\n        self.assertEqual(\n            token,\n            {\n                \"access_token\": \"ecUN1r8KhJewMCdLAmpHOdZ4O0ofXKB9zf6CXK61\",\n                \"expires_in\": 86400,\n                \"token_type\": \"Bearer\",\n                \"refresh_token\": \"iG2kBGIjcXaRE4xmTVUnv7xwxX7XMcWCHqJmFaSX\",\n            },\n        )\n\n\nclass EbayComplianceFixTest(TestCase):\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://api.ebay.com/identity/v1/oauth2/token\",\n            json={\n                \"access_token\": \"this is the access token\",\n                \"expires_in\": 7200,\n                \"token_type\": \"Application Access Token\",\n            },\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        session = OAuth2Session()\n        self.fixed_session = ebay_compliance_fix(session)\n\n    def test_fetch_access_token(self):\n        token = self.fixed_session.fetch_token(\n            \"https://api.ebay.com/identity/v1/oauth2/token\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n        assert token[\"token_type\"] == \"Bearer\"\n\n\ndef access_and_refresh_token_request_compliance_fix_test(session, client_secret):\n    def _non_compliant_header(url, headers, body):\n        headers[\"X-Client-Secret\"] = client_secret\n        return url, headers, body\n\n    session.register_compliance_hook(\"access_token_request\", _non_compliant_header)\n    session.register_compliance_hook(\"refresh_token_request\", _non_compliant_header)\n    return session\n\n\nclass RefreshTokenRequestComplianceFixTest(TestCase):\n    value_to_test_for = \"value_to_test_for\"\n\n    def setUp(self):\n        mocker = requests_mock.Mocker()\n        mocker.post(\n            \"https://example.com/token\",\n            request_headers={\"X-Client-Secret\": self.value_to_test_for},\n            json={\n                \"access_token\": \"this is the access token\",\n                \"expires_in\": 7200,\n                \"token_type\": \"Bearer\",\n            },\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        mocker.post(\n            \"https://example.com/refresh\",\n            request_headers={\"X-Client-Secret\": self.value_to_test_for},\n            json={\n                \"access_token\": \"this is the access token\",\n                \"expires_in\": 7200,\n                \"token_type\": \"Bearer\",\n            },\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        mocker.start()\n        self.addCleanup(mocker.stop)\n\n        session = OAuth2Session()\n        self.fixed_session = access_and_refresh_token_request_compliance_fix_test(\n            session, self.value_to_test_for\n        )\n\n    def test_access_token(self):\n        token = self.fixed_session.fetch_token(\n            \"https://example.com/token\",\n            authorization_response=\"https://i.b/?code=hello\",\n        )\n        assert token[\"token_type\"] == \"Bearer\"\n\n    def test_refresh_token(self):\n        token = self.fixed_session.refresh_token(\n            \"https://example.com/refresh\",\n        )\n        assert token[\"token_type\"] == \"Bearer\"\n", "tests/test_core.py": "# -*- coding: utf-8 -*-\nimport requests\nimport requests_oauthlib\nimport oauthlib\nimport os.path\nfrom io import StringIO\nimport unittest\n\nfrom unittest import mock\n\n\n@mock.patch(\"oauthlib.oauth1.rfc5849.generate_timestamp\")\n@mock.patch(\"oauthlib.oauth1.rfc5849.generate_nonce\")\nclass OAuth1Test(unittest.TestCase):\n    def testFormEncoded(self, generate_nonce, generate_timestamp):\n        \"\"\"OAuth1 assumes form encoded if content type is not specified.\"\"\"\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"1\"\n        oauth = requests_oauthlib.OAuth1(\"client_key\")\n        headers = {\"Content-type\": \"application/x-www-form-urlencoded\"}\n        r = requests.Request(\n            method=\"POST\",\n            url=\"http://a.b/path?query=retain\",\n            auth=oauth,\n            data=\"this=really&is=&+form=encoded\",\n            headers=headers,\n        )\n        a = r.prepare()\n\n        self.assertEqual(a.url, \"http://a.b/path?query=retain\")\n        self.assertEqual(a.body, b\"this=really&is=&+form=encoded\")\n        self.assertEqual(\n            a.headers.get(\"Content-Type\"), b\"application/x-www-form-urlencoded\"\n        )\n\n        # guess content-type\n        r = requests.Request(\n            method=\"POST\",\n            url=\"http://a.b/path?query=retain\",\n            auth=oauth,\n            data=\"this=really&is=&+form=encoded\",\n        )\n        b = r.prepare()\n        self.assertEqual(b.url, \"http://a.b/path?query=retain\")\n        self.assertEqual(b.body, b\"this=really&is=&+form=encoded\")\n        self.assertEqual(\n            b.headers.get(\"Content-Type\"), b\"application/x-www-form-urlencoded\"\n        )\n\n        self.assertEqual(a.headers.get(\"Authorization\"), b.headers.get(\"Authorization\"))\n\n    def testNonFormEncoded(self, generate_nonce, generate_timestamp):\n        \"\"\"OAuth signature only depend on body if it is form encoded.\"\"\"\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"1\"\n        oauth = requests_oauthlib.OAuth1(\"client_key\")\n\n        r = requests.Request(\n            method=\"POST\",\n            url=\"http://a.b/path?query=retain\",\n            auth=oauth,\n            data=\"this really is not form encoded\",\n        )\n        a = r.prepare()\n\n        r = requests.Request(\n            method=\"POST\", url=\"http://a.b/path?query=retain\", auth=oauth\n        )\n        b = r.prepare()\n\n        self.assertEqual(a.headers.get(\"Authorization\"), b.headers.get(\"Authorization\"))\n\n        r = requests.Request(\n            method=\"POST\",\n            url=\"http://a.b/path?query=retain\",\n            auth=oauth,\n            files={\"test\": StringIO(\"hello\")},\n        )\n        c = r.prepare()\n\n        self.assertEqual(b.headers.get(\"Authorization\"), c.headers.get(\"Authorization\"))\n\n    def testCanPostBinaryData(self, generate_nonce, generate_timestamp):\n        \"\"\"\n        Test we can post binary data. Should prevent regression of the\n        UnicodeDecodeError issue.\n        \"\"\"\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"1\"\n        oauth = requests_oauthlib.OAuth1(\"client_key\")\n        dirname = os.path.dirname(__file__)\n        fname = os.path.join(dirname, \"test.bin\")\n\n        with open(fname, \"rb\") as f:\n            r = requests.post(\n                \"http://httpbin.org/post\",\n                data={\"hi\": \"there\"},\n                files={\"media\": (os.path.basename(f.name), f)},\n                headers={\"content-type\": \"application/octet-stream\"},\n                auth=oauth,\n            )\n            self.assertEqual(r.status_code, 200)\n\n    def test_url_is_native_str(self, generate_nonce, generate_timestamp):\n        \"\"\"\n        Test that the URL is always a native string.\n        \"\"\"\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"1\"\n        oauth = requests_oauthlib.OAuth1(\"client_key\")\n\n        r = requests.get(\"http://httpbin.org/get\", auth=oauth)\n        self.assertIsInstance(r.request.url, str)\n\n    def test_content_type_override(self, generate_nonce, generate_timestamp):\n        \"\"\"\n        Content type should only be guessed if none is given.\n        \"\"\"\n        generate_nonce.return_value = \"abc\"\n        generate_timestamp.return_value = \"1\"\n        oauth = requests_oauthlib.OAuth1(\"client_key\")\n        data = \"a\"\n        r = requests.post(\"http://httpbin.org/get\", data=data, auth=oauth)\n        self.assertEqual(\n            r.request.headers.get(\"Content-Type\"), b\"application/x-www-form-urlencoded\"\n        )\n        r = requests.post(\n            \"http://httpbin.org/get\",\n            auth=oauth,\n            data=data,\n            headers={\"Content-type\": \"application/json\"},\n        )\n        self.assertEqual(r.request.headers.get(\"Content-Type\"), b\"application/json\")\n\n    def test_register_client_class(self, generate_timestamp, generate_nonce):\n        class ClientSubclass(oauthlib.oauth1.Client):\n            pass\n\n        self.assertTrue(hasattr(requests_oauthlib.OAuth1, \"client_class\"))\n\n        self.assertEqual(requests_oauthlib.OAuth1.client_class, oauthlib.oauth1.Client)\n\n        normal = requests_oauthlib.OAuth1(\"client_key\")\n\n        self.assertIsInstance(normal.client, oauthlib.oauth1.Client)\n        self.assertNotIsInstance(normal.client, ClientSubclass)\n\n        requests_oauthlib.OAuth1.client_class = ClientSubclass\n\n        self.assertEqual(requests_oauthlib.OAuth1.client_class, ClientSubclass)\n\n        custom = requests_oauthlib.OAuth1(\"client_key\")\n\n        self.assertIsInstance(custom.client, oauthlib.oauth1.Client)\n        self.assertIsInstance(custom.client, ClientSubclass)\n\n        overridden = requests_oauthlib.OAuth1(\n            \"client_key\", client_class=oauthlib.oauth1.Client\n        )\n\n        self.assertIsInstance(overridden.client, oauthlib.oauth1.Client)\n        self.assertNotIsInstance(normal.client, ClientSubclass)\n", "tests/__init__.py": "", "tests/test_oauth2_session.py": "import json\nimport time\nimport tempfile\nimport shutil\nimport os\nfrom base64 import b64encode\nfrom copy import deepcopy\nfrom unittest import TestCase\n\nfrom unittest import mock\n\nfrom oauthlib.common import urlencode\nfrom oauthlib.oauth2 import TokenExpiredError, OAuth2Error\nfrom oauthlib.oauth2 import MismatchingStateError\nfrom oauthlib.oauth2 import WebApplicationClient, MobileApplicationClient\nfrom oauthlib.oauth2 import LegacyApplicationClient, BackendApplicationClient\nfrom requests_oauthlib import OAuth2Session, TokenUpdated\nimport requests\n\nfrom requests.auth import _basic_auth_str\n\n\nfake_time = time.time()\nCODE = \"asdf345xdf\"\n\n\ndef fake_token(token):\n    def fake_send(r, **kwargs):\n        resp = mock.MagicMock()\n        resp.text = json.dumps(token)\n        return resp\n\n    return fake_send\n\n\nclass OAuth2SessionTest(TestCase):\n    def setUp(self):\n        self.token = {\n            \"token_type\": \"Bearer\",\n            \"access_token\": \"asdfoiw37850234lkjsdfsdf\",\n            \"refresh_token\": \"sldvafkjw34509s8dfsdf\",\n            \"expires_in\": 3600,\n            \"expires_at\": fake_time + 3600,\n        }\n        # use someclientid:someclientsecret to easily differentiate between client and user credentials\n        # these are the values used in oauthlib tests\n        self.client_id = \"someclientid\"\n        self.client_secret = \"someclientsecret\"\n        self.user_username = \"user_username\"\n        self.user_password = \"user_password\"\n        self.client_WebApplication = WebApplicationClient(self.client_id, code=CODE)\n        self.client_LegacyApplication = LegacyApplicationClient(self.client_id)\n        self.client_BackendApplication = BackendApplicationClient(self.client_id)\n        self.client_MobileApplication = MobileApplicationClient(self.client_id)\n        self.clients = [\n            self.client_WebApplication,\n            self.client_LegacyApplication,\n            self.client_BackendApplication,\n        ]\n        self.all_clients = self.clients + [self.client_MobileApplication]\n\n    def test_add_token(self):\n        token = \"Bearer \" + self.token[\"access_token\"]\n\n        def verifier(r, **kwargs):\n            auth_header = r.headers.get(str(\"Authorization\"), None)\n            self.assertEqual(auth_header, token)\n            resp = mock.MagicMock()\n            resp.cookes = []\n            return resp\n\n        for client in self.all_clients:\n            sess = OAuth2Session(client=client, token=self.token)\n            sess.send = verifier\n            sess.get(\"https://i.b\")\n\n    def test_mtls(self):\n        cert = (\n            \"testsomething.example-client.pem\",\n            \"testsomething.example-client-key.pem\",\n        )\n\n        def verifier(r, **kwargs):\n            self.assertIn(\"cert\", kwargs)\n            self.assertEqual(cert, kwargs[\"cert\"])\n            self.assertIn(\"client_id=\" + self.client_id, r.body)\n            resp = mock.MagicMock()\n            resp.text = json.dumps(self.token)\n            return resp\n\n        for client in self.clients:\n            sess = OAuth2Session(client=client)\n            sess.send = verifier\n\n            if isinstance(client, LegacyApplicationClient):\n                sess.fetch_token(\n                    \"https://i.b\",\n                    include_client_id=True,\n                    cert=cert,\n                    username=\"username1\",\n                    password=\"password1\",\n                )\n            else:\n                sess.fetch_token(\"https://i.b\", include_client_id=True, cert=cert)\n\n    def test_authorization_url(self):\n        url = \"https://example.com/authorize?foo=bar\"\n\n        web = WebApplicationClient(self.client_id)\n        s = OAuth2Session(client=web)\n        auth_url, state = s.authorization_url(url)\n        self.assertIn(state, auth_url)\n        self.assertIn(self.client_id, auth_url)\n        self.assertIn(\"response_type=code\", auth_url)\n\n        mobile = MobileApplicationClient(self.client_id)\n        s = OAuth2Session(client=mobile)\n        auth_url, state = s.authorization_url(url)\n        self.assertIn(state, auth_url)\n        self.assertIn(self.client_id, auth_url)\n        self.assertIn(\"response_type=token\", auth_url)\n\n    def test_pkce_authorization_url(self):\n        url = \"https://example.com/authorize?foo=bar\"\n\n        web = WebApplicationClient(self.client_id)\n        s = OAuth2Session(client=web, pkce=\"S256\")\n        auth_url, state = s.authorization_url(url)\n        self.assertIn(state, auth_url)\n        self.assertIn(self.client_id, auth_url)\n        self.assertIn(\"response_type=code\", auth_url)\n        self.assertIn(\"code_challenge=\", auth_url)\n        self.assertIn(\"code_challenge_method=S256\", auth_url)\n\n        mobile = MobileApplicationClient(self.client_id)\n        s = OAuth2Session(client=mobile, pkce=\"S256\")\n        auth_url, state = s.authorization_url(url)\n        self.assertIn(state, auth_url)\n        self.assertIn(self.client_id, auth_url)\n        self.assertIn(\"response_type=token\", auth_url)\n        self.assertIn(\"code_challenge=\", auth_url)\n        self.assertIn(\"code_challenge_method=S256\", auth_url)\n\n    @mock.patch(\"time.time\", new=lambda: fake_time)\n    def test_refresh_token_request(self):\n        self.expired_token = dict(self.token)\n        self.expired_token[\"expires_in\"] = \"-1\"\n        del self.expired_token[\"expires_at\"]\n\n        def fake_refresh(r, **kwargs):\n            if \"/refresh\" in r.url:\n                self.assertNotIn(\"Authorization\", r.headers)\n            resp = mock.MagicMock()\n            resp.text = json.dumps(self.token)\n            return resp\n\n        # No auto refresh setup\n        for client in self.clients:\n            sess = OAuth2Session(client=client, token=self.expired_token)\n            self.assertRaises(TokenExpiredError, sess.get, \"https://i.b\")\n\n        # Auto refresh but no auto update\n        for client in self.clients:\n            sess = OAuth2Session(\n                client=client,\n                token=self.expired_token,\n                auto_refresh_url=\"https://i.b/refresh\",\n            )\n            sess.send = fake_refresh\n            self.assertRaises(TokenUpdated, sess.get, \"https://i.b\")\n\n        # Auto refresh and auto update\n        def token_updater(token):\n            self.assertEqual(token, self.token)\n\n        for client in self.clients:\n            sess = OAuth2Session(\n                client=client,\n                token=self.expired_token,\n                auto_refresh_url=\"https://i.b/refresh\",\n                token_updater=token_updater,\n            )\n            sess.send = fake_refresh\n            sess.get(\"https://i.b\")\n\n        def fake_refresh_with_auth(r, **kwargs):\n            if \"/refresh\" in r.url:\n                self.assertIn(\"Authorization\", r.headers)\n                encoded = b64encode(\n                    \"{client_id}:{client_secret}\".format(\n                        client_id=self.client_id, client_secret=self.client_secret\n                    ).encode(\"latin1\")\n                )\n                content = \"Basic {encoded}\".format(encoded=encoded.decode(\"latin1\"))\n                self.assertEqual(r.headers[\"Authorization\"], content)\n            resp = mock.MagicMock()\n            resp.text = json.dumps(self.token)\n            return resp\n\n        for client in self.clients:\n            sess = OAuth2Session(\n                client=client,\n                token=self.expired_token,\n                auto_refresh_url=\"https://i.b/refresh\",\n                token_updater=token_updater,\n            )\n            sess.send = fake_refresh_with_auth\n            sess.get(\n                \"https://i.b\",\n                client_id=self.client_id,\n                client_secret=self.client_secret,\n            )\n\n    @mock.patch(\"time.time\", new=lambda: fake_time)\n    def test_token_from_fragment(self):\n        mobile = MobileApplicationClient(self.client_id)\n        response_url = \"https://i.b/callback#\" + urlencode(self.token.items())\n        sess = OAuth2Session(client=mobile)\n        self.assertEqual(sess.token_from_fragment(response_url), self.token)\n\n    @mock.patch(\"time.time\", new=lambda: fake_time)\n    def test_fetch_token(self):\n        url = \"https://example.com/token\"\n\n        for client in self.clients:\n            sess = OAuth2Session(client=client, token=self.token)\n            sess.send = fake_token(self.token)\n            if isinstance(client, LegacyApplicationClient):\n                # this client requires a username+password\n                # if unset, an error will be raised\n                self.assertRaises(ValueError, sess.fetch_token, url)\n                self.assertRaises(\n                    ValueError, sess.fetch_token, url, username=\"username1\"\n                )\n                self.assertRaises(\n                    ValueError, sess.fetch_token, url, password=\"password1\"\n                )\n                # otherwise it will pass\n                self.assertEqual(\n                    sess.fetch_token(url, username=\"username1\", password=\"password1\"),\n                    self.token,\n                )\n            else:\n                self.assertEqual(sess.fetch_token(url), self.token)\n\n        error = {\"error\": \"invalid_request\"}\n        for client in self.clients:\n            sess = OAuth2Session(client=client, token=self.token)\n            sess.send = fake_token(error)\n            if isinstance(client, LegacyApplicationClient):\n                # this client requires a username+password\n                # if unset, an error will be raised\n                self.assertRaises(ValueError, sess.fetch_token, url)\n                self.assertRaises(\n                    ValueError, sess.fetch_token, url, username=\"username1\"\n                )\n                self.assertRaises(\n                    ValueError, sess.fetch_token, url, password=\"password1\"\n                )\n                # otherwise it will pass\n                self.assertRaises(\n                    OAuth2Error,\n                    sess.fetch_token,\n                    url,\n                    username=\"username1\",\n                    password=\"password1\",\n                )\n            else:\n                self.assertRaises(OAuth2Error, sess.fetch_token, url)\n\n        # there are different scenarios in which the `client_id` can be specified\n        # reference `oauthlib.tests.oauth2.rfc6749.clients.test_web_application.WebApplicationClientTest.test_prepare_request_body`\n        # this only needs to test WebApplicationClient\n        client = self.client_WebApplication\n        client.tester = True\n\n        # this should be a tuple of (r.url, r.body, r.headers.get('Authorization'))\n        _fetch_history = []\n\n        def fake_token_history(token):\n            def fake_send(r, **kwargs):\n                resp = mock.MagicMock()\n                resp.text = json.dumps(token)\n                _fetch_history.append(\n                    (r.url, r.body, r.headers.get(\"Authorization\", None))\n                )\n                return resp\n\n            return fake_send\n\n        sess = OAuth2Session(client=client, token=self.token)\n        sess.send = fake_token_history(self.token)\n        expected_auth_header = _basic_auth_str(self.client_id, self.client_secret)\n\n        # scenario 1 - default request\n        # this should send the `client_id` in the headers, as that is recommended by the RFC\n        self.assertEqual(\n            sess.fetch_token(url, client_secret=\"someclientsecret\"), self.token\n        )\n        self.assertEqual(len(_fetch_history), 1)\n        self.assertNotIn(\n            \"client_id\", _fetch_history[0][1]\n        )  # no `client_id` in the body\n        self.assertNotIn(\n            \"client_secret\", _fetch_history[0][1]\n        )  # no `client_secret` in the body\n        self.assertEqual(\n            _fetch_history[0][2], expected_auth_header\n        )  # ensure a Basic Authorization header\n\n        # scenario 2 - force the `client_id` into the body\n        self.assertEqual(\n            sess.fetch_token(\n                url, client_secret=\"someclientsecret\", include_client_id=True\n            ),\n            self.token,\n        )\n        self.assertEqual(len(_fetch_history), 2)\n        self.assertIn(\"client_id=%s\" % self.client_id, _fetch_history[1][1])\n        self.assertIn(\"client_secret=%s\" % self.client_secret, _fetch_history[1][1])\n        self.assertEqual(\n            _fetch_history[1][2], None\n        )  # ensure NO Basic Authorization header\n\n        # scenario 3 - send in an auth object\n        auth = requests.auth.HTTPBasicAuth(self.client_id, self.client_secret)\n        self.assertEqual(sess.fetch_token(url, auth=auth), self.token)\n        self.assertEqual(len(_fetch_history), 3)\n        self.assertNotIn(\n            \"client_id\", _fetch_history[2][1]\n        )  # no `client_id` in the body\n        self.assertNotIn(\n            \"client_secret\", _fetch_history[2][1]\n        )  # no `client_secret` in the body\n        self.assertEqual(\n            _fetch_history[2][2], expected_auth_header\n        )  # ensure a Basic Authorization header\n\n        # scenario 4 - send in a username/password combo\n        # this should send the `client_id` in the headers, like scenario 1\n        self.assertEqual(\n            sess.fetch_token(\n                url, username=self.user_username, password=self.user_password\n            ),\n            self.token,\n        )\n        self.assertEqual(len(_fetch_history), 4)\n        self.assertNotIn(\n            \"client_id\", _fetch_history[3][1]\n        )  # no `client_id` in the body\n        self.assertNotIn(\n            \"client_secret\", _fetch_history[3][1]\n        )  # no `client_secret` in the body\n        self.assertEqual(\n            _fetch_history[0][2], expected_auth_header\n        )  # ensure a Basic Authorization header\n        self.assertIn(\"username=%s\" % self.user_username, _fetch_history[3][1])\n        self.assertIn(\"password=%s\" % self.user_password, _fetch_history[3][1])\n\n        # scenario 5 - send data in `params` and not in `data` for providers\n        # that expect data in URL\n        self.assertEqual(\n            sess.fetch_token(url, client_secret=\"somesecret\", force_querystring=True),\n            self.token,\n        )\n        self.assertIn(\"code=%s\" % CODE, _fetch_history[4][0])\n\n        # some quick tests for valid ways of supporting `client_secret`\n\n        # scenario 2b - force the `client_id` into the body; but the `client_secret` is `None`\n        self.assertEqual(\n            sess.fetch_token(url, client_secret=None, include_client_id=True),\n            self.token,\n        )\n        self.assertEqual(len(_fetch_history), 6)\n        self.assertIn(\"client_id=%s\" % self.client_id, _fetch_history[5][1])\n        self.assertNotIn(\n            \"client_secret=\", _fetch_history[5][1]\n        )  # no `client_secret` in the body\n        self.assertEqual(\n            _fetch_history[5][2], None\n        )  # ensure NO Basic Authorization header\n\n        # scenario 2c - force the `client_id` into the body; but the `client_secret` is an empty string\n        self.assertEqual(\n            sess.fetch_token(url, client_secret=\"\", include_client_id=True), self.token\n        )\n        self.assertEqual(len(_fetch_history), 7)\n        self.assertIn(\"client_id=%s\" % self.client_id, _fetch_history[6][1])\n        self.assertIn(\"client_secret=\", _fetch_history[6][1])\n        self.assertEqual(\n            _fetch_history[6][2], None\n        )  # ensure NO Basic Authorization header\n\n    def test_cleans_previous_token_before_fetching_new_one(self):\n        \"\"\"Makes sure the previous token is cleaned before fetching a new one.\n\n        The reason behind it is that, if the previous token is expired, this\n        method shouldn't fail with a TokenExpiredError, since it's attempting\n        to get a new one (which shouldn't be expired).\n\n        \"\"\"\n        new_token = deepcopy(self.token)\n        past = time.time() - 7200\n        now = time.time()\n        self.token[\"expires_at\"] = past\n        new_token[\"expires_at\"] = now + 3600\n        url = \"https://example.com/token\"\n\n        with mock.patch(\"time.time\", lambda: now):\n            for client in self.clients:\n                sess = OAuth2Session(client=client, token=self.token)\n                sess.send = fake_token(new_token)\n                if isinstance(client, LegacyApplicationClient):\n                    # this client requires a username+password\n                    # if unset, an error will be raised\n                    self.assertRaises(ValueError, sess.fetch_token, url)\n                    self.assertRaises(\n                        ValueError, sess.fetch_token, url, username=\"username1\"\n                    )\n                    self.assertRaises(\n                        ValueError, sess.fetch_token, url, password=\"password1\"\n                    )\n                    # otherwise it will pass\n                    self.assertEqual(\n                        sess.fetch_token(\n                            url, username=\"username1\", password=\"password1\"\n                        ),\n                        new_token,\n                    )\n                else:\n                    self.assertEqual(sess.fetch_token(url), new_token)\n\n    def test_web_app_fetch_token(self):\n        # Ensure the state parameter is used, see issue #105.\n        client = OAuth2Session(\"someclientid\", state=\"somestate\")\n        self.assertRaises(\n            MismatchingStateError,\n            client.fetch_token,\n            \"https://i.b/token\",\n            authorization_response=\"https://i.b/no-state?code=abc\",\n        )\n\n    @mock.patch(\"time.time\", new=lambda: fake_time)\n    def test_pkce_web_app_fetch_token(self):\n        url = \"https://example.com/token\"\n\n        web = WebApplicationClient(self.client_id, code=CODE)\n        sess = OAuth2Session(client=web, token=self.token, pkce=\"S256\")\n        sess.send = fake_token(self.token)\n        sess._code_verifier = \"foobar\"\n        self.assertEqual(sess.fetch_token(url), self.token)\n\n    def test_client_id_proxy(self):\n        sess = OAuth2Session(\"test-id\")\n        self.assertEqual(sess.client_id, \"test-id\")\n        sess.client_id = \"different-id\"\n        self.assertEqual(sess.client_id, \"different-id\")\n        sess._client.client_id = \"something-else\"\n        self.assertEqual(sess.client_id, \"something-else\")\n        del sess.client_id\n        self.assertIsNone(sess.client_id)\n\n    def test_access_token_proxy(self):\n        sess = OAuth2Session(\"test-id\")\n        self.assertIsNone(sess.access_token)\n        sess.access_token = \"test-token\"\n        self.assertEqual(sess.access_token, \"test-token\")\n        sess._client.access_token = \"different-token\"\n        self.assertEqual(sess.access_token, \"different-token\")\n        del sess.access_token\n        self.assertIsNone(sess.access_token)\n\n    def test_token_proxy(self):\n        token = {\"access_token\": \"test-access\"}\n        sess = OAuth2Session(\"test-id\", token=token)\n        self.assertEqual(sess.access_token, \"test-access\")\n        self.assertEqual(sess.token, token)\n        token[\"access_token\"] = \"something-else\"\n        sess.token = token\n        self.assertEqual(sess.access_token, \"something-else\")\n        self.assertEqual(sess.token, token)\n        sess._client.access_token = \"different-token\"\n        token[\"access_token\"] = \"different-token\"\n        self.assertEqual(sess.access_token, \"different-token\")\n        self.assertEqual(sess.token, token)\n        # can't delete token attribute\n        with self.assertRaises(AttributeError):\n            del sess.token\n\n    def test_authorized_false(self):\n        sess = OAuth2Session(\"someclientid\")\n        self.assertFalse(sess.authorized)\n\n    @mock.patch(\"time.time\", new=lambda: fake_time)\n    def test_authorized_true(self):\n        def fake_token(token):\n            def fake_send(r, **kwargs):\n                resp = mock.MagicMock()\n                resp.text = json.dumps(token)\n                return resp\n\n            return fake_send\n\n        url = \"https://example.com/token\"\n\n        for client in self.clients:\n            sess = OAuth2Session(client=client)\n            sess.send = fake_token(self.token)\n            self.assertFalse(sess.authorized)\n            if isinstance(client, LegacyApplicationClient):\n                # this client requires a username+password\n                # if unset, an error will be raised\n                self.assertRaises(ValueError, sess.fetch_token, url)\n                self.assertRaises(\n                    ValueError, sess.fetch_token, url, username=\"username1\"\n                )\n                self.assertRaises(\n                    ValueError, sess.fetch_token, url, password=\"password1\"\n                )\n                # otherwise it will pass\n                sess.fetch_token(url, username=\"username1\", password=\"password1\")\n            else:\n                sess.fetch_token(url)\n            self.assertTrue(sess.authorized)\n\n\nclass OAuth2SessionNetrcTest(OAuth2SessionTest):\n    \"\"\"Ensure that there is no magic auth handling.\n\n    By default, requests sessions have magic handling of netrc files,\n    which is undesirable for this library because it will take\n    precedence over manually set authentication headers.\n    \"\"\"\n\n    def setUp(self):\n        # Set up a temporary home directory\n        self.homedir = tempfile.mkdtemp()\n        self.prehome = os.environ.get(\"HOME\", None)\n        os.environ[\"HOME\"] = self.homedir\n\n        # Write a .netrc file that will cause problems\n        netrc_loc = os.path.expanduser(\"~/.netrc\")\n        with open(netrc_loc, \"w\") as f:\n            f.write(\"machine i.b\\n\" \"  password abc123\\n\" \"  login spam@eggs.co\\n\")\n\n        super(OAuth2SessionNetrcTest, self).setUp()\n\n    def tearDown(self):\n        super(OAuth2SessionNetrcTest, self).tearDown()\n\n        if self.prehome is not None:\n            os.environ[\"HOME\"] = self.prehome\n        shutil.rmtree(self.homedir)\n", "tests/examples/base.py": "import os.path\nimport os\nimport subprocess\nimport shlex\nimport shutil\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait\n\n\ncwd = os.path.dirname(os.path.realpath(__file__))\n\n\nclass Sample():\n    def setUp(self):\n        super().setUp()\n        self.proc = None\n        self.outputs = []\n\n    def tearDown(self):\n        super().tearDown()\n        if self.proc is not None:\n            self.proc.stdin.close()\n            self.proc.stdout.close()\n            self.proc.kill()\n    \n    def replaceVariables(self, filein ,fileout, vars):\n        with open(filein, \"rt\") as fin:\n            with open(fileout, \"wt\") as fout:\n                for line in fin:\n                    for k, v in vars.items():\n                        line = line.replace(k, v)\n                    fout.write(line)\n\n    def run_sample(self, filepath, variables):\n        \"\"\"\n        Execute python sample as a background process.\n\n        :param filepath: Name of the python sample present in docs examples folder.\n        :type filepath: string\n        :param variables: Key Names/Values to replace in the python script before being run\n        :type variables: dict\n        \"\"\"\n        inpath = os.path.join(cwd, \"..\", \"..\", \"docs\", \"examples\", filepath)\n        outpath = os.path.join(cwd, \"tmp_{}\".format(filepath))\n        self.replaceVariables(inpath, outpath, variables)\n\n        self.proc = subprocess.Popen(\n            [shutil.which(\"python\"),\n             outpath],\n            text=True, bufsize=1,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE\n        )\n\n    def write(self, string):\n        \"\"\"\n        Write string into standard input. Useful to fill an answer to ``input()``\n\n        :param string: string to write\n        \"\"\"\n        self.proc.stdin.write(string)\n        self.proc.stdin.flush()\n\n    def wait_for_pattern(self, pattern):\n        \"\"\"\n        Wait until the background process is writing ``pattern`` in standard output.\n\n        :param pattern: search for this string before returning.\n        :type pattern: string\n        \"\"\"\n        try:\n            while True:\n                line = self.proc.stdout.readline()\n                self.outputs.append(line)\n                if pattern in line:\n                    return line\n        except subprocess.TimeoutExpired:\n            self.assertTrue(False, \"timeout when looking for output\")\n\n    def wait_for_end(self):\n        \"\"\"\n        Wait until the background process ends. Timeout after 10sec.\n        \"\"\"\n        try:\n            outs, err = self.proc.communicate(timeout=10)\n            self.outputs += filter(lambda x: x != '', outs.split('\\n'))\n        except subprocess.TimeoutExpired:\n            self.assertTrue(False, \"timeout when looking for output\")\n        return self.outputs[-1]\n            \n\n\nclass Browser():\n    def setUp(self):\n        super().setUp()\n        options = webdriver.ChromeOptions()\n        options.add_argument(\"--headless=new\")\n        self.driver = webdriver.Chrome(options=options)\n        self.user_username = os.environ.get(\"AUTH0_USERNAME\")\n        self.user_password = os.environ.get(\"AUTH0_PASSWORD\")\n\n        if not self.user_username or not self.user_password:\n            self.skipTest(\"auth0 is not configured properly\")\n\n    def tearDown(self):\n        super().tearDown()\n        self.driver.quit()\n\n    def authorize_auth0(self, authorize_url, expected_redirect_uri):\n        \"\"\"\n        Start browser based on an Auth0 authorize url, and log user with user and password.\n        Returns once login journey ends with a redirection to ``expected_redirect_uri``.\n        Note this is for Auth0 login dialog specifically.\n\n        :param authorize_url: Full Authorize URL of Identity Provider\n        :type authorize_url: string\n        :param expected_redirect_uri: Expected ``redirect_uri``. Used only to check end of the authorize journey.\n        :type expected_redirect_uri: string\n        \"\"\"\n        self.driver.get(authorize_url)\n        username = self.driver.find_element(By.ID, \"username\")\n        password = self.driver.find_element(By.ID, \"password\")\n\n        wait = WebDriverWait(self.driver, timeout=2)\n        wait.until(lambda d : username.is_displayed())\n        wait.until(lambda d : password.is_displayed())\n\n        username.clear()\n        username.send_keys(self.user_username)\n        password.send_keys(self.user_password)\n        username.send_keys(Keys.RETURN)\n\n        wait.until(EC.url_contains(expected_redirect_uri))\n        return self.driver.current_url\n\n", "tests/examples/test_native_spa_pkce_auth0.py": "import os\nimport unittest\n\nfrom . import Sample\nfrom . import Browser\n\nclass TestNativeAuth0Test(Sample, Browser, unittest.TestCase):\n    def setUp(self):\n        super().setUp()\n        self.client_id = os.environ.get(\"AUTH0_PKCE_CLIENT_ID\")\n        self.idp_domain = os.environ.get(\"AUTH0_DOMAIN\")\n\n        if not self.client_id or not self.idp_domain:\n            self.skipTest(\"native auth0 is not configured properly\")\n\n    def test_login(self):\n        # redirect_uri is http://\n        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = \"1\"\n\n        self.run_sample(\n            \"native_spa_pkce_auth0.py\", {\n                \"OAUTH_CLIENT_ID\": self.client_id,\n                \"OAUTH_IDP_DOMAIN\": self.idp_domain,\n            }\n        )\n        authorize_url = self.wait_for_pattern(\"https://\")\n        redirect_uri = self.authorize_auth0(authorize_url, \"http://\")\n        self.write(redirect_uri)\n        last_line = self.wait_for_end()\n\n        import ast\n        response = ast.literal_eval(last_line)\n        self.assertIn(\"access_token\", response)\n        self.assertIn(\"id_token\", response)\n        self.assertIn(\"scope\", response)\n        self.assertIn(\"openid\", response[\"scope\"])\n        self.assertIn(\"expires_in\", response)\n        self.assertIn(\"expires_at\", response)\n        self.assertIn(\"token_type\", response)\n        self.assertEqual(\"Bearer\", response[\"token_type\"])\n", "tests/examples/__init__.py": "from .base import Sample\nfrom .base import Browser\n", "requests_oauthlib/oauth1_session.py": "from urllib.parse import urlparse\n\nimport logging\n\nfrom oauthlib.common import add_params_to_uri\nfrom oauthlib.common import urldecode as _urldecode\nfrom oauthlib.oauth1 import SIGNATURE_HMAC, SIGNATURE_RSA, SIGNATURE_TYPE_AUTH_HEADER\nimport requests\n\nfrom . import OAuth1\n\n\nlog = logging.getLogger(__name__)\n\n\ndef urldecode(body):\n    \"\"\"Parse query or json to python dictionary\"\"\"\n    try:\n        return _urldecode(body)\n    except Exception:\n        import json\n\n        return json.loads(body)\n\n\nclass TokenRequestDenied(ValueError):\n    def __init__(self, message, response):\n        super(TokenRequestDenied, self).__init__(message)\n        self.response = response\n\n    @property\n    def status_code(self):\n        \"\"\"For backwards-compatibility purposes\"\"\"\n        return self.response.status_code\n\n\nclass TokenMissing(ValueError):\n    def __init__(self, message, response):\n        super(TokenMissing, self).__init__(message)\n        self.response = response\n\n\nclass VerifierMissing(ValueError):\n    pass\n\n\nclass OAuth1Session(requests.Session):\n    \"\"\"Request signing and convenience methods for the oauth dance.\n\n    What is the difference between OAuth1Session and OAuth1?\n\n    OAuth1Session actually uses OAuth1 internally and its purpose is to assist\n    in the OAuth workflow through convenience methods to prepare authorization\n    URLs and parse the various token and redirection responses. It also provide\n    rudimentary validation of responses.\n\n    An example of the OAuth workflow using a basic CLI app and Twitter.\n\n    >>> # Credentials obtained during the registration.\n    >>> client_key = 'client key'\n    >>> client_secret = 'secret'\n    >>> callback_uri = 'https://127.0.0.1/callback'\n    >>>\n    >>> # Endpoints found in the OAuth provider API documentation\n    >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n    >>> authorization_url = 'https://api.twitter.com/oauth/authorize'\n    >>> access_token_url = 'https://api.twitter.com/oauth/access_token'\n    >>>\n    >>> oauth_session = OAuth1Session(client_key,client_secret=client_secret, callback_uri=callback_uri)\n    >>>\n    >>> # First step, fetch the request token.\n    >>> oauth_session.fetch_request_token(request_token_url)\n    {\n        'oauth_token': 'kjerht2309u',\n        'oauth_token_secret': 'lsdajfh923874',\n    }\n    >>>\n    >>> # Second step. Follow this link and authorize\n    >>> oauth_session.authorization_url(authorization_url)\n    'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf&oauth_callback=https%3A%2F%2F127.0.0.1%2Fcallback'\n    >>>\n    >>> # Third step. Fetch the access token\n    >>> redirect_response = input('Paste the full redirect URL here.')\n    >>> oauth_session.parse_authorization_response(redirect_response)\n    {\n        'oauth_token: 'kjerht2309u',\n        'oauth_token_secret: 'lsdajfh923874',\n        'oauth_verifier: 'w34o8967345',\n    }\n    >>> oauth_session.fetch_access_token(access_token_url)\n    {\n        'oauth_token': 'sdf0o9823sjdfsdf',\n        'oauth_token_secret': '2kjshdfp92i34asdasd',\n    }\n    >>> # Done. You can now make OAuth requests.\n    >>> status_url = 'http://api.twitter.com/1/statuses/update.json'\n    >>> new_status = {'status':  'hello world!'}\n    >>> oauth_session.post(status_url, data=new_status)\n    <Response [200]>\n    \"\"\"\n\n    def __init__(\n        self,\n        client_key,\n        client_secret=None,\n        resource_owner_key=None,\n        resource_owner_secret=None,\n        callback_uri=None,\n        signature_method=SIGNATURE_HMAC,\n        signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n        rsa_key=None,\n        verifier=None,\n        client_class=None,\n        force_include_body=False,\n        **kwargs\n    ):\n        \"\"\"Construct the OAuth 1 session.\n\n        :param client_key: A client specific identifier.\n        :param client_secret: A client specific secret used to create HMAC and\n                              plaintext signatures.\n        :param resource_owner_key: A resource owner key, also referred to as\n                                   request token or access token depending on\n                                   when in the workflow it is used.\n        :param resource_owner_secret: A resource owner secret obtained with\n                                      either a request or access token. Often\n                                      referred to as token secret.\n        :param callback_uri: The URL the user is redirect back to after\n                             authorization.\n        :param signature_method: Signature methods determine how the OAuth\n                                 signature is created. The three options are\n                                 oauthlib.oauth1.SIGNATURE_HMAC (default),\n                                 oauthlib.oauth1.SIGNATURE_RSA and\n                                 oauthlib.oauth1.SIGNATURE_PLAIN.\n        :param signature_type: Signature type decides where the OAuth\n                               parameters are added. Either in the\n                               Authorization header (default) or to the URL\n                               query parameters or the request body. Defined as\n                               oauthlib.oauth1.SIGNATURE_TYPE_AUTH_HEADER,\n                               oauthlib.oauth1.SIGNATURE_TYPE_QUERY and\n                               oauthlib.oauth1.SIGNATURE_TYPE_BODY\n                               respectively.\n        :param rsa_key: The private RSA key as a string. Can only be used with\n                        signature_method=oauthlib.oauth1.SIGNATURE_RSA.\n        :param verifier: A verifier string to prove authorization was granted.\n        :param client_class: A subclass of `oauthlib.oauth1.Client` to use with\n                             `requests_oauthlib.OAuth1` instead of the default\n        :param force_include_body: Always include the request body in the\n                                   signature creation.\n        :param **kwargs: Additional keyword arguments passed to `OAuth1`\n        \"\"\"\n        super(OAuth1Session, self).__init__()\n        self._client = OAuth1(\n            client_key,\n            client_secret=client_secret,\n            resource_owner_key=resource_owner_key,\n            resource_owner_secret=resource_owner_secret,\n            callback_uri=callback_uri,\n            signature_method=signature_method,\n            signature_type=signature_type,\n            rsa_key=rsa_key,\n            verifier=verifier,\n            client_class=client_class,\n            force_include_body=force_include_body,\n            **kwargs\n        )\n        self.auth = self._client\n\n    @property\n    def token(self):\n        oauth_token = self._client.client.resource_owner_key\n        oauth_token_secret = self._client.client.resource_owner_secret\n        oauth_verifier = self._client.client.verifier\n\n        token_dict = {}\n        if oauth_token:\n            token_dict[\"oauth_token\"] = oauth_token\n        if oauth_token_secret:\n            token_dict[\"oauth_token_secret\"] = oauth_token_secret\n        if oauth_verifier:\n            token_dict[\"oauth_verifier\"] = oauth_verifier\n\n        return token_dict\n\n    @token.setter\n    def token(self, value):\n        self._populate_attributes(value)\n\n    @property\n    def authorized(self):\n        \"\"\"Boolean that indicates whether this session has an OAuth token\n        or not. If `self.authorized` is True, you can reasonably expect\n        OAuth-protected requests to the resource to succeed. If\n        `self.authorized` is False, you need the user to go through the OAuth\n        authentication dance before OAuth-protected requests to the resource\n        will succeed.\n        \"\"\"\n        if self._client.client.signature_method == SIGNATURE_RSA:\n            # RSA only uses resource_owner_key\n            return bool(self._client.client.resource_owner_key)\n        else:\n            # other methods of authentication use all three pieces\n            return (\n                bool(self._client.client.client_secret)\n                and bool(self._client.client.resource_owner_key)\n                and bool(self._client.client.resource_owner_secret)\n            )\n\n    def authorization_url(self, url, request_token=None, **kwargs):\n        \"\"\"Create an authorization URL by appending request_token and optional\n        kwargs to url.\n\n        This is the second step in the OAuth 1 workflow. The user should be\n        redirected to this authorization URL, grant access to you, and then\n        be redirected back to you. The redirection back can either be specified\n        during client registration or by supplying a callback URI per request.\n\n        :param url: The authorization endpoint URL.\n        :param request_token: The previously obtained request token.\n        :param kwargs: Optional parameters to append to the URL.\n        :returns: The authorization URL with new parameters embedded.\n\n        An example using a registered default callback URI.\n\n        >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n        >>> authorization_url = 'https://api.twitter.com/oauth/authorize'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.fetch_request_token(request_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        >>> oauth_session.authorization_url(authorization_url)\n        'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf'\n        >>> oauth_session.authorization_url(authorization_url, foo='bar')\n        'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf&foo=bar'\n\n        An example using an explicit callback URI.\n\n        >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n        >>> authorization_url = 'https://api.twitter.com/oauth/authorize'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret', callback_uri='https://127.0.0.1/callback')\n        >>> oauth_session.fetch_request_token(request_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        >>> oauth_session.authorization_url(authorization_url)\n        'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf&oauth_callback=https%3A%2F%2F127.0.0.1%2Fcallback'\n        \"\"\"\n        kwargs[\"oauth_token\"] = request_token or self._client.client.resource_owner_key\n        log.debug(\"Adding parameters %s to url %s\", kwargs, url)\n        return add_params_to_uri(url, kwargs.items())\n\n    def fetch_request_token(self, url, realm=None, **request_kwargs):\n        \"\"\"Fetch a request token.\n\n        This is the first step in the OAuth 1 workflow. A request token is\n        obtained by making a signed post request to url. The token is then\n        parsed from the application/x-www-form-urlencoded response and ready\n        to be used to construct an authorization url.\n\n        :param url: The request token endpoint URL.\n        :param realm: A list of realms to request access to.\n        :param request_kwargs: Optional arguments passed to ''post''\n            function in ''requests.Session''\n        :returns: The response in dict format.\n\n        Note that a previously set callback_uri will be reset for your\n        convenience, or else signature creation will be incorrect on\n        consecutive requests.\n\n        >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.fetch_request_token(request_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        \"\"\"\n        self._client.client.realm = \" \".join(realm) if realm else None\n        token = self._fetch_token(url, **request_kwargs)\n        log.debug(\"Resetting callback_uri and realm (not needed in next phase).\")\n        self._client.client.callback_uri = None\n        self._client.client.realm = None\n        return token\n\n    def fetch_access_token(self, url, verifier=None, **request_kwargs):\n        \"\"\"Fetch an access token.\n\n        This is the final step in the OAuth 1 workflow. An access token is\n        obtained using all previously obtained credentials, including the\n        verifier from the authorization step.\n\n        Note that a previously set verifier will be reset for your\n        convenience, or else signature creation will be incorrect on\n        consecutive requests.\n\n        >>> access_token_url = 'https://api.twitter.com/oauth/access_token'\n        >>> redirect_response = 'https://127.0.0.1/callback?oauth_token=kjerht2309uf&oauth_token_secret=lsdajfh923874&oauth_verifier=w34o8967345'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.parse_authorization_response(redirect_response)\n        {\n            'oauth_token: 'kjerht2309u',\n            'oauth_token_secret: 'lsdajfh923874',\n            'oauth_verifier: 'w34o8967345',\n        }\n        >>> oauth_session.fetch_access_token(access_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        \"\"\"\n        if verifier:\n            self._client.client.verifier = verifier\n        if not getattr(self._client.client, \"verifier\", None):\n            raise VerifierMissing(\"No client verifier has been set.\")\n        token = self._fetch_token(url, **request_kwargs)\n        log.debug(\"Resetting verifier attribute, should not be used anymore.\")\n        self._client.client.verifier = None\n        return token\n\n    def parse_authorization_response(self, url):\n        \"\"\"Extract parameters from the post authorization redirect response URL.\n\n        :param url: The full URL that resulted from the user being redirected\n                    back from the OAuth provider to you, the client.\n        :returns: A dict of parameters extracted from the URL.\n\n        >>> redirect_response = 'https://127.0.0.1/callback?oauth_token=kjerht2309uf&oauth_token_secret=lsdajfh923874&oauth_verifier=w34o8967345'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.parse_authorization_response(redirect_response)\n        {\n            'oauth_token: 'kjerht2309u',\n            'oauth_token_secret: 'lsdajfh923874',\n            'oauth_verifier: 'w34o8967345',\n        }\n        \"\"\"\n        log.debug(\"Parsing token from query part of url %s\", url)\n        token = dict(urldecode(urlparse(url).query))\n        log.debug(\"Updating internal client token attribute.\")\n        self._populate_attributes(token)\n        self.token = token\n        return token\n\n    def _populate_attributes(self, token):\n        if \"oauth_token\" in token:\n            self._client.client.resource_owner_key = token[\"oauth_token\"]\n        else:\n            raise TokenMissing(\n                \"Response does not contain a token: {resp}\".format(resp=token), token\n            )\n        if \"oauth_token_secret\" in token:\n            self._client.client.resource_owner_secret = token[\"oauth_token_secret\"]\n        if \"oauth_verifier\" in token:\n            self._client.client.verifier = token[\"oauth_verifier\"]\n\n    def _fetch_token(self, url, **request_kwargs):\n        log.debug(\"Fetching token from %s using client %s\", url, self._client.client)\n        r = self.post(url, **request_kwargs)\n\n        if r.status_code >= 400:\n            error = \"Token request failed with code %s, response was '%s'.\"\n            raise TokenRequestDenied(error % (r.status_code, r.text), r)\n\n        log.debug('Decoding token from response \"%s\"', r.text)\n        try:\n            token = dict(urldecode(r.text.strip()))\n        except ValueError as e:\n            error = (\n                \"Unable to decode token from token response. \"\n                \"This is commonly caused by an unsuccessful request where\"\n                \" a non urlencoded error message is returned. \"\n                \"The decoding error was %s\"\n                \"\" % e\n            )\n            raise ValueError(error)\n\n        log.debug(\"Obtained token %s\", token)\n        log.debug(\"Updating internal client attributes from token data.\")\n        self._populate_attributes(token)\n        self.token = token\n        return token\n\n    def rebuild_auth(self, prepared_request, response):\n        \"\"\"\n        When being redirected we should always strip Authorization\n        header, since nonce may not be reused as per OAuth spec.\n        \"\"\"\n        if \"Authorization\" in prepared_request.headers:\n            # If we get redirected to a new host, we should strip out\n            # any authentication headers.\n            prepared_request.headers.pop(\"Authorization\", True)\n            prepared_request.prepare_auth(self.auth)\n        return\n", "requests_oauthlib/oauth2_auth.py": "from oauthlib.oauth2 import WebApplicationClient, InsecureTransportError\nfrom oauthlib.oauth2 import is_secure_transport\nfrom requests.auth import AuthBase\n\n\nclass OAuth2(AuthBase):\n    \"\"\"Adds proof of authorization (OAuth2 token) to the request.\"\"\"\n\n    def __init__(self, client_id=None, client=None, token=None):\n        \"\"\"Construct a new OAuth 2 authorization object.\n\n        :param client_id: Client id obtained during registration\n        :param client: :class:`oauthlib.oauth2.Client` to be used. Default is\n                       WebApplicationClient which is useful for any\n                       hosted application but not mobile or desktop.\n        :param token: Token dictionary, must include access_token\n                      and token_type.\n        \"\"\"\n        self._client = client or WebApplicationClient(client_id, token=token)\n        if token:\n            for k, v in token.items():\n                setattr(self._client, k, v)\n\n    def __call__(self, r):\n        \"\"\"Append an OAuth 2 token to the request.\n\n        Note that currently HTTPS is required for all requests. There may be\n        a token type that allows for plain HTTP in the future and then this\n        should be updated to allow plain HTTP on a white list basis.\n        \"\"\"\n        if not is_secure_transport(r.url):\n            raise InsecureTransportError()\n        r.url, r.headers, r.body = self._client.add_token(\n            r.url, http_method=r.method, body=r.body, headers=r.headers\n        )\n        return r\n", "requests_oauthlib/oauth1_auth.py": "# -*- coding: utf-8 -*-\nimport logging\n\nfrom oauthlib.common import extract_params\nfrom oauthlib.oauth1 import Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER\nfrom oauthlib.oauth1 import SIGNATURE_TYPE_BODY\nfrom requests.utils import to_native_string\nfrom requests.auth import AuthBase\n\nCONTENT_TYPE_FORM_URLENCODED = \"application/x-www-form-urlencoded\"\nCONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\n\n\nlog = logging.getLogger(__name__)\n\n# OBS!: Correct signing of requests are conditional on invoking OAuth1\n# as the last step of preparing a request, or at least having the\n# content-type set properly.\nclass OAuth1(AuthBase):\n    \"\"\"Signs the request using OAuth 1 (RFC5849)\"\"\"\n\n    client_class = Client\n\n    def __init__(\n        self,\n        client_key,\n        client_secret=None,\n        resource_owner_key=None,\n        resource_owner_secret=None,\n        callback_uri=None,\n        signature_method=SIGNATURE_HMAC,\n        signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n        rsa_key=None,\n        verifier=None,\n        decoding=\"utf-8\",\n        client_class=None,\n        force_include_body=False,\n        **kwargs\n    ):\n\n        try:\n            signature_type = signature_type.upper()\n        except AttributeError:\n            pass\n\n        client_class = client_class or self.client_class\n\n        self.force_include_body = force_include_body\n\n        self.client = client_class(\n            client_key,\n            client_secret,\n            resource_owner_key,\n            resource_owner_secret,\n            callback_uri,\n            signature_method,\n            signature_type,\n            rsa_key,\n            verifier,\n            decoding=decoding,\n            **kwargs\n        )\n\n    def __call__(self, r):\n        \"\"\"Add OAuth parameters to the request.\n\n        Parameters may be included from the body if the content-type is\n        urlencoded, if no content type is set a guess is made.\n        \"\"\"\n        # Overwriting url is safe here as request will not modify it past\n        # this point.\n        log.debug(\"Signing request %s using client %s\", r, self.client)\n\n        content_type = r.headers.get(\"Content-Type\", \"\")\n        if (\n            not content_type\n            and extract_params(r.body)\n            or self.client.signature_type == SIGNATURE_TYPE_BODY\n        ):\n            content_type = CONTENT_TYPE_FORM_URLENCODED\n        if not isinstance(content_type, str):\n            content_type = content_type.decode(\"utf-8\")\n\n        is_form_encoded = CONTENT_TYPE_FORM_URLENCODED in content_type\n\n        log.debug(\n            \"Including body in call to sign: %s\",\n            is_form_encoded or self.force_include_body,\n        )\n\n        if is_form_encoded:\n            r.headers[\"Content-Type\"] = CONTENT_TYPE_FORM_URLENCODED\n            r.url, headers, r.body = self.client.sign(\n                str(r.url), str(r.method), r.body or \"\", r.headers\n            )\n        elif self.force_include_body:\n            # To allow custom clients to work on non form encoded bodies.\n            r.url, headers, r.body = self.client.sign(\n                str(r.url), str(r.method), r.body or \"\", r.headers\n            )\n        else:\n            # Omit body data in the signing of non form-encoded requests\n            r.url, headers, _ = self.client.sign(\n                str(r.url), str(r.method), None, r.headers\n            )\n\n        r.prepare_headers(headers)\n        r.url = to_native_string(r.url)\n        log.debug(\"Updated url: %s\", r.url)\n        log.debug(\"Updated headers: %s\", headers)\n        log.debug(\"Updated body: %r\", r.body)\n        return r\n", "requests_oauthlib/__init__.py": "# ruff: noqa: F401\nimport logging\n\nfrom .oauth1_auth import OAuth1\nfrom .oauth1_session import OAuth1Session\nfrom .oauth2_auth import OAuth2\nfrom .oauth2_session import OAuth2Session, TokenUpdated\n\n__version__ = \"2.0.0\"\n\nimport requests\n\nif requests.__version__ < \"2.0.0\":\n    msg = (\n        \"You are using requests version %s, which is older than \"\n        \"requests-oauthlib expects, please upgrade to 2.0.0 or later.\"\n    )\n    raise Warning(msg % requests.__version__)\n\nlogging.getLogger(\"requests_oauthlib\").addHandler(logging.NullHandler())\n", "requests_oauthlib/oauth2_session.py": "import logging\n\nfrom oauthlib.common import generate_token, urldecode\nfrom oauthlib.oauth2 import WebApplicationClient, InsecureTransportError\nfrom oauthlib.oauth2 import LegacyApplicationClient\nfrom oauthlib.oauth2 import TokenExpiredError, is_secure_transport\nimport requests\n\nlog = logging.getLogger(__name__)\n\n\nclass TokenUpdated(Warning):\n    def __init__(self, token):\n        super(TokenUpdated, self).__init__()\n        self.token = token\n\n\nclass OAuth2Session(requests.Session):\n    \"\"\"Versatile OAuth 2 extension to :class:`requests.Session`.\n\n    Supports any grant type adhering to :class:`oauthlib.oauth2.Client` spec\n    including the four core OAuth 2 grants.\n\n    Can be used to create authorization urls, fetch tokens and access protected\n    resources using the :class:`requests.Session` interface you are used to.\n\n    - :class:`oauthlib.oauth2.WebApplicationClient` (default): Authorization Code Grant\n    - :class:`oauthlib.oauth2.MobileApplicationClient`: Implicit Grant\n    - :class:`oauthlib.oauth2.LegacyApplicationClient`: Password Credentials Grant\n    - :class:`oauthlib.oauth2.BackendApplicationClient`: Client Credentials Grant\n\n    Note that the only time you will be using Implicit Grant from python is if\n    you are driving a user agent able to obtain URL fragments.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id=None,\n        client=None,\n        auto_refresh_url=None,\n        auto_refresh_kwargs=None,\n        scope=None,\n        redirect_uri=None,\n        token=None,\n        state=None,\n        token_updater=None,\n        pkce=None,\n        **kwargs\n    ):\n        \"\"\"Construct a new OAuth 2 client session.\n\n        :param client_id: Client id obtained during registration\n        :param client: :class:`oauthlib.oauth2.Client` to be used. Default is\n                       WebApplicationClient which is useful for any\n                       hosted application but not mobile or desktop.\n        :param scope: List of scopes you wish to request access to\n        :param redirect_uri: Redirect URI you registered as callback\n        :param token: Token dictionary, must include access_token\n                      and token_type.\n        :param state: State string used to prevent CSRF. This will be given\n                      when creating the authorization url and must be supplied\n                      when parsing the authorization response.\n                      Can be either a string or a no argument callable.\n        :auto_refresh_url: Refresh token endpoint URL, must be HTTPS. Supply\n                           this if you wish the client to automatically refresh\n                           your access tokens.\n        :auto_refresh_kwargs: Extra arguments to pass to the refresh token\n                              endpoint.\n        :token_updater: Method with one argument, token, to be used to update\n                        your token database on automatic token refresh. If not\n                        set a TokenUpdated warning will be raised when a token\n                        has been refreshed. This warning will carry the token\n                        in its token argument.\n        :param pkce: Set \"S256\" or \"plain\" to enable PKCE. Default is disabled.\n        :param kwargs: Arguments to pass to the Session constructor.\n        \"\"\"\n        super(OAuth2Session, self).__init__(**kwargs)\n        self._client = client or WebApplicationClient(client_id, token=token)\n        self.token = token or {}\n        self._scope = scope\n        self.redirect_uri = redirect_uri\n        self.state = state or generate_token\n        self._state = state\n        self.auto_refresh_url = auto_refresh_url\n        self.auto_refresh_kwargs = auto_refresh_kwargs or {}\n        self.token_updater = token_updater\n        self._pkce = pkce\n\n        if self._pkce not in [\"S256\", \"plain\", None]:\n            raise AttributeError(\"Wrong value for {}(.., pkce={})\".format(self.__class__, self._pkce))\n\n        # Ensure that requests doesn't do any automatic auth. See #278.\n        # The default behavior can be re-enabled by setting auth to None.\n        self.auth = lambda r: r\n\n        # Allow customizations for non compliant providers through various\n        # hooks to adjust requests and responses.\n        self.compliance_hook = {\n            \"access_token_response\": set(),\n            \"refresh_token_response\": set(),\n            \"protected_request\": set(),\n            \"refresh_token_request\": set(),\n            \"access_token_request\": set(),\n        }\n\n    @property\n    def scope(self):\n        \"\"\"By default the scope from the client is used, except if overridden\"\"\"\n        if self._scope is not None:\n            return self._scope\n        elif self._client is not None:\n            return self._client.scope\n        else:\n            return None\n\n    @scope.setter\n    def scope(self, scope):\n        self._scope = scope\n\n    def new_state(self):\n        \"\"\"Generates a state string to be used in authorizations.\"\"\"\n        try:\n            self._state = self.state()\n            log.debug(\"Generated new state %s.\", self._state)\n        except TypeError:\n            self._state = self.state\n            log.debug(\"Re-using previously supplied state %s.\", self._state)\n        return self._state\n\n    @property\n    def client_id(self):\n        return getattr(self._client, \"client_id\", None)\n\n    @client_id.setter\n    def client_id(self, value):\n        self._client.client_id = value\n\n    @client_id.deleter\n    def client_id(self):\n        del self._client.client_id\n\n    @property\n    def token(self):\n        return getattr(self._client, \"token\", None)\n\n    @token.setter\n    def token(self, value):\n        self._client.token = value\n        self._client.populate_token_attributes(value)\n\n    @property\n    def access_token(self):\n        return getattr(self._client, \"access_token\", None)\n\n    @access_token.setter\n    def access_token(self, value):\n        self._client.access_token = value\n\n    @access_token.deleter\n    def access_token(self):\n        del self._client.access_token\n\n    @property\n    def authorized(self):\n        \"\"\"Boolean that indicates whether this session has an OAuth token\n        or not. If `self.authorized` is True, you can reasonably expect\n        OAuth-protected requests to the resource to succeed. If\n        `self.authorized` is False, you need the user to go through the OAuth\n        authentication dance before OAuth-protected requests to the resource\n        will succeed.\n        \"\"\"\n        return bool(self.access_token)\n\n    def authorization_url(self, url, state=None, **kwargs):\n        \"\"\"Form an authorization URL.\n\n        :param url: Authorization endpoint url, must be HTTPS.\n        :param state: An optional state string for CSRF protection. If not\n                      given it will be generated for you.\n        :param kwargs: Extra parameters to include.\n        :return: authorization_url, state\n        \"\"\"\n        state = state or self.new_state()\n        if self._pkce:\n            self._code_verifier = self._client.create_code_verifier(43)\n            kwargs[\"code_challenge_method\"] = self._pkce\n            kwargs[\"code_challenge\"] = self._client.create_code_challenge(\n                code_verifier=self._code_verifier,\n                code_challenge_method=self._pkce\n            )\n        return (\n            self._client.prepare_request_uri(\n                url,\n                redirect_uri=self.redirect_uri,\n                scope=self.scope,\n                state=state,\n                **kwargs\n            ),\n            state,\n        )\n\n    def fetch_token(\n        self,\n        token_url,\n        code=None,\n        authorization_response=None,\n        body=\"\",\n        auth=None,\n        username=None,\n        password=None,\n        method=\"POST\",\n        force_querystring=False,\n        timeout=None,\n        headers=None,\n        verify=None,\n        proxies=None,\n        include_client_id=None,\n        client_secret=None,\n        cert=None,\n        **kwargs\n    ):\n        \"\"\"Generic method for fetching an access token from the token endpoint.\n\n        If you are using the MobileApplicationClient you will want to use\n        `token_from_fragment` instead of `fetch_token`.\n\n        The current implementation enforces the RFC guidelines.\n\n        :param token_url: Token endpoint URL, must use HTTPS.\n        :param code: Authorization code (used by WebApplicationClients).\n        :param authorization_response: Authorization response URL, the callback\n                                       URL of the request back to you. Used by\n                                       WebApplicationClients instead of code.\n        :param body: Optional application/x-www-form-urlencoded body to add the\n                     include in the token request. Prefer kwargs over body.\n        :param auth: An auth tuple or method as accepted by `requests`.\n        :param username: Username required by LegacyApplicationClients to appear\n                         in the request body.\n        :param password: Password required by LegacyApplicationClients to appear\n                         in the request body.\n        :param method: The HTTP method used to make the request. Defaults\n                       to POST, but may also be GET. Other methods should\n                       be added as needed.\n        :param force_querystring: If True, force the request body to be sent\n            in the querystring instead.\n        :param timeout: Timeout of the request in seconds.\n        :param headers: Dict to default request headers with.\n        :param verify: Verify SSL certificate.\n        :param proxies: The `proxies` argument is passed onto `requests`.\n        :param include_client_id: Should the request body include the\n                                  `client_id` parameter. Default is `None`,\n                                  which will attempt to autodetect. This can be\n                                  forced to always include (True) or never\n                                  include (False).\n        :param client_secret: The `client_secret` paired to the `client_id`.\n                              This is generally required unless provided in the\n                              `auth` tuple. If the value is `None`, it will be\n                              omitted from the request, however if the value is\n                              an empty string, an empty string will be sent.\n        :param cert: Client certificate to send for OAuth 2.0 Mutual-TLS Client\n                     Authentication (draft-ietf-oauth-mtls). Can either be the\n                     path of a file containing the private key and certificate or\n                     a tuple of two filenames for certificate and key.\n        :param kwargs: Extra parameters to include in the token request.\n        :return: A token dict\n        \"\"\"\n        if not is_secure_transport(token_url):\n            raise InsecureTransportError()\n\n        if not code and authorization_response:\n            self._client.parse_request_uri_response(\n                authorization_response, state=self._state\n            )\n            code = self._client.code\n        elif not code and isinstance(self._client, WebApplicationClient):\n            code = self._client.code\n            if not code:\n                raise ValueError(\n                    \"Please supply either code or \" \"authorization_response parameters.\"\n                )\n\n        if self._pkce:\n            if self._code_verifier is None:\n                raise ValueError(\n                    \"Code verifier is not found, authorization URL must be generated before\"\n                )\n            kwargs[\"code_verifier\"] = self._code_verifier\n\n        # Earlier versions of this library build an HTTPBasicAuth header out of\n        # `username` and `password`. The RFC states, however these attributes\n        # must be in the request body and not the header.\n        # If an upstream server is not spec compliant and requires them to\n        # appear as an Authorization header, supply an explicit `auth` header\n        # to this function.\n        # This check will allow for empty strings, but not `None`.\n        #\n        # References\n        # 4.3.2 - Resource Owner Password Credentials Grant\n        #         https://tools.ietf.org/html/rfc6749#section-4.3.2\n\n        if isinstance(self._client, LegacyApplicationClient):\n            if username is None:\n                raise ValueError(\n                    \"`LegacyApplicationClient` requires both the \"\n                    \"`username` and `password` parameters.\"\n                )\n            if password is None:\n                raise ValueError(\n                    \"The required parameter `username` was supplied, \"\n                    \"but `password` was not.\"\n                )\n\n        # merge username and password into kwargs for `prepare_request_body`\n        if username is not None:\n            kwargs[\"username\"] = username\n        if password is not None:\n            kwargs[\"password\"] = password\n\n        # is an auth explicitly supplied?\n        if auth is not None:\n            # if we're dealing with the default of `include_client_id` (None):\n            # we will assume the `auth` argument is for an RFC compliant server\n            # and we should not send the `client_id` in the body.\n            # This approach allows us to still force the client_id by submitting\n            # `include_client_id=True` along with an `auth` object.\n            if include_client_id is None:\n                include_client_id = False\n\n        # otherwise we may need to create an auth header\n        else:\n            # since we don't have an auth header, we MAY need to create one\n            # it is possible that we want to send the `client_id` in the body\n            # if so, `include_client_id` should be set to True\n            # otherwise, we will generate an auth header\n            if include_client_id is not True:\n                client_id = self.client_id\n                if client_id:\n                    log.debug(\n                        'Encoding `client_id` \"%s\" with `client_secret` '\n                        \"as Basic auth credentials.\",\n                        client_id,\n                    )\n                    client_secret = client_secret if client_secret is not None else \"\"\n                    auth = requests.auth.HTTPBasicAuth(client_id, client_secret)\n\n        if include_client_id:\n            # this was pulled out of the params\n            # it needs to be passed into prepare_request_body\n            if client_secret is not None:\n                kwargs[\"client_secret\"] = client_secret\n\n        body = self._client.prepare_request_body(\n            code=code,\n            body=body,\n            redirect_uri=self.redirect_uri,\n            include_client_id=include_client_id,\n            **kwargs\n        )\n\n        headers = headers or {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }\n        self.token = {}\n        request_kwargs = {}\n        if method.upper() == \"POST\":\n            request_kwargs[\"params\" if force_querystring else \"data\"] = dict(\n                urldecode(body)\n            )\n        elif method.upper() == \"GET\":\n            request_kwargs[\"params\"] = dict(urldecode(body))\n        else:\n            raise ValueError(\"The method kwarg must be POST or GET.\")\n\n        for hook in self.compliance_hook[\"access_token_request\"]:\n            log.debug(\"Invoking access_token_request hook %s.\", hook)\n            token_url, headers, request_kwargs = hook(\n                token_url, headers, request_kwargs\n            )\n\n        r = self.request(\n            method=method,\n            url=token_url,\n            timeout=timeout,\n            headers=headers,\n            auth=auth,\n            verify=verify,\n            proxies=proxies,\n            cert=cert,\n            **request_kwargs\n        )\n\n        log.debug(\"Request to fetch token completed with status %s.\", r.status_code)\n        log.debug(\"Request url was %s\", r.request.url)\n        log.debug(\"Request headers were %s\", r.request.headers)\n        log.debug(\"Request body was %s\", r.request.body)\n        log.debug(\"Response headers were %s and content %s.\", r.headers, r.text)\n        log.debug(\n            \"Invoking %d token response hooks.\",\n            len(self.compliance_hook[\"access_token_response\"]),\n        )\n        for hook in self.compliance_hook[\"access_token_response\"]:\n            log.debug(\"Invoking hook %s.\", hook)\n            r = hook(r)\n\n        self._client.parse_request_body_response(r.text, scope=self.scope)\n        self.token = self._client.token\n        log.debug(\"Obtained token %s.\", self.token)\n        return self.token\n\n    def token_from_fragment(self, authorization_response):\n        \"\"\"Parse token from the URI fragment, used by MobileApplicationClients.\n\n        :param authorization_response: The full URL of the redirect back to you\n        :return: A token dict\n        \"\"\"\n        self._client.parse_request_uri_response(\n            authorization_response, state=self._state\n        )\n        self.token = self._client.token\n        return self.token\n\n    def refresh_token(\n        self,\n        token_url,\n        refresh_token=None,\n        body=\"\",\n        auth=None,\n        timeout=None,\n        headers=None,\n        verify=None,\n        proxies=None,\n        **kwargs\n    ):\n        \"\"\"Fetch a new access token using a refresh token.\n\n        :param token_url: The token endpoint, must be HTTPS.\n        :param refresh_token: The refresh_token to use.\n        :param body: Optional application/x-www-form-urlencoded body to add the\n                     include in the token request. Prefer kwargs over body.\n        :param auth: An auth tuple or method as accepted by `requests`.\n        :param timeout: Timeout of the request in seconds.\n        :param headers: A dict of headers to be used by `requests`.\n        :param verify: Verify SSL certificate.\n        :param proxies: The `proxies` argument will be passed to `requests`.\n        :param kwargs: Extra parameters to include in the token request.\n        :return: A token dict\n        \"\"\"\n        if not token_url:\n            raise ValueError(\"No token endpoint set for auto_refresh.\")\n\n        if not is_secure_transport(token_url):\n            raise InsecureTransportError()\n\n        refresh_token = refresh_token or self.token.get(\"refresh_token\")\n\n        log.debug(\n            \"Adding auto refresh key word arguments %s.\", self.auto_refresh_kwargs\n        )\n        kwargs.update(self.auto_refresh_kwargs)\n        body = self._client.prepare_refresh_body(\n            body=body, refresh_token=refresh_token, scope=self.scope, **kwargs\n        )\n        log.debug(\"Prepared refresh token request body %s\", body)\n\n        if headers is None:\n            headers = {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": (\"application/x-www-form-urlencoded\"),\n            }\n\n        for hook in self.compliance_hook[\"refresh_token_request\"]:\n            log.debug(\"Invoking refresh_token_request hook %s.\", hook)\n            token_url, headers, body = hook(token_url, headers, body)\n\n        r = self.post(\n            token_url,\n            data=dict(urldecode(body)),\n            auth=auth,\n            timeout=timeout,\n            headers=headers,\n            verify=verify,\n            withhold_token=True,\n            proxies=proxies,\n        )\n        log.debug(\"Request to refresh token completed with status %s.\", r.status_code)\n        log.debug(\"Response headers were %s and content %s.\", r.headers, r.text)\n        log.debug(\n            \"Invoking %d token response hooks.\",\n            len(self.compliance_hook[\"refresh_token_response\"]),\n        )\n        for hook in self.compliance_hook[\"refresh_token_response\"]:\n            log.debug(\"Invoking hook %s.\", hook)\n            r = hook(r)\n\n        self.token = self._client.parse_request_body_response(r.text, scope=self.scope)\n        if \"refresh_token\" not in self.token:\n            log.debug(\"No new refresh token given. Re-using old.\")\n            self.token[\"refresh_token\"] = refresh_token\n        return self.token\n\n    def request(\n        self,\n        method,\n        url,\n        data=None,\n        headers=None,\n        withhold_token=False,\n        client_id=None,\n        client_secret=None,\n        files=None,\n        **kwargs\n    ):\n        \"\"\"Intercept all requests and add the OAuth 2 token if present.\"\"\"\n        if not is_secure_transport(url):\n            raise InsecureTransportError()\n        if self.token and not withhold_token:\n            log.debug(\n                \"Invoking %d protected resource request hooks.\",\n                len(self.compliance_hook[\"protected_request\"]),\n            )\n            for hook in self.compliance_hook[\"protected_request\"]:\n                log.debug(\"Invoking hook %s.\", hook)\n                url, headers, data = hook(url, headers, data)\n\n            log.debug(\"Adding token %s to request.\", self.token)\n            try:\n                url, headers, data = self._client.add_token(\n                    url, http_method=method, body=data, headers=headers\n                )\n            # Attempt to retrieve and save new access token if expired\n            except TokenExpiredError:\n                if self.auto_refresh_url:\n                    log.debug(\n                        \"Auto refresh is set, attempting to refresh at %s.\",\n                        self.auto_refresh_url,\n                    )\n\n                    # We mustn't pass auth twice.\n                    auth = kwargs.pop(\"auth\", None)\n                    if client_id and client_secret and (auth is None):\n                        log.debug(\n                            'Encoding client_id \"%s\" with client_secret as Basic auth credentials.',\n                            client_id,\n                        )\n                        auth = requests.auth.HTTPBasicAuth(client_id, client_secret)\n                    token = self.refresh_token(\n                        self.auto_refresh_url, auth=auth, **kwargs\n                    )\n                    if self.token_updater:\n                        log.debug(\n                            \"Updating token to %s using %s.\", token, self.token_updater\n                        )\n                        self.token_updater(token)\n                        url, headers, data = self._client.add_token(\n                            url, http_method=method, body=data, headers=headers\n                        )\n                    else:\n                        raise TokenUpdated(token)\n                else:\n                    raise\n\n        log.debug(\"Requesting url %s using method %s.\", url, method)\n        log.debug(\"Supplying headers %s and data %s\", headers, data)\n        log.debug(\"Passing through key word arguments %s.\", kwargs)\n        return super(OAuth2Session, self).request(\n            method, url, headers=headers, data=data, files=files, **kwargs\n        )\n\n    def register_compliance_hook(self, hook_type, hook):\n        \"\"\"Register a hook for request/response tweaking.\n\n        Available hooks are:\n            access_token_response invoked before token parsing.\n            refresh_token_response invoked before refresh token parsing.\n            protected_request invoked before making a request.\n            access_token_request invoked before making a token fetch request.\n            refresh_token_request invoked before making a refresh request.\n\n        If you find a new hook is needed please send a GitHub PR request\n        or open an issue.\n        \"\"\"\n        if hook_type not in self.compliance_hook:\n            raise ValueError(\n                \"Hook type %s is not in %s.\", hook_type, self.compliance_hook\n            )\n        self.compliance_hook[hook_type].add(hook)\n", "requests_oauthlib/compliance_fixes/fitbit.py": "\"\"\"\nThe Fitbit API breaks from the OAuth2 RFC standard by returning an \"errors\"\nobject list, rather than a single \"error\" string. This puts hooks in place so\nthat oauthlib can process an error in the results from access token and refresh\ntoken responses. This is necessary to prevent getting the generic red herring\nMissingTokenError.\n\"\"\"\n\nfrom json import loads, dumps\n\n\ndef fitbit_compliance_fix(session):\n    def _missing_error(r):\n        token = loads(r.text)\n        if \"errors\" in token:\n            # Set the error to the first one we have\n            token[\"error\"] = token[\"errors\"][0][\"errorType\"]\n        r._content = dumps(token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _missing_error)\n    session.register_compliance_hook(\"refresh_token_response\", _missing_error)\n    return session\n", "requests_oauthlib/compliance_fixes/facebook.py": "from json import dumps\nfrom urllib.parse import parse_qsl\n\n\ndef facebook_compliance_fix(session):\n    def _compliance_fix(r):\n        # if Facebook claims to be sending us json, let's trust them.\n        if \"application/json\" in r.headers.get(\"content-type\", {}):\n            return r\n\n        # Facebook returns a content-type of text/plain when sending their\n        # x-www-form-urlencoded responses, along with a 200. If not, let's\n        # assume we're getting JSON and bail on the fix.\n        if \"text/plain\" in r.headers.get(\"content-type\", {}) and r.status_code == 200:\n            token = dict(parse_qsl(r.text, keep_blank_values=True))\n        else:\n            return r\n\n        expires = token.get(\"expires\")\n        if expires is not None:\n            token[\"expires_in\"] = expires\n        token[\"token_type\"] = \"Bearer\"\n        r._content = dumps(token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _compliance_fix)\n    return session\n", "requests_oauthlib/compliance_fixes/plentymarkets.py": "from json import dumps, loads\nimport re\n\n\ndef plentymarkets_compliance_fix(session):\n    def _to_snake_case(n):\n        return re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", n).lower()\n\n    def _compliance_fix(r):\n        # Plenty returns the Token in CamelCase instead of _\n        if (\n            \"application/json\" in r.headers.get(\"content-type\", {})\n            and r.status_code == 200\n        ):\n            token = loads(r.text)\n        else:\n            return r\n\n        fixed_token = {}\n        for k, v in token.items():\n            fixed_token[_to_snake_case(k)] = v\n\n        r._content = dumps(fixed_token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _compliance_fix)\n    return session\n", "requests_oauthlib/compliance_fixes/douban.py": "import json\n\n\ndef douban_compliance_fix(session):\n    def fix_token_type(r):\n        token = json.loads(r.text)\n        token.setdefault(\"token_type\", \"Bearer\")\n        fixed_token = json.dumps(token)\n        r._content = fixed_token.encode()\n        return r\n\n    session._client_default_token_placement = \"query\"\n    session.register_compliance_hook(\"access_token_response\", fix_token_type)\n\n    return session\n", "requests_oauthlib/compliance_fixes/slack.py": "from urllib.parse import urlparse, parse_qs\n\nfrom oauthlib.common import add_params_to_uri\n\n\ndef slack_compliance_fix(session):\n    def _non_compliant_param_name(url, headers, data):\n        # If the user has already specified the token, either in the URL\n        # or in a data dictionary, then there's nothing to do.\n        # If the specified token is different from ``session.access_token``,\n        # we assume the user intends to override the access token.\n        url_query = dict(parse_qs(urlparse(url).query))\n        token = url_query.get(\"token\")\n        if not token and isinstance(data, dict):\n            token = data.get(\"token\")\n\n        if token:\n            # Nothing to do, just return.\n            return url, headers, data\n\n        if not data:\n            data = {\"token\": session.access_token}\n        elif isinstance(data, dict):\n            data[\"token\"] = session.access_token\n        else:\n            # ``data`` is something other than a dict: maybe a stream,\n            # maybe a file object, maybe something else. We can't easily\n            # modify it, so we'll set the token by modifying the URL instead.\n            token = [(\"token\", session.access_token)]\n            url = add_params_to_uri(url, token)\n        return url, headers, data\n\n    session.register_compliance_hook(\"protected_request\", _non_compliant_param_name)\n    return session\n", "requests_oauthlib/compliance_fixes/ebay.py": "import json\n\n\ndef ebay_compliance_fix(session):\n    def _compliance_fix(response):\n        token = json.loads(response.text)\n\n        # eBay responds with non-compliant token types.\n        # https://developer.ebay.com/api-docs/static/oauth-client-credentials-grant.html\n        # https://developer.ebay.com/api-docs/static/oauth-auth-code-grant-request.html\n        # Modify these to be \"Bearer\".\n        if token.get(\"token_type\") in [\"Application Access Token\", \"User Access Token\"]:\n            token[\"token_type\"] = \"Bearer\"\n            fixed_token = json.dumps(token)\n            response._content = fixed_token.encode()\n\n        return response\n\n    session.register_compliance_hook(\"access_token_response\", _compliance_fix)\n    session.register_compliance_hook(\"refresh_token_response\", _compliance_fix)\n\n    return session\n", "requests_oauthlib/compliance_fixes/mailchimp.py": "import json\n\n\ndef mailchimp_compliance_fix(session):\n    def _null_scope(r):\n        token = json.loads(r.text)\n        if \"scope\" in token and token[\"scope\"] is None:\n            token.pop(\"scope\")\n        r._content = json.dumps(token).encode()\n        return r\n\n    def _non_zero_expiration(r):\n        token = json.loads(r.text)\n        if \"expires_in\" in token and token[\"expires_in\"] == 0:\n            token[\"expires_in\"] = 3600\n        r._content = json.dumps(token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _null_scope)\n    session.register_compliance_hook(\"access_token_response\", _non_zero_expiration)\n    return session\n", "requests_oauthlib/compliance_fixes/weibo.py": "from json import loads, dumps\n\n\ndef weibo_compliance_fix(session):\n    def _missing_token_type(r):\n        token = loads(r.text)\n        token[\"token_type\"] = \"Bearer\"\n        r._content = dumps(token).encode()\n        return r\n\n    session._client.default_token_placement = \"query\"\n    session.register_compliance_hook(\"access_token_response\", _missing_token_type)\n    return session\n", "requests_oauthlib/compliance_fixes/__init__.py": "# ruff: noqa: F401\nfrom .facebook import facebook_compliance_fix\nfrom .fitbit import fitbit_compliance_fix\nfrom .slack import slack_compliance_fix\nfrom .instagram import instagram_compliance_fix\nfrom .mailchimp import mailchimp_compliance_fix\nfrom .weibo import weibo_compliance_fix\nfrom .plentymarkets import plentymarkets_compliance_fix\nfrom .ebay import ebay_compliance_fix\n", "requests_oauthlib/compliance_fixes/instagram.py": "from urllib.parse import urlparse, parse_qs\n\nfrom oauthlib.common import add_params_to_uri\n\n\ndef instagram_compliance_fix(session):\n    def _non_compliant_param_name(url, headers, data):\n        # If the user has already specified the token in the URL\n        # then there's nothing to do.\n        # If the specified token is different from ``session.access_token``,\n        # we assume the user intends to override the access token.\n        url_query = dict(parse_qs(urlparse(url).query))\n        token = url_query.get(\"access_token\")\n        if token:\n            # Nothing to do, just return.\n            return url, headers, data\n\n        token = [(\"access_token\", session.access_token)]\n        url = add_params_to_uri(url, token)\n        return url, headers, data\n\n    session.register_compliance_hook(\"protected_request\", _non_compliant_param_name)\n    return session\n"}