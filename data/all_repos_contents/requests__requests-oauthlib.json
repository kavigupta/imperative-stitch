{"setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport re\n\nfrom setuptools import setup\n\n\n# Get the version\nversion_regex = r'__version__ = [\"\\']([^\"\\']*)[\"\\']'\nwith open(\"requests_oauthlib/__init__.py\", \"r\") as f:\n    text = f.read()\n    match = re.search(version_regex, text)\n\n    if match:\n        VERSION = match.group(1)\n    else:\n        raise RuntimeError(\"No version number found!\")\n\n\nAPP_NAME = \"requests-oauthlib\"\n\n# Publish Helper.\nif sys.argv[-1] == \"publish\":\n    os.system(\"python setup.py sdist upload\")\n    sys.exit()\n\n\ndef readall(path):\n    with open(path) as fp:\n        return fp.read()\n\n\nsetup(\n    name=APP_NAME,\n    version=VERSION,\n    description=\"OAuthlib authentication support for Requests.\",\n    long_description=readall(\"README.rst\") + \"\\n\\n\" + readall(\"HISTORY.rst\"),\n    long_description_content_type=\"text/x-rst\",\n    author=\"Kenneth Reitz\",\n    author_email=\"me@kennethreitz.com\",\n    url=\"https://github.com/requests/requests-oauthlib\",\n    packages=[\"requests_oauthlib\", \"requests_oauthlib.compliance_fixes\"],\n    python_requires=\">=3.7\",\n    install_requires=[\"oauthlib>=3.0.0\", \"requests>=2.0.0\"],\n    extras_require={\"rsa\": [\"oauthlib[signedtoken]>=3.0.0\"]},\n    license=\"ISC\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Natural Language :: English\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n    ],\n    zip_safe=False,\n    tests_require=['mock;python_version<\"3.3\"', \"requests-mock\"],\n    test_suite=\"tests\",\n)\n", "requests_oauthlib/oauth1_session.py": "from urllib.parse import urlparse\n\nimport logging\n\nfrom oauthlib.common import add_params_to_uri\nfrom oauthlib.common import urldecode as _urldecode\nfrom oauthlib.oauth1 import SIGNATURE_HMAC, SIGNATURE_RSA, SIGNATURE_TYPE_AUTH_HEADER\nimport requests\n\nfrom . import OAuth1\n\n\nlog = logging.getLogger(__name__)\n\n\ndef urldecode(body):\n    \"\"\"Parse query or json to python dictionary\"\"\"\n    try:\n        return _urldecode(body)\n    except Exception:\n        import json\n\n        return json.loads(body)\n\n\nclass TokenRequestDenied(ValueError):\n    def __init__(self, message, response):\n        super(TokenRequestDenied, self).__init__(message)\n        self.response = response\n\n    @property\n    def status_code(self):\n        \"\"\"For backwards-compatibility purposes\"\"\"\n        return self.response.status_code\n\n\nclass TokenMissing(ValueError):\n    def __init__(self, message, response):\n        super(TokenMissing, self).__init__(message)\n        self.response = response\n\n\nclass VerifierMissing(ValueError):\n    pass\n\n\nclass OAuth1Session(requests.Session):\n    \"\"\"Request signing and convenience methods for the oauth dance.\n\n    What is the difference between OAuth1Session and OAuth1?\n\n    OAuth1Session actually uses OAuth1 internally and its purpose is to assist\n    in the OAuth workflow through convenience methods to prepare authorization\n    URLs and parse the various token and redirection responses. It also provide\n    rudimentary validation of responses.\n\n    An example of the OAuth workflow using a basic CLI app and Twitter.\n\n    >>> # Credentials obtained during the registration.\n    >>> client_key = 'client key'\n    >>> client_secret = 'secret'\n    >>> callback_uri = 'https://127.0.0.1/callback'\n    >>>\n    >>> # Endpoints found in the OAuth provider API documentation\n    >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n    >>> authorization_url = 'https://api.twitter.com/oauth/authorize'\n    >>> access_token_url = 'https://api.twitter.com/oauth/access_token'\n    >>>\n    >>> oauth_session = OAuth1Session(client_key,client_secret=client_secret, callback_uri=callback_uri)\n    >>>\n    >>> # First step, fetch the request token.\n    >>> oauth_session.fetch_request_token(request_token_url)\n    {\n        'oauth_token': 'kjerht2309u',\n        'oauth_token_secret': 'lsdajfh923874',\n    }\n    >>>\n    >>> # Second step. Follow this link and authorize\n    >>> oauth_session.authorization_url(authorization_url)\n    'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf&oauth_callback=https%3A%2F%2F127.0.0.1%2Fcallback'\n    >>>\n    >>> # Third step. Fetch the access token\n    >>> redirect_response = input('Paste the full redirect URL here.')\n    >>> oauth_session.parse_authorization_response(redirect_response)\n    {\n        'oauth_token: 'kjerht2309u',\n        'oauth_token_secret: 'lsdajfh923874',\n        'oauth_verifier: 'w34o8967345',\n    }\n    >>> oauth_session.fetch_access_token(access_token_url)\n    {\n        'oauth_token': 'sdf0o9823sjdfsdf',\n        'oauth_token_secret': '2kjshdfp92i34asdasd',\n    }\n    >>> # Done. You can now make OAuth requests.\n    >>> status_url = 'http://api.twitter.com/1/statuses/update.json'\n    >>> new_status = {'status':  'hello world!'}\n    >>> oauth_session.post(status_url, data=new_status)\n    <Response [200]>\n    \"\"\"\n\n    def __init__(\n        self,\n        client_key,\n        client_secret=None,\n        resource_owner_key=None,\n        resource_owner_secret=None,\n        callback_uri=None,\n        signature_method=SIGNATURE_HMAC,\n        signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n        rsa_key=None,\n        verifier=None,\n        client_class=None,\n        force_include_body=False,\n        **kwargs\n    ):\n        \"\"\"Construct the OAuth 1 session.\n\n        :param client_key: A client specific identifier.\n        :param client_secret: A client specific secret used to create HMAC and\n                              plaintext signatures.\n        :param resource_owner_key: A resource owner key, also referred to as\n                                   request token or access token depending on\n                                   when in the workflow it is used.\n        :param resource_owner_secret: A resource owner secret obtained with\n                                      either a request or access token. Often\n                                      referred to as token secret.\n        :param callback_uri: The URL the user is redirect back to after\n                             authorization.\n        :param signature_method: Signature methods determine how the OAuth\n                                 signature is created. The three options are\n                                 oauthlib.oauth1.SIGNATURE_HMAC (default),\n                                 oauthlib.oauth1.SIGNATURE_RSA and\n                                 oauthlib.oauth1.SIGNATURE_PLAIN.\n        :param signature_type: Signature type decides where the OAuth\n                               parameters are added. Either in the\n                               Authorization header (default) or to the URL\n                               query parameters or the request body. Defined as\n                               oauthlib.oauth1.SIGNATURE_TYPE_AUTH_HEADER,\n                               oauthlib.oauth1.SIGNATURE_TYPE_QUERY and\n                               oauthlib.oauth1.SIGNATURE_TYPE_BODY\n                               respectively.\n        :param rsa_key: The private RSA key as a string. Can only be used with\n                        signature_method=oauthlib.oauth1.SIGNATURE_RSA.\n        :param verifier: A verifier string to prove authorization was granted.\n        :param client_class: A subclass of `oauthlib.oauth1.Client` to use with\n                             `requests_oauthlib.OAuth1` instead of the default\n        :param force_include_body: Always include the request body in the\n                                   signature creation.\n        :param **kwargs: Additional keyword arguments passed to `OAuth1`\n        \"\"\"\n        super(OAuth1Session, self).__init__()\n        self._client = OAuth1(\n            client_key,\n            client_secret=client_secret,\n            resource_owner_key=resource_owner_key,\n            resource_owner_secret=resource_owner_secret,\n            callback_uri=callback_uri,\n            signature_method=signature_method,\n            signature_type=signature_type,\n            rsa_key=rsa_key,\n            verifier=verifier,\n            client_class=client_class,\n            force_include_body=force_include_body,\n            **kwargs\n        )\n        self.auth = self._client\n\n    @property\n    def token(self):\n        oauth_token = self._client.client.resource_owner_key\n        oauth_token_secret = self._client.client.resource_owner_secret\n        oauth_verifier = self._client.client.verifier\n\n        token_dict = {}\n        if oauth_token:\n            token_dict[\"oauth_token\"] = oauth_token\n        if oauth_token_secret:\n            token_dict[\"oauth_token_secret\"] = oauth_token_secret\n        if oauth_verifier:\n            token_dict[\"oauth_verifier\"] = oauth_verifier\n\n        return token_dict\n\n    @token.setter\n    def token(self, value):\n        self._populate_attributes(value)\n\n    @property\n    def authorized(self):\n        \"\"\"Boolean that indicates whether this session has an OAuth token\n        or not. If `self.authorized` is True, you can reasonably expect\n        OAuth-protected requests to the resource to succeed. If\n        `self.authorized` is False, you need the user to go through the OAuth\n        authentication dance before OAuth-protected requests to the resource\n        will succeed.\n        \"\"\"\n        if self._client.client.signature_method == SIGNATURE_RSA:\n            # RSA only uses resource_owner_key\n            return bool(self._client.client.resource_owner_key)\n        else:\n            # other methods of authentication use all three pieces\n            return (\n                bool(self._client.client.client_secret)\n                and bool(self._client.client.resource_owner_key)\n                and bool(self._client.client.resource_owner_secret)\n            )\n\n    def authorization_url(self, url, request_token=None, **kwargs):\n        \"\"\"Create an authorization URL by appending request_token and optional\n        kwargs to url.\n\n        This is the second step in the OAuth 1 workflow. The user should be\n        redirected to this authorization URL, grant access to you, and then\n        be redirected back to you. The redirection back can either be specified\n        during client registration or by supplying a callback URI per request.\n\n        :param url: The authorization endpoint URL.\n        :param request_token: The previously obtained request token.\n        :param kwargs: Optional parameters to append to the URL.\n        :returns: The authorization URL with new parameters embedded.\n\n        An example using a registered default callback URI.\n\n        >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n        >>> authorization_url = 'https://api.twitter.com/oauth/authorize'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.fetch_request_token(request_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        >>> oauth_session.authorization_url(authorization_url)\n        'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf'\n        >>> oauth_session.authorization_url(authorization_url, foo='bar')\n        'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf&foo=bar'\n\n        An example using an explicit callback URI.\n\n        >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n        >>> authorization_url = 'https://api.twitter.com/oauth/authorize'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret', callback_uri='https://127.0.0.1/callback')\n        >>> oauth_session.fetch_request_token(request_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        >>> oauth_session.authorization_url(authorization_url)\n        'https://api.twitter.com/oauth/authorize?oauth_token=sdf0o9823sjdfsdf&oauth_callback=https%3A%2F%2F127.0.0.1%2Fcallback'\n        \"\"\"\n        kwargs[\"oauth_token\"] = request_token or self._client.client.resource_owner_key\n        log.debug(\"Adding parameters %s to url %s\", kwargs, url)\n        return add_params_to_uri(url, kwargs.items())\n\n    def fetch_request_token(self, url, realm=None, **request_kwargs):\n        \"\"\"Fetch a request token.\n\n        This is the first step in the OAuth 1 workflow. A request token is\n        obtained by making a signed post request to url. The token is then\n        parsed from the application/x-www-form-urlencoded response and ready\n        to be used to construct an authorization url.\n\n        :param url: The request token endpoint URL.\n        :param realm: A list of realms to request access to.\n        :param request_kwargs: Optional arguments passed to ''post''\n            function in ''requests.Session''\n        :returns: The response in dict format.\n\n        Note that a previously set callback_uri will be reset for your\n        convenience, or else signature creation will be incorrect on\n        consecutive requests.\n\n        >>> request_token_url = 'https://api.twitter.com/oauth/request_token'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.fetch_request_token(request_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        \"\"\"\n        self._client.client.realm = \" \".join(realm) if realm else None\n        token = self._fetch_token(url, **request_kwargs)\n        log.debug(\"Resetting callback_uri and realm (not needed in next phase).\")\n        self._client.client.callback_uri = None\n        self._client.client.realm = None\n        return token\n\n    def fetch_access_token(self, url, verifier=None, **request_kwargs):\n        \"\"\"Fetch an access token.\n\n        This is the final step in the OAuth 1 workflow. An access token is\n        obtained using all previously obtained credentials, including the\n        verifier from the authorization step.\n\n        Note that a previously set verifier will be reset for your\n        convenience, or else signature creation will be incorrect on\n        consecutive requests.\n\n        >>> access_token_url = 'https://api.twitter.com/oauth/access_token'\n        >>> redirect_response = 'https://127.0.0.1/callback?oauth_token=kjerht2309uf&oauth_token_secret=lsdajfh923874&oauth_verifier=w34o8967345'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.parse_authorization_response(redirect_response)\n        {\n            'oauth_token: 'kjerht2309u',\n            'oauth_token_secret: 'lsdajfh923874',\n            'oauth_verifier: 'w34o8967345',\n        }\n        >>> oauth_session.fetch_access_token(access_token_url)\n        {\n            'oauth_token': 'sdf0o9823sjdfsdf',\n            'oauth_token_secret': '2kjshdfp92i34asdasd',\n        }\n        \"\"\"\n        if verifier:\n            self._client.client.verifier = verifier\n        if not getattr(self._client.client, \"verifier\", None):\n            raise VerifierMissing(\"No client verifier has been set.\")\n        token = self._fetch_token(url, **request_kwargs)\n        log.debug(\"Resetting verifier attribute, should not be used anymore.\")\n        self._client.client.verifier = None\n        return token\n\n    def parse_authorization_response(self, url):\n        \"\"\"Extract parameters from the post authorization redirect response URL.\n\n        :param url: The full URL that resulted from the user being redirected\n                    back from the OAuth provider to you, the client.\n        :returns: A dict of parameters extracted from the URL.\n\n        >>> redirect_response = 'https://127.0.0.1/callback?oauth_token=kjerht2309uf&oauth_token_secret=lsdajfh923874&oauth_verifier=w34o8967345'\n        >>> oauth_session = OAuth1Session('client-key', client_secret='secret')\n        >>> oauth_session.parse_authorization_response(redirect_response)\n        {\n            'oauth_token: 'kjerht2309u',\n            'oauth_token_secret: 'lsdajfh923874',\n            'oauth_verifier: 'w34o8967345',\n        }\n        \"\"\"\n        log.debug(\"Parsing token from query part of url %s\", url)\n        token = dict(urldecode(urlparse(url).query))\n        log.debug(\"Updating internal client token attribute.\")\n        self._populate_attributes(token)\n        self.token = token\n        return token\n\n    def _populate_attributes(self, token):\n        if \"oauth_token\" in token:\n            self._client.client.resource_owner_key = token[\"oauth_token\"]\n        else:\n            raise TokenMissing(\n                \"Response does not contain a token: {resp}\".format(resp=token), token\n            )\n        if \"oauth_token_secret\" in token:\n            self._client.client.resource_owner_secret = token[\"oauth_token_secret\"]\n        if \"oauth_verifier\" in token:\n            self._client.client.verifier = token[\"oauth_verifier\"]\n\n    def _fetch_token(self, url, **request_kwargs):\n        log.debug(\"Fetching token from %s using client %s\", url, self._client.client)\n        r = self.post(url, **request_kwargs)\n\n        if r.status_code >= 400:\n            error = \"Token request failed with code %s, response was '%s'.\"\n            raise TokenRequestDenied(error % (r.status_code, r.text), r)\n\n        log.debug('Decoding token from response \"%s\"', r.text)\n        try:\n            token = dict(urldecode(r.text.strip()))\n        except ValueError as e:\n            error = (\n                \"Unable to decode token from token response. \"\n                \"This is commonly caused by an unsuccessful request where\"\n                \" a non urlencoded error message is returned. \"\n                \"The decoding error was %s\"\n                \"\" % e\n            )\n            raise ValueError(error)\n\n        log.debug(\"Obtained token %s\", token)\n        log.debug(\"Updating internal client attributes from token data.\")\n        self._populate_attributes(token)\n        self.token = token\n        return token\n\n    def rebuild_auth(self, prepared_request, response):\n        \"\"\"\n        When being redirected we should always strip Authorization\n        header, since nonce may not be reused as per OAuth spec.\n        \"\"\"\n        if \"Authorization\" in prepared_request.headers:\n            # If we get redirected to a new host, we should strip out\n            # any authentication headers.\n            prepared_request.headers.pop(\"Authorization\", True)\n            prepared_request.prepare_auth(self.auth)\n        return\n", "requests_oauthlib/oauth2_auth.py": "from oauthlib.oauth2 import WebApplicationClient, InsecureTransportError\nfrom oauthlib.oauth2 import is_secure_transport\nfrom requests.auth import AuthBase\n\n\nclass OAuth2(AuthBase):\n    \"\"\"Adds proof of authorization (OAuth2 token) to the request.\"\"\"\n\n    def __init__(self, client_id=None, client=None, token=None):\n        \"\"\"Construct a new OAuth 2 authorization object.\n\n        :param client_id: Client id obtained during registration\n        :param client: :class:`oauthlib.oauth2.Client` to be used. Default is\n                       WebApplicationClient which is useful for any\n                       hosted application but not mobile or desktop.\n        :param token: Token dictionary, must include access_token\n                      and token_type.\n        \"\"\"\n        self._client = client or WebApplicationClient(client_id, token=token)\n        if token:\n            for k, v in token.items():\n                setattr(self._client, k, v)\n\n    def __call__(self, r):\n        \"\"\"Append an OAuth 2 token to the request.\n\n        Note that currently HTTPS is required for all requests. There may be\n        a token type that allows for plain HTTP in the future and then this\n        should be updated to allow plain HTTP on a white list basis.\n        \"\"\"\n        if not is_secure_transport(r.url):\n            raise InsecureTransportError()\n        r.url, r.headers, r.body = self._client.add_token(\n            r.url, http_method=r.method, body=r.body, headers=r.headers\n        )\n        return r\n", "requests_oauthlib/oauth1_auth.py": "# -*- coding: utf-8 -*-\nimport logging\n\nfrom oauthlib.common import extract_params\nfrom oauthlib.oauth1 import Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER\nfrom oauthlib.oauth1 import SIGNATURE_TYPE_BODY\nfrom requests.utils import to_native_string\nfrom requests.auth import AuthBase\n\nCONTENT_TYPE_FORM_URLENCODED = \"application/x-www-form-urlencoded\"\nCONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\n\n\nlog = logging.getLogger(__name__)\n\n# OBS!: Correct signing of requests are conditional on invoking OAuth1\n# as the last step of preparing a request, or at least having the\n# content-type set properly.\nclass OAuth1(AuthBase):\n    \"\"\"Signs the request using OAuth 1 (RFC5849)\"\"\"\n\n    client_class = Client\n\n    def __init__(\n        self,\n        client_key,\n        client_secret=None,\n        resource_owner_key=None,\n        resource_owner_secret=None,\n        callback_uri=None,\n        signature_method=SIGNATURE_HMAC,\n        signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n        rsa_key=None,\n        verifier=None,\n        decoding=\"utf-8\",\n        client_class=None,\n        force_include_body=False,\n        **kwargs\n    ):\n\n        try:\n            signature_type = signature_type.upper()\n        except AttributeError:\n            pass\n\n        client_class = client_class or self.client_class\n\n        self.force_include_body = force_include_body\n\n        self.client = client_class(\n            client_key,\n            client_secret,\n            resource_owner_key,\n            resource_owner_secret,\n            callback_uri,\n            signature_method,\n            signature_type,\n            rsa_key,\n            verifier,\n            decoding=decoding,\n            **kwargs\n        )\n\n    def __call__(self, r):\n        \"\"\"Add OAuth parameters to the request.\n\n        Parameters may be included from the body if the content-type is\n        urlencoded, if no content type is set a guess is made.\n        \"\"\"\n        # Overwriting url is safe here as request will not modify it past\n        # this point.\n        log.debug(\"Signing request %s using client %s\", r, self.client)\n\n        content_type = r.headers.get(\"Content-Type\", \"\")\n        if (\n            not content_type\n            and extract_params(r.body)\n            or self.client.signature_type == SIGNATURE_TYPE_BODY\n        ):\n            content_type = CONTENT_TYPE_FORM_URLENCODED\n        if not isinstance(content_type, str):\n            content_type = content_type.decode(\"utf-8\")\n\n        is_form_encoded = CONTENT_TYPE_FORM_URLENCODED in content_type\n\n        log.debug(\n            \"Including body in call to sign: %s\",\n            is_form_encoded or self.force_include_body,\n        )\n\n        if is_form_encoded:\n            r.headers[\"Content-Type\"] = CONTENT_TYPE_FORM_URLENCODED\n            r.url, headers, r.body = self.client.sign(\n                str(r.url), str(r.method), r.body or \"\", r.headers\n            )\n        elif self.force_include_body:\n            # To allow custom clients to work on non form encoded bodies.\n            r.url, headers, r.body = self.client.sign(\n                str(r.url), str(r.method), r.body or \"\", r.headers\n            )\n        else:\n            # Omit body data in the signing of non form-encoded requests\n            r.url, headers, _ = self.client.sign(\n                str(r.url), str(r.method), None, r.headers\n            )\n\n        r.prepare_headers(headers)\n        r.url = to_native_string(r.url)\n        log.debug(\"Updated url: %s\", r.url)\n        log.debug(\"Updated headers: %s\", headers)\n        log.debug(\"Updated body: %r\", r.body)\n        return r\n", "requests_oauthlib/__init__.py": "# ruff: noqa: F401\nimport logging\n\nfrom .oauth1_auth import OAuth1\nfrom .oauth1_session import OAuth1Session\nfrom .oauth2_auth import OAuth2\nfrom .oauth2_session import OAuth2Session, TokenUpdated\n\n__version__ = \"2.0.0\"\n\nimport requests\n\nif requests.__version__ < \"2.0.0\":\n    msg = (\n        \"You are using requests version %s, which is older than \"\n        \"requests-oauthlib expects, please upgrade to 2.0.0 or later.\"\n    )\n    raise Warning(msg % requests.__version__)\n\nlogging.getLogger(\"requests_oauthlib\").addHandler(logging.NullHandler())\n", "requests_oauthlib/oauth2_session.py": "import logging\n\nfrom oauthlib.common import generate_token, urldecode\nfrom oauthlib.oauth2 import WebApplicationClient, InsecureTransportError\nfrom oauthlib.oauth2 import LegacyApplicationClient\nfrom oauthlib.oauth2 import TokenExpiredError, is_secure_transport\nimport requests\n\nlog = logging.getLogger(__name__)\n\n\nclass TokenUpdated(Warning):\n    def __init__(self, token):\n        super(TokenUpdated, self).__init__()\n        self.token = token\n\n\nclass OAuth2Session(requests.Session):\n    \"\"\"Versatile OAuth 2 extension to :class:`requests.Session`.\n\n    Supports any grant type adhering to :class:`oauthlib.oauth2.Client` spec\n    including the four core OAuth 2 grants.\n\n    Can be used to create authorization urls, fetch tokens and access protected\n    resources using the :class:`requests.Session` interface you are used to.\n\n    - :class:`oauthlib.oauth2.WebApplicationClient` (default): Authorization Code Grant\n    - :class:`oauthlib.oauth2.MobileApplicationClient`: Implicit Grant\n    - :class:`oauthlib.oauth2.LegacyApplicationClient`: Password Credentials Grant\n    - :class:`oauthlib.oauth2.BackendApplicationClient`: Client Credentials Grant\n\n    Note that the only time you will be using Implicit Grant from python is if\n    you are driving a user agent able to obtain URL fragments.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id=None,\n        client=None,\n        auto_refresh_url=None,\n        auto_refresh_kwargs=None,\n        scope=None,\n        redirect_uri=None,\n        token=None,\n        state=None,\n        token_updater=None,\n        pkce=None,\n        **kwargs\n    ):\n        \"\"\"Construct a new OAuth 2 client session.\n\n        :param client_id: Client id obtained during registration\n        :param client: :class:`oauthlib.oauth2.Client` to be used. Default is\n                       WebApplicationClient which is useful for any\n                       hosted application but not mobile or desktop.\n        :param scope: List of scopes you wish to request access to\n        :param redirect_uri: Redirect URI you registered as callback\n        :param token: Token dictionary, must include access_token\n                      and token_type.\n        :param state: State string used to prevent CSRF. This will be given\n                      when creating the authorization url and must be supplied\n                      when parsing the authorization response.\n                      Can be either a string or a no argument callable.\n        :auto_refresh_url: Refresh token endpoint URL, must be HTTPS. Supply\n                           this if you wish the client to automatically refresh\n                           your access tokens.\n        :auto_refresh_kwargs: Extra arguments to pass to the refresh token\n                              endpoint.\n        :token_updater: Method with one argument, token, to be used to update\n                        your token database on automatic token refresh. If not\n                        set a TokenUpdated warning will be raised when a token\n                        has been refreshed. This warning will carry the token\n                        in its token argument.\n        :param pkce: Set \"S256\" or \"plain\" to enable PKCE. Default is disabled.\n        :param kwargs: Arguments to pass to the Session constructor.\n        \"\"\"\n        super(OAuth2Session, self).__init__(**kwargs)\n        self._client = client or WebApplicationClient(client_id, token=token)\n        self.token = token or {}\n        self._scope = scope\n        self.redirect_uri = redirect_uri\n        self.state = state or generate_token\n        self._state = state\n        self.auto_refresh_url = auto_refresh_url\n        self.auto_refresh_kwargs = auto_refresh_kwargs or {}\n        self.token_updater = token_updater\n        self._pkce = pkce\n\n        if self._pkce not in [\"S256\", \"plain\", None]:\n            raise AttributeError(\"Wrong value for {}(.., pkce={})\".format(self.__class__, self._pkce))\n\n        # Ensure that requests doesn't do any automatic auth. See #278.\n        # The default behavior can be re-enabled by setting auth to None.\n        self.auth = lambda r: r\n\n        # Allow customizations for non compliant providers through various\n        # hooks to adjust requests and responses.\n        self.compliance_hook = {\n            \"access_token_response\": set(),\n            \"refresh_token_response\": set(),\n            \"protected_request\": set(),\n            \"refresh_token_request\": set(),\n            \"access_token_request\": set(),\n        }\n\n    @property\n    def scope(self):\n        \"\"\"By default the scope from the client is used, except if overridden\"\"\"\n        if self._scope is not None:\n            return self._scope\n        elif self._client is not None:\n            return self._client.scope\n        else:\n            return None\n\n    @scope.setter\n    def scope(self, scope):\n        self._scope = scope\n\n    def new_state(self):\n        \"\"\"Generates a state string to be used in authorizations.\"\"\"\n        try:\n            self._state = self.state()\n            log.debug(\"Generated new state %s.\", self._state)\n        except TypeError:\n            self._state = self.state\n            log.debug(\"Re-using previously supplied state %s.\", self._state)\n        return self._state\n\n    @property\n    def client_id(self):\n        return getattr(self._client, \"client_id\", None)\n\n    @client_id.setter\n    def client_id(self, value):\n        self._client.client_id = value\n\n    @client_id.deleter\n    def client_id(self):\n        del self._client.client_id\n\n    @property\n    def token(self):\n        return getattr(self._client, \"token\", None)\n\n    @token.setter\n    def token(self, value):\n        self._client.token = value\n        self._client.populate_token_attributes(value)\n\n    @property\n    def access_token(self):\n        return getattr(self._client, \"access_token\", None)\n\n    @access_token.setter\n    def access_token(self, value):\n        self._client.access_token = value\n\n    @access_token.deleter\n    def access_token(self):\n        del self._client.access_token\n\n    @property\n    def authorized(self):\n        \"\"\"Boolean that indicates whether this session has an OAuth token\n        or not. If `self.authorized` is True, you can reasonably expect\n        OAuth-protected requests to the resource to succeed. If\n        `self.authorized` is False, you need the user to go through the OAuth\n        authentication dance before OAuth-protected requests to the resource\n        will succeed.\n        \"\"\"\n        return bool(self.access_token)\n\n    def authorization_url(self, url, state=None, **kwargs):\n        \"\"\"Form an authorization URL.\n\n        :param url: Authorization endpoint url, must be HTTPS.\n        :param state: An optional state string for CSRF protection. If not\n                      given it will be generated for you.\n        :param kwargs: Extra parameters to include.\n        :return: authorization_url, state\n        \"\"\"\n        state = state or self.new_state()\n        if self._pkce:\n            self._code_verifier = self._client.create_code_verifier(43)\n            kwargs[\"code_challenge_method\"] = self._pkce\n            kwargs[\"code_challenge\"] = self._client.create_code_challenge(\n                code_verifier=self._code_verifier,\n                code_challenge_method=self._pkce\n            )\n        return (\n            self._client.prepare_request_uri(\n                url,\n                redirect_uri=self.redirect_uri,\n                scope=self.scope,\n                state=state,\n                **kwargs\n            ),\n            state,\n        )\n\n    def fetch_token(\n        self,\n        token_url,\n        code=None,\n        authorization_response=None,\n        body=\"\",\n        auth=None,\n        username=None,\n        password=None,\n        method=\"POST\",\n        force_querystring=False,\n        timeout=None,\n        headers=None,\n        verify=None,\n        proxies=None,\n        include_client_id=None,\n        client_secret=None,\n        cert=None,\n        **kwargs\n    ):\n        \"\"\"Generic method for fetching an access token from the token endpoint.\n\n        If you are using the MobileApplicationClient you will want to use\n        `token_from_fragment` instead of `fetch_token`.\n\n        The current implementation enforces the RFC guidelines.\n\n        :param token_url: Token endpoint URL, must use HTTPS.\n        :param code: Authorization code (used by WebApplicationClients).\n        :param authorization_response: Authorization response URL, the callback\n                                       URL of the request back to you. Used by\n                                       WebApplicationClients instead of code.\n        :param body: Optional application/x-www-form-urlencoded body to add the\n                     include in the token request. Prefer kwargs over body.\n        :param auth: An auth tuple or method as accepted by `requests`.\n        :param username: Username required by LegacyApplicationClients to appear\n                         in the request body.\n        :param password: Password required by LegacyApplicationClients to appear\n                         in the request body.\n        :param method: The HTTP method used to make the request. Defaults\n                       to POST, but may also be GET. Other methods should\n                       be added as needed.\n        :param force_querystring: If True, force the request body to be sent\n            in the querystring instead.\n        :param timeout: Timeout of the request in seconds.\n        :param headers: Dict to default request headers with.\n        :param verify: Verify SSL certificate.\n        :param proxies: The `proxies` argument is passed onto `requests`.\n        :param include_client_id: Should the request body include the\n                                  `client_id` parameter. Default is `None`,\n                                  which will attempt to autodetect. This can be\n                                  forced to always include (True) or never\n                                  include (False).\n        :param client_secret: The `client_secret` paired to the `client_id`.\n                              This is generally required unless provided in the\n                              `auth` tuple. If the value is `None`, it will be\n                              omitted from the request, however if the value is\n                              an empty string, an empty string will be sent.\n        :param cert: Client certificate to send for OAuth 2.0 Mutual-TLS Client\n                     Authentication (draft-ietf-oauth-mtls). Can either be the\n                     path of a file containing the private key and certificate or\n                     a tuple of two filenames for certificate and key.\n        :param kwargs: Extra parameters to include in the token request.\n        :return: A token dict\n        \"\"\"\n        if not is_secure_transport(token_url):\n            raise InsecureTransportError()\n\n        if not code and authorization_response:\n            self._client.parse_request_uri_response(\n                authorization_response, state=self._state\n            )\n            code = self._client.code\n        elif not code and isinstance(self._client, WebApplicationClient):\n            code = self._client.code\n            if not code:\n                raise ValueError(\n                    \"Please supply either code or \" \"authorization_response parameters.\"\n                )\n\n        if self._pkce:\n            if self._code_verifier is None:\n                raise ValueError(\n                    \"Code verifier is not found, authorization URL must be generated before\"\n                )\n            kwargs[\"code_verifier\"] = self._code_verifier\n\n        # Earlier versions of this library build an HTTPBasicAuth header out of\n        # `username` and `password`. The RFC states, however these attributes\n        # must be in the request body and not the header.\n        # If an upstream server is not spec compliant and requires them to\n        # appear as an Authorization header, supply an explicit `auth` header\n        # to this function.\n        # This check will allow for empty strings, but not `None`.\n        #\n        # References\n        # 4.3.2 - Resource Owner Password Credentials Grant\n        #         https://tools.ietf.org/html/rfc6749#section-4.3.2\n\n        if isinstance(self._client, LegacyApplicationClient):\n            if username is None:\n                raise ValueError(\n                    \"`LegacyApplicationClient` requires both the \"\n                    \"`username` and `password` parameters.\"\n                )\n            if password is None:\n                raise ValueError(\n                    \"The required parameter `username` was supplied, \"\n                    \"but `password` was not.\"\n                )\n\n        # merge username and password into kwargs for `prepare_request_body`\n        if username is not None:\n            kwargs[\"username\"] = username\n        if password is not None:\n            kwargs[\"password\"] = password\n\n        # is an auth explicitly supplied?\n        if auth is not None:\n            # if we're dealing with the default of `include_client_id` (None):\n            # we will assume the `auth` argument is for an RFC compliant server\n            # and we should not send the `client_id` in the body.\n            # This approach allows us to still force the client_id by submitting\n            # `include_client_id=True` along with an `auth` object.\n            if include_client_id is None:\n                include_client_id = False\n\n        # otherwise we may need to create an auth header\n        else:\n            # since we don't have an auth header, we MAY need to create one\n            # it is possible that we want to send the `client_id` in the body\n            # if so, `include_client_id` should be set to True\n            # otherwise, we will generate an auth header\n            if include_client_id is not True:\n                client_id = self.client_id\n                if client_id:\n                    log.debug(\n                        'Encoding `client_id` \"%s\" with `client_secret` '\n                        \"as Basic auth credentials.\",\n                        client_id,\n                    )\n                    client_secret = client_secret if client_secret is not None else \"\"\n                    auth = requests.auth.HTTPBasicAuth(client_id, client_secret)\n\n        if include_client_id:\n            # this was pulled out of the params\n            # it needs to be passed into prepare_request_body\n            if client_secret is not None:\n                kwargs[\"client_secret\"] = client_secret\n\n        body = self._client.prepare_request_body(\n            code=code,\n            body=body,\n            redirect_uri=self.redirect_uri,\n            include_client_id=include_client_id,\n            **kwargs\n        )\n\n        headers = headers or {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }\n        self.token = {}\n        request_kwargs = {}\n        if method.upper() == \"POST\":\n            request_kwargs[\"params\" if force_querystring else \"data\"] = dict(\n                urldecode(body)\n            )\n        elif method.upper() == \"GET\":\n            request_kwargs[\"params\"] = dict(urldecode(body))\n        else:\n            raise ValueError(\"The method kwarg must be POST or GET.\")\n\n        for hook in self.compliance_hook[\"access_token_request\"]:\n            log.debug(\"Invoking access_token_request hook %s.\", hook)\n            token_url, headers, request_kwargs = hook(\n                token_url, headers, request_kwargs\n            )\n\n        r = self.request(\n            method=method,\n            url=token_url,\n            timeout=timeout,\n            headers=headers,\n            auth=auth,\n            verify=verify,\n            proxies=proxies,\n            cert=cert,\n            **request_kwargs\n        )\n\n        log.debug(\"Request to fetch token completed with status %s.\", r.status_code)\n        log.debug(\"Request url was %s\", r.request.url)\n        log.debug(\"Request headers were %s\", r.request.headers)\n        log.debug(\"Request body was %s\", r.request.body)\n        log.debug(\"Response headers were %s and content %s.\", r.headers, r.text)\n        log.debug(\n            \"Invoking %d token response hooks.\",\n            len(self.compliance_hook[\"access_token_response\"]),\n        )\n        for hook in self.compliance_hook[\"access_token_response\"]:\n            log.debug(\"Invoking hook %s.\", hook)\n            r = hook(r)\n\n        self._client.parse_request_body_response(r.text, scope=self.scope)\n        self.token = self._client.token\n        log.debug(\"Obtained token %s.\", self.token)\n        return self.token\n\n    def token_from_fragment(self, authorization_response):\n        \"\"\"Parse token from the URI fragment, used by MobileApplicationClients.\n\n        :param authorization_response: The full URL of the redirect back to you\n        :return: A token dict\n        \"\"\"\n        self._client.parse_request_uri_response(\n            authorization_response, state=self._state\n        )\n        self.token = self._client.token\n        return self.token\n\n    def refresh_token(\n        self,\n        token_url,\n        refresh_token=None,\n        body=\"\",\n        auth=None,\n        timeout=None,\n        headers=None,\n        verify=None,\n        proxies=None,\n        **kwargs\n    ):\n        \"\"\"Fetch a new access token using a refresh token.\n\n        :param token_url: The token endpoint, must be HTTPS.\n        :param refresh_token: The refresh_token to use.\n        :param body: Optional application/x-www-form-urlencoded body to add the\n                     include in the token request. Prefer kwargs over body.\n        :param auth: An auth tuple or method as accepted by `requests`.\n        :param timeout: Timeout of the request in seconds.\n        :param headers: A dict of headers to be used by `requests`.\n        :param verify: Verify SSL certificate.\n        :param proxies: The `proxies` argument will be passed to `requests`.\n        :param kwargs: Extra parameters to include in the token request.\n        :return: A token dict\n        \"\"\"\n        if not token_url:\n            raise ValueError(\"No token endpoint set for auto_refresh.\")\n\n        if not is_secure_transport(token_url):\n            raise InsecureTransportError()\n\n        refresh_token = refresh_token or self.token.get(\"refresh_token\")\n\n        log.debug(\n            \"Adding auto refresh key word arguments %s.\", self.auto_refresh_kwargs\n        )\n        kwargs.update(self.auto_refresh_kwargs)\n        body = self._client.prepare_refresh_body(\n            body=body, refresh_token=refresh_token, scope=self.scope, **kwargs\n        )\n        log.debug(\"Prepared refresh token request body %s\", body)\n\n        if headers is None:\n            headers = {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": (\"application/x-www-form-urlencoded\"),\n            }\n\n        for hook in self.compliance_hook[\"refresh_token_request\"]:\n            log.debug(\"Invoking refresh_token_request hook %s.\", hook)\n            token_url, headers, body = hook(token_url, headers, body)\n\n        r = self.post(\n            token_url,\n            data=dict(urldecode(body)),\n            auth=auth,\n            timeout=timeout,\n            headers=headers,\n            verify=verify,\n            withhold_token=True,\n            proxies=proxies,\n        )\n        log.debug(\"Request to refresh token completed with status %s.\", r.status_code)\n        log.debug(\"Response headers were %s and content %s.\", r.headers, r.text)\n        log.debug(\n            \"Invoking %d token response hooks.\",\n            len(self.compliance_hook[\"refresh_token_response\"]),\n        )\n        for hook in self.compliance_hook[\"refresh_token_response\"]:\n            log.debug(\"Invoking hook %s.\", hook)\n            r = hook(r)\n\n        self.token = self._client.parse_request_body_response(r.text, scope=self.scope)\n        if \"refresh_token\" not in self.token:\n            log.debug(\"No new refresh token given. Re-using old.\")\n            self.token[\"refresh_token\"] = refresh_token\n        return self.token\n\n    def request(\n        self,\n        method,\n        url,\n        data=None,\n        headers=None,\n        withhold_token=False,\n        client_id=None,\n        client_secret=None,\n        files=None,\n        **kwargs\n    ):\n        \"\"\"Intercept all requests and add the OAuth 2 token if present.\"\"\"\n        if not is_secure_transport(url):\n            raise InsecureTransportError()\n        if self.token and not withhold_token:\n            log.debug(\n                \"Invoking %d protected resource request hooks.\",\n                len(self.compliance_hook[\"protected_request\"]),\n            )\n            for hook in self.compliance_hook[\"protected_request\"]:\n                log.debug(\"Invoking hook %s.\", hook)\n                url, headers, data = hook(url, headers, data)\n\n            log.debug(\"Adding token %s to request.\", self.token)\n            try:\n                url, headers, data = self._client.add_token(\n                    url, http_method=method, body=data, headers=headers\n                )\n            # Attempt to retrieve and save new access token if expired\n            except TokenExpiredError:\n                if self.auto_refresh_url:\n                    log.debug(\n                        \"Auto refresh is set, attempting to refresh at %s.\",\n                        self.auto_refresh_url,\n                    )\n\n                    # We mustn't pass auth twice.\n                    auth = kwargs.pop(\"auth\", None)\n                    if client_id and client_secret and (auth is None):\n                        log.debug(\n                            'Encoding client_id \"%s\" with client_secret as Basic auth credentials.',\n                            client_id,\n                        )\n                        auth = requests.auth.HTTPBasicAuth(client_id, client_secret)\n                    token = self.refresh_token(\n                        self.auto_refresh_url, auth=auth, **kwargs\n                    )\n                    if self.token_updater:\n                        log.debug(\n                            \"Updating token to %s using %s.\", token, self.token_updater\n                        )\n                        self.token_updater(token)\n                        url, headers, data = self._client.add_token(\n                            url, http_method=method, body=data, headers=headers\n                        )\n                    else:\n                        raise TokenUpdated(token)\n                else:\n                    raise\n\n        log.debug(\"Requesting url %s using method %s.\", url, method)\n        log.debug(\"Supplying headers %s and data %s\", headers, data)\n        log.debug(\"Passing through key word arguments %s.\", kwargs)\n        return super(OAuth2Session, self).request(\n            method, url, headers=headers, data=data, files=files, **kwargs\n        )\n\n    def register_compliance_hook(self, hook_type, hook):\n        \"\"\"Register a hook for request/response tweaking.\n\n        Available hooks are:\n            access_token_response invoked before token parsing.\n            refresh_token_response invoked before refresh token parsing.\n            protected_request invoked before making a request.\n            access_token_request invoked before making a token fetch request.\n            refresh_token_request invoked before making a refresh request.\n\n        If you find a new hook is needed please send a GitHub PR request\n        or open an issue.\n        \"\"\"\n        if hook_type not in self.compliance_hook:\n            raise ValueError(\n                \"Hook type %s is not in %s.\", hook_type, self.compliance_hook\n            )\n        self.compliance_hook[hook_type].add(hook)\n", "requests_oauthlib/compliance_fixes/fitbit.py": "\"\"\"\nThe Fitbit API breaks from the OAuth2 RFC standard by returning an \"errors\"\nobject list, rather than a single \"error\" string. This puts hooks in place so\nthat oauthlib can process an error in the results from access token and refresh\ntoken responses. This is necessary to prevent getting the generic red herring\nMissingTokenError.\n\"\"\"\n\nfrom json import loads, dumps\n\n\ndef fitbit_compliance_fix(session):\n    def _missing_error(r):\n        token = loads(r.text)\n        if \"errors\" in token:\n            # Set the error to the first one we have\n            token[\"error\"] = token[\"errors\"][0][\"errorType\"]\n        r._content = dumps(token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _missing_error)\n    session.register_compliance_hook(\"refresh_token_response\", _missing_error)\n    return session\n", "requests_oauthlib/compliance_fixes/facebook.py": "from json import dumps\nfrom urllib.parse import parse_qsl\n\n\ndef facebook_compliance_fix(session):\n    def _compliance_fix(r):\n        # if Facebook claims to be sending us json, let's trust them.\n        if \"application/json\" in r.headers.get(\"content-type\", {}):\n            return r\n\n        # Facebook returns a content-type of text/plain when sending their\n        # x-www-form-urlencoded responses, along with a 200. If not, let's\n        # assume we're getting JSON and bail on the fix.\n        if \"text/plain\" in r.headers.get(\"content-type\", {}) and r.status_code == 200:\n            token = dict(parse_qsl(r.text, keep_blank_values=True))\n        else:\n            return r\n\n        expires = token.get(\"expires\")\n        if expires is not None:\n            token[\"expires_in\"] = expires\n        token[\"token_type\"] = \"Bearer\"\n        r._content = dumps(token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _compliance_fix)\n    return session\n", "requests_oauthlib/compliance_fixes/plentymarkets.py": "from json import dumps, loads\nimport re\n\n\ndef plentymarkets_compliance_fix(session):\n    def _to_snake_case(n):\n        return re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", n).lower()\n\n    def _compliance_fix(r):\n        # Plenty returns the Token in CamelCase instead of _\n        if (\n            \"application/json\" in r.headers.get(\"content-type\", {})\n            and r.status_code == 200\n        ):\n            token = loads(r.text)\n        else:\n            return r\n\n        fixed_token = {}\n        for k, v in token.items():\n            fixed_token[_to_snake_case(k)] = v\n\n        r._content = dumps(fixed_token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _compliance_fix)\n    return session\n", "requests_oauthlib/compliance_fixes/douban.py": "import json\n\n\ndef douban_compliance_fix(session):\n    def fix_token_type(r):\n        token = json.loads(r.text)\n        token.setdefault(\"token_type\", \"Bearer\")\n        fixed_token = json.dumps(token)\n        r._content = fixed_token.encode()\n        return r\n\n    session._client_default_token_placement = \"query\"\n    session.register_compliance_hook(\"access_token_response\", fix_token_type)\n\n    return session\n", "requests_oauthlib/compliance_fixes/slack.py": "from urllib.parse import urlparse, parse_qs\n\nfrom oauthlib.common import add_params_to_uri\n\n\ndef slack_compliance_fix(session):\n    def _non_compliant_param_name(url, headers, data):\n        # If the user has already specified the token, either in the URL\n        # or in a data dictionary, then there's nothing to do.\n        # If the specified token is different from ``session.access_token``,\n        # we assume the user intends to override the access token.\n        url_query = dict(parse_qs(urlparse(url).query))\n        token = url_query.get(\"token\")\n        if not token and isinstance(data, dict):\n            token = data.get(\"token\")\n\n        if token:\n            # Nothing to do, just return.\n            return url, headers, data\n\n        if not data:\n            data = {\"token\": session.access_token}\n        elif isinstance(data, dict):\n            data[\"token\"] = session.access_token\n        else:\n            # ``data`` is something other than a dict: maybe a stream,\n            # maybe a file object, maybe something else. We can't easily\n            # modify it, so we'll set the token by modifying the URL instead.\n            token = [(\"token\", session.access_token)]\n            url = add_params_to_uri(url, token)\n        return url, headers, data\n\n    session.register_compliance_hook(\"protected_request\", _non_compliant_param_name)\n    return session\n", "requests_oauthlib/compliance_fixes/ebay.py": "import json\n\n\ndef ebay_compliance_fix(session):\n    def _compliance_fix(response):\n        token = json.loads(response.text)\n\n        # eBay responds with non-compliant token types.\n        # https://developer.ebay.com/api-docs/static/oauth-client-credentials-grant.html\n        # https://developer.ebay.com/api-docs/static/oauth-auth-code-grant-request.html\n        # Modify these to be \"Bearer\".\n        if token.get(\"token_type\") in [\"Application Access Token\", \"User Access Token\"]:\n            token[\"token_type\"] = \"Bearer\"\n            fixed_token = json.dumps(token)\n            response._content = fixed_token.encode()\n\n        return response\n\n    session.register_compliance_hook(\"access_token_response\", _compliance_fix)\n    session.register_compliance_hook(\"refresh_token_response\", _compliance_fix)\n\n    return session\n", "requests_oauthlib/compliance_fixes/mailchimp.py": "import json\n\n\ndef mailchimp_compliance_fix(session):\n    def _null_scope(r):\n        token = json.loads(r.text)\n        if \"scope\" in token and token[\"scope\"] is None:\n            token.pop(\"scope\")\n        r._content = json.dumps(token).encode()\n        return r\n\n    def _non_zero_expiration(r):\n        token = json.loads(r.text)\n        if \"expires_in\" in token and token[\"expires_in\"] == 0:\n            token[\"expires_in\"] = 3600\n        r._content = json.dumps(token).encode()\n        return r\n\n    session.register_compliance_hook(\"access_token_response\", _null_scope)\n    session.register_compliance_hook(\"access_token_response\", _non_zero_expiration)\n    return session\n", "requests_oauthlib/compliance_fixes/weibo.py": "from json import loads, dumps\n\n\ndef weibo_compliance_fix(session):\n    def _missing_token_type(r):\n        token = loads(r.text)\n        token[\"token_type\"] = \"Bearer\"\n        r._content = dumps(token).encode()\n        return r\n\n    session._client.default_token_placement = \"query\"\n    session.register_compliance_hook(\"access_token_response\", _missing_token_type)\n    return session\n", "requests_oauthlib/compliance_fixes/__init__.py": "# ruff: noqa: F401\nfrom .facebook import facebook_compliance_fix\nfrom .fitbit import fitbit_compliance_fix\nfrom .slack import slack_compliance_fix\nfrom .instagram import instagram_compliance_fix\nfrom .mailchimp import mailchimp_compliance_fix\nfrom .weibo import weibo_compliance_fix\nfrom .plentymarkets import plentymarkets_compliance_fix\nfrom .ebay import ebay_compliance_fix\n", "requests_oauthlib/compliance_fixes/instagram.py": "from urllib.parse import urlparse, parse_qs\n\nfrom oauthlib.common import add_params_to_uri\n\n\ndef instagram_compliance_fix(session):\n    def _non_compliant_param_name(url, headers, data):\n        # If the user has already specified the token in the URL\n        # then there's nothing to do.\n        # If the specified token is different from ``session.access_token``,\n        # we assume the user intends to override the access token.\n        url_query = dict(parse_qs(urlparse(url).query))\n        token = url_query.get(\"access_token\")\n        if token:\n            # Nothing to do, just return.\n            return url, headers, data\n\n        token = [(\"access_token\", session.access_token)]\n        url = add_params_to_uri(url, token)\n        return url, headers, data\n\n    session.register_compliance_hook(\"protected_request\", _non_compliant_param_name)\n    return session\n"}