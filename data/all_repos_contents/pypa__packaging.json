{"noxfile.py": "# mypy: disallow-untyped-defs=False, disallow-untyped-calls=False\n\nimport contextlib\nimport datetime\nimport difflib\nimport glob\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nimport time\nimport webbrowser\nfrom pathlib import Path\n\nimport nox\n\nnox.options.sessions = [\"lint\"]\nnox.options.reuse_existing_virtualenvs = True\n\n\n@nox.session(\n    python=[\n        \"3.8\",\n        \"3.9\",\n        \"3.10\",\n        \"3.11\",\n        \"3.12\",\n        \"3.13\",\n        \"pypy3.8\",\n        \"pypy3.9\",\n        \"pypy3.10\",\n    ]\n)\ndef tests(session):\n    def coverage(*args):\n        session.run(\"python\", \"-m\", \"coverage\", *args)\n\n    session.install(\"-r\", \"tests/requirements.txt\")\n    session.install(\".\")\n\n    if \"pypy\" not in session.python:\n        coverage(\n            \"run\",\n            \"--source\",\n            \"packaging\",\n            \"-m\",\n            \"pytest\",\n            \"--strict-markers\",\n            *session.posargs,\n        )\n        coverage(\"report\", \"-m\", \"--fail-under\", \"100\")\n    else:\n        # Don't do coverage tracking for PyPy, since it's SLOW.\n        session.run(\n            \"python\",\n            \"-m\",\n            \"pytest\",\n            \"--capture=no\",\n            \"--strict-markers\",\n            *session.posargs,\n        )\n\n\n@nox.session(python=\"3.9\")\ndef lint(session):\n    # Run the linters (via pre-commit)\n    session.install(\"pre-commit\")\n    session.run(\"pre-commit\", \"run\", \"--all-files\", *session.posargs)\n\n    # Check the distribution\n    session.install(\"build\", \"twine\")\n    session.run(\"pyproject-build\")\n    session.run(\"twine\", \"check\", *glob.glob(\"dist/*\"))\n\n\n@nox.session(python=\"3.9\")\ndef docs(session):\n    shutil.rmtree(\"docs/_build\", ignore_errors=True)\n    session.install(\"-r\", \"docs/requirements.txt\")\n    session.install(\"-e\", \".\")\n\n    variants = [\n        # (builder, dest)\n        (\"html\", \"html\"),\n        (\"latex\", \"latex\"),\n        (\"doctest\", \"html\"),\n    ]\n\n    for builder, dest in variants:\n        session.run(\n            \"sphinx-build\",\n            \"-W\",\n            \"-b\",\n            builder,\n            \"-d\",\n            \"docs/_build/doctrees/\" + dest,\n            \"docs\",  # source directory\n            \"docs/_build/\" + dest,  # output directory\n        )\n\n\n@nox.session\ndef release(session):\n    package_name = \"packaging\"\n    version_file = Path(f\"src/{package_name}/__init__.py\")\n    changelog_file = Path(\"CHANGELOG.rst\")\n\n    try:\n        release_version = _get_version_from_arguments(session.posargs)\n    except ValueError as e:\n        session.error(f\"Invalid arguments: {e}\")\n        return\n\n    # Check state of working directory and git.\n    _check_working_directory_state(session)\n    _check_git_state(session, release_version)\n\n    # Prepare for release.\n    _changelog_update_unreleased_title(release_version, file=changelog_file)\n    session.run(\"git\", \"add\", str(changelog_file), external=True)\n    _bump(session, version=release_version, file=version_file, kind=\"release\")\n\n    # Tag the release commit.\n    # fmt: off\n    session.run(\n        \"git\", \"tag\",\n        \"-s\", release_version,\n        \"-m\", f\"Release {release_version}\",\n        external=True,\n    )\n    # fmt: on\n\n    # Prepare for development.\n    _changelog_add_unreleased_title(file=changelog_file)\n    session.run(\"git\", \"add\", str(changelog_file), external=True)\n\n    major, minor = map(int, release_version.split(\".\"))\n    next_version = f\"{major}.{minor + 1}.dev0\"\n    _bump(session, version=next_version, file=version_file, kind=\"development\")\n\n    # Checkout the git tag.\n    session.run(\"git\", \"checkout\", \"-q\", release_version, external=True)\n\n    session.install(\"build\", \"twine\")\n\n    # Build the distribution.\n    session.run(\"python\", \"-m\", \"build\")\n\n    # Check what files are in dist/ for upload.\n    files = sorted(glob.glob(\"dist/*\"))\n    expected = [\n        f\"dist/{package_name}-{release_version}-py3-none-any.whl\",\n        f\"dist/{package_name}-{release_version}.tar.gz\",\n    ]\n    if files != expected:\n        diff_generator = difflib.context_diff(\n            expected, files, fromfile=\"expected\", tofile=\"got\", lineterm=\"\"\n        )\n        diff = \"\\n\".join(diff_generator)\n        session.error(f\"Got the wrong files:\\n{diff}\")\n\n    # Get back out into main.\n    session.run(\"git\", \"checkout\", \"-q\", \"main\", external=True)\n\n    # Check and upload distribution files.\n    session.run(\"twine\", \"check\", *files)\n\n    # Push the commits and tag.\n    # NOTE: The following fails if pushing to the branch is not allowed. This can\n    #       happen on GitHub, if the main branch is protected, there are required\n    #       CI checks and \"Include administrators\" is enabled on the protection.\n    session.run(\"git\", \"push\", \"upstream\", \"main\", release_version, external=True)\n\n    # Upload the distribution.\n    session.run(\"twine\", \"upload\", *files)\n\n    # Open up the GitHub release page.\n    webbrowser.open(\"https://github.com/pypa/packaging/releases\")\n\n\n# -----------------------------------------------------------------------------\n# Helpers\n# -----------------------------------------------------------------------------\ndef _get_version_from_arguments(arguments):\n    \"\"\"Checks the arguments passed to `nox -s release`.\n\n    Only 1 argument that looks like a version? Return the argument.\n    Otherwise, raise a ValueError describing what's wrong.\n    \"\"\"\n    if len(arguments) != 1:\n        raise ValueError(\"Expected exactly 1 argument\")\n\n    version = arguments[0]\n    parts = version.split(\".\")\n\n    if len(parts) != 2:\n        # Not of the form: YY.N\n        raise ValueError(\"not of the form: YY.N\")\n\n    if not all(part.isdigit() for part in parts):\n        # Not all segments are integers.\n        raise ValueError(\"non-integer segments\")\n\n    # All is good.\n    return version\n\n\ndef _check_working_directory_state(session):\n    \"\"\"Check state of the working directory, prior to making the release.\"\"\"\n    should_not_exist = [\"build/\", \"dist/\"]\n\n    bad_existing_paths = list(filter(os.path.exists, should_not_exist))\n    if bad_existing_paths:\n        session.error(f\"Remove {', '.join(bad_existing_paths)} and try again\")\n\n\ndef _check_git_state(session, version_tag):\n    \"\"\"Check state of the git repository, prior to making the release.\"\"\"\n    # Ensure the upstream remote pushes to the correct URL.\n    allowed_upstreams = [\n        \"git@github.com:pypa/packaging.git\",\n        \"https://github.com/pypa/packaging.git\",\n    ]\n    result = subprocess.run(\n        [\"git\", \"remote\", \"get-url\", \"--push\", \"upstream\"],\n        capture_output=True,\n        encoding=\"utf-8\",\n    )\n    if result.stdout.rstrip() not in allowed_upstreams:\n        session.error(f\"git remote `upstream` is not one of {allowed_upstreams}\")\n    # Ensure we're on main branch for cutting a release.\n    result = subprocess.run(\n        [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"],\n        capture_output=True,\n        encoding=\"utf-8\",\n    )\n    if result.stdout != \"main\\n\":\n        session.error(f\"Not on main branch: {result.stdout!r}\")\n\n    # Ensure there are no uncommitted changes.\n    result = subprocess.run(\n        [\"git\", \"status\", \"--porcelain\"], capture_output=True, encoding=\"utf-8\"\n    )\n    if result.stdout:\n        print(result.stdout, end=\"\", file=sys.stderr)\n        session.error(\"The working tree has uncommitted changes\")\n\n    # Ensure this tag doesn't exist already.\n    result = subprocess.run(\n        [\"git\", \"rev-parse\", version_tag], capture_output=True, encoding=\"utf-8\"\n    )\n    if not result.returncode:\n        session.error(f\"Tag already exists! {version_tag} -- {result.stdout!r}\")\n\n    # Back up the current git reference, in a tag that's easy to clean up.\n    _release_backup_tag = \"auto/release-start-\" + str(int(time.time()))\n    session.run(\"git\", \"tag\", _release_backup_tag, external=True)\n\n\ndef _bump(session, *, version, file, kind):\n    session.log(f\"Bump version to {version!r}\")\n    contents = file.read_text()\n    new_contents = re.sub(\n        '__version__ = \"(.+)\"', f'__version__ = \"{version}\"', contents\n    )\n    file.write_text(new_contents)\n\n    session.log(\"git commit\")\n    subprocess.run([\"git\", \"add\", str(file)])\n    subprocess.run([\"git\", \"commit\", \"-m\", f\"Bump for {kind}\"])\n\n\n@contextlib.contextmanager\ndef _replace_file(original_path):\n    # Create a temporary file.\n    fh, replacement_path = tempfile.mkstemp()\n\n    try:\n        with os.fdopen(fh, \"w\") as replacement:\n            with open(original_path) as original:\n                yield original, replacement\n    except Exception:\n        raise\n    else:\n        shutil.copymode(original_path, replacement_path)\n        os.remove(original_path)\n        shutil.move(replacement_path, original_path)\n\n\ndef _changelog_update_unreleased_title(version, *, file):\n    \"\"\"Update an \"*unreleased*\" heading to \"{version} - {date}\" \"\"\"\n    yyyy_mm_dd = datetime.datetime.today().strftime(\"%Y-%m-%d\")\n    title = f\"{version} - {yyyy_mm_dd}\"\n\n    with _replace_file(file) as (original, replacement):\n        for line in original:\n            if line == \"*unreleased*\\n\":\n                replacement.write(f\"{title}\\n\")\n                replacement.write(len(title) * \"~\" + \"\\n\")\n                # Skip processing the next line (the heading underline for *unreleased*)\n                # since we already wrote the heading underline.\n                next(original)\n            else:\n                replacement.write(line)\n\n\ndef _changelog_add_unreleased_title(*, file):\n    with _replace_file(file) as (original, replacement):\n        # Duplicate first 3 lines from the original file.\n        for _ in range(3):\n            line = next(original)\n            replacement.write(line)\n\n        # Write the heading.\n        replacement.write(\n            textwrap.dedent(\n                \"\"\"\\\n                *unreleased*\n                ~~~~~~~~~~~~\n\n                No unreleased changes.\n\n                \"\"\"\n            )\n        )\n\n        # Duplicate all the remaining lines.\n        for line in original:\n            replacement.write(line)\n", "tasks/paths.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport os.path\n\nPROJECT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))\n\nCACHE = os.path.join(PROJECT, \".cache\")\n", "tasks/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport invoke\n\nfrom . import check\n\nns = invoke.Collection(check)\n", "tasks/check.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport itertools\nimport json\nimport os.path\nimport xmlrpc.client\n\nimport invoke\nimport pkg_resources\nimport progress.bar\n\nfrom packaging.version import Version\n\nfrom .paths import CACHE\n\n\ndef _parse_version(value):\n    try:\n        return Version(value)\n    except ValueError:\n        return None\n\n\n@invoke.task\ndef pep440(cached=False):\n    cache_path = os.path.join(CACHE, \"pep440.json\")\n\n    # If we were given --cached, then we want to attempt to use cached data if\n    # possible\n    if cached:\n        try:\n            with open(cache_path) as fp:\n                data = json.load(fp)\n        except Exception:\n            data = None\n    else:\n        data = None\n\n    # If we don't have data, then let's go fetch it from PyPI\n    if data is None:\n        bar = progress.bar.ShadyBar(\"Fetching Versions\")\n        client = xmlrpc.client.Server(\"https://pypi.python.org/pypi\")\n\n        data = {\n            project: client.package_releases(project, True)\n            for project in bar.iter(client.list_packages())\n        }\n\n        os.makedirs(os.path.dirname(cache_path), exist_ok=True)\n        with open(cache_path, \"w\") as fp:\n            json.dump(data, fp)\n\n    # Get a list of all of the version numbers on PyPI\n    all_versions = list(itertools.chain.from_iterable(data.values()))\n\n    # Determine the total number of versions which are compatible with the\n    # current routine\n    parsed_versions = [\n        _parse_version(v) for v in all_versions if _parse_version(v) is not None\n    ]\n\n    # Determine a list of projects that sort exactly the same between\n    # pkg_resources and PEP 440\n    compatible_sorting = [\n        project\n        for project, versions in data.items()\n        if (\n            sorted(versions, key=pkg_resources.parse_version)\n            == sorted((x for x in versions if _parse_version(x)), key=Version)\n        )\n    ]\n\n    # Determine a list of projects that sort exactly the same between\n    # pkg_resources and PEP 440 when invalid versions are filtered out\n    filtered_compatible_sorting = [\n        project\n        for project, versions in (\n            (p, [v for v in vs if _parse_version(v) is not None])\n            for p, vs in data.items()\n        )\n        if (\n            sorted(versions, key=pkg_resources.parse_version)\n            == sorted(versions, key=Version)\n        )\n    ]\n\n    # Determine a list of projects which do not have any versions that are\n    # valid with PEP 440 and which have any versions registered\n    only_invalid_versions = [\n        project\n        for project, versions in data.items()\n        if (versions and not [v for v in versions if _parse_version(v) is not None])\n    ]\n\n    # Determine a list of projects which have matching latest versions between\n    # pkg_resources and PEP 440\n    differing_latest_versions = [\n        project\n        for project, versions in data.items()\n        if (\n            sorted(versions, key=pkg_resources.parse_version)[-1:]\n            != sorted((x for x in versions if _parse_version(x)), key=Version)[-1:]\n        )\n    ]\n\n    # Print out our findings\n    print(\n        \"Total Version Compatibility:              {}/{} ({:.2%})\".format(\n            len(parsed_versions),\n            len(all_versions),\n            len(parsed_versions) / len(all_versions),\n        )\n    )\n    print(\n        \"Total Sorting Compatibility (Unfiltered): {}/{} ({:.2%})\".format(\n            len(compatible_sorting), len(data), len(compatible_sorting) / len(data)\n        )\n    )\n    print(\n        \"Total Sorting Compatibility (Filtered):   {}/{} ({:.2%})\".format(\n            len(filtered_compatible_sorting),\n            len(data),\n            len(filtered_compatible_sorting) / len(data),\n        )\n    )\n    print(\n        \"Projects with No Compatible Versions:     {}/{} ({:.2%})\".format(\n            len(only_invalid_versions),\n            len(data),\n            len(only_invalid_versions) / len(data),\n        )\n    )\n    print(\n        \"Projects with Differing Latest Version:   {}/{} ({:.2%})\".format(\n            len(differing_latest_versions),\n            len(data),\n            len(differing_latest_versions) / len(data),\n        )\n    )\n", "docs/conf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport os\n\n# -- Project information loading ----------------------------------------------\n\nABOUT = {}\n_BASE_DIR = os.path.join(os.path.dirname(__file__), os.pardir)\nwith open(os.path.join(_BASE_DIR, \"src\", \"packaging\", \"__init__.py\")) as f:\n    exec(f.read(), ABOUT)\n\n# -- General configuration ----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions  coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx_toolbox.more_autodoc.autotypeddict\",\n]\n\n# General information about the project.\nproject = \"Packaging\"\nversion = ABOUT[\"__version__\"]\nrelease = ABOUT[\"__version__\"]\ncopyright = ABOUT[\"__copyright__\"]\n\n# -- Options for HTML output --------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n\nhtml_theme = \"furo\"\nhtml_title = project\n\n# -- Options for autodoc ----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html#configuration\n\nautodoc_member_order = \"bysource\"\nautodoc_preserve_defaults = True\n\n# Automatically extract typehints when specified and place them in\n# descriptions of the relevant function/method.\nautodoc_typehints = \"description\"\n\n# Don't show class signature with the class' name.\nautodoc_class_signature = \"separated\"\n\n# -- Options for extlinks -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/extensions/extlinks.html#configuration\n\nextlinks = {\n    \"issue\": (\"https://github.com/pypa/packaging/issues/%s\", \"#%s\"),\n    \"pull\": (\"https://github.com/pypa/packaging/pull/%s\", \"PR #%s\"),\n}\n\n# -- Options for intersphinx ----------------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html#configuration\n\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3/\", None),\n    \"pypug\": (\"https://packaging.python.org/\", None),\n}\n", "tests/test_markers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport collections\nimport itertools\nimport os\nimport platform\nimport sys\nfrom typing import cast\nfrom unittest import mock\n\nimport pytest\n\nfrom packaging._parser import Node\nfrom packaging.markers import (\n    InvalidMarker,\n    Marker,\n    UndefinedComparison,\n    default_environment,\n    format_full_version,\n)\nfrom packaging.version import InvalidVersion\n\nVARIABLES = [\n    \"extra\",\n    \"implementation_name\",\n    \"implementation_version\",\n    \"os_name\",\n    \"platform_machine\",\n    \"platform_release\",\n    \"platform_system\",\n    \"platform_version\",\n    \"python_full_version\",\n    \"python_version\",\n    \"platform_python_implementation\",\n    \"sys_platform\",\n]\n\nPEP_345_VARIABLES = [\n    \"os.name\",\n    \"sys.platform\",\n    \"platform.version\",\n    \"platform.machine\",\n    \"platform.python_implementation\",\n]\n\nSETUPTOOLS_VARIABLES = [\"python_implementation\"]\n\nOPERATORS = [\"===\", \"==\", \">=\", \"<=\", \"!=\", \"~=\", \">\", \"<\", \"in\", \"not in\"]\n\nVALUES = [\n    \"1.0\",\n    \"5.6a0\",\n    \"dog\",\n    \"freebsd\",\n    \"literally any string can go here\",\n    \"things @#4 dsfd (((\",\n]\n\n\nclass TestNode:\n    @pytest.mark.parametrize(\"value\", [\"one\", \"two\", None, 3, 5, []])\n    def test_accepts_value(self, value):\n        assert Node(value).value == value\n\n    @pytest.mark.parametrize(\"value\", [\"one\", \"two\"])\n    def test_str(self, value):\n        assert str(Node(value)) == str(value)\n\n    @pytest.mark.parametrize(\"value\", [\"one\", \"two\"])\n    def test_repr(self, value):\n        assert repr(Node(value)) == f\"<Node({str(value)!r})>\"\n\n    def test_base_class(self):\n        with pytest.raises(NotImplementedError):\n            Node(\"cover all the code\").serialize()\n\n\nclass TestOperatorEvaluation:\n    def test_prefers_pep440(self):\n        assert Marker('\"2.7.9\" < \"foo\"').evaluate(dict(foo=\"2.7.10\"))\n\n    def test_falls_back_to_python(self):\n        assert Marker('\"b\" > \"a\"').evaluate(dict(a=\"a\"))\n\n    def test_fails_when_undefined(self):\n        with pytest.raises(UndefinedComparison):\n            Marker(\"'2.7.0' ~= os_name\").evaluate()\n\n    def test_allows_prerelease(self):\n        assert Marker('python_full_version > \"3.6.2\"').evaluate(\n            {\"python_full_version\": \"3.11.0a5\"}\n        )\n\n\nFakeVersionInfo = collections.namedtuple(\n    \"FakeVersionInfo\", [\"major\", \"minor\", \"micro\", \"releaselevel\", \"serial\"]\n)\n\n\nclass TestDefaultEnvironment:\n    def test_matches_expected(self):\n        environment = default_environment()\n\n        iver = \"{0.major}.{0.minor}.{0.micro}\".format(sys.implementation.version)\n        if sys.implementation.version.releaselevel != \"final\":\n            iver = \"{0}{1[0]}{2}\".format(\n                iver,\n                sys.implementation.version.releaselevel,\n                sys.implementation.version.serial,\n            )\n\n        assert environment == {\n            \"implementation_name\": sys.implementation.name,\n            \"implementation_version\": iver,\n            \"os_name\": os.name,\n            \"platform_machine\": platform.machine(),\n            \"platform_release\": platform.release(),\n            \"platform_system\": platform.system(),\n            \"platform_version\": platform.version(),\n            \"python_full_version\": platform.python_version(),\n            \"platform_python_implementation\": platform.python_implementation(),\n            \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n            \"sys_platform\": sys.platform,\n        }\n\n    def test_multidigit_minor_version(self, monkeypatch):\n        version_info = (3, 10, 0, \"final\", 0)\n        monkeypatch.setattr(sys, \"version_info\", version_info, raising=False)\n\n        monkeypatch.setattr(platform, \"python_version\", lambda: \"3.10.0\", raising=False)\n        monkeypatch.setattr(\n            platform, \"python_version_tuple\", lambda: (\"3\", \"10\", \"0\"), raising=False\n        )\n\n        environment = default_environment()\n        assert environment[\"python_version\"] == \"3.10\"\n\n    def tests_when_releaselevel_final(self):\n        v = FakeVersionInfo(3, 4, 2, \"final\", 0)\n        assert format_full_version(v) == \"3.4.2\"\n\n    def tests_when_releaselevel_not_final(self):\n        v = FakeVersionInfo(3, 4, 2, \"beta\", 4)\n        assert format_full_version(v) == \"3.4.2b4\"\n\n\nclass TestMarker:\n    @pytest.mark.parametrize(\n        \"marker_string\",\n        [\n            \"{} {} {!r}\".format(*i)\n            for i in itertools.product(VARIABLES, OPERATORS, VALUES)\n        ]\n        + [\n            \"{2!r} {1} {0}\".format(*i)\n            for i in itertools.product(VARIABLES, OPERATORS, VALUES)\n        ],\n    )\n    def test_parses_valid(self, marker_string):\n        Marker(marker_string)\n\n    @pytest.mark.parametrize(\n        \"marker_string\",\n        [\n            \"this_isnt_a_real_variable >= '1.0'\",\n            \"python_version\",\n            \"(python_version)\",\n            \"python_version >= 1.0 and (python_version)\",\n            '(python_version == \"2.7\" and os_name == \"linux\"',\n            '(python_version == \"2.7\") with random text',\n        ],\n    )\n    def test_parses_invalid(self, marker_string):\n        with pytest.raises(InvalidMarker):\n            Marker(marker_string)\n\n    @pytest.mark.parametrize(\n        (\"marker_string\", \"expected\"),\n        [\n            # Test the different quoting rules\n            (\"python_version == '2.7'\", 'python_version == \"2.7\"'),\n            ('python_version == \"2.7\"', 'python_version == \"2.7\"'),\n            # Test and/or expressions\n            (\n                'python_version == \"2.7\" and os_name == \"linux\"',\n                'python_version == \"2.7\" and os_name == \"linux\"',\n            ),\n            (\n                'python_version == \"2.7\" or os_name == \"linux\"',\n                'python_version == \"2.7\" or os_name == \"linux\"',\n            ),\n            (\n                'python_version == \"2.7\" and os_name == \"linux\" or '\n                'sys_platform == \"win32\"',\n                'python_version == \"2.7\" and os_name == \"linux\" or '\n                'sys_platform == \"win32\"',\n            ),\n            # Test nested expressions and grouping with ()\n            ('(python_version == \"2.7\")', 'python_version == \"2.7\"'),\n            (\n                '(python_version == \"2.7\" and sys_platform == \"win32\")',\n                'python_version == \"2.7\" and sys_platform == \"win32\"',\n            ),\n            (\n                'python_version == \"2.7\" and (sys_platform == \"win32\" or '\n                'sys_platform == \"linux\")',\n                'python_version == \"2.7\" and (sys_platform == \"win32\" or '\n                'sys_platform == \"linux\")',\n            ),\n        ],\n    )\n    def test_str_repr_eq_hash(self, marker_string, expected):\n        m = Marker(marker_string)\n        assert str(m) == expected\n        assert repr(m) == f\"<Marker({str(m)!r})>\"\n        # Objects created from the same string should be equal.\n        assert m == Marker(marker_string)\n        # Objects created from the equivalent strings should also be equal.\n        assert m == Marker(expected)\n        # Objects created from the same string should have the same hash.\n        assert hash(Marker(marker_string)) == hash(Marker(marker_string))\n        # Objects created from equivalent strings should also have the same hash.\n        assert hash(Marker(marker_string)) == hash(Marker(expected))\n\n    @pytest.mark.parametrize(\n        (\"example1\", \"example2\"),\n        [\n            # Test trivial comparisons.\n            ('python_version == \"2.7\"', 'python_version == \"3.7\"'),\n            (\n                'python_version == \"2.7\"',\n                'python_version == \"2.7\" and os_name == \"linux\"',\n            ),\n            (\n                'python_version == \"2.7\"',\n                '(python_version == \"2.7\" and os_name == \"linux\")',\n            ),\n            # Test different precedence.\n            (\n                'python_version == \"2.7\" and (os_name == \"linux\" or '\n                'sys_platform == \"win32\")',\n                'python_version == \"2.7\" and os_name == \"linux\" or '\n                'sys_platform == \"win32\"',\n            ),\n        ],\n    )\n    def test_different_markers_different_hashes(self, example1, example2):\n        marker1, marker2 = Marker(example1), Marker(example2)\n        # Markers created from strings that are not equivalent should differ.\n        assert marker1 != marker2\n        # Different Marker objects should have different hashes.\n        assert hash(marker1) != hash(marker2)\n\n    def test_compare_markers_to_other_objects(self):\n        # Markers should not be comparable to other kinds of objects.\n        assert Marker(\"os_name == 'nt'\") != \"os_name == 'nt'\"\n\n    def test_environment_assumes_empty_extra(self):\n        assert Marker('extra == \"im_valid\"').evaluate() is False\n\n    def test_environment_with_extra_none(self):\n        # GIVEN\n        marker_str = 'extra == \"im_valid\"'\n\n        # Pretend that this is dict[str, str], even though it's not. This is a\n        # test for being bug-for-bug compatible with the older implementation.\n        environment = cast(\"dict[str, str]\", {\"extra\": None})\n\n        # WHEN\n        marker = Marker(marker_str)\n\n        # THEN\n        assert marker.evaluate(environment) is False\n\n    @pytest.mark.parametrize(\n        (\"marker_string\", \"environment\", \"expected\"),\n        [\n            (f\"os_name == '{os.name}'\", None, True),\n            (\"os_name == 'foo'\", {\"os_name\": \"foo\"}, True),\n            (\"os_name == 'foo'\", {\"os_name\": \"bar\"}, False),\n            (\"'2.7' in python_version\", {\"python_version\": \"2.7.5\"}, True),\n            (\"'2.7' not in python_version\", {\"python_version\": \"2.7\"}, False),\n            (\n                \"os_name == 'foo' and python_version ~= '2.7.0'\",\n                {\"os_name\": \"foo\", \"python_version\": \"2.7.6\"},\n                True,\n            ),\n            (\n                \"python_version ~= '2.7.0' and (os_name == 'foo' or \"\n                \"os_name == 'bar')\",\n                {\"os_name\": \"foo\", \"python_version\": \"2.7.4\"},\n                True,\n            ),\n            (\n                \"python_version ~= '2.7.0' and (os_name == 'foo' or \"\n                \"os_name == 'bar')\",\n                {\"os_name\": \"bar\", \"python_version\": \"2.7.4\"},\n                True,\n            ),\n            (\n                \"python_version ~= '2.7.0' and (os_name == 'foo' or \"\n                \"os_name == 'bar')\",\n                {\"os_name\": \"other\", \"python_version\": \"2.7.4\"},\n                False,\n            ),\n            (\"extra == 'security'\", {\"extra\": \"quux\"}, False),\n            (\"extra == 'security'\", {\"extra\": \"security\"}, True),\n            (\"extra == 'SECURITY'\", {\"extra\": \"security\"}, True),\n            (\"extra == 'security'\", {\"extra\": \"SECURITY\"}, True),\n            (\"extra == 'pep-685-norm'\", {\"extra\": \"PEP_685...norm\"}, True),\n            (\n                \"extra == 'Different.punctuation..is...equal'\",\n                {\"extra\": \"different__punctuation_is_EQUAL\"},\n                True,\n            ),\n        ],\n    )\n    def test_evaluates(self, marker_string, environment, expected):\n        args = [] if environment is None else [environment]\n        assert Marker(marker_string).evaluate(*args) == expected\n\n    @pytest.mark.parametrize(\n        \"marker_string\",\n        [\n            \"{} {} {!r}\".format(*i)\n            for i in itertools.product(PEP_345_VARIABLES, OPERATORS, VALUES)\n        ]\n        + [\n            \"{2!r} {1} {0}\".format(*i)\n            for i in itertools.product(PEP_345_VARIABLES, OPERATORS, VALUES)\n        ],\n    )\n    def test_parses_pep345_valid(self, marker_string):\n        Marker(marker_string)\n\n    @pytest.mark.parametrize(\n        (\"marker_string\", \"environment\", \"expected\"),\n        [\n            (f\"os.name == '{os.name}'\", None, True),\n            (\"sys.platform == 'win32'\", {\"sys_platform\": \"linux2\"}, False),\n            (\"platform.version in 'Ubuntu'\", {\"platform_version\": \"#39\"}, False),\n            (\"platform.machine=='x86_64'\", {\"platform_machine\": \"x86_64\"}, True),\n            (\n                \"platform.python_implementation=='Jython'\",\n                {\"platform_python_implementation\": \"CPython\"},\n                False,\n            ),\n            (\n                \"python_version == '2.5' and platform.python_implementation\"\n                \"!= 'Jython'\",\n                {\"python_version\": \"2.7\"},\n                False,\n            ),\n        ],\n    )\n    def test_evaluate_pep345_markers(self, marker_string, environment, expected):\n        args = [] if environment is None else [environment]\n        assert Marker(marker_string).evaluate(*args) == expected\n\n    @pytest.mark.parametrize(\n        \"marker_string\",\n        [\n            \"{} {} {!r}\".format(*i)\n            for i in itertools.product(SETUPTOOLS_VARIABLES, OPERATORS, VALUES)\n        ]\n        + [\n            \"{2!r} {1} {0}\".format(*i)\n            for i in itertools.product(SETUPTOOLS_VARIABLES, OPERATORS, VALUES)\n        ],\n    )\n    def test_parses_setuptools_legacy_valid(self, marker_string):\n        Marker(marker_string)\n\n    def test_evaluate_setuptools_legacy_markers(self):\n        marker_string = \"python_implementation=='Jython'\"\n        args = [{\"platform_python_implementation\": \"CPython\"}]\n        assert Marker(marker_string).evaluate(*args) is False\n\n    def test_extra_str_normalization(self):\n        raw_name = \"S_P__A_M\"\n        normalized_name = \"s-p-a-m\"\n        lhs = f\"{raw_name!r} == extra\"\n        rhs = f\"extra == {raw_name!r}\"\n\n        assert str(Marker(lhs)) == f'\"{normalized_name}\" == extra'\n        assert str(Marker(rhs)) == f'extra == \"{normalized_name}\"'\n\n    def test_python_full_version_untagged_user_provided(self):\n        \"\"\"A user-provided python_full_version ending with a + fails to parse.\"\"\"\n        with pytest.raises(InvalidVersion):\n            Marker(\"python_full_version < '3.12'\").evaluate(\n                {\"python_full_version\": \"3.11.1+\"}\n            )\n\n    def test_python_full_version_untagged(self):\n        with mock.patch(\"platform.python_version\", return_value=\"3.11.1+\"):\n            assert Marker(\"python_full_version < '3.12'\").evaluate()\n", "tests/test_specifiers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport itertools\nimport operator\n\nimport pytest\n\nfrom packaging.specifiers import InvalidSpecifier, Specifier, SpecifierSet\nfrom packaging.version import Version, parse\n\nfrom .test_version import VERSIONS\n\nLEGACY_SPECIFIERS = [\n    \"==2.1.0.3\",\n    \"!=2.2.0.5\",\n    \"<=5\",\n    \">=7.9a1\",\n    \"<1.0.dev1\",\n    \">2.0.post1\",\n]\n\nSPECIFIERS = [\n    \"~=2.0\",\n    \"==2.1.*\",\n    \"==2.1.0.3\",\n    \"!=2.2.*\",\n    \"!=2.2.0.5\",\n    \"<=5\",\n    \">=7.9a1\",\n    \"<1.0.dev1\",\n    \">2.0.post1\",\n]\n\n\nclass TestSpecifier:\n    @pytest.mark.parametrize(\"specifier\", SPECIFIERS)\n    def test_specifiers_valid(self, specifier):\n        Specifier(specifier)\n\n    @pytest.mark.parametrize(\n        \"specifier\",\n        [\n            # Operator-less specifier\n            \"2.0\",\n            # Invalid operator\n            \"=>2.0\",\n            # Version-less specifier\n            \"==\",\n            # Local segment on operators which don't support them\n            \"~=1.0+5\",\n            \">=1.0+deadbeef\",\n            \"<=1.0+abc123\",\n            \">1.0+watwat\",\n            \"<1.0+1.0\",\n            # Prefix matching on operators which don't support them\n            \"~=1.0.*\",\n            \">=1.0.*\",\n            \"<=1.0.*\",\n            \">1.0.*\",\n            \"<1.0.*\",\n            # Combination of local and prefix matching on operators which do\n            # support one or the other\n            \"==1.0.*+5\",\n            \"!=1.0.*+deadbeef\",\n            # Prefix matching cannot be used with a pre-release, post-release,\n            # dev or local version\n            \"==2.0a1.*\",\n            \"!=2.0a1.*\",\n            \"==2.0.post1.*\",\n            \"!=2.0.post1.*\",\n            \"==2.0.dev1.*\",\n            \"!=2.0.dev1.*\",\n            \"==1.0+5.*\",\n            \"!=1.0+deadbeef.*\",\n            # Prefix matching must appear at the end\n            \"==1.0.*.5\",\n            # Compatible operator requires 2 digits in the release operator\n            \"~=1\",\n            # Cannot use a prefix matching after a .devN version\n            \"==1.0.dev1.*\",\n            \"!=1.0.dev1.*\",\n        ],\n    )\n    def test_specifiers_invalid(self, specifier):\n        with pytest.raises(InvalidSpecifier):\n            Specifier(specifier)\n\n    @pytest.mark.parametrize(\n        \"version\",\n        [\n            # Various development release incarnations\n            \"1.0dev\",\n            \"1.0.dev\",\n            \"1.0dev1\",\n            \"1.0dev\",\n            \"1.0-dev\",\n            \"1.0-dev1\",\n            \"1.0DEV\",\n            \"1.0.DEV\",\n            \"1.0DEV1\",\n            \"1.0DEV\",\n            \"1.0.DEV1\",\n            \"1.0-DEV\",\n            \"1.0-DEV1\",\n            # Various alpha incarnations\n            \"1.0a\",\n            \"1.0.a\",\n            \"1.0.a1\",\n            \"1.0-a\",\n            \"1.0-a1\",\n            \"1.0alpha\",\n            \"1.0.alpha\",\n            \"1.0.alpha1\",\n            \"1.0-alpha\",\n            \"1.0-alpha1\",\n            \"1.0A\",\n            \"1.0.A\",\n            \"1.0.A1\",\n            \"1.0-A\",\n            \"1.0-A1\",\n            \"1.0ALPHA\",\n            \"1.0.ALPHA\",\n            \"1.0.ALPHA1\",\n            \"1.0-ALPHA\",\n            \"1.0-ALPHA1\",\n            # Various beta incarnations\n            \"1.0b\",\n            \"1.0.b\",\n            \"1.0.b1\",\n            \"1.0-b\",\n            \"1.0-b1\",\n            \"1.0beta\",\n            \"1.0.beta\",\n            \"1.0.beta1\",\n            \"1.0-beta\",\n            \"1.0-beta1\",\n            \"1.0B\",\n            \"1.0.B\",\n            \"1.0.B1\",\n            \"1.0-B\",\n            \"1.0-B1\",\n            \"1.0BETA\",\n            \"1.0.BETA\",\n            \"1.0.BETA1\",\n            \"1.0-BETA\",\n            \"1.0-BETA1\",\n            # Various release candidate incarnations\n            \"1.0c\",\n            \"1.0.c\",\n            \"1.0.c1\",\n            \"1.0-c\",\n            \"1.0-c1\",\n            \"1.0rc\",\n            \"1.0.rc\",\n            \"1.0.rc1\",\n            \"1.0-rc\",\n            \"1.0-rc1\",\n            \"1.0C\",\n            \"1.0.C\",\n            \"1.0.C1\",\n            \"1.0-C\",\n            \"1.0-C1\",\n            \"1.0RC\",\n            \"1.0.RC\",\n            \"1.0.RC1\",\n            \"1.0-RC\",\n            \"1.0-RC1\",\n            # Various post release incarnations\n            \"1.0post\",\n            \"1.0.post\",\n            \"1.0post1\",\n            \"1.0post\",\n            \"1.0-post\",\n            \"1.0-post1\",\n            \"1.0POST\",\n            \"1.0.POST\",\n            \"1.0POST1\",\n            \"1.0POST\",\n            \"1.0.POST1\",\n            \"1.0-POST\",\n            \"1.0-POST1\",\n            \"1.0-5\",\n            # Local version case insensitivity\n            \"1.0+AbC\"\n            # Integer Normalization\n            \"1.01\",\n            \"1.0a05\",\n            \"1.0b07\",\n            \"1.0c056\",\n            \"1.0rc09\",\n            \"1.0.post000\",\n            \"1.1.dev09000\",\n            \"00!1.2\",\n            \"0100!0.0\",\n            # Various other normalizations\n            \"v1.0\",\n            \"  \\r \\f \\v v1.0\\t\\n\",\n        ],\n    )\n    def test_specifiers_normalized(self, version):\n        if \"+\" not in version:\n            ops = [\"~=\", \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"]\n        else:\n            ops = [\"==\", \"!=\"]\n\n        for op in ops:\n            Specifier(op + version)\n\n    @pytest.mark.parametrize(\n        (\"specifier\", \"expected\"),\n        [\n            # Single item specifiers should just be reflexive\n            (\"!=2.0\", \"!=2.0\"),\n            (\"<2.0\", \"<2.0\"),\n            (\"<=2.0\", \"<=2.0\"),\n            (\"==2.0\", \"==2.0\"),\n            (\">2.0\", \">2.0\"),\n            (\">=2.0\", \">=2.0\"),\n            (\"~=2.0\", \"~=2.0\"),\n            # Spaces should be removed\n            (\"< 2\", \"<2\"),\n        ],\n    )\n    def test_specifiers_str_and_repr(self, specifier, expected):\n        spec = Specifier(specifier)\n\n        assert str(spec) == expected\n        assert repr(spec) == f\"<Specifier({expected!r})>\"\n\n    @pytest.mark.parametrize(\"specifier\", SPECIFIERS)\n    def test_specifiers_hash(self, specifier):\n        assert hash(Specifier(specifier)) == hash(Specifier(specifier))\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"op\"),\n        itertools.chain.from_iterable(\n            # Verify that the equal (==) operator works correctly\n            [[(x, x, operator.eq) for x in SPECIFIERS]]\n            +\n            # Verify that the not equal (!=) operator works correctly\n            [\n                [(x, y, operator.ne) for j, y in enumerate(SPECIFIERS) if i != j]\n                for i, x in enumerate(SPECIFIERS)\n            ]\n        ),\n    )\n    def test_comparison_true(self, left, right, op):\n        assert op(Specifier(left), Specifier(right))\n        assert op(left, Specifier(right))\n        assert op(Specifier(left), right)\n\n    @pytest.mark.parametrize((\"left\", \"right\"), [(\"==2.8.0\", \"==2.8\")])\n    def test_comparison_canonicalizes(self, left, right):\n        assert Specifier(left) == Specifier(right)\n        assert left == Specifier(right)\n        assert Specifier(left) == right\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"op\"),\n        itertools.chain.from_iterable(\n            # Verify that the equal (==) operator works correctly\n            [[(x, x, operator.ne) for x in SPECIFIERS]]\n            +\n            # Verify that the not equal (!=) operator works correctly\n            [\n                [(x, y, operator.eq) for j, y in enumerate(SPECIFIERS) if i != j]\n                for i, x in enumerate(SPECIFIERS)\n            ]\n        ),\n    )\n    def test_comparison_false(self, left, right, op):\n        assert not op(Specifier(left), Specifier(right))\n        assert not op(left, Specifier(right))\n        assert not op(Specifier(left), right)\n\n    def test_comparison_non_specifier(self):\n        assert Specifier(\"==1.0\") != 12\n        assert not Specifier(\"==1.0\") == 12\n        assert Specifier(\"==1.0\") != \"12\"\n        assert not Specifier(\"==1.0\") == \"12\"\n\n    @pytest.mark.parametrize(\n        (\"version\", \"spec\", \"expected\"),\n        [\n            (v, s, True)\n            for v, s in [\n                # Test the equality operation\n                (\"2.0\", \"==2\"),\n                (\"2.0\", \"==2.0\"),\n                (\"2.0\", \"==2.0.0\"),\n                (\"2.0+deadbeef\", \"==2\"),\n                (\"2.0+deadbeef\", \"==2.0\"),\n                (\"2.0+deadbeef\", \"==2.0.0\"),\n                (\"2.0+deadbeef\", \"==2+deadbeef\"),\n                (\"2.0+deadbeef\", \"==2.0+deadbeef\"),\n                (\"2.0+deadbeef\", \"==2.0.0+deadbeef\"),\n                (\"2.0+deadbeef.0\", \"==2.0.0+deadbeef.00\"),\n                # Test the equality operation with a prefix\n                (\"2.dev1\", \"==2.*\"),\n                (\"2a1\", \"==2.*\"),\n                (\"2a1.post1\", \"==2.*\"),\n                (\"2b1\", \"==2.*\"),\n                (\"2b1.dev1\", \"==2.*\"),\n                (\"2c1\", \"==2.*\"),\n                (\"2c1.post1.dev1\", \"==2.*\"),\n                (\"2c1.post1.dev1\", \"==2.0.*\"),\n                (\"2rc1\", \"==2.*\"),\n                (\"2rc1\", \"==2.0.*\"),\n                (\"2\", \"==2.*\"),\n                (\"2\", \"==2.0.*\"),\n                (\"2\", \"==0!2.*\"),\n                (\"0!2\", \"==2.*\"),\n                (\"2.0\", \"==2.*\"),\n                (\"2.0.0\", \"==2.*\"),\n                (\"2.1+local.version\", \"==2.1.*\"),\n                # Test the in-equality operation\n                (\"2.1\", \"!=2\"),\n                (\"2.1\", \"!=2.0\"),\n                (\"2.0.1\", \"!=2\"),\n                (\"2.0.1\", \"!=2.0\"),\n                (\"2.0.1\", \"!=2.0.0\"),\n                (\"2.0\", \"!=2.0+deadbeef\"),\n                # Test the in-equality operation with a prefix\n                (\"2.0\", \"!=3.*\"),\n                (\"2.1\", \"!=2.0.*\"),\n                # Test the greater than equal operation\n                (\"2.0\", \">=2\"),\n                (\"2.0\", \">=2.0\"),\n                (\"2.0\", \">=2.0.0\"),\n                (\"2.0.post1\", \">=2\"),\n                (\"2.0.post1.dev1\", \">=2\"),\n                (\"3\", \">=2\"),\n                # Test the less than equal operation\n                (\"2.0\", \"<=2\"),\n                (\"2.0\", \"<=2.0\"),\n                (\"2.0\", \"<=2.0.0\"),\n                (\"2.0.dev1\", \"<=2\"),\n                (\"2.0a1\", \"<=2\"),\n                (\"2.0a1.dev1\", \"<=2\"),\n                (\"2.0b1\", \"<=2\"),\n                (\"2.0b1.post1\", \"<=2\"),\n                (\"2.0c1\", \"<=2\"),\n                (\"2.0c1.post1.dev1\", \"<=2\"),\n                (\"2.0rc1\", \"<=2\"),\n                (\"1\", \"<=2\"),\n                # Test the greater than operation\n                (\"3\", \">2\"),\n                (\"2.1\", \">2.0\"),\n                (\"2.0.1\", \">2\"),\n                (\"2.1.post1\", \">2\"),\n                (\"2.1+local.version\", \">2\"),\n                # Test the less than operation\n                (\"1\", \"<2\"),\n                (\"2.0\", \"<2.1\"),\n                (\"2.0.dev0\", \"<2.1\"),\n                # Test the compatibility operation\n                (\"1\", \"~=1.0\"),\n                (\"1.0.1\", \"~=1.0\"),\n                (\"1.1\", \"~=1.0\"),\n                (\"1.9999999\", \"~=1.0\"),\n                (\"1.1\", \"~=1.0a1\"),\n                (\"2022.01.01\", \"~=2022.01.01\"),\n                # Test that epochs are handled sanely\n                (\"2!1.0\", \"~=2!1.0\"),\n                (\"2!1.0\", \"==2!1.*\"),\n                (\"2!1.0\", \"==2!1.0\"),\n                (\"2!1.0\", \"!=1.0\"),\n                (\"2!1.0.0\", \"==2!1.0.0.0.*\"),\n                (\"2!1.0.0\", \"==2!1.0.*\"),\n                (\"2!1.0.0\", \"==2!1.*\"),\n                (\"1.0\", \"!=2!1.0\"),\n                (\"1.0\", \"<=2!0.1\"),\n                (\"2!1.0\", \">=2.0\"),\n                (\"1.0\", \"<2!0.1\"),\n                (\"2!1.0\", \">2.0\"),\n                # Test some normalization rules\n                (\"2.0.5\", \">2.0dev\"),\n            ]\n        ]\n        + [\n            (v, s, False)\n            for v, s in [\n                # Test the equality operation\n                (\"2.1\", \"==2\"),\n                (\"2.1\", \"==2.0\"),\n                (\"2.1\", \"==2.0.0\"),\n                (\"2.0\", \"==2.0+deadbeef\"),\n                # Test the equality operation with a prefix\n                (\"2.0\", \"==3.*\"),\n                (\"2.1\", \"==2.0.*\"),\n                # Test the in-equality operation\n                (\"2.0\", \"!=2\"),\n                (\"2.0\", \"!=2.0\"),\n                (\"2.0\", \"!=2.0.0\"),\n                (\"2.0+deadbeef\", \"!=2\"),\n                (\"2.0+deadbeef\", \"!=2.0\"),\n                (\"2.0+deadbeef\", \"!=2.0.0\"),\n                (\"2.0+deadbeef\", \"!=2+deadbeef\"),\n                (\"2.0+deadbeef\", \"!=2.0+deadbeef\"),\n                (\"2.0+deadbeef\", \"!=2.0.0+deadbeef\"),\n                (\"2.0+deadbeef.0\", \"!=2.0.0+deadbeef.00\"),\n                # Test the in-equality operation with a prefix\n                (\"2.dev1\", \"!=2.*\"),\n                (\"2a1\", \"!=2.*\"),\n                (\"2a1.post1\", \"!=2.*\"),\n                (\"2b1\", \"!=2.*\"),\n                (\"2b1.dev1\", \"!=2.*\"),\n                (\"2c1\", \"!=2.*\"),\n                (\"2c1.post1.dev1\", \"!=2.*\"),\n                (\"2c1.post1.dev1\", \"!=2.0.*\"),\n                (\"2rc1\", \"!=2.*\"),\n                (\"2rc1\", \"!=2.0.*\"),\n                (\"2\", \"!=2.*\"),\n                (\"2\", \"!=2.0.*\"),\n                (\"2.0\", \"!=2.*\"),\n                (\"2.0.0\", \"!=2.*\"),\n                # Test the greater than equal operation\n                (\"2.0.dev1\", \">=2\"),\n                (\"2.0a1\", \">=2\"),\n                (\"2.0a1.dev1\", \">=2\"),\n                (\"2.0b1\", \">=2\"),\n                (\"2.0b1.post1\", \">=2\"),\n                (\"2.0c1\", \">=2\"),\n                (\"2.0c1.post1.dev1\", \">=2\"),\n                (\"2.0rc1\", \">=2\"),\n                (\"1\", \">=2\"),\n                # Test the less than equal operation\n                (\"2.0.post1\", \"<=2\"),\n                (\"2.0.post1.dev1\", \"<=2\"),\n                (\"3\", \"<=2\"),\n                # Test the greater than operation\n                (\"1\", \">2\"),\n                (\"2.0.dev1\", \">2\"),\n                (\"2.0a1\", \">2\"),\n                (\"2.0a1.post1\", \">2\"),\n                (\"2.0b1\", \">2\"),\n                (\"2.0b1.dev1\", \">2\"),\n                (\"2.0c1\", \">2\"),\n                (\"2.0c1.post1.dev1\", \">2\"),\n                (\"2.0rc1\", \">2\"),\n                (\"2.0\", \">2\"),\n                (\"2.0.post1\", \">2\"),\n                (\"2.0.post1.dev1\", \">2\"),\n                (\"2.0+local.version\", \">2\"),\n                # Test the less than operation\n                (\"2.0.dev1\", \"<2\"),\n                (\"2.0a1\", \"<2\"),\n                (\"2.0a1.post1\", \"<2\"),\n                (\"2.0b1\", \"<2\"),\n                (\"2.0b2.dev1\", \"<2\"),\n                (\"2.0c1\", \"<2\"),\n                (\"2.0c1.post1.dev1\", \"<2\"),\n                (\"2.0rc1\", \"<2\"),\n                (\"2.0\", \"<2\"),\n                (\"2.post1\", \"<2\"),\n                (\"2.post1.dev1\", \"<2\"),\n                (\"3\", \"<2\"),\n                # Test the compatibility operation\n                (\"2.0\", \"~=1.0\"),\n                (\"1.1.0\", \"~=1.0.0\"),\n                (\"1.1.post1\", \"~=1.0.0\"),\n                # Test that epochs are handled sanely\n                (\"1.0\", \"~=2!1.0\"),\n                (\"2!1.0\", \"~=1.0\"),\n                (\"2!1.0\", \"==1.0\"),\n                (\"1.0\", \"==2!1.0\"),\n                (\"2!1.0\", \"==1.0.0.*\"),\n                (\"1.0\", \"==2!1.0.0.*\"),\n                (\"2!1.0\", \"==1.*\"),\n                (\"1.0\", \"==2!1.*\"),\n                (\"2!1.0\", \"!=2!1.0\"),\n            ]\n        ],\n    )\n    def test_specifiers(self, version, spec, expected):\n        spec = Specifier(spec, prereleases=True)\n\n        if expected:\n            # Test that the plain string form works\n            assert version in spec\n            assert spec.contains(version)\n\n            # Test that the version instance form works\n            assert Version(version) in spec\n            assert spec.contains(Version(version))\n        else:\n            # Test that the plain string form works\n            assert version not in spec\n            assert not spec.contains(version)\n\n            # Test that the version instance form works\n            assert Version(version) not in spec\n            assert not spec.contains(Version(version))\n\n    @pytest.mark.parametrize(\n        (\"version\", \"spec\", \"expected\"),\n        [\n            (\"1.0.0\", \"===1.0\", False),\n            (\"1.0.dev0\", \"===1.0\", False),\n            # Test identity comparison by itself\n            (\"1.0\", \"===1.0\", True),\n            (\"1.0.dev0\", \"===1.0.dev0\", True),\n        ],\n    )\n    def test_specifiers_identity(self, version, spec, expected):\n        spec = Specifier(spec)\n\n        if expected:\n            # Identity comparisons only support the plain string form\n            assert version in spec\n        else:\n            # Identity comparisons only support the plain string form\n            assert version not in spec\n\n    @pytest.mark.parametrize(\n        (\"specifier\", \"expected\"),\n        [\n            (\"==1.0\", False),\n            (\">=1.0\", False),\n            (\"<=1.0\", False),\n            (\"~=1.0\", False),\n            (\"<1.0\", False),\n            (\">1.0\", False),\n            (\"<1.0.dev1\", False),\n            (\">1.0.dev1\", False),\n            (\"==1.0.*\", False),\n            (\"==1.0.dev1\", True),\n            (\">=1.0.dev1\", True),\n            (\"<=1.0.dev1\", True),\n            (\"~=1.0.dev1\", True),\n        ],\n    )\n    def test_specifier_prereleases_detection(self, specifier, expected):\n        assert Specifier(specifier).prereleases == expected\n\n    @pytest.mark.parametrize(\n        (\"specifier\", \"version\", \"expected\"),\n        [\n            (\">=1.0\", \"2.0.dev1\", False),\n            (\">=2.0.dev1\", \"2.0a1\", True),\n            (\"==2.0.*\", \"2.0a1.dev1\", False),\n            (\"<=2.0\", \"1.0.dev1\", False),\n            (\"<=2.0.dev1\", \"1.0a1\", True),\n        ],\n    )\n    def test_specifiers_prereleases(self, specifier, version, expected):\n        spec = Specifier(specifier)\n\n        if expected:\n            assert version in spec\n            spec.prereleases = False\n            assert version not in spec\n        else:\n            assert version not in spec\n            spec.prereleases = True\n            assert version in spec\n\n    @pytest.mark.parametrize(\n        (\"specifier\", \"prereleases\", \"input\", \"expected\"),\n        [\n            (\">=1.0\", None, [\"2.0a1\"], [\"2.0a1\"]),\n            (\">=1.0.dev1\", None, [\"1.0\", \"2.0a1\"], [\"1.0\", \"2.0a1\"]),\n            (\">=1.0.dev1\", False, [\"1.0\", \"2.0a1\"], [\"1.0\"]),\n        ],\n    )\n    def test_specifier_filter(self, specifier, prereleases, input, expected):\n        spec = Specifier(specifier)\n\n        kwargs = {\"prereleases\": prereleases} if prereleases is not None else {}\n\n        assert list(spec.filter(input, **kwargs)) == expected\n\n    @pytest.mark.parametrize(\n        (\"spec\", \"op\"),\n        [\n            (\"~=2.0\", \"~=\"),\n            (\"==2.1.*\", \"==\"),\n            (\"==2.1.0.3\", \"==\"),\n            (\"!=2.2.*\", \"!=\"),\n            (\"!=2.2.0.5\", \"!=\"),\n            (\"<=5\", \"<=\"),\n            (\">=7.9a1\", \">=\"),\n            (\"<1.0.dev1\", \"<\"),\n            (\">2.0.post1\", \">\"),\n            # === is an escape hatch in PEP 440\n            (\"===lolwat\", \"===\"),\n        ],\n    )\n    def test_specifier_operator_property(self, spec, op):\n        assert Specifier(spec).operator == op\n\n    @pytest.mark.parametrize(\n        (\"spec\", \"version\"),\n        [\n            (\"~=2.0\", \"2.0\"),\n            (\"==2.1.*\", \"2.1.*\"),\n            (\"==2.1.0.3\", \"2.1.0.3\"),\n            (\"!=2.2.*\", \"2.2.*\"),\n            (\"!=2.2.0.5\", \"2.2.0.5\"),\n            (\"<=5\", \"5\"),\n            (\">=7.9a1\", \"7.9a1\"),\n            (\"<1.0.dev1\", \"1.0.dev1\"),\n            (\">2.0.post1\", \"2.0.post1\"),\n            # === is an escape hatch in PEP 440\n            (\"===lolwat\", \"lolwat\"),\n        ],\n    )\n    def test_specifier_version_property(self, spec, version):\n        assert Specifier(spec).version == version\n\n    @pytest.mark.parametrize(\n        (\"spec\", \"expected_length\"),\n        [(\"\", 0), (\"==2.0\", 1), (\">=2.0\", 1), (\">=2.0,<3\", 2), (\">=2.0,<3,==2.4\", 3)],\n    )\n    def test_length(self, spec, expected_length):\n        spec = SpecifierSet(spec)\n        assert len(spec) == expected_length\n\n    @pytest.mark.parametrize(\n        (\"spec\", \"expected_items\"),\n        [\n            (\"\", []),\n            (\"==2.0\", [\"==2.0\"]),\n            (\">=2.0\", [\">=2.0\"]),\n            (\">=2.0,<3\", [\">=2.0\", \"<3\"]),\n            (\">=2.0,<3,==2.4\", [\">=2.0\", \"<3\", \"==2.4\"]),\n        ],\n    )\n    def test_iteration(self, spec, expected_items):\n        spec = SpecifierSet(spec)\n        items = {str(item) for item in spec}\n        assert items == set(expected_items)\n\n    def test_specifier_equal_for_compatible_operator(self):\n        assert Specifier(\"~=1.18.0\") != Specifier(\"~=1.18\")\n\n    def test_specifier_hash_for_compatible_operator(self):\n        assert hash(Specifier(\"~=1.18.0\")) != hash(Specifier(\"~=1.18\"))\n\n\nclass TestSpecifierSet:\n    @pytest.mark.parametrize(\"version\", VERSIONS)\n    def test_empty_specifier(self, version):\n        spec = SpecifierSet(prereleases=True)\n\n        assert version in spec\n        assert spec.contains(version)\n        assert parse(version) in spec\n        assert spec.contains(parse(version))\n\n    def test_specifier_prereleases_explicit(self):\n        spec = SpecifierSet()\n        assert not spec.prereleases\n        assert \"1.0.dev1\" not in spec\n        assert not spec.contains(\"1.0.dev1\")\n        spec.prereleases = True\n        assert spec.prereleases\n        assert \"1.0.dev1\" in spec\n        assert spec.contains(\"1.0.dev1\")\n\n        spec = SpecifierSet(prereleases=True)\n        assert spec.prereleases\n        assert \"1.0.dev1\" in spec\n        assert spec.contains(\"1.0.dev1\")\n        spec.prereleases = False\n        assert not spec.prereleases\n        assert \"1.0.dev1\" not in spec\n        assert not spec.contains(\"1.0.dev1\")\n\n        spec = SpecifierSet(prereleases=True)\n        assert spec.prereleases\n        assert \"1.0.dev1\" in spec\n        assert spec.contains(\"1.0.dev1\")\n        spec.prereleases = None\n        assert not spec.prereleases\n        assert \"1.0.dev1\" not in spec\n        assert not spec.contains(\"1.0.dev1\")\n\n    def test_specifier_contains_prereleases(self):\n        spec = SpecifierSet()\n        assert spec.prereleases is None\n        assert not spec.contains(\"1.0.dev1\")\n        assert spec.contains(\"1.0.dev1\", prereleases=True)\n\n        spec = SpecifierSet(prereleases=True)\n        assert spec.prereleases\n        assert spec.contains(\"1.0.dev1\")\n        assert not spec.contains(\"1.0.dev1\", prereleases=False)\n\n    def test_specifier_contains_installed_prereleases(self):\n        spec = SpecifierSet(\"~=1.0\")\n        assert not spec.contains(\"1.0.0.dev1\", installed=True)\n        assert spec.contains(\"1.0.0.dev1\", prereleases=True, installed=True)\n\n        spec = SpecifierSet(\"~=1.0\", prereleases=True)\n        assert spec.contains(\"1.0.0.dev1\", installed=True)\n        assert not spec.contains(\"1.0.0.dev1\", prereleases=False, installed=False)\n\n    @pytest.mark.parametrize(\n        (\"specifier\", \"specifier_prereleases\", \"prereleases\", \"input\", \"expected\"),\n        [\n            # General test of the filter method\n            (\"\", None, None, [\"1.0\", \"2.0a1\"], [\"1.0\"]),\n            (\">=1.0.dev1\", None, None, [\"1.0\", \"2.0a1\"], [\"1.0\", \"2.0a1\"]),\n            (\"\", None, None, [\"1.0a1\"], [\"1.0a1\"]),\n            (\"\", None, None, [\"1.0\", Version(\"2.0\")], [\"1.0\", Version(\"2.0\")]),\n            # Test overriding with the prereleases parameter on filter\n            (\"\", None, False, [\"1.0a1\"], []),\n            (\">=1.0.dev1\", None, False, [\"1.0\", \"2.0a1\"], [\"1.0\"]),\n            (\"\", None, True, [\"1.0\", \"2.0a1\"], [\"1.0\", \"2.0a1\"]),\n            # Test overriding with the overall specifier\n            (\"\", True, None, [\"1.0\", \"2.0a1\"], [\"1.0\", \"2.0a1\"]),\n            (\"\", False, None, [\"1.0\", \"2.0a1\"], [\"1.0\"]),\n            (\">=1.0.dev1\", True, None, [\"1.0\", \"2.0a1\"], [\"1.0\", \"2.0a1\"]),\n            (\">=1.0.dev1\", False, None, [\"1.0\", \"2.0a1\"], [\"1.0\"]),\n            (\"\", True, None, [\"1.0a1\"], [\"1.0a1\"]),\n            (\"\", False, None, [\"1.0a1\"], []),\n        ],\n    )\n    def test_specifier_filter(\n        self, specifier_prereleases, specifier, prereleases, input, expected\n    ):\n        if specifier_prereleases is None:\n            spec = SpecifierSet(specifier)\n        else:\n            spec = SpecifierSet(specifier, prereleases=specifier_prereleases)\n\n        kwargs = {\"prereleases\": prereleases} if prereleases is not None else {}\n\n        assert list(spec.filter(input, **kwargs)) == expected\n\n    @pytest.mark.parametrize(\n        (\"specifier\", \"expected\"),\n        [\n            # Single item specifiers should just be reflexive\n            (\"!=2.0\", \"!=2.0\"),\n            (\"<2.0\", \"<2.0\"),\n            (\"<=2.0\", \"<=2.0\"),\n            (\"==2.0\", \"==2.0\"),\n            (\">2.0\", \">2.0\"),\n            (\">=2.0\", \">=2.0\"),\n            (\"~=2.0\", \"~=2.0\"),\n            # Spaces should be removed\n            (\"< 2\", \"<2\"),\n            # Multiple item specifiers should work\n            (\"!=2.0,>1.0\", \"!=2.0,>1.0\"),\n            (\"!=2.0 ,>1.0\", \"!=2.0,>1.0\"),\n        ],\n    )\n    def test_specifiers_str_and_repr(self, specifier, expected):\n        spec = SpecifierSet(specifier)\n\n        assert str(spec) == expected\n        assert repr(spec) == f\"<SpecifierSet({expected!r})>\"\n\n    @pytest.mark.parametrize(\"specifier\", SPECIFIERS + LEGACY_SPECIFIERS)\n    def test_specifiers_hash(self, specifier):\n        assert hash(SpecifierSet(specifier)) == hash(SpecifierSet(specifier))\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"expected\"), [(\">2.0\", \"<5.0\", \">2.0,<5.0\")]\n    )\n    def test_specifiers_combine(self, left, right, expected):\n        result = SpecifierSet(left) & SpecifierSet(right)\n        assert result == SpecifierSet(expected)\n\n        result = SpecifierSet(left) & right\n        assert result == SpecifierSet(expected)\n\n        result = SpecifierSet(left, prereleases=True) & SpecifierSet(right)\n        assert result == SpecifierSet(expected)\n        assert result.prereleases\n\n        result = SpecifierSet(left, prereleases=False) & SpecifierSet(right)\n        assert result == SpecifierSet(expected)\n        assert not result.prereleases\n\n        result = SpecifierSet(left) & SpecifierSet(right, prereleases=True)\n        assert result == SpecifierSet(expected)\n        assert result.prereleases\n\n        result = SpecifierSet(left) & SpecifierSet(right, prereleases=False)\n        assert result == SpecifierSet(expected)\n        assert not result.prereleases\n\n        result = SpecifierSet(left, prereleases=True) & SpecifierSet(\n            right, prereleases=True\n        )\n        assert result == SpecifierSet(expected)\n        assert result.prereleases\n\n        result = SpecifierSet(left, prereleases=False) & SpecifierSet(\n            right, prereleases=False\n        )\n        assert result == SpecifierSet(expected)\n        assert not result.prereleases\n\n        with pytest.raises(ValueError):\n            result = SpecifierSet(left, prereleases=True) & SpecifierSet(\n                right, prereleases=False\n            )\n\n        with pytest.raises(ValueError):\n            result = SpecifierSet(left, prereleases=False) & SpecifierSet(\n                right, prereleases=True\n            )\n\n    def test_specifiers_combine_not_implemented(self):\n        with pytest.raises(TypeError):\n            SpecifierSet() & 12\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"op\"),\n        itertools.chain.from_iterable(\n            # Verify that the equal (==) operator works correctly\n            [[(x, x, operator.eq) for x in SPECIFIERS]]\n            +\n            # Verify that the not equal (!=) operator works correctly\n            [\n                [(x, y, operator.ne) for j, y in enumerate(SPECIFIERS) if i != j]\n                for i, x in enumerate(SPECIFIERS)\n            ]\n        ),\n    )\n    def test_comparison_true(self, left, right, op):\n        assert op(SpecifierSet(left), SpecifierSet(right))\n        assert op(SpecifierSet(left), Specifier(right))\n        assert op(Specifier(left), SpecifierSet(right))\n        assert op(left, SpecifierSet(right))\n        assert op(SpecifierSet(left), right)\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"op\"),\n        itertools.chain.from_iterable(\n            # Verify that the equal (==) operator works correctly\n            [[(x, x, operator.ne) for x in SPECIFIERS]]\n            +\n            # Verify that the not equal (!=) operator works correctly\n            [\n                [(x, y, operator.eq) for j, y in enumerate(SPECIFIERS) if i != j]\n                for i, x in enumerate(SPECIFIERS)\n            ]\n        ),\n    )\n    def test_comparison_false(self, left, right, op):\n        assert not op(SpecifierSet(left), SpecifierSet(right))\n        assert not op(SpecifierSet(left), Specifier(right))\n        assert not op(Specifier(left), SpecifierSet(right))\n        assert not op(left, SpecifierSet(right))\n        assert not op(SpecifierSet(left), right)\n\n    @pytest.mark.parametrize((\"left\", \"right\"), [(\"==2.8.0\", \"==2.8\")])\n    def test_comparison_canonicalizes(self, left, right):\n        assert SpecifierSet(left) == SpecifierSet(right)\n        assert left == SpecifierSet(right)\n        assert SpecifierSet(left) == right\n\n    def test_comparison_non_specifier(self):\n        assert SpecifierSet(\"==1.0\") != 12\n        assert not SpecifierSet(\"==1.0\") == 12\n\n    @pytest.mark.parametrize(\n        (\"version\", \"specifier\", \"expected\"),\n        [\n            (\"1.0.0+local\", \"==1.0.0\", True),\n            (\"1.0.0+local\", \"!=1.0.0\", False),\n            (\"1.0.0+local\", \"<=1.0.0\", True),\n            (\"1.0.0+local\", \">=1.0.0\", True),\n            (\"1.0.0+local\", \"<1.0.0\", False),\n            (\"1.0.0+local\", \">1.0.0\", False),\n        ],\n    )\n    def test_comparison_ignores_local(self, version, specifier, expected):\n        assert (Version(version) in SpecifierSet(specifier)) == expected\n\n    def test_contains_with_compatible_operator(self):\n        combination = SpecifierSet(\"~=1.18.0\") & SpecifierSet(\"~=1.18\")\n        assert \"1.19.5\" not in combination\n        assert \"1.18.0\" in combination\n", "tests/test_version.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport itertools\nimport operator\n\nimport pretend\nimport pytest\n\nfrom packaging.version import InvalidVersion, Version, parse\n\n\ndef test_parse():\n    assert isinstance(parse(\"1.0\"), Version)\n\n\ndef test_parse_raises():\n    with pytest.raises(InvalidVersion):\n        parse(\"lolwat\")\n\n\n# This list must be in the correct sorting order\nVERSIONS = [\n    # Implicit epoch of 0\n    \"1.0.dev456\",\n    \"1.0a1\",\n    \"1.0a2.dev456\",\n    \"1.0a12.dev456\",\n    \"1.0a12\",\n    \"1.0b1.dev456\",\n    \"1.0b2\",\n    \"1.0b2.post345.dev456\",\n    \"1.0b2.post345\",\n    \"1.0b2-346\",\n    \"1.0c1.dev456\",\n    \"1.0c1\",\n    \"1.0rc2\",\n    \"1.0c3\",\n    \"1.0\",\n    \"1.0.post456.dev34\",\n    \"1.0.post456\",\n    \"1.1.dev1\",\n    \"1.2+123abc\",\n    \"1.2+123abc456\",\n    \"1.2+abc\",\n    \"1.2+abc123\",\n    \"1.2+abc123def\",\n    \"1.2+1234.abc\",\n    \"1.2+123456\",\n    \"1.2.r32+123456\",\n    \"1.2.rev33+123456\",\n    # Explicit epoch of 1\n    \"1!1.0.dev456\",\n    \"1!1.0a1\",\n    \"1!1.0a2.dev456\",\n    \"1!1.0a12.dev456\",\n    \"1!1.0a12\",\n    \"1!1.0b1.dev456\",\n    \"1!1.0b2\",\n    \"1!1.0b2.post345.dev456\",\n    \"1!1.0b2.post345\",\n    \"1!1.0b2-346\",\n    \"1!1.0c1.dev456\",\n    \"1!1.0c1\",\n    \"1!1.0rc2\",\n    \"1!1.0c3\",\n    \"1!1.0\",\n    \"1!1.0.post456.dev34\",\n    \"1!1.0.post456\",\n    \"1!1.1.dev1\",\n    \"1!1.2+123abc\",\n    \"1!1.2+123abc456\",\n    \"1!1.2+abc\",\n    \"1!1.2+abc123\",\n    \"1!1.2+abc123def\",\n    \"1!1.2+1234.abc\",\n    \"1!1.2+123456\",\n    \"1!1.2.r32+123456\",\n    \"1!1.2.rev33+123456\",\n]\n\n\nclass TestVersion:\n    @pytest.mark.parametrize(\"version\", VERSIONS)\n    def test_valid_versions(self, version):\n        Version(version)\n\n    @pytest.mark.parametrize(\n        \"version\",\n        [\n            # Non sensical versions should be invalid\n            \"french toast\",\n            # Versions with invalid local versions\n            \"1.0+a+\",\n            \"1.0++\",\n            \"1.0+_foobar\",\n            \"1.0+foo&asd\",\n            \"1.0+1+1\",\n        ],\n    )\n    def test_invalid_versions(self, version):\n        with pytest.raises(InvalidVersion):\n            Version(version)\n\n    @pytest.mark.parametrize(\n        (\"version\", \"normalized\"),\n        [\n            # Various development release incarnations\n            (\"1.0dev\", \"1.0.dev0\"),\n            (\"1.0.dev\", \"1.0.dev0\"),\n            (\"1.0dev1\", \"1.0.dev1\"),\n            (\"1.0dev\", \"1.0.dev0\"),\n            (\"1.0-dev\", \"1.0.dev0\"),\n            (\"1.0-dev1\", \"1.0.dev1\"),\n            (\"1.0DEV\", \"1.0.dev0\"),\n            (\"1.0.DEV\", \"1.0.dev0\"),\n            (\"1.0DEV1\", \"1.0.dev1\"),\n            (\"1.0DEV\", \"1.0.dev0\"),\n            (\"1.0.DEV1\", \"1.0.dev1\"),\n            (\"1.0-DEV\", \"1.0.dev0\"),\n            (\"1.0-DEV1\", \"1.0.dev1\"),\n            # Various alpha incarnations\n            (\"1.0a\", \"1.0a0\"),\n            (\"1.0.a\", \"1.0a0\"),\n            (\"1.0.a1\", \"1.0a1\"),\n            (\"1.0-a\", \"1.0a0\"),\n            (\"1.0-a1\", \"1.0a1\"),\n            (\"1.0alpha\", \"1.0a0\"),\n            (\"1.0.alpha\", \"1.0a0\"),\n            (\"1.0.alpha1\", \"1.0a1\"),\n            (\"1.0-alpha\", \"1.0a0\"),\n            (\"1.0-alpha1\", \"1.0a1\"),\n            (\"1.0A\", \"1.0a0\"),\n            (\"1.0.A\", \"1.0a0\"),\n            (\"1.0.A1\", \"1.0a1\"),\n            (\"1.0-A\", \"1.0a0\"),\n            (\"1.0-A1\", \"1.0a1\"),\n            (\"1.0ALPHA\", \"1.0a0\"),\n            (\"1.0.ALPHA\", \"1.0a0\"),\n            (\"1.0.ALPHA1\", \"1.0a1\"),\n            (\"1.0-ALPHA\", \"1.0a0\"),\n            (\"1.0-ALPHA1\", \"1.0a1\"),\n            # Various beta incarnations\n            (\"1.0b\", \"1.0b0\"),\n            (\"1.0.b\", \"1.0b0\"),\n            (\"1.0.b1\", \"1.0b1\"),\n            (\"1.0-b\", \"1.0b0\"),\n            (\"1.0-b1\", \"1.0b1\"),\n            (\"1.0beta\", \"1.0b0\"),\n            (\"1.0.beta\", \"1.0b0\"),\n            (\"1.0.beta1\", \"1.0b1\"),\n            (\"1.0-beta\", \"1.0b0\"),\n            (\"1.0-beta1\", \"1.0b1\"),\n            (\"1.0B\", \"1.0b0\"),\n            (\"1.0.B\", \"1.0b0\"),\n            (\"1.0.B1\", \"1.0b1\"),\n            (\"1.0-B\", \"1.0b0\"),\n            (\"1.0-B1\", \"1.0b1\"),\n            (\"1.0BETA\", \"1.0b0\"),\n            (\"1.0.BETA\", \"1.0b0\"),\n            (\"1.0.BETA1\", \"1.0b1\"),\n            (\"1.0-BETA\", \"1.0b0\"),\n            (\"1.0-BETA1\", \"1.0b1\"),\n            # Various release candidate incarnations\n            (\"1.0c\", \"1.0rc0\"),\n            (\"1.0.c\", \"1.0rc0\"),\n            (\"1.0.c1\", \"1.0rc1\"),\n            (\"1.0-c\", \"1.0rc0\"),\n            (\"1.0-c1\", \"1.0rc1\"),\n            (\"1.0rc\", \"1.0rc0\"),\n            (\"1.0.rc\", \"1.0rc0\"),\n            (\"1.0.rc1\", \"1.0rc1\"),\n            (\"1.0-rc\", \"1.0rc0\"),\n            (\"1.0-rc1\", \"1.0rc1\"),\n            (\"1.0C\", \"1.0rc0\"),\n            (\"1.0.C\", \"1.0rc0\"),\n            (\"1.0.C1\", \"1.0rc1\"),\n            (\"1.0-C\", \"1.0rc0\"),\n            (\"1.0-C1\", \"1.0rc1\"),\n            (\"1.0RC\", \"1.0rc0\"),\n            (\"1.0.RC\", \"1.0rc0\"),\n            (\"1.0.RC1\", \"1.0rc1\"),\n            (\"1.0-RC\", \"1.0rc0\"),\n            (\"1.0-RC1\", \"1.0rc1\"),\n            # Various post release incarnations\n            (\"1.0post\", \"1.0.post0\"),\n            (\"1.0.post\", \"1.0.post0\"),\n            (\"1.0post1\", \"1.0.post1\"),\n            (\"1.0post\", \"1.0.post0\"),\n            (\"1.0-post\", \"1.0.post0\"),\n            (\"1.0-post1\", \"1.0.post1\"),\n            (\"1.0POST\", \"1.0.post0\"),\n            (\"1.0.POST\", \"1.0.post0\"),\n            (\"1.0POST1\", \"1.0.post1\"),\n            (\"1.0POST\", \"1.0.post0\"),\n            (\"1.0r\", \"1.0.post0\"),\n            (\"1.0rev\", \"1.0.post0\"),\n            (\"1.0.POST1\", \"1.0.post1\"),\n            (\"1.0.r1\", \"1.0.post1\"),\n            (\"1.0.rev1\", \"1.0.post1\"),\n            (\"1.0-POST\", \"1.0.post0\"),\n            (\"1.0-POST1\", \"1.0.post1\"),\n            (\"1.0-5\", \"1.0.post5\"),\n            (\"1.0-r5\", \"1.0.post5\"),\n            (\"1.0-rev5\", \"1.0.post5\"),\n            # Local version case insensitivity\n            (\"1.0+AbC\", \"1.0+abc\"),\n            # Integer Normalization\n            (\"1.01\", \"1.1\"),\n            (\"1.0a05\", \"1.0a5\"),\n            (\"1.0b07\", \"1.0b7\"),\n            (\"1.0c056\", \"1.0rc56\"),\n            (\"1.0rc09\", \"1.0rc9\"),\n            (\"1.0.post000\", \"1.0.post0\"),\n            (\"1.1.dev09000\", \"1.1.dev9000\"),\n            (\"00!1.2\", \"1.2\"),\n            (\"0100!0.0\", \"100!0.0\"),\n            # Various other normalizations\n            (\"v1.0\", \"1.0\"),\n            (\"   v1.0\\t\\n\", \"1.0\"),\n        ],\n    )\n    def test_normalized_versions(self, version, normalized):\n        assert str(Version(version)) == normalized\n\n    @pytest.mark.parametrize(\n        (\"version\", \"expected\"),\n        [\n            (\"1.0.dev456\", \"1.0.dev456\"),\n            (\"1.0a1\", \"1.0a1\"),\n            (\"1.0a2.dev456\", \"1.0a2.dev456\"),\n            (\"1.0a12.dev456\", \"1.0a12.dev456\"),\n            (\"1.0a12\", \"1.0a12\"),\n            (\"1.0b1.dev456\", \"1.0b1.dev456\"),\n            (\"1.0b2\", \"1.0b2\"),\n            (\"1.0b2.post345.dev456\", \"1.0b2.post345.dev456\"),\n            (\"1.0b2.post345\", \"1.0b2.post345\"),\n            (\"1.0rc1.dev456\", \"1.0rc1.dev456\"),\n            (\"1.0rc1\", \"1.0rc1\"),\n            (\"1.0\", \"1.0\"),\n            (\"1.0.post456.dev34\", \"1.0.post456.dev34\"),\n            (\"1.0.post456\", \"1.0.post456\"),\n            (\"1.0.1\", \"1.0.1\"),\n            (\"0!1.0.2\", \"1.0.2\"),\n            (\"1.0.3+7\", \"1.0.3+7\"),\n            (\"0!1.0.4+8.0\", \"1.0.4+8.0\"),\n            (\"1.0.5+9.5\", \"1.0.5+9.5\"),\n            (\"1.2+1234.abc\", \"1.2+1234.abc\"),\n            (\"1.2+123456\", \"1.2+123456\"),\n            (\"1.2+123abc\", \"1.2+123abc\"),\n            (\"1.2+123abc456\", \"1.2+123abc456\"),\n            (\"1.2+abc\", \"1.2+abc\"),\n            (\"1.2+abc123\", \"1.2+abc123\"),\n            (\"1.2+abc123def\", \"1.2+abc123def\"),\n            (\"1.1.dev1\", \"1.1.dev1\"),\n            (\"7!1.0.dev456\", \"7!1.0.dev456\"),\n            (\"7!1.0a1\", \"7!1.0a1\"),\n            (\"7!1.0a2.dev456\", \"7!1.0a2.dev456\"),\n            (\"7!1.0a12.dev456\", \"7!1.0a12.dev456\"),\n            (\"7!1.0a12\", \"7!1.0a12\"),\n            (\"7!1.0b1.dev456\", \"7!1.0b1.dev456\"),\n            (\"7!1.0b2\", \"7!1.0b2\"),\n            (\"7!1.0b2.post345.dev456\", \"7!1.0b2.post345.dev456\"),\n            (\"7!1.0b2.post345\", \"7!1.0b2.post345\"),\n            (\"7!1.0rc1.dev456\", \"7!1.0rc1.dev456\"),\n            (\"7!1.0rc1\", \"7!1.0rc1\"),\n            (\"7!1.0\", \"7!1.0\"),\n            (\"7!1.0.post456.dev34\", \"7!1.0.post456.dev34\"),\n            (\"7!1.0.post456\", \"7!1.0.post456\"),\n            (\"7!1.0.1\", \"7!1.0.1\"),\n            (\"7!1.0.2\", \"7!1.0.2\"),\n            (\"7!1.0.3+7\", \"7!1.0.3+7\"),\n            (\"7!1.0.4+8.0\", \"7!1.0.4+8.0\"),\n            (\"7!1.0.5+9.5\", \"7!1.0.5+9.5\"),\n            (\"7!1.1.dev1\", \"7!1.1.dev1\"),\n        ],\n    )\n    def test_version_str_repr(self, version, expected):\n        assert str(Version(version)) == expected\n        assert repr(Version(version)) == f\"<Version({expected!r})>\"\n\n    def test_version_rc_and_c_equals(self):\n        assert Version(\"1.0rc1\") == Version(\"1.0c1\")\n\n    @pytest.mark.parametrize(\"version\", VERSIONS)\n    def test_version_hash(self, version):\n        assert hash(Version(version)) == hash(Version(version))\n\n    @pytest.mark.parametrize(\n        (\"version\", \"public\"),\n        [\n            (\"1.0\", \"1.0\"),\n            (\"1.0.dev0\", \"1.0.dev0\"),\n            (\"1.0.dev6\", \"1.0.dev6\"),\n            (\"1.0a1\", \"1.0a1\"),\n            (\"1.0a1.post5\", \"1.0a1.post5\"),\n            (\"1.0a1.post5.dev6\", \"1.0a1.post5.dev6\"),\n            (\"1.0rc4\", \"1.0rc4\"),\n            (\"1.0.post5\", \"1.0.post5\"),\n            (\"1!1.0\", \"1!1.0\"),\n            (\"1!1.0.dev6\", \"1!1.0.dev6\"),\n            (\"1!1.0a1\", \"1!1.0a1\"),\n            (\"1!1.0a1.post5\", \"1!1.0a1.post5\"),\n            (\"1!1.0a1.post5.dev6\", \"1!1.0a1.post5.dev6\"),\n            (\"1!1.0rc4\", \"1!1.0rc4\"),\n            (\"1!1.0.post5\", \"1!1.0.post5\"),\n            (\"1.0+deadbeef\", \"1.0\"),\n            (\"1.0.dev6+deadbeef\", \"1.0.dev6\"),\n            (\"1.0a1+deadbeef\", \"1.0a1\"),\n            (\"1.0a1.post5+deadbeef\", \"1.0a1.post5\"),\n            (\"1.0a1.post5.dev6+deadbeef\", \"1.0a1.post5.dev6\"),\n            (\"1.0rc4+deadbeef\", \"1.0rc4\"),\n            (\"1.0.post5+deadbeef\", \"1.0.post5\"),\n            (\"1!1.0+deadbeef\", \"1!1.0\"),\n            (\"1!1.0.dev6+deadbeef\", \"1!1.0.dev6\"),\n            (\"1!1.0a1+deadbeef\", \"1!1.0a1\"),\n            (\"1!1.0a1.post5+deadbeef\", \"1!1.0a1.post5\"),\n            (\"1!1.0a1.post5.dev6+deadbeef\", \"1!1.0a1.post5.dev6\"),\n            (\"1!1.0rc4+deadbeef\", \"1!1.0rc4\"),\n            (\"1!1.0.post5+deadbeef\", \"1!1.0.post5\"),\n        ],\n    )\n    def test_version_public(self, version, public):\n        assert Version(version).public == public\n\n    @pytest.mark.parametrize(\n        (\"version\", \"base_version\"),\n        [\n            (\"1.0\", \"1.0\"),\n            (\"1.0.dev0\", \"1.0\"),\n            (\"1.0.dev6\", \"1.0\"),\n            (\"1.0a1\", \"1.0\"),\n            (\"1.0a1.post5\", \"1.0\"),\n            (\"1.0a1.post5.dev6\", \"1.0\"),\n            (\"1.0rc4\", \"1.0\"),\n            (\"1.0.post5\", \"1.0\"),\n            (\"1!1.0\", \"1!1.0\"),\n            (\"1!1.0.dev6\", \"1!1.0\"),\n            (\"1!1.0a1\", \"1!1.0\"),\n            (\"1!1.0a1.post5\", \"1!1.0\"),\n            (\"1!1.0a1.post5.dev6\", \"1!1.0\"),\n            (\"1!1.0rc4\", \"1!1.0\"),\n            (\"1!1.0.post5\", \"1!1.0\"),\n            (\"1.0+deadbeef\", \"1.0\"),\n            (\"1.0.dev6+deadbeef\", \"1.0\"),\n            (\"1.0a1+deadbeef\", \"1.0\"),\n            (\"1.0a1.post5+deadbeef\", \"1.0\"),\n            (\"1.0a1.post5.dev6+deadbeef\", \"1.0\"),\n            (\"1.0rc4+deadbeef\", \"1.0\"),\n            (\"1.0.post5+deadbeef\", \"1.0\"),\n            (\"1!1.0+deadbeef\", \"1!1.0\"),\n            (\"1!1.0.dev6+deadbeef\", \"1!1.0\"),\n            (\"1!1.0a1+deadbeef\", \"1!1.0\"),\n            (\"1!1.0a1.post5+deadbeef\", \"1!1.0\"),\n            (\"1!1.0a1.post5.dev6+deadbeef\", \"1!1.0\"),\n            (\"1!1.0rc4+deadbeef\", \"1!1.0\"),\n            (\"1!1.0.post5+deadbeef\", \"1!1.0\"),\n        ],\n    )\n    def test_version_base_version(self, version, base_version):\n        assert Version(version).base_version == base_version\n\n    @pytest.mark.parametrize(\n        (\"version\", \"epoch\"),\n        [\n            (\"1.0\", 0),\n            (\"1.0.dev0\", 0),\n            (\"1.0.dev6\", 0),\n            (\"1.0a1\", 0),\n            (\"1.0a1.post5\", 0),\n            (\"1.0a1.post5.dev6\", 0),\n            (\"1.0rc4\", 0),\n            (\"1.0.post5\", 0),\n            (\"1!1.0\", 1),\n            (\"1!1.0.dev6\", 1),\n            (\"1!1.0a1\", 1),\n            (\"1!1.0a1.post5\", 1),\n            (\"1!1.0a1.post5.dev6\", 1),\n            (\"1!1.0rc4\", 1),\n            (\"1!1.0.post5\", 1),\n            (\"1.0+deadbeef\", 0),\n            (\"1.0.dev6+deadbeef\", 0),\n            (\"1.0a1+deadbeef\", 0),\n            (\"1.0a1.post5+deadbeef\", 0),\n            (\"1.0a1.post5.dev6+deadbeef\", 0),\n            (\"1.0rc4+deadbeef\", 0),\n            (\"1.0.post5+deadbeef\", 0),\n            (\"1!1.0+deadbeef\", 1),\n            (\"1!1.0.dev6+deadbeef\", 1),\n            (\"1!1.0a1+deadbeef\", 1),\n            (\"1!1.0a1.post5+deadbeef\", 1),\n            (\"1!1.0a1.post5.dev6+deadbeef\", 1),\n            (\"1!1.0rc4+deadbeef\", 1),\n            (\"1!1.0.post5+deadbeef\", 1),\n        ],\n    )\n    def test_version_epoch(self, version, epoch):\n        assert Version(version).epoch == epoch\n\n    @pytest.mark.parametrize(\n        (\"version\", \"release\"),\n        [\n            (\"1.0\", (1, 0)),\n            (\"1.0.dev0\", (1, 0)),\n            (\"1.0.dev6\", (1, 0)),\n            (\"1.0a1\", (1, 0)),\n            (\"1.0a1.post5\", (1, 0)),\n            (\"1.0a1.post5.dev6\", (1, 0)),\n            (\"1.0rc4\", (1, 0)),\n            (\"1.0.post5\", (1, 0)),\n            (\"1!1.0\", (1, 0)),\n            (\"1!1.0.dev6\", (1, 0)),\n            (\"1!1.0a1\", (1, 0)),\n            (\"1!1.0a1.post5\", (1, 0)),\n            (\"1!1.0a1.post5.dev6\", (1, 0)),\n            (\"1!1.0rc4\", (1, 0)),\n            (\"1!1.0.post5\", (1, 0)),\n            (\"1.0+deadbeef\", (1, 0)),\n            (\"1.0.dev6+deadbeef\", (1, 0)),\n            (\"1.0a1+deadbeef\", (1, 0)),\n            (\"1.0a1.post5+deadbeef\", (1, 0)),\n            (\"1.0a1.post5.dev6+deadbeef\", (1, 0)),\n            (\"1.0rc4+deadbeef\", (1, 0)),\n            (\"1.0.post5+deadbeef\", (1, 0)),\n            (\"1!1.0+deadbeef\", (1, 0)),\n            (\"1!1.0.dev6+deadbeef\", (1, 0)),\n            (\"1!1.0a1+deadbeef\", (1, 0)),\n            (\"1!1.0a1.post5+deadbeef\", (1, 0)),\n            (\"1!1.0a1.post5.dev6+deadbeef\", (1, 0)),\n            (\"1!1.0rc4+deadbeef\", (1, 0)),\n            (\"1!1.0.post5+deadbeef\", (1, 0)),\n        ],\n    )\n    def test_version_release(self, version, release):\n        assert Version(version).release == release\n\n    @pytest.mark.parametrize(\n        (\"version\", \"local\"),\n        [\n            (\"1.0\", None),\n            (\"1.0.dev0\", None),\n            (\"1.0.dev6\", None),\n            (\"1.0a1\", None),\n            (\"1.0a1.post5\", None),\n            (\"1.0a1.post5.dev6\", None),\n            (\"1.0rc4\", None),\n            (\"1.0.post5\", None),\n            (\"1!1.0\", None),\n            (\"1!1.0.dev6\", None),\n            (\"1!1.0a1\", None),\n            (\"1!1.0a1.post5\", None),\n            (\"1!1.0a1.post5.dev6\", None),\n            (\"1!1.0rc4\", None),\n            (\"1!1.0.post5\", None),\n            (\"1.0+deadbeef\", \"deadbeef\"),\n            (\"1.0.dev6+deadbeef\", \"deadbeef\"),\n            (\"1.0a1+deadbeef\", \"deadbeef\"),\n            (\"1.0a1.post5+deadbeef\", \"deadbeef\"),\n            (\"1.0a1.post5.dev6+deadbeef\", \"deadbeef\"),\n            (\"1.0rc4+deadbeef\", \"deadbeef\"),\n            (\"1.0.post5+deadbeef\", \"deadbeef\"),\n            (\"1!1.0+deadbeef\", \"deadbeef\"),\n            (\"1!1.0.dev6+deadbeef\", \"deadbeef\"),\n            (\"1!1.0a1+deadbeef\", \"deadbeef\"),\n            (\"1!1.0a1.post5+deadbeef\", \"deadbeef\"),\n            (\"1!1.0a1.post5.dev6+deadbeef\", \"deadbeef\"),\n            (\"1!1.0rc4+deadbeef\", \"deadbeef\"),\n            (\"1!1.0.post5+deadbeef\", \"deadbeef\"),\n        ],\n    )\n    def test_version_local(self, version, local):\n        assert Version(version).local == local\n\n    @pytest.mark.parametrize(\n        (\"version\", \"pre\"),\n        [\n            (\"1.0\", None),\n            (\"1.0.dev0\", None),\n            (\"1.0.dev6\", None),\n            (\"1.0a1\", (\"a\", 1)),\n            (\"1.0a1.post5\", (\"a\", 1)),\n            (\"1.0a1.post5.dev6\", (\"a\", 1)),\n            (\"1.0rc4\", (\"rc\", 4)),\n            (\"1.0.post5\", None),\n            (\"1!1.0\", None),\n            (\"1!1.0.dev6\", None),\n            (\"1!1.0a1\", (\"a\", 1)),\n            (\"1!1.0a1.post5\", (\"a\", 1)),\n            (\"1!1.0a1.post5.dev6\", (\"a\", 1)),\n            (\"1!1.0rc4\", (\"rc\", 4)),\n            (\"1!1.0.post5\", None),\n            (\"1.0+deadbeef\", None),\n            (\"1.0.dev6+deadbeef\", None),\n            (\"1.0a1+deadbeef\", (\"a\", 1)),\n            (\"1.0a1.post5+deadbeef\", (\"a\", 1)),\n            (\"1.0a1.post5.dev6+deadbeef\", (\"a\", 1)),\n            (\"1.0rc4+deadbeef\", (\"rc\", 4)),\n            (\"1.0.post5+deadbeef\", None),\n            (\"1!1.0+deadbeef\", None),\n            (\"1!1.0.dev6+deadbeef\", None),\n            (\"1!1.0a1+deadbeef\", (\"a\", 1)),\n            (\"1!1.0a1.post5+deadbeef\", (\"a\", 1)),\n            (\"1!1.0a1.post5.dev6+deadbeef\", (\"a\", 1)),\n            (\"1!1.0rc4+deadbeef\", (\"rc\", 4)),\n            (\"1!1.0.post5+deadbeef\", None),\n        ],\n    )\n    def test_version_pre(self, version, pre):\n        assert Version(version).pre == pre\n\n    @pytest.mark.parametrize(\n        (\"version\", \"expected\"),\n        [\n            (\"1.0.dev0\", True),\n            (\"1.0.dev1\", True),\n            (\"1.0a1.dev1\", True),\n            (\"1.0b1.dev1\", True),\n            (\"1.0c1.dev1\", True),\n            (\"1.0rc1.dev1\", True),\n            (\"1.0a1\", True),\n            (\"1.0b1\", True),\n            (\"1.0c1\", True),\n            (\"1.0rc1\", True),\n            (\"1.0a1.post1.dev1\", True),\n            (\"1.0b1.post1.dev1\", True),\n            (\"1.0c1.post1.dev1\", True),\n            (\"1.0rc1.post1.dev1\", True),\n            (\"1.0a1.post1\", True),\n            (\"1.0b1.post1\", True),\n            (\"1.0c1.post1\", True),\n            (\"1.0rc1.post1\", True),\n            (\"1.0\", False),\n            (\"1.0+dev\", False),\n            (\"1.0.post1\", False),\n            (\"1.0.post1+dev\", False),\n        ],\n    )\n    def test_version_is_prerelease(self, version, expected):\n        assert Version(version).is_prerelease is expected\n\n    @pytest.mark.parametrize(\n        (\"version\", \"dev\"),\n        [\n            (\"1.0\", None),\n            (\"1.0.dev0\", 0),\n            (\"1.0.dev6\", 6),\n            (\"1.0a1\", None),\n            (\"1.0a1.post5\", None),\n            (\"1.0a1.post5.dev6\", 6),\n            (\"1.0rc4\", None),\n            (\"1.0.post5\", None),\n            (\"1!1.0\", None),\n            (\"1!1.0.dev6\", 6),\n            (\"1!1.0a1\", None),\n            (\"1!1.0a1.post5\", None),\n            (\"1!1.0a1.post5.dev6\", 6),\n            (\"1!1.0rc4\", None),\n            (\"1!1.0.post5\", None),\n            (\"1.0+deadbeef\", None),\n            (\"1.0.dev6+deadbeef\", 6),\n            (\"1.0a1+deadbeef\", None),\n            (\"1.0a1.post5+deadbeef\", None),\n            (\"1.0a1.post5.dev6+deadbeef\", 6),\n            (\"1.0rc4+deadbeef\", None),\n            (\"1.0.post5+deadbeef\", None),\n            (\"1!1.0+deadbeef\", None),\n            (\"1!1.0.dev6+deadbeef\", 6),\n            (\"1!1.0a1+deadbeef\", None),\n            (\"1!1.0a1.post5+deadbeef\", None),\n            (\"1!1.0a1.post5.dev6+deadbeef\", 6),\n            (\"1!1.0rc4+deadbeef\", None),\n            (\"1!1.0.post5+deadbeef\", None),\n        ],\n    )\n    def test_version_dev(self, version, dev):\n        assert Version(version).dev == dev\n\n    @pytest.mark.parametrize(\n        (\"version\", \"expected\"),\n        [\n            (\"1.0\", False),\n            (\"1.0.dev0\", True),\n            (\"1.0.dev6\", True),\n            (\"1.0a1\", False),\n            (\"1.0a1.post5\", False),\n            (\"1.0a1.post5.dev6\", True),\n            (\"1.0rc4\", False),\n            (\"1.0.post5\", False),\n            (\"1!1.0\", False),\n            (\"1!1.0.dev6\", True),\n            (\"1!1.0a1\", False),\n            (\"1!1.0a1.post5\", False),\n            (\"1!1.0a1.post5.dev6\", True),\n            (\"1!1.0rc4\", False),\n            (\"1!1.0.post5\", False),\n            (\"1.0+deadbeef\", False),\n            (\"1.0.dev6+deadbeef\", True),\n            (\"1.0a1+deadbeef\", False),\n            (\"1.0a1.post5+deadbeef\", False),\n            (\"1.0a1.post5.dev6+deadbeef\", True),\n            (\"1.0rc4+deadbeef\", False),\n            (\"1.0.post5+deadbeef\", False),\n            (\"1!1.0+deadbeef\", False),\n            (\"1!1.0.dev6+deadbeef\", True),\n            (\"1!1.0a1+deadbeef\", False),\n            (\"1!1.0a1.post5+deadbeef\", False),\n            (\"1!1.0a1.post5.dev6+deadbeef\", True),\n            (\"1!1.0rc4+deadbeef\", False),\n            (\"1!1.0.post5+deadbeef\", False),\n        ],\n    )\n    def test_version_is_devrelease(self, version, expected):\n        assert Version(version).is_devrelease is expected\n\n    @pytest.mark.parametrize(\n        (\"version\", \"post\"),\n        [\n            (\"1.0\", None),\n            (\"1.0.dev0\", None),\n            (\"1.0.dev6\", None),\n            (\"1.0a1\", None),\n            (\"1.0a1.post5\", 5),\n            (\"1.0a1.post5.dev6\", 5),\n            (\"1.0rc4\", None),\n            (\"1.0.post5\", 5),\n            (\"1!1.0\", None),\n            (\"1!1.0.dev6\", None),\n            (\"1!1.0a1\", None),\n            (\"1!1.0a1.post5\", 5),\n            (\"1!1.0a1.post5.dev6\", 5),\n            (\"1!1.0rc4\", None),\n            (\"1!1.0.post5\", 5),\n            (\"1.0+deadbeef\", None),\n            (\"1.0.dev6+deadbeef\", None),\n            (\"1.0a1+deadbeef\", None),\n            (\"1.0a1.post5+deadbeef\", 5),\n            (\"1.0a1.post5.dev6+deadbeef\", 5),\n            (\"1.0rc4+deadbeef\", None),\n            (\"1.0.post5+deadbeef\", 5),\n            (\"1!1.0+deadbeef\", None),\n            (\"1!1.0.dev6+deadbeef\", None),\n            (\"1!1.0a1+deadbeef\", None),\n            (\"1!1.0a1.post5+deadbeef\", 5),\n            (\"1!1.0a1.post5.dev6+deadbeef\", 5),\n            (\"1!1.0rc4+deadbeef\", None),\n            (\"1!1.0.post5+deadbeef\", 5),\n        ],\n    )\n    def test_version_post(self, version, post):\n        assert Version(version).post == post\n\n    @pytest.mark.parametrize(\n        (\"version\", \"expected\"),\n        [\n            (\"1.0.dev1\", False),\n            (\"1.0\", False),\n            (\"1.0+foo\", False),\n            (\"1.0.post1.dev1\", True),\n            (\"1.0.post1\", True),\n        ],\n    )\n    def test_version_is_postrelease(self, version, expected):\n        assert Version(version).is_postrelease is expected\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"op\"),\n        # Below we'll generate every possible combination of VERSIONS that\n        # should be True for the given operator\n        itertools.chain.from_iterable(\n            # Verify that the less than (<) operator works correctly\n            [\n                [(x, y, operator.lt) for y in VERSIONS[i + 1 :]]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the less than equal (<=) operator works correctly\n            [\n                [(x, y, operator.le) for y in VERSIONS[i:]]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the equal (==) operator works correctly\n            [[(x, x, operator.eq) for x in VERSIONS]]\n            +\n            # Verify that the not equal (!=) operator works correctly\n            [\n                [(x, y, operator.ne) for j, y in enumerate(VERSIONS) if i != j]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the greater than equal (>=) operator works correctly\n            [\n                [(x, y, operator.ge) for y in VERSIONS[: i + 1]]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the greater than (>) operator works correctly\n            [\n                [(x, y, operator.gt) for y in VERSIONS[:i]]\n                for i, x in enumerate(VERSIONS)\n            ]\n        ),\n    )\n    def test_comparison_true(self, left, right, op):\n        assert op(Version(left), Version(right))\n\n    @pytest.mark.parametrize(\n        (\"left\", \"right\", \"op\"),\n        # Below we'll generate every possible combination of VERSIONS that\n        # should be False for the given operator\n        itertools.chain.from_iterable(\n            # Verify that the less than (<) operator works correctly\n            [\n                [(x, y, operator.lt) for y in VERSIONS[: i + 1]]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the less than equal (<=) operator works correctly\n            [\n                [(x, y, operator.le) for y in VERSIONS[:i]]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the equal (==) operator works correctly\n            [\n                [(x, y, operator.eq) for j, y in enumerate(VERSIONS) if i != j]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the not equal (!=) operator works correctly\n            [[(x, x, operator.ne) for x in VERSIONS]]\n            +\n            # Verify that the greater than equal (>=) operator works correctly\n            [\n                [(x, y, operator.ge) for y in VERSIONS[i + 1 :]]\n                for i, x in enumerate(VERSIONS)\n            ]\n            +\n            # Verify that the greater than (>) operator works correctly\n            [\n                [(x, y, operator.gt) for y in VERSIONS[i:]]\n                for i, x in enumerate(VERSIONS)\n            ]\n        ),\n    )\n    def test_comparison_false(self, left, right, op):\n        assert not op(Version(left), Version(right))\n\n    @pytest.mark.parametrize(\"op\", [\"lt\", \"le\", \"eq\", \"ge\", \"gt\", \"ne\"])\n    def test_dunder_op_returns_notimplemented(self, op):\n        method = getattr(Version, f\"__{op}__\")\n        assert method(Version(\"1\"), 1) is NotImplemented\n\n    @pytest.mark.parametrize((\"op\", \"expected\"), [(\"eq\", False), (\"ne\", True)])\n    def test_compare_other(self, op, expected):\n        other = pretend.stub(**{f\"__{op}__\": lambda other: NotImplemented})\n\n        assert getattr(operator, op)(Version(\"1\"), other) is expected\n\n    def test_major_version(self):\n        assert Version(\"2.1.0\").major == 2\n\n    def test_minor_version(self):\n        assert Version(\"2.1.0\").minor == 1\n        assert Version(\"2\").minor == 0\n\n    def test_micro_version(self):\n        assert Version(\"2.1.3\").micro == 3\n        assert Version(\"2.1\").micro == 0\n        assert Version(\"2\").micro == 0\n", "tests/test_metadata.py": "import pathlib\n\nimport pytest\n\nfrom packaging import metadata, requirements, specifiers, utils, version\nfrom packaging.metadata import ExceptionGroup\n\n\nclass TestRawMetadata:\n    @pytest.mark.parametrize(\"raw_field\", metadata._STRING_FIELDS)\n    def test_non_repeating_fields_only_once(self, raw_field):\n        data = \"VaLuE\"\n        header_field = metadata._RAW_TO_EMAIL_MAPPING[raw_field]\n        single_header = f\"{header_field}: {data}\"\n        raw, unparsed = metadata.parse_email(single_header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert raw_field in raw\n        assert raw[raw_field] == data\n\n    @pytest.mark.parametrize(\"raw_field\", metadata._STRING_FIELDS)\n    def test_non_repeating_fields_repeated(self, raw_field):\n        header_field = metadata._RAW_TO_EMAIL_MAPPING[raw_field]\n        data = \"VaLuE\"\n        single_header = f\"{header_field}: {data}\"\n        repeated_header = \"\\n\".join([single_header] * 2)\n        raw, unparsed = metadata.parse_email(repeated_header)\n        assert not raw\n        assert len(unparsed) == 1\n        assert header_field in unparsed\n        assert unparsed[header_field] == [data] * 2\n\n    @pytest.mark.parametrize(\"raw_field\", metadata._LIST_FIELDS)\n    def test_repeating_fields_only_once(self, raw_field):\n        data = \"VaLuE\"\n        header_field = metadata._RAW_TO_EMAIL_MAPPING[raw_field]\n        single_header = f\"{header_field}: {data}\"\n        raw, unparsed = metadata.parse_email(single_header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert raw_field in raw\n        assert raw[raw_field] == [data]\n\n    @pytest.mark.parametrize(\"raw_field\", metadata._LIST_FIELDS)\n    def test_repeating_fields_repeated(self, raw_field):\n        header_field = metadata._RAW_TO_EMAIL_MAPPING[raw_field]\n        data = \"VaLuE\"\n        single_header = f\"{header_field}: {data}\"\n        repeated_header = \"\\n\".join([single_header] * 2)\n        raw, unparsed = metadata.parse_email(repeated_header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert raw_field in raw\n        assert raw[raw_field] == [data] * 2\n\n    @pytest.mark.parametrize(\n        [\"given\", \"expected\"],\n        [\n            (\"A\", [\"A\"]),\n            (\"A \", [\"A\"]),\n            (\" A\", [\"A\"]),\n            (\"A, B\", [\"A\", \"B\"]),\n            (\"A,B\", [\"A\", \"B\"]),\n            (\" A, B\", [\"A\", \"B\"]),\n            (\"A,B \", [\"A\", \"B\"]),\n            (\"A B\", [\"A B\"]),\n        ],\n    )\n    def test_keywords(self, given, expected):\n        header = f\"Keywords: {given}\"\n        raw, unparsed = metadata.parse_email(header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert \"keywords\" in raw\n        assert raw[\"keywords\"] == expected\n\n    @pytest.mark.parametrize(\n        [\"given\", \"expected\"],\n        [\n            (\"\", {\"\": \"\"}),\n            (\"A\", {\"A\": \"\"}),\n            (\"A,B\", {\"A\": \"B\"}),\n            (\"A, B\", {\"A\": \"B\"}),\n            (\" A,B\", {\"A\": \"B\"}),\n            (\"A,B \", {\"A\": \"B\"}),\n            (\"A,B,C\", {\"A\": \"B,C\"}),\n        ],\n    )\n    def test_project_urls_parsing(self, given, expected):\n        header = f\"project-url: {given}\"\n        raw, unparsed = metadata.parse_email(header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert \"project_urls\" in raw\n        assert raw[\"project_urls\"] == expected\n\n    def test_duplicate_project_urls(self):\n        header = \"project-url: A, B\\nproject-url: A, C\"\n        raw, unparsed = metadata.parse_email(header)\n        assert not raw\n        assert len(unparsed) == 1\n        assert \"project-url\" in unparsed\n        assert unparsed[\"project-url\"] == [\"A, B\", \"A, C\"]\n\n    def test_str_input(self):\n        name = \"Tarek Ziad\u00e9\"\n        header = f\"author: {name}\"\n        raw, unparsed = metadata.parse_email(header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert \"author\" in raw\n        assert raw[\"author\"] == name\n\n    def test_bytes_input(self):\n        name = \"Tarek Ziad\u00e9\"\n        header = f\"author: {name}\".encode()\n        raw, unparsed = metadata.parse_email(header)\n        assert not unparsed\n        assert len(raw) == 1\n        assert \"author\" in raw\n        assert raw[\"author\"] == name\n\n    def test_header_mojibake(self):\n        value = \"\\xc0msterdam\"\n        header_name = \"value\"\n        header_bytes = f\"{header_name}: {value}\".encode(\"latin1\")\n        raw, unparsed = metadata.parse_email(header_bytes)\n        # Sanity check\n        with pytest.raises(UnicodeDecodeError):\n            header_bytes.decode(\"utf-8\")\n        assert not raw\n        assert len(unparsed) == 1\n        assert header_name in unparsed\n        assert unparsed[header_name] == [value]\n\n    @pytest.mark.parametrize(\n        [\"given\"], [(\"hello\",), (\"description: hello\",), (b\"hello\",)]\n    )\n    def test_description(self, given):\n        raw, unparsed = metadata.parse_email(given)\n        assert not unparsed\n        assert len(raw) == 1\n        assert \"description\" in raw\n        assert raw[\"description\"] == \"hello\"\n\n    def test_description_non_utf8(self):\n        header = \"\\xc0msterdam\"\n        header_bytes = header.encode(\"latin1\")\n        raw, unparsed = metadata.parse_email(header_bytes)\n        assert not raw\n        assert len(unparsed) == 1\n        assert \"description\" in unparsed\n        assert unparsed[\"description\"] == [header_bytes]\n\n    @pytest.mark.parametrize(\n        [\"given\", \"expected\"],\n        [\n            (\"description: 1\\ndescription: 2\", [\"1\", \"2\"]),\n            (\"description: 1\\n\\n2\", [\"1\", \"2\"]),\n            (\"description: 1\\ndescription: 2\\n\\n3\", [\"1\", \"2\", \"3\"]),\n        ],\n    )\n    def test_description_multiple(self, given, expected):\n        raw, unparsed = metadata.parse_email(given)\n        assert not raw\n        assert len(unparsed) == 1\n        assert \"description\" in unparsed\n        assert unparsed[\"description\"] == expected\n\n    def test_lowercase_keys(self):\n        header = \"AUTHOR: Tarek Ziad\u00e9\\nWhatever: Else\"\n        raw, unparsed = metadata.parse_email(header)\n        assert len(raw) == 1\n        assert \"author\" in raw\n        assert len(unparsed) == 1\n        assert \"whatever\" in unparsed\n\n    def test_complete(self):\n        \"\"\"Test all fields (except `Obsoletes-Dist`).\n\n        `Obsoletes-Dist` was sacrificed to provide a value for `Dynamic`.\n        \"\"\"\n        path = pathlib.Path(__file__).parent / \"metadata\" / \"everything.metadata\"\n        with path.open(\"r\", encoding=\"utf-8\") as file:\n            metadata_contents = file.read()\n        raw, unparsed = metadata.parse_email(metadata_contents)\n        assert len(unparsed) == 1\n        assert unparsed[\"thisisnotreal\"] == [\"Hello!\"]\n        assert len(raw) == 24\n        assert raw[\"metadata_version\"] == \"2.3\"\n        assert raw[\"name\"] == \"BeagleVote\"\n        assert raw[\"version\"] == \"1.0a2\"\n        assert raw[\"platforms\"] == [\"ObscureUnix\", \"RareDOS\"]\n        assert raw[\"supported_platforms\"] == [\"RedHat 7.2\", \"i386-win32-2791\"]\n        assert raw[\"summary\"] == \"A module for collecting votes from beagles.\"\n        assert (\n            raw[\"description_content_type\"]\n            == \"text/markdown; charset=UTF-8; variant=GFM\"\n        )\n        assert raw[\"keywords\"] == [\"dog\", \"puppy\", \"voting\", \"election\"]\n        assert raw[\"home_page\"] == \"http://www.example.com/~cschultz/bvote/\"\n        assert raw[\"download_url\"] == \"\u2026/BeagleVote-0.45.tgz\"\n        assert raw[\"author\"] == (\n            \"C. Schultz, Universal Features Syndicate,\\n\"\n            \"        Los Angeles, CA <cschultz@peanuts.example.com>\"\n        )\n        assert raw[\"author_email\"] == '\"C. Schultz\" <cschultz@example.com>'\n        assert raw[\"maintainer\"] == (\n            \"C. Schultz, Universal Features Syndicate,\\n\"\n            \"        Los Angeles, CA <cschultz@peanuts.example.com>\"\n        )\n        assert raw[\"maintainer_email\"] == '\"C. Schultz\" <cschultz@example.com>'\n        assert raw[\"license\"] == (\n            \"This software may only be obtained by sending the\\n\"\n            \"        author a postcard, and then the user promises not\\n\"\n            \"        to redistribute it.\"\n        )\n        assert raw[\"classifiers\"] == [\n            \"Development Status :: 4 - Beta\",\n            \"Environment :: Console (Text Based)\",\n        ]\n        assert raw[\"provides_extra\"] == [\"pdf\"]\n        assert raw[\"requires_dist\"] == [\n            \"reportlab; extra == 'pdf'\",\n            \"pkginfo\",\n            \"PasteDeploy\",\n            \"zope.interface (>3.5.0)\",\n            \"pywin32 >1.0; sys_platform == 'win32'\",\n        ]\n        assert raw[\"requires_python\"] == \">=3\"\n        assert raw[\"requires_external\"] == [\n            \"C\",\n            \"libpng (>=1.5)\",\n            'make; sys_platform != \"win32\"',\n        ]\n        assert raw[\"project_urls\"] == {\n            \"Bug Tracker\": \"http://bitbucket.org/tarek/distribute/issues/\",\n            \"Documentation\": \"https://example.com/BeagleVote\",\n        }\n        assert raw[\"provides_dist\"] == [\n            \"OtherProject\",\n            \"AnotherProject (3.4)\",\n            'virtual_package; python_version >= \"3.4\"',\n        ]\n        assert raw[\"dynamic\"] == [\"Obsoletes-Dist\"]\n        assert raw[\"description\"] == \"This description intentionally left blank.\\n\"\n\n\nclass TestExceptionGroup:\n    def test_attributes(self):\n        individual_exception = Exception(\"not important\")\n        exc = metadata.ExceptionGroup(\"message\", [individual_exception])\n        assert exc.message == \"message\"\n        assert list(exc.exceptions) == [individual_exception]\n\n    def test_repr(self):\n        individual_exception = RuntimeError(\"not important\")\n        exc = metadata.ExceptionGroup(\"message\", [individual_exception])\n        assert individual_exception.__class__.__name__ in repr(exc)\n\n\n_RAW_EXAMPLE = {\n    \"metadata_version\": \"2.3\",\n    \"name\": \"packaging\",\n    \"version\": \"2023.0.0\",\n}\n\n\nclass TestMetadata:\n    def _invalid_with_cause(self, meta, attr, cause=None, *, field=None):\n        if field is None:\n            field = attr\n        with pytest.raises(metadata.InvalidMetadata) as exc_info:\n            getattr(meta, attr)\n        exc = exc_info.value\n        assert exc.field == field\n        if cause is None:\n            assert exc.__cause__ is None\n        else:\n            assert isinstance(exc.__cause__, cause)\n\n    def test_from_email(self):\n        metadata_version = \"2.3\"\n        meta = metadata.Metadata.from_email(\n            f\"Metadata-Version: {metadata_version}\", validate=False\n        )\n\n        assert meta.metadata_version == metadata_version\n\n    def test_from_email_unparsed(self):\n        with pytest.raises(ExceptionGroup) as exc_info:\n            metadata.Metadata.from_email(\"Hello: PyPA\")\n\n            assert len(exc_info.exceptions) == 1\n            assert isinstance(exc_info.exceptions[0], metadata.InvalidMetadata)\n\n    def test_from_email_validate(self):\n        with pytest.raises(ExceptionGroup):\n            # Lacking all required fields.\n            metadata.Metadata.from_email(\"Name: packaging\", validate=True)\n\n    def test_from_email_unparsed_valid_field_name(self):\n        with pytest.raises(ExceptionGroup):\n            metadata.Metadata.from_email(\n                \"Project-URL: A, B\\nProject-URL: A, C\", validate=True\n            )\n\n    def test_required_fields(self):\n        meta = metadata.Metadata.from_raw(_RAW_EXAMPLE)\n\n        assert meta.metadata_version == _RAW_EXAMPLE[\"metadata_version\"]\n\n    @pytest.mark.parametrize(\"field\", list(_RAW_EXAMPLE.keys()))\n    def test_required_fields_missing(self, field):\n        required_fields = _RAW_EXAMPLE.copy()\n\n        del required_fields[field]\n\n        with pytest.raises(ExceptionGroup):\n            metadata.Metadata.from_raw(required_fields)\n\n    def test_raw_validate_unrecognized_field(self):\n        raw = {\n            \"metadata_version\": \"2.3\",\n            \"name\": \"packaging\",\n            \"version\": \"2023.0.0\",\n        }\n\n        # Safety check.\n        assert metadata.Metadata.from_raw(raw, validate=True)\n\n        raw[\"dynamc\"] = [\"Obsoletes-Dist\"]  # Misspelled; missing an \"i\".\n\n        with pytest.raises(ExceptionGroup):\n            metadata.Metadata.from_raw(raw, validate=True)\n\n    def test_raw_data_not_mutated(self):\n        raw = _RAW_EXAMPLE.copy()\n        meta = metadata.Metadata.from_raw(raw, validate=True)\n\n        assert meta.version == version.Version(_RAW_EXAMPLE[\"version\"])\n        assert raw == _RAW_EXAMPLE\n\n    def test_caching(self):\n        meta = metadata.Metadata.from_raw(_RAW_EXAMPLE, validate=True)\n\n        assert meta.version is meta.version\n\n    def test_from_raw_validate(self):\n        required_fields = _RAW_EXAMPLE.copy()\n        required_fields[\"version\"] = \"-----\"\n\n        with pytest.raises(ExceptionGroup):\n            # Multiple things to trigger a validation error:\n            # invalid version, missing keys, etc.\n            metadata.Metadata.from_raw(required_fields)\n\n    @pytest.mark.parametrize(\"meta_version\", [\"2.2\", \"2.3\"])\n    def test_metadata_version_field_introduction(self, meta_version):\n        raw = {\n            \"metadata_version\": meta_version,\n            \"name\": \"packaging\",\n            \"version\": \"2023.0.0\",\n            \"dynamic\": [\"Obsoletes-Dist\"],  # Introduced in 2.2.\n        }\n\n        assert metadata.Metadata.from_raw(raw, validate=True)\n\n    @pytest.mark.parametrize(\"meta_version\", [\"1.0\", \"1.1\", \"1.2\", \"2.1\"])\n    def test_metadata_version_field_introduction_mismatch(self, meta_version):\n        raw = {\n            \"metadata_version\": meta_version,\n            \"name\": \"packaging\",\n            \"version\": \"2023.0.0\",\n            \"dynamic\": [\"Obsoletes-Dist\"],  # Introduced in 2.2.\n        }\n\n        with pytest.raises(ExceptionGroup):\n            metadata.Metadata.from_raw(raw, validate=True)\n\n    @pytest.mark.parametrize(\n        \"attribute\",\n        [\n            \"description\",\n            \"home_page\",\n            \"download_url\",\n            \"author\",\n            \"author_email\",\n            \"maintainer\",\n            \"maintainer_email\",\n            \"license\",\n        ],\n    )\n    def test_single_value_unvalidated_attribute(self, attribute):\n        value = \"Not important\"\n        meta = metadata.Metadata.from_raw({attribute: value}, validate=False)\n\n        assert getattr(meta, attribute) == value\n\n    @pytest.mark.parametrize(\n        \"attribute\",\n        [\n            \"supported_platforms\",\n            \"platforms\",\n            \"classifiers\",\n            \"provides_dist\",\n            \"obsoletes_dist\",\n            \"requires\",\n            \"provides\",\n            \"obsoletes\",\n        ],\n    )\n    def test_multi_value_unvalidated_attribute(self, attribute):\n        values = [\"Not important\", \"Still not important\"]\n        meta = metadata.Metadata.from_raw({attribute: values}, validate=False)\n\n        assert getattr(meta, attribute) == values\n\n    @pytest.mark.parametrize(\"version\", [\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\"])\n    def test_valid_metadata_version(self, version):\n        meta = metadata.Metadata.from_raw({\"metadata_version\": version}, validate=False)\n\n        assert meta.metadata_version == version\n\n    @pytest.mark.parametrize(\"version\", [\"1.3\", \"2.0\"])\n    def test_invalid_metadata_version(self, version):\n        meta = metadata.Metadata.from_raw({\"metadata_version\": version}, validate=False)\n\n        with pytest.raises(metadata.InvalidMetadata):\n            meta.metadata_version\n\n    def test_valid_version(self):\n        version_str = \"1.2.3\"\n        meta = metadata.Metadata.from_raw({\"version\": version_str}, validate=False)\n        assert meta.version == version.parse(version_str)\n\n    def test_missing_version(self):\n        meta = metadata.Metadata.from_raw({}, validate=False)\n        with pytest.raises(metadata.InvalidMetadata) as exc_info:\n            meta.version\n        assert exc_info.value.field == \"version\"\n\n    def test_invalid_version(self):\n        meta = metadata.Metadata.from_raw({\"version\": \"a.b.c\"}, validate=False)\n        self._invalid_with_cause(meta, \"version\", version.InvalidVersion)\n\n    def test_valid_summary(self):\n        summary = \"Hello\"\n        meta = metadata.Metadata.from_raw({\"summary\": summary}, validate=False)\n\n        assert meta.summary == summary\n\n    def test_invalid_summary(self):\n        meta = metadata.Metadata.from_raw(\n            {\"summary\": \"Hello\\n    Again\"}, validate=False\n        )\n\n        with pytest.raises(metadata.InvalidMetadata) as exc_info:\n            meta.summary\n        assert exc_info.value.field == \"summary\"\n\n    def test_valid_name(self):\n        name = \"Hello_World\"\n        meta = metadata.Metadata.from_raw({\"name\": name}, validate=False)\n        assert meta.name == name\n\n    def test_invalid_name(self):\n        meta = metadata.Metadata.from_raw({\"name\": \"-not-legal\"}, validate=False)\n        self._invalid_with_cause(meta, \"name\", utils.InvalidName)\n\n    @pytest.mark.parametrize(\n        \"content_type\",\n        [\n            \"text/plain\",\n            \"TEXT/PLAIN\",\n            \"text/x-rst\",\n            \"text/markdown\",\n            \"text/plain; charset=UTF-8\",\n            \"text/x-rst; charset=UTF-8\",\n            \"text/markdown; charset=UTF-8; variant=GFM\",\n            \"text/markdown; charset=UTF-8; variant=CommonMark\",\n            \"text/markdown; variant=GFM\",\n            \"text/markdown; variant=CommonMark\",\n        ],\n    )\n    def test_valid_description_content_type(self, content_type):\n        meta = metadata.Metadata.from_raw(\n            {\"description_content_type\": content_type}, validate=False\n        )\n\n        assert meta.description_content_type == content_type\n\n    @pytest.mark.parametrize(\n        \"content_type\",\n        [\n            \"application/json\",\n            \"text/plain; charset=ascii\",\n            \"text/plain; charset=utf-8\",\n            \"text/markdown; variant=gfm\",\n            \"text/markdown; variant=commonmark\",\n        ],\n    )\n    def test_invalid_description_content_type(self, content_type):\n        meta = metadata.Metadata.from_raw(\n            {\"description_content_type\": content_type}, validate=False\n        )\n\n        with pytest.raises(metadata.InvalidMetadata):\n            meta.description_content_type\n\n    def test_keywords(self):\n        keywords = [\"hello\", \"world\"]\n        meta = metadata.Metadata.from_raw({\"keywords\": keywords}, validate=False)\n\n        assert meta.keywords == keywords\n\n    def test_valid_project_urls(self):\n        urls = {\n            \"Documentation\": \"https://example.com/BeagleVote\",\n            \"Bug Tracker\": \"http://bitbucket.org/tarek/distribute/issues/\",\n        }\n        meta = metadata.Metadata.from_raw({\"project_urls\": urls}, validate=False)\n\n        assert meta.project_urls == urls\n\n    @pytest.mark.parametrize(\"specifier\", [\">=3\", \">2.6,!=3.0.*,!=3.1.*\", \"~=2.6\"])\n    def test_valid_requires_python(self, specifier):\n        expected = specifiers.SpecifierSet(specifier)\n        meta = metadata.Metadata.from_raw(\n            {\"requires_python\": specifier}, validate=False\n        )\n\n        assert meta.requires_python == expected\n\n    def test_invalid_requires_python(self):\n        meta = metadata.Metadata.from_raw(\n            {\"requires_python\": \"NotReal\"}, validate=False\n        )\n        self._invalid_with_cause(\n            meta,\n            \"requires_python\",\n            specifiers.InvalidSpecifier,\n            field=\"requires-python\",\n        )\n\n    def test_requires_external(self):\n        externals = [\n            \"C\",\n            \"libpng (>=1.5)\",\n            'make; sys_platform != \"win32\"',\n            \"libjpeg (>6b)\",\n        ]\n        meta = metadata.Metadata.from_raw(\n            {\"requires_external\": externals}, validate=False\n        )\n\n        assert meta.requires_external == externals\n\n    def test_valid_provides_extra(self):\n        extras = [\"dev\", \"test\"]\n        meta = metadata.Metadata.from_raw({\"provides_extra\": extras}, validate=False)\n\n        assert meta.provides_extra == extras\n\n    def test_invalid_provides_extra(self):\n        extras = [\"pdf\", \"-Not-Valid\", \"ok\"]\n        meta = metadata.Metadata.from_raw({\"provides_extra\": extras}, validate=False)\n        self._invalid_with_cause(\n            meta, \"provides_extra\", utils.InvalidName, field=\"provides-extra\"\n        )\n\n    def test_valid_requires_dist(self):\n        requires = [\n            \"pkginfo\",\n            \"PasteDeploy\",\n            \"zope.interface (>3.5.0)\",\n            \"pywin32 >1.0; sys_platform == 'win32'\",\n        ]\n        expected_requires = list(map(requirements.Requirement, requires))\n        meta = metadata.Metadata.from_raw({\"requires_dist\": requires}, validate=False)\n\n        assert meta.requires_dist == expected_requires\n\n    def test_invalid_requires_dist(self):\n        requires = [\"pkginfo\", \"-not-real\", \"zope.interface (>3.5.0)\"]\n        meta = metadata.Metadata.from_raw({\"requires_dist\": requires}, validate=False)\n        self._invalid_with_cause(\n            meta,\n            \"requires_dist\",\n            requirements.InvalidRequirement,\n            field=\"requires-dist\",\n        )\n\n    def test_valid_dynamic(self):\n        dynamic = [\"Keywords\", \"Home-Page\", \"Author\"]\n        meta = metadata.Metadata.from_raw({\"dynamic\": dynamic}, validate=False)\n\n        assert meta.dynamic == [d.lower() for d in dynamic]\n\n    def test_invalid_dynamic_value(self):\n        dynamic = [\"Keywords\", \"NotReal\", \"Author\"]\n        meta = metadata.Metadata.from_raw({\"dynamic\": dynamic}, validate=False)\n\n        with pytest.raises(metadata.InvalidMetadata):\n            meta.dynamic\n\n    @pytest.mark.parametrize(\"field_name\", [\"name\", \"version\", \"metadata-version\"])\n    def test_disallowed_dynamic(self, field_name):\n        meta = metadata.Metadata.from_raw({\"dynamic\": [field_name]}, validate=False)\n\n        with pytest.raises(metadata.InvalidMetadata):\n            meta.dynamic\n\n    @pytest.mark.parametrize(\n        \"field_name\",\n        sorted(metadata._RAW_TO_EMAIL_MAPPING.keys() - metadata._REQUIRED_ATTRS),\n    )\n    def test_optional_defaults_to_none(self, field_name):\n        meta = metadata.Metadata.from_raw({}, validate=False)\n        assert getattr(meta, field_name) is None\n", "tests/test_elffile.py": "import io\nimport pathlib\nimport struct\n\nimport pytest\n\nfrom packaging._elffile import EIClass, EIData, ELFFile, ELFInvalid, EMachine\n\nDIR_MANYLINUX = pathlib.Path(__file__, \"..\", \"manylinux\").resolve()\nDIR_MUSLLINUX = pathlib.Path(__file__, \"..\", \"musllinux\").resolve()\nBIN_MUSL_X86_64 = DIR_MUSLLINUX.joinpath(\"musl-x86_64\").read_bytes()\n\n\n@pytest.mark.parametrize(\n    \"name, capacity, encoding, machine\",\n    [\n        (\"x86_64-x32\", EIClass.C32, EIData.Lsb, EMachine.X8664),\n        (\"x86_64-i386\", EIClass.C32, EIData.Lsb, EMachine.I386),\n        (\"x86_64-amd64\", EIClass.C64, EIData.Lsb, EMachine.X8664),\n        (\"armv7l-armel\", EIClass.C32, EIData.Lsb, EMachine.Arm),\n        (\"armv7l-armhf\", EIClass.C32, EIData.Lsb, EMachine.Arm),\n        (\"s390x-s390x\", EIClass.C64, EIData.Msb, EMachine.S390),\n    ],\n)\ndef test_elffile_glibc(name, capacity, encoding, machine):\n    path = DIR_MANYLINUX.joinpath(f\"hello-world-{name}\")\n    with path.open(\"rb\") as f:\n        ef = ELFFile(f)\n        assert ef.capacity == capacity\n        assert ef.encoding == encoding\n        assert ef.machine == machine\n        assert ef.flags is not None\n\n\n@pytest.mark.parametrize(\n    \"name, capacity, encoding, machine, interpreter\",\n    [\n        (\n            \"aarch64\",\n            EIClass.C64,\n            EIData.Lsb,\n            EMachine.AArc64,\n            \"aarch64\",\n        ),\n        (\"i386\", EIClass.C32, EIData.Lsb, EMachine.I386, \"i386\"),\n        (\"x86_64\", EIClass.C64, EIData.Lsb, EMachine.X8664, \"x86_64\"),\n    ],\n)\ndef test_elffile_musl(name, capacity, encoding, machine, interpreter):\n    path = DIR_MUSLLINUX.joinpath(f\"musl-{name}\")\n    with path.open(\"rb\") as f:\n        ef = ELFFile(f)\n        assert ef.capacity == capacity\n        assert ef.encoding == encoding\n        assert ef.machine == machine\n        assert ef.interpreter == f\"/lib/ld-musl-{interpreter}.so.1\"\n\n\n@pytest.mark.parametrize(\n    \"data\",\n    [\n        # Too short for magic.\n        b\"\\0\",\n        # Enough for magic, but not ELF.\n        b\"#!/bin/bash\" + b\"\\0\" * 16,\n        # ELF, but unknown byte declaration.\n        b\"\\x7fELF\\3\" + b\"\\0\" * 16,\n    ],\n    ids=[\"no-magic\", \"wrong-magic\", \"unknown-format\"],\n)\ndef test_elffile_bad_ident(data):\n    with pytest.raises(ELFInvalid):\n        ELFFile(io.BytesIO(data))\n\n\ndef test_elffile_no_section():\n    \"\"\"Enough for magic, but not the section definitions.\"\"\"\n    data = BIN_MUSL_X86_64[:25]\n    with pytest.raises(ELFInvalid):\n        ELFFile(io.BytesIO(data))\n\n\ndef test_elffile_invalid_section():\n    \"\"\"Enough for section definitions, but not the actual sections.\"\"\"\n    data = BIN_MUSL_X86_64[:58]\n    assert ELFFile(io.BytesIO(data)).interpreter is None\n\n\ndef test_elffle_no_interpreter_section():\n    ef = ELFFile(io.BytesIO(BIN_MUSL_X86_64))\n\n    # Change all sections to *not* PT_INTERP.\n    data = BIN_MUSL_X86_64\n    for i in range(ef._e_phnum + 1):\n        sb = ef._e_phoff + ef._e_phentsize * i\n        se = sb + ef._e_phentsize\n        section = struct.unpack(ef._p_fmt, data[sb:se])\n        data = data[:sb] + struct.pack(ef._p_fmt, 0, *section[1:]) + data[se:]\n\n    assert ELFFile(io.BytesIO(data)).interpreter is None\n", "tests/test_tags.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport collections.abc\nimport subprocess\n\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\nimport importlib\nimport os\nimport pathlib\nimport platform\nimport struct\nimport sys\nimport sysconfig\nimport types\n\nimport pretend\nimport pytest\n\nfrom packaging import tags\nfrom packaging._manylinux import _GLibCVersion\nfrom packaging._musllinux import _MuslVersion\n\n\n@pytest.fixture\ndef example_tag():\n    return tags.Tag(\"py3\", \"none\", \"any\")\n\n\n@pytest.fixture\ndef manylinux_module(monkeypatch):\n    monkeypatch.setattr(tags._manylinux, \"_get_glibc_version\", lambda *args: (2, 20))\n    module_name = \"_manylinux\"\n    module = types.ModuleType(module_name)\n    monkeypatch.setitem(sys.modules, module_name, module)\n    return module\n\n\n@pytest.fixture\ndef mock_interpreter_name(monkeypatch):\n    def mock(name):\n        name = name.lower()\n        if sys.implementation.name != name:\n            monkeypatch.setattr(sys.implementation, \"name\", name)\n            return True\n        return False\n\n    return mock\n\n\nclass TestTag:\n    def test_lowercasing(self):\n        tag = tags.Tag(\"PY3\", \"None\", \"ANY\")\n        assert tag.interpreter == \"py3\"\n        assert tag.abi == \"none\"\n        assert tag.platform == \"any\"\n\n    def test_equality(self):\n        args = \"py3\", \"none\", \"any\"\n        assert tags.Tag(*args) == tags.Tag(*args)\n\n    def test_equality_fails_with_non_tag(self):\n        assert not tags.Tag(\"py3\", \"none\", \"any\") == \"non-tag\"\n\n    def test_hashing(self, example_tag):\n        tags = {example_tag}  # Should not raise TypeError.\n        assert example_tag in tags\n\n    def test_hash_equality(self, example_tag):\n        equal_tag = tags.Tag(\"py3\", \"none\", \"any\")\n        assert example_tag == equal_tag  # Sanity check.\n        assert example_tag.__hash__() == equal_tag.__hash__()\n\n    def test_str(self, example_tag):\n        assert str(example_tag) == \"py3-none-any\"\n\n    def test_repr(self, example_tag):\n        assert repr(example_tag) == \"<py3-none-any @ {tag_id}>\".format(\n            tag_id=id(example_tag)\n        )\n\n    def test_attribute_access(self, example_tag):\n        assert example_tag.interpreter == \"py3\"\n        assert example_tag.abi == \"none\"\n        assert example_tag.platform == \"any\"\n\n\nclass TestParseTag:\n    def test_simple(self, example_tag):\n        parsed_tags = tags.parse_tag(str(example_tag))\n        assert parsed_tags == {example_tag}\n\n    def test_multi_interpreter(self, example_tag):\n        expected = {example_tag, tags.Tag(\"py2\", \"none\", \"any\")}\n        given = tags.parse_tag(\"py2.py3-none-any\")\n        assert given == expected\n\n    def test_multi_platform(self):\n        expected = {\n            tags.Tag(\"cp37\", \"cp37m\", platform)\n            for platform in (\n                \"macosx_10_6_intel\",\n                \"macosx_10_9_intel\",\n                \"macosx_10_9_x86_64\",\n                \"macosx_10_10_intel\",\n                \"macosx_10_10_x86_64\",\n            )\n        }\n        given = tags.parse_tag(\n            \"cp37-cp37m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.\"\n            \"macosx_10_10_intel.macosx_10_10_x86_64\"\n        )\n        assert given == expected\n\n\nclass TestInterpreterName:\n    def test_sys_implementation_name(self, monkeypatch):\n        class MockImplementation:\n            pass\n\n        mock_implementation = MockImplementation()\n        mock_implementation.name = \"sillywalk\"\n        monkeypatch.setattr(sys, \"implementation\", mock_implementation, raising=False)\n        assert tags.interpreter_name() == \"sillywalk\"\n\n    def test_interpreter_short_names(self, mock_interpreter_name, monkeypatch):\n        mock_interpreter_name(\"cpython\")\n        assert tags.interpreter_name() == \"cp\"\n\n\nclass TestInterpreterVersion:\n    def test_warn(self, monkeypatch):\n        class MockConfigVar:\n            def __init__(self, return_):\n                self.warn = None\n                self._return = return_\n\n            def __call__(self, name, warn):\n                self.warn = warn\n                return self._return\n\n        mock_config_var = MockConfigVar(\"38\")\n        monkeypatch.setattr(tags, \"_get_config_var\", mock_config_var)\n        tags.interpreter_version(warn=True)\n        assert mock_config_var.warn\n\n    def test_python_version_nodot(self, monkeypatch):\n        monkeypatch.setattr(tags, \"_get_config_var\", lambda var, warn: \"NN\")\n        assert tags.interpreter_version() == \"NN\"\n\n    @pytest.mark.parametrize(\n        \"version_info,version_str\",\n        [\n            ((1, 2, 3), \"12\"),\n            ((1, 12, 3), \"112\"),\n            ((11, 2, 3), \"112\"),\n            ((11, 12, 3), \"1112\"),\n            ((1, 2, 13), \"12\"),\n        ],\n    )\n    def test_sys_version_info(self, version_info, version_str, monkeypatch):\n        monkeypatch.setattr(tags, \"_get_config_var\", lambda *args, **kwargs: None)\n        monkeypatch.setattr(sys, \"version_info\", version_info)\n        assert tags.interpreter_version() == version_str\n\n\nclass TestMacOSPlatforms:\n    @pytest.mark.parametrize(\n        \"arch, is_32bit, expected\",\n        [\n            (\"i386\", True, \"i386\"),\n            (\"ppc\", True, \"ppc\"),\n            (\"x86_64\", False, \"x86_64\"),\n            (\"x86_64\", True, \"i386\"),\n            (\"ppc64\", False, \"ppc64\"),\n            (\"ppc64\", True, \"ppc\"),\n        ],\n    )\n    def test_architectures(self, arch, is_32bit, expected):\n        assert tags._mac_arch(arch, is_32bit=is_32bit) == expected\n\n    @pytest.mark.parametrize(\n        \"version,arch,expected\",\n        [\n            (\n                (10, 15),\n                \"x86_64\",\n                [\"x86_64\", \"intel\", \"fat64\", \"fat32\", \"universal2\", \"universal\"],\n            ),\n            (\n                (10, 4),\n                \"x86_64\",\n                [\"x86_64\", \"intel\", \"fat64\", \"fat32\", \"universal2\", \"universal\"],\n            ),\n            ((10, 3), \"x86_64\", []),\n            ((10, 15), \"i386\", [\"i386\", \"intel\", \"fat32\", \"fat\", \"universal\"]),\n            ((10, 4), \"i386\", [\"i386\", \"intel\", \"fat32\", \"fat\", \"universal\"]),\n            ((10, 3), \"intel\", [\"intel\", \"universal\"]),\n            ((10, 5), \"intel\", [\"intel\", \"universal\"]),\n            ((10, 15), \"intel\", [\"intel\", \"universal\"]),\n            ((10, 3), \"i386\", []),\n            ((10, 15), \"ppc64\", []),\n            ((10, 6), \"ppc64\", []),\n            ((10, 5), \"ppc64\", [\"ppc64\", \"fat64\", \"universal\"]),\n            ((10, 3), \"ppc64\", []),\n            ((10, 15), \"ppc\", []),\n            ((10, 7), \"ppc\", []),\n            ((10, 6), \"ppc\", [\"ppc\", \"fat32\", \"fat\", \"universal\"]),\n            ((10, 0), \"ppc\", [\"ppc\", \"fat32\", \"fat\", \"universal\"]),\n            ((11, 0), \"riscv\", [\"riscv\"]),\n            (\n                (11, 0),\n                \"x86_64\",\n                [\"x86_64\", \"intel\", \"fat64\", \"fat32\", \"universal2\", \"universal\"],\n            ),\n            ((11, 0), \"arm64\", [\"arm64\", \"universal2\"]),\n            ((11, 1), \"arm64\", [\"arm64\", \"universal2\"]),\n            ((12, 0), \"arm64\", [\"arm64\", \"universal2\"]),\n        ],\n    )\n    def test_binary_formats(self, version, arch, expected):\n        assert tags._mac_binary_formats(version, arch) == expected\n\n    def test_version_detection(self, monkeypatch):\n        if platform.system() != \"Darwin\":\n            monkeypatch.setattr(\n                platform, \"mac_ver\", lambda: (\"10.14\", (\"\", \"\", \"\"), \"x86_64\")\n            )\n        version = platform.mac_ver()[0].split(\".\")\n        major = version[0]\n        minor = version[1] if major == \"10\" else \"0\"\n\n        platforms = list(tags.mac_platforms(arch=\"x86_64\"))\n        if (major, minor) == (\"10\", \"16\"):\n            # For 10.16, the real version is at least 11.0.\n            prefix, major, minor, _ = platforms[0].split(\"_\", maxsplit=3)\n            assert prefix == \"macosx\"\n            assert int(major) >= 11\n            assert minor == \"0\"\n        else:\n            expected = f\"macosx_{major}_{minor}_\"\n            assert platforms[0].startswith(expected)\n\n    def test_version_detection_10_15(self, monkeypatch):\n        monkeypatch.setattr(\n            platform, \"mac_ver\", lambda: (\"10.15\", (\"\", \"\", \"\"), \"x86_64\")\n        )\n        expected = \"macosx_10_15_\"\n\n        platforms = list(tags.mac_platforms(arch=\"x86_64\"))\n        assert platforms[0].startswith(expected)\n\n    def test_version_detection_compatibility(self, monkeypatch):\n        if platform.system() != \"Darwin\":\n            monkeypatch.setattr(\n                subprocess,\n                \"run\",\n                lambda *args, **kwargs: subprocess.CompletedProcess(\n                    [], 0, stdout=\"10.15\"\n                ),\n            )\n        monkeypatch.setattr(\n            platform, \"mac_ver\", lambda: (\"10.16\", (\"\", \"\", \"\"), \"x86_64\")\n        )\n        unexpected = \"macosx_10_16_\"\n\n        platforms = list(tags.mac_platforms(arch=\"x86_64\"))\n        assert not platforms[0].startswith(unexpected)\n\n    @pytest.mark.parametrize(\"arch\", [\"x86_64\", \"i386\"])\n    def test_arch_detection(self, arch, monkeypatch):\n        if platform.system() != \"Darwin\" or platform.mac_ver()[2] != arch:\n            monkeypatch.setattr(\n                platform, \"mac_ver\", lambda: (\"10.14\", (\"\", \"\", \"\"), arch)\n            )\n            monkeypatch.setattr(tags, \"_mac_arch\", lambda *args: arch)\n        assert next(tags.mac_platforms((10, 14))).endswith(arch)\n\n    def test_mac_platforms(self):\n        platforms = list(tags.mac_platforms((10, 5), \"x86_64\"))\n        assert platforms == [\n            \"macosx_10_5_x86_64\",\n            \"macosx_10_5_intel\",\n            \"macosx_10_5_fat64\",\n            \"macosx_10_5_fat32\",\n            \"macosx_10_5_universal2\",\n            \"macosx_10_5_universal\",\n            \"macosx_10_4_x86_64\",\n            \"macosx_10_4_intel\",\n            \"macosx_10_4_fat64\",\n            \"macosx_10_4_fat32\",\n            \"macosx_10_4_universal2\",\n            \"macosx_10_4_universal\",\n        ]\n\n        assert len(list(tags.mac_platforms((10, 17), \"x86_64\"))) == 14 * 6\n\n        assert not list(tags.mac_platforms((10, 0), \"x86_64\"))\n\n    @pytest.mark.parametrize(\"major,minor\", [(11, 0), (11, 3), (12, 0), (12, 3)])\n    def test_macos_11(self, major, minor):\n        platforms = list(tags.mac_platforms((major, minor), \"x86_64\"))\n        assert \"macosx_11_0_arm64\" not in platforms\n        assert \"macosx_11_0_x86_64\" in platforms\n        assert \"macosx_11_3_x86_64\" not in platforms\n        assert \"macosx_11_0_universal\" in platforms\n        assert \"macosx_11_0_universal2\" in platforms\n        # Mac OS \"10.16\" is the version number that binaries compiled against an old\n        # (pre 11.0) SDK will see.   It can also be enabled explicitly for a process\n        # with the environment variable SYSTEM_VERSION_COMPAT=1.\n        assert \"macosx_10_16_x86_64\" in platforms\n        assert \"macosx_10_15_x86_64\" in platforms\n        assert \"macosx_10_15_universal2\" in platforms\n        assert \"macosx_10_4_x86_64\" in platforms\n        assert \"macosx_10_3_x86_64\" not in platforms\n        if major >= 12:\n            assert \"macosx_12_0_x86_64\" in platforms\n            assert \"macosx_12_0_universal\" in platforms\n            assert \"macosx_12_0_universal2\" in platforms\n\n        platforms = list(tags.mac_platforms((major, minor), \"arm64\"))\n        assert \"macosx_11_0_arm64\" in platforms\n        assert \"macosx_11_3_arm64\" not in platforms\n        assert \"macosx_11_0_universal\" not in platforms\n        assert \"macosx_11_0_universal2\" in platforms\n        assert \"macosx_10_15_universal2\" in platforms\n        assert \"macosx_10_15_x86_64\" not in platforms\n        assert \"macosx_10_4_x86_64\" not in platforms\n        assert \"macosx_10_3_x86_64\" not in platforms\n        if major >= 12:\n            assert \"macosx_12_0_arm64\" in platforms\n            assert \"macosx_12_0_universal2\" in platforms\n\n\nclass TestManylinuxPlatform:\n    def teardown_method(self):\n        # Clear the version cache\n        tags._manylinux._get_glibc_version.cache_clear()\n\n    def test_get_config_var_does_not_log(self, monkeypatch):\n        debug = pretend.call_recorder(lambda *a: None)\n        monkeypatch.setattr(tags.logger, \"debug\", debug)\n        tags._get_config_var(\"missing\")\n        assert debug.calls == []\n\n    def test_get_config_var_does_log(self, monkeypatch):\n        debug = pretend.call_recorder(lambda *a: None)\n        monkeypatch.setattr(tags.logger, \"debug\", debug)\n        tags._get_config_var(\"missing\", warn=True)\n        assert debug.calls == [\n            pretend.call(\n                \"Config variable '%s' is unset, Python ABI tag may be incorrect\",\n                \"missing\",\n            )\n        ]\n\n    @pytest.mark.parametrize(\n        \"arch,is_32bit,expected\",\n        [\n            (\"linux-x86_64\", False, [\"linux_x86_64\"]),\n            (\"linux-x86_64\", True, [\"linux_i686\"]),\n            (\"linux-aarch64\", False, [\"linux_aarch64\"]),\n            (\"linux-aarch64\", True, [\"linux_armv8l\", \"linux_armv7l\"]),\n        ],\n    )\n    def test_linux_platforms_32_64bit_on_64bit_os(\n        self, arch, is_32bit, expected, monkeypatch\n    ):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: arch)\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.20\", raising=False)\n        monkeypatch.setattr(tags._manylinux, \"_is_compatible\", lambda *args: False)\n        linux_platform = list(tags._linux_platforms(is_32bit=is_32bit))[\n            -len(expected) :\n        ]\n        assert linux_platform == expected\n\n    def test_linux_platforms_manylinux_unsupported(self, monkeypatch):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_x86_64\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.20\", raising=False)\n        monkeypatch.setattr(tags._manylinux, \"_is_compatible\", lambda *args: False)\n        linux_platform = list(tags._linux_platforms(is_32bit=False))\n        assert linux_platform == [\"linux_x86_64\"]\n\n    def test_linux_platforms_manylinux1(self, monkeypatch):\n        monkeypatch.setattr(\n            tags._manylinux,\n            \"_is_compatible\",\n            lambda _, glibc_version: glibc_version == _GLibCVersion(2, 5),\n        )\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_x86_64\")\n        monkeypatch.setattr(platform, \"machine\", lambda: \"x86_64\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.20\", raising=False)\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        assert platforms == [\n            \"manylinux_2_5_x86_64\",\n            \"manylinux1_x86_64\",\n            \"linux_x86_64\",\n        ]\n\n    def test_linux_platforms_manylinux2010(self, monkeypatch):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_x86_64\")\n        monkeypatch.setattr(platform, \"machine\", lambda: \"x86_64\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.12\", raising=False)\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        expected = [\n            \"manylinux_2_12_x86_64\",\n            \"manylinux2010_x86_64\",\n            \"manylinux_2_11_x86_64\",\n            \"manylinux_2_10_x86_64\",\n            \"manylinux_2_9_x86_64\",\n            \"manylinux_2_8_x86_64\",\n            \"manylinux_2_7_x86_64\",\n            \"manylinux_2_6_x86_64\",\n            \"manylinux_2_5_x86_64\",\n            \"manylinux1_x86_64\",\n            \"linux_x86_64\",\n        ]\n        assert platforms == expected\n\n    def test_linux_platforms_manylinux2014(self, monkeypatch):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_x86_64\")\n        monkeypatch.setattr(platform, \"machine\", lambda: \"x86_64\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.17\", raising=False)\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        arch = platform.machine()\n        expected = [\n            \"manylinux_2_17_\" + arch,\n            \"manylinux2014_\" + arch,\n            \"manylinux_2_16_\" + arch,\n            \"manylinux_2_15_\" + arch,\n            \"manylinux_2_14_\" + arch,\n            \"manylinux_2_13_\" + arch,\n            \"manylinux_2_12_\" + arch,\n            \"manylinux2010_\" + arch,\n            \"manylinux_2_11_\" + arch,\n            \"manylinux_2_10_\" + arch,\n            \"manylinux_2_9_\" + arch,\n            \"manylinux_2_8_\" + arch,\n            \"manylinux_2_7_\" + arch,\n            \"manylinux_2_6_\" + arch,\n            \"manylinux_2_5_\" + arch,\n            \"manylinux1_\" + arch,\n            \"linux_\" + arch,\n        ]\n        assert platforms == expected\n\n    @pytest.mark.parametrize(\n        \"native_arch, cross_arch\",\n        [(\"armv7l\", \"armv7l\"), (\"armv8l\", \"armv8l\"), (\"aarch64\", \"armv8l\")],\n    )\n    def test_linux_platforms_manylinux2014_armhf_abi(\n        self, native_arch, cross_arch, monkeypatch\n    ):\n        monkeypatch.setattr(tags._manylinux, \"_glibc_version_string\", lambda: \"2.30\")\n        monkeypatch.setattr(\n            tags._manylinux,\n            \"_is_compatible\",\n            lambda _, glibc_version: glibc_version == _GLibCVersion(2, 17),\n        )\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: f\"linux_{native_arch}\")\n        monkeypatch.setattr(\n            sys,\n            \"executable\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"manylinux\",\n                \"hello-world-armv7l-armhf\",\n            ),\n        )\n        platforms = list(tags._linux_platforms(is_32bit=True))\n        archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(cross_arch, [cross_arch])\n        expected = []\n        for arch in archs:\n            expected.extend([f\"manylinux_2_17_{arch}\", f\"manylinux2014_{arch}\"])\n        expected.extend(f\"linux_{arch}\" for arch in archs)\n        assert platforms == expected\n\n    def test_linux_platforms_manylinux2014_i386_abi(self, monkeypatch):\n        monkeypatch.setattr(tags._manylinux, \"_glibc_version_string\", lambda: \"2.17\")\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_x86_64\")\n        monkeypatch.setattr(\n            sys,\n            \"executable\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"manylinux\",\n                \"hello-world-x86_64-i386\",\n            ),\n        )\n        platforms = list(tags._linux_platforms(is_32bit=True))\n        expected = [\n            \"manylinux_2_17_i686\",\n            \"manylinux2014_i686\",\n            \"manylinux_2_16_i686\",\n            \"manylinux_2_15_i686\",\n            \"manylinux_2_14_i686\",\n            \"manylinux_2_13_i686\",\n            \"manylinux_2_12_i686\",\n            \"manylinux2010_i686\",\n            \"manylinux_2_11_i686\",\n            \"manylinux_2_10_i686\",\n            \"manylinux_2_9_i686\",\n            \"manylinux_2_8_i686\",\n            \"manylinux_2_7_i686\",\n            \"manylinux_2_6_i686\",\n            \"manylinux_2_5_i686\",\n            \"manylinux1_i686\",\n            \"linux_i686\",\n        ]\n        assert platforms == expected\n\n    def test_linux_platforms_manylinux_glibc3(self, monkeypatch):\n        # test for a future glic 3.x version\n        monkeypatch.setattr(tags._manylinux, \"_glibc_version_string\", lambda: \"3.2\")\n        monkeypatch.setattr(tags._manylinux, \"_is_compatible\", lambda *args: True)\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_aarch64\")\n        monkeypatch.setattr(\n            sys,\n            \"executable\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"manylinux\",\n                \"hello-world-aarch64\",\n            ),\n        )\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        expected = (\n            [\"manylinux_3_2_aarch64\", \"manylinux_3_1_aarch64\", \"manylinux_3_0_aarch64\"]\n            + [f\"manylinux_2_{i}_aarch64\" for i in range(50, 16, -1)]\n            + [\"manylinux2014_aarch64\", \"linux_aarch64\"]\n        )\n        assert platforms == expected\n\n    @pytest.mark.parametrize(\n        \"native_arch, cross32_arch, musl_version\",\n        [\n            (\"armv7l\", \"armv7l\", _MuslVersion(1, 1)),\n            (\"aarch64\", \"armv8l\", _MuslVersion(1, 1)),\n            (\"i386\", \"i386\", _MuslVersion(1, 2)),\n            (\"x86_64\", \"i686\", _MuslVersion(1, 2)),\n        ],\n    )\n    @pytest.mark.parametrize(\"cross32\", [True, False], ids=[\"cross\", \"native\"])\n    def test_linux_platforms_musllinux(\n        self, monkeypatch, native_arch, cross32_arch, musl_version, cross32\n    ):\n        fake_executable = str(\n            pathlib.Path(__file__)\n            .parent.joinpath(\"musllinux\", f\"musl-{native_arch}\")\n            .resolve()\n        )\n        monkeypatch.setattr(tags._musllinux.sys, \"executable\", fake_executable)\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: f\"linux_{native_arch}\")\n        monkeypatch.setattr(tags._manylinux, \"platform_tags\", lambda *_: ())\n\n        recorder = pretend.call_recorder(lambda _: musl_version)\n        monkeypatch.setattr(tags._musllinux, \"_get_musl_version\", recorder)\n\n        platforms = list(tags._linux_platforms(is_32bit=cross32))\n        target_arch = cross32_arch if cross32 else native_arch\n        archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(target_arch, [target_arch])\n        expected = []\n        for arch in archs:\n            expected.extend(\n                f\"musllinux_{musl_version[0]}_{minor}_{arch}\"\n                for minor in range(musl_version[1], -1, -1)\n            )\n        expected.extend(f\"linux_{arch}\" for arch in archs)\n        assert platforms == expected\n\n        assert recorder.calls == [pretend.call(fake_executable)]\n\n    def test_linux_platforms_manylinux2014_armv6l(self, monkeypatch):\n        monkeypatch.setattr(\n            tags._manylinux,\n            \"_is_compatible\",\n            lambda _, glibc_version: glibc_version == _GLibCVersion(2, 17),\n        )\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_armv6l\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.20\", raising=False)\n        platforms = list(tags._linux_platforms(is_32bit=True))\n        expected = [\"linux_armv6l\"]\n        assert platforms == expected\n\n    @pytest.mark.parametrize(\n        \"machine, abi, alt_machine\",\n        [(\"x86_64\", \"x32\", \"i686\"), (\"armv7l\", \"armel\", \"armv7l\")],\n    )\n    def test_linux_platforms_not_manylinux_abi(\n        self, monkeypatch, machine, abi, alt_machine\n    ):\n        monkeypatch.setattr(tags._manylinux, \"_is_compatible\", lambda *args: False)\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: f\"linux_{machine}\")\n        monkeypatch.setattr(\n            sys,\n            \"executable\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"manylinux\",\n                f\"hello-world-{machine}-{abi}\",\n            ),\n        )\n        platforms = list(tags._linux_platforms(is_32bit=True))\n        expected = [f\"linux_{alt_machine}\"]\n        assert platforms == expected\n\n    def test_linux_not_linux(self, monkeypatch):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"not_linux_x86_64\")\n        monkeypatch.setattr(platform, \"machine\", lambda: \"x86_64\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.17\", raising=False)\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        assert platforms == [\"not_linux_x86_64\"]\n\n\n@pytest.mark.parametrize(\n    \"platform_name,dispatch_func\",\n    [\n        (\"Darwin\", \"mac_platforms\"),\n        (\"Linux\", \"_linux_platforms\"),\n        (\"Generic\", \"_generic_platforms\"),\n    ],\n)\ndef test_platform_tags(platform_name, dispatch_func, monkeypatch):\n    expected = [\"sillywalk\"]\n    monkeypatch.setattr(platform, \"system\", lambda: platform_name)\n    monkeypatch.setattr(tags, dispatch_func, lambda: expected)\n    assert tags.platform_tags() == expected\n\n\ndef test_platform_tags_space(monkeypatch):\n    \"\"\"Ensure spaces in platform tags are normalized to underscores.\"\"\"\n    monkeypatch.setattr(platform, \"system\", lambda: \"Isilon OneFS\")\n    monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"isilon onefs\")\n    assert list(tags.platform_tags()) == [\"isilon_onefs\"]\n\n\nclass TestCPythonABI:\n    @pytest.mark.parametrize(\n        \"py_debug,gettotalrefcount,result\",\n        [(1, False, True), (0, False, False), (None, True, True)],\n    )\n    def test_debug(self, py_debug, gettotalrefcount, result, monkeypatch):\n        config = {\"Py_DEBUG\": py_debug, \"WITH_PYMALLOC\": 0, \"Py_UNICODE_SIZE\": 2}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        if gettotalrefcount:\n            monkeypatch.setattr(sys, \"gettotalrefcount\", 1, raising=False)\n        expected = [\"cp37d\" if result else \"cp37\"]\n        assert tags._cpython_abis((3, 7)) == expected\n\n    def test_debug_file_extension(self, monkeypatch):\n        config = {\"Py_DEBUG\": None}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        monkeypatch.delattr(sys, \"gettotalrefcount\", raising=False)\n        monkeypatch.setattr(tags, \"EXTENSION_SUFFIXES\", {\"_d.pyd\"})\n        assert tags._cpython_abis((3, 8)) == [\"cp38d\", \"cp38\"]\n\n    @pytest.mark.parametrize(\n        \"debug,expected\", [(True, [\"cp38d\", \"cp38\"]), (False, [\"cp38\"])]\n    )\n    def test__debug_cp38(self, debug, expected, monkeypatch):\n        config = {\"Py_DEBUG\": debug}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._cpython_abis((3, 8)) == expected\n\n    @pytest.mark.parametrize(\n        \"pymalloc,version,result\",\n        [\n            (1, (3, 7), True),\n            (0, (3, 7), False),\n            (None, (3, 7), True),\n            (1, (3, 8), False),\n        ],\n    )\n    def test_pymalloc(self, pymalloc, version, result, monkeypatch):\n        config = {\"Py_DEBUG\": 0, \"WITH_PYMALLOC\": pymalloc, \"Py_UNICODE_SIZE\": 2}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        base_abi = f\"cp{version[0]}{version[1]}\"\n        expected = [base_abi + \"m\" if result else base_abi]\n        assert tags._cpython_abis(version) == expected\n\n    @pytest.mark.parametrize(\n        \"unicode_size,maxunicode,version,result\",\n        [\n            (4, 0x10FFFF, (3, 2), True),\n            (2, 0xFFFF, (3, 2), False),\n            (None, 0x10FFFF, (3, 2), True),\n            (None, 0xFFFF, (3, 2), False),\n            (4, 0x10FFFF, (3, 3), False),\n        ],\n    )\n    def test_wide_unicode(self, unicode_size, maxunicode, version, result, monkeypatch):\n        config = {\"Py_DEBUG\": 0, \"WITH_PYMALLOC\": 0, \"Py_UNICODE_SIZE\": unicode_size}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        monkeypatch.setattr(sys, \"maxunicode\", maxunicode)\n        base_abi = \"cp\" + tags._version_nodot(version)\n        expected = [base_abi + \"u\" if result else base_abi]\n        assert tags._cpython_abis(version) == expected\n\n\nclass TestCPythonTags:\n    def test_iterator_returned(self):\n        result_iterator = tags.cpython_tags(\n            (3, 8), [\"cp38d\", \"cp38\"], [\"plat1\", \"plat2\"]\n        )\n        assert isinstance(result_iterator, collections.abc.Iterator)\n\n    def test_all_args(self):\n        result_iterator = tags.cpython_tags(\n            (3, 11), [\"cp311d\", \"cp311\"], [\"plat1\", \"plat2\"]\n        )\n        result = list(result_iterator)\n        assert result == [\n            tags.Tag(\"cp311\", \"cp311d\", \"plat1\"),\n            tags.Tag(\"cp311\", \"cp311d\", \"plat2\"),\n            tags.Tag(\"cp311\", \"cp311\", \"plat1\"),\n            tags.Tag(\"cp311\", \"cp311\", \"plat2\"),\n            tags.Tag(\"cp311\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp311\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp311\", \"none\", \"plat1\"),\n            tags.Tag(\"cp311\", \"none\", \"plat2\"),\n            tags.Tag(\"cp310\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp310\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp39\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp39\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp38\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp38\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp37\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp37\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp36\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp36\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp35\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp35\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp34\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp34\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat2\"),\n        ]\n        result_iterator = tags.cpython_tags(\n            (3, 8), [\"cp38d\", \"cp38\"], [\"plat1\", \"plat2\"]\n        )\n        result = list(result_iterator)\n        assert result == [\n            tags.Tag(\"cp38\", \"cp38d\", \"plat1\"),\n            tags.Tag(\"cp38\", \"cp38d\", \"plat2\"),\n            tags.Tag(\"cp38\", \"cp38\", \"plat1\"),\n            tags.Tag(\"cp38\", \"cp38\", \"plat2\"),\n            tags.Tag(\"cp38\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp38\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp38\", \"none\", \"plat1\"),\n            tags.Tag(\"cp38\", \"none\", \"plat2\"),\n            tags.Tag(\"cp37\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp37\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp36\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp36\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp35\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp35\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp34\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp34\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat2\"),\n        ]\n\n        result = list(tags.cpython_tags((3, 3), [\"cp33m\"], [\"plat1\", \"plat2\"]))\n        assert result == [\n            tags.Tag(\"cp33\", \"cp33m\", \"plat1\"),\n            tags.Tag(\"cp33\", \"cp33m\", \"plat2\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat2\"),\n            tags.Tag(\"cp33\", \"none\", \"plat1\"),\n            tags.Tag(\"cp33\", \"none\", \"plat2\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat1\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat2\"),\n        ]\n\n        result = list(tags.cpython_tags((3, 13), [\"cp313t\"], [\"plat1\", \"plat2\"]))\n        assert result == [\n            tags.Tag(\"cp313\", \"cp313t\", \"plat1\"),\n            tags.Tag(\"cp313\", \"cp313t\", \"plat2\"),\n            tags.Tag(\"cp313\", \"none\", \"plat1\"),\n            tags.Tag(\"cp313\", \"none\", \"plat2\"),\n        ]\n\n    def test_python_version_defaults(self):\n        tag = next(tags.cpython_tags(abis=[\"abi3\"], platforms=[\"any\"]))\n        interpreter = \"cp\" + tags._version_nodot(sys.version_info[:2])\n        assert interpreter == tag.interpreter\n\n    def test_abi_defaults(self, monkeypatch):\n        monkeypatch.setattr(tags, \"_cpython_abis\", lambda _1, _2: [\"cp38\"])\n        result = list(tags.cpython_tags((3, 8), platforms=[\"any\"]))\n        assert tags.Tag(\"cp38\", \"cp38\", \"any\") in result\n        assert tags.Tag(\"cp38\", \"abi3\", \"any\") in result\n        assert tags.Tag(\"cp38\", \"none\", \"any\") in result\n\n    def test_abi_defaults_needs_underscore(self, monkeypatch):\n        monkeypatch.setattr(tags, \"_cpython_abis\", lambda _1, _2: [\"cp311\"])\n        result = list(tags.cpython_tags((3, 11), platforms=[\"any\"]))\n        assert tags.Tag(\"cp311\", \"cp311\", \"any\") in result\n        assert tags.Tag(\"cp311\", \"abi3\", \"any\") in result\n        assert tags.Tag(\"cp311\", \"none\", \"any\") in result\n\n    def test_platforms_defaults(self, monkeypatch):\n        monkeypatch.setattr(tags, \"platform_tags\", lambda: [\"plat1\"])\n        result = list(tags.cpython_tags((3, 8), abis=[\"whatever\"]))\n        assert tags.Tag(\"cp38\", \"whatever\", \"plat1\") in result\n\n    def test_platforms_defaults_needs_underscore(self, monkeypatch):\n        monkeypatch.setattr(tags, \"platform_tags\", lambda: [\"plat1\"])\n        result = list(tags.cpython_tags((3, 11), abis=[\"whatever\"]))\n        assert tags.Tag(\"cp311\", \"whatever\", \"plat1\") in result\n\n    def test_platform_name_space_normalization(self, monkeypatch):\n        \"\"\"Ensure that spaces are translated to underscores in platform names.\"\"\"\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"isilon onefs\")\n        for tag in tags.cpython_tags():\n            assert \" \" not in tag.platform\n\n    def test_major_only_python_version(self):\n        result = list(tags.cpython_tags((3,), [\"abi\"], [\"plat\"]))\n        assert result == [\n            tags.Tag(\"cp3\", \"abi\", \"plat\"),\n            tags.Tag(\"cp3\", \"none\", \"plat\"),\n        ]\n\n    def test_major_only_python_version_with_default_abis(self):\n        result = list(tags.cpython_tags((3,), platforms=[\"plat\"]))\n        assert result == [tags.Tag(\"cp3\", \"none\", \"plat\")]\n\n    @pytest.mark.parametrize(\"abis\", [[], [\"abi3\"], [\"none\"]])\n    def test_skip_redundant_abis(self, abis):\n        results = list(tags.cpython_tags((3, 0), abis=abis, platforms=[\"any\"]))\n        assert results == [tags.Tag(\"cp30\", \"none\", \"any\")]\n\n    def test_abi3_python33(self):\n        results = list(tags.cpython_tags((3, 3), abis=[\"cp33\"], platforms=[\"plat\"]))\n        assert results == [\n            tags.Tag(\"cp33\", \"cp33\", \"plat\"),\n            tags.Tag(\"cp33\", \"abi3\", \"plat\"),\n            tags.Tag(\"cp33\", \"none\", \"plat\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat\"),\n        ]\n\n    def test_no_excess_abi3_python32(self):\n        results = list(tags.cpython_tags((3, 2), abis=[\"cp32\"], platforms=[\"plat\"]))\n        assert results == [\n            tags.Tag(\"cp32\", \"cp32\", \"plat\"),\n            tags.Tag(\"cp32\", \"abi3\", \"plat\"),\n            tags.Tag(\"cp32\", \"none\", \"plat\"),\n        ]\n\n    def test_no_abi3_python31(self):\n        results = list(tags.cpython_tags((3, 1), abis=[\"cp31\"], platforms=[\"plat\"]))\n        assert results == [\n            tags.Tag(\"cp31\", \"cp31\", \"plat\"),\n            tags.Tag(\"cp31\", \"none\", \"plat\"),\n        ]\n\n    def test_no_abi3_python27(self):\n        results = list(tags.cpython_tags((2, 7), abis=[\"cp27\"], platforms=[\"plat\"]))\n        assert results == [\n            tags.Tag(\"cp27\", \"cp27\", \"plat\"),\n            tags.Tag(\"cp27\", \"none\", \"plat\"),\n        ]\n\n\nclass TestGenericTags:\n    def test__generic_abi_macos(self, monkeypatch):\n        monkeypatch.setattr(\n            sysconfig, \"get_config_var\", lambda key: \".cpython-37m-darwin.so\"\n        )\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"cp\")\n        assert tags._generic_abi() == [\"cp37m\"]\n\n    def test__generic_abi_linux_cpython(self, monkeypatch):\n        config = {\n            \"Py_DEBUG\": False,\n            \"WITH_PYMALLOC\": True,\n            \"EXT_SUFFIX\": \".cpython-37m-x86_64-linux-gnu.so\",\n        }\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"cp\")\n        # They are identical\n        assert tags._cpython_abis((3, 7)) == [\"cp37m\"]\n        assert tags._generic_abi() == [\"cp37m\"]\n\n    def test__generic_abi_jp(self, monkeypatch):\n        config = {\"EXT_SUFFIX\": \".return_exactly_this.so\"}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._generic_abi() == [\"return_exactly_this\"]\n\n    def test__generic_abi_graal(self, monkeypatch):\n        config = {\"EXT_SUFFIX\": \".graalpy-38-native-x86_64-darwin.so\"}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._generic_abi() == [\"graalpy_38_native\"]\n\n    def test__generic_abi_disable_gil(self, monkeypatch):\n        config = {\n            \"Py_DEBUG\": False,\n            \"EXT_SUFFIX\": \".cpython-313t-x86_64-linux-gnu.so\",\n            \"WITH_PYMALLOC\": 0,\n            \"Py_GIL_DISABLED\": 1,\n        }\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._generic_abi() == [\"cp313t\"]\n        assert tags._generic_abi() == tags._cpython_abis((3, 13))\n\n    def test__generic_abi_none(self, monkeypatch):\n        config = {\"EXT_SUFFIX\": \"..so\"}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._generic_abi() == []\n\n    @pytest.mark.parametrize(\"ext_suffix\", [\"invalid\", None])\n    def test__generic_abi_error(self, ext_suffix, monkeypatch):\n        config = {\"EXT_SUFFIX\": ext_suffix}\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        with pytest.raises(SystemError) as e:\n            tags._generic_abi()\n        assert \"EXT_SUFFIX\" in str(e.value)\n\n    def test__generic_abi_linux_pypy(self, monkeypatch):\n        # issue gh-606\n        config = {\n            \"Py_DEBUG\": False,\n            \"EXT_SUFFIX\": \".pypy39-pp73-x86_64-linux-gnu.so\",\n        }\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"pp\")\n        assert tags._generic_abi() == [\"pypy39_pp73\"]\n\n    def test__generic_abi_old_windows(self, monkeypatch):\n        config = {\n            \"EXT_SUFFIX\": \".pyd\",\n            \"Py_DEBUG\": 0,\n            \"WITH_PYMALLOC\": 0,\n            \"Py_GIL_DISABLED\": 0,\n        }\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._generic_abi() == tags._cpython_abis(sys.version_info[:2])\n\n    def test__generic_abi_windows(self, monkeypatch):\n        config = {\n            \"EXT_SUFFIX\": \".cp310-win_amd64.pyd\",\n        }\n        monkeypatch.setattr(sysconfig, \"get_config_var\", config.__getitem__)\n        assert tags._generic_abi() == [\"cp310\"]\n\n    @pytest.mark.skipif(sys.implementation.name != \"cpython\", reason=\"CPython-only\")\n    def test__generic_abi_agree(self):\n        \"\"\"Test that the two methods of finding the abi tag agree\"\"\"\n        assert tags._generic_abi() == tags._cpython_abis(sys.version_info[:2])\n\n    def test_generic_platforms(self):\n        platform = sysconfig.get_platform().replace(\"-\", \"_\")\n        platform = platform.replace(\".\", \"_\")\n        assert list(tags._generic_platforms()) == [platform]\n\n    def test_generic_platforms_space(self, monkeypatch):\n        \"\"\"Ensure platform tags normalize spaces to underscores.\"\"\"\n        platform_ = \"isilon onefs\"\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: platform_)\n        assert list(tags._generic_platforms()) == [platform_.replace(\" \", \"_\")]\n\n    def test_iterator_returned(self):\n        result_iterator = tags.generic_tags(\"sillywalk33\", [\"abi\"], [\"plat1\", \"plat2\"])\n        assert isinstance(result_iterator, collections.abc.Iterator)\n\n    def test_all_args(self):\n        result_iterator = tags.generic_tags(\"sillywalk33\", [\"abi\"], [\"plat1\", \"plat2\"])\n        result = list(result_iterator)\n        assert result == [\n            tags.Tag(\"sillywalk33\", \"abi\", \"plat1\"),\n            tags.Tag(\"sillywalk33\", \"abi\", \"plat2\"),\n            tags.Tag(\"sillywalk33\", \"none\", \"plat1\"),\n            tags.Tag(\"sillywalk33\", \"none\", \"plat2\"),\n        ]\n\n    @pytest.mark.parametrize(\"abi\", [[], [\"none\"]])\n    def test_abi_unspecified(self, abi):\n        no_abi = list(tags.generic_tags(\"sillywalk34\", abi, [\"plat1\", \"plat2\"]))\n        assert no_abi == [\n            tags.Tag(\"sillywalk34\", \"none\", \"plat1\"),\n            tags.Tag(\"sillywalk34\", \"none\", \"plat2\"),\n        ]\n\n    def test_interpreter_default(self, monkeypatch):\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"sillywalk\")\n        monkeypatch.setattr(tags, \"interpreter_version\", lambda warn: \"NN\")\n        result = list(tags.generic_tags(abis=[\"none\"], platforms=[\"any\"]))\n        assert result == [tags.Tag(\"sillywalkNN\", \"none\", \"any\")]\n\n    def test_abis_default(self, monkeypatch):\n        monkeypatch.setattr(tags, \"_generic_abi\", lambda: [\"abi\"])\n        result = list(tags.generic_tags(interpreter=\"sillywalk\", platforms=[\"any\"]))\n        assert result == [\n            tags.Tag(\"sillywalk\", \"abi\", \"any\"),\n            tags.Tag(\"sillywalk\", \"none\", \"any\"),\n        ]\n\n    def test_platforms_default(self, monkeypatch):\n        monkeypatch.setattr(tags, \"platform_tags\", lambda: [\"plat\"])\n        result = list(tags.generic_tags(interpreter=\"sillywalk\", abis=[\"none\"]))\n        assert result == [tags.Tag(\"sillywalk\", \"none\", \"plat\")]\n\n\nclass TestCompatibleTags:\n    def test_all_args(self):\n        result = list(tags.compatible_tags((3, 3), \"cp33\", [\"plat1\", \"plat2\"]))\n        assert result == [\n            tags.Tag(\"py33\", \"none\", \"plat1\"),\n            tags.Tag(\"py33\", \"none\", \"plat2\"),\n            tags.Tag(\"py3\", \"none\", \"plat1\"),\n            tags.Tag(\"py3\", \"none\", \"plat2\"),\n            tags.Tag(\"py32\", \"none\", \"plat1\"),\n            tags.Tag(\"py32\", \"none\", \"plat2\"),\n            tags.Tag(\"py31\", \"none\", \"plat1\"),\n            tags.Tag(\"py31\", \"none\", \"plat2\"),\n            tags.Tag(\"py30\", \"none\", \"plat1\"),\n            tags.Tag(\"py30\", \"none\", \"plat2\"),\n            tags.Tag(\"cp33\", \"none\", \"any\"),\n            tags.Tag(\"py33\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n            tags.Tag(\"py32\", \"none\", \"any\"),\n            tags.Tag(\"py31\", \"none\", \"any\"),\n            tags.Tag(\"py30\", \"none\", \"any\"),\n        ]\n\n    def test_all_args_needs_underscore(self):\n        result = list(tags.compatible_tags((3, 11), \"cp311\", [\"plat1\", \"plat2\"]))\n        assert result == [\n            tags.Tag(\"py311\", \"none\", \"plat1\"),\n            tags.Tag(\"py311\", \"none\", \"plat2\"),\n            tags.Tag(\"py3\", \"none\", \"plat1\"),\n            tags.Tag(\"py3\", \"none\", \"plat2\"),\n            tags.Tag(\"py310\", \"none\", \"plat1\"),\n            tags.Tag(\"py310\", \"none\", \"plat2\"),\n            tags.Tag(\"py39\", \"none\", \"plat1\"),\n            tags.Tag(\"py39\", \"none\", \"plat2\"),\n            tags.Tag(\"py38\", \"none\", \"plat1\"),\n            tags.Tag(\"py38\", \"none\", \"plat2\"),\n            tags.Tag(\"py37\", \"none\", \"plat1\"),\n            tags.Tag(\"py37\", \"none\", \"plat2\"),\n            tags.Tag(\"py36\", \"none\", \"plat1\"),\n            tags.Tag(\"py36\", \"none\", \"plat2\"),\n            tags.Tag(\"py35\", \"none\", \"plat1\"),\n            tags.Tag(\"py35\", \"none\", \"plat2\"),\n            tags.Tag(\"py34\", \"none\", \"plat1\"),\n            tags.Tag(\"py34\", \"none\", \"plat2\"),\n            tags.Tag(\"py33\", \"none\", \"plat1\"),\n            tags.Tag(\"py33\", \"none\", \"plat2\"),\n            tags.Tag(\"py32\", \"none\", \"plat1\"),\n            tags.Tag(\"py32\", \"none\", \"plat2\"),\n            tags.Tag(\"py31\", \"none\", \"plat1\"),\n            tags.Tag(\"py31\", \"none\", \"plat2\"),\n            tags.Tag(\"py30\", \"none\", \"plat1\"),\n            tags.Tag(\"py30\", \"none\", \"plat2\"),\n            tags.Tag(\"cp311\", \"none\", \"any\"),\n            tags.Tag(\"py311\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n            tags.Tag(\"py310\", \"none\", \"any\"),\n            tags.Tag(\"py39\", \"none\", \"any\"),\n            tags.Tag(\"py38\", \"none\", \"any\"),\n            tags.Tag(\"py37\", \"none\", \"any\"),\n            tags.Tag(\"py36\", \"none\", \"any\"),\n            tags.Tag(\"py35\", \"none\", \"any\"),\n            tags.Tag(\"py34\", \"none\", \"any\"),\n            tags.Tag(\"py33\", \"none\", \"any\"),\n            tags.Tag(\"py32\", \"none\", \"any\"),\n            tags.Tag(\"py31\", \"none\", \"any\"),\n            tags.Tag(\"py30\", \"none\", \"any\"),\n        ]\n\n    def test_major_only_python_version(self):\n        result = list(tags.compatible_tags((3,), \"cp33\", [\"plat\"]))\n        assert result == [\n            tags.Tag(\"py3\", \"none\", \"plat\"),\n            tags.Tag(\"cp33\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n        ]\n\n    def test_default_python_version(self, monkeypatch):\n        monkeypatch.setattr(sys, \"version_info\", (3, 1))\n        result = list(tags.compatible_tags(interpreter=\"cp31\", platforms=[\"plat\"]))\n        assert result == [\n            tags.Tag(\"py31\", \"none\", \"plat\"),\n            tags.Tag(\"py3\", \"none\", \"plat\"),\n            tags.Tag(\"py30\", \"none\", \"plat\"),\n            tags.Tag(\"cp31\", \"none\", \"any\"),\n            tags.Tag(\"py31\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n            tags.Tag(\"py30\", \"none\", \"any\"),\n        ]\n\n    def test_default_python_version_needs_underscore(self, monkeypatch):\n        monkeypatch.setattr(sys, \"version_info\", (3, 11))\n        result = list(tags.compatible_tags(interpreter=\"cp311\", platforms=[\"plat\"]))\n        assert result == [\n            tags.Tag(\"py311\", \"none\", \"plat\"),\n            tags.Tag(\"py3\", \"none\", \"plat\"),\n            tags.Tag(\"py310\", \"none\", \"plat\"),\n            tags.Tag(\"py39\", \"none\", \"plat\"),\n            tags.Tag(\"py38\", \"none\", \"plat\"),\n            tags.Tag(\"py37\", \"none\", \"plat\"),\n            tags.Tag(\"py36\", \"none\", \"plat\"),\n            tags.Tag(\"py35\", \"none\", \"plat\"),\n            tags.Tag(\"py34\", \"none\", \"plat\"),\n            tags.Tag(\"py33\", \"none\", \"plat\"),\n            tags.Tag(\"py32\", \"none\", \"plat\"),\n            tags.Tag(\"py31\", \"none\", \"plat\"),\n            tags.Tag(\"py30\", \"none\", \"plat\"),\n            tags.Tag(\"cp311\", \"none\", \"any\"),\n            tags.Tag(\"py311\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n            tags.Tag(\"py310\", \"none\", \"any\"),\n            tags.Tag(\"py39\", \"none\", \"any\"),\n            tags.Tag(\"py38\", \"none\", \"any\"),\n            tags.Tag(\"py37\", \"none\", \"any\"),\n            tags.Tag(\"py36\", \"none\", \"any\"),\n            tags.Tag(\"py35\", \"none\", \"any\"),\n            tags.Tag(\"py34\", \"none\", \"any\"),\n            tags.Tag(\"py33\", \"none\", \"any\"),\n            tags.Tag(\"py32\", \"none\", \"any\"),\n            tags.Tag(\"py31\", \"none\", \"any\"),\n            tags.Tag(\"py30\", \"none\", \"any\"),\n        ]\n\n    def test_default_interpreter(self):\n        result = list(tags.compatible_tags((3, 1), platforms=[\"plat\"]))\n        assert result == [\n            tags.Tag(\"py31\", \"none\", \"plat\"),\n            tags.Tag(\"py3\", \"none\", \"plat\"),\n            tags.Tag(\"py30\", \"none\", \"plat\"),\n            tags.Tag(\"py31\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n            tags.Tag(\"py30\", \"none\", \"any\"),\n        ]\n\n    def test_default_platforms(self, monkeypatch):\n        monkeypatch.setattr(tags, \"platform_tags\", lambda: iter([\"plat\", \"plat2\"]))\n        result = list(tags.compatible_tags((3, 1), \"cp31\"))\n        assert result == [\n            tags.Tag(\"py31\", \"none\", \"plat\"),\n            tags.Tag(\"py31\", \"none\", \"plat2\"),\n            tags.Tag(\"py3\", \"none\", \"plat\"),\n            tags.Tag(\"py3\", \"none\", \"plat2\"),\n            tags.Tag(\"py30\", \"none\", \"plat\"),\n            tags.Tag(\"py30\", \"none\", \"plat2\"),\n            tags.Tag(\"cp31\", \"none\", \"any\"),\n            tags.Tag(\"py31\", \"none\", \"any\"),\n            tags.Tag(\"py3\", \"none\", \"any\"),\n            tags.Tag(\"py30\", \"none\", \"any\"),\n        ]\n\n\nclass TestSysTags:\n    def teardown_method(self):\n        # Clear the version cache\n        tags._glibc_version = []\n\n    @pytest.mark.parametrize(\n        \"name,expected\",\n        [(\"CPython\", \"cp\"), (\"PyPy\", \"pp\"), (\"Jython\", \"jy\"), (\"IronPython\", \"ip\")],\n    )\n    def test_interpreter_name(self, name, expected, mock_interpreter_name):\n        mock_interpreter_name(name)\n        assert tags.interpreter_name() == expected\n\n    def test_iterator(self):\n        assert isinstance(tags.sys_tags(), collections.abc.Iterator)\n\n    def test_mac_cpython(self, mock_interpreter_name, monkeypatch):\n        if mock_interpreter_name(\"CPython\"):\n            monkeypatch.setattr(tags, \"_cpython_abis\", lambda *a: [\"cp33m\"])\n        if platform.system() != \"Darwin\":\n            monkeypatch.setattr(platform, \"system\", lambda: \"Darwin\")\n            monkeypatch.setattr(tags, \"mac_platforms\", lambda: [\"macosx_10_5_x86_64\"])\n        abis = tags._cpython_abis(sys.version_info[:2])\n        platforms = list(tags.mac_platforms())\n        result = list(tags.sys_tags())\n        assert len(abis) == 1\n        assert result[0] == tags.Tag(\n            \"cp\" + tags._version_nodot(sys.version_info[:2]), abis[0], platforms[0]\n        )\n        assert result[-1] == tags.Tag(\n            \"py\" + tags._version_nodot((sys.version_info[0], 0)), \"none\", \"any\"\n        )\n\n    def test_windows_cpython(self, mock_interpreter_name, monkeypatch):\n        if mock_interpreter_name(\"CPython\"):\n            monkeypatch.setattr(tags, \"_cpython_abis\", lambda *a: [\"cp33m\"])\n        if platform.system() != \"Windows\":\n            monkeypatch.setattr(platform, \"system\", lambda: \"Windows\")\n            monkeypatch.setattr(tags, \"_generic_platforms\", lambda: [\"win_amd64\"])\n        abis = list(tags._cpython_abis(sys.version_info[:2]))\n        platforms = list(tags._generic_platforms())\n        result = list(tags.sys_tags())\n        interpreter = \"cp\" + tags._version_nodot(sys.version_info[:2])\n        assert len(abis) == 1\n        expected = tags.Tag(interpreter, abis[0], platforms[0])\n        assert result[0] == expected\n        expected = tags.Tag(\n            \"py\" + tags._version_nodot((sys.version_info[0], 0)), \"none\", \"any\"\n        )\n        assert result[-1] == expected\n\n    def test_linux_cpython(self, mock_interpreter_name, monkeypatch):\n        if mock_interpreter_name(\"CPython\"):\n            monkeypatch.setattr(tags, \"_cpython_abis\", lambda *a: [\"cp33m\"])\n        if platform.system() != \"Linux\":\n            monkeypatch.setattr(platform, \"system\", lambda: \"Linux\")\n            monkeypatch.setattr(tags, \"_linux_platforms\", lambda: [\"linux_x86_64\"])\n        abis = list(tags._cpython_abis(sys.version_info[:2]))\n        platforms = list(tags._linux_platforms())\n        result = list(tags.sys_tags())\n        expected_interpreter = \"cp\" + tags._version_nodot(sys.version_info[:2])\n        assert len(abis) == 1\n        assert result[0] == tags.Tag(expected_interpreter, abis[0], platforms[0])\n        expected = tags.Tag(\n            \"py\" + tags._version_nodot((sys.version_info[0], 0)), \"none\", \"any\"\n        )\n        assert result[-1] == expected\n\n    def test_generic(self, monkeypatch):\n        monkeypatch.setattr(platform, \"system\", lambda: \"Generic\")\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"generic\")\n\n        result = list(tags.sys_tags())\n        expected = tags.Tag(\n            \"py\" + tags._version_nodot((sys.version_info[0], 0)), \"none\", \"any\"\n        )\n        assert result[-1] == expected\n\n    def test_linux_platforms_manylinux2014_armv6l(self, monkeypatch, manylinux_module):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_armv6l\")\n        monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.20\", raising=False)\n        platforms = list(tags._linux_platforms(is_32bit=True))\n        expected = [\"linux_armv6l\"]\n        assert platforms == expected\n\n    def test_skip_manylinux_2014(self, monkeypatch, manylinux_module):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_ppc64\")\n        monkeypatch.setattr(tags._manylinux, \"_get_glibc_version\", lambda: (2, 20))\n        monkeypatch.setattr(\n            manylinux_module, \"manylinux2014_compatible\", False, raising=False\n        )\n        expected = [\n            \"manylinux_2_20_ppc64\",\n            \"manylinux_2_19_ppc64\",\n            \"manylinux_2_18_ppc64\",\n            # \"manylinux2014_ppc64\",  # this one is skipped\n            # \"manylinux_2_17_ppc64\", # this one is also skipped\n            \"linux_ppc64\",\n        ]\n        platforms = list(tags._linux_platforms())\n        assert platforms == expected\n\n    @pytest.mark.parametrize(\n        \"machine, abi, alt_machine\",\n        [(\"x86_64\", \"x32\", \"i686\"), (\"armv7l\", \"armel\", \"armv7l\")],\n    )\n    def test_linux_platforms_not_manylinux_abi(\n        self, monkeypatch, manylinux_module, machine, abi, alt_machine\n    ):\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: f\"linux_{machine}\")\n        monkeypatch.setattr(\n            sys,\n            \"executable\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"manylinux\",\n                f\"hello-world-{machine}-{abi}\",\n            ),\n        )\n        platforms = list(tags._linux_platforms(is_32bit=True))\n        expected = [f\"linux_{alt_machine}\"]\n        assert platforms == expected\n\n    @pytest.mark.parametrize(\n        \"machine, major, minor, tf\", [(\"x86_64\", 2, 20, False), (\"s390x\", 2, 22, True)]\n    )\n    def test_linux_use_manylinux_compatible(\n        self, monkeypatch, manylinux_module, machine, major, minor, tf\n    ):\n        def manylinux_compatible(tag_major, tag_minor, tag_arch):\n            if tag_major == 2 and tag_minor == 22:\n                return tag_arch == \"s390x\"\n            return False\n\n        monkeypatch.setattr(\n            tags._manylinux,\n            \"_get_glibc_version\",\n            lambda: (major, minor),\n        )\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: f\"linux_{machine}\")\n        monkeypatch.setattr(\n            manylinux_module,\n            \"manylinux_compatible\",\n            manylinux_compatible,\n            raising=False,\n        )\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        if tf:\n            expected = [f\"manylinux_2_22_{machine}\"]\n        else:\n            expected = []\n        expected.append(f\"linux_{machine}\")\n        assert platforms == expected\n\n    def test_linux_use_manylinux_compatible_none(self, monkeypatch, manylinux_module):\n        def manylinux_compatible(tag_major, tag_minor, tag_arch):\n            if tag_major == 2 and tag_minor < 25:\n                return False\n            return None\n\n        monkeypatch.setattr(tags._manylinux, \"_get_glibc_version\", lambda: (2, 30))\n        monkeypatch.setattr(sysconfig, \"get_platform\", lambda: \"linux_x86_64\")\n        monkeypatch.setattr(\n            manylinux_module,\n            \"manylinux_compatible\",\n            manylinux_compatible,\n            raising=False,\n        )\n        platforms = list(tags._linux_platforms(is_32bit=False))\n        expected = [\n            \"manylinux_2_30_x86_64\",\n            \"manylinux_2_29_x86_64\",\n            \"manylinux_2_28_x86_64\",\n            \"manylinux_2_27_x86_64\",\n            \"manylinux_2_26_x86_64\",\n            \"manylinux_2_25_x86_64\",\n            \"linux_x86_64\",\n        ]\n        assert platforms == expected\n\n    def test_pypy_first_none_any_tag(self, monkeypatch):\n        # When building the complete list of pypy tags, make sure the first\n        # <interpreter>-none-any one is pp3-none-any\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"pp\")\n\n        for tag in tags.sys_tags():\n            if tag.abi == \"none\" and tag.platform == \"any\":\n                break\n\n        assert tag == tags.Tag(\"pp3\", \"none\", \"any\")\n\n    def test_cpython_first_none_any_tag(self, monkeypatch):\n        # When building the complete list of cpython tags, make sure the first\n        # <interpreter>-none-any one is cpxx-none-any\n        monkeypatch.setattr(tags, \"interpreter_name\", lambda: \"cp\")\n\n        # Find the first tag that is ABI- and platform-agnostic.\n        for tag in tags.sys_tags():\n            if tag.abi == \"none\" and tag.platform == \"any\":\n                break\n\n        interpreter = f\"cp{tags.interpreter_version()}\"\n        assert tag == tags.Tag(interpreter, \"none\", \"any\")\n\n\nclass TestBitness:\n    def teardown_method(self):\n        importlib.reload(tags)\n\n    @pytest.mark.parametrize(\n        \"maxsize, sizeof_voidp, expected\",\n        [\n            # 64-bit\n            (9223372036854775807, 8, False),\n            # 32-bit\n            (2147483647, 4, True),\n            # 64-bit w/ 32-bit sys.maxsize: GraalPy, IronPython, Jython\n            (2147483647, 8, False),\n        ],\n    )\n    def test_32bit_interpreter(self, maxsize, sizeof_voidp, expected, monkeypatch):\n        def _calcsize(fmt):\n            assert fmt == \"P\"\n            return sizeof_voidp\n\n        monkeypatch.setattr(sys, \"maxsize\", maxsize)\n        monkeypatch.setattr(struct, \"calcsize\", _calcsize)\n        importlib.reload(tags)\n        assert tags._32_BIT_INTERPRETER == expected\n", "tests/test_musllinux.py": "import collections\nimport pathlib\nimport subprocess\n\nimport pretend\nimport pytest\n\nfrom packaging import _musllinux\nfrom packaging._musllinux import _get_musl_version, _MuslVersion, _parse_musl_version\n\nMUSL_AMD64 = \"musl libc (x86_64)\\nVersion 1.2.2\\n\"\nMUSL_I386 = \"musl libc (i386)\\nVersion 1.2.1\\n\"\nMUSL_AARCH64 = \"musl libc (aarch64)\\nVersion 1.1.24\\n\"\nMUSL_INVALID = \"musl libc (invalid)\\n\"\nMUSL_UNKNOWN = \"musl libc (unknown)\\nVersion unknown\\n\"\n\nMUSL_DIR = pathlib.Path(__file__).with_name(\"musllinux\").resolve()\n\nBIN_GLIBC_X86_64 = MUSL_DIR.joinpath(\"glibc-x86_64\")\nBIN_MUSL_X86_64 = MUSL_DIR.joinpath(\"musl-x86_64\")\nBIN_MUSL_I386 = MUSL_DIR.joinpath(\"musl-i386\")\nBIN_MUSL_AARCH64 = MUSL_DIR.joinpath(\"musl-aarch64\")\n\nLD_MUSL_X86_64 = \"/lib/ld-musl-x86_64.so.1\"\nLD_MUSL_I386 = \"/lib/ld-musl-i386.so.1\"\nLD_MUSL_AARCH64 = \"/lib/ld-musl-aarch64.so.1\"\n\n\n@pytest.fixture(autouse=True)\ndef clear_lru_cache():\n    yield\n    _get_musl_version.cache_clear()\n\n\n@pytest.mark.parametrize(\n    \"output, version\",\n    [\n        (MUSL_AMD64, _MuslVersion(1, 2)),\n        (MUSL_I386, _MuslVersion(1, 2)),\n        (MUSL_AARCH64, _MuslVersion(1, 1)),\n        (MUSL_INVALID, None),\n        (MUSL_UNKNOWN, None),\n    ],\n    ids=[\"amd64-1.2.2\", \"i386-1.2.1\", \"aarch64-1.1.24\", \"invalid\", \"unknown\"],\n)\ndef test_parse_musl_version(output, version):\n    assert _parse_musl_version(output) == version\n\n\n@pytest.mark.parametrize(\n    \"executable, output, version, ld_musl\",\n    [\n        (MUSL_DIR.joinpath(\"does-not-exist\"), \"error\", None, None),\n        (BIN_GLIBC_X86_64, \"error\", None, None),\n        (BIN_MUSL_X86_64, MUSL_AMD64, _MuslVersion(1, 2), LD_MUSL_X86_64),\n        (BIN_MUSL_I386, MUSL_I386, _MuslVersion(1, 2), LD_MUSL_I386),\n        (BIN_MUSL_AARCH64, MUSL_AARCH64, _MuslVersion(1, 1), LD_MUSL_AARCH64),\n    ],\n    ids=[\"does-not-exist\", \"glibc\", \"x86_64\", \"i386\", \"aarch64\"],\n)\ndef test_get_musl_version(monkeypatch, executable, output, version, ld_musl):\n    def mock_run(*args, **kwargs):\n        return collections.namedtuple(\"Proc\", \"stderr\")(output)\n\n    run_recorder = pretend.call_recorder(mock_run)\n    monkeypatch.setattr(_musllinux.subprocess, \"run\", run_recorder)\n\n    assert _get_musl_version(str(executable)) == version\n\n    if ld_musl is not None:\n        expected_calls = [\n            pretend.call(\n                [ld_musl],\n                stderr=subprocess.PIPE,\n                text=True,\n            )\n        ]\n    else:\n        expected_calls = []\n    assert run_recorder.calls == expected_calls\n", "tests/test_requirements.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport pytest\n\nfrom packaging.markers import Marker\nfrom packaging.requirements import InvalidRequirement, Requirement\nfrom packaging.specifiers import SpecifierSet\n\nEQUAL_DEPENDENCIES = [\n    (\"packaging>20.1\", \"packaging>20.1\"),\n    (\n        'requests[security, tests]>=2.8.1,==2.8.*;python_version<\"2.7\"',\n        'requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"',\n    ),\n    (\n        'importlib-metadata; python_version<\"3.8\"',\n        \"importlib-metadata; python_version<'3.8'\",\n    ),\n    (\n        'appdirs>=1.4.4,<2; os_name==\"posix\" and extra==\"testing\"',\n        \"appdirs>=1.4.4,<2; os_name == 'posix' and extra == 'testing'\",\n    ),\n]\n\nEQUIVALENT_DEPENDENCIES = [\n    (\"scikit-learn==1.0.1\", \"scikit_learn==1.0.1\"),\n]\n\nDIFFERENT_DEPENDENCIES = [\n    (\"package_one\", \"package_two\"),\n    (\"packaging>20.1\", \"packaging>=20.1\"),\n    (\"packaging>20.1\", \"packaging>21.1\"),\n    (\"packaging>20.1\", \"package>20.1\"),\n    (\n        'requests[security,tests]>=2.8.1,==2.8.*;python_version<\"2.7\"',\n        'requests [security,tests] >= 2.8.1 ; python_version < \"2.7\"',\n    ),\n    (\n        'importlib-metadata; python_version<\"3.8\"',\n        \"importlib-metadata; python_version<'3.7'\",\n    ),\n    (\n        'appdirs>=1.4.4,<2; os_name==\"posix\" and extra==\"testing\"',\n        \"appdirs>=1.4.4,<2; os_name == 'posix' and extra == 'docs'\",\n    ),\n]\n\n\n@pytest.mark.parametrize(\n    \"name\",\n    [\n        \"package\",\n        \"pAcKaGe\",\n        \"Package\",\n        \"foo-bar.quux_bAz\",\n        \"installer\",\n        \"android12\",\n    ],\n)\n@pytest.mark.parametrize(\n    \"extras\",\n    [\n        set(),\n        {\"a\"},\n        {\"a\", \"b\"},\n        {\"a\", \"B\", \"CDEF123\"},\n    ],\n)\n@pytest.mark.parametrize(\n    (\"url\", \"specifier\"),\n    [\n        (None, \"\"),\n        (\"https://example.com/packagename.zip\", \"\"),\n        (\"ssh://user:pass%20word@example.com/packagename.zip\", \"\"),\n        (\"https://example.com/name;v=1.1/?query=foo&bar=baz#blah\", \"\"),\n        (\"git+ssh://git.example.com/MyProject\", \"\"),\n        (\"git+ssh://git@github.com:pypa/packaging.git\", \"\"),\n        (\"git+https://git.example.com/MyProject.git@master\", \"\"),\n        (\"git+https://git.example.com/MyProject.git@v1.0\", \"\"),\n        (\"git+https://git.example.com/MyProject.git@refs/pull/123/head\", \"\"),\n        (\"gopher:/foo/com\", \"\"),\n        (None, \"==={ws}arbitrarystring\"),\n        (None, \"({ws}==={ws}arbitrarystring{ws})\"),\n        (None, \"=={ws}1.0\"),\n        (None, \"({ws}=={ws}1.0{ws})\"),\n        (None, \"=={ws}1.0-alpha\"),\n        (None, \"<={ws}1!3.0.0.rc2\"),\n        (None, \">{ws}2.2{ws},{ws}<{ws}3\"),\n        (None, \"(>{ws}2.2{ws},{ws}<{ws}3)\"),\n    ],\n)\n@pytest.mark.parametrize(\n    \"marker\",\n    [\n        None,\n        \"python_version{ws}>={ws}'3.3'\",\n        '({ws}python_version{ws}>={ws}\"3.4\"{ws}){ws}and extra{ws}=={ws}\"oursql\"',\n        (\n            \"sys_platform{ws}!={ws}'linux' and(os_name{ws}=={ws}'linux' or \"\n            \"python_version{ws}>={ws}'3.3'{ws}){ws}\"\n        ),\n    ],\n)\n@pytest.mark.parametrize(\"whitespace\", [\"\", \" \", \"\\t\"])\ndef test_basic_valid_requirement_parsing(\n    name: str,\n    extras: set[str],\n    specifier: str,\n    url: str | None,\n    marker: str,\n    whitespace: str,\n) -> None:\n    # GIVEN\n    parts = [name]\n    if extras:\n        parts.append(\"[\")\n        parts.append(\"{ws},{ws}\".format(ws=whitespace).join(sorted(extras)))\n        parts.append(\"]\")\n    if specifier:\n        parts.append(specifier.format(ws=whitespace))\n    if url is not None:\n        parts.append(\"@\")\n        parts.append(url.format(ws=whitespace))\n    if marker is not None:\n        if url is not None:\n            parts.append(\" ;\")\n        else:\n            parts.append(\";\")\n        parts.append(marker.format(ws=whitespace))\n\n    to_parse = whitespace.join(parts)\n\n    # WHEN\n    req = Requirement(to_parse)\n\n    # THEN\n    assert req.name == name\n    assert req.extras == extras\n    assert req.url == url\n    assert req.specifier == specifier.format(ws=\"\").strip(\"()\")\n    assert req.marker == (Marker(marker.format(ws=\"\")) if marker else None)\n\n\nclass TestRequirementParsing:\n    @pytest.mark.parametrize(\n        \"marker\",\n        [\n            \"python_implementation == ''\",\n            \"platform_python_implementation == ''\",\n            \"os.name == 'linux'\",\n            \"os_name == 'linux'\",\n            \"'8' in platform.version\",\n            \"'8' not in platform.version\",\n        ],\n    )\n    def test_valid_marker(self, marker: str) -> None:\n        # GIVEN\n        to_parse = f\"name; {marker}\"\n\n        # WHEN\n        Requirement(to_parse)\n\n    @pytest.mark.parametrize(\n        \"url\",\n        [\n            \"file:///absolute/path\",\n            \"file://.\",\n            \"file:.\",\n            \"file:/.\",\n        ],\n    )\n    def test_file_url(self, url: str) -> None:\n        # GIVEN\n        to_parse = f\"name @ {url}\"\n\n        # WHEN\n        req = Requirement(to_parse)\n\n        # THEN\n        assert req.url == url\n\n    def test_empty_extras(self) -> None:\n        # GIVEN\n        to_parse = \"name[]\"\n\n        # WHEN\n        req = Requirement(to_parse)\n\n        # THEN\n        assert req.name == \"name\"\n        assert req.extras == set()\n\n    def test_empty_specifier(self) -> None:\n        # GIVEN\n        to_parse = \"name()\"\n\n        # WHEN\n        req = Requirement(to_parse)\n\n        # THEN\n        assert req.name == \"name\"\n        assert req.specifier == \"\"\n\n    # ----------------------------------------------------------------------------------\n    # Everything below this (in this class) should be parsing failure modes\n    # ----------------------------------------------------------------------------------\n    # Start all method names with with `test_error_`\n    # to make it easier to run these tests with `-k error`\n\n    def test_error_when_empty_string(self) -> None:\n        # GIVEN\n        to_parse = \"\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected package name at the start of dependency specifier\\n\"\n            \"    \\n\"\n            \"    ^\"\n        )\n\n    def test_error_no_name(self) -> None:\n        # GIVEN\n        to_parse = \"==0.0\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected package name at the start of dependency specifier\\n\"\n            \"    ==0.0\\n\"\n            \"    ^\"\n        )\n\n    def test_error_when_missing_comma_in_extras(self) -> None:\n        # GIVEN\n        to_parse = \"name[bar baz]\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected comma between extra names\\n\"\n            \"    name[bar baz]\\n\"\n            \"             ^\"\n        )\n\n    def test_error_when_trailing_comma_in_extras(self) -> None:\n        # GIVEN\n        to_parse = \"name[bar, baz,]\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected extra name after comma\\n\"\n            \"    name[bar, baz,]\\n\"\n            \"                  ^\"\n        )\n\n    def test_error_when_parens_not_closed_correctly(self) -> None:\n        # GIVEN\n        to_parse = \"name (>= 1.0\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected matching RIGHT_PARENTHESIS for LEFT_PARENTHESIS, \"\n            \"after version specifier\\n\"\n            \"    name (>= 1.0\\n\"\n            \"         ~~~~~~~^\"\n        )\n\n    def test_error_when_prefix_match_is_used_incorrectly(self) -> None:\n        # GIVEN\n        to_parse = \"black (>=20.*) ; extra == 'format'\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \".* suffix can only be used with `==` or `!=` operators\\n\"\n            \"    black (>=20.*) ; extra == 'format'\\n\"\n            \"           ~~~~~^\"\n        )\n\n    @pytest.mark.parametrize(\"operator\", [\">=\", \"<=\", \">\", \"<\", \"~=\"])\n    def test_error_when_local_version_label_is_used_incorrectly(\n        self, operator: str\n    ) -> None:\n        # GIVEN\n        to_parse = f\"name {operator} 1.0+local.version.label\"\n        op_tilde = len(operator) * \"~\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Local version label can only be used with `==` or `!=` operators\\n\"\n            f\"    name {operator} 1.0+local.version.label\\n\"\n            f\"         {op_tilde}~~~~^\"\n        )\n\n    def test_error_when_bracket_not_closed_correctly(self) -> None:\n        # GIVEN\n        to_parse = \"name[bar, baz >= 1.0\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected matching RIGHT_BRACKET for LEFT_BRACKET, \"\n            \"after extras\\n\"\n            \"    name[bar, baz >= 1.0\\n\"\n            \"        ~~~~~~~~~~^\"\n        )\n\n    def test_error_when_extras_bracket_left_unclosed(self) -> None:\n        # GIVEN\n        to_parse = \"name[bar, baz\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected matching RIGHT_BRACKET for LEFT_BRACKET, \"\n            \"after extras\\n\"\n            \"    name[bar, baz\\n\"\n            \"        ~~~~~~~~~^\"\n        )\n\n    def test_error_no_space_after_url(self) -> None:\n        # GIVEN\n        to_parse = \"name @ https://example.com/; extra == 'example'\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected end or semicolon (after URL and whitespace)\\n\"\n            \"    name @ https://example.com/; extra == 'example'\\n\"\n            \"           ~~~~~~~~~~~~~~~~~~~~~~^\"\n        )\n\n    def test_error_marker_bracket_unclosed(self) -> None:\n        # GIVEN\n        to_parse = \"name; (extra == 'example'\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected matching RIGHT_PARENTHESIS for LEFT_PARENTHESIS, \"\n            \"after marker expression\\n\"\n            \"    name; (extra == 'example'\\n\"\n            \"          ~~~~~~~~~~~~~~~~~~~^\"\n        )\n\n    def test_error_no_url_after_at(self) -> None:\n        # GIVEN\n        to_parse = \"name @ \"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected URL after @\\n\"\n            \"    name @ \\n\"\n            \"           ^\"\n        )\n\n    def test_error_invalid_marker_lvalue(self) -> None:\n        # GIVEN\n        to_parse = \"name; invalid_name\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected a marker variable or quoted string\\n\"\n            \"    name; invalid_name\\n\"\n            \"          ^\"\n        )\n\n    def test_error_invalid_marker_rvalue(self) -> None:\n        # GIVEN\n        to_parse = \"name; '3.7' <= invalid_name\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected a marker variable or quoted string\\n\"\n            \"    name; '3.7' <= invalid_name\\n\"\n            \"                   ^\"\n        )\n\n    def test_error_invalid_marker_notin_without_whitespace(self) -> None:\n        # GIVEN\n        to_parse = \"name; '3.7' notin python_version\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected marker operator, one of <=, <, !=, ==, >=, >, ~=, ===, \"\n            \"in, not in\\n\"\n            \"    name; '3.7' notin python_version\\n\"\n            \"                ^\"\n        )\n\n    def test_error_when_no_word_boundary(self) -> None:\n        # GIVEN\n        to_parse = \"name; '3.6'inpython_version\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected marker operator, one of <=, <, !=, ==, >=, >, ~=, ===, \"\n            \"in, not in\\n\"\n            \"    name; '3.6'inpython_version\\n\"\n            \"               ^\"\n        )\n\n    def test_error_invalid_marker_not_without_in(self) -> None:\n        # GIVEN\n        to_parse = \"name; '3.7' not python_version\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected 'in' after 'not'\\n\"\n            \"    name; '3.7' not python_version\\n\"\n            \"                    ^\"\n        )\n\n    def test_error_invalid_marker_with_invalid_op(self) -> None:\n        # GIVEN\n        to_parse = \"name; '3.7' ~ python_version\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected marker operator, one of <=, <, !=, ==, >=, >, ~=, ===, \"\n            \"in, not in\\n\"\n            \"    name; '3.7' ~ python_version\\n\"\n            \"                ^\"\n        )\n\n    def test_error_on_legacy_version_outside_triple_equals(self) -> None:\n        # GIVEN\n        to_parse = \"name==1.0.org1\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected end or semicolon (after version specifier)\\n\"\n            \"    name==1.0.org1\\n\"\n            \"        ~~~~~^\"\n        )\n\n    def test_error_on_missing_version_after_op(self) -> None:\n        # GIVEN\n        to_parse = \"name==\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected end or semicolon (after name and no valid version specifier)\\n\"\n            \"    name==\\n\"\n            \"        ^\"\n        )\n\n    def test_error_on_missing_op_after_name(self) -> None:\n        # GIVEN\n        to_parse = \"name 1.0\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected end or semicolon (after name and no valid version specifier)\\n\"\n            \"    name 1.0\\n\"\n            \"         ^\"\n        )\n\n    def test_error_on_random_char_after_specifier(self) -> None:\n        # GIVEN\n        to_parse = \"name >= 1.0 #\"\n\n        # WHEN\n        with pytest.raises(InvalidRequirement) as ctx:\n            Requirement(to_parse)\n\n        # THEN\n        assert ctx.exconly() == (\n            \"packaging.requirements.InvalidRequirement: \"\n            \"Expected end or semicolon (after version specifier)\\n\"\n            \"    name >= 1.0 #\\n\"\n            \"         ~~~~~~~^\"\n        )\n\n\nclass TestRequirementBehaviour:\n    def test_types_with_nothing(self) -> None:\n        # GIVEN\n        to_parse = \"foobar\"\n\n        # WHEN\n        req = Requirement(to_parse)\n\n        # THEN\n        assert isinstance(req.name, str)\n        assert isinstance(req.extras, set)\n        assert req.url is None\n        assert isinstance(req.specifier, SpecifierSet)\n        assert req.marker is None\n\n    def test_types_with_specifier_and_marker(self) -> None:\n        # GIVEN\n        to_parse = \"foobar[quux]<2,>=3; os_name=='a'\"\n\n        # WHEN\n        req = Requirement(to_parse)\n\n        # THEN\n        assert isinstance(req.name, str)\n        assert isinstance(req.extras, set)\n        assert req.url is None\n        assert isinstance(req.specifier, SpecifierSet)\n        assert isinstance(req.marker, Marker)\n\n    def test_types_with_url(self) -> None:\n        req = Requirement(\"foobar @ http://foo.com\")\n        assert isinstance(req.name, str)\n        assert isinstance(req.extras, set)\n        assert isinstance(req.url, str)\n        assert isinstance(req.specifier, SpecifierSet)\n        assert req.marker is None\n\n    @pytest.mark.parametrize(\n        \"url_or_specifier\",\n        [\"\", \"@ https://url \", \"!=2.0\", \"==2.*\"],\n    )\n    @pytest.mark.parametrize(\"extras\", [\"\", \"[a]\", \"[a,b]\", \"[a1,b1,b2]\"])\n    @pytest.mark.parametrize(\n        \"marker\",\n        [\"\", '; python_version == \"3.11\"', '; \"3.\" not in python_version'],\n    )\n    def test_str_and_repr(\n        self, extras: str, url_or_specifier: str, marker: str\n    ) -> None:\n        # GIVEN\n        to_parse = f\"name{extras}{url_or_specifier}{marker}\"\n\n        # WHEN\n        req = Requirement(to_parse)\n\n        # THEN\n        assert str(req) == to_parse.strip()\n        assert repr(req) == f\"<Requirement({to_parse.strip()!r})>\"\n\n    @pytest.mark.parametrize(\"dep1, dep2\", EQUAL_DEPENDENCIES)\n    def test_equal_reqs_equal_hashes(self, dep1: str, dep2: str) -> None:\n        \"\"\"Requirement objects created from equal strings should be equal.\"\"\"\n        # GIVEN / WHEN\n        req1, req2 = Requirement(dep1), Requirement(dep2)\n\n        assert req1 == req2\n        assert hash(req1) == hash(req2)\n\n    @pytest.mark.parametrize(\"dep1, dep2\", EQUIVALENT_DEPENDENCIES)\n    def test_equivalent_reqs_equal_hashes_unequal_strings(\n        self, dep1: str, dep2: str\n    ) -> None:\n        \"\"\"Requirement objects created from equivalent strings should be equal,\n        even though their string representation will not.\"\"\"\n        # GIVEN / WHEN\n        req1, req2 = Requirement(dep1), Requirement(dep2)\n\n        assert req1 == req2\n        assert hash(req1) == hash(req2)\n        assert str(req1) != str(req2)\n\n    @pytest.mark.parametrize(\"dep1, dep2\", DIFFERENT_DEPENDENCIES)\n    def test_different_reqs_different_hashes(self, dep1: str, dep2: str) -> None:\n        \"\"\"Requirement objects created from non-equivalent strings should differ.\"\"\"\n        # GIVEN / WHEN\n        req1, req2 = Requirement(dep1), Requirement(dep2)\n\n        # THEN\n        assert req1 != req2\n        assert hash(req1) != hash(req2)\n\n    def test_compare_with_string(self) -> None:\n        assert Requirement(\"packaging>=21.3\") != \"packaging>=21.3\"\n", "tests/test_manylinux.py": "try:\n    import ctypes\nexcept ImportError:\n    ctypes = None\nimport os\nimport pathlib\nimport platform\nimport sys\nimport types\nimport warnings\n\nimport pretend\nimport pytest\n\nfrom packaging import _manylinux\nfrom packaging._manylinux import (\n    _get_glibc_version,\n    _glibc_version_string,\n    _glibc_version_string_confstr,\n    _glibc_version_string_ctypes,\n    _is_compatible,\n    _parse_elf,\n    _parse_glibc_version,\n)\n\n\n@pytest.fixture(autouse=True)\ndef clear_lru_cache():\n    yield\n    _get_glibc_version.cache_clear()\n\n\n@pytest.fixture\ndef manylinux_module(monkeypatch):\n    monkeypatch.setattr(_manylinux, \"_get_glibc_version\", lambda *args: (2, 20))\n    module_name = \"_manylinux\"\n    module = types.ModuleType(module_name)\n    monkeypatch.setitem(sys.modules, module_name, module)\n    return module\n\n\n@pytest.mark.parametrize(\"tf\", (True, False))\n@pytest.mark.parametrize(\n    \"attribute,glibc\", ((\"1\", (2, 5)), (\"2010\", (2, 12)), (\"2014\", (2, 17)))\n)\ndef test_module_declaration(monkeypatch, manylinux_module, attribute, glibc, tf):\n    manylinux = f\"manylinux{attribute}_compatible\"\n    monkeypatch.setattr(manylinux_module, manylinux, tf, raising=False)\n    res = _is_compatible(\"x86_64\", glibc)\n    assert tf is res\n\n\n@pytest.mark.parametrize(\n    \"attribute,glibc\", ((\"1\", (2, 5)), (\"2010\", (2, 12)), (\"2014\", (2, 17)))\n)\ndef test_module_declaration_missing_attribute(\n    monkeypatch, manylinux_module, attribute, glibc\n):\n    manylinux = f\"manylinux{attribute}_compatible\"\n    monkeypatch.delattr(manylinux_module, manylinux, raising=False)\n    assert _is_compatible(\"x86_64\", glibc)\n\n\n@pytest.mark.parametrize(\n    \"version,compatible\", (((2, 0), True), ((2, 5), True), ((2, 10), False))\n)\ndef test_is_manylinux_compatible_glibc_support(version, compatible, monkeypatch):\n    monkeypatch.setitem(sys.modules, \"_manylinux\", None)\n    monkeypatch.setattr(_manylinux, \"_get_glibc_version\", lambda: (2, 5))\n    assert bool(_is_compatible(\"any\", version)) == compatible\n\n\n@pytest.mark.parametrize(\"version_str\", [\"glibc-2.4.5\", \"2\"])\ndef test_check_glibc_version_warning(version_str):\n    with warnings.catch_warnings(record=True) as w:\n        _parse_glibc_version(version_str)\n        assert len(w) == 1\n        assert issubclass(w[0].category, RuntimeWarning)\n\n\n@pytest.mark.skipif(not ctypes, reason=\"requires ctypes\")\n@pytest.mark.parametrize(\n    \"version_str,expected\",\n    [\n        # Be very explicit about bytes and Unicode for Python 2 testing.\n        (b\"2.4\", \"2.4\"),\n        (\"2.4\", \"2.4\"),\n    ],\n)\ndef test_glibc_version_string(version_str, expected, monkeypatch):\n    class LibcVersion:\n        def __init__(self, version_str):\n            self.version_str = version_str\n\n        def __call__(self):\n            return version_str\n\n    class ProcessNamespace:\n        def __init__(self, libc_version):\n            self.gnu_get_libc_version = libc_version\n\n    process_namespace = ProcessNamespace(LibcVersion(version_str))\n    monkeypatch.setattr(ctypes, \"CDLL\", lambda _: process_namespace)\n    monkeypatch.setattr(_manylinux, \"_glibc_version_string_confstr\", lambda: False)\n\n    assert _glibc_version_string() == expected\n\n    del process_namespace.gnu_get_libc_version\n    assert _glibc_version_string() is None\n\n\ndef test_glibc_version_string_confstr(monkeypatch):\n    monkeypatch.setattr(os, \"confstr\", lambda x: \"glibc 2.20\", raising=False)\n    assert _glibc_version_string_confstr() == \"2.20\"\n\n\ndef test_glibc_version_string_fail(monkeypatch):\n    monkeypatch.setattr(os, \"confstr\", lambda x: None, raising=False)\n    monkeypatch.setitem(sys.modules, \"ctypes\", None)\n    assert _glibc_version_string() is None\n    assert _get_glibc_version() == (-1, -1)\n\n\n@pytest.mark.parametrize(\n    \"failure\",\n    [pretend.raiser(ValueError), pretend.raiser(OSError), lambda x: \"XXX\"],\n)\ndef test_glibc_version_string_confstr_fail(monkeypatch, failure):\n    monkeypatch.setattr(os, \"confstr\", failure, raising=False)\n    assert _glibc_version_string_confstr() is None\n\n\ndef test_glibc_version_string_confstr_missing(monkeypatch):\n    monkeypatch.delattr(os, \"confstr\", raising=False)\n    assert _glibc_version_string_confstr() is None\n\n\ndef test_glibc_version_string_ctypes_missing(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ctypes\", None)\n    assert _glibc_version_string_ctypes() is None\n\n\n@pytest.mark.xfail(ctypes is None, reason=\"ctypes not available\")\ndef test_glibc_version_string_ctypes_raise_oserror(monkeypatch):\n    def patched_cdll(name):\n        raise OSError(\"Dynamic loading not supported\")\n\n    monkeypatch.setattr(ctypes, \"CDLL\", patched_cdll)\n    assert _glibc_version_string_ctypes() is None\n\n\n@pytest.mark.skipif(platform.system() != \"Linux\", reason=\"requires Linux\")\ndef test_is_manylinux_compatible_old():\n    # Assuming no one is running this test with a version of glibc released in\n    # 1997.\n    assert _is_compatible(\"any\", (2, 0))\n\n\ndef test_is_manylinux_compatible(monkeypatch):\n    monkeypatch.setattr(_manylinux, \"_glibc_version_string\", lambda: \"2.4\")\n    assert _is_compatible(\"any\", (2, 4))\n\n\ndef test_glibc_version_string_none(monkeypatch):\n    monkeypatch.setattr(_manylinux, \"_glibc_version_string\", lambda: None)\n    assert not _is_compatible(\"any\", (2, 4))\n\n\n@pytest.mark.parametrize(\n    \"content\", [None, \"invalid-magic\", \"invalid-class\", \"invalid-data\", \"too-short\"]\n)\ndef test_parse_elf_bad_executable(monkeypatch, content):\n    if content:\n        path = pathlib.Path(__file__).parent / \"manylinux\" / f\"hello-world-{content}\"\n        path = os.fsdecode(path)\n    else:\n        path = None\n    with _parse_elf(path) as ef:\n        assert ef is None\n", "tests/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/test_structures.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pytest\n\nfrom packaging._structures import Infinity, NegativeInfinity\n\n\ndef test_infinity_repr():\n    assert repr(Infinity) == \"Infinity\"\n\n\ndef test_negative_infinity_repr():\n    assert repr(NegativeInfinity) == \"-Infinity\"\n\n\ndef test_infinity_hash():\n    assert hash(Infinity) == hash(Infinity)\n\n\ndef test_negative_infinity_hash():\n    assert hash(NegativeInfinity) == hash(NegativeInfinity)\n\n\n@pytest.mark.parametrize(\"left\", [1, \"a\", (\"b\", 4)])\ndef test_infinity_comparison(left):\n    assert left < Infinity\n    assert left <= Infinity\n    assert not left == Infinity\n    assert left != Infinity\n    assert not left > Infinity\n    assert not left >= Infinity\n\n\n@pytest.mark.parametrize(\"left\", [1, \"a\", (\"b\", 4)])\ndef test_negative_infinity_lesser(left):\n    assert not left < NegativeInfinity\n    assert not left <= NegativeInfinity\n    assert not left == NegativeInfinity\n    assert left != NegativeInfinity\n    assert left > NegativeInfinity\n    assert left >= NegativeInfinity\n\n\ndef test_infinity_equal():\n    assert Infinity == Infinity\n\n\ndef test_negative_infinity_equal():\n    assert NegativeInfinity == NegativeInfinity\n\n\ndef test_negate_infinity():\n    assert isinstance(-Infinity, NegativeInfinity.__class__)\n\n\ndef test_negate_negative_infinity():\n    assert isinstance(-NegativeInfinity, Infinity.__class__)\n", "tests/test_utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pytest\n\nfrom packaging.tags import Tag\nfrom packaging.utils import (\n    InvalidName,\n    InvalidSdistFilename,\n    InvalidWheelFilename,\n    canonicalize_name,\n    canonicalize_version,\n    is_normalized_name,\n    parse_sdist_filename,\n    parse_wheel_filename,\n)\nfrom packaging.version import Version\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected\"),\n    [\n        (\"foo\", \"foo\"),\n        (\"Foo\", \"foo\"),\n        (\"fOo\", \"foo\"),\n        (\"foo.bar\", \"foo-bar\"),\n        (\"Foo.Bar\", \"foo-bar\"),\n        (\"Foo.....Bar\", \"foo-bar\"),\n        (\"foo_bar\", \"foo-bar\"),\n        (\"foo___bar\", \"foo-bar\"),\n        (\"foo-bar\", \"foo-bar\"),\n        (\"foo----bar\", \"foo-bar\"),\n    ],\n)\ndef test_canonicalize_name(name, expected):\n    assert canonicalize_name(name) == expected\n\n\ndef test_canonicalize_name_invalid():\n    with pytest.raises(InvalidName):\n        canonicalize_name(\"_not_legal\", validate=True)\n    assert canonicalize_name(\"_not_legal\") == \"-not-legal\"\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected\"),\n    [\n        (\"foo\", \"foo\"),\n        (\"Foo\", \"foo\"),\n        (\"fOo\", \"foo\"),\n        (\"foo.bar\", \"foo-bar\"),\n        (\"Foo.Bar\", \"foo-bar\"),\n        (\"Foo.....Bar\", \"foo-bar\"),\n        (\"foo_bar\", \"foo-bar\"),\n        (\"foo___bar\", \"foo-bar\"),\n        (\"foo-bar\", \"foo-bar\"),\n        (\"foo----bar\", \"foo-bar\"),\n    ],\n)\ndef test_is_normalized_name(name, expected):\n    assert is_normalized_name(expected)\n    if name != expected:\n        assert not is_normalized_name(name)\n\n\n@pytest.mark.parametrize(\n    (\"version\", \"expected\"),\n    [\n        (Version(\"1.4.0\"), \"1.4\"),\n        (\"1.4.0\", \"1.4\"),\n        (\"1.40.0\", \"1.40\"),\n        (\"1.4.0.0.00.000.0000\", \"1.4\"),\n        (\"1.0\", \"1\"),\n        (\"1.0+abc\", \"1+abc\"),\n        (\"1.0.dev0\", \"1.dev0\"),\n        (\"1.0.post0\", \"1.post0\"),\n        (\"1.0a0\", \"1a0\"),\n        (\"1.0rc0\", \"1rc0\"),\n        (\"100!0.0\", \"100!0\"),\n        # improper version strings are unchanged\n        (\"lolwat\", \"lolwat\"),\n        (\"1.0.1-test7\", \"1.0.1-test7\"),\n    ],\n)\ndef test_canonicalize_version(version, expected):\n    assert canonicalize_version(version) == expected\n\n\n@pytest.mark.parametrize((\"version\"), [\"1.4.0\", \"1.0\"])\ndef test_canonicalize_version_no_strip_trailing_zero(version):\n    assert canonicalize_version(version, strip_trailing_zero=False) == version\n\n\n@pytest.mark.parametrize(\n    (\"filename\", \"name\", \"version\", \"build\", \"tags\"),\n    [\n        (\n            \"foo-1.0-py3-none-any.whl\",\n            \"foo\",\n            Version(\"1.0\"),\n            (),\n            {Tag(\"py3\", \"none\", \"any\")},\n        ),\n        (\n            \"some_PACKAGE-1.0-py3-none-any.whl\",\n            \"some-package\",\n            Version(\"1.0\"),\n            (),\n            {Tag(\"py3\", \"none\", \"any\")},\n        ),\n        (\n            \"foo-1.0-1000-py3-none-any.whl\",\n            \"foo\",\n            Version(\"1.0\"),\n            (1000, \"\"),\n            {Tag(\"py3\", \"none\", \"any\")},\n        ),\n        (\n            \"foo-1.0-1000abc-py3-none-any.whl\",\n            \"foo\",\n            Version(\"1.0\"),\n            (1000, \"abc\"),\n            {Tag(\"py3\", \"none\", \"any\")},\n        ),\n    ],\n)\ndef test_parse_wheel_filename(filename, name, version, build, tags):\n    assert parse_wheel_filename(filename) == (name, version, build, tags)\n\n\n@pytest.mark.parametrize(\n    (\"filename\"),\n    [\n        (\"foo-1.0.whl\"),  # Missing tags\n        (\"foo-1.0-py3-none-any.wheel\"),  # Incorrect file extension (`.wheel`)\n        (\"foo__bar-1.0-py3-none-any.whl\"),  # Invalid name (`__`)\n        (\"foo#bar-1.0-py3-none-any.whl\"),  # Invalid name (`#`)\n        (\"foobar-1.x-py3-none-any.whl\"),  # Invalid version (`1.x`)\n        # Build number doesn't start with a digit (`abc`)\n        (\"foo-1.0-abc-py3-none-any.whl\"),\n        (\"foo-1.0-200-py3-none-any-junk.whl\"),  # Too many dashes (`-junk`)\n    ],\n)\ndef test_parse_wheel_invalid_filename(filename):\n    with pytest.raises(InvalidWheelFilename):\n        parse_wheel_filename(filename)\n\n\n@pytest.mark.parametrize(\n    (\"filename\", \"name\", \"version\"),\n    [(\"foo-1.0.tar.gz\", \"foo\", Version(\"1.0\")), (\"foo-1.0.zip\", \"foo\", Version(\"1.0\"))],\n)\ndef test_parse_sdist_filename(filename, name, version):\n    assert parse_sdist_filename(filename) == (name, version)\n\n\n@pytest.mark.parametrize(\n    (\"filename\"),\n    [\n        (\"foo-1.0.xz\"),  # Incorrect extension\n        (\"foo1.0.tar.gz\"),  # Missing separator\n        (\"foo-1.x.tar.gz\"),  # Invalid version\n    ],\n)\ndef test_parse_sdist_invalid_filename(filename):\n    with pytest.raises(InvalidSdistFilename):\n        parse_sdist_filename(filename)\n", "src/packaging/tags.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Iterable,\n    Iterator,\n    Sequence,\n    Tuple,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> frozenset[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> int | str | None:\n    value: int | str | None = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: list[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> list[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: PythonVersion | None = None,\n    abis: Iterable[str] | None = None,\n    platforms: Iterable[str] | None = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                interpreter = \"cp{version}\".format(\n                    version=_version_nodot((python_version[0], minor_version))\n                )\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> list[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: str | None = None,\n    abis: Iterable[str] | None = None,\n    platforms: Iterable[str] | None = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: PythonVersion | None = None,\n    interpreter: str | None = None,\n    platforms: Iterable[str] | None = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: MacVersion, cpu_arch: str) -> list[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: MacVersion | None = None, arch: str | None = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        for minor_version in range(version[1], -1, -1):\n            compat_version = 10, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=10, minor=minor_version, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, 0\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=major_version, minor=0, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                        major=compat_version[0],\n                        minor=compat_version[1],\n                        binary_format=binary_format,\n                    )\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_format = \"universal2\"\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=compat_version[0],\n                    minor=compat_version[1],\n                    binary_format=binary_format,\n                )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n", "src/packaging/_musllinux.py": "\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> _MuslVersion | None:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache\ndef _get_musl_version(executable: str) -> _MuslVersion | None:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n", "src/packaging/_manylinux.py": "from __future__ import annotations\n\nimport collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Generator, Iterator, NamedTuple, Sequence\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[ELFFile | None, None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> str | None:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: str | None = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> str | None:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> str | None:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache\ndef _get_glibc_version() -> tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n", "src/packaging/_tokenizer.py": "from __future__ import annotations\n\nimport contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Iterator, NoReturn\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: dict[str, str | re.Pattern[str]] = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: dict[str, str | re.Pattern[str]],\n    ) -> None:\n        self.source = source\n        self.rules: dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Token | None = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: int | None = None,\n        span_end: int | None = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n", "src/packaging/_structures.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n", "src/packaging/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\ndef canonicalize_version(\n    version: Version | str, *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)\n        except InvalidVersion:\n            # Legacy versions cannot be normalized\n            return version\n    else:\n        parsed = version\n\n    parts = []\n\n    # Epoch\n    if parsed.epoch != 0:\n        parts.append(f\"{parsed.epoch}!\")\n\n    # Release segment\n    release_segment = \".\".join(str(x) for x in parsed.release)\n    if strip_trailing_zero:\n        # NB: This strips trailing '.0's to normalize\n        release_segment = re.sub(r\"(\\.0)+$\", \"\", release_segment)\n    parts.append(release_segment)\n\n    # Pre-release\n    if parsed.pre is not None:\n        parts.append(\"\".join(str(x) for x in parsed.pre))\n\n    # Post-release\n    if parsed.post is not None:\n        parts.append(f\".post{parsed.post}\")\n\n    # Development release\n    if parsed.dev is not None:\n        parts.append(f\".dev{parsed.dev}\")\n\n    # Local version segment\n    if parsed.local is not None:\n        parts.append(f\"+{parsed.local}\")\n\n    return \"\".join(parts)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> tuple[NormalizedName, Version, BuildTag, frozenset[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in '{filename}'\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename}\"\n        ) from e\n\n    return (name, version)\n", "src/packaging/version.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.version import parse, Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: tuple[int, ...]\n    dev: tuple[str, int] | None\n    pre: tuple[str, int] | None\n    post: tuple[str, int] | None\n    local: LocalType | None\n\n\ndef parse(version: str) -> Version:\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: '{version}'\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be rounded-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> tuple[str, int] | None:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> int | None:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> int | None:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> str | None:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc.dev1\").public\n        '1.2.3'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3+abc.dev1\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\ndef _parse_letter_version(\n    letter: str | None, number: str | bytes | SupportsInt | None\n) -> tuple[str, int] | None:\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n    if not letter and number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: str | None) -> LocalType | None:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: tuple[int, ...],\n    pre: tuple[str, int] | None,\n    post: tuple[str, int] | None,\n    dev: tuple[str, int] | None,\n    local: LocalType | None,\n) -> CmpKey:\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n", "src/packaging/_elffile.py": "\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nfrom __future__ import annotations\n\nimport enum\nimport os\nimport struct\nfrom typing import IO\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            )\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> str | None:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n", "src/packaging/requirements.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\nfrom __future__ import annotations\n\nfrom typing import Any, Iterator\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: str | None = parsed.url or None\n        self.extras: set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Marker | None = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n", "src/packaging/_parser.py": "\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains EBNF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nfrom typing import NamedTuple, Sequence, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\nMarkerAtom = Union[MarkerItem, Sequence[\"MarkerAtom\"]]\nMarkerList = Sequence[Union[\"MarkerList\", MarkerAtom, str]]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: list[str]\n    specifier: str\n    marker: MarkerList | None\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> tuple[str, str, MarkerList | None]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> list[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> list[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: list[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n", "src/packaging/metadata.py": "from __future__ import annotations\n\nimport email.feedparser\nimport email.header\nimport email.message\nimport email.parser\nimport email.policy\nimport typing\nfrom typing import (\n    Any,\n    Callable,\n    Generic,\n    Literal,\n    TypedDict,\n    cast,\n)\n\nfrom . import requirements, specifiers, utils\nfrom . import version as version_module\n\nT = typing.TypeVar(\"T\")\n\n\ntry:\n    ExceptionGroup\nexcept NameError:  # pragma: no cover\n\n    class ExceptionGroup(Exception):\n        \"\"\"A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.\n\n        If :external:exc:`ExceptionGroup` is already defined by Python itself,\n        that version is used instead.\n        \"\"\"\n\n        message: str\n        exceptions: list[Exception]\n\n        def __init__(self, message: str, exceptions: list[Exception]) -> None:\n            self.message = message\n            self.exceptions = exceptions\n\n        def __repr__(self) -> str:\n            return f\"{self.__class__.__name__}({self.message!r}, {self.exceptions!r})\"\n\nelse:  # pragma: no cover\n    ExceptionGroup = ExceptionGroup\n\n\nclass InvalidMetadata(ValueError):\n    \"\"\"A metadata field contains invalid data.\"\"\"\n\n    field: str\n    \"\"\"The name of the field that contains invalid data.\"\"\"\n\n    def __init__(self, field: str, message: str) -> None:\n        self.field = field\n        super().__init__(message)\n\n\n# The RawMetadata class attempts to make as few assumptions about the underlying\n# serialization formats as possible. The idea is that as long as a serialization\n# formats offer some very basic primitives in *some* way then we can support\n# serializing to and from that format.\nclass RawMetadata(TypedDict, total=False):\n    \"\"\"A dictionary of raw core metadata.\n\n    Each field in core metadata maps to a key of this dictionary (when data is\n    provided). The key is lower-case and underscores are used instead of dashes\n    compared to the equivalent core metadata field. Any core metadata field that\n    can be specified multiple times or can hold multiple values in a single\n    field have a key with a plural name. See :class:`Metadata` whose attributes\n    match the keys of this dictionary.\n\n    Core metadata fields that can be specified multiple times are stored as a\n    list or dict depending on which is appropriate for the field. Any fields\n    which hold multiple values in a single field are stored as a list.\n\n    \"\"\"\n\n    # Metadata 1.0 - PEP 241\n    metadata_version: str\n    name: str\n    version: str\n    platforms: list[str]\n    summary: str\n    description: str\n    keywords: list[str]\n    home_page: str\n    author: str\n    author_email: str\n    license: str\n\n    # Metadata 1.1 - PEP 314\n    supported_platforms: list[str]\n    download_url: str\n    classifiers: list[str]\n    requires: list[str]\n    provides: list[str]\n    obsoletes: list[str]\n\n    # Metadata 1.2 - PEP 345\n    maintainer: str\n    maintainer_email: str\n    requires_dist: list[str]\n    provides_dist: list[str]\n    obsoletes_dist: list[str]\n    requires_python: str\n    requires_external: list[str]\n    project_urls: dict[str, str]\n\n    # Metadata 2.0\n    # PEP 426 attempted to completely revamp the metadata format\n    # but got stuck without ever being able to build consensus on\n    # it and ultimately ended up withdrawn.\n    #\n    # However, a number of tools had started emitting METADATA with\n    # `2.0` Metadata-Version, so for historical reasons, this version\n    # was skipped.\n\n    # Metadata 2.1 - PEP 566\n    description_content_type: str\n    provides_extra: list[str]\n\n    # Metadata 2.2 - PEP 643\n    dynamic: list[str]\n\n    # Metadata 2.3 - PEP 685\n    # No new fields were added in PEP 685, just some edge case were\n    # tightened up to provide better interoptability.\n\n\n_STRING_FIELDS = {\n    \"author\",\n    \"author_email\",\n    \"description\",\n    \"description_content_type\",\n    \"download_url\",\n    \"home_page\",\n    \"license\",\n    \"maintainer\",\n    \"maintainer_email\",\n    \"metadata_version\",\n    \"name\",\n    \"requires_python\",\n    \"summary\",\n    \"version\",\n}\n\n_LIST_FIELDS = {\n    \"classifiers\",\n    \"dynamic\",\n    \"obsoletes\",\n    \"obsoletes_dist\",\n    \"platforms\",\n    \"provides\",\n    \"provides_dist\",\n    \"provides_extra\",\n    \"requires\",\n    \"requires_dist\",\n    \"requires_external\",\n    \"supported_platforms\",\n}\n\n_DICT_FIELDS = {\n    \"project_urls\",\n}\n\n\ndef _parse_keywords(data: str) -> list[str]:\n    \"\"\"Split a string of comma-separate keyboards into a list of keywords.\"\"\"\n    return [k.strip() for k in data.split(\",\")]\n\n\ndef _parse_project_urls(data: list[str]) -> dict[str, str]:\n    \"\"\"Parse a list of label/URL string pairings separated by a comma.\"\"\"\n    urls = {}\n    for pair in data:\n        # Our logic is slightly tricky here as we want to try and do\n        # *something* reasonable with malformed data.\n        #\n        # The main thing that we have to worry about, is data that does\n        # not have a ',' at all to split the label from the Value. There\n        # isn't a singular right answer here, and we will fail validation\n        # later on (if the caller is validating) so it doesn't *really*\n        # matter, but since the missing value has to be an empty str\n        # and our return value is dict[str, str], if we let the key\n        # be the missing value, then they'd have multiple '' values that\n        # overwrite each other in a accumulating dict.\n        #\n        # The other potentional issue is that it's possible to have the\n        # same label multiple times in the metadata, with no solid \"right\"\n        # answer with what to do in that case. As such, we'll do the only\n        # thing we can, which is treat the field as unparseable and add it\n        # to our list of unparsed fields.\n        parts = [p.strip() for p in pair.split(\",\", 1)]\n        parts.extend([\"\"] * (max(0, 2 - len(parts))))  # Ensure 2 items\n\n        # TODO: The spec doesn't say anything about if the keys should be\n        #       considered case sensitive or not... logically they should\n        #       be case-preserving and case-insensitive, but doing that\n        #       would open up more cases where we might have duplicate\n        #       entries.\n        label, url = parts\n        if label in urls:\n            # The label already exists in our set of urls, so this field\n            # is unparseable, and we can just add the whole thing to our\n            # unparseable data and stop processing it.\n            raise KeyError(\"duplicate labels in project urls\")\n        urls[label] = url\n\n    return urls\n\n\ndef _get_payload(msg: email.message.Message, source: bytes | str) -> str:\n    \"\"\"Get the body of the message.\"\"\"\n    # If our source is a str, then our caller has managed encodings for us,\n    # and we don't need to deal with it.\n    if isinstance(source, str):\n        payload: str = msg.get_payload()\n        return payload\n    # If our source is a bytes, then we're managing the encoding and we need\n    # to deal with it.\n    else:\n        bpayload: bytes = msg.get_payload(decode=True)\n        try:\n            return bpayload.decode(\"utf8\", \"strict\")\n        except UnicodeDecodeError:\n            raise ValueError(\"payload in an invalid encoding\")\n\n\n# The various parse_FORMAT functions here are intended to be as lenient as\n# possible in their parsing, while still returning a correctly typed\n# RawMetadata.\n#\n# To aid in this, we also generally want to do as little touching of the\n# data as possible, except where there are possibly some historic holdovers\n# that make valid data awkward to work with.\n#\n# While this is a lower level, intermediate format than our ``Metadata``\n# class, some light touch ups can make a massive difference in usability.\n\n# Map METADATA fields to RawMetadata.\n_EMAIL_TO_RAW_MAPPING = {\n    \"author\": \"author\",\n    \"author-email\": \"author_email\",\n    \"classifier\": \"classifiers\",\n    \"description\": \"description\",\n    \"description-content-type\": \"description_content_type\",\n    \"download-url\": \"download_url\",\n    \"dynamic\": \"dynamic\",\n    \"home-page\": \"home_page\",\n    \"keywords\": \"keywords\",\n    \"license\": \"license\",\n    \"maintainer\": \"maintainer\",\n    \"maintainer-email\": \"maintainer_email\",\n    \"metadata-version\": \"metadata_version\",\n    \"name\": \"name\",\n    \"obsoletes\": \"obsoletes\",\n    \"obsoletes-dist\": \"obsoletes_dist\",\n    \"platform\": \"platforms\",\n    \"project-url\": \"project_urls\",\n    \"provides\": \"provides\",\n    \"provides-dist\": \"provides_dist\",\n    \"provides-extra\": \"provides_extra\",\n    \"requires\": \"requires\",\n    \"requires-dist\": \"requires_dist\",\n    \"requires-external\": \"requires_external\",\n    \"requires-python\": \"requires_python\",\n    \"summary\": \"summary\",\n    \"supported-platform\": \"supported_platforms\",\n    \"version\": \"version\",\n}\n_RAW_TO_EMAIL_MAPPING = {raw: email for email, raw in _EMAIL_TO_RAW_MAPPING.items()}\n\n\ndef parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]:\n    \"\"\"Parse a distribution's metadata stored as email headers (e.g. from ``METADATA``).\n\n    This function returns a two-item tuple of dicts. The first dict is of\n    recognized fields from the core metadata specification. Fields that can be\n    parsed and translated into Python's built-in types are converted\n    appropriately. All other fields are left as-is. Fields that are allowed to\n    appear multiple times are stored as lists.\n\n    The second dict contains all other fields from the metadata. This includes\n    any unrecognized fields. It also includes any fields which are expected to\n    be parsed into a built-in type but were not formatted appropriately. Finally,\n    any fields that are expected to appear only once but are repeated are\n    included in this dict.\n\n    \"\"\"\n    raw: dict[str, str | list[str] | dict[str, str]] = {}\n    unparsed: dict[str, list[str]] = {}\n\n    if isinstance(data, str):\n        parsed = email.parser.Parser(policy=email.policy.compat32).parsestr(data)\n    else:\n        parsed = email.parser.BytesParser(policy=email.policy.compat32).parsebytes(data)\n\n    # We have to wrap parsed.keys() in a set, because in the case of multiple\n    # values for a key (a list), the key will appear multiple times in the\n    # list of keys, but we're avoiding that by using get_all().\n    for name in frozenset(parsed.keys()):\n        # Header names in RFC are case insensitive, so we'll normalize to all\n        # lower case to make comparisons easier.\n        name = name.lower()\n\n        # We use get_all() here, even for fields that aren't multiple use,\n        # because otherwise someone could have e.g. two Name fields, and we\n        # would just silently ignore it rather than doing something about it.\n        headers = parsed.get_all(name) or []\n\n        # The way the email module works when parsing bytes is that it\n        # unconditionally decodes the bytes as ascii using the surrogateescape\n        # handler. When you pull that data back out (such as with get_all() ),\n        # it looks to see if the str has any surrogate escapes, and if it does\n        # it wraps it in a Header object instead of returning the string.\n        #\n        # As such, we'll look for those Header objects, and fix up the encoding.\n        value = []\n        # Flag if we have run into any issues processing the headers, thus\n        # signalling that the data belongs in 'unparsed'.\n        valid_encoding = True\n        for h in headers:\n            # It's unclear if this can return more types than just a Header or\n            # a str, so we'll just assert here to make sure.\n            assert isinstance(h, (email.header.Header, str))\n\n            # If it's a header object, we need to do our little dance to get\n            # the real data out of it. In cases where there is invalid data\n            # we're going to end up with mojibake, but there's no obvious, good\n            # way around that without reimplementing parts of the Header object\n            # ourselves.\n            #\n            # That should be fine since, if mojibacked happens, this key is\n            # going into the unparsed dict anyways.\n            if isinstance(h, email.header.Header):\n                # The Header object stores it's data as chunks, and each chunk\n                # can be independently encoded, so we'll need to check each\n                # of them.\n                chunks: list[tuple[bytes, str | None]] = []\n                for bin, encoding in email.header.decode_header(h):\n                    try:\n                        bin.decode(\"utf8\", \"strict\")\n                    except UnicodeDecodeError:\n                        # Enable mojibake.\n                        encoding = \"latin1\"\n                        valid_encoding = False\n                    else:\n                        encoding = \"utf8\"\n                    chunks.append((bin, encoding))\n\n                # Turn our chunks back into a Header object, then let that\n                # Header object do the right thing to turn them into a\n                # string for us.\n                value.append(str(email.header.make_header(chunks)))\n            # This is already a string, so just add it.\n            else:\n                value.append(h)\n\n        # We've processed all of our values to get them into a list of str,\n        # but we may have mojibake data, in which case this is an unparsed\n        # field.\n        if not valid_encoding:\n            unparsed[name] = value\n            continue\n\n        raw_name = _EMAIL_TO_RAW_MAPPING.get(name)\n        if raw_name is None:\n            # This is a bit of a weird situation, we've encountered a key that\n            # we don't know what it means, so we don't know whether it's meant\n            # to be a list or not.\n            #\n            # Since we can't really tell one way or another, we'll just leave it\n            # as a list, even though it may be a single item list, because that's\n            # what makes the most sense for email headers.\n            unparsed[name] = value\n            continue\n\n        # If this is one of our string fields, then we'll check to see if our\n        # value is a list of a single item. If it is then we'll assume that\n        # it was emitted as a single string, and unwrap the str from inside\n        # the list.\n        #\n        # If it's any other kind of data, then we haven't the faintest clue\n        # what we should parse it as, and we have to just add it to our list\n        # of unparsed stuff.\n        if raw_name in _STRING_FIELDS and len(value) == 1:\n            raw[raw_name] = value[0]\n        # If this is one of our list of string fields, then we can just assign\n        # the value, since email *only* has strings, and our get_all() call\n        # above ensures that this is a list.\n        elif raw_name in _LIST_FIELDS:\n            raw[raw_name] = value\n        # Special Case: Keywords\n        # The keywords field is implemented in the metadata spec as a str,\n        # but it conceptually is a list of strings, and is serialized using\n        # \", \".join(keywords), so we'll do some light data massaging to turn\n        # this into what it logically is.\n        elif raw_name == \"keywords\" and len(value) == 1:\n            raw[raw_name] = _parse_keywords(value[0])\n        # Special Case: Project-URL\n        # The project urls is implemented in the metadata spec as a list of\n        # specially-formatted strings that represent a key and a value, which\n        # is fundamentally a mapping, however the email format doesn't support\n        # mappings in a sane way, so it was crammed into a list of strings\n        # instead.\n        #\n        # We will do a little light data massaging to turn this into a map as\n        # it logically should be.\n        elif raw_name == \"project_urls\":\n            try:\n                raw[raw_name] = _parse_project_urls(value)\n            except KeyError:\n                unparsed[name] = value\n        # Nothing that we've done has managed to parse this, so it'll just\n        # throw it in our unparseable data and move on.\n        else:\n            unparsed[name] = value\n\n    # We need to support getting the Description from the message payload in\n    # addition to getting it from the the headers. This does mean, though, there\n    # is the possibility of it being set both ways, in which case we put both\n    # in 'unparsed' since we don't know which is right.\n    try:\n        payload = _get_payload(parsed, data)\n    except ValueError:\n        unparsed.setdefault(\"description\", []).append(\n            parsed.get_payload(decode=isinstance(data, bytes))\n        )\n    else:\n        if payload:\n            # Check to see if we've already got a description, if so then both\n            # it, and this body move to unparseable.\n            if \"description\" in raw:\n                description_header = cast(str, raw.pop(\"description\"))\n                unparsed.setdefault(\"description\", []).extend(\n                    [description_header, payload]\n                )\n            elif \"description\" in unparsed:\n                unparsed[\"description\"].append(payload)\n            else:\n                raw[\"description\"] = payload\n\n    # We need to cast our `raw` to a metadata, because a TypedDict only support\n    # literal key names, but we're computing our key names on purpose, but the\n    # way this function is implemented, our `TypedDict` can only have valid key\n    # names.\n    return cast(RawMetadata, raw), unparsed\n\n\n_NOT_FOUND = object()\n\n\n# Keep the two values in sync.\n_VALID_METADATA_VERSIONS = [\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\"]\n_MetadataVersion = Literal[\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\"]\n\n_REQUIRED_ATTRS = frozenset([\"metadata_version\", \"name\", \"version\"])\n\n\nclass _Validator(Generic[T]):\n    \"\"\"Validate a metadata field.\n\n    All _process_*() methods correspond to a core metadata field. The method is\n    called with the field's raw value. If the raw value is valid it is returned\n    in its \"enriched\" form (e.g. ``version.Version`` for the ``Version`` field).\n    If the raw value is invalid, :exc:`InvalidMetadata` is raised (with a cause\n    as appropriate).\n    \"\"\"\n\n    name: str\n    raw_name: str\n    added: _MetadataVersion\n\n    def __init__(\n        self,\n        *,\n        added: _MetadataVersion = \"1.0\",\n    ) -> None:\n        self.added = added\n\n    def __set_name__(self, _owner: Metadata, name: str) -> None:\n        self.name = name\n        self.raw_name = _RAW_TO_EMAIL_MAPPING[name]\n\n    def __get__(self, instance: Metadata, _owner: type[Metadata]) -> T:\n        # With Python 3.8, the caching can be replaced with functools.cached_property().\n        # No need to check the cache as attribute lookup will resolve into the\n        # instance's __dict__ before __get__ is called.\n        cache = instance.__dict__\n        value = instance._raw.get(self.name)\n\n        # To make the _process_* methods easier, we'll check if the value is None\n        # and if this field is NOT a required attribute, and if both of those\n        # things are true, we'll skip the the converter. This will mean that the\n        # converters never have to deal with the None union.\n        if self.name in _REQUIRED_ATTRS or value is not None:\n            try:\n                converter: Callable[[Any], T] = getattr(self, f\"_process_{self.name}\")\n            except AttributeError:\n                pass\n            else:\n                value = converter(value)\n\n        cache[self.name] = value\n        try:\n            del instance._raw[self.name]  # type: ignore[misc]\n        except KeyError:\n            pass\n\n        return cast(T, value)\n\n    def _invalid_metadata(\n        self, msg: str, cause: Exception | None = None\n    ) -> InvalidMetadata:\n        exc = InvalidMetadata(\n            self.raw_name, msg.format_map({\"field\": repr(self.raw_name)})\n        )\n        exc.__cause__ = cause\n        return exc\n\n    def _process_metadata_version(self, value: str) -> _MetadataVersion:\n        # Implicitly makes Metadata-Version required.\n        if value not in _VALID_METADATA_VERSIONS:\n            raise self._invalid_metadata(f\"{value!r} is not a valid metadata version\")\n        return cast(_MetadataVersion, value)\n\n    def _process_name(self, value: str) -> str:\n        if not value:\n            raise self._invalid_metadata(\"{field} is a required field\")\n        # Validate the name as a side-effect.\n        try:\n            utils.canonicalize_name(value, validate=True)\n        except utils.InvalidName as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            )\n        else:\n            return value\n\n    def _process_version(self, value: str) -> version_module.Version:\n        if not value:\n            raise self._invalid_metadata(\"{field} is a required field\")\n        try:\n            return version_module.parse(value)\n        except version_module.InvalidVersion as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            )\n\n    def _process_summary(self, value: str) -> str:\n        \"\"\"Check the field contains no newlines.\"\"\"\n        if \"\\n\" in value:\n            raise self._invalid_metadata(\"{field} must be a single line\")\n        return value\n\n    def _process_description_content_type(self, value: str) -> str:\n        content_types = {\"text/plain\", \"text/x-rst\", \"text/markdown\"}\n        message = email.message.EmailMessage()\n        message[\"content-type\"] = value\n\n        content_type, parameters = (\n            # Defaults to `text/plain` if parsing failed.\n            message.get_content_type().lower(),\n            message[\"content-type\"].params,\n        )\n        # Check if content-type is valid or defaulted to `text/plain` and thus was\n        # not parseable.\n        if content_type not in content_types or content_type not in value.lower():\n            raise self._invalid_metadata(\n                f\"{{field}} must be one of {list(content_types)}, not {value!r}\"\n            )\n\n        charset = parameters.get(\"charset\", \"UTF-8\")\n        if charset != \"UTF-8\":\n            raise self._invalid_metadata(\n                f\"{{field}} can only specify the UTF-8 charset, not {list(charset)}\"\n            )\n\n        markdown_variants = {\"GFM\", \"CommonMark\"}\n        variant = parameters.get(\"variant\", \"GFM\")  # Use an acceptable default.\n        if content_type == \"text/markdown\" and variant not in markdown_variants:\n            raise self._invalid_metadata(\n                f\"valid Markdown variants for {{field}} are {list(markdown_variants)}, \"\n                f\"not {variant!r}\",\n            )\n        return value\n\n    def _process_dynamic(self, value: list[str]) -> list[str]:\n        for dynamic_field in map(str.lower, value):\n            if dynamic_field in {\"name\", \"version\", \"metadata-version\"}:\n                raise self._invalid_metadata(\n                    f\"{value!r} is not allowed as a dynamic field\"\n                )\n            elif dynamic_field not in _EMAIL_TO_RAW_MAPPING:\n                raise self._invalid_metadata(f\"{value!r} is not a valid dynamic field\")\n        return list(map(str.lower, value))\n\n    def _process_provides_extra(\n        self,\n        value: list[str],\n    ) -> list[utils.NormalizedName]:\n        normalized_names = []\n        try:\n            for name in value:\n                normalized_names.append(utils.canonicalize_name(name, validate=True))\n        except utils.InvalidName as exc:\n            raise self._invalid_metadata(\n                f\"{name!r} is invalid for {{field}}\", cause=exc\n            )\n        else:\n            return normalized_names\n\n    def _process_requires_python(self, value: str) -> specifiers.SpecifierSet:\n        try:\n            return specifiers.SpecifierSet(value)\n        except specifiers.InvalidSpecifier as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            )\n\n    def _process_requires_dist(\n        self,\n        value: list[str],\n    ) -> list[requirements.Requirement]:\n        reqs = []\n        try:\n            for req in value:\n                reqs.append(requirements.Requirement(req))\n        except requirements.InvalidRequirement as exc:\n            raise self._invalid_metadata(f\"{req!r} is invalid for {{field}}\", cause=exc)\n        else:\n            return reqs\n\n\nclass Metadata:\n    \"\"\"Representation of distribution metadata.\n\n    Compared to :class:`RawMetadata`, this class provides objects representing\n    metadata fields instead of only using built-in types. Any invalid metadata\n    will cause :exc:`InvalidMetadata` to be raised (with a\n    :py:attr:`~BaseException.__cause__` attribute as appropriate).\n    \"\"\"\n\n    _raw: RawMetadata\n\n    @classmethod\n    def from_raw(cls, data: RawMetadata, *, validate: bool = True) -> Metadata:\n        \"\"\"Create an instance from :class:`RawMetadata`.\n\n        If *validate* is true, all metadata will be validated. All exceptions\n        related to validation will be gathered and raised as an :class:`ExceptionGroup`.\n        \"\"\"\n        ins = cls()\n        ins._raw = data.copy()  # Mutations occur due to caching enriched values.\n\n        if validate:\n            exceptions: list[Exception] = []\n            try:\n                metadata_version = ins.metadata_version\n                metadata_age = _VALID_METADATA_VERSIONS.index(metadata_version)\n            except InvalidMetadata as metadata_version_exc:\n                exceptions.append(metadata_version_exc)\n                metadata_version = None\n\n            # Make sure to check for the fields that are present, the required\n            # fields (so their absence can be reported).\n            fields_to_check = frozenset(ins._raw) | _REQUIRED_ATTRS\n            # Remove fields that have already been checked.\n            fields_to_check -= {\"metadata_version\"}\n\n            for key in fields_to_check:\n                try:\n                    if metadata_version:\n                        # Can't use getattr() as that triggers descriptor protocol which\n                        # will fail due to no value for the instance argument.\n                        try:\n                            field_metadata_version = cls.__dict__[key].added\n                        except KeyError:\n                            exc = InvalidMetadata(key, f\"unrecognized field: {key!r}\")\n                            exceptions.append(exc)\n                            continue\n                        field_age = _VALID_METADATA_VERSIONS.index(\n                            field_metadata_version\n                        )\n                        if field_age > metadata_age:\n                            field = _RAW_TO_EMAIL_MAPPING[key]\n                            exc = InvalidMetadata(\n                                field,\n                                \"{field} introduced in metadata version \"\n                                \"{field_metadata_version}, not {metadata_version}\",\n                            )\n                            exceptions.append(exc)\n                            continue\n                    getattr(ins, key)\n                except InvalidMetadata as exc:\n                    exceptions.append(exc)\n\n            if exceptions:\n                raise ExceptionGroup(\"invalid metadata\", exceptions)\n\n        return ins\n\n    @classmethod\n    def from_email(cls, data: bytes | str, *, validate: bool = True) -> Metadata:\n        \"\"\"Parse metadata from email headers.\n\n        If *validate* is true, the metadata will be validated. All exceptions\n        related to validation will be gathered and raised as an :class:`ExceptionGroup`.\n        \"\"\"\n        raw, unparsed = parse_email(data)\n\n        if validate:\n            exceptions: list[Exception] = []\n            for unparsed_key in unparsed:\n                if unparsed_key in _EMAIL_TO_RAW_MAPPING:\n                    message = f\"{unparsed_key!r} has invalid data\"\n                else:\n                    message = f\"unrecognized field: {unparsed_key!r}\"\n                exceptions.append(InvalidMetadata(unparsed_key, message))\n\n            if exceptions:\n                raise ExceptionGroup(\"unparsed\", exceptions)\n\n        try:\n            return cls.from_raw(raw, validate=validate)\n        except ExceptionGroup as exc_group:\n            raise ExceptionGroup(\n                \"invalid or unparsed metadata\", exc_group.exceptions\n            ) from None\n\n    metadata_version: _Validator[_MetadataVersion] = _Validator()\n    \"\"\":external:ref:`core-metadata-metadata-version`\n    (required; validated to be a valid metadata version)\"\"\"\n    name: _Validator[str] = _Validator()\n    \"\"\":external:ref:`core-metadata-name`\n    (required; validated using :func:`~packaging.utils.canonicalize_name` and its\n    *validate* parameter)\"\"\"\n    version: _Validator[version_module.Version] = _Validator()\n    \"\"\":external:ref:`core-metadata-version` (required)\"\"\"\n    dynamic: _Validator[list[str] | None] = _Validator(\n        added=\"2.2\",\n    )\n    \"\"\":external:ref:`core-metadata-dynamic`\n    (validated against core metadata field names and lowercased)\"\"\"\n    platforms: _Validator[list[str] | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-platform`\"\"\"\n    supported_platforms: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-supported-platform`\"\"\"\n    summary: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-summary` (validated to contain no newlines)\"\"\"\n    description: _Validator[str | None] = _Validator()  # TODO 2.1: can be in body\n    \"\"\":external:ref:`core-metadata-description`\"\"\"\n    description_content_type: _Validator[str | None] = _Validator(added=\"2.1\")\n    \"\"\":external:ref:`core-metadata-description-content-type` (validated)\"\"\"\n    keywords: _Validator[list[str] | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-keywords`\"\"\"\n    home_page: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-home-page`\"\"\"\n    download_url: _Validator[str | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-download-url`\"\"\"\n    author: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-author`\"\"\"\n    author_email: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-author-email`\"\"\"\n    maintainer: _Validator[str | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-maintainer`\"\"\"\n    maintainer_email: _Validator[str | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-maintainer-email`\"\"\"\n    license: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-license`\"\"\"\n    classifiers: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-classifier`\"\"\"\n    requires_dist: _Validator[list[requirements.Requirement] | None] = _Validator(\n        added=\"1.2\"\n    )\n    \"\"\":external:ref:`core-metadata-requires-dist`\"\"\"\n    requires_python: _Validator[specifiers.SpecifierSet | None] = _Validator(\n        added=\"1.2\"\n    )\n    \"\"\":external:ref:`core-metadata-requires-python`\"\"\"\n    # Because `Requires-External` allows for non-PEP 440 version specifiers, we\n    # don't do any processing on the values.\n    requires_external: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-requires-external`\"\"\"\n    project_urls: _Validator[dict[str, str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-project-url`\"\"\"\n    # PEP 685 lets us raise an error if an extra doesn't pass `Name` validation\n    # regardless of metadata version.\n    provides_extra: _Validator[list[utils.NormalizedName] | None] = _Validator(\n        added=\"2.1\",\n    )\n    \"\"\":external:ref:`core-metadata-provides-extra`\"\"\"\n    provides_dist: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-provides-dist`\"\"\"\n    obsoletes_dist: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-obsoletes-dist`\"\"\"\n    requires: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Requires`` (deprecated)\"\"\"\n    provides: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Provides`` (deprecated)\"\"\"\n    obsoletes: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Obsoletes`` (deprecated)\"\"\"\n", "src/packaging/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__title__ = \"packaging\"\n__summary__ = \"Core utilities for Python packages\"\n__uri__ = \"https://github.com/pypa/packaging\"\n\n__version__ = \"24.2.dev0\"\n\n__author__ = \"Donald Stufft and individual contributors\"\n__email__ = \"donald@stufft.io\"\n\n__license__ = \"BSD-2-Clause or Apache-2.0\"\n__copyright__ = \"2014 %s\" % __author__\n", "src/packaging/specifiers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> bool | None:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: bool | None = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: bool | None = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: '{spec}'\")\n\n        self._spec: tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: str | Version) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(self, item: UnparsedVersion, prereleases: bool | None = None) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> list[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: list[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: list[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: list[str], right: list[str]) -> tuple[list[str], list[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(self, specifiers: str = \"\", prereleases: bool | None = None) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        # Split on `,` to break each individual specifier into it's own item, and\n        # strip each item to remove leading/trailing whitespace.\n        split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n        # Make each individual specifier a Specifier and save in a frozen set for later.\n        self._specs = frozenset(map(Specifier, split_specifiers))\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> bool | None:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: SpecifierSet | str) -> SpecifierSet:\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: bool | None = None,\n        installed: bool | None = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: list[UnparsedVersionVar] = []\n            found_prereleases: list[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n", "src/packaging/markers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, TypedDict, cast\n\nfrom ._parser import MarkerAtom, MarkerList, Op, Value, Variable\nfrom ._parser import parse_marker as _parse_marker\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\nclass Environment(TypedDict):\n    implementation_name: str\n    \"\"\"The implementation's identifier, e.g. ``'cpython'``.\"\"\"\n\n    implementation_version: str\n    \"\"\"\n    The implementation's version, e.g. ``'3.13.0a2'`` for CPython 3.13.0a2, or\n    ``'7.3.13'`` for PyPy3.10 v7.3.13.\n    \"\"\"\n\n    os_name: str\n    \"\"\"\n    The value of :py:data:`os.name`. The name of the operating system dependent module\n    imported, e.g. ``'posix'``.\n    \"\"\"\n\n    platform_machine: str\n    \"\"\"\n    Returns the machine type, e.g. ``'i386'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_release: str\n    \"\"\"\n    The system's release, e.g. ``'2.2.0'`` or ``'NT'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_system: str\n    \"\"\"\n    The system/OS name, e.g. ``'Linux'``, ``'Windows'`` or ``'Java'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_version: str\n    \"\"\"\n    The system's release version, e.g. ``'#3 on degas'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    python_full_version: str\n    \"\"\"\n    The Python version as string ``'major.minor.patchlevel'``.\n\n    Note that unlike the Python :py:data:`sys.version`, this value will always include\n    the patchlevel (it defaults to 0).\n    \"\"\"\n\n    platform_python_implementation: str\n    \"\"\"\n    A string identifying the Python implementation, e.g. ``'CPython'``.\n    \"\"\"\n\n    python_version: str\n    \"\"\"The Python version as string ``'major.minor'``.\"\"\"\n\n    sys_platform: str\n    \"\"\"\n    This string contains a platform identifier that can be used to append\n    platform-specific components to :py:data:`sys.path`, for instance.\n\n    For Unix systems, except on Linux and AIX, this is the lowercased OS name as\n    returned by ``uname -s`` with the first part of the version as returned by\n    ``uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, at the time when Python\n    was built.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: list[str] | MarkerAtom | str, first: bool | None = True\n) -> str:\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Operator | None = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> tuple[str, ...]:\n    # PEP 685 \u2013 Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: dict[str, str]) -> bool:\n    groups: list[list[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: sys._version_info) -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Environment:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: dict[str, str] | None = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = cast(\"dict[str, str]\", default_environment())\n        current_environment[\"extra\"] = \"\"\n        # Work around platform.python_version() returning something that is not PEP 440\n        # compliant for non-tagged Python builds. We preserve default_environment()'s\n        # behavior of returning platform.python_version() verbatim, and leave it to the\n        # caller to provide a syntactically valid version if they want to override it.\n        if current_environment[\"python_full_version\"].endswith(\"+\"):\n            current_environment[\"python_full_version\"] += \"local\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(self._markers, current_environment)\n"}