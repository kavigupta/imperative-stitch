{"src/filelock/asyncio.py": "\"\"\"An asyncio-based implementation of the file lock.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport logging\nimport os\nimport time\nfrom dataclasses import dataclass\nfrom threading import local\nfrom typing import TYPE_CHECKING, Any, Callable, NoReturn, cast\n\nfrom ._api import BaseFileLock, FileLockContext, FileLockMeta\nfrom ._error import Timeout\nfrom ._soft import SoftFileLock\nfrom ._unix import UnixFileLock\nfrom ._windows import WindowsFileLock\n\nif TYPE_CHECKING:\n    import sys\n    from concurrent import futures\n    from types import TracebackType\n\n    if sys.version_info >= (3, 11):  # pragma: no cover (py311+)\n        from typing import Self\n    else:  # pragma: no cover (<py311)\n        from typing_extensions import Self\n\n\n_LOGGER = logging.getLogger(\"filelock\")\n\n\n@dataclass\nclass AsyncFileLockContext(FileLockContext):\n    \"\"\"A dataclass which holds the context for a ``BaseAsyncFileLock`` object.\"\"\"\n\n    #: Whether run in executor\n    run_in_executor: bool = True\n\n    #: The executor\n    executor: futures.Executor | None = None\n\n    #: The loop\n    loop: asyncio.AbstractEventLoop | None = None\n\n\nclass AsyncThreadLocalFileContext(AsyncFileLockContext, local):\n    \"\"\"A thread local version of the ``FileLockContext`` class.\"\"\"\n\n\nclass AsyncAcquireReturnProxy:\n    \"\"\"A context-aware object that will release the lock file when exiting.\"\"\"\n\n    def __init__(self, lock: BaseAsyncFileLock) -> None:  # noqa: D107\n        self.lock = lock\n\n    async def __aenter__(self) -> BaseAsyncFileLock:  # noqa: D105\n        return self.lock\n\n    async def __aexit__(  # noqa: D105\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        await self.lock.release()\n\n\nclass AsyncFileLockMeta(FileLockMeta):\n    def __call__(  # type: ignore[override] # noqa: PLR0913\n        cls,  # noqa: N805\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = False,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n        loop: asyncio.AbstractEventLoop | None = None,\n        run_in_executor: bool = True,\n        executor: futures.Executor | None = None,\n    ) -> BaseAsyncFileLock:\n        if thread_local and run_in_executor:\n            msg = \"run_in_executor is not supported when thread_local is True\"\n            raise ValueError(msg)\n        instance = super().__call__(\n            lock_file=lock_file,\n            timeout=timeout,\n            mode=mode,\n            thread_local=thread_local,\n            blocking=blocking,\n            is_singleton=is_singleton,\n            loop=loop,\n            run_in_executor=run_in_executor,\n            executor=executor,\n        )\n        return cast(BaseAsyncFileLock, instance)\n\n\nclass BaseAsyncFileLock(BaseFileLock, metaclass=AsyncFileLockMeta):\n    \"\"\"Base class for asynchronous file locks.\"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = False,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n        loop: asyncio.AbstractEventLoop | None = None,\n        run_in_executor: bool = True,\n        executor: futures.Executor | None = None,\n    ) -> None:\n        \"\"\"\n        Create a new lock object.\n\n        :param lock_file: path to the file\n        :param timeout: default timeout when acquiring the lock, in seconds. It will be used as fallback value in \\\n            the acquire method, if no timeout value (``None``) is given. If you want to disable the timeout, set it \\\n            to a negative value. A timeout of 0 means that there is exactly one attempt to acquire the file lock.\n        :param mode: file permissions for the lockfile\n        :param thread_local: Whether this object's internal context should be thread local or not. If this is set to \\\n            ``False`` then the lock will be reentrant across threads.\n        :param blocking: whether the lock should be blocking or not\n        :param is_singleton: If this is set to ``True`` then only one instance of this class will be created \\\n            per lock file. This is useful if you want to use the lock object for reentrant locking without needing \\\n            to pass the same object around.\n        :param loop: The event loop to use. If not specified, the running event loop will be used.\n        :param run_in_executor: If this is set to ``True`` then the lock will be acquired in an executor.\n        :param executor: The executor to use. If not specified, the default executor will be used.\n\n        \"\"\"\n        self._is_thread_local = thread_local\n        self._is_singleton = is_singleton\n\n        # Create the context. Note that external code should not work with the context directly and should instead use\n        # properties of this class.\n        kwargs: dict[str, Any] = {\n            \"lock_file\": os.fspath(lock_file),\n            \"timeout\": timeout,\n            \"mode\": mode,\n            \"blocking\": blocking,\n            \"loop\": loop,\n            \"run_in_executor\": run_in_executor,\n            \"executor\": executor,\n        }\n        self._context: AsyncFileLockContext = (AsyncThreadLocalFileContext if thread_local else AsyncFileLockContext)(\n            **kwargs\n        )\n\n    @property\n    def run_in_executor(self) -> bool:\n        \"\"\"::return: whether run in executor.\"\"\"\n        return self._context.run_in_executor\n\n    @property\n    def executor(self) -> futures.Executor | None:\n        \"\"\"::return: the executor.\"\"\"\n        return self._context.executor\n\n    @executor.setter\n    def executor(self, value: futures.Executor | None) -> None:  # pragma: no cover\n        \"\"\"\n        Change the executor.\n\n        :param value: the new executor or ``None``\n        :type value: futures.Executor | None\n\n        \"\"\"\n        self._context.executor = value\n\n    @property\n    def loop(self) -> asyncio.AbstractEventLoop | None:\n        \"\"\"::return: the event loop.\"\"\"\n        return self._context.loop\n\n    async def acquire(  # type: ignore[override]\n        self,\n        timeout: float | None = None,\n        poll_interval: float = 0.05,\n        *,\n        blocking: bool | None = None,\n    ) -> AsyncAcquireReturnProxy:\n        \"\"\"\n        Try to acquire the file lock.\n\n        :param timeout: maximum wait time for acquiring the lock, ``None`` means use the default\n            :attr:`~BaseFileLock.timeout` is and if ``timeout < 0``, there is no timeout and\n            this method will block until the lock could be acquired\n        :param poll_interval: interval of trying to acquire the lock file\n        :param blocking: defaults to True. If False, function will return immediately if it cannot obtain a lock on the\n         first attempt. Otherwise, this method will block until the timeout expires or the lock is acquired.\n        :raises Timeout: if fails to acquire lock within the timeout period\n        :return: a context object that will unlock the file when the context is exited\n\n        .. code-block:: python\n\n            # You can use this method in the context manager (recommended)\n            with lock.acquire():\n                pass\n\n            # Or use an equivalent try-finally construct:\n            lock.acquire()\n            try:\n                pass\n            finally:\n                lock.release()\n\n        \"\"\"\n        # Use the default timeout, if no timeout is provided.\n        if timeout is None:\n            timeout = self._context.timeout\n\n        if blocking is None:\n            blocking = self._context.blocking\n\n        # Increment the number right at the beginning. We can still undo it, if something fails.\n        self._context.lock_counter += 1\n\n        lock_id = id(self)\n        lock_filename = self.lock_file\n        start_time = time.perf_counter()\n        try:\n            while True:\n                if not self.is_locked:\n                    _LOGGER.debug(\"Attempting to acquire lock %s on %s\", lock_id, lock_filename)\n                    await self._run_internal_method(self._acquire)\n                if self.is_locked:\n                    _LOGGER.debug(\"Lock %s acquired on %s\", lock_id, lock_filename)\n                    break\n                if blocking is False:\n                    _LOGGER.debug(\"Failed to immediately acquire lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                if 0 <= timeout < time.perf_counter() - start_time:\n                    _LOGGER.debug(\"Timeout on acquiring lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                msg = \"Lock %s not acquired on %s, waiting %s seconds ...\"\n                _LOGGER.debug(msg, lock_id, lock_filename, poll_interval)\n                await asyncio.sleep(poll_interval)\n        except BaseException:  # Something did go wrong, so decrement the counter.\n            self._context.lock_counter = max(0, self._context.lock_counter - 1)\n            raise\n        return AsyncAcquireReturnProxy(lock=self)\n\n    async def release(self, force: bool = False) -> None:  # type: ignore[override]  # noqa: FBT001, FBT002\n        \"\"\"\n        Releases the file lock. Please note, that the lock is only completely released, if the lock counter is 0.\n        Also note, that the lock file itself is not automatically deleted.\n\n        :param force: If true, the lock counter is ignored and the lock is released in every case/\n\n        \"\"\"\n        if self.is_locked:\n            self._context.lock_counter -= 1\n\n            if self._context.lock_counter == 0 or force:\n                lock_id, lock_filename = id(self), self.lock_file\n\n                _LOGGER.debug(\"Attempting to release lock %s on %s\", lock_id, lock_filename)\n                await self._run_internal_method(self._release)\n                self._context.lock_counter = 0\n                _LOGGER.debug(\"Lock %s released on %s\", lock_id, lock_filename)\n\n    async def _run_internal_method(self, method: Callable[[], Any]) -> None:\n        if asyncio.iscoroutinefunction(method):\n            await method()\n        elif self.run_in_executor:\n            loop = self.loop or asyncio.get_running_loop()\n            await loop.run_in_executor(self.executor, method)\n        else:\n            method()\n\n    def __enter__(self) -> NoReturn:\n        \"\"\"\n        Replace old __enter__ method to avoid using it.\n\n        NOTE: DO NOT USE `with` FOR ASYNCIO LOCKS, USE `async with` INSTEAD.\n\n        :return: none\n        :rtype: NoReturn\n        \"\"\"\n        msg = \"Do not use `with` for asyncio locks, use `async with` instead.\"\n        raise NotImplementedError(msg)\n\n    async def __aenter__(self) -> Self:\n        \"\"\"\n        Acquire the lock.\n\n        :return: the lock object\n\n        \"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        \"\"\"\n        Release the lock.\n\n        :param exc_type: the exception type if raised\n        :param exc_value: the exception value if raised\n        :param traceback: the exception traceback if raised\n\n        \"\"\"\n        await self.release()\n\n    def __del__(self) -> None:\n        \"\"\"Called when the lock object is deleted.\"\"\"\n        with contextlib.suppress(RuntimeError):\n            loop = self.loop or asyncio.get_running_loop()\n            if not loop.is_running():  # pragma: no cover\n                loop.run_until_complete(self.release(force=True))\n            else:\n                loop.create_task(self.release(force=True))\n\n\nclass AsyncSoftFileLock(SoftFileLock, BaseAsyncFileLock):\n    \"\"\"Simply watches the existence of the lock file.\"\"\"\n\n\nclass AsyncUnixFileLock(UnixFileLock, BaseAsyncFileLock):\n    \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n\n\nclass AsyncWindowsFileLock(WindowsFileLock, BaseAsyncFileLock):\n    \"\"\"Uses the :func:`msvcrt.locking` to hard lock the lock file on windows systems.\"\"\"\n\n\n__all__ = [\n    \"AsyncAcquireReturnProxy\",\n    \"AsyncSoftFileLock\",\n    \"AsyncUnixFileLock\",\n    \"AsyncWindowsFileLock\",\n    \"BaseAsyncFileLock\",\n]\n", "src/filelock/_unix.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom contextlib import suppress\nfrom errno import ENOSYS\nfrom pathlib import Path\nfrom typing import cast\n\nfrom ._api import BaseFileLock\nfrom ._util import ensure_directory_exists\n\n#: a flag to indicate if the fcntl API is available\nhas_fcntl = False\nif sys.platform == \"win32\":  # pragma: win32 cover\n\n    class UnixFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n\n        def _acquire(self) -> None:\n            raise NotImplementedError\n\n        def _release(self) -> None:\n            raise NotImplementedError\n\nelse:  # pragma: win32 no cover\n    try:\n        import fcntl\n    except ImportError:\n        pass\n    else:\n        has_fcntl = True\n\n    class UnixFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n\n        def _acquire(self) -> None:\n            ensure_directory_exists(self.lock_file)\n            open_flags = os.O_RDWR | os.O_TRUNC\n            if not Path(self.lock_file).exists():\n                open_flags |= os.O_CREAT\n            fd = os.open(self.lock_file, open_flags, self._context.mode)\n            with suppress(PermissionError):  # This locked is not owned by this UID\n                os.fchmod(fd, self._context.mode)\n            try:\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n            except OSError as exception:\n                os.close(fd)\n                if exception.errno == ENOSYS:  # NotImplemented error\n                    msg = \"FileSystem does not appear to support flock; use SoftFileLock instead\"\n                    raise NotImplementedError(msg) from exception\n            else:\n                self._context.lock_file_fd = fd\n\n        def _release(self) -> None:\n            # Do not remove the lockfile:\n            #   https://github.com/tox-dev/py-filelock/issues/31\n            #   https://stackoverflow.com/questions/17708885/flock-removing-locked-file-without-race-condition\n            fd = cast(int, self._context.lock_file_fd)\n            self._context.lock_file_fd = None\n            fcntl.flock(fd, fcntl.LOCK_UN)\n            os.close(fd)\n\n\n__all__ = [\n    \"UnixFileLock\",\n    \"has_fcntl\",\n]\n", "src/filelock/_api.py": "from __future__ import annotations\n\nimport contextlib\nimport inspect\nimport logging\nimport os\nimport time\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom dataclasses import dataclass\nfrom threading import local\nfrom typing import TYPE_CHECKING, Any, cast\nfrom weakref import WeakValueDictionary\n\nfrom ._error import Timeout\n\nif TYPE_CHECKING:\n    import sys\n    from types import TracebackType\n\n    if sys.version_info >= (3, 11):  # pragma: no cover (py311+)\n        from typing import Self\n    else:  # pragma: no cover (<py311)\n        from typing_extensions import Self\n\n\n_LOGGER = logging.getLogger(\"filelock\")\n\n\n# This is a helper class which is returned by :meth:`BaseFileLock.acquire` and wraps the lock to make sure __enter__\n# is not called twice when entering the with statement. If we would simply return *self*, the lock would be acquired\n# again in the *__enter__* method of the BaseFileLock, but not released again automatically. issue #37 (memory leak)\nclass AcquireReturnProxy:\n    \"\"\"A context-aware object that will release the lock file when exiting.\"\"\"\n\n    def __init__(self, lock: BaseFileLock) -> None:\n        self.lock = lock\n\n    def __enter__(self) -> BaseFileLock:\n        return self.lock\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        self.lock.release()\n\n\n@dataclass\nclass FileLockContext:\n    \"\"\"A dataclass which holds the context for a ``BaseFileLock`` object.\"\"\"\n\n    # The context is held in a separate class to allow optional use of thread local storage via the\n    # ThreadLocalFileContext class.\n\n    #: The path to the lock file.\n    lock_file: str\n\n    #: The default timeout value.\n    timeout: float\n\n    #: The mode for the lock files\n    mode: int\n\n    #: Whether the lock should be blocking or not\n    blocking: bool\n\n    #: The file descriptor for the *_lock_file* as it is returned by the os.open() function, not None when lock held\n    lock_file_fd: int | None = None\n\n    #: The lock counter is used for implementing the nested locking mechanism.\n    lock_counter: int = 0  # When the lock is acquired is increased and the lock is only released, when this value is 0\n\n\nclass ThreadLocalFileContext(FileLockContext, local):\n    \"\"\"A thread local version of the ``FileLockContext`` class.\"\"\"\n\n\nclass FileLockMeta(ABCMeta):\n    def __call__(  # noqa: PLR0913\n        cls,\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = True,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n        **kwargs: Any,  # capture remaining kwargs for subclasses  # noqa: ANN401\n    ) -> BaseFileLock:\n        if is_singleton:\n            instance = cls._instances.get(str(lock_file))  # type: ignore[attr-defined]\n            if instance:\n                params_to_check = {\n                    \"thread_local\": (thread_local, instance.is_thread_local()),\n                    \"timeout\": (timeout, instance.timeout),\n                    \"mode\": (mode, instance.mode),\n                    \"blocking\": (blocking, instance.blocking),\n                }\n\n                non_matching_params = {\n                    name: (passed_param, set_param)\n                    for name, (passed_param, set_param) in params_to_check.items()\n                    if passed_param != set_param\n                }\n                if not non_matching_params:\n                    return cast(BaseFileLock, instance)\n\n                # parameters do not match; raise error\n                msg = \"Singleton lock instances cannot be initialized with differing arguments\"\n                msg += \"\\nNon-matching arguments: \"\n                for param_name, (passed_param, set_param) in non_matching_params.items():\n                    msg += f\"\\n\\t{param_name} (existing lock has {set_param} but {passed_param} was passed)\"\n                raise ValueError(msg)\n\n        # Workaround to make `__init__`'s params optional in subclasses\n        # E.g. virtualenv changes the signature of the `__init__` method in the `BaseFileLock` class descendant\n        # (https://github.com/tox-dev/filelock/pull/340)\n\n        all_params = {\n            \"timeout\": timeout,\n            \"mode\": mode,\n            \"thread_local\": thread_local,\n            \"blocking\": blocking,\n            \"is_singleton\": is_singleton,\n            **kwargs,\n        }\n\n        present_params = inspect.signature(cls.__init__).parameters  # type: ignore[misc]\n        init_params = {key: value for key, value in all_params.items() if key in present_params}\n\n        instance = super().__call__(lock_file, **init_params)\n\n        if is_singleton:\n            cls._instances[str(lock_file)] = instance  # type: ignore[attr-defined]\n\n        return cast(BaseFileLock, instance)\n\n\nclass BaseFileLock(contextlib.ContextDecorator, metaclass=FileLockMeta):\n    \"\"\"Abstract base class for a file lock object.\"\"\"\n\n    _instances: WeakValueDictionary[str, BaseFileLock]\n\n    def __init_subclass__(cls, **kwargs: dict[str, Any]) -> None:\n        \"\"\"Setup unique state for lock subclasses.\"\"\"\n        super().__init_subclass__(**kwargs)\n        cls._instances = WeakValueDictionary()\n\n    def __init__(  # noqa: PLR0913\n        self,\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = True,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n    ) -> None:\n        \"\"\"\n        Create a new lock object.\n\n        :param lock_file: path to the file\n        :param timeout: default timeout when acquiring the lock, in seconds. It will be used as fallback value in \\\n            the acquire method, if no timeout value (``None``) is given. If you want to disable the timeout, set it \\\n            to a negative value. A timeout of 0 means that there is exactly one attempt to acquire the file lock.\n        :param mode: file permissions for the lockfile\n        :param thread_local: Whether this object's internal context should be thread local or not. If this is set to \\\n            ``False`` then the lock will be reentrant across threads.\n        :param blocking: whether the lock should be blocking or not\n        :param is_singleton: If this is set to ``True`` then only one instance of this class will be created \\\n            per lock file. This is useful if you want to use the lock object for reentrant locking without needing \\\n            to pass the same object around.\n\n        \"\"\"\n        self._is_thread_local = thread_local\n        self._is_singleton = is_singleton\n\n        # Create the context. Note that external code should not work with the context directly and should instead use\n        # properties of this class.\n        kwargs: dict[str, Any] = {\n            \"lock_file\": os.fspath(lock_file),\n            \"timeout\": timeout,\n            \"mode\": mode,\n            \"blocking\": blocking,\n        }\n        self._context: FileLockContext = (ThreadLocalFileContext if thread_local else FileLockContext)(**kwargs)\n\n    def is_thread_local(self) -> bool:\n        \"\"\":return: a flag indicating if this lock is thread local or not\"\"\"\n        return self._is_thread_local\n\n    @property\n    def is_singleton(self) -> bool:\n        \"\"\":return: a flag indicating if this lock is singleton or not\"\"\"\n        return self._is_singleton\n\n    @property\n    def lock_file(self) -> str:\n        \"\"\":return: path to the lock file\"\"\"\n        return self._context.lock_file\n\n    @property\n    def timeout(self) -> float:\n        \"\"\"\n        :return: the default timeout value, in seconds\n\n        .. versionadded:: 2.0.0\n        \"\"\"\n        return self._context.timeout\n\n    @timeout.setter\n    def timeout(self, value: float | str) -> None:\n        \"\"\"\n        Change the default timeout value.\n\n        :param value: the new value, in seconds\n\n        \"\"\"\n        self._context.timeout = float(value)\n\n    @property\n    def blocking(self) -> bool:\n        \"\"\":return: whether the locking is blocking or not\"\"\"\n        return self._context.blocking\n\n    @blocking.setter\n    def blocking(self, value: bool) -> None:\n        \"\"\"\n        Change the default blocking value.\n\n        :param value: the new value as bool\n\n        \"\"\"\n        self._context.blocking = value\n\n    @property\n    def mode(self) -> int:\n        \"\"\":return: the file permissions for the lockfile\"\"\"\n        return self._context.mode\n\n    @abstractmethod\n    def _acquire(self) -> None:\n        \"\"\"If the file lock could be acquired, self._context.lock_file_fd holds the file descriptor of the lock file.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def _release(self) -> None:\n        \"\"\"Releases the lock and sets self._context.lock_file_fd to None.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def is_locked(self) -> bool:\n        \"\"\"\n\n        :return: A boolean indicating if the lock file is holding the lock currently.\n\n        .. versionchanged:: 2.0.0\n\n            This was previously a method and is now a property.\n        \"\"\"\n        return self._context.lock_file_fd is not None\n\n    @property\n    def lock_counter(self) -> int:\n        \"\"\":return: The number of times this lock has been acquired (but not yet released).\"\"\"\n        return self._context.lock_counter\n\n    def acquire(\n        self,\n        timeout: float | None = None,\n        poll_interval: float = 0.05,\n        *,\n        poll_intervall: float | None = None,\n        blocking: bool | None = None,\n    ) -> AcquireReturnProxy:\n        \"\"\"\n        Try to acquire the file lock.\n\n        :param timeout: maximum wait time for acquiring the lock, ``None`` means use the default :attr:`~timeout` is and\n         if ``timeout < 0``, there is no timeout and this method will block until the lock could be acquired\n        :param poll_interval: interval of trying to acquire the lock file\n        :param poll_intervall: deprecated, kept for backwards compatibility, use ``poll_interval`` instead\n        :param blocking: defaults to True. If False, function will return immediately if it cannot obtain a lock on the\n         first attempt. Otherwise, this method will block until the timeout expires or the lock is acquired.\n        :raises Timeout: if fails to acquire lock within the timeout period\n        :return: a context object that will unlock the file when the context is exited\n\n        .. code-block:: python\n\n            # You can use this method in the context manager (recommended)\n            with lock.acquire():\n                pass\n\n            # Or use an equivalent try-finally construct:\n            lock.acquire()\n            try:\n                pass\n            finally:\n                lock.release()\n\n        .. versionchanged:: 2.0.0\n\n            This method returns now a *proxy* object instead of *self*,\n            so that it can be used in a with statement without side effects.\n\n        \"\"\"\n        # Use the default timeout, if no timeout is provided.\n        if timeout is None:\n            timeout = self._context.timeout\n\n        if blocking is None:\n            blocking = self._context.blocking\n\n        if poll_intervall is not None:\n            msg = \"use poll_interval instead of poll_intervall\"\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            poll_interval = poll_intervall\n\n        # Increment the number right at the beginning. We can still undo it, if something fails.\n        self._context.lock_counter += 1\n\n        lock_id = id(self)\n        lock_filename = self.lock_file\n        start_time = time.perf_counter()\n        try:\n            while True:\n                if not self.is_locked:\n                    _LOGGER.debug(\"Attempting to acquire lock %s on %s\", lock_id, lock_filename)\n                    self._acquire()\n                if self.is_locked:\n                    _LOGGER.debug(\"Lock %s acquired on %s\", lock_id, lock_filename)\n                    break\n                if blocking is False:\n                    _LOGGER.debug(\"Failed to immediately acquire lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                if 0 <= timeout < time.perf_counter() - start_time:\n                    _LOGGER.debug(\"Timeout on acquiring lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                msg = \"Lock %s not acquired on %s, waiting %s seconds ...\"\n                _LOGGER.debug(msg, lock_id, lock_filename, poll_interval)\n                time.sleep(poll_interval)\n        except BaseException:  # Something did go wrong, so decrement the counter.\n            self._context.lock_counter = max(0, self._context.lock_counter - 1)\n            raise\n        return AcquireReturnProxy(lock=self)\n\n    def release(self, force: bool = False) -> None:  # noqa: FBT001, FBT002\n        \"\"\"\n        Releases the file lock. Please note, that the lock is only completely released, if the lock counter is 0.\n        Also note, that the lock file itself is not automatically deleted.\n\n        :param force: If true, the lock counter is ignored and the lock is released in every case/\n\n        \"\"\"\n        if self.is_locked:\n            self._context.lock_counter -= 1\n\n            if self._context.lock_counter == 0 or force:\n                lock_id, lock_filename = id(self), self.lock_file\n\n                _LOGGER.debug(\"Attempting to release lock %s on %s\", lock_id, lock_filename)\n                self._release()\n                self._context.lock_counter = 0\n                _LOGGER.debug(\"Lock %s released on %s\", lock_id, lock_filename)\n\n    def __enter__(self) -> Self:\n        \"\"\"\n        Acquire the lock.\n\n        :return: the lock object\n\n        \"\"\"\n        self.acquire()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        \"\"\"\n        Release the lock.\n\n        :param exc_type: the exception type if raised\n        :param exc_value: the exception value if raised\n        :param traceback: the exception traceback if raised\n\n        \"\"\"\n        self.release()\n\n    def __del__(self) -> None:\n        \"\"\"Called when the lock object is deleted.\"\"\"\n        self.release(force=True)\n\n\n__all__ = [\n    \"AcquireReturnProxy\",\n    \"BaseFileLock\",\n]\n", "src/filelock/_util.py": "from __future__ import annotations\n\nimport os\nimport stat\nimport sys\nfrom errno import EACCES, EISDIR\nfrom pathlib import Path\n\n\ndef raise_on_not_writable_file(filename: str) -> None:\n    \"\"\"\n    Raise an exception if attempting to open the file for writing would fail.\n\n    This is done so files that will never be writable can be separated from files that are writable but currently\n    locked.\n\n    :param filename: file to check\n    :raises OSError: as if the file was opened for writing.\n\n    \"\"\"\n    try:  # use stat to do exists + can write to check without race condition\n        file_stat = os.stat(filename)  # noqa: PTH116\n    except OSError:\n        return  # swallow does not exist or other errors\n\n    if file_stat.st_mtime != 0:  # if os.stat returns but modification is zero that's an invalid os.stat - ignore it\n        if not (file_stat.st_mode & stat.S_IWUSR):\n            raise PermissionError(EACCES, \"Permission denied\", filename)\n\n        if stat.S_ISDIR(file_stat.st_mode):\n            if sys.platform == \"win32\":  # pragma: win32 cover\n                # On Windows, this is PermissionError\n                raise PermissionError(EACCES, \"Permission denied\", filename)\n            else:  # pragma: win32 no cover # noqa: RET506\n                # On linux / macOS, this is IsADirectoryError\n                raise IsADirectoryError(EISDIR, \"Is a directory\", filename)\n\n\ndef ensure_directory_exists(filename: Path | str) -> None:\n    \"\"\"\n    Ensure the directory containing the file exists (create it if necessary).\n\n    :param filename: file.\n\n    \"\"\"\n    Path(filename).parent.mkdir(parents=True, exist_ok=True)\n\n\n__all__ = [\n    \"ensure_directory_exists\",\n    \"raise_on_not_writable_file\",\n]\n", "src/filelock/_error.py": "from __future__ import annotations\n\nfrom typing import Any\n\n\nclass Timeout(TimeoutError):  # noqa: N818\n    \"\"\"Raised when the lock could not be acquired in *timeout* seconds.\"\"\"\n\n    def __init__(self, lock_file: str) -> None:\n        super().__init__()\n        self._lock_file = lock_file\n\n    def __reduce__(self) -> str | tuple[Any, ...]:\n        return self.__class__, (self._lock_file,)  # Properly pickle the exception\n\n    def __str__(self) -> str:\n        return f\"The file lock '{self._lock_file}' could not be acquired.\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.lock_file!r})\"\n\n    @property\n    def lock_file(self) -> str:\n        \"\"\":return: The path of the file lock.\"\"\"\n        return self._lock_file\n\n\n__all__ = [\n    \"Timeout\",\n]\n", "src/filelock/__init__.py": "\"\"\"\nA platform independent file lock that supports the with-statement.\n\n.. autodata:: filelock.__version__\n   :no-value:\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport warnings\nfrom typing import TYPE_CHECKING\n\nfrom ._api import AcquireReturnProxy, BaseFileLock\nfrom ._error import Timeout\nfrom ._soft import SoftFileLock\nfrom ._unix import UnixFileLock, has_fcntl\nfrom ._windows import WindowsFileLock\nfrom .asyncio import (\n    AsyncAcquireReturnProxy,\n    AsyncSoftFileLock,\n    AsyncUnixFileLock,\n    AsyncWindowsFileLock,\n    BaseAsyncFileLock,\n)\nfrom .version import version\n\n#: version of the project as a string\n__version__: str = version\n\n\nif sys.platform == \"win32\":  # pragma: win32 cover\n    _FileLock: type[BaseFileLock] = WindowsFileLock\n    _AsyncFileLock: type[BaseAsyncFileLock] = AsyncWindowsFileLock\nelse:  # pragma: win32 no cover # noqa: PLR5501\n    if has_fcntl:\n        _FileLock: type[BaseFileLock] = UnixFileLock\n        _AsyncFileLock: type[BaseAsyncFileLock] = AsyncUnixFileLock\n    else:\n        _FileLock = SoftFileLock\n        _AsyncFileLock = AsyncSoftFileLock\n        if warnings is not None:\n            warnings.warn(\"only soft file lock is available\", stacklevel=2)\n\nif TYPE_CHECKING:\n    FileLock = SoftFileLock\n    AsyncFileLock = AsyncSoftFileLock\nelse:\n    #: Alias for the lock, which should be used for the current platform.\n    FileLock = _FileLock\n    AsyncFileLock = _AsyncFileLock\n\n\n__all__ = [\n    \"AcquireReturnProxy\",\n    \"AsyncAcquireReturnProxy\",\n    \"AsyncFileLock\",\n    \"AsyncSoftFileLock\",\n    \"AsyncUnixFileLock\",\n    \"AsyncWindowsFileLock\",\n    \"BaseAsyncFileLock\",\n    \"BaseFileLock\",\n    \"FileLock\",\n    \"SoftFileLock\",\n    \"Timeout\",\n    \"UnixFileLock\",\n    \"WindowsFileLock\",\n    \"__version__\",\n]\n", "src/filelock/_windows.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom contextlib import suppress\nfrom errno import EACCES\nfrom pathlib import Path\nfrom typing import cast\n\nfrom ._api import BaseFileLock\nfrom ._util import ensure_directory_exists, raise_on_not_writable_file\n\nif sys.platform == \"win32\":  # pragma: win32 cover\n    import msvcrt\n\n    class WindowsFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`msvcrt.locking` function to hard lock the lock file on Windows systems.\"\"\"\n\n        def _acquire(self) -> None:\n            raise_on_not_writable_file(self.lock_file)\n            ensure_directory_exists(self.lock_file)\n            flags = (\n                os.O_RDWR  # open for read and write\n                | os.O_CREAT  # create file if not exists\n                | os.O_TRUNC  # truncate file if not empty\n            )\n            try:\n                fd = os.open(self.lock_file, flags, self._context.mode)\n            except OSError as exception:\n                if exception.errno != EACCES:  # has no access to this lock\n                    raise\n            else:\n                try:\n                    msvcrt.locking(fd, msvcrt.LK_NBLCK, 1)\n                except OSError as exception:\n                    os.close(fd)  # close file first\n                    if exception.errno != EACCES:  # file is already locked\n                        raise\n                else:\n                    self._context.lock_file_fd = fd\n\n        def _release(self) -> None:\n            fd = cast(int, self._context.lock_file_fd)\n            self._context.lock_file_fd = None\n            msvcrt.locking(fd, msvcrt.LK_UNLCK, 1)\n            os.close(fd)\n\n            with suppress(OSError):  # Probably another instance of the application hat acquired the file lock.\n                Path(self.lock_file).unlink()\n\nelse:  # pragma: win32 no cover\n\n    class WindowsFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`msvcrt.locking` function to hard lock the lock file on Windows systems.\"\"\"\n\n        def _acquire(self) -> None:\n            raise NotImplementedError\n\n        def _release(self) -> None:\n            raise NotImplementedError\n\n\n__all__ = [\n    \"WindowsFileLock\",\n]\n", "src/filelock/_soft.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom contextlib import suppress\nfrom errno import EACCES, EEXIST\nfrom pathlib import Path\n\nfrom ._api import BaseFileLock\nfrom ._util import ensure_directory_exists, raise_on_not_writable_file\n\n\nclass SoftFileLock(BaseFileLock):\n    \"\"\"Simply watches the existence of the lock file.\"\"\"\n\n    def _acquire(self) -> None:\n        raise_on_not_writable_file(self.lock_file)\n        ensure_directory_exists(self.lock_file)\n        # first check for exists and read-only mode as the open will mask this case as EEXIST\n        flags = (\n            os.O_WRONLY  # open for writing only\n            | os.O_CREAT\n            | os.O_EXCL  # together with above raise EEXIST if the file specified by filename exists\n            | os.O_TRUNC  # truncate the file to zero byte\n        )\n        try:\n            file_handler = os.open(self.lock_file, flags, self._context.mode)\n        except OSError as exception:  # re-raise unless expected exception\n            if not (\n                exception.errno == EEXIST  # lock already exist\n                or (exception.errno == EACCES and sys.platform == \"win32\")  # has no access to this lock\n            ):  # pragma: win32 no cover\n                raise\n        else:\n            self._context.lock_file_fd = file_handler\n\n    def _release(self) -> None:\n        assert self._context.lock_file_fd is not None  # noqa: S101\n        os.close(self._context.lock_file_fd)  # the lock file is definitely not None\n        self._context.lock_file_fd = None\n        with suppress(OSError):  # the file is already deleted and that's what we want\n            Path(self.lock_file).unlink()\n\n\n__all__ = [\n    \"SoftFileLock\",\n]\n"}