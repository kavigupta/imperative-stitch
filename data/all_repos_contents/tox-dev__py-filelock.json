{"docs/conf.py": "# noqa: INP001\n\"\"\"Configuration for Sphinx.\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import datetime, timezone\nfrom typing import TYPE_CHECKING\n\nfrom docutils.nodes import Element, Text\nfrom sphinx.domains.python import PythonDomain\n\nfrom filelock import __version__\n\nif TYPE_CHECKING:\n    from sphinx.addnodes import pending_xref\n    from sphinx.application import Sphinx\n    from sphinx.builders import Builder\n    from sphinx.environment import BuildEnvironment\n\nname, company = \"filelock\", \"tox-dev\"\nnow = datetime.now(tz=timezone.utc)\nversion, release = \".\".join(__version__.split(\".\")[:2]), __version__\ncopyright = f\"2014-{now.date().year}, {company}\"  # noqa: A001\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx_autodoc_typehints\",\n]\nhtml_theme = \"furo\"\nhtml_title, html_last_updated_fmt = name, now.isoformat()\npygments_style, pygments_dark_style = \"sphinx\", \"monokai\"\nautoclass_content, autodoc_member_order, autodoc_typehints = \"class\", \"bysource\", \"none\"\nautodoc_default_options = {\"member-order\": \"bysource\", \"undoc-members\": True, \"show-inheritance\": True}\nautosectionlabel_prefix_document = True\n\nintersphinx_mapping = {\"python\": (\"https://docs.python.org/3\", None)}\nnitpicky = True\nnitpick_ignore = []\nextlinks = {\n    \"issue\": (\"https://github.com/tox-dev/py-filelock/issues/%s\", \"issue #%s\"),\n    \"pr\": (\"https://github.com/tox-dev/py-filelock/issues/%s\", \"PR #%s\"),\n    \"user\": (\"https://github.com/%s\", \"@%s\"),\n}\n\n\ndef setup(app: Sphinx) -> None:\n    \"\"\"\n    Setup app.\n\n    :param app: the app\n\n    \"\"\"\n\n    class PatchedPythonDomain(PythonDomain):\n        def resolve_xref(  # noqa: PLR0913, PLR0917\n            self,\n            env: BuildEnvironment,\n            fromdocname: str,\n            builder: Builder,\n            type: str,  # noqa: A002\n            target: str,\n            node: pending_xref,\n            contnode: Element,\n        ) -> Element:\n            mapping = {\"_thread._local\": (\"threading.local\", \"local\")}\n            if target in mapping:\n                of_type, with_name = mapping[target]\n                target = node[\"reftarget\"] = of_type\n                contnode.children[0] = Text(with_name, with_name)\n            return super().resolve_xref(env, fromdocname, builder, type, target, node, contnode)\n\n    app.add_domain(PatchedPythonDomain, override=True)\n", "tests/test_async_filelock.py": "from __future__ import annotations\n\nimport logging\nfrom pathlib import Path, PurePath\n\nimport pytest\n\nfrom filelock import AsyncFileLock, AsyncSoftFileLock, BaseAsyncFileLock, Timeout\n\n\n@pytest.mark.parametrize(\"lock_type\", [AsyncFileLock, AsyncSoftFileLock])\n@pytest.mark.parametrize(\"path_type\", [str, PurePath, Path])\n@pytest.mark.parametrize(\"filename\", [\"a\", \"new/b\", \"new2/new3/c\"])\n@pytest.mark.asyncio()\nasync def test_simple(\n    lock_type: type[BaseAsyncFileLock],\n    path_type: type[str | Path],\n    filename: str,\n    tmp_path: Path,\n    caplog: pytest.LogCaptureFixture,\n) -> None:\n    caplog.set_level(logging.DEBUG)\n\n    # test lock creation by passing a `str`\n    lock_path = tmp_path / filename\n    lock = lock_type(path_type(lock_path))\n    async with lock as locked:\n        assert lock.is_locked\n        assert lock is locked\n    assert not lock.is_locked\n\n    assert caplog.messages == [\n        f\"Attempting to acquire lock {id(lock)} on {lock_path}\",\n        f\"Lock {id(lock)} acquired on {lock_path}\",\n        f\"Attempting to release lock {id(lock)} on {lock_path}\",\n        f\"Lock {id(lock)} released on {lock_path}\",\n    ]\n    assert [r.levelno for r in caplog.records] == [logging.DEBUG, logging.DEBUG, logging.DEBUG, logging.DEBUG]\n    assert [r.name for r in caplog.records] == [\"filelock\", \"filelock\", \"filelock\", \"filelock\"]\n    assert logging.getLogger(\"filelock\").level == logging.NOTSET\n\n\n@pytest.mark.parametrize(\"lock_type\", [AsyncFileLock, AsyncSoftFileLock])\n@pytest.mark.parametrize(\"path_type\", [str, PurePath, Path])\n@pytest.mark.parametrize(\"filename\", [\"a\", \"new/b\", \"new2/new3/c\"])\n@pytest.mark.asyncio()\nasync def test_acquire(\n    lock_type: type[BaseAsyncFileLock],\n    path_type: type[str | Path],\n    filename: str,\n    tmp_path: Path,\n    caplog: pytest.LogCaptureFixture,\n) -> None:\n    caplog.set_level(logging.DEBUG)\n\n    # test lock creation by passing a `str`\n    lock_path = tmp_path / filename\n    lock = lock_type(path_type(lock_path))\n    async with await lock.acquire() as locked:\n        assert lock.is_locked\n        assert lock is locked\n    assert not lock.is_locked\n\n    assert caplog.messages == [\n        f\"Attempting to acquire lock {id(lock)} on {lock_path}\",\n        f\"Lock {id(lock)} acquired on {lock_path}\",\n        f\"Attempting to release lock {id(lock)} on {lock_path}\",\n        f\"Lock {id(lock)} released on {lock_path}\",\n    ]\n    assert [r.levelno for r in caplog.records] == [logging.DEBUG, logging.DEBUG, logging.DEBUG, logging.DEBUG]\n    assert [r.name for r in caplog.records] == [\"filelock\", \"filelock\", \"filelock\", \"filelock\"]\n    assert logging.getLogger(\"filelock\").level == logging.NOTSET\n\n\n@pytest.mark.parametrize(\"lock_type\", [AsyncFileLock, AsyncSoftFileLock])\n@pytest.mark.asyncio()\nasync def test_non_blocking(lock_type: type[BaseAsyncFileLock], tmp_path: Path) -> None:\n    # raises Timeout error when the lock cannot be acquired\n    lock_path = tmp_path / \"a\"\n    lock_1, lock_2 = lock_type(str(lock_path)), lock_type(str(lock_path))\n    lock_3 = lock_type(str(lock_path), blocking=False)\n    lock_4 = lock_type(str(lock_path), timeout=0)\n    lock_5 = lock_type(str(lock_path), blocking=False, timeout=-1)\n\n    # acquire lock 1\n    await lock_1.acquire()\n    assert lock_1.is_locked\n    assert not lock_2.is_locked\n    assert not lock_3.is_locked\n    assert not lock_4.is_locked\n    assert not lock_5.is_locked\n\n    # try to acquire lock 2\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        await lock_2.acquire(blocking=False)\n    assert not lock_2.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `blocking=False` lock 3 with `acquire`\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        await lock_3.acquire()\n    assert not lock_3.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `blocking=False` lock 3 with context manager\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        async with lock_3:\n            pass\n    assert not lock_3.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `timeout=0` lock 4 with `acquire`\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        await lock_4.acquire()\n    assert not lock_4.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `timeout=0` lock 4 with context manager\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        async with lock_4:\n            pass\n    assert not lock_4.is_locked\n    assert lock_1.is_locked\n\n    # blocking precedence over timeout\n    # try to acquire pre-parametrized `timeout=-1,blocking=False` lock 5 with `acquire`\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        await lock_5.acquire()\n    assert not lock_5.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `timeout=-1,blocking=False` lock 5 with context manager\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        async with lock_5:\n            pass\n    assert not lock_5.is_locked\n    assert lock_1.is_locked\n\n    # release lock 1\n    await lock_1.release()\n    assert not lock_1.is_locked\n    assert not lock_2.is_locked\n    assert not lock_3.is_locked\n    assert not lock_4.is_locked\n    assert not lock_5.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [AsyncFileLock, AsyncSoftFileLock])\n@pytest.mark.parametrize(\"thread_local\", [True, False])\n@pytest.mark.asyncio()\nasync def test_non_executor(lock_type: type[BaseAsyncFileLock], thread_local: bool, tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path), thread_local=thread_local, run_in_executor=False)\n    async with lock as locked:\n        assert lock.is_locked\n        assert lock is locked\n    assert not lock.is_locked\n\n\n@pytest.mark.asyncio()\nasync def test_coroutine_function(tmp_path: Path) -> None:\n    acquired = released = False\n\n    class AioFileLock(BaseAsyncFileLock):\n        async def _acquire(self) -> None:  # type: ignore[override]\n            nonlocal acquired\n            acquired = True\n            self._context.lock_file_fd = 1\n\n        async def _release(self) -> None:  # type: ignore[override]\n            nonlocal released\n            released = True\n            self._context.lock_file_fd = None\n\n    lock = AioFileLock(str(tmp_path / \"a\"))\n    await lock.acquire()\n    assert acquired\n    assert not released\n    await lock.release()\n    assert acquired\n    assert released\n", "tests/test_filelock.py": "from __future__ import annotations\n\nimport inspect\nimport logging\nimport os\nimport sys\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor\nfrom contextlib import contextmanager\nfrom errno import ENOSYS\nfrom inspect import getframeinfo, stack\nfrom pathlib import Path, PurePath\nfrom stat import S_IWGRP, S_IWOTH, S_IWUSR, filemode\nfrom types import TracebackType\nfrom typing import TYPE_CHECKING, Any, Callable, Iterator, Tuple, Type, Union\nfrom uuid import uuid4\nfrom weakref import WeakValueDictionary\n\nimport pytest\n\nfrom filelock import BaseFileLock, FileLock, SoftFileLock, Timeout, UnixFileLock, WindowsFileLock\n\nif TYPE_CHECKING:\n    from pytest_mock import MockerFixture\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n@pytest.mark.parametrize(\"path_type\", [str, PurePath, Path])\n@pytest.mark.parametrize(\"filename\", [\"a\", \"new/b\", \"new2/new3/c\"])\ndef test_simple(\n    lock_type: type[BaseFileLock],\n    path_type: type[str | Path],\n    filename: str,\n    tmp_path: Path,\n    caplog: pytest.LogCaptureFixture,\n) -> None:\n    caplog.set_level(logging.DEBUG)\n\n    # test lock creation by passing a `str`\n    lock_path = tmp_path / filename\n    lock = lock_type(path_type(lock_path))\n    with lock as locked:\n        assert lock.is_locked\n        assert lock is locked\n    assert not lock.is_locked\n\n    assert caplog.messages == [\n        f\"Attempting to acquire lock {id(lock)} on {lock_path}\",\n        f\"Lock {id(lock)} acquired on {lock_path}\",\n        f\"Attempting to release lock {id(lock)} on {lock_path}\",\n        f\"Lock {id(lock)} released on {lock_path}\",\n    ]\n    assert [r.levelno for r in caplog.records] == [logging.DEBUG, logging.DEBUG, logging.DEBUG, logging.DEBUG]\n    assert [r.name for r in caplog.records] == [\"filelock\", \"filelock\", \"filelock\", \"filelock\"]\n    assert logging.getLogger(\"filelock\").level == logging.NOTSET\n\n\n@contextmanager\ndef make_ro(path: Path) -> Iterator[None]:\n    write = S_IWUSR | S_IWGRP | S_IWOTH\n    path.chmod(path.stat().st_mode & ~write)\n    yield\n    path.chmod(path.stat().st_mode | write)\n\n\n@pytest.fixture()\ndef tmp_path_ro(tmp_path: Path) -> Iterator[Path]:\n    with make_ro(tmp_path):\n        yield tmp_path\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n@pytest.mark.skipif(sys.platform == \"win32\", reason=\"Windows does not have read only folders\")\n@pytest.mark.skipif(\n    sys.platform != \"win32\" and os.geteuid() == 0,\n    reason=\"Cannot make a read only file (that the current user: root can't read)\",\n)\ndef test_ro_folder(lock_type: type[BaseFileLock], tmp_path_ro: Path) -> None:\n    lock = lock_type(str(tmp_path_ro / \"a\"))\n    with pytest.raises(PermissionError, match=\"Permission denied\"):\n        lock.acquire()\n\n\n@pytest.fixture()\ndef tmp_file_ro(tmp_path: Path) -> Iterator[Path]:\n    filename = tmp_path / \"a\"\n    filename.write_text(\"\")\n    with make_ro(filename):\n        yield filename\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n@pytest.mark.skipif(\n    sys.platform != \"win32\" and os.geteuid() == 0,\n    reason=\"Cannot make a read only file (that the current user: root can't read)\",\n)\ndef test_ro_file(lock_type: type[BaseFileLock], tmp_file_ro: Path) -> None:\n    lock = lock_type(str(tmp_file_ro))\n    with pytest.raises(PermissionError, match=\"Permission denied\"):\n        lock.acquire()\n\n\nWindowsOnly = pytest.mark.skipif(sys.platform != \"win32\", reason=\"Windows only\")\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n@pytest.mark.parametrize(\n    (\"expected_error\", \"match\", \"bad_lock_file\"),\n    [\n        pytest.param(FileNotFoundError, \"No such file or directory:\", \"\", id=\"blank_filename\"),\n        pytest.param(ValueError, \"embedded null (byte|character)\", \"\\0\", id=\"null_byte\"),\n        # Should be PermissionError on Windows\n        (\n            pytest.param(PermissionError, \"Permission denied:\", \".\", id=\"current_directory\")\n            if sys.platform == \"win32\"\n            # Should be IsADirectoryError on MacOS and Linux\n            else (\n                pytest.param(IsADirectoryError, \"Is a directory\", \".\", id=\"current_directory\")\n                if sys.platform in {\"darwin\", \"linux\"}\n                # Should be some type of OSError at least on other operating systems\n                else pytest.param(OSError, None, \".\", id=\"current_directory\")\n            )\n        ),\n    ]\n    + [pytest.param(OSError, \"Invalid argument\", i, id=f\"invalid_{i}\", marks=WindowsOnly) for i in '<>:\"|?*\\a']\n    + [pytest.param(PermissionError, \"Permission denied:\", i, id=f\"permission_{i}\", marks=WindowsOnly) for i in \"/\\\\\"],\n)\n@pytest.mark.timeout(5)  # timeout in case of infinite loop\ndef test_bad_lock_file(\n    lock_type: type[BaseFileLock],\n    expected_error: type[Exception],\n    match: str,\n    bad_lock_file: str,\n) -> None:\n    lock = lock_type(bad_lock_file)\n\n    with pytest.raises(expected_error, match=match):\n        lock.acquire()\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_nested_context_manager(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # lock is not released before the most outer with statement that locked the lock, is left\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    with lock as lock_1:\n        assert lock.is_locked\n        assert lock is lock_1\n\n        with lock as lock_2:\n            assert lock.is_locked\n            assert lock is lock_2\n\n            with lock as lock_3:\n                assert lock.is_locked\n                assert lock is lock_3\n\n            assert lock.is_locked\n        assert lock.is_locked\n    assert not lock.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_nested_acquire(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # lock is not released before the most outer with statement that locked the lock, is left\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    with lock.acquire() as lock_1:\n        assert lock.is_locked\n        assert lock is lock_1\n\n        with lock.acquire() as lock_2:\n            assert lock.is_locked\n            assert lock is lock_2\n\n            with lock.acquire() as lock_3:\n                assert lock.is_locked\n                assert lock is lock_3\n\n            assert lock.is_locked\n        assert lock.is_locked\n    assert not lock.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_nested_forced_release(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # acquires the lock using a with-statement and releases the lock before leaving the with-statement\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    with lock:\n        assert lock.is_locked\n\n        lock.acquire()\n        assert lock.is_locked\n\n        lock.release(force=True)\n        assert not lock.is_locked\n    assert not lock.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_nested_contruct(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # lock is re-entrant for a given file even if it is constructed multiple times\n    lock_path = tmp_path / \"a\"\n\n    with lock_type(str(lock_path), is_singleton=True, timeout=2) as lock_1:\n        assert lock_1.is_locked\n\n        with lock_type(str(lock_path), is_singleton=True, timeout=2) as lock_2:\n            assert lock_2 is lock_1\n            assert lock_2.is_locked\n\n        assert lock_1.is_locked\n\n    assert not lock_1.is_locked\n\n\n_ExcInfoType = Union[Tuple[Type[BaseException], BaseException, TracebackType], Tuple[None, None, None]]\n\n\nclass ExThread(threading.Thread):\n    def __init__(self, target: Callable[[], None], name: str) -> None:\n        super().__init__(target=target, name=name)\n        self.ex: _ExcInfoType | None = None\n\n    def run(self) -> None:\n        try:\n            super().run()\n        except Exception:  # noqa: BLE001 # pragma: no cover\n            self.ex = sys.exc_info()  # pragma: no cover\n\n    def join(self, timeout: float | None = None) -> None:\n        super().join(timeout=timeout)\n        if self.ex is not None:\n            raise RuntimeError from self.ex[1]  # pragma: no cover\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_threaded_shared_lock_obj(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # Runs 100 threads, which need the filelock. The lock must be acquired if at least one thread required it and\n    # released, as soon as all threads stopped.\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    def thread_work() -> None:\n        for _ in range(100):\n            with lock:\n                assert lock.is_locked\n\n    threads = [ExThread(target=thread_work, name=f\"t{i}\") for i in range(100)]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n\n    assert not lock.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\n@pytest.mark.skipif(hasattr(sys, \"pypy_version_info\") and sys.platform == \"win32\", reason=\"deadlocks randomly\")\ndef test_threaded_lock_different_lock_obj(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # Runs multiple threads, which acquire the same lock file with a different FileLock object. When thread group 1\n    # acquired the lock, thread group 2 must not hold their lock.\n\n    def t_1() -> None:\n        for _ in range(1000):\n            with lock_1:\n                assert lock_1.is_locked\n                assert not lock_2.is_locked\n\n    def t_2() -> None:\n        for _ in range(1000):\n            with lock_2:\n                assert not lock_1.is_locked\n                assert lock_2.is_locked\n\n    lock_path = tmp_path / \"a\"\n    lock_1, lock_2 = lock_type(str(lock_path)), lock_type(str(lock_path))\n    threads = [(ExThread(t_1, f\"t1_{i}\"), ExThread(t_2, f\"t2_{i}\")) for i in range(10)]\n\n    for thread_1, thread_2 in threads:\n        thread_1.start()\n        thread_2.start()\n    for thread_1, thread_2 in threads:\n        thread_1.join()\n        thread_2.join()\n\n    assert not lock_1.is_locked\n    assert not lock_2.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_timeout(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # raises Timeout error when the lock cannot be acquired\n    lock_path = tmp_path / \"a\"\n    lock_1, lock_2 = lock_type(str(lock_path)), lock_type(str(lock_path))\n\n    # acquire lock 1\n    lock_1.acquire()\n    assert lock_1.is_locked\n    assert not lock_2.is_locked\n\n    # try to acquire lock 2\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_2.acquire(timeout=0.1)\n    assert not lock_2.is_locked\n    assert lock_1.is_locked\n\n    # release lock 1\n    lock_1.release()\n    assert not lock_1.is_locked\n    assert not lock_2.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_non_blocking(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # raises Timeout error when the lock cannot be acquired\n    lock_path = tmp_path / \"a\"\n    lock_1, lock_2 = lock_type(str(lock_path)), lock_type(str(lock_path))\n    lock_3 = lock_type(str(lock_path), blocking=False)\n    lock_4 = lock_type(str(lock_path), timeout=0)\n    lock_5 = lock_type(str(lock_path), blocking=False, timeout=-1)\n\n    # acquire lock 1\n    lock_1.acquire()\n    assert lock_1.is_locked\n    assert not lock_2.is_locked\n    assert not lock_3.is_locked\n    assert not lock_4.is_locked\n    assert not lock_5.is_locked\n\n    # try to acquire lock 2\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_2.acquire(blocking=False)\n    assert not lock_2.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `blocking=False` lock 3 with `acquire`\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_3.acquire()\n    assert not lock_3.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `blocking=False` lock 3 with context manager\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"), lock_3:\n        pass\n    assert not lock_3.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `timeout=0` lock 4 with `acquire`\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_4.acquire()\n    assert not lock_4.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `timeout=0` lock 4 with context manager\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"), lock_4:\n        pass\n    assert not lock_4.is_locked\n    assert lock_1.is_locked\n\n    # blocking precedence over timeout\n    # try to acquire pre-parametrized `timeout=-1,blocking=False` lock 5 with `acquire`\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_5.acquire()\n    assert not lock_5.is_locked\n    assert lock_1.is_locked\n\n    # try to acquire pre-parametrized `timeout=-1,blocking=False` lock 5 with context manager\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"), lock_5:\n        pass\n    assert not lock_5.is_locked\n    assert lock_1.is_locked\n\n    # release lock 1\n    lock_1.release()\n    assert not lock_1.is_locked\n    assert not lock_2.is_locked\n    assert not lock_3.is_locked\n    assert not lock_4.is_locked\n    assert not lock_5.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_default_timeout(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # test if the default timeout parameter works\n    lock_path = tmp_path / \"a\"\n    lock_1, lock_2 = lock_type(str(lock_path)), lock_type(str(lock_path), timeout=0.1)\n    assert lock_2.timeout == 0.1\n\n    # acquire lock 1\n    lock_1.acquire()\n    assert lock_1.is_locked\n    assert not lock_2.is_locked\n\n    # try to acquire lock 2\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_2.acquire()\n    assert not lock_2.is_locked\n    assert lock_1.is_locked\n\n    lock_2.timeout = 0\n    assert lock_2.timeout == 0\n\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_2.acquire()\n    assert not lock_2.is_locked\n    assert lock_1.is_locked\n\n    # release lock 1\n    lock_1.release()\n    assert not lock_1.is_locked\n    assert not lock_2.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_context_release_on_exc(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # lock is released when an exception is thrown in a with-statement\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    try:\n        with lock as lock_1:\n            assert lock is lock_1\n            assert lock.is_locked\n            raise ValueError  # noqa: TRY301\n    except ValueError:\n        assert not lock.is_locked\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_acquire_release_on_exc(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # lock is released when an exception is thrown in a acquire statement\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    try:\n        with lock.acquire() as lock_1:\n            assert lock is lock_1\n            assert lock.is_locked\n            raise ValueError  # noqa: TRY301\n    except ValueError:\n        assert not lock.is_locked\n\n\n@pytest.mark.skipif(hasattr(sys, \"pypy_version_info\"), reason=\"del() does not trigger GC in PyPy\")\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_del(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    # lock is released when the object is deleted\n    lock_path = tmp_path / \"a\"\n    lock_1, lock_2 = lock_type(str(lock_path)), lock_type(str(lock_path))\n\n    # acquire lock 1\n    lock_1.acquire()\n    assert lock_1.is_locked\n    assert not lock_2.is_locked\n\n    # try to acquire lock 2\n    with pytest.raises(Timeout, match=\"The file lock '.*' could not be acquired.\"):\n        lock_2.acquire(timeout=0.1)\n\n    # delete lock 1 and try to acquire lock 2 again\n    del lock_1\n\n    lock_2.acquire()\n    assert lock_2.is_locked\n\n    lock_2.release()\n\n\ndef test_cleanup_soft_lock(tmp_path: Path) -> None:\n    # tests if the lock file is removed after use\n    lock_path = tmp_path / \"a\"\n\n    with SoftFileLock(lock_path):\n        assert lock_path.exists()\n    assert not lock_path.exists()\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_poll_intervall_deprecated(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    with pytest.deprecated_call(match=\"use poll_interval instead of poll_intervall\") as checker:\n        lock.acquire(poll_intervall=0.05)  # the deprecation warning will be captured by the checker\n        frame_info = getframeinfo(stack()[0][0])  # get frame info of current file and lineno (+1 than the above lineno)\n        for warning in checker:\n            if warning.filename == frame_info.filename and warning.lineno + 1 == frame_info.lineno:  # pragma: no cover\n                break\n        else:  # pragma: no cover\n            pytest.fail(\"No warnings of stacklevel=2 matching.\")\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_context_decorator(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path))\n\n    @lock\n    def decorated_method() -> None:\n        assert lock.is_locked\n\n    assert not lock.is_locked\n    decorated_method()\n    assert not lock.is_locked\n\n\ndef test_lock_mode(tmp_path: Path) -> None:\n    # test file lock permissions are independent of umask\n    lock_path = tmp_path / \"a.lock\"\n    lock = FileLock(str(lock_path), mode=0o666)\n\n    # set umask so permissions can be anticipated\n    initial_umask = os.umask(0o022)\n    try:\n        lock.acquire()\n        assert lock.is_locked\n\n        mode = filemode(lock_path.stat().st_mode)\n        assert mode == \"-rw-rw-rw-\"\n    finally:\n        os.umask(initial_umask)\n\n    lock.release()\n\n\ndef test_lock_mode_soft(tmp_path: Path) -> None:\n    # test soft lock permissions are dependent of umask\n    lock_path = tmp_path / \"a.lock\"\n    lock = SoftFileLock(str(lock_path), mode=0o666)\n\n    # set umask so permissions can be anticipated\n    initial_umask = os.umask(0o022)\n    try:\n        lock.acquire()\n        assert lock.is_locked\n\n        mode = filemode(lock_path.stat().st_mode)\n        if sys.platform == \"win32\":\n            assert mode == \"-rw-rw-rw-\"\n        else:\n            assert mode == \"-rw-r--r--\"\n    finally:\n        os.umask(initial_umask)\n\n    lock.release()\n\n\ndef test_umask(tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a.lock\"\n    lock = FileLock(str(lock_path), mode=0o666)\n\n    initial_umask = os.umask(0)\n    os.umask(initial_umask)\n\n    lock.acquire()\n    assert lock.is_locked\n\n    current_umask = os.umask(0)\n    os.umask(current_umask)\n    assert initial_umask == current_umask\n\n    lock.release()\n\n\ndef test_umask_soft(tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a.lock\"\n    lock = SoftFileLock(str(lock_path), mode=0o666)\n\n    initial_umask = os.umask(0)\n    os.umask(initial_umask)\n\n    lock.acquire()\n    assert lock.is_locked\n\n    current_umask = os.umask(0)\n    os.umask(current_umask)\n    assert initial_umask == current_umask\n\n    lock.release()\n\n\ndef test_wrong_platform(tmp_path: Path) -> None:\n    assert not inspect.isabstract(UnixFileLock)\n    assert not inspect.isabstract(WindowsFileLock)\n    assert inspect.isabstract(BaseFileLock)\n\n    lock_type = UnixFileLock if sys.platform == \"win32\" else WindowsFileLock\n    lock = lock_type(tmp_path / \"lockfile\")\n\n    with pytest.raises(NotImplementedError):\n        lock.acquire()\n    with pytest.raises(NotImplementedError):\n        lock._release()  # noqa: SLF001\n\n\n@pytest.mark.skipif(sys.platform == \"win32\", reason=\"flock not run on windows\")\ndef test_flock_not_implemented_unix(tmp_path: Path, mocker: MockerFixture) -> None:\n    mocker.patch(\"fcntl.flock\", side_effect=OSError(ENOSYS, \"mock error\"))\n    with pytest.raises(NotImplementedError), FileLock(tmp_path / \"a.lock\"):\n        pass\n\n\ndef test_soft_errors(tmp_path: Path, mocker: MockerFixture) -> None:\n    mocker.patch(\"os.open\", side_effect=OSError(ENOSYS, \"mock error\"))\n    with pytest.raises(OSError, match=\"mock error\"):\n        SoftFileLock(tmp_path / \"a.lock\").acquire()\n\n\ndef _check_file_read_write(txt_file: Path) -> None:\n    for _ in range(3):\n        uuid = str(uuid4())\n        txt_file.write_text(uuid)\n        assert txt_file.read_text() == uuid\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_thrashing_with_thread_pool_passing_lock_to_threads(tmp_path: Path, lock_type: type[BaseFileLock]) -> None:\n    def mess_with_file(lock_: BaseFileLock) -> None:\n        with lock_:\n            _check_file_read_write(txt_file)\n\n    lock_file, txt_file = tmp_path / \"test.txt.lock\", tmp_path / \"test.txt\"\n    lock = lock_type(lock_file)\n    with ThreadPoolExecutor() as executor:\n        results = [executor.submit(mess_with_file, lock) for _ in range(100)]\n    assert all(r.result() is None for r in results)\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_thrashing_with_thread_pool_global_lock(tmp_path: Path, lock_type: type[BaseFileLock]) -> None:\n    def mess_with_file() -> None:\n        with lock:\n            _check_file_read_write(txt_file)\n\n    lock_file, txt_file = tmp_path / \"test.txt.lock\", tmp_path / \"test.txt\"\n    lock = lock_type(lock_file)\n    with ThreadPoolExecutor() as executor:\n        results = [executor.submit(mess_with_file) for _ in range(100)]\n\n    assert all(r.result() is None for r in results)\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_thrashing_with_thread_pool_lock_recreated_in_each_thread(\n    tmp_path: Path,\n    lock_type: type[BaseFileLock],\n) -> None:\n    def mess_with_file() -> None:\n        with lock_type(lock_file):\n            _check_file_read_write(txt_file)\n\n    lock_file, txt_file = tmp_path / \"test.txt.lock\", tmp_path / \"test.txt\"\n    with ThreadPoolExecutor() as executor:\n        results = [executor.submit(mess_with_file) for _ in range(100)]\n\n    assert all(r.result() is None for r in results)\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_lock_can_be_non_thread_local(\n    tmp_path: Path,\n    lock_type: type[BaseFileLock],\n) -> None:\n    lock = lock_type(tmp_path / \"test.lock\", thread_local=False)\n\n    for _ in range(2):\n        thread = threading.Thread(target=lock.acquire, kwargs={\"timeout\": 2})\n        thread.start()\n        thread.join()\n\n    assert lock.lock_counter == 2\n\n    lock.release(force=True)\n\n\ndef test_subclass_compatibility(tmp_path: Path) -> None:\n    class MyFileLock(FileLock):\n        def __init__(  # noqa: PLR0913 Too many arguments to function call (6 > 5)\n            self,\n            lock_file: str | os.PathLike[str],\n            timeout: float = -1,\n            mode: int = 0o644,\n            thread_local: bool = True,\n            my_param: int = 0,\n            **kwargs: dict[str, Any],  # noqa: ARG002\n        ) -> None:\n            super().__init__(lock_file, timeout, mode, thread_local, blocking=True, is_singleton=True)\n            self.my_param = my_param\n\n    lock_path = tmp_path / \"a\"\n    MyFileLock(str(lock_path), my_param=1)\n\n    class MySoftFileLock(SoftFileLock):\n        def __init__(  # noqa: PLR0913 Too many arguments to function call (6 > 5)\n            self,\n            lock_file: str | os.PathLike[str],\n            timeout: float = -1,\n            mode: int = 0o644,\n            thread_local: bool = True,\n            my_param: int = 0,\n            **kwargs: dict[str, Any],  # noqa: ARG002\n        ) -> None:\n            super().__init__(lock_file, timeout, mode, thread_local, blocking=True, is_singleton=True)\n            self.my_param = my_param\n\n    MySoftFileLock(str(lock_path), my_param=1)\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_singleton_and_non_singleton_locks_are_distinct(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a\"\n    lock_1 = lock_type(str(lock_path), is_singleton=False)\n    assert lock_1.is_singleton is False\n\n    lock_2 = lock_type(str(lock_path), is_singleton=True)\n    assert lock_2.is_singleton is True\n    assert lock_2 is not lock_1\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_singleton_locks_are_the_same(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a\"\n    lock_1 = lock_type(str(lock_path), is_singleton=True)\n\n    lock_2 = lock_type(str(lock_path), is_singleton=True)\n    assert lock_2 is lock_1\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_singleton_locks_are_distinct_per_lock_file(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    lock_path_1 = tmp_path / \"a\"\n    lock_1 = lock_type(str(lock_path_1), is_singleton=True)\n\n    lock_path_2 = tmp_path / \"b\"\n    lock_2 = lock_type(str(lock_path_2), is_singleton=True)\n    assert lock_1 is not lock_2\n\n\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_singleton_locks_must_be_initialized_with_the_same_args(lock_type: type[BaseFileLock], tmp_path: Path) -> None:\n    lock_path = tmp_path / \"a\"\n    args: dict[str, Any] = {\"timeout\": -1, \"mode\": 0o644, \"thread_local\": True, \"blocking\": True}\n    alternate_args: dict[str, Any] = {\"timeout\": 10, \"mode\": 0, \"thread_local\": False, \"blocking\": False}\n\n    lock = lock_type(str(lock_path), is_singleton=True, **args)\n\n    for arg_name in args:\n        general_msg = \"Singleton lock instances cannot be initialized with differing arguments\"\n        altered_args = args.copy()\n        altered_args[arg_name] = alternate_args[arg_name]\n        with pytest.raises(ValueError, match=general_msg) as exc_info:\n            lock_type(str(lock_path), is_singleton=True, **altered_args)\n        exc_info.match(arg_name)  # ensure specific non-matching argument is included in exception text\n    del lock, exc_info\n\n\n@pytest.mark.skipif(hasattr(sys, \"pypy_version_info\"), reason=\"del() does not trigger GC in PyPy\")\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_singleton_locks_are_deleted_when_no_external_references_exist(\n    lock_type: type[BaseFileLock],\n    tmp_path: Path,\n) -> None:\n    lock_path = tmp_path / \"a\"\n    lock = lock_type(str(lock_path), is_singleton=True)\n\n    assert lock_type._instances == {str(lock_path): lock}  # noqa: SLF001\n    del lock\n    assert lock_type._instances == {}  # noqa: SLF001\n\n\n@pytest.mark.skipif(hasattr(sys, \"pypy_version_info\"), reason=\"del() does not trigger GC in PyPy\")\n@pytest.mark.parametrize(\"lock_type\", [FileLock, SoftFileLock])\ndef test_singleton_instance_tracking_is_unique_per_subclass(lock_type: type[BaseFileLock]) -> None:\n    class Lock1(lock_type):  # type: ignore[valid-type, misc]\n        pass\n\n    class Lock2(lock_type):  # type: ignore[valid-type, misc]\n        pass\n\n    assert isinstance(Lock1._instances, WeakValueDictionary)  # noqa: SLF001\n    assert isinstance(Lock2._instances, WeakValueDictionary)  # noqa: SLF001\n    assert Lock1._instances is not Lock2._instances  # noqa: SLF001\n\n\ndef test_singleton_locks_when_inheriting_init_is_called_once(tmp_path: Path) -> None:\n    init_calls = 0\n\n    class MyFileLock(FileLock):\n        def __init__(self, *args: Any, **kwargs: Any) -> None:  # noqa: ANN401\n            super().__init__(*args, **kwargs)\n            nonlocal init_calls\n            init_calls += 1\n\n    lock_path = tmp_path / \"a\"\n    lock1 = MyFileLock(str(lock_path), is_singleton=True)\n    lock2 = MyFileLock(str(lock_path), is_singleton=True)\n\n    assert lock1 is lock2\n    assert init_calls == 1\n\n\ndef test_file_lock_positional_argument(tmp_path: Path) -> None:\n    class FilePathLock(FileLock):\n        def __init__(self, file_path: str) -> None:\n            super().__init__(file_path + \".lock\")\n\n    lock_path = tmp_path / \"a\"\n    lock = FilePathLock(str(lock_path))\n    assert lock.lock_file == str(lock_path) + \".lock\"\n", "tests/test_error.py": "from __future__ import annotations\n\nimport pickle  # noqa: S403\n\nfrom filelock import Timeout\n\n\ndef test_timeout_str() -> None:\n    timeout = Timeout(\"/path/to/lock\")\n    assert str(timeout) == \"The file lock '/path/to/lock' could not be acquired.\"\n\n\ndef test_timeout_repr() -> None:\n    timeout = Timeout(\"/path/to/lock\")\n    assert repr(timeout) == \"Timeout('/path/to/lock')\"\n\n\ndef test_timeout_lock_file() -> None:\n    timeout = Timeout(\"/path/to/lock\")\n    assert timeout.lock_file == \"/path/to/lock\"\n\n\ndef test_timeout_pickle() -> None:\n    timeout = Timeout(\"/path/to/lock\")\n    timeout_loaded = pickle.loads(pickle.dumps(timeout))  # noqa: S301\n\n    assert timeout.__class__ == timeout_loaded.__class__\n    assert str(timeout) == str(timeout_loaded)\n    assert repr(timeout) == repr(timeout_loaded)\n    assert timeout.lock_file == timeout_loaded.lock_file\n", "tests/test_virtualenv.py": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom virtualenv import cli_run  # type: ignore[import-untyped]\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n\ndef test_virtualenv(tmp_path: Path) -> None:\n    cli_run([str(tmp_path), \"--no-pip\", \"--no-setuptools\", \"--no-periodic-update\"])\n", "src/filelock/asyncio.py": "\"\"\"An asyncio-based implementation of the file lock.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport logging\nimport os\nimport time\nfrom dataclasses import dataclass\nfrom threading import local\nfrom typing import TYPE_CHECKING, Any, Callable, NoReturn, cast\n\nfrom ._api import BaseFileLock, FileLockContext, FileLockMeta\nfrom ._error import Timeout\nfrom ._soft import SoftFileLock\nfrom ._unix import UnixFileLock\nfrom ._windows import WindowsFileLock\n\nif TYPE_CHECKING:\n    import sys\n    from concurrent import futures\n    from types import TracebackType\n\n    if sys.version_info >= (3, 11):  # pragma: no cover (py311+)\n        from typing import Self\n    else:  # pragma: no cover (<py311)\n        from typing_extensions import Self\n\n\n_LOGGER = logging.getLogger(\"filelock\")\n\n\n@dataclass\nclass AsyncFileLockContext(FileLockContext):\n    \"\"\"A dataclass which holds the context for a ``BaseAsyncFileLock`` object.\"\"\"\n\n    #: Whether run in executor\n    run_in_executor: bool = True\n\n    #: The executor\n    executor: futures.Executor | None = None\n\n    #: The loop\n    loop: asyncio.AbstractEventLoop | None = None\n\n\nclass AsyncThreadLocalFileContext(AsyncFileLockContext, local):\n    \"\"\"A thread local version of the ``FileLockContext`` class.\"\"\"\n\n\nclass AsyncAcquireReturnProxy:\n    \"\"\"A context-aware object that will release the lock file when exiting.\"\"\"\n\n    def __init__(self, lock: BaseAsyncFileLock) -> None:  # noqa: D107\n        self.lock = lock\n\n    async def __aenter__(self) -> BaseAsyncFileLock:  # noqa: D105\n        return self.lock\n\n    async def __aexit__(  # noqa: D105\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        await self.lock.release()\n\n\nclass AsyncFileLockMeta(FileLockMeta):\n    def __call__(  # type: ignore[override] # noqa: PLR0913\n        cls,  # noqa: N805\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = False,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n        loop: asyncio.AbstractEventLoop | None = None,\n        run_in_executor: bool = True,\n        executor: futures.Executor | None = None,\n    ) -> BaseAsyncFileLock:\n        if thread_local and run_in_executor:\n            msg = \"run_in_executor is not supported when thread_local is True\"\n            raise ValueError(msg)\n        instance = super().__call__(\n            lock_file=lock_file,\n            timeout=timeout,\n            mode=mode,\n            thread_local=thread_local,\n            blocking=blocking,\n            is_singleton=is_singleton,\n            loop=loop,\n            run_in_executor=run_in_executor,\n            executor=executor,\n        )\n        return cast(BaseAsyncFileLock, instance)\n\n\nclass BaseAsyncFileLock(BaseFileLock, metaclass=AsyncFileLockMeta):\n    \"\"\"Base class for asynchronous file locks.\"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = False,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n        loop: asyncio.AbstractEventLoop | None = None,\n        run_in_executor: bool = True,\n        executor: futures.Executor | None = None,\n    ) -> None:\n        \"\"\"\n        Create a new lock object.\n\n        :param lock_file: path to the file\n        :param timeout: default timeout when acquiring the lock, in seconds. It will be used as fallback value in \\\n            the acquire method, if no timeout value (``None``) is given. If you want to disable the timeout, set it \\\n            to a negative value. A timeout of 0 means that there is exactly one attempt to acquire the file lock.\n        :param mode: file permissions for the lockfile\n        :param thread_local: Whether this object's internal context should be thread local or not. If this is set to \\\n            ``False`` then the lock will be reentrant across threads.\n        :param blocking: whether the lock should be blocking or not\n        :param is_singleton: If this is set to ``True`` then only one instance of this class will be created \\\n            per lock file. This is useful if you want to use the lock object for reentrant locking without needing \\\n            to pass the same object around.\n        :param loop: The event loop to use. If not specified, the running event loop will be used.\n        :param run_in_executor: If this is set to ``True`` then the lock will be acquired in an executor.\n        :param executor: The executor to use. If not specified, the default executor will be used.\n\n        \"\"\"\n        self._is_thread_local = thread_local\n        self._is_singleton = is_singleton\n\n        # Create the context. Note that external code should not work with the context directly and should instead use\n        # properties of this class.\n        kwargs: dict[str, Any] = {\n            \"lock_file\": os.fspath(lock_file),\n            \"timeout\": timeout,\n            \"mode\": mode,\n            \"blocking\": blocking,\n            \"loop\": loop,\n            \"run_in_executor\": run_in_executor,\n            \"executor\": executor,\n        }\n        self._context: AsyncFileLockContext = (AsyncThreadLocalFileContext if thread_local else AsyncFileLockContext)(\n            **kwargs\n        )\n\n    @property\n    def run_in_executor(self) -> bool:\n        \"\"\"::return: whether run in executor.\"\"\"\n        return self._context.run_in_executor\n\n    @property\n    def executor(self) -> futures.Executor | None:\n        \"\"\"::return: the executor.\"\"\"\n        return self._context.executor\n\n    @executor.setter\n    def executor(self, value: futures.Executor | None) -> None:  # pragma: no cover\n        \"\"\"\n        Change the executor.\n\n        :param value: the new executor or ``None``\n        :type value: futures.Executor | None\n\n        \"\"\"\n        self._context.executor = value\n\n    @property\n    def loop(self) -> asyncio.AbstractEventLoop | None:\n        \"\"\"::return: the event loop.\"\"\"\n        return self._context.loop\n\n    async def acquire(  # type: ignore[override]\n        self,\n        timeout: float | None = None,\n        poll_interval: float = 0.05,\n        *,\n        blocking: bool | None = None,\n    ) -> AsyncAcquireReturnProxy:\n        \"\"\"\n        Try to acquire the file lock.\n\n        :param timeout: maximum wait time for acquiring the lock, ``None`` means use the default\n            :attr:`~BaseFileLock.timeout` is and if ``timeout < 0``, there is no timeout and\n            this method will block until the lock could be acquired\n        :param poll_interval: interval of trying to acquire the lock file\n        :param blocking: defaults to True. If False, function will return immediately if it cannot obtain a lock on the\n         first attempt. Otherwise, this method will block until the timeout expires or the lock is acquired.\n        :raises Timeout: if fails to acquire lock within the timeout period\n        :return: a context object that will unlock the file when the context is exited\n\n        .. code-block:: python\n\n            # You can use this method in the context manager (recommended)\n            with lock.acquire():\n                pass\n\n            # Or use an equivalent try-finally construct:\n            lock.acquire()\n            try:\n                pass\n            finally:\n                lock.release()\n\n        \"\"\"\n        # Use the default timeout, if no timeout is provided.\n        if timeout is None:\n            timeout = self._context.timeout\n\n        if blocking is None:\n            blocking = self._context.blocking\n\n        # Increment the number right at the beginning. We can still undo it, if something fails.\n        self._context.lock_counter += 1\n\n        lock_id = id(self)\n        lock_filename = self.lock_file\n        start_time = time.perf_counter()\n        try:\n            while True:\n                if not self.is_locked:\n                    _LOGGER.debug(\"Attempting to acquire lock %s on %s\", lock_id, lock_filename)\n                    await self._run_internal_method(self._acquire)\n                if self.is_locked:\n                    _LOGGER.debug(\"Lock %s acquired on %s\", lock_id, lock_filename)\n                    break\n                if blocking is False:\n                    _LOGGER.debug(\"Failed to immediately acquire lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                if 0 <= timeout < time.perf_counter() - start_time:\n                    _LOGGER.debug(\"Timeout on acquiring lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                msg = \"Lock %s not acquired on %s, waiting %s seconds ...\"\n                _LOGGER.debug(msg, lock_id, lock_filename, poll_interval)\n                await asyncio.sleep(poll_interval)\n        except BaseException:  # Something did go wrong, so decrement the counter.\n            self._context.lock_counter = max(0, self._context.lock_counter - 1)\n            raise\n        return AsyncAcquireReturnProxy(lock=self)\n\n    async def release(self, force: bool = False) -> None:  # type: ignore[override]  # noqa: FBT001, FBT002\n        \"\"\"\n        Releases the file lock. Please note, that the lock is only completely released, if the lock counter is 0.\n        Also note, that the lock file itself is not automatically deleted.\n\n        :param force: If true, the lock counter is ignored and the lock is released in every case/\n\n        \"\"\"\n        if self.is_locked:\n            self._context.lock_counter -= 1\n\n            if self._context.lock_counter == 0 or force:\n                lock_id, lock_filename = id(self), self.lock_file\n\n                _LOGGER.debug(\"Attempting to release lock %s on %s\", lock_id, lock_filename)\n                await self._run_internal_method(self._release)\n                self._context.lock_counter = 0\n                _LOGGER.debug(\"Lock %s released on %s\", lock_id, lock_filename)\n\n    async def _run_internal_method(self, method: Callable[[], Any]) -> None:\n        if asyncio.iscoroutinefunction(method):\n            await method()\n        elif self.run_in_executor:\n            loop = self.loop or asyncio.get_running_loop()\n            await loop.run_in_executor(self.executor, method)\n        else:\n            method()\n\n    def __enter__(self) -> NoReturn:\n        \"\"\"\n        Replace old __enter__ method to avoid using it.\n\n        NOTE: DO NOT USE `with` FOR ASYNCIO LOCKS, USE `async with` INSTEAD.\n\n        :return: none\n        :rtype: NoReturn\n        \"\"\"\n        msg = \"Do not use `with` for asyncio locks, use `async with` instead.\"\n        raise NotImplementedError(msg)\n\n    async def __aenter__(self) -> Self:\n        \"\"\"\n        Acquire the lock.\n\n        :return: the lock object\n\n        \"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        \"\"\"\n        Release the lock.\n\n        :param exc_type: the exception type if raised\n        :param exc_value: the exception value if raised\n        :param traceback: the exception traceback if raised\n\n        \"\"\"\n        await self.release()\n\n    def __del__(self) -> None:\n        \"\"\"Called when the lock object is deleted.\"\"\"\n        with contextlib.suppress(RuntimeError):\n            loop = self.loop or asyncio.get_running_loop()\n            if not loop.is_running():  # pragma: no cover\n                loop.run_until_complete(self.release(force=True))\n            else:\n                loop.create_task(self.release(force=True))\n\n\nclass AsyncSoftFileLock(SoftFileLock, BaseAsyncFileLock):\n    \"\"\"Simply watches the existence of the lock file.\"\"\"\n\n\nclass AsyncUnixFileLock(UnixFileLock, BaseAsyncFileLock):\n    \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n\n\nclass AsyncWindowsFileLock(WindowsFileLock, BaseAsyncFileLock):\n    \"\"\"Uses the :func:`msvcrt.locking` to hard lock the lock file on windows systems.\"\"\"\n\n\n__all__ = [\n    \"AsyncAcquireReturnProxy\",\n    \"AsyncSoftFileLock\",\n    \"AsyncUnixFileLock\",\n    \"AsyncWindowsFileLock\",\n    \"BaseAsyncFileLock\",\n]\n", "src/filelock/_unix.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom contextlib import suppress\nfrom errno import ENOSYS\nfrom pathlib import Path\nfrom typing import cast\n\nfrom ._api import BaseFileLock\nfrom ._util import ensure_directory_exists\n\n#: a flag to indicate if the fcntl API is available\nhas_fcntl = False\nif sys.platform == \"win32\":  # pragma: win32 cover\n\n    class UnixFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n\n        def _acquire(self) -> None:\n            raise NotImplementedError\n\n        def _release(self) -> None:\n            raise NotImplementedError\n\nelse:  # pragma: win32 no cover\n    try:\n        import fcntl\n    except ImportError:\n        pass\n    else:\n        has_fcntl = True\n\n    class UnixFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.\"\"\"\n\n        def _acquire(self) -> None:\n            ensure_directory_exists(self.lock_file)\n            open_flags = os.O_RDWR | os.O_TRUNC\n            if not Path(self.lock_file).exists():\n                open_flags |= os.O_CREAT\n            fd = os.open(self.lock_file, open_flags, self._context.mode)\n            with suppress(PermissionError):  # This locked is not owned by this UID\n                os.fchmod(fd, self._context.mode)\n            try:\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n            except OSError as exception:\n                os.close(fd)\n                if exception.errno == ENOSYS:  # NotImplemented error\n                    msg = \"FileSystem does not appear to support flock; use SoftFileLock instead\"\n                    raise NotImplementedError(msg) from exception\n            else:\n                self._context.lock_file_fd = fd\n\n        def _release(self) -> None:\n            # Do not remove the lockfile:\n            #   https://github.com/tox-dev/py-filelock/issues/31\n            #   https://stackoverflow.com/questions/17708885/flock-removing-locked-file-without-race-condition\n            fd = cast(int, self._context.lock_file_fd)\n            self._context.lock_file_fd = None\n            fcntl.flock(fd, fcntl.LOCK_UN)\n            os.close(fd)\n\n\n__all__ = [\n    \"UnixFileLock\",\n    \"has_fcntl\",\n]\n", "src/filelock/_api.py": "from __future__ import annotations\n\nimport contextlib\nimport inspect\nimport logging\nimport os\nimport time\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom dataclasses import dataclass\nfrom threading import local\nfrom typing import TYPE_CHECKING, Any, cast\nfrom weakref import WeakValueDictionary\n\nfrom ._error import Timeout\n\nif TYPE_CHECKING:\n    import sys\n    from types import TracebackType\n\n    if sys.version_info >= (3, 11):  # pragma: no cover (py311+)\n        from typing import Self\n    else:  # pragma: no cover (<py311)\n        from typing_extensions import Self\n\n\n_LOGGER = logging.getLogger(\"filelock\")\n\n\n# This is a helper class which is returned by :meth:`BaseFileLock.acquire` and wraps the lock to make sure __enter__\n# is not called twice when entering the with statement. If we would simply return *self*, the lock would be acquired\n# again in the *__enter__* method of the BaseFileLock, but not released again automatically. issue #37 (memory leak)\nclass AcquireReturnProxy:\n    \"\"\"A context-aware object that will release the lock file when exiting.\"\"\"\n\n    def __init__(self, lock: BaseFileLock) -> None:\n        self.lock = lock\n\n    def __enter__(self) -> BaseFileLock:\n        return self.lock\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        self.lock.release()\n\n\n@dataclass\nclass FileLockContext:\n    \"\"\"A dataclass which holds the context for a ``BaseFileLock`` object.\"\"\"\n\n    # The context is held in a separate class to allow optional use of thread local storage via the\n    # ThreadLocalFileContext class.\n\n    #: The path to the lock file.\n    lock_file: str\n\n    #: The default timeout value.\n    timeout: float\n\n    #: The mode for the lock files\n    mode: int\n\n    #: Whether the lock should be blocking or not\n    blocking: bool\n\n    #: The file descriptor for the *_lock_file* as it is returned by the os.open() function, not None when lock held\n    lock_file_fd: int | None = None\n\n    #: The lock counter is used for implementing the nested locking mechanism.\n    lock_counter: int = 0  # When the lock is acquired is increased and the lock is only released, when this value is 0\n\n\nclass ThreadLocalFileContext(FileLockContext, local):\n    \"\"\"A thread local version of the ``FileLockContext`` class.\"\"\"\n\n\nclass FileLockMeta(ABCMeta):\n    def __call__(  # noqa: PLR0913\n        cls,\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = True,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n        **kwargs: Any,  # capture remaining kwargs for subclasses  # noqa: ANN401\n    ) -> BaseFileLock:\n        if is_singleton:\n            instance = cls._instances.get(str(lock_file))  # type: ignore[attr-defined]\n            if instance:\n                params_to_check = {\n                    \"thread_local\": (thread_local, instance.is_thread_local()),\n                    \"timeout\": (timeout, instance.timeout),\n                    \"mode\": (mode, instance.mode),\n                    \"blocking\": (blocking, instance.blocking),\n                }\n\n                non_matching_params = {\n                    name: (passed_param, set_param)\n                    for name, (passed_param, set_param) in params_to_check.items()\n                    if passed_param != set_param\n                }\n                if not non_matching_params:\n                    return cast(BaseFileLock, instance)\n\n                # parameters do not match; raise error\n                msg = \"Singleton lock instances cannot be initialized with differing arguments\"\n                msg += \"\\nNon-matching arguments: \"\n                for param_name, (passed_param, set_param) in non_matching_params.items():\n                    msg += f\"\\n\\t{param_name} (existing lock has {set_param} but {passed_param} was passed)\"\n                raise ValueError(msg)\n\n        # Workaround to make `__init__`'s params optional in subclasses\n        # E.g. virtualenv changes the signature of the `__init__` method in the `BaseFileLock` class descendant\n        # (https://github.com/tox-dev/filelock/pull/340)\n\n        all_params = {\n            \"timeout\": timeout,\n            \"mode\": mode,\n            \"thread_local\": thread_local,\n            \"blocking\": blocking,\n            \"is_singleton\": is_singleton,\n            **kwargs,\n        }\n\n        present_params = inspect.signature(cls.__init__).parameters  # type: ignore[misc]\n        init_params = {key: value for key, value in all_params.items() if key in present_params}\n\n        instance = super().__call__(lock_file, **init_params)\n\n        if is_singleton:\n            cls._instances[str(lock_file)] = instance  # type: ignore[attr-defined]\n\n        return cast(BaseFileLock, instance)\n\n\nclass BaseFileLock(contextlib.ContextDecorator, metaclass=FileLockMeta):\n    \"\"\"Abstract base class for a file lock object.\"\"\"\n\n    _instances: WeakValueDictionary[str, BaseFileLock]\n\n    def __init_subclass__(cls, **kwargs: dict[str, Any]) -> None:\n        \"\"\"Setup unique state for lock subclasses.\"\"\"\n        super().__init_subclass__(**kwargs)\n        cls._instances = WeakValueDictionary()\n\n    def __init__(  # noqa: PLR0913\n        self,\n        lock_file: str | os.PathLike[str],\n        timeout: float = -1,\n        mode: int = 0o644,\n        thread_local: bool = True,  # noqa: FBT001, FBT002\n        *,\n        blocking: bool = True,\n        is_singleton: bool = False,\n    ) -> None:\n        \"\"\"\n        Create a new lock object.\n\n        :param lock_file: path to the file\n        :param timeout: default timeout when acquiring the lock, in seconds. It will be used as fallback value in \\\n            the acquire method, if no timeout value (``None``) is given. If you want to disable the timeout, set it \\\n            to a negative value. A timeout of 0 means that there is exactly one attempt to acquire the file lock.\n        :param mode: file permissions for the lockfile\n        :param thread_local: Whether this object's internal context should be thread local or not. If this is set to \\\n            ``False`` then the lock will be reentrant across threads.\n        :param blocking: whether the lock should be blocking or not\n        :param is_singleton: If this is set to ``True`` then only one instance of this class will be created \\\n            per lock file. This is useful if you want to use the lock object for reentrant locking without needing \\\n            to pass the same object around.\n\n        \"\"\"\n        self._is_thread_local = thread_local\n        self._is_singleton = is_singleton\n\n        # Create the context. Note that external code should not work with the context directly and should instead use\n        # properties of this class.\n        kwargs: dict[str, Any] = {\n            \"lock_file\": os.fspath(lock_file),\n            \"timeout\": timeout,\n            \"mode\": mode,\n            \"blocking\": blocking,\n        }\n        self._context: FileLockContext = (ThreadLocalFileContext if thread_local else FileLockContext)(**kwargs)\n\n    def is_thread_local(self) -> bool:\n        \"\"\":return: a flag indicating if this lock is thread local or not\"\"\"\n        return self._is_thread_local\n\n    @property\n    def is_singleton(self) -> bool:\n        \"\"\":return: a flag indicating if this lock is singleton or not\"\"\"\n        return self._is_singleton\n\n    @property\n    def lock_file(self) -> str:\n        \"\"\":return: path to the lock file\"\"\"\n        return self._context.lock_file\n\n    @property\n    def timeout(self) -> float:\n        \"\"\"\n        :return: the default timeout value, in seconds\n\n        .. versionadded:: 2.0.0\n        \"\"\"\n        return self._context.timeout\n\n    @timeout.setter\n    def timeout(self, value: float | str) -> None:\n        \"\"\"\n        Change the default timeout value.\n\n        :param value: the new value, in seconds\n\n        \"\"\"\n        self._context.timeout = float(value)\n\n    @property\n    def blocking(self) -> bool:\n        \"\"\":return: whether the locking is blocking or not\"\"\"\n        return self._context.blocking\n\n    @blocking.setter\n    def blocking(self, value: bool) -> None:\n        \"\"\"\n        Change the default blocking value.\n\n        :param value: the new value as bool\n\n        \"\"\"\n        self._context.blocking = value\n\n    @property\n    def mode(self) -> int:\n        \"\"\":return: the file permissions for the lockfile\"\"\"\n        return self._context.mode\n\n    @abstractmethod\n    def _acquire(self) -> None:\n        \"\"\"If the file lock could be acquired, self._context.lock_file_fd holds the file descriptor of the lock file.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def _release(self) -> None:\n        \"\"\"Releases the lock and sets self._context.lock_file_fd to None.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def is_locked(self) -> bool:\n        \"\"\"\n\n        :return: A boolean indicating if the lock file is holding the lock currently.\n\n        .. versionchanged:: 2.0.0\n\n            This was previously a method and is now a property.\n        \"\"\"\n        return self._context.lock_file_fd is not None\n\n    @property\n    def lock_counter(self) -> int:\n        \"\"\":return: The number of times this lock has been acquired (but not yet released).\"\"\"\n        return self._context.lock_counter\n\n    def acquire(\n        self,\n        timeout: float | None = None,\n        poll_interval: float = 0.05,\n        *,\n        poll_intervall: float | None = None,\n        blocking: bool | None = None,\n    ) -> AcquireReturnProxy:\n        \"\"\"\n        Try to acquire the file lock.\n\n        :param timeout: maximum wait time for acquiring the lock, ``None`` means use the default :attr:`~timeout` is and\n         if ``timeout < 0``, there is no timeout and this method will block until the lock could be acquired\n        :param poll_interval: interval of trying to acquire the lock file\n        :param poll_intervall: deprecated, kept for backwards compatibility, use ``poll_interval`` instead\n        :param blocking: defaults to True. If False, function will return immediately if it cannot obtain a lock on the\n         first attempt. Otherwise, this method will block until the timeout expires or the lock is acquired.\n        :raises Timeout: if fails to acquire lock within the timeout period\n        :return: a context object that will unlock the file when the context is exited\n\n        .. code-block:: python\n\n            # You can use this method in the context manager (recommended)\n            with lock.acquire():\n                pass\n\n            # Or use an equivalent try-finally construct:\n            lock.acquire()\n            try:\n                pass\n            finally:\n                lock.release()\n\n        .. versionchanged:: 2.0.0\n\n            This method returns now a *proxy* object instead of *self*,\n            so that it can be used in a with statement without side effects.\n\n        \"\"\"\n        # Use the default timeout, if no timeout is provided.\n        if timeout is None:\n            timeout = self._context.timeout\n\n        if blocking is None:\n            blocking = self._context.blocking\n\n        if poll_intervall is not None:\n            msg = \"use poll_interval instead of poll_intervall\"\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            poll_interval = poll_intervall\n\n        # Increment the number right at the beginning. We can still undo it, if something fails.\n        self._context.lock_counter += 1\n\n        lock_id = id(self)\n        lock_filename = self.lock_file\n        start_time = time.perf_counter()\n        try:\n            while True:\n                if not self.is_locked:\n                    _LOGGER.debug(\"Attempting to acquire lock %s on %s\", lock_id, lock_filename)\n                    self._acquire()\n                if self.is_locked:\n                    _LOGGER.debug(\"Lock %s acquired on %s\", lock_id, lock_filename)\n                    break\n                if blocking is False:\n                    _LOGGER.debug(\"Failed to immediately acquire lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                if 0 <= timeout < time.perf_counter() - start_time:\n                    _LOGGER.debug(\"Timeout on acquiring lock %s on %s\", lock_id, lock_filename)\n                    raise Timeout(lock_filename)  # noqa: TRY301\n                msg = \"Lock %s not acquired on %s, waiting %s seconds ...\"\n                _LOGGER.debug(msg, lock_id, lock_filename, poll_interval)\n                time.sleep(poll_interval)\n        except BaseException:  # Something did go wrong, so decrement the counter.\n            self._context.lock_counter = max(0, self._context.lock_counter - 1)\n            raise\n        return AcquireReturnProxy(lock=self)\n\n    def release(self, force: bool = False) -> None:  # noqa: FBT001, FBT002\n        \"\"\"\n        Releases the file lock. Please note, that the lock is only completely released, if the lock counter is 0.\n        Also note, that the lock file itself is not automatically deleted.\n\n        :param force: If true, the lock counter is ignored and the lock is released in every case/\n\n        \"\"\"\n        if self.is_locked:\n            self._context.lock_counter -= 1\n\n            if self._context.lock_counter == 0 or force:\n                lock_id, lock_filename = id(self), self.lock_file\n\n                _LOGGER.debug(\"Attempting to release lock %s on %s\", lock_id, lock_filename)\n                self._release()\n                self._context.lock_counter = 0\n                _LOGGER.debug(\"Lock %s released on %s\", lock_id, lock_filename)\n\n    def __enter__(self) -> Self:\n        \"\"\"\n        Acquire the lock.\n\n        :return: the lock object\n\n        \"\"\"\n        self.acquire()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        \"\"\"\n        Release the lock.\n\n        :param exc_type: the exception type if raised\n        :param exc_value: the exception value if raised\n        :param traceback: the exception traceback if raised\n\n        \"\"\"\n        self.release()\n\n    def __del__(self) -> None:\n        \"\"\"Called when the lock object is deleted.\"\"\"\n        self.release(force=True)\n\n\n__all__ = [\n    \"AcquireReturnProxy\",\n    \"BaseFileLock\",\n]\n", "src/filelock/_util.py": "from __future__ import annotations\n\nimport os\nimport stat\nimport sys\nfrom errno import EACCES, EISDIR\nfrom pathlib import Path\n\n\ndef raise_on_not_writable_file(filename: str) -> None:\n    \"\"\"\n    Raise an exception if attempting to open the file for writing would fail.\n\n    This is done so files that will never be writable can be separated from files that are writable but currently\n    locked.\n\n    :param filename: file to check\n    :raises OSError: as if the file was opened for writing.\n\n    \"\"\"\n    try:  # use stat to do exists + can write to check without race condition\n        file_stat = os.stat(filename)  # noqa: PTH116\n    except OSError:\n        return  # swallow does not exist or other errors\n\n    if file_stat.st_mtime != 0:  # if os.stat returns but modification is zero that's an invalid os.stat - ignore it\n        if not (file_stat.st_mode & stat.S_IWUSR):\n            raise PermissionError(EACCES, \"Permission denied\", filename)\n\n        if stat.S_ISDIR(file_stat.st_mode):\n            if sys.platform == \"win32\":  # pragma: win32 cover\n                # On Windows, this is PermissionError\n                raise PermissionError(EACCES, \"Permission denied\", filename)\n            else:  # pragma: win32 no cover # noqa: RET506\n                # On linux / macOS, this is IsADirectoryError\n                raise IsADirectoryError(EISDIR, \"Is a directory\", filename)\n\n\ndef ensure_directory_exists(filename: Path | str) -> None:\n    \"\"\"\n    Ensure the directory containing the file exists (create it if necessary).\n\n    :param filename: file.\n\n    \"\"\"\n    Path(filename).parent.mkdir(parents=True, exist_ok=True)\n\n\n__all__ = [\n    \"ensure_directory_exists\",\n    \"raise_on_not_writable_file\",\n]\n", "src/filelock/_error.py": "from __future__ import annotations\n\nfrom typing import Any\n\n\nclass Timeout(TimeoutError):  # noqa: N818\n    \"\"\"Raised when the lock could not be acquired in *timeout* seconds.\"\"\"\n\n    def __init__(self, lock_file: str) -> None:\n        super().__init__()\n        self._lock_file = lock_file\n\n    def __reduce__(self) -> str | tuple[Any, ...]:\n        return self.__class__, (self._lock_file,)  # Properly pickle the exception\n\n    def __str__(self) -> str:\n        return f\"The file lock '{self._lock_file}' could not be acquired.\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.lock_file!r})\"\n\n    @property\n    def lock_file(self) -> str:\n        \"\"\":return: The path of the file lock.\"\"\"\n        return self._lock_file\n\n\n__all__ = [\n    \"Timeout\",\n]\n", "src/filelock/__init__.py": "\"\"\"\nA platform independent file lock that supports the with-statement.\n\n.. autodata:: filelock.__version__\n   :no-value:\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport warnings\nfrom typing import TYPE_CHECKING\n\nfrom ._api import AcquireReturnProxy, BaseFileLock\nfrom ._error import Timeout\nfrom ._soft import SoftFileLock\nfrom ._unix import UnixFileLock, has_fcntl\nfrom ._windows import WindowsFileLock\nfrom .asyncio import (\n    AsyncAcquireReturnProxy,\n    AsyncSoftFileLock,\n    AsyncUnixFileLock,\n    AsyncWindowsFileLock,\n    BaseAsyncFileLock,\n)\nfrom .version import version\n\n#: version of the project as a string\n__version__: str = version\n\n\nif sys.platform == \"win32\":  # pragma: win32 cover\n    _FileLock: type[BaseFileLock] = WindowsFileLock\n    _AsyncFileLock: type[BaseAsyncFileLock] = AsyncWindowsFileLock\nelse:  # pragma: win32 no cover # noqa: PLR5501\n    if has_fcntl:\n        _FileLock: type[BaseFileLock] = UnixFileLock\n        _AsyncFileLock: type[BaseAsyncFileLock] = AsyncUnixFileLock\n    else:\n        _FileLock = SoftFileLock\n        _AsyncFileLock = AsyncSoftFileLock\n        if warnings is not None:\n            warnings.warn(\"only soft file lock is available\", stacklevel=2)\n\nif TYPE_CHECKING:\n    FileLock = SoftFileLock\n    AsyncFileLock = AsyncSoftFileLock\nelse:\n    #: Alias for the lock, which should be used for the current platform.\n    FileLock = _FileLock\n    AsyncFileLock = _AsyncFileLock\n\n\n__all__ = [\n    \"AcquireReturnProxy\",\n    \"AsyncAcquireReturnProxy\",\n    \"AsyncFileLock\",\n    \"AsyncSoftFileLock\",\n    \"AsyncUnixFileLock\",\n    \"AsyncWindowsFileLock\",\n    \"BaseAsyncFileLock\",\n    \"BaseFileLock\",\n    \"FileLock\",\n    \"SoftFileLock\",\n    \"Timeout\",\n    \"UnixFileLock\",\n    \"WindowsFileLock\",\n    \"__version__\",\n]\n", "src/filelock/_windows.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom contextlib import suppress\nfrom errno import EACCES\nfrom pathlib import Path\nfrom typing import cast\n\nfrom ._api import BaseFileLock\nfrom ._util import ensure_directory_exists, raise_on_not_writable_file\n\nif sys.platform == \"win32\":  # pragma: win32 cover\n    import msvcrt\n\n    class WindowsFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`msvcrt.locking` function to hard lock the lock file on Windows systems.\"\"\"\n\n        def _acquire(self) -> None:\n            raise_on_not_writable_file(self.lock_file)\n            ensure_directory_exists(self.lock_file)\n            flags = (\n                os.O_RDWR  # open for read and write\n                | os.O_CREAT  # create file if not exists\n                | os.O_TRUNC  # truncate file if not empty\n            )\n            try:\n                fd = os.open(self.lock_file, flags, self._context.mode)\n            except OSError as exception:\n                if exception.errno != EACCES:  # has no access to this lock\n                    raise\n            else:\n                try:\n                    msvcrt.locking(fd, msvcrt.LK_NBLCK, 1)\n                except OSError as exception:\n                    os.close(fd)  # close file first\n                    if exception.errno != EACCES:  # file is already locked\n                        raise\n                else:\n                    self._context.lock_file_fd = fd\n\n        def _release(self) -> None:\n            fd = cast(int, self._context.lock_file_fd)\n            self._context.lock_file_fd = None\n            msvcrt.locking(fd, msvcrt.LK_UNLCK, 1)\n            os.close(fd)\n\n            with suppress(OSError):  # Probably another instance of the application hat acquired the file lock.\n                Path(self.lock_file).unlink()\n\nelse:  # pragma: win32 no cover\n\n    class WindowsFileLock(BaseFileLock):\n        \"\"\"Uses the :func:`msvcrt.locking` function to hard lock the lock file on Windows systems.\"\"\"\n\n        def _acquire(self) -> None:\n            raise NotImplementedError\n\n        def _release(self) -> None:\n            raise NotImplementedError\n\n\n__all__ = [\n    \"WindowsFileLock\",\n]\n", "src/filelock/_soft.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom contextlib import suppress\nfrom errno import EACCES, EEXIST\nfrom pathlib import Path\n\nfrom ._api import BaseFileLock\nfrom ._util import ensure_directory_exists, raise_on_not_writable_file\n\n\nclass SoftFileLock(BaseFileLock):\n    \"\"\"Simply watches the existence of the lock file.\"\"\"\n\n    def _acquire(self) -> None:\n        raise_on_not_writable_file(self.lock_file)\n        ensure_directory_exists(self.lock_file)\n        # first check for exists and read-only mode as the open will mask this case as EEXIST\n        flags = (\n            os.O_WRONLY  # open for writing only\n            | os.O_CREAT\n            | os.O_EXCL  # together with above raise EEXIST if the file specified by filename exists\n            | os.O_TRUNC  # truncate the file to zero byte\n        )\n        try:\n            file_handler = os.open(self.lock_file, flags, self._context.mode)\n        except OSError as exception:  # re-raise unless expected exception\n            if not (\n                exception.errno == EEXIST  # lock already exist\n                or (exception.errno == EACCES and sys.platform == \"win32\")  # has no access to this lock\n            ):  # pragma: win32 no cover\n                raise\n        else:\n            self._context.lock_file_fd = file_handler\n\n    def _release(self) -> None:\n        assert self._context.lock_file_fd is not None  # noqa: S101\n        os.close(self._context.lock_file_fd)  # the lock file is definitely not None\n        self._context.lock_file_fd = None\n        with suppress(OSError):  # the file is already deleted and that's what we want\n            Path(self.lock_file).unlink()\n\n\n__all__ = [\n    \"SoftFileLock\",\n]\n"}