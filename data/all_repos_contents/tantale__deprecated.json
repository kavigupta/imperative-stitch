{"setup.py": "#!/usr/bin/env python\n#  -*- coding: utf-8 -*-\nu\"\"\"\nDeprecated Library\n------------------\n\nDeprecated is Easy to Use\n`````````````````````````\n\nIf you need to mark a function or a method as deprecated,\nyou can use the ``@deprecated`` decorator:\n\nSave in a hello.py:\n\n.. code:: python\n\n    from deprecated import deprecated\n\n\n    @deprecated(version='1.2.1', reason=\"You should use another function\")\n    def some_old_function(x, y):\n        return x + y\n\n\n    class SomeClass(object):\n        @deprecated(version='1.3.0', reason=\"This method is deprecated\")\n        def some_old_method(self, x, y):\n            return x + y\n\n\n    some_old_function(12, 34)\n    obj = SomeClass()\n    obj.some_old_method(5, 8)\n\n\nAnd Easy to Setup\n`````````````````\n\nAnd run it:\n\n.. code:: bash\n\n    $ pip install Deprecated\n    $ python hello.py\n    hello.py:15: DeprecationWarning: Call to deprecated function (or staticmethod) some_old_function.\n    (You should use another function) -- Deprecated since version 1.2.0.\n      some_old_function(12, 34)\n    hello.py:17: DeprecationWarning: Call to deprecated method some_old_method.\n    (This method is deprecated) -- Deprecated since version 1.3.0.\n      obj.some_old_method(5, 8)\n\n\nYou can document your code\n``````````````````````````\n\nHave you ever wonder how to document that some functions, classes, methods, etc. are deprecated?\nThis is now possible with the integrated Sphinx directives:\n\nFor instance, in hello_sphinx.py:\n\n.. code:: python\n\n    from deprecated.sphinx import deprecated\n    from deprecated.sphinx import versionadded\n    from deprecated.sphinx import versionchanged\n\n\n    @versionadded(version='1.0', reason=\"This function is new\")\n    def function_one():\n        '''This is the function one'''\n\n\n    @versionchanged(version='1.0', reason=\"This function is modified\")\n    def function_two():\n        '''This is the function two'''\n\n\n    @deprecated(version='1.0', reason=\"This function will be removed soon\")\n    def function_three():\n        '''This is the function three'''\n\n\n    function_one()\n    function_two()\n    function_three()  # warns\n\n    help(function_one)\n    help(function_two)\n    help(function_three)\n\n\nThe result it immediate\n```````````````````````\n\nRun it:\n\n.. code:: bash\n\n    $ python hello_sphinx.py\n\n    hello_sphinx.py:23: DeprecationWarning: Call to deprecated function (or staticmethod) function_three.\n    (This function will be removed soon) -- Deprecated since version 1.0.\n      function_three()  # warns\n\n    Help on function function_one in module __main__:\n\n    function_one()\n        This is the function one\n\n        .. versionadded:: 1.0\n           This function is new\n\n    Help on function function_two in module __main__:\n\n    function_two()\n        This is the function two\n\n        .. versionchanged:: 1.0\n           This function is modified\n\n    Help on function function_three in module __main__:\n\n    function_three()\n        This is the function three\n\n        .. deprecated:: 1.0\n           This function will be removed soon\n\n\nLinks\n`````\n\n* `Python package index (PyPi) <https://pypi.python.org/pypi/deprecated>`_\n* `GitHub website <https://github.com/tantale/deprecated>`_\n* `Read The Docs <https://readthedocs.org/projects/deprecated>`_\n* `EBook on Lulu.com <http://www.lulu.com/commerce/index.php?fBuyContent=21305117>`_\n* `StackOverFlow Q&A <https://stackoverflow.com/a/40301488/1513933>`_\n* `Development version\n  <https://github.com/tantale/deprecated/zipball/master#egg=Deprecated-dev>`_\n\n\"\"\"\nfrom setuptools import setup\n\nsetup(\n    name='Deprecated',\n    version='1.2.14',\n    url='https://github.com/tantale/deprecated',\n    project_urls={\n        \"Documentation\": \"https://deprecated.readthedocs.io/en/latest/\",\n        \"Source\": \"https://github.com/tantale/deprecated\",\n        \"Bug Tracker\": \"https://github.com/tantale/deprecated/issues\",\n    },\n    license='MIT',\n    author='Laurent LAPORTE',  # since v1.1.0\n    author_email='tantale.solutions@gmail.com',\n    description='Python @deprecated decorator to deprecate old python classes, functions or methods.',\n    long_description=__doc__,\n    long_description_content_type=\"text/x-rst\",\n    keywords='deprecate,deprecated,deprecation,warning,warn,decorator',\n    packages=['deprecated'],\n    install_requires=['wrapt < 2, >= 1.10'],\n    zip_safe=False,\n    include_package_data=True,\n    platforms='any',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Web Environment',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    extras_require={\n        'dev': [\n            'tox',\n            'PyTest',\n            'PyTest-Cov',\n            'bump2version < 1',\n            'sphinx < 2',\n            # jinja2 3.0.3 was the last version to have contextfunction that sphinx 1.x needs\n            'jinja2~=3.0.3',\n        ]\n    },\n    python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*',\n)\n", "docs/source/conf.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# Deprecated Library Documentation build configuration file, created by\n# sphinx-quickstart on Wed Jul 19 22:23:11 2017.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.doctest',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.coverage',\n    'sphinx.ext.githubpages',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = 'Deprecated'\ncopyright = '2017, Marcos CARDOSO & Laurent LAPORTE'\nauthor = 'Marcos CARDOSO & Laurent LAPORTE'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The full version, including alpha/beta/rc tags.\nrelease = \"1.2.14\"\n# The short X.Y version.\nversion = release.rpartition('.')[0]\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'alabaster'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# This is required for the alabaster theme\n# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars\nhtml_sidebars = {\n    '**': [\n        'about.html',\n        'navigation.html',\n        'relations.html',  # needs 'show_related': True theme option to display\n        'searchbox.html',\n        'donate.html',\n    ]\n}\n\n# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'Deprecated-Doc'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, 'Deprecated.tex', 'Deprecated Documentation', 'Marcos CARDOSO and Laurent LAPORTE', 'manual')\n]\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, 'deprecated', 'Deprecated Documentation', [author], 1)]\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        'Deprecated',\n        'Deprecated Documentation',\n        author,\n        'Deprecated',\n        'Python @deprecated decorator to deprecate old python classes, functions or methods.',\n        'Miscellaneous',\n    )\n]\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    'https://docs.python.org/3/': None,\n    'https://wrapt.readthedocs.io/en/latest/': None,\n    'http://flask.pocoo.org/docs/1.0/': None,\n    'django': ('https://docs.djangoproject.com/en/2.1/', 'https://docs.djangoproject.com/en/2.1/_objects/'),\n}\n\n# -- Options for EPub output -------------------------------------------\n\nepub_basename = project\nepub_theme = 'epub'\nepub_theme_options = {\n    # relbar1: If this is true, the relbar1 block is inserted in the epub output, otherwise it is omitted.\n    'relbar1': False,\n    # footer: If this is true, the footer block is inserted in the epub output, otherwise it is omitted.\n    'footer': False,\n}\nepub_title = \"Python Deprecated Library v1.2 Documentation\"\nepub_description = \"Python @deprecated decorator to deprecate old python classes, functions or methods.\"\nepub_author = author\nepub_contributor = \"Original idea from Leandro REGUEIRO, Patrizio BERTONI, Eric WIESER\"\nepub_language = language or 'en'\nepub_publisher = \"www.lulu.com\"\nepub_copyright = copyright\nepub_identifier = \"9780244627768\"\nepub_scheme = 'ISBN'\nepub_uid = \"BookId\"  # dacd6b24-3909-4358-8527-359be2e25777\nepub_cover = ('_static/title-page.jpg', '')\n", "docs/source/tutorial/warning_ctrl/warning_classes_demo.py": "import warnings\n\nfrom deprecated import deprecated\n\n\nclass MyDeprecationWarning(DeprecationWarning):\n    \"\"\" My DeprecationWarning \"\"\"\n\n\nclass DeprecatedIn26(MyDeprecationWarning):\n    \"\"\" deprecated in 2.6 \"\"\"\n\n\nclass DeprecatedIn30(MyDeprecationWarning):\n    \"\"\" deprecated in 3.0 \"\"\"\n\n\n@deprecated(category=DeprecatedIn26, reason=\"deprecated function\")\ndef foo():\n    print(\"foo\")\n\n\n@deprecated(category=DeprecatedIn30, reason=\"deprecated function\")\ndef bar():\n    print(\"bar\")\n\n\nif __name__ == '__main__':\n    warnings.filterwarnings(\"ignore\", category=DeprecatedIn30)\n    foo()\n    bar()\n", "docs/source/tutorial/warning_ctrl/filter_action_demo.py": "import warnings\nfrom deprecated import deprecated\n\n\n@deprecated(reason=\"do not call it\", action=\"error\")\ndef foo():\n    print(\"foo\")\n\n\nif __name__ == '__main__':\n    warnings.simplefilter(\"ignore\")\n    foo()\n", "docs/source/tutorial/warning_ctrl/extra_stacklevel_demo.py": "import warnings\n\nfrom deprecated import deprecated\n\n\n@deprecated(version='1.0', extra_stacklevel=1)\nclass MyObject(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return \"object: {name}\".format(name=self.name)\n\n\ndef create_object(name):\n    return MyObject(name)\n\n\nif __name__ == '__main__':\n    warnings.filterwarnings(\"default\", category=DeprecationWarning)\n    # warn here:\n    print(create_object(\"orange\"))\n    # and also here:\n    print(create_object(\"banane\"))\n", "docs/source/tutorial/warning_ctrl/filter_warnings_demo.py": "import warnings\nfrom deprecated import deprecated\n\n\n@deprecated(version='1.2.1', reason=\"deprecated function\")\ndef fun():\n    print(\"fun\")\n\n\nif __name__ == '__main__':\n    warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n    fun()\n", "docs/source/tutorial/v1/liberty.py": "# coding: utf-8\n\"\"\" Liberty library is free \"\"\"\n\nimport pprint\n\nfrom deprecated import deprecated\n\n\n@deprecated\ndef print_value(value):\n    \"\"\"\n    Print the value\n\n    :param value: The value to print\n    \"\"\"\n    pprint.pprint(value)\n\n\ndef better_print(value, printer=None):\n    \"\"\"\n    Print the value using a *printer*.\n\n    :param value: The value to print\n    :param printer: Callable used to print the value, by default: :func:`pprint.pprint`\n    \"\"\"\n    printer = printer or pprint.pprint\n    printer(value)\n", "docs/source/tutorial/v1/using_liberty.py": "# coding: utf-8\nimport liberty\n\nliberty.print_value(\"hello\")\nliberty.print_value(\"hello again\")\nliberty.better_print(\"Hi Tom!\")\n", "docs/source/tutorial/v2/liberty.py": "# coding: utf-8\n\"\"\" Liberty library is free \"\"\"\n\nimport pprint\n\nfrom deprecated import deprecated\n\n\n@deprecated(\"This function is rotten, use 'better_print' instead\")\ndef print_value(value):\n    \"\"\"\n    Print the value\n\n    :param value: The value to print\n    \"\"\"\n    pprint.pprint(value)\n\n\ndef better_print(value, printer=None):\n    \"\"\"\n    Print the value using a *printer*.\n\n    :param value: The value to print\n    :param printer: Callable used to print the value, by default: :func:`pprint.pprint`\n    \"\"\"\n    printer = printer or pprint.pprint\n    printer(value)\n", "docs/source/tutorial/v2/using_liberty.py": "# coding: utf-8\nimport liberty\n\nliberty.print_value(\"hello\")\nliberty.print_value(\"hello again\")\nliberty.better_print(\"Hi Tom!\")\n", "docs/source/tutorial/v3/liberty.py": "# coding: utf-8\n\"\"\" Liberty library is free \"\"\"\n\nimport pprint\n\nfrom deprecated import deprecated\n\n\nclass Liberty(object):\n    def __init__(self, value):\n        self.value = value\n\n    @deprecated(\"This method is rotten, use 'better_print' instead\")\n    def print_value(self):\n        \"\"\" Print the value \"\"\"\n        pprint.pprint(self.value)\n\n    def better_print(self, printer=None):\n        \"\"\"\n        Print the value using a *printer*.\n\n        :param printer: Callable used to print the value, by default: :func:`pprint.pprint`\n        \"\"\"\n        printer = printer or pprint.pprint\n        printer(self.value)\n", "docs/source/tutorial/v3/using_liberty.py": "# coding: utf-8\nimport liberty\n\nobj = liberty.Liberty(\"Greeting\")\nobj.print_value()\nobj.print_value()\nobj.better_print()\n", "docs/source/tutorial/v4/liberty.py": "# coding: utf-8\n\"\"\" Liberty library is free \"\"\"\n\nimport pprint\n\nfrom deprecated import deprecated\n\n\n@deprecated(\"This class is not perfect\")\nclass Liberty(object):\n    def __init__(self, value):\n        self.value = value\n\n    def print_value(self):\n        \"\"\" Print the value \"\"\"\n        pprint.pprint(self.value)\n", "docs/source/tutorial/v4/using_liberty.py": "# coding: utf-8\nimport liberty\n\nobj = liberty.Liberty(\"Salutation\")\nobj.print_value()\nobj.print_value()\n", "docs/source/tutorial/v0/liberty.py": "# coding: utf-8\n\"\"\" Liberty library is free \"\"\"\n\nimport pprint\n\n\ndef print_value(value):\n    \"\"\"\n    Print the value\n\n    :param value: The value to print\n    \"\"\"\n    pprint.pprint(value)\n", "docs/source/sphinx/sphinx_demo.py": "# coding: utf-8\nfrom deprecated.sphinx import deprecated\nfrom deprecated.sphinx import versionadded\nfrom deprecated.sphinx import versionchanged\n\n\n@deprecated(\n    reason=\"\"\"\n    This is deprecated, really. So you need to use another function.\n    But I don\\'t know which one.\n\n       - The first,\n       - The second.\n\n    Just guess!\n    \"\"\",\n    version='0.3.0',\n)\n@versionchanged(\n    reason='Well, I add a new feature in this function. '\n           'It is very useful as you can see in the example below, so try it. '\n           'This is a very very very very very long sentence.',\n    version='0.2.0',\n)\n@versionadded(reason='Here is my new function.', version='0.1.0')\ndef successor(n):\n    \"\"\"\n    Calculate the successor of a number.\n\n    :param n: a number\n    :return: number + 1\n    \"\"\"\n    return n + 1\n", "docs/source/sphinx/calc_mean_deco.py": "from deprecated.sphinx import deprecated\n\n\n@deprecated(\n    reason=\"\"\"Since Python 3.4, you can use the standard function :func:`statistics.mean`.\"\"\",\n    version=\"2.5.0\",\n)\ndef mean(values):\n    \"\"\"\n    Compute the arithmetic mean (\u201caverage\u201d) of values.\n\n    :type  values: typing.List[float]\n    :param values: List of floats\n    :return: Mean of values.\n    \"\"\"\n    return sum(values) / len(values)\n", "docs/source/sphinx/use_calc_mean_deco.py": "from calc_mean_deco import mean\n\nprint(mean.__doc__)\n", "docs/source/sphinx/calc_mean.py": "def mean(values):\n    \"\"\"\n    Compute the arithmetic mean (\u201caverage\u201d) of values.\n\n    :type  values: typing.List[float]\n    :param values: List of floats\n    :return: Mean of values.\n\n    .. deprecated:: 2.5.0\n       Since Python 3.4, you can use the standard function :func:`statistics.mean`.\n    \"\"\"\n    return sum(values) / len(values)\n", "tests/test_sphinx_metaclass.py": "# coding: utf-8\nimport warnings\n\nimport deprecated.sphinx\n\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n\ndef test_with_init():\n    @deprecated.classic.deprecated\n    class MyClass(object):\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(\"five\")\n\n    assert len(warns) == 1\n\n    assert obj.a == \"five\"\n    assert obj.b == 5\n\n\ndef test_with_new():\n    @deprecated.classic.deprecated\n    class MyClass(object):\n        def __new__(cls, a, b=5):\n            obj = super(MyClass, cls).__new__(cls)\n            obj.c = 3.14\n            return obj\n\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(\"five\")\n\n    assert len(warns) == 1\n\n    assert obj.a == \"five\"\n    assert obj.b == 5\n    assert obj.c == 3.14\n\n\ndef test_with_metaclass():\n    class Meta(type):\n        def __call__(cls, *args, **kwargs):\n            obj = super(Meta, cls).__call__(*args, **kwargs)\n            obj.c = 3.14\n            return obj\n\n    @deprecated.classic.deprecated\n    class MyClass(with_metaclass(Meta)):\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(\"five\")\n\n    assert len(warns) == 1\n\n    assert obj.a == \"five\"\n    assert obj.b == 5\n    assert obj.c == 3.14\n\n\ndef test_with_singleton_metaclass():\n    class Singleton(type):\n        _instances = {}\n\n        def __call__(cls, *args, **kwargs):\n            if cls not in cls._instances:\n                cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n            return cls._instances[cls]\n\n    @deprecated.classic.deprecated\n    class MyClass(with_metaclass(Singleton)):\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj1 = MyClass(\"five\")\n        obj2 = MyClass(\"six\", b=6)\n\n    # __new__ is called only once:\n    # the instance is constructed only once,\n    # so we have only one warning.\n    assert len(warns) == 1\n\n    assert obj1.a == \"five\"\n    assert obj1.b == 5\n    assert obj2 is obj1\n", "tests/test_sphinx_adapter.py": "# coding: utf-8\nimport textwrap\n\nimport pytest\n\nfrom deprecated.sphinx import SphinxAdapter\nfrom deprecated.sphinx import deprecated\nfrom deprecated.sphinx import versionadded\nfrom deprecated.sphinx import versionchanged\n\n\n@pytest.mark.parametrize(\n    \"line_length, expected\",\n    [\n        (\n            50,\n            textwrap.dedent(\n                \"\"\"\n                Description of foo\n\n                :return: nothing\n\n                .. {directive}:: 1.2.3\n                   foo has changed in this version\n\n                   bar bar bar bar bar bar bar bar bar bar bar\n                   bar bar bar bar bar bar bar bar bar bar bar\n                   bar\n                \"\"\"\n            ),\n        ),\n        (\n            0,\n            textwrap.dedent(\n                \"\"\"\n                Description of foo\n\n                :return: nothing\n\n                .. {directive}:: 1.2.3\n                   foo has changed in this version\n\n                   bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar bar\n                \"\"\"\n            ),\n        ),\n    ],\n    ids=[\"wrapped\", \"long\"],\n)\n@pytest.mark.parametrize(\"directive\", [\"versionchanged\", \"versionadded\", \"deprecated\"])\ndef test_sphinx_adapter(directive, line_length, expected):\n    lines = [\n        \"foo has changed in this version\",\n        \"\",  # newline\n        \"bar \" * 23,  # long line\n        \"\",  # trailing newline\n    ]\n    reason = \"\\n\".join(lines)\n    adapter = SphinxAdapter(directive, reason=reason, version=\"1.2.3\", line_length=line_length)\n\n    def foo():\n        \"\"\"\n        Description of foo\n\n        :return: nothing\n        \"\"\"\n\n    wrapped = adapter.__call__(foo)\n    expected = expected.format(directive=directive)\n    assert wrapped.__doc__ == expected\n\n\n@pytest.mark.parametrize(\"directive\", [\"versionchanged\", \"versionadded\", \"deprecated\"])\ndef test_sphinx_adapter__empty_docstring(directive):\n    lines = [\n        \"foo has changed in this version\",\n        \"\",  # newline\n        \"bar \" * 23,  # long line\n        \"\",  # trailing newline\n    ]\n    reason = \"\\n\".join(lines)\n    adapter = SphinxAdapter(directive, reason=reason, version=\"1.2.3\", line_length=50)\n\n    def foo():\n        pass\n\n    wrapped = adapter.__call__(foo)\n    expected = textwrap.dedent(\n        \"\"\"\n        .. {directive}:: 1.2.3\n           foo has changed in this version\n\n           bar bar bar bar bar bar bar bar bar bar bar\n           bar bar bar bar bar bar bar bar bar bar bar\n           bar\n        \"\"\"\n    )\n    expected = expected.format(directive=directive)\n    assert wrapped.__doc__ == expected\n\n\n@pytest.mark.parametrize(\n    \"decorator_factory, directive\",\n    [\n        (versionadded, \"versionadded\"),\n        (versionchanged, \"versionchanged\"),\n        (deprecated, \"deprecated\"),\n    ],\n)\ndef test_decorator_accept_line_length(decorator_factory, directive):\n    reason = \"bar \" * 30\n    decorator = decorator_factory(reason=reason, version=\"1.2.3\", line_length=50)\n\n    def foo():\n        pass\n\n    foo = decorator(foo)\n\n    expected = textwrap.dedent(\n        \"\"\"\n        .. {directive}:: 1.2.3\n           bar bar bar bar bar bar bar bar bar bar bar\n           bar bar bar bar bar bar bar bar bar bar bar\n           bar bar bar bar bar bar bar bar\n        \"\"\"\n    )\n    expected = expected.format(directive=directive)\n    assert foo.__doc__ == expected\n", "tests/test_sphinx_class.py": "# coding: utf-8\nfrom __future__ import print_function\n\nimport inspect\nimport io\nimport sys\nimport warnings\n\nimport pytest\n\nimport deprecated.sphinx\n\n\ndef test_class_deprecation_using_a_simple_decorator():\n    # stream is used to store the deprecation message for testing\n    stream = io.StringIO()\n\n    # To deprecated the class, we use a simple decorator\n    # which patches the original ``__new__`` method.\n\n    def simple_decorator(wrapped_cls):\n        old_new = wrapped_cls.__new__\n\n        def wrapped_new(unused, *args, **kwargs):\n            print(u\"I am deprecated!\", file=stream)\n            return old_new(*args, **kwargs)\n\n        wrapped_cls.__new__ = classmethod(wrapped_new)\n        return wrapped_cls\n\n    @simple_decorator\n    class MyBaseClass(object):\n        pass\n\n    class MySubClass(MyBaseClass):\n        pass\n\n    obj = MySubClass()\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert stream.getvalue().strip() == u\"I am deprecated!\"\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_class_deprecation_using_deprecated_decorator():\n    @deprecated.sphinx.deprecated(version=\"7.8.9\")\n    class MyBaseClass(object):\n        pass\n\n    class MySubClass(MyBaseClass):\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MySubClass()\n\n    assert len(warns) == 1\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert issubclass(MySubClass, MyBaseClass)\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_subclass_deprecation_using_deprecated_decorator():\n    @deprecated.sphinx.deprecated(version=\"7.8.9\")\n    class MyBaseClass(object):\n        pass\n\n    @deprecated.sphinx.deprecated(version=\"7.8.9\")\n    class MySubClass(MyBaseClass):\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MySubClass()\n\n    assert len(warns) == 2\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert issubclass(MySubClass, MyBaseClass)\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_isinstance_versionadded():\n    # https://github.com/tantale/deprecated/issues/48\n    @deprecated.sphinx.versionadded(version=\"X.Y\", reason=\"some reason\")\n    class VersionAddedCls:\n        pass\n\n    @deprecated.sphinx.versionadded(version=\"X.Y\", reason=\"some reason\")\n    class VersionAddedChildCls(VersionAddedCls):\n        pass\n\n    instance = VersionAddedChildCls()\n    assert isinstance(instance, VersionAddedChildCls)\n    assert isinstance(instance, VersionAddedCls)\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_isinstance_versionchanged():\n    @deprecated.sphinx.versionchanged(version=\"X.Y\", reason=\"some reason\")\n    class VersionChangedCls:\n        pass\n\n    @deprecated.sphinx.versionchanged(version=\"X.Y\", reason=\"some reason\")\n    class VersionChangedChildCls(VersionChangedCls):\n        pass\n\n    instance = VersionChangedChildCls()\n    assert isinstance(instance, VersionChangedChildCls)\n    assert isinstance(instance, VersionChangedCls)\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_isinstance_deprecated():\n    @deprecated.sphinx.deprecated(version=\"X.Y\", reason=\"some reason\")\n    class DeprecatedCls:\n        pass\n\n    @deprecated.sphinx.deprecated(version=\"Y.Z\", reason=\"some reason\")\n    class DeprecatedChildCls(DeprecatedCls):\n        pass\n\n    instance = DeprecatedChildCls()\n    assert isinstance(instance, DeprecatedChildCls)\n    assert isinstance(instance, DeprecatedCls)\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_isinstance_versionadded_versionchanged():\n    @deprecated.sphinx.versionadded(version=\"X.Y\")\n    @deprecated.sphinx.versionchanged(version=\"X.Y.Z\")\n    class AddedChangedCls:\n        pass\n\n    instance = AddedChangedCls()\n    assert isinstance(instance, AddedChangedCls)\n", "tests/test_deprecated_metaclass.py": "# coding: utf-8\nimport warnings\n\nimport deprecated.classic\n\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n\ndef test_with_init():\n    @deprecated.classic.deprecated\n    class MyClass(object):\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(\"five\")\n\n    assert len(warns) == 1\n\n    assert obj.a == \"five\"\n    assert obj.b == 5\n\n\ndef test_with_new():\n    @deprecated.classic.deprecated\n    class MyClass(object):\n        def __new__(cls, a, b=5):\n            obj = super(MyClass, cls).__new__(cls)\n            obj.c = 3.14\n            return obj\n\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(\"five\")\n\n    assert len(warns) == 1\n\n    assert obj.a == \"five\"\n    assert obj.b == 5\n    assert obj.c == 3.14\n\n\ndef test_with_metaclass():\n    class Meta(type):\n        def __call__(cls, *args, **kwargs):\n            obj = super(Meta, cls).__call__(*args, **kwargs)\n            obj.c = 3.14\n            return obj\n\n    @deprecated.classic.deprecated\n    class MyClass(with_metaclass(Meta)):\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(\"five\")\n\n    assert len(warns) == 1\n\n    assert obj.a == \"five\"\n    assert obj.b == 5\n    assert obj.c == 3.14\n\n\ndef test_with_singleton_metaclass():\n    class Singleton(type):\n        _instances = {}\n\n        def __call__(cls, *args, **kwargs):\n            if cls not in cls._instances:\n                cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n            return cls._instances[cls]\n\n    @deprecated.classic.deprecated\n    class MyClass(with_metaclass(Singleton)):\n        def __init__(self, a, b=5):\n            self.a = a\n            self.b = b\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj1 = MyClass(\"five\")\n        obj2 = MyClass(\"six\", b=6)\n\n    # __new__ is called only once:\n    # the instance is constructed only once,\n    # so we have only one warning.\n    assert len(warns) == 1\n\n    assert obj1.a == \"five\"\n    assert obj1.b == 5\n    assert obj2 is obj1\n", "tests/__init__.py": "", "tests/test_deprecated_class.py": "# coding: utf-8\nfrom __future__ import print_function\n\nimport inspect\nimport io\nimport warnings\n\nimport deprecated.classic\n\n\ndef test_simple_class_deprecation():\n    # stream is used to store the deprecation message for testing\n    stream = io.StringIO()\n\n    # To deprecate a class, it is better to emit a message when ``__new__`` is called.\n    # The simplest way is to override the ``__new__``method.\n    class MyBaseClass(object):\n        def __new__(cls, *args, **kwargs):\n            print(u\"I am deprecated!\", file=stream)\n            return super(MyBaseClass, cls).__new__(cls, *args, **kwargs)\n\n    # Of course, the subclass will be deprecated too\n    class MySubClass(MyBaseClass):\n        pass\n\n    obj = MySubClass()\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert stream.getvalue().strip() == u\"I am deprecated!\"\n\n\ndef test_class_deprecation_using_wrapper():\n    # stream is used to store the deprecation message for testing\n    stream = io.StringIO()\n\n    class MyBaseClass(object):\n        pass\n\n    # To deprecated the class, we use a wrapper function which emits\n    # the deprecation message and calls ``__new__```.\n\n    original_new = MyBaseClass.__new__\n\n    def wrapped_new(unused, *args, **kwargs):\n        print(u\"I am deprecated!\", file=stream)\n        return original_new(*args, **kwargs)\n\n    # Like ``__new__``, this wrapper is a class method.\n    # It is used to patch the original ``__new__``method.\n    MyBaseClass.__new__ = classmethod(wrapped_new)\n\n    class MySubClass(MyBaseClass):\n        pass\n\n    obj = MySubClass()\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert stream.getvalue().strip() == u\"I am deprecated!\"\n\n\ndef test_class_deprecation_using_a_simple_decorator():\n    # stream is used to store the deprecation message for testing\n    stream = io.StringIO()\n\n    # To deprecated the class, we use a simple decorator\n    # which patches the original ``__new__`` method.\n\n    def simple_decorator(wrapped_cls):\n        old_new = wrapped_cls.__new__\n\n        def wrapped_new(unused, *args, **kwargs):\n            print(u\"I am deprecated!\", file=stream)\n            return old_new(*args, **kwargs)\n\n        wrapped_cls.__new__ = classmethod(wrapped_new)\n        return wrapped_cls\n\n    @simple_decorator\n    class MyBaseClass(object):\n        pass\n\n    class MySubClass(MyBaseClass):\n        pass\n\n    obj = MySubClass()\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert stream.getvalue().strip() == u\"I am deprecated!\"\n\n\ndef test_class_deprecation_using_deprecated_decorator():\n    @deprecated.classic.deprecated\n    class MyBaseClass(object):\n        pass\n\n    class MySubClass(MyBaseClass):\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MySubClass()\n\n    assert len(warns) == 1\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert issubclass(MySubClass, MyBaseClass)\n\n\ndef test_class_respect_global_filter():\n    @deprecated.classic.deprecated\n    class MyBaseClass(object):\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"once\")\n        obj = MyBaseClass()\n        obj = MyBaseClass()\n\n    assert len(warns) == 1\n\n\ndef test_subclass_deprecation_using_deprecated_decorator():\n    @deprecated.classic.deprecated\n    class MyBaseClass(object):\n        pass\n\n    @deprecated.classic.deprecated\n    class MySubClass(MyBaseClass):\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MySubClass()\n\n    assert len(warns) == 2\n    assert isinstance(obj, MyBaseClass)\n    assert inspect.isclass(MyBaseClass)\n    assert issubclass(MySubClass, MyBaseClass)\n\n\ndef test_simple_class_deprecation_with_args():\n    @deprecated.classic.deprecated('kwargs class')\n    class MyClass(object):\n        def __init__(self, arg):\n            super(MyClass, self).__init__()\n            self.args = arg\n\n    MyClass(5)\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = MyClass(5)\n\n    assert len(warns) == 1\n    assert isinstance(obj, MyClass)\n    assert inspect.isclass(MyClass)\n", "tests/test_sphinx.py": "# coding: utf-8\nfrom __future__ import print_function\n\nimport re\nimport sys\nimport textwrap\nimport warnings\n\nimport pytest\n\nimport deprecated.sphinx\n\n\n@pytest.fixture(\n    scope=\"module\",\n    params=[\n        None,\n        \"\"\"This function adds *x* and *y*.\"\"\",\n        \"\"\"\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        \"\"\",\n        \"\"\"This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        \"\"\",\n    ],\n    ids=[\"no_docstring\", \"short_docstring\", \"D213_long_docstring\", \"D212_long_docstring\"],\n)\ndef docstring(request):\n    return request.param\n\n\n@pytest.fixture(scope=\"module\", params=['versionadded', 'versionchanged', 'deprecated'])\ndef directive(request):\n    return request.param\n\n\n# noinspection PyShadowingNames\n@pytest.mark.parametrize(\n    \"reason, version, expected\",\n    [\n        (\n            'A good reason',\n            '1.2.0',\n            textwrap.dedent(\n                \"\"\"\\\n                .. {directive}:: {version}\n                   {reason}\n                \"\"\"\n            ),\n        ),\n        (\n            None,\n            '1.2.0',\n            textwrap.dedent(\n                \"\"\"\\\n                .. {directive}:: {version}\n                \"\"\"\n            ),\n        ),\n    ],\n    ids=[\"reason&version\", \"version\"],\n)\ndef test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n    # The function:\n    def foo(x, y):\n        return x + y\n\n    # with docstring:\n    foo.__doc__ = docstring\n\n    # is decorated with:\n    decorator_factory = getattr(deprecated.sphinx, directive)\n    decorator = decorator_factory(reason=reason, version=version)\n    foo = decorator(foo)\n\n    # The function must contains this Sphinx docstring:\n    expected = expected.format(directive=directive, version=version, reason=reason)\n\n    current = textwrap.dedent(foo.__doc__)\n    assert current.endswith(expected)\n\n    current = current.replace(expected, '')\n    if docstring:\n        # An empty line must separate the original docstring and the directive.\n        assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n    else:\n        # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n        assert current == \"\\n\"\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo(1, 2)\n\n    if directive in {'versionadded', 'versionchanged'}:\n        # don't emit DeprecationWarning\n        assert len(warns) == 0\n    else:\n        # emit DeprecationWarning\n        assert len(warns) == 1\n\n\n# noinspection PyShadowingNames\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\n@pytest.mark.parametrize(\n    \"reason, version, expected\",\n    [\n        (\n            'A good reason',\n            '1.2.0',\n            textwrap.dedent(\n                \"\"\"\\\n                .. {directive}:: {version}\n                   {reason}\n                \"\"\"\n            ),\n        ),\n        (\n            None,\n            '1.2.0',\n            textwrap.dedent(\n                \"\"\"\\\n                .. {directive}:: {version}\n                \"\"\"\n            ),\n        ),\n    ],\n    ids=[\"reason&version\", \"version\"],\n)\ndef test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):\n    # The class:\n    class Foo(object):\n        pass\n\n    # with docstring:\n    Foo.__doc__ = docstring\n\n    # is decorated with:\n    decorator_factory = getattr(deprecated.sphinx, directive)\n    decorator = decorator_factory(reason=reason, version=version)\n    Foo = decorator(Foo)\n\n    # The class must contain this Sphinx docstring:\n    expected = expected.format(directive=directive, version=version, reason=reason)\n\n    current = textwrap.dedent(Foo.__doc__)\n    assert current.endswith(expected)\n\n    current = current.replace(expected, '')\n    if docstring:\n        # An empty line must separate the original docstring and the directive.\n        assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n    else:\n        # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n        assert current == \"\\n\"\n\n    with warnings.catch_warnings(record=True) as warns:\n        Foo()\n\n    if directive in {'versionadded', 'versionchanged'}:\n        # don't emit DeprecationWarning\n        assert len(warns) == 0\n    else:\n        # emit DeprecationWarning\n        assert len(warns) == 1\n\n\nclass MyDeprecationWarning(DeprecationWarning):\n    pass\n\n\n_PARAMS = [\n    {'version': '1.2.3'},\n    {'version': '1.2.3', 'reason': 'Good reason'},\n    {'version': '1.2.3', 'action': 'once'},\n    {'version': '1.2.3', 'category': MyDeprecationWarning},\n]\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef sphinx_deprecated_function(request):\n    kwargs = request.param\n\n    @deprecated.sphinx.deprecated(**kwargs)\n    def foo1():\n        pass\n\n    return foo1\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef sphinx_deprecated_class(request):\n    kwargs = request.param\n\n    @deprecated.sphinx.deprecated(**kwargs)\n    class Foo2(object):\n        pass\n\n    return Foo2\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef sphinx_deprecated_method(request):\n    kwargs = request.param\n\n    class Foo3(object):\n        @deprecated.sphinx.deprecated(**kwargs)\n        def foo3(self):\n            pass\n\n    return Foo3\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef sphinx_deprecated_static_method(request):\n    kwargs = request.param\n\n    class Foo4(object):\n        @staticmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n        def foo4():\n            pass\n\n    return Foo4.foo4\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef sphinx_deprecated_class_method(request):\n    kwargs = request.param\n\n    class Foo5(object):\n        @classmethod\n        @deprecated.sphinx.deprecated(**kwargs)\n        def foo5(cls):\n            pass\n\n    return Foo5\n\n\n# noinspection PyShadowingNames\ndef test_sphinx_deprecated_function__warns(sphinx_deprecated_function):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        sphinx_deprecated_function()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated function (or staticmethod)\" in str(warn.message)\n\n\n# noinspection PyShadowingNames\n@pytest.mark.skipif(\n    sys.version_info < (3, 3), reason=\"Classes should have mutable docstrings -- resolved in python 3.3\"\n)\ndef test_sphinx_deprecated_class__warns(sphinx_deprecated_class):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        sphinx_deprecated_class()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated class\" in str(warn.message)\n\n\n# noinspection PyShadowingNames\ndef test_sphinx_deprecated_method__warns(sphinx_deprecated_method):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = sphinx_deprecated_method()\n        obj.foo3()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated method\" in str(warn.message)\n\n\n# noinspection PyShadowingNames\ndef test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        sphinx_deprecated_static_method()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated function (or staticmethod)\" in str(warn.message)\n\n\n# noinspection PyShadowingNames\ndef test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        cls = sphinx_deprecated_class_method()\n        cls.foo5()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    if sys.version_info >= (3, 9):\n        assert \"deprecated class method\" in str(warn.message)\n    else:\n        assert \"deprecated function (or staticmethod)\" in str(warn.message)\n\n\ndef test_should_raise_type_error():\n    try:\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=5)\n        def foo():\n            pass\n\n        assert False, \"TypeError not raised\"\n    except TypeError:\n        pass\n\n\ndef test_warning_msg_has_reason():\n    reason = \"Good reason\"\n\n    @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert reason in str(warn.message)\n\n\ndef test_warning_msg_has_version():\n    version = \"1.2.3\"\n\n    @deprecated.sphinx.deprecated(version=version)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert version in str(warn.message)\n\n\ndef test_warning_is_ignored():\n    @deprecated.sphinx.deprecated(version=\"4.5.6\", action='ignore')\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    assert len(warns) == 0\n\n\ndef test_specific_warning_cls_is_used():\n    @deprecated.sphinx.deprecated(version=\"4.5.6\", category=MyDeprecationWarning)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert issubclass(warn.category, MyDeprecationWarning)\n\n\ndef test_can_catch_warnings():\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        warnings.warn(\"A message in a bottle\", category=DeprecationWarning, stacklevel=2)\n    assert len(warns) == 1\n\n\n@pytest.mark.parametrize(\n    [\"reason\", \"expected\"],\n    [\n        (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n        (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n    ],\n)\ndef test_sphinx_syntax_trimming(reason, expected):\n    @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert expected in str(warn.message)\n\n\n# noinspection SpellCheckingInspection\n@pytest.mark.parametrize(\n    \"reason, expected\",\n    [\n        # classic examples using the default domain (Python)\n        (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n        (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n        (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n        (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n        (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n        (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n        (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n        # other examples using a domain :\n        (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n        (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n        (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n        # the reference can have special characters:\n        (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n        # edge cases:\n        (\"Use :r:`` instead\", \"Use `` instead\"),\n        (\"Use :d:r:`` instead\", \"Use `` instead\"),\n        (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n        (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n        (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n        (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n        (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n    ],\n)\ndef test_get_deprecated_msg(reason, expected):\n    adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n    actual = adapter.get_deprecated_msg(lambda: None, None)\n    assert expected in actual\n", "tests/test_deprecated.py": "# -*- coding: utf-8 -*-\nimport inspect\nimport sys\nimport warnings\n\nimport pytest\n\nimport deprecated.classic\n\n\nclass MyDeprecationWarning(DeprecationWarning):\n    pass\n\n\nclass WrongStackLevelWarning(DeprecationWarning):\n    pass\n\n\n_PARAMS = [\n    None,\n    ((), {}),\n    (('Good reason',), {}),\n    ((), {'reason': 'Good reason'}),\n    ((), {'version': '1.2.3'}),\n    ((), {'action': 'once'}),\n    ((), {'category': MyDeprecationWarning}),\n    ((), {'extra_stacklevel': 1, 'category': WrongStackLevelWarning}),\n]\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef classic_deprecated_function(request):\n    if request.param is None:\n\n        @deprecated.classic.deprecated\n        def foo1():\n            pass\n\n        return foo1\n    else:\n        args, kwargs = request.param\n\n        @deprecated.classic.deprecated(*args, **kwargs)\n        def foo1():\n            pass\n\n        return foo1\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef classic_deprecated_class(request):\n    if request.param is None:\n\n        @deprecated.classic.deprecated\n        class Foo2(object):\n            pass\n\n        return Foo2\n    else:\n        args, kwargs = request.param\n\n        @deprecated.classic.deprecated(*args, **kwargs)\n        class Foo2(object):\n            pass\n\n        return Foo2\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef classic_deprecated_method(request):\n    if request.param is None:\n\n        class Foo3(object):\n            @deprecated.classic.deprecated\n            def foo3(self):\n                pass\n\n        return Foo3\n    else:\n        args, kwargs = request.param\n\n        class Foo3(object):\n            @deprecated.classic.deprecated(*args, **kwargs)\n            def foo3(self):\n                pass\n\n        return Foo3\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef classic_deprecated_static_method(request):\n    if request.param is None:\n\n        class Foo4(object):\n            @staticmethod\n            @deprecated.classic.deprecated\n            def foo4():\n                pass\n\n        return Foo4.foo4\n    else:\n        args, kwargs = request.param\n\n        class Foo4(object):\n            @staticmethod\n            @deprecated.classic.deprecated(*args, **kwargs)\n            def foo4():\n                pass\n\n        return Foo4.foo4\n\n\n@pytest.fixture(scope=\"module\", params=_PARAMS)\ndef classic_deprecated_class_method(request):\n    if request.param is None:\n\n        class Foo5(object):\n            @classmethod\n            @deprecated.classic.deprecated\n            def foo5(cls):\n                pass\n\n        return Foo5\n    else:\n        args, kwargs = request.param\n\n        class Foo5(object):\n            @classmethod\n            @deprecated.classic.deprecated(*args, **kwargs)\n            def foo5(cls):\n                pass\n\n        return Foo5\n\n\n# noinspection PyShadowingNames\ndef test_classic_deprecated_function__warns(classic_deprecated_function):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        classic_deprecated_function()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated function (or staticmethod)\" in str(warn.message)\n    assert warn.filename == __file__ or warn.category is WrongStackLevelWarning, 'Incorrect warning stackLevel'\n\n\n# noinspection PyShadowingNames\ndef test_classic_deprecated_class__warns(classic_deprecated_class):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        classic_deprecated_class()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated class\" in str(warn.message)\n    assert warn.filename == __file__ or warn.category is WrongStackLevelWarning, 'Incorrect warning stackLevel'\n\n\n# noinspection PyShadowingNames\ndef test_classic_deprecated_method__warns(classic_deprecated_method):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        obj = classic_deprecated_method()\n        obj.foo3()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated method\" in str(warn.message)\n    assert warn.filename == __file__ or warn.category is WrongStackLevelWarning, 'Incorrect warning stackLevel'\n\n\n# noinspection PyShadowingNames\ndef test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        classic_deprecated_static_method()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    assert \"deprecated function (or staticmethod)\" in str(warn.message)\n    assert warn.filename == __file__ or warn.category is WrongStackLevelWarning, 'Incorrect warning stackLevel'\n\n\n# noinspection PyShadowingNames\ndef test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        cls = classic_deprecated_class_method()\n        cls.foo5()\n    assert len(warns) == 1\n    warn = warns[0]\n    assert issubclass(warn.category, DeprecationWarning)\n    if sys.version_info >= (3, 9):\n        assert \"deprecated class method\" in str(warn.message)\n    else:\n        assert \"deprecated function (or staticmethod)\" in str(warn.message)\n    assert warn.filename == __file__ or warn.category is WrongStackLevelWarning, 'Incorrect warning stackLevel'\n\n\ndef test_should_raise_type_error():\n    try:\n        deprecated.classic.deprecated(5)\n        assert False, \"TypeError not raised\"\n    except TypeError:\n        pass\n\n\ndef test_warning_msg_has_reason():\n    reason = \"Good reason\"\n\n    @deprecated.classic.deprecated(reason=reason)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert reason in str(warn.message)\n\n\ndef test_warning_msg_has_version():\n    version = \"1.2.3\"\n\n    @deprecated.classic.deprecated(version=version)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert version in str(warn.message)\n\n\ndef test_warning_is_ignored():\n    @deprecated.classic.deprecated(action='ignore')\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    assert len(warns) == 0\n\n\ndef test_specific_warning_cls_is_used():\n    @deprecated.classic.deprecated(category=MyDeprecationWarning)\n    def foo():\n        pass\n\n    with warnings.catch_warnings(record=True) as warns:\n        foo()\n    warn = warns[0]\n    assert issubclass(warn.category, MyDeprecationWarning)\n\n\ndef test_respect_global_filter():\n    @deprecated.classic.deprecated(version='1.2.1', reason=\"deprecated function\")\n    def fun():\n        print(\"fun\")\n\n    warnings.simplefilter(\"once\", category=DeprecationWarning)\n\n    with warnings.catch_warnings(record=True) as warns:\n        fun()\n        fun()\n    assert len(warns) == 1\n\n\ndef test_default_stacklevel():\n    \"\"\"\n    The objective of this unit test is to ensure that the triggered warning message,\n    when invoking the 'use_foo' function, correctly indicates the line where the\n    deprecated 'foo' function is called.\n    \"\"\"\n\n    @deprecated.classic.deprecated\n    def foo():\n        pass\n\n    def use_foo():\n        foo()\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        use_foo()\n\n    # Check that the warning path matches the module path\n    warn = warns[0]\n    assert warn.filename == __file__\n\n    # Check that the line number points to the first line inside 'use_foo'\n    use_foo_lineno = inspect.getsourcelines(use_foo)[1]\n    assert warn.lineno == use_foo_lineno + 1\n\n\ndef test_extra_stacklevel():\n    \"\"\"\n    The unit test utilizes an 'extra_stacklevel' of 1 to ensure that the warning message\n    accurately identifies the caller of the deprecated function. It verifies that when\n    the 'use_foo' function is called, the warning message correctly indicates the line\n    where the call to 'use_foo' is made.\n    \"\"\"\n\n    @deprecated.classic.deprecated(extra_stacklevel=1)\n    def foo():\n        pass\n\n    def use_foo():\n        foo()\n\n    def demo():\n        use_foo()\n\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.simplefilter(\"always\")\n        demo()\n\n    # Check that the warning path matches the module path\n    warn = warns[0]\n    assert warn.filename == __file__\n\n    # Check that the line number points to the first line inside 'demo'\n    demo_lineno = inspect.getsourcelines(demo)[1]\n    assert warn.lineno == demo_lineno + 1\n", "tests/test.py": "# coding: utf-8\nimport pkg_resources\n\nimport deprecated\n\n\ndef test_deprecated_has_docstring():\n    # The deprecated package must have a docstring\n    assert deprecated.__doc__ is not None\n    assert \"Deprecated Library\" in deprecated.__doc__\n\n\ndef test_deprecated_has_version():\n    # The deprecated package must have a valid version number\n    assert deprecated.__version__ is not None\n    version = pkg_resources.parse_version(deprecated.__version__)\n\n    # .. note::\n    #\n    #    The classes ``SetuptoolsVersion`` and ``SetuptoolsLegacyVersion``\n    #    are removed since setuptools >= 39.\n    #    They are replaced by ``Version`` and ``LegacyVersion`` respectively.\n    #\n    #    To check if the version is good, we now use the solution explained here:\n    #    https://github.com/pypa/setuptools/issues/1299\n\n    assert 'Legacy' not in version.__class__.__name__\n", "deprecated/sphinx.py": "# coding: utf-8\n\"\"\"\nSphinx directive integration\n============================\n\nWe usually need to document the life-cycle of functions and classes:\nwhen they are created, modified or deprecated.\n\nTo do that, `Sphinx <http://www.sphinx-doc.org>`_ has a set\nof `Paragraph-level markups <http://www.sphinx-doc.org/en/stable/markup/para.html>`_:\n\n- ``versionadded``: to document the version of the project which added the described feature to the library,\n- ``versionchanged``: to document changes of a feature,\n- ``deprecated``: to document a deprecated feature.\n\nThe purpose of this module is to defined decorators which adds this Sphinx directives\nto the docstring of your function and classes.\n\nOf course, the ``@deprecated`` decorator will emit a deprecation warning\nwhen the function/method is called or the class is constructed.\n\"\"\"\nimport re\nimport textwrap\n\nfrom deprecated.classic import ClassicAdapter\nfrom deprecated.classic import deprecated as _classic_deprecated\n\n\nclass SphinxAdapter(ClassicAdapter):\n    \"\"\"\n    Sphinx adapter -- *for advanced usage only*\n\n    This adapter override the :class:`~deprecated.classic.ClassicAdapter`\n    in order to add the Sphinx directives to the end of the function/class docstring.\n    Such a directive is a `Paragraph-level markup <http://www.sphinx-doc.org/en/stable/markup/para.html>`_\n\n    - The directive can be one of \"versionadded\", \"versionchanged\" or \"deprecated\".\n    - The version number is added if provided.\n    - The reason message is obviously added in the directive block if not empty.\n    \"\"\"\n\n    def __init__(\n        self,\n        directive,\n        reason=\"\",\n        version=\"\",\n        action=None,\n        category=DeprecationWarning,\n        extra_stacklevel=0,\n        line_length=70,\n    ):\n        \"\"\"\n        Construct a wrapper adapter.\n\n        :type  directive: str\n        :param directive:\n            Sphinx directive: can be one of \"versionadded\", \"versionchanged\" or \"deprecated\".\n\n        :type  reason: str\n        :param reason:\n            Reason message which documents the deprecation in your library (can be omitted).\n\n        :type  version: str\n        :param version:\n            Version of your project which deprecates this feature.\n            If you follow the `Semantic Versioning <https://semver.org/>`_,\n            the version number has the format \"MAJOR.MINOR.PATCH\".\n\n        :type  action: Literal[\"default\", \"error\", \"ignore\", \"always\", \"module\", \"once\"]\n        :param action:\n            A warning filter used to activate or not the deprecation warning.\n            Can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n            If ``None`` or empty, the global filtering mechanism is used.\n            See: `The Warnings Filter`_ in the Python documentation.\n\n        :type  category: Type[Warning]\n        :param category:\n            The warning category to use for the deprecation warning.\n            By default, the category class is :class:`~DeprecationWarning`,\n            you can inherit this class to define your own deprecation warning category.\n\n        :type  extra_stacklevel: int\n        :param extra_stacklevel:\n            Number of additional stack levels to consider instrumentation rather than user code.\n            With the default value of 0, the warning refers to where the class was instantiated\n            or the function was called.\n\n        :type  line_length: int\n        :param line_length:\n            Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n        .. versionchanged:: 1.2.15\n            Add the *extra_stacklevel* parameter.\n        \"\"\"\n        if not version:\n            # https://github.com/tantale/deprecated/issues/40\n            raise ValueError(\"'version' argument is required in Sphinx directives\")\n        self.directive = directive\n        self.line_length = line_length\n        super(SphinxAdapter, self).__init__(\n            reason=reason, version=version, action=action, category=category, extra_stacklevel=extra_stacklevel\n        )\n\n    def __call__(self, wrapped):\n        \"\"\"\n        Add the Sphinx directive to your class or function.\n\n        :param wrapped: Wrapped class or function.\n\n        :return: the decorated class or function.\n        \"\"\"\n        # -- build the directive division\n        fmt = \".. {directive}:: {version}\" if self.version else \".. {directive}::\"\n        div_lines = [fmt.format(directive=self.directive, version=self.version)]\n        width = self.line_length - 3 if self.line_length > 3 else 2**16\n        reason = textwrap.dedent(self.reason).strip()\n        for paragraph in reason.splitlines():\n            if paragraph:\n                div_lines.extend(\n                    textwrap.fill(\n                        paragraph,\n                        width=width,\n                        initial_indent=\"   \",\n                        subsequent_indent=\"   \",\n                    ).splitlines()\n                )\n            else:\n                div_lines.append(\"\")\n\n        # -- get the docstring, normalize the trailing newlines\n        # keep a consistent behaviour if the docstring starts with newline or directly on the first one\n        docstring = wrapped.__doc__ or \"\"\n        lines = docstring.splitlines(True) or [\"\"]\n        docstring = textwrap.dedent(\"\".join(lines[1:])) if len(lines) > 1 else \"\"\n        docstring = lines[0] + docstring\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            docstring = re.sub(r\"\\n+$\", \"\", docstring, flags=re.DOTALL) + \"\\n\\n\"\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            docstring = \"\\n\"\n\n        # -- append the directive division to the docstring\n        docstring += \"\".join(\"{}\\n\".format(line) for line in div_lines)\n\n        wrapped.__doc__ = docstring\n        if self.directive in {\"versionadded\", \"versionchanged\"}:\n            return wrapped\n        return super(SphinxAdapter, self).__call__(wrapped)\n\n    def get_deprecated_msg(self, wrapped, instance):\n        \"\"\"\n        Get the deprecation warning message (without Sphinx cross-referencing syntax) for the user.\n\n        :param wrapped: Wrapped class or function.\n\n        :param instance: The object to which the wrapped function was bound when it was called.\n\n        :return: The warning message.\n\n        .. versionadded:: 1.2.12\n           Strip Sphinx cross-referencing syntax from warning message.\n\n        \"\"\"\n        msg = super(SphinxAdapter, self).get_deprecated_msg(wrapped, instance)\n        # Strip Sphinx cross-reference syntax (like \":function:\", \":py:func:\" and \":py:meth:\")\n        # Possible values are \":role:`foo`\", \":domain:role:`foo`\"\n        # where ``role`` and ``domain`` should match \"[a-zA-Z]+\"\n        msg = re.sub(r\"(?: : [a-zA-Z]+ )? : [a-zA-Z]+ : (`[^`]*`)\", r\"\\1\", msg, flags=re.X)\n        return msg\n\n\ndef versionadded(reason=\"\", version=\"\", line_length=70):\n    \"\"\"\n    This decorator can be used to insert a \"versionadded\" directive\n    in your function/class docstring in order to document the\n    version of the project which adds this new functionality in your library.\n\n    :param str reason:\n        Reason message which documents the addition in your library (can be omitted).\n\n    :param str version:\n        Version of your project which adds this feature.\n        If you follow the `Semantic Versioning <https://semver.org/>`_,\n        the version number has the format \"MAJOR.MINOR.PATCH\", and,\n        in the case of a new functionality, the \"PATCH\" component should be \"0\".\n\n    :type  line_length: int\n    :param line_length:\n        Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n    :return: the decorated function.\n    \"\"\"\n    adapter = SphinxAdapter(\n        'versionadded',\n        reason=reason,\n        version=version,\n        line_length=line_length,\n    )\n    return adapter\n\n\ndef versionchanged(reason=\"\", version=\"\", line_length=70):\n    \"\"\"\n    This decorator can be used to insert a \"versionchanged\" directive\n    in your function/class docstring in order to document the\n    version of the project which modifies this functionality in your library.\n\n    :param str reason:\n        Reason message which documents the modification in your library (can be omitted).\n\n    :param str version:\n        Version of your project which modifies this feature.\n        If you follow the `Semantic Versioning <https://semver.org/>`_,\n        the version number has the format \"MAJOR.MINOR.PATCH\".\n\n    :type  line_length: int\n    :param line_length:\n        Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n    :return: the decorated function.\n    \"\"\"\n    adapter = SphinxAdapter(\n        'versionchanged',\n        reason=reason,\n        version=version,\n        line_length=line_length,\n    )\n    return adapter\n\n\ndef deprecated(reason=\"\", version=\"\", line_length=70, **kwargs):\n    \"\"\"\n    This decorator can be used to insert a \"deprecated\" directive\n    in your function/class docstring in order to document the\n    version of the project which deprecates this functionality in your library.\n\n    :param str reason:\n        Reason message which documents the deprecation in your library (can be omitted).\n\n    :param str version:\n        Version of your project which deprecates this feature.\n        If you follow the `Semantic Versioning <https://semver.org/>`_,\n        the version number has the format \"MAJOR.MINOR.PATCH\".\n\n    :type  line_length: int\n    :param line_length:\n        Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n    Keyword arguments can be:\n\n    -   \"action\":\n        A warning filter used to activate or not the deprecation warning.\n        Can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the global filtering mechanism is used.\n\n    -   \"category\":\n        The warning category to use for the deprecation warning.\n        By default, the category class is :class:`~DeprecationWarning`,\n        you can inherit this class to define your own deprecation warning category.\n\n    -   \"extra_stacklevel\":\n        Number of additional stack levels to consider instrumentation rather than user code.\n        With the default value of 0, the warning refers to where the class was instantiated\n        or the function was called.\n\n\n    :return: a decorator used to deprecate a function.\n\n    .. versionchanged:: 1.2.13\n       Change the signature of the decorator to reflect the valid use cases.\n\n    .. versionchanged:: 1.2.15\n        Add the *extra_stacklevel* parameter.\n    \"\"\"\n    directive = kwargs.pop('directive', 'deprecated')\n    adapter_cls = kwargs.pop('adapter_cls', SphinxAdapter)\n    kwargs[\"reason\"] = reason\n    kwargs[\"version\"] = version\n    kwargs[\"line_length\"] = line_length\n    return _classic_deprecated(directive=directive, adapter_cls=adapter_cls, **kwargs)\n", "deprecated/classic.py": "# -*- coding: utf-8 -*-\n\"\"\"\nClassic deprecation warning\n===========================\n\nClassic ``@deprecated`` decorator to deprecate old python classes, functions or methods.\n\n.. _The Warnings Filter: https://docs.python.org/3/library/warnings.html#the-warnings-filter\n\"\"\"\nimport functools\nimport inspect\nimport platform\nimport warnings\n\nimport wrapt\n\ntry:\n    # If the C extension for wrapt was compiled and wrapt/_wrappers.pyd exists, then the\n    # stack level that should be passed to warnings.warn should be 2. However, if using\n    # a pure python wrapt, an extra stacklevel is required.\n    import wrapt._wrappers\n\n    _routine_stacklevel = 2\n    _class_stacklevel = 2\nexcept ImportError:\n    _routine_stacklevel = 3\n    if platform.python_implementation() == \"PyPy\":\n        _class_stacklevel = 2\n    else:\n        _class_stacklevel = 3\n\nstring_types = (type(b''), type(u''))\n\n\nclass ClassicAdapter(wrapt.AdapterFactory):\n    \"\"\"\n    Classic adapter -- *for advanced usage only*\n\n    This adapter is used to get the deprecation message according to the wrapped object type:\n    class, function, standard method, static method, or class method.\n\n    This is the base class of the :class:`~deprecated.sphinx.SphinxAdapter` class\n    which is used to update the wrapped object docstring.\n\n    You can also inherit this class to change the deprecation message.\n\n    In the following example, we change the message into \"The ... is deprecated.\":\n\n    .. code-block:: python\n\n       import inspect\n\n       from deprecated.classic import ClassicAdapter\n       from deprecated.classic import deprecated\n\n\n       class MyClassicAdapter(ClassicAdapter):\n           def get_deprecated_msg(self, wrapped, instance):\n               if instance is None:\n                   if inspect.isclass(wrapped):\n                       fmt = \"The class {name} is deprecated.\"\n                   else:\n                       fmt = \"The function {name} is deprecated.\"\n               else:\n                   if inspect.isclass(instance):\n                       fmt = \"The class method {name} is deprecated.\"\n                   else:\n                       fmt = \"The method {name} is deprecated.\"\n               if self.reason:\n                   fmt += \" ({reason})\"\n               if self.version:\n                   fmt += \" -- Deprecated since version {version}.\"\n               return fmt.format(name=wrapped.__name__,\n                                 reason=self.reason or \"\",\n                                 version=self.version or \"\")\n\n    Then, you can use your ``MyClassicAdapter`` class like this in your source code:\n\n    .. code-block:: python\n\n       @deprecated(reason=\"use another function\", adapter_cls=MyClassicAdapter)\n       def some_old_function(x, y):\n           return x + y\n    \"\"\"\n\n    def __init__(self, reason=\"\", version=\"\", action=None, category=DeprecationWarning, extra_stacklevel=0):\n        \"\"\"\n        Construct a wrapper adapter.\n\n        :type  reason: str\n        :param reason:\n            Reason message which documents the deprecation in your library (can be omitted).\n\n        :type  version: str\n        :param version:\n            Version of your project which deprecates this feature.\n            If you follow the `Semantic Versioning <https://semver.org/>`_,\n            the version number has the format \"MAJOR.MINOR.PATCH\".\n\n        :type  action: Literal[\"default\", \"error\", \"ignore\", \"always\", \"module\", \"once\"]\n        :param action:\n            A warning filter used to activate or not the deprecation warning.\n            Can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n            If ``None`` or empty, the global filtering mechanism is used.\n            See: `The Warnings Filter`_ in the Python documentation.\n\n        :type  category: Type[Warning]\n        :param category:\n            The warning category to use for the deprecation warning.\n            By default, the category class is :class:`~DeprecationWarning`,\n            you can inherit this class to define your own deprecation warning category.\n\n        :type  extra_stacklevel: int\n        :param extra_stacklevel:\n            Number of additional stack levels to consider instrumentation rather than user code.\n            With the default value of 0, the warning refers to where the class was instantiated\n            or the function was called.\n\n        .. versionchanged:: 1.2.15\n            Add the *extra_stacklevel* parameter.\n        \"\"\"\n        self.reason = reason or \"\"\n        self.version = version or \"\"\n        self.action = action\n        self.category = category\n        self.extra_stacklevel = extra_stacklevel\n        super(ClassicAdapter, self).__init__()\n\n    def get_deprecated_msg(self, wrapped, instance):\n        \"\"\"\n        Get the deprecation warning message for the user.\n\n        :param wrapped: Wrapped class or function.\n\n        :param instance: The object to which the wrapped function was bound when it was called.\n\n        :return: The warning message.\n        \"\"\"\n        if instance is None:\n            if inspect.isclass(wrapped):\n                fmt = \"Call to deprecated class {name}.\"\n            else:\n                fmt = \"Call to deprecated function (or staticmethod) {name}.\"\n        else:\n            if inspect.isclass(instance):\n                fmt = \"Call to deprecated class method {name}.\"\n            else:\n                fmt = \"Call to deprecated method {name}.\"\n        if self.reason:\n            fmt += \" ({reason})\"\n        if self.version:\n            fmt += \" -- Deprecated since version {version}.\"\n        return fmt.format(name=wrapped.__name__, reason=self.reason or \"\", version=self.version or \"\")\n\n    def __call__(self, wrapped):\n        \"\"\"\n        Decorate your class or function.\n\n        :param wrapped: Wrapped class or function.\n\n        :return: the decorated class or function.\n\n        .. versionchanged:: 1.2.4\n           Don't pass arguments to :meth:`object.__new__` (other than *cls*).\n\n        .. versionchanged:: 1.2.8\n           The warning filter is not set if the *action* parameter is ``None`` or empty.\n        \"\"\"\n        if inspect.isclass(wrapped):\n            old_new1 = wrapped.__new__\n\n            def wrapped_cls(cls, *args, **kwargs):\n                msg = self.get_deprecated_msg(wrapped, None)\n                stacklevel = _class_stacklevel + self.extra_stacklevel\n                if self.action:\n                    with warnings.catch_warnings():\n                        warnings.simplefilter(self.action, self.category)\n                        warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                else:\n                    warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                if old_new1 is object.__new__:\n                    return old_new1(cls)\n                # actually, we don't know the real signature of *old_new1*\n                return old_new1(cls, *args, **kwargs)\n\n            wrapped.__new__ = staticmethod(wrapped_cls)\n\n        elif inspect.isroutine(wrapped):\n            @wrapt.decorator\n            def wrapper_function(wrapped_, instance_, args_, kwargs_):\n                msg = self.get_deprecated_msg(wrapped_, instance_)\n                stacklevel = _routine_stacklevel + self.extra_stacklevel\n                if self.action:\n                    with warnings.catch_warnings():\n                        warnings.simplefilter(self.action, self.category)\n                        warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                else:\n                    warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                return wrapped_(*args_, **kwargs_)\n\n            return wrapper_function(wrapped)\n\n        else:\n            raise TypeError(repr(type(wrapped)))\n\n        return wrapped\n\n\ndef deprecated(*args, **kwargs):\n    \"\"\"\n    This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n    when the function is used.\n\n    **Classic usage:**\n\n    To use this, decorate your deprecated function with **@deprecated** decorator:\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated\n       def some_old_function(x, y):\n           return x + y\n\n    You can also decorate a class or a method:\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       class SomeClass(object):\n           @deprecated\n           def some_old_method(self, x, y):\n               return x + y\n\n\n       @deprecated\n       class SomeOldClass(object):\n           pass\n\n    You can give a *reason* message to help the developer to choose another function/class,\n    and a *version* number to specify the starting version number of the deprecation.\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated(reason=\"use another function\", version='1.2.0')\n       def some_old_function(x, y):\n           return x + y\n\n    The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n    By default, :exc:`DeprecationWarning` is used, but you can choose :exc:`FutureWarning`,\n    :exc:`PendingDeprecationWarning` or a custom subclass.\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated(category=PendingDeprecationWarning)\n       def some_old_function(x, y):\n           return x + y\n\n    The *action* keyword argument allow you to locally change the warning filtering.\n    *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n    If ``None``, empty or missing, the global filtering mechanism is used.\n    See: `The Warnings Filter`_ in the Python documentation.\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated(action=\"error\")\n       def some_old_function(x, y):\n           return x + y\n\n    The *extra_stacklevel* keyword argument allows you to specify additional stack levels\n    to consider instrumentation rather than user code. With the default value of 0, the\n    warning refers to where the class was instantiated or the function was called.\n    \"\"\"\n    if args and isinstance(args[0], string_types):\n        kwargs['reason'] = args[0]\n        args = args[1:]\n\n    if args and not callable(args[0]):\n        raise TypeError(repr(type(args[0])))\n\n    if args:\n        adapter_cls = kwargs.pop('adapter_cls', ClassicAdapter)\n        adapter = adapter_cls(**kwargs)\n        wrapped = args[0]\n        return adapter(wrapped)\n\n    return functools.partial(deprecated, **kwargs)\n", "deprecated/__init__.py": "# -*- coding: utf-8 -*-\n\"\"\"\nDeprecated Library\n==================\n\nPython ``@deprecated`` decorator to deprecate old python classes, functions or methods.\n\n\"\"\"\n\n__version__ = \"1.2.14\"\n__author__ = u\"Laurent LAPORTE <tantale.solutions@gmail.com>\"\n__date__ = \"2023-05-27\"\n__credits__ = \"(c) Laurent LAPORTE\"\n\nfrom deprecated.classic import deprecated\n"}