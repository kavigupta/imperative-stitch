{"setup.py": "#!/usr/bin/env python\n#  -*- coding: utf-8 -*-\nu\"\"\"\nDeprecated Library\n------------------\n\nDeprecated is Easy to Use\n`````````````````````````\n\nIf you need to mark a function or a method as deprecated,\nyou can use the ``@deprecated`` decorator:\n\nSave in a hello.py:\n\n.. code:: python\n\n    from deprecated import deprecated\n\n\n    @deprecated(version='1.2.1', reason=\"You should use another function\")\n    def some_old_function(x, y):\n        return x + y\n\n\n    class SomeClass(object):\n        @deprecated(version='1.3.0', reason=\"This method is deprecated\")\n        def some_old_method(self, x, y):\n            return x + y\n\n\n    some_old_function(12, 34)\n    obj = SomeClass()\n    obj.some_old_method(5, 8)\n\n\nAnd Easy to Setup\n`````````````````\n\nAnd run it:\n\n.. code:: bash\n\n    $ pip install Deprecated\n    $ python hello.py\n    hello.py:15: DeprecationWarning: Call to deprecated function (or staticmethod) some_old_function.\n    (You should use another function) -- Deprecated since version 1.2.0.\n      some_old_function(12, 34)\n    hello.py:17: DeprecationWarning: Call to deprecated method some_old_method.\n    (This method is deprecated) -- Deprecated since version 1.3.0.\n      obj.some_old_method(5, 8)\n\n\nYou can document your code\n``````````````````````````\n\nHave you ever wonder how to document that some functions, classes, methods, etc. are deprecated?\nThis is now possible with the integrated Sphinx directives:\n\nFor instance, in hello_sphinx.py:\n\n.. code:: python\n\n    from deprecated.sphinx import deprecated\n    from deprecated.sphinx import versionadded\n    from deprecated.sphinx import versionchanged\n\n\n    @versionadded(version='1.0', reason=\"This function is new\")\n    def function_one():\n        '''This is the function one'''\n\n\n    @versionchanged(version='1.0', reason=\"This function is modified\")\n    def function_two():\n        '''This is the function two'''\n\n\n    @deprecated(version='1.0', reason=\"This function will be removed soon\")\n    def function_three():\n        '''This is the function three'''\n\n\n    function_one()\n    function_two()\n    function_three()  # warns\n\n    help(function_one)\n    help(function_two)\n    help(function_three)\n\n\nThe result it immediate\n```````````````````````\n\nRun it:\n\n.. code:: bash\n\n    $ python hello_sphinx.py\n\n    hello_sphinx.py:23: DeprecationWarning: Call to deprecated function (or staticmethod) function_three.\n    (This function will be removed soon) -- Deprecated since version 1.0.\n      function_three()  # warns\n\n    Help on function function_one in module __main__:\n\n    function_one()\n        This is the function one\n\n        .. versionadded:: 1.0\n           This function is new\n\n    Help on function function_two in module __main__:\n\n    function_two()\n        This is the function two\n\n        .. versionchanged:: 1.0\n           This function is modified\n\n    Help on function function_three in module __main__:\n\n    function_three()\n        This is the function three\n\n        .. deprecated:: 1.0\n           This function will be removed soon\n\n\nLinks\n`````\n\n* `Python package index (PyPi) <https://pypi.python.org/pypi/deprecated>`_\n* `GitHub website <https://github.com/tantale/deprecated>`_\n* `Read The Docs <https://readthedocs.org/projects/deprecated>`_\n* `EBook on Lulu.com <http://www.lulu.com/commerce/index.php?fBuyContent=21305117>`_\n* `StackOverFlow Q&A <https://stackoverflow.com/a/40301488/1513933>`_\n* `Development version\n  <https://github.com/tantale/deprecated/zipball/master#egg=Deprecated-dev>`_\n\n\"\"\"\nfrom setuptools import setup\n\nsetup(\n    name='Deprecated',\n    version='1.2.14',\n    url='https://github.com/tantale/deprecated',\n    project_urls={\n        \"Documentation\": \"https://deprecated.readthedocs.io/en/latest/\",\n        \"Source\": \"https://github.com/tantale/deprecated\",\n        \"Bug Tracker\": \"https://github.com/tantale/deprecated/issues\",\n    },\n    license='MIT',\n    author='Laurent LAPORTE',  # since v1.1.0\n    author_email='tantale.solutions@gmail.com',\n    description='Python @deprecated decorator to deprecate old python classes, functions or methods.',\n    long_description=__doc__,\n    long_description_content_type=\"text/x-rst\",\n    keywords='deprecate,deprecated,deprecation,warning,warn,decorator',\n    packages=['deprecated'],\n    install_requires=['wrapt < 2, >= 1.10'],\n    zip_safe=False,\n    include_package_data=True,\n    platforms='any',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Web Environment',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    extras_require={\n        'dev': [\n            'tox',\n            'PyTest',\n            'PyTest-Cov',\n            'bump2version < 1',\n            'sphinx < 2',\n            # jinja2 3.0.3 was the last version to have contextfunction that sphinx 1.x needs\n            'jinja2~=3.0.3',\n        ]\n    },\n    python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*',\n)\n", "deprecated/sphinx.py": "# coding: utf-8\n\"\"\"\nSphinx directive integration\n============================\n\nWe usually need to document the life-cycle of functions and classes:\nwhen they are created, modified or deprecated.\n\nTo do that, `Sphinx <http://www.sphinx-doc.org>`_ has a set\nof `Paragraph-level markups <http://www.sphinx-doc.org/en/stable/markup/para.html>`_:\n\n- ``versionadded``: to document the version of the project which added the described feature to the library,\n- ``versionchanged``: to document changes of a feature,\n- ``deprecated``: to document a deprecated feature.\n\nThe purpose of this module is to defined decorators which adds this Sphinx directives\nto the docstring of your function and classes.\n\nOf course, the ``@deprecated`` decorator will emit a deprecation warning\nwhen the function/method is called or the class is constructed.\n\"\"\"\nimport re\nimport textwrap\n\nfrom deprecated.classic import ClassicAdapter\nfrom deprecated.classic import deprecated as _classic_deprecated\n\n\nclass SphinxAdapter(ClassicAdapter):\n    \"\"\"\n    Sphinx adapter -- *for advanced usage only*\n\n    This adapter override the :class:`~deprecated.classic.ClassicAdapter`\n    in order to add the Sphinx directives to the end of the function/class docstring.\n    Such a directive is a `Paragraph-level markup <http://www.sphinx-doc.org/en/stable/markup/para.html>`_\n\n    - The directive can be one of \"versionadded\", \"versionchanged\" or \"deprecated\".\n    - The version number is added if provided.\n    - The reason message is obviously added in the directive block if not empty.\n    \"\"\"\n\n    def __init__(\n        self,\n        directive,\n        reason=\"\",\n        version=\"\",\n        action=None,\n        category=DeprecationWarning,\n        extra_stacklevel=0,\n        line_length=70,\n    ):\n        \"\"\"\n        Construct a wrapper adapter.\n\n        :type  directive: str\n        :param directive:\n            Sphinx directive: can be one of \"versionadded\", \"versionchanged\" or \"deprecated\".\n\n        :type  reason: str\n        :param reason:\n            Reason message which documents the deprecation in your library (can be omitted).\n\n        :type  version: str\n        :param version:\n            Version of your project which deprecates this feature.\n            If you follow the `Semantic Versioning <https://semver.org/>`_,\n            the version number has the format \"MAJOR.MINOR.PATCH\".\n\n        :type  action: Literal[\"default\", \"error\", \"ignore\", \"always\", \"module\", \"once\"]\n        :param action:\n            A warning filter used to activate or not the deprecation warning.\n            Can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n            If ``None`` or empty, the global filtering mechanism is used.\n            See: `The Warnings Filter`_ in the Python documentation.\n\n        :type  category: Type[Warning]\n        :param category:\n            The warning category to use for the deprecation warning.\n            By default, the category class is :class:`~DeprecationWarning`,\n            you can inherit this class to define your own deprecation warning category.\n\n        :type  extra_stacklevel: int\n        :param extra_stacklevel:\n            Number of additional stack levels to consider instrumentation rather than user code.\n            With the default value of 0, the warning refers to where the class was instantiated\n            or the function was called.\n\n        :type  line_length: int\n        :param line_length:\n            Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n        .. versionchanged:: 1.2.15\n            Add the *extra_stacklevel* parameter.\n        \"\"\"\n        if not version:\n            # https://github.com/tantale/deprecated/issues/40\n            raise ValueError(\"'version' argument is required in Sphinx directives\")\n        self.directive = directive\n        self.line_length = line_length\n        super(SphinxAdapter, self).__init__(\n            reason=reason, version=version, action=action, category=category, extra_stacklevel=extra_stacklevel\n        )\n\n    def __call__(self, wrapped):\n        \"\"\"\n        Add the Sphinx directive to your class or function.\n\n        :param wrapped: Wrapped class or function.\n\n        :return: the decorated class or function.\n        \"\"\"\n        # -- build the directive division\n        fmt = \".. {directive}:: {version}\" if self.version else \".. {directive}::\"\n        div_lines = [fmt.format(directive=self.directive, version=self.version)]\n        width = self.line_length - 3 if self.line_length > 3 else 2**16\n        reason = textwrap.dedent(self.reason).strip()\n        for paragraph in reason.splitlines():\n            if paragraph:\n                div_lines.extend(\n                    textwrap.fill(\n                        paragraph,\n                        width=width,\n                        initial_indent=\"   \",\n                        subsequent_indent=\"   \",\n                    ).splitlines()\n                )\n            else:\n                div_lines.append(\"\")\n\n        # -- get the docstring, normalize the trailing newlines\n        # keep a consistent behaviour if the docstring starts with newline or directly on the first one\n        docstring = wrapped.__doc__ or \"\"\n        lines = docstring.splitlines(True) or [\"\"]\n        docstring = textwrap.dedent(\"\".join(lines[1:])) if len(lines) > 1 else \"\"\n        docstring = lines[0] + docstring\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            docstring = re.sub(r\"\\n+$\", \"\", docstring, flags=re.DOTALL) + \"\\n\\n\"\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            docstring = \"\\n\"\n\n        # -- append the directive division to the docstring\n        docstring += \"\".join(\"{}\\n\".format(line) for line in div_lines)\n\n        wrapped.__doc__ = docstring\n        if self.directive in {\"versionadded\", \"versionchanged\"}:\n            return wrapped\n        return super(SphinxAdapter, self).__call__(wrapped)\n\n    def get_deprecated_msg(self, wrapped, instance):\n        \"\"\"\n        Get the deprecation warning message (without Sphinx cross-referencing syntax) for the user.\n\n        :param wrapped: Wrapped class or function.\n\n        :param instance: The object to which the wrapped function was bound when it was called.\n\n        :return: The warning message.\n\n        .. versionadded:: 1.2.12\n           Strip Sphinx cross-referencing syntax from warning message.\n\n        \"\"\"\n        msg = super(SphinxAdapter, self).get_deprecated_msg(wrapped, instance)\n        # Strip Sphinx cross-reference syntax (like \":function:\", \":py:func:\" and \":py:meth:\")\n        # Possible values are \":role:`foo`\", \":domain:role:`foo`\"\n        # where ``role`` and ``domain`` should match \"[a-zA-Z]+\"\n        msg = re.sub(r\"(?: : [a-zA-Z]+ )? : [a-zA-Z]+ : (`[^`]*`)\", r\"\\1\", msg, flags=re.X)\n        return msg\n\n\ndef versionadded(reason=\"\", version=\"\", line_length=70):\n    \"\"\"\n    This decorator can be used to insert a \"versionadded\" directive\n    in your function/class docstring in order to document the\n    version of the project which adds this new functionality in your library.\n\n    :param str reason:\n        Reason message which documents the addition in your library (can be omitted).\n\n    :param str version:\n        Version of your project which adds this feature.\n        If you follow the `Semantic Versioning <https://semver.org/>`_,\n        the version number has the format \"MAJOR.MINOR.PATCH\", and,\n        in the case of a new functionality, the \"PATCH\" component should be \"0\".\n\n    :type  line_length: int\n    :param line_length:\n        Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n    :return: the decorated function.\n    \"\"\"\n    adapter = SphinxAdapter(\n        'versionadded',\n        reason=reason,\n        version=version,\n        line_length=line_length,\n    )\n    return adapter\n\n\ndef versionchanged(reason=\"\", version=\"\", line_length=70):\n    \"\"\"\n    This decorator can be used to insert a \"versionchanged\" directive\n    in your function/class docstring in order to document the\n    version of the project which modifies this functionality in your library.\n\n    :param str reason:\n        Reason message which documents the modification in your library (can be omitted).\n\n    :param str version:\n        Version of your project which modifies this feature.\n        If you follow the `Semantic Versioning <https://semver.org/>`_,\n        the version number has the format \"MAJOR.MINOR.PATCH\".\n\n    :type  line_length: int\n    :param line_length:\n        Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n    :return: the decorated function.\n    \"\"\"\n    adapter = SphinxAdapter(\n        'versionchanged',\n        reason=reason,\n        version=version,\n        line_length=line_length,\n    )\n    return adapter\n\n\ndef deprecated(reason=\"\", version=\"\", line_length=70, **kwargs):\n    \"\"\"\n    This decorator can be used to insert a \"deprecated\" directive\n    in your function/class docstring in order to document the\n    version of the project which deprecates this functionality in your library.\n\n    :param str reason:\n        Reason message which documents the deprecation in your library (can be omitted).\n\n    :param str version:\n        Version of your project which deprecates this feature.\n        If you follow the `Semantic Versioning <https://semver.org/>`_,\n        the version number has the format \"MAJOR.MINOR.PATCH\".\n\n    :type  line_length: int\n    :param line_length:\n        Max line length of the directive text. If non nul, a long text is wrapped in several lines.\n\n    Keyword arguments can be:\n\n    -   \"action\":\n        A warning filter used to activate or not the deprecation warning.\n        Can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the global filtering mechanism is used.\n\n    -   \"category\":\n        The warning category to use for the deprecation warning.\n        By default, the category class is :class:`~DeprecationWarning`,\n        you can inherit this class to define your own deprecation warning category.\n\n    -   \"extra_stacklevel\":\n        Number of additional stack levels to consider instrumentation rather than user code.\n        With the default value of 0, the warning refers to where the class was instantiated\n        or the function was called.\n\n\n    :return: a decorator used to deprecate a function.\n\n    .. versionchanged:: 1.2.13\n       Change the signature of the decorator to reflect the valid use cases.\n\n    .. versionchanged:: 1.2.15\n        Add the *extra_stacklevel* parameter.\n    \"\"\"\n    directive = kwargs.pop('directive', 'deprecated')\n    adapter_cls = kwargs.pop('adapter_cls', SphinxAdapter)\n    kwargs[\"reason\"] = reason\n    kwargs[\"version\"] = version\n    kwargs[\"line_length\"] = line_length\n    return _classic_deprecated(directive=directive, adapter_cls=adapter_cls, **kwargs)\n", "deprecated/classic.py": "# -*- coding: utf-8 -*-\n\"\"\"\nClassic deprecation warning\n===========================\n\nClassic ``@deprecated`` decorator to deprecate old python classes, functions or methods.\n\n.. _The Warnings Filter: https://docs.python.org/3/library/warnings.html#the-warnings-filter\n\"\"\"\nimport functools\nimport inspect\nimport platform\nimport warnings\n\nimport wrapt\n\ntry:\n    # If the C extension for wrapt was compiled and wrapt/_wrappers.pyd exists, then the\n    # stack level that should be passed to warnings.warn should be 2. However, if using\n    # a pure python wrapt, an extra stacklevel is required.\n    import wrapt._wrappers\n\n    _routine_stacklevel = 2\n    _class_stacklevel = 2\nexcept ImportError:\n    _routine_stacklevel = 3\n    if platform.python_implementation() == \"PyPy\":\n        _class_stacklevel = 2\n    else:\n        _class_stacklevel = 3\n\nstring_types = (type(b''), type(u''))\n\n\nclass ClassicAdapter(wrapt.AdapterFactory):\n    \"\"\"\n    Classic adapter -- *for advanced usage only*\n\n    This adapter is used to get the deprecation message according to the wrapped object type:\n    class, function, standard method, static method, or class method.\n\n    This is the base class of the :class:`~deprecated.sphinx.SphinxAdapter` class\n    which is used to update the wrapped object docstring.\n\n    You can also inherit this class to change the deprecation message.\n\n    In the following example, we change the message into \"The ... is deprecated.\":\n\n    .. code-block:: python\n\n       import inspect\n\n       from deprecated.classic import ClassicAdapter\n       from deprecated.classic import deprecated\n\n\n       class MyClassicAdapter(ClassicAdapter):\n           def get_deprecated_msg(self, wrapped, instance):\n               if instance is None:\n                   if inspect.isclass(wrapped):\n                       fmt = \"The class {name} is deprecated.\"\n                   else:\n                       fmt = \"The function {name} is deprecated.\"\n               else:\n                   if inspect.isclass(instance):\n                       fmt = \"The class method {name} is deprecated.\"\n                   else:\n                       fmt = \"The method {name} is deprecated.\"\n               if self.reason:\n                   fmt += \" ({reason})\"\n               if self.version:\n                   fmt += \" -- Deprecated since version {version}.\"\n               return fmt.format(name=wrapped.__name__,\n                                 reason=self.reason or \"\",\n                                 version=self.version or \"\")\n\n    Then, you can use your ``MyClassicAdapter`` class like this in your source code:\n\n    .. code-block:: python\n\n       @deprecated(reason=\"use another function\", adapter_cls=MyClassicAdapter)\n       def some_old_function(x, y):\n           return x + y\n    \"\"\"\n\n    def __init__(self, reason=\"\", version=\"\", action=None, category=DeprecationWarning, extra_stacklevel=0):\n        \"\"\"\n        Construct a wrapper adapter.\n\n        :type  reason: str\n        :param reason:\n            Reason message which documents the deprecation in your library (can be omitted).\n\n        :type  version: str\n        :param version:\n            Version of your project which deprecates this feature.\n            If you follow the `Semantic Versioning <https://semver.org/>`_,\n            the version number has the format \"MAJOR.MINOR.PATCH\".\n\n        :type  action: Literal[\"default\", \"error\", \"ignore\", \"always\", \"module\", \"once\"]\n        :param action:\n            A warning filter used to activate or not the deprecation warning.\n            Can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n            If ``None`` or empty, the global filtering mechanism is used.\n            See: `The Warnings Filter`_ in the Python documentation.\n\n        :type  category: Type[Warning]\n        :param category:\n            The warning category to use for the deprecation warning.\n            By default, the category class is :class:`~DeprecationWarning`,\n            you can inherit this class to define your own deprecation warning category.\n\n        :type  extra_stacklevel: int\n        :param extra_stacklevel:\n            Number of additional stack levels to consider instrumentation rather than user code.\n            With the default value of 0, the warning refers to where the class was instantiated\n            or the function was called.\n\n        .. versionchanged:: 1.2.15\n            Add the *extra_stacklevel* parameter.\n        \"\"\"\n        self.reason = reason or \"\"\n        self.version = version or \"\"\n        self.action = action\n        self.category = category\n        self.extra_stacklevel = extra_stacklevel\n        super(ClassicAdapter, self).__init__()\n\n    def get_deprecated_msg(self, wrapped, instance):\n        \"\"\"\n        Get the deprecation warning message for the user.\n\n        :param wrapped: Wrapped class or function.\n\n        :param instance: The object to which the wrapped function was bound when it was called.\n\n        :return: The warning message.\n        \"\"\"\n        if instance is None:\n            if inspect.isclass(wrapped):\n                fmt = \"Call to deprecated class {name}.\"\n            else:\n                fmt = \"Call to deprecated function (or staticmethod) {name}.\"\n        else:\n            if inspect.isclass(instance):\n                fmt = \"Call to deprecated class method {name}.\"\n            else:\n                fmt = \"Call to deprecated method {name}.\"\n        if self.reason:\n            fmt += \" ({reason})\"\n        if self.version:\n            fmt += \" -- Deprecated since version {version}.\"\n        return fmt.format(name=wrapped.__name__, reason=self.reason or \"\", version=self.version or \"\")\n\n    def __call__(self, wrapped):\n        \"\"\"\n        Decorate your class or function.\n\n        :param wrapped: Wrapped class or function.\n\n        :return: the decorated class or function.\n\n        .. versionchanged:: 1.2.4\n           Don't pass arguments to :meth:`object.__new__` (other than *cls*).\n\n        .. versionchanged:: 1.2.8\n           The warning filter is not set if the *action* parameter is ``None`` or empty.\n        \"\"\"\n        if inspect.isclass(wrapped):\n            old_new1 = wrapped.__new__\n\n            def wrapped_cls(cls, *args, **kwargs):\n                msg = self.get_deprecated_msg(wrapped, None)\n                stacklevel = _class_stacklevel + self.extra_stacklevel\n                if self.action:\n                    with warnings.catch_warnings():\n                        warnings.simplefilter(self.action, self.category)\n                        warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                else:\n                    warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                if old_new1 is object.__new__:\n                    return old_new1(cls)\n                # actually, we don't know the real signature of *old_new1*\n                return old_new1(cls, *args, **kwargs)\n\n            wrapped.__new__ = staticmethod(wrapped_cls)\n\n        elif inspect.isroutine(wrapped):\n            @wrapt.decorator\n            def wrapper_function(wrapped_, instance_, args_, kwargs_):\n                msg = self.get_deprecated_msg(wrapped_, instance_)\n                stacklevel = _routine_stacklevel + self.extra_stacklevel\n                if self.action:\n                    with warnings.catch_warnings():\n                        warnings.simplefilter(self.action, self.category)\n                        warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                else:\n                    warnings.warn(msg, category=self.category, stacklevel=stacklevel)\n                return wrapped_(*args_, **kwargs_)\n\n            return wrapper_function(wrapped)\n\n        else:\n            raise TypeError(repr(type(wrapped)))\n\n        return wrapped\n\n\ndef deprecated(*args, **kwargs):\n    \"\"\"\n    This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n    when the function is used.\n\n    **Classic usage:**\n\n    To use this, decorate your deprecated function with **@deprecated** decorator:\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated\n       def some_old_function(x, y):\n           return x + y\n\n    You can also decorate a class or a method:\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       class SomeClass(object):\n           @deprecated\n           def some_old_method(self, x, y):\n               return x + y\n\n\n       @deprecated\n       class SomeOldClass(object):\n           pass\n\n    You can give a *reason* message to help the developer to choose another function/class,\n    and a *version* number to specify the starting version number of the deprecation.\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated(reason=\"use another function\", version='1.2.0')\n       def some_old_function(x, y):\n           return x + y\n\n    The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n    By default, :exc:`DeprecationWarning` is used, but you can choose :exc:`FutureWarning`,\n    :exc:`PendingDeprecationWarning` or a custom subclass.\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated(category=PendingDeprecationWarning)\n       def some_old_function(x, y):\n           return x + y\n\n    The *action* keyword argument allow you to locally change the warning filtering.\n    *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n    If ``None``, empty or missing, the global filtering mechanism is used.\n    See: `The Warnings Filter`_ in the Python documentation.\n\n    .. code-block:: python\n\n       from deprecated import deprecated\n\n\n       @deprecated(action=\"error\")\n       def some_old_function(x, y):\n           return x + y\n\n    The *extra_stacklevel* keyword argument allows you to specify additional stack levels\n    to consider instrumentation rather than user code. With the default value of 0, the\n    warning refers to where the class was instantiated or the function was called.\n    \"\"\"\n    if args and isinstance(args[0], string_types):\n        kwargs['reason'] = args[0]\n        args = args[1:]\n\n    if args and not callable(args[0]):\n        raise TypeError(repr(type(args[0])))\n\n    if args:\n        adapter_cls = kwargs.pop('adapter_cls', ClassicAdapter)\n        adapter = adapter_cls(**kwargs)\n        wrapped = args[0]\n        return adapter(wrapped)\n\n    return functools.partial(deprecated, **kwargs)\n", "deprecated/__init__.py": "# -*- coding: utf-8 -*-\n\"\"\"\nDeprecated Library\n==================\n\nPython ``@deprecated`` decorator to deprecate old python classes, functions or methods.\n\n\"\"\"\n\n__version__ = \"1.2.14\"\n__author__ = u\"Laurent LAPORTE <tantale.solutions@gmail.com>\"\n__date__ = \"2023-05-27\"\n__credits__ = \"(c) Laurent LAPORTE\"\n\nfrom deprecated.classic import deprecated\n"}