{"create_timing_table.py": "#!/usr/bin/env python\n#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nimport time\nimport rsa\n\npoolsize = 8\naccurate = True\n\n\ndef run_speed_test(bitsize):\n    iterations = 0\n    start = end = time.time()\n\n    # At least a number of iterations, and at least 2 seconds\n    while iterations < 10 or end - start < 2:\n        iterations += 1\n        rsa.newkeys(bitsize, accurate=accurate, poolsize=poolsize)\n        end = time.time()\n\n    duration = end - start\n    dur_per_call = duration / iterations\n\n    print('%5i bit: %9.3f sec. (%i iterations over %.1f seconds)' %\n          (bitsize, dur_per_call, iterations, duration))\n\n\nif __name__ == '__main__':\n    for bitsize in (128, 256, 384, 512, 1024, 2048, 3072, 4096):\n        run_speed_test(bitsize)\n", "rsa/asn1.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"ASN.1 definitions.\n\nNot all ASN.1-handling code use these definitions, but when it does, they should be here.\n\"\"\"\n\nfrom pyasn1.type import univ, namedtype, tag\n\n\nclass PubKeyHeader(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\"oid\", univ.ObjectIdentifier()),\n        namedtype.NamedType(\"parameters\", univ.Null()),\n    )\n\n\nclass OpenSSLPubKey(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\"header\", PubKeyHeader()),\n        # This little hack (the implicit tag) allows us to get a Bit String as Octet String\n        namedtype.NamedType(\n            \"key\",\n            univ.OctetString().subtype(implicitTag=tag.Tag(tagClass=0, tagFormat=0, tagId=3)),\n        ),\n    )\n\n\nclass AsnPubKey(univ.Sequence):\n    \"\"\"ASN.1 contents of DER encoded public key:\n\n    RSAPublicKey ::= SEQUENCE {\n         modulus           INTEGER,  -- n\n         publicExponent    INTEGER,  -- e\n    \"\"\"\n\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\"modulus\", univ.Integer()),\n        namedtype.NamedType(\"publicExponent\", univ.Integer()),\n    )\n", "rsa/common.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Common functionality shared by several modules.\"\"\"\n\nimport typing\n\n\nclass NotRelativePrimeError(ValueError):\n    def __init__(self, a: int, b: int, d: int, msg: str = \"\") -> None:\n        super().__init__(msg or \"%d and %d are not relatively prime, divider=%i\" % (a, b, d))\n        self.a = a\n        self.b = b\n        self.d = d\n\n\ndef bit_size(num: int) -> int:\n    \"\"\"\n    Number of bits needed to represent a integer excluding any prefix\n    0 bits.\n\n    Usage::\n\n        >>> bit_size(1023)\n        10\n        >>> bit_size(1024)\n        11\n        >>> bit_size(1025)\n        11\n\n    :param num:\n        Integer value. If num is 0, returns 0. Only the absolute value of the\n        number is considered. Therefore, signed integers will be abs(num)\n        before the number's bit length is determined.\n    :returns:\n        Returns the number of bits in the integer.\n    \"\"\"\n\n    try:\n        return num.bit_length()\n    except AttributeError as ex:\n        raise TypeError(\"bit_size(num) only supports integers, not %r\" % type(num)) from ex\n\n\ndef byte_size(number: int) -> int:\n    \"\"\"\n    Returns the number of bytes required to hold a specific long number.\n\n    The number of bytes is rounded up.\n\n    Usage::\n\n        >>> byte_size(1 << 1023)\n        128\n        >>> byte_size((1 << 1024) - 1)\n        128\n        >>> byte_size(1 << 1024)\n        129\n\n    :param number:\n        An unsigned integer\n    :returns:\n        The number of bytes required to hold a specific long number.\n    \"\"\"\n    if number == 0:\n        return 1\n    return ceil_div(bit_size(number), 8)\n\n\ndef ceil_div(num: int, div: int) -> int:\n    \"\"\"\n    Returns the ceiling function of a division between `num` and `div`.\n\n    Usage::\n\n        >>> ceil_div(100, 7)\n        15\n        >>> ceil_div(100, 10)\n        10\n        >>> ceil_div(1, 4)\n        1\n\n    :param num: Division's numerator, a number\n    :param div: Division's divisor, a number\n\n    :return: Rounded up result of the division between the parameters.\n    \"\"\"\n    quanta, mod = divmod(num, div)\n    if mod:\n        quanta += 1\n    return quanta\n\n\ndef extended_gcd(a: int, b: int) -> typing.Tuple[int, int, int]:\n    \"\"\"Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb\"\"\"\n    # r = gcd(a,b) i = multiplicitive inverse of a mod b\n    #      or      j = multiplicitive inverse of b mod a\n    # Neg return values for i or j are made positive mod b or a respectively\n    # Iterateive Version is faster and uses much less stack space\n    x = 0\n    y = 1\n    lx = 1\n    ly = 0\n    oa = a  # Remember original a/b to remove\n    ob = b  # negative values from return results\n    while b != 0:\n        q = a // b\n        (a, b) = (b, a % b)\n        (x, lx) = ((lx - (q * x)), x)\n        (y, ly) = ((ly - (q * y)), y)\n    if lx < 0:\n        lx += ob  # If neg wrap modulo original b\n    if ly < 0:\n        ly += oa  # If neg wrap modulo original a\n    return a, lx, ly  # Return only positive values\n\n\ndef inverse(x: int, n: int) -> int:\n    \"\"\"Returns the inverse of x % n under multiplication, a.k.a x^-1 (mod n)\n\n    >>> inverse(7, 4)\n    3\n    >>> (inverse(143, 4) * 143) % 4\n    1\n    \"\"\"\n\n    (divider, inv, _) = extended_gcd(x, n)\n\n    if divider != 1:\n        raise NotRelativePrimeError(x, n, divider)\n\n    return inv\n\n\ndef crt(a_values: typing.Iterable[int], modulo_values: typing.Iterable[int]) -> int:\n    \"\"\"Chinese Remainder Theorem.\n\n    Calculates x such that x = a[i] (mod m[i]) for each i.\n\n    :param a_values: the a-values of the above equation\n    :param modulo_values: the m-values of the above equation\n    :returns: x such that x = a[i] (mod m[i]) for each i\n\n\n    >>> crt([2, 3], [3, 5])\n    8\n\n    >>> crt([2, 3, 2], [3, 5, 7])\n    23\n\n    >>> crt([2, 3, 0], [7, 11, 15])\n    135\n    \"\"\"\n\n    m = 1\n    x = 0\n\n    for modulo in modulo_values:\n        m *= modulo\n\n    for (m_i, a_i) in zip(modulo_values, a_values):\n        M_i = m // m_i\n        inv = inverse(M_i, m_i)\n\n        x = (x + a_i * M_i * inv) % m\n\n    return x\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "rsa/cli.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Commandline scripts.\n\nThese scripts are called by the executables defined in setup.py.\n\"\"\"\n\nimport abc\nimport sys\nimport typing\nimport optparse\n\nimport rsa\nimport rsa.key\nimport rsa.pkcs1\n\nHASH_METHODS = sorted(rsa.pkcs1.HASH_METHODS.keys())\nIndexable = typing.Union[typing.Tuple, typing.List[str]]\n\n\ndef keygen() -> None:\n    \"\"\"Key generator.\"\"\"\n\n    # Parse the CLI options\n    parser = optparse.OptionParser(\n        usage=\"usage: %prog [options] keysize\",\n        description='Generates a new RSA key pair of \"keysize\" bits.',\n    )\n\n    parser.add_option(\n        \"--pubout\",\n        type=\"string\",\n        help=\"Output filename for the public key. The public key is \"\n        \"not saved if this option is not present. You can use \"\n        \"pyrsa-priv2pub to create the public key file later.\",\n    )\n\n    parser.add_option(\n        \"-o\",\n        \"--out\",\n        type=\"string\",\n        help=\"Output filename for the private key. The key is \"\n        \"written to stdout if this option is not present.\",\n    )\n\n    parser.add_option(\n        \"--form\",\n        help=\"key format of the private and public keys - default PEM\",\n        choices=(\"PEM\", \"DER\"),\n        default=\"PEM\",\n    )\n\n    (cli, cli_args) = parser.parse_args(sys.argv[1:])\n\n    if len(cli_args) != 1:\n        parser.print_help()\n        raise SystemExit(1)\n\n    try:\n        keysize = int(cli_args[0])\n    except ValueError as ex:\n        parser.print_help()\n        print(\"Not a valid number: %s\" % cli_args[0], file=sys.stderr)\n        raise SystemExit(1) from ex\n\n    print(\"Generating %i-bit key\" % keysize, file=sys.stderr)\n    (pub_key, priv_key) = rsa.newkeys(keysize)\n\n    # Save public key\n    if cli.pubout:\n        print(\"Writing public key to %s\" % cli.pubout, file=sys.stderr)\n        data = pub_key.save_pkcs1(format=cli.form)\n        with open(cli.pubout, \"wb\") as outfile:\n            outfile.write(data)\n\n    # Save private key\n    data = priv_key.save_pkcs1(format=cli.form)\n\n    if cli.out:\n        print(\"Writing private key to %s\" % cli.out, file=sys.stderr)\n        with open(cli.out, \"wb\") as outfile:\n            outfile.write(data)\n    else:\n        print(\"Writing private key to stdout\", file=sys.stderr)\n        sys.stdout.buffer.write(data)\n\n\nclass CryptoOperation(metaclass=abc.ABCMeta):\n    \"\"\"CLI callable that operates with input, output, and a key.\"\"\"\n\n    keyname = \"public\"  # or 'private'\n    usage = \"usage: %%prog [options] %(keyname)s_key\"\n    description = \"\"\n    operation = \"decrypt\"\n    operation_past = \"decrypted\"\n    operation_progressive = \"decrypting\"\n    input_help = \"Name of the file to %(operation)s. Reads from stdin if \" \"not specified.\"\n    output_help = (\n        \"Name of the file to write the %(operation_past)s file \"\n        \"to. Written to stdout if this option is not present.\"\n    )\n    expected_cli_args = 1\n    has_output = True\n\n    key_class = rsa.PublicKey  # type: typing.Type[rsa.key.AbstractKey]\n\n    def __init__(self) -> None:\n        self.usage = self.usage % self.__class__.__dict__\n        self.input_help = self.input_help % self.__class__.__dict__\n        self.output_help = self.output_help % self.__class__.__dict__\n\n    @abc.abstractmethod\n    def perform_operation(\n        self, indata: bytes, key: rsa.key.AbstractKey, cli_args: Indexable\n    ) -> typing.Any:\n        \"\"\"Performs the program's operation.\n\n        Implement in a subclass.\n\n        :returns: the data to write to the output.\n        \"\"\"\n\n    def __call__(self) -> None:\n        \"\"\"Runs the program.\"\"\"\n\n        (cli, cli_args) = self.parse_cli()\n\n        key = self.read_key(cli_args[0], cli.keyform)\n\n        indata = self.read_infile(cli.input)\n\n        print(self.operation_progressive.title(), file=sys.stderr)\n        outdata = self.perform_operation(indata, key, cli_args)\n\n        if self.has_output:\n            self.write_outfile(outdata, cli.output)\n\n    def parse_cli(self) -> typing.Tuple[optparse.Values, typing.List[str]]:\n        \"\"\"Parse the CLI options\n\n        :returns: (cli_opts, cli_args)\n        \"\"\"\n\n        parser = optparse.OptionParser(usage=self.usage, description=self.description)\n\n        parser.add_option(\"-i\", \"--input\", type=\"string\", help=self.input_help)\n\n        if self.has_output:\n            parser.add_option(\"-o\", \"--output\", type=\"string\", help=self.output_help)\n\n        parser.add_option(\n            \"--keyform\",\n            help=\"Key format of the %s key - default PEM\" % self.keyname,\n            choices=(\"PEM\", \"DER\"),\n            default=\"PEM\",\n        )\n\n        (cli, cli_args) = parser.parse_args(sys.argv[1:])\n\n        if len(cli_args) != self.expected_cli_args:\n            parser.print_help()\n            raise SystemExit(1)\n\n        return cli, cli_args\n\n    def read_key(self, filename: str, keyform: str) -> rsa.key.AbstractKey:\n        \"\"\"Reads a public or private key.\"\"\"\n\n        print(\"Reading %s key from %s\" % (self.keyname, filename), file=sys.stderr)\n        with open(filename, \"rb\") as keyfile:\n            keydata = keyfile.read()\n\n        return self.key_class.load_pkcs1(keydata, keyform)\n\n    def read_infile(self, inname: str) -> bytes:\n        \"\"\"Read the input file\"\"\"\n\n        if inname:\n            print(\"Reading input from %s\" % inname, file=sys.stderr)\n            with open(inname, \"rb\") as infile:\n                return infile.read()\n\n        print(\"Reading input from stdin\", file=sys.stderr)\n        return sys.stdin.buffer.read()\n\n    def write_outfile(self, outdata: bytes, outname: str) -> None:\n        \"\"\"Write the output file\"\"\"\n\n        if outname:\n            print(\"Writing output to %s\" % outname, file=sys.stderr)\n            with open(outname, \"wb\") as outfile:\n                outfile.write(outdata)\n        else:\n            print(\"Writing output to stdout\", file=sys.stderr)\n            sys.stdout.buffer.write(outdata)\n\n\nclass EncryptOperation(CryptoOperation):\n    \"\"\"Encrypts a file.\"\"\"\n\n    keyname = \"public\"\n    description = (\n        \"Encrypts a file. The file must be shorter than the key \" \"length in order to be encrypted.\"\n    )\n    operation = \"encrypt\"\n    operation_past = \"encrypted\"\n    operation_progressive = \"encrypting\"\n\n    def perform_operation(\n        self, indata: bytes, pub_key: rsa.key.AbstractKey, cli_args: Indexable = ()\n    ) -> bytes:\n        \"\"\"Encrypts files.\"\"\"\n        assert isinstance(pub_key, rsa.key.PublicKey)\n        return rsa.encrypt(indata, pub_key)\n\n\nclass DecryptOperation(CryptoOperation):\n    \"\"\"Decrypts a file.\"\"\"\n\n    keyname = \"private\"\n    description = (\n        \"Decrypts a file. The original file must be shorter than \"\n        \"the key length in order to have been encrypted.\"\n    )\n    operation = \"decrypt\"\n    operation_past = \"decrypted\"\n    operation_progressive = \"decrypting\"\n    key_class = rsa.PrivateKey\n\n    def perform_operation(\n        self, indata: bytes, priv_key: rsa.key.AbstractKey, cli_args: Indexable = ()\n    ) -> bytes:\n        \"\"\"Decrypts files.\"\"\"\n        assert isinstance(priv_key, rsa.key.PrivateKey)\n        return rsa.decrypt(indata, priv_key)\n\n\nclass SignOperation(CryptoOperation):\n    \"\"\"Signs a file.\"\"\"\n\n    keyname = \"private\"\n    usage = \"usage: %%prog [options] private_key hash_method\"\n    description = (\n        \"Signs a file, outputs the signature. Choose the hash \"\n        \"method from %s\" % \", \".join(HASH_METHODS)\n    )\n    operation = \"sign\"\n    operation_past = \"signature\"\n    operation_progressive = \"Signing\"\n    key_class = rsa.PrivateKey\n    expected_cli_args = 2\n\n    output_help = (\n        \"Name of the file to write the signature to. Written \"\n        \"to stdout if this option is not present.\"\n    )\n\n    def perform_operation(\n        self, indata: bytes, priv_key: rsa.key.AbstractKey, cli_args: Indexable\n    ) -> bytes:\n        \"\"\"Signs files.\"\"\"\n        assert isinstance(priv_key, rsa.key.PrivateKey)\n\n        hash_method = cli_args[1]\n        if hash_method not in HASH_METHODS:\n            raise SystemExit(\"Invalid hash method, choose one of %s\" % \", \".join(HASH_METHODS))\n\n        return rsa.sign(indata, priv_key, hash_method)\n\n\nclass VerifyOperation(CryptoOperation):\n    \"\"\"Verify a signature.\"\"\"\n\n    keyname = \"public\"\n    usage = \"usage: %%prog [options] public_key signature_file\"\n    description = (\n        \"Verifies a signature, exits with status 0 upon success, \"\n        \"prints an error message and exits with status 1 upon error.\"\n    )\n    operation = \"verify\"\n    operation_past = \"verified\"\n    operation_progressive = \"Verifying\"\n    key_class = rsa.PublicKey\n    expected_cli_args = 2\n    has_output = False\n\n    def perform_operation(\n        self, indata: bytes, pub_key: rsa.key.AbstractKey, cli_args: Indexable\n    ) -> None:\n        \"\"\"Verifies files.\"\"\"\n        assert isinstance(pub_key, rsa.key.PublicKey)\n\n        signature_file = cli_args[1]\n\n        with open(signature_file, \"rb\") as sigfile:\n            signature = sigfile.read()\n\n        try:\n            rsa.verify(indata, signature, pub_key)\n        except rsa.VerificationError as ex:\n            raise SystemExit(\"Verification failed.\") from ex\n\n        print(\"Verification OK\", file=sys.stderr)\n\n\nencrypt = EncryptOperation()\ndecrypt = DecryptOperation()\nsign = SignOperation()\nverify = VerifyOperation()\n", "rsa/pkcs1_v2.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for PKCS#1 version 2 encryption and signing\n\nThis module implements certain functionality from PKCS#1 version 2. Main\ndocumentation is RFC 2437: https://tools.ietf.org/html/rfc2437\n\"\"\"\n\nfrom rsa import (\n    common,\n    pkcs1,\n    transform,\n)\n\n\ndef mgf1(seed: bytes, length: int, hasher: str = \"SHA-1\") -> bytes:\n    \"\"\"\n    MGF1 is a Mask Generation Function based on a hash function.\n\n    A mask generation function takes an octet string of variable length and a\n    desired output length as input, and outputs an octet string of the desired\n    length. The plaintext-awareness of RSAES-OAEP relies on the random nature of\n    the output of the mask generation function, which in turn relies on the\n    random nature of the underlying hash.\n\n    :param bytes seed: seed from which mask is generated, an octet string\n    :param int length: intended length in octets of the mask, at most 2^32(hLen)\n    :param str hasher: hash function (hLen denotes the length in octets of the hash\n        function output)\n\n    :return: mask, an octet string of length `length`\n    :rtype: bytes\n\n    :raise OverflowError: when `length` is too large for the specified `hasher`\n    :raise ValueError: when specified `hasher` is invalid\n    \"\"\"\n\n    try:\n        hash_length = pkcs1.HASH_METHODS[hasher]().digest_size\n    except KeyError as ex:\n        raise ValueError(\n            \"Invalid `hasher` specified. Please select one of: {hash_list}\".format(\n                hash_list=\", \".join(sorted(pkcs1.HASH_METHODS.keys()))\n            )\n        ) from ex\n\n    # If l > 2^32(hLen), output \"mask too long\" and stop.\n    if length > (2 ** 32 * hash_length):\n        raise OverflowError(\n            \"Desired length should be at most 2**32 times the hasher's output \"\n            \"length ({hash_length} for {hasher} function)\".format(\n                hash_length=hash_length,\n                hasher=hasher,\n            )\n        )\n\n    # Looping `counter` from 0 to ceil(l / hLen)-1, build `output` based on the\n    # hashes formed by (`seed` + C), being `C` an octet string of length 4\n    # generated by converting `counter` with the primitive I2OSP\n    output = b\"\".join(\n        pkcs1.compute_hash(\n            seed + transform.int2bytes(counter, fill_size=4),\n            method_name=hasher,\n        )\n        for counter in range(common.ceil_div(length, hash_length) + 1)\n    )\n\n    # Output the leading `length` octets of `output` as the octet string mask.\n    return output[:length]\n\n\n__all__ = [\n    \"mgf1\",\n]\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(1000):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 100 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "rsa/core.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Core mathematical operations.\n\nThis is the actual core RSA implementation, which is only defined\nmathematically on integers.\n\"\"\"\nimport itertools\nimport typing\n\n\ndef assert_int(var: int, name: str) -> None:\n    if isinstance(var, int):\n        return\n\n    raise TypeError(\"{} should be an integer, not {}\".format(name, var.__class__))\n\n\ndef encrypt_int(message: int, ekey: int, n: int) -> int:\n    \"\"\"Encrypts a message using encryption key 'ekey', working modulo n\"\"\"\n\n    assert_int(message, \"message\")\n    assert_int(ekey, \"ekey\")\n    assert_int(n, \"n\")\n\n    if message < 0:\n        raise ValueError(\"Only non-negative numbers are supported\")\n\n    if message >= n:\n        raise OverflowError(\"The message %i is too long for n=%i\" % (message, n))\n\n    return pow(message, ekey, n)\n\n\ndef decrypt_int(cyphertext: int, dkey: int, n: int) -> int:\n    \"\"\"Decrypts a cypher text using the decryption key 'dkey', working modulo n\"\"\"\n\n    assert_int(cyphertext, \"cyphertext\")\n    assert_int(dkey, \"dkey\")\n    assert_int(n, \"n\")\n\n    message = pow(cyphertext, dkey, n)\n    return message\n\n\ndef decrypt_int_fast(\n    cyphertext: int,\n    rs: typing.List[int],\n    ds: typing.List[int],\n    ts: typing.List[int],\n) -> int:\n    \"\"\"Decrypts a cypher text more quickly using the Chinese Remainder Theorem.\"\"\"\n\n    assert_int(cyphertext, \"cyphertext\")\n    for r in rs:\n        assert_int(r, \"r\")\n    for d in ds:\n        assert_int(d, \"d\")\n    for t in ts:\n        assert_int(t, \"t\")\n\n    p, q, rs = rs[0], rs[1], rs[2:]\n    exp1, exp2, ds = ds[0], ds[1], ds[2:]\n    coef, ts = ts[0], ts[1:]\n\n    M1 = pow(cyphertext, exp1, p)\n    M2 = pow(cyphertext, exp2, q)\n    h = ((M1 - M2) * coef) % p\n    m = M2 + q * h\n\n    Ms = [pow(cyphertext, d, r) for d, r in zip(ds, rs)]\n    Rs = list(itertools.accumulate([p, q] + rs, lambda x, y: x*y))\n    for R, r, M, t in zip(Rs[1:], rs, Ms, ts):\n        h = ((M - m) * t) % r\n        m += R * h\n\n    return m", "rsa/randnum.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for generating random numbers.\"\"\"\n\n# Source inspired by code by Yesudeep Mangalapilly <yesudeep@gmail.com>\n\nimport os\nimport struct\n\nfrom rsa import common, transform\n\n\ndef read_random_bits(nbits: int) -> bytes:\n    \"\"\"Reads 'nbits' random bits.\n\n    If nbits isn't a whole number of bytes, an extra byte will be appended with\n    only the lower bits set.\n    \"\"\"\n\n    nbytes, rbits = divmod(nbits, 8)\n\n    # Get the random bytes\n    randomdata = os.urandom(nbytes)\n\n    # Add the remaining random bits\n    if rbits > 0:\n        randomvalue = ord(os.urandom(1))\n        randomvalue >>= 8 - rbits\n        randomdata = struct.pack(\"B\", randomvalue) + randomdata\n\n    return randomdata\n\n\ndef read_random_int(nbits: int) -> int:\n    \"\"\"Reads a random integer of approximately nbits bits.\"\"\"\n\n    randomdata = read_random_bits(nbits)\n    value = transform.bytes2int(randomdata)\n\n    # Ensure that the number is large enough to just fill out the required\n    # number of bits.\n    value |= 1 << (nbits - 1)\n\n    return value\n\n\ndef read_random_odd_int(nbits: int) -> int:\n    \"\"\"Reads a random odd integer of approximately nbits bits.\n\n    >>> read_random_odd_int(512) & 1\n    1\n    \"\"\"\n\n    value = read_random_int(nbits)\n\n    # Make sure it's odd\n    return value | 1\n\n\ndef randint(maxvalue: int) -> int:\n    \"\"\"Returns a random integer x with 1 <= x <= maxvalue\n\n    May take a very long time in specific situations. If maxvalue needs N bits\n    to store, the closer maxvalue is to (2 ** N) - 1, the faster this function\n    is.\n    \"\"\"\n\n    bit_size = common.bit_size(maxvalue)\n\n    tries = 0\n    while True:\n        value = read_random_int(bit_size)\n        if value <= maxvalue:\n            break\n\n        if tries % 10 == 0 and tries:\n            # After a lot of tries to get the right number of bits but still\n            # smaller than maxvalue, decrease the number of bits by 1. That'll\n            # dramatically increase the chances to get a large enough number.\n            bit_size -= 1\n        tries += 1\n\n    return value\n", "rsa/parallel.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for parallel computation on multiple cores.\n\nIntroduced in Python-RSA 3.1.\n\n.. note::\n\n    Requires Python 2.6 or newer.\n\n\"\"\"\n\nimport multiprocessing as mp\nfrom multiprocessing.connection import Connection\n\nimport rsa.prime\nimport rsa.randnum\n\n\ndef _find_prime(nbits: int, pipe: Connection) -> None:\n    while True:\n        integer = rsa.randnum.read_random_odd_int(nbits)\n\n        # Test for primeness\n        if rsa.prime.is_prime(integer):\n            pipe.send(integer)\n            return\n\n\ndef getprime(nbits: int, poolsize: int) -> int:\n    \"\"\"Returns a prime number that can be stored in 'nbits' bits.\n\n    Works in multiple threads at the same time.\n\n    >>> p = getprime(128, 3)\n    >>> rsa.prime.is_prime(p-1)\n    False\n    >>> rsa.prime.is_prime(p)\n    True\n    >>> rsa.prime.is_prime(p+1)\n    False\n\n    >>> from rsa import common\n    >>> common.bit_size(p) == 128\n    True\n\n    \"\"\"\n\n    (pipe_recv, pipe_send) = mp.Pipe(duplex=False)\n\n    # Create processes\n    try:\n        procs = [mp.Process(target=_find_prime, args=(nbits, pipe_send)) for _ in range(poolsize)]\n        # Start processes\n        for p in procs:\n            p.start()\n\n        result = pipe_recv.recv()\n    finally:\n        pipe_recv.close()\n        pipe_send.close()\n\n    # Terminate processes\n    for p in procs:\n        p.terminate()\n\n    return result\n\n\n__all__ = [\"getprime\"]\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(100):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 10 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "rsa/prime.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Numerical functions related to primes.\n\nImplementation based on the book Algorithm Design by Michael T. Goodrich and\nRoberto Tamassia, 2002.\n\"\"\"\n\nimport rsa.common\nimport rsa.randnum\n\n__all__ = [\"getprime\", \"are_relatively_prime\"]\n\n\ndef gcd(p: int, q: int) -> int:\n    \"\"\"Returns the greatest common divisor of p and q\n\n    >>> gcd(48, 180)\n    12\n    \"\"\"\n\n    while q != 0:\n        (p, q) = (q, p % q)\n    return p\n\n\ndef get_primality_testing_rounds(number: int) -> int:\n    \"\"\"Returns minimum number of rounds for Miller-Rabing primality testing,\n    based on number bitsize.\n\n    According to NIST FIPS 186-4, Appendix C, Table C.3, minimum number of\n    rounds of M-R testing, using an error probability of 2 ** (-100), for\n    different p, q bitsizes are:\n      * p, q bitsize: 512; rounds: 7\n      * p, q bitsize: 1024; rounds: 4\n      * p, q bitsize: 1536; rounds: 3\n    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    \"\"\"\n\n    # Calculate number bitsize.\n    bitsize = rsa.common.bit_size(number)\n    # Set number of rounds.\n    if bitsize >= 1536:\n        return 3\n    if bitsize >= 1024:\n        return 4\n    if bitsize >= 512:\n        return 7\n    # For smaller bitsizes, set arbitrary number of rounds.\n    return 10\n\n\ndef miller_rabin_primality_testing(n: int, k: int) -> bool:\n    \"\"\"Calculates whether n is composite (which is always correct) or prime\n    (which theoretically is incorrect with error probability 4**-k), by\n    applying Miller-Rabin primality testing.\n\n    For reference and implementation example, see:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n\n    :param n: Integer to be tested for primality.\n    :type n: int\n    :param k: Number of rounds (witnesses) of Miller-Rabin testing.\n    :type k: int\n    :return: False if the number is composite, True if it's probably prime.\n    :rtype: bool\n    \"\"\"\n\n    # prevent potential infinite loop when d = 0\n    if n < 2:\n        return False\n\n    # Decompose (n - 1) to write it as (2 ** r) * d\n    # While d is even, divide it by 2 and increase the exponent.\n    d = n - 1\n    r = 0\n\n    while not (d & 1):\n        r += 1\n        d >>= 1\n\n    # Test k witnesses.\n    for _ in range(k):\n        # Generate random integer a, where 2 <= a <= (n - 2)\n        a = rsa.randnum.randint(n - 3) + 1\n\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                # n is composite.\n                return False\n            if x == n - 1:\n                # Exit inner loop and continue with next witness.\n                break\n        else:\n            # If loop doesn't break, n is composite.\n            return False\n\n    return True\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Returns True if the number is prime, and False otherwise.\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(42)\n    False\n    >>> is_prime(41)\n    True\n    \"\"\"\n\n    # Check for small numbers.\n    if number < 10:\n        return number in {2, 3, 5, 7}\n\n    # Check for even numbers.\n    if not (number & 1):\n        return False\n\n    # Calculate minimum number of rounds.\n    k = get_primality_testing_rounds(number)\n\n    # Run primality testing with (minimum + 1) rounds.\n    return miller_rabin_primality_testing(number, k + 1)\n\n\ndef getprime(nbits: int) -> int:\n    \"\"\"Returns a prime number that can be stored in 'nbits' bits.\n\n    >>> p = getprime(128)\n    >>> is_prime(p-1)\n    False\n    >>> is_prime(p)\n    True\n    >>> is_prime(p+1)\n    False\n\n    >>> from rsa import common\n    >>> common.bit_size(p) == 128\n    True\n    \"\"\"\n\n    assert nbits > 3  # the loop will hang on too small numbers\n\n    while True:\n        integer = rsa.randnum.read_random_odd_int(nbits)\n\n        # Test for primeness\n        if is_prime(integer):\n            return integer\n\n            # Retry if not prime\n\n\ndef are_relatively_prime(a: int, b: int) -> bool:\n    \"\"\"Returns True if a and b are relatively prime, and False if they\n    are not.\n\n    >>> are_relatively_prime(2, 3)\n    True\n    >>> are_relatively_prime(2, 4)\n    False\n    \"\"\"\n\n    d = gcd(a, b)\n    return d == 1\n\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(1000):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 100 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "rsa/util.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Utility functions.\"\"\"\n\nimport sys\nfrom optparse import OptionParser\n\nimport rsa.key\n\n\ndef private_to_public() -> None:\n    \"\"\"Reads a private key and outputs the corresponding public key.\"\"\"\n\n    # Parse the CLI options\n    parser = OptionParser(\n        usage=\"usage: %prog [options]\",\n        description=\"Reads a private key and outputs the \"\n        \"corresponding public key. Both private and public keys use \"\n        \"the format described in PKCS#1 v1.5\",\n    )\n\n    parser.add_option(\n        \"-i\",\n        \"--input\",\n        dest=\"infilename\",\n        type=\"string\",\n        help=\"Input filename. Reads from stdin if not specified\",\n    )\n    parser.add_option(\n        \"-o\",\n        \"--output\",\n        dest=\"outfilename\",\n        type=\"string\",\n        help=\"Output filename. Writes to stdout of not specified\",\n    )\n\n    parser.add_option(\n        \"--inform\",\n        dest=\"inform\",\n        help=\"key format of input - default PEM\",\n        choices=(\"PEM\", \"DER\"),\n        default=\"PEM\",\n    )\n\n    parser.add_option(\n        \"--outform\",\n        dest=\"outform\",\n        help=\"key format of output - default PEM\",\n        choices=(\"PEM\", \"DER\"),\n        default=\"PEM\",\n    )\n\n    (cli, cli_args) = parser.parse_args(sys.argv)\n\n    # Read the input data\n    if cli.infilename:\n        print(\n            \"Reading private key from %s in %s format\" % (cli.infilename, cli.inform),\n            file=sys.stderr,\n        )\n        with open(cli.infilename, \"rb\") as infile:\n            in_data = infile.read()\n    else:\n        print(\"Reading private key from stdin in %s format\" % cli.inform, file=sys.stderr)\n        in_data = sys.stdin.read().encode(\"ascii\")\n\n    assert type(in_data) == bytes, type(in_data)\n\n    # Take the public fields and create a public key\n    priv_key = rsa.key.PrivateKey.load_pkcs1(in_data, cli.inform)\n    pub_key = rsa.key.PublicKey(priv_key.n, priv_key.e)\n\n    # Save to the output file\n    out_data = pub_key.save_pkcs1(cli.outform)\n\n    if cli.outfilename:\n        print(\n            \"Writing public key to %s in %s format\" % (cli.outfilename, cli.outform),\n            file=sys.stderr,\n        )\n        with open(cli.outfilename, \"wb\") as outfile:\n            outfile.write(out_data)\n    else:\n        print(\"Writing public key to stdout in %s format\" % cli.outform, file=sys.stderr)\n        sys.stdout.write(out_data.decode(\"ascii\"))\n", "rsa/key.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"RSA key generation code.\n\nCreate new keys with the newkeys() function. It will give you a PublicKey and a\nPrivateKey object.\n\nLoading and saving keys requires the pyasn1 module. This module is imported as\nlate as possible, such that other functionality will remain working in absence\nof pyasn1.\n\n.. note::\n\n    Storing public and private keys via the `pickle` module is possible.\n    However, it is insecure to load a key from an untrusted source.\n    The pickle module is not secure against erroneous or maliciously\n    constructed data. Never unpickle data received from an untrusted\n    or unauthenticated source.\n\n\"\"\"\n\nimport abc\nimport math\nimport threading\nimport typing\nimport warnings\nimport itertools\n\nimport rsa.prime\nimport rsa.pem\nimport rsa.common\nimport rsa.randnum\nimport rsa.core\n\n\nDEFAULT_EXPONENT = 65537\n\n\nT = typing.TypeVar(\"T\", bound=\"AbstractKey\")\n\n\nclass AbstractKey(metaclass=abc.ABCMeta):\n    \"\"\"Abstract superclass for private and public keys.\"\"\"\n\n    __slots__ = (\"n\", \"e\", \"blindfac\", \"blindfac_inverse\", \"mutex\")\n\n    def __init__(self, n: int, e: int) -> None:\n        self.n = n\n        self.e = e\n\n        # These will be computed properly on the first call to blind().\n        self.blindfac = self.blindfac_inverse = -1\n\n        # Used to protect updates to the blinding factor in multi-threaded\n        # environments.\n        self.mutex = threading.Lock()\n\n    @classmethod\n    @abc.abstractmethod\n    def _load_pkcs1_pem(cls: typing.Type[T], keyfile: bytes) -> T:\n        \"\"\"Loads a key in PKCS#1 PEM format, implement in a subclass.\n\n        :param keyfile: contents of a PEM-encoded file that contains\n            the public key.\n        :type keyfile: bytes\n\n        :return: the loaded key\n        :rtype: AbstractKey\n        \"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def _load_pkcs1_der(cls: typing.Type[T], keyfile: bytes) -> T:\n        \"\"\"Loads a key in PKCS#1 PEM format, implement in a subclass.\n\n        :param keyfile: contents of a DER-encoded file that contains\n            the public key.\n        :type keyfile: bytes\n\n        :return: the loaded key\n        :rtype: AbstractKey\n        \"\"\"\n\n    @abc.abstractmethod\n    def _save_pkcs1_pem(self) -> bytes:\n        \"\"\"Saves the key in PKCS#1 PEM format, implement in a subclass.\n\n        :returns: the PEM-encoded key.\n        :rtype: bytes\n        \"\"\"\n\n    @abc.abstractmethod\n    def _save_pkcs1_der(self) -> bytes:\n        \"\"\"Saves the key in PKCS#1 DER format, implement in a subclass.\n\n        :returns: the DER-encoded key.\n        :rtype: bytes\n        \"\"\"\n\n    @classmethod\n    def load_pkcs1(cls: typing.Type[T], keyfile: bytes, format: str = \"PEM\") -> T:\n        \"\"\"Loads a key in PKCS#1 DER or PEM format.\n\n        :param keyfile: contents of a DER- or PEM-encoded file that contains\n            the key.\n        :type keyfile: bytes\n        :param format: the format of the file to load; 'PEM' or 'DER'\n        :type format: str\n\n        :return: the loaded key\n        :rtype: AbstractKey\n        \"\"\"\n\n        methods = {\n            \"PEM\": cls._load_pkcs1_pem,\n            \"DER\": cls._load_pkcs1_der,\n        }\n\n        method = cls._assert_format_exists(format, methods)\n        return method(keyfile)\n\n    @staticmethod\n    def _assert_format_exists(\n        file_format: str, methods: typing.Mapping[str, typing.Callable]\n    ) -> typing.Callable:\n        \"\"\"Checks whether the given file format exists in 'methods'.\"\"\"\n\n        try:\n            return methods[file_format]\n        except KeyError as ex:\n            formats = \", \".join(sorted(methods.keys()))\n            raise ValueError(\n                \"Unsupported format: %r, try one of %s\" % (file_format, formats)\n            ) from ex\n\n    def save_pkcs1(self, format: str = \"PEM\") -> bytes:\n        \"\"\"Saves the key in PKCS#1 DER or PEM format.\n\n        :param format: the format to save; 'PEM' or 'DER'\n        :type format: str\n        :returns: the DER- or PEM-encoded key.\n        :rtype: bytes\n        \"\"\"\n\n        methods = {\n            \"PEM\": self._save_pkcs1_pem,\n            \"DER\": self._save_pkcs1_der,\n        }\n\n        method = self._assert_format_exists(format, methods)\n        return method()\n\n    def blind(self, message: int) -> typing.Tuple[int, int]:\n        \"\"\"Performs blinding on the message.\n\n        :param message: the message, as integer, to blind.\n        :param r: the random number to blind with.\n        :return: tuple (the blinded message, the inverse of the used blinding factor)\n\n        The blinding is such that message = unblind(decrypt(blind(encrypt(message))).\n\n        See https://en.wikipedia.org/wiki/Blinding_%28cryptography%29\n        \"\"\"\n        blindfac, blindfac_inverse = self._update_blinding_factor()\n        blinded = (message * pow(blindfac, self.e, self.n)) % self.n\n        return blinded, blindfac_inverse\n\n    def unblind(self, blinded: int, blindfac_inverse: int) -> int:\n        \"\"\"Performs blinding on the message using random number 'blindfac_inverse'.\n\n        :param blinded: the blinded message, as integer, to unblind.\n        :param blindfac: the factor to unblind with.\n        :return: the original message.\n\n        The blinding is such that message = unblind(decrypt(blind(encrypt(message))).\n\n        See https://en.wikipedia.org/wiki/Blinding_%28cryptography%29\n        \"\"\"\n        return (blindfac_inverse * blinded) % self.n\n\n    def _initial_blinding_factor(self) -> int:\n        for _ in range(1000):\n            blind_r = rsa.randnum.randint(self.n - 1)\n            if rsa.prime.are_relatively_prime(self.n, blind_r):\n                return blind_r\n        raise RuntimeError(\"unable to find blinding factor\")\n\n    def _update_blinding_factor(self) -> typing.Tuple[int, int]:\n        \"\"\"Update blinding factors.\n\n        Computing a blinding factor is expensive, so instead this function\n        does this once, then updates the blinding factor as per section 9\n        of 'A Timing Attack against RSA with the Chinese Remainder Theorem'\n        by Werner Schindler.\n        See https://tls.mbed.org/public/WSchindler-RSA_Timing_Attack.pdf\n\n        :return: the new blinding factor and its inverse.\n        \"\"\"\n\n        with self.mutex:\n            if self.blindfac < 0:\n                # Compute initial blinding factor, which is rather slow to do.\n                self.blindfac = self._initial_blinding_factor()\n                self.blindfac_inverse = rsa.common.inverse(self.blindfac, self.n)\n            else:\n                # Reuse previous blinding factor.\n                self.blindfac = pow(self.blindfac, 2, self.n)\n                self.blindfac_inverse = pow(self.blindfac_inverse, 2, self.n)\n\n            return self.blindfac, self.blindfac_inverse\n\n\nclass PublicKey(AbstractKey):\n    \"\"\"Represents a public RSA key.\n\n    This key is also known as the 'encryption key'. It contains the 'n' and 'e'\n    values.\n\n    Supports attributes as well as dictionary-like access. Attribute access is\n    faster, though.\n\n    >>> PublicKey(5, 3)\n    PublicKey(5, 3)\n\n    >>> key = PublicKey(5, 3)\n    >>> key.n\n    5\n    >>> key['n']\n    5\n    >>> key.e\n    3\n    >>> key['e']\n    3\n\n    \"\"\"\n\n    __slots__ = ()\n\n    def __getitem__(self, key: str) -> int:\n        return getattr(self, key)\n\n    def __repr__(self) -> str:\n        return \"PublicKey(%i, %i)\" % (self.n, self.e)\n\n    def __getstate__(self) -> typing.Tuple[int, int]:\n        \"\"\"Returns the key as tuple for pickling.\"\"\"\n        return self.n, self.e\n\n    def __setstate__(self, state: typing.Tuple[int, int]) -> None:\n        \"\"\"Sets the key from tuple.\"\"\"\n        self.n, self.e = state\n        AbstractKey.__init__(self, self.n, self.e)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if other is None:\n            return False\n\n        if not isinstance(other, PublicKey):\n            return False\n\n        return self.n == other.n and self.e == other.e\n\n    def __ne__(self, other: typing.Any) -> bool:\n        return not (self == other)\n\n    def __hash__(self) -> int:\n        return hash((self.n, self.e))\n\n    @classmethod\n    def _load_pkcs1_der(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a key in PKCS#1 DER format.\n\n        :param keyfile: contents of a DER-encoded file that contains the public\n            key.\n        :return: a PublicKey object\n\n        First let's construct a DER encoded key:\n\n        >>> import base64\n        >>> b64der = 'MAwCBQCNGmYtAgMBAAE='\n        >>> der = base64.standard_b64decode(b64der)\n\n        This loads the file:\n\n        >>> PublicKey._load_pkcs1_der(der)\n        PublicKey(2367317549, 65537)\n\n        \"\"\"\n\n        from pyasn1.codec.der import decoder\n        from rsa.asn1 import AsnPubKey\n\n        (priv, _) = decoder.decode(keyfile, asn1Spec=AsnPubKey())\n        return cls(n=int(priv[\"modulus\"]), e=int(priv[\"publicExponent\"]))\n\n    def _save_pkcs1_der(self) -> bytes:\n        \"\"\"Saves the public key in PKCS#1 DER format.\n\n        :returns: the DER-encoded public key.\n        :rtype: bytes\n        \"\"\"\n\n        from pyasn1.codec.der import encoder\n        from rsa.asn1 import AsnPubKey\n\n        # Create the ASN object\n        asn_key = AsnPubKey()\n        asn_key.setComponentByName(\"modulus\", self.n)\n        asn_key.setComponentByName(\"publicExponent\", self.e)\n\n        return encoder.encode(asn_key)\n\n    @classmethod\n    def _load_pkcs1_pem(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a PKCS#1 PEM-encoded public key file.\n\n        The contents of the file before the \"-----BEGIN RSA PUBLIC KEY-----\" and\n        after the \"-----END RSA PUBLIC KEY-----\" lines is ignored.\n\n        :param keyfile: contents of a PEM-encoded file that contains the public\n            key.\n        :return: a PublicKey object\n        \"\"\"\n\n        der = rsa.pem.load_pem(keyfile, \"RSA PUBLIC KEY\")\n        return cls._load_pkcs1_der(der)\n\n    def _save_pkcs1_pem(self) -> bytes:\n        \"\"\"Saves a PKCS#1 PEM-encoded public key file.\n\n        :return: contents of a PEM-encoded file that contains the public key.\n        :rtype: bytes\n        \"\"\"\n\n        der = self._save_pkcs1_der()\n        return rsa.pem.save_pem(der, \"RSA PUBLIC KEY\")\n\n    @classmethod\n    def load_pkcs1_openssl_pem(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a PKCS#1.5 PEM-encoded public key file from OpenSSL.\n\n        These files can be recognised in that they start with BEGIN PUBLIC KEY\n        rather than BEGIN RSA PUBLIC KEY.\n\n        The contents of the file before the \"-----BEGIN PUBLIC KEY-----\" and\n        after the \"-----END PUBLIC KEY-----\" lines is ignored.\n\n        :param keyfile: contents of a PEM-encoded file that contains the public\n            key, from OpenSSL.\n        :type keyfile: bytes\n        :return: a PublicKey object\n        \"\"\"\n\n        der = rsa.pem.load_pem(keyfile, \"PUBLIC KEY\")\n        return cls.load_pkcs1_openssl_der(der)\n\n    @classmethod\n    def load_pkcs1_openssl_der(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a PKCS#1 DER-encoded public key file from OpenSSL.\n\n        :param keyfile: contents of a DER-encoded file that contains the public\n            key, from OpenSSL.\n        :return: a PublicKey object\n        \"\"\"\n\n        from rsa.asn1 import OpenSSLPubKey\n        from pyasn1.codec.der import decoder\n        from pyasn1.type import univ\n\n        (keyinfo, _) = decoder.decode(keyfile, asn1Spec=OpenSSLPubKey())\n\n        if keyinfo[\"header\"][\"oid\"] != univ.ObjectIdentifier(\"1.2.840.113549.1.1.1\"):\n            raise TypeError(\"This is not a DER-encoded OpenSSL-compatible public key\")\n\n        return cls._load_pkcs1_der(keyinfo[\"key\"][1:])\n\n\nclass PrivateKey(AbstractKey):\n    \"\"\"Represents a private RSA key.\n\n    This key is also known as the 'decryption key'. It contains the 'n', 'e',\n    'd', 'p', 'q' and other values. For example ,in the case of multiprime RSA,\n    it additionally contains the lists 'rs', 'ds', and 'ts' which contain the\n    factors, exponents, and coefficients for the other primes.\n\n    Supports attributes as well as dictionary-like access. Attribute access is\n    faster, though.\n\n    >>> PrivateKey(3247, 65537, 833, 191, 17)\n    PrivateKey(3247, 65537, 833, 191, 17)\n\n    exp1, exp2 and coef will be calculated:\n\n    >>> pk = PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n    >>> pk.exp1\n    55063\n    >>> pk.exp2\n    10095\n    >>> pk.coef\n    50797\n\n    \"\"\"\n\n    __slots__ = (\"d\", \"p\", \"q\", \"exp1\", \"exp2\", \"coef\", \"rs\", \"ds\", \"ts\")\n\n    def __init__(\n        self,\n        n: int,\n        e: int,\n        d: int,\n        p: int,\n        q: int,\n        rs: typing.Optional[typing.List[int]] = None,\n    ) -> None:\n        rs = [] if rs is None else rs\n\n        AbstractKey.__init__(self, n, e)\n        self.d = d\n        self.p = p\n        self.q = q\n\n        # Calculate exponents and coefficient.\n        self.exp1 = int(d % (p - 1))\n        self.exp2 = int(d % (q - 1))\n        self.coef = rsa.common.inverse(q, p)\n\n        # Calculate other primes' exponents and coefficients.\n        self.rs = rs\n        self.ds = [int(d % (r - 1)) for r in rs]\n        Rs = list(itertools.accumulate([p, q] + rs, lambda x, y: x*y))\n        self.ts = [pow(R, -1, r) for R, r in zip(Rs[1:], rs)]\n\n    def __getitem__(self, key: str) -> int:\n        return getattr(self, key)\n\n    def __repr__(self) -> str:\n        if self.rs:\n            return \"PrivateKey(%i, %i, %i, %i, %i, %s)\" % (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.rs,\n            )\n        else:\n            return \"PrivateKey(%i, %i, %i, %i, %i)\" % (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n            )\n\n    def __getstate__(self) -> typing.Tuple:\n        \"\"\"Returns the key as tuple for pickling.\"\"\"\n        if self.rs:\n            return (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.exp1,\n                self.exp2,\n                self.coef,\n                self.rs,\n                self.ds,\n                self.ts,\n            )\n        else:\n            return self.n, self.e, self.d, self.p, self.q, self.exp1, self.exp2, self.coef\n\n    def __setstate__(self, state: typing.Tuple) -> None:\n        \"\"\"Sets the key from tuple.\"\"\"\n        if len(state) != 8:\n            (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.exp1,\n                self.exp2,\n                self.coef,\n                self.rs,\n                self.ds,\n                self.ts,\n             ) = state\n        else:\n            self.n, self.e, self.d, self.p, self.q, self.exp1, self.exp2, self.coef = state\n            self.rs = self.ds = self.ts = []\n        AbstractKey.__init__(self, self.n, self.e)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if other is None:\n            return False\n\n        if not isinstance(other, PrivateKey):\n            return False\n\n        return all([getattr(self, k) == getattr(other, k) for k in self.__slots__])\n\n    def __ne__(self, other: typing.Any) -> bool:\n        return not (self == other)\n\n    def __hash__(self) -> int:\n        if self.rs:\n            return hash((\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.exp1,\n                self.exp2,\n                self.coef,\n                *self.rs,\n                *self.ds,\n                *self.ts\n            ))\n        else:\n            return hash((self.n, self.e, self.d, self.p, self.q, self.exp1, self.exp2, self.coef))\n\n    def blinded_decrypt(self, encrypted: int) -> int:\n        \"\"\"Decrypts the message using blinding to prevent side-channel attacks.\n\n        :param encrypted: the encrypted message\n        :type encrypted: int\n\n        :returns: the decrypted message\n        :rtype: int\n        \"\"\"\n\n        # Blinding and un-blinding should be using the same factor\n        blinded, blindfac_inverse = self.blind(encrypted)\n        decrypted = rsa.core.decrypt_int_fast(\n            blinded,\n            [self.p, self.q] + self.rs,\n            [self.exp1, self.exp2] + self.ds,\n            [self.coef] + self.ts,\n        )\n        return self.unblind(decrypted, blindfac_inverse)\n\n    @classmethod\n    def _load_pkcs1_der(cls, keyfile: bytes) -> \"PrivateKey\":\n        \"\"\"Loads a key in PKCS#1 DER format.\n\n        :param keyfile: contents of a DER-encoded file that contains the private\n            key.\n        :type keyfile: bytes\n        :return: a PrivateKey object\n\n        First let's construct a DER encoded key:\n\n        >>> import base64\n        >>> b64der = 'MC4CAQACBQDeKYlRAgMBAAECBQDHn4npAgMA/icCAwDfxwIDANcXAgInbwIDAMZt'\n        >>> der = base64.standard_b64decode(b64der)\n\n        This loads the file:\n\n        >>> PrivateKey._load_pkcs1_der(der)\n        PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        \"\"\"\n\n        from pyasn1.codec.der import decoder\n\n        (priv, _) = decoder.decode(keyfile)\n\n        # ASN.1 contents of DER encoded private key:\n        #\n        # RSAPrivateKey ::= SEQUENCE {\n        #     version           Version,\n        #     modulus           INTEGER,  -- n\n        #     publicExponent    INTEGER,  -- e\n        #     privateExponent   INTEGER,  -- d\n        #     prime1            INTEGER,  -- p\n        #     prime2            INTEGER,  -- q\n        #     exponent1         INTEGER,  -- d mod (p-1)\n        #     exponent2         INTEGER,  -- d mod (q-1)\n        #     coefficient       INTEGER,  -- (inverse of q) mod p\n        #     otherPrimeInfos   OtherPrimeInfos OPTIONAL\n        # }\n\n        if priv[0] != 0:\n            raise ValueError(\"Unable to read this file, version %s != 0\" % priv[0])\n\n        n, e, d, p, q = map(int, priv[1:6])\n        exp1, exp2, coef = map(int, priv[6:9])\n        rs = map(int, priv[9::3])\n        ds = map(int, priv[10::3])\n        ts = map(int, priv[11::3])\n\n        key = cls(n, e, d, p, q, list(rs))\n\n        if (key.exp1, key.exp2, key.coef, key.rs, key.ds, key.ts) != (exp1, exp2, coef, rs, ds, ts):\n            warnings.warn(\n                \"You have provided a malformed keyfile. Either the exponents \"\n                \"or the coefficient are incorrect. Using the correct values \"\n                \"instead.\",\n                UserWarning,\n            )\n\n        return key\n\n    def _save_pkcs1_der(self) -> bytes:\n        \"\"\"Saves the private key in PKCS#1 DER format.\n\n        :returns: the DER-encoded private key.\n        :rtype: bytes\n        \"\"\"\n\n        from pyasn1.type import univ, namedtype\n        from pyasn1.codec.der import encoder\n\n        other_fields = [\n            (\n                namedtype.NamedType(\"prime%d\" % (i + 3), univ.Integer()),\n                namedtype.NamedType(\"exponent%d\" % (i + 3), univ.Integer()),\n                namedtype.NamedType(\"coefficient%d\" % (i + 3), univ.Integer()),\n            ) for i in range(len(self.rs))\n        ]\n        \n        class AsnPrivKey(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType(\"version\", univ.Integer()),\n                namedtype.NamedType(\"modulus\", univ.Integer()),\n                namedtype.NamedType(\"publicExponent\", univ.Integer()),\n                namedtype.NamedType(\"privateExponent\", univ.Integer()),\n                namedtype.NamedType(\"prime1\", univ.Integer()),\n                namedtype.NamedType(\"prime2\", univ.Integer()),\n                namedtype.NamedType(\"exponent1\", univ.Integer()),\n                namedtype.NamedType(\"exponent2\", univ.Integer()),\n                namedtype.NamedType(\"coefficient\", univ.Integer()),\n                *list(itertools.chain(*other_fields))\n            )\n\n        # Create the ASN object\n        asn_key = AsnPrivKey()\n        asn_key.setComponentByName(\"version\", 0)\n        asn_key.setComponentByName(\"modulus\", self.n)\n        asn_key.setComponentByName(\"publicExponent\", self.e)\n        asn_key.setComponentByName(\"privateExponent\", self.d)\n        asn_key.setComponentByName(\"prime1\", self.p)\n        asn_key.setComponentByName(\"prime2\", self.q)\n        asn_key.setComponentByName(\"exponent1\", self.exp1)\n        asn_key.setComponentByName(\"exponent2\", self.exp2)\n        asn_key.setComponentByName(\"coefficient\", self.coef)\n        for i, (r, d, t) in enumerate(zip(self.rs, self.ds, self.ts), start=3):\n            asn_key.setComponentByName(\"prime%d\" % i, r)\n            asn_key.setComponentByName(\"exponent%d\" % i, d)\n            asn_key.setComponentByName(\"coefficient%d\" % i, t)\n\n        return encoder.encode(asn_key)\n\n    @classmethod\n    def _load_pkcs1_pem(cls, keyfile: bytes) -> \"PrivateKey\":\n        \"\"\"Loads a PKCS#1 PEM-encoded private key file.\n\n        The contents of the file before the \"-----BEGIN RSA PRIVATE KEY-----\" and\n        after the \"-----END RSA PRIVATE KEY-----\" lines is ignored.\n\n        :param keyfile: contents of a PEM-encoded file that contains the private\n            key.\n        :type keyfile: bytes\n        :return: a PrivateKey object\n        \"\"\"\n\n        der = rsa.pem.load_pem(keyfile, b\"RSA PRIVATE KEY\")\n        return cls._load_pkcs1_der(der)\n\n    def _save_pkcs1_pem(self) -> bytes:\n        \"\"\"Saves a PKCS#1 PEM-encoded private key file.\n\n        :return: contents of a PEM-encoded file that contains the private key.\n        :rtype: bytes\n        \"\"\"\n\n        der = self._save_pkcs1_der()\n        return rsa.pem.save_pem(der, b\"RSA PRIVATE KEY\")\n\n\ndef find_primes(\n    nbits: int,\n    getprime_func: typing.Callable[[int], int] = rsa.prime.getprime,\n    accurate: bool = True,\n    nprimes: int = 2,\n) -> typing.List[int]:\n    \"\"\"Returns a list of different primes with nbits divided evenly among them.\n\n    :param nbits: the number of bits for the primes to sum to.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n    :param accurate: whether to enable accurate mode or not.\n    :returns: list of primes in descending order.\n\n    \"\"\"\n    if nprimes == 2:\n        return list(find_p_q(nbits // 2, getprime_func, accurate))\n\n    quo, rem = divmod(nbits, nprimes)\n    factor_lengths = [quo + 1]*rem + [quo] * (nprimes - rem)\n\n    while True:\n        primes = [getprime_func(length) for length in factor_lengths]\n        if len(set(primes)) == len(primes):\n            break\n\n    return list(reversed(sorted(primes)))\n\n\ndef find_p_q(\n    nbits: int,\n    getprime_func: typing.Callable[[int], int] = rsa.prime.getprime,\n    accurate: bool = True,\n) -> typing.Tuple[int, int]:\n    \"\"\"Returns a tuple of two different primes of nbits bits each.\n\n    The resulting p * q has exactly 2 * nbits bits, and the returned p and q\n    will not be equal.\n\n    :param nbits: the number of bits in each of p and q.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n\n        *Introduced in Python-RSA 3.1*\n\n    :param accurate: whether to enable accurate mode or not.\n    :returns: (p, q), where p > q\n\n    >>> (p, q) = find_p_q(128)\n    >>> from rsa import common\n    >>> common.bit_size(p * q)\n    256\n\n    When not in accurate mode, the number of bits can be slightly less\n\n    >>> (p, q) = find_p_q(128, accurate=False)\n    >>> from rsa import common\n    >>> common.bit_size(p * q) <= 256\n    True\n    >>> common.bit_size(p * q) > 240\n    True\n\n    \"\"\"\n\n    total_bits = nbits * 2\n\n    # Make sure that p and q aren't too close or the factoring programs can\n    # factor n.\n    shift = nbits // 16\n    pbits = nbits + shift\n    qbits = nbits - shift\n\n    # Choose the two initial primes\n    p = getprime_func(pbits)\n    q = getprime_func(qbits)\n\n    def is_acceptable(p: int, q: int) -> bool:\n        \"\"\"Returns True iff p and q are acceptable:\n\n        - p and q differ\n        - (p * q) has the right nr of bits (when accurate=True)\n        \"\"\"\n\n        if p == q:\n            return False\n\n        if not accurate:\n            return True\n\n        # Make sure we have just the right amount of bits\n        found_size = rsa.common.bit_size(p * q)\n        return total_bits == found_size\n\n    # Keep choosing other primes until they match our requirements.\n    change_p = False\n    while not is_acceptable(p, q):\n        # Change p on one iteration and q on the other\n        if change_p:\n            p = getprime_func(pbits)\n        else:\n            q = getprime_func(qbits)\n\n        change_p = not change_p\n\n    # We want p > q as described on\n    # http://www.di-mgt.com.au/rsa_alg.html#crt\n    return max(p, q), min(p, q)\n\n\ndef calculate_keys_custom_exponent(\n    p: int,\n    q: int,\n    exponent: int,\n    rs: typing.Optional[typing.List[int]] = None,\n) -> typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p, q and an exponent,\n    and returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param rs: the list of other large primes\n\n    \"\"\"\n\n    phi_n = math.prod([x - 1 for x in [p, q] + ([] if rs is None else rs)])\n\n    try:\n        d = rsa.common.inverse(exponent, phi_n)\n    except rsa.common.NotRelativePrimeError as ex:\n        raise rsa.common.NotRelativePrimeError(\n            exponent,\n            phi_n,\n            ex.d,\n            msg=\"e (%d) and phi_n (%d) are not relatively prime (divider=%i)\"\n            % (exponent, phi_n, ex.d),\n        ) from ex\n\n    if (exponent * d) % phi_n != 1:\n        raise ValueError(\n            \"e (%d) and d (%d) are not mult. inv. modulo \" \"phi_n (%d)\" % (exponent, d, phi_n)\n        )\n\n    return exponent, d\n\n\ndef calculate_keys(p: int, q: int) -> typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p and q, and\n    returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n\n    :return: tuple (e, d) with the encryption and decryption exponents.\n    \"\"\"\n\n    return calculate_keys_custom_exponent(p, q, DEFAULT_EXPONENT)\n\n\ndef gen_keys(\n    nbits: int,\n    getprime_func: typing.Callable[[int], int],\n    accurate: bool = True,\n    exponent: int = DEFAULT_EXPONENT,\n    nprimes: int = 2,\n) -> typing.Tuple:\n    \"\"\"Generate RSA keys of nbits bits. Returns (p, q, e, d) or (p, q, e, d, rs).\n\n    Note: this can take a long time, depending on the key size.\n\n    :param nbits: the total number of bits in ``p`` and ``q``. Both ``p`` and\n        ``q`` will use ``nbits/2`` bits.\n    :param getprime_func: either :py:func:`rsa.prime.getprime` or a function\n        with similar signature.\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param nprimes: the number of prime factors comprising the modulus.\n    \"\"\"\n\n    # Regenerate prime values, until calculate_keys_custom_exponent doesn't raise a\n    # ValueError.\n    while True:\n        primes = find_primes(nbits, getprime_func, accurate, nprimes)\n        p, q, rs = primes[0], primes[1], primes[2:]\n        try:\n            (e, d) = calculate_keys_custom_exponent(p, q, exponent=exponent, rs=rs)\n            break\n        except ValueError:\n            pass\n\n    if rs:\n        return p, q, e, d, rs\n    else:\n        return p, q, e, d\n\n\ndef newkeys(\n    nbits: int,\n    accurate: bool = True,\n    poolsize: int = 1,\n    exponent: int = DEFAULT_EXPONENT,\n    nprimes: int = 2,\n) -> typing.Tuple[PublicKey, PrivateKey]:\n    \"\"\"Generates public and private keys, and returns them as (pub, priv).\n\n    The public key is also known as the 'encryption key', and is a\n    :py:class:`rsa.PublicKey` object. The private key is also known as the\n    'decryption key' and is a :py:class:`rsa.PrivateKey` object.\n\n    :param nbits: the number of bits required to store the modulus ``n``.\n    :param accurate: when True, ``n`` will have exactly the number of bits you\n        asked for. However, this makes key generation much slower. When False,\n        `n`` may have slightly less bits.\n    :param poolsize: the number of processes to use to generate the prime\n        numbers. If set to a number > 1, a parallel algorithm will be used.\n        This requires Python 2.6 or newer.\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param nprimes: the number of prime factors comprising the modulus.\n\n    :returns: a tuple (:py:class:`rsa.PublicKey`, :py:class:`rsa.PrivateKey`)\n\n    The ``poolsize`` parameter was added in *Python-RSA 3.1* and requires\n    Python 2.6 or newer.\n\n    \"\"\"\n\n    if nbits < 16:\n        raise ValueError(\"Key too small\")\n\n    if poolsize < 1:\n        raise ValueError(\"Pool size (%i) should be >= 1\" % poolsize)\n\n    if nprimes < 2:\n        raise ValueError(\"Number of primes (%i) should be >= 2\" % nprimes)\n\n    # Determine which getprime function to use\n    if poolsize > 1:\n        from rsa import parallel\n\n        def getprime_func(nbits: int) -> int:\n            return parallel.getprime(nbits, poolsize=poolsize)\n\n    else:\n        getprime_func = rsa.prime.getprime\n\n    # Generate the key components\n    result = gen_keys(nbits, getprime_func, accurate=accurate, exponent=exponent, nprimes=nprimes)\n    if len(result) == 4:\n        p, q, e, d = result\n        rs = []\n    else:\n        p, q, e, d, rs = result\n\n    # Create the key objects\n    n = math.prod([p, q] + rs)\n\n    return (PublicKey(n, e), PrivateKey(n, e, d, p, q, rs))\n\n\n__all__ = [\"PublicKey\", \"PrivateKey\", \"newkeys\"]\n\nif __name__ == \"__main__\":\n    import doctest\n\n    try:\n        for count in range(100):\n            (failures, tests) = doctest.testmod()\n            if failures:\n                break\n\n            if (count % 10 == 0 and count) or count == 1:\n                print(\"%i times\" % count)\n    except KeyboardInterrupt:\n        print(\"Aborted\")\n    else:\n        print(\"Doctests done\")\n", "rsa/pem.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions that load and write PEM-encoded files.\"\"\"\n\nimport base64\nimport typing\n\n# Should either be ASCII strings or bytes.\nFlexiText = typing.Union[str, bytes]\n\n\ndef _markers(pem_marker: FlexiText) -> typing.Tuple[bytes, bytes]:\n    \"\"\"\n    Returns the start and end PEM markers, as bytes.\n    \"\"\"\n\n    if not isinstance(pem_marker, bytes):\n        pem_marker = pem_marker.encode(\"ascii\")\n\n    return (\n        b\"-----BEGIN \" + pem_marker + b\"-----\",\n        b\"-----END \" + pem_marker + b\"-----\",\n    )\n\n\ndef _pem_lines(contents: bytes, pem_start: bytes, pem_end: bytes) -> typing.Iterator[bytes]:\n    \"\"\"Generator over PEM lines between pem_start and pem_end.\"\"\"\n\n    in_pem_part = False\n    seen_pem_start = False\n\n    for line in contents.splitlines():\n        line = line.strip()\n\n        # Skip empty lines\n        if not line:\n            continue\n\n        # Handle start marker\n        if line == pem_start:\n            if in_pem_part:\n                raise ValueError('Seen start marker \"%r\" twice' % pem_start)\n\n            in_pem_part = True\n            seen_pem_start = True\n            continue\n\n        # Skip stuff before first marker\n        if not in_pem_part:\n            continue\n\n        # Handle end marker\n        if in_pem_part and line == pem_end:\n            in_pem_part = False\n            break\n\n        # Load fields\n        if b\":\" in line:\n            continue\n\n        yield line\n\n    # Do some sanity checks\n    if not seen_pem_start:\n        raise ValueError('No PEM start marker \"%r\" found' % pem_start)\n\n    if in_pem_part:\n        raise ValueError('No PEM end marker \"%r\" found' % pem_end)\n\n\ndef load_pem(contents: FlexiText, pem_marker: FlexiText) -> bytes:\n    \"\"\"Loads a PEM file.\n\n    :param contents: the contents of the file to interpret\n    :param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'\n        when your file has '-----BEGIN RSA PRIVATE KEY-----' and\n        '-----END RSA PRIVATE KEY-----' markers.\n\n    :return: the base64-decoded content between the start and end markers.\n\n    @raise ValueError: when the content is invalid, for example when the start\n        marker cannot be found.\n\n    \"\"\"\n\n    # We want bytes, not text. If it's text, it can be converted to ASCII bytes.\n    if not isinstance(contents, bytes):\n        contents = contents.encode(\"ascii\")\n\n    (pem_start, pem_end) = _markers(pem_marker)\n    pem_lines = [line for line in _pem_lines(contents, pem_start, pem_end)]\n\n    # Base64-decode the contents\n    pem = b\"\".join(pem_lines)\n    return base64.standard_b64decode(pem)\n\n\ndef save_pem(contents: bytes, pem_marker: FlexiText) -> bytes:\n    \"\"\"Saves a PEM file.\n\n    :param contents: the contents to encode in PEM format\n    :param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'\n        when your file has '-----BEGIN RSA PRIVATE KEY-----' and\n        '-----END RSA PRIVATE KEY-----' markers.\n\n    :return: the base64-encoded content between the start and end markers, as bytes.\n\n    \"\"\"\n\n    (pem_start, pem_end) = _markers(pem_marker)\n\n    b64 = base64.standard_b64encode(contents).replace(b\"\\n\", b\"\")\n    pem_lines = [pem_start]\n\n    for block_start in range(0, len(b64), 64):\n        block = b64[block_start : block_start + 64]\n        pem_lines.append(block)\n\n    pem_lines.append(pem_end)\n    pem_lines.append(b\"\")\n\n    return b\"\\n\".join(pem_lines)\n", "rsa/__init__.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\"\"\"RSA module\n\nModule for calculating large primes, and RSA encryption, decryption, signing\nand verification. Includes generating public and private keys.\n\nWARNING: this implementation does not use compression of the cleartext input to\nprevent repetitions, or other common security improvements. Use with care.\n\n\"\"\"\n\nfrom rsa.key import newkeys, PrivateKey, PublicKey\nfrom rsa.pkcs1 import (\n    encrypt,\n    decrypt,\n    sign,\n    verify,\n    DecryptionError,\n    VerificationError,\n    find_signature_hash,\n    sign_hash,\n    compute_hash,\n)\n\n__author__ = \"Sybren Stuvel, Barry Mead and Yesudeep Mangalapilly\"\n__date__ = \"2023-04-23\"\n__version__ = \"4.10-dev0\"\n\n# Do doctest if we're run directly\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n__all__ = [\n    \"newkeys\",\n    \"encrypt\",\n    \"decrypt\",\n    \"sign\",\n    \"verify\",\n    \"PublicKey\",\n    \"PrivateKey\",\n    \"DecryptionError\",\n    \"VerificationError\",\n    \"find_signature_hash\",\n    \"compute_hash\",\n    \"sign_hash\",\n]\n", "rsa/transform.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Data transformation functions.\n\nFrom bytes to a number, number to bytes, etc.\n\"\"\"\n\nimport math\n\n\ndef bytes2int(raw_bytes: bytes) -> int:\n    r\"\"\"Converts a list of bytes or an 8-bit string to an integer.\n\n    When using unicode strings, encode it to some encoding like UTF8 first.\n\n    >>> (((128 * 256) + 64) * 256) + 15\n    8405007\n    >>> bytes2int(b'\\x80@\\x0f')\n    8405007\n\n    \"\"\"\n    return int.from_bytes(raw_bytes, \"big\", signed=False)\n\n\ndef int2bytes(number: int, fill_size: int = 0) -> bytes:\n    \"\"\"\n    Convert an unsigned integer to bytes (big-endian)::\n\n    Does not preserve leading zeros if you don't specify a fill size.\n\n    :param number:\n        Integer value\n    :param fill_size:\n        If the optional fill size is given the length of the resulting\n        byte string is expected to be the fill size and will be padded\n        with prefix zero bytes to satisfy that length.\n    :returns:\n        Raw bytes (base-256 representation).\n    :raises:\n        ``OverflowError`` when fill_size is given and the number takes up more\n        bytes than fit into the block. This requires the ``overflow``\n        argument to this function to be set to ``False`` otherwise, no\n        error will be raised.\n    \"\"\"\n\n    if number < 0:\n        raise ValueError(\"Number must be an unsigned integer: %d\" % number)\n\n    bytes_required = max(1, math.ceil(number.bit_length() / 8))\n\n    if fill_size > 0:\n        return number.to_bytes(fill_size, \"big\")\n\n    return number.to_bytes(bytes_required, \"big\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "rsa/pkcs1.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for PKCS#1 version 1.5 encryption and signing\n\nThis module implements certain functionality from PKCS#1 version 1.5. For a\nvery clear example, read http://www.di-mgt.com.au/rsa_alg.html#pkcs1schemes\n\nAt least 8 bytes of random padding is used when encrypting a message. This makes\nthese methods much more secure than the ones in the ``rsa`` module.\n\nWARNING: this module leaks information when decryption fails. The exceptions\nthat are raised contain the Python traceback information, which can be used to\ndeduce where in the process the failure occurred. DO NOT PASS SUCH INFORMATION\nto your users.\n\"\"\"\n\nimport hashlib\nimport os\nimport sys\nimport typing\nfrom hmac import compare_digest\n\nfrom . import common, transform, core, key\n\nif typing.TYPE_CHECKING:\n    HashType = hashlib._Hash\nelse:\n    HashType = typing.Any\n\n# ASN.1 codes that describe the hash algorithm used.\nHASH_ASN1 = {\n    \"MD5\": b\"\\x30\\x20\\x30\\x0c\\x06\\x08\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x02\\x05\\x05\\x00\\x04\\x10\",\n    \"SHA-1\": b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\",\n    \"SHA-224\": b\"\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c\",\n    \"SHA-256\": b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\",\n    \"SHA-384\": b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\",\n    \"SHA-512\": b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\",\n    \"SHA3-256\": b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x08\\x05\\x00\\x04\\x20\",\n    \"SHA3-384\": b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x09\\x05\\x00\\x04\\x30\",\n    \"SHA3-512\": b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x0a\\x05\\x00\\x04\\x40\",\n}\n\nHASH_METHODS: typing.Dict[str, typing.Callable[[], HashType]] = {\n    \"MD5\": hashlib.md5,\n    \"SHA-1\": hashlib.sha1,\n    \"SHA-224\": hashlib.sha224,\n    \"SHA-256\": hashlib.sha256,\n    \"SHA-384\": hashlib.sha384,\n    \"SHA-512\": hashlib.sha512,\n    \"SHA3-256\": hashlib.sha3_256,\n    \"SHA3-384\": hashlib.sha3_384,\n    \"SHA3-512\": hashlib.sha3_512,\n}\n\"\"\"Hash methods supported by this library.\"\"\"\n\n\nclass CryptoError(Exception):\n    \"\"\"Base class for all exceptions in this module.\"\"\"\n\n\nclass DecryptionError(CryptoError):\n    \"\"\"Raised when decryption fails.\"\"\"\n\n\nclass VerificationError(CryptoError):\n    \"\"\"Raised when verification fails.\"\"\"\n\n\ndef _pad_for_encryption(message: bytes, target_length: int) -> bytes:\n    r\"\"\"Pads the message for encryption, returning the padded message.\n\n    :return: 00 02 RANDOM_DATA 00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \"\"\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError(\n            \"%i bytes needed for message, but there is only\"\n            \" space for %i\" % (msglength, max_msglength)\n        )\n\n    # Get random padding\n    padding = b\"\"\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b\"\\x00\", b\"\")\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b\"\".join([b\"\\x00\\x02\", padding, b\"\\x00\", message])\n\n\ndef _pad_for_signing(message: bytes, target_length: int) -> bytes:\n    r\"\"\"Pads the message for signing, returning the padded message.\n\n    The padding is always a repetition of FF bytes.\n\n    :return: 00 01 PADDING 00 MESSAGE\n\n    >>> block = _pad_for_signing(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x01'\n    >>> block[-6:]\n    b'\\x00hello'\n    >>> block[2:-6]\n    b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\n\n    \"\"\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError(\n            \"%i bytes needed for message, but there is only\"\n            \" space for %i\" % (msglength, max_msglength)\n        )\n\n    padding_length = target_length - msglength - 3\n\n    return b\"\".join([b\"\\x00\\x01\", padding_length * b\"\\xff\", b\"\\x00\", message])\n\n\ndef encrypt(message: bytes, pub_key: key.PublicKey) -> bytes:\n    \"\"\"Encrypts the given message using PKCS#1 v1.5\n\n    :param message: the message to encrypt. Must be a byte string no longer than\n        ``k-11`` bytes, where ``k`` is the number of bytes needed to encode\n        the ``n`` component of the public key.\n    :param pub_key: the :py:class:`rsa.PublicKey` to encrypt with.\n    :raise OverflowError: when the message is too large to fit in the padded\n        block.\n\n    >>> from rsa import key, common\n    >>> (pub_key, priv_key) = key.newkeys(256)\n    >>> message = b'hello'\n    >>> crypto = encrypt(message, pub_key)\n\n    The crypto text should be just as long as the public key 'n' component:\n\n    >>> len(crypto) == common.byte_size(pub_key.n)\n    True\n\n    \"\"\"\n\n    keylength = common.byte_size(pub_key.n)\n    padded = _pad_for_encryption(message, keylength)\n\n    payload = transform.bytes2int(padded)\n    encrypted = core.encrypt_int(payload, pub_key.e, pub_key.n)\n    block = transform.int2bytes(encrypted, keylength)\n\n    return block\n\n\ndef decrypt(crypto: bytes, priv_key: key.PrivateKey) -> bytes:\n    r\"\"\"Decrypts the given message using PKCS#1 v1.5\n\n    The decryption is considered 'failed' when the resulting cleartext doesn't\n    start with the bytes 00 02, or when the 00 byte between the padding and\n    the message cannot be found.\n\n    :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`\n    :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.\n    :raise DecryptionError: when the decryption fails. No details are given as\n        to why the code thinks the decryption fails, as this would leak\n        information about the private key.\n\n\n    >>> import rsa\n    >>> (pub_key, priv_key) = rsa.newkeys(256)\n\n    It works with strings:\n\n    >>> crypto = encrypt(b'hello', pub_key)\n    >>> decrypt(crypto, priv_key)\n    b'hello'\n\n    And with binary data:\n\n    >>> crypto = encrypt(b'\\x00\\x00\\x00\\x00\\x01', pub_key)\n    >>> decrypt(crypto, priv_key)\n    b'\\x00\\x00\\x00\\x00\\x01'\n\n    Altering the encrypted information will *likely* cause a\n    :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use\n    :py:func:`rsa.sign`.\n\n\n    .. warning::\n\n        Never display the stack trace of a\n        :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the\n        code the exception occurred, and thus leaks information about the key.\n        It's only a tiny bit of information, but every bit makes cracking the\n        keys easier.\n\n    >>> crypto = encrypt(b'hello', pub_key)\n    >>> crypto = crypto[0:5] + b'X' + crypto[6:] # change a byte\n    >>> decrypt(crypto, priv_key)\n    Traceback (most recent call last):\n    ...\n    rsa.pkcs1.DecryptionError: Decryption failed\n\n    \"\"\"\n\n    blocksize = common.byte_size(priv_key.n)\n    encrypted = transform.bytes2int(crypto)\n    decrypted = priv_key.blinded_decrypt(encrypted)\n    cleartext = transform.int2bytes(decrypted, blocksize)\n\n    # Detect leading zeroes in the crypto. These are not reflected in the\n    # encrypted value (as leading zeroes do not influence the value of an\n    # integer). This fixes CVE-2020-13757.\n    if len(crypto) > blocksize:\n        # This is operating on public information, so doesn't need to be constant-time.\n        raise DecryptionError(\"Decryption failed\")\n\n    # If we can't find the cleartext marker, decryption failed.\n    cleartext_marker_bad = not compare_digest(cleartext[:2], b\"\\x00\\x02\")\n\n    # Find the 00 separator between the padding and the message\n    sep_idx = cleartext.find(b\"\\x00\", 2)\n\n    # sep_idx indicates the position of the `\\x00` separator that separates the\n    # padding from the actual message. The padding should be at least 8 bytes\n    # long (see https://tools.ietf.org/html/rfc8017#section-7.2.2 step 3), which\n    # means the separator should be at least at index 10 (because of the\n    # `\\x00\\x02` marker that precedes it).\n    sep_idx_bad = sep_idx < 10\n\n    anything_bad = cleartext_marker_bad | sep_idx_bad\n    if anything_bad:\n        raise DecryptionError(\"Decryption failed\")\n\n    return cleartext[sep_idx + 1 :]\n\n\ndef sign_hash(hash_value: bytes, priv_key: key.PrivateKey, hash_method: str) -> bytes:\n    \"\"\"Signs a precomputed hash with the private key.\n\n    Signs the hash with the given key. This is known as a \"detached signature\",\n    because the message itself isn't altered.\n\n    :param hash_value: A precomputed hash to sign (ignores message).\n    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with\n    :param hash_method: the hash method used on the message. Use 'MD5', 'SHA-1',\n        'SHA-224', SHA-256', 'SHA-384' or 'SHA-512'.\n    :return: a message signature block.\n    :raise OverflowError: if the private key is too small to contain the\n        requested hash.\n\n    \"\"\"\n\n    # Get the ASN1 code for this hash method\n    if hash_method not in HASH_ASN1:\n        raise ValueError(\"Invalid hash method: %s\" % hash_method)\n    asn1code = HASH_ASN1[hash_method]\n\n    # Encrypt the hash with the private key\n    cleartext = asn1code + hash_value\n    keylength = common.byte_size(priv_key.n)\n    padded = _pad_for_signing(cleartext, keylength)\n\n    payload = transform.bytes2int(padded)\n    encrypted = priv_key.blinded_decrypt(payload)\n    block = transform.int2bytes(encrypted, keylength)\n\n    return block\n\n\ndef sign(message: bytes, priv_key: key.PrivateKey, hash_method: str) -> bytes:\n    \"\"\"Signs the message with the private key.\n\n    Hashes the message, then signs the hash with the given key. This is known\n    as a \"detached signature\", because the message itself isn't altered.\n\n    :param message: the message to sign. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with\n    :param hash_method: the hash method used on the message. Use 'MD5', 'SHA-1',\n        'SHA-224', SHA-256', 'SHA-384' or 'SHA-512'.\n    :return: a message signature block.\n    :raise OverflowError: if the private key is too small to contain the\n        requested hash.\n\n    \"\"\"\n\n    msg_hash = compute_hash(message, hash_method)\n    return sign_hash(msg_hash, priv_key, hash_method)\n\n\ndef verify(message: bytes, signature: bytes, pub_key: key.PublicKey) -> str:\n    \"\"\"Verifies that the signature matches the message.\n\n    The hash method is detected automatically from the signature.\n\n    :param message: the signed message. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param signature: the signature block, as created with :py:func:`rsa.sign`.\n    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.\n    :raise VerificationError: when the signature doesn't match the message.\n    :returns: the name of the used hash.\n\n    \"\"\"\n\n    keylength = common.byte_size(pub_key.n)\n    if len(signature) != keylength:\n        raise VerificationError(\"Verification failed\")\n    \n    encrypted = transform.bytes2int(signature)\n    decrypted = core.encrypt_int(encrypted, pub_key.e, pub_key.n)\n    clearsig = transform.int2bytes(decrypted, keylength)\n\n    # Get the hash method\n    method_name = _find_method_hash(clearsig)\n    message_hash = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    cleartext = HASH_ASN1[method_name] + message_hash\n    expected = _pad_for_signing(cleartext, keylength)\n\n    # Compare with the signed one\n    if expected != clearsig:\n        raise VerificationError(\"Verification failed\")\n\n    return method_name\n\n\ndef find_signature_hash(signature: bytes, pub_key: key.PublicKey) -> str:\n    \"\"\"Returns the hash name detected from the signature.\n\n    If you also want to verify the message, use :py:func:`rsa.verify()` instead.\n    It also returns the name of the used hash.\n\n    :param signature: the signature block, as created with :py:func:`rsa.sign`.\n    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.\n    :returns: the name of the used hash.\n    \"\"\"\n\n    keylength = common.byte_size(pub_key.n)\n    encrypted = transform.bytes2int(signature)\n    decrypted = core.decrypt_int(encrypted, pub_key.e, pub_key.n)\n    clearsig = transform.int2bytes(decrypted, keylength)\n\n    return _find_method_hash(clearsig)\n\n\ndef yield_fixedblocks(infile: typing.BinaryIO, blocksize: int) -> typing.Iterator[bytes]:\n    \"\"\"Generator, yields each block of ``blocksize`` bytes in the input file.\n\n    :param infile: file to read and separate in blocks.\n    :param blocksize: block size in bytes.\n    :returns: a generator that yields the contents of each block\n    \"\"\"\n\n    while True:\n        block = infile.read(blocksize)\n\n        read_bytes = len(block)\n        if read_bytes == 0:\n            break\n\n        yield block\n\n        if read_bytes < blocksize:\n            break\n\n\ndef compute_hash(message: typing.Union[bytes, typing.BinaryIO], method_name: str) -> bytes:\n    \"\"\"Returns the message digest.\n\n    :param message: the signed message. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param method_name: the hash method, must be a key of\n        :py:const:`rsa.pkcs1.HASH_METHODS`.\n\n    \"\"\"\n\n    if method_name not in HASH_METHODS:\n        raise ValueError(\"Invalid hash method: %s\" % method_name)\n\n    method = HASH_METHODS[method_name]\n    hasher = method()\n\n    if isinstance(message, bytes):\n        hasher.update(message)\n    else:\n        assert hasattr(message, \"read\") and hasattr(message.read, \"__call__\")\n        # read as 1K blocks\n        for block in yield_fixedblocks(message, 1024):\n            hasher.update(block)\n\n    return hasher.digest()\n\n\ndef _find_method_hash(clearsig: bytes) -> str:\n    \"\"\"Finds the hash method.\n\n    :param clearsig: full padded ASN1 and hash.\n    :return: the used hash method.\n    :raise VerificationFailed: when the hash method cannot be found\n    \"\"\"\n\n    for (hashname, asn1code) in HASH_ASN1.items():\n        if asn1code in clearsig:\n            return hashname\n\n    raise VerificationError(\"Verification failed\")\n\n\n__all__ = [\n    \"encrypt\",\n    \"decrypt\",\n    \"sign\",\n    \"verify\",\n    \"DecryptionError\",\n    \"VerificationError\",\n    \"CryptoError\",\n]\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(1000):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 100 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n"}