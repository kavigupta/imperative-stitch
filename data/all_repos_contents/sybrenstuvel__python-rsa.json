{"create_timing_table.py": "#!/usr/bin/env python\n#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nimport time\nimport rsa\n\npoolsize = 8\naccurate = True\n\n\ndef run_speed_test(bitsize):\n    iterations = 0\n    start = end = time.time()\n\n    # At least a number of iterations, and at least 2 seconds\n    while iterations < 10 or end - start < 2:\n        iterations += 1\n        rsa.newkeys(bitsize, accurate=accurate, poolsize=poolsize)\n        end = time.time()\n\n    duration = end - start\n    dur_per_call = duration / iterations\n\n    print('%5i bit: %9.3f sec. (%i iterations over %.1f seconds)' %\n          (bitsize, dur_per_call, iterations, duration))\n\n\nif __name__ == '__main__':\n    for bitsize in (128, 256, 384, 512, 1024, 2048, 3072, 4096):\n        run_speed_test(bitsize)\n", "rsa/asn1.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"ASN.1 definitions.\n\nNot all ASN.1-handling code use these definitions, but when it does, they should be here.\n\"\"\"\n\nfrom pyasn1.type import univ, namedtype, tag\n\n\nclass PubKeyHeader(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\"oid\", univ.ObjectIdentifier()),\n        namedtype.NamedType(\"parameters\", univ.Null()),\n    )\n\n\nclass OpenSSLPubKey(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\"header\", PubKeyHeader()),\n        # This little hack (the implicit tag) allows us to get a Bit String as Octet String\n        namedtype.NamedType(\n            \"key\",\n            univ.OctetString().subtype(implicitTag=tag.Tag(tagClass=0, tagFormat=0, tagId=3)),\n        ),\n    )\n\n\nclass AsnPubKey(univ.Sequence):\n    \"\"\"ASN.1 contents of DER encoded public key:\n\n    RSAPublicKey ::= SEQUENCE {\n         modulus           INTEGER,  -- n\n         publicExponent    INTEGER,  -- e\n    \"\"\"\n\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\"modulus\", univ.Integer()),\n        namedtype.NamedType(\"publicExponent\", univ.Integer()),\n    )\n", "rsa/common.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Common functionality shared by several modules.\"\"\"\n\nimport typing\n\n\nclass NotRelativePrimeError(ValueError):\n    def __init__(self, a: int, b: int, d: int, msg: str = \"\") -> None:\n        super().__init__(msg or \"%d and %d are not relatively prime, divider=%i\" % (a, b, d))\n        self.a = a\n        self.b = b\n        self.d = d\n\n\ndef bit_size(num: int) -> int:\n    \"\"\"\n    Number of bits needed to represent a integer excluding any prefix\n    0 bits.\n\n    Usage::\n\n        >>> bit_size(1023)\n        10\n        >>> bit_size(1024)\n        11\n        >>> bit_size(1025)\n        11\n\n    :param num:\n        Integer value. If num is 0, returns 0. Only the absolute value of the\n        number is considered. Therefore, signed integers will be abs(num)\n        before the number's bit length is determined.\n    :returns:\n        Returns the number of bits in the integer.\n    \"\"\"\n\n    try:\n        return num.bit_length()\n    except AttributeError as ex:\n        raise TypeError(\"bit_size(num) only supports integers, not %r\" % type(num)) from ex\n\n\ndef byte_size(number: int) -> int:\n    \"\"\"\n    Returns the number of bytes required to hold a specific long number.\n\n    The number of bytes is rounded up.\n\n    Usage::\n\n        >>> byte_size(1 << 1023)\n        128\n        >>> byte_size((1 << 1024) - 1)\n        128\n        >>> byte_size(1 << 1024)\n        129\n\n    :param number:\n        An unsigned integer\n    :returns:\n        The number of bytes required to hold a specific long number.\n    \"\"\"\n    if number == 0:\n        return 1\n    return ceil_div(bit_size(number), 8)\n\n\ndef ceil_div(num: int, div: int) -> int:\n    \"\"\"\n    Returns the ceiling function of a division between `num` and `div`.\n\n    Usage::\n\n        >>> ceil_div(100, 7)\n        15\n        >>> ceil_div(100, 10)\n        10\n        >>> ceil_div(1, 4)\n        1\n\n    :param num: Division's numerator, a number\n    :param div: Division's divisor, a number\n\n    :return: Rounded up result of the division between the parameters.\n    \"\"\"\n    quanta, mod = divmod(num, div)\n    if mod:\n        quanta += 1\n    return quanta\n\n\ndef extended_gcd(a: int, b: int) -> typing.Tuple[int, int, int]:\n    \"\"\"Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb\"\"\"\n    # r = gcd(a,b) i = multiplicitive inverse of a mod b\n    #      or      j = multiplicitive inverse of b mod a\n    # Neg return values for i or j are made positive mod b or a respectively\n    # Iterateive Version is faster and uses much less stack space\n    x = 0\n    y = 1\n    lx = 1\n    ly = 0\n    oa = a  # Remember original a/b to remove\n    ob = b  # negative values from return results\n    while b != 0:\n        q = a // b\n        (a, b) = (b, a % b)\n        (x, lx) = ((lx - (q * x)), x)\n        (y, ly) = ((ly - (q * y)), y)\n    if lx < 0:\n        lx += ob  # If neg wrap modulo original b\n    if ly < 0:\n        ly += oa  # If neg wrap modulo original a\n    return a, lx, ly  # Return only positive values\n\n\ndef inverse(x: int, n: int) -> int:\n    \"\"\"Returns the inverse of x % n under multiplication, a.k.a x^-1 (mod n)\n\n    >>> inverse(7, 4)\n    3\n    >>> (inverse(143, 4) * 143) % 4\n    1\n    \"\"\"\n\n    (divider, inv, _) = extended_gcd(x, n)\n\n    if divider != 1:\n        raise NotRelativePrimeError(x, n, divider)\n\n    return inv\n\n\ndef crt(a_values: typing.Iterable[int], modulo_values: typing.Iterable[int]) -> int:\n    \"\"\"Chinese Remainder Theorem.\n\n    Calculates x such that x = a[i] (mod m[i]) for each i.\n\n    :param a_values: the a-values of the above equation\n    :param modulo_values: the m-values of the above equation\n    :returns: x such that x = a[i] (mod m[i]) for each i\n\n\n    >>> crt([2, 3], [3, 5])\n    8\n\n    >>> crt([2, 3, 2], [3, 5, 7])\n    23\n\n    >>> crt([2, 3, 0], [7, 11, 15])\n    135\n    \"\"\"\n\n    m = 1\n    x = 0\n\n    for modulo in modulo_values:\n        m *= modulo\n\n    for (m_i, a_i) in zip(modulo_values, a_values):\n        M_i = m // m_i\n        inv = inverse(M_i, m_i)\n\n        x = (x + a_i * M_i * inv) % m\n\n    return x\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "rsa/cli.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Commandline scripts.\n\nThese scripts are called by the executables defined in setup.py.\n\"\"\"\n\nimport abc\nimport sys\nimport typing\nimport optparse\n\nimport rsa\nimport rsa.key\nimport rsa.pkcs1\n\nHASH_METHODS = sorted(rsa.pkcs1.HASH_METHODS.keys())\nIndexable = typing.Union[typing.Tuple, typing.List[str]]\n\n\ndef keygen() -> None:\n    \"\"\"Key generator.\"\"\"\n\n    # Parse the CLI options\n    parser = optparse.OptionParser(\n        usage=\"usage: %prog [options] keysize\",\n        description='Generates a new RSA key pair of \"keysize\" bits.',\n    )\n\n    parser.add_option(\n        \"--pubout\",\n        type=\"string\",\n        help=\"Output filename for the public key. The public key is \"\n        \"not saved if this option is not present. You can use \"\n        \"pyrsa-priv2pub to create the public key file later.\",\n    )\n\n    parser.add_option(\n        \"-o\",\n        \"--out\",\n        type=\"string\",\n        help=\"Output filename for the private key. The key is \"\n        \"written to stdout if this option is not present.\",\n    )\n\n    parser.add_option(\n        \"--form\",\n        help=\"key format of the private and public keys - default PEM\",\n        choices=(\"PEM\", \"DER\"),\n        default=\"PEM\",\n    )\n\n    (cli, cli_args) = parser.parse_args(sys.argv[1:])\n\n    if len(cli_args) != 1:\n        parser.print_help()\n        raise SystemExit(1)\n\n    try:\n        keysize = int(cli_args[0])\n    except ValueError as ex:\n        parser.print_help()\n        print(\"Not a valid number: %s\" % cli_args[0], file=sys.stderr)\n        raise SystemExit(1) from ex\n\n    print(\"Generating %i-bit key\" % keysize, file=sys.stderr)\n    (pub_key, priv_key) = rsa.newkeys(keysize)\n\n    # Save public key\n    if cli.pubout:\n        print(\"Writing public key to %s\" % cli.pubout, file=sys.stderr)\n        data = pub_key.save_pkcs1(format=cli.form)\n        with open(cli.pubout, \"wb\") as outfile:\n            outfile.write(data)\n\n    # Save private key\n    data = priv_key.save_pkcs1(format=cli.form)\n\n    if cli.out:\n        print(\"Writing private key to %s\" % cli.out, file=sys.stderr)\n        with open(cli.out, \"wb\") as outfile:\n            outfile.write(data)\n    else:\n        print(\"Writing private key to stdout\", file=sys.stderr)\n        sys.stdout.buffer.write(data)\n\n\nclass CryptoOperation(metaclass=abc.ABCMeta):\n    \"\"\"CLI callable that operates with input, output, and a key.\"\"\"\n\n    keyname = \"public\"  # or 'private'\n    usage = \"usage: %%prog [options] %(keyname)s_key\"\n    description = \"\"\n    operation = \"decrypt\"\n    operation_past = \"decrypted\"\n    operation_progressive = \"decrypting\"\n    input_help = \"Name of the file to %(operation)s. Reads from stdin if \" \"not specified.\"\n    output_help = (\n        \"Name of the file to write the %(operation_past)s file \"\n        \"to. Written to stdout if this option is not present.\"\n    )\n    expected_cli_args = 1\n    has_output = True\n\n    key_class = rsa.PublicKey  # type: typing.Type[rsa.key.AbstractKey]\n\n    def __init__(self) -> None:\n        self.usage = self.usage % self.__class__.__dict__\n        self.input_help = self.input_help % self.__class__.__dict__\n        self.output_help = self.output_help % self.__class__.__dict__\n\n    @abc.abstractmethod\n    def perform_operation(\n        self, indata: bytes, key: rsa.key.AbstractKey, cli_args: Indexable\n    ) -> typing.Any:\n        \"\"\"Performs the program's operation.\n\n        Implement in a subclass.\n\n        :returns: the data to write to the output.\n        \"\"\"\n\n    def __call__(self) -> None:\n        \"\"\"Runs the program.\"\"\"\n\n        (cli, cli_args) = self.parse_cli()\n\n        key = self.read_key(cli_args[0], cli.keyform)\n\n        indata = self.read_infile(cli.input)\n\n        print(self.operation_progressive.title(), file=sys.stderr)\n        outdata = self.perform_operation(indata, key, cli_args)\n\n        if self.has_output:\n            self.write_outfile(outdata, cli.output)\n\n    def parse_cli(self) -> typing.Tuple[optparse.Values, typing.List[str]]:\n        \"\"\"Parse the CLI options\n\n        :returns: (cli_opts, cli_args)\n        \"\"\"\n\n        parser = optparse.OptionParser(usage=self.usage, description=self.description)\n\n        parser.add_option(\"-i\", \"--input\", type=\"string\", help=self.input_help)\n\n        if self.has_output:\n            parser.add_option(\"-o\", \"--output\", type=\"string\", help=self.output_help)\n\n        parser.add_option(\n            \"--keyform\",\n            help=\"Key format of the %s key - default PEM\" % self.keyname,\n            choices=(\"PEM\", \"DER\"),\n            default=\"PEM\",\n        )\n\n        (cli, cli_args) = parser.parse_args(sys.argv[1:])\n\n        if len(cli_args) != self.expected_cli_args:\n            parser.print_help()\n            raise SystemExit(1)\n\n        return cli, cli_args\n\n    def read_key(self, filename: str, keyform: str) -> rsa.key.AbstractKey:\n        \"\"\"Reads a public or private key.\"\"\"\n\n        print(\"Reading %s key from %s\" % (self.keyname, filename), file=sys.stderr)\n        with open(filename, \"rb\") as keyfile:\n            keydata = keyfile.read()\n\n        return self.key_class.load_pkcs1(keydata, keyform)\n\n    def read_infile(self, inname: str) -> bytes:\n        \"\"\"Read the input file\"\"\"\n\n        if inname:\n            print(\"Reading input from %s\" % inname, file=sys.stderr)\n            with open(inname, \"rb\") as infile:\n                return infile.read()\n\n        print(\"Reading input from stdin\", file=sys.stderr)\n        return sys.stdin.buffer.read()\n\n    def write_outfile(self, outdata: bytes, outname: str) -> None:\n        \"\"\"Write the output file\"\"\"\n\n        if outname:\n            print(\"Writing output to %s\" % outname, file=sys.stderr)\n            with open(outname, \"wb\") as outfile:\n                outfile.write(outdata)\n        else:\n            print(\"Writing output to stdout\", file=sys.stderr)\n            sys.stdout.buffer.write(outdata)\n\n\nclass EncryptOperation(CryptoOperation):\n    \"\"\"Encrypts a file.\"\"\"\n\n    keyname = \"public\"\n    description = (\n        \"Encrypts a file. The file must be shorter than the key \" \"length in order to be encrypted.\"\n    )\n    operation = \"encrypt\"\n    operation_past = \"encrypted\"\n    operation_progressive = \"encrypting\"\n\n    def perform_operation(\n        self, indata: bytes, pub_key: rsa.key.AbstractKey, cli_args: Indexable = ()\n    ) -> bytes:\n        \"\"\"Encrypts files.\"\"\"\n        assert isinstance(pub_key, rsa.key.PublicKey)\n        return rsa.encrypt(indata, pub_key)\n\n\nclass DecryptOperation(CryptoOperation):\n    \"\"\"Decrypts a file.\"\"\"\n\n    keyname = \"private\"\n    description = (\n        \"Decrypts a file. The original file must be shorter than \"\n        \"the key length in order to have been encrypted.\"\n    )\n    operation = \"decrypt\"\n    operation_past = \"decrypted\"\n    operation_progressive = \"decrypting\"\n    key_class = rsa.PrivateKey\n\n    def perform_operation(\n        self, indata: bytes, priv_key: rsa.key.AbstractKey, cli_args: Indexable = ()\n    ) -> bytes:\n        \"\"\"Decrypts files.\"\"\"\n        assert isinstance(priv_key, rsa.key.PrivateKey)\n        return rsa.decrypt(indata, priv_key)\n\n\nclass SignOperation(CryptoOperation):\n    \"\"\"Signs a file.\"\"\"\n\n    keyname = \"private\"\n    usage = \"usage: %%prog [options] private_key hash_method\"\n    description = (\n        \"Signs a file, outputs the signature. Choose the hash \"\n        \"method from %s\" % \", \".join(HASH_METHODS)\n    )\n    operation = \"sign\"\n    operation_past = \"signature\"\n    operation_progressive = \"Signing\"\n    key_class = rsa.PrivateKey\n    expected_cli_args = 2\n\n    output_help = (\n        \"Name of the file to write the signature to. Written \"\n        \"to stdout if this option is not present.\"\n    )\n\n    def perform_operation(\n        self, indata: bytes, priv_key: rsa.key.AbstractKey, cli_args: Indexable\n    ) -> bytes:\n        \"\"\"Signs files.\"\"\"\n        assert isinstance(priv_key, rsa.key.PrivateKey)\n\n        hash_method = cli_args[1]\n        if hash_method not in HASH_METHODS:\n            raise SystemExit(\"Invalid hash method, choose one of %s\" % \", \".join(HASH_METHODS))\n\n        return rsa.sign(indata, priv_key, hash_method)\n\n\nclass VerifyOperation(CryptoOperation):\n    \"\"\"Verify a signature.\"\"\"\n\n    keyname = \"public\"\n    usage = \"usage: %%prog [options] public_key signature_file\"\n    description = (\n        \"Verifies a signature, exits with status 0 upon success, \"\n        \"prints an error message and exits with status 1 upon error.\"\n    )\n    operation = \"verify\"\n    operation_past = \"verified\"\n    operation_progressive = \"Verifying\"\n    key_class = rsa.PublicKey\n    expected_cli_args = 2\n    has_output = False\n\n    def perform_operation(\n        self, indata: bytes, pub_key: rsa.key.AbstractKey, cli_args: Indexable\n    ) -> None:\n        \"\"\"Verifies files.\"\"\"\n        assert isinstance(pub_key, rsa.key.PublicKey)\n\n        signature_file = cli_args[1]\n\n        with open(signature_file, \"rb\") as sigfile:\n            signature = sigfile.read()\n\n        try:\n            rsa.verify(indata, signature, pub_key)\n        except rsa.VerificationError as ex:\n            raise SystemExit(\"Verification failed.\") from ex\n\n        print(\"Verification OK\", file=sys.stderr)\n\n\nencrypt = EncryptOperation()\ndecrypt = DecryptOperation()\nsign = SignOperation()\nverify = VerifyOperation()\n", "rsa/pkcs1_v2.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for PKCS#1 version 2 encryption and signing\n\nThis module implements certain functionality from PKCS#1 version 2. Main\ndocumentation is RFC 2437: https://tools.ietf.org/html/rfc2437\n\"\"\"\n\nfrom rsa import (\n    common,\n    pkcs1,\n    transform,\n)\n\n\ndef mgf1(seed: bytes, length: int, hasher: str = \"SHA-1\") -> bytes:\n    \"\"\"\n    MGF1 is a Mask Generation Function based on a hash function.\n\n    A mask generation function takes an octet string of variable length and a\n    desired output length as input, and outputs an octet string of the desired\n    length. The plaintext-awareness of RSAES-OAEP relies on the random nature of\n    the output of the mask generation function, which in turn relies on the\n    random nature of the underlying hash.\n\n    :param bytes seed: seed from which mask is generated, an octet string\n    :param int length: intended length in octets of the mask, at most 2^32(hLen)\n    :param str hasher: hash function (hLen denotes the length in octets of the hash\n        function output)\n\n    :return: mask, an octet string of length `length`\n    :rtype: bytes\n\n    :raise OverflowError: when `length` is too large for the specified `hasher`\n    :raise ValueError: when specified `hasher` is invalid\n    \"\"\"\n\n    try:\n        hash_length = pkcs1.HASH_METHODS[hasher]().digest_size\n    except KeyError as ex:\n        raise ValueError(\n            \"Invalid `hasher` specified. Please select one of: {hash_list}\".format(\n                hash_list=\", \".join(sorted(pkcs1.HASH_METHODS.keys()))\n            )\n        ) from ex\n\n    # If l > 2^32(hLen), output \"mask too long\" and stop.\n    if length > (2 ** 32 * hash_length):\n        raise OverflowError(\n            \"Desired length should be at most 2**32 times the hasher's output \"\n            \"length ({hash_length} for {hasher} function)\".format(\n                hash_length=hash_length,\n                hasher=hasher,\n            )\n        )\n\n    # Looping `counter` from 0 to ceil(l / hLen)-1, build `output` based on the\n    # hashes formed by (`seed` + C), being `C` an octet string of length 4\n    # generated by converting `counter` with the primitive I2OSP\n    output = b\"\".join(\n        pkcs1.compute_hash(\n            seed + transform.int2bytes(counter, fill_size=4),\n            method_name=hasher,\n        )\n        for counter in range(common.ceil_div(length, hash_length) + 1)\n    )\n\n    # Output the leading `length` octets of `output` as the octet string mask.\n    return output[:length]\n\n\n__all__ = [\n    \"mgf1\",\n]\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(1000):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 100 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "rsa/core.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Core mathematical operations.\n\nThis is the actual core RSA implementation, which is only defined\nmathematically on integers.\n\"\"\"\nimport itertools\nimport typing\n\n\ndef assert_int(var: int, name: str) -> None:\n    if isinstance(var, int):\n        return\n\n    raise TypeError(\"{} should be an integer, not {}\".format(name, var.__class__))\n\n\ndef encrypt_int(message: int, ekey: int, n: int) -> int:\n    \"\"\"Encrypts a message using encryption key 'ekey', working modulo n\"\"\"\n\n    assert_int(message, \"message\")\n    assert_int(ekey, \"ekey\")\n    assert_int(n, \"n\")\n\n    if message < 0:\n        raise ValueError(\"Only non-negative numbers are supported\")\n\n    if message >= n:\n        raise OverflowError(\"The message %i is too long for n=%i\" % (message, n))\n\n    return pow(message, ekey, n)\n\n\ndef decrypt_int(cyphertext: int, dkey: int, n: int) -> int:\n    \"\"\"Decrypts a cypher text using the decryption key 'dkey', working modulo n\"\"\"\n\n    assert_int(cyphertext, \"cyphertext\")\n    assert_int(dkey, \"dkey\")\n    assert_int(n, \"n\")\n\n    message = pow(cyphertext, dkey, n)\n    return message\n\n\ndef decrypt_int_fast(\n    cyphertext: int,\n    rs: typing.List[int],\n    ds: typing.List[int],\n    ts: typing.List[int],\n) -> int:\n    \"\"\"Decrypts a cypher text more quickly using the Chinese Remainder Theorem.\"\"\"\n\n    assert_int(cyphertext, \"cyphertext\")\n    for r in rs:\n        assert_int(r, \"r\")\n    for d in ds:\n        assert_int(d, \"d\")\n    for t in ts:\n        assert_int(t, \"t\")\n\n    p, q, rs = rs[0], rs[1], rs[2:]\n    exp1, exp2, ds = ds[0], ds[1], ds[2:]\n    coef, ts = ts[0], ts[1:]\n\n    M1 = pow(cyphertext, exp1, p)\n    M2 = pow(cyphertext, exp2, q)\n    h = ((M1 - M2) * coef) % p\n    m = M2 + q * h\n\n    Ms = [pow(cyphertext, d, r) for d, r in zip(ds, rs)]\n    Rs = list(itertools.accumulate([p, q] + rs, lambda x, y: x*y))\n    for R, r, M, t in zip(Rs[1:], rs, Ms, ts):\n        h = ((M - m) * t) % r\n        m += R * h\n\n    return m", "rsa/randnum.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for generating random numbers.\"\"\"\n\n# Source inspired by code by Yesudeep Mangalapilly <yesudeep@gmail.com>\n\nimport os\nimport struct\n\nfrom rsa import common, transform\n\n\ndef read_random_bits(nbits: int) -> bytes:\n    \"\"\"Reads 'nbits' random bits.\n\n    If nbits isn't a whole number of bytes, an extra byte will be appended with\n    only the lower bits set.\n    \"\"\"\n\n    nbytes, rbits = divmod(nbits, 8)\n\n    # Get the random bytes\n    randomdata = os.urandom(nbytes)\n\n    # Add the remaining random bits\n    if rbits > 0:\n        randomvalue = ord(os.urandom(1))\n        randomvalue >>= 8 - rbits\n        randomdata = struct.pack(\"B\", randomvalue) + randomdata\n\n    return randomdata\n\n\ndef read_random_int(nbits: int) -> int:\n    \"\"\"Reads a random integer of approximately nbits bits.\"\"\"\n\n    randomdata = read_random_bits(nbits)\n    value = transform.bytes2int(randomdata)\n\n    # Ensure that the number is large enough to just fill out the required\n    # number of bits.\n    value |= 1 << (nbits - 1)\n\n    return value\n\n\ndef read_random_odd_int(nbits: int) -> int:\n    \"\"\"Reads a random odd integer of approximately nbits bits.\n\n    >>> read_random_odd_int(512) & 1\n    1\n    \"\"\"\n\n    value = read_random_int(nbits)\n\n    # Make sure it's odd\n    return value | 1\n\n\ndef randint(maxvalue: int) -> int:\n    \"\"\"Returns a random integer x with 1 <= x <= maxvalue\n\n    May take a very long time in specific situations. If maxvalue needs N bits\n    to store, the closer maxvalue is to (2 ** N) - 1, the faster this function\n    is.\n    \"\"\"\n\n    bit_size = common.bit_size(maxvalue)\n\n    tries = 0\n    while True:\n        value = read_random_int(bit_size)\n        if value <= maxvalue:\n            break\n\n        if tries % 10 == 0 and tries:\n            # After a lot of tries to get the right number of bits but still\n            # smaller than maxvalue, decrease the number of bits by 1. That'll\n            # dramatically increase the chances to get a large enough number.\n            bit_size -= 1\n        tries += 1\n\n    return value\n", "rsa/parallel.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for parallel computation on multiple cores.\n\nIntroduced in Python-RSA 3.1.\n\n.. note::\n\n    Requires Python 2.6 or newer.\n\n\"\"\"\n\nimport multiprocessing as mp\nfrom multiprocessing.connection import Connection\n\nimport rsa.prime\nimport rsa.randnum\n\n\ndef _find_prime(nbits: int, pipe: Connection) -> None:\n    while True:\n        integer = rsa.randnum.read_random_odd_int(nbits)\n\n        # Test for primeness\n        if rsa.prime.is_prime(integer):\n            pipe.send(integer)\n            return\n\n\ndef getprime(nbits: int, poolsize: int) -> int:\n    \"\"\"Returns a prime number that can be stored in 'nbits' bits.\n\n    Works in multiple threads at the same time.\n\n    >>> p = getprime(128, 3)\n    >>> rsa.prime.is_prime(p-1)\n    False\n    >>> rsa.prime.is_prime(p)\n    True\n    >>> rsa.prime.is_prime(p+1)\n    False\n\n    >>> from rsa import common\n    >>> common.bit_size(p) == 128\n    True\n\n    \"\"\"\n\n    (pipe_recv, pipe_send) = mp.Pipe(duplex=False)\n\n    # Create processes\n    try:\n        procs = [mp.Process(target=_find_prime, args=(nbits, pipe_send)) for _ in range(poolsize)]\n        # Start processes\n        for p in procs:\n            p.start()\n\n        result = pipe_recv.recv()\n    finally:\n        pipe_recv.close()\n        pipe_send.close()\n\n    # Terminate processes\n    for p in procs:\n        p.terminate()\n\n    return result\n\n\n__all__ = [\"getprime\"]\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(100):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 10 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "rsa/prime.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Numerical functions related to primes.\n\nImplementation based on the book Algorithm Design by Michael T. Goodrich and\nRoberto Tamassia, 2002.\n\"\"\"\n\nimport rsa.common\nimport rsa.randnum\n\n__all__ = [\"getprime\", \"are_relatively_prime\"]\n\n\ndef gcd(p: int, q: int) -> int:\n    \"\"\"Returns the greatest common divisor of p and q\n\n    >>> gcd(48, 180)\n    12\n    \"\"\"\n\n    while q != 0:\n        (p, q) = (q, p % q)\n    return p\n\n\ndef get_primality_testing_rounds(number: int) -> int:\n    \"\"\"Returns minimum number of rounds for Miller-Rabing primality testing,\n    based on number bitsize.\n\n    According to NIST FIPS 186-4, Appendix C, Table C.3, minimum number of\n    rounds of M-R testing, using an error probability of 2 ** (-100), for\n    different p, q bitsizes are:\n      * p, q bitsize: 512; rounds: 7\n      * p, q bitsize: 1024; rounds: 4\n      * p, q bitsize: 1536; rounds: 3\n    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    \"\"\"\n\n    # Calculate number bitsize.\n    bitsize = rsa.common.bit_size(number)\n    # Set number of rounds.\n    if bitsize >= 1536:\n        return 3\n    if bitsize >= 1024:\n        return 4\n    if bitsize >= 512:\n        return 7\n    # For smaller bitsizes, set arbitrary number of rounds.\n    return 10\n\n\ndef miller_rabin_primality_testing(n: int, k: int) -> bool:\n    \"\"\"Calculates whether n is composite (which is always correct) or prime\n    (which theoretically is incorrect with error probability 4**-k), by\n    applying Miller-Rabin primality testing.\n\n    For reference and implementation example, see:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n\n    :param n: Integer to be tested for primality.\n    :type n: int\n    :param k: Number of rounds (witnesses) of Miller-Rabin testing.\n    :type k: int\n    :return: False if the number is composite, True if it's probably prime.\n    :rtype: bool\n    \"\"\"\n\n    # prevent potential infinite loop when d = 0\n    if n < 2:\n        return False\n\n    # Decompose (n - 1) to write it as (2 ** r) * d\n    # While d is even, divide it by 2 and increase the exponent.\n    d = n - 1\n    r = 0\n\n    while not (d & 1):\n        r += 1\n        d >>= 1\n\n    # Test k witnesses.\n    for _ in range(k):\n        # Generate random integer a, where 2 <= a <= (n - 2)\n        a = rsa.randnum.randint(n - 3) + 1\n\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                # n is composite.\n                return False\n            if x == n - 1:\n                # Exit inner loop and continue with next witness.\n                break\n        else:\n            # If loop doesn't break, n is composite.\n            return False\n\n    return True\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Returns True if the number is prime, and False otherwise.\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(42)\n    False\n    >>> is_prime(41)\n    True\n    \"\"\"\n\n    # Check for small numbers.\n    if number < 10:\n        return number in {2, 3, 5, 7}\n\n    # Check for even numbers.\n    if not (number & 1):\n        return False\n\n    # Calculate minimum number of rounds.\n    k = get_primality_testing_rounds(number)\n\n    # Run primality testing with (minimum + 1) rounds.\n    return miller_rabin_primality_testing(number, k + 1)\n\n\ndef getprime(nbits: int) -> int:\n    \"\"\"Returns a prime number that can be stored in 'nbits' bits.\n\n    >>> p = getprime(128)\n    >>> is_prime(p-1)\n    False\n    >>> is_prime(p)\n    True\n    >>> is_prime(p+1)\n    False\n\n    >>> from rsa import common\n    >>> common.bit_size(p) == 128\n    True\n    \"\"\"\n\n    assert nbits > 3  # the loop will hang on too small numbers\n\n    while True:\n        integer = rsa.randnum.read_random_odd_int(nbits)\n\n        # Test for primeness\n        if is_prime(integer):\n            return integer\n\n            # Retry if not prime\n\n\ndef are_relatively_prime(a: int, b: int) -> bool:\n    \"\"\"Returns True if a and b are relatively prime, and False if they\n    are not.\n\n    >>> are_relatively_prime(2, 3)\n    True\n    >>> are_relatively_prime(2, 4)\n    False\n    \"\"\"\n\n    d = gcd(a, b)\n    return d == 1\n\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(1000):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 100 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "rsa/util.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Utility functions.\"\"\"\n\nimport sys\nfrom optparse import OptionParser\n\nimport rsa.key\n\n\ndef private_to_public() -> None:\n    \"\"\"Reads a private key and outputs the corresponding public key.\"\"\"\n\n    # Parse the CLI options\n    parser = OptionParser(\n        usage=\"usage: %prog [options]\",\n        description=\"Reads a private key and outputs the \"\n        \"corresponding public key. Both private and public keys use \"\n        \"the format described in PKCS#1 v1.5\",\n    )\n\n    parser.add_option(\n        \"-i\",\n        \"--input\",\n        dest=\"infilename\",\n        type=\"string\",\n        help=\"Input filename. Reads from stdin if not specified\",\n    )\n    parser.add_option(\n        \"-o\",\n        \"--output\",\n        dest=\"outfilename\",\n        type=\"string\",\n        help=\"Output filename. Writes to stdout of not specified\",\n    )\n\n    parser.add_option(\n        \"--inform\",\n        dest=\"inform\",\n        help=\"key format of input - default PEM\",\n        choices=(\"PEM\", \"DER\"),\n        default=\"PEM\",\n    )\n\n    parser.add_option(\n        \"--outform\",\n        dest=\"outform\",\n        help=\"key format of output - default PEM\",\n        choices=(\"PEM\", \"DER\"),\n        default=\"PEM\",\n    )\n\n    (cli, cli_args) = parser.parse_args(sys.argv)\n\n    # Read the input data\n    if cli.infilename:\n        print(\n            \"Reading private key from %s in %s format\" % (cli.infilename, cli.inform),\n            file=sys.stderr,\n        )\n        with open(cli.infilename, \"rb\") as infile:\n            in_data = infile.read()\n    else:\n        print(\"Reading private key from stdin in %s format\" % cli.inform, file=sys.stderr)\n        in_data = sys.stdin.read().encode(\"ascii\")\n\n    assert type(in_data) == bytes, type(in_data)\n\n    # Take the public fields and create a public key\n    priv_key = rsa.key.PrivateKey.load_pkcs1(in_data, cli.inform)\n    pub_key = rsa.key.PublicKey(priv_key.n, priv_key.e)\n\n    # Save to the output file\n    out_data = pub_key.save_pkcs1(cli.outform)\n\n    if cli.outfilename:\n        print(\n            \"Writing public key to %s in %s format\" % (cli.outfilename, cli.outform),\n            file=sys.stderr,\n        )\n        with open(cli.outfilename, \"wb\") as outfile:\n            outfile.write(out_data)\n    else:\n        print(\"Writing public key to stdout in %s format\" % cli.outform, file=sys.stderr)\n        sys.stdout.write(out_data.decode(\"ascii\"))\n", "rsa/key.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"RSA key generation code.\n\nCreate new keys with the newkeys() function. It will give you a PublicKey and a\nPrivateKey object.\n\nLoading and saving keys requires the pyasn1 module. This module is imported as\nlate as possible, such that other functionality will remain working in absence\nof pyasn1.\n\n.. note::\n\n    Storing public and private keys via the `pickle` module is possible.\n    However, it is insecure to load a key from an untrusted source.\n    The pickle module is not secure against erroneous or maliciously\n    constructed data. Never unpickle data received from an untrusted\n    or unauthenticated source.\n\n\"\"\"\n\nimport abc\nimport math\nimport threading\nimport typing\nimport warnings\nimport itertools\n\nimport rsa.prime\nimport rsa.pem\nimport rsa.common\nimport rsa.randnum\nimport rsa.core\n\n\nDEFAULT_EXPONENT = 65537\n\n\nT = typing.TypeVar(\"T\", bound=\"AbstractKey\")\n\n\nclass AbstractKey(metaclass=abc.ABCMeta):\n    \"\"\"Abstract superclass for private and public keys.\"\"\"\n\n    __slots__ = (\"n\", \"e\", \"blindfac\", \"blindfac_inverse\", \"mutex\")\n\n    def __init__(self, n: int, e: int) -> None:\n        self.n = n\n        self.e = e\n\n        # These will be computed properly on the first call to blind().\n        self.blindfac = self.blindfac_inverse = -1\n\n        # Used to protect updates to the blinding factor in multi-threaded\n        # environments.\n        self.mutex = threading.Lock()\n\n    @classmethod\n    @abc.abstractmethod\n    def _load_pkcs1_pem(cls: typing.Type[T], keyfile: bytes) -> T:\n        \"\"\"Loads a key in PKCS#1 PEM format, implement in a subclass.\n\n        :param keyfile: contents of a PEM-encoded file that contains\n            the public key.\n        :type keyfile: bytes\n\n        :return: the loaded key\n        :rtype: AbstractKey\n        \"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def _load_pkcs1_der(cls: typing.Type[T], keyfile: bytes) -> T:\n        \"\"\"Loads a key in PKCS#1 PEM format, implement in a subclass.\n\n        :param keyfile: contents of a DER-encoded file that contains\n            the public key.\n        :type keyfile: bytes\n\n        :return: the loaded key\n        :rtype: AbstractKey\n        \"\"\"\n\n    @abc.abstractmethod\n    def _save_pkcs1_pem(self) -> bytes:\n        \"\"\"Saves the key in PKCS#1 PEM format, implement in a subclass.\n\n        :returns: the PEM-encoded key.\n        :rtype: bytes\n        \"\"\"\n\n    @abc.abstractmethod\n    def _save_pkcs1_der(self) -> bytes:\n        \"\"\"Saves the key in PKCS#1 DER format, implement in a subclass.\n\n        :returns: the DER-encoded key.\n        :rtype: bytes\n        \"\"\"\n\n    @classmethod\n    def load_pkcs1(cls: typing.Type[T], keyfile: bytes, format: str = \"PEM\") -> T:\n        \"\"\"Loads a key in PKCS#1 DER or PEM format.\n\n        :param keyfile: contents of a DER- or PEM-encoded file that contains\n            the key.\n        :type keyfile: bytes\n        :param format: the format of the file to load; 'PEM' or 'DER'\n        :type format: str\n\n        :return: the loaded key\n        :rtype: AbstractKey\n        \"\"\"\n\n        methods = {\n            \"PEM\": cls._load_pkcs1_pem,\n            \"DER\": cls._load_pkcs1_der,\n        }\n\n        method = cls._assert_format_exists(format, methods)\n        return method(keyfile)\n\n    @staticmethod\n    def _assert_format_exists(\n        file_format: str, methods: typing.Mapping[str, typing.Callable]\n    ) -> typing.Callable:\n        \"\"\"Checks whether the given file format exists in 'methods'.\"\"\"\n\n        try:\n            return methods[file_format]\n        except KeyError as ex:\n            formats = \", \".join(sorted(methods.keys()))\n            raise ValueError(\n                \"Unsupported format: %r, try one of %s\" % (file_format, formats)\n            ) from ex\n\n    def save_pkcs1(self, format: str = \"PEM\") -> bytes:\n        \"\"\"Saves the key in PKCS#1 DER or PEM format.\n\n        :param format: the format to save; 'PEM' or 'DER'\n        :type format: str\n        :returns: the DER- or PEM-encoded key.\n        :rtype: bytes\n        \"\"\"\n\n        methods = {\n            \"PEM\": self._save_pkcs1_pem,\n            \"DER\": self._save_pkcs1_der,\n        }\n\n        method = self._assert_format_exists(format, methods)\n        return method()\n\n    def blind(self, message: int) -> typing.Tuple[int, int]:\n        \"\"\"Performs blinding on the message.\n\n        :param message: the message, as integer, to blind.\n        :param r: the random number to blind with.\n        :return: tuple (the blinded message, the inverse of the used blinding factor)\n\n        The blinding is such that message = unblind(decrypt(blind(encrypt(message))).\n\n        See https://en.wikipedia.org/wiki/Blinding_%28cryptography%29\n        \"\"\"\n        blindfac, blindfac_inverse = self._update_blinding_factor()\n        blinded = (message * pow(blindfac, self.e, self.n)) % self.n\n        return blinded, blindfac_inverse\n\n    def unblind(self, blinded: int, blindfac_inverse: int) -> int:\n        \"\"\"Performs blinding on the message using random number 'blindfac_inverse'.\n\n        :param blinded: the blinded message, as integer, to unblind.\n        :param blindfac: the factor to unblind with.\n        :return: the original message.\n\n        The blinding is such that message = unblind(decrypt(blind(encrypt(message))).\n\n        See https://en.wikipedia.org/wiki/Blinding_%28cryptography%29\n        \"\"\"\n        return (blindfac_inverse * blinded) % self.n\n\n    def _initial_blinding_factor(self) -> int:\n        for _ in range(1000):\n            blind_r = rsa.randnum.randint(self.n - 1)\n            if rsa.prime.are_relatively_prime(self.n, blind_r):\n                return blind_r\n        raise RuntimeError(\"unable to find blinding factor\")\n\n    def _update_blinding_factor(self) -> typing.Tuple[int, int]:\n        \"\"\"Update blinding factors.\n\n        Computing a blinding factor is expensive, so instead this function\n        does this once, then updates the blinding factor as per section 9\n        of 'A Timing Attack against RSA with the Chinese Remainder Theorem'\n        by Werner Schindler.\n        See https://tls.mbed.org/public/WSchindler-RSA_Timing_Attack.pdf\n\n        :return: the new blinding factor and its inverse.\n        \"\"\"\n\n        with self.mutex:\n            if self.blindfac < 0:\n                # Compute initial blinding factor, which is rather slow to do.\n                self.blindfac = self._initial_blinding_factor()\n                self.blindfac_inverse = rsa.common.inverse(self.blindfac, self.n)\n            else:\n                # Reuse previous blinding factor.\n                self.blindfac = pow(self.blindfac, 2, self.n)\n                self.blindfac_inverse = pow(self.blindfac_inverse, 2, self.n)\n\n            return self.blindfac, self.blindfac_inverse\n\n\nclass PublicKey(AbstractKey):\n    \"\"\"Represents a public RSA key.\n\n    This key is also known as the 'encryption key'. It contains the 'n' and 'e'\n    values.\n\n    Supports attributes as well as dictionary-like access. Attribute access is\n    faster, though.\n\n    >>> PublicKey(5, 3)\n    PublicKey(5, 3)\n\n    >>> key = PublicKey(5, 3)\n    >>> key.n\n    5\n    >>> key['n']\n    5\n    >>> key.e\n    3\n    >>> key['e']\n    3\n\n    \"\"\"\n\n    __slots__ = ()\n\n    def __getitem__(self, key: str) -> int:\n        return getattr(self, key)\n\n    def __repr__(self) -> str:\n        return \"PublicKey(%i, %i)\" % (self.n, self.e)\n\n    def __getstate__(self) -> typing.Tuple[int, int]:\n        \"\"\"Returns the key as tuple for pickling.\"\"\"\n        return self.n, self.e\n\n    def __setstate__(self, state: typing.Tuple[int, int]) -> None:\n        \"\"\"Sets the key from tuple.\"\"\"\n        self.n, self.e = state\n        AbstractKey.__init__(self, self.n, self.e)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if other is None:\n            return False\n\n        if not isinstance(other, PublicKey):\n            return False\n\n        return self.n == other.n and self.e == other.e\n\n    def __ne__(self, other: typing.Any) -> bool:\n        return not (self == other)\n\n    def __hash__(self) -> int:\n        return hash((self.n, self.e))\n\n    @classmethod\n    def _load_pkcs1_der(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a key in PKCS#1 DER format.\n\n        :param keyfile: contents of a DER-encoded file that contains the public\n            key.\n        :return: a PublicKey object\n\n        First let's construct a DER encoded key:\n\n        >>> import base64\n        >>> b64der = 'MAwCBQCNGmYtAgMBAAE='\n        >>> der = base64.standard_b64decode(b64der)\n\n        This loads the file:\n\n        >>> PublicKey._load_pkcs1_der(der)\n        PublicKey(2367317549, 65537)\n\n        \"\"\"\n\n        from pyasn1.codec.der import decoder\n        from rsa.asn1 import AsnPubKey\n\n        (priv, _) = decoder.decode(keyfile, asn1Spec=AsnPubKey())\n        return cls(n=int(priv[\"modulus\"]), e=int(priv[\"publicExponent\"]))\n\n    def _save_pkcs1_der(self) -> bytes:\n        \"\"\"Saves the public key in PKCS#1 DER format.\n\n        :returns: the DER-encoded public key.\n        :rtype: bytes\n        \"\"\"\n\n        from pyasn1.codec.der import encoder\n        from rsa.asn1 import AsnPubKey\n\n        # Create the ASN object\n        asn_key = AsnPubKey()\n        asn_key.setComponentByName(\"modulus\", self.n)\n        asn_key.setComponentByName(\"publicExponent\", self.e)\n\n        return encoder.encode(asn_key)\n\n    @classmethod\n    def _load_pkcs1_pem(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a PKCS#1 PEM-encoded public key file.\n\n        The contents of the file before the \"-----BEGIN RSA PUBLIC KEY-----\" and\n        after the \"-----END RSA PUBLIC KEY-----\" lines is ignored.\n\n        :param keyfile: contents of a PEM-encoded file that contains the public\n            key.\n        :return: a PublicKey object\n        \"\"\"\n\n        der = rsa.pem.load_pem(keyfile, \"RSA PUBLIC KEY\")\n        return cls._load_pkcs1_der(der)\n\n    def _save_pkcs1_pem(self) -> bytes:\n        \"\"\"Saves a PKCS#1 PEM-encoded public key file.\n\n        :return: contents of a PEM-encoded file that contains the public key.\n        :rtype: bytes\n        \"\"\"\n\n        der = self._save_pkcs1_der()\n        return rsa.pem.save_pem(der, \"RSA PUBLIC KEY\")\n\n    @classmethod\n    def load_pkcs1_openssl_pem(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a PKCS#1.5 PEM-encoded public key file from OpenSSL.\n\n        These files can be recognised in that they start with BEGIN PUBLIC KEY\n        rather than BEGIN RSA PUBLIC KEY.\n\n        The contents of the file before the \"-----BEGIN PUBLIC KEY-----\" and\n        after the \"-----END PUBLIC KEY-----\" lines is ignored.\n\n        :param keyfile: contents of a PEM-encoded file that contains the public\n            key, from OpenSSL.\n        :type keyfile: bytes\n        :return: a PublicKey object\n        \"\"\"\n\n        der = rsa.pem.load_pem(keyfile, \"PUBLIC KEY\")\n        return cls.load_pkcs1_openssl_der(der)\n\n    @classmethod\n    def load_pkcs1_openssl_der(cls, keyfile: bytes) -> \"PublicKey\":\n        \"\"\"Loads a PKCS#1 DER-encoded public key file from OpenSSL.\n\n        :param keyfile: contents of a DER-encoded file that contains the public\n            key, from OpenSSL.\n        :return: a PublicKey object\n        \"\"\"\n\n        from rsa.asn1 import OpenSSLPubKey\n        from pyasn1.codec.der import decoder\n        from pyasn1.type import univ\n\n        (keyinfo, _) = decoder.decode(keyfile, asn1Spec=OpenSSLPubKey())\n\n        if keyinfo[\"header\"][\"oid\"] != univ.ObjectIdentifier(\"1.2.840.113549.1.1.1\"):\n            raise TypeError(\"This is not a DER-encoded OpenSSL-compatible public key\")\n\n        return cls._load_pkcs1_der(keyinfo[\"key\"][1:])\n\n\nclass PrivateKey(AbstractKey):\n    \"\"\"Represents a private RSA key.\n\n    This key is also known as the 'decryption key'. It contains the 'n', 'e',\n    'd', 'p', 'q' and other values. For example ,in the case of multiprime RSA,\n    it additionally contains the lists 'rs', 'ds', and 'ts' which contain the\n    factors, exponents, and coefficients for the other primes.\n\n    Supports attributes as well as dictionary-like access. Attribute access is\n    faster, though.\n\n    >>> PrivateKey(3247, 65537, 833, 191, 17)\n    PrivateKey(3247, 65537, 833, 191, 17)\n\n    exp1, exp2 and coef will be calculated:\n\n    >>> pk = PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n    >>> pk.exp1\n    55063\n    >>> pk.exp2\n    10095\n    >>> pk.coef\n    50797\n\n    \"\"\"\n\n    __slots__ = (\"d\", \"p\", \"q\", \"exp1\", \"exp2\", \"coef\", \"rs\", \"ds\", \"ts\")\n\n    def __init__(\n        self,\n        n: int,\n        e: int,\n        d: int,\n        p: int,\n        q: int,\n        rs: typing.Optional[typing.List[int]] = None,\n    ) -> None:\n        rs = [] if rs is None else rs\n\n        AbstractKey.__init__(self, n, e)\n        self.d = d\n        self.p = p\n        self.q = q\n\n        # Calculate exponents and coefficient.\n        self.exp1 = int(d % (p - 1))\n        self.exp2 = int(d % (q - 1))\n        self.coef = rsa.common.inverse(q, p)\n\n        # Calculate other primes' exponents and coefficients.\n        self.rs = rs\n        self.ds = [int(d % (r - 1)) for r in rs]\n        Rs = list(itertools.accumulate([p, q] + rs, lambda x, y: x*y))\n        self.ts = [pow(R, -1, r) for R, r in zip(Rs[1:], rs)]\n\n    def __getitem__(self, key: str) -> int:\n        return getattr(self, key)\n\n    def __repr__(self) -> str:\n        if self.rs:\n            return \"PrivateKey(%i, %i, %i, %i, %i, %s)\" % (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.rs,\n            )\n        else:\n            return \"PrivateKey(%i, %i, %i, %i, %i)\" % (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n            )\n\n    def __getstate__(self) -> typing.Tuple:\n        \"\"\"Returns the key as tuple for pickling.\"\"\"\n        if self.rs:\n            return (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.exp1,\n                self.exp2,\n                self.coef,\n                self.rs,\n                self.ds,\n                self.ts,\n            )\n        else:\n            return self.n, self.e, self.d, self.p, self.q, self.exp1, self.exp2, self.coef\n\n    def __setstate__(self, state: typing.Tuple) -> None:\n        \"\"\"Sets the key from tuple.\"\"\"\n        if len(state) != 8:\n            (\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.exp1,\n                self.exp2,\n                self.coef,\n                self.rs,\n                self.ds,\n                self.ts,\n             ) = state\n        else:\n            self.n, self.e, self.d, self.p, self.q, self.exp1, self.exp2, self.coef = state\n            self.rs = self.ds = self.ts = []\n        AbstractKey.__init__(self, self.n, self.e)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if other is None:\n            return False\n\n        if not isinstance(other, PrivateKey):\n            return False\n\n        return all([getattr(self, k) == getattr(other, k) for k in self.__slots__])\n\n    def __ne__(self, other: typing.Any) -> bool:\n        return not (self == other)\n\n    def __hash__(self) -> int:\n        if self.rs:\n            return hash((\n                self.n,\n                self.e,\n                self.d,\n                self.p,\n                self.q,\n                self.exp1,\n                self.exp2,\n                self.coef,\n                *self.rs,\n                *self.ds,\n                *self.ts\n            ))\n        else:\n            return hash((self.n, self.e, self.d, self.p, self.q, self.exp1, self.exp2, self.coef))\n\n    def blinded_decrypt(self, encrypted: int) -> int:\n        \"\"\"Decrypts the message using blinding to prevent side-channel attacks.\n\n        :param encrypted: the encrypted message\n        :type encrypted: int\n\n        :returns: the decrypted message\n        :rtype: int\n        \"\"\"\n\n        # Blinding and un-blinding should be using the same factor\n        blinded, blindfac_inverse = self.blind(encrypted)\n        decrypted = rsa.core.decrypt_int_fast(\n            blinded,\n            [self.p, self.q] + self.rs,\n            [self.exp1, self.exp2] + self.ds,\n            [self.coef] + self.ts,\n        )\n        return self.unblind(decrypted, blindfac_inverse)\n\n    @classmethod\n    def _load_pkcs1_der(cls, keyfile: bytes) -> \"PrivateKey\":\n        \"\"\"Loads a key in PKCS#1 DER format.\n\n        :param keyfile: contents of a DER-encoded file that contains the private\n            key.\n        :type keyfile: bytes\n        :return: a PrivateKey object\n\n        First let's construct a DER encoded key:\n\n        >>> import base64\n        >>> b64der = 'MC4CAQACBQDeKYlRAgMBAAECBQDHn4npAgMA/icCAwDfxwIDANcXAgInbwIDAMZt'\n        >>> der = base64.standard_b64decode(b64der)\n\n        This loads the file:\n\n        >>> PrivateKey._load_pkcs1_der(der)\n        PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        \"\"\"\n\n        from pyasn1.codec.der import decoder\n\n        (priv, _) = decoder.decode(keyfile)\n\n        # ASN.1 contents of DER encoded private key:\n        #\n        # RSAPrivateKey ::= SEQUENCE {\n        #     version           Version,\n        #     modulus           INTEGER,  -- n\n        #     publicExponent    INTEGER,  -- e\n        #     privateExponent   INTEGER,  -- d\n        #     prime1            INTEGER,  -- p\n        #     prime2            INTEGER,  -- q\n        #     exponent1         INTEGER,  -- d mod (p-1)\n        #     exponent2         INTEGER,  -- d mod (q-1)\n        #     coefficient       INTEGER,  -- (inverse of q) mod p\n        #     otherPrimeInfos   OtherPrimeInfos OPTIONAL\n        # }\n\n        if priv[0] != 0:\n            raise ValueError(\"Unable to read this file, version %s != 0\" % priv[0])\n\n        n, e, d, p, q = map(int, priv[1:6])\n        exp1, exp2, coef = map(int, priv[6:9])\n        rs = map(int, priv[9::3])\n        ds = map(int, priv[10::3])\n        ts = map(int, priv[11::3])\n\n        key = cls(n, e, d, p, q, list(rs))\n\n        if (key.exp1, key.exp2, key.coef, key.rs, key.ds, key.ts) != (exp1, exp2, coef, rs, ds, ts):\n            warnings.warn(\n                \"You have provided a malformed keyfile. Either the exponents \"\n                \"or the coefficient are incorrect. Using the correct values \"\n                \"instead.\",\n                UserWarning,\n            )\n\n        return key\n\n    def _save_pkcs1_der(self) -> bytes:\n        \"\"\"Saves the private key in PKCS#1 DER format.\n\n        :returns: the DER-encoded private key.\n        :rtype: bytes\n        \"\"\"\n\n        from pyasn1.type import univ, namedtype\n        from pyasn1.codec.der import encoder\n\n        other_fields = [\n            (\n                namedtype.NamedType(\"prime%d\" % (i + 3), univ.Integer()),\n                namedtype.NamedType(\"exponent%d\" % (i + 3), univ.Integer()),\n                namedtype.NamedType(\"coefficient%d\" % (i + 3), univ.Integer()),\n            ) for i in range(len(self.rs))\n        ]\n        \n        class AsnPrivKey(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType(\"version\", univ.Integer()),\n                namedtype.NamedType(\"modulus\", univ.Integer()),\n                namedtype.NamedType(\"publicExponent\", univ.Integer()),\n                namedtype.NamedType(\"privateExponent\", univ.Integer()),\n                namedtype.NamedType(\"prime1\", univ.Integer()),\n                namedtype.NamedType(\"prime2\", univ.Integer()),\n                namedtype.NamedType(\"exponent1\", univ.Integer()),\n                namedtype.NamedType(\"exponent2\", univ.Integer()),\n                namedtype.NamedType(\"coefficient\", univ.Integer()),\n                *list(itertools.chain(*other_fields))\n            )\n\n        # Create the ASN object\n        asn_key = AsnPrivKey()\n        asn_key.setComponentByName(\"version\", 0)\n        asn_key.setComponentByName(\"modulus\", self.n)\n        asn_key.setComponentByName(\"publicExponent\", self.e)\n        asn_key.setComponentByName(\"privateExponent\", self.d)\n        asn_key.setComponentByName(\"prime1\", self.p)\n        asn_key.setComponentByName(\"prime2\", self.q)\n        asn_key.setComponentByName(\"exponent1\", self.exp1)\n        asn_key.setComponentByName(\"exponent2\", self.exp2)\n        asn_key.setComponentByName(\"coefficient\", self.coef)\n        for i, (r, d, t) in enumerate(zip(self.rs, self.ds, self.ts), start=3):\n            asn_key.setComponentByName(\"prime%d\" % i, r)\n            asn_key.setComponentByName(\"exponent%d\" % i, d)\n            asn_key.setComponentByName(\"coefficient%d\" % i, t)\n\n        return encoder.encode(asn_key)\n\n    @classmethod\n    def _load_pkcs1_pem(cls, keyfile: bytes) -> \"PrivateKey\":\n        \"\"\"Loads a PKCS#1 PEM-encoded private key file.\n\n        The contents of the file before the \"-----BEGIN RSA PRIVATE KEY-----\" and\n        after the \"-----END RSA PRIVATE KEY-----\" lines is ignored.\n\n        :param keyfile: contents of a PEM-encoded file that contains the private\n            key.\n        :type keyfile: bytes\n        :return: a PrivateKey object\n        \"\"\"\n\n        der = rsa.pem.load_pem(keyfile, b\"RSA PRIVATE KEY\")\n        return cls._load_pkcs1_der(der)\n\n    def _save_pkcs1_pem(self) -> bytes:\n        \"\"\"Saves a PKCS#1 PEM-encoded private key file.\n\n        :return: contents of a PEM-encoded file that contains the private key.\n        :rtype: bytes\n        \"\"\"\n\n        der = self._save_pkcs1_der()\n        return rsa.pem.save_pem(der, b\"RSA PRIVATE KEY\")\n\n\ndef find_primes(\n    nbits: int,\n    getprime_func: typing.Callable[[int], int] = rsa.prime.getprime,\n    accurate: bool = True,\n    nprimes: int = 2,\n) -> typing.List[int]:\n    \"\"\"Returns a list of different primes with nbits divided evenly among them.\n\n    :param nbits: the number of bits for the primes to sum to.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n    :param accurate: whether to enable accurate mode or not.\n    :returns: list of primes in descending order.\n\n    \"\"\"\n    if nprimes == 2:\n        return list(find_p_q(nbits // 2, getprime_func, accurate))\n\n    quo, rem = divmod(nbits, nprimes)\n    factor_lengths = [quo + 1]*rem + [quo] * (nprimes - rem)\n\n    while True:\n        primes = [getprime_func(length) for length in factor_lengths]\n        if len(set(primes)) == len(primes):\n            break\n\n    return list(reversed(sorted(primes)))\n\n\ndef find_p_q(\n    nbits: int,\n    getprime_func: typing.Callable[[int], int] = rsa.prime.getprime,\n    accurate: bool = True,\n) -> typing.Tuple[int, int]:\n    \"\"\"Returns a tuple of two different primes of nbits bits each.\n\n    The resulting p * q has exactly 2 * nbits bits, and the returned p and q\n    will not be equal.\n\n    :param nbits: the number of bits in each of p and q.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n\n        *Introduced in Python-RSA 3.1*\n\n    :param accurate: whether to enable accurate mode or not.\n    :returns: (p, q), where p > q\n\n    >>> (p, q) = find_p_q(128)\n    >>> from rsa import common\n    >>> common.bit_size(p * q)\n    256\n\n    When not in accurate mode, the number of bits can be slightly less\n\n    >>> (p, q) = find_p_q(128, accurate=False)\n    >>> from rsa import common\n    >>> common.bit_size(p * q) <= 256\n    True\n    >>> common.bit_size(p * q) > 240\n    True\n\n    \"\"\"\n\n    total_bits = nbits * 2\n\n    # Make sure that p and q aren't too close or the factoring programs can\n    # factor n.\n    shift = nbits // 16\n    pbits = nbits + shift\n    qbits = nbits - shift\n\n    # Choose the two initial primes\n    p = getprime_func(pbits)\n    q = getprime_func(qbits)\n\n    def is_acceptable(p: int, q: int) -> bool:\n        \"\"\"Returns True iff p and q are acceptable:\n\n        - p and q differ\n        - (p * q) has the right nr of bits (when accurate=True)\n        \"\"\"\n\n        if p == q:\n            return False\n\n        if not accurate:\n            return True\n\n        # Make sure we have just the right amount of bits\n        found_size = rsa.common.bit_size(p * q)\n        return total_bits == found_size\n\n    # Keep choosing other primes until they match our requirements.\n    change_p = False\n    while not is_acceptable(p, q):\n        # Change p on one iteration and q on the other\n        if change_p:\n            p = getprime_func(pbits)\n        else:\n            q = getprime_func(qbits)\n\n        change_p = not change_p\n\n    # We want p > q as described on\n    # http://www.di-mgt.com.au/rsa_alg.html#crt\n    return max(p, q), min(p, q)\n\n\ndef calculate_keys_custom_exponent(\n    p: int,\n    q: int,\n    exponent: int,\n    rs: typing.Optional[typing.List[int]] = None,\n) -> typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p, q and an exponent,\n    and returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param rs: the list of other large primes\n\n    \"\"\"\n\n    phi_n = math.prod([x - 1 for x in [p, q] + ([] if rs is None else rs)])\n\n    try:\n        d = rsa.common.inverse(exponent, phi_n)\n    except rsa.common.NotRelativePrimeError as ex:\n        raise rsa.common.NotRelativePrimeError(\n            exponent,\n            phi_n,\n            ex.d,\n            msg=\"e (%d) and phi_n (%d) are not relatively prime (divider=%i)\"\n            % (exponent, phi_n, ex.d),\n        ) from ex\n\n    if (exponent * d) % phi_n != 1:\n        raise ValueError(\n            \"e (%d) and d (%d) are not mult. inv. modulo \" \"phi_n (%d)\" % (exponent, d, phi_n)\n        )\n\n    return exponent, d\n\n\ndef calculate_keys(p: int, q: int) -> typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p and q, and\n    returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n\n    :return: tuple (e, d) with the encryption and decryption exponents.\n    \"\"\"\n\n    return calculate_keys_custom_exponent(p, q, DEFAULT_EXPONENT)\n\n\ndef gen_keys(\n    nbits: int,\n    getprime_func: typing.Callable[[int], int],\n    accurate: bool = True,\n    exponent: int = DEFAULT_EXPONENT,\n    nprimes: int = 2,\n) -> typing.Tuple:\n    \"\"\"Generate RSA keys of nbits bits. Returns (p, q, e, d) or (p, q, e, d, rs).\n\n    Note: this can take a long time, depending on the key size.\n\n    :param nbits: the total number of bits in ``p`` and ``q``. Both ``p`` and\n        ``q`` will use ``nbits/2`` bits.\n    :param getprime_func: either :py:func:`rsa.prime.getprime` or a function\n        with similar signature.\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param nprimes: the number of prime factors comprising the modulus.\n    \"\"\"\n\n    # Regenerate prime values, until calculate_keys_custom_exponent doesn't raise a\n    # ValueError.\n    while True:\n        primes = find_primes(nbits, getprime_func, accurate, nprimes)\n        p, q, rs = primes[0], primes[1], primes[2:]\n        try:\n            (e, d) = calculate_keys_custom_exponent(p, q, exponent=exponent, rs=rs)\n            break\n        except ValueError:\n            pass\n\n    if rs:\n        return p, q, e, d, rs\n    else:\n        return p, q, e, d\n\n\ndef newkeys(\n    nbits: int,\n    accurate: bool = True,\n    poolsize: int = 1,\n    exponent: int = DEFAULT_EXPONENT,\n    nprimes: int = 2,\n) -> typing.Tuple[PublicKey, PrivateKey]:\n    \"\"\"Generates public and private keys, and returns them as (pub, priv).\n\n    The public key is also known as the 'encryption key', and is a\n    :py:class:`rsa.PublicKey` object. The private key is also known as the\n    'decryption key' and is a :py:class:`rsa.PrivateKey` object.\n\n    :param nbits: the number of bits required to store the modulus ``n``.\n    :param accurate: when True, ``n`` will have exactly the number of bits you\n        asked for. However, this makes key generation much slower. When False,\n        `n`` may have slightly less bits.\n    :param poolsize: the number of processes to use to generate the prime\n        numbers. If set to a number > 1, a parallel algorithm will be used.\n        This requires Python 2.6 or newer.\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param nprimes: the number of prime factors comprising the modulus.\n\n    :returns: a tuple (:py:class:`rsa.PublicKey`, :py:class:`rsa.PrivateKey`)\n\n    The ``poolsize`` parameter was added in *Python-RSA 3.1* and requires\n    Python 2.6 or newer.\n\n    \"\"\"\n\n    if nbits < 16:\n        raise ValueError(\"Key too small\")\n\n    if poolsize < 1:\n        raise ValueError(\"Pool size (%i) should be >= 1\" % poolsize)\n\n    if nprimes < 2:\n        raise ValueError(\"Number of primes (%i) should be >= 2\" % nprimes)\n\n    # Determine which getprime function to use\n    if poolsize > 1:\n        from rsa import parallel\n\n        def getprime_func(nbits: int) -> int:\n            return parallel.getprime(nbits, poolsize=poolsize)\n\n    else:\n        getprime_func = rsa.prime.getprime\n\n    # Generate the key components\n    result = gen_keys(nbits, getprime_func, accurate=accurate, exponent=exponent, nprimes=nprimes)\n    if len(result) == 4:\n        p, q, e, d = result\n        rs = []\n    else:\n        p, q, e, d, rs = result\n\n    # Create the key objects\n    n = math.prod([p, q] + rs)\n\n    return (PublicKey(n, e), PrivateKey(n, e, d, p, q, rs))\n\n\n__all__ = [\"PublicKey\", \"PrivateKey\", \"newkeys\"]\n\nif __name__ == \"__main__\":\n    import doctest\n\n    try:\n        for count in range(100):\n            (failures, tests) = doctest.testmod()\n            if failures:\n                break\n\n            if (count % 10 == 0 and count) or count == 1:\n                print(\"%i times\" % count)\n    except KeyboardInterrupt:\n        print(\"Aborted\")\n    else:\n        print(\"Doctests done\")\n", "rsa/pem.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions that load and write PEM-encoded files.\"\"\"\n\nimport base64\nimport typing\n\n# Should either be ASCII strings or bytes.\nFlexiText = typing.Union[str, bytes]\n\n\ndef _markers(pem_marker: FlexiText) -> typing.Tuple[bytes, bytes]:\n    \"\"\"\n    Returns the start and end PEM markers, as bytes.\n    \"\"\"\n\n    if not isinstance(pem_marker, bytes):\n        pem_marker = pem_marker.encode(\"ascii\")\n\n    return (\n        b\"-----BEGIN \" + pem_marker + b\"-----\",\n        b\"-----END \" + pem_marker + b\"-----\",\n    )\n\n\ndef _pem_lines(contents: bytes, pem_start: bytes, pem_end: bytes) -> typing.Iterator[bytes]:\n    \"\"\"Generator over PEM lines between pem_start and pem_end.\"\"\"\n\n    in_pem_part = False\n    seen_pem_start = False\n\n    for line in contents.splitlines():\n        line = line.strip()\n\n        # Skip empty lines\n        if not line:\n            continue\n\n        # Handle start marker\n        if line == pem_start:\n            if in_pem_part:\n                raise ValueError('Seen start marker \"%r\" twice' % pem_start)\n\n            in_pem_part = True\n            seen_pem_start = True\n            continue\n\n        # Skip stuff before first marker\n        if not in_pem_part:\n            continue\n\n        # Handle end marker\n        if in_pem_part and line == pem_end:\n            in_pem_part = False\n            break\n\n        # Load fields\n        if b\":\" in line:\n            continue\n\n        yield line\n\n    # Do some sanity checks\n    if not seen_pem_start:\n        raise ValueError('No PEM start marker \"%r\" found' % pem_start)\n\n    if in_pem_part:\n        raise ValueError('No PEM end marker \"%r\" found' % pem_end)\n\n\ndef load_pem(contents: FlexiText, pem_marker: FlexiText) -> bytes:\n    \"\"\"Loads a PEM file.\n\n    :param contents: the contents of the file to interpret\n    :param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'\n        when your file has '-----BEGIN RSA PRIVATE KEY-----' and\n        '-----END RSA PRIVATE KEY-----' markers.\n\n    :return: the base64-decoded content between the start and end markers.\n\n    @raise ValueError: when the content is invalid, for example when the start\n        marker cannot be found.\n\n    \"\"\"\n\n    # We want bytes, not text. If it's text, it can be converted to ASCII bytes.\n    if not isinstance(contents, bytes):\n        contents = contents.encode(\"ascii\")\n\n    (pem_start, pem_end) = _markers(pem_marker)\n    pem_lines = [line for line in _pem_lines(contents, pem_start, pem_end)]\n\n    # Base64-decode the contents\n    pem = b\"\".join(pem_lines)\n    return base64.standard_b64decode(pem)\n\n\ndef save_pem(contents: bytes, pem_marker: FlexiText) -> bytes:\n    \"\"\"Saves a PEM file.\n\n    :param contents: the contents to encode in PEM format\n    :param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'\n        when your file has '-----BEGIN RSA PRIVATE KEY-----' and\n        '-----END RSA PRIVATE KEY-----' markers.\n\n    :return: the base64-encoded content between the start and end markers, as bytes.\n\n    \"\"\"\n\n    (pem_start, pem_end) = _markers(pem_marker)\n\n    b64 = base64.standard_b64encode(contents).replace(b\"\\n\", b\"\")\n    pem_lines = [pem_start]\n\n    for block_start in range(0, len(b64), 64):\n        block = b64[block_start : block_start + 64]\n        pem_lines.append(block)\n\n    pem_lines.append(pem_end)\n    pem_lines.append(b\"\")\n\n    return b\"\\n\".join(pem_lines)\n", "rsa/__init__.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\"\"\"RSA module\n\nModule for calculating large primes, and RSA encryption, decryption, signing\nand verification. Includes generating public and private keys.\n\nWARNING: this implementation does not use compression of the cleartext input to\nprevent repetitions, or other common security improvements. Use with care.\n\n\"\"\"\n\nfrom rsa.key import newkeys, PrivateKey, PublicKey\nfrom rsa.pkcs1 import (\n    encrypt,\n    decrypt,\n    sign,\n    verify,\n    DecryptionError,\n    VerificationError,\n    find_signature_hash,\n    sign_hash,\n    compute_hash,\n)\n\n__author__ = \"Sybren Stuvel, Barry Mead and Yesudeep Mangalapilly\"\n__date__ = \"2023-04-23\"\n__version__ = \"4.10-dev0\"\n\n# Do doctest if we're run directly\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n__all__ = [\n    \"newkeys\",\n    \"encrypt\",\n    \"decrypt\",\n    \"sign\",\n    \"verify\",\n    \"PublicKey\",\n    \"PrivateKey\",\n    \"DecryptionError\",\n    \"VerificationError\",\n    \"find_signature_hash\",\n    \"compute_hash\",\n    \"sign_hash\",\n]\n", "rsa/transform.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Data transformation functions.\n\nFrom bytes to a number, number to bytes, etc.\n\"\"\"\n\nimport math\n\n\ndef bytes2int(raw_bytes: bytes) -> int:\n    r\"\"\"Converts a list of bytes or an 8-bit string to an integer.\n\n    When using unicode strings, encode it to some encoding like UTF8 first.\n\n    >>> (((128 * 256) + 64) * 256) + 15\n    8405007\n    >>> bytes2int(b'\\x80@\\x0f')\n    8405007\n\n    \"\"\"\n    return int.from_bytes(raw_bytes, \"big\", signed=False)\n\n\ndef int2bytes(number: int, fill_size: int = 0) -> bytes:\n    \"\"\"\n    Convert an unsigned integer to bytes (big-endian)::\n\n    Does not preserve leading zeros if you don't specify a fill size.\n\n    :param number:\n        Integer value\n    :param fill_size:\n        If the optional fill size is given the length of the resulting\n        byte string is expected to be the fill size and will be padded\n        with prefix zero bytes to satisfy that length.\n    :returns:\n        Raw bytes (base-256 representation).\n    :raises:\n        ``OverflowError`` when fill_size is given and the number takes up more\n        bytes than fit into the block. This requires the ``overflow``\n        argument to this function to be set to ``False`` otherwise, no\n        error will be raised.\n    \"\"\"\n\n    if number < 0:\n        raise ValueError(\"Number must be an unsigned integer: %d\" % number)\n\n    bytes_required = max(1, math.ceil(number.bit_length() / 8))\n\n    if fill_size > 0:\n        return number.to_bytes(fill_size, \"big\")\n\n    return number.to_bytes(bytes_required, \"big\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "rsa/pkcs1.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Functions for PKCS#1 version 1.5 encryption and signing\n\nThis module implements certain functionality from PKCS#1 version 1.5. For a\nvery clear example, read http://www.di-mgt.com.au/rsa_alg.html#pkcs1schemes\n\nAt least 8 bytes of random padding is used when encrypting a message. This makes\nthese methods much more secure than the ones in the ``rsa`` module.\n\nWARNING: this module leaks information when decryption fails. The exceptions\nthat are raised contain the Python traceback information, which can be used to\ndeduce where in the process the failure occurred. DO NOT PASS SUCH INFORMATION\nto your users.\n\"\"\"\n\nimport hashlib\nimport os\nimport sys\nimport typing\nfrom hmac import compare_digest\n\nfrom . import common, transform, core, key\n\nif typing.TYPE_CHECKING:\n    HashType = hashlib._Hash\nelse:\n    HashType = typing.Any\n\n# ASN.1 codes that describe the hash algorithm used.\nHASH_ASN1 = {\n    \"MD5\": b\"\\x30\\x20\\x30\\x0c\\x06\\x08\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x02\\x05\\x05\\x00\\x04\\x10\",\n    \"SHA-1\": b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\",\n    \"SHA-224\": b\"\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c\",\n    \"SHA-256\": b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\",\n    \"SHA-384\": b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\",\n    \"SHA-512\": b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\",\n    \"SHA3-256\": b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x08\\x05\\x00\\x04\\x20\",\n    \"SHA3-384\": b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x09\\x05\\x00\\x04\\x30\",\n    \"SHA3-512\": b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x0a\\x05\\x00\\x04\\x40\",\n}\n\nHASH_METHODS: typing.Dict[str, typing.Callable[[], HashType]] = {\n    \"MD5\": hashlib.md5,\n    \"SHA-1\": hashlib.sha1,\n    \"SHA-224\": hashlib.sha224,\n    \"SHA-256\": hashlib.sha256,\n    \"SHA-384\": hashlib.sha384,\n    \"SHA-512\": hashlib.sha512,\n    \"SHA3-256\": hashlib.sha3_256,\n    \"SHA3-384\": hashlib.sha3_384,\n    \"SHA3-512\": hashlib.sha3_512,\n}\n\"\"\"Hash methods supported by this library.\"\"\"\n\n\nclass CryptoError(Exception):\n    \"\"\"Base class for all exceptions in this module.\"\"\"\n\n\nclass DecryptionError(CryptoError):\n    \"\"\"Raised when decryption fails.\"\"\"\n\n\nclass VerificationError(CryptoError):\n    \"\"\"Raised when verification fails.\"\"\"\n\n\ndef _pad_for_encryption(message: bytes, target_length: int) -> bytes:\n    r\"\"\"Pads the message for encryption, returning the padded message.\n\n    :return: 00 02 RANDOM_DATA 00 MESSAGE\n\n    >>> block = _pad_for_encryption(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x02'\n    >>> block[-6:]\n    b'\\x00hello'\n\n    \"\"\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError(\n            \"%i bytes needed for message, but there is only\"\n            \" space for %i\" % (msglength, max_msglength)\n        )\n\n    # Get random padding\n    padding = b\"\"\n    padding_length = target_length - msglength - 3\n\n    # We remove 0-bytes, so we'll end up with less padding than we've asked for,\n    # so keep adding data until we're at the correct length.\n    while len(padding) < padding_length:\n        needed_bytes = padding_length - len(padding)\n\n        # Always read at least 8 bytes more than we need, and trim off the rest\n        # after removing the 0-bytes. This increases the chance of getting\n        # enough bytes, especially when needed_bytes is small\n        new_padding = os.urandom(needed_bytes + 5)\n        new_padding = new_padding.replace(b\"\\x00\", b\"\")\n        padding = padding + new_padding[:needed_bytes]\n\n    assert len(padding) == padding_length\n\n    return b\"\".join([b\"\\x00\\x02\", padding, b\"\\x00\", message])\n\n\ndef _pad_for_signing(message: bytes, target_length: int) -> bytes:\n    r\"\"\"Pads the message for signing, returning the padded message.\n\n    The padding is always a repetition of FF bytes.\n\n    :return: 00 01 PADDING 00 MESSAGE\n\n    >>> block = _pad_for_signing(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x01'\n    >>> block[-6:]\n    b'\\x00hello'\n    >>> block[2:-6]\n    b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\n\n    \"\"\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError(\n            \"%i bytes needed for message, but there is only\"\n            \" space for %i\" % (msglength, max_msglength)\n        )\n\n    padding_length = target_length - msglength - 3\n\n    return b\"\".join([b\"\\x00\\x01\", padding_length * b\"\\xff\", b\"\\x00\", message])\n\n\ndef encrypt(message: bytes, pub_key: key.PublicKey) -> bytes:\n    \"\"\"Encrypts the given message using PKCS#1 v1.5\n\n    :param message: the message to encrypt. Must be a byte string no longer than\n        ``k-11`` bytes, where ``k`` is the number of bytes needed to encode\n        the ``n`` component of the public key.\n    :param pub_key: the :py:class:`rsa.PublicKey` to encrypt with.\n    :raise OverflowError: when the message is too large to fit in the padded\n        block.\n\n    >>> from rsa import key, common\n    >>> (pub_key, priv_key) = key.newkeys(256)\n    >>> message = b'hello'\n    >>> crypto = encrypt(message, pub_key)\n\n    The crypto text should be just as long as the public key 'n' component:\n\n    >>> len(crypto) == common.byte_size(pub_key.n)\n    True\n\n    \"\"\"\n\n    keylength = common.byte_size(pub_key.n)\n    padded = _pad_for_encryption(message, keylength)\n\n    payload = transform.bytes2int(padded)\n    encrypted = core.encrypt_int(payload, pub_key.e, pub_key.n)\n    block = transform.int2bytes(encrypted, keylength)\n\n    return block\n\n\ndef decrypt(crypto: bytes, priv_key: key.PrivateKey) -> bytes:\n    r\"\"\"Decrypts the given message using PKCS#1 v1.5\n\n    The decryption is considered 'failed' when the resulting cleartext doesn't\n    start with the bytes 00 02, or when the 00 byte between the padding and\n    the message cannot be found.\n\n    :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`\n    :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.\n    :raise DecryptionError: when the decryption fails. No details are given as\n        to why the code thinks the decryption fails, as this would leak\n        information about the private key.\n\n\n    >>> import rsa\n    >>> (pub_key, priv_key) = rsa.newkeys(256)\n\n    It works with strings:\n\n    >>> crypto = encrypt(b'hello', pub_key)\n    >>> decrypt(crypto, priv_key)\n    b'hello'\n\n    And with binary data:\n\n    >>> crypto = encrypt(b'\\x00\\x00\\x00\\x00\\x01', pub_key)\n    >>> decrypt(crypto, priv_key)\n    b'\\x00\\x00\\x00\\x00\\x01'\n\n    Altering the encrypted information will *likely* cause a\n    :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use\n    :py:func:`rsa.sign`.\n\n\n    .. warning::\n\n        Never display the stack trace of a\n        :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the\n        code the exception occurred, and thus leaks information about the key.\n        It's only a tiny bit of information, but every bit makes cracking the\n        keys easier.\n\n    >>> crypto = encrypt(b'hello', pub_key)\n    >>> crypto = crypto[0:5] + b'X' + crypto[6:] # change a byte\n    >>> decrypt(crypto, priv_key)\n    Traceback (most recent call last):\n    ...\n    rsa.pkcs1.DecryptionError: Decryption failed\n\n    \"\"\"\n\n    blocksize = common.byte_size(priv_key.n)\n    encrypted = transform.bytes2int(crypto)\n    decrypted = priv_key.blinded_decrypt(encrypted)\n    cleartext = transform.int2bytes(decrypted, blocksize)\n\n    # Detect leading zeroes in the crypto. These are not reflected in the\n    # encrypted value (as leading zeroes do not influence the value of an\n    # integer). This fixes CVE-2020-13757.\n    if len(crypto) > blocksize:\n        # This is operating on public information, so doesn't need to be constant-time.\n        raise DecryptionError(\"Decryption failed\")\n\n    # If we can't find the cleartext marker, decryption failed.\n    cleartext_marker_bad = not compare_digest(cleartext[:2], b\"\\x00\\x02\")\n\n    # Find the 00 separator between the padding and the message\n    sep_idx = cleartext.find(b\"\\x00\", 2)\n\n    # sep_idx indicates the position of the `\\x00` separator that separates the\n    # padding from the actual message. The padding should be at least 8 bytes\n    # long (see https://tools.ietf.org/html/rfc8017#section-7.2.2 step 3), which\n    # means the separator should be at least at index 10 (because of the\n    # `\\x00\\x02` marker that precedes it).\n    sep_idx_bad = sep_idx < 10\n\n    anything_bad = cleartext_marker_bad | sep_idx_bad\n    if anything_bad:\n        raise DecryptionError(\"Decryption failed\")\n\n    return cleartext[sep_idx + 1 :]\n\n\ndef sign_hash(hash_value: bytes, priv_key: key.PrivateKey, hash_method: str) -> bytes:\n    \"\"\"Signs a precomputed hash with the private key.\n\n    Signs the hash with the given key. This is known as a \"detached signature\",\n    because the message itself isn't altered.\n\n    :param hash_value: A precomputed hash to sign (ignores message).\n    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with\n    :param hash_method: the hash method used on the message. Use 'MD5', 'SHA-1',\n        'SHA-224', SHA-256', 'SHA-384' or 'SHA-512'.\n    :return: a message signature block.\n    :raise OverflowError: if the private key is too small to contain the\n        requested hash.\n\n    \"\"\"\n\n    # Get the ASN1 code for this hash method\n    if hash_method not in HASH_ASN1:\n        raise ValueError(\"Invalid hash method: %s\" % hash_method)\n    asn1code = HASH_ASN1[hash_method]\n\n    # Encrypt the hash with the private key\n    cleartext = asn1code + hash_value\n    keylength = common.byte_size(priv_key.n)\n    padded = _pad_for_signing(cleartext, keylength)\n\n    payload = transform.bytes2int(padded)\n    encrypted = priv_key.blinded_decrypt(payload)\n    block = transform.int2bytes(encrypted, keylength)\n\n    return block\n\n\ndef sign(message: bytes, priv_key: key.PrivateKey, hash_method: str) -> bytes:\n    \"\"\"Signs the message with the private key.\n\n    Hashes the message, then signs the hash with the given key. This is known\n    as a \"detached signature\", because the message itself isn't altered.\n\n    :param message: the message to sign. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with\n    :param hash_method: the hash method used on the message. Use 'MD5', 'SHA-1',\n        'SHA-224', SHA-256', 'SHA-384' or 'SHA-512'.\n    :return: a message signature block.\n    :raise OverflowError: if the private key is too small to contain the\n        requested hash.\n\n    \"\"\"\n\n    msg_hash = compute_hash(message, hash_method)\n    return sign_hash(msg_hash, priv_key, hash_method)\n\n\ndef verify(message: bytes, signature: bytes, pub_key: key.PublicKey) -> str:\n    \"\"\"Verifies that the signature matches the message.\n\n    The hash method is detected automatically from the signature.\n\n    :param message: the signed message. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param signature: the signature block, as created with :py:func:`rsa.sign`.\n    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.\n    :raise VerificationError: when the signature doesn't match the message.\n    :returns: the name of the used hash.\n\n    \"\"\"\n\n    keylength = common.byte_size(pub_key.n)\n    if len(signature) != keylength:\n        raise VerificationError(\"Verification failed\")\n    \n    encrypted = transform.bytes2int(signature)\n    decrypted = core.encrypt_int(encrypted, pub_key.e, pub_key.n)\n    clearsig = transform.int2bytes(decrypted, keylength)\n\n    # Get the hash method\n    method_name = _find_method_hash(clearsig)\n    message_hash = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash\n    cleartext = HASH_ASN1[method_name] + message_hash\n    expected = _pad_for_signing(cleartext, keylength)\n\n    # Compare with the signed one\n    if expected != clearsig:\n        raise VerificationError(\"Verification failed\")\n\n    return method_name\n\n\ndef find_signature_hash(signature: bytes, pub_key: key.PublicKey) -> str:\n    \"\"\"Returns the hash name detected from the signature.\n\n    If you also want to verify the message, use :py:func:`rsa.verify()` instead.\n    It also returns the name of the used hash.\n\n    :param signature: the signature block, as created with :py:func:`rsa.sign`.\n    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.\n    :returns: the name of the used hash.\n    \"\"\"\n\n    keylength = common.byte_size(pub_key.n)\n    encrypted = transform.bytes2int(signature)\n    decrypted = core.decrypt_int(encrypted, pub_key.e, pub_key.n)\n    clearsig = transform.int2bytes(decrypted, keylength)\n\n    return _find_method_hash(clearsig)\n\n\ndef yield_fixedblocks(infile: typing.BinaryIO, blocksize: int) -> typing.Iterator[bytes]:\n    \"\"\"Generator, yields each block of ``blocksize`` bytes in the input file.\n\n    :param infile: file to read and separate in blocks.\n    :param blocksize: block size in bytes.\n    :returns: a generator that yields the contents of each block\n    \"\"\"\n\n    while True:\n        block = infile.read(blocksize)\n\n        read_bytes = len(block)\n        if read_bytes == 0:\n            break\n\n        yield block\n\n        if read_bytes < blocksize:\n            break\n\n\ndef compute_hash(message: typing.Union[bytes, typing.BinaryIO], method_name: str) -> bytes:\n    \"\"\"Returns the message digest.\n\n    :param message: the signed message. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param method_name: the hash method, must be a key of\n        :py:const:`rsa.pkcs1.HASH_METHODS`.\n\n    \"\"\"\n\n    if method_name not in HASH_METHODS:\n        raise ValueError(\"Invalid hash method: %s\" % method_name)\n\n    method = HASH_METHODS[method_name]\n    hasher = method()\n\n    if isinstance(message, bytes):\n        hasher.update(message)\n    else:\n        assert hasattr(message, \"read\") and hasattr(message.read, \"__call__\")\n        # read as 1K blocks\n        for block in yield_fixedblocks(message, 1024):\n            hasher.update(block)\n\n    return hasher.digest()\n\n\ndef _find_method_hash(clearsig: bytes) -> str:\n    \"\"\"Finds the hash method.\n\n    :param clearsig: full padded ASN1 and hash.\n    :return: the used hash method.\n    :raise VerificationFailed: when the hash method cannot be found\n    \"\"\"\n\n    for (hashname, asn1code) in HASH_ASN1.items():\n        if asn1code in clearsig:\n            return hashname\n\n    raise VerificationError(\"Verification failed\")\n\n\n__all__ = [\n    \"encrypt\",\n    \"decrypt\",\n    \"sign\",\n    \"verify\",\n    \"DecryptionError\",\n    \"VerificationError\",\n    \"CryptoError\",\n]\n\nif __name__ == \"__main__\":\n    print(\"Running doctests 1000x or until failure\")\n    import doctest\n\n    for count in range(1000):\n        (failures, tests) = doctest.testmod()\n        if failures:\n            break\n\n        if count % 100 == 0 and count:\n            print(\"%i times\" % count)\n\n    print(\"Doctests done\")\n", "doc/conf.py": "# Python-RSA documentation build configuration file, created by\n# sphinx-quickstart on Sat Jul 30 23:11:07 2011.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# import sys\n# import os\nimport rsa\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',\n              'sphinx.ext.coverage']\n\n# I would like to add 'sphinx.ext.viewcode', but it causes a UnicodeDecodeError\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\nsource_encoding = 'utf-8'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = 'Python-RSA'\ncopyright = '2011-2019, Sybren A. St\u00fcvel'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = rsa.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = rsa.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\nlanguage = 'en'\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'sphinxdoc'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'Python-RSAdoc'\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# The paper size ('letter' or 'a4').\n# latex_paper_size = 'letter'\n\n# The font size ('10pt', '11pt' or '12pt').\n# latex_font_size = '10pt'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    ('index', 'Python-RSA.tex', 'Python-RSA Documentation',\n     'Sybren A. St\u00fcvel', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Additional stuff for the LaTeX preamble.\n# latex_preamble = ''\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'python-rsa', 'Python-RSA Documentation',\n     ['Sybren A. St\u00fcvel'], 1)\n]\n\ntodo_include_todos = True\n", "tests/test_integers.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Tests integer operations.\"\"\"\n\nimport unittest\n\nimport rsa\nimport rsa.core\n\n\nclass IntegerTest(unittest.TestCase):\n    def setUp(self):\n        (self.pub, self.priv) = rsa.newkeys(64)\n\n    def test_enc_dec(self):\n        message = 42\n        print(\"\\n\\tMessage:   %d\" % message)\n\n        encrypted = rsa.core.encrypt_int(message, self.pub.e, self.pub.n)\n        print(\"\\tEncrypted: %d\" % encrypted)\n\n        decrypted = rsa.core.decrypt_int(encrypted, self.priv.d, self.pub.n)\n        print(\"\\tDecrypted: %d\" % decrypted)\n\n        self.assertEqual(message, decrypted)\n\n    def test_sign_verify(self):\n        message = 42\n\n        signed = rsa.core.encrypt_int(message, self.priv.d, self.pub.n)\n        print(\"\\n\\tSigned:    %d\" % signed)\n\n        verified = rsa.core.decrypt_int(signed, self.pub.e, self.pub.n)\n        print(\"\\tVerified:  %d\" % verified)\n\n        self.assertEqual(message, verified)\n\n    def test_extreme_values(self):\n        # message < 0\n        message = -1\n        print(\"\\n\\tMessage:   %d\" % message)\n\n        with self.assertRaises(ValueError):\n            rsa.core.encrypt_int(message, self.pub.e, self.pub.n)\n\n        # message == 0\n        message = 0\n        print(\"\\n\\tMessage:   %d\" % message)\n\n        encrypted = rsa.core.encrypt_int(message, self.pub.e, self.pub.n)\n        print(\"\\tEncrypted: %d\" % encrypted)\n\n        decrypted = rsa.core.decrypt_int(encrypted, self.priv.d, self.pub.n)\n        print(\"\\tDecrypted: %d\" % decrypted)\n\n        self.assertEqual(message, decrypted)\n\n        # message >= n\n        message = self.pub.n\n        print(\"\\n\\tMessage:   %d\" % message)\n\n        with self.assertRaises(OverflowError):\n            rsa.core.encrypt_int(message, self.pub.e, self.pub.n)\n\n", "tests/test_prime.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Tests prime functions.\"\"\"\n\nimport unittest\n\nimport rsa.prime\nimport rsa.randnum\n\n\nclass PrimeTest(unittest.TestCase):\n    def test_is_prime(self):\n        \"\"\"Test some common primes.\"\"\"\n\n        # Test some trivial numbers\n        self.assertFalse(rsa.prime.is_prime(-1))\n        self.assertFalse(rsa.prime.is_prime(0))\n        self.assertFalse(rsa.prime.is_prime(1))\n        self.assertTrue(rsa.prime.is_prime(2))\n        self.assertFalse(rsa.prime.is_prime(42))\n        self.assertTrue(rsa.prime.is_prime(41))\n\n        # Test some slightly larger numbers\n        self.assertEqual(\n            [907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],\n            [x for x in range(901, 1000) if rsa.prime.is_prime(x)],\n        )\n\n        # Test around the 50th millionth known prime.\n        self.assertTrue(rsa.prime.is_prime(982451653))\n        self.assertFalse(rsa.prime.is_prime(982451653 * 961748941))\n\n    def test_miller_rabin_primality_testing(self):\n        \"\"\"Uses monkeypatching to ensure certain random numbers.\n\n        This allows us to predict/control the code path.\n        \"\"\"\n\n        randints = []\n\n        def fake_randint(maxvalue):\n            return randints.pop(0)\n\n        orig_randint = rsa.randnum.randint\n        rsa.randnum.randint = fake_randint\n        try:\n            # 'n is composite'\n            randints.append(2630484832)  # causes the 'n is composite' case with n=3784949785\n            self.assertEqual(False, rsa.prime.miller_rabin_primality_testing(2787998641, 7))\n            self.assertEqual([], randints)\n\n            # 'Exit inner loop and continue with next witness'\n            randints.extend(\n                [\n                    2119139098,  # causes 'Exit inner loop and continue with next witness'\n                    # the next witnesses for the above case:\n                    3051067716,\n                    3603501763,\n                    3230895847,\n                    3687808133,\n                    3760099987,\n                    4026931495,\n                    3022471882,\n                ]\n            )\n            self.assertEqual(\n                True,\n                rsa.prime.miller_rabin_primality_testing(2211417913, len(randints)),\n            )\n            self.assertEqual([], randints)\n        finally:\n            rsa.randnum.randint = orig_randint\n\n    def test_mersenne_primes(self):\n        \"\"\"Tests first known Mersenne primes.\n\n        Mersenne primes are prime numbers that can be written in the form\n        `Mn = 2**n - 1` for some integer `n`. For the list of known Mersenne\n        primes, see:\n        https://en.wikipedia.org/wiki/Mersenne_prime#List_of_known_Mersenne_primes\n        \"\"\"\n\n        # List of known Mersenne exponents.\n        known_mersenne_exponents = [\n            2,\n            3,\n            5,\n            7,\n            13,\n            17,\n            19,\n            31,\n            61,\n            89,\n            107,\n            127,\n            521,\n            607,\n            1279,\n            2203,\n            2281,\n            4423,\n        ]\n\n        # Test Mersenne primes.\n        for exp in known_mersenne_exponents:\n            self.assertTrue(rsa.prime.is_prime(2 ** exp - 1))\n\n    def test_get_primality_testing_rounds(self):\n        \"\"\"Test round calculation for primality testing.\"\"\"\n\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 63), 10)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 127), 10)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 255), 10)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 511), 7)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 767), 7)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 1023), 4)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 1279), 4)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 1535), 3)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 2047), 3)\n        self.assertEqual(rsa.prime.get_primality_testing_rounds(1 << 4095), 3)\n", "tests/test_pkcs1.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Tests string operations.\"\"\"\n\nimport struct\nimport sys\nimport unittest\n\nimport rsa\nfrom rsa import pkcs1\n\n\nclass BinaryTest(unittest.TestCase):\n    def setUp(self):\n        (self.pub, self.priv) = rsa.newkeys(256)\n\n    def test_enc_dec(self):\n        message = struct.pack(\">IIII\", 0, 0, 0, 1)\n        print(\"\\n\\tMessage:   %r\" % message)\n\n        encrypted = pkcs1.encrypt(message, self.pub)\n        print(\"\\tEncrypted: %r\" % encrypted)\n\n        decrypted = pkcs1.decrypt(encrypted, self.priv)\n        print(\"\\tDecrypted: %r\" % decrypted)\n\n        self.assertEqual(message, decrypted)\n\n    def test_decoding_failure(self):\n        message = struct.pack(\">IIII\", 0, 0, 0, 1)\n        encrypted = pkcs1.encrypt(message, self.pub)\n\n        # Alter the encrypted stream\n        a = encrypted[5]\n        self.assertIsInstance(a, int)\n\n        altered_a = (a + 1) % 256\n        encrypted = encrypted[:5] + bytes([altered_a]) + encrypted[6:]\n\n        self.assertRaises(pkcs1.DecryptionError, pkcs1.decrypt, encrypted, self.priv)\n\n    def test_randomness(self):\n        \"\"\"Encrypting the same message twice should result in different\n        cryptos.\n        \"\"\"\n\n        message = struct.pack(\">IIII\", 0, 0, 0, 1)\n        encrypted1 = pkcs1.encrypt(message, self.pub)\n        encrypted2 = pkcs1.encrypt(message, self.pub)\n\n        self.assertNotEqual(encrypted1, encrypted2)\n\n\nclass MultiprimeBinaryTest(unittest.TestCase):\n    def setUp(self):\n        (self.pub, self.priv) = rsa.newkeys(256, nprimes=3)\n\n    def test_multiprime_enc_dec(self):\n        message = struct.pack(\">IIII\", 0, 0, 0, 1)\n        print(\"\\n\\tMessage:   %r\" % message)\n\n        encrypted = pkcs1.encrypt(message, self.pub)\n        print(\"\\tEncrypted: %r\" % encrypted)\n\n        decrypted = pkcs1.decrypt(encrypted, self.priv)\n        print(\"\\tDecrypted: %r\" % decrypted)\n\n        self.assertEqual(message, decrypted)\n\n\nclass ExtraZeroesTest(unittest.TestCase):\n    def setUp(self):\n        # Key, cyphertext, and plaintext taken from https://github.com/sybrenstuvel/python-rsa/issues/146\n        self.private_key = rsa.PrivateKey.load_pkcs1(\n            \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEowIBAAKCAQEAs1EKK81M5kTFtZSuUFnhKy8FS2WNXaWVmi/fGHG4CLw98+Yo\\n0nkuUarVwSS0O9pFPcpc3kvPKOe9Tv+6DLS3Qru21aATy2PRqjqJ4CYn71OYtSwM\\n/ZfSCKvrjXybzgu+sBmobdtYm+sppbdL+GEHXGd8gdQw8DDCZSR6+dPJFAzLZTCd\\nB+Ctwe/RXPF+ewVdfaOGjkZIzDoYDw7n+OHnsYCYozkbTOcWHpjVevipR+IBpGPi\\n1rvKgFnlcG6d/tj0hWRl/6cS7RqhjoiNEtxqoJzpXs/Kg8xbCxXbCchkf11STA8u\\ndiCjQWuWI8rcDwl69XMmHJjIQAqhKvOOQ8rYTQIDAQABAoIBABpQLQ7qbHtp4h1Y\\nORAfcFRW7Q74UvtH/iEHH1TF8zyM6wZsYtcn4y0mxYE3Mp+J0xlTJbeVJkwZXYVH\\nL3UH29CWHSlR+TWiazTwrCTRVJDhEoqbcTiRW8fb+o/jljVxMcVDrpyYUHNo2c6w\\njBxhmKPtp66hhaDpds1Cwi0A8APZ8Z2W6kya/L/hRBzMgCz7Bon1nYBMak5PQEwV\\nF0dF7Wy4vIjvCzO6DSqA415DvJDzUAUucgFudbANNXo4HJwNRnBpymYIh8mHdmNJ\\n/MQ0YLSqUWvOB57dh7oWQwe3UsJ37ZUorTugvxh3NJ7Tt5ZqbCQBEECb9ND63gxo\\n/a3YR/0CgYEA7BJc834xCi/0YmO5suBinWOQAF7IiRPU+3G9TdhWEkSYquupg9e6\\nK9lC5k0iP+t6I69NYF7+6mvXDTmv6Z01o6oV50oXaHeAk74O3UqNCbLe9tybZ/+F\\ndkYlwuGSNttMQBzjCiVy0+y0+Wm3rRnFIsAtd0RlZ24aN3bFTWJINIsCgYEAwnQq\\nvNmJe9SwtnH5c/yCqPhKv1cF/4jdQZSGI6/p3KYNxlQzkHZ/6uvrU5V27ov6YbX8\\nvKlKfO91oJFQxUD6lpTdgAStI3GMiJBJIZNpyZ9EWNSvwUj28H34cySpbZz3s4Xd\\nhiJBShgy+fKURvBQwtWmQHZJ3EGrcOI7PcwiyYcCgYEAlql5jSUCY0ALtidzQogW\\nJ+B87N+RGHsBuJ/0cxQYinwg+ySAAVbSyF1WZujfbO/5+YBN362A/1dn3lbswCnH\\nK/bHF9+fZNqvwprPnceQj5oK1n4g6JSZNsy6GNAhosT+uwQ0misgR8SQE4W25dDG\\nkdEYsz+BgCsyrCcu8J5C+tUCgYAFVPQbC4f2ikVyKzvgz0qx4WUDTBqRACq48p6e\\n+eLatv7nskVbr7QgN+nS9+Uz80ihR0Ev1yCAvnwmM/XYAskcOea87OPmdeWZlQM8\\nVXNwINrZ6LMNBLgorfuTBK1UoRo1pPUHCYdqxbEYI2unak18mikd2WB7Fp3h0YI4\\nVpGZnwKBgBxkAYnZv+jGI4MyEKdsQgxvROXXYOJZkWzsKuKxVkVpYP2V4nR2YMOJ\\nViJQ8FUEnPq35cMDlUk4SnoqrrHIJNOvcJSCqM+bWHAioAsfByLbUPM8sm3CDdIk\\nXVJl32HuKYPJOMIWfc7hIfxLRHnCN+coz2M6tgqMDs0E/OfjuqVZ\\n-----END RSA PRIVATE KEY-----\",\n            format=\"PEM\",\n        )\n        self.cyphertext = bytes.fromhex(\n            \"4501b4d669e01b9ef2dc800aa1b06d49196f5a09fe8fbcd037323c60eaf027bfb98432be4e4a26c567ffec718bcbea977dd26812fa071c33808b4d5ebb742d9879806094b6fbeea63d25ea3141733b60e31c6912106e1b758a7fe0014f075193faa8b4622bfd5d3013f0a32190a95de61a3604711bc62945f95a6522bd4dfed0a994ef185b28c281f7b5e4c8ed41176d12d9fc1b837e6a0111d0132d08a6d6f0580de0c9eed8ed105531799482d1e466c68c23b0c222af7fc12ac279bc4ff57e7b4586d209371b38c4c1035edd418dc5f960441cb21ea2bedbfea86de0d7861e81021b650a1de51002c315f1e7c12debe4dcebf790caaa54a2f26b149cf9e77d\"\n        )\n        self.plaintext = bytes.fromhex(\"54657374\")\n\n    def test_unmodified(self):\n        message = rsa.decrypt(self.cyphertext, self.private_key)\n        self.assertEqual(message, self.plaintext)\n\n    def test_prepend_zeroes(self):\n        cyphertext = bytes.fromhex(\"0000\") + self.cyphertext\n        with self.assertRaises(rsa.DecryptionError):\n            rsa.decrypt(cyphertext, self.private_key)\n\n    def test_append_zeroes(self):\n        cyphertext = self.cyphertext + bytes.fromhex(\"0000\")\n        with self.assertRaises(rsa.DecryptionError):\n            rsa.decrypt(cyphertext, self.private_key)\n\n\nclass SignatureTest(unittest.TestCase):\n    def setUp(self):\n        (self.pub, self.priv) = rsa.newkeys(512)\n\n    def test_sign_verify(self):\n        \"\"\"Test happy flow of sign and verify\"\"\"\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA-256\")\n        self.assertEqual(\"SHA-256\", pkcs1.verify(message, signature, self.pub))\n\n    def test_sign_verify_sha3(self):\n        \"\"\"Test happy flow of sign and verify with SHA3-256\"\"\"\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA3-256\")\n        self.assertEqual(\"SHA3-256\", pkcs1.verify(message, signature, self.pub))\n\n    def test_find_signature_hash(self):\n        \"\"\"Test happy flow of sign and find_signature_hash\"\"\"\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA-256\")\n\n        self.assertEqual(\"SHA-256\", pkcs1.find_signature_hash(signature, self.pub))\n\n    def test_alter_message(self):\n        \"\"\"Altering the message should let the verification fail.\"\"\"\n\n        signature = pkcs1.sign(b\"je moeder\", self.priv, \"SHA-256\")\n        self.assertRaises(\n            pkcs1.VerificationError, pkcs1.verify, b\"mijn moeder\", signature, self.pub\n        )\n\n    def test_sign_different_key(self):\n        \"\"\"Signing with another key should let the verification fail.\"\"\"\n\n        (otherpub, _) = rsa.newkeys(512)\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA-256\")\n        self.assertRaises(pkcs1.VerificationError, pkcs1.verify, message, signature, otherpub)\n\n    def test_multiple_signings(self):\n        \"\"\"Signing the same message twice should return the same signatures.\"\"\"\n\n        message = struct.pack(\">IIII\", 0, 0, 0, 1)\n        signature1 = pkcs1.sign(message, self.priv, \"SHA-1\")\n        signature2 = pkcs1.sign(message, self.priv, \"SHA-1\")\n\n        self.assertEqual(signature1, signature2)\n\n    def test_split_hash_sign(self):\n        \"\"\"Hashing and then signing should match with directly signing the message.\"\"\"\n\n        message = b\"je moeder\"\n        msg_hash = pkcs1.compute_hash(message, \"SHA-256\")\n        signature1 = pkcs1.sign_hash(msg_hash, self.priv, \"SHA-256\")\n\n        # Calculate the signature using the unified method\n        signature2 = pkcs1.sign(message, self.priv, \"SHA-256\")\n\n        self.assertEqual(signature1, signature2)\n\n    def test_hash_sign_verify(self):\n        \"\"\"Test happy flow of hash, sign, and verify\"\"\"\n\n        message = b\"je moeder\"\n        msg_hash = pkcs1.compute_hash(message, \"SHA-224\")\n        signature = pkcs1.sign_hash(msg_hash, self.priv, \"SHA-224\")\n\n        self.assertTrue(pkcs1.verify(message, signature, self.pub))\n\n    def test_prepend_zeroes(self):\n        \"\"\"Prepending the signature with zeroes should be detected.\"\"\"\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA-256\")\n        signature = bytes.fromhex(\"0000\") + signature\n        with self.assertRaises(rsa.VerificationError):\n            pkcs1.verify(message, signature, self.pub)\n\n    def test_apppend_zeroes(self):\n        \"\"\"Apppending the signature with zeroes should be detected.\"\"\"\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA-256\")\n        signature = signature + bytes.fromhex(\"0000\")\n        with self.assertRaises(rsa.VerificationError):\n            pkcs1.verify(message, signature, self.pub)\n\n\nclass MultiprimeSignatureTest(unittest.TestCase):\n    def setUp(self):\n        (self.pub, self.priv) = rsa.newkeys(512, nprimes=3)\n\n    def test_multiprime_sign_verify(self):\n        \"\"\"Test happy flow of sign and verify\"\"\"\n\n        message = b\"je moeder\"\n        signature = pkcs1.sign(message, self.priv, \"SHA-256\")\n        self.assertEqual(\"SHA-256\", pkcs1.verify(message, signature, self.pub))\n\n\nclass PaddingSizeTest(unittest.TestCase):\n    def test_too_little_padding(self):\n        \"\"\"Padding less than 8 bytes should be rejected.\"\"\"\n\n        # Construct key that will be small enough to need only 7 bytes of padding.\n        # This key is 168 bit long, and was generated with rsa.newkeys(nbits=168).\n        self.private_key = rsa.PrivateKey.load_pkcs1(\n            b\"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMHkCAQACFgCIGbbNSkIRLtprxka9NgOf5UxgxCMCAwEAAQIVQqymO0gHubdEVS68\nCdCiWmOJxVfRAgwBQM+e1JJwMKmxSF0CCmya6CFxO8Evdn8CDACMM3AlVC4FhlN8\n3QIKC9cjoam/swMirwIMAR7Br9tdouoH7jAE\n-----END RSA PRIVATE KEY-----\n        \"\"\"\n        )\n        self.public_key = rsa.PublicKey(n=self.private_key.n, e=self.private_key.e)\n\n        cyphertext = self.encrypt_with_short_padding(b\"op je hoofd\")\n        with self.assertRaises(rsa.DecryptionError):\n            rsa.decrypt(cyphertext, self.private_key)\n\n    def encrypt_with_short_padding(self, message: bytes) -> bytes:\n        # This is a copy of rsa.pkcs1.encrypt() adjusted to use the wrong padding length.\n        keylength = rsa.common.byte_size(self.public_key.n)\n\n        # The word 'padding' has 7 letters, so is one byte short of a valid padding length.\n        padded = b\"\\x00\\x02padding\\x00\" + message\n\n        payload = rsa.transform.bytes2int(padded)\n        encrypted_value = rsa.core.encrypt_int(payload, self.public_key.e, self.public_key.n)\n        cyphertext = rsa.transform.int2bytes(encrypted_value, keylength)\n\n        return cyphertext\n", "tests/test_cli.py": "\"\"\"\nUnit tests for CLI entry points.\n\"\"\"\n\n\nimport functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager, redirect_stdout, redirect_stderr\n\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef captured_output() -> typing.Generator:\n    \"\"\"Captures output to stdout and stderr\"\"\"\n\n    # According to mypy, we're not supposed to change buf_out.buffer.\n    # However, this is just a test, and it works, hence the 'type: ignore'.\n    buf_out = io.StringIO()\n    buf_out.buffer = io.BytesIO()  # type: ignore\n\n    buf_err = io.StringIO()\n    buf_err.buffer = io.BytesIO()  # type: ignore\n\n    with redirect_stdout(buf_out), redirect_stderr(buf_err):\n        yield buf_out, buf_err\n\n\ndef get_bytes_out(buf) -> bytes:\n    return buf.buffer.getvalue()\n\n\n@contextmanager\ndef cli_args(*new_argv):\n    \"\"\"Updates sys.argv[1:] for a single test.\"\"\"\n\n    old_args = sys.argv[:]\n    sys.argv[1:] = [str(arg) for arg in new_argv]\n\n    try:\n        yield\n    finally:\n        sys.argv[1:] = old_args\n\n\ndef remove_if_exists(fname):\n    \"\"\"Removes a file if it exists.\"\"\"\n\n    if os.path.exists(fname):\n        os.unlink(fname)\n\n\ndef cleanup_files(*filenames):\n    \"\"\"Makes sure the files don't exist when the test runs, and deletes them afterward.\"\"\"\n\n    def remove():\n        for fname in filenames:\n            remove_if_exists(fname)\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            remove()\n            try:\n                return func(*args, **kwargs)\n            finally:\n                remove()\n\n        return wrapper\n\n    return decorator\n\n\nclass AbstractCliTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Ensure there is a key to use\n        cls.pub_key, cls.priv_key = rsa.newkeys(512)\n        cls.pub_fname = \"%s.pub\" % cls.__name__\n        cls.priv_fname = \"%s.key\" % cls.__name__\n\n        with open(cls.pub_fname, \"wb\") as outfile:\n            outfile.write(cls.pub_key.save_pkcs1())\n\n        with open(cls.priv_fname, \"wb\") as outfile:\n            outfile.write(cls.priv_key.save_pkcs1())\n\n    @classmethod\n    def tearDownClass(cls):\n        if hasattr(cls, \"pub_fname\"):\n            remove_if_exists(cls.pub_fname)\n        if hasattr(cls, \"priv_fname\"):\n            remove_if_exists(cls.priv_fname)\n\n    def assertExits(self, status_code, func, *args, **kwargs):\n        try:\n            func(*args, **kwargs)\n        except SystemExit as ex:\n            if status_code == ex.code:\n                return\n            self.fail(\n                \"SystemExit() raised by %r, but exited with code %r, expected %r\"\n                % (func, ex.code, status_code)\n            )\n        else:\n            self.fail(\"SystemExit() not raised by %r\" % func)\n\n\nclass KeygenTest(AbstractCliTest):\n    def test_keygen_no_args(self):\n        with captured_output(), cli_args():\n            self.assertExits(1, rsa.cli.keygen)\n\n    def test_keygen_priv_stdout(self):\n        with captured_output() as (out, err):\n            with cli_args(128):\n                rsa.cli.keygen()\n\n        lines = get_bytes_out(out).splitlines()\n        self.assertEqual(b\"-----BEGIN RSA PRIVATE KEY-----\", lines[0])\n        self.assertEqual(b\"-----END RSA PRIVATE KEY-----\", lines[-1])\n\n        # The key size should be shown on stderr\n        self.assertTrue(\"128-bit key\" in err.getvalue())\n\n    @cleanup_files(\"test_cli_privkey_out.pem\")\n    def test_keygen_priv_out_pem(self):\n        with captured_output() as (out, err):\n            with cli_args(\"--out=test_cli_privkey_out.pem\", \"--form=PEM\", 128):\n                rsa.cli.keygen()\n\n        # The key size should be shown on stderr\n        self.assertTrue(\"128-bit key\" in err.getvalue())\n\n        # The output file should be shown on stderr\n        self.assertTrue(\"test_cli_privkey_out.pem\" in err.getvalue())\n\n        # If we can load the file as PEM, it's good enough.\n        with open(\"test_cli_privkey_out.pem\", \"rb\") as pemfile:\n            rsa.PrivateKey.load_pkcs1(pemfile.read())\n\n    @cleanup_files(\"test_cli_privkey_out.der\")\n    def test_keygen_priv_out_der(self):\n        with captured_output() as (out, err):\n            with cli_args(\"--out=test_cli_privkey_out.der\", \"--form=DER\", 128):\n                rsa.cli.keygen()\n\n        # The key size should be shown on stderr\n        self.assertTrue(\"128-bit key\" in err.getvalue())\n\n        # The output file should be shown on stderr\n        self.assertTrue(\"test_cli_privkey_out.der\" in err.getvalue())\n\n        # If we can load the file as der, it's good enough.\n        with open(\"test_cli_privkey_out.der\", \"rb\") as derfile:\n            rsa.PrivateKey.load_pkcs1(derfile.read(), format=\"DER\")\n\n    @cleanup_files(\"test_cli_privkey_out.pem\", \"test_cli_pubkey_out.pem\")\n    def test_keygen_pub_out_pem(self):\n        with captured_output() as (out, err):\n            with cli_args(\n                \"--out=test_cli_privkey_out.pem\",\n                \"--pubout=test_cli_pubkey_out.pem\",\n                \"--form=PEM\",\n                256,\n            ):\n                rsa.cli.keygen()\n\n        # The key size should be shown on stderr\n        self.assertTrue(\"256-bit key\" in err.getvalue())\n\n        # The output files should be shown on stderr\n        self.assertTrue(\"test_cli_privkey_out.pem\" in err.getvalue())\n        self.assertTrue(\"test_cli_pubkey_out.pem\" in err.getvalue())\n\n        # If we can load the file as PEM, it's good enough.\n        with open(\"test_cli_pubkey_out.pem\", \"rb\") as pemfile:\n            rsa.PublicKey.load_pkcs1(pemfile.read())\n\n\nclass EncryptDecryptTest(AbstractCliTest):\n    def test_empty_decrypt(self):\n        with captured_output(), cli_args():\n            self.assertExits(1, rsa.cli.decrypt)\n\n    def test_empty_encrypt(self):\n        with captured_output(), cli_args():\n            self.assertExits(1, rsa.cli.encrypt)\n\n    @cleanup_files(\"encrypted.txt\", \"cleartext.txt\")\n    def test_encrypt_decrypt(self):\n        with open(\"cleartext.txt\", \"wb\") as outfile:\n            outfile.write(b\"Hello cleartext RSA users!\")\n\n        with cli_args(\"-i\", \"cleartext.txt\", \"--out=encrypted.txt\", self.pub_fname):\n            with captured_output():\n                rsa.cli.encrypt()\n\n        with cli_args(\"-i\", \"encrypted.txt\", self.priv_fname):\n            with captured_output() as (out, err):\n                rsa.cli.decrypt()\n\n        # We should have the original cleartext on stdout now.\n        output = get_bytes_out(out)\n        self.assertEqual(b\"Hello cleartext RSA users!\", output)\n\n    @cleanup_files(\"encrypted.txt\", \"cleartext.txt\")\n    def test_encrypt_decrypt_unhappy(self):\n        with open(\"cleartext.txt\", \"wb\") as outfile:\n            outfile.write(b\"Hello cleartext RSA users!\")\n\n        with cli_args(\"-i\", \"cleartext.txt\", \"--out=encrypted.txt\", self.pub_fname):\n            with captured_output():\n                rsa.cli.encrypt()\n\n        # Change a few bytes in the encrypted stream.\n        with open(\"encrypted.txt\", \"r+b\") as encfile:\n            encfile.seek(40)\n            encfile.write(b\"hahaha\")\n\n        with cli_args(\"-i\", \"encrypted.txt\", self.priv_fname):\n            with captured_output() as (out, err):\n                self.assertRaises(rsa.DecryptionError, rsa.cli.decrypt)\n\n\nclass SignVerifyTest(AbstractCliTest):\n    def test_empty_verify(self):\n        with captured_output(), cli_args():\n            self.assertExits(1, rsa.cli.verify)\n\n    def test_empty_sign(self):\n        with captured_output(), cli_args():\n            self.assertExits(1, rsa.cli.sign)\n\n    @cleanup_files(\"signature.txt\", \"cleartext.txt\")\n    def test_sign_verify(self):\n        with open(\"cleartext.txt\", \"wb\") as outfile:\n            outfile.write(b\"Hello RSA users!\")\n\n        with cli_args(\"-i\", \"cleartext.txt\", \"--out=signature.txt\", self.priv_fname, \"SHA-256\"):\n            with captured_output():\n                rsa.cli.sign()\n\n        with cli_args(\"-i\", \"cleartext.txt\", self.pub_fname, \"signature.txt\"):\n            with captured_output() as (out, err):\n                rsa.cli.verify()\n\n        self.assertFalse(b\"Verification OK\" in get_bytes_out(out))\n\n    @cleanup_files(\"signature.txt\", \"cleartext.txt\")\n    def test_sign_verify_unhappy(self):\n        with open(\"cleartext.txt\", \"wb\") as outfile:\n            outfile.write(b\"Hello RSA users!\")\n\n        with cli_args(\"-i\", \"cleartext.txt\", \"--out=signature.txt\", self.priv_fname, \"SHA-256\"):\n            with captured_output():\n                rsa.cli.sign()\n\n        # Change a few bytes in the cleartext file.\n        with open(\"cleartext.txt\", \"r+b\") as encfile:\n            encfile.seek(6)\n            encfile.write(b\"DSA\")\n\n        with cli_args(\"-i\", \"cleartext.txt\", self.pub_fname, \"signature.txt\"):\n            with captured_output() as (out, err):\n                self.assertExits(\"Verification failed.\", rsa.cli.verify)\n\n\nclass PrivatePublicTest(AbstractCliTest):\n    \"\"\"Test CLI command to convert a private to a public key.\"\"\"\n\n    @cleanup_files(\"test_private_to_public.pem\")\n    def test_private_to_public(self):\n\n        with cli_args(\"-i\", self.priv_fname, \"-o\", \"test_private_to_public.pem\"):\n            with captured_output():\n                rsa.util.private_to_public()\n\n        # Check that the key is indeed valid.\n        with open(\"test_private_to_public.pem\", \"rb\") as pemfile:\n            key = rsa.PublicKey.load_pkcs1(pemfile.read())\n\n        self.assertEqual(self.priv_key.n, key.n)\n        self.assertEqual(self.priv_key.e, key.e)\n", "tests/test_mypy.py": "import pathlib\nimport sys\nimport unittest\n\nimport mypy.api\n\ntest_modules = [\"rsa\", \"tests\"]\n\n\nclass MypyRunnerTest(unittest.TestCase):\n    def test_run_mypy(self):\n        proj_root = pathlib.Path(__file__).parent.parent\n        args = [\n            \"--incremental\",\n            \"--ignore-missing-imports\",\n            f\"--python-version={sys.version_info.major}.{sys.version_info.minor}\",\n        ] + [str(proj_root / dirname) for dirname in test_modules]\n\n        result = mypy.api.run(args)\n\n        stdout, stderr, status = result\n\n        messages = []\n        if stderr:\n            messages.append(stderr)\n        if stdout:\n            messages.append(stdout)\n        if status:\n            messages.append(\"Mypy failed with status %d\" % status)\n        if messages and not all(\"Success\" in message for message in messages):\n            self.fail(\"\\n\".join([\"Mypy errors:\"] + messages))\n", "tests/test_pkcs1_v2.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Tests PKCS #1 version 2 functionality.\n\nMost of the mocked values come from the test vectors found at:\nhttp://www.itomorrowmag.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm\n\"\"\"\n\nimport unittest\n\nfrom rsa import pkcs1_v2\n\n\nclass MGFTest(unittest.TestCase):\n    def test_oaep_int_db_mask(self):\n        seed = (\n            b\"\\xaa\\xfd\\x12\\xf6\\x59\\xca\\xe6\\x34\\x89\\xb4\\x79\\xe5\\x07\\x6d\\xde\\xc2\" b\"\\xf0\\x6c\\xb5\\x8f\"\n        )\n        db = (\n            b\"\\xda\\x39\\xa3\\xee\\x5e\\x6b\\x4b\\x0d\\x32\\x55\\xbf\\xef\\x95\\x60\\x18\\x90\"\n            b\"\\xaf\\xd8\\x07\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n            b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n            b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n            b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n            b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xd4\\x36\\xe9\\x95\\x69\"\n            b\"\\xfd\\x32\\xa7\\xc8\\xa0\\x5b\\xbc\\x90\\xd3\\x2c\\x49\"\n        )\n        masked_db = (\n            b\"\\xdc\\xd8\\x7d\\x5c\\x68\\xf1\\xee\\xa8\\xf5\\x52\\x67\\xc3\\x1b\\x2e\\x8b\\xb4\"\n            b\"\\x25\\x1f\\x84\\xd7\\xe0\\xb2\\xc0\\x46\\x26\\xf5\\xaf\\xf9\\x3e\\xdc\\xfb\\x25\"\n            b\"\\xc9\\xc2\\xb3\\xff\\x8a\\xe1\\x0e\\x83\\x9a\\x2d\\xdb\\x4c\\xdc\\xfe\\x4f\\xf4\"\n            b\"\\x77\\x28\\xb4\\xa1\\xb7\\xc1\\x36\\x2b\\xaa\\xd2\\x9a\\xb4\\x8d\\x28\\x69\\xd5\"\n            b\"\\x02\\x41\\x21\\x43\\x58\\x11\\x59\\x1b\\xe3\\x92\\xf9\\x82\\xfb\\x3e\\x87\\xd0\"\n            b\"\\x95\\xae\\xb4\\x04\\x48\\xdb\\x97\\x2f\\x3a\\xc1\\x4f\\x7b\\xc2\\x75\\x19\\x52\"\n            b\"\\x81\\xce\\x32\\xd2\\xf1\\xb7\\x6d\\x4d\\x35\\x3e\\x2d\"\n        )\n\n        # dbMask = MGF(seed, length(DB))\n        db_mask = pkcs1_v2.mgf1(seed, length=len(db))\n        expected_db_mask = (\n            b\"\\x06\\xe1\\xde\\xb2\\x36\\x9a\\xa5\\xa5\\xc7\\x07\\xd8\\x2c\\x8e\\x4e\\x93\\x24\"\n            b\"\\x8a\\xc7\\x83\\xde\\xe0\\xb2\\xc0\\x46\\x26\\xf5\\xaf\\xf9\\x3e\\xdc\\xfb\\x25\"\n            b\"\\xc9\\xc2\\xb3\\xff\\x8a\\xe1\\x0e\\x83\\x9a\\x2d\\xdb\\x4c\\xdc\\xfe\\x4f\\xf4\"\n            b\"\\x77\\x28\\xb4\\xa1\\xb7\\xc1\\x36\\x2b\\xaa\\xd2\\x9a\\xb4\\x8d\\x28\\x69\\xd5\"\n            b\"\\x02\\x41\\x21\\x43\\x58\\x11\\x59\\x1b\\xe3\\x92\\xf9\\x82\\xfb\\x3e\\x87\\xd0\"\n            b\"\\x95\\xae\\xb4\\x04\\x48\\xdb\\x97\\x2f\\x3a\\xc1\\x4e\\xaf\\xf4\\x9c\\x8c\\x3b\"\n            b\"\\x7c\\xfc\\x95\\x1a\\x51\\xec\\xd1\\xdd\\xe6\\x12\\x64\"\n        )\n\n        self.assertEqual(db_mask, expected_db_mask)\n\n        # seedMask = MGF(maskedDB, length(seed))\n        seed_mask = pkcs1_v2.mgf1(masked_db, length=len(seed))\n        expected_seed_mask = (\n            b\"\\x41\\x87\\x0b\\x5a\\xb0\\x29\\xe6\\x57\\xd9\\x57\\x50\\xb5\\x4c\\x28\\x3c\\x08\" b\"\\x72\\x5d\\xbe\\xa9\"\n        )\n\n        self.assertEqual(seed_mask, expected_seed_mask)\n\n    def test_invalid_hasher(self):\n        \"\"\"Tests an invalid hasher generates an exception\"\"\"\n        with self.assertRaises(ValueError):\n            pkcs1_v2.mgf1(b\"\\x06\\xe1\\xde\\xb2\", length=8, hasher=\"SHA2\")\n\n    def test_invalid_length(self):\n        with self.assertRaises(OverflowError):\n            pkcs1_v2.mgf1(b\"\\x06\\xe1\\xde\\xb2\", length=2 ** 50)\n", "tests/test_transform.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nimport unittest\nfrom rsa.transform import int2bytes, bytes2int\n\n\nclass Test_int2bytes(unittest.TestCase):\n    def test_accuracy(self):\n        self.assertEqual(int2bytes(123456789), b\"\\x07[\\xcd\\x15\")\n\n    def test_codec_identity(self):\n        self.assertEqual(bytes2int(int2bytes(123456789, 128)), 123456789)\n\n    def test_chunk_size(self):\n        self.assertEqual(int2bytes(123456789, 6), b\"\\x00\\x00\\x07[\\xcd\\x15\")\n        self.assertEqual(int2bytes(123456789, 7), b\"\\x00\\x00\\x00\\x07[\\xcd\\x15\")\n\n    def test_zero(self):\n        self.assertEqual(int2bytes(0, 4), b\"\\x00\" * 4)\n        self.assertEqual(int2bytes(0, 7), b\"\\x00\" * 7)\n        self.assertEqual(int2bytes(0), b\"\\x00\")\n\n    def test_correctness_against_base_implementation(self):\n        # Slow test.\n        values = [\n            1 << 512,\n            1 << 8192,\n            1 << 77,\n        ]\n        for value in values:\n            self.assertEqual(bytes2int(int2bytes(value)), value, \"Boom %d\" % value)\n\n    def test_raises_OverflowError_when_chunk_size_is_insufficient(self):\n        self.assertRaises(OverflowError, int2bytes, 123456789, 3)\n        self.assertRaises(OverflowError, int2bytes, 299999999999, 4)\n\n    def test_raises_ValueError_when_negative_integer(self):\n        self.assertRaises(ValueError, int2bytes, -1)\n\n    def test_raises_TypeError_when_not_integer(self):\n        self.assertRaises(TypeError, int2bytes, None)\n", "tests/test_common.py": "#!/usr/bin/env python\n#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nimport unittest\nimport struct\nfrom rsa.common import byte_size, bit_size, inverse\n\n\nclass TestByteSize(unittest.TestCase):\n    def test_values(self):\n        self.assertEqual(byte_size(1 << 1023), 128)\n        self.assertEqual(byte_size((1 << 1024) - 1), 128)\n        self.assertEqual(byte_size(1 << 1024), 129)\n        self.assertEqual(byte_size(255), 1)\n        self.assertEqual(byte_size(256), 2)\n        self.assertEqual(byte_size(0xFFFF), 2)\n        self.assertEqual(byte_size(0xFFFFFF), 3)\n        self.assertEqual(byte_size(0xFFFFFFFF), 4)\n        self.assertEqual(byte_size(0xFFFFFFFFFF), 5)\n        self.assertEqual(byte_size(0xFFFFFFFFFFFF), 6)\n        self.assertEqual(byte_size(0xFFFFFFFFFFFFFF), 7)\n        self.assertEqual(byte_size(0xFFFFFFFFFFFFFFFF), 8)\n\n    def test_zero(self):\n        self.assertEqual(byte_size(0), 1)\n\n    def test_bad_type(self):\n        self.assertRaises(TypeError, byte_size, [])\n        self.assertRaises(TypeError, byte_size, ())\n        self.assertRaises(TypeError, byte_size, dict())\n        self.assertRaises(TypeError, byte_size, \"\")\n        self.assertRaises(TypeError, byte_size, None)\n\n\nclass TestBitSize(unittest.TestCase):\n    def test_zero(self):\n        self.assertEqual(bit_size(0), 0)\n\n    def test_values(self):\n        self.assertEqual(bit_size(1023), 10)\n        self.assertEqual(bit_size(1024), 11)\n        self.assertEqual(bit_size(1025), 11)\n        self.assertEqual(bit_size(1 << 1024), 1025)\n        self.assertEqual(bit_size((1 << 1024) + 1), 1025)\n        self.assertEqual(bit_size((1 << 1024) - 1), 1024)\n\n    def test_negative_values(self):\n        self.assertEqual(bit_size(-1023), 10)\n        self.assertEqual(bit_size(-1024), 11)\n        self.assertEqual(bit_size(-1025), 11)\n        self.assertEqual(bit_size(-1 << 1024), 1025)\n        self.assertEqual(bit_size(-((1 << 1024) + 1)), 1025)\n        self.assertEqual(bit_size(-((1 << 1024) - 1)), 1024)\n\n    def test_bad_type(self):\n        self.assertRaises(TypeError, bit_size, [])\n        self.assertRaises(TypeError, bit_size, ())\n        self.assertRaises(TypeError, bit_size, dict())\n        self.assertRaises(TypeError, bit_size, \"\")\n        self.assertRaises(TypeError, bit_size, None)\n        self.assertRaises(TypeError, bit_size, 0.0)\n\n\nclass TestInverse(unittest.TestCase):\n    def test_normal(self):\n        self.assertEqual(3, inverse(7, 4))\n        self.assertEqual(9, inverse(5, 11))\n\n    def test_not_relprime(self):\n        self.assertRaises(ValueError, inverse, 4, 8)\n        self.assertRaises(ValueError, inverse, 25, 5)\n", "tests/test_strings.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Tests string operations.\"\"\"\n\n\nimport unittest\n\nimport rsa\n\nunicode_string = \"Euro=\\u20ac ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\nclass StringTest(unittest.TestCase):\n    def setUp(self):\n        (self.pub, self.priv) = rsa.newkeys(384)\n\n    def test_enc_dec(self):\n        message = unicode_string.encode(\"utf-8\")\n        print(\"\\n\\tMessage:   %r\" % message)\n\n        encrypted = rsa.encrypt(message, self.pub)\n        print(\"\\tEncrypted: %r\" % encrypted)\n\n        decrypted = rsa.decrypt(encrypted, self.priv)\n        print(\"\\tDecrypted: %r\" % decrypted)\n\n        self.assertEqual(message, decrypted)\n", "tests/__init__.py": "", "tests/test_parallel.py": "\"\"\"Test for multiprocess prime generation.\"\"\"\n\nimport unittest\n\nimport rsa.prime\nimport rsa.parallel\nimport rsa.common\n\n\nclass ParallelTest(unittest.TestCase):\n    \"\"\"Tests for multiprocess prime generation.\"\"\"\n\n    def test_parallel_primegen(self):\n        p = rsa.parallel.getprime(1024, 3)\n\n        self.assertFalse(rsa.prime.is_prime(p - 1))\n        self.assertTrue(rsa.prime.is_prime(p))\n        self.assertFalse(rsa.prime.is_prime(p + 1))\n\n        self.assertEqual(1024, rsa.common.bit_size(p))\n", "tests/test_load_save_keys.py": "#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"Unittest for saving and loading keys.\"\"\"\n\nimport base64\nimport os.path\nimport pickle\nimport unittest\nimport warnings\nfrom unittest import mock\n\nimport rsa.key\n\nB64PRIV_DER = b\"MC4CAQACBQDeKYlRAgMBAAECBQDHn4npAgMA/icCAwDfxwIDANcXAgInbwIDAMZt\"\nPRIVATE_DER = base64.standard_b64decode(B64PRIV_DER)\n\nB64PUB_DER = b\"MAwCBQDeKYlRAgMBAAE=\"\nPUBLIC_DER = base64.standard_b64decode(B64PUB_DER)\n\nPRIVATE_PEM = (\n    b\"\"\"\\\n-----BEGIN CONFUSING STUFF-----\nCruft before the key\n\n-----BEGIN RSA PRIVATE KEY-----\nComment: something blah\n\n\"\"\"\n    + B64PRIV_DER\n    + b\"\"\"\n-----END RSA PRIVATE KEY-----\n\nStuff after the key\n-----END CONFUSING STUFF-----\n\"\"\"\n)\n\nCLEAN_PRIVATE_PEM = (\n    b\"\"\"\\\n-----BEGIN RSA PRIVATE KEY-----\n\"\"\"\n    + B64PRIV_DER\n    + b\"\"\"\n-----END RSA PRIVATE KEY-----\n\"\"\"\n)\n\nPUBLIC_PEM = (\n    b\"\"\"\\\n-----BEGIN CONFUSING STUFF-----\nCruft before the key\n\n-----BEGIN RSA PUBLIC KEY-----\nComment: something blah\n\n\"\"\"\n    + B64PUB_DER\n    + b\"\"\"\n-----END RSA PUBLIC KEY-----\n\nStuff after the key\n-----END CONFUSING STUFF-----\n\"\"\"\n)\n\nCLEAN_PUBLIC_PEM = (\n    b\"\"\"\\\n-----BEGIN RSA PUBLIC KEY-----\n\"\"\"\n    + B64PUB_DER\n    + b\"\"\"\n-----END RSA PUBLIC KEY-----\n\"\"\"\n)\n\n\nclass DerTest(unittest.TestCase):\n    \"\"\"Test saving and loading DER keys.\"\"\"\n\n    def test_load_private_key(self):\n        \"\"\"Test loading private DER keys.\"\"\"\n\n        key = rsa.key.PrivateKey.load_pkcs1(PRIVATE_DER, \"DER\")\n        expected = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        self.assertEqual(expected, key)\n        self.assertEqual(key.exp1, 55063)\n        self.assertEqual(key.exp2, 10095)\n        self.assertEqual(key.coef, 50797)\n\n    @mock.patch(\"pyasn1.codec.der.decoder.decode\")\n    def test_load_malformed_private_key(self, der_decode):\n        \"\"\"Test loading malformed private DER keys.\"\"\"\n\n        # Decode returns an invalid exp2 value.\n        der_decode.return_value = (\n            [0, 3727264081, 65537, 3349121513, 65063, 57287, 55063, 0, 50797],\n            0,\n        )\n\n        with warnings.catch_warnings(record=True) as w:\n            # Always print warnings\n            warnings.simplefilter(\"always\")\n\n            # Load 3 keys\n            for _ in range(3):\n                key = rsa.key.PrivateKey.load_pkcs1(PRIVATE_DER, \"DER\")\n\n            # Check that 3 warnings were generated.\n            self.assertEqual(3, len(w))\n\n            for warning in w:\n                self.assertTrue(issubclass(warning.category, UserWarning))\n                self.assertIn(\"malformed\", str(warning.message))\n\n        # Check that we are creating the key with correct values\n        self.assertEqual(key.exp1, 55063)\n        self.assertEqual(key.exp2, 10095)\n        self.assertEqual(key.coef, 50797)\n\n    def test_save_private_key(self):\n        \"\"\"Test saving private DER keys.\"\"\"\n\n        key = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n        der = key.save_pkcs1(\"DER\")\n\n        self.assertIsInstance(der, bytes)\n        self.assertEqual(PRIVATE_DER, der)\n\n    def test_load_public_key(self):\n        \"\"\"Test loading public DER keys.\"\"\"\n\n        key = rsa.key.PublicKey.load_pkcs1(PUBLIC_DER, \"DER\")\n        expected = rsa.key.PublicKey(3727264081, 65537)\n\n        self.assertEqual(expected, key)\n\n    def test_save_public_key(self):\n        \"\"\"Test saving public DER keys.\"\"\"\n\n        key = rsa.key.PublicKey(3727264081, 65537)\n        der = key.save_pkcs1(\"DER\")\n\n        self.assertIsInstance(der, bytes)\n        self.assertEqual(PUBLIC_DER, der)\n\n\nclass PemTest(unittest.TestCase):\n    \"\"\"Test saving and loading PEM keys.\"\"\"\n\n    def test_load_private_key(self):\n        \"\"\"Test loading private PEM files.\"\"\"\n\n        key = rsa.key.PrivateKey.load_pkcs1(PRIVATE_PEM, \"PEM\")\n        expected = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        self.assertEqual(expected, key)\n        self.assertEqual(key.exp1, 55063)\n        self.assertEqual(key.exp2, 10095)\n        self.assertEqual(key.coef, 50797)\n\n    def test_save_private_key(self):\n        \"\"\"Test saving private PEM files.\"\"\"\n\n        key = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n        pem = key.save_pkcs1(\"PEM\")\n\n        self.assertIsInstance(pem, bytes)\n        self.assertEqual(CLEAN_PRIVATE_PEM, pem)\n\n    def test_load_public_key(self):\n        \"\"\"Test loading public PEM files.\"\"\"\n\n        key = rsa.key.PublicKey.load_pkcs1(PUBLIC_PEM, \"PEM\")\n        expected = rsa.key.PublicKey(3727264081, 65537)\n\n        self.assertEqual(expected, key)\n\n    def test_save_public_key(self):\n        \"\"\"Test saving public PEM files.\"\"\"\n\n        key = rsa.key.PublicKey(3727264081, 65537)\n        pem = key.save_pkcs1(\"PEM\")\n\n        self.assertIsInstance(pem, bytes)\n        self.assertEqual(CLEAN_PUBLIC_PEM, pem)\n\n    def test_load_from_disk(self):\n        \"\"\"Test loading a PEM file from disk.\"\"\"\n\n        fname = os.path.join(os.path.dirname(__file__), \"private.pem\")\n        with open(fname, mode=\"rb\") as privatefile:\n            keydata = privatefile.read()\n        privkey = rsa.key.PrivateKey.load_pkcs1(keydata)\n\n        self.assertEqual(15945948582725241569, privkey.p)\n        self.assertEqual(14617195220284816877, privkey.q)\n\n\nMP_B64PRIV_DER = b\"MEoCAQACCDsGeWW1Om5xAgMBAAECBQDHn4npAgMA+nsCAwDHDQICcw0CAwCWDQICTjYCAwCZlQICaukCAioVAgMAgVMCAksjAgIq3g==\"\nMP_PRIVATE_DER = base64.standard_b64decode(MP_B64PRIV_DER)\n\nMP_B64PUB_DER = b\"MA8CCDsGeWW1Om5xAgMBAAE=\"\nMP_PUBLIC_DER = base64.standard_b64decode(MP_B64PUB_DER)\n\nMP_PRIVATE_PEM = (\n    b\"\"\"\\\n-----BEGIN CONFUSING STUFF-----\nCruft before the key\n\n-----BEGIN RSA PRIVATE KEY-----\nComment: something blah\n\n\"\"\"\n    + MP_B64PRIV_DER\n    + b\"\"\"\n-----END RSA PRIVATE KEY-----\n\nStuff after the key\n-----END CONFUSING STUFF-----\n\"\"\"\n)\n\nMP_CLEAN_PRIVATE_PEM = (\n    b\"\"\"\\\n-----BEGIN RSA PRIVATE KEY-----\n\"\"\"\n    + MP_B64PRIV_DER\n    + b\"\"\"\n-----END RSA PRIVATE KEY-----\n\"\"\"\n)\n\nMP_PUBLIC_PEM = (\n    b\"\"\"\\\n-----BEGIN CONFUSING STUFF-----\nCruft before the key\n\n-----BEGIN RSA PUBLIC KEY-----\nComment: something blah\n\n\"\"\"\n    + MP_B64PUB_DER\n    + b\"\"\"\n-----END RSA PUBLIC KEY-----\n\nStuff after the key\n-----END CONFUSING STUFF-----\n\"\"\"\n)\n\nMP_CLEAN_PUBLIC_PEM = (\n    b\"\"\"\\\n-----BEGIN RSA PUBLIC KEY-----\n\"\"\"\n    + MP_B64PUB_DER\n    + b\"\"\"\n-----END RSA PUBLIC KEY-----\n\"\"\"\n)\n\n\nclass MultiprimeDerTest(unittest.TestCase):\n    \"\"\"Test saving and loading multiprime DER keys.\"\"\"\n\n    def test_load_multiprime_private_key(self):\n        \"\"\"Test loading private DER keys.\"\"\"\n\n        key = rsa.key.PrivateKey.load_pkcs1(MP_PRIVATE_DER, \"DER\")\n        expected = rsa.key.PrivateKey(4253220375837175409, 65537, 3349121513, 64123, 50957, [39317, 33107])\n\n        self.assertEqual(expected, key)\n        self.assertEqual(key.exp1, 29453)\n        self.assertEqual(key.exp2, 38413)\n        self.assertEqual(key.coef, 20022)\n        self.assertEqual(key.ds, [27369, 19235])\n        self.assertEqual(key.ts, [10773, 10974])\n\n    def test_save_multiprime_private_key(self):\n        \"\"\"Test saving private DER keys.\"\"\"\n\n        key = rsa.key.PrivateKey(4253220375837175409, 65537, 3349121513, 64123, 50957, [39317, 33107])\n        der = key.save_pkcs1(\"DER\")\n\n        self.assertIsInstance(der, bytes)\n        self.assertEqual(MP_PRIVATE_DER, der)\n\n    def test_load_multiprime_public_key(self):\n        \"\"\"Test loading public DER keys.\"\"\"\n\n        key = rsa.key.PublicKey.load_pkcs1(MP_PUBLIC_DER, \"DER\")\n        expected = rsa.key.PublicKey(4253220375837175409, 65537)\n\n        self.assertEqual(expected, key)\n\n    def test_save_multiprime_public_key(self):\n        \"\"\"Test saving public DER keys.\"\"\"\n\n        key = rsa.key.PublicKey(4253220375837175409, 65537)\n        der = key.save_pkcs1(\"DER\")\n\n        self.assertIsInstance(der, bytes)\n        self.assertEqual(MP_PUBLIC_DER, der)\n\n\nclass MultiprimePemTest(unittest.TestCase):\n    \"\"\"Test saving and loading multiprime PEM keys.\"\"\"\n\n    def test_load_multiprime_private_key(self):\n        \"\"\"Test loading private PEM files.\"\"\"\n\n        key = rsa.key.PrivateKey.load_pkcs1(MP_PRIVATE_PEM, \"PEM\")\n        expected = rsa.key.PrivateKey(4253220375837175409, 65537, 3349121513, 64123, 50957, [39317, 33107])\n\n        self.assertEqual(expected, key)\n        self.assertEqual(key.exp1, 29453)\n        self.assertEqual(key.exp2, 38413)\n        self.assertEqual(key.coef, 20022)\n        self.assertEqual(key.ds, [27369, 19235])\n        self.assertEqual(key.ts, [10773, 10974])\n\n    def test_save_multiprime_private_key(self):\n        \"\"\"Test saving private PEM files.\"\"\"\n\n        key = rsa.key.PrivateKey(4253220375837175409, 65537, 3349121513, 64123, 50957, [39317, 33107])\n        pem = key.save_pkcs1(\"PEM\")\n\n        self.assertIsInstance(pem, bytes)\n        self.assertEqual(MP_CLEAN_PRIVATE_PEM.replace(b\"\\n\", b\"\"), pem.replace(b\"\\n\", b\"\"))\n\n    def test_load_multiprime_public_key(self):\n        \"\"\"Test loading public PEM files.\"\"\"\n\n        key = rsa.key.PublicKey.load_pkcs1(MP_PUBLIC_PEM, \"PEM\")\n        expected = rsa.key.PublicKey(4253220375837175409, 65537)\n\n        self.assertEqual(expected, key)\n\n    def test_save_multiprime_public_key(self):\n        \"\"\"Test saving public PEM files.\"\"\"\n\n        key = rsa.key.PublicKey(4253220375837175409, 65537)\n        pem = key.save_pkcs1(\"PEM\")\n\n        self.assertIsInstance(pem, bytes)\n        self.assertEqual(MP_CLEAN_PUBLIC_PEM, pem)\n\n\nclass PickleTest(unittest.TestCase):\n    \"\"\"Test saving and loading keys by pickling.\"\"\"\n\n    def test_private_key(self):\n        pk = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        pickled = pickle.dumps(pk)\n        unpickled = pickle.loads(pickled)\n        self.assertEqual(pk, unpickled)\n\n        for attr in rsa.key.AbstractKey.__slots__:\n            self.assertTrue(hasattr(unpickled, attr))\n\n    def test_multiprime_private_key(self):\n        pk = rsa.key.PrivateKey(4253220375837175409, 65537, 3349121513, 64123, 50957, [39317, 33107])\n\n        pickled = pickle.dumps(pk)\n        unpickled = pickle.loads(pickled)\n        self.assertEqual(pk, unpickled)\n\n        for attr in rsa.key.AbstractKey.__slots__:\n            self.assertTrue(hasattr(unpickled, attr))\n\n    def test_public_key(self):\n        pk = rsa.key.PublicKey(3727264081, 65537)\n\n        pickled = pickle.dumps(pk)\n        unpickled = pickle.loads(pickled)\n\n        self.assertEqual(pk, unpickled)\n        for attr in rsa.key.AbstractKey.__slots__:\n            self.assertTrue(hasattr(unpickled, attr))\n", "tests/test_key.py": "\"\"\"\nSome tests for the rsa/key.py file.\n\"\"\"\n\nimport unittest\n\nimport rsa.key\nimport rsa.core\n\n\nclass BlindingTest(unittest.TestCase):\n    def test_blinding(self):\n        \"\"\"Test blinding and unblinding.\n\n        This is basically the doctest of the PrivateKey.blind method, but then\n        implemented as unittest to allow running on different Python versions.\n        \"\"\"\n\n        pk = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        message = 12345\n        encrypted = rsa.core.encrypt_int(message, pk.e, pk.n)\n\n        blinded_1, unblind_1 = pk.blind(encrypted)  # blind before decrypting\n        decrypted = rsa.core.decrypt_int(blinded_1, pk.d, pk.n)\n        unblinded_1 = pk.unblind(decrypted, unblind_1)\n\n        self.assertEqual(unblinded_1, message)\n\n        # Re-blinding should use a different blinding factor.\n        blinded_2, unblind_2 = pk.blind(encrypted)  # blind before decrypting\n        self.assertNotEqual(blinded_1, blinded_2)\n\n        # The unblinding should still work, though.\n        decrypted = rsa.core.decrypt_int(blinded_2, pk.d, pk.n)\n        unblinded_2 = pk.unblind(decrypted, unblind_2)\n        self.assertEqual(unblinded_2, message)\n\n\nclass KeyGenTest(unittest.TestCase):\n    def test_custom_exponent(self):\n        pub, priv = rsa.key.newkeys(16, exponent=3)\n\n        self.assertEqual(3, priv.e)\n        self.assertEqual(3, pub.e)\n\n    def test_default_exponent(self):\n        pub, priv = rsa.key.newkeys(16)\n\n        self.assertEqual(0x10001, priv.e)\n        self.assertEqual(0x10001, pub.e)\n\n    def test_exponents_coefficient_calculation(self):\n        pk = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)\n\n        self.assertEqual(pk.exp1, 55063)\n        self.assertEqual(pk.exp2, 10095)\n        self.assertEqual(pk.coef, 50797)\n\n    def test_custom_getprime_func(self):\n        # List of primes to test with, in order [p, q, p, q, ....]\n        # By starting with two of the same primes, we test that this is\n        # properly rejected.\n        primes = [64123, 64123, 64123, 50957, 39317, 33107]\n\n        def getprime(_):\n            return primes.pop(0)\n\n        # This exponent will cause two other primes to be generated.\n        exponent = 136407\n\n        (p, q, e, d) = rsa.key.gen_keys(\n            64, accurate=False, getprime_func=getprime, exponent=exponent\n        )\n        self.assertEqual(39317, p)\n        self.assertEqual(33107, q)\n\n    def test_multiprime(self):\n        primes = [64123, 50957, 39317, 33107]\n        exponent = 2**2**4 + 1\n\n        def getprime(_):\n            return primes.pop(0)\n        (p, q, e, d, rs) = rsa.key.gen_keys(\n            128, accurate=False, getprime_func=getprime, exponent=exponent, nprimes=4\n        )\n        self.assertEqual(64123, p)\n        self.assertEqual(50957, q)\n        self.assertEqual(rs, [39317, 33107])\n\n\nclass HashTest(unittest.TestCase):\n    \"\"\"Test hashing of keys\"\"\"\n\n    def test_hash_possible(self):\n        pub, priv = rsa.key.newkeys(16)\n\n        # This raises a TypeError when hashing isn't possible.\n        hash(priv)\n        hash(pub)\n", "tests/test_pem.py": "#!/usr/bin/env python\n#  Copyright 2011 Sybren A. St\u00fcvel <sybren@stuvel.eu>\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\nimport unittest\n\nfrom rsa.pem import _markers\nimport rsa.key\n\n# 512-bit key. Too small for practical purposes, but good enough for testing with.\npublic_key_pem = \"\"\"\n-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKH0aYP9ZFuctlPnXhEyHjgc8ltKKx9M\n0c+h4sKMXwjhjbQAZdtWIw8RRghpUJnKj+6bN2XzZDazyULxgPhtax0CAwEAAQ==\n-----END PUBLIC KEY-----\n\"\"\"\n\nprivate_key_pem = \"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMIIBOwIBAAJBAKH0aYP9ZFuctlPnXhEyHjgc8ltKKx9M0c+h4sKMXwjhjbQAZdtW\nIw8RRghpUJnKj+6bN2XzZDazyULxgPhtax0CAwEAAQJADwR36EpNzQTqDzusCFIq\nZS+h9X8aIovgBK3RNhMIGO2ThpsnhiDTcqIvgQ56knbl6B2W4iOl54tJ6CNtf6l6\nzQIhANTaNLFGsJfOvZHcI0WL1r89+1A4JVxR+lpslJJwAvgDAiEAwsjqqZ2wY2F0\nF8p1J98BEbtjU2mEZIVCMn6vQuhWdl8CIDRL4IJl4eGKlB0QP0JJF1wpeGO/R76l\nDaPF5cMM7k3NAiEAss28m/ck9BWBfFVdNjx/vsdFZkx2O9AX9EJWoBSnSgECIQCa\n+sVQMUVJFGsdE/31C7wCIbE3IpB7ziABZ7mN+V3Dhg==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\n# Private key components\nprime1 = 96275860229939261876671084930484419185939191875438854026071315955024109172739\nprime2 = 88103681619592083641803383393198542599284510949756076218404908654323473741407\n\n\nclass TestMarkers(unittest.TestCase):\n    def test_values(self):\n        self.assertEqual(\n            _markers(\"RSA PRIVATE KEY\"),\n            (b\"-----BEGIN RSA PRIVATE KEY-----\", b\"-----END RSA PRIVATE KEY-----\"),\n        )\n\n\nclass TestBytesAndStrings(unittest.TestCase):\n    \"\"\"Test that we can use PEM in both Unicode strings and bytes.\"\"\"\n\n    def test_unicode_public(self):\n        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem)\n        self.assertEqual(prime1 * prime2, key.n)\n\n    def test_bytes_public(self):\n        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem.encode(\"ascii\"))\n        self.assertEqual(prime1 * prime2, key.n)\n\n    def test_unicode_private(self):\n        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem)\n        self.assertEqual(prime1 * prime2, key.n)\n\n    def test_bytes_private(self):\n        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem.encode(\"ascii\"))\n        self.assertEqual(prime1, key.p)\n        self.assertEqual(prime2, key.q)\n\n\nclass TestByteOutput(unittest.TestCase):\n    \"\"\"Tests that PEM and DER are returned as bytes.\"\"\"\n\n    def test_bytes_public(self):\n        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem)\n        self.assertIsInstance(key.save_pkcs1(format=\"DER\"), bytes)\n        self.assertIsInstance(key.save_pkcs1(format=\"PEM\"), bytes)\n\n    def test_bytes_private(self):\n        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem)\n        self.assertIsInstance(key.save_pkcs1(format=\"DER\"), bytes)\n        self.assertIsInstance(key.save_pkcs1(format=\"PEM\"), bytes)\n\n\nclass TestByteInput(unittest.TestCase):\n    \"\"\"Tests that PEM and DER can be loaded from bytes.\"\"\"\n\n    def test_bytes_public(self):\n        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem.encode(\"ascii\"))\n        self.assertIsInstance(key.save_pkcs1(format=\"DER\"), bytes)\n        self.assertIsInstance(key.save_pkcs1(format=\"PEM\"), bytes)\n\n    def test_bytes_private(self):\n        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem.encode(\"ascii\"))\n        self.assertIsInstance(key.save_pkcs1(format=\"DER\"), bytes)\n        self.assertIsInstance(key.save_pkcs1(format=\"PEM\"), bytes)\n"}