{"versioninfo.py": "import io\nimport os\nimport re\nimport sys\n\n__LXML_VERSION = None\n\n\ndef version():\n    global __LXML_VERSION\n    if __LXML_VERSION is None:\n        with open(os.path.join(get_base_dir(), 'src', 'lxml', '__init__.py')) as f:\n            __LXML_VERSION = re.search(r'__version__\\s*=\\s*\"([^\"]+)\"', f.read(250)).group(1)\n            assert __LXML_VERSION\n    return __LXML_VERSION\n\n\ndef branch_version():\n    return version()[:3]\n\n\ndef is_pre_release():\n    version_string = version()\n    return \"a\" in version_string or \"b\" in version_string\n\n\ndef dev_status():\n    _version = version()\n    if 'a' in _version:\n        return 'Development Status :: 3 - Alpha'\n    elif 'b' in _version or 'c' in _version:\n        return 'Development Status :: 4 - Beta'\n    else:\n        return 'Development Status :: 5 - Production/Stable'\n\n\ndef changes():\n    \"\"\"Extract part of changelog pertaining to version.\n    \"\"\"\n    _version = version()\n    with io.open(os.path.join(get_base_dir(), \"CHANGES.txt\"), 'r', encoding='utf8') as f:\n        lines = []\n        for line in f:\n            if line.startswith('====='):\n                if len(lines) > 1:\n                    break\n            if lines:\n                lines.append(line)\n            elif line.startswith(_version):\n                lines.append(line)\n    return ''.join(lines[:-1])\n\n\ndef create_version_h():\n    \"\"\"Create lxml-version.h\n    \"\"\"\n    lxml_version = version()\n    # make sure we have a triple part version number\n    parts = lxml_version.split('-')\n    while parts[0].count('.') < 2:\n        parts[0] += '.0'\n    lxml_version = '-'.join(parts).replace('a', '.alpha').replace('b', '.beta')\n\n    file_path = os.path.join(get_base_dir(), 'src', 'lxml', 'includes', 'lxml-version.h')\n\n    # Avoid changing file timestamp if content didn't change.\n    if os.path.isfile(file_path):\n        with open(file_path, 'r') as version_h:\n            if ('\"%s\"' % lxml_version) in version_h.read(100):\n                return\n\n    with open(file_path, 'w') as version_h:\n        version_h.write('''\\\n#ifndef LXML_VERSION_STRING\n#define LXML_VERSION_STRING \"%s\"\n#endif\n''' % lxml_version)\n\n\ndef get_base_dir():\n    return os.path.abspath(os.path.dirname(sys.argv[0]))\n", "update-error-constants.py": "#!/usr/bin/env python\n\nimport operator\nimport os.path\nimport sys\nimport xml.etree.ElementTree as ET\n\nBUILD_SOURCE_FILE = os.path.join(\"src\", \"lxml\", \"xmlerror.pxi\")\nBUILD_DEF_FILE    = os.path.join(\"src\", \"lxml\", \"includes\", \"xmlerror.pxd\")\n\n# map enum name to Python variable name and alignment for constant name\nENUM_MAP = {\n    'xmlErrorLevel'       : ('__ERROR_LEVELS',  'XML_ERR_'),\n    'xmlErrorDomain'      : ('__ERROR_DOMAINS', 'XML_FROM_'),\n    'xmlParserErrors'     : ('__PARSER_ERROR_TYPES',   'XML_'),\n#    'xmlXPathError'       : ('__XPATH_ERROR_TYPES',   ''),\n#    'xmlSchemaValidError' : ('__XMLSCHEMA_ERROR_TYPES',   'XML_'),\n    'xmlRelaxNGValidErr'  : ('__RELAXNG_ERROR_TYPES',   'XML_'),\n    }\n\nENUM_ORDER = (\n    'xmlErrorLevel',\n    'xmlErrorDomain',\n    'xmlParserErrors',\n#    'xmlXPathError',\n#    'xmlSchemaValidError',\n    'xmlRelaxNGValidErr')\n\nCOMMENT = \"\"\"\n# This section is generated by the script '%s'.\n\n\"\"\" % os.path.basename(sys.argv[0])\n\n\ndef split(lines):\n    lines = iter(lines)\n    pre = []\n    for line in lines:\n        pre.append(line)\n        if line.startswith('#') and \"BEGIN: GENERATED CONSTANTS\" in line:\n            break\n    pre.append('')\n    old = []\n    for line in lines:\n        if line.startswith('#') and \"END: GENERATED CONSTANTS\" in line:\n            break\n        old.append(line.rstrip('\\n'))\n    post = ['', line]\n    post.extend(lines)\n    post.append('')\n    return pre, old, post\n\n\ndef regenerate_file(filename, result):\n    new = COMMENT + '\\n'.join(result)\n\n    # read .pxi source file\n    with open(filename, 'r', encoding=\"utf-8\") as f:\n        pre, old, post = split(f)\n\n    if new.strip() == '\\n'.join(old).strip():\n        # no changes\n        return False\n\n    # write .pxi source file\n    with open(filename, 'w', encoding=\"utf-8\") as f:\n        f.write(''.join(pre))\n        f.write(new)\n        f.write(''.join(post))\n\n    return True\n\n\ndef parse_enums(doc_dir, api_filename, enum_dict):\n    tree = ET.parse(os.path.join(doc_dir, api_filename))\n    for enum in tree.iterfind('symbols/enum'):\n        enum_type = enum.get('type')\n        if enum_type not in ENUM_MAP:\n            continue\n        entries = enum_dict.get(enum_type)\n        if not entries:\n            print(\"Found enum\", enum_type)\n            entries = enum_dict[enum_type] = []\n        entries.append((\n            enum.get('name'),\n            int(enum.get('value')),\n            enum.get('info', '').strip(),\n        ))\n\n\ndef main(doc_dir):\n    enum_dict = {}\n    parse_enums(doc_dir, 'libxml2-api.xml',   enum_dict)\n    #parse_enums(doc_dir, 'libxml-xmlerror.html',   enum_dict)\n    #parse_enums(doc_dir, 'libxml-xpath.html',      enum_dict)\n    #parse_enums(doc_dir, 'libxml-xmlschemas.html', enum_dict)\n    #parse_enums(doc_dir, 'libxml-relaxng.html',    enum_dict)\n\n    # regenerate source files\n    pxi_result = []\n    append_pxi = pxi_result.append\n    pxd_result = []\n    append_pxd = pxd_result.append\n\n    append_pxd('cdef extern from \"libxml/xmlerror.h\":')\n\n    ctypedef_indent = ' '*4\n    constant_indent = ctypedef_indent*2\n\n    for enum_name in ENUM_ORDER:\n        constants = enum_dict[enum_name]\n        constants.sort(key=operator.itemgetter(1))\n        pxi_name, prefix = ENUM_MAP[enum_name]\n\n        append_pxd(ctypedef_indent + 'ctypedef enum %s:' % enum_name)\n        append_pxi('cdef object %s = \"\"\"\\\\' % pxi_name)\n\n        prefix_len = len(prefix)\n        length = 2  # each string ends with '\\n\\0'\n        for name, val, descr in constants:\n            if descr and descr != str(val):\n                line = '%-50s = %7d # %s' % (name, val, descr)\n            else:\n                line = '%-50s = %7d' % (name, val)\n            append_pxd(constant_indent + line)\n\n            if name[:prefix_len] == prefix and len(name) > prefix_len:\n                name = name[prefix_len:]\n            line = '%s=%d' % (name, val)\n            append_pxi(line)\n            length += len(line) + 2  # + '\\n\\0'\n\n        append_pxd('')\n        append_pxi('\"\"\"')\n        append_pxi('')\n\n    # write source files\n    print(\"Updating file %s\" % BUILD_SOURCE_FILE)\n    updated = regenerate_file(BUILD_SOURCE_FILE, pxi_result)\n    if not updated:\n        print(\"No changes.\")\n\n    print(\"Updating file %s\" % BUILD_DEF_FILE)\n    updated = regenerate_file(BUILD_DEF_FILE,    pxd_result)\n    if not updated:\n        print(\"No changes.\")\n\n    print(\"Done\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1].lower() in ('-h', '--help'):\n        print(\"This script generates the constants in file %s\" % BUILD_SOURCE_FILE)\n        print(\"Call as\")\n        print(sys.argv[0], \"/path/to/libxml2-doc-dir\")\n        sys.exit(len(sys.argv) > 1)\n\n    main(sys.argv[1])\n", "download_artefacts.py": "#!/usr/bin/python3\n\nimport json\nimport logging\nimport shutil\nimport datetime\n\nfrom concurrent.futures import ProcessPoolExecutor as Pool, as_completed\nfrom pathlib import Path\nfrom urllib.request import urlopen, Request\nfrom urllib.parse import urljoin\n\nlogger = logging.getLogger()\n\nPARALLEL_DOWNLOADS = 6\nGITHUB_API_URL = \"https://api.github.com/repos/lxml/lxml\"\nAPPVEYOR_PACKAGE_URL = \"https://ci.appveyor.com/api/projects/scoder/lxml\"\nAPPVEYOR_BUILDJOBS_URL = \"https://ci.appveyor.com/api/buildjobs\"\n\n\ndef find_github_files(version, api_url=GITHUB_API_URL):\n    url = f\"{api_url}/releases/tags/lxml-{version}\"\n    release, _ = read_url(url, accept=\"application/vnd.github+json\", as_json=True)\n\n    for asset in release.get('assets', ()):\n        yield asset['browser_download_url']\n\n\ndef find_appveyor_files(version, base_package_url=APPVEYOR_PACKAGE_URL, base_job_url=APPVEYOR_BUILDJOBS_URL):\n    url = f\"{base_package_url}/history?recordsNumber=20\"\n    with urlopen(url) as p:\n        builds = json.load(p)[\"builds\"]\n\n    tag = f\"lxml-{version}\"\n    for build in builds:\n        if build['isTag'] and build['tag'] == tag:\n            build_id = build['buildId']\n            break\n    else:\n        logger.warning(f\"No appveyor build found for tag '{tag}'\")\n        return\n\n    build_url = f\"{base_package_url}/builds/{build_id}\"\n    with urlopen(build_url) as p:\n        jobs = json.load(p)[\"build\"][\"jobs\"]\n\n    for job in jobs:\n        artifacts_url = f\"{base_job_url}/{job['jobId']}/artifacts/\"\n\n        with urlopen(artifacts_url) as p:\n            for artifact in json.load(p):\n                yield urljoin(artifacts_url, artifact['fileName'])\n\n\ndef read_url(url, decode=True, accept=None, as_json=False):\n    if accept:\n        request = Request(url, headers={'Accept': accept})\n    else:\n        request = Request(url)\n\n    with urlopen(request) as res:\n        charset = _find_content_encoding(res)\n        content_type = res.headers.get('Content-Type')\n        data = res.read()\n\n    if decode:\n        data = data.decode(charset)\n    if as_json:\n        data = json.loads(data)\n    return data, content_type\n\n\ndef _find_content_encoding(response, default='iso8859-1'):\n    from email.message import Message\n    content_type = response.headers.get('Content-Type')\n    if content_type:\n        msg = Message()\n        msg.add_header('Content-Type', content_type)\n        charset = msg.get_content_charset(default)\n    else:\n        charset = default\n    return charset\n\n\ndef download1(wheel_url, dest_dir):\n    wheel_name = wheel_url.rsplit(\"/\", 1)[1]\n    logger.info(f\"Downloading {wheel_url} ...\")\n    with urlopen(wheel_url) as w:\n        file_path = dest_dir / wheel_name\n        if (file_path.exists()\n                and \"Content-Length\" in w.headers\n                and file_path.stat().st_size == int(w.headers[\"Content-Length\"])):\n            logger.info(f\"Already have {wheel_name}\")\n        else:\n            temp_file_path = file_path.with_suffix(\".tmp\")\n            try:\n                with open(temp_file_path, \"wb\") as f:\n                    shutil.copyfileobj(w, f)\n            except:\n                if temp_file_path.exists():\n                    temp_file_path.unlink()\n                raise\n            else:\n                temp_file_path.replace(file_path)\n                logger.info(f\"Finished downloading {wheel_name}\")\n    return wheel_name\n\n\ndef download(urls, dest_dir, jobs=PARALLEL_DOWNLOADS):\n    with Pool(max_workers=jobs) as pool:\n        futures = [pool.submit(download1, url, dest_dir) for url in urls]\n        try:\n            for future in as_completed(futures):\n                wheel_name = future.result()\n                yield wheel_name\n        except KeyboardInterrupt:\n            for future in futures:\n                future.cancel()\n            raise\n\n\ndef dedup(it):\n    seen = set()\n    for value in it:\n        if value not in seen:\n            seen.add(value)\n            yield value\n\n\ndef roundrobin(*iterables):\n    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n    # Recipe credited to George Sakkis\n    from itertools import cycle, islice\n    num_active = len(iterables)\n    nexts = cycle(iter(it).__next__ for it in iterables)\n    while num_active:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            # Remove the iterator we just exhausted from the cycle.\n            num_active -= 1\n            nexts = cycle(islice(nexts, num_active))\n\n\ndef main(*args):\n    if not args:\n        print(\"Please pass the version to download\")\n        return\n\n    version = args[0]\n    dest_dir = Path(\"dist\") / version\n    if not dest_dir.is_dir():\n        dest_dir.mkdir()\n\n    start_time = datetime.datetime.now().replace(microsecond=0)\n    urls = roundrobin(*map(dedup, [\n        find_github_files(version),\n        find_appveyor_files(version),\n    ]))\n    count = sum(1 for _ in enumerate(download(urls, dest_dir)))\n    duration = datetime.datetime.now().replace(microsecond=0) - start_time\n    logger.info(f\"Downloaded {count} files in {duration}.\")\n\n\nif __name__ == \"__main__\":\n    import sys\n    logging.basicConfig(\n        stream=sys.stderr,\n        level=logging.INFO,\n        format=\"%(asctime)-15s  %(message)s\",\n    )\n    main(*sys.argv[1:])\n", "setup.py": "import os\nimport re\nimport sys\nimport fnmatch\nimport os.path\n\n# for command line options and supported environment variables, please\n# see the end of 'setupinfo.py'\n\nif sys.version_info[:2] < (3, 6):\n    print(\"This lxml version requires Python 3.6 or later.\")\n    sys.exit(1)\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\n# make sure Cython finds include files in the project directory and not outside\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))\n\nimport versioninfo\nimport setupinfo\n\n# override these and pass --static for a static build. See\n# doc/build.txt for more information. If you do not pass --static\n# changing this will have no effect.\ndef static_env_list(name, separator=None):\n    return [x.strip() for x in os.environ.get(name, \"\").split(separator) if x.strip()]\n\nSTATIC_INCLUDE_DIRS = static_env_list(\"LXML_STATIC_INCLUDE_DIRS\", separator=os.pathsep)\nSTATIC_LIBRARY_DIRS = static_env_list(\"LXML_STATIC_LIBRARY_DIRS\", separator=os.pathsep)\nSTATIC_CFLAGS = static_env_list(\"LXML_STATIC_CFLAGS\")\nSTATIC_BINARIES = static_env_list(\"LXML_STATIC_BINARIES\", separator=os.pathsep)\n\n# create lxml-version.h file\nversioninfo.create_version_h()\nlxml_version = versioninfo.version()\nprint(\"Building lxml version %s.\" % lxml_version)\n\nOPTION_RUN_TESTS = setupinfo.has_option('run-tests')\n\nbranch_link = \"\"\"\nAfter an official release of a new stable series, bug fixes may become\navailable at\nhttps://github.com/lxml/lxml/tree/lxml-%(branch_version)s .\nRunning ``easy_install lxml==%(branch_version)sbugfix`` will install\nthe unreleased branch state from\nhttps://github.com/lxml/lxml/tarball/lxml-%(branch_version)s#egg=lxml-%(branch_version)sbugfix\nas soon as a maintenance branch has been established.  Note that this\nrequires Cython to be installed at an appropriate version for the build.\n\n\"\"\"\n\nif versioninfo.is_pre_release():\n    branch_link = \"\"\n\n\nextra_options = {}\nif 'setuptools' in sys.modules:\n    extra_options['zip_safe'] = False\n    extra_options['python_requires'] = (\n        # NOTE: keep in sync with Trove classifier list below.\n        '>=3.6')\n\n    try:\n        import pkg_resources\n    except ImportError:\n        pass\n    else:\n        f = open(\"requirements.txt\", \"r\")\n        try:\n            deps = [str(req) for req in pkg_resources.parse_requirements(f)]\n        finally:\n            f.close()\n        extra_options['extras_require'] = {\n            'source': deps,\n            'cssselect': 'cssselect>=0.7',\n            'html5': 'html5lib',\n            'htmlsoup': 'BeautifulSoup4',\n            'html_clean': 'lxml_html_clean',\n        }\n\nextra_options.update(setupinfo.extra_setup_args())\n\nextra_options['package_data'] = {\n    'lxml': [\n        'etree.h',\n        'etree_api.h',\n        'lxml.etree.h',\n        'lxml.etree_api.h',\n        # Include Cython source files for better traceback output.\n        '*.pyx',\n        '*.pxi',\n    ],\n    'lxml.includes': [\n        '*.pxd', '*.h'\n        ],\n    'lxml.isoschematron':  [\n        'resources/rng/iso-schematron.rng',\n        'resources/xsl/*.xsl',\n        'resources/xsl/iso-schematron-xslt1/*.xsl',\n        'resources/xsl/iso-schematron-xslt1/readme.txt'\n        ],\n    }\n\nextra_options['package_dir'] = {\n        '': 'src'\n    }\n\nextra_options['packages'] = [\n        'lxml', 'lxml.includes', 'lxml.html', 'lxml.isoschematron'\n    ]\n\n\ndef setup_extra_options():\n    is_interesting_package = re.compile('^(libxml|libxslt|libexslt)$').match\n    is_interesting_header = re.compile(r'^(zconf|zlib|.*charset)\\.h$').match\n\n    def extract_files(directories, pattern='*'):\n        def get_files(root, dir_path, files):\n            return [ (root, dir_path, filename)\n                     for filename in fnmatch.filter(files, pattern) ]\n\n        file_list = []\n        for dir_path in directories:\n            dir_path = os.path.realpath(dir_path)\n            for root, dirs, files in os.walk(dir_path):\n                rel_dir = root[len(dir_path)+1:]\n                if is_interesting_package(rel_dir):\n                    file_list.extend(get_files(root, rel_dir, files))\n                elif not rel_dir:\n                    # include also top-level header files (zlib/iconv)\n                    file_list.extend(\n                        item for item in get_files(root, rel_dir, files)\n                        if is_interesting_header(item[-1])\n                    )\n        return file_list\n\n    def build_packages(files):\n        packages = {}\n        seen = set()\n        for root_path, rel_path, filename in files:\n            if filename in seen:\n                # libxml2/libxslt header filenames are unique\n                continue\n            seen.add(filename)\n            package_path = '.'.join(rel_path.split(os.sep))\n            if package_path in packages:\n                root, package_files = packages[package_path]\n                if root != root_path:\n                    print(\"WARNING: conflicting directories found for include package '%s': %s and %s\"\n                          % (package_path, root_path, root))\n                    continue\n            else:\n                package_files = []\n                packages[package_path] = (root_path, package_files)\n            package_files.append(filename)\n\n        return packages\n\n    # Copy Global Extra Options\n    extra_opts = dict(extra_options)\n\n    # Build ext modules\n    ext_modules = setupinfo.ext_modules(\n                    STATIC_INCLUDE_DIRS, STATIC_LIBRARY_DIRS,\n                    STATIC_CFLAGS, STATIC_BINARIES)\n    extra_opts['ext_modules'] = ext_modules\n\n    packages = extra_opts.get('packages', list())\n    package_dir = extra_opts.get('package_dir', dict())\n    package_data = extra_opts.get('package_data', dict())\n\n    # Add lxml.include with (lxml, libxslt headers...)\n    #   python setup.py build --static --static-deps install\n    #   python setup.py bdist_wininst --static\n    if setupinfo.OPTION_STATIC:\n        include_dirs = [] # keep them in order\n        for extension in ext_modules:\n            for inc_dir in extension.include_dirs:\n                if inc_dir not in include_dirs:\n                    include_dirs.append(inc_dir)\n\n        header_packages = build_packages(extract_files(include_dirs))\n\n        package_filename = \"__init__.py\"\n        for package_path, (root_path, filenames) in header_packages.items():\n            if not package_path:\n                # lxml.includes -> lxml.includes.extlibs\n                package_path = \"extlibs\"\n            package = 'lxml.includes.' + package_path\n            packages.append(package)\n\n            # create '__init__.py' to make sure it's considered a package\n            if package_filename not in filenames:\n                with open(os.path.join(root_path, package_filename), 'wb') as f:\n                    pass\n                filenames.append(package_filename)\n\n            assert package not in package_data\n            package_data[package] = filenames\n            assert package not in package_dir\n            package_dir[package] = root_path\n\n    return extra_opts\n\nsetup(\n    name = \"lxml\",\n    version = lxml_version,\n    author=\"lxml dev team\",\n    author_email=\"lxml-dev@lxml.de\",\n    maintainer=\"lxml dev team\",\n    maintainer_email=\"lxml-dev@lxml.de\",\n    license=\"BSD-3-Clause\",\n    url=\"https://lxml.de/\",\n    # Commented out because this causes distutils to emit warnings\n    # `Unknown distribution option: 'bugtrack_url'`\n    # which distract folks from real causes of problems when troubleshooting\n    # bugtrack_url=\"https://bugs.launchpad.net/lxml\",\n    project_urls={\n        \"Source\": \"https://github.com/lxml/lxml\",\n    },\n    description=(\n        \"Powerful and Pythonic XML processing library\"\n        \" combining libxml2/libxslt with the ElementTree API.\"\n    ),\n    long_description=(((\"\"\"\\\nlxml is a Pythonic, mature binding for the libxml2 and libxslt libraries.  It\nprovides safe and convenient access to these libraries using the ElementTree\nAPI.\n\nIt extends the ElementTree API significantly to offer support for XPath,\nRelaxNG, XML Schema, XSLT, C14N and much more.\n\nTo contact the project, go to the `project home page\n<https://lxml.de/>`_ or see our bug tracker at\nhttps://launchpad.net/lxml\n\nIn case you want to use the current in-development version of lxml,\nyou can get it from the github repository at\nhttps://github.com/lxml/lxml .  Note that this requires Cython to\nbuild the sources, see the build instructions on the project home\npage.  To the same end, running ``easy_install lxml==dev`` will\ninstall lxml from\nhttps://github.com/lxml/lxml/tarball/master#egg=lxml-dev if you have\nan appropriate version of Cython installed.\n\n\"\"\" + branch_link) % {\"branch_version\": versioninfo.branch_version()}) +\n                      versioninfo.changes()),\n    classifiers=[\n        versioninfo.dev_status(),\n        'Intended Audience :: Developers',\n        'Intended Audience :: Information Technology',\n        'License :: OSI Approved :: BSD License',\n        'Programming Language :: Cython',\n        # NOTE: keep in sync with 'python_requires' list above.\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: C',\n        'Operating System :: OS Independent',\n        'Topic :: Text Processing :: Markup :: HTML',\n        'Topic :: Text Processing :: Markup :: XML',\n        'Topic :: Software Development :: Libraries :: Python Modules'\n    ],\n\n    **setup_extra_options()\n)\n\nif OPTION_RUN_TESTS:\n    print(\"Running tests.\")\n    import test\n    try:\n        sys.exit( test.main(sys.argv[:1]) )\n    except ImportError:\n        pass  # we assume that the binaries were not built with this setup.py run\n", "setupinfo.py": "import sys\nimport io\nimport os\nimport os.path\nimport subprocess\n\nfrom setuptools.command.build_ext import build_ext as _build_ext\nfrom distutils.core import Extension\nfrom distutils.errors import CompileError, DistutilsOptionError\nfrom versioninfo import get_base_dir\n\ntry:\n    import Cython.Compiler.Version\n    CYTHON_INSTALLED = True\nexcept ImportError:\n    CYTHON_INSTALLED = False\n\nEXT_MODULES = [\"lxml.etree\", \"lxml.objectify\"]\nCOMPILED_MODULES = [\n    \"lxml.builder\",\n    \"lxml._elementpath\",\n    \"lxml.html.diff\",\n    \"lxml.sax\",\n]\nHEADER_FILES = ['etree.h', 'etree_api.h']\n\nif hasattr(sys, 'pypy_version_info') or (\n        getattr(sys, 'implementation', None) and sys.implementation.name != 'cpython'):\n    # disable Cython compilation of Python modules in PyPy and other non-CPythons\n    del COMPILED_MODULES[:]\n\nSOURCE_PATH = \"src\"\nINCLUDE_PACKAGE_PATH = os.path.join(SOURCE_PATH, 'lxml', 'includes')\n\n_system_encoding = sys.getdefaultencoding()\nif _system_encoding is None:\n    _system_encoding = \"iso-8859-1\" # :-)\n\ndef decode_input(data):\n    if isinstance(data, str):\n        return data\n    return data.decode(_system_encoding)\n\ndef env_var(name):\n    value = os.getenv(name)\n    if value:\n        value = decode_input(value)\n        if sys.platform == 'win32' and ';' in value:\n            return value.split(';')\n        else:\n            return value.split()\n    else:\n        return []\n\n\ndef _prefer_reldirs(base_dir, dirs):\n    return [\n        os.path.relpath(path) if path.startswith(base_dir) else path\n        for path in dirs\n    ]\n\ndef ext_modules(static_include_dirs, static_library_dirs,\n                static_cflags, static_binaries):\n    global XML2_CONFIG, XSLT_CONFIG\n    if OPTION_BUILD_LIBXML2XSLT:\n        from buildlibxml import build_libxml2xslt, get_prebuilt_libxml2xslt\n        if sys.platform.startswith('win'):\n            get_prebuilt_libxml2xslt(\n                OPTION_DOWNLOAD_DIR, static_include_dirs, static_library_dirs)\n        else:\n            XML2_CONFIG, XSLT_CONFIG = build_libxml2xslt(\n                OPTION_DOWNLOAD_DIR, 'build/tmp',\n                static_include_dirs, static_library_dirs,\n                static_cflags, static_binaries,\n                libiconv_version=OPTION_LIBICONV_VERSION,\n                libxml2_version=OPTION_LIBXML2_VERSION,\n                libxslt_version=OPTION_LIBXSLT_VERSION,\n                zlib_version=OPTION_ZLIB_VERSION,\n                multicore=OPTION_MULTICORE)\n\n    modules = EXT_MODULES + COMPILED_MODULES\n    if OPTION_WITHOUT_OBJECTIFY:\n        modules = [entry for entry in modules if 'objectify' not in entry]\n\n    module_files = list(os.path.join(SOURCE_PATH, *module.split('.')) for module in modules)\n    c_files_exist = [os.path.exists(module + '.c') for module in module_files]\n\n    use_cython = True\n    if CYTHON_INSTALLED and (OPTION_WITH_CYTHON or not all(c_files_exist)):\n        print(\"Building with Cython %s.\" % Cython.Compiler.Version.version)\n        # generate module cleanup code\n        from Cython.Compiler import Options\n        Options.generate_cleanup_code = 3\n        Options.clear_to_none = False\n    elif not OPTION_WITHOUT_CYTHON and not all(c_files_exist):\n        for exists, module in zip(c_files_exist, module_files):\n            if not exists:\n                raise RuntimeError(\n                    \"ERROR: Trying to build without Cython, but pre-generated '%s.c' \"\n                    \"is not available (to ignore this error, pass --without-cython or \"\n                    \"set environment variable WITHOUT_CYTHON=true).\" % module)\n    else:\n        if not all(c_files_exist):\n            for exists, module in zip(c_files_exist, module_files):\n                if not exists:\n                    print(\"WARNING: Trying to build without Cython, but pre-generated \"\n                          \"'%s.c' is not available.\" % module)\n        use_cython = False\n        print(\"Building without Cython.\")\n\n    if not check_build_dependencies():\n        raise RuntimeError(\"Dependency missing\")\n\n    base_dir = get_base_dir()\n    _include_dirs = _prefer_reldirs(\n        base_dir, include_dirs(static_include_dirs) + [\n            SOURCE_PATH,\n            INCLUDE_PACKAGE_PATH,\n        ])\n    _library_dirs = _prefer_reldirs(base_dir, library_dirs(static_library_dirs))\n    _cflags = cflags(static_cflags)\n    _ldflags = ['-isysroot', get_xcode_isysroot()] if sys.platform == 'darwin' else None\n    _define_macros = define_macros()\n    _libraries = libraries()\n\n    if _library_dirs:\n        message = \"Building against libxml2/libxslt in \"\n        if len(_library_dirs) > 1:\n            print(message + \"one of the following directories:\")\n            for dir in _library_dirs:\n                print(\"  \" + dir)\n        else:\n            print(message + \"the following directory: \" +\n                  _library_dirs[0])\n\n    if OPTION_AUTO_RPATH:\n        runtime_library_dirs = _library_dirs\n    else:\n        runtime_library_dirs = []\n\n    if CYTHON_INSTALLED and OPTION_SHOW_WARNINGS:\n        from Cython.Compiler import Errors\n        Errors.LEVEL = 0\n\n    cythonize_directives = {\n        'binding': True,\n    }\n    if OPTION_WITH_COVERAGE:\n        cythonize_directives['linetrace'] = True\n\n    result = []\n    for module, src_file in zip(modules, module_files):\n        is_py = module in COMPILED_MODULES\n        main_module_source = src_file + (\n            '.c' if not use_cython else '.py' if is_py else '.pyx')\n        result.append(\n            Extension(\n                module,\n                sources = [main_module_source],\n                depends = find_dependencies(module),\n                extra_compile_args = _cflags,\n                extra_link_args = None if is_py else _ldflags,\n                extra_objects = None if is_py else static_binaries,\n                define_macros = _define_macros,\n                include_dirs = _include_dirs,\n                library_dirs = None if is_py else _library_dirs,\n                runtime_library_dirs = None if is_py else runtime_library_dirs,\n                libraries = None if is_py else _libraries,\n            ))\n    if CYTHON_INSTALLED and OPTION_WITH_CYTHON_GDB:\n        for ext in result:\n            ext.cython_gdb = True\n\n    if CYTHON_INSTALLED and use_cython:\n        # build .c files right now and convert Extension() objects\n        from Cython.Build import cythonize\n        result = cythonize(result, compiler_directives=cythonize_directives)\n\n        # Fix compiler warning due to missing pragma-push in Cython 3.0.9.\n        for ext in result:\n            for source_file in ext.sources:\n                if not source_file.endswith('.c'):\n                    continue\n                with open(source_file, 'rb') as f:\n                    lines = f.readlines()\n                if b'Generated by Cython 3.0.9' not in lines[0]:\n                    continue\n\n                modified = False\n                temp_file = source_file + \".tmp\"\n                with open(temp_file, 'wb') as f:\n                    last_was_push = False\n                    for line in lines:\n                        if b'#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"' in line and not last_was_push:\n                            f.write(b\"#pragma GCC diagnostic push\\n\")\n                            modified = True\n                        last_was_push = b'#pragma GCC diagnostic push' in line\n                        f.write(line)\n\n                if modified:\n                    print(\"Fixed Cython 3.0.9 generated source file \" + source_file)\n                    os.unlink(source_file)\n                    os.rename(temp_file, source_file)\n                else:\n                    os.unlink(temp_file)\n\n    # for backwards compatibility reasons, provide \"etree[_api].h\" also as \"lxml.etree[_api].h\"\n    for header_filename in HEADER_FILES:\n        src_file = os.path.join(SOURCE_PATH, 'lxml', header_filename)\n        dst_file = os.path.join(SOURCE_PATH, 'lxml', 'lxml.' + header_filename)\n        if not os.path.exists(src_file):\n            continue\n        if os.path.exists(dst_file) and os.path.getmtime(dst_file) >= os.path.getmtime(src_file):\n            continue\n\n        with io.open(src_file, 'r', encoding='iso8859-1') as f:\n            content = f.read()\n        for filename in HEADER_FILES:\n            content = content.replace('\"%s\"' % filename, '\"lxml.%s\"' % filename)\n        with io.open(dst_file, 'w', encoding='iso8859-1') as f:\n            f.write(content)\n\n    return result\n\n\ndef find_dependencies(module):\n    if not CYTHON_INSTALLED or 'lxml.html' in module:\n        return []\n    base_dir = get_base_dir()\n    package_dir = os.path.join(base_dir, SOURCE_PATH, 'lxml')\n    includes_dir = os.path.join(base_dir, INCLUDE_PACKAGE_PATH)\n\n    pxd_files = [\n        os.path.join(INCLUDE_PACKAGE_PATH, filename)\n        for filename in os.listdir(includes_dir)\n        if filename.endswith('.pxd')\n    ]\n\n    if module == 'lxml.etree':\n        pxi_files = [\n            os.path.join(SOURCE_PATH, 'lxml', filename)\n            for filename in os.listdir(package_dir)\n            if filename.endswith('.pxi') and 'objectpath' not in filename\n        ]\n        pxd_files = [\n            filename for filename in pxd_files\n            if 'etreepublic' not in filename\n        ]\n    elif module == 'lxml.objectify':\n        pxi_files = [os.path.join(SOURCE_PATH, 'lxml', 'objectpath.pxi')]\n    else:\n        pxi_files = pxd_files = []\n\n    return pxd_files + pxi_files\n\n\ndef extra_setup_args():\n    class CheckLibxml2BuildExt(_build_ext):\n        \"\"\"Subclass to check whether libxml2 is really available if the build fails\"\"\"\n        def run(self):\n            try:\n                _build_ext.run(self)  # old-style class in Py2\n            except CompileError as e:\n                print('Compile failed: %s' % e)\n                if not seems_to_have_libxml2():\n                    print_libxml_error()\n                raise\n    result = {'cmdclass': {'build_ext': CheckLibxml2BuildExt}}\n    return result\n\n\ndef seems_to_have_libxml2():\n    from distutils import ccompiler\n    compiler = ccompiler.new_compiler()\n    return compiler.has_function(\n        'xmlXPathInit',\n        include_dirs=include_dirs([]) + ['/usr/include/libxml2'],\n        includes=['libxml/xpath.h'],\n        library_dirs=library_dirs([]),\n        libraries=['xml2'])\n\n\ndef print_libxml_error():\n    print('*********************************************************************************')\n    print('Could not find function xmlCheckVersion in library libxml2. Is libxml2 installed?')\n    if sys.platform in ('darwin',):\n        print('Perhaps try: xcode-select --install')\n    print('*********************************************************************************')\n\n\ndef libraries():\n    standard_libs = []\n    if 'linux' in sys.platform:\n        standard_libs.append('rt')\n    if not OPTION_BUILD_LIBXML2XSLT:\n        standard_libs.append('z')\n    standard_libs.append('m')\n\n    if sys.platform in ('win32',):\n        libs = ['libxslt', 'libexslt', 'libxml2', 'iconv']\n        if OPTION_STATIC:\n            libs = ['%s_a' % lib for lib in libs]\n        libs.extend(['zlib', 'WS2_32'])\n    elif OPTION_STATIC:\n        libs = standard_libs\n    else:\n        libs = ['xslt', 'exslt', 'xml2'] + standard_libs\n    return libs\n\ndef library_dirs(static_library_dirs):\n    if OPTION_STATIC:\n        if not static_library_dirs:\n            static_library_dirs = env_var('LIBRARY')\n        assert static_library_dirs, \"Static build not configured, see doc/build.txt\"\n        return static_library_dirs\n    # filter them from xslt-config --libs\n    result = []\n    possible_library_dirs = flags('libs')\n    for possible_library_dir in possible_library_dirs:\n        if possible_library_dir.startswith('-L'):\n            result.append(possible_library_dir[2:])\n    return result\n\ndef include_dirs(static_include_dirs):\n    if OPTION_STATIC:\n        if not static_include_dirs:\n            static_include_dirs = env_var('INCLUDE')\n        return static_include_dirs\n    # filter them from xslt-config --cflags\n    result = []\n    possible_include_dirs = flags('cflags')\n    for possible_include_dir in possible_include_dirs:\n        if possible_include_dir.startswith('-I'):\n            result.append(possible_include_dir[2:])\n    return result\n\ndef cflags(static_cflags):\n    result = []\n    if not OPTION_SHOW_WARNINGS:\n        result.append('-w')\n    if OPTION_DEBUG_GCC:\n        result.append('-g2')\n\n    if OPTION_STATIC:\n        if not static_cflags:\n            static_cflags = env_var('CFLAGS')\n        result.extend(static_cflags)\n    else:\n        # anything from xslt-config --cflags that doesn't start with -I\n        possible_cflags = flags('cflags')\n        for possible_cflag in possible_cflags:\n            if not possible_cflag.startswith('-I'):\n                result.append(possible_cflag)\n\n    if sys.platform in ('darwin',):\n        for opt in result:\n            if 'flat_namespace' in opt:\n                break\n        else:\n            result.append('-flat_namespace')\n\n    return result\n\ndef define_macros():\n    macros = []\n    if OPTION_WITHOUT_ASSERT:\n        macros.append(('PYREX_WITHOUT_ASSERTIONS', None))\n    if OPTION_WITHOUT_THREADING:\n        macros.append(('WITHOUT_THREADING', None))\n    if OPTION_WITH_REFNANNY:\n        macros.append(('CYTHON_REFNANNY', None))\n    if OPTION_WITH_UNICODE_STRINGS:\n        macros.append(('LXML_UNICODE_STRINGS', '1'))\n    if OPTION_WITH_COVERAGE:\n        macros.append(('CYTHON_TRACE_NOGIL', '1'))\n    if OPTION_BUILD_LIBXML2XSLT:\n        macros.append(('LIBXML_STATIC', None))\n        macros.append(('LIBXSLT_STATIC', None))\n        macros.append(('LIBEXSLT_STATIC', None))\n    # Disable showing C lines in tracebacks, unless explicitly requested.\n    macros.append(('CYTHON_CLINE_IN_TRACEBACK', '1' if OPTION_WITH_CLINES else '0'))\n    return macros\n\n\ndef run_command(cmd, *args):\n    if not cmd:\n        return ''\n    if args:\n        cmd = ' '.join((cmd,) + args)\n\n    p = subprocess.Popen(cmd, shell=True,\n                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout_data, errors = p.communicate()\n\n    if p.returncode != 0 and errors:\n        return ''\n    return decode_input(stdout_data).strip()\n\n\ndef check_min_version(version, min_version, libname):\n    if not version:\n        # this is ok for targets like sdist etc.\n        return True\n    lib_version = tuple(map(int, version.split('.')[:3]))\n    req_version = tuple(map(int, min_version.split('.')[:3]))\n    if lib_version < req_version:\n        print(\"Minimum required version of %s is %s. Your system has version %s.\" % (\n            libname, min_version, version))\n        return False\n    return True\n\n\ndef get_library_version(prog, libname=None):\n    if libname:\n        return run_command(prog, '--modversion %s' % libname)\n    else:\n        return run_command(prog, '--version')\n\n\nPKG_CONFIG = None\nXML2_CONFIG = None\nXSLT_CONFIG = None\n\ndef get_library_versions():\n    global XML2_CONFIG, XSLT_CONFIG\n\n    # Pre-built libraries\n    if XML2_CONFIG and XSLT_CONFIG:\n        xml2_version = get_library_version(XML2_CONFIG)\n        xslt_version = get_library_version(XSLT_CONFIG)\n        return xml2_version, xslt_version\n\n    # Path to xml2-config and xslt-config specified on the command line\n    if OPTION_WITH_XML2_CONFIG:\n        xml2_version = get_library_version(OPTION_WITH_XML2_CONFIG)\n        if xml2_version and OPTION_WITH_XSLT_CONFIG:\n            xslt_version = get_library_version(OPTION_WITH_XSLT_CONFIG)\n            if xslt_version:\n                XML2_CONFIG = OPTION_WITH_XML2_CONFIG\n                XSLT_CONFIG = OPTION_WITH_XSLT_CONFIG\n                return xml2_version, xslt_version\n\n    # Try pkg-config\n    global PKG_CONFIG\n    PKG_CONFIG = os.getenv('PKG_CONFIG', 'pkg-config')\n    xml2_version = get_library_version(PKG_CONFIG, 'libxml-2.0')\n    if xml2_version:\n        xslt_version = get_library_version(PKG_CONFIG, 'libxslt')\n        if xml2_version and xslt_version:\n            return xml2_version, xslt_version\n\n    # Try xml2-config and xslt-config\n    XML2_CONFIG = os.getenv('XML2_CONFIG', 'xml2-config')\n    xml2_version = get_library_version(XML2_CONFIG)\n    if xml2_version:\n        XSLT_CONFIG = os.getenv('XSLT_CONFIG', 'xslt-config')\n        xslt_version = get_library_version(XSLT_CONFIG)\n        if xml2_version and xslt_version:\n            return xml2_version, xslt_version\n\n    # One or both build dependencies not found. Fail on Linux platforms only.\n    if sys.platform.startswith('win'):\n        return '', ''\n    print(\"Error: Please make sure the libxml2 and libxslt development packages are installed.\")\n    sys.exit(1)\n\n\ndef check_build_dependencies():\n    xml2_version, xslt_version = get_library_versions()\n\n    xml2_ok = check_min_version(xml2_version, '2.7.0', 'libxml2')\n    xslt_ok = check_min_version(xslt_version, '1.1.23', 'libxslt')\n\n    if not OPTION_BUILD_LIBXML2XSLT and xml2_version in ('2.9.11', '2.9.12'):\n        print(\"\\n\"\n              \"WARNING: The stock libxml2 versions 2.9.11 and 2.9.12 are incompatible\"\n              \" with this lxml version. \"\n              \"They produce excess content on serialisation. \"\n              \"Use a different library version or a static build.\"\n              \"\\n\")\n\n    if xml2_version and xslt_version:\n        print(\"Building against libxml2 %s and libxslt %s\" % (xml2_version, xslt_version))\n    else:\n        print(\"Building against pre-built libxml2 andl libxslt libraries\")\n\n    return (xml2_ok and xslt_ok)\n\n\ndef get_flags(prog, option, libname=None):\n    if libname:\n        return run_command(prog, '--%s %s' % (option, libname))\n    else:\n        return run_command(prog, '--%s' % option)\n\n\ndef flags(option):\n    if XML2_CONFIG:\n        xml2_flags = get_flags(XML2_CONFIG, option)\n        xslt_flags = get_flags(XSLT_CONFIG, option)\n    else:\n        xml2_flags = get_flags(PKG_CONFIG, option, 'libxml-2.0')\n        xslt_flags = get_flags(PKG_CONFIG, option, 'libxslt')\n\n    flag_list = xml2_flags.split()\n    for flag in xslt_flags.split():\n        if flag not in flag_list:\n            flag_list.append(flag)\n    return flag_list\n\n\ndef get_xcode_isysroot():\n    return run_command('xcrun', '--show-sdk-path')\n\n\n## Option handling:\n\ndef has_option(name):\n    try:\n        sys.argv.remove('--%s' % name)\n        return True\n    except ValueError:\n        pass\n    # allow passing all cmd line options also as environment variables\n    env_val = os.getenv(name.upper().replace('-', '_'), 'false').lower()\n    if env_val == \"true\":\n        return True\n    return False\n\n\ndef option_value(name, deprecated_for=None):\n    for index, option in enumerate(sys.argv):\n        if option == '--' + name:\n            if index+1 >= len(sys.argv):\n                raise DistutilsOptionError(\n                    'The option %s requires a value' % option)\n            value = sys.argv[index+1]\n            sys.argv[index:index+2] = []\n            if deprecated_for:\n                print_deprecated_option(name, deprecated_for)\n            return value\n        if option.startswith('--' + name + '='):\n            value = option[len(name)+3:]\n            sys.argv[index:index+1] = []\n            if deprecated_for:\n                print_deprecated_option(name, deprecated_for)\n            return value\n    env_name = name.upper().replace('-', '_')\n    env_val = os.getenv(env_name)\n    if env_val and deprecated_for:\n        print_deprecated_option(env_name, deprecated_for.upper().replace('-', '_'))\n    return env_val\n\n\ndef print_deprecated_option(name, new_name):\n    print(\"WARN: Option '%s' is deprecated. Use '%s' instead.\" % (name, new_name))\n\n\nstaticbuild = bool(os.environ.get('STATICBUILD', ''))\n# pick up any commandline options and/or env variables\nOPTION_WITHOUT_OBJECTIFY = has_option('without-objectify')\nOPTION_WITH_UNICODE_STRINGS = has_option('with-unicode-strings')\nOPTION_WITHOUT_ASSERT = has_option('without-assert')\nOPTION_WITHOUT_THREADING = has_option('without-threading')\nOPTION_WITHOUT_CYTHON = has_option('without-cython')\nOPTION_WITH_CYTHON = has_option('with-cython')\nOPTION_WITH_CYTHON_GDB = has_option('cython-gdb')\nOPTION_WITH_REFNANNY = has_option('with-refnanny')\nOPTION_WITH_COVERAGE = has_option('with-coverage')\nOPTION_WITH_CLINES = has_option('with-clines')\nif OPTION_WITHOUT_CYTHON:\n    CYTHON_INSTALLED = False\nOPTION_STATIC = staticbuild or has_option('static')\nOPTION_DEBUG_GCC = has_option('debug-gcc')\nOPTION_SHOW_WARNINGS = has_option('warnings')\nOPTION_AUTO_RPATH = has_option('auto-rpath')\nOPTION_BUILD_LIBXML2XSLT = staticbuild or has_option('static-deps')\nif OPTION_BUILD_LIBXML2XSLT:\n    OPTION_STATIC = True\nOPTION_WITH_XML2_CONFIG = option_value('with-xml2-config') or option_value('xml2-config', deprecated_for='with-xml2-config')\nOPTION_WITH_XSLT_CONFIG = option_value('with-xslt-config') or option_value('xslt-config', deprecated_for='with-xslt-config')\nOPTION_LIBXML2_VERSION = option_value('libxml2-version')\nOPTION_LIBXSLT_VERSION = option_value('libxslt-version')\nOPTION_LIBICONV_VERSION = option_value('libiconv-version')\nOPTION_ZLIB_VERSION = option_value('zlib-version')\nOPTION_MULTICORE = option_value('multicore')\nOPTION_DOWNLOAD_DIR = option_value('download-dir')\nif OPTION_DOWNLOAD_DIR is None:\n    OPTION_DOWNLOAD_DIR = 'libs'\n", "buildlibxml.py": "import json\nimport os, re, sys, subprocess, platform\nimport tarfile\nfrom distutils import log\nfrom contextlib import closing, contextmanager\nfrom ftplib import FTP\n\nfrom urllib.parse import urljoin, unquote, urlparse\nfrom urllib.request import urlretrieve, urlopen, Request\n\nmulti_make_options = []\ntry:\n    import multiprocessing\n    cpus = multiprocessing.cpu_count()\n    if cpus > 1:\n        if cpus > 5:\n            cpus = 5\n        multi_make_options = ['-j%d' % (cpus+1)]\nexcept:\n    pass\n\n\n# overridable to control script usage\nsys_platform = sys.platform\n\n\n# use pre-built libraries on Windows\n\ndef download_and_extract_windows_binaries(destdir):\n    url = \"https://api.github.com/repos/lxml/libxml2-win-binaries/releases?per_page=5\"\n    releases, _ = read_url(\n        url,\n        accept=\"application/vnd.github+json\",\n        as_json=True,\n        github_api_token=os.environ.get(\"GITHUB_API_TOKEN\"),\n    )\n\n    max_release = {'tag_name': ''}\n    for release in releases:\n        if max_release['tag_name'] < release.get('tag_name', ''):\n            max_release = release\n\n    url = \"https://github.com/lxml/libxml2-win-binaries/releases/download/%s/\" % max_release['tag_name']\n    filenames = [asset['name'] for asset in max_release.get('assets', ())]\n\n    # Check for native ARM64 build or the environment variable that is set by\n    # Visual Studio for cross-compilation (same variable as setuptools uses)\n    if platform.machine() == 'ARM64' or os.getenv('VSCMD_ARG_TGT_ARCH') == 'arm64':\n        arch = \"win-arm64\"\n    elif sys.maxsize > 2**32:\n        arch = \"win64\"\n    else:\n        arch = \"win32\"\n\n    if sys.version_info < (3, 5):\n        arch = 'vs2008.' + arch\n\n    arch_part = '.' + arch + '.'\n    filenames = [filename for filename in filenames if arch_part in filename]\n\n    libs = {}\n    for libname in ['libxml2', 'libxslt', 'zlib', 'iconv']:\n        libs[libname] = \"%s-%s.%s.zip\" % (\n            libname,\n            find_max_version(libname, filenames),\n            arch,\n        )\n\n    if not os.path.exists(destdir):\n        os.makedirs(destdir)\n\n    for libname, libfn in libs.items():\n        srcfile = urljoin(url, libfn)\n        destfile = os.path.join(destdir, libfn)\n        if os.path.exists(destfile + \".keep\"):\n            print('Using local copy of  \"{}\"'.format(srcfile))\n        else:\n            print('Retrieving \"%s\" to \"%s\"' % (srcfile, destfile))\n            urlretrieve(srcfile, destfile)\n        d = unpack_zipfile(destfile, destdir)\n        libs[libname] = d\n\n    return libs\n\n\ndef find_top_dir_of_zipfile(zipfile):\n    topdir = None\n    files = [f.filename for f in zipfile.filelist]\n    dirs = [d for d in files if d.endswith('/')]\n    if dirs:\n        dirs.sort(key=len)\n        topdir = dirs[0]\n        topdir = topdir[:topdir.index(\"/\")+1]\n        for path in files:\n            if not path.startswith(topdir):\n                topdir = None\n                break\n    assert topdir, (\n        \"cannot determine single top-level directory in zip file %s\" %\n        zipfile.filename)\n    return topdir.rstrip('/')\n\n\ndef unpack_zipfile(zipfn, destdir):\n    assert zipfn.endswith('.zip')\n    import zipfile\n    print('Unpacking %s into %s' % (os.path.basename(zipfn), destdir))\n    f = zipfile.ZipFile(zipfn)\n    try:\n        extracted_dir = os.path.join(destdir, find_top_dir_of_zipfile(f))\n        f.extractall(path=destdir)\n    finally:\n        f.close()\n    assert os.path.exists(extracted_dir), 'missing: %s' % extracted_dir\n    return extracted_dir\n\n\ndef get_prebuilt_libxml2xslt(download_dir, static_include_dirs, static_library_dirs):\n    assert sys_platform.startswith('win')\n    libs = download_and_extract_windows_binaries(download_dir)\n    for libname, path in libs.items():\n        i = os.path.join(path, 'include')\n        l = os.path.join(path, 'lib')\n        assert os.path.exists(i), 'does not exist: %s' % i\n        assert os.path.exists(l), 'does not exist: %s' % l\n        static_include_dirs.append(i)\n        static_library_dirs.append(l)\n\n\n## Routines to download and build libxml2/xslt from sources:\n\nLIBXML2_LOCATION = 'https://download.gnome.org/sources/libxml2/'\nLIBXSLT_LOCATION = 'https://download.gnome.org/sources/libxslt/'\nLIBICONV_LOCATION = 'https://ftp.gnu.org/pub/gnu/libiconv/'\nZLIB_LOCATION = 'https://zlib.net/'\nmatch_libfile_version = re.compile('^[^-]*-([.0-9-]+)[.].*').match\n\n\ndef _find_content_encoding(response, default='iso8859-1'):\n    from email.message import Message\n    content_type = response.headers.get('Content-Type')\n    if content_type:\n        msg = Message()\n        msg.add_header('Content-Type', content_type)\n        charset = msg.get_content_charset(default)\n    else:\n        charset = default\n    return charset\n\n\ndef remote_listdir(url):\n    try:\n        return _list_dir_urllib(url)\n    except IOError:\n        assert url.lower().startswith('ftp://')\n        print(\"Requesting with urllib failed. Falling back to ftplib. \"\n              \"Proxy argument will be ignored for %s\" % url)\n        return _list_dir_ftplib(url)\n\n\ndef _list_dir_ftplib(url):\n    parts = urlparse(url)\n    ftp = FTP(parts.netloc)\n    try:\n        ftp.login()\n        ftp.cwd(parts.path)\n        data = []\n        ftp.dir(data.append)\n    finally:\n        ftp.quit()\n    return parse_text_ftplist(\"\\n\".join(data))\n\n\ndef read_url(url, decode=True, accept=None, as_json=False, github_api_token=None):\n    headers = {'User-Agent': 'https://github.com/lxml/lxml'}\n    if accept:\n        headers['Accept'] = accept\n    if github_api_token:\n        headers['authorization'] = \"Bearer \" + github_api_token\n    request = Request(url, headers=headers)\n\n    with closing(urlopen(request)) as res:\n        charset = _find_content_encoding(res)\n        content_type = res.headers.get('Content-Type')\n        data = res.read()\n\n    if decode:\n        data = data.decode(charset)\n    if as_json:\n        data = json.loads(data)\n    return data, content_type\n\n\ndef _list_dir_urllib(url):\n    data, content_type = read_url(url)\n    if content_type and content_type.startswith('text/html'):\n        files = parse_html_filelist(data)\n    else:\n        files = parse_text_ftplist(data)\n    return files\n\n\ndef http_find_latest_version_directory(url, version=None):\n    data, _ = read_url(url)\n    # e.g. <a href=\"1.0/\">\n    directories = [\n        (int(v[0]), int(v[1]))\n        for v in re.findall(r' href=[\"\\']([0-9]+)\\.([0-9]+)/?[\"\\']', data)\n    ]\n    if not directories:\n        return url\n    best_version = max(directories)\n    if version:\n        major, minor, _ = version.split(\".\", 2)\n        major, minor = int(major), int(minor)\n        if (major, minor) in directories:\n            best_version = (major, minor)\n    latest_dir = \"%s.%s\" % best_version\n    return urljoin(url, latest_dir) + \"/\"\n\n\ndef http_listfiles(url, re_pattern):\n    data, _ = read_url(url)\n    files = re.findall(re_pattern, data)\n    return files\n\n\ndef parse_text_ftplist(s):\n    for line in s.splitlines():\n        if not line.startswith('d'):\n            # -rw-r--r--   1 ftp      ftp           476 Sep  1  2011 md5sum.txt\n            # Last (9th) element is 'md5sum.txt' in the above example, but there\n            # may be variations, so we discard only the first 8 entries.\n            yield line.split(None, 8)[-1]\n\n\ndef parse_html_filelist(s):\n    re_href = re.compile(\n        r'''<a[^>]*\\shref=[\"']([^;?\"']+?)[;?\"']''',\n        re.I|re.M)\n    links = set(re_href.findall(s))\n    for link in links:\n        if not link.endswith('/'):\n            yield unquote(link)\n\n\ndef tryint(s):\n    try:\n        return int(s)\n    except ValueError:\n        return s\n\n\n@contextmanager\ndef py2_tarxz(filename):\n    import tempfile\n    with tempfile.TemporaryFile() as tmp:\n        subprocess.check_call([\"xz\", \"-dc\", filename], stdout=tmp.fileno())\n        tmp.seek(0)\n        with closing(tarfile.TarFile(fileobj=tmp)) as tf:\n            yield tf\n\n\ndef download_libxml2(dest_dir, version=None):\n    \"\"\"Downloads libxml2, returning the filename where the library was downloaded\"\"\"\n    #version_re = re.compile(r'LATEST_LIBXML2_IS_([0-9.]+[0-9](?:-[abrc0-9]+)?)')\n    version_re = re.compile(r'libxml2-([0-9.]+[0-9]).tar.xz')\n    filename = 'libxml2-%s.tar.xz'\n\n    if version == \"2.9.12\":\n        # Temporarily using the latest master (2.9.12+) until there is a release that supports lxml again.\n        from_location = \"https://gitlab.gnome.org/GNOME/libxml2/-/archive/dea91c97debeac7c1aaf9c19f79029809e23a353/\"\n        version = \"dea91c97debeac7c1aaf9c19f79029809e23a353\"\n    else:\n        from_location = http_find_latest_version_directory(LIBXML2_LOCATION, version=version)\n\n    return download_library(dest_dir, from_location, 'libxml2',\n                            version_re, filename, version=version)\n\n\ndef download_libxslt(dest_dir, version=None):\n    \"\"\"Downloads libxslt, returning the filename where the library was downloaded\"\"\"\n    #version_re = re.compile(r'LATEST_LIBXSLT_IS_([0-9.]+[0-9](?:-[abrc0-9]+)?)')\n    version_re = re.compile(r'libxslt-([0-9.]+[0-9]).tar.xz')\n    filename = 'libxslt-%s.tar.xz'\n    from_location = http_find_latest_version_directory(LIBXSLT_LOCATION, version=version)\n    return download_library(dest_dir, from_location, 'libxslt',\n                            version_re, filename, version=version)\n\n\ndef download_libiconv(dest_dir, version=None):\n    \"\"\"Downloads libiconv, returning the filename where the library was downloaded\"\"\"\n    version_re = re.compile(r'libiconv-([0-9.]+[0-9]).tar.gz')\n    filename = 'libiconv-%s.tar.gz'\n    return download_library(dest_dir, LIBICONV_LOCATION, 'libiconv',\n                            version_re, filename, version=version)\n\n\ndef download_zlib(dest_dir, version):\n    \"\"\"Downloads zlib, returning the filename where the library was downloaded\"\"\"\n    version_re = re.compile(r'zlib-([0-9.]+[0-9]).tar.gz')\n    filename = 'zlib-%s.tar.gz'\n    return download_library(dest_dir, ZLIB_LOCATION, 'zlib',\n                            version_re, filename, version=version)\n\n\ndef find_max_version(libname, filenames, version_re=None):\n    if version_re is None:\n        version_re = re.compile(r'%s-([0-9.]+[0-9](?:-[abrc0-9]+)?)' % libname)\n    versions = []\n    for fn in filenames:\n        match = version_re.search(fn)\n        if match:\n            version_string = match.group(1)\n            versions.append((tuple(map(tryint, version_string.replace(\"-\", \".-\").split('.'))),\n                             version_string))\n    if not versions:\n        raise Exception(\n            \"Could not find the most current version of %s from the files: %s\" % (\n                libname, filenames))\n    versions.sort()\n    version_string = versions[-1][-1]\n    print('Latest version of %s is %s' % (libname, version_string))\n    return version_string\n\n\ndef download_library(dest_dir, location, name, version_re, filename, version=None):\n    if version is None:\n        try:\n            if location.startswith('ftp://'):\n                fns = remote_listdir(location)\n            else:\n                print(location)\n                fns = http_listfiles(location, '(%s)' % filename.replace('%s', '(?:[0-9.]+[0-9])'))\n            version = find_max_version(name, fns, version_re)\n        except IOError:\n            # network failure - maybe we have the files already?\n            latest = (0,0,0)\n            fns = os.listdir(dest_dir)\n            for fn in fns:\n                if fn.startswith(name+'-'):\n                    match = match_libfile_version(fn)\n                    if match:\n                        version_tuple = tuple(map(tryint, match.group(1).split('.')))\n                        if version_tuple > latest:\n                            latest = version_tuple\n                            filename = fn\n                            version = None\n            if latest == (0,0,0):\n                raise\n    if version:\n        filename = filename % version\n\n    full_url = urljoin(location, filename)\n    dest_filename = os.path.join(dest_dir, filename)\n    if os.path.exists(dest_filename):\n        print(('Using existing %s downloaded into %s '\n               '(delete this file if you want to re-download the package)') % (\n            name, dest_filename))\n        return dest_filename\n\n    print('Downloading %s into %s from %s' % (name, dest_filename, full_url))\n    urlretrieve(full_url, dest_filename)\n    return dest_filename\n\n\ndef unpack_tarball(tar_filename, dest):\n    print('Unpacking %s into %s' % (os.path.basename(tar_filename), dest))\n    if sys.version_info[0] < 3 and tar_filename.endswith('.xz'):\n        # Py 2.7 lacks lzma support\n        tar_cm = py2_tarxz(tar_filename)\n    else:\n        tar_cm = closing(tarfile.open(tar_filename))\n\n    base_dir = None\n    with tar_cm as tar:\n        for member in tar:\n            base_name = member.name.split('/')[0]\n            if base_dir is None:\n                base_dir = base_name\n            elif base_dir != base_name:\n                print('Unexpected path in %s: %s' % (tar_filename, base_name))\n        tar.extractall(dest)\n    return os.path.join(dest, base_dir)\n\n\ndef call_subprocess(cmd, **kw):\n    import subprocess\n    cwd = kw.get('cwd', '.')\n    cmd_desc = ' '.join(cmd)\n    log.info('Running \"%s\" in %s' % (cmd_desc, cwd))\n    returncode = subprocess.call(cmd, **kw)\n    if returncode:\n        raise Exception('Command \"%s\" returned code %s' % (cmd_desc, returncode))\n\n\ndef safe_mkdir(dir):\n    if not os.path.exists(dir):\n        os.makedirs(dir)\n\n\ndef cmmi(configure_cmd, build_dir, multicore=None, **call_setup):\n    print('Starting build in %s' % build_dir)\n    call_subprocess(configure_cmd, cwd=build_dir, **call_setup)\n    if not multicore:\n        make_jobs = multi_make_options\n    elif int(multicore) > 1:\n        make_jobs = ['-j%s' % multicore]\n    else:\n        make_jobs = []\n    call_subprocess(\n        ['make'] + make_jobs,\n        cwd=build_dir, **call_setup)\n    call_subprocess(\n        ['make'] + make_jobs + ['install'],\n        cwd=build_dir, **call_setup)\n\n\ndef configure_darwin_env(env_setup):\n    import platform\n    # configure target architectures on MacOS-X (x86_64 + Arm64, by default)\n    major_version, minor_version = tuple(map(int, platform.mac_ver()[0].split('.')[:2]))\n    if major_version >= 11:\n        env_default = {\n            'CFLAGS': \"-arch x86_64 -arch arm64 -O3\",\n            'LDFLAGS': \"-arch x86_64 -arch arm64\",\n            'MACOSX_DEPLOYMENT_TARGET': \"11.0\"\n        }\n        env_default.update(os.environ)\n        env_setup['env'] = env_default\n\n\ndef build_libxml2xslt(download_dir, build_dir,\n                      static_include_dirs, static_library_dirs,\n                      static_cflags, static_binaries,\n                      libxml2_version=None,\n                      libxslt_version=None,\n                      libiconv_version=None,\n                      zlib_version=None,\n                      multicore=None):\n    safe_mkdir(download_dir)\n    safe_mkdir(build_dir)\n    zlib_dir = unpack_tarball(download_zlib(download_dir, zlib_version), build_dir)\n    libiconv_dir = unpack_tarball(download_libiconv(download_dir, libiconv_version), build_dir)\n    libxml2_dir  = unpack_tarball(download_libxml2(download_dir, libxml2_version), build_dir)\n    libxslt_dir  = unpack_tarball(download_libxslt(download_dir, libxslt_version), build_dir)\n    prefix = os.path.join(os.path.abspath(build_dir), 'libxml2')\n    lib_dir = os.path.join(prefix, 'lib')\n    safe_mkdir(prefix)\n\n    lib_names = ['libxml2', 'libexslt', 'libxslt', 'iconv', 'libz']\n    existing_libs = {\n        lib: os.path.join(lib_dir, filename)\n        for lib in lib_names\n        for filename in os.listdir(lib_dir)\n        if lib in filename and filename.endswith('.a')\n    } if os.path.isdir(lib_dir) else {}\n\n    def has_current_lib(name, build_dir, _build_all_following=[False]):\n        if _build_all_following[0]:\n            return False  # a dependency was rebuilt => rebuilt this lib as well\n        lib_file = existing_libs.get(name)\n        found = lib_file and os.path.getmtime(lib_file) > os.path.getmtime(build_dir)\n        if found:\n            print(\"Found pre-built '%s'\" % name)\n        else:\n            # also rebuild all following libs (which may depend on this one)\n            _build_all_following[0] = True\n        return found\n\n    call_setup = {}\n    if sys_platform == 'darwin':\n        configure_darwin_env(call_setup)\n\n    configure_cmd = ['./configure',\n                     '--disable-dependency-tracking',\n                     '--disable-shared',\n                     '--prefix=%s' % prefix,\n                     ]\n\n    # build zlib\n    zlib_configure_cmd = [\n        './configure',\n        '--prefix=%s' % prefix,\n    ]\n    if not has_current_lib(\"libz\", zlib_dir):\n        cmmi(zlib_configure_cmd, zlib_dir, multicore, **call_setup)\n\n    # build libiconv\n    if not has_current_lib(\"iconv\", libiconv_dir):\n        cmmi(configure_cmd, libiconv_dir, multicore, **call_setup)\n\n    # build libxml2\n    libxml2_configure_cmd = configure_cmd + [\n        '--without-python',\n        '--with-iconv=%s' % prefix,\n        '--with-zlib=%s' % prefix,\n    ]\n\n    if not libxml2_version:\n        libxml2_version = os.path.basename(libxml2_dir).split('-', 1)[-1]\n\n    if tuple(map(tryint, libxml2_version.split('-', 1)[0].split('.'))) >= (2, 9, 5):\n        libxml2_configure_cmd.append('--without-lzma')  # can't currently build that\n\n    try:\n        if tuple(map(tryint, libxml2_version.split('-', 1)[0].split('.'))) >= (2, 7, 3):\n            libxml2_configure_cmd.append('--enable-rebuild-docs=no')\n    except Exception:\n        pass # this isn't required, so ignore any errors\n    if not has_current_lib(\"libxml2\", libxml2_dir):\n        if not os.path.exists(os.path.join(libxml2_dir, \"configure\")):\n            # Allow building from git sources by running autoconf etc.\n            libxml2_configure_cmd[0] = \"./autogen.sh\"\n        cmmi(libxml2_configure_cmd, libxml2_dir, multicore, **call_setup)\n\n    # Fix up libxslt configure script (needed up to and including 1.1.34)\n    # https://gitlab.gnome.org/GNOME/libxslt/-/commit/90c34c8bb90e095a8a8fe8b2ce368bd9ff1837cc\n    with open(os.path.join(libxslt_dir, \"configure\"), 'rb') as f:\n        config_script = f.read()\n    if b' --libs print ' in config_script:\n        config_script = config_script.replace(b' --libs print ', b' --libs ')\n        with open(os.path.join(libxslt_dir, \"configure\"), 'wb') as f:\n            f.write(config_script)\n\n    # build libxslt\n    libxslt_configure_cmd = configure_cmd + [\n        '--without-python',\n        '--with-libxml-prefix=%s' % prefix,\n        '--without-crypto',\n    ]\n    if not (has_current_lib(\"libxslt\", libxslt_dir) and has_current_lib(\"libexslt\", libxslt_dir)):\n        cmmi(libxslt_configure_cmd, libxslt_dir, multicore, **call_setup)\n\n    # collect build setup for lxml\n    xslt_config = os.path.join(prefix, 'bin', 'xslt-config')\n    xml2_config = os.path.join(prefix, 'bin', 'xml2-config')\n\n    static_include_dirs.extend([\n            os.path.join(prefix, 'include'),\n            os.path.join(prefix, 'include', 'libxml2'),\n            os.path.join(prefix, 'include', 'libxslt'),\n            os.path.join(prefix, 'include', 'libexslt')])\n    static_library_dirs.append(lib_dir)\n\n    listdir = os.listdir(lib_dir)\n    static_binaries += [os.path.join(lib_dir, filename)\n        for lib in lib_names\n        for filename in listdir\n        if lib in filename and filename.endswith('.a')]\n\n    return xml2_config, xslt_config\n\n\ndef main():\n    static_include_dirs = []\n    static_library_dirs = []\n    download_dir = \"libs\"\n\n    if sys_platform.startswith('win'):\n        return get_prebuilt_libxml2xslt(\n            download_dir, static_include_dirs, static_library_dirs)\n    else:\n        return build_libxml2xslt(\n            download_dir, 'build/tmp',\n            static_include_dirs, static_library_dirs,\n            static_cflags=[],\n            static_binaries=[]\n        )\n\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        # change global sys_platform setting\n        sys_platform = sys.argv[1]\n    main()\n", "test.py": "#!/usr/bin/env python\n#\n# SchoolTool - common information systems platform for school administration\n# Copyright (c) 2003 Shuttleworth Foundation\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n#\n\"\"\"\nSchoolTool test runner.\n\nSyntax: test.py [options] [pathname-regexp [test-regexp]]\n\nThere are two kinds of tests:\n  - unit tests (or programmer tests) test the internal workings of various\n    components of the system\n  - functional tests (acceptance tests, customer tests) test only externally\n    visible system behaviour\n\nYou can choose to run unit tests (this is the default mode), functional tests\n(by giving a -f option to test.py) or both (by giving both -u and -f options).\n\nTest cases are located in the directory tree starting at the location of this\nscript, in subdirectories named 'tests' for unit tests and 'ftests' for\nfunctional tests, in Python modules named 'test*.py'.  They are then filtered\naccording to pathname and test regexes.  Alternatively, packages may just have\n'tests.py' and 'ftests.py' instead of subpackages 'tests' and 'ftests'\nrespectively.\n\nA leading \"!\" in a regexp is stripped and negates the regexp.  Pathname\nregexp is applied to the whole path (package/package/module.py). Test regexp\nis applied to a full test id (package.package.module.class.test_method).\n\nOptions:\n  -h            print this help message\n  -v            verbose (print dots for each test run)\n  -vv           very verbose (print test names)\n  -q            quiet (do not print anything on success)\n  -w            enable warnings about omitted test cases\n  -p            show progress bar (can be combined with -v or -vv)\n  -u            select unit tests (default)\n  -f            select functional tests\n  --level n     select only tests at level n or lower\n  --all-levels  select all tests\n  --list-files  list all selected test files\n  --list-tests  list all selected test cases\n  --list-hooks  list all loaded test hooks\n  --coverage    create code coverage reports\n\"\"\"\n#\n# This script borrows ideas from Zope 3's test runner heavily.  It is smaller\n# and cleaner though, at the expense of more limited functionality.\n#\n\nimport re\nimport os\nimport sys\nimport time\nimport types\nimport getopt\nimport unittest\nimport traceback\n\nfrom unittest import TextTestResult\n\n__metaclass__ = type\n\ndef stderr(text):\n    sys.stderr.write(text)\n    sys.stderr.write(\"\\n\")\n\nclass Options:\n    \"\"\"Configurable properties of the test runner.\"\"\"\n\n    # test location\n    basedir = ''                # base directory for tests (defaults to\n                                # basedir of argv[0] + 'src'), must be absolute\n    src_in_path = True          # add 'src/' to sys.path\n    follow_symlinks = True      # should symlinks to subdirectories be\n                                # followed? (hardcoded, may cause loops)\n\n    # which tests to run\n    unit_tests = False          # unit tests (default if both are false)\n    functional_tests = False    # functional tests\n\n    # test filtering\n    level = 1                   # run only tests at this or lower level\n                                # (if None, runs all tests)\n    pathname_regex = ''         # regexp for filtering filenames\n    test_regex = ''             # regexp for filtering test cases\n\n    # actions to take\n    list_files = False          # --list-files\n    list_tests = False          # --list-tests\n    list_hooks = False          # --list-hooks\n    run_tests = True            # run tests (disabled by --list-foo)\n\n    # output verbosity\n    verbosity = 0               # verbosity level (-v)\n    quiet = 0                   # do not print anything on success (-q)\n    warn_omitted = False        # produce warnings when a test case is\n                                # not included in a test suite (-w)\n    progress = False            # show running progress (-p)\n    coverage = False            # produce coverage reports (--coverage)\n    coverdir = 'coverage'       # where to put them (currently hardcoded)\n    immediate_errors = False    # show tracebacks twice (currently hardcoded)\n    screen_width = 80           # screen width (autodetected)\n\n\ndef compile_matcher(regex):\n    \"\"\"Returns a function that takes one argument and returns True or False.\n\n    Regex is a regular expression.  Empty regex matches everything.  There\n    is one expression: if the regex starts with \"!\", the meaning of it is\n    reversed.\n    \"\"\"\n    if not regex:\n        return lambda x: True\n    elif regex == '!':\n        return lambda x: False\n    elif regex.startswith('!'):\n        rx = re.compile(regex[1:])\n        return lambda x: rx.search(x) is None\n    else:\n        rx = re.compile(regex)\n        return lambda x: rx.search(x) is not None\n\n\ndef walk_with_symlinks(top, func, arg):\n    \"\"\"Like os.path.walk, but follows symlinks on POSIX systems.\n\n    If the symlinks create a loop, this function will never finish.\n    \"\"\"\n    try:\n        names = os.listdir(top)\n    except os.error:\n        return\n    func(arg, top, names)\n    exceptions = ('.', '..')\n    for name in names:\n        if name not in exceptions:\n            name = os.path.join(top, name)\n            if os.path.isdir(name):\n                walk_with_symlinks(name, func, arg)\n\n\ndef get_test_files(cfg):\n    \"\"\"Returns a list of test module filenames.\"\"\"\n    matcher = compile_matcher(cfg.pathname_regex)\n    results = []\n    test_names = []\n    if cfg.unit_tests:\n        test_names.append('tests')\n    if cfg.functional_tests:\n        test_names.append('ftests')\n    baselen = len(cfg.basedir) + 1\n    def visit(ignored, dir, files):\n        if os.path.basename(dir) not in test_names:\n            for name in test_names:\n                if name + '.py' in files:\n                    path = os.path.join(dir, name + '.py')\n                    if matcher(path[baselen:]):\n                        results.append(path)\n            return\n        if '__init__.py' not in files:\n            stderr(\"%s is not a package\" % dir)\n            return\n        for file in files:\n            if file.startswith('test') and file.endswith('.py'):\n                path = os.path.join(dir, file)\n                if matcher(path[baselen:]):\n                    results.append(path)\n    if cfg.follow_symlinks:\n        walker = walk_with_symlinks\n    else:\n        walker = os.path.walk\n    walker(cfg.basedir, visit, None)\n    results.sort()\n    return results\n\n\ndef import_module(filename, cfg, cov=None):\n    \"\"\"Imports and returns a module.\"\"\"\n    filename = os.path.splitext(filename)[0]\n    modname = filename[len(cfg.basedir):].replace(os.path.sep, '.')\n    if modname.startswith('.'):\n        modname = modname[1:]\n    if cov is not None:\n        cov.start()\n    mod = __import__(modname)\n    if cov is not None:\n        cov.stop()\n    components = modname.split('.')\n    for comp in components[1:]:\n        mod = getattr(mod, comp)\n    return mod\n\n\ndef filter_testsuite(suite, matcher, level=None):\n    \"\"\"Returns a flattened list of test cases that match the given matcher.\"\"\"\n    if not isinstance(suite, unittest.TestSuite):\n        raise TypeError('not a TestSuite', suite)\n    results = []\n    for test in suite._tests:\n        if level is not None and getattr(test, 'level', 0) > level:\n            continue\n        if isinstance(test, unittest.TestCase):\n            testname = test.id() # package.module.class.method\n            if matcher(testname):\n                results.append(test)\n        else:\n            filtered = filter_testsuite(test, matcher, level)\n            results.extend(filtered)\n    return results\n\n\ndef get_all_test_cases(module):\n    \"\"\"Returns a list of all test case classes defined in a given module.\"\"\"\n    results = []\n    for name in dir(module):\n        if not name.startswith('Test'):\n            continue\n        item = getattr(module, name)\n        if (isinstance(item, (type, types.ClassType)) and\n            issubclass(item, unittest.TestCase)):\n            results.append(item)\n    return results\n\n\ndef get_test_classes_from_testsuite(suite):\n    \"\"\"Returns a set of test case classes used in a test suite.\"\"\"\n    if not isinstance(suite, unittest.TestSuite):\n        raise TypeError('not a TestSuite', suite)\n    results = set()\n    for test in suite._tests:\n        if isinstance(test, unittest.TestCase):\n            results.add(test.__class__)\n        else:\n            classes = get_test_classes_from_testsuite(test)\n            results.update(classes)\n    return results\n\n\ndef get_test_cases(test_files, cfg, cov=None):\n    \"\"\"Returns a list of test cases from a given list of test modules.\"\"\"\n    matcher = compile_matcher(cfg.test_regex)\n    results = []\n    for file in test_files:\n        module = import_module(file, cfg, cov=cov)\n        if cov is not None:\n            cov.start()\n        test_suite = module.test_suite()\n        if cov is not None:\n            cov.stop()\n        if test_suite is None:\n            continue\n        if cfg.warn_omitted:\n            all_classes = set(get_all_test_cases(module))\n            classes_in_suite = get_test_classes_from_testsuite(test_suite)\n            difference = all_classes - classes_in_suite\n            for test_class in difference:\n                # surround the warning with blank lines, otherwise it tends\n                # to get lost in the noise\n                stderr(\"\\n%s: WARNING: %s not in test suite\\n\"\n                                      % (file, test_class.__name__))\n        if (cfg.level is not None and\n            getattr(test_suite, 'level', 0) > cfg.level):\n            continue\n        filtered = filter_testsuite(test_suite, matcher, cfg.level)\n        results.extend(filtered)\n    return results\n\n\ndef get_test_hooks(test_files, cfg, cov=None):\n    \"\"\"Returns a list of test hooks from a given list of test modules.\"\"\"\n    results = []\n    dirs = set(map(os.path.dirname, test_files))\n    for dir in list(dirs):\n        if os.path.basename(dir) == 'ftests':\n            dirs.add(os.path.join(os.path.dirname(dir), 'tests'))\n    dirs = list(dirs)\n    dirs.sort()\n    for dir in dirs:\n        filename = os.path.join(dir, 'checks.py')\n        if os.path.exists(filename):\n            module = import_module(filename, cfg, tracer=tracer)\n            if cov is not None:\n                cov.start()\n            hooks = module.test_hooks()\n            if cov is not None:\n                cov.stop()\n            results.extend(hooks)\n    return results\n\n\nclass CustomTestResult(TextTestResult):\n    \"\"\"Customised TestResult.\n\n    It can show a progress bar, and displays tracebacks for errors and failures\n    as soon as they happen, in addition to listing them all at the end.\n    \"\"\"\n\n    __super = TextTestResult\n    __super_init = __super.__init__\n    __super_startTest = __super.startTest\n    __super_stopTest = __super.stopTest\n    __super_printErrors = __super.printErrors\n\n    def __init__(self, stream, descriptions, verbosity, count, cfg, hooks):\n        self.__super_init(stream, descriptions, verbosity)\n        self.count = count\n        self.cfg = cfg\n        self.hooks = hooks\n        if cfg.progress:\n            self.dots = False\n            self._lastWidth = 0\n            self._maxWidth = cfg.screen_width - len(\"xxxx/xxxx (xxx.x%): \") - 1\n\n    def startTest(self, test):\n        if self.cfg.progress:\n            # verbosity == 0: 'xxxx/xxxx (xxx.x%)'\n            # verbosity == 1: 'xxxx/xxxx (xxx.x%): test name'\n            # verbosity >= 2: 'xxxx/xxxx (xxx.x%): test name ... ok'\n            n = self.testsRun + 1\n            self.stream.write(\"\\r%4d\" % n)\n            if self.count:\n                self.stream.write(\"/%d (%5.1f%%)\"\n                                  % (self.count, n * 100.0 / self.count))\n            if self.showAll: # self.cfg.verbosity == 1\n                self.stream.write(\": \")\n            elif self.cfg.verbosity:\n                name = self.getShortDescription(test)\n                width = len(name)\n                if width < self._lastWidth:\n                    name += \" \" * (self._lastWidth - width)\n                self.stream.write(\": %s\" % name)\n                self._lastWidth = width\n            self.stream.flush()\n        self.__super_startTest(test)\n        for hook in self.hooks:\n            hook.startTest(test)\n\n    def stopTest(self, test):\n        for hook in self.hooks:\n            hook.stopTest(test)\n        self.__super_stopTest(test)\n\n    def getShortDescription(self, test):\n        s = self.getDescription(test)\n        if len(s) > self._maxWidth:\n            # s is 'testname (package.module.class)'\n            # try to shorten it to 'testname (...age.module.class)'\n            # if it is still too long, shorten it to 'testnam...'\n            # limit case is 'testname (...)'\n            pos = s.find(\" (\")\n            if pos + len(\" (...)\") > self._maxWidth:\n                s = s[:self._maxWidth - 3] + \"...\"\n            else:\n                s = \"%s...%s\" % (s[:pos + 2], s[pos + 5 - self._maxWidth:])\n        return s\n\n    def printErrors(self):\n        if self.cfg.progress and not (self.dots or self.showAll):\n            self.stream.writeln()\n        self.__super_printErrors()\n\n    def formatError(self, err):\n        return \"\".join(traceback.format_exception(*err))\n\n    def printTraceback(self, kind, test, err):\n        self.stream.writeln()\n        self.stream.writeln()\n        self.stream.writeln(\"%s: %s\" % (kind, test))\n        self.stream.writeln(self.formatError(err))\n        self.stream.writeln()\n\n    def addFailure(self, test, err):\n        if self.cfg.immediate_errors:\n            self.printTraceback(\"FAIL\", test, err)\n        self.failures.append((test, self.formatError(err)))\n\n    def addError(self, test, err):\n        if self.cfg.immediate_errors:\n            self.printTraceback(\"ERROR\", test, err)\n        self.errors.append((test, self.formatError(err)))\n\n\nclass CustomTestRunner(unittest.TextTestRunner):\n    \"\"\"Customised TestRunner.\n\n    See CustomisedTextResult for a list of extensions.\n    \"\"\"\n\n    __super = unittest.TextTestRunner\n    __super_init = __super.__init__\n    __super_run = __super.run\n\n    def __init__(self, cfg, hooks=None):\n        self.__super_init(verbosity=cfg.verbosity)\n        self.cfg = cfg\n        if hooks is not None:\n            self.hooks = hooks\n        else:\n            self.hooks = []\n\n    def run(self, test):\n        \"\"\"Run the given test case or test suite.\"\"\"\n        self.count = test.countTestCases()\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = float(stopTime - startTime)\n        result.printErrors()\n        run = result.testsRun\n        if not self.cfg.quiet:\n            self.stream.writeln(result.separator2)\n            self.stream.writeln(\"Ran %d test%s in %.3fs\" %\n                                (run, run != 1 and \"s\" or \"\", timeTaken))\n            self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write(\"FAILED (\")\n            failed, errored = list(map(len, (result.failures, result.errors)))\n            if failed:\n                self.stream.write(\"failures=%d\" % failed)\n            if errored:\n                if failed: self.stream.write(\", \")\n                self.stream.write(\"errors=%d\" % errored)\n            self.stream.writeln(\")\")\n        elif not self.cfg.quiet:\n            self.stream.writeln(\"OK\")\n        return result\n\n    def _makeResult(self):\n        return CustomTestResult(self.stream, self.descriptions, self.verbosity,\n                                cfg=self.cfg, count=self.count,\n                                hooks=self.hooks)\n\n\ndef main(argv):\n    \"\"\"Main program.\"\"\"\n\n    # Environment\n    if sys.version_info < (2, 7):\n        stderr('%s: need Python 2.7 or later' % argv[0])\n        stderr('your python is %s' % sys.version)\n        return 1\n\n    # Defaults\n    cfg = Options()\n    cfg.basedir = os.path.join(os.path.dirname(argv[0]), 'src')\n    cfg.basedir = os.path.abspath(cfg.basedir)\n\n    # Figure out terminal size\n    try:\n        import curses\n    except ImportError:\n        pass\n    else:\n        try:\n            curses.setupterm()\n            cols = curses.tigetnum('cols')\n            if cols > 0:\n                cfg.screen_width = cols\n        except (curses.error, TypeError):\n            # tigetnum() is broken in PyPy3 and raises TypeError\n            pass\n\n    # Option processing\n    opts, args = getopt.gnu_getopt(argv[1:], 'hvpqufw',\n                                   ['list-files', 'list-tests', 'list-hooks',\n                                    'level=', 'all-levels', 'coverage', 'no-src'])\n    for k, v in opts:\n        if k == '-h':\n            print(__doc__)\n            return 0\n        elif k == '-v':\n            cfg.verbosity += 1\n            cfg.quiet = False\n        elif k == '-p':\n            cfg.progress = True\n            cfg.quiet = False\n        elif k == '-q':\n            cfg.verbosity = 0\n            cfg.progress = False\n            cfg.quiet = True\n        elif k == '-u':\n            cfg.unit_tests = True\n        elif k == '-f':\n            cfg.functional_tests = True\n        elif k == '-w':\n            cfg.warn_omitted = True\n        elif k == '--list-files':\n            cfg.list_files = True\n            cfg.run_tests = False\n        elif k == '--list-tests':\n            cfg.list_tests = True\n            cfg.run_tests = False\n        elif k == '--list-hooks':\n            cfg.list_hooks = True\n            cfg.run_tests = False\n        elif k == '--coverage':\n            cfg.coverage = True\n        elif k == '--no-src':\n            cfg.src_in_path = False\n        elif k == '--level':\n            try:\n                cfg.level = int(v)\n            except ValueError:\n                stderr('%s: invalid level: %s' % (argv[0], v))\n                stderr('run %s -h for help')\n                return 1\n        elif k == '--all-levels':\n            cfg.level = None\n        else:\n            stderr('%s: invalid option: %s' % (argv[0], k))\n            stderr('run %s -h for help')\n            return 1\n    if args:\n        cfg.pathname_regex = args[0]\n    if len(args) > 1:\n        cfg.test_regex = args[1]\n    if len(args) > 2:\n        stderr('%s: too many arguments: %s' % (argv[0], args[2]))\n        stderr('run %s -h for help')\n        return 1\n    if not cfg.unit_tests and not cfg.functional_tests:\n        cfg.unit_tests = True\n\n    # Set up the python path\n    if cfg.src_in_path:\n        sys.path[0] = cfg.basedir\n\n    # Set up tracing before we start importing things\n    cov = None\n    if cfg.run_tests and cfg.coverage:\n        from coverage import Coverage\n        cov = Coverage(omit=['test.py'])\n\n    # Finding and importing\n    test_files = get_test_files(cfg)\n\n    if cov is not None:\n        cov.start()\n    if cfg.list_tests or cfg.run_tests:\n        test_cases = get_test_cases(test_files, cfg, cov=cov)\n    if cfg.list_hooks or cfg.run_tests:\n        test_hooks = get_test_hooks(test_files, cfg, cov=cov)\n\n    # Configure the logging module\n    import logging\n    logging.basicConfig()\n    logging.root.setLevel(logging.CRITICAL)\n\n    # Running\n    success = True\n    if cfg.list_files:\n        baselen = len(cfg.basedir) + 1\n        print(\"\\n\".join([fn[baselen:] for fn in test_files]))\n    if cfg.list_tests:\n        print(\"\\n\".join([test.id() for test in test_cases]))\n    if cfg.list_hooks:\n        print(\"\\n\".join([str(hook) for hook in test_hooks]))\n    if cfg.run_tests:\n        runner = CustomTestRunner(cfg, test_hooks)\n        suite = unittest.TestSuite()\n        suite.addTests(test_cases)\n        if cov is not None:\n            cov.start()\n        run_result = runner.run(suite)\n        if cov is not None:\n            cov.stop()\n        success = run_result.wasSuccessful()\n        del run_result\n\n    if cov is not None:\n        traced_file_types = ('.py', '.pyx', '.pxi', '.pxd')\n        modules = []\n\n        def add_file(_, path, files):\n            if 'tests' in os.path.relpath(path, cfg.basedir).split(os.sep):\n                return\n            for filename in files:\n                if filename.endswith(traced_file_types):\n                    modules.append(os.path.join(path, filename))\n\n        if cfg.follow_symlinks:\n            walker = walk_with_symlinks\n        else:\n            walker = os.path.walk\n        walker(os.path.abspath(cfg.basedir), add_file, None)\n\n        try:\n            cov.xml_report(modules, outfile='coverage.xml')\n            if cfg.coverdir:\n                cov.html_report(modules, directory=cfg.coverdir)\n        finally:\n            # test runs can take a while, so at least try to print something\n            cov.report()\n\n    # That's all\n    if success:\n        return 0\n    else:\n        return 1\n\n\nif __name__ == '__main__':\n    exitcode = main(sys.argv)\n    sys.exit(exitcode)\n", "tools/xpathgrep.py": "#!/usr/bin/env python\n\nimport sys\nimport os.path\n\ndef error(message, *args):\n    if args:\n        message = message % args\n    sys.stderr.write('ERROR: %s\\n' % message)\n\ntry:\n    import lxml.etree as et\nexcept ImportError:\n    error(sys.exc_info()[1])\n    sys.exit(5)\n\ntry:\n    basestring\nexcept NameError:\n    basestring = (str, bytes)\n\ntry:\n    unicode\nexcept NameError:\n    unicode = str\n\nSHORT_DESCRIPTION = \"An XPath file finder for XML files.\"\n\n__doc__ = SHORT_DESCRIPTION + '''\n\nEvaluates an XPath expression against a series of files and prints the\nmatching subtrees to stdout.\n\nExamples::\n\n  $ cat test.xml\n  <root>\n    <a num=\"1234\" notnum=\"1234abc\"/>\n    <b text=\"abc\"/>\n    <c text=\"aBc\"/>\n    <d xmlns=\"http://www.example.org/ns/example\" num=\"2\"/>\n    <d xmlns=\"http://www.example.org/ns/example\" num=\"4\"/>\n  </root>\n\n  # find all leaf elements:\n  $ SCRIPT '//*[not(*)]' test.xml\n  <a num=\"1234\" notnum=\"1234abc\"/>\n  <b text=\"abc\"/>\n  <c text=\"aBc\"/>\n\n  # find all elements with attribute values containing \"abc\" ignoring case:\n  $ SCRIPT '//*[@*[contains(py:lower(.), \"abc\")]]' test.xml\n  <a num=\"1234\" notnum=\"1234abc\"/>\n  <b text=\"abc\"/>\n  <c text=\"aBc\"/>\n\n  # find all numeric attribute values:\n  $ SCRIPT '//@*[re:match(., \"^[0-9]+$\")]' test.xml\n  1234\n\n  * find all elements with numeric attribute values:\n  $ SCRIPT '//*[@*[re:match(., \"^[0-9]+$\")]]' test.xml\n  <a num=\"1234\" notnum=\"1234abc\"/>\n\n  * find all elements with numeric attribute values in more than one file:\n  $ SCRIPT '//*[@*[re:match(., \"^[0-9]+$\")]]' test.xml test.xml test.xml\n  >> test.xml\n  <a num=\"1234\" notnum=\"1234abc\"/>\n  >> test.xml\n  <a num=\"1234\" notnum=\"1234abc\"/>\n  >> test.xml\n  <a num=\"1234\" notnum=\"1234abc\"/>\n\n  * find XML files that have non-empty root nodes:\n  $ SCRIPT -q '*' test.xml test.xml test.xml\n  >> test.xml\n  >> test.xml\n  >> test.xml\n\n  * find out if an XML file has at most depth three:\n  $ SCRIPT 'not(/*/*/*)' test.xml\n  True\n\n  * find all elements that belong to a specific namespace and have @num=2\n  $ SCRIPT --ns e=http://www.example.org/ns/example '//e:*[@num=\"2\"]' test.xml\n  <d xmlns=\"http://www.example.org/ns/example\" num=\"2\"/>\n\nBy default, all Python builtins and string methods are available as\nXPath functions through the ``py`` prefix.  There is also a string\ncomparison function ``py:within(x, a, b)`` that tests the string x for\nbeing lexicographically within the interval ``a <= x <= b``.\n'''.replace('SCRIPT', os.path.basename(sys.argv[0]))\n\nREGEXP_NS = \"http://exslt.org/regular-expressions\"\nPYTHON_BUILTINS_NS = \"PYTHON-BUILTINS\"\n\ndef make_parser(remove_blank_text=True, **kwargs):\n    return et.XMLParser(remove_blank_text=remove_blank_text, **kwargs)\n\ndef print_result(result, pretty_print, encoding=None, _is_py3=sys.version_info[0] >= 3):\n    stdout = sys.stdout\n    if not stdout.isatty() and not encoding:\n        encoding = 'utf8'\n    if et.iselement(result):\n        result = et.tostring(result, xml_declaration=False, with_tail=False,\n                             pretty_print=pretty_print, encoding=encoding)\n        if not pretty_print:\n            # pretty printing appends newline, otherwise we do it\n            if isinstance(result, unicode):\n                result += '\\n'\n            else:\n                result += '\\n'.encode('ascii')\n    elif isinstance(result, basestring):\n        result += '\\n'\n    else:\n        result = '%r\\n' % result # '%r' for better number formatting\n\n    if encoding and encoding != 'unicode' and isinstance(result, unicode):\n        result = result.encode(encoding)\n\n    if _is_py3 and not isinstance(result, unicode):\n        stdout.buffer.write(result)\n    else:\n        stdout.write(result)\n\ndef print_results(results, pretty_print):\n    if isinstance(results, list):\n        for result in results:\n            print_result(result, pretty_print)\n    else:\n        print_result(results, pretty_print)\n\ndef iter_input(input, filename, parser, line_by_line):\n    if isinstance(input, basestring):\n        with open(input, 'rb') as f:\n            for tree in iter_input(f, filename, parser, line_by_line):\n                yield tree\n    else:\n        try:\n            if line_by_line:\n                for line in input:\n                    if line:\n                        yield et.ElementTree(et.fromstring(line, parser))\n            else:\n                yield et.parse(input, parser)\n        except IOError:\n            e = sys.exc_info()[1]\n            error(\"parsing %r failed: %s: %s\",\n                  filename, e.__class__.__name__, e)\n\ndef find_in_file(f, xpath, print_name=True, xinclude=False, pretty_print=True, line_by_line=False,\n                 encoding=None, verbose=True):\n    try:\n        filename = f.name\n    except AttributeError:\n        filename = f\n\n    xml_parser = et.XMLParser(encoding=encoding)\n\n    try:\n        if not callable(xpath):\n            xpath = et.XPath(xpath)\n\n        found = False\n        for tree in iter_input(f, filename, xml_parser, line_by_line):\n            try:\n                if xinclude:\n                    tree.xinclude()\n            except IOError:\n                e = sys.exc_info()[1]\n                error(\"XInclude for %r failed: %s: %s\",\n                      filename, e.__class__.__name__, e)\n\n            results = xpath(tree)\n            if results is not None and results != []:\n                found = True\n                if verbose:\n                    print_results(results, pretty_print)\n\n        if not found:\n            return False\n        if not verbose and print_name:\n            print(filename)\n        return True\n    except Exception:\n        e = sys.exc_info()[1]\n        error(\"%r: %s: %s\",\n              filename, e.__class__.__name__, e)\n        return False\n\ndef register_builtins():\n    ns = et.FunctionNamespace(PYTHON_BUILTINS_NS)\n    tostring = et.tostring\n\n    def make_string(s):\n        if isinstance(s, list):\n            if not s:\n                return ''\n            s = s[0]\n        if not isinstance(s, unicode):\n            if et.iselement(s):\n                s = tostring(s, method=\"text\", encoding='unicode')\n            else:\n                s = unicode(s)\n        return s\n\n    def wrap_builtin(b):\n        def wrapped_builtin(_, *args):\n            return b(*args)\n        return wrapped_builtin\n\n    for (name, builtin) in vars(__builtins__).items():\n        if callable(builtin):\n            if not name.startswith('_') and name == name.lower():\n                ns[name] = wrap_builtin(builtin)\n\n    def wrap_str_method(b):\n        def wrapped_method(_, *args):\n            args = tuple(map(make_string, args))\n            return b(*args)\n        return wrapped_method\n\n    for (name, method) in vars(unicode).items():\n        if callable(method):\n            if not name.startswith('_'):\n                ns[name] = wrap_str_method(method)\n\n    def within(_, s, a, b):\n        return make_string(a) <= make_string(s) <= make_string(b)\n    ns[\"within\"] = within\n\n\ndef parse_options():\n    from optparse import OptionParser\n\n    usage = \"usage: %prog [options] XPATH [FILE ...]\"\n\n    parser = OptionParser(\n        usage       = usage,\n        version     = \"%prog using lxml.etree \" + et.__version__,\n        description = SHORT_DESCRIPTION)\n    parser.add_option(\"-H\", \"--long-help\",\n                      action=\"store_true\", dest=\"long_help\", default=False,\n                      help=\"a longer help text including usage examples\")\n    parser.add_option(\"-i\", \"--xinclude\",\n                      action=\"store_true\", dest=\"xinclude\", default=False,\n                      help=\"run XInclude on the file before XPath\")\n    parser.add_option(\"--no-python\", \n                      action=\"store_false\", dest=\"python\", default=True,\n                      help=\"disable Python builtins and functions (prefix 'py')\")\n    parser.add_option(\"--no-regexp\", \n                      action=\"store_false\", dest=\"regexp\", default=True,\n                      help=\"disable regular expressions (prefix 're')\")\n    parser.add_option(\"-q\", \"--quiet\",\n                      action=\"store_false\", dest=\"verbose\", default=True,\n                      help=\"don't print status messages to stdout\")\n    parser.add_option(\"-t\", \"--root-tag\",\n                      dest=\"root_tag\", metavar=\"TAG\",\n                      help=\"surround output with <TAG>...</TAG> to produce a well-formed XML document\")\n    parser.add_option(\"-p\", \"--plain\",\n                      action=\"store_false\", dest=\"pretty_print\", default=True,\n                      help=\"do not pretty-print the output\")\n    parser.add_option(\"-l\", \"--lines\",\n                      action=\"store_true\", dest=\"line_by_line\", default=False,\n                      help=\"parse each line of input separately (e.g. grep output)\")\n    parser.add_option(\"-e\", \"--encoding\",\n                      dest=\"encoding\",\n                      help=\"use a specific encoding for parsing (may be required with --lines)\")\n    parser.add_option(\"-N\", \"--ns\", metavar=\"PREFIX=NS\",\n                      action=\"append\", dest=\"namespaces\", default=[],\n                      help=\"add a namespace declaration\")\n\n    options, args = parser.parse_args()\n\n    if options.long_help:\n        parser.print_help()\n        print(__doc__[__doc__.find('\\n\\n')+1:])\n        sys.exit(0)\n\n    if len(args) < 1:\n        parser.error(\"first argument must be an XPath expression\")\n\n    return options, args\n\n\ndef main(options, args):\n    namespaces = {}\n    if options.regexp:\n        namespaces[\"re\"] = REGEXP_NS\n    if options.python:\n        register_builtins()\n        namespaces[\"py\"] = PYTHON_BUILTINS_NS\n\n    for ns in options.namespaces:\n        prefix, NS = ns.split(\"=\", 1)\n        namespaces[prefix.strip()] = NS.strip()\n\n    xpath = et.XPath(args[0], namespaces=namespaces)\n    files = args[1:] or [sys.stdin]\n\n    if options.root_tag and options.verbose:\n        print('<%s>' % options.root_tag)\n\n    found = False\n    print_name = len(files) > 1 and not options.root_tag\n    for input in files:\n        found |= find_in_file(\n            input, xpath,\n            print_name=print_name,\n            xinclude=options.xinclude,\n            pretty_print=options.pretty_print,\n            line_by_line=options.line_by_line,\n            encoding=options.encoding,\n            verbose=options.verbose,\n        )\n\n    if options.root_tag and options.verbose:\n        print('</%s>' % options.root_tag)\n\n    return found\n\nif __name__ == \"__main__\":\n    try:\n        options, args = parse_options()\n        found = main(options, args)\n        if found:\n            sys.exit(0)\n        else:\n            sys.exit(1)\n    except et.XPathSyntaxError:\n        error(sys.exc_info()[1])\n        sys.exit(4)\n    except KeyboardInterrupt:\n        pass\n", "tools/pypistats.py": "#!/usr/bin/env python3\nimport json\nfrom collections import defaultdict\nfrom urllib.request import urlopen\nimport ssl\n\nPACKAGE = \"lxml\"\n\n\ndef get_stats(stats_type, package=PACKAGE, period=\"month\"):\n    stats_url = f\"https://www.pypistats.org/api/packages/{package}/{stats_type}?period={period}\"\n\n    ctx = ssl.create_default_context()\n    ctx.check_hostname = False\n    ctx.verify_mode = ssl.CERT_NONE\n\n    with urlopen(stats_url, context=ctx) as stats:\n        data = json.load(stats)\n    return data\n\n\ndef aggregate(stats):\n    counts = defaultdict(int)\n    days = defaultdict(int)\n    for entry in stats['data']:\n        category = entry['category']\n        counts[category] += entry['downloads']\n        days[category] += 1\n    return {category: counts[category] / days[category] for category in counts}\n\n\ndef version_sorter(version_and_count):\n    version = version_and_count[0]\n    return tuple(map(int, version.split(\".\"))) if version.replace(\".\", \"\").isdigit() else (2**32,)\n\n\ndef system_sorter(name_and_count):\n    order = ('linux', 'windows', 'darwin')\n    system = name_and_count[0]\n    try:\n        return order.index(system.lower())\n    except ValueError:\n        return len(order)\n\n\ndef print_agg_stats(stats, sort_key=None):\n    total = sum(stats.values())\n    max_len = max(len(category) for category in stats)\n    agg_sum = 0.0\n    for category, count in sorted(stats.items(), key=sort_key, reverse=True):\n        agg_sum += count\n        print(f\"  {category:{max_len}}: {count:-12.1f} / day ({agg_sum / total * 100:-5.1f}%)\")\n\n\ndef main():\n    import sys\n    package_name = sys.argv[1] if len(sys.argv) > 1 else PACKAGE\n\n    counts = get_stats(\"python_minor\", package=package_name)\n    stats = aggregate(counts)\n    print(\"Downloads by Python version:\")\n    print_agg_stats(stats, sort_key=version_sorter)\n\n    print()\n    counts = get_stats(\"system\", package=package_name)\n    stats = aggregate(counts)\n    print(\"Downloads by system:\")\n    print_agg_stats(stats, sort_key=system_sorter)\n\n    total = sum(stats.values())\n    days = {\"month\": 30, \"week\": 7, \"day\": 1}\n    print(f\"Total downloads: {total * days['month']:-12,.1f}\")\n\n\nif __name__ == '__main__':\n    main()\n", "doc/mklatex.py": "# The script builds the LaTeX documentation.\n# Testing:\n#    python mklatex.py latex .. 1.0\n\nfrom docstructure import SITE_STRUCTURE, BASENAME_MAP\nimport os, shutil, re, sys, datetime\n\nTARGET_FILE = \"lxmldoc.tex\"\n\nRST2LATEX_OPTIONS = \" \".join([\n#    \"--no-toc-backlinks\",\n    \"--strip-comments\",\n    \"--language en\",\n#    \"--date\",\n#    \"--use-latex-footnotes\",\n    \"--use-latex-citations\",\n    \"--use-latex-toc\",\n    \"--font-encoding=T1\",\n    \"--output-encoding=utf-8\",\n    \"--input-encoding=utf-8\",\n    \"--graphicx-option=pdftex\",\n    ])\n\nhtmlnsmap = {\"h\" : \"http://www.w3.org/1999/xhtml\"}\n\nreplace_invalid = re.compile(r'[-_/.\\s\\\\]').sub\nreplace_content = re.compile(r\"\\{[^\\}]*\\}\").sub\n\nreplace_epydoc_macros = re.compile(r'(,\\s*amssymb|dvips\\s*,\\s*)').sub\nreplace_rst_macros = re.compile(r'(\\\\usepackage\\{color}|\\\\usepackage\\[[^]]*]\\{hyperref})').sub\n\nBASENAME_MAP = BASENAME_MAP.copy()\nBASENAME_MAP.update({'api' : 'lxmlapi'})\n\n# LaTeX snippets\n\nDOCUMENT_CLASS = r\"\"\"\n\\documentclass[10pt,english]{report}\n\\usepackage[a4paper]{geometry}\n\\usepackage{tabularx}\n\\usepackage{ifthen}\n\\usepackage[pdftex]{graphicx}\n\\parindent0pt\n\\parskip1ex\n\n%%% Fallback definitions for Docutils-specific commands\n\n% providelength (provide a length variable and set default, if it is new)\n\\providecommand*{\\DUprovidelength}[2]{\n  \\ifthenelse{\\isundefined{#1}}{\\newlength{#1}\\setlength{#1}{#2}}{}\n}\n\n% docinfo (width of docinfo table)\n\\DUprovidelength{\\DUdocinfowidth}{0.9\\textwidth}\n\n% titlereference role\n\\providecommand*{\\DUroletitlereference}[1]{\\textsl{#1}}\n\n\"\"\"\n\nPYGMENTS_IMPORT = r\"\"\"\n\\usepackage{fancyvrb}\n\\input{_part_pygments.tex}\n\"\"\"\n\nEPYDOC_IMPORT = r\"\"\"\n\\input{_part_epydoc.tex}\n\"\"\"\n\ndef write_chapter(master, title, filename):\n    filename = os.path.join(os.path.dirname(filename),\n                            \"_part_%s\" % os.path.basename(filename))\n    master.write(r\"\"\"\n\\chapter{%s}\n\\label{%s}\n\\input{%s}\n\"\"\" % (title, filename, filename))\n\n\n# the program ----\n\ndef rest2latex(script, source_path, dest_path):\n    command = ('%s %s %s  %s > %s' %\n               (sys.executable, script, RST2LATEX_OPTIONS,\n                source_path, dest_path))\n    os.system(command)\n\ndef build_pygments_macros(filename):\n    from pygments.formatters import LatexFormatter\n    text = LatexFormatter().get_style_defs()\n    with open(filename, \"w\") as f:\n        f.write(text)\n        f.write('\\n')\n\ndef copy_epydoc_macros(src, dest, existing_header_lines):\n    doc = open(src, 'r')\n    out = open(dest, \"w\")\n    for line in doc:\n        if line.startswith('%% generator') \\\n                or line.startswith('% generated by ') \\\n                or '\\\\begin{document}' in line \\\n                or '\\\\makeindex' in line:\n            break\n        if line.startswith('%') or \\\n                r'\\documentclass' in line or \\\n                r'\\makeindex' in line or \\\n                r'{inputenc}' in line:\n            continue\n        if line.startswith(r'\\usepackage'):\n            if line in existing_header_lines:\n                continue\n            if '{hyperref}' in line:\n                line = line.replace('black', 'blue')\n        out.write( replace_epydoc_macros('', line) )\n    out.close()\n    doc.close()\n\ndef noop(input):\n    return input\n\ncounter_no = 0\n\ndef tex_postprocess(src_path, dest_path, want_header=False, process_line=noop):\n    \"\"\"\n    Postprocessing of the LaTeX file generated from ReST.\n\n    Reads file src_path and saves to dest_path only the true content\n    (without the document header and final) - so it is suitable\n    to be used as part of the longer document.\n\n    Returns the title of document\n\n    If want_header is set, returns also the document header (as\n    the list of lines).\n    \"\"\"\n    header = []\n    add_header_line = header.append\n    global counter_no\n    counter_no = counter_no + 1\n    counter_text = \"listcnt%d\" % counter_no\n\n    search_title = re.compile(r'\\\\title{([^{}]*(?:{[^}]*})*)}').search\n    skipping = re.compile(r'(\\\\end{document}|\\\\tableofcontents|^%)').search\n\n    with open(src_path) as src:\n        src_text = src.read()\n\n    dest = open(dest_path, \"w\")\n\n    title = search_title(src_text)\n    if title:\n        # remove any commands from the title\n        title = re.sub(r'\\\\\\w+({[^}]*})?', '', title.group(1))\n\n    iter_lines = iter(src_text.splitlines())\n    for l in iter_lines:\n        l = process_line(l)\n        if not l:\n            continue\n        if want_header:\n            add_header_line(replace_rst_macros('', l))\n        if l.startswith(\"\\\\maketitle\"):\n            break\n\n    for l in iter_lines:\n        l = process_line(l)\n        if skipping(l):\n            # To-Do minitoc instead of tableofcontents\n            continue\n        elif r\"\\hypertarget{old-versions}\" in l:\n            break\n        elif \"listcnt0\" in l:\n            l = l.replace(\"listcnt0\", counter_text)\n        dest.write(l + '\\n')\n\n    dest.close()\n\n    if not title:\n        raise Exception(\"Bueee, no title in %s\" % src_path)\n    return title, header\n\ndef publish(dirname, lxml_path, release):\n    if not os.path.exists(dirname):\n        os.mkdir(dirname)\n\n    book_title = \"lxml %s\" % release\n\n    doc_dir = os.path.join(lxml_path, 'doc')\n    script = os.path.join(doc_dir, 'rest2latex.py')\n    pubkey = os.path.join(doc_dir, 'pubkey.asc')\n\n    shutil.copy(pubkey, dirname)\n\n    # build pygments macros\n    build_pygments_macros(os.path.join(dirname, '_part_pygments.tex'))\n\n    # Used in postprocessing of generated LaTeX files\n    header = []\n    titles = {}\n\n    replace_interdoc_hyperrefs = re.compile(\n        r'\\\\href\\{([^/}]+)[.]([^./}]+)\\}').sub\n    replace_docinternal_hyperrefs = re.compile(\n        r'\\\\href\\{\\\\#([^}]+)\\}').sub\n    replace_image_paths = re.compile(\n        r'^(\\\\includegraphics{)').sub\n    def build_hyperref(match):\n        basename, extension = match.groups()\n        outname = BASENAME_MAP.get(basename, basename)\n        if '#' in extension:\n            anchor = extension.split('#')[-1]\n            return r\"\\hyperref[%s]\" % anchor\n        elif extension != 'html':\n            return r'\\href{https://lxml.de/%s.%s}' % (\n                outname, extension)\n        else:\n            return r\"\\hyperref[_part_%s.tex]\" % outname\n    def fix_relative_hyperrefs(line):\n        line = replace_image_paths(r'\\1../html/', line)\n        if r'\\href' not in line:\n            return line\n        line = replace_interdoc_hyperrefs(build_hyperref, line)\n        return replace_docinternal_hyperrefs(r'\\\\hyperref[\\1]', line)\n\n    # Building pages\n    for section, text_files in SITE_STRUCTURE:\n        for filename in text_files:\n            if filename.startswith('@'):\n                continue\n                #page_title = filename[1:]\n                #url = href_map[page_title]\n                #build_menu_entry(page_title, url, section_head)\n\n            basename = os.path.splitext(os.path.basename(filename))[0]\n            basename = BASENAME_MAP.get(basename, basename)\n            outname = basename + '.tex'\n            outpath = os.path.join(dirname, outname)\n            path = os.path.join(doc_dir, filename)\n\n            print(\"Creating %s\" % outname)\n            rest2latex(script, path, outpath)\n\n            final_name = os.path.join(dirname, os.path.dirname(outname),\n                                      \"_part_%s\" % os.path.basename(outname))\n\n            title, hd = tex_postprocess(outpath, final_name,\n                                        want_header = not header,\n                                        process_line=fix_relative_hyperrefs)\n            if not header:\n                header = hd\n            titles[outname] = title\n\n    # integrate generated API docs\n\n    print(\"Integrating API docs\")\n    apidocsname = 'lxmlapi.tex'\n    apipath = os.path.join(dirname, apidocsname)\n    tex_postprocess(apipath, os.path.join(dirname, \"_part_%s\" % apidocsname),\n                    process_line=fix_relative_hyperrefs)\n    copy_epydoc_macros(apipath, os.path.join(dirname, '_part_epydoc.tex'),\n                       set(header))\n\n    # convert CHANGES.txt\n\n    print(\"Integrating ChangeLog\")\n    find_version_title = re.compile(\n        r'(.*\\\\section\\{)([0-9][^\\} ]*)\\s+\\(([^)]+)\\)(\\}.*)').search\n    def fix_changelog(line):\n        m = find_version_title(line)\n        if m:\n            line = \"%sChanges in version %s, released %s%s\" % m.groups()\n        else:\n            line = line.replace(r'\\subsection{', r'\\subsection*{')\n        return line\n\n    chgname = 'changes-%s.tex' % release\n    chgpath = os.path.join(dirname, chgname)\n    rest2latex(script,\n               os.path.join(lxml_path, 'CHANGES.txt'),\n               chgpath)\n    tex_postprocess(chgpath, os.path.join(dirname, \"_part_%s\" % chgname),\n                    process_line=fix_changelog)\n\n    # Writing a master file\n    print(\"Building %s\\n\" % TARGET_FILE)\n    master = open( os.path.join(dirname, TARGET_FILE), \"w\")\n    for hln in header:\n        if hln.startswith(r\"\\documentclass\"):\n            #hln = hln.replace('article', 'book')\n            hln = DOCUMENT_CLASS + EPYDOC_IMPORT\n        elif hln.startswith(r\"\\begin{document}\"):\n            # pygments and epydoc support\n            master.write(PYGMENTS_IMPORT)\n        elif hln.startswith(r\"\\title{\"):\n            hln = replace_content(\n                r'{%s\\\\\\\\\\\\vspace{1cm}\\\\includegraphics[width=2.5cm]{../html/tagpython-big.png}}' % book_title, hln)\n        elif hln.startswith(r\"\\date{\"):\n            hln = replace_content(\n                r'{%s}' % datetime.date.today().isoformat(), hln)\n        elif hln.startswith(\"pdftitle\"):\n            hln = replace_content(\n                r'{%s}' % book_title, hln)\n        master.write(hln + '\\n')\n\n    master.write(\"\\\\setcounter{page}{2}\\n\")\n    master.write(\"\\\\tableofcontents\\n\")\n\n    for section, text_files in SITE_STRUCTURE:\n        master.write(\"\\n\\n\\\\part{%s}\\n\" % section)\n        for filename in text_files:\n            if filename.startswith('@'):\n                continue\n                #print \"Not yet implemented: %s\" % filename[1:]\n                #page_title = filename[1:]\n                #url = href_map[page_title]\n                #build_menu_entry(page_title, url, section_head)\n            else:\n                basename = os.path.splitext(os.path.basename(filename))[0]\n                basename = BASENAME_MAP.get(basename, basename)\n                outname = basename + '.tex'\n            write_chapter(master, titles[outname], outname)\n\n    master.write(\"\\\\appendix\\n\")\n    master.write(\"\\\\begin{appendix}\\n\")\n\n    write_chapter(master, \"Changes\", chgname)\n    write_chapter(master, \"Generated API documentation\", apidocsname)\n\n    master.write(\"\\\\end{appendix}\\n\")\n    master.write(\"\\\\end{document}\\n\")\n                \n\nif __name__ == '__main__':\n    publish(sys.argv[1], sys.argv[2], sys.argv[3])\n", "doc/docstructure.py": "\nimport os\n\nif os.path.exists(os.path.join(os.path.dirname(__file__), '..', 'funding.txt')):\n    funding = ('../funding.txt',)\nelse:\n    funding = ()\n\nSITE_STRUCTURE = [\n    ('lxml', ('main.txt', 'intro.txt', '../INSTALL.txt', # 'lxml2.txt',\n              'performance.txt', 'compatibility.txt', 'FAQ.txt') + funding),\n    ('Developing with lxml', ('tutorial.txt', '@API reference',\n                              'api.txt', 'parsing.txt',\n                              'validation.txt', 'xpathxslt.txt',\n                              'objectify.txt', 'lxmlhtml.txt',\n                              'cssselect.txt', 'elementsoup.txt',\n                              'html5parser.txt')),\n    ('Extending lxml', ('resolvers.txt', 'extensions.txt',\n                        'element_classes.txt', 'sax.txt', 'capi.txt')),\n    ('Developing lxml', ('build.txt', 'lxml-source-howto.txt',\n                         '@Release Changelog', '../CREDITS.txt')),\n    ]\n\nHREF_MAP = {\n    \"API reference\" : \"apidoc/lxml.html\"\n}\n\nBASENAME_MAP = {\n    'main' : 'index',\n    'INSTALL' : 'installation',\n    'CREDITS' : 'credits',\n}\n", "doc/rest2html.py": "#!/usr/bin/python\n\n\"\"\"\nA minimal front end to the Docutils Publisher, producing HTML with\nPygments syntax highlighting.\n\"\"\"\n\n# Set to True if you want inline CSS styles instead of classes\nINLINESTYLES = False\n\n\ntry:\n    import locale\n    locale.setlocale(locale.LC_ALL, '')\nexcept:\n    pass\n\n# set up Pygments\n\nfrom pygments.formatters import HtmlFormatter\n\n# The default formatter\nDEFAULT = HtmlFormatter(noclasses=INLINESTYLES, cssclass='syntax')\n\n# Add name -> formatter pairs for every variant you want to use\nVARIANTS = {\n    # 'linenos': HtmlFormatter(noclasses=INLINESTYLES, linenos=True),\n}\n\n\nfrom docutils import nodes\nfrom docutils.parsers.rst import directives\n\nfrom pygments import highlight\nfrom pygments.lexers import get_lexer_by_name, TextLexer\n\ndef pygments_directive(name, arguments, options, content, lineno,\n                       content_offset, block_text, state, state_machine):\n    try:\n        lexer = get_lexer_by_name(arguments[0])\n    except ValueError:\n        # no lexer found - use the text one instead of an exception\n        lexer = TextLexer()\n    # take an arbitrary option if more than one is given\n    formatter = options and VARIANTS[options.keys()[0]] or DEFAULT\n    parsed = highlight(u'\\n'.join(content), lexer, formatter)\n    return [nodes.raw('', parsed, format='html')]\n\npygments_directive.arguments = (1, 0, 1)\npygments_directive.content = 1\npygments_directive.options = dict([(key, directives.flag) for key in VARIANTS])\n\ndirectives.register_directive('sourcecode', pygments_directive)\n\n\n# run the generation\n\nfrom docutils.core import publish_cmdline, default_description\n\ndescription = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\n\npublish_cmdline(writer_name='html', description=description)\n", "doc/mkhtml.py": "from __future__ import absolute_import\n\nfrom docstructure import SITE_STRUCTURE, HREF_MAP, BASENAME_MAP\nfrom lxml.etree import (parse, fromstring, ElementTree,\n                        Element, SubElement, XPath, XML)\nimport glob\nimport hashlib\nimport os\nimport re\nimport sys\nimport copy\nimport shutil\nimport textwrap\nimport subprocess\n\nfrom io import open as open_file\n\nRST2HTML_OPTIONS = \" \".join([\n    '--no-toc-backlinks',\n    '--strip-comments',\n    '--language en',\n    '--date',\n    ])\n\nXHTML_NS = 'http://www.w3.org/1999/xhtml'\nhtmlnsmap = {\"h\": XHTML_NS}\n\nfind_head = XPath(\"/h:html/h:head[1]\", namespaces=htmlnsmap)\nfind_body = XPath(\"/h:html/h:body[1]\", namespaces=htmlnsmap)\nfind_title = XPath(\"/h:html/h:head/h:title/text()\", namespaces=htmlnsmap)\nfind_title_tag = XPath(\"/h:html/h:head/h:title\", namespaces=htmlnsmap)\nfind_headings = XPath(\"//h:h1[not(@class)]//text()\", namespaces=htmlnsmap)\nfind_heading_tag = XPath(\"//h:h1[@class = 'title'][1]\", namespaces=htmlnsmap)\nfind_menu = XPath(\"//h:ul[@id=$name]\", namespaces=htmlnsmap)\nfind_page_end = XPath(\"/h:html/h:body/h:div[last()]\", namespaces=htmlnsmap)\n\nfind_words = re.compile(r'(\\w+)').findall\nreplace_invalid = re.compile(r'[-_/.\\s\\\\]').sub\n\n\ndef make_menu_section_head(section, menuroot):\n    section_id = section + '-section'\n    section_head = menuroot.xpath(\"//ul[@id=$section]/li\", section=section_id)\n    if not section_head:\n        ul = SubElement(menuroot, \"ul\", id=section_id)\n        section_head = SubElement(ul, \"li\")\n        title = SubElement(section_head, \"span\", {\"class\":\"section title\"})\n        title.text = section\n    else:\n        section_head = section_head[0]\n    return section_head\n\n\ndef build_menu(tree, basename, section_head):\n    page_title = find_title(tree)\n    if page_title:\n        page_title = page_title[0]\n    else:\n        page_title = replace_invalid('', basename.capitalize())\n    build_menu_entry(page_title, basename+\".html\", section_head,\n                     headings=find_headings(tree))\n\n\ndef build_menu_entry(page_title, url, section_head, headings=None):\n    page_id = replace_invalid(' ', os.path.splitext(url)[0]) + '-menu'\n    ul = SubElement(section_head, \"ul\", {\"class\":\"menu foreign\", \"id\":page_id})\n\n    title = SubElement(ul, \"li\", {\"class\":\"menu title\"})\n    a = SubElement(title, \"a\", href=url)\n    a.text = page_title\n\n    if headings:\n        subul = SubElement(title, \"ul\", {\"class\":\"submenu\"})\n        for heading in headings:\n            li = SubElement(subul, \"li\", {\"class\":\"menu item\"})\n            try:\n                ref = heading.getparent().getparent().get('id')\n            except AttributeError:\n                ref = None\n            if ref is None:\n                ref = '-'.join(find_words(replace_invalid(' ', heading.lower())))\n            a = SubElement(li, \"a\", href=url+'#'+ref)\n            a.text = heading\n\n\ndef merge_menu(tree, menu, name):\n    menu_root = copy.deepcopy(menu)\n    tree.getroot()[1][0].insert(0, menu_root)  # html->body->div[class=document]\n    for el in menu_root.iter():\n        tag = el.tag\n        if tag[0] != '{':\n            el.tag = \"{http://www.w3.org/1999/xhtml}\" + tag\n    current_menu = find_menu(\n        menu_root, name=replace_invalid(' ', name) + '-menu')\n    if not current_menu:\n        current_menu = find_menu(\n            menu_root, name=replace_invalid('-', name) + '-menu')\n    if current_menu:\n        for submenu in current_menu:\n            submenu.set(\"class\", submenu.get(\"class\", \"\").\n                        replace(\"foreign\", \"current\"))\n    return tree\n\n\ndef inject_flatter_button(tree):\n    head = tree.xpath('h:head[1]', namespaces=htmlnsmap)[0]\n    script = SubElement(head, '{%s}script' % XHTML_NS, type='text/javascript')\n    script.text = \"\"\"\n    (function() {\n        var s = document.createElement('script');\n        var t = document.getElementsByTagName('script')[0];\n        s.type = 'text/javascript';\n        s.async = true;\n        s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';\n        t.parentNode.insertBefore(s, t);\n    })();\n\"\"\"\n    script.tail = '\\n'\n    intro_div = tree.xpath('h:body//h:div[@id = \"introduction\"][1]', namespaces=htmlnsmap)[0]\n    intro_div.insert(-1, XML(\n        '<p style=\"text-align: center;\">Like working with lxml? '\n        'Happy about the time that it just saved you? <br />'\n        'Show your appreciation with <a href=\"http://flattr.com/thing/268156/lxml-The-Python-XML-Toolkit\">Flattr</a>.<br />'\n        '<a class=\"FlattrButton\" style=\"display:none;\" rev=\"flattr;button:compact;\" href=\"https://lxml.de/\"></a>'\n        '</p>'\n        ))\n\n\ndef inject_donate_buttons(lxml_path, rst2html_script, tree):\n    command = ([sys.executable, rst2html_script]\n               + RST2HTML_OPTIONS.split() + [os.path.join(lxml_path, 'README.rst')])\n    rst2html = subprocess.Popen(command, stdout=subprocess.PIPE)\n    stdout, _ = rst2html.communicate()\n    readme = fromstring(stdout)\n\n    intro_div = tree.xpath('h:body//h:div[@id = \"introduction\"][1]',\n                           namespaces=htmlnsmap)[0]\n    support_div = readme.xpath('h:body//h:div[@id = \"support-the-project\"][1]',\n                               namespaces=htmlnsmap)[0]\n    intro_div.append(support_div)\n\n    finance_div = readme.xpath('h:body//h:div[@id = \"project-income-report\"][1]',\n                               namespaces=htmlnsmap)[0]\n    legal = readme.xpath('h:body//h:div[@id = \"legal-notice-for-donations\"][1]',\n                         namespaces=htmlnsmap)[0]\n    last_div = tree.xpath('h:body//h:div//h:div', namespaces=htmlnsmap)[-1]\n    last_div.addnext(finance_div)\n    finance_div.addnext(legal)\n\n\ndef inject_banner(parent):\n    banner = parent.makeelement('div', {'class': 'banner'})\n    parent.insert(0, banner)\n\n    banner_image = SubElement(banner, 'div', {'class': \"banner_image\"})\n    SubElement(banner_image, 'img', src=\"python-xml-title.png\")\n\n    banner_text = SubElement(banner, 'div', {'class': \"banner_link\"})\n    banner_link = SubElement(banner_text, 'a', href=\"index.html#support-the-project\")\n    banner_link.text = \"Like the tool? \"\n    SubElement(banner_link, 'br', {'class': \"first\"}).tail = \"Help making it better! \"\n    SubElement(banner_link, 'br', {'class': \"second\"}).tail = \"Your donation helps!\"\n\n\ndef rest2html(script, source_path, dest_path, stylesheet_url):\n    command = ('%s %s %s --stylesheet=%s --link-stylesheet %s > %s' %\n               (sys.executable, script, RST2HTML_OPTIONS,\n                stylesheet_url, source_path, dest_path))\n    subprocess.call(command, shell=True)\n\n\ndef convert_changelog(lxml_path, changelog_file_path, rst2html_script, stylesheet_url):\n    f = open_file(os.path.join(lxml_path, 'CHANGES.txt'), 'r', encoding='utf-8')\n    try:\n        content = f.read()\n    finally:\n        f.close()\n\n    links = dict(LP='`%s <https://bugs.launchpad.net/lxml/+bug/%s>`_',\n                 GH='`%s <https://github.com/lxml/lxml/issues/%s>`_')\n    replace_tracker_links = re.compile('((LP|GH)#([0-9]+))').sub\n    def insert_link(match):\n        text, ref_type, ref_id = match.groups()\n        return links[ref_type] % (text, ref_id)\n    content = replace_tracker_links(insert_link, content)\n\n    command = [sys.executable, rst2html_script] + RST2HTML_OPTIONS.split() + [\n        '--link-stylesheet', '--stylesheet', stylesheet_url ]\n    out_file = open(changelog_file_path, 'wb')\n    try:\n        rst2html = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=out_file)\n        rst2html.communicate(content.encode('utf8'))\n    finally:\n        out_file.close()\n\n\ndef publish(dirname, lxml_path, release, with_donations=True):\n    if not os.path.exists(dirname):\n        os.mkdir(dirname)\n\n    doc_dir = os.path.join(lxml_path, 'doc')\n    script = os.path.join(doc_dir, 'rest2html.py')\n    pubkey = os.path.join(doc_dir, 'pubkey.asc')\n    stylesheet_file = 'style.css'\n\n    shutil.copy(pubkey, dirname)\n    # FIXME: find a way to make hashed filenames work both locally and in the versioned directories.\n    stylesheet_url = stylesheet_file\n    \"\"\"\n    style_file_pattern = \"style_%s.css\"\n    for old_stylesheet in glob.iglob(os.path.join(dirname, style_file_pattern % \"*\")):\n        os.unlink(old_stylesheet)\n    with open(os.path.join(dirname, stylesheet_file), 'rb') as f:\n        css = f.read()\n        checksum = hashlib.sha256(css).hexdigest()[:32]\n\n        stylesheet_url = style_file_pattern % checksum\n        with open(os.path.join(dirname, stylesheet_url), 'wb') as out:\n            out.write(css)\n    \"\"\"\n\n    href_map = HREF_MAP.copy()\n    changelog_basename = 'changes-%s' % release\n    href_map['Release Changelog'] = changelog_basename + '.html'\n\n    menu_js = textwrap.dedent('''\n    function trigger_menu(event) {\n        var sidemenu = document.getElementById(\"sidemenu\");\n        var classes = sidemenu.getAttribute(\"class\");\n        classes = (classes.indexOf(\" visible\") === -1) ? classes + \" visible\" : classes.replace(\" visible\", \"\");\n        sidemenu.setAttribute(\"class\", classes);\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    function hide_menu() {\n        var sidemenu = document.getElementById(\"sidemenu\");\n        var classes = sidemenu.getAttribute(\"class\");\n        if (classes.indexOf(\" visible\") !== -1) {\n            sidemenu.setAttribute(\"class\", classes.replace(\" visible\", \"\"));\n        }\n    }\n    ''')\n\n    trees = {}\n    menu = Element(\"div\", {'class': 'sidemenu', 'id': 'sidemenu'})\n    SubElement(menu, 'div', {'class': 'menutrigger', 'onclick': 'trigger_menu(event)'}).text = \"Menu\"\n    menu_div = SubElement(menu, 'div', {'class': 'menu'})\n    if with_donations:\n        inject_banner(menu_div)\n\n    # build HTML pages and parse them back\n    for section, text_files in SITE_STRUCTURE:\n        section_head = make_menu_section_head(section, menu_div)\n        for filename in text_files:\n            if filename.startswith('@'):\n                # special menu entry\n                page_title = filename[1:]\n                url = href_map[page_title]\n                build_menu_entry(page_title, url, section_head)\n            else:\n                path = os.path.join(doc_dir, filename)\n                basename = os.path.splitext(os.path.basename(filename))[0]\n                basename = BASENAME_MAP.get(basename, basename)\n                outname = basename + '.html'\n                outpath = os.path.join(dirname, outname)\n\n                rest2html(script, path, outpath, stylesheet_url)\n                tree = parse(outpath)\n\n                if with_donations:\n                    page_div = tree.getroot()[1][0]  # html->body->div[class=document]\n                    inject_banner(page_div)\n\n                    if filename == 'main.txt':\n                        # inject donation buttons\n                        #inject_flatter_button(tree)\n                        inject_donate_buttons(lxml_path, script, tree)\n\n                trees[filename] = (tree, basename, outpath)\n                build_menu(tree, basename, section_head)\n\n    # also convert CHANGES.txt\n    convert_changelog(lxml_path, os.path.join(dirname, 'changes-%s.html' % release),\n                      script, stylesheet_url)\n\n    # generate sitemap from menu\n    sitemap = XML(textwrap.dedent('''\\\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n      <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n        <title>Sitemap of lxml.de - Processing XML and HTML with Python</title>\n        <meta content=\"lxml - the most feature-rich and easy-to-use library for processing XML and HTML in the Python language\"\n              name=\"description\" />\n        <meta content=\"Python XML, XML, XML processing, HTML, lxml, simple XML, ElementTree, etree, lxml.etree, objectify, XML parsing, XML validation, XPath, XSLT\"\n              name=\"keywords\" />\n      </head>\n      <body>\n        <h1>Sitemap of lxml.de - Processing XML and HTML with Python</h1>\n      </body>\n    </html>\n    '''))\n    sitemap_menu = copy.deepcopy(menu)\n    SubElement(SubElement(sitemap_menu[-1], 'li'), 'a', href='https://lxml.de/files/').text = 'Download files'\n    sitemap[-1].append(sitemap_menu)  # append to body\n    ElementTree(sitemap).write(os.path.join(dirname, 'sitemap.html'))\n\n    # integrate sitemap into the menu\n    SubElement(SubElement(menu_div[-1], 'li'), 'a', href='/sitemap.html').text = 'Sitemap'\n\n    # integrate menu into web pages\n    for tree, basename, outpath in trees.values():\n        head = find_head(tree)[0]\n        SubElement(head, 'script', type='text/javascript').text = menu_js\n        SubElement(head, 'meta', name='viewport', content=\"width=device-width, initial-scale=1\")\n        find_body(tree)[0].set('onclick', 'hide_menu()')\n\n        new_tree = merge_menu(tree, menu, basename)\n        title = find_title_tag(new_tree)\n        if title and title[0].text == 'lxml':\n            title[0].text = \"lxml - Processing XML and HTML with Python\"\n            heading = find_heading_tag(new_tree)\n            if heading:\n                heading[0].text = \"lxml - XML and HTML with Python\"\n        new_tree.write(outpath)\n\n\nif __name__ == '__main__':\n    no_donations = '--no-donations' in sys.argv[1:]\n    if no_donations:\n        sys.argv.remove('--no-donations')\n    publish(sys.argv[1], sys.argv[2], sys.argv[3], with_donations=not no_donations)\n", "doc/rest2latex.py": "#!/usr/bin/python\n\n# Testing:\n#    python rest2latex.py objectify.txt > latex/objectify.tex\n\n\"\"\"\nA minimal front end to the Docutils Publisher, producing LaTeX with\nsome syntax highlighting.\n\"\"\"\n\n# Set to True if you want inline CSS styles instead of classes\nINLINESTYLES = False\n\n\ntry:\n    import locale\n    locale.setlocale(locale.LC_ALL, '')\nexcept:\n    pass\n\n# set up Pygments\n\nfrom pygments.formatters import LatexFormatter\n\n# The default formatter\nDEFAULT = LatexFormatter()\n\n# Add name -> formatter pairs for every variant you want to use\nVARIANTS = {\n    # 'linenos': HtmlFormatter(noclasses=INLINESTYLES, linenos=True),\n}\n\n\nfrom docutils import nodes\nfrom docutils.parsers.rst import directives\n\nfrom pygments import highlight\nfrom pygments.lexers import get_lexer_by_name, TextLexer\n\ndef pygments_directive(name, arguments, options, content, lineno,\n                       content_offset, block_text, state, state_machine):\n    try:\n        lexer = get_lexer_by_name(arguments[0])\n    except ValueError as e:\n        # no lexer found - use the text one instead of an exception\n        lexer = TextLexer()\n    # take an arbitrary option if more than one is given\n    formatter = options and VARIANTS[options.keys()[0]] or DEFAULT\n    parsed = highlight(u'\\n'.join(content), lexer, formatter)\n    return [nodes.raw('', parsed, format='latex')]\n\npygments_directive.arguments = (1, 0, 1)\npygments_directive.content = 1\npygments_directive.options = dict([(key, directives.flag) for key in VARIANTS])\n\ndirectives.register_directive('sourcecode', pygments_directive)\n\n\n# run the generation\n\nfrom docutils.core import publish_cmdline, default_description\n\ndescription = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources.  ' + default_description)\n\npublish_cmdline(writer_name='latex2e', description=description)\n", "doc/update_performance_results.py": "import operator\nimport re\n\n_parse_result_line = re.compile(\n    r\"\\s*(?P<library>\\w+):\\s*(?P<name>\\w+)\\s+\\((?P<config>[-\\w]+\\s[\\w,]+)\\s*\\)\\s+(?P<time>[0-9.]+\\s+msec/pass)\"\n).match\n\n_make_key = operator.itemgetter('library', 'name', 'config')\n\n\ndef read_benchmark_results(benchmark_files):\n    benchmark_results = {}\n    for file_path in benchmark_files:\n        with open(file_path) as f:\n            for line in f:\n                result = _parse_result_line(line)\n                if not result:\n                    continue\n                d = result.groupdict()\n                benchmark_results[_make_key(d)] = d['time']\n\n    return benchmark_results\n\n\ndef update_results(text_file, benchmark_results):\n    with open(text_file) as f:\n        for line in f:\n            match = _parse_result_line(line)\n            if not match:\n                yield line\n                continue\n\n            d = match.groupdict()\n            key = _make_key(d)\n            try:\n                new_time = benchmark_results[key]\n            except KeyError:\n                print(\"Failed to update benchmark results of %r\" % d)\n                yield line\n            else:\n                yield line.replace(d['time'], new_time)\n\n\ndef main(log_files, doc_file=\"doc/performance.txt\"):\n    results = read_benchmark_results(log_files)\n    if not results:\n        return\n\n    print(\"Found %d benchmark results\" % len(results))\n    new_text = \"\".join(update_results(doc_file, results))\n    with open(doc_file, 'w') as f:\n        f.write(new_text)\n    print(\"Updated benchmark results in %s\" % doc_file)\n\n\nif __name__ == '__main__':\n    import sys\n    main(sys.argv[1:])\n", "doc/s5/rst2s5.py": "# -*- coding: utf-8 -*-\n\"\"\"\n    The Pygments reStructuredText directive\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    This fragment is a Docutils_ 0.5 directive that renders source code\n    (to HTML only, currently) via Pygments.\n\n    To use it, adjust the options below and copy the code into a module\n    that you import on initialization.  The code then automatically\n    registers a ``sourcecode`` directive that you can use instead of\n    normal code blocks like this::\n\n        .. sourcecode:: python\n\n            My code goes here.\n\n    If you want to have different code styles, e.g. one with line numbers\n    and one without, add formatters with their names in the VARIANTS dict\n    below.  You can invoke them instead of the DEFAULT one by using a\n    directive option::\n\n        .. sourcecode:: python\n            :linenos:\n\n            My code goes here.\n\n    Look at the `directive documentation`_ to get all the gory details.\n\n    .. _Docutils: http://docutils.sf.net/\n    .. _directive documentation:\n       http://docutils.sourceforge.net/docs/howto/rst-directives.html\n\n    :copyright: Copyright 2006-2009 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\n# Options\n# ~~~~~~~\n\n# Set to True if you want inline CSS styles instead of classes\nINLINESTYLES = False\nSTYLE = \"fruity\"\n\nfrom pygments.formatters import HtmlFormatter\n\n# The default formatter\nDEFAULT = HtmlFormatter(noclasses=INLINESTYLES, style=STYLE)\n\n# Add name -> formatter pairs for every variant you want to use\nVARIANTS = {\n    # 'linenos': HtmlFormatter(noclasses=INLINESTYLES, linenos=True),\n}\n\n\nfrom docutils import nodes\nfrom docutils.parsers.rst import directives, Directive\n\nfrom pygments import highlight\nfrom pygments.lexers import get_lexer_by_name, TextLexer\n\nclass Pygments(Directive):\n    \"\"\" Source code syntax highlighting.\n    \"\"\"\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec = dict([(key, directives.flag) for key in VARIANTS])\n    has_content = True\n\n    def run(self):\n        self.assert_has_content()\n        try:\n            lexer = get_lexer_by_name(self.arguments[0])\n        except ValueError:\n            # no lexer found - use the text one instead of an exception\n            lexer = TextLexer()\n        # take an arbitrary option if more than one is given\n        formatter = self.options and VARIANTS[self.options.keys()[0]] or DEFAULT\n\n#        print >>open('ui/default/pygments.css', 'w'), formatter.get_style_defs('.highlight')\n        parsed = highlight(u'\\n'.join(self.content), lexer, formatter)\n        return [nodes.raw('', parsed, format='html')]\n\ndirectives.register_directive('sourcecode', Pygments)\n\nfrom docutils.core import publish_cmdline, default_description\n\ndescription = ('Generates S5 (X)HTML slideshow documents from standalone '\n               'reStructuredText sources.  ' + default_description)\n\npublish_cmdline(writer_name='s5', description=description)\n", "doc/s5/ep2008/atomgen.py": "# atomgen.py\n\nimport os.path\n\nfrom lxml import etree\nfrom lxml.builder import ElementMaker\n\nATOM_NAMESPACE = \"http://www.w3.org/2005/Atom\"\n\nA = ElementMaker(namespace=ATOM_NAMESPACE,\n                 nsmap={None : ATOM_NAMESPACE})\n\nfeed      = A.feed\nentry     = A.entry\ntitle     = A.title\nauthor    = A.author\nname      = A.name\nlink      = A.link\nsummary   = A.summary\nid        = A.id\nupdated   = A.updated\n# ... and so on and so forth ...\n\n\n# plus a little validation function: isvalid()\nisvalid = etree.RelaxNG(\n    file=os.path.join(os.path.abspath(os.path.dirname(__file__)), \"atom.rng\"))\n", "doc/s5/ep2008/atom.py": "# ET is 80's!\n#import elementtree as etree\n# LXML is 00's!\nfrom lxml import etree\nfrom lxml.etree import tostring\n#from dateutil.parser import parse as parse_date\nfrom datetime import datetime\nimport uuid\nimport cgi\nimport copy\n\n__all__ = [\n    'ATOM', 'atom_ns', 'Element', 'tostring']\n\nATOM_NAMESPACE = atom_ns = 'http://www.w3.org/2005/Atom'\napp_ns = 'http://www.w3.org/2007/app'\nxhtml_ns = 'http://www.w3.org/1999/xhtml'\n\nnsmap = {'': atom_ns, 'app': app_ns}\n\n_rel_alternate_xpath = etree.XPath(\n    \"./atom:link[not(@rel) or @rel = 'alternate']\",\n    namespaces=dict(atom=atom_ns))\n_rel_other_xpath = etree.XPath(\n    \"./atom:link[@rel = $rel]\",\n    namespaces=dict(atom=atom_ns))\n\n\n\nclass AtomLookup(etree.CustomElementClassLookup):\n    _elements = {}\n    _app_elements = {}\n\n    def lookup(self, node_type, document, namespace, name):\n        if node_type == 'element':\n            if namespace == atom_ns:\n                return self._elements.get(name, AtomElement)\n            elif namespace == app_ns:\n                return self._app_elements.get(name, APPElement)\n            ## FIXME: is this default good?\n            return AtomElement\n        # Otherwise normal lookup\n        return None\n\natom_parser = etree.XMLParser()\natom_parser.setElementClassLookup(AtomLookup())\n\ndef parse(input):\n    return etree.parse(input, atom_parser)\n\ndef ATOM(atom):\n    \"\"\"\n    Parse an Atom document\n    \"\"\"\n    return etree.XML(atom, atom_parser)\n\ndef Element(tag, *args, **kw):\n    \"\"\"\n    Create an Atom element.  Adds the Atom namespace if no namespace\n    is given.\n    \"\"\"\n    if '{' not in tag:\n        # No namespace means the atom namespace\n        tag = '{%s}%s' % (atom_ns, tag)\n    return atom_parser.makeelement(tag, *args, **kw)\n\ndef _strftime(d):\n    \"\"\"\n    Format a date the way Atom likes it (RFC3339?)\n    \"\"\"\n    return d.strftime('%Y-%m-%dT%H:%M:%SZ%z')\n\n## try:\n##     from lxml import builder\n## except ImportError:\n##     pass\n## else:\n##     E = builder.ElementMaker(parser=atom_parser,\n##                              typemap={datetime: lambda e, v: _strftime(v)})\nfrom lxml import builder\nE = builder.ElementMaker(#parser=atom_parser,\n                         typemap={datetime: lambda e, v: _strftime(v)})\n__all__.append('E')\n\nclass NoDefault:\n    pass\n\nclass _LiveList(list):\n    \"\"\"\n    This list calls on_add or on_remove whenever the list is modified.\n    \"\"\"\n    on_add = on_remove = None\n    name = None\n    def __init__(self, *args, **kw):\n        on_add = on_remove = name = None\n        if 'on_add' in kw:\n            on_add = kw.pop('on_add')\n        if 'on_remove' in kw:\n            on_remove = kw.pop('on_remove')\n        if 'name' in kw:\n            name = kw.pop('name')\n        list.__init__(self, *args, **kw)\n        self.on_add = on_add\n        self.on_remove = on_remove\n        self.name = name\n    def _make_list(self, obj):\n        if not isinstance(obj, (list, tuple)):\n            obj = list(obj)\n        return obj\n    def _do_add(self, items):\n        if self.on_add is not None:\n            for item in items:\n                self.on_add(self, item)\n    def _do_remove(self, items):\n        if self.on_remove is not None:\n            for item in items:\n                self.on_remove(self, item)\n    def __setslice__(self, i, j, other):\n        other = self._make_list(other)\n        old = self[i:j]\n        list.__setslice__(self, i, j, other)\n        self._do_remove(old)\n        self._do_add(other)\n    def __delslice__(self, i, j):\n        old = self[i:j]\n        list.__delslice__(self, i, j)\n        self._do_remove(old)\n    def __iadd__(self, other):\n        other = self._make_list(other)\n        list.__iadd__(self, other)\n        self._do_add(other)\n    def __imul__(self, n):\n        while n > 0:\n            self += self\n            n -= 1\n    def append(self, item):\n        list.append(self, item)\n        self._do_add([item])\n    def insert(self, i, item):\n        list.insert(self, i, item)\n        self._do_add([item])\n    def pop(self, i=-1):\n        item = self[i]\n        result = list.pop(self, i)\n        self._do_remove([item])\n        return result\n    def remove(self, item):\n        list.remove(self, item)\n        self._do_remove([item])\n    def extend(self, other):\n        for item in other:\n            self.append(item)\n    def __repr__(self):\n        name = self.name\n        if name is None:\n            name = '_LiveList'\n        return '%s(%s)' % (name, list.__repr__(self))\n\nclass _findall_property(object):\n    \"\"\"\n    Returns a LiveList of all the objects with the given tag.  You can\n    append or remove items to the list to add or remove them from the\n    containing tag.\n    \"\"\"\n    \n    def __init__(self, tag, ns=atom_ns):\n        self.tag = tag\n        self.ns = ns\n        self.__doc__ = 'Return live list of all the <atom:%s> element' % self.tag\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        def add(lst, item):\n            # FIXME: shouldn't just be an append\n            obj.append(item)\n        def remove(lst, item):\n            obj.remove(item)\n        return _LiveList(obj._atom_iter(self.tag, ns=self.ns),\n                         on_add=add, on_remove=remove,\n                         name='live_%s_list' % self.tag)\n    def __set__(self, obj, value):\n        cur = self.__get__(obj)\n        cur[:] = value\n\nclass _text_element_property(object):\n    \"\"\"\n    Creates an attribute that returns the text content of the given\n    subelement.  E.g., ``title = _text_element_property('title')``\n    will make ``obj.title`` return the contents of the ``<title>``.\n    Similarly setting the attribute sets the text content of the\n    attribute.\n    \"\"\"\n\n    def __init__(self, tag, strip=True):\n        self.tag = tag\n        self.strip = strip\n        self.__doc__ = 'Access the <atom:%s> element as text' % self.tag\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        v = obj._atom_findtext(self.tag)\n        if self.strip:\n            if v is not None:\n                v = v.strip()\n            else:\n                return ''\n        return v\n    def __set__(self, obj, value):\n        el = obj._get_or_create(self.tag)\n        el.text = value\n    def __delete__(self, obj):\n        el = obj._atom_get(self.tag)\n        if el:\n            # FIXME: should it be an error if it doesn't exist?\n            obj.remove(el)\n\nclass _element_property(object):\n    \"\"\"\n    Returns a single subelement based on tag.  Setting the attribute\n    removes the element and adds a new one.  Deleting it removes the\n    element.\n\n    \"\"\"\n    def __init__(self, tag):\n        self.tag = tag\n        self.__doc__ = 'Get the <atom:%s> element' % self.tag\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        return obj._atom_get(self.tag)\n    def __set__(self, obj, value):\n        el = obj._atom_get(self.tag)\n        if el is not None:\n            parent = el.getparent()\n            index = parent.index(el)\n            parent[index] = value\n        else:\n            obj.append(value)\n    def __delete__(self):\n        el = obj._atom_get(self.tag)\n        if el is not None:\n            obj.remove(el)\n\nclass _attr_element_property(object):\n    \"\"\"\n    Get/set the value of the attribute on this element.\n    \"\"\"\n\n    def __init__(self, attr, default=NoDefault):\n        self.attr = attr\n        self.default = default\n        self.__doc__ = 'Access the %s attribute' % self.attr\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        try:\n            return obj.attrib[self.attr]\n        except KeyError:\n            if self.default is not NoDefault:\n                return self.default\n            raise AttributeError(self.attr)\n    def __set__(self, obj, value):\n        if value is None:\n            self.__delete__(obj)\n        else:\n            obj.attrib[self.attr] = value\n    def __delete__(self, obj):\n        if self.attr in obj.attrib:\n            del obj.attrib[self.attr]\n\nclass _date_element_property(object):\n    \"\"\"\n    Get/set the parsed date value of the text content of a tag.\n    \"\"\"\n\n    def __init__(self, tag, ns=atom_ns):\n        self.tag = tag\n        self.ns = ns\n        self.__doc__ = 'Access the date in %s' % self.tag\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        el = obj._atom_get(self.tag, ns=self.ns)\n        if el is None:\n            return None\n        return el.date\n    def __set__(self, obj, value):\n        el = obj._get_or_create(self.tag, ns=self.ns)\n        el.date = value\n    def __delete__(self):\n        el = obj._atom_get(self.tag)\n        if el is not None:\n            obj.remove(el)\n\nclass _date_text_property(object):\n\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        return parse_date(obj.text)\n    def __set__(self, obj, value):\n        if not value:\n            obj.text = None\n            return\n        if isinstance(value, datetime):\n            value = _strftime(value)\n        obj.text = value\n    def __del__(self, obj):\n        obj.text = None\n\nclass AtomElement(etree.ElementBase):\n    def _get_or_create(self, tag, ns=atom_ns):\n        el = self.find('{%s}%s' % (ns, tag))\n        if el is None:\n            el = self.makeelement('{%s}%s' % (ns, tag))\n            self.append(el)\n        return el\n\n    def _atom_get(self, tag, ns=atom_ns):\n        for item in self._atom_iter(tag, ns=ns):\n            return item\n        return None\n\n    def _atom_iter(self, tag, ns=atom_ns):\n        return self.getiterator('{%s}%s' % (ns, tag))\n\n    def _atom_findtext(self, tag, ns=atom_ns):\n        return self.findtext('{%s}%s' % (ns, tag))\n\n    def _get_parent(self, tag, ns=atom_ns):\n        parent = self\n        while 1:\n            if parent.tag == '{%s}%s' % (ns, tag):\n                return parent\n            parent = parent.getparent()\n            if parent is None:\n                return None\n\n    @property\n    def feed(self):\n        return self._get_parent('feed')\n\n    def rel_links(self, rel='alternate'):\n        \"\"\"\n        Return all the links with the given ``rel`` attribute.  The\n        default relation is ``'alternate'``, and as specified for Atom\n        links with no ``rel`` attribute are assumed to mean alternate.\n        \"\"\"\n        if rel is None:\n            return self._atom_iter('link')\n        return [\n            el for el in self._atom_iter('link')\n            if el.get('rel') == rel\n            or rel == 'alternate' and not el.get('rel')]\n\n    def __repr__(self):\n        tag = self.tag\n        if '}' in tag:\n            tag = tag.split('}', 1)[1]\n        return '<%s.%s atom:%s at %s>' % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            tag,\n            hex(abs(id(self)))[2:])\n\nclass Feed(AtomElement):\n    \"\"\"\n    For ``<feed>`` elements.\n    \"\"\"\n    \n    @property\n    def feed(self):\n        return self\n\n    entries = _findall_property('entry')\n    title = _text_element_property('title')\n    author = _element_property('author')\n\nclass Entry(AtomElement):\n    \"\"\"\n    For ``<entry>`` elements.\n    \"\"\"\n    \n    @property\n    def entry(self):\n        return self\n    id = _text_element_property('id')\n    title = _text_element_property('title')\n    published = _date_element_property('published')\n    updated = _date_element_property('updated')\n    edited = _date_element_property('edited', ns=app_ns)\n    def update_edited(self):\n        \"\"\"\n        Set app:edited to current time\n        \"\"\"\n        self.edited = datetime.utcnow()\n    def update_updated(self):\n        \"\"\"\n        Set atom:updated to the current time\n        \"\"\"\n        self.updated = datetime.utcnow()\n    def make_id(self):\n        \"\"\"\n        Create an artificial id for this entry\n        \"\"\"\n        assert not self.id, (\n            \"You cannot make an id if one already exists\")\n        self.id = 'uuid:%s' % uuid.uuid4()\n    def author__get(self):\n        el = self._atom_get('author')\n        if el is None:\n            if self.feed is not None:\n                return self.feed.author\n        return el\n    def author__set(self, value):\n        el = self._atom_get('author')\n        if el is not None:\n            self.remove(el)\n        self.append(value)\n    def author__del(self):\n        el = self._atom_get('author')\n        if el is not None:\n            self.remove(el)\n    author = property(author__get, author__set, author__del)\n\n    categories = _findall_property('category')\n\nclass _EntryElement(AtomElement):\n    @property\n    def entry(self):\n        return self._get_parent('entry')\n\nclass Category(_EntryElement):\n    \"\"\"\n    For ``<category>`` elements.\n    \"\"\"\n    term = _attr_element_property('term')\n    scheme = _attr_element_property('scheme', None)\n    label = _attr_element_property('label', None)\n\n    def as_string(self):\n        \"\"\"\n        Returns the string representation of the category, using the\n        GData convention of ``{scheme}term``\n        \"\"\"\n        if self.scheme is not None:\n            return '{%s}%s' % (self.scheme, self.term)\n        else:\n            return self.term\n\nclass PersonElement(_EntryElement):\n    \"\"\"\n    Represents authors and contributors\n    \"\"\"\n    \n    email = _text_element_property('email')\n    uri = _text_element_property('uri')\n    name = _text_element_property('name')\n\nclass DateElement(_EntryElement):\n    \"\"\"\n    For elements that contain a date in their text content.\n    \"\"\"\n    date = _date_text_property()\n\nclass TextElement(_EntryElement):\n\n    type = _attr_element_property('type', None)\n    src = _attr_element_property('src', None)\n\n    def _html__get(self):\n        \"\"\"\n        Gives the parsed HTML of element's content.  May return an\n        HtmlElement (from lxml.html) or an XHTML tree.  If the element\n        is ``type=\"text\"`` then it is returned as quoted HTML.\n\n        You can also set this attribute to either an lxml.html\n        element, an XHTML element, or an HTML string.\n\n        Raises AttributeError if this is not HTML content.\n        \"\"\"\n        ## FIXME: should this handle text/html types?\n        if self.type == 'html':\n            content = self.text\n        elif self.type == 'text':\n            content = cgi.escape(self.text)\n        elif self.type == 'xhtml':\n            div = copy.deepcopy(self[0])\n            # Now remove the namespaces:\n            for el in div.getiterator():\n                if el.tag.startswith('{'):\n                    el.tag = el.tag.split('}', 1)[1]\n            if div.tag.startswith('{'):\n                div.tag = el.tag.split('}', 1)[1]\n            from lxml.html import tostring\n            content = tostring(div)\n        else:\n            raise AttributeError(\n                \"Not an HTML or text content (type=%r)\" % self.type)\n        from lxml.html import fromstring\n        return fromstring(content)\n\n    def _html__set(self, value):\n        if value is None:\n            del self.html\n            return\n        if isinstance(value, basestring):\n            # Some HTML text\n            self.type = 'html'\n            self.text = value\n            return\n        if value.tag.startswith('{%s}' % xhtml_ns):\n            if value.tag != '{%s}div' % xhtml_ns:\n                # Need to wrap it in a <div>\n                el = self.makeelement('{%s}div' % xhtml_ns)\n                el.append(value)\n                value = el\n            self[:] = []\n            self.type = 'xhtml'\n            self.append(value)\n            return\n        from lxml import html\n        if isinstance(value, html.HtmlElement):\n            value = tostring(value)\n            self[:] = []\n            self.type = 'html'\n            self.text = value\n            return\n        raise TypeError(\n            \"Unknown HTML type: %s\" % type(value))\n\n    def _html__del(self):\n        self.text = None\n\n    html = property(_html__get, _html__set, _html__del, doc=_html__get.__doc__)\n\n    def _binary__get(self):\n        \"\"\"\n        Gets/sets the binary content, which is base64 encoded in the\n        text.\n        \"\"\"\n        text = self.text\n        if text is None:\n            raise AttributeError(\n                \"No text (maybe in src?)\")\n        text = text.decode('base64')\n        return text\n\n    def _binary__set(self, value):\n        if isinstance(value, unicode):\n            ## FIXME: is this kosher?\n            value = value.encode('utf8')\n        if not isinstance(value, str):\n            raise TypeError(\n                \"Must set .binary to a str or unicode object (not %s)\"\n                % type(value))\n        value = value.encode('base64')\n        self.text = value\n\n    def _binary__del(self):\n        self.text = None\n\n    binary = property(_binary__get, _binary__set, _binary__del, doc=_binary__get.__doc__)\n            \n\nclass LinkElement(_EntryElement):\n    \"\"\"\n    For ``<link>`` elements.\n    \"\"\"\n    href = _attr_element_property('href', None)\n    rel = _attr_element_property('rel', None)\n    type = _attr_element_property('type', None)\n    title = _attr_element_property('title', None)\n\n    def __repr__(self):\n        return '<%s.%s at %s rel=%r href=%r>' % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            hex(abs(id(self)))[2:],\n            self.rel, self.href)\n\nAtomLookup._elements.update(dict(\n    feed=Feed,\n    entry=Entry,\n    category=Category,\n    author=PersonElement,\n    contributor=PersonElement,\n    published=DateElement,\n    updated=DateElement,\n    content=TextElement,\n    summary=TextElement,\n    title=TextElement,\n    rights=TextElement,\n    subtitle=TextElement,\n    link=LinkElement,\n    ))\n\nclass APPElement(etree.ElementBase):\n    def __repr__(self):\n        tag = self.tag\n        if '}' in tag:\n            tag = tag.split('}', 1)[1]\n        return '<%s.%s app:%s at %s>' % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            tag,\n            hex(abs(id(self)))[2:])\n\nclass Service(APPElement):\n    workspaces = _findall_property('workspace', ns=app_ns)\n\nclass Workspace(APPElement):\n    collections = _findall_property('collection', ns=app_ns)\n\nclass Collection(APPElement):\n    pass\n\nclass Edited(APPElement):\n    date = _date_text_property()\n\nAtomLookup._app_elements.update(dict(\n    service=Service,\n    workspace=Workspace,\n    collection=Collection,\n    edited=Edited,\n    ))\n", "doc/api/conf.py": "import os\nimport sys\nsys.path.insert(0, os.path.abspath('../../src'))\n\nfrom lxml import __version__ as lxml_version\n\n# -- Project information -----------------------------------------------------\n\nproject = 'lxml'\ncopyright = '2020, lxml dev team'\nauthor = 'lxml dev team'\nversion = lxml_version\n\n\n# -- General configuration ---------------------------------------------------\n\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.viewcode',\n    'sphinx_rtd_theme',\n]\n\nlanguage = 'en'\n\nexclude_patterns = ['_build']\n\n\n# -- Options for HTML output -------------------------------------------------\n\nhtml_theme = 'sphinx_rtd_theme'\n\nhtml_logo = '../html/python-xml.png'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n#html_static_path = ['_static']\n\nhtml_theme_options = {\n    'collapse_navigation': False,\n    'titles_only': True,\n}\n\n# -- Extension configuration -------------------------------------------------\n\nautodoc_default_options = {\n    'ignore-module-all': True,\n    'private-members': True,\n    'inherited-members': True,\n}\n\nautodoc_member_order = 'groupwise'\n\nintersphinx_mapping = {\n    \"lxml\": (\"https://lxml.de/apidoc/\", None),\n}\n\n# -- Options for todo extension ----------------------------------------------\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\n#todo_include_todos = True\n", "benchmark/bench_objectify.py": "from itertools import *\n\nimport benchbase\nfrom benchbase import (with_text, children, nochange)\n\n############################################################\n# Benchmarks\n############################################################\n\nclass BenchMark(benchbase.TreeBenchMark):\n    repeat100  = range(100)\n    repeat1000 = range(1000)\n    repeat3000 = range(3000)\n\n    def __init__(self, lib):\n        from lxml import etree, objectify\n        self.objectify = objectify\n        parser = etree.XMLParser(remove_blank_text=True)\n        lookup = objectify.ObjectifyElementClassLookup()\n        parser.setElementClassLookup(lookup)\n        super(BenchMark, self).__init__(etree, parser)\n\n    @nochange\n    def bench_attribute(self, root):\n        \"1 2 4\"\n        for i in self.repeat3000:\n            root.zzzzz\n\n    def bench_attribute_assign_int(self, root):\n        \"1 2 4\"\n        for i in self.repeat3000:\n            root.XYZ = 5\n\n    def bench_attribute_assign_string(self, root):\n        \"1 2 4\"\n        for i in self.repeat3000:\n            root.XYZ = \"5\"\n\n    @nochange\n    def bench_attribute_cached(self, root):\n        \"1 2 4\"\n        cache = root.zzzzz\n        for i in self.repeat3000:\n            root.zzzzz\n\n    @nochange\n    def bench_attributes_deep(self, root):\n        \"1 2 4\"\n        for i in self.repeat3000:\n            root.zzzzz['{cdefg}a00001']\n\n    @nochange\n    def bench_attributes_deep_cached(self, root):\n        \"1 2 4\"\n        cache1 = root.zzzzz\n        cache2 = cache1['{cdefg}a00001']\n        for i in self.repeat3000:\n            root.zzzzz['{cdefg}a00001']\n\n    @nochange\n    def bench_objectpath(self, root):\n        \"1 2 4\"\n        path = self.objectify.ObjectPath(\".zzzzz\")\n        for i in self.repeat3000:\n            path(root)\n\n    @nochange\n    def bench_objectpath_deep(self, root):\n        \"1 2 4\"\n        path = self.objectify.ObjectPath(\".zzzzz.{cdefg}a00001\")\n        for i in self.repeat3000:\n            path(root)\n\n    @nochange\n    def bench_objectpath_deep_cached(self, root):\n        \"1 2 4\"\n        cache1 = root.zzzzz\n        cache2 = cache1['{cdefg}a00001']\n        path = self.objectify.ObjectPath(\".zzzzz.{cdefg}a00001\")\n        for i in self.repeat3000:\n            path(root)\n\n    @with_text(text=True, utext=True, no_text=True)\n    def bench_annotate(self, root):\n        self.objectify.annotate(root)\n\n    @nochange\n    def bench_descendantpaths(self, root):\n        root.descendantpaths()\n\n    @nochange\n    @with_text(text=True)\n    def bench_type_inference(self, root):\n        \"1 2 4\"\n        el = root.aaaaa\n        for i in self.repeat1000:\n            el.getchildren()\n\n    @nochange\n    @with_text(text=True)\n    def bench_type_inference_annotated(self, root):\n        \"1 2 4\"\n        el = root.aaaaa\n        self.objectify.annotate(el)\n        for i in self.repeat1000:\n            el.getchildren()\n\n    @nochange\n    @children\n    def bench_elementmaker(self, children):\n        E = self.objectify.E\n        for child in children:\n            root = E.this(\n                \"test\",\n                E.will(\n                    E.do(\"nothing\"),\n                    E.special,\n                    )\n                )\n\nif __name__ == '__main__':\n    benchbase.main(BenchMark)\n", "benchmark/bench_etree.py": "import copy\nfrom io import BytesIO\nfrom itertools import *\n\nimport benchbase\nfrom benchbase import (with_attributes, with_text, onlylib,\n                       serialized, children, nochange)\n\nTEXT  = \"some ASCII text\"\nUTEXT = u\"some klingon: \\uF8D2\"\n\n############################################################\n# Benchmarks\n############################################################\n\nclass BenchMark(benchbase.TreeBenchMark):\n    @nochange\n    def bench_iter_children(self, root):\n        for child in root:\n            pass\n\n    @nochange\n    def bench_iter_children_reversed(self, root):\n        for child in reversed(root):\n            pass\n\n    @nochange\n    def bench_first_child(self, root):\n        for i in self.repeat1000:\n            child = root[0]\n\n    @nochange\n    def bench_last_child(self, root):\n        for i in self.repeat1000:\n            child = root[-1]\n\n    @nochange\n    def bench_middle_child(self, root):\n        pos = len(root) // 2\n        for i in self.repeat1000:\n            child = root[pos]\n\n    @nochange\n    @with_attributes(False)\n    @with_text(text=True)\n    def bench_tostring_text_ascii(self, root):\n        self.etree.tostring(root, method=\"text\")\n\n    @nochange\n    @with_attributes(False)\n    @with_text(text=True, utext=True)\n    def bench_tostring_text_unicode(self, root):\n        self.etree.tostring(root, method=\"text\", encoding='unicode')\n\n    @nochange\n    @with_attributes(False)\n    @with_text(text=True, utext=True)\n    def bench_tostring_text_utf16(self, root):\n        self.etree.tostring(root, method=\"text\", encoding='UTF-16')\n\n    @nochange\n    @with_attributes(False)\n    @with_text(text=True, utext=True)\n    @onlylib('lxe')\n    @children\n    def bench_tostring_text_utf8_with_tail(self, children):\n        for child in children:\n            self.etree.tostring(child, method=\"text\",\n                                encoding='UTF-8', with_tail=True)\n\n    @nochange\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    def bench_tostring_utf8(self, root):\n        self.etree.tostring(root, encoding='UTF-8')\n\n    @nochange\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    def bench_tostring_utf16(self, root):\n        self.etree.tostring(root, encoding='UTF-16')\n\n    @nochange\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    def bench_tostring_utf8_unicode_XML(self, root):\n        xml = self.etree.tostring(root, encoding='UTF-8').decode('UTF-8')\n        self.etree.XML(xml)\n\n    @nochange\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    def bench_write_utf8_parse_bytesIO(self, root):\n        f = BytesIO()\n        self.etree.ElementTree(root).write(f, encoding='UTF-8')\n        f.seek(0)\n        self.etree.parse(f)\n\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    @serialized\n    def bench_parse_bytesIO(self, root_xml):\n        f = BytesIO(root_xml)\n        self.etree.parse(f)\n\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    @serialized\n    def bench_XML(self, root_xml):\n        self.etree.XML(root_xml)\n\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    @serialized\n    def bench_iterparse_bytesIO(self, root_xml):\n        f = BytesIO(root_xml)\n        for event, element in self.etree.iterparse(f):\n            pass\n\n    @with_attributes(True, False)\n    @with_text(text=True, utext=True)\n    @serialized\n    def bench_iterparse_bytesIO_clear(self, root_xml):\n        f = BytesIO(root_xml)\n        for event, element in self.etree.iterparse(f):\n            element.clear()\n\n    def bench_append_from_document(self, root1, root2):\n        # == \"1,2 2,3 1,3 3,1 3,2 2,1\" # trees 1 and 2, or 2 and 3, or ...\n        for el in root2:\n            root1.append(el)\n\n    def bench_insert_from_document(self, root1, root2):\n        pos = len(root1)//2\n        for el in root2:\n            root1.insert(pos, el)\n            pos = pos + 1\n\n    def bench_rotate_children(self, root):\n        # == \"1 2 3\" # runs on any single tree independently\n        for i in range(100):\n            el = root[0]\n            del root[0]\n            root.append(el)\n\n    def bench_reorder(self, root):\n        for i in range(1,len(root)//2):\n            el = root[0]\n            del root[0]\n            root[-i:-i] = [ el ]\n\n    def bench_reorder_slice(self, root):\n        for i in range(1,len(root)//2):\n            els = root[0:1]\n            del root[0]\n            root[-i:-i] = els\n\n    def bench_clear(self, root):\n        root.clear()\n\n    @nochange\n    @children\n    def bench_has_children(self, children):\n        for child in children:\n            if child and child and child and child and child:\n                pass\n\n    @nochange\n    @children\n    def bench_len(self, children):\n        for child in children:\n            map(len, repeat(child, 20))\n\n    @children\n    def bench_create_subelements(self, children):\n        SubElement = self.etree.SubElement\n        for child in children:\n            SubElement(child, '{test}test')\n\n    def bench_append_elements(self, root):\n        Element = self.etree.Element\n        for child in root:\n            el = Element('{test}test')\n            child.append(el)\n\n    @nochange\n    @children\n    def bench_makeelement(self, children):\n        empty_attrib = {}\n        for child in children:\n            child.makeelement('{test}test', empty_attrib)\n\n    @nochange\n    @children\n    def bench_create_elements(self, children):\n        Element = self.etree.Element\n        for child in children:\n            Element('{test}test')\n\n    @children\n    def bench_replace_children_element(self, children):\n        Element = self.etree.Element\n        for child in children:\n            el = Element('{test}test')\n            child[:] = [el]\n\n    @children\n    def bench_replace_children(self, children):\n        els = [ self.etree.Element(\"newchild\") ]\n        for child in children:\n            child[:] = els\n\n    def bench_remove_children(self, root):\n        for child in root:\n            root.remove(child)\n\n    def bench_remove_children_reversed(self, root):\n        for child in reversed(root):\n            root.remove(child)\n\n    @children\n    def bench_set_attributes(self, children):\n        for child in children:\n            child.set('a', 'bla')\n\n    @with_attributes(True)\n    @children\n    @nochange\n    def bench_get_attributes(self, children):\n        for child in children:\n            child.get('bla1')\n            child.get('{attr}test1')\n\n    @children\n    def bench_setget_attributes(self, children):\n        for child in children:\n            child.set('a', 'bla')\n        for child in children:\n            child.get('a')\n\n    @nochange\n    def bench_root_getchildren(self, root):\n        root.getchildren()\n\n    @nochange\n    def bench_root_list_children(self, root):\n        list(root)\n\n    @nochange\n    @children\n    def bench_getchildren(self, children):\n        for child in children:\n            child.getchildren()\n\n    @nochange\n    @children\n    def bench_get_children_slice(self, children):\n        for child in children:\n            child[:]\n\n    @nochange\n    @children\n    def bench_get_children_slice_2x(self, children):\n        for child in children:\n            child[:]\n            child[:]\n\n    @nochange\n    @children\n    @with_attributes(True, False)\n    @with_text(utext=True, text=True, no_text=True)\n    def bench_deepcopy(self, children):\n        for child in children:\n            copy.deepcopy(child)\n\n    @nochange\n    @with_attributes(True, False)\n    @with_text(utext=True, text=True, no_text=True)\n    def bench_deepcopy_all(self, root):\n        copy.deepcopy(root)\n\n    @nochange\n    @children\n    def bench_tag(self, children):\n        for child in children:\n            child.tag\n\n    @nochange\n    @children\n    def bench_tag_repeat(self, children):\n        for child in children:\n            for i in self.repeat100:\n                child.tag\n\n    @nochange\n    @with_text(utext=True, text=True, no_text=True)\n    @children\n    def bench_text(self, children):\n        for child in children:\n            child.text\n\n    @nochange\n    @with_text(utext=True, text=True, no_text=True)\n    @children\n    def bench_text_repeat(self, children):\n        for child in children:\n            for i in self.repeat500:\n                child.text\n\n    @children\n    def bench_set_text(self, children):\n        text = TEXT\n        for child in children:\n            child.text = text\n\n    @children\n    def bench_set_utext(self, children):\n        text = UTEXT\n        for child in children:\n            child.text = text\n\n    @nochange\n    @onlylib('lxe')\n    def bench_index(self, root):\n        for child in root:\n            root.index(child)\n\n    @nochange\n    @onlylib('lxe')\n    def bench_index_slice(self, root):\n        for child in root[5:100]:\n            root.index(child, 5, 100)\n\n    @nochange\n    @onlylib('lxe')\n    def bench_index_slice_neg(self, root):\n        for child in root[-100:-5]:\n            root.index(child, start=-100, stop=-5)\n\n    @nochange\n    def bench_iter_all(self, root):\n        list(root.iter())\n\n    @nochange\n    def bench_iter_one_at_a_time(self, root):\n        list(islice(root.iter(), 2**30, None))\n\n    @nochange\n    def bench_iter_islice(self, root):\n        list(islice(root.iter(), 10, 110))\n\n    @nochange\n    def bench_iter_tag(self, root):\n        list(islice(root.iter(self.SEARCH_TAG), 3, 10))\n\n    @nochange\n    def bench_iter_tag_all(self, root):\n        list(root.iter(self.SEARCH_TAG))\n\n    @nochange\n    def bench_iter_tag_one_at_a_time(self, root):\n        list(islice(root.iter(self.SEARCH_TAG), 2**30, None))\n\n    @nochange\n    def bench_iter_tag_none(self, root):\n        list(root.iter(\"{ThisShould}NeverExist\"))\n\n    @nochange\n    def bench_iter_tag_text(self, root):\n        [ e.text for e in root.iter(self.SEARCH_TAG) ]\n\n    @nochange\n    def bench_findall(self, root):\n        root.findall(\".//*\")\n\n    @nochange\n    def bench_findall_child(self, root):\n        root.findall(\".//*/\" + self.SEARCH_TAG)\n\n    @nochange\n    def bench_findall_tag(self, root):\n        root.findall(\".//\" + self.SEARCH_TAG)\n\n    @nochange\n    def bench_findall_path(self, root):\n        root.findall(\".//*[%s]/./%s/./*\" % (self.SEARCH_TAG, self.SEARCH_TAG))\n\n    @nochange\n    @onlylib('lxe')\n    def bench_xpath_path(self, root):\n        ns, tag = self.SEARCH_TAG[1:].split('}')\n        root.xpath(\".//*[p:%s]/./p:%s/./*\" % (tag,tag),\n                   namespaces = {'p':ns})\n\n    @nochange\n    def bench_iterfind(self, root):\n        list(root.iterfind(\".//*\"))\n\n    @nochange\n    def bench_iterfind_tag(self, root):\n        list(root.iterfind(\".//\" + self.SEARCH_TAG))\n\n    @nochange\n    def bench_iterfind_islice(self, root):\n        list(islice(root.iterfind(\".//*\"), 10, 110))\n\n    _bench_xpath_single_xpath = None\n\n    @nochange\n    @onlylib('lxe')\n    def bench_xpath_single(self, root):\n        xpath = self._bench_xpath_single_xpath\n        if xpath is None:\n            ns, tag = self.SEARCH_TAG[1:].split('}')\n            xpath = self._bench_xpath_single_xpath = self.etree.XPath(\n                './/p:%s[1]' % tag, namespaces={'p': ns})\n        xpath(root)\n\n    @nochange\n    def bench_find_single(self, root):\n        root.find(\".//%s\" % self.SEARCH_TAG)\n\n    @nochange\n    def bench_iter_single(self, root):\n        next(root.iter(self.SEARCH_TAG))\n\n    _bench_xpath_two_xpath = None\n\n    @nochange\n    @onlylib('lxe')\n    def bench_xpath_two(self, root):\n        xpath = self._bench_xpath_two_xpath\n        if xpath is None:\n            ns, tag = self.SEARCH_TAG[1:].split('}')\n            xpath = self._bench_xpath_two_xpath = self.etree.XPath(\n                './/p:%s[position() < 3]' % tag, namespaces={'p': ns})\n        xpath(root)\n\n    @nochange\n    def bench_iterfind_two(self, root):\n        it = root.iterfind(\".//%s\" % self.SEARCH_TAG)\n        next(it)\n        next(it)\n\n    @nochange\n    def bench_iter_two(self, root):\n        it = root.iter(self.SEARCH_TAG)\n        next(it)\n        next(it)\n\n\nif __name__ == '__main__':\n    benchbase.main(BenchMark)\n", "benchmark/bench_xslt.py": "from itertools import *\n\nimport benchbase\nfrom benchbase import onlylib\n\n############################################################\n# Benchmarks\n############################################################\n\nclass XSLTBenchMark(benchbase.TreeBenchMark):\n    @onlylib('lxe')\n    def bench_xslt_extensions_old(self, root):\n        tree = self.etree.XML(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:l=\"test\"\n   xmlns:testns=\"testns\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <l:data>TEST</l:data>\n  <xsl:template match=\"/\">\n    <l:result>\n      <xsl:for-each select=\"*/*\">\n        <xsl:copy-of select=\"testns:child(.)\"/>\n      </xsl:for-each>\n    </l:result>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\")\n        def return_child(_, elements):\n            return elements[0][0]\n\n        extensions = {('testns', 'child') : return_child}\n\n        transform = self.etree.XSLT(tree, extensions)\n        for i in range(10):\n            transform(root)\n\n    @onlylib('lxe')\n    def bench_xslt_document(self, root):\n        transform = self.etree.XSLT(self.etree.XML(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:l=\"test\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <l:data>TEST</l:data>\n  <xsl:template match=\"/\">\n    <l:result>\n      <xsl:for-each select=\"*/*\">\n        <l:test><xsl:copy-of select=\"document('')//l:data/text()\"/></l:test>\n      </xsl:for-each>\n    </l:result>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        transform(root)\n\nif __name__ == '__main__':\n    benchbase.main(XSLTBenchMark)\n", "benchmark/bench_xpath.py": "from itertools import *\n\nimport benchbase\nfrom benchbase import onlylib, children, nochange\n\n############################################################\n# Benchmarks\n############################################################\n\nclass XPathBenchMark(benchbase.TreeBenchMark):\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_xpath_class(self, children):\n        xpath = self.etree.XPath(\"./*[1]\")\n        for child in children:\n            xpath(child)\n\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_xpath_class_repeat(self, children):\n        for child in children:\n            xpath = self.etree.XPath(\"./*[1]\")\n            xpath(child)\n\n    @nochange\n    @onlylib('lxe')\n    def bench_xpath_element(self, root):\n        xpath = self.etree.XPathElementEvaluator(root)\n        for child in root:\n            xpath.evaluate(\"./*[1]\")\n\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_xpath_method(self, children):\n        for child in children:\n            child.xpath(\"./*[1]\")\n\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_multiple_xpath_or(self, children):\n        xpath = self.etree.XPath(\".//p:a00001|.//p:b00001|.//p:c00001\",\n                                 namespaces={'p':'cdefg'})\n        for child in children:\n            xpath(child)\n\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_multiple_iter_tag(self, children):\n        for child in children:\n            list(child.iter(\"{cdefg}a00001\"))\n            list(child.iter(\"{cdefg}b00001\"))\n            list(child.iter(\"{cdefg}c00001\"))\n\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_xpath_old_extensions(self, children):\n        def return_child(_, elements):\n            if elements:\n                return elements[0][0]\n            else:\n                return ()\n        extensions = {(\"test\", \"child\") : return_child}\n        xpath = self.etree.XPath(\"t:child(.)\", namespaces={\"t\":\"test\"},\n                                 extensions=extensions)\n        for child in children:\n            xpath(child)\n\n    @nochange\n    @onlylib('lxe')\n    @children\n    def bench_xpath_extensions(self, children):\n        def return_child(_, elements):\n            if elements:\n                return elements[0][0]\n            else:\n                return ()\n        self.etree.FunctionNamespace(\"testns\")[\"t\"] = return_child\n\n        try:\n            xpath = self.etree.XPath(\"test:t(.)\", namespaces={\"test\":\"testns\"})\n            for child in children:\n                xpath(child)\n        finally:\n            del self.etree.FunctionNamespace(\"testns\")[\"t\"]\n\nif __name__ == '__main__':\n    benchbase.main(XPathBenchMark)\n", "benchmark/benchbase.py": "import sys, re, string, copy, gc\nfrom itertools import *\nimport time\n\ntry:\n    izip\nexcept NameError:\n    izip = zip  # Py3\n\ndef exec_(code, glob):\n    if sys.version_info[0] >= 3:\n        exec(code, glob)\n    else:\n        exec(\"exec code in glob\")\n\n\nTREE_FACTOR = 1 # increase tree size with '-l / '-L' cmd option\n\n_TEXT  = \"some ASCII text\" * TREE_FACTOR\n_UTEXT = u\"some klingon: \\uF8D2\" * TREE_FACTOR\n_ATTRIBUTES = {\n    '{attr}test1' : _TEXT,\n    '{attr}test2' : _TEXT,\n    'bla1'        : _TEXT,\n    'bla2'        : _TEXT,\n    'bla3'        : _TEXT\n    }\n\n\ndef initArgs(argv):\n    global TREE_FACTOR\n    try:\n        argv.remove('-l')\n        # use large trees\n        TREE_FACTOR *= 2\n    except ValueError:\n        pass\n\n    try:\n        argv.remove('-L')\n        # use LARGE trees\n        TREE_FACTOR *= 2\n    except ValueError:\n        pass\n\n############################################################\n# benchmark decorators\n############################################################\n\ndef with_attributes(*use_attributes):\n    \"Decorator for benchmarks that use attributes\"\n    vmap = {False : 0, True : 1}\n    values = [ vmap[bool(v)] for v in use_attributes ]\n    def set_value(function):\n        try:\n            function.ATTRIBUTES.update(values)\n        except AttributeError:\n            function.ATTRIBUTES = set(values)\n        return function\n    return set_value\n\ndef with_text(no_text=False, text=False, utext=False):\n    \"Decorator for benchmarks that use text\"\n    values = []\n    if no_text:\n        values.append(0)\n    if text:\n        values.append(1)\n    if utext:\n        values.append(2)\n    def set_value(function):\n        try:\n            function.TEXT.add(values)\n        except AttributeError:\n            function.TEXT = set(values)\n        return function\n    return set_value\n\ndef onlylib(*libs):\n    \"Decorator to restrict benchmarks to specific libraries\"\n    def set_libs(function):\n        if libs:\n            function.LIBS = libs\n        return function\n    return set_libs\n\ndef serialized(function):\n    \"Decorator for benchmarks that require serialized XML data\"\n    function.STRING = True\n    return function\n\ndef children(function):\n    \"Decorator for benchmarks that require a list of root children\"\n    function.CHILDREN = True\n    return function\n\ndef nochange(function):\n    \"Decorator for benchmarks that do not change the XML tree\"\n    function.NO_CHANGE = True\n    return function\n\n############################################################\n# benchmark baseclass\n############################################################\n\nclass SkippedTest(Exception):\n    pass\n\nclass TreeBenchMark(object):\n    atoz = string.ascii_lowercase\n    repeat100  = range(100)\n    repeat500  = range(500)\n    repeat1000 = range(1000)\n\n    _LIB_NAME_MAP = {\n        'etree'        : 'lxe',\n        'ElementTree'  : 'ET',\n        'cElementTree' : 'cET'\n        }\n\n    SEARCH_TAG = \"{cdefg}a00001\"\n\n    def __init__(self, etree, etree_parser=None):\n        self.etree = etree\n        libname = etree.__name__.split('.')[-1]\n        self.lib_name = self._LIB_NAME_MAP.get(libname, libname)\n\n        if libname == 'etree':\n            deepcopy = copy.deepcopy\n            def set_property(root, fname):\n                xml = self._serialize_tree(root)\n                if etree_parser is not None:\n                    setattr(self, fname, lambda : etree.XML(xml, etree_parser))\n                else:\n                    setattr(self, fname, lambda : deepcopy(root))\n                setattr(self, fname + '_xml', lambda : xml)\n                setattr(self, fname + '_children', lambda : root[:])\n        else:\n            def set_property(root, fname):\n                setattr(self, fname, self.et_make_clone_factory(root))\n                xml = self._serialize_tree(root)\n                setattr(self, fname + '_xml', lambda : xml)\n                setattr(self, fname + '_children', lambda : root[:])\n\n        attribute_list = list(enumerate( [{}, _ATTRIBUTES] ))\n        text_list = list(enumerate( [None, _TEXT, _UTEXT] ))\n        build_name = self._tree_builder_name\n\n        self.setup_times = []\n        for tree in self._all_trees():\n            times = []\n            self.setup_times.append(times)\n            setup = getattr(self, '_setup_tree%d' % tree)\n            for an, attributes in attribute_list:\n                for tn, text in text_list:\n                    root, t = setup(text, attributes)\n                    times.append(t)\n                    set_property(root, build_name(tree, tn, an))\n\n    def _tree_builder_name(self, tree, tn, an):\n        return '_root%d_T%d_A%d' % (tree, tn, an)\n\n    def tree_builder(self, tree, tn, an, serial, children):\n        name = self._tree_builder_name(tree, tn, an)\n        if serial:\n            name += '_xml'\n        elif children:\n            name += '_children'\n        return getattr(self, name)\n\n    def _serialize_tree(self, root):\n        return self.etree.tostring(root, encoding='UTF-8')\n\n    def et_make_clone_factory(self, elem):\n        def generate_elem(append, elem, level):\n            var = \"e\" + str(level)\n            arg = repr(elem.tag)\n            if elem.attrib:\n                arg += \", **%r\" % elem.attrib\n            if level == 1:\n                append(\" e1 = Element(%s)\" % arg)\n            else:\n                append(\" %s = SubElement(e%d, %s)\" % (var, level-1, arg))\n            if elem.text:\n                append(\" %s.text = %r\" % (var, elem.text))\n            if elem.tail:\n                append(\" %s.tail = %r\" % (var, elem.tail))\n            for e in elem:\n                generate_elem(append, e, level+1)\n        # generate code for a function that creates a tree\n        output = [\"def element_factory():\"]\n        generate_elem(output.append, elem, 1)\n        output.append(\" return e1\")\n        # setup global function namespace\n        namespace = {\n            \"Element\"    : self.etree.Element,\n            \"SubElement\" : self.etree.SubElement\n            }\n\n        # create function object\n        exec_(\"\\n\".join(output), namespace)\n        return namespace[\"element_factory\"]\n\n    def _all_trees(self):\n        all_trees = []\n        for name in dir(self):\n            if name.startswith('_setup_tree'):\n                all_trees.append(int(name[11:]))\n        return all_trees\n\n    def _setup_tree1(self, text, attributes):\n        \"tree with 26 2nd level and 520 * TREE_FACTOR 3rd level children\"\n        atoz = self.atoz\n        SubElement = self.etree.SubElement\n        current_time = time.time\n        t = current_time()\n        root = self.etree.Element('{abc}rootnode')\n        for ch1 in atoz:\n            el = SubElement(root, \"{abc}\"+ch1*5, attributes)\n            el.text = text\n            for ch2 in atoz:\n                tag = \"{cdefg}%s00001\" % ch2\n                for i in range(20 * TREE_FACTOR):\n                    SubElement(el, tag).tail = text\n        t = current_time() - t\n        return root, t\n\n    def _setup_tree2(self, text, attributes):\n        \"tree with 520 * TREE_FACTOR 2nd level and 26 3rd level children\"\n        atoz = self.atoz\n        SubElement = self.etree.SubElement\n        current_time = time.time\n        t = current_time()\n        root = self.etree.Element('{abc}rootnode')\n        for ch1 in atoz:\n            for i in range(20 * TREE_FACTOR):\n                el = SubElement(root, \"{abc}\"+ch1*5, attributes)\n                el.text = text\n                for ch2 in atoz:\n                    SubElement(el, \"{cdefg}%s00001\" % ch2).tail = text\n        t = current_time() - t\n        return root, t\n\n    def _setup_tree3(self, text, attributes):\n        \"tree of depth 8 + TREE_FACTOR with 3 children per node\"\n        SubElement = self.etree.SubElement\n        current_time = time.time\n        t = current_time()\n        root = self.etree.Element('{abc}rootnode')\n        children = [root]\n        for i in range(6 + TREE_FACTOR):\n            children = [ SubElement(c, \"{cdefg}a%05d\" % (i%8), attributes)\n                         for i,c in enumerate(chain(children, children, children)) ]\n        for child in children:\n            child.text = text\n            child.tail = text\n        t = current_time() - t\n        return root, t\n\n    def _setup_tree4(self, text, attributes):\n        \"small tree with 26 2nd level and 2 3rd level children\"\n        SubElement = self.etree.SubElement\n        current_time = time.time\n        t = current_time()\n        root = self.etree.Element('{abc}rootnode')\n        for ch1 in self.atoz:\n            el = SubElement(root, \"{abc}\"+ch1*5, attributes)\n            el.text = text\n            SubElement(el, \"{cdefg}a00001\", attributes).tail = text\n            SubElement(el, \"{cdefg}z00000\", attributes).tail = text\n        t = current_time() - t\n        return root, t\n\n    def benchmarks(self):\n        \"\"\"Returns a list of all benchmarks.\n\n        A benchmark is a tuple containing a method name and a list of tree\n        numbers.  Trees are prepared by the setup function.\n        \"\"\"\n        all_trees = self._all_trees()\n        benchmarks = []\n        for name in dir(self):\n            if not name.startswith('bench_'):\n                continue\n            method = getattr(self, name)\n            if hasattr(method, 'LIBS') and self.lib_name not in method.LIBS:\n                method_call = None\n            else:\n                method_call = method\n            if method.__doc__:\n                tree_sets = method.__doc__.split()\n            else:\n                tree_sets = ()\n            if tree_sets:\n                tree_tuples = [list(map(int, tree_set.split(',')))\n                               for tree_set in tree_sets]\n            else:\n                try:\n                    arg_count = method.func_code.co_argcount - 1\n                except AttributeError:\n                    try:\n                        arg_count = method.__code__.co_argcount - 1\n                    except AttributeError:\n                        arg_count = 1\n                tree_tuples = self._permutations(all_trees, arg_count)\n\n            serialized = getattr(method, 'STRING',   False)\n            children   = getattr(method, 'CHILDREN', False)\n            no_change  = getattr(method, 'NO_CHANGE', False)\n\n            for tree_tuple in tree_tuples:\n                for tn in sorted(getattr(method, 'TEXT', (0,))):\n                    for an in sorted(getattr(method, 'ATTRIBUTES', (0,))):\n                        benchmarks.append((name, method_call, tree_tuple,\n                                           tn, an, serialized, children,\n                                           no_change))\n\n        return benchmarks\n\n    def _permutations(self, seq, count):\n        def _permutations(prefix, remainder, count):\n            if count == 0:\n                return [ prefix[:] ]\n            count -= 1\n            perms = []\n            prefix.append(None)\n            for pos, el in enumerate(remainder):\n                new_remainder = remainder[:pos] + remainder[pos+1:]\n                prefix[-1] = el\n                perms.extend( _permutations(prefix, new_remainder, count) )\n            prefix.pop()\n            return perms\n        return _permutations([], seq, count)\n\n############################################################\n# Prepare and run benchmark suites\n############################################################\n\ndef buildSuites(benchmark_class, etrees, selected):\n    benchmark_suites = list(map(benchmark_class, etrees))\n\n    # sorted by name and tree tuple\n    benchmarks = [ sorted(b.benchmarks()) for b in benchmark_suites ]\n\n    selected = [ re.compile(r).search for r in selected ]\n\n    if selected:\n        benchmarks = [ [ b for b in bs\n                         if [ match for match in selected\n                              if match(b[0]) ] ]\n                       for bs in benchmarks ]\n\n    return benchmark_suites, benchmarks\n\ndef build_treeset_name(trees, tn, an, serialized, children):\n    text = {0:'-', 1:'S', 2:'U'}[tn]\n    attr = {0:'-', 1:'A'}[an]\n    ser  = {True:'X', False:'T'}[serialized]\n    chd  = {True:'C', False:'R'}[children]\n    return \"%s%s%s%s T%s\" % (text, attr, ser, chd, ',T'.join(map(str, trees))[:6])\n\ndef printSetupTimes(benchmark_suites):\n    print(\"Setup times for trees in seconds:\")\n    for b in benchmark_suites:\n        sys.stdout.write(\"%-3s:     \" % b.lib_name)\n        for an in (0,1):\n            for tn in (0,1,2):\n                sys.stdout.write('  %s   ' %\n                    build_treeset_name((), tn, an, False, False)[:2])\n        print('')\n        for i, tree_times in enumerate(b.setup_times):\n            print(\"     T%d: %s\" % (i+1, ' '.join(\"%6.4f\" % t for t in tree_times)))\n    print('')\n\ndef runBench(suite, method_name, method_call, tree_set, tn, an,\n             serial, children, no_change):\n    if method_call is None:\n        raise SkippedTest\n\n    current_time = time.time\n    call_repeat = range(10)\n\n    tree_builders = [ suite.tree_builder(tree, tn, an, serial, children)\n                      for tree in tree_set ]\n\n    rebuild_trees = not no_change and not serial\n\n    args = tuple([ build() for build in tree_builders ])\n    method_call(*args) # run once to skip setup overhead\n\n    times = []\n    for i in range(3):\n        gc.collect()\n        gc.disable()\n        t = -1\n        for i in call_repeat:\n            if rebuild_trees:\n                args = [ build() for build in tree_builders ]\n            t_one_call = current_time()\n            method_call(*args)\n            t_one_call = current_time() - t_one_call\n            if t < 0:\n                t = t_one_call\n            else:\n                t = min(t, t_one_call)\n        times.append(1000.0 * t)\n        gc.enable()\n        if rebuild_trees:\n            args = ()\n    args = ()\n    gc.collect()\n    return times\n\n\ndef runBenchmarks(benchmark_suites, benchmarks):\n    for bench_calls in izip(*benchmarks):\n        for lib, (bench, benchmark_setup) in enumerate(izip(benchmark_suites, bench_calls)):\n            bench_name = benchmark_setup[0]\n            tree_set_name = build_treeset_name(*benchmark_setup[-6:-1])\n            sys.stdout.write(\"%-3s: %-28s (%-10s) \" % (\n                bench.lib_name, bench_name[6:34], tree_set_name))\n            sys.stdout.flush()\n\n            try:\n                result = runBench(bench, *benchmark_setup)\n            except SkippedTest:\n                print(\"skipped\")\n            except KeyboardInterrupt:\n                print(\"interrupted by user\")\n                sys.exit(1)\n            except Exception:\n                exc_type, exc_value = sys.exc_info()[:2]\n                print(\"failed: %s: %s\" % (exc_type.__name__, exc_value))\n                exc_type = exc_value = None\n            else:\n                print(\"%9.4f msec/pass, best of (%s)\" % (\n                      min(result), ' '.join(\"%9.4f\" % t for t in result)))\n\n        if len(benchmark_suites) > 1:\n            print('')  # empty line between different benchmarks\n\n############################################################\n# Main program\n############################################################\n\ndef main(benchmark_class):\n    import_lxml = True\n    callgrind_zero = False\n    if len(sys.argv) > 1:\n        try:\n            sys.argv.remove('-i')\n            # run benchmark 'inplace'\n            sys.path.insert(0, 'src')\n        except ValueError:\n            pass\n\n        try:\n            sys.argv.remove('-nolxml')\n            # run without lxml\n            import_lxml = False\n        except ValueError:\n            pass\n\n        try:\n            sys.argv.remove('-z')\n            # reset callgrind after tree setup\n            callgrind_zero = True\n        except ValueError:\n            pass\n\n        initArgs(sys.argv)\n\n    _etrees = []\n    if import_lxml:\n        from lxml import etree\n        _etrees.append(etree)\n        print(\"Using lxml %s (with libxml2 %s)\" % (\n            etree.__version__, '.'.join(map(str, etree.LIBXML_VERSION))))\n\n        try:\n            sys.argv.remove('-fel')\n        except ValueError:\n            pass\n        else:\n            # use fast element creation in lxml.etree\n            etree.set_element_class_lookup(\n                etree.ElementDefaultClassLookup())\n\n    if len(sys.argv) > 1:\n        if '-a' in sys.argv or '-c' in sys.argv:\n            # 'all' or 'C-implementations' ?\n            try:\n                sys.argv.remove('-c')\n            except ValueError:\n                pass\n            try:\n                import cElementTree as cET\n                _etrees.append(cET)\n            except ImportError:\n                try:\n                    import xml.etree.cElementTree as cET\n                    _etrees.append(cET)\n                except ImportError:\n                    pass\n\n        try:\n            # 'all' ?\n            sys.argv.remove('-a')\n        except ValueError:\n            pass\n        else:\n            try:\n                from elementtree import ElementTree as ET\n                _etrees.append(ET)\n            except ImportError:\n                try:\n                    from xml.etree import ElementTree as ET\n                    _etrees.append(ET)\n                except ImportError:\n                    pass\n\n    if not _etrees:\n        print(\"No library to test. Exiting.\")\n        sys.exit(1)\n\n    print(\"Running benchmarks in Python %s\" % (sys.version_info,))\n\n    print(\"Preparing test suites and trees ...\")\n    selected = set( sys.argv[1:] )\n    benchmark_suites, benchmarks = \\\n                      buildSuites(benchmark_class, _etrees, selected)\n\n    print(\"Running benchmark on\", ', '.join(b.lib_name\n                                            for b in benchmark_suites))\n    print('')\n\n    printSetupTimes(benchmark_suites)\n\n    if callgrind_zero:\n        cmd = open(\"callgrind.cmd\", 'w')\n        cmd.write('+Instrumentation\\n')\n        cmd.write('Zero\\n')\n        cmd.close()\n\n    runBenchmarks(benchmark_suites, benchmarks)\n", "src/lxml/usedoctest.py": "\"\"\"Doctest module for XML comparison.\n\nUsage::\n\n   >>> import lxml.usedoctest\n   >>> # now do your XML doctests ...\n\nSee `lxml.doctestcompare`\n\"\"\"\n\nfrom lxml import doctestcompare\n\ndoctestcompare.temp_install(del_module=__name__)\n", "src/lxml/sax.py": "# cython: language_level=2\n\n\"\"\"\nSAX-based adapter to copy trees from/to the Python standard library.\n\nUse the `ElementTreeContentHandler` class to build an ElementTree from\nSAX events.\n\nUse the `ElementTreeProducer` class or the `saxify()` function to fire\nthe SAX events of an ElementTree against a SAX ContentHandler.\n\nSee https://lxml.de/sax.html\n\"\"\"\n\n\nfrom xml.sax.handler import ContentHandler\nfrom lxml import etree\nfrom lxml.etree import ElementTree, SubElement\nfrom lxml.etree import Comment, ProcessingInstruction\n\n\nclass SaxError(etree.LxmlError):\n    \"\"\"General SAX error.\n    \"\"\"\n\n\ndef _getNsTag(tag):\n    if tag[0] == '{':\n        return tuple(tag[1:].split('}', 1))\n    else:\n        return None, tag\n\n\nclass ElementTreeContentHandler(ContentHandler):\n    \"\"\"Build an lxml ElementTree from SAX events.\n    \"\"\"\n    def __init__(self, makeelement=None):\n        ContentHandler.__init__(self)\n        self._root = None\n        self._root_siblings = []\n        self._element_stack = []\n        self._default_ns = None\n        self._ns_mapping = { None : [None] }\n        self._new_mappings = {}\n        if makeelement is None:\n            makeelement = etree.Element\n        self._makeelement = makeelement\n\n    def _get_etree(self):\n        \"Contains the generated ElementTree after parsing is finished.\"\n        return ElementTree(self._root)\n\n    etree = property(_get_etree, doc=_get_etree.__doc__)\n\n    def setDocumentLocator(self, locator):\n        pass\n\n    def startDocument(self):\n        pass\n\n    def endDocument(self):\n        pass\n\n    def startPrefixMapping(self, prefix, uri):\n        self._new_mappings[prefix] = uri\n        try:\n            self._ns_mapping[prefix].append(uri)\n        except KeyError:\n            self._ns_mapping[prefix] = [uri]\n        if prefix is None:\n            self._default_ns = uri\n\n    def endPrefixMapping(self, prefix):\n        ns_uri_list = self._ns_mapping[prefix]\n        ns_uri_list.pop()\n        if prefix is None:\n            self._default_ns = ns_uri_list[-1]\n\n    def _buildTag(self, ns_name_tuple):\n        ns_uri, local_name = ns_name_tuple\n        if ns_uri:\n            el_tag = \"{%s}%s\" % ns_name_tuple\n        elif self._default_ns:\n            el_tag = \"{%s}%s\" % (self._default_ns, local_name)\n        else:\n            el_tag = local_name\n        return el_tag\n\n    def startElementNS(self, ns_name, qname, attributes=None):\n        el_name = self._buildTag(ns_name)\n        if attributes:\n            attrs = {}\n            try:\n                iter_attributes = attributes.iteritems()\n            except AttributeError:\n                iter_attributes = attributes.items()\n\n            for name_tuple, value in iter_attributes:\n                if name_tuple[0]:\n                    attr_name = \"{%s}%s\" % name_tuple\n                else:\n                    attr_name = name_tuple[1]\n                attrs[attr_name] = value\n        else:\n            attrs = None\n\n        element_stack = self._element_stack\n        if self._root is None:\n            element = self._root = \\\n                      self._makeelement(el_name, attrs, self._new_mappings)\n            if self._root_siblings and hasattr(element, 'addprevious'):\n                for sibling in self._root_siblings:\n                    element.addprevious(sibling)\n            del self._root_siblings[:]\n        else:\n            element = SubElement(element_stack[-1], el_name,\n                                 attrs, self._new_mappings)\n        element_stack.append(element)\n\n        self._new_mappings.clear()\n\n    def processingInstruction(self, target, data):\n        pi = ProcessingInstruction(target, data)\n        if self._root is None:\n            self._root_siblings.append(pi)\n        else:\n            self._element_stack[-1].append(pi)\n\n    def endElementNS(self, ns_name, qname):\n        element = self._element_stack.pop()\n        el_tag = self._buildTag(ns_name)\n        if el_tag != element.tag:\n            raise SaxError(\"Unexpected element closed: \" + el_tag)\n\n    def startElement(self, name, attributes=None):\n        if attributes:\n            attributes = {(None, k): v for k, v in attributes.items()}\n        self.startElementNS((None, name), name, attributes)\n\n    def endElement(self, name):\n        self.endElementNS((None, name), name)\n\n    def characters(self, data):\n        last_element = self._element_stack[-1]\n        try:\n            # if there already is a child element, we must append to its tail\n            last_element = last_element[-1]\n            last_element.tail = (last_element.tail or '') + data\n        except IndexError:\n            # otherwise: append to the text\n            last_element.text = (last_element.text or '') + data\n\n    ignorableWhitespace = characters\n\n\nclass ElementTreeProducer:\n    \"\"\"Produces SAX events for an element and children.\n    \"\"\"\n    def __init__(self, element_or_tree, content_handler):\n        try:\n            element = element_or_tree.getroot()\n        except AttributeError:\n            element = element_or_tree\n        self._element = element\n        self._content_handler = content_handler\n        from xml.sax.xmlreader import AttributesNSImpl as attr_class\n        self._attr_class = attr_class\n        self._empty_attributes = attr_class({}, {})\n\n    def saxify(self):\n        self._content_handler.startDocument()\n\n        element = self._element\n        if hasattr(element, 'getprevious'):\n            siblings = []\n            sibling = element.getprevious()\n            while getattr(sibling, 'tag', None) is ProcessingInstruction:\n                siblings.append(sibling)\n                sibling = sibling.getprevious()\n            for sibling in siblings[::-1]:\n                self._recursive_saxify(sibling, {})\n\n        self._recursive_saxify(element, {})\n\n        if hasattr(element, 'getnext'):\n            sibling = element.getnext()\n            while getattr(sibling, 'tag', None) is ProcessingInstruction:\n                self._recursive_saxify(sibling, {})\n                sibling = sibling.getnext()\n\n        self._content_handler.endDocument()\n\n    def _recursive_saxify(self, element, parent_nsmap):\n        content_handler = self._content_handler\n        tag = element.tag\n        if tag is Comment or tag is ProcessingInstruction:\n            if tag is ProcessingInstruction:\n                content_handler.processingInstruction(\n                    element.target, element.text)\n            tail = element.tail\n            if tail:\n                content_handler.characters(tail)\n            return\n\n        element_nsmap = element.nsmap\n        new_prefixes = []\n        if element_nsmap != parent_nsmap:\n            # There have been updates to the namespace\n            for prefix, ns_uri in element_nsmap.items():\n                if parent_nsmap.get(prefix) != ns_uri:\n                    new_prefixes.append( (prefix, ns_uri) )\n\n        attribs = element.items()\n        if attribs:\n            attr_values = {}\n            attr_qnames = {}\n            for attr_ns_name, value in attribs:\n                attr_ns_tuple = _getNsTag(attr_ns_name)\n                attr_values[attr_ns_tuple] = value\n                attr_qnames[attr_ns_tuple] = self._build_qname(\n                    attr_ns_tuple[0], attr_ns_tuple[1], element_nsmap,\n                    preferred_prefix=None, is_attribute=True)\n            sax_attributes = self._attr_class(attr_values, attr_qnames)\n        else:\n            sax_attributes = self._empty_attributes\n\n        ns_uri, local_name = _getNsTag(tag)\n        qname = self._build_qname(\n            ns_uri, local_name, element_nsmap, element.prefix, is_attribute=False)\n\n        for prefix, uri in new_prefixes:\n            content_handler.startPrefixMapping(prefix, uri)\n        content_handler.startElementNS(\n            (ns_uri, local_name), qname, sax_attributes)\n        text = element.text\n        if text:\n            content_handler.characters(text)\n        for child in element:\n            self._recursive_saxify(child, element_nsmap)\n        content_handler.endElementNS((ns_uri, local_name), qname)\n        for prefix, uri in new_prefixes:\n            content_handler.endPrefixMapping(prefix)\n        tail = element.tail\n        if tail:\n            content_handler.characters(tail)\n\n    def _build_qname(self, ns_uri, local_name, nsmap, preferred_prefix, is_attribute):\n        if ns_uri is None:\n            return local_name\n\n        if not is_attribute and nsmap.get(preferred_prefix) == ns_uri:\n            prefix = preferred_prefix\n        else:\n            # Pick the first matching prefix, in alphabetical order.\n            candidates = [\n                pfx for (pfx, uri) in nsmap.items()\n                if pfx is not None and uri == ns_uri\n            ]\n            prefix = (\n                candidates[0] if len(candidates) == 1\n                else min(candidates) if candidates\n                else None\n            )\n\n        if prefix is None:\n            # Default namespace\n            return local_name\n        return prefix + ':' + local_name\n\n\ndef saxify(element_or_tree, content_handler):\n    \"\"\"One-shot helper to generate SAX events from an XML tree and fire\n    them against a SAX ContentHandler.\n    \"\"\"\n    return ElementTreeProducer(element_or_tree, content_handler).saxify()\n", "src/lxml/pyclasslookup.py": "# dummy module for backwards compatibility\n\nfrom lxml.etree import PythonElementClassLookup\n", "src/lxml/ElementInclude.py": "#\n# ElementTree\n# $Id: ElementInclude.py 1862 2004-06-18 07:31:02Z Fredrik $\n#\n# limited xinclude support for element trees\n#\n# history:\n# 2003-08-15 fl   created\n# 2003-11-14 fl   fixed default loader\n#\n# Copyright (c) 2003-2004 by Fredrik Lundh.  All rights reserved.\n#\n# fredrik@pythonware.com\n# http://www.pythonware.com\n#\n# --------------------------------------------------------------------\n# The ElementTree toolkit is\n#\n# Copyright (c) 1999-2004 by Fredrik Lundh\n#\n# By obtaining, using, and/or copying this software and/or its\n# associated documentation, you agree that you have read, understood,\n# and will comply with the following terms and conditions:\n#\n# Permission to use, copy, modify, and distribute this software and\n# its associated documentation for any purpose and without fee is\n# hereby granted, provided that the above copyright notice appears in\n# all copies, and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of\n# Secret Labs AB or the author not be used in advertising or publicity\n# pertaining to distribution of the software without specific, written\n# prior permission.\n#\n# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD\n# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-\n# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR\n# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\n# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n# OF THIS SOFTWARE.\n# --------------------------------------------------------------------\n\n\"\"\"\nLimited XInclude support for the ElementTree package.\n\nWhile lxml.etree has full support for XInclude (see\n`etree.ElementTree.xinclude()`), this module provides a simpler, pure\nPython, ElementTree compatible implementation that supports a simple\nform of custom URL resolvers.\n\"\"\"\n\nfrom lxml import etree\ntry:\n    from urlparse import urljoin\n    from urllib2 import urlopen\nexcept ImportError:\n    # Python 3\n    from urllib.parse import urljoin\n    from urllib.request import urlopen\n\nXINCLUDE = \"{http://www.w3.org/2001/XInclude}\"\n\nXINCLUDE_INCLUDE = XINCLUDE + \"include\"\nXINCLUDE_FALLBACK = XINCLUDE + \"fallback\"\nXINCLUDE_ITER_TAG = XINCLUDE + \"*\"\n\n# For security reasons, the inclusion depth is limited to this read-only value by default.\nDEFAULT_MAX_INCLUSION_DEPTH = 6\n\n\n##\n# Fatal include error.\n\nclass FatalIncludeError(etree.LxmlSyntaxError):\n    pass\n\n\nclass LimitedRecursiveIncludeError(FatalIncludeError):\n    pass\n\n\n##\n# ET compatible default loader.\n# This loader reads an included resource from disk.\n#\n# @param href Resource reference.\n# @param parse Parse mode.  Either \"xml\" or \"text\".\n# @param encoding Optional text encoding.\n# @return The expanded resource.  If the parse mode is \"xml\", this\n#    is an ElementTree instance.  If the parse mode is \"text\", this\n#    is a Unicode string.  If the loader fails, it can return None\n#    or raise an IOError exception.\n# @throws IOError If the loader fails to load the resource.\n\ndef default_loader(href, parse, encoding=None):\n    file = open(href, 'rb')\n    if parse == \"xml\":\n        data = etree.parse(file).getroot()\n    else:\n        data = file.read()\n        if not encoding:\n            encoding = 'utf-8'\n        data = data.decode(encoding)\n    file.close()\n    return data\n\n\n##\n# Default loader used by lxml.etree - handles custom resolvers properly\n# \n\ndef _lxml_default_loader(href, parse, encoding=None, parser=None):\n    if parse == \"xml\":\n        data = etree.parse(href, parser).getroot()\n    else:\n        if \"://\" in href:\n            f = urlopen(href)\n        else:\n            f = open(href, 'rb')\n        data = f.read()\n        f.close()\n        if not encoding:\n            encoding = 'utf-8'\n        data = data.decode(encoding)\n    return data\n\n\n##\n# Wrapper for ET compatibility - drops the parser\n\ndef _wrap_et_loader(loader):\n    def load(href, parse, encoding=None, parser=None):\n        return loader(href, parse, encoding)\n    return load\n\n\n##\n# Expand XInclude directives.\n#\n# @param elem Root element.\n# @param loader Optional resource loader.  If omitted, it defaults\n#     to {@link default_loader}.  If given, it should be a callable\n#     that implements the same interface as <b>default_loader</b>.\n# @param base_url The base URL of the original file, to resolve\n#     relative include file references.\n# @param max_depth The maximum number of recursive inclusions.\n#     Limited to reduce the risk of malicious content explosion.\n#     Pass None to disable the limitation.\n# @throws LimitedRecursiveIncludeError If the {@link max_depth} was exceeded.\n# @throws FatalIncludeError If the function fails to include a given\n#     resource, or if the tree contains malformed XInclude elements.\n# @throws IOError If the function fails to load a given resource.\n# @returns the node or its replacement if it was an XInclude node\n\ndef include(elem, loader=None, base_url=None,\n            max_depth=DEFAULT_MAX_INCLUSION_DEPTH):\n    if max_depth is None:\n        max_depth = -1\n    elif max_depth < 0:\n        raise ValueError(\"expected non-negative depth or None for 'max_depth', got %r\" % max_depth)\n\n    if base_url is None:\n        if hasattr(elem, 'getroot'):\n            tree = elem\n            elem = elem.getroot()\n        else:\n            tree = elem.getroottree()\n        if hasattr(tree, 'docinfo'):\n            base_url = tree.docinfo.URL\n    elif hasattr(elem, 'getroot'):\n        elem = elem.getroot()\n    _include(elem, loader, base_url, max_depth)\n\n\ndef _include(elem, loader=None, base_url=None,\n             max_depth=DEFAULT_MAX_INCLUSION_DEPTH, _parent_hrefs=None):\n    if loader is not None:\n        load_include = _wrap_et_loader(loader)\n    else:\n        load_include = _lxml_default_loader\n\n    if _parent_hrefs is None:\n        _parent_hrefs = set()\n\n    parser = elem.getroottree().parser\n\n    include_elements = list(\n        elem.iter(XINCLUDE_ITER_TAG))\n\n    for e in include_elements:\n        if e.tag == XINCLUDE_INCLUDE:\n            # process xinclude directive\n            href = urljoin(base_url, e.get(\"href\"))\n            parse = e.get(\"parse\", \"xml\")\n            parent = e.getparent()\n            if parse == \"xml\":\n                if href in _parent_hrefs:\n                    raise FatalIncludeError(\n                        \"recursive include of %r detected\" % href\n                        )\n                if max_depth == 0:\n                    raise LimitedRecursiveIncludeError(\n                        \"maximum xinclude depth reached when including file %s\" % href)\n                node = load_include(href, parse, parser=parser)\n                if node is None:\n                    raise FatalIncludeError(\n                        \"cannot load %r as %r\" % (href, parse)\n                        )\n                node = _include(node, loader, href, max_depth - 1, {href} | _parent_hrefs)\n                if e.tail:\n                    node.tail = (node.tail or \"\") + e.tail\n                if parent is None:\n                    return node # replaced the root node!\n                parent.replace(e, node)\n            elif parse == \"text\":\n                text = load_include(href, parse, encoding=e.get(\"encoding\"))\n                if text is None:\n                    raise FatalIncludeError(\n                        \"cannot load %r as %r\" % (href, parse)\n                        )\n                predecessor = e.getprevious()\n                if predecessor is not None:\n                    predecessor.tail = (predecessor.tail or \"\") + text\n                elif parent is None:\n                    return text # replaced the root node!\n                else:\n                    parent.text = (parent.text or \"\") + text + (e.tail or \"\")\n                parent.remove(e)\n            else:\n                raise FatalIncludeError(\n                    \"unknown parse type in xi:include tag (%r)\" % parse\n                )\n        elif e.tag == XINCLUDE_FALLBACK:\n            parent = e.getparent()\n            if parent is not None and parent.tag != XINCLUDE_INCLUDE:\n                raise FatalIncludeError(\n                    \"xi:fallback tag must be child of xi:include (%r)\" % e.tag\n                    )\n        else:\n            raise FatalIncludeError(\n                \"Invalid element found in XInclude namespace (%r)\" % e.tag\n                )\n    return elem\n", "src/lxml/cssselect.py": "\"\"\"CSS Selectors based on XPath.\n\nThis module supports selecting XML/HTML tags based on CSS selectors.\nSee the `CSSSelector` class for details.\n\nThis is a thin wrapper around cssselect 0.7 or later.\n\"\"\"\n\n\nfrom . import etree\ntry:\n    import cssselect as external_cssselect\nexcept ImportError:\n    raise ImportError(\n        'cssselect does not seem to be installed. '\n        'See https://pypi.org/project/cssselect/')\n\n\nSelectorSyntaxError = external_cssselect.SelectorSyntaxError\nExpressionError = external_cssselect.ExpressionError\nSelectorError = external_cssselect.SelectorError\n\n\n__all__ = ['SelectorSyntaxError', 'ExpressionError', 'SelectorError',\n           'CSSSelector']\n\n\nclass LxmlTranslator(external_cssselect.GenericTranslator):\n    \"\"\"\n    A custom CSS selector to XPath translator with lxml-specific extensions.\n    \"\"\"\n    def xpath_contains_function(self, xpath, function):\n        # Defined there, removed in later drafts:\n        # http://www.w3.org/TR/2001/CR-css3-selectors-20011113/#content-selectors\n        if function.argument_types() not in (['STRING'], ['IDENT']):\n            raise ExpressionError(\n                \"Expected a single string or ident for :contains(), got %r\"\n                % function.arguments)\n        value = function.arguments[0].value\n        return xpath.add_condition(\n            'contains(__lxml_internal_css:lower-case(string(.)), %s)'\n            % self.xpath_literal(value.lower()))\n\n\nclass LxmlHTMLTranslator(LxmlTranslator, external_cssselect.HTMLTranslator):\n    \"\"\"\n    lxml extensions + HTML support.\n    \"\"\"\n\n\ndef _make_lower_case(context, s):\n    return s.lower()\n\nns = etree.FunctionNamespace('http://codespeak.net/lxml/css/')\nns.prefix = '__lxml_internal_css'\nns['lower-case'] = _make_lower_case\n\n\nclass CSSSelector(etree.XPath):\n    \"\"\"A CSS selector.\n\n    Usage::\n\n        >>> from lxml import etree, cssselect\n        >>> select = cssselect.CSSSelector(\"a tag > child\")\n\n        >>> root = etree.XML(\"<a><b><c/><tag><child>TEXT</child></tag></b></a>\")\n        >>> [ el.tag for el in select(root) ]\n        ['child']\n\n    To use CSS namespaces, you need to pass a prefix-to-namespace\n    mapping as ``namespaces`` keyword argument::\n\n        >>> rdfns = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'\n        >>> select_ns = cssselect.CSSSelector('root > rdf|Description',\n        ...                                   namespaces={'rdf': rdfns})\n\n        >>> rdf = etree.XML((\n        ...     '<root xmlns:rdf=\"%s\">'\n        ...       '<rdf:Description>blah</rdf:Description>'\n        ...     '</root>') % rdfns)\n        >>> [(el.tag, el.text) for el in select_ns(rdf)]\n        [('{http://www.w3.org/1999/02/22-rdf-syntax-ns#}Description', 'blah')]\n\n    \"\"\"\n    def __init__(self, css, namespaces=None, translator='xml'):\n        if translator == 'xml':\n            translator = LxmlTranslator()\n        elif translator == 'html':\n            translator = LxmlHTMLTranslator()\n        elif translator == 'xhtml':\n            translator = LxmlHTMLTranslator(xhtml=True)\n        path = translator.css_to_xpath(css)\n        super().__init__(path, namespaces=namespaces)\n        self.css = css\n\n    def __repr__(self):\n        return '<%s %x for %r>' % (\n            self.__class__.__name__,\n            abs(id(self)),\n            self.css)\n", "src/lxml/__init__.py": "# this is a package\n\n__version__ = \"5.2.2\"\n\n\ndef get_include():\n    \"\"\"\n    Returns a list of header include paths (for lxml itself, libxml2\n    and libxslt) needed to compile C code against lxml if it was built\n    with statically linked libraries.\n    \"\"\"\n    import os\n    lxml_path = __path__[0]\n    include_path = os.path.join(lxml_path, 'includes')\n    includes = [include_path, lxml_path]\n\n    for name in os.listdir(include_path):\n        path = os.path.join(include_path, name)\n        if os.path.isdir(path):\n            includes.append(path)\n\n    return includes\n", "src/lxml/builder.py": "# cython: language_level=2\n\n#\n# Element generator factory by Fredrik Lundh.\n#\n# Source:\n#    http://online.effbot.org/2006_11_01_archive.htm#et-builder\n#    http://effbot.python-hosting.com/file/stuff/sandbox/elementlib/builder.py\n#\n# --------------------------------------------------------------------\n# The ElementTree toolkit is\n#\n# Copyright (c) 1999-2004 by Fredrik Lundh\n#\n# By obtaining, using, and/or copying this software and/or its\n# associated documentation, you agree that you have read, understood,\n# and will comply with the following terms and conditions:\n#\n# Permission to use, copy, modify, and distribute this software and\n# its associated documentation for any purpose and without fee is\n# hereby granted, provided that the above copyright notice appears in\n# all copies, and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of\n# Secret Labs AB or the author not be used in advertising or publicity\n# pertaining to distribution of the software without specific, written\n# prior permission.\n#\n# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD\n# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-\n# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR\n# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\n# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n# OF THIS SOFTWARE.\n# --------------------------------------------------------------------\n\n\"\"\"\nThe ``E`` Element factory for generating XML documents.\n\"\"\"\n\n\nimport lxml.etree as ET\n_QName = ET.QName\n\nfrom functools import partial\n\ntry:\n    basestring\nexcept NameError:\n    basestring = str\n\ntry:\n    unicode\nexcept NameError:\n    unicode = str\n\n\nclass ElementMaker:\n    \"\"\"Element generator factory.\n\n    Unlike the ordinary Element factory, the E factory allows you to pass in\n    more than just a tag and some optional attributes; you can also pass in\n    text and other elements.  The text is added as either text or tail\n    attributes, and elements are inserted at the right spot.  Some small\n    examples::\n\n        >>> from lxml import etree as ET\n        >>> from lxml.builder import E\n\n        >>> ET.tostring(E(\"tag\"))\n        '<tag/>'\n        >>> ET.tostring(E(\"tag\", \"text\"))\n        '<tag>text</tag>'\n        >>> ET.tostring(E(\"tag\", \"text\", key=\"value\"))\n        '<tag key=\"value\">text</tag>'\n        >>> ET.tostring(E(\"tag\", E(\"subtag\", \"text\"), \"tail\"))\n        '<tag><subtag>text</subtag>tail</tag>'\n\n    For simple tags, the factory also allows you to write ``E.tag(...)`` instead\n    of ``E('tag', ...)``::\n\n        >>> ET.tostring(E.tag())\n        '<tag/>'\n        >>> ET.tostring(E.tag(\"text\"))\n        '<tag>text</tag>'\n        >>> ET.tostring(E.tag(E.subtag(\"text\"), \"tail\"))\n        '<tag><subtag>text</subtag>tail</tag>'\n\n    Here's a somewhat larger example; this shows how to generate HTML\n    documents, using a mix of prepared factory functions for inline elements,\n    nested ``E.tag`` calls, and embedded XHTML fragments::\n\n        # some common inline elements\n        A = E.a\n        I = E.i\n        B = E.b\n\n        def CLASS(v):\n            # helper function, 'class' is a reserved word\n            return {'class': v}\n\n        page = (\n            E.html(\n                E.head(\n                    E.title(\"This is a sample document\")\n                ),\n                E.body(\n                    E.h1(\"Hello!\", CLASS(\"title\")),\n                    E.p(\"This is a paragraph with \", B(\"bold\"), \" text in it!\"),\n                    E.p(\"This is another paragraph, with a \",\n                        A(\"link\", href=\"http://www.python.org\"), \".\"),\n                    E.p(\"Here are some reserved characters: <spam&egg>.\"),\n                    ET.XML(\"<p>And finally, here is an embedded XHTML fragment.</p>\"),\n                )\n            )\n        )\n\n        print ET.tostring(page)\n\n    Here's a prettyprinted version of the output from the above script::\n\n        <html>\n          <head>\n            <title>This is a sample document</title>\n          </head>\n          <body>\n            <h1 class=\"title\">Hello!</h1>\n            <p>This is a paragraph with <b>bold</b> text in it!</p>\n            <p>This is another paragraph, with <a href=\"http://www.python.org\">link</a>.</p>\n            <p>Here are some reserved characters: &lt;spam&amp;egg&gt;.</p>\n            <p>And finally, here is an embedded XHTML fragment.</p>\n          </body>\n        </html>\n\n    For namespace support, you can pass a namespace map (``nsmap``)\n    and/or a specific target ``namespace`` to the ElementMaker class::\n\n        >>> E = ElementMaker(namespace=\"http://my.ns/\")\n        >>> print(ET.tostring( E.test ))\n        <test xmlns=\"http://my.ns/\"/>\n\n        >>> E = ElementMaker(namespace=\"http://my.ns/\", nsmap={'p':'http://my.ns/'})\n        >>> print(ET.tostring( E.test ))\n        <p:test xmlns:p=\"http://my.ns/\"/>\n    \"\"\"\n\n    def __init__(self, typemap=None,\n                 namespace=None, nsmap=None, makeelement=None):\n        self._namespace = '{' + namespace + '}' if namespace is not None else None\n        self._nsmap = dict(nsmap) if nsmap else None\n\n        assert makeelement is None or callable(makeelement)\n        self._makeelement = makeelement if makeelement is not None else ET.Element\n\n        # initialize the default type map functions for this element factory\n        typemap = dict(typemap) if typemap else {}\n\n        def add_text(elem, item):\n            try:\n                last_child = elem[-1]\n            except IndexError:\n                elem.text = (elem.text or \"\") + item\n            else:\n                last_child.tail = (last_child.tail or \"\") + item\n\n        def add_cdata(elem, cdata):\n            if elem.text:\n                raise ValueError(\"Can't add a CDATA section. Element already has some text: %r\" % elem.text)\n            elem.text = cdata\n\n        if str not in typemap:\n            typemap[str] = add_text\n        if unicode not in typemap:\n            typemap[unicode] = add_text\n        if ET.CDATA not in typemap:\n            typemap[ET.CDATA] = add_cdata\n\n        def add_dict(elem, item):\n            attrib = elem.attrib\n            for k, v in item.items():\n                if isinstance(v, basestring):\n                    attrib[k] = v\n                else:\n                    attrib[k] = typemap[type(v)](None, v)\n\n        if dict not in typemap:\n            typemap[dict] = add_dict\n\n        self._typemap = typemap\n\n    def __call__(self, tag, *children, **attrib):\n        typemap = self._typemap\n\n        # We'll usually get a 'str', and the compiled type check is very fast.\n        if not isinstance(tag, str) and isinstance(tag, _QName):\n            # A QName is explicitly qualified, do not look at self._namespace.\n            tag = tag.text\n        elif self._namespace is not None and tag[0] != '{':\n            tag = self._namespace + tag\n        elem = self._makeelement(tag, nsmap=self._nsmap)\n        if attrib:\n            typemap[dict](elem, attrib)\n\n        for item in children:\n            if callable(item):\n                item = item()\n            t = typemap.get(type(item))\n            if t is None:\n                if ET.iselement(item):\n                    elem.append(item)\n                    continue\n                for basetype in type(item).__mro__:\n                    # See if the typemap knows of any of this type's bases.\n                    t = typemap.get(basetype)\n                    if t is not None:\n                        break\n                else:\n                    raise TypeError(\"bad argument type: %s(%r)\" %\n                                    (type(item).__name__, item))\n            v = t(elem, item)\n            if v:\n                typemap.get(type(v))(elem, v)\n\n        return elem\n\n    def __getattr__(self, tag):\n        return partial(self, tag)\n\n\n# create factory object\nE = ElementMaker()\n", "src/lxml/doctestcompare.py": "\"\"\"\nlxml-based doctest output comparison.\n\nNote: normally, you should just import the `lxml.usedoctest` and\n`lxml.html.usedoctest` modules from within a doctest, instead of this\none::\n\n    >>> import lxml.usedoctest # for XML output\n\n    >>> import lxml.html.usedoctest # for HTML output\n\nTo use this module directly, you must call ``lxmldoctest.install()``,\nwhich will cause doctest to use this in all subsequent calls.\n\nThis changes the way output is checked and comparisons are made for\nXML or HTML-like content.\n\nXML or HTML content is noticed because the example starts with ``<``\n(it's HTML if it starts with ``<html``).  You can also use the\n``PARSE_HTML`` and ``PARSE_XML`` flags to force parsing.\n\nSome rough wildcard-like things are allowed.  Whitespace is generally\nignored (except in attributes).  In text (attributes and text in the\nbody) you can use ``...`` as a wildcard.  In an example it also\nmatches any trailing tags in the element, though it does not match\nleading tags.  You may create a tag ``<any>`` or include an ``any``\nattribute in the tag.  An ``any`` tag matches any tag, while the\nattribute matches any and all attributes.\n\nWhen a match fails, the reformatted example and gotten text is\ndisplayed (indented), and a rough diff-like output is given.  Anything\nmarked with ``+`` is in the output but wasn't supposed to be, and\nsimilarly ``-`` means its in the example but wasn't in the output.\n\nYou can disable parsing on one line with ``# doctest:+NOPARSE_MARKUP``\n\"\"\"\n\nfrom lxml import etree\nimport sys\nimport re\nimport doctest\ntry:\n    from html import escape as html_escape\nexcept ImportError:\n    from cgi import escape as html_escape\n\n__all__ = ['PARSE_HTML', 'PARSE_XML', 'NOPARSE_MARKUP', 'LXMLOutputChecker',\n           'LHTMLOutputChecker', 'install', 'temp_install']\n\nPARSE_HTML = doctest.register_optionflag('PARSE_HTML')\nPARSE_XML = doctest.register_optionflag('PARSE_XML')\nNOPARSE_MARKUP = doctest.register_optionflag('NOPARSE_MARKUP')\n\nOutputChecker = doctest.OutputChecker\n\ndef strip(v):\n    if v is None:\n        return None\n    else:\n        return v.strip()\n\ndef norm_whitespace(v):\n    return _norm_whitespace_re.sub(' ', v)\n\n_html_parser = etree.HTMLParser(recover=False, remove_blank_text=True)\n\ndef html_fromstring(html):\n    return etree.fromstring(html, _html_parser)\n\n# We use this to distinguish repr()s from elements:\n_repr_re = re.compile(r'^<[^>]+ (at|object) ')\n_norm_whitespace_re = re.compile(r'[ \\t\\n][ \\t\\n]+')\n\nclass LXMLOutputChecker(OutputChecker):\n\n    empty_tags = (\n        'param', 'img', 'area', 'br', 'basefont', 'input',\n        'base', 'meta', 'link', 'col')\n\n    def get_default_parser(self):\n        return etree.XML\n\n    def check_output(self, want, got, optionflags):\n        alt_self = getattr(self, '_temp_override_self', None)\n        if alt_self is not None:\n            super_method = self._temp_call_super_check_output\n            self = alt_self\n        else:\n            super_method = OutputChecker.check_output\n        parser = self.get_parser(want, got, optionflags)\n        if not parser:\n            return super_method(\n                self, want, got, optionflags)\n        try:\n            want_doc = parser(want)\n        except etree.XMLSyntaxError:\n            return False\n        try:\n            got_doc = parser(got)\n        except etree.XMLSyntaxError:\n            return False\n        return self.compare_docs(want_doc, got_doc)\n\n    def get_parser(self, want, got, optionflags):\n        parser = None\n        if NOPARSE_MARKUP & optionflags:\n            return None\n        if PARSE_HTML & optionflags:\n            parser = html_fromstring\n        elif PARSE_XML & optionflags:\n            parser = etree.XML\n        elif (want.strip().lower().startswith('<html')\n              and got.strip().startswith('<html')):\n            parser = html_fromstring\n        elif (self._looks_like_markup(want)\n              and self._looks_like_markup(got)):\n            parser = self.get_default_parser()\n        return parser\n\n    def _looks_like_markup(self, s):\n        s = s.strip()\n        return (s.startswith('<')\n                and not _repr_re.search(s))\n\n    def compare_docs(self, want, got):\n        if not self.tag_compare(want.tag, got.tag):\n            return False\n        if not self.text_compare(want.text, got.text, True):\n            return False\n        if not self.text_compare(want.tail, got.tail, True):\n            return False\n        if 'any' not in want.attrib:\n            want_keys = sorted(want.attrib.keys())\n            got_keys = sorted(got.attrib.keys())\n            if want_keys != got_keys:\n                return False\n            for key in want_keys:\n                if not self.text_compare(want.attrib[key], got.attrib[key], False):\n                    return False\n        if want.text != '...' or len(want):\n            want_children = list(want)\n            got_children = list(got)\n            while want_children or got_children:\n                if not want_children or not got_children:\n                    return False\n                want_first = want_children.pop(0)\n                got_first = got_children.pop(0)\n                if not self.compare_docs(want_first, got_first):\n                    return False\n                if not got_children and want_first.tail == '...':\n                    break\n        return True\n\n    def text_compare(self, want, got, strip):\n        want = want or ''\n        got = got or ''\n        if strip:\n            want = norm_whitespace(want).strip()\n            got = norm_whitespace(got).strip()\n        want = '^%s$' % re.escape(want)\n        want = want.replace(r'\\.\\.\\.', '.*')\n        if re.search(want, got):\n            return True\n        else:\n            return False\n\n    def tag_compare(self, want, got):\n        if want == 'any':\n            return True\n        if (not isinstance(want, (str, bytes))\n                or not isinstance(got, (str, bytes))):\n            return want == got\n        want = want or ''\n        got = got or ''\n        if want.startswith('{...}'):\n            # Ellipsis on the namespace\n            return want.split('}')[-1] == got.split('}')[-1]\n        else:\n            return want == got\n\n    def output_difference(self, example, got, optionflags):\n        want = example.want\n        parser = self.get_parser(want, got, optionflags)\n        errors = []\n        if parser is not None:\n            try:\n                want_doc = parser(want)\n            except etree.XMLSyntaxError:\n                e = sys.exc_info()[1]\n                errors.append('In example: %s' % e)\n            try:\n                got_doc = parser(got)\n            except etree.XMLSyntaxError:\n                e = sys.exc_info()[1]\n                errors.append('In actual output: %s' % e)\n        if parser is None or errors:\n            value = OutputChecker.output_difference(\n                self, example, got, optionflags)\n            if errors:\n                errors.append(value)\n                return '\\n'.join(errors)\n            else:\n                return value\n        html = parser is html_fromstring\n        diff_parts = ['Expected:',\n                      self.format_doc(want_doc, html, 2),\n                      'Got:',\n                      self.format_doc(got_doc, html, 2),\n                      'Diff:',\n                      self.collect_diff(want_doc, got_doc, html, 2)]\n        return '\\n'.join(diff_parts)\n\n    def html_empty_tag(self, el, html=True):\n        if not html:\n            return False\n        if el.tag not in self.empty_tags:\n            return False\n        if el.text or len(el):\n            # This shouldn't happen (contents in an empty tag)\n            return False\n        return True\n\n    def format_doc(self, doc, html, indent, prefix=''):\n        parts = []\n        if not len(doc):\n            # No children...\n            parts.append(' '*indent)\n            parts.append(prefix)\n            parts.append(self.format_tag(doc))\n            if not self.html_empty_tag(doc, html):\n                if strip(doc.text):\n                    parts.append(self.format_text(doc.text))\n                parts.append(self.format_end_tag(doc))\n            if strip(doc.tail):\n                parts.append(self.format_text(doc.tail))\n            parts.append('\\n')\n            return ''.join(parts)\n        parts.append(' '*indent)\n        parts.append(prefix)\n        parts.append(self.format_tag(doc))\n        if not self.html_empty_tag(doc, html):\n            parts.append('\\n')\n            if strip(doc.text):\n                parts.append(' '*indent)\n                parts.append(self.format_text(doc.text))\n                parts.append('\\n')\n            for el in doc:\n                parts.append(self.format_doc(el, html, indent+2))\n            parts.append(' '*indent)\n            parts.append(self.format_end_tag(doc))\n            parts.append('\\n')\n        if strip(doc.tail):\n            parts.append(' '*indent)\n            parts.append(self.format_text(doc.tail))\n            parts.append('\\n')\n        return ''.join(parts)\n\n    def format_text(self, text, strip=True):\n        if text is None:\n            return ''\n        if strip:\n            text = text.strip()\n        return html_escape(text, 1)\n\n    def format_tag(self, el):\n        attrs = []\n        if isinstance(el, etree.CommentBase):\n            # FIXME: probably PIs should be handled specially too?\n            return '<!--'\n        for name, value in sorted(el.attrib.items()):\n            attrs.append('%s=\"%s\"' % (name, self.format_text(value, False)))\n        if not attrs:\n            return '<%s>' % el.tag\n        return '<%s %s>' % (el.tag, ' '.join(attrs))\n    \n    def format_end_tag(self, el):\n        if isinstance(el, etree.CommentBase):\n            # FIXME: probably PIs should be handled specially too?\n            return '-->'\n        return '</%s>' % el.tag\n\n    def collect_diff(self, want, got, html, indent):\n        parts = []\n        if not len(want) and not len(got):\n            parts.append(' '*indent)\n            parts.append(self.collect_diff_tag(want, got))\n            if not self.html_empty_tag(got, html):\n                parts.append(self.collect_diff_text(want.text, got.text))\n                parts.append(self.collect_diff_end_tag(want, got))\n            parts.append(self.collect_diff_text(want.tail, got.tail))\n            parts.append('\\n')\n            return ''.join(parts)\n        parts.append(' '*indent)\n        parts.append(self.collect_diff_tag(want, got))\n        parts.append('\\n')\n        if strip(want.text) or strip(got.text):\n            parts.append(' '*indent)\n            parts.append(self.collect_diff_text(want.text, got.text))\n            parts.append('\\n')\n        want_children = list(want)\n        got_children = list(got)\n        while want_children or got_children:\n            if not want_children:\n                parts.append(self.format_doc(got_children.pop(0), html, indent+2, '+'))\n                continue\n            if not got_children:\n                parts.append(self.format_doc(want_children.pop(0), html, indent+2, '-'))\n                continue\n            parts.append(self.collect_diff(\n                want_children.pop(0), got_children.pop(0), html, indent+2))\n        parts.append(' '*indent)\n        parts.append(self.collect_diff_end_tag(want, got))\n        parts.append('\\n')\n        if strip(want.tail) or strip(got.tail):\n            parts.append(' '*indent)\n            parts.append(self.collect_diff_text(want.tail, got.tail))\n            parts.append('\\n')\n        return ''.join(parts)\n\n    def collect_diff_tag(self, want, got):\n        if not self.tag_compare(want.tag, got.tag):\n            tag = '%s (got: %s)' % (want.tag, got.tag)\n        else:\n            tag = got.tag\n        attrs = []\n        any = want.tag == 'any' or 'any' in want.attrib\n        for name, value in sorted(got.attrib.items()):\n            if name not in want.attrib and not any:\n                attrs.append('+%s=\"%s\"' % (name, self.format_text(value, False)))\n            else:\n                if name in want.attrib:\n                    text = self.collect_diff_text(want.attrib[name], value, False)\n                else:\n                    text = self.format_text(value, False)\n                attrs.append('%s=\"%s\"' % (name, text))\n        if not any:\n            for name, value in sorted(want.attrib.items()):\n                if name in got.attrib:\n                    continue\n                attrs.append('-%s=\"%s\"' % (name, self.format_text(value, False)))\n        if attrs:\n            tag = '<%s %s>' % (tag, ' '.join(attrs))\n        else:\n            tag = '<%s>' % tag\n        return tag\n\n    def collect_diff_end_tag(self, want, got):\n        if want.tag != got.tag:\n            tag = '%s (got: %s)' % (want.tag, got.tag)\n        else:\n            tag = got.tag\n        return '</%s>' % tag\n\n    def collect_diff_text(self, want, got, strip=True):\n        if self.text_compare(want, got, strip):\n            if not got:\n                return ''\n            return self.format_text(got, strip)\n        text = '%s (got: %s)' % (want, got)\n        return self.format_text(text, strip)\n\nclass LHTMLOutputChecker(LXMLOutputChecker):\n    def get_default_parser(self):\n        return html_fromstring\n    \ndef install(html=False):\n    \"\"\"\n    Install doctestcompare for all future doctests.\n\n    If html is true, then by default the HTML parser will be used;\n    otherwise the XML parser is used.\n    \"\"\"\n    if html:\n        doctest.OutputChecker = LHTMLOutputChecker\n    else:\n        doctest.OutputChecker = LXMLOutputChecker\n\ndef temp_install(html=False, del_module=None):\n    \"\"\"\n    Use this *inside* a doctest to enable this checker for this\n    doctest only.\n\n    If html is true, then by default the HTML parser will be used;\n    otherwise the XML parser is used.\n    \"\"\"\n    if html:\n        Checker = LHTMLOutputChecker\n    else:\n        Checker = LXMLOutputChecker\n    frame = _find_doctest_frame()\n    dt_self = frame.f_locals['self']\n    checker = Checker()\n    old_checker = dt_self._checker\n    dt_self._checker = checker\n    # The unfortunate thing is that there is a local variable 'check'\n    # in the function that runs the doctests, that is a bound method\n    # into the output checker.  We have to update that.  We can't\n    # modify the frame, so we have to modify the object in place.  The\n    # only way to do this is to actually change the func_code\n    # attribute of the method.  We change it, and then wait for\n    # __record_outcome to be run, which signals the end of the __run\n    # method, at which point we restore the previous check_output\n    # implementation.\n    check_func = frame.f_locals['check'].__func__\n    checker_check_func = checker.check_output.__func__\n    # Because we can't patch up func_globals, this is the only global\n    # in check_output that we care about:\n    doctest.etree = etree\n    _RestoreChecker(dt_self, old_checker, checker,\n                    check_func, checker_check_func,\n                    del_module)\n\nclass _RestoreChecker:\n    def __init__(self, dt_self, old_checker, new_checker, check_func, clone_func,\n                 del_module):\n        self.dt_self = dt_self\n        self.checker = old_checker\n        self.checker._temp_call_super_check_output = self.call_super\n        self.checker._temp_override_self = new_checker\n        self.check_func = check_func\n        self.clone_func = clone_func\n        self.del_module = del_module\n        self.install_clone()\n        self.install_dt_self()\n    def install_clone(self):\n        self.func_code = self.check_func.__code__\n        self.func_globals = self.check_func.__globals__\n        self.check_func.__code__ = self.clone_func.__code__\n    def uninstall_clone(self):\n        self.check_func.__code__ = self.func_code\n    def install_dt_self(self):\n        self.prev_func = self.dt_self._DocTestRunner__record_outcome\n        self.dt_self._DocTestRunner__record_outcome = self\n    def uninstall_dt_self(self):\n        self.dt_self._DocTestRunner__record_outcome = self.prev_func\n    def uninstall_module(self):\n        if self.del_module:\n            import sys\n            del sys.modules[self.del_module]\n            if '.' in self.del_module:\n                package, module = self.del_module.rsplit('.', 1)\n                package_mod = sys.modules[package]\n                delattr(package_mod, module)\n    def __call__(self, *args, **kw):\n        self.uninstall_clone()\n        self.uninstall_dt_self()\n        del self.checker._temp_override_self\n        del self.checker._temp_call_super_check_output\n        result = self.prev_func(*args, **kw)\n        self.uninstall_module()\n        return result\n    def call_super(self, *args, **kw):\n        self.uninstall_clone()\n        try:\n            return self.check_func(*args, **kw)\n        finally:\n            self.install_clone()\n            \ndef _find_doctest_frame():\n    import sys\n    frame = sys._getframe(1)\n    while frame:\n        l = frame.f_locals\n        if 'BOOM' in l:\n            # Sign of doctest\n            return frame\n        frame = frame.f_back\n    raise LookupError(\n        \"Could not find doctest (only use this function *inside* a doctest)\")\n    \n__test__ = {\n    'basic': '''\n    >>> temp_install()\n    >>> print \"\"\"<xml a=\"1\" b=\"2\">stuff</xml>\"\"\"\n    <xml b=\"2\" a=\"1\">...</xml>\n    >>> print \"\"\"<xml xmlns=\"http://example.com\"><tag   attr=\"bar\"   /></xml>\"\"\"\n    <xml xmlns=\"...\">\n      <tag attr=\"...\" />\n    </xml>\n    >>> print \"\"\"<xml>blahblahblah<foo /></xml>\"\"\" # doctest: +NOPARSE_MARKUP, +ELLIPSIS\n    <xml>...foo /></xml>\n    '''}\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    \n    \n", "src/lxml/_elementpath.py": "# cython: language_level=2\n\n#\n# ElementTree\n# $Id: ElementPath.py 3375 2008-02-13 08:05:08Z fredrik $\n#\n# limited xpath support for element trees\n#\n# history:\n# 2003-05-23 fl   created\n# 2003-05-28 fl   added support for // etc\n# 2003-08-27 fl   fixed parsing of periods in element names\n# 2007-09-10 fl   new selection engine\n# 2007-09-12 fl   fixed parent selector\n# 2007-09-13 fl   added iterfind; changed findall to return a list\n# 2007-11-30 fl   added namespaces support\n# 2009-10-30 fl   added child element value filter\n#\n# Copyright (c) 2003-2009 by Fredrik Lundh.  All rights reserved.\n#\n# fredrik@pythonware.com\n# http://www.pythonware.com\n#\n# --------------------------------------------------------------------\n# The ElementTree toolkit is\n#\n# Copyright (c) 1999-2009 by Fredrik Lundh\n#\n# By obtaining, using, and/or copying this software and/or its\n# associated documentation, you agree that you have read, understood,\n# and will comply with the following terms and conditions:\n#\n# Permission to use, copy, modify, and distribute this software and\n# its associated documentation for any purpose and without fee is\n# hereby granted, provided that the above copyright notice appears in\n# all copies, and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of\n# Secret Labs AB or the author not be used in advertising or publicity\n# pertaining to distribution of the software without specific, written\n# prior permission.\n#\n# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD\n# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-\n# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR\n# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\n# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n# OF THIS SOFTWARE.\n# --------------------------------------------------------------------\n\n##\n# Implementation module for XPath support.  There's usually no reason\n# to import this module directly; the <b>ElementTree</b> does this for\n# you, if needed.\n##\n\n\nimport re\n\nxpath_tokenizer_re = re.compile(\n    \"(\"\n    \"'[^']*'|\\\"[^\\\"]*\\\"|\"\n    \"::|\"\n    \"//?|\"\n    r\"\\.\\.|\"\n    r\"\\(\\)|\"\n    r\"[/.*:\\[\\]\\(\\)@=])|\"\n    r\"((?:\\{[^}]+\\})?[^/\\[\\]\\(\\)@=\\s]+)|\"\n    r\"\\s+\"\n    )\n\ndef xpath_tokenizer(pattern, namespaces=None, with_prefixes=True):\n    # ElementTree uses '', lxml used None originally.\n    default_namespace = (namespaces.get(None) or namespaces.get('')) if namespaces else None\n    parsing_attribute = False\n    for token in xpath_tokenizer_re.findall(pattern):\n        ttype, tag = token\n        if tag and tag[0] != \"{\":\n            if \":\" in tag and with_prefixes:\n                prefix, uri = tag.split(\":\", 1)\n                try:\n                    if not namespaces:\n                        raise KeyError\n                    yield ttype, \"{%s}%s\" % (namespaces[prefix], uri)\n                except KeyError:\n                    raise SyntaxError(\"prefix %r not found in prefix map\" % prefix)\n            elif default_namespace and not parsing_attribute:\n                yield ttype, \"{%s}%s\" % (default_namespace, tag)\n            else:\n                yield token\n            parsing_attribute = False\n        else:\n            yield token\n            parsing_attribute = ttype == '@'\n\n\ndef prepare_child(next, token):\n    tag = token[1]\n    def select(result):\n        for elem in result:\n            yield from elem.iterchildren(tag)\n    return select\n\ndef prepare_star(next, token):\n    def select(result):\n        for elem in result:\n            yield from elem.iterchildren('*')\n    return select\n\ndef prepare_self(next, token):\n    def select(result):\n        return result\n    return select\n\ndef prepare_descendant(next, token):\n    token = next()\n    if token[0] == \"*\":\n        tag = \"*\"\n    elif not token[0]:\n        tag = token[1]\n    else:\n        raise SyntaxError(\"invalid descendant\")\n    def select(result):\n        for elem in result:\n            yield from elem.iterdescendants(tag)\n    return select\n\ndef prepare_parent(next, token):\n    def select(result):\n        for elem in result:\n            parent = elem.getparent()\n            if parent is not None:\n                yield parent\n    return select\n\ndef prepare_predicate(next, token):\n    # FIXME: replace with real parser!!! refs:\n    # http://effbot.org/zone/simple-iterator-parser.htm\n    # http://javascript.crockford.com/tdop/tdop.html\n    signature = ''\n    predicate = []\n    while 1:\n        token = next()\n        if token[0] == \"]\":\n            break\n        if token == ('', ''):\n            # ignore whitespace\n            continue\n        if token[0] and token[0][:1] in \"'\\\"\":\n            token = \"'\", token[0][1:-1]\n        signature += token[0] or \"-\"\n        predicate.append(token[1])\n\n    # use signature to determine predicate type\n    if signature == \"@-\":\n        # [@attribute] predicate\n        key = predicate[1]\n        def select(result):\n            for elem in result:\n                if elem.get(key) is not None:\n                    yield elem\n        return select\n    if signature == \"@-='\":\n        # [@attribute='value']\n        key = predicate[1]\n        value = predicate[-1]\n        def select(result):\n            for elem in result:\n                if elem.get(key) == value:\n                    yield elem\n        return select\n    if signature == \"-\" and not re.match(r\"-?\\d+$\", predicate[0]):\n        # [tag]\n        tag = predicate[0]\n        def select(result):\n            for elem in result:\n                for _ in elem.iterchildren(tag):\n                    yield elem\n                    break\n        return select\n    if signature == \".='\" or (signature == \"-='\" and not re.match(r\"-?\\d+$\", predicate[0])):\n        # [.='value'] or [tag='value']\n        tag = predicate[0]\n        value = predicate[-1]\n        if tag:\n            def select(result):\n                for elem in result:\n                    for e in elem.iterchildren(tag):\n                        if \"\".join(e.itertext()) == value:\n                            yield elem\n                            break\n        else:\n            def select(result):\n                for elem in result:\n                    if \"\".join(elem.itertext()) == value:\n                        yield elem\n        return select\n    if signature == \"-\" or signature == \"-()\" or signature == \"-()-\":\n        # [index] or [last()] or [last()-index]\n        if signature == \"-\":\n            # [index]\n            index = int(predicate[0]) - 1\n            if index < 0:\n                if index == -1:\n                    raise SyntaxError(\n                        \"indices in path predicates are 1-based, not 0-based\")\n                else:\n                    raise SyntaxError(\"path index >= 1 expected\")\n        else:\n            if predicate[0] != \"last\":\n                raise SyntaxError(\"unsupported function\")\n            if signature == \"-()-\":\n                try:\n                    index = int(predicate[2]) - 1\n                except ValueError:\n                    raise SyntaxError(\"unsupported expression\")\n            else:\n                index = -1\n        def select(result):\n            for elem in result:\n                parent = elem.getparent()\n                if parent is None:\n                    continue\n                try:\n                    # FIXME: what if the selector is \"*\" ?\n                    elems = list(parent.iterchildren(elem.tag))\n                    if elems[index] is elem:\n                        yield elem\n                except IndexError:\n                    pass\n        return select\n    raise SyntaxError(\"invalid predicate\")\n\nops = {\n    \"\": prepare_child,\n    \"*\": prepare_star,\n    \".\": prepare_self,\n    \"..\": prepare_parent,\n    \"//\": prepare_descendant,\n    \"[\": prepare_predicate,\n}\n\n\n# --------------------------------------------------------------------\n\n_cache = {}\n\n\ndef _build_path_iterator(path, namespaces, with_prefixes=True):\n    \"\"\"compile selector pattern\"\"\"\n    if path[-1:] == \"/\":\n        path += \"*\"  # implicit all (FIXME: keep this?)\n\n    cache_key = (path,)\n    if namespaces:\n        # lxml originally used None for the default namespace but ElementTree uses the\n        # more convenient (all-strings-dict) empty string, so we support both here,\n        # preferring the more convenient '', as long as they aren't ambiguous.\n        if None in namespaces:\n            if '' in namespaces and namespaces[None] != namespaces['']:\n                raise ValueError(\"Ambiguous default namespace provided: %r versus %r\" % (\n                    namespaces[None], namespaces['']))\n            cache_key += (namespaces[None],) + tuple(sorted(\n                item for item in namespaces.items() if item[0] is not None))\n        else:\n            cache_key += tuple(sorted(namespaces.items()))\n\n    try:\n        return _cache[cache_key]\n    except KeyError:\n        pass\n    if len(_cache) > 100:\n        _cache.clear()\n\n    if path[:1] == \"/\":\n        raise SyntaxError(\"cannot use absolute path on element\")\n    stream = iter(xpath_tokenizer(path, namespaces, with_prefixes=with_prefixes))\n    try:\n        _next = stream.next\n    except AttributeError:\n        # Python 3\n        _next = stream.__next__\n    try:\n        token = _next()\n    except StopIteration:\n        raise SyntaxError(\"empty path expression\")\n    selector = []\n    while 1:\n        try:\n            selector.append(ops[token[0]](_next, token))\n        except StopIteration:\n            raise SyntaxError(\"invalid path\")\n        try:\n            token = _next()\n            if token[0] == \"/\":\n                token = _next()\n        except StopIteration:\n            break\n    _cache[cache_key] = selector\n    return selector\n\n\n##\n# Iterate over the matching nodes\n\ndef iterfind(elem, path, namespaces=None, with_prefixes=True):\n    selector = _build_path_iterator(path, namespaces, with_prefixes=with_prefixes)\n    result = iter((elem,))\n    for select in selector:\n        result = select(result)\n    return result\n\n\n##\n# Find first matching object.\n\ndef find(elem, path, namespaces=None, with_prefixes=True):\n    it = iterfind(elem, path, namespaces, with_prefixes=with_prefixes)\n    try:\n        return next(it)\n    except StopIteration:\n        return None\n\n\n##\n# Find all matching objects.\n\ndef findall(elem, path, namespaces=None, with_prefixes=True):\n    return list(iterfind(elem, path, namespaces))\n\n\n##\n# Find text for first matching object.\n\ndef findtext(elem, path, default=None, namespaces=None, with_prefixes=True):\n    el = find(elem, path, namespaces, with_prefixes=with_prefixes)\n    if el is None:\n        return default\n    else:\n        return el.text or ''\n", "src/lxml/tests/selftest2.py": "# $Id: selftest.py 2213 2005-01-11 18:49:47Z fredrik $\n# elementtree selftest program\n\n# this test script uses Python's \"doctest\" module to check that the\n# *test script* works as expected.\n\nimport sys\nfrom io import BytesIO, StringIO\n\nfrom lxml import etree as ElementTree\n\ndef stdout():\n    class bytes_stdout:\n        def write(self, data):\n            if isinstance(data, bytes):\n                data = data.decode('ISO8859-1')\n            sys.stdout.write(data)\n    return bytes_stdout()\n\ndef unserialize(text):\n    file = StringIO(text)\n    tree = ElementTree.parse(file)\n    return tree.getroot()\n\ndef serialize(elem, encoding=None):\n    file = BytesIO()\n    tree = ElementTree.ElementTree(elem)\n    if encoding:\n        tree.write(file, encoding=encoding)\n    else:\n        tree.write(file)\n    result = file.getvalue()\n    result = result.decode('ISO8859-1')\n    result = result.replace(' />', '/>')\n    if result[-1:] == '\\n':\n        result = result[:-1]\n    return result\n\ndef summarize(elem):\n    return elem.tag\n\ndef summarize_list(seq):\n    return list(map(summarize, seq))\n\nSAMPLE_XML = unserialize(\"\"\"\n<body>\n  <tag>text</tag>\n  <tag />\n  <section>\n    <tag>subtext</tag>\n  </section>\n</body>\n\"\"\")\n\nSAMPLE_XML_NS = unserialize(\"\"\"\n<body xmlns=\"http://effbot.org/ns\">\n  <tag>text</tag>\n  <tag />\n  <section>\n    <tag>subtext</tag>\n  </section>\n</body>\n\"\"\")\n\n# interface tests\n\ndef check_string(string):\n    len(string)\n    for char in string:\n        if len(char) != 1:\n            print(\"expected one-character string, got %r\" % char)\n    new_string = string + \"\"\n    new_string = string + \" \"\n    string[:0]\n\ndef check_mapping(mapping):\n    len(mapping)\n    keys = mapping.keys()\n    items = mapping.items()\n    for key in keys:\n        item = mapping[key]\n    mapping[\"key\"] = \"value\"\n    if mapping[\"key\"] != \"value\":\n        print(\"expected value string, got %r\" % mapping[\"key\"])\n\ndef check_element(element):\n    if not hasattr(element, \"tag\"):\n        print(\"no tag member\")\n    if not hasattr(element, \"attrib\"):\n        print(\"no attrib member\")\n    if not hasattr(element, \"text\"):\n        print(\"no text member\")\n    if not hasattr(element, \"tail\"):\n        print(\"no tail member\")\n    check_string(element.tag)\n    check_mapping(element.attrib)\n    if element.text is not None:\n        check_string(element.text)\n    if element.tail is not None:\n        check_string(element.tail)\n\ndef check_element_tree(tree):\n    check_element(tree.getroot())\n\ndef element():\n    \"\"\"\n    Test element tree interface.\n\n    >>> element = ElementTree.Element(\"tag\")\n    >>> check_element(element)\n    >>> tree = ElementTree.ElementTree(element)\n    >>> check_element_tree(tree)\n    \"\"\"\n\ndef parsefile():\n    \"\"\"\n    Test parsing from file.  Note that we're opening the files in\n    here; by default, the 'parse' function opens the file in binary\n    mode, and doctest doesn't filter out carriage returns.\n\n    >>> file = open(\"samples/simple.xml\", \"rb\")\n    >>> tree = ElementTree.parse(file)\n    >>> file.close()\n    >>> tree.write(stdout())\n    <root>\n       <element key=\"value\">text</element>\n       <element>text</element>tail\n       <empty-element/>\n    </root>\n    >>> file = open(\"samples/simple-ns.xml\", \"rb\")\n    >>> tree = ElementTree.parse(file)\n    >>> file.close()\n    >>> tree.write(stdout())\n    <root xmlns=\"http://namespace/\">\n       <element key=\"value\">text</element>\n       <element>text</element>tail\n       <empty-element/>\n    </root>\n    \"\"\"\n\ndef writefile():\n    \"\"\"\n    >>> elem = ElementTree.Element(\"tag\")\n    >>> elem.text = \"text\"\n    >>> serialize(elem)\n    '<tag>text</tag>'\n    >>> ElementTree.SubElement(elem, \"subtag\").text = \"subtext\"\n    >>> serialize(elem)\n    '<tag>text<subtag>subtext</subtag></tag>'\n    \"\"\"\n\ndef encoding():\n    r\"\"\"\n    Test encoding issues.\n\n    >>> elem = ElementTree.Element(\"tag\")\n    >>> elem.text = 'abc'\n    >>> serialize(elem)\n    '<tag>abc</tag>'\n    >>> serialize(elem, \"utf-8\")\n    '<tag>abc</tag>'\n    >>> serialize(elem, \"us-ascii\")\n    '<tag>abc</tag>'\n    >>> serialize(elem, \"iso-8859-1\").lower()\n    \"<?xml version='1.0' encoding='iso-8859-1'?>\\n<tag>abc</tag>\"\n\n    >>> elem.text = \"<&\\\"\\'>\"\n    >>> serialize(elem)\n    '<tag>&lt;&amp;\"\\'&gt;</tag>'\n    >>> serialize(elem, \"utf-8\")\n    '<tag>&lt;&amp;\"\\'&gt;</tag>'\n    >>> serialize(elem, \"us-ascii\") # cdata characters\n    '<tag>&lt;&amp;\"\\'&gt;</tag>'\n    >>> serialize(elem, \"iso-8859-1\").lower()\n    '<?xml version=\\'1.0\\' encoding=\\'iso-8859-1\\'?>\\n<tag>&lt;&amp;\"\\'&gt;</tag>'\n\n    >>> elem.attrib[\"key\"] = \"<&\\\"\\'>\"\n    >>> elem.text = None\n    >>> serialize(elem)\n    '<tag key=\"&lt;&amp;&quot;\\'&gt;\"/>'\n    >>> serialize(elem, \"utf-8\")\n    '<tag key=\"&lt;&amp;&quot;\\'&gt;\"/>'\n    >>> serialize(elem, \"us-ascii\")\n    '<tag key=\"&lt;&amp;&quot;\\'&gt;\"/>'\n    >>> serialize(elem, \"iso-8859-1\").lower()\n    '<?xml version=\\'1.0\\' encoding=\\'iso-8859-1\\'?>\\n<tag key=\"&lt;&amp;&quot;\\'&gt;\"/>'\n\n    >>> elem.text = '\\xe5\\xf6\\xf6<>'\n    >>> elem.attrib.clear()\n    >>> serialize(elem)\n    '<tag>&#229;&#246;&#246;&lt;&gt;</tag>'\n    >>> serialize(elem, \"utf-8\")\n    '<tag>\\xc3\\xa5\\xc3\\xb6\\xc3\\xb6&lt;&gt;</tag>'\n    >>> serialize(elem, \"us-ascii\")\n    '<tag>&#229;&#246;&#246;&lt;&gt;</tag>'\n    >>> serialize(elem, \"iso-8859-1\").lower()\n    \"<?xml version='1.0' encoding='iso-8859-1'?>\\n<tag>\\xe5\\xf6\\xf6&lt;&gt;</tag>\"\n\n    >>> elem.attrib[\"key\"] = '\\xe5\\xf6\\xf6<>'\n    >>> elem.text = None\n    >>> serialize(elem)\n    '<tag key=\"&#229;&#246;&#246;&lt;&gt;\"/>'\n    >>> serialize(elem, \"utf-8\")\n    '<tag key=\"\\xc3\\xa5\\xc3\\xb6\\xc3\\xb6&lt;&gt;\"/>'\n    >>> serialize(elem, \"us-ascii\")\n    '<tag key=\"&#229;&#246;&#246;&lt;&gt;\"/>'\n    >>> serialize(elem, \"iso-8859-1\").lower()\n    '<?xml version=\\'1.0\\' encoding=\\'iso-8859-1\\'?>\\n<tag key=\"\\xe5\\xf6\\xf6&lt;&gt;\"/>'\n\n    \"\"\"\n\n\ndef qname():\n    \"\"\"\n    Test QName handling.\n\n    1) decorated tags\n\n    >>> elem = ElementTree.Element(\"{uri}tag\")\n    >>> serialize(elem) # 1.1\n    '<ns0:tag xmlns:ns0=\"uri\"/>'\n\n##     2) decorated attributes\n\n##     >>> elem.attrib[\"{uri}key\"] = \"value\"\n##     >>> serialize(elem) # 2.1\n##     '<ns0:tag ns0:key=\"value\" xmlns:ns0=\"uri\"/>'\n\n    \"\"\"\n\ndef cdata():\n    \"\"\"\n    Test CDATA handling (etc).\n\n    >>> serialize(unserialize(\"<tag>hello</tag>\"))\n    '<tag>hello</tag>'\n    >>> serialize(unserialize(\"<tag>&#104;&#101;&#108;&#108;&#111;</tag>\"))\n    '<tag>hello</tag>'\n    >>> serialize(unserialize(\"<tag><![CDATA[hello]]></tag>\"))\n    '<tag>hello</tag>'\n\n    \"\"\"\n\ndef find():\n    \"\"\"\n    Test find methods (including xpath syntax).\n\n    >>> elem = SAMPLE_XML\n    >>> elem.find(\"tag\").tag\n    'tag'\n    >>> ElementTree.ElementTree(elem).find(\"tag\").tag\n    'tag'\n    >>> elem.find(\"section/tag\").tag\n    'tag'\n    >>> ElementTree.ElementTree(elem).find(\"section/tag\").tag\n    'tag'\n    >>> elem.findtext(\"tag\")\n    'text'\n    >>> elem.findtext(\"tog\", \"default\")\n    'default'\n    >>> ElementTree.ElementTree(elem).findtext(\"tag\")\n    'text'\n    >>> elem.findtext(\"section/tag\")\n    'subtext'\n    >>> ElementTree.ElementTree(elem).findtext(\"section/tag\")\n    'subtext'\n    >>> summarize_list(elem.findall(\"tag\"))\n    ['tag', 'tag']\n    >>> summarize_list(elem.findall(\"*\"))\n    ['tag', 'tag', 'section']\n    >>> summarize_list(elem.findall(\".//tag\"))\n    ['tag', 'tag', 'tag']\n    >>> summarize_list(elem.findall(\"section/tag\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"section//tag\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"section/*\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"section//*\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"section/.//*\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"*/*\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"*//*\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"*/tag\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"*/./tag\"))\n    ['tag']\n    >>> summarize_list(elem.findall(\"./tag\"))\n    ['tag', 'tag']\n    >>> summarize_list(elem.findall(\".//tag\"))\n    ['tag', 'tag', 'tag']\n    >>> summarize_list(elem.findall(\"././tag\"))\n    ['tag', 'tag']\n    >>> summarize_list(ElementTree.ElementTree(elem).findall(\"/tag\"))\n    ['tag', 'tag']\n    >>> summarize_list(ElementTree.ElementTree(elem).findall(\"./tag\"))\n    ['tag', 'tag']\n    >>> elem = SAMPLE_XML_NS\n    >>> summarize_list(elem.findall(\"tag\"))\n    []\n    >>> summarize_list(elem.findall(\"{http://effbot.org/ns}tag\"))\n    ['{http://effbot.org/ns}tag', '{http://effbot.org/ns}tag']\n    >>> summarize_list(elem.findall(\".//{http://effbot.org/ns}tag\"))\n    ['{http://effbot.org/ns}tag', '{http://effbot.org/ns}tag', '{http://effbot.org/ns}tag']\n    \"\"\"\n\n# XXX only deep copying is supported\n\ndef copy():\n    \"\"\"\n    Test copy handling (etc).\n\n    >>> import copy\n    >>> e1 = unserialize(\"<tag>hello<foo/></tag>\")\n    >>> # e2 = copy.copy(e1)\n    >>> e3 = copy.deepcopy(e1)\n    >>> e1.find(\"foo\").tag = \"bar\"\n\n    >>> serialize(e1).replace(' ', '')\n    '<tag>hello<bar/></tag>'\n\n##     >>> serialize(e2).replace(' ', '')\n##     '<tag>hello<bar/></tag>'\n\n    >>> serialize(e3).replace(' ', '')\n    '<tag>hello<foo/></tag>'\n\n    \"\"\"\n\ndef attrib():\n    \"\"\"\n    Test attribute handling.\n\n    >>> elem = ElementTree.Element(\"tag\")\n    >>> elem.get(\"key\") # 1.1\n    >>> elem.get(\"key\", \"default\") # 1.2\n    'default'\n    >>> elem.set(\"key\", \"value\")\n    >>> elem.get(\"key\") # 1.3\n    'value'\n\n    >>> elem = ElementTree.Element(\"tag\", key=\"value\")\n    >>> elem.get(\"key\") # 2.1\n    'value'\n    >>> elem.attrib # 2.2\n    {'key': 'value'}\n\n    >>> elem = ElementTree.Element(\"tag\", {\"key\": \"value\"})\n    >>> elem.get(\"key\") # 3.1\n    'value'\n    >>> elem.attrib # 3.2\n    {'key': 'value'}\n\n    >>> elem = ElementTree.Element(\"tag\", {\"key\": \"other\"}, key=\"value\")\n    >>> elem.get(\"key\") # 4.1\n    'value'\n    >>> elem.attrib # 4.2\n    {'key': 'value'}\n\n    \"\"\"\n\ndef makeelement():\n    \"\"\"\n    Test makeelement handling.\n\n    >>> elem = ElementTree.Element(\"tag\")\n    >>> subelem = elem.makeelement(\"subtag\", {\"key\": \"value\"})\n    >>> elem.append(subelem)\n    >>> serialize(elem)\n    '<tag><subtag key=\"value\"/></tag>'\n\n    >>> elem.clear()\n    >>> serialize(elem)\n    '<tag/>'\n    >>> elem.append(subelem)\n    >>> serialize(elem)\n    '<tag><subtag key=\"value\"/></tag>'\n\n    \"\"\"\n\n## def observer():\n##     \"\"\"\n##     Test observers.\n\n##     >>> def observer(action, elem):\n##     ...     print(\"%s %s\" % (action, elem.tag))\n##     >>> builder = ElementTree.TreeBuilder()\n##     >>> builder.addobserver(observer)\n##     >>> parser = ElementTree.XMLParser(builder)\n##     >>> file = open(\"samples/simple.xml\", \"rb\")\n##     >>> parser.feed(file.read())\n##     start root\n##     start element\n##     end element\n##     start element\n##     end element\n##     start empty-element\n##     end empty-element\n##     end root\n##     >>> file.close()\n\n##     \"\"\"\n\nENTITY_XML = \"\"\"\\\n<!DOCTYPE points [\n<!ENTITY % user-entities SYSTEM 'user-entities.xml'>\n%user-entities;\n]>\n<document>&entity;</document>\n\"\"\"\n\n## def entity():\n##     \"\"\"\n##     Test entity handling.\n\n##     1) bad entities\n\n##     >>> ElementTree.XML(\"<document>&entity;</document>\")\n##     Traceback (most recent call last):\n##     SyntaxError: undefined entity: line 1, column 10\n\n##     2) custom entity\n\n##     >>> parser = ElementTree.XMLParser()\n##     >>> parser.entity[\"entity\"] = \"text\"\n##     >>> parser.feed(ENTITY_XML)\n##     >>> root = parser.close()\n##     >>> serialize(root)\n##     '<document>text</document>'\n\n##     \"\"\"\n\nif __name__ == \"__main__\":\n    import doctest, selftest2\n    failed, tested = doctest.testmod(selftest2)\n    print(\"%d tests ok.\" % (tested - failed))\n    if failed > 0:\n        print(\"%d tests failed. Exiting with non-zero return code.\" % failed)\n        sys.exit(1)\n", "src/lxml/tests/test_etree.py": "\"\"\"\nTests specific to the extended etree API\n\nTests that apply to the general ElementTree API should go into\ntest_elementtree\n\"\"\"\n\n\nfrom collections import OrderedDict\nfrom io import StringIO, BytesIO\nimport os.path\nimport unittest\nimport contextlib\nimport copy\nimport sys\nimport re\nimport gc\nimport operator\nimport shutil\nimport tempfile\nimport textwrap\nimport zlib\nimport gzip\n\nfrom .common_imports import etree, HelperTestCase\nfrom .common_imports import fileInTestDir, fileUrlInTestDir, read_file, path2url, tmpfile\nfrom .common_imports import SillyFileLike, LargeFileLikeUnicode, doctest, make_doctest\nfrom .common_imports import canonicalize, _str, _bytes\nfrom .common_imports import SimpleFSPath\n\nprint(f\"\"\"\nTESTED VERSION: {etree.__version__}\n    Python:           {tuple(sys.version_info)!r}\n    lxml.etree:       {etree.LXML_VERSION!r}\n    libxml used:      {etree.LIBXML_VERSION!r}\n    libxml compiled:  {etree.LIBXML_COMPILED_VERSION!r}\n    libxslt used:     {etree.LIBXSLT_VERSION!r}\n    libxslt compiled: {etree.LIBXSLT_COMPILED_VERSION!r}\n    iconv compiled:   {etree.ICONV_COMPILED_VERSION!r}\n    FS encoding:      {sys.getfilesystemencoding()}\n    Default encoding: {sys.getdefaultencoding()}\n    Max Unicode:      {sys.maxunicode}\n    PyUCS4 encoding:  {getattr(etree, '_pyucs4_encoding_name', '')}\n\"\"\")\n\n\nclass ETreeOnlyTestCase(HelperTestCase):\n    \"\"\"Tests only for etree, not ElementTree\"\"\"\n    etree = etree\n\n    def test_version(self):\n        self.assertTrue(isinstance(etree.__version__, str))\n        self.assertTrue(isinstance(etree.LXML_VERSION, tuple))\n        self.assertEqual(len(etree.LXML_VERSION), 4)\n        self.assertTrue(isinstance(etree.LXML_VERSION[0], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[1], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[2], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[3], int))\n        self.assertTrue(etree.__version__.startswith(\n            str(etree.LXML_VERSION[0])))\n\n    def test_c_api(self):\n        if hasattr(self.etree, '__pyx_capi__'):\n            # newer Pyrex compatible C-API\n            self.assertTrue(isinstance(self.etree.__pyx_capi__, dict))\n            self.assertTrue(len(self.etree.__pyx_capi__) > 0)\n        else:\n            # older C-API mechanism\n            self.assertTrue(hasattr(self.etree, '_import_c_api'))\n\n    def test_include_paths(self):\n        import lxml\n        includes = lxml.get_include()\n        self.assertTrue(includes)\n        self.assertTrue(len(includes) >= 2)\n        self.assertTrue(os.path.join(os.path.dirname(lxml.__file__), 'includes') in includes,\n                        includes)\n\n    def test_element_names(self):\n        Element = self.etree.Element\n        el = Element('name')\n        self.assertEqual(el.tag, 'name')\n        el = Element('{}name')\n        self.assertEqual(el.tag, 'name')\n\n    def test_element_name_empty(self):\n        Element = self.etree.Element\n        el = Element('name')\n        self.assertRaises(ValueError, Element, '{}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{}')\n\n        self.assertRaises(ValueError, Element, '{test}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{test}')\n\n    def test_element_name_colon(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, 'p:name')\n        self.assertRaises(ValueError, Element, '{test}p:name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', 'p:name')\n\n    def test_element_name_quote(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, \"p'name\")\n        self.assertRaises(ValueError, Element, 'p\"name')\n\n        self.assertRaises(ValueError, Element, \"{test}p'name\")\n        self.assertRaises(ValueError, Element, '{test}p\"name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', \"p'name\")\n        self.assertRaises(ValueError, setattr, el, 'tag', 'p\"name')\n\n    def test_element_name_space(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, ' name ')\n        self.assertRaises(ValueError, Element, 'na me')\n        self.assertRaises(ValueError, Element, '{test} name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', ' name ')\n\n    def test_subelement_name_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, '{}')\n        self.assertRaises(ValueError, SubElement, el, '{test}')\n\n    def test_subelement_name_colon(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, 'p:name')\n        self.assertRaises(ValueError, SubElement, el, '{test}p:name')\n\n    def test_subelement_name_quote(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, \"p'name\")\n        self.assertRaises(ValueError, SubElement, el, \"{test}p'name\")\n\n        self.assertRaises(ValueError, SubElement, el, 'p\"name')\n        self.assertRaises(ValueError, SubElement, el, '{test}p\"name')\n\n    def test_subelement_name_space(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, ' name ')\n        self.assertRaises(ValueError, SubElement, el, 'na me')\n        self.assertRaises(ValueError, SubElement, el, '{test} name')\n\n    def test_subelement_attribute_invalid(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, 'name', {'a b c' : 'abc'})\n        self.assertRaises(ValueError, SubElement, el, 'name', {'a' : 'a\\0\\n'})\n        self.assertEqual(0, len(el))\n\n    def test_qname_empty(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, '')\n        self.assertRaises(ValueError, QName, None)\n        self.assertRaises(ValueError, QName, None, None)\n        self.assertRaises(ValueError, QName, 'test', '')\n\n    def test_qname_none(self):\n        QName = self.etree.QName\n        q = QName(None, 'TAG')\n        self.assertEqual('TAG', q)\n        self.assertEqual('TAG', q.localname)\n        self.assertEqual(None, q.namespace)\n\n    def test_qname_colon(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, 'p:name')\n        self.assertRaises(ValueError, QName, 'test', 'p:name')\n\n    def test_qname_space(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, ' name ')\n        self.assertRaises(ValueError, QName, 'na me')\n        self.assertRaises(ValueError, QName, 'test', ' name')\n\n    def test_qname_namespace_localname(self):\n        # ET doesn't have namespace/localname properties on QNames\n        QName = self.etree.QName\n        namespace, localname = 'http://myns', 'a'\n        qname = QName(namespace, localname)\n        self.assertEqual(namespace, qname.namespace)\n        self.assertEqual(localname, qname.localname)\n\n    def test_qname_element(self):\n        # ET doesn't have namespace/localname properties on QNames\n        QName = self.etree.QName\n        qname1 = QName('http://myns', 'a')\n        a = self.etree.Element(qname1, nsmap={'p' : 'http://myns'})\n\n        qname2 = QName(a)\n        self.assertEqual(a.tag, qname1.text)\n        self.assertEqual(a.tag, qname1)\n        self.assertEqual(qname1.text, qname2.text)\n        self.assertEqual(qname1, qname2.text)\n        self.assertEqual(qname1.text, qname2)\n        self.assertEqual(qname1, qname2)\n\n    def test_qname_text_resolve(self):\n        # ET doesn't resove QNames as text values\n        etree = self.etree\n        qname = etree.QName('http://myns', 'a')\n        a = etree.Element(qname, nsmap={'p' : 'http://myns'})\n        a.text = qname\n\n        self.assertEqual(\"p:a\", a.text)\n\n    def test_nsmap_prefix_invalid(self):\n        etree = self.etree\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'\"' : 'testns'})\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'&' : 'testns'})\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'a:b' : 'testns'})\n\n    def test_clear_keep_tail(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        a = XML('<a aa=\"A\"><b ba=\"B\">B1</b>B2<c ca=\"C\">C1</c>C2</a>')\n        a[0].clear(keep_tail=True)\n        self.assertEqual(b'<a aa=\"A\"><b/>B2<c ca=\"C\">C1</c>C2</a>', tostring(a))\n\n    def test_attrib_is_Mapping(self):\n        from collections.abc import Mapping, MutableMapping\n        Element = self.etree.Element\n        root = Element(\"root\")\n\n        self.assertTrue(isinstance(root.attrib, Mapping))\n        self.assertTrue(isinstance(root.attrib, MutableMapping))\n\n    def test_attribute_has_key(self):\n        # ET in Py 3.x has no \"attrib.has_key()\" method\n        XML = self.etree.XML\n\n        root = XML(b'<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />')\n        self.assertEqual(\n            True, root.attrib.has_key('bar'))\n        self.assertEqual(\n            False, root.attrib.has_key('baz'))\n        self.assertEqual(\n            False, root.attrib.has_key('hah'))\n        self.assertEqual(\n            True,\n            root.attrib.has_key('{http://ns.codespeak.net/test}baz'))\n\n    def test_attribute_set(self):\n        Element = self.etree.Element\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n\n    def test_attribute_set_nonstring(self):\n        # ElementTree accepts arbitrary attribute values\n        # lxml.etree allows only strings\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n        self.assertRaises(TypeError, root.set, \"newattr\", 5)\n\n    def test_attrib_and_keywords(self):\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.attrib[\"attr\"])\n\n        root2 = Element(\"root2\", root.attrib, attr2='TOAST')\n        self.assertEqual(\"TEST\", root2.attrib[\"attr\"])\n        self.assertEqual(\"TOAST\", root2.attrib[\"attr2\"])\n        self.assertEqual(None, root.attrib.get(\"attr2\"))\n\n    def test_attrib_order(self):\n        Element = self.etree.Element\n\n        keys = [\"attr%d\" % i for i in range(12, 4, -1)]\n        values = [\"TEST-%d\" % i for i in range(12, 4, -1)]\n        items = list(zip(keys, values))\n\n        root = Element(\"root\")\n        for key, value in items:\n            root.set(key, value)\n        self.assertEqual(keys, root.attrib.keys())\n        self.assertEqual(values, root.attrib.values())\n\n        attr_order = [\n            ('attr_99', 'TOAST-1'),\n            ('attr_98', 'TOAST-2'),\n        ]\n        ordered_dict_types = [dict, OrderedDict, lambda x:x]\n        attr_order += items\n        expected_keys = [attr[0] for attr in attr_order]\n        expected_values = [attr[1] for attr in attr_order]\n        expected_items = list(zip(expected_keys, expected_values))\n\n        for dict_type in ordered_dict_types:\n            root2 = Element(\"root2\", dict_type(root.attrib),\n                            attr_99='TOAST-1', attr_98='TOAST-2')\n\n            try:\n                self.assertSequenceEqual(expected_keys, root2.attrib.keys())\n                self.assertSequenceEqual(expected_values, root2.attrib.values())\n                self.assertSequenceEqual(expected_items, root2.attrib.items())\n            except AssertionError as exc:\n                exc.args = (\"Order of '%s': %s\" % (dict_type.__name__, exc.args[0]),) + exc.args[1:]\n                raise\n\n        self.assertEqual(keys, root.attrib.keys())\n        self.assertEqual(values, root.attrib.values())\n\n    def test_attribute_set_invalid(self):\n        # ElementTree accepts arbitrary attribute values\n        # lxml.etree allows only strings, or None for (html5) boolean attributes\n        Element = self.etree.Element\n        root = Element(\"root\")\n        self.assertRaises(TypeError, root.set, \"newattr\", 5)\n        self.assertRaises(TypeError, root.set, \"newattr\", object)\n        self.assertRaises(TypeError, root.set, \"newattr\", None)\n        self.assertRaises(TypeError, root.set, \"newattr\")\n\n    def test_strip_attributes(self):\n        XML = self.etree.XML\n        xml = b'<test a=\"5\" b=\"10\" c=\"20\"><x a=\"4\" b=\"2\"/></test>'\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'a')\n        self.assertEqual(b'<test b=\"10\" c=\"20\"><x b=\"2\"></x></test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'b', 'c')\n        self.assertEqual(b'<test a=\"5\"><x a=\"4\"></x></test>',\n                          self._writeElement(root))\n\n    def test_strip_attributes_ns(self):\n        XML = self.etree.XML\n        xml = b'<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\" c=\"20\" n:a=\"5\"><x a=\"4\" n:b=\"2\"/></test>'\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'a')\n        self.assertEqual(\n            b'<test xmlns:n=\"http://test/ns\" b=\"10\" c=\"20\" n:a=\"5\"><x n:b=\"2\"></x></test>',\n            self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, '{http://test/ns}a', 'c')\n        self.assertEqual(\n            b'<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\"><x a=\"4\" n:b=\"2\"></x></test>',\n            self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, '{http://test/ns}*')\n        self.assertEqual(\n            b'<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\" c=\"20\"><x a=\"4\"></x></test>',\n            self._writeElement(root))\n\n    def test_strip_elements(self):\n        XML = self.etree.XML\n        xml = b'<test><a><b><c/></b></a><x><a><b/><c/></a></x></test>'\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'a')\n        self.assertEqual(b'<test><x></x></test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'b', 'c', 'X', 'Y', 'Z')\n        self.assertEqual(b'<test><a></a><x><a></a></x></test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'c')\n        self.assertEqual(b'<test><a><b></b></a><x><a><b></b></a></x></test>',\n                          self._writeElement(root))\n\n    def test_strip_elements_ns(self):\n        XML = self.etree.XML\n        xml = b'<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"/>C</b>BT</n:a>AT<x>X<a>A<b xmlns=\"urn:a\"/>BT<c xmlns=\"urn:x\"/>CT</a>AT</x>XT</test>'\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'a')\n        self.assertEqual(b'<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>C</b>BT</n:a>AT<x>X</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}b', 'c')\n        self.assertEqual(b'<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>C</b>BT</n:a>AT<x>X<a>A<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}*', 'c')\n        self.assertEqual(b'<test>TEST<x>X<a>A<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}*', 'c', with_tail=False)\n        self.assertEqual(b'<test>TESTAT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n    def test_strip_tags(self):\n        XML = self.etree.XML\n        xml = b'<test>TEST<a>A<b>B<c/>CT</b>BT</a>AT<x>X<a>A<b/>BT<c/>CT</a>AT</x>XT</test>'\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(b'<test>TESTA<b>B<c></c>CT</b>BTAT<x>XA<b></b>BT<c></c>CTAT</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'b', 'c', 'X', 'Y', 'Z')\n        self.assertEqual(b'<test>TEST<a>ABCTBT</a>AT<x>X<a>ABTCT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'c')\n        self.assertEqual(b'<test>TEST<a>A<b>BCT</b>BT</a>AT<x>X<a>A<b></b>BTCT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n    def test_strip_tags_pi_comment(self):\n        XML = self.etree.XML\n        PI = self.etree.ProcessingInstruction\n        Comment = self.etree.Comment\n        xml = b'<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>'\n\n        root = XML(xml)\n        self.etree.strip_tags(root, PI)\n        self.assertEqual(b'<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT</test>\\n<!--comment3-->\\n<?PI1?>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, Comment)\n        self.assertEqual(b'<!--comment1-->\\n<?PI1?>\\n<test>TESTXT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, PI, Comment)\n        self.assertEqual(b'<!--comment1-->\\n<?PI1?>\\n<test>TESTXT</test>\\n<!--comment3-->\\n<?PI1?>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, Comment, PI)\n        self.assertEqual(b'<!--comment1-->\\n<?PI1?>\\n<test>TESTXT</test>\\n<!--comment3-->\\n<?PI1?>',\n                          self._writeElement(root))\n\n    def test_strip_tags_pi_comment_all(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        PI = self.etree.ProcessingInstruction\n        Comment = self.etree.Comment\n        xml = b'<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>'\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), PI)\n        self.assertEqual(b'<!--comment1-->\\n<test>TEST<!--comment2-->XT</test>\\n<!--comment3-->',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), Comment)\n        self.assertEqual(b'<?PI1?>\\n<test>TESTXT<?PI2?></test>\\n<?PI1?>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), PI, Comment)\n        self.assertEqual(b'<test>TESTXT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), Comment, PI)\n        self.assertEqual(b'<test>TESTXT</test>',\n                          self._writeElement(root))\n\n    def test_strip_tags_doc_style(self):\n        XML = self.etree.XML\n        xml = b'''\n        <div>\n            <div>\n                I like <strong>sheep</strong>.\n                <br/>\n                I like lots of <strong>sheep</strong>.\n                <br/>\n                Click <a href=\"http://www.sheep.com\">here</a>\n                 for <a href=\"http://www.sheep.com\">those</a> sheep.\n                <br/>\n            </div>\n        </div>\n        '''.strip()\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(re.sub(b'</?a[^>]*>', b'', xml).replace(b'<br/>', b'<br></br>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a', 'br')\n        self.assertEqual(re.sub(b'</?a[^>]*>', b'',\n                                 re.sub(b'<br[^>]*>', b'', xml)),\n                          self._writeElement(root))\n\n    def test_strip_tags_ns(self):\n        XML = self.etree.XML\n        xml = b'<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"/>CT</b>BT</n:a>AT<x>X<a>A<b xmlns=\"urn:a\"/>BT<c xmlns=\"urn:x\"/>CT</a>AT</x>XT</test>'\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(b'<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>CT</b>BT</n:a>AT<x>XA<b xmlns=\"urn:a\"></b>BT<c xmlns=\"urn:x\"></c>CTAT</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, '{urn:a}b', 'c')\n        self.assertEqual(b'<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>CT</b>BT</n:a>AT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, '{urn:a}*', 'c')\n        self.assertEqual(b'<test>TESTA<b>B<c xmlns=\"urn:c\"></c>CT</b>BTAT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>',\n                          self._writeElement(root))\n\n    def test_strip_tags_and_remove(self):\n        # previously crashed\n        HTML = self.etree.HTML\n        root = HTML(b'<div><h1>title</h1> <b>foo</b> <p>boo</p></div>')[0][0]\n        self.assertEqual(b'<div><h1>title</h1> <b>foo</b> <p>boo</p></div>',\n                          self.etree.tostring(root))\n        self.etree.strip_tags(root, 'b')\n        self.assertEqual(b'<div><h1>title</h1> foo <p>boo</p></div>',\n                          self.etree.tostring(root))\n        root.remove(root[0])\n        self.assertEqual(b'<div><p>boo</p></div>',\n                          self.etree.tostring(root))\n\n    def test_append_rejects_ancestor(self):\n        XML = self.etree.XML\n        root = XML(\"<root><a><b><c /></b></a></root>\")\n        a = root[0]\n        self.assertRaises(ValueError, a.append, root)\n        self.assertRaises(ValueError, a[0].append, root)\n        self.assertRaises(ValueError, a[0].append, a)\n        self.assertRaises(ValueError, a[0][0].append, root)\n        self.assertRaises(ValueError, a[0][0].append, a)\n        self.assertRaises(ValueError, a[0][0].append, a[0])\n\n    def test_insert_rejects_ancestor(self):\n        XML = self.etree.XML\n        root = XML(\"<root><a><b><c /></b></a></root>\")\n        a = root[0]\n        self.assertRaises(ValueError, a.insert, 0, root)\n        self.assertRaises(ValueError, a[0].insert, 0, root)\n        self.assertRaises(ValueError, a[0].insert, 0, a)\n        self.assertRaises(ValueError, a[0][0].insert, 0, root)\n        self.assertRaises(ValueError, a[0][0].insert, 0, a)\n        self.assertRaises(ValueError, a[0][0].insert, 0, a[0])\n\n    def test_replace_rejects_ancestor(self):\n        XML = self.etree.XML\n        root = XML(\"<root><a><b><c /></b></a></root>\")\n        a = root[0]\n        root.replace(a, a)\n        self.assertRaises(ValueError, root.replace, a, root)\n        a.replace(a[0], a[0])\n        self.assertRaises(ValueError, a.replace, a[0], root)\n        a[0].replace(a[0][0], a[0][0])\n        self.assertRaises(ValueError, a[0].replace, a[0][0], root)\n        self.assertRaises(ValueError, a[0].replace, a[0][0], a)\n        self.assertRaises(ValueError, a[0].replace, a[0][0], a[0])\n\n    def test_pi(self):\n        # lxml.etree separates target and text\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ProcessingInstruction = self.etree.ProcessingInstruction\n\n        a = Element('a')\n        a.append(ProcessingInstruction('foo', 'some more text'))\n        self.assertEqual(a[0].target, 'foo')\n        self.assertEqual(a[0].text, 'some more text')\n\n    def test_pi_parse(self):\n        XML = self.etree.XML\n        root = XML(b\"<test><?mypi my test ?></test>\")\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].text, \"my test \")\n\n    def test_pi_pseudo_attributes_get(self):\n        XML = self.etree.XML\n        root = XML(b\"<test><?mypi my='1' test=\\\" abc \\\" quotes=\\\"' '\\\" only names ?></test>\")\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].get('my'), \"1\")\n        self.assertEqual(root[0].get('test'), \" abc \")\n        self.assertEqual(root[0].get('quotes'), \"' '\")\n        self.assertEqual(root[0].get('only'), None)\n        self.assertEqual(root[0].get('names'), None)\n        self.assertEqual(root[0].get('nope'), None)\n\n    def test_pi_pseudo_attributes_attrib(self):\n        XML = self.etree.XML\n        root = XML(b\"<test><?mypi my='1' test=\\\" abc \\\" quotes=\\\"' '\\\" only names ?></test>\")\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].attrib['my'], \"1\")\n        self.assertEqual(root[0].attrib['test'], \" abc \")\n        self.assertEqual(root[0].attrib['quotes'], \"' '\")\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'only')\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'names')\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'nope')\n\n    def test_deepcopy_pi(self):\n        # previously caused a crash\n        ProcessingInstruction = self.etree.ProcessingInstruction\n        \n        a = ProcessingInstruction(\"PI\", \"ONE\")\n        b = copy.deepcopy(a)\n        b.text = \"ANOTHER\"\n\n        self.assertEqual('ONE',     a.text)\n        self.assertEqual('ANOTHER', b.text)\n\n    def test_deepcopy_elementtree_pi(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        root = XML(b\"<?mypi my test ?><test/><!--comment -->\")\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(b\"<?mypi my test ?><test/><!--comment -->\",\n                          tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(b\"<?mypi my test ?><test/><!--comment -->\",\n                          tostring(tree2))\n\n        root2 = copy.deepcopy(tree1.getroot())\n        self.assertEqual(b\"<test/>\",\n                          tostring(root2))\n\n    def test_deepcopy_elementtree_dtd(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        xml = b'<!DOCTYPE test [\\n<!ENTITY entity \"tasty\">\\n]>\\n<test/>'\n        root = XML(xml)\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(xml, tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(xml, tostring(tree2))\n\n        root2 = copy.deepcopy(tree1.getroot())\n        self.assertEqual(b\"<test/>\",\n                          tostring(root2))\n\n    def test_deepcopy_pi_dtd(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        xml = b'<!-- comment --><!DOCTYPE test [\\n<!ENTITY entity \"tasty\">\\n]>\\n<test/>'\n        root = XML(xml)\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(xml, tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(xml, tostring(tree2))\n\n    def test_parse_remove_comments(self):\n        fromstring = self.etree.fromstring\n        tostring = self.etree.tostring\n        XMLParser = self.etree.XMLParser\n\n        xml = b'<a><!--A--><b><!-- B --><c/></b><!--C--></a>'\n        parser = XMLParser(remove_comments=True)\n        root = fromstring(xml, parser)\n        self.assertEqual(\n            b'<a><b><c/></b></a>',\n            tostring(root))\n\n    def test_parse_remove_pis(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n        XMLParser = self.etree.XMLParser\n\n        xml = b'<?test?><a><?A?><b><?B?><c/></b><?C?></a><?tail?>'\n\n        f = BytesIO(xml)\n        tree = parse(f)\n        self.assertEqual(\n            xml,\n            tostring(tree))\n\n        parser = XMLParser(remove_pis=True)\n        tree = parse(f, parser)\n        self.assertEqual(\n            b'<a><b><c/></b></a>',\n            tostring(tree))\n\n    def test_parse_parser_type_error(self):\n        # ET raises IOError only\n        parse = self.etree.parse\n        self.assertRaises(TypeError, parse, 'notthere.xml', object())\n\n    def test_parse_premature_end(self):\n        fromstring = self.etree.fromstring\n        XMLParser = self.etree.XMLParser\n\n        xml = b'<a><b></b>'\n        parser = XMLParser()\n        self.assertRaises(self.etree.XMLSyntaxError, fromstring, xml, parser)\n\n    def test_parse_premature_end_with_target(self):\n        # tests issue https://bugs.launchpad.net/lxml/+bug/1980767 is fixed\n        fromstring = self.etree.fromstring\n        XMLParser = self.etree.XMLParser\n\n        xml = b'<a><b></b>'\n        parser = XMLParser(target=etree.TreeBuilder())\n        self.assertRaises(self.etree.XMLSyntaxError, fromstring, xml, parser)\n\n    def test_iterparse_getiterator(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><d/></b><c/></a>')\n\n        counts = []\n        for event, elem in iterparse(f):\n            counts.append(len(list(elem.getiterator())))\n        self.assertEqual(\n            [1,2,1,4],\n            counts)\n\n    def test_iterparse_tree_comments(self):\n        # ET removes comments\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        f = BytesIO(b'<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f))\n        root = events[-1][1]\n        self.assertEqual(3, len(events))\n        self.assertEqual(\n            b'<a><!--A--><b><!-- B --><c/></b><!--C--></a>',\n            tostring(root))\n\n    def test_iterparse_comments(self):\n        # ET removes comments\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        def name(event, el):\n            if event == 'comment':\n                return el.text\n            else:\n                return el.tag\n\n        f = BytesIO(b'<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f, events=('end', 'comment')))\n        root = events[-1][1]\n        self.assertEqual(6, len(events))\n        self.assertEqual(['A', ' B ', 'c', 'b', 'C', 'a'],\n                          [ name(*item) for item in events ])\n        self.assertEqual(\n            b'<a><!--A--><b><!-- B --><c/></b><!--C--></a>',\n            tostring(root))\n\n    def test_iterparse_pis(self):\n        # ET removes pis\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n        ElementTree = self.etree.ElementTree\n\n        def name(event, el):\n            if event == 'pi':\n                return el.target, el.text\n            else:\n                return el.tag\n\n        f = BytesIO(b'<?pia a?><a><?pib b?><b><?pic c?><c/></b><?pid d?></a><?pie e?>')\n        events = list(iterparse(f, events=('end', 'pi')))\n        root = events[-2][1]\n        self.assertEqual(8, len(events))\n        self.assertEqual([('pia','a'), ('pib','b'), ('pic','c'), 'c', 'b',\n                           ('pid','d'), 'a', ('pie','e')],\n                          [ name(*item) for item in events ])\n        self.assertEqual(\n            b'<?pia a?><a><?pib b?><b><?pic c?><c/></b><?pid d?></a><?pie e?>',\n            tostring(ElementTree(root)))\n\n    def test_iterparse_remove_comments(self):\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        f = BytesIO(b'<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f, remove_comments=True,\n                                events=('end', 'comment')))\n        root = events[-1][1]\n        self.assertEqual(3, len(events))\n        self.assertEqual(['c', 'b', 'a'],\n                          [ el.tag for (event, el) in events ])\n        self.assertEqual(\n            b'<a><b><c/></b></a>',\n            tostring(root))\n\n    def test_iterparse_broken(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><c/></a>')\n        # ET raises ExpatError, lxml raises XMLSyntaxError\n        self.assertRaises(self.etree.XMLSyntaxError, list, iterparse(f))\n\n    def test_iterparse_broken_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><c/></a>')\n        it = iterparse(f, events=('start', 'end'), recover=True)\n        events = [(ev, el.tag) for ev, el in it]\n        root = it.root\n        self.assertTrue(root is not None)\n\n        self.assertEqual(1, events.count(('start', 'a')))\n        self.assertEqual(1, events.count(('end', 'a')))\n\n        self.assertEqual(1, events.count(('start', 'b')))\n        self.assertEqual(1, events.count(('end', 'b')))\n\n        self.assertEqual(1, events.count(('start', 'c')))\n        self.assertEqual(1, events.count(('end', 'c')))\n\n    def test_iterparse_broken_multi_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><c/></d><b><c/></a></b>')\n        it = iterparse(f, events=('start', 'end'), recover=True)\n        events = [(ev, el.tag) for ev, el in it]\n        root = it.root\n        self.assertTrue(root is not None)\n\n        self.assertEqual(1, events.count(('start', 'a')))\n        self.assertEqual(1, events.count(('end', 'a')))\n\n        self.assertEqual(2, events.count(('start', 'b')))\n        self.assertEqual(2, events.count(('end', 'b')))\n\n        self.assertEqual(2, events.count(('start', 'c')))\n        self.assertEqual(2, events.count(('end', 'c')))\n\n    def test_iterparse_strip(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b\"\"\"\n               <a>  \\n \\n  <b> b test </b>  \\n\n\n               \\n\\t <c> \\n </c> </a>  \\n \"\"\")\n        iterator = iterparse(f, remove_blank_text=True)\n        text = [ (element.text, element.tail)\n                 for event, element in iterator ]\n        self.assertEqual(\n            [(\" b test \", None), (\" \\n \", None), (None, None)],\n            text)\n\n    def test_iterparse_tag(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterparse_tag_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            8,\n            len(events))\n\n    def test_iterparse_tag_ns(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"{urn:test:1}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterparse_tag_ns_empty(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n        f = BytesIO(b'<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual([], events)\n\n    def test_iterparse_tag_ns_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{urn:test:1}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(8, len(events))\n\n    def test_iterparse_tag_ns_empty_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual([], events)\n\n        f = BytesIO(b'<a><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(8, len(events))\n\n    def test_iterparse_encoding_error(self):\n        text = 'S\u00f8k p\u00e5 nettet'\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = ('%s<a>%s</a>' % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        self.assertRaises(self.etree.ParseError,\n                          list, self.etree.iterparse(BytesIO(xml_latin1)))\n\n    def test_iterparse_encoding_8bit_override(self):\n        text = _str('S\u00f8k p\u00e5 nettet', encoding=\"UTF-8\")\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = ('%s<a>%s</a>' % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        iterator = self.etree.iterparse(BytesIO(xml_latin1),\n                                        encoding=\"iso-8859-1\")\n        self.assertEqual(1, len(list(iterator)))\n\n        a = iterator.root\n        self.assertEqual(a.text, text)\n\n    def test_iterparse_keep_cdata(self):\n        tostring = self.etree.tostring\n        f = BytesIO(b'<root><![CDATA[test]]></root>')\n        context = self.etree.iterparse(f, strip_cdata=False)\n        content = [ el.text for event,el in context ]\n\n        self.assertEqual(['test'], content)\n        self.assertEqual(b'<root><![CDATA[test]]></root>',\n                          tostring(context.root))\n\n    def test_parser_encoding_unknown(self):\n        self.assertRaises(\n            LookupError, self.etree.XMLParser, encoding=\"hopefully unknown\")\n\n    def test_parser_encoding(self):\n        self.etree.XMLParser(encoding=\"ascii\")\n        self.etree.XMLParser(encoding=\"utf-8\")\n        self.etree.XMLParser(encoding=\"iso-8859-1\")\n\n    def test_feed_parser_recover(self):\n        parser = self.etree.XMLParser(recover=True)\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot><')\n        parser.feed('a test=\"works\"')\n        parser.feed('><othertag/></root') # <a> not closed!\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, \"othertag\")\n        # FIXME: would be nice to get some errors logged ...\n        #self.assertTrue(len(parser.error_log) > 0, \"error log is empty\")\n\n    def test_feed_parser_recover_no_id_dict(self):\n        # test that recover mode plays nicely with the no-id-dict setup\n        parser = self.etree.XMLParser(recover=True, collect_ids=False)\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot xml:id=\"123\"><')\n        parser.feed('a test=\"works\" xml:id=')\n        parser.feed('\"321\"><othertag/></root') # <a> not closed!\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n        self.assertEqual(root[0].attrib, {\n            'test': 'works',\n            '{http://www.w3.org/XML/1998/namespace}id': '321'})\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, \"othertag\")\n        # FIXME: would be nice to get some errors logged ...\n        #self.assertTrue(len(parser.error_log) > 0, \"error log is empty\")\n\n    def test_elementtree_parser_target_type_error(self):\n        assertEqual = self.assertEqual\n        assertFalse  = self.assertFalse\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertFalse(attrib)\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                return \"DONE\" # no Element!\n\n        parser = self.etree.XMLParser(target=Target())\n        tree = self.etree.ElementTree()\n\n        self.assertRaises(TypeError,\n                          tree.parse, BytesIO(b\"<TAG/>\"), parser=parser)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_feed_exception(self):\n        # ET doesn't call .close() on errors\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n                if tag == 'a':\n                    raise ValueError(\"dead and gone\")\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        try:\n            parser.feed(b'<root>A<a>ca</a>B</root>')\n            done = parser.close()\n            self.fail(\"error expected, but parsing succeeded\")\n        except ValueError:\n            done = 'value error received as expected'\n\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"close\"],\n                          events)\n\n    def test_parser_target_fromstring_exception(self):\n        # ET doesn't call .close() on errors\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n                if tag == 'a':\n                    raise ValueError(\"dead and gone\")\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        try:\n            done = self.etree.fromstring(b'<root>A<a>ca</a>B</root>',\n                                         parser=parser)\n            self.fail(\"error expected, but parsing succeeded\")\n        except ValueError:\n            done = 'value error received as expected'\n\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                          \"data-ca\", \"end-a\", \"close\"],\n                         events)\n\n    def test_parser_target_feed_no_id_dict(self):\n        # test that target parsing works nicely with the no-id-hash setup\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def comment(self, text):\n                events.append(\"comment-\" + text)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(), collect_ids=False)\n\n        parser.feed(b'<!--a--><root xml:id=\"123\">A<!--b-->')\n        parser.feed(b'<sub xml:id=\"321\"/>B</root>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"comment-a\", \"start-root\", \"data-A\", \"comment-b\",\n                          \"start-sub\", \"end-sub\", \"data-B\", \"end-root\"],\n                         events)\n\n    def test_parser_target_comment(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def comment(self, text):\n                events.append(\"comment-\" + text)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        parser.feed(b'<!--a--><root>A<!--b--><sub/><!--c-->B</root><!--d-->')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"comment-a\", \"start-root\", \"data-A\", \"comment-b\",\n                           \"start-sub\", \"end-sub\", \"comment-c\", \"data-B\",\n                           \"end-root\", \"comment-d\"],\n                          events)\n\n    def test_parser_target_pi(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def pi(self, target, data):\n                events.append(\"pi-\" + target + \"-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        parser.feed(b'<?test a?><root>A<?test b?>B</root><?test c?>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"pi-test-a\", \"start-root\", \"data-A\", \"pi-test-b\",\n                           \"data-B\", \"end-root\", \"pi-test-c\"],\n                          events)\n\n    def test_parser_target_cdata(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(),\n                                      strip_cdata=False)\n\n        parser.feed(b'<root>A<a><![CDATA[ca]]></a>B</root>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"data-B\", \"end-root\"],\n                          events)\n\n    def test_parser_target_recover(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(),\n                                      recover=True)\n\n        parser.feed(b'<root>A<a>ca</a>B</not-root>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"data-B\",\n                           \"end-root\", \"close\"],\n                          events)\n\n    def test_iterwalk_tag(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b><d/></b><c/></a>')\n\n        iterator = iterwalk(root, tag=\"b\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterwalk_tag_all(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b><d/></b><c/></a>')\n\n        iterator = iterwalk(root, tag=\"*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            8,\n            len(events))\n\n    def test_iterwalk(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/></a>')\n\n        events = list(iterwalk(root))\n        self.assertEqual(\n            [('end', root[0]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterwalk_comments_root_element(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><a><!--Ca--><b><!--Cb--></b><!--Cc--><c/></a><!--C99-->')\n\n        iterator = iterwalk(root, events=('start', 'end', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('comment', root[0]),\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),\n             ('comment', root[2]), ('start', root[3]), ('end', root[3]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_comments_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><a><!--Ca--><b><!--Cb--></b><!--Cc--><c/></a><!--C99-->')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('comment', root.getprevious()),\n             ('start', root), ('comment', root[0]),  # <a>\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),  # <b>\n             ('comment', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('comment', root.getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_root_element(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<?C0?><a><?Ca?><b><?Cb?></b><?Cc?><c/></a><?C99?>')\n\n        iterator = iterwalk(root, events=('start', 'end', 'pi'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('pi', root[0]),\n             ('start', root[1]), ('pi', root[1][0]), ('end', root[1]),\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_pis_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<?C0?><a><?Ca?><b><?Cb?></b><?Cc?><c/></a><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'pi'))\n        events = list(iterator)\n        self.assertEqual(\n            [('pi', root.getprevious()),\n             ('start', root), ('pi', root[0]),  # <a>\n             ('start', root[1]), ('pi', root[1][0]), ('end', root[1]),  # <b>\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('pi', root.getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_comments_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><?C0?><!--C1--><a><?Ca?><b><!--Cb--></b><?Cc?><c/></a><!--C99--><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'pi', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('comment', root.getprevious().getprevious().getprevious()),\n             ('pi', root.getprevious().getprevious()),\n             ('comment', root.getprevious()),\n             ('start', root), ('pi', root[0]),  # <a>\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),  # <b>\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('comment', root.getnext()), ('pi', root.getnext().getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_comments_tree_no_events(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><?C0?><!--C1--><a><?Ca?><b><!--Cb--></b><?Cc?><c/></a><!--C99--><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root),  # <a>\n             ('start', root[1]), ('end', root[1]),  # <b>\n             ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_start(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/></a>')\n\n        iterator = iterwalk(root, events=('start',))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('start', root[1])],\n            events)\n\n    def test_iterwalk_start_end(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/></a>')\n\n        iterator = iterwalk(root, events=('start','end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('end', root[0]),\n             ('start', root[1]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterwalk_start_tags(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/><b><d/></b></a>')\n\n        iterator = iterwalk(root, events=('start',), tag='b')\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('start', root[2])],\n            events)\n\n    def test_iterwalk_start_end_tags(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/><b><d/></b></a>')\n\n        iterator = iterwalk(root, events=('start', 'end'), tag='b')\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0]), ('start', root[2]), ('end', root[2])],\n            events)\n\n    def test_iterwalk_start_end_tags_with_root(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/><b><d/></b></a>')\n\n        iterator = iterwalk(root, events=('start', 'end'), tag=('b', 'a'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root),\n             ('start', root[0]), ('end', root[0]),\n             ('start', root[2]), ('end', root[2]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_clear(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b></b><c/></a>')\n\n        iterator = iterwalk(root)\n        for event, elem in iterator:\n            elem.clear()\n\n        self.assertEqual(0,\n                          len(root))\n\n    def test_iterwalk_attrib_ns(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a xmlns=\"ns1\"><b><c xmlns=\"ns2\"/></b></a>')\n\n        attr_name = '{testns}bla'\n        events = []\n        iterator = iterwalk(root, events=('start','end','start-ns','end-ns'))\n        for event, elem in iterator:\n            events.append(event)\n            if event == 'start':\n                if elem.tag != '{ns1}a':\n                    elem.set(attr_name, 'value')\n\n        self.assertEqual(\n            ['start-ns', 'start', 'start', 'start-ns', 'start',\n             'end', 'end-ns', 'end', 'end', 'end-ns'],\n            events)\n\n        self.assertEqual(\n            None,\n            root.get(attr_name))\n        self.assertEqual(\n            'value',\n            root[0].get(attr_name))\n\n    def test_iterwalk_end_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b><c/></b><d><e/></d></a>')\n\n        iterator = iterwalk(root)\n        tags = []\n        for event, elem in iterator:\n            tags.append(elem.tag)\n            # requesting a skip after an 'end' event should never have an effect\n            iterator.skip_subtree()\n\n        self.assertEqual(['c', 'b', 'e', 'd', 'a'], tags)\n\n    def test_iterwalk_start_end_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b><c/></b><d><e/></d></a>')\n\n        iterator = iterwalk(root, events=('start', 'end'))\n        tags = []\n        for event, elem in iterator:\n            tags.append((event, elem.tag))\n            if elem.tag in ('b', 'e'):\n                # skipping should only have an effect on 'start', not on 'end'\n                iterator.skip_subtree()\n\n        self.assertEqual(\n            [('start', 'a'),\n             ('start', 'b'), ('end', 'b'),  # ignored child 'c'\n             ('start', 'd'),\n             ('start', 'e'), ('end', 'e'),\n             ('end', 'd'),\n             ('end', 'a')],\n            tags)\n\n    def test_iterwalk_ns_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes(\n            '<a xmlns=\"ns1\"><b xmlns=\"nsb\"><c xmlns=\"ns2\"/></b><d xmlns=\"ns2\"><e/></d></a>'))\n\n        events = []\n        iterator = iterwalk(root, events=('start','start-ns','end-ns'))\n        for event, elem in iterator:\n            if event in ('start-ns', 'end-ns'):\n                events.append((event, elem))\n                if event == 'start-ns' and elem == ('', 'nsb'):\n                    events.append('skip')\n                    iterator.skip_subtree()\n            else:\n                events.append((event, elem.tag))\n\n        self.assertEqual(\n            [('start-ns', ('', 'ns1')),\n             ('start', '{ns1}a'),\n             ('start-ns', ('', 'nsb')),\n             'skip',\n             ('start', '{nsb}b'),\n             ('end-ns', None),\n             ('start-ns', ('', 'ns2')),\n             ('start', '{ns2}d'),\n             ('start', '{ns2}e'),\n             ('end-ns', None),\n             ('end-ns', None)\n             ],\n            events)\n\n    def test_iterwalk_getiterator(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(b'<a><b><d/></b><c/></a>')\n\n        counts = []\n        for event, elem in iterwalk(root):\n            counts.append(len(list(elem.getiterator())))\n        self.assertEqual(\n            [1,2,1,4],\n            counts)\n\n    def test_walk_after_parse_failure(self):\n        # This used to be an issue because libxml2 can leak empty namespaces\n        # between failed parser runs.  iterwalk() failed to handle such a tree.\n        parser = etree.XMLParser()\n\n        try:\n            etree.XML('''<anot xmlns=\"1\">''', parser=parser)\n        except etree.XMLSyntaxError:\n            pass\n        else:\n            assert False, \"invalid input did not fail to parse\"\n\n        et = etree.XML('''<root>  </root>''', parser=parser)\n        try:\n            ns = next(etree.iterwalk(et, events=('start-ns',)))\n        except StopIteration:\n            # This would be the expected result, because there was no namespace\n            pass\n        else:\n            assert False, \"Found unexpected namespace '%s'\" % ns\n\n    def test_itertext_comment_pi(self):\n        # https://bugs.launchpad.net/lxml/+bug/1844674\n        XML = self.etree.XML\n        root = XML(_bytes(\n            \"<root>RTEXT<a></a>ATAIL<b/><!-- COMMENT -->CTAIL<?PI PITEXT?> PITAIL </root>\"\n        ))\n\n        text = list(root.itertext())\n        self.assertEqual([\"RTEXT\", \"ATAIL\", \"CTAIL\", \" PITAIL \"],\n                          text)\n\n    def test_itertext_no_tails(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\n            \"<root>RTEXT<a>ATEXT</a>ATAIL<b/><!-- COMMENT -->CTAIL<?PI PITEXT?> PITAIL </root>\"\n        ))\n\n        text = list(root.itertext(with_tail=False))\n        self.assertEqual([\"RTEXT\", \"ATEXT\"],\n                          text)\n\n    def test_resolve_string_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_string(\n                    _str('''<!ENTITY myentity \"%s\">\n                        <!ELEMENT doc ANY>''') % url, context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>' % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_bytes_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_string(\n                    (_str('''<!ENTITY myentity \"%s\">\n                             <!ELEMENT doc ANY>''') % url).encode('utf-8'),\n                    context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>' % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_filelike_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_file(\n                    SillyFileLike(\n                        _str('''<!ENTITY myentity \"%s\">\n                        <!ELEMENT doc ANY>''') % url), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>' % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_filename_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_filename(\n                    fileInTestDir('test.dtd'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>' % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_filename_dtd_relative(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                expected = fileUrlInTestDir(test_url)\n                url = url.replace('file://', 'file:')  # depends on libxml2 version\n                expected = expected.replace('file://', 'file:')\n                assertEqual(url, expected)\n                return self.resolve_filename(\n                    fileUrlInTestDir('test.dtd'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>' % test_url\n        tree = parse(StringIO(xml), parser,\n                     base_url=fileUrlInTestDir('__test.xml'))\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_file_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_file(\n                    open(fileInTestDir('test.dtd'), 'rb'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>' % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_empty(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(load_dtd=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class check:\n            resolved = False\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                check.resolved = True\n                return self.resolve_empty(context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>' % test_url\n        self.assertRaises(etree.XMLSyntaxError, parse, StringIO(xml), parser)\n        self.assertTrue(check.resolved)\n\n    def test_resolve_error(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n\n        class _LocalException(Exception):\n            pass\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                raise _LocalException\n\n        parser.resolvers.add(MyResolver())\n\n        xml = b'<!DOCTYPE doc SYSTEM \"test\"><doc>&myentity;</doc>'\n        self.assertRaises(_LocalException, parse, BytesIO(xml), parser)\n\n    def test_entity_parse(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(resolve_entities=False)\n        Entity = self.etree.Entity\n\n        xml = b'<!DOCTYPE doc SYSTEM \"test\"><doc>&myentity;</doc>'\n        tree = parse(BytesIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&myentity;\")\n        self.assertEqual(root[0].tail, None)\n        self.assertEqual(root[0].name, \"myentity\")\n\n        self.assertEqual(b'<doc>&myentity;</doc>',\n                          tostring(root))\n\n    @contextlib.contextmanager\n    def _xml_test_file(self, name, content=b'<evil>XML</evil>'):\n        temp_dir = tempfile.mkdtemp()\n        try:\n            xml_file = os.path.join(temp_dir, name)\n            with open(xml_file, 'wb') as tmpfile:\n                tmpfile.write(content)\n            yield xml_file\n        finally:\n            shutil.rmtree(temp_dir)\n\n    def test_entity_parse_external(self):\n        fromstring = self.etree.fromstring\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(resolve_entities=True)\n\n        with self._xml_test_file(\"entity.xml\") as entity_file:\n            xml = '''\n            <!DOCTYPE doc [\n                <!ENTITY my_external_entity SYSTEM \"%s\">\n            ]>\n            <doc>&my_external_entity;</doc>\n            ''' % path2url(entity_file)\n            root = fromstring(xml, parser)\n\n        self.assertEqual(b'<doc><evil>XML</evil></doc>',\n                          tostring(root))\n        self.assertEqual(root.tag, 'doc')\n        self.assertEqual(root[0].tag, 'evil')\n        self.assertEqual(root[0].text, 'XML')\n        self.assertEqual(root[0].tail, None)\n\n    def test_entity_parse_external_no_resolve(self):\n        fromstring = self.etree.fromstring\n        parser = self.etree.XMLParser(resolve_entities=False)\n        Entity = self.etree.Entity\n\n        with self._xml_test_file(\"entity.xml\") as entity_file:\n            xml = '''\n            <!DOCTYPE doc [\n                <!ENTITY my_external_entity SYSTEM \"%s\">\n            ]>\n            <doc>&my_external_entity;</doc>\n            ''' % path2url(entity_file)\n            root = fromstring(xml, parser)\n\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&my_external_entity;\")\n\n    def test_entity_parse_no_external_default(self):\n        fromstring = self.etree.fromstring\n\n        with self._xml_test_file(\"entity.xml\") as entity_file:\n            xml = '''\n            <!DOCTYPE doc [\n                <!ENTITY my_failing_external_entity SYSTEM \"%s\">\n            ]>\n            <doc>&my_failing_external_entity;</doc>\n            ''' % path2url(entity_file)\n\n            try:\n                fromstring(xml)\n            except self.etree.XMLSyntaxError as exc:\n                exception = exc\n            else:\n                self.assertTrue(False, \"XMLSyntaxError was not raised\")\n\n        self.assertIn(\"my_failing_external_entity\", str(exception))\n        self.assertTrue(exception.error_log)\n        # Depending on the libxml2 version, we get different errors here,\n        # not necessarily the one that lxml produced. But it should fail either way.\n        for error in exception.error_log:\n            if \"my_failing_external_entity\" in error.message:\n                self.assertEqual(5, error.line)\n                break\n        else:\n            self.assertFalse(\"entity error not found in parser error log\")\n\n    def test_entity_restructure(self):\n        xml = b'''<!DOCTYPE root [ <!ENTITY nbsp \"&#160;\"> ]>\n            <root>\n              <child1/>\n              <child2/>\n              <child3>&nbsp;</child3>\n            </root>'''\n\n        parser = self.etree.XMLParser(resolve_entities=False)\n        root = etree.fromstring(xml, parser)\n        self.assertEqual([ el.tag for el in root ],\n                          ['child1', 'child2', 'child3'])\n\n        root[0] = root[-1]\n        self.assertEqual([ el.tag for el in root ],\n                          ['child3', 'child2'])\n        self.assertEqual(root[0][0].text, '&nbsp;')\n        self.assertEqual(root[0][0].name, 'nbsp')\n\n    def test_entity_append(self):\n        Entity = self.etree.Entity\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.append( Entity(\"test\") )\n\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&test;\")\n        self.assertEqual(root[0].tail, None)\n        self.assertEqual(root[0].name, \"test\")\n\n        self.assertEqual(b'<root>&test;</root>',\n                          tostring(root))\n\n    def test_entity_append_parsed(self):\n        Entity = self.etree.Entity\n        Element = self.etree.Element\n        parser = self.etree.XMLParser(resolve_entities=False)\n        entity = self.etree.XML('''<!DOCTYPE data [\n        <!ENTITY a \"a\">\n        <!ENTITY b \"&a;\">\n        ]>\n        <data>&b;</data>\n        ''', parser)\n\n        el = Element('test')\n        el.append(entity)\n        self.assertEqual(el.tag, 'test')\n        self.assertEqual(el[0].tag, 'data')\n        self.assertEqual(el[0][0].tag, Entity)\n        self.assertEqual(el[0][0].name, 'b')\n\n    def test_entity_values(self):\n        Entity = self.etree.Entity\n        self.assertEqual(Entity(\"test\").text, '&test;')\n        self.assertEqual(Entity(\"#17683\").text, '&#17683;')\n        self.assertEqual(Entity(\"#x1768\").text, '&#x1768;')\n        self.assertEqual(Entity(\"#x98AF\").text, '&#x98AF;')\n\n    def test_entity_error(self):\n        Entity = self.etree.Entity\n        self.assertRaises(ValueError, Entity, 'a b c')\n        self.assertRaises(ValueError, Entity, 'a,b')\n        self.assertRaises(ValueError, Entity, 'a\\0b')\n        self.assertRaises(ValueError, Entity, '#abc')\n        self.assertRaises(ValueError, Entity, '#xxyz')\n\n    def test_cdata(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.text = CDATA('test')\n\n        self.assertEqual('test',\n                          root.text)\n        self.assertEqual(b'<root><![CDATA[test]]></root>',\n                          tostring(root))\n\n    def test_cdata_tail(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        child = SubElement(root, 'child')\n        child.tail = CDATA('test')\n\n        self.assertEqual('test', child.tail)\n        self.assertEqual(b'<root><child/><![CDATA[test]]></root>',\n                         tostring(root))\n\n        root = Element(\"root\")\n        root.tail = CDATA('test')\n\n        self.assertEqual('test', root.tail)\n        self.assertEqual(b'<root/><![CDATA[test]]>',\n                         tostring(root))\n\n    def test_cdata_type(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        root = Element(\"root\")\n\n        root.text = CDATA(\"test\")\n        self.assertEqual('test', root.text)\n\n        root.text = CDATA(_str(\"test\"))\n        self.assertEqual('test', root.text)\n\n        self.assertRaises(TypeError, CDATA, 1)\n\n    def test_cdata_errors(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        cdata = CDATA('test')\n\n        self.assertRaises(TypeError,\n                          root.set, 'attr', cdata)\n        self.assertRaises(TypeError,\n                          operator.setitem, root.attrib, 'attr', cdata)\n\n    def test_cdata_parser(self):\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(strip_cdata=False)\n        root = self.etree.XML(b'<root><![CDATA[test]]></root>', parser)\n\n        self.assertEqual('test', root.text)\n        self.assertEqual(b'<root><![CDATA[test]]></root>',\n                          tostring(root))\n\n    def test_cdata_xpath(self):\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(strip_cdata=False)\n        root = self.etree.XML(b'<root><![CDATA[test]]></root>', parser)\n        self.assertEqual(b'<root><![CDATA[test]]></root>',\n                          tostring(root))\n\n        self.assertEqual(['test'], root.xpath('//text()'))\n\n    def test_cdata_split_cdend(self):\n        # Tests that existing ']]>' in CDATA is split to 'escape' it\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.text = CDATA('test]]>')\n\n        self.assertEqual('test]]>',\n                          root.text)\n        self.assertEqual(b'<root><![CDATA[test]]]]><![CDATA[>]]></root>',\n                          tostring(root))\n\n    # TypeError in etree, AssertionError in ElementTree;\n    def test_setitem_assert(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        \n        self.assertRaises(TypeError,\n                          a.__setitem__, 0, 'foo')\n\n    def test_append_error(self):\n        Element = self.etree.Element\n        root = Element('root')\n        # raises AssertionError in ElementTree\n        self.assertRaises(TypeError, root.append, None)\n        self.assertRaises(TypeError, root.extend, [None])\n        self.assertRaises(TypeError, root.extend, [Element('one'), None])\n        self.assertEqual('one', root[0].tag)\n\n    def test_append_recursive_error(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        self.assertRaises(ValueError, root.append, root)\n        child = SubElement(root, 'child')\n        self.assertRaises(ValueError, child.append, root)\n        child2 = SubElement(child, 'child2')\n        self.assertRaises(ValueError, child2.append, root)\n        self.assertRaises(ValueError, child2.append, child)\n        self.assertEqual('child2', root[0][0].tag)\n\n    def test_addnext(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n\n        self.assertEqual(['a', 'b'],\n                          [c.tag for c in root])\n        root[1].addnext(root[0])\n        self.assertEqual(['b', 'a'],\n                          [c.tag for c in root])\n\n    def test_addnext_tails(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a').tail = \"A\"\n        SubElement(root, 'b').tail = \"B\"\n        SubElement(root, 'c').tail = \"C\"\n        SubElement(root, 'd').tail = \"D\"\n\n        self.assertEqual(['a', 'b', 'c', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual(['A', 'B', 'C', 'D'], [c.tail for c in root])\n\n        root[2].addnext(root[1])\n        self.assertEqual(['a', 'c', 'b', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual(['A', 'C', 'B', 'D'], [c.tail for c in root])\n\n    def test_addnext_with_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b').tail = \"B\"\n        SubElement(root, 'c')\n        SubElement(root, 'd')\n\n        self.assertEqual(['a', 'b', 'c', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual([None, 'B', None, None], [c.tail for c in root])\n\n        root[2].addnext(root[1])\n        self.assertEqual(['a', 'c', 'b', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual([None, None, 'B', None], [c.tail for c in root])\n\n    def test_addprevious(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n\n        self.assertEqual(['a', 'b'],\n                          [c.tag for c in root])\n        root[0].addprevious(root[1])\n        self.assertEqual(['b', 'a'],\n                          [c.tag for c in root])\n\n    def test_addprevious_tails(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a').tail = \"A\"\n        SubElement(root, 'b').tail = \"B\"\n        SubElement(root, 'c').tail = \"C\"\n        SubElement(root, 'd').tail = \"D\"\n\n        self.assertEqual(['a', 'b', 'c', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual(['A', 'B', 'C', 'D'], [c.tail for c in root])\n\n        root[1].addprevious(root[2])\n        self.assertEqual(['a', 'c', 'b', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual(['A', 'C', 'B', 'D'], [c.tail for c in root])\n\n    def test_addprevious_with_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n        SubElement(root, 'c').tail = \"C\"\n        SubElement(root, 'd')\n\n        self.assertEqual(['a', 'b', 'c', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual([None, None, 'C', None], [c.tail for c in root])\n\n        root[1].addprevious(root[2])\n        self.assertEqual(['a', 'c', 'b', 'd'],\n                          [c.tag for c in root])\n        self.assertEqual([None, 'C', None, None], [c.tail for c in root])\n\n    def test_addnext_cycle(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, b.addnext, a)\n        self.assertEqual(['a'], [c.tag for c in root])\n        self.assertEqual(['b'], [c.tag for c in a])\n\n    def test_addprevious_cycle(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, b.addprevious, a)\n        self.assertEqual(['a'], [c.tag for c in root])\n        self.assertEqual(['b'], [c.tag for c in a])\n\n    def test_addnext_cycle_long(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, c.addnext, a)\n\n    def test_addprevious_cycle_long(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, c.addprevious, a)\n\n    def test_addprevious_noops(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(root, 'b')\n        a.addprevious(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addprevious(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addprevious(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n\n    def test_addnext_noops(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(root, 'b')\n        a.addnext(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addnext(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        a.addnext(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n\n    def test_addnext_root(self):\n        Element = self.etree.Element\n        a = Element('a')\n        b = Element('b')\n        self.assertRaises(TypeError, a.addnext, b)\n\n    def test_addprevious_pi(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        PI = self.etree.PI\n        root = Element('root')\n        SubElement(root, 'a')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(b'<root><a></a></root>',\n                          self._writeElement(root))\n        root[0].addprevious(pi)\n        self.assertEqual(b'<root><?TARGET TEXT?>TAIL<a></a></root>',\n                          self._writeElement(root))\n\n    def test_addprevious_root_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.PI\n        root = Element('root')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(b'<root></root>',\n                          self._writeElement(root))\n        root.addprevious(pi)\n        self.assertEqual(b'<?TARGET TEXT?>\\n<root></root>',\n                          self._writeElement(root))\n\n    def test_addnext_pi(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        PI = self.etree.PI\n        root = Element('root')\n        SubElement(root, 'a')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(b'<root><a></a></root>',\n                          self._writeElement(root))\n        root[0].addnext(pi)\n        self.assertEqual(b'<root><a></a><?TARGET TEXT?>TAIL</root>',\n                          self._writeElement(root))\n\n    def test_addnext_root_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.PI\n        root = Element('root')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(b'<root></root>',\n                          self._writeElement(root))\n        root.addnext(pi)\n        self.assertEqual(b'<root></root>\\n<?TARGET TEXT?>',\n                          self._writeElement(root))\n\n    def test_addnext_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        root = Element('root')\n        SubElement(root, 'a')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(b'<root><a></a></root>',\n                          self._writeElement(root))\n        root[0].addnext(comment)\n        self.assertEqual(b'<root><a></a><!--TEXT -->TAIL</root>',\n                          self._writeElement(root))\n\n    def test_addnext_root_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        root = Element('root')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(b'<root></root>',\n                          self._writeElement(root))\n        root.addnext(comment)\n        self.assertEqual(b'<root></root>\\n<!--TEXT -->',\n                          self._writeElement(root))\n\n    def test_addprevious_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        root = Element('root')\n        SubElement(root, 'a')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(b'<root><a></a></root>',\n                          self._writeElement(root))\n        root[0].addprevious(comment)\n        self.assertEqual(b'<root><!--TEXT -->TAIL<a></a></root>',\n                          self._writeElement(root))\n\n    def test_addprevious_root_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        root = Element('root')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(b'<root></root>',\n                          self._writeElement(root))\n        root.addprevious(comment)\n        self.assertEqual(b'<!--TEXT -->\\n<root></root>',\n                          self._writeElement(root))\n\n    # ET's Elements have items() and key(), but not values()\n    def test_attribute_values(self):\n        XML = self.etree.XML\n        \n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>')\n        values = root.values()\n        values.sort()\n        self.assertEqual(['Alpha', 'Beta', 'Gamma'], values)\n\n    # gives error in ElementTree\n    def test_comment_empty(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n\n        a = Element('a')\n        a.append(Comment())\n        self.assertEqual(\n            b'<a><!----></a>',\n            self._writeElement(a))\n\n    # ElementTree ignores comments\n    def test_comment_parse_empty(self):\n        ElementTree = self.etree.ElementTree\n        tostring = self.etree.tostring\n\n        xml = b'<a><b/><!----><c/></a>'\n        f = BytesIO(xml)\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            '',\n            a[1].text)\n        self.assertEqual(\n            xml,\n            tostring(a))\n\n    # ElementTree ignores comments\n    def test_comment_no_proxy_yet(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO(b'<a><b></b><!-- hoi --><c></c></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            ' hoi ',\n            a[1].text)\n\n    # does not raise an exception in ElementTree\n    def test_comment_immutable(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n\n        c = Comment()\n        el = Element('myel')\n\n        self.assertRaises(TypeError, c.append, el)\n        self.assertRaises(TypeError, c.insert, 0, el)\n        self.assertRaises(TypeError, c.set, \"myattr\", \"test\")\n\n    def test_comment_immutable_attrib(self):\n        c = self.etree.Comment()\n        self.assertEqual(0, len(c.attrib))\n\n        self.assertFalse(c.attrib.__contains__('nope'))\n        self.assertFalse('nope' in c.attrib)\n        self.assertFalse('nope' in c.attrib.keys())\n        self.assertFalse('nope' in c.attrib.values())\n        self.assertFalse(('nope', 'huhu') in c.attrib.items())\n\n        self.assertEqual([], list(c.attrib))\n        self.assertEqual([], list(c.attrib.keys()))\n        self.assertEqual([], list(c.attrib.items()))\n        self.assertEqual([], list(c.attrib.values()))\n        self.assertEqual([], list(c.attrib.iterkeys()))\n        self.assertEqual([], list(c.attrib.iteritems()))\n        self.assertEqual([], list(c.attrib.itervalues()))\n\n        self.assertEqual('HUHU', c.attrib.pop('nope', 'HUHU'))\n        self.assertRaises(KeyError, c.attrib.pop, 'nope')\n\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'only')\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'names')\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'nope')\n        self.assertRaises(KeyError, c.attrib.__setitem__, 'nope', 'yep')\n        self.assertRaises(KeyError, c.attrib.__delitem__, 'nope')\n\n    # test passing 'None' to dump()\n    def test_dump_none(self):\n        self.assertRaises(TypeError, self.etree.dump, None)\n\n    def test_prefix(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO(b'<a xmlns:foo=\"http://www.infrae.com/ns/1\"><foo:b/></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            None,\n            a.prefix)\n        self.assertEqual(\n            'foo',\n            a[0].prefix)\n\n    def test_prefix_default_ns(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO(b'<a xmlns=\"http://www.infrae.com/ns/1\"><b/></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            None,\n            a.prefix)\n        self.assertEqual(\n            None,\n            a[0].prefix)\n\n    def test_getparent(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            None,\n            a.getparent())\n        self.assertEqual(\n            a,\n            b.getparent())\n        self.assertEqual(\n            b.getparent(),\n            c.getparent())\n        self.assertEqual(\n            b,\n            d.getparent())\n\n    def test_iterchildren(self):\n        XML = self.etree.XML\n        \n        root = XML(b'<doc><one/><two>Two</two>Hm<three/></doc>')\n        result = []\n        for el in root.iterchildren():\n            result.append(el.tag)\n        self.assertEqual(['one', 'two', 'three'], result)\n\n    def test_iterchildren_reversed(self):\n        XML = self.etree.XML\n        \n        root = XML(b'<doc><one/><two>Two</two>Hm<three/></doc>')\n        result = []\n        for el in root.iterchildren(reversed=True):\n            result.append(el.tag)\n        self.assertEqual(['three', 'two', 'one'], result)\n\n    def test_iterchildren_tag(self):\n        XML = self.etree.XML\n        \n        root = XML(b'<doc><one/><two>Two</two>Hm<two>Bla</two></doc>')\n        result = []\n        for el in root.iterchildren(tag='two'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla'], result)\n\n    def test_iterchildren_tag_posarg(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<two>Bla</two></doc>')\n        result = []\n        for el in root.iterchildren('two'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla'], result)\n\n    def test_iterchildren_tag_reversed(self):\n        XML = self.etree.XML\n        \n        root = XML(b'<doc><one/><two>Two</two>Hm<two>Bla</two></doc>')\n        result = []\n        for el in root.iterchildren(reversed=True, tag='two'):\n            result.append(el.text)\n        self.assertEqual(['Bla', 'Two'], result)\n\n    def test_iterchildren_tag_multiple(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>')\n        result = []\n        for el in root.iterchildren(tag=['two', 'three']):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla', None], result)\n\n    def test_iterchildren_tag_multiple_posarg(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>')\n        result = []\n        for el in root.iterchildren('two', 'three'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla', None], result)\n\n    def test_iterchildren_tag_multiple_reversed(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>')\n        result = []\n        for el in root.iterchildren(reversed=True, tag=['two', 'three']):\n            result.append(el.text)\n        self.assertEqual([None, 'Bla', 'Two'], result)\n\n    def test_iterancestors(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.iterancestors()))\n        self.assertEqual(\n            [a],\n            list(b.iterancestors()))\n        self.assertEqual(\n            [a],\n            list(c.iterancestors()))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors()))\n\n    def test_iterancestors_tag(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [a],\n            list(d.iterancestors('a')))\n        self.assertEqual(\n            [a],\n            list(d.iterancestors(tag='a')))\n\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('*')))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag='*')))\n\n    def test_iterancestors_tag_multiple(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag=('a', 'b'))))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('a', 'b')))\n\n        self.assertEqual(\n            [],\n            list(d.iterancestors(tag=('w', 'x', 'y', 'z'))))\n        self.assertEqual(\n            [],\n            list(d.iterancestors('w', 'x', 'y', 'z')))\n\n        self.assertEqual(\n            [],\n            list(d.iterancestors(tag=('d', 'x'))))\n        self.assertEqual(\n            [],\n            list(d.iterancestors('d', 'x')))\n\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag=('b', '*'))))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('b', '*')))\n\n        self.assertEqual(\n            [b],\n            list(d.iterancestors(tag=('b', 'c'))))\n        self.assertEqual(\n            [b],\n            list(d.iterancestors('b', 'c')))\n\n    def test_iterdescendants(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [b, d, c, e],\n            list(a.iterdescendants()))\n        self.assertEqual(\n            [],\n            list(d.iterdescendants()))\n\n    def test_iterdescendants_tag(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [],\n            list(a.iterdescendants('a')))\n        self.assertEqual(\n            [],\n            list(a.iterdescendants(tag='a')))\n\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a2],\n            list(a.iterdescendants('a')))\n\n        self.assertEqual(\n            [a2],\n            list(c.iterdescendants('a')))\n        self.assertEqual(\n            [a2],\n            list(c.iterdescendants(tag='a')))\n\n    def test_iterdescendants_tag_multiple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [b, e],\n            list(a.iterdescendants(tag=('a', 'b', 'e'))))\n        self.assertEqual(\n            [b, e],\n            list(a.iterdescendants('a', 'b', 'e')))\n\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [b, a2],\n            list(a.iterdescendants(tag=('a', 'b'))))\n        self.assertEqual(\n            [b, a2],\n            list(a.iterdescendants('a', 'b')))\n\n        self.assertEqual(\n            [],\n            list(c.iterdescendants(tag=('x', 'y', 'z'))))\n        self.assertEqual(\n            [],\n            list(c.iterdescendants('x', 'y', 'z')))\n\n        self.assertEqual(\n            [b, d, c, e, a2],\n            list(a.iterdescendants(tag=('x', 'y', 'z', '*'))))\n        self.assertEqual(\n            [b, d, c, e, a2],\n            list(a.iterdescendants('x', 'y', 'z', '*')))\n\n    def test_getroottree(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            a,\n            a.getroottree().getroot())\n        self.assertEqual(\n            a,\n            b.getroottree().getroot())\n        self.assertEqual(\n            a,\n            d.getroottree().getroot())\n\n    def test_getnext(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        self.assertEqual(\n            None,\n            a.getnext())\n        self.assertEqual(\n            c,\n            b.getnext())\n        self.assertEqual(\n            None,\n            c.getnext())\n\n    def test_getprevious(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            None,\n            a.getprevious())\n        self.assertEqual(\n            b,\n            c.getprevious())\n        self.assertEqual(\n            None,\n            b.getprevious())\n\n    def test_itersiblings(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.itersiblings()))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings()))\n        self.assertEqual(\n            [],\n            list(c.itersiblings()))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True)))\n        self.assertEqual(\n            [],\n            list(b.itersiblings(preceding=True)))\n\n    def test_itersiblings_tag(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.itersiblings(tag='XXX')))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings(tag='c')))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings(tag='*')))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True, tag='b')))\n        self.assertEqual(\n            [],\n            list(c.itersiblings(preceding=True, tag='c')))\n\n    def test_itersiblings_tag_multiple(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(a, 'e')\n        self.assertEqual(\n            [],\n            list(a.itersiblings(tag=('XXX', 'YYY'))))\n        self.assertEqual(\n            [c, e],\n            list(b.itersiblings(tag=('c', 'd', 'e'))))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True, tag=('b', 'b', 'c', 'd'))))\n        self.assertEqual(\n            [c, b],\n            list(e.itersiblings(preceding=True, tag=('c', '*'))))\n\n    def test_parseid(self):\n        parseid = self.etree.parseid\n        XML     = self.etree.XML\n        xml_text = b'''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        '''\n\n        tree, dic = parseid(BytesIO(xml_text))\n        root = tree.getroot()\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"xmlid\"    : root[3],\n            \"warn1\"    : root[4]\n            }\n        self.assertTrue(\"chapter1\" in dic)\n        self.assertTrue(\"warn1\" in dic)\n        self.assertTrue(\"xmlid\" in dic)\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = b'''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        '''\n\n        root, dic = XMLDTDID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"xmlid\"    : root[3],\n            \"warn1\"    : root[4]\n            }\n        self.assertTrue(\"chapter1\" in dic)\n        self.assertTrue(\"warn1\" in dic)\n        self.assertTrue(\"xmlid\" in dic)\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID_empty(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = b'''\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        '''\n\n        root, dic = XMLDTDID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {}\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID_no_id_dict(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = b'''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        '''\n\n        parser = etree.XMLParser(collect_ids=False)\n        root, dic = XMLDTDID(xml_text, parser=parser)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                         self._writeElement(root2))\n        self.assertFalse(dic)\n        self._checkIDDict(dic, {})\n\n    def _checkIDDict(self, dic, expected):\n        self.assertEqual(len(dic),\n                          len(expected))\n        self.assertEqual(sorted(dic.items()),\n                          sorted(expected.items()))\n        self.assertEqual(sorted(dic.keys()),\n                          sorted(expected.keys()))\n\n    def test_register_namespace_xml(self):\n        self.assertRaises(ValueError, self.etree.register_namespace,\n                          \"XML\", \"http://www.w3.org/XML/1998/namespace\")\n        self.assertRaises(ValueError, self.etree.register_namespace,\n                          \"xml\", \"http://www.w3.org/XML/2345\")\n        self.etree.register_namespace(\"xml\", \"http://www.w3.org/XML/1998/namespace\")  # ok\n\n    def test_namespaces(self):\n        etree = self.etree\n\n        r = {'foo': 'http://ns.infrae.com/foo'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            'foo',\n            e.prefix)\n        self.assertEqual(\n            b'<foo:bar xmlns:foo=\"http://ns.infrae.com/foo\"></foo:bar>',\n            self._writeElement(e))\n        \n    def test_namespaces_default(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            None,\n            e.prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e.tag)\n        self.assertEqual(\n            b'<bar xmlns=\"http://ns.infrae.com/foo\"></bar>',\n            self._writeElement(e))\n\n    def test_namespaces_default_and_other(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo', 'p': 'http://test/'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(None, e.prefix)\n        self.assertEqual('{http://ns.infrae.com/foo}bar', e.tag)\n        self.assertEqual(\n            b'<bar xmlns=\"http://ns.infrae.com/foo\" xmlns:p=\"http://test/\"></bar>',\n            self._writeElement(e))\n\n    def test_namespaces_default_and_attr(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        e.set('{http://ns.infrae.com/hoi}test', 'value')\n        self.assertEqual(\n            b'<bar xmlns=\"http://ns.infrae.com/foo\" xmlns:hoi=\"http://ns.infrae.com/hoi\" hoi:test=\"value\"></bar>',\n            self._writeElement(e))\n\n    def test_attribute_keeps_namespace_prefix_on_merge(self):\n        etree = self.etree\n\n        root = etree.Element('{http://test/ns}root',\n                             nsmap={None: 'http://test/ns'})\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={'test': 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            b'<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>',\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            b'<root xmlns=\"http://test/ns\">'\n                   b'<sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'\n                   b'</root>',\n            etree.tostring(root))\n\n    def test_attribute_keeps_namespace_prefix_on_merge_with_nons(self):\n        etree = self.etree\n\n        root = etree.Element('root')\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={'test': 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            b'<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>',\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            b'<root>'\n                   b'<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'\n                   b'</root>',\n            etree.tostring(root))\n\n    def test_attribute_gets_namespace_prefix_on_merge_with_nons(self):\n        etree = self.etree\n\n        root = etree.Element('root')\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={None: 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            b'<sub xmlns=\"http://test/ns\" '\n                   b'xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>',\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            b'<root>'\n                   b'<sub xmlns=\"http://test/ns\"'\n                   b' xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'\n                   b'</root>',\n            etree.tostring(root))\n\n    def test_attribute_gets_namespace_prefix_on_merge(self):\n        etree = self.etree\n\n        root = etree.Element('{http://test/ns}root',\n                             nsmap={'test': 'http://test/ns',\n                                    None: 'http://test/ns'})\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={None: 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            b'<sub xmlns=\"http://test/ns\" '\n                   b'xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>',\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            b'<test:root xmlns:test=\"http://test/ns\" xmlns=\"http://test/ns\">'\n                   b'<test:sub test:attr=\"value\"/>'\n                   b'</test:root>',\n            etree.tostring(root))\n\n    def test_namespaces_elementtree(self):\n        etree = self.etree\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'} \n        e = etree.Element('{http://ns.infrae.com/foo}z', nsmap=r)\n        tree = etree.ElementTree(element=e)\n        etree.SubElement(e, '{http://ns.infrae.com/hoi}x')\n        self.assertEqual(\n            b'<z xmlns=\"http://ns.infrae.com/foo\" xmlns:hoi=\"http://ns.infrae.com/hoi\"><hoi:x></hoi:x></z>',\n            self._writeElement(e))\n\n    def test_namespaces_default_copy_element(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo'}\n        e1 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        e2 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n\n        e1.append(e2)\n\n        self.assertEqual(\n            None,\n            e1.prefix)\n        self.assertEqual(\n            None,\n            e1[0].prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e1.tag)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e1[0].tag)\n\n    def test_namespaces_copy_element(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/BAR'}\n        e1 = etree.Element('{http://ns.infrae.com/BAR}bar', nsmap=r)\n        e2 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n\n        e1.append(e2)\n\n        self.assertEqual(\n            None,\n            e1.prefix)\n        self.assertNotEqual(\n            None,\n            e2.prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/BAR}bar',\n            e1.tag)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e2.tag)\n\n    def test_namespaces_reuse_after_move(self):\n        ns_href = \"http://a.b.c\"\n        one = self.etree.fromstring(\n            '<foo><bar xmlns:ns=\"%s\"><ns:baz/></bar></foo>' % ns_href)\n        baz = one[0][0]\n\n        two = self.etree.fromstring(\n            '<root xmlns:ns=\"%s\"/>' % ns_href)\n        two.append(baz)\n        del one # make sure the source document is deallocated\n\n        self.assertEqual('{%s}baz' % ns_href, baz.tag)\n        self.assertEqual(\n            ('<root xmlns:ns=\"%s\"><ns:baz/></root>' % ns_href).encode('utf-8'),\n            self.etree.tostring(two))\n\n    def test_namespace_cleanup(self):\n        xml = (\n            b'<foo xmlns=\"F\" xmlns:x=\"x\">'\n            b'<bar xmlns:ns=\"NS\" xmlns:b=\"b\" xmlns=\"B\">'\n            b'<ns:baz/>'\n            b'</bar></foo>'\n        )\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<foo xmlns=\"F\"><bar xmlns:ns=\"NS\" xmlns=\"B\"><ns:baz/></bar></foo>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_attributes(self):\n        xml = (\n            b'<foo xmlns=\"F\" xmlns:x=\"X\" xmlns:a=\"A\">'\n            b'<bar xmlns:ns=\"NS\" xmlns:b=\"b\" xmlns=\"B\">'\n            b'<ns:baz a:test=\"attr\"/>'\n            b'</bar></foo>'\n        )\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<foo xmlns=\"F\" xmlns:a=\"A\">'\n                   b'<bar xmlns:ns=\"NS\" xmlns=\"B\">'\n                   b'<ns:baz a:test=\"attr\"/>'\n                   b'</bar></foo>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_many(self):\n        xml = ('<n12:foo ' +\n               ' '.join('xmlns:n{n}=\"NS{n}\"'.format(n=i) for i in range(100)) +\n               '><n68:a/></n12:foo>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<n12:foo xmlns:n12=\"NS12\" xmlns:n68=\"NS68\"><n68:a/></n12:foo>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_deep(self):\n        xml = ('<root>' +\n               ''.join('<a xmlns:n{n}=\"NS{n}\">'.format(n=i) for i in range(100)) +\n               '<n64:x/>' + '</a>'*100 + '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<root>' + b'<a>'*64 + b'<a xmlns:n64=\"NS64\">' + b'<a>'*35 +\n            b'<n64:x/>' + b'</a>'*100 + b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_deep_to_top(self):\n        xml = ('<root>' +\n               ''.join('<a xmlns:n{n}=\"NS{n}\">'.format(n=i) for i in range(100)) +\n               '<n64:x xmlns:a=\"A\" a:attr=\"X\"/>' +\n               '</a>'*100 +\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root, top_nsmap={'n64': 'NS64'})\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\">' + b'<a>'*100 +\n            b'<n64:x xmlns:a=\"A\" a:attr=\"X\"/>' + b'</a>'*100 + b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_keep_prefixes(self):\n        xml = (b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\" xmlns:unused1=\"UNUSED\" xmlns:no=\"NO\">'\n               b'<a xmlns:unused2=\"UNUSED\"><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n               b'<foo>foo:bar</foo>'\n               b'</root>')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root, keep_ns_prefixes=['foo'])\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\">'\n            b'<a><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n            b'<foo>foo:bar</foo>'\n            b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_keep_prefixes_top(self):\n        xml = (b'<root xmlns:n64=\"NS64\" xmlns:unused1=\"UNUSED\" xmlns:no=\"NO\">'\n               b'<sub xmlns:foo=\"FOO\">'\n               b'<a xmlns:unused2=\"UNUSED\"><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n               b'<foo>foo:bar</foo>'\n               b'</sub>'\n               b'</root>')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(\n            root,\n            top_nsmap={'foo': 'FOO', 'unused1': 'UNUSED'},\n            keep_ns_prefixes=['foo'])\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\">'\n            b'<sub>'\n            b'<a><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n            b'<foo>foo:bar</foo>'\n            b'</sub>'\n            b'</root>',\n            self.etree.tostring(root))\n\n    def test_element_nsmap(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            r,\n            e.nsmap)\n\n    def test_subelement_nsmap(self):\n        etree = self.etree\n\n        re = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=re)\n\n        rs = {None: 'http://ns.infrae.com/honk',\n             'top': 'http://ns.infrae.com/top'}\n        s = etree.SubElement(e, '{http://ns.infrae.com/honk}bar', nsmap=rs)\n\n        r = re.copy()\n        r.update(rs)\n        self.assertEqual(re, e.nsmap)\n        self.assertEqual(r,  s.nsmap)\n\n    def test_html_prefix_nsmap(self):\n        etree = self.etree\n        el = etree.HTML('<hha:page-description>aa</hha:page-description>')\n        pd = el[-1]\n        while len(pd):\n            pd = pd[-1]\n\n        if etree.LIBXML_VERSION >= (2, 10, 4):\n            # \"Prefix\" is kept as part of the tag name.\n            self.assertEqual(\"hha:page-description\", pd.tag)\n            self.assertIsNone(el.find('.//page-description'))\n            self.assertIsNotNone(el.find('.//hha:page-description'))  # no namespaces!\n            for e in el.iter():\n                self.assertEqual({}, e.nsmap)\n        elif etree.LIBXML_VERSION >= (2, 9, 11):\n            # \"Prefix\" is stripped.\n            self.assertEqual(\"page-description\", pd.tag)\n            self.assertIsNotNone(el.find('.//page-description'))\n            for e in el.iter():\n                self.assertEqual({}, e.nsmap)\n        else:\n            # \"Prefix\" is parsed as XML prefix.\n            self.assertEqual(\"page-description\", pd.tag)\n            pd = el.find('.//page-description')\n            self.assertEqual({'hha': None}, pd.nsmap)\n\n    def test_getchildren(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        self.assertEqual(\n            b'<a><b><d></d></b><c><e></e></c></a>',\n            self.etree.tostring(a, method=\"c14n\"))\n        self.assertEqual(\n            [b, c],\n            a.getchildren())\n        self.assertEqual(\n            [d],\n            b.getchildren())\n        self.assertEqual(\n            [],\n            d.getchildren())\n\n    def test_getiterator(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator()))\n        self.assertEqual(\n            [d],\n            list(d.getiterator()))\n\n    def test_getiterator_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [],\n            list(a.getiterator('none')))\n        self.assertEqual(\n            [],\n            list(e.getiterator('none')))\n        self.assertEqual(\n            [e],\n            list(e.getiterator()))\n\n    def test_getiterator_filter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a2],\n            list(c.getiterator('a')))\n\n    def test_getiterator_filter_all(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator('*')))\n\n    def test_getiterator_filter_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        comment_b = Comment(\"TEST-b\")\n        b.append(comment_b)\n\n        self.assertEqual(\n            [comment_b],\n            list(a.getiterator(Comment)))\n\n        comment_a = Comment(\"TEST-a\")\n        a.append(comment_a)\n\n        self.assertEqual(\n            [comment_b, comment_a],\n            list(a.getiterator(Comment)))\n\n        self.assertEqual(\n            [comment_b],\n            list(b.getiterator(Comment)))\n\n    def test_getiterator_filter_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.ProcessingInstruction\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        pi_b = PI(\"TEST-b\")\n        b.append(pi_b)\n\n        self.assertEqual(\n            [pi_b],\n            list(a.getiterator(PI)))\n\n        pi_a = PI(\"TEST-a\")\n        a.append(pi_a)\n\n        self.assertEqual(\n            [pi_b, pi_a],\n            list(a.getiterator(PI)))\n\n        self.assertEqual(\n            [pi_b],\n            list(b.getiterator(PI)))\n\n    def test_getiterator_with_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1'\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1'\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1'\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1'\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator()))\n        #self.assertEqual(\n        #    [d],\n        #    list(d.getiterator()))\n\n    def test_getiterator_filter_with_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1'\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1'\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1'\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1'\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a2],\n            list(e.getiterator('a')))\n\n    def test_getiterator_filter_multiple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        f = SubElement(c, 'f')\n\n        self.assertEqual(\n            [a, b],\n               list(a.getiterator('a', 'b')))\n        self.assertEqual(\n            [],\n              list(a.getiterator('x', 'y')))\n        self.assertEqual(\n            [a, f],\n              list(a.getiterator('f', 'a')))\n        self.assertEqual(\n            [c, e, f],\n               list(c.getiterator('c', '*', 'a')))\n        self.assertEqual(\n            [],\n                  list(a.getiterator( (), () )))\n\n    def test_getiterator_filter_multiple_tuple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        f = SubElement(c, 'f')\n\n        self.assertEqual(\n            [a, b],\n                  list(a.getiterator( ('a', 'b') )))\n        self.assertEqual(\n            [],\n              list(a.getiterator( ('x', 'y') )))\n        self.assertEqual(\n            [a, f],\n                  list(a.getiterator( ('f', 'a') )))\n        self.assertEqual(\n            [c, e, f],\n                     list(c.getiterator( ('c', '*', 'a') )))\n        self.assertEqual(\n            [],\n              list(a.getiterator( () )))\n\n    def test_getiterator_filter_namespace(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('{a}a')\n        b = SubElement(a, '{a}b')\n        c = SubElement(a, '{a}c')\n        d = SubElement(b, '{b}d')\n        e = SubElement(c, '{a}e')\n        f = SubElement(c, '{b}f')\n        g = SubElement(c, 'g')\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('{a}a')))\n        self.assertEqual(\n            [],\n            list(a.getiterator('{b}a')))\n        self.assertEqual(\n            [],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a,b,d,c,e,f,g],\n            list(a.getiterator('*')))\n        self.assertEqual(\n            [f],\n            list(c.getiterator('{b}*')))\n        self.assertEqual(\n            [d, f],\n            list(a.getiterator('{b}*')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('g')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('{}g')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('{}*')))\n\n    def test_getiterator_filter_local_name(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('{a}a')\n        b = SubElement(a, '{nsA}b')\n        c = SubElement(b, '{nsB}b')\n        d = SubElement(a, 'b')\n        e = SubElement(a, '{nsA}e')\n        f = SubElement(e, '{nsB}e')\n        g = SubElement(e, 'e')\n        a.append(Comment('test'))\n\n        self.assertEqual(\n            [b, c, d],\n            list(a.getiterator('{*}b')))\n        self.assertEqual(\n            [e, f, g],\n            list(a.getiterator('{*}e')))\n        self.assertEqual(\n            [a, b, c, d, e, f, g],\n            list(a.getiterator('{*}*')))\n\n    def test_getiterator_filter_entities(self):\n        Element = self.etree.Element\n        Entity = self.etree.Entity\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        entity_b = Entity(\"TEST-b\")\n        b.append(entity_b)\n\n        self.assertEqual(\n            [entity_b],\n            list(a.getiterator(Entity)))\n\n        entity_a = Entity(\"TEST-a\")\n        a.append(entity_a)\n\n        self.assertEqual(\n            [entity_b, entity_a],\n            list(a.getiterator(Entity)))\n\n        self.assertEqual(\n            [entity_b],\n            list(b.getiterator(Entity)))\n\n    def test_getiterator_filter_element(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        PI = self.etree.PI\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.append(Comment(\"test\"))\n        a.append(PI(\"pi\", \"content\"))\n        c = SubElement(a, 'c')\n\n        self.assertEqual(\n            [a, b, c],\n            list(a.getiterator(Element)))\n\n    def test_getiterator_filter_all_comment_pi(self):\n        # ElementTree iterates over everything here\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        PI = self.etree.PI\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.append(Comment(\"test\"))\n        a.append(PI(\"pi\", \"content\"))\n        c = SubElement(a, 'c')\n\n        self.assertEqual(\n            [a, b, c],\n            list(a.getiterator('*')))\n\n    def test_elementtree_getiterator(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        t = ElementTree(element=a)\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(t.getiterator()))\n\n    def test_elementtree_getiterator_filter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        t = ElementTree(element=a)\n\n        self.assertEqual(\n            [a],\n            list(t.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(t.getiterator('a')))\n\n    def test_elementtree_getelementpath(self):\n        a  = etree.Element(\"a\")\n        b  = etree.SubElement(a, \"b\")\n        c  = etree.SubElement(a, \"c\")\n        d1 = etree.SubElement(c, \"d\")\n        d2 = etree.SubElement(c, \"d\")\n        c.text = d1.text = 'TEXT'\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('.', tree.getelementpath(a))\n        self.assertEqual('c/d[1]', tree.getelementpath(d1))\n        self.assertEqual('c/d[2]', tree.getelementpath(d2))\n\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('.', tree.getelementpath(c))\n        self.assertEqual('d[2]', tree.getelementpath(d2))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n\n        tree = etree.ElementTree(b)  # not a parent of a/c/d1/d2\n        self.assertEqual('.', tree.getelementpath(b))\n        self.assertRaises(ValueError, tree.getelementpath, a)\n        self.assertRaises(ValueError, tree.getelementpath, c)\n        self.assertRaises(ValueError, tree.getelementpath, d2)\n\n    def test_elementtree_getelementpath_ns(self):\n        a  = etree.Element(\"{http://ns1/}a\")\n        b  = etree.SubElement(a, \"{http://ns1/}b\")\n        c  = etree.SubElement(a, \"{http://ns1/}c\")\n        d1 = etree.SubElement(c, \"{http://ns1/}d\")\n        d2 = etree.SubElement(c, \"{http://ns2/}d\")\n        d3 = etree.SubElement(c, \"{http://ns1/}d\")\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('.', tree.getelementpath(a))\n        self.assertEqual('{http://ns1/}c/{http://ns1/}d[1]',\n                         tree.getelementpath(d1))\n        self.assertEqual('{http://ns1/}c/{http://ns2/}d',\n                         tree.getelementpath(d2))\n        self.assertEqual('{http://ns1/}c/{http://ns1/}d[2]',\n                         tree.getelementpath(d3))\n\n        self.assertEqual(a, tree.find(tree.getelementpath(a)))\n        self.assertEqual(b, tree.find(tree.getelementpath(b)))\n        self.assertEqual(c, tree.find(tree.getelementpath(c)))\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n        self.assertEqual(d3, tree.find(tree.getelementpath(d3)))\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('{http://ns1/}d[1]', tree.getelementpath(d1))\n        self.assertEqual('{http://ns2/}d', tree.getelementpath(d2))\n        self.assertEqual('{http://ns1/}d[2]', tree.getelementpath(d3))\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n        self.assertEqual(d3, tree.find(tree.getelementpath(d3)))\n\n        tree = etree.ElementTree(b)  # not a parent of d1/d2\n        self.assertRaises(ValueError, tree.getelementpath, d1)\n        self.assertRaises(ValueError, tree.getelementpath, d2)\n\n    def test_elementtree_iter_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(\n                b'<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>'))\n        self.assertEqual(\n            list(tree.iter(QName(\"b\"))),\n            list(tree.iter(\"b\")),\n        )\n        self.assertEqual(\n            list(tree.iter(QName(\"X\", \"b\"))),\n            list(tree.iter(\"{X}b\")),\n        )\n\n        self.assertEqual(\n            [e.tag for e in tree.iter(QName(\"X\", \"b\"), QName(\"b\"))],\n            ['{X}b', 'b', '{X}b', 'b', 'b']\n        )\n        self.assertEqual(\n            list(tree.iter(QName(\"X\", \"b\"), QName(\"b\"))),\n            list(tree.iter(\"{X}b\", \"b\"))\n        )\n\n    def test_elementtree_find_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(b'<a><b><c/></b><b/><c><b/></c></a>'))\n        self.assertEqual(tree.find(QName(\"c\")), tree.getroot()[2])\n\n    def test_elementtree_findall_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(b'<a><b><c/></b><b/><c><b/></c></a>'))\n        self.assertEqual(len(list(tree.findall(QName(\"c\")))), 1)\n\n    def test_elementtree_findall_ns_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(\n                b'<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>'))\n        self.assertEqual(len(list(tree.findall(QName(\"b\")))), 2)\n        self.assertEqual(len(list(tree.findall(QName(\"X\", \"b\")))), 1)\n\n    def test_findall_ns(self):\n        XML = self.etree.XML\n        root = XML(b'<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')\n        self.assertEqual(len(root.findall(\".//{X}b\")), 2)\n        self.assertEqual(len(root.findall(\".//{X}*\")), 2)\n        self.assertEqual(len(root.findall(\".//b\")), 3)\n\n    def test_findall_different_nsmaps(self):\n        XML = self.etree.XML\n        root = XML(b'<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><y:b/></a>')\n        nsmap = {'xx': 'X'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 2)\n        self.assertEqual(len(root.findall(\".//xx:*\", namespaces=nsmap)), 2)\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 2)\n        nsmap = {'xx': 'Y'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 1)\n        self.assertEqual(len(root.findall(\".//xx:*\", namespaces=nsmap)), 1)\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 2)\n\n    def test_findall_empty_prefix(self):\n        XML = self.etree.XML\n        root = XML(b'<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><y:b/></a>')\n        nsmap = {'xx': 'X'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 2)\n        nsmap = {'xx': 'X', None: 'Y'}\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 1)\n        nsmap = {'xx': 'X', '': 'Y'}\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 1)\n\n    def test_findall_syntax_error(self):\n        XML = self.etree.XML\n        root = XML(b'<a><b><c/></b><b/><c><b/><b/></c><b/></a>')\n        self.assertRaises(SyntaxError, root.findall, '')\n        self.assertRaises(SyntaxError, root.findall, '//')  # absolute path on Element\n        self.assertRaises(SyntaxError, root.findall, './//')\n\n    def test_index(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            etree.SubElement(e, 'a%s' % i)\n        for i in range(10):\n            self.assertEqual(\n                i,\n                e.index(e[i]))\n        self.assertEqual(\n            3, e.index(e[3], 3))\n        self.assertRaises(\n            ValueError, e.index, e[3], 4)\n        self.assertRaises(\n            ValueError, e.index, e[3], 0, 2)\n        self.assertRaises(\n            ValueError, e.index, e[8], 0, -3)\n        self.assertRaises(\n            ValueError, e.index, e[8], -5, -3)\n        self.assertEqual(\n            8, e.index(e[8], 0, -1))\n        self.assertEqual(\n            8, e.index(e[8], -12, -1))\n        self.assertEqual(\n            0, e.index(e[0], -12, -1))\n\n    def test_replace(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            el = etree.SubElement(e, 'a%s' % i)\n            el.text = \"text%d\" % i\n            el.tail = \"tail%d\" % i\n\n        child0 = e[0]\n        child1 = e[1]\n        child2 = e[2]\n\n        e.replace(e[0], e[1])\n        self.assertEqual(\n            9, len(e))\n        self.assertEqual(\n            child1, e[0])\n        self.assertEqual(\n            child1.text, \"text1\")\n        self.assertEqual(\n            child1.tail, \"tail1\")\n        self.assertEqual(\n            child0.tail, \"tail0\")\n        self.assertEqual(\n            child2, e[1])\n\n        e.replace(e[-1], e[0])\n        self.assertEqual(\n            child1, e[-1])\n        self.assertEqual(\n            child1.text, \"text1\")\n        self.assertEqual(\n            child1.tail, \"tail1\")\n        self.assertEqual(\n            child2, e[0])\n\n    def test_replace_new(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            etree.SubElement(e, 'a%s' % i)\n\n        new_element = etree.Element(\"test\")\n        new_element.text = \"TESTTEXT\"\n        new_element.tail = \"TESTTAIL\"\n        child1 = e[1]\n        e.replace(e[0], new_element)\n        self.assertEqual(\n            new_element, e[0])\n        self.assertEqual(\n            \"TESTTEXT\",\n            e[0].text)\n        self.assertEqual(\n            \"TESTTAIL\",\n            e[0].tail)\n        self.assertEqual(\n            child1, e[1])\n\n    def test_setslice_all_reversed(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        a[:] = [e, f, g]\n        self.assertEqual(\n            [e, f, g],\n            list(a))\n\n        a[::-1] = [e, f, g]\n        self.assertEqual(\n            [g, f, e],\n            list(a))\n\n    def test_setslice_step(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1::2] = [x, y]\n        self.assertEqual(\n            [b, x, d, y],\n            list(a))\n\n    def test_setslice_step_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1::-1] = [x, y]\n        self.assertEqual(\n            [y, x, d, e],\n            list(a))\n\n    def test_setslice_step_negative2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[::-2] = [x, y]\n        self.assertEqual(\n            [b, y, d, x],\n            list(a))\n\n    def test_setslice_step_overrun(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        try:\n            slice\n        except NameError:\n            print(\"slice() not found\")\n            return\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n        z = Element('z')\n\n        self.assertRaises(\n            ValueError,\n            operator.setitem, a, slice(1,None,2), [x, y, z])\n\n        self.assertEqual(\n            [b, c, d, e],\n            list(a))\n\n    def test_sourceline_XML(self):\n        XML = self.etree.XML\n        root = XML(b'''<?xml version=\"1.0\"?>\n        <root><test>\n\n        <bla/></test>\n        </root>\n        ''')\n\n        self.assertEqual(\n            [2, 2, 4],\n            [ el.sourceline for el in root.getiterator() ])\n\n    def test_large_sourceline_XML(self):\n        XML = self.etree.XML\n        root = XML(\n            b'<?xml version=\"1.0\"?>\\n'\n            b'<root>' + b'\\n' * 65536 +\n            b'<p>' + b'\\n' * 65536 + b'</p>\\n' +\n            b'<br/>\\n'\n            b'</root>')\n\n        if self.etree.LIBXML_VERSION >= (2, 9):\n            expected = [2, 131074, 131076]\n        else:\n            expected = [2, 65535, 65535]\n\n        self.assertEqual(expected, [el.sourceline for el in root.iter()])\n\n    def test_sourceline_parse(self):\n        parse = self.etree.parse\n        tree = parse(fileInTestDir('include/test_xinclude.xml'))\n\n        self.assertEqual(\n            [1, 2, 3],\n            [ el.sourceline for el in tree.getiterator() ])\n\n    def test_sourceline_iterparse_end(self):\n        iterparse = self.etree.iterparse\n        lines = [ el.sourceline for (event, el) in \n                  iterparse(fileInTestDir('include/test_xinclude.xml')) ]\n\n        self.assertEqual(\n            [2, 3, 1],\n            lines)\n\n    def test_sourceline_iterparse_start(self):\n        iterparse = self.etree.iterparse\n        lines = [ el.sourceline for (event, el) in \n                  iterparse(fileInTestDir('include/test_xinclude.xml'),\n                            events=(\"start\",)) ]\n\n        self.assertEqual(\n            [1, 2, 3],\n            lines)\n\n    def test_very_large_sourceline_iterparse(self):\n        if self.etree.LIBXML_VERSION < (2, 11):\n            return\n        # libxml2 has a default limit of 10M for text content, so we use 125*3*6M text chunks, 2.2G total.\n        lines = b'\\n' * (1024 * 1024 * 6)\n        data = [b'<?xml version=\"1.0\"?>\\n', b'<root>\\n']\n        data += [lines + b'<br/>', lines + b'<p>', lines + b'</p>'] * 125\n        data.append(b'\\n<p>xxx</p>')\n        data.append(b'\\n</root>')\n        expected_last_line = 3 + (len(data) - 4) * len(lines)\n        assert expected_last_line > 2**31\n\n        chunks = iter(data)\n\n        class Source(object):\n            def read(self, _):\n                try:\n                    return next(chunks)\n                except StopIteration:\n                    return b''\n\n        events = self.etree.iterparse(Source(), events=['end'])\n\n        root = last_el = None\n        for _, el in events:\n            root = last_el = el.getparent()\n            break\n\n        max_line = 0\n        for _, el in events:\n            if len(root) > 20:\n                del root[:18]\n            line = last_el.sourceline\n            if line is not None:\n                if max_line > line:\n                    # This is the main thing that we currently test:\n                    self.assertLessEqual(max_line, line)\n                max_line = line\n            last_el = el\n\n        # The final line does not seem very accurate, so we stop here.\n        #self.assertGreater(max_line, 2**31)\n        #self.assertEqual(expected_last_line, max_line)\n\n    def test_sourceline_element(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        el = Element(\"test\")\n        self.assertEqual(None, el.sourceline)\n\n        child = SubElement(el, \"test\")\n        self.assertEqual(None, el.sourceline)\n        self.assertEqual(None, child.sourceline)\n\n    def test_XML_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_XML_set_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n        docinfo.URL = \"https://secret/url\"\n        self.assertEqual(docinfo.URL, \"https://secret/url\")\n\n    def test_parse_stringio_base_url(self):\n        etree = self.etree\n        tree = etree.parse(BytesIO(b\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_parse_base_url_docinfo(self):\n        etree = self.etree\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_HTML_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.HTML(b\"<html/>\", base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_docinfo_public(self):\n        etree = self.etree\n        xml_header = '<?xml version=\"1.0\" encoding=\"ascii\"?>'\n        pub_id = \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        sys_id = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n        doctype_string = '<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_id)\n\n        xml = _bytes(xml_header + doctype_string + '<html><body></body></html>')\n\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"ascii\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   pub_id)\n        self.assertEqual(docinfo.system_url,  sys_id)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, doctype_string)\n\n    def test_docinfo_system(self):\n        etree = self.etree\n        xml_header = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n        sys_id = \"some.dtd\"\n        doctype_string = '<!DOCTYPE html SYSTEM \"%s\">' % sys_id\n        xml = _bytes(xml_header + doctype_string + '<html><body></body></html>')\n\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  sys_id)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, doctype_string)\n\n    def test_docinfo_empty(self):\n        etree = self.etree\n        xml = b'<html><body></body></html>'\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  None)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, '')\n\n    def test_docinfo_name_only(self):\n        etree = self.etree\n        xml = b'<!DOCTYPE root><root></root>'\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  None)\n        self.assertEqual(docinfo.root_name,   'root')\n        self.assertEqual(docinfo.doctype, '<!DOCTYPE root>')\n\n    def test_doctype_name_only_roundtrip(self):\n        etree = self.etree\n        xml = b'<!DOCTYPE root>\\n<root/>'\n        tree = etree.parse(BytesIO(xml))\n        self.assertEqual(xml, etree.tostring(tree))\n\n    def test_doctype_output_override(self):\n        etree = self.etree\n        pub_id = b\"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        sys_id = b\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n        doctype_string = b'<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_id)\n\n        xml = b'<!DOCTYPE root>\\n<root/>'\n        tree = etree.parse(BytesIO(xml))\n        self.assertEqual(xml.replace(b'<!DOCTYPE root>', doctype_string),\n                          etree.tostring(tree, doctype=doctype_string))\n\n    def test_xml_base(self):\n        etree = self.etree\n        root = etree.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.base = \"https://secret/url\"\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_xml_base_attribute(self):\n        etree = self.etree\n        root = etree.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.set('{http://www.w3.org/XML/1998/namespace}base',\n                 \"https://secret/url\")\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_html_base(self):\n        etree = self.etree\n        root = etree.HTML(b\"<html><body></body></html>\",\n                          base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n\n    def test_html_base_tag(self):\n        etree = self.etree\n        root = etree.HTML(b'<html><head><base href=\"http://no/such/url\"></head></html>')\n        self.assertEqual(root.base, \"http://no/such/url\")\n\n    def test_indent(self):\n        ET = self.etree\n        elem = ET.XML(\"<root></root>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<root/>')\n\n        elem = ET.XML(\"<html><body>text</body></html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html> <body>text</body>  </html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html> <body>text</body>   </html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html><body>text</body>tail</html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>tail</html>')\n\n        elem = ET.XML(\"<html><body><p>par</p>\\n<p>text</p>\\t<p><br/></p></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'    <p>par</p>\\n'\n            b'    <p>text</p>\\n'\n            b'    <p>\\n'\n            b'      <br/>\\n'\n            b'    </p>\\n'\n            b'  </body>\\n'\n            b'</html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'    <p>pre<br/>post</p>\\n'\n            b'    <p>text</p>\\n'\n            b'  </body>\\n'\n            b'</html>'\n        )\n\n    def test_indent_space(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, space='\\t')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'\\t<body>\\n'\n            b'\\t\\t<p>pre<br/>post</p>\\n'\n            b'\\t\\t<p>text</p>\\n'\n            b'\\t</body>\\n'\n            b'</html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, space='')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'<body>\\n'\n            b'<p>pre<br/>post</p>\\n'\n            b'<p>text</p>\\n'\n            b'</body>\\n'\n            b'</html>'\n        )\n\n    def test_indent_space_caching(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>par</p><p>text</p><p><br/></p><p /></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            {el.tail for el in elem.iter()},\n            {None, \"\\n\", \"\\n  \", \"\\n    \"}\n        )\n        self.assertEqual(\n            {el.text for el in elem.iter()},\n            {None, \"\\n  \", \"\\n    \", \"\\n      \", \"par\", \"text\"}\n        )\n        # NOTE: lxml does not reuse Python text strings across elements.\n        #self.assertEqual(\n        #    len({el.tail for el in elem.iter()}),\n        #    len({id(el.tail) for el in elem.iter()}),\n        #)\n\n    def test_indent_level(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        try:\n            ET.indent(elem, level=-1)\n        except ValueError:\n            pass\n        else:\n            self.assertTrue(False, \"ValueError not raised\")\n        self.assertEqual(\n            ET.tostring(elem),\n            b\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\"\n        )\n\n        ET.indent(elem, level=2)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'      <body>\\n'\n            b'        <p>pre<br/>post</p>\\n'\n            b'        <p>text</p>\\n'\n            b'      </body>\\n'\n            b'    </html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, level=1, space=' ')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'   <p>pre<br/>post</p>\\n'\n            b'   <p>text</p>\\n'\n            b'  </body>\\n'\n            b' </html>'\n        )\n\n    def test_parse_fileobject_unicode(self):\n        # parse from a file object that returns unicode strings\n        f = LargeFileLikeUnicode()\n        tree = self.etree.parse(f)\n        root = tree.getroot()\n        self.assertTrue(root.tag.endswith('root'))\n\n    def test_dtd_io(self):\n        # check that DTDs that go in also go back out\n        xml = b'''\\\n        <!DOCTYPE test SYSTEM \"test.dtd\" [\n          <!ENTITY entity \"tasty\">\n          <!ELEMENT test (a)>\n          <!ELEMENT a (#PCDATA)>\n        ]>\n        <test><a>test-test</a></test>\\\n        '''\n        tree = self.etree.parse(BytesIO(xml))\n        self.assertEqual(self.etree.tostring(tree).replace(b\" \", b\"\"),\n                         xml.replace(b\" \", b\"\"))\n\n    def test_byte_zero(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\0ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\0ho')\n\n        self.assertRaises(ValueError, Element, 'ha\\0ho')\n\n    def test_unicode_byte_zero(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          'ha\\0ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          'ha\\0ho')\n\n        self.assertRaises(ValueError, Element,\n                          'ha\\0ho')\n\n    def test_byte_invalid(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\x02ho')\n\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\x02ho')\n\n        self.assertRaises(ValueError, Element, 'ha\\x07ho')\n        self.assertRaises(ValueError, Element, 'ha\\x02ho')\n\n    def test_unicode_byte_invalid(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          'ha\\x02ho')\n\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          'ha\\x02ho')\n\n        self.assertRaises(ValueError, Element,\n                          'ha\\x07ho')\n        self.assertRaises(ValueError, Element,\n                          'ha\\x02ho')\n\n    def test_unicode_byte_invalid_sequence(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          'ha\\u1234\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          'ha\\u1234\\x02ho')\n\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          'ha\\u1234\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          'ha\\u1234\\x02ho')\n\n        self.assertRaises(ValueError, Element,\n                          'ha\\u1234\\x07ho')\n        self.assertRaises(ValueError, Element,\n                          'ha\\u1234\\x02ho')\n\n    def test_encoding_tostring_utf16(self):\n        # ElementTree fails to serialize this\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a, encoding='UTF-16')\n        self.assertEqual(b'<a><b></b><c></c></a>',\n                          canonicalize(result))\n\n    def test_tostring_none(self):\n        # ElementTree raises an AssertionError here\n        tostring = self.etree.tostring\n        self.assertRaises(TypeError, self.etree.tostring, None)\n\n    def test_tostring_pretty(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a)\n        self.assertEqual(result, b\"<a><b/><c/></a>\")\n\n        result = tostring(a, pretty_print=False)\n        self.assertEqual(result, b\"<a><b/><c/></a>\")\n\n        result = tostring(a, pretty_print=True)\n        self.assertEqual(result, b\"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_tostring_with_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.tail = \"aTAIL\"\n        b = SubElement(a, 'b')\n        b.tail = \"bTAIL\"\n        c = SubElement(a, 'c')\n\n        result = tostring(a)\n        self.assertEqual(result, b\"<a><b/>bTAIL<c/></a>aTAIL\")\n\n        result = tostring(a, with_tail=False)\n        self.assertEqual(result, b\"<a><b/>bTAIL<c/></a>\")\n\n        result = tostring(a, with_tail=True)\n        self.assertEqual(result, b\"<a><b/>bTAIL<c/></a>aTAIL\")\n\n    def test_tostring_method_html_with_tail(self):\n        tostring = self.etree.tostring\n        html = self.etree.fromstring(\n            '<html><body>'\n            '<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n'\n            '</body></html>',\n            parser=self.etree.HTMLParser())\n        self.assertEqual(html.tag, 'html')\n        div = html.find('.//div')\n        self.assertEqual(div.tail, '\\r\\n')\n        result = tostring(div, method='html')\n        self.assertEqual(\n            result,\n            b\"<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n\")\n        result = tostring(div, method='html', with_tail=True)\n        self.assertEqual(\n            result,\n            b\"<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n\")\n        result = tostring(div, method='html', with_tail=False)\n        self.assertEqual(\n            result,\n            b\"<div><p>Some text<i>\\r\\n</i></p></div>\")\n\n    def test_standalone(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n\n        tree = Element(\"root\").getroottree()\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        tree = XML(b\"<root/>\").getroottree()\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"\n            )).getroottree()\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='no'?>\\n<root/>\"\n            )).getroottree()\n        self.assertEqual(False, tree.docinfo.standalone)\n\n    def test_tostring_standalone(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n\n        root = XML(b\"<root/>\")\n\n        tree = ElementTree(root)\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\")\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII'?>\\n<root/>\"))\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=True)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"))\n\n        tree = ElementTree(XML(result))\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=False)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='no'?>\\n<root/>\"))\n\n        tree = ElementTree(XML(result))\n        self.assertEqual(False, tree.docinfo.standalone)\n\n    def test_tostring_standalone_in_out(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n\n        root = XML(_bytes(\n            \"<?xml version='1.0' encoding='UTF-8' standalone='yes'?>\\n<root/>\"))\n\n        tree = ElementTree(root)\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\")\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII'?>\\n<root/>\"))\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=True)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"))\n\n    def test_tostring_method_text_encoding(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        a.text = \"A\"\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = _str(\"S\u00f8k p\u00e5 nettet\")\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n\n        result = tostring(a, method=\"text\", encoding=\"UTF-16\")\n\n        self.assertEqual('ABS\u00f8k p\u00e5 nettetCtail'.encode(\"UTF-16\"),\n                          result)\n\n    def test_tostring_method_text_unicode(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettetA'\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = 'S\u00f8k p\u00e5 nettetB'\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n        \n        self.assertRaises(UnicodeEncodeError,\n                          tostring, a, method=\"text\")\n        \n        self.assertEqual(\n            'S\u00f8k p\u00e5 nettetABS\u00f8k p\u00e5 nettetBCtail'.encode(),\n            tostring(a, encoding=\"UTF-8\", method=\"text\"))\n\n    def test_tounicode(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        \n        self.assertTrue(isinstance(tounicode(a), str))\n        self.assertEqual(b'<a><b></b><c></c></a>',\n                          canonicalize(tounicode(a)))\n\n    def test_tounicode_element(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertTrue(isinstance(tounicode(b), str))\n        self.assertTrue(isinstance(tounicode(c), str))\n        self.assertEqual(b'<b></b>',\n                          canonicalize(tounicode(b)))\n        self.assertEqual(b'<c><d></d></c>',\n                          canonicalize(tounicode(c)))\n\n    def test_tounicode_none(self):\n        tounicode = self.etree.tounicode\n        self.assertRaises(TypeError, self.etree.tounicode, None)\n\n    def test_tounicode_element_tail(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(isinstance(tounicode(b), str))\n        self.assertTrue(tounicode(b) == '<b/>Foo' or\n                     tounicode(b) == '<b />Foo')\n\n    def test_tounicode_pretty(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tounicode(a)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tounicode(a, pretty_print=False)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tounicode(a, pretty_print=True)\n        self.assertEqual(result, \"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_tostring_unicode(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        \n        self.assertTrue(isinstance(tostring(a, encoding='unicode'), str))\n        self.assertEqual(b'<a><b></b><c></c></a>',\n                          canonicalize(tostring(a, encoding='unicode')))\n\n    def test_tostring_unicode_element(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertTrue(isinstance(tostring(b, encoding='unicode'), str))\n        self.assertTrue(isinstance(tostring(c, encoding='unicode'), str))\n        self.assertEqual(b'<b></b>',\n                          canonicalize(tostring(b, encoding=str)))\n        self.assertEqual(b'<c><d></d></c>',\n                          canonicalize(tostring(c, encoding=str)))\n\n    def test_tostring_unicode_none(self):\n        tostring = self.etree.tostring\n        self.assertRaises(TypeError, self.etree.tostring,\n                          None, encoding='unicode')\n\n    def test_tostring_unicode_element_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(isinstance(tostring(b, encoding='unicode'), str))\n        self.assertTrue(tostring(b, encoding='unicode') == '<b/>Foo' or\n                     tostring(b, encoding='unicode') == '<b />Foo')\n\n    def test_tostring_unicode_pretty(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a, encoding='unicode')\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tostring(a, encoding='unicode', pretty_print=False)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tostring(a, encoding='unicode', pretty_print=True)\n        self.assertEqual(result, \"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_pypy_proxy_collect(self):\n        root = etree.Element('parent')\n        etree.SubElement(root, 'child')\n\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, 'child')\n\n        # in PyPy, GC used to kill the Python proxy instance without cleanup\n        gc.collect()\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, 'child')\n\n    def test_element_refcycle(self):\n        class SubEl(etree.ElementBase):\n            pass\n\n        el1 = SubEl()\n        el2 = SubEl()\n        self.assertEqual('SubEl', el1.tag)\n        self.assertEqual('SubEl', el2.tag)\n        el1.other = el2\n        el2.other = el1\n\n        del el1, el2\n        gc.collect()\n        # not really testing anything here, but it shouldn't crash\n\n    def test_proxy_collect_siblings(self):\n        root = etree.Element('parent')\n        c1 = etree.SubElement(root, 'child1')\n        c2 = etree.SubElement(root, 'child2')\n\n        root.remove(c1)\n        root.remove(c2)\n        c1.addnext(c2)\n        del c1\n        # trigger deallocation attempt of c1\n        c2.getprevious()\n        # make sure it wasn't deallocated\n        self.assertEqual('child1', c2.getprevious().tag)\n\n    def test_proxy_collect_siblings_text(self):\n        root = etree.Element('parent')\n        c1 = etree.SubElement(root, 'child1')\n        c2 = etree.SubElement(root, 'child2')\n\n        root.remove(c1)\n        root.remove(c2)\n        c1.addnext(c2)\n        c1.tail = 'abc'\n        c2.tail = 'xyz'\n        del c1\n        # trigger deallocation attempt of c1\n        c2.getprevious()\n        # make sure it wasn't deallocated\n        self.assertEqual('child1', c2.getprevious().tag)\n        self.assertEqual('abc', c2.getprevious().tail)\n\n    def test_parse_source_pathlike(self):\n        etree = self.etree\n        tounicode = self.etree.tounicode\n\n        tree = etree.parse(SimpleFSPath(fileInTestDir('test.xml')))\n        self.assertEqual(b'<a><b></b></a>',\n                         canonicalize(tounicode(tree)))\n    \n    def test_iterparse_source_pathlike(self):\n        iterparse = self.etree.iterparse\n\n        events = list(iterparse(SimpleFSPath(fileInTestDir('test.xml'))))\n        self.assertEqual(2, len(events))\n\n    # helper methods\n\n    def _writeElement(self, element, encoding='us-ascii', compression=0):\n        \"\"\"Write out element for comparison.\n        \"\"\"\n        ElementTree = self.etree.ElementTree\n        f = BytesIO()\n        tree = ElementTree(element=element)\n        tree.write(f, encoding=encoding, compression=compression)\n        data = f.getvalue()\n        if compression:\n            data = zlib.decompress(data)\n        return canonicalize(data)\n\n\nclass _XIncludeTestCase(HelperTestCase):\n    def test_xinclude_text(self):\n        filename = fileInTestDir('test_broken.xml')\n        root = etree.XML('''\\\n        <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n          <xi:include href=\"%s\" parse=\"text\"/>\n        </doc>\n        ''' % path2url(filename))\n        old_text = root.text\n        content = read_file(filename)\n        old_tail = root[0].tail\n\n        self.include( etree.ElementTree(root) )\n        self.assertEqual(old_text + content + old_tail,\n                          root.text)\n\n    def test_xinclude(self):\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'))\n        self.assertNotEqual(\n            'a',\n            tree.getroot()[1].tag)\n        # process xincludes\n        self.include( tree )\n        # check whether we find it replaced with included data\n        self.assertEqual(\n            'a',\n            tree.getroot()[1].tag)\n\n    def test_xinclude_resolver(self):\n        class res(etree.Resolver):\n            include_text = read_file(fileInTestDir('test.xml'))\n            called = {}\n            def resolve(self, url, id, context):\n                if url.endswith(\".dtd\"):\n                    self.called[\"dtd\"] = True\n                    return self.resolve_filename(\n                        fileInTestDir('test.dtd'), context)\n                elif url.endswith(\"test_xinclude.xml\"):\n                    self.called[\"input\"] = True\n                    return None # delegate to default resolver\n                else:\n                    self.called[\"include\"] = True\n                    return self.resolve_string(self.include_text, context)\n\n        res_instance = res()\n        parser = etree.XMLParser(load_dtd = True)\n        parser.resolvers.add(res_instance)\n\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           parser = parser)\n\n        self.include(tree)\n\n        called = list(res_instance.called.items())\n        called.sort()\n        self.assertEqual(\n            [(\"dtd\", True), (\"include\", True), (\"input\", True)],\n            called)\n\n    def test_xinclude_resolver_recursive(self):\n        data = textwrap.dedent('''\n        <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n        <foo/>\n        <xi:include href=\"./test.xml\" />\n        </doc>\n        ''')\n\n        class Resolver(etree.Resolver):\n            called = {}\n\n            def resolve(self, url, id, context):\n                if url.endswith(\"test_xinclude.xml\"):\n                    assert not self.called.get(\"input\")\n                    self.called[\"input\"] = True\n                    return None  # delegate to default resolver\n                elif url.endswith('/test5.xml'):\n                    assert not self.called.get(\"DONE\")\n                    self.called[\"DONE\"] = True\n                    return self.resolve_string('<DONE/>', context)\n                else:\n                    _, filename = url.rsplit('/', 1)\n                    assert not self.called.get(filename)\n                    self.called[filename] = True\n                    next_data = data.replace(\n                        'test.xml', 'test%d.xml' % len(self.called))\n                    return self.resolve_string(next_data, context)\n\n        res_instance = Resolver()\n        parser = etree.XMLParser(load_dtd=True)\n        parser.resolvers.add(res_instance)\n\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           parser=parser)\n\n        self.include(tree)\n\n        called = list(res_instance.called.items())\n        called.sort()\n        self.assertEqual(\n            [(\"DONE\", True), (\"input\", True), (\"test.xml\", True),\n             (\"test2.xml\", True), (\"test3.xml\", True), (\"test4.xml\", True)],\n            called)\n\n\nclass ETreeXIncludeTestCase(_XIncludeTestCase):\n    def include(self, tree):\n        tree.xinclude()\n\n\nclass ElementIncludeTestCase(_XIncludeTestCase):\n    from lxml import ElementInclude\n\n    def include(self, tree, loader=None, max_depth=None):\n        self.ElementInclude.include(tree.getroot(), loader=loader, max_depth=max_depth)\n\n    XINCLUDE = {}\n\n    XINCLUDE[\"Recursive1.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive2.xml:</p>\n      <xi:include href=\"Recursive2.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Recursive2.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive3.xml:</p>\n      <xi:include href=\"Recursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Recursive3.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive1.xml:</p>\n      <xi:include href=\"Recursive1.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive1.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <p>The following is multiple times the source code of Leaf.xml:</p>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n      <p>One more time the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive2.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <xi:include href=\"NonRecursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive3.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of Leaf.xml:</p>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Leaf.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>No further includes</p>\n    </document>\n    \"\"\"\n\n    def xinclude_loader(self, href, parse=\"xml\", encoding=None):\n        try:\n            data = textwrap.dedent(self.XINCLUDE[href])\n        except KeyError:\n            raise OSError(\"resource not found\")\n        if parse == \"xml\":\n            data = etree.fromstring(data)\n        return data\n\n    def test_xinclude_failures(self):\n        # Test infinitely recursive includes.\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n        # Test 'max_depth' limitation.\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=None)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=0)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive2.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=1)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive3.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=2)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive1.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=3)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n    def test_multiple_include_of_same_file(self):\n        # Test that including the same file multiple times, but on the same level\n        # is not detected as recursive include\n        document = self.xinclude_loader(\"NonRecursive3.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n        # same but for more than one level\n        document = self.xinclude_loader(\"NonRecursive1.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n        # same but no Leaf.xml in top-level file\n        document = self.xinclude_loader(\"NonRecursive2.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n\nclass ETreeC14NTestCase(HelperTestCase):\n    def test_c14n(self):\n        tree = self.parse(b'<a><b/></a>')\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n_gzip(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        f = BytesIO()\n        tree.write_c14n(f, compression=9)\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(b'<a>'+b'<b></b>'*200+b'</a>',\n                          s)\n\n    def test_c14n_file(self):\n        tree = self.parse(b'<a><b/></a>')\n        with tmpfile() as filename:\n            tree.write_c14n(filename)\n            data = read_file(filename, 'rb')\n        self.assertEqual(b'<a><b></b></a>',\n                          data)\n    \n    def test_c14n_file_pathlike(self):\n        tree = self.parse(b'<a><b/></a>')\n        with tmpfile() as filename:\n            tree.write_c14n(SimpleFSPath(filename))\n            data = read_file(filename, 'rb')\n        self.assertEqual(b'<a><b></b></a>',\n                        data)\n\n    def test_c14n_file_gzip(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write_c14n(filename, compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(b'<a>'+b'<b></b>'*200+b'</a>',\n                          data)\n    \n    def test_c14n_file_gzip_pathlike(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write_c14n(SimpleFSPath(filename), compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(b'<a>'+b'<b></b>'*200+b'</a>',\n                        data)\n\n    def test_c14n2_file_gzip(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write(filename, method='c14n2', compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(b'<a>'+b'<b></b>'*200+b'</a>',\n                          data)\n\n    def test_c14n2_with_text(self):\n        tree = self.parse(\n            b'<?xml version=\"1.0\"?>    <a> abc \\n <b>  btext </b> btail <c/>    ctail </a>     ')\n        f = BytesIO()\n        tree.write(f, method='c14n2')\n        s = f.getvalue()\n        self.assertEqual(b'<a> abc \\n <b>  btext </b> btail <c></c>    ctail </a>',\n                         s)\n\n        f = BytesIO()\n        tree.write(f, method='c14n2', strip_text=True)\n        s = f.getvalue()\n        self.assertEqual(b'<a>abc<b>btext</b>btail<c></c>ctail</a>',\n                         s)\n\n    def test_c14n_with_comments(self):\n        tree = self.parse(b'<!--hi--><a><!--ho--><b/></a><!--hu-->')\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, with_comments=True)\n        s = f.getvalue()\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, with_comments=False)\n        s = f.getvalue()\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n2_with_comments(self):\n        tree = self.parse(b'<!--hi--> <a> <!-- ho --> <b/> </a> <!-- hu -->')\n        self.assertEqual(\n            b'<!--hi-->\\n<a> <!-- ho --> <b></b> </a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2'))\n\n        self.assertEqual(\n            b'<!--hi-->\\n<a> <!-- ho --> <b></b> </a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2', with_comments=True))\n\n        self.assertEqual(\n            b'<a>  <b></b> </a>',\n            etree.tostring(tree, method='c14n2', with_comments=False))\n\n    def test_c14n2_with_comments_strip_text(self):\n        tree = self.parse(b'<!--hi--> <a> <!-- ho --> <b/> </a> <!-- hu -->')\n        self.assertEqual(\n            b'<!--hi-->\\n<a><!-- ho --><b></b></a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2', with_comments=True, strip_text=True))\n        self.assertEqual(\n            b'<a><b></b></a>',\n            etree.tostring(tree, method='c14n2', with_comments=False, strip_text=True))\n\n    def test_c14n_tostring_with_comments(self):\n        tree = self.parse(b'<!--hi--><a><!--ho--><b/></a><!--hu-->')\n        s = etree.tostring(tree, method='c14n')\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n', with_comments=True)\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n', with_comments=False)\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n2_tostring_with_comments(self):\n        tree = self.parse(b'<!--hi--><a><!--ho--><b/></a><!--hu-->')\n        s = etree.tostring(tree, method='c14n2')\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n2', with_comments=True)\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n2', with_comments=False)\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n_element_tostring_with_comments(self):\n        tree = self.parse(b'<!--hi--><a><!--ho--><b/></a><!--hu-->')\n        s = etree.tostring(tree.getroot(), method='c14n')\n        self.assertEqual(b'<a><!--ho--><b></b></a>',\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', with_comments=True)\n        self.assertEqual(b'<a><!--ho--><b></b></a>',\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', with_comments=False)\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=False)\n        s = f.getvalue()\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=True)\n        s = f.getvalue()\n        self.assertEqual(b'<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>',\n                          s)\n\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=True, inclusive_ns_prefixes=['z'])\n        s = f.getvalue()\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n\n    def test_c14n_tostring_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        s = etree.tostring(tree, method='c14n')\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n        s = etree.tostring(tree, method='c14n', exclusive=False)\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n        s = etree.tostring(tree, method='c14n', exclusive=True)\n        self.assertEqual(b'<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>',\n                          s)\n\n        s = etree.tostring(tree, method='c14n', exclusive=True, inclusive_ns_prefixes=['y'])\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\"><z:b xmlns:z=\"http://cde\"></z:b></a>',\n                          s)\n\n    def test_c14n_element_tostring_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        s = etree.tostring(tree.getroot(), method='c14n')\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', exclusive=False)\n        self.assertEqual(b'<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', exclusive=True)\n        self.assertEqual(b'<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>',\n                          s)\n\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=False)\n        self.assertEqual(b'<z:b xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"></z:b>',\n                          s)\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=True)\n        self.assertEqual(b'<z:b xmlns:z=\"http://cde\"></z:b>',\n                          s)\n\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=True, inclusive_ns_prefixes=['y'])\n        self.assertEqual(b'<z:b xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"></z:b>',\n                          s)\n\n    def test_c14n_tostring_inclusive_ns_prefixes(self):\n        \"\"\" Regression test to fix memory allocation issues (use 3+ inclusive NS spaces)\"\"\"\n        tree = self.parse(_bytes(\n                '<a xmlns:x=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n\n        s = etree.tostring(tree, method='c14n', exclusive=True, inclusive_ns_prefixes=['x', 'y', 'z'])\n        self.assertEqual(b'<a xmlns:x=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>',\n                          s)\n    \n    def test_python3_problem_bytesio_iterparse(self):\n        content = BytesIO(b'''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>''')\n        def handle_div_end(event, element):\n            if event == 'end' and element.tag.lower().startswith(\"{http://www.w3.org/1999/xhtml}div\"):\n                # for ns_id, ns_uri in element.nsmap.items():\n                #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n                etree.tostring(element, method=\"c14n2\")\n        for event, element in etree.iterparse(\n            source=content,\n            events=('start', 'end')\n        ):\n            handle_div_end(event, element)\n    \n    def test_python3_problem_filebased_iterparse(self):\n        with open('test.xml', 'w+b') as f:\n            f.write(b'''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>''')\n        def handle_div_end(event, element):\n            if event == 'end' and element.tag.lower() == \"{http://www.w3.org/1999/xhtml}div\":\n                # for ns_id, ns_uri in element.nsmap.items():\n                #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n                etree.tostring(element, method=\"c14n2\")\n        for event, element in etree.iterparse(\n            source='test.xml',\n            events=('start', 'end')\n        ):\n            handle_div_end(event, element)\n    \n    def test_python3_problem_filebased_parse(self):\n        with open('test.xml', 'w+b') as f:\n            f.write(b'''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>''')\n        def serialize_div_element(element):        \n            # for ns_id, ns_uri in element.nsmap.items():\n            #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n            etree.tostring(element, method=\"c14n2\")\n        tree = etree.parse(source='test.xml')\n        root = tree.getroot()\n        div = root.xpath('//xhtml:div', namespaces={'xhtml':'http://www.w3.org/1999/xhtml'})[0]\n        serialize_div_element(div)\n\n\nclass ETreeWriteTestCase(HelperTestCase):\n    def test_write(self):\n        tree = self.parse(b'<a><b/></a>')\n        f = BytesIO()\n        tree.write(f)\n        s = f.getvalue()\n        self.assertEqual(b'<a><b/></a>',\n                          s)\n\n    def test_write_doctype(self):\n        tree = self.parse(b'<a><b/></a>')\n        f = BytesIO()\n        tree.write(f, doctype='HUHU')\n        s = f.getvalue()\n        self.assertEqual(b'HUHU\\n<a><b/></a>',\n                         s)\n\n    def test_write_gzip(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        f = BytesIO()\n        tree.write(f, compression=9)\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                         s)\n\n    def test_write_gzip_doctype(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        f = BytesIO()\n        tree.write(f, compression=9, doctype='<!DOCTYPE a>')\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(b'<!DOCTYPE a>\\n<a>'+b'<b/>'*200+b'</a>',\n                         s)\n\n    def test_write_gzip_level(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        f = BytesIO()\n        tree.write(f, compression=0)\n        s0 = f.getvalue()\n\n        f = BytesIO()\n        tree.write(f)\n        self.assertEqual(f.getvalue(), s0)\n\n        f = BytesIO()\n        tree.write(f, compression=1)\n        s = f.getvalue()\n        self.assertTrue(len(s) <= len(s0))\n        with gzip.GzipFile(fileobj=BytesIO(s)) as gzfile:\n            s1 = gzfile.read()\n\n        f = BytesIO()\n        tree.write(f, compression=9)\n        s = f.getvalue()\n        self.assertTrue(len(s) <= len(s0))\n        with gzip.GzipFile(fileobj=BytesIO(s)) as gzfile:\n            s9 = gzfile.read()\n\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                          s0)\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                          s1)\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                          s9)\n\n    def test_write_file(self):\n        tree = self.parse(b'<a><b/></a>')\n        with tmpfile() as filename:\n            tree.write(filename)\n            data = read_file(filename, 'rb')\n        self.assertEqual(b'<a><b/></a>',\n                          data)\n    \n    def test_write_file_pathlike(self):\n        tree = self.parse(b'<a><b/></a>')\n        with tmpfile() as filename:\n            tree.write(SimpleFSPath(filename))\n            data = read_file(filename, 'rb')\n        self.assertEqual(b'<a><b/></a>',\n                        data)\n\n    def test_write_file_gzip(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                          data)\n\n    def test_write_file_gzip_pathlike(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write(SimpleFSPath(filename), compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                        data)\n\n    def test_write_file_gzip_parse(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            data = etree.tostring(etree.parse(filename))\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                          data)\n\n    def test_write_file_gzipfile_parse(self):\n        tree = self.parse(b'<a>'+b'<b/>'*200+b'</a>')\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            with gzip.GzipFile(filename) as f:\n                data = etree.tostring(etree.parse(f))\n        self.assertEqual(b'<a>'+b'<b/>'*200+b'</a>',\n                          data)\n\n    def test_write_file_url(self):\n        xml = b'<a>'+b'<b/>'*200+b'</a>'\n        tree = self.parse(xml)\n        with tmpfile(prefix=\"p+%20\", suffix=\".xml\") as filename:\n            url = 'file://' + (filename if sys.platform != 'win32'\n                               else '/' + filename.replace('\\\\', '/'))\n            tree.write(url)\n            data = read_file(filename, 'rb').replace(b'\\n', b'')\n        self.assertEqual(data, xml)\n\n\nclass ETreeErrorLogTest(HelperTestCase):\n    etree = etree\n\n    def test_parse_error_logging(self):\n        parse = self.etree.parse\n        f = BytesIO(b'<a><b></c></b></a>')\n        self.etree.clear_error_log()\n        try:\n            parse(f)\n            logs = None\n        except SyntaxError:\n            e = sys.exc_info()[1]\n            logs = e.error_log\n        f.close()\n        self.assertTrue([ log for log in logs\n                       if 'mismatch' in log.message ])\n        self.assertTrue([ log for log in logs\n                       if 'PARSER'   in log.domain_name])\n        self.assertTrue([ log for log in logs\n                       if 'ERR_TAG_NAME_MISMATCH' in log.type_name ])\n        self.assertTrue([ log for log in logs\n                       if 1 == log.line ])\n        self.assertTrue([ log for log in logs\n                       if 15 == log.column ])\n\n    def _test_python_error_logging(self):\n        \"\"\"This can't really be tested as long as there isn't a way to\n        reset the logging setup ...\n        \"\"\"\n        parse = self.etree.parse\n\n        messages = []\n        class Logger(self.etree.PyErrorLog):\n            def log(self, entry, message, *args):\n                messages.append(message)\n\n        self.etree.use_global_python_log(Logger())\n        f = BytesIO(b'<a><b></c></b></a>')\n        try:\n            parse(f)\n        except SyntaxError:\n            pass\n        f.close()\n\n        self.assertTrue([ message for message in messages\n                       if 'mismatch' in message ])\n        self.assertTrue([ message for message in messages\n                       if ':PARSER:'   in message])\n        self.assertTrue([ message for message in messages\n                       if ':ERR_TAG_NAME_MISMATCH:' in message ])\n        self.assertTrue([ message for message in messages\n                       if ':1:15:' in message ])\n\n\nclass XMLPullParserTest(unittest.TestCase):\n    etree = etree\n\n    def assert_event_tags(self, events, expected):\n        self.assertEqual([(action, elem.tag) for action, elem in events],\n                         expected)\n\n    def test_pull_from_simple_target(self):\n        class Target:\n            def start(self, tag, attrib):\n                return 'start(%s)' % tag\n            def end(self, tag):\n                return 'end(%s)' % tag\n            def close(self):\n                return 'close()'\n\n        parser = self.etree.XMLPullParser(target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assertFalse(list(events))\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assertEqual([('end', 'end(element)')], list(events))\n        parser.feed('</child>')\n        self.assertEqual([('end', 'end(child)')], list(events))\n        parser.feed('</root>')\n        self.assertEqual([('end', 'end(root)')], list(events))\n        self.assertFalse(list(events))\n        self.assertEqual('close()', parser.close())\n\n    def test_pull_from_simple_target_start_end(self):\n        class Target:\n            def start(self, tag, attrib):\n                return 'start(%s)' % tag\n            def end(self, tag):\n                return 'end(%s)' % tag\n            def close(self):\n                return 'close()'\n\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assertEqual(\n            [('start', 'start(root)'), ('start', 'start(element)')],\n            list(events))\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assertEqual(\n            [('end', 'end(element)'), ('start', 'start(child)')],\n            list(events))\n        parser.feed('</child>')\n        self.assertEqual(\n            [('end', 'end(child)')],\n            list(events))\n        parser.feed('</root>')\n        self.assertEqual(\n            [('end', 'end(root)')],\n            list(events))\n        self.assertFalse(list(events))\n        self.assertEqual('close()', parser.close())\n\n    def test_pull_from_tree_builder(self):\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=etree.TreeBuilder())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assert_event_tags(\n            events, [('start', 'root'), ('start', 'element')])\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assert_event_tags(\n            events, [('end', 'element'), ('start', 'child')])\n        parser.feed('</child>')\n        self.assert_event_tags(\n            events, [('end', 'child')])\n        parser.feed('</root>')\n        self.assert_event_tags(\n            events, [('end', 'root')])\n        self.assertFalse(list(events))\n        root = parser.close()\n        self.assertEqual('root', root.tag)\n\n    def test_pull_from_tree_builder_subclass(self):\n        class Target(etree.TreeBuilder):\n            def end(self, tag):\n                el = super().end(tag)\n                el.tag += '-huhu'\n                return el\n\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assert_event_tags(\n            events, [('start', 'root'), ('start', 'element')])\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assert_event_tags(\n            events, [('end', 'element-huhu'), ('start', 'child')])\n        parser.feed('</child>')\n        self.assert_event_tags(\n            events, [('end', 'child-huhu')])\n        parser.feed('</root>')\n        self.assert_event_tags(\n            events, [('end', 'root-huhu')])\n        self.assertFalse(list(events))\n        root = parser.close()\n        self.assertEqual('root-huhu', root.tag)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeOnlyTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXIncludeTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementIncludeTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeC14NTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeWriteTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeErrorLogTest)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(XMLPullParserTest)])\n\n    # add original doctests from ElementTree selftest modules\n    from . import selftest, selftest2\n    suite.addTests(doctest.DocTestSuite(selftest))\n    suite.addTests(doctest.DocTestSuite(selftest2))\n\n    # add doctests\n    suite.addTests(doctest.DocTestSuite(etree))\n    suite.addTests(\n        [make_doctest('tutorial.txt')])\n    suite.addTests(\n        [make_doctest('api.txt')])\n    suite.addTests(\n        [make_doctest('FAQ.txt')])\n    suite.addTests(\n        [make_doctest('parsing.txt')])\n    suite.addTests(\n        [make_doctest('resolvers.txt')])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_builder.py": "\"\"\"\nTests that ElementMaker works properly.\n\"\"\"\n\n\nimport unittest\n\nfrom lxml import etree\nfrom lxml.builder import E, ElementMaker\nfrom lxml.html.builder import E as HE\n\nfrom .common_imports import HelperTestCase, _bytes\n\n\nclass BuilderTestCase(HelperTestCase):\n    etree = etree\n\n    def test_build_from_xpath_result(self):\n        class StringSubclass(str): pass\n        wrapped = E.b(StringSubclass('Hello'))\n        self.assertEqual(b'<b>Hello</b>', etree.tostring(wrapped))\n\n    def test_unknown_type_raises(self):\n        class UnknownType:\n            pass\n        self.assertRaises(TypeError, E.b, UnknownType())\n\n    def test_cdata(self):\n        wrapped = E.b(etree.CDATA('Hello'))\n        self.assertEqual(b'<b><![CDATA[Hello]]></b>', etree.tostring(wrapped))\n\n    def test_cdata_solo(self):\n        self.assertRaises(ValueError, E.b, 'Hello', etree.CDATA('World'))\n\n    def test_html_builder(self):\n        html = HE.html(\n            HE.head(HE.title(\"H-T-M-L!\")),\n            HE.body(HE.p(\"TexT\"))\n        )\n        self.assertEqual(\"TexT\", html.findtext(\".//p\"))\n\n    def test_qname_tag(self):\n        p = E(etree.QName(\"http://lxml.de/nsp\", \"p\"), \"xyz\")\n        self.assertEqual(p.tag, \"{http://lxml.de/nsp}p\")\n\n    def test_qname_tag_default_namespace(self):\n        em = ElementMaker(namespace=\"http://python.org\")\n\n        p = em(etree.QName(\"http://lxml.de/nsp\", \"p\"), \"xyz\")\n        self.assertEqual(p.tag, \"{http://lxml.de/nsp}p\")\n\n        p = em(\"{http://lxml.de/nsp}p\", \"xyz\")\n        self.assertEqual(p.tag, \"{http://lxml.de/nsp}p\")\n\n        # safety check\n        p = em(\"p\", \"xyz\")\n        self.assertEqual(p.tag, \"{http://python.org}p\")\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(BuilderTestCase)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_classlookup.py": "\"\"\"\nTests for different Element class lookup mechanisms.\n\"\"\"\n\n\n\nimport unittest, gc\n\nfrom .common_imports import etree, HelperTestCase, _bytes, BytesIO\n\nxml_str = b'''\\\n<root xmlns=\"myNS\" xmlns:other=\"otherNS\">\n  <c1 a1=\"A1\" a2=\"A2\" other:a3=\"A3\">\n    <c2 a1=\"C2\">0</c2>\n    <c2>1</c2>\n    <other:c2>2</other:c2>\n  </c1>\n</root>'''\n\n\nclass ProxyTestCase(HelperTestCase):\n    \"\"\"Basic tests for element proxy behaviour.\n    \"\"\"\n    etree = etree\n\n    def test_proxy_reuse(self):\n        root = etree.XML('<a><b><c/></b></a>')\n        b = root.find('b')\n        self.assertTrue(b is root[0])\n\n    def test_proxy_reuse_after_gc(self):\n        root = etree.XML('<a><b><c/></b></a>')\n        b = root.find('b')\n        self.assertTrue(self.etree.iselement(b))\n        gc.collect()\n        self.assertTrue(b is root[0])\n\n    def test_proxy_reuse_after_del_root(self):\n        root = etree.XML('<a><b><c/></b></a>')\n        b = root.find('b')\n        self.assertTrue(self.etree.iselement(b))\n        c = b.find('c')\n        self.assertTrue(self.etree.iselement(c))\n        del root\n        gc.collect()\n        self.assertTrue(b[0] is c)\n\n    def test_proxy_hashing(self):\n        root = etree.XML('<a><b><c/></b></a>')\n        old_elements = set(root.iter())\n        elements = root.iter()\n        del root\n        gc.collect()\n\n        missing = len(old_elements)\n        self.assertEqual(3, missing)\n        for new in elements:\n            for old in old_elements:\n                if old == new:\n                    self.assertTrue(old is new)\n                    missing -= 1\n                    break\n            else:\n                self.assertTrue(False, \"element '%s' is missing\" % new.tag)\n        self.assertEqual(0, missing)\n\n    def test_element_base(self):\n        el = self.etree.ElementBase()\n        self.assertEqual('ElementBase', el.tag)\n        root = self.etree.ElementBase()\n        root.append(el)\n        self.assertEqual('ElementBase', root[0].tag)\n\n    def test_element_base_children(self):\n        el = self.etree.ElementBase(etree.ElementBase())\n        self.assertEqual('ElementBase', el.tag)\n        self.assertEqual(1, len(el))\n        self.assertEqual('ElementBase', el[0].tag)\n\n        root = self.etree.ElementBase()\n        root.append(el)\n        self.assertEqual('ElementBase', root[0].tag)\n        self.assertEqual('ElementBase', root[0][0].tag)\n\n    def test_comment_base(self):\n        el = self.etree.CommentBase('some text')\n        self.assertEqual(self.etree.Comment, el.tag)\n        self.assertEqual('some text', el.text)\n        root = self.etree.Element('root')\n        root.append(el)\n        self.assertEqual('some text', root[0].text)\n\n    def test_pi_base(self):\n        el = self.etree.PIBase('the target', 'some text')\n        self.assertEqual(self.etree.ProcessingInstruction, el.tag)\n        self.assertEqual('some text', el.text)\n        root = self.etree.Element('root')\n        root.append(el)\n        self.assertEqual('some text', root[0].text)\n\n\nclass ClassLookupTestCase(HelperTestCase):\n    \"\"\"Test cases for different Element class lookup mechanisms.\n    \"\"\"\n    etree = etree\n\n    def tearDown(self):\n        etree.set_element_class_lookup()\n        super().tearDown()\n\n    def test_namespace_lookup(self):\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"namespace class\"\n\n        lookup = etree.ElementNamespaceClassLookup()\n        etree.set_element_class_lookup(lookup)\n\n        ns = lookup.get_namespace(\"myNS\")\n        ns[None] = TestElement\n\n        root = etree.XML(xml_str)\n        self.assertEqual(root.FIND_ME,\n                          TestElement.FIND_ME)\n        self.assertEqual(root[0].FIND_ME,\n                          TestElement.FIND_ME)\n        self.assertFalse(hasattr(root[0][-1], 'FIND_ME'))\n\n    def test_default_class_lookup(self):\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"default element\"\n        class TestComment(etree.CommentBase):\n            FIND_ME = \"default comment\"\n        class TestPI(etree.PIBase):\n            FIND_ME = \"default pi\"\n\n        parser = etree.XMLParser()\n\n        lookup = etree.ElementDefaultClassLookup(\n            element=TestElement, comment=TestComment, pi=TestPI)\n        parser.set_element_class_lookup(lookup)\n\n        root = etree.XML(b\"\"\"<?xml version='1.0'?>\n        <root>\n          <?myPI?>\n          <!-- hi -->\n        </root>\n        \"\"\", parser)\n\n        self.assertEqual(\"default element\", root.FIND_ME)\n        self.assertEqual(\"default pi\", root[0].FIND_ME)\n        self.assertEqual(\"default comment\", root[1].FIND_ME)\n\n    def test_default_class_lookup_pull_parser(self):\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"default element\"\n        class TestComment(etree.CommentBase):\n            FIND_ME = \"default comment\"\n        class TestPI(etree.PIBase):\n            FIND_ME = \"default pi\"\n\n        parser = etree.XMLPullParser(events=('start', 'end', 'comment', 'pi'))\n        lookup = etree.ElementDefaultClassLookup(\n            element=TestElement, comment=TestComment, pi=TestPI)\n        parser.set_element_class_lookup(lookup)\n\n        events_seen = []\n\n        def add_events(events):\n            for ev, el in events:\n                events_seen.append((ev, el.FIND_ME))\n\n        parser.feed(\"\"\"<?xml version='1.0'?>\n        <root>\n          <?myPI?>\n        \"\"\")\n        add_events(parser.read_events())\n\n        parser.feed(\"<!-- hi -->\")\n        add_events(parser.read_events())\n\n        parser.feed(\"</root>\")\n        root = parser.close()\n        add_events(parser.read_events())\n\n        self.assertEqual([\n            ('start',   \"default element\"),\n            ('pi',      \"default pi\"),\n            ('comment', \"default comment\"),\n            ('end',     \"default element\"),\n        ], events_seen)\n\n        self.assertEqual(\"default element\", root.FIND_ME)\n        self.assertEqual(\"default pi\", root[0].FIND_ME)\n        self.assertEqual(\"default comment\", root[1].FIND_ME)\n\n    def test_evil_class_lookup(self):\n        class MyLookup(etree.CustomElementClassLookup):\n            def lookup(self, t, d, ns, name):\n                if name == 'none':\n                    return None\n                elif name == 'obj':\n                    return object()\n                else:\n                    return etree.ElementBase\n\n        parser = etree.XMLParser()\n        parser.set_element_class_lookup(MyLookup())\n\n        root = etree.XML(b'<none/>', parser)\n        self.assertEqual('none', root.tag)\n\n        self.assertRaises(\n            TypeError,\n            etree.XML, b\"<obj />\", parser)\n\n        root = etree.XML(b'<root/>', parser)\n        self.assertEqual('root', root.tag)\n\n    def test_class_lookup_type_mismatch(self):\n        class MyLookup(etree.CustomElementClassLookup):\n            def lookup(self, t, d, ns, name):\n                if t == 'element':\n                    if name == 'root':\n                        return etree.ElementBase\n                    return etree.CommentBase\n                elif t == 'comment':\n                    return etree.PIBase\n                elif t == 'PI':\n                    return etree.EntityBase\n                elif t == 'entity':\n                    return etree.ElementBase\n                else:\n                    raise ValueError('got type %s' % t)\n\n        parser = etree.XMLParser(resolve_entities=False)\n        parser.set_element_class_lookup(MyLookup())\n\n        root = etree.XML(b'<root></root>', parser)\n        self.assertEqual('root', root.tag)\n        self.assertEqual(etree.ElementBase, type(root))\n\n        root = etree.XML(b\"<root><test/></root>\", parser)\n        self.assertRaises(TypeError, root.__getitem__, 0)\n\n        root = etree.XML(b\"<root><!-- test --></root>\", parser)\n        self.assertRaises(TypeError, root.__getitem__, 0)\n\n        root = etree.XML(b\"<root><?test?></root>\", parser)\n        self.assertRaises(TypeError, root.__getitem__, 0)\n\n        root = etree.XML(\n            b'<!DOCTYPE root [<!ENTITY myent \"ent\">]>'\n                   b'<root>&myent;</root>',\n            parser)\n        self.assertRaises(TypeError, root.__getitem__, 0)\n\n        root = etree.XML(b'<root><root/></root>', parser)\n        self.assertEqual('root', root[0].tag)\n\n    def test_attribute_based_lookup(self):\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"attribute_based\"\n\n        class_dict = {\"A1\" : TestElement}\n\n        lookup = etree.AttributeBasedElementClassLookup(\n            \"a1\", class_dict)\n        etree.set_element_class_lookup(lookup)\n\n        root = etree.XML(xml_str)\n        self.assertFalse(hasattr(root, 'FIND_ME'))\n        self.assertEqual(root[0].FIND_ME,\n                          TestElement.FIND_ME)\n        self.assertFalse(hasattr(root[0][0], 'FIND_ME'))\n\n    def test_custom_lookup(self):\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"custom\"\n\n        class MyLookup(etree.CustomElementClassLookup):\n            def lookup(self, t, d, ns, name):\n                if name == 'c1':\n                    return TestElement\n\n        etree.set_element_class_lookup( MyLookup() )\n\n        root = etree.XML(xml_str)\n        self.assertFalse(hasattr(root, 'FIND_ME'))\n        self.assertEqual(root[0].FIND_ME,\n                          TestElement.FIND_ME)\n        self.assertFalse(hasattr(root[0][1], 'FIND_ME'))\n\n    def test_custom_lookup_ns_fallback(self):\n        class TestElement1(etree.ElementBase):\n            FIND_ME = \"custom\"\n\n        class TestElement2(etree.ElementBase):\n            FIND_ME = \"nsclasses\"\n\n        class MyLookup(etree.CustomElementClassLookup):\n            def lookup(self, t, d, ns, name):\n                if name == 'c1':\n                    return TestElement1\n\n        lookup = etree.ElementNamespaceClassLookup( MyLookup() )\n        etree.set_element_class_lookup(lookup)\n\n        ns = lookup.get_namespace(\"otherNS\")\n        ns[None] = TestElement2\n\n        root = etree.XML(xml_str)\n        self.assertFalse(hasattr(root, 'FIND_ME'))\n        self.assertEqual(root[0].FIND_ME,\n                          TestElement1.FIND_ME)\n        self.assertFalse(hasattr(root[0][1], 'FIND_ME'))\n        self.assertEqual(root[0][-1].FIND_ME,\n                          TestElement2.FIND_ME)\n\n    def test_parser_based_lookup(self):\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"parser_based\"\n\n        lookup = etree.ParserBasedElementClassLookup()\n        etree.set_element_class_lookup(lookup)\n\n        class MyLookup(etree.CustomElementClassLookup):\n            def lookup(self, t, d, ns, name):\n                return TestElement\n\n        parser = etree.XMLParser()\n        parser.set_element_class_lookup( MyLookup() )\n\n        root = etree.parse(BytesIO(xml_str), parser).getroot()\n        self.assertEqual(root.FIND_ME,\n                          TestElement.FIND_ME)\n        self.assertEqual(root[0].FIND_ME,\n                          TestElement.FIND_ME)\n\n        root = etree.parse(BytesIO(xml_str)).getroot()\n        self.assertFalse(hasattr(root, 'FIND_ME'))\n        self.assertFalse(hasattr(root[0], 'FIND_ME'))\n\n    def test_class_lookup_reentry(self):\n        XML = self.etree.XML\n\n        class TestElement(etree.ElementBase):\n            FIND_ME = \"here\"\n\n        root = None\n        class MyLookup(etree.CustomElementClassLookup):\n            el = None\n            def lookup(self, t, d, ns, name):\n                if root is not None: # not in the parser\n                    if self.el is None and name == \"a\":\n                        self.el = []\n                        self.el.append(root.find(name))\n                return TestElement\n\n        parser = self.etree.XMLParser()\n        parser.set_element_class_lookup(MyLookup())\n\n        root = XML(b'<root><a>A</a><b xmlns=\"test\">B</b></root>',\n                   parser)\n\n        a = root[0]\n        self.assertEqual(a.tag, \"a\")\n        self.assertEqual(root[0].tag, \"a\")\n        del a\n        self.assertEqual(root[0].tag, \"a\")\n\n    def test_lookup_without_fallback(self):\n        class Lookup(etree.CustomElementClassLookup):\n             def __init__(self):\n                 # no super call here, so no fallback is set\n                 pass\n\n             def lookup(self, node_type, document, namespace, name):\n                 return Foo\n\n        class Foo(etree.ElementBase):\n             def custom(self):\n                 return \"test\"\n\n        parser = self.etree.XMLParser()\n        parser.set_element_class_lookup( Lookup() )\n\n        root = etree.XML('<foo/>', parser)\n\n        self.assertEqual(\"test\", root.custom())\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ProxyTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ClassLookupTestCase)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_io.py": "\"\"\"\nIO test cases that apply to both etree and ElementTree\n\"\"\"\n\n\nimport unittest\nimport tempfile, gzip, os, os.path, gc, shutil\n\nfrom .common_imports import (\n    etree, ElementTree, _str, _bytes,\n    SillyFileLike, LargeFileLike, HelperTestCase,\n    read_file, write_to_file, BytesIO, tmpfile\n)\n\n\nclass _IOTestCaseBase(HelperTestCase):\n    \"\"\"(c)ElementTree compatibility for IO functions/methods\n    \"\"\"\n    etree = None\n    \n    def setUp(self):\n        \"\"\"Setting up a minimal tree\n        \"\"\"\n        self.root = self.etree.Element('a')\n        self.root_str = self.etree.tostring(self.root)\n        self.tree = self.etree.ElementTree(self.root)\n        self._temp_dir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        gc.collect()\n        shutil.rmtree(self._temp_dir)\n\n    def getTestFilePath(self, name):\n        return os.path.join(self._temp_dir, name)\n\n    def buildNodes(self, element, children, depth):\n        Element = self.etree.Element\n\n        if depth == 0:\n            return\n        for i in range(children):\n            new_element = Element('element_%s_%s' % (depth, i))\n            self.buildNodes(new_element, children, depth - 1)\n            element.append(new_element)\n\n    def test_tree_io(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        element = Element('top')\n        element.text = _str(\"qwrtio\u00fc\u00f6\u00e4\\uAABB\")\n        tree = ElementTree(element)\n        self.buildNodes(element, 10, 3)\n        with open(self.getTestFilePath('testdump.xml'), 'wb') as f:\n            tree.write(f, encoding='UTF-8')\n        with open(self.getTestFilePath('testdump.xml'), 'rb') as f:\n            tree = ElementTree(file=f)\n        with open(self.getTestFilePath('testdump2.xml'), 'wb') as f:\n            tree.write(f, encoding='UTF-8')\n        with open(self.getTestFilePath('testdump.xml'), 'rb') as f:\n            data1 = f.read()\n        with open(self.getTestFilePath('testdump2.xml'), 'rb') as f:\n            data2 = f.read()\n        self.assertEqual(data1, data2)\n\n    def test_tree_io_latin1(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        element = Element('top')\n        element.text = _str(\"qwrtio\u00fc\u00f6\u00e4\u00df\u00c3\u00a1\")\n        tree = ElementTree(element)\n        self.buildNodes(element, 10, 3)\n        with open(self.getTestFilePath('testdump.xml'), 'wb') as f:\n            tree.write(f, encoding='iso-8859-1')\n        with open(self.getTestFilePath('testdump.xml'), 'rb') as f:\n            tree = ElementTree(file=f)\n        with open(self.getTestFilePath('testdump2.xml'), 'wb') as f:\n            tree.write(f, encoding='iso-8859-1')\n        with open(self.getTestFilePath('testdump.xml'), 'rb') as f:\n            data1 = f.read()\n        with open(self.getTestFilePath('testdump2.xml'), 'rb') as f:\n            data2 = f.read()\n        self.assertEqual(data1, data2)\n\n    def test_write_filename(self):\n        # (c)ElementTree  supports filename strings as write argument\n        with tmpfile(prefix=\"p\", suffix=\".xml\") as filename:\n            self.tree.write(filename)\n            self.assertEqual(read_file(filename, 'rb').replace(b'\\n', b''),\n                             self.root_str)\n\n    def test_write_filename_special_percent(self):\n        # '%20' is a URL escaped space character.\n        before_test = os.listdir(tempfile.gettempdir())\n\n        def difference(filenames):\n            return sorted(\n                fn for fn in set(filenames).difference(before_test)\n                if fn.startswith('lxmltmp-')\n            )\n\n        with tmpfile(prefix=\"lxmltmp-p%20p\", suffix=\".xml\") as filename:\n            try:\n                before_write = os.listdir(tempfile.gettempdir())\n                self.tree.write(filename)\n                after_write = os.listdir(tempfile.gettempdir())\n                self.assertEqual(read_file(filename, 'rb').replace(b'\\n', b''),\n                                 self.root_str)\n            except (AssertionError, OSError):\n                print(\"Before write: %s, after write: %s\" % (\n                    difference(before_write), difference(after_write))\n                )\n                raise\n\n    def test_write_filename_special_plus(self):\n        # '+' is used as an escaped space character in URLs.\n        with tmpfile(prefix=\"p+\", suffix=\".xml\") as filename:\n            self.tree.write(filename)\n            self.assertEqual(read_file(filename, 'rb').replace(b'\\n', b''),\n                             self.root_str)\n\n    def test_write_invalid_filename(self):\n        filename = os.path.join(\n            os.path.join('hopefullynonexistingpathname'),\n            'invalid_file.xml')\n        try:\n            self.tree.write(filename)\n        except OSError:\n            pass\n        else:\n            self.assertTrue(\n                False, \"writing to an invalid file path should fail\")\n\n    def test_module_parse_gzipobject(self):\n        # (c)ElementTree supports gzip instance as parse argument\n        with tmpfile(suffix=\".xml.gz\") as filename:\n            with gzip.open(filename, 'wb') as f:\n                f.write(self.root_str)\n            with gzip.open(filename, 'rb') as f_gz:\n                tree = self.etree.parse(f_gz)\n            self.assertEqual(self.etree.tostring(tree.getroot()), self.root_str)\n\n    def test_class_parse_filename(self):\n        # (c)ElementTree class ElementTree has a 'parse' method that returns\n        # the root of the tree\n\n        # parse from filename\n        with tmpfile(suffix=\".xml\") as filename:\n            write_to_file(filename, self.root_str, 'wb')\n            tree = self.etree.ElementTree()\n            root = tree.parse(filename)\n            self.assertEqual(self.etree.tostring(root), self.root_str)\n\n    def test_class_parse_filename_remove_previous(self):\n        with tmpfile(suffix=\".xml\") as filename:\n            write_to_file(filename, self.root_str, 'wb')\n            tree = self.etree.ElementTree()\n            root = tree.parse(filename)\n            # and now do it again; previous content should still be there\n            root2 = tree.parse(filename)\n            self.assertEqual('a', root.tag)\n            self.assertEqual('a', root2.tag)\n            # now remove all references to root2, and parse again\n            del root2\n            root3 = tree.parse(filename)\n            self.assertEqual('a', root.tag)\n            self.assertEqual('a', root3.tag)\n            # root2's memory should've been freed here\n            # XXX how to check?\n\n    def test_class_parse_fileobject(self):\n        # (c)ElementTree class ElementTree has a 'parse' method that returns\n        # the root of the tree\n\n        # parse from file object\n        handle, filename = tempfile.mkstemp(suffix=\".xml\")\n        try:\n            os.write(handle, self.root_str)\n            with open(filename, 'rb') as f:\n                tree = self.etree.ElementTree()\n                root = tree.parse(f)\n            self.assertEqual(self.etree.tostring(root), self.root_str)\n        finally:\n            os.close(handle)\n            os.remove(filename)\n\n    def test_class_parse_unamed_fileobject(self):\n        # (c)ElementTree class ElementTree has a 'parse' method that returns\n        # the root of the tree\n\n        # parse from unnamed file object\n        f = SillyFileLike()\n        root = self.etree.ElementTree().parse(f)\n        self.assertTrue(root.tag.endswith('foo'))\n\n    def test_module_parse_large_fileobject(self):\n        # parse from unnamed file object\n        f = LargeFileLike()\n        tree = self.etree.parse(f)\n        root = tree.getroot()\n        self.assertTrue(root.tag.endswith('root'))\n\n    def test_module_parse_fileobject_error(self):\n        class LocalError(Exception):\n            pass\n        class TestFile:\n            def read(*args):\n                raise LocalError\n        f = TestFile()\n        self.assertRaises(LocalError, self.etree.parse, f)\n\n    def test_module_parse_fileobject_late_error(self):\n        class LocalError(Exception):\n            pass\n        class TestFile:\n            data = '<root>test</'\n            try:\n                next_char = iter(data).next\n            except AttributeError:\n                # Python 3\n                next_char = iter(data).__next__\n            counter = 0\n            def read(self, amount=None):\n                if amount is None:\n                    while True:\n                        self.read(1)\n                else:\n                    try:\n                        self.counter += 1\n                        return _bytes(self.next_char())\n                    except StopIteration:\n                        raise LocalError\n        f = TestFile()\n        self.assertRaises(LocalError, self.etree.parse, f)\n        self.assertEqual(f.counter, len(f.data)+1)\n\n    def test_module_parse_fileobject_type_error(self):\n        class TestFile:\n            def read(*args):\n                return 1\n        f = TestFile()\n\n        try:\n            expect_exc = (TypeError, self.etree.ParseError)\n        except AttributeError:\n            expect_exc = TypeError\n        self.assertRaises(expect_exc, self.etree.parse, f)\n\n    def test_etree_parse_io_error(self):\n        # this is a directory name that contains characters beyond latin-1\n        dirnameEN = 'Directory'\n        dirnameRU = '\u00d0\u0161\u00d0\u00b0\u00d1\u201a\u00d0\u00b0\u00d0\u00bb\u00d0\u00be\u00d0\u00b3'\n        filename = 'nosuchfile.xml'\n        dn = tempfile.mkdtemp(prefix=dirnameEN)\n        try:\n            self.assertRaises(IOError, self.etree.parse, os.path.join(dn, filename))\n        finally:\n            os.rmdir(dn)\n        try:\n            dn = tempfile.mkdtemp(prefix=dirnameRU)\n        except (OSError, UnicodeEncodeError, UnicodeDecodeError):\n            # Creating the directory might fail on some platforms depending on encodings.\n            raise unittest.SkipTest(\"file system cannot create slavic file names\")\n        try:\n            self.assertRaises(IOError, self.etree.parse, os.path.join(dn, filename))\n        finally:\n            os.rmdir(dn)\n\n    def test_parse_utf8_bom(self):\n        utext = 'S\u00f8k p\u00e5 nettet'\n        uxml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><p>%s</p>' % utext\n        bom = b'\\\\xEF\\\\xBB\\\\xBF'.decode(\n            \"unicode_escape\").encode(\"latin1\")\n        self.assertEqual(3, len(bom))\n        f = tempfile.NamedTemporaryFile(delete=False)\n        try:\n            try:\n                f.write(bom)\n                f.write(uxml.encode(\"utf-8\"))\n            finally:\n                f.close()\n            tree = self.etree.parse(f.name)\n        finally:\n            os.unlink(f.name)\n        self.assertEqual(utext, tree.getroot().text)\n\n    def test_iterparse_utf8_bom(self):\n        utext = 'S\u00f8k p\u00e5 nettet'\n        uxml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><p>%s</p>' % utext\n        bom = b'\\\\xEF\\\\xBB\\\\xBF'.decode(\n            \"unicode_escape\").encode(\"latin1\")\n        self.assertEqual(3, len(bom))\n        f = tempfile.NamedTemporaryFile(delete=False)\n        try:\n            try:\n                f.write(bom)\n                f.write(uxml.encode(\"utf-8\"))\n            finally:\n                f.close()\n            elements = [el for _, el in self.etree.iterparse(f.name)]\n            self.assertEqual(1, len(elements))\n            root = elements[0]\n        finally:\n            os.unlink(f.name)\n        self.assertEqual(utext, root.text)\n\n    def test_iterparse_utf16_bom(self):\n        utext = 'S\u00f8k p\u00e5 nettet'\n        uxml = '<?xml version=\"1.0\" encoding=\"UTF-16\"?><p>%s</p>' % utext\n        boms = b'\\\\xFE\\\\xFF \\\\xFF\\\\xFE'.decode(\n            \"unicode_escape\").encode(\"latin1\")\n        self.assertEqual(5, len(boms))\n        xml = uxml.encode(\"utf-16\")\n        self.assertTrue(xml[:2] in boms, repr(xml[:2]))\n\n        f = tempfile.NamedTemporaryFile(delete=False)\n        try:\n            try:\n                f.write(xml)\n            finally:\n                f.close()\n            elements = [el for _, el in self.etree.iterparse(f.name)]\n            self.assertEqual(1, len(elements))\n            root = elements[0]\n        finally:\n            os.unlink(f.name)\n        self.assertEqual(utext, root.text)\n\n\nclass ETreeIOTestCase(_IOTestCaseBase):\n    etree = etree\n\n    def test_write_compressed_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n        text = _str(\"qwrtio\u00fc\u00f6\u00e4\")\n\n        root = Element('root')\n        root.text = text\n        child = SubElement(root, 'sub')\n        child.text = 'TEXT'\n        child.tail = 'TAIL'\n        SubElement(root, 'sub').text = text\n\n        tree = ElementTree(root)\n        out = BytesIO()\n        tree.write(out, method='text', encoding='utf8', compression=9)\n        out.seek(0)\n\n        f = gzip.GzipFile(fileobj=out)\n        try:\n            result = f.read().decode('utf8')\n        finally:\n            f.close()\n        self.assertEqual(text+'TEXTTAIL'+text, result)\n\n\nif ElementTree:\n    class ElementTreeIOTestCase(_IOTestCaseBase):\n        etree = ElementTree\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeIOTestCase)])\n    if ElementTree:\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementTreeIOTestCase)])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_pyclasslookup.py": "\"\"\"\nTests specific to the Python based class lookup.\n\"\"\"\n\n\nimport unittest\n\nfrom .common_imports import etree, HelperTestCase, _bytes\n\nfrom lxml.etree import PythonElementClassLookup\n\n\nxml_str = b'''\\\n<obj:root xmlns:obj=\"objectified\" xmlns:other=\"otherNS\">\n  <obj:c1 a1=\"A1\" a2=\"A2\" other:a3=\"A3\">\n    <obj:c2>0</obj:c2>\n    <obj:c2>1</obj:c2>\n    <obj:c2>2</obj:c2>\n    <other:c2>3</other:c2>\n    <c2>3</c2>\n  </obj:c1>\n</obj:root>'''\n\n\nclass PyClassLookupTestCase(HelperTestCase):\n    \"\"\"Test cases for the lxml.pyclasslookup class lookup mechanism.\n    \"\"\"\n    etree = etree\n    parser = etree.XMLParser()\n    Element = parser.makeelement\n\n    def tearDown(self):\n        self.parser.set_element_class_lookup(None)\n        super().tearDown()\n\n    def _setClassLookup(self, lookup_function):\n        class Lookup(PythonElementClassLookup):\n            def lookup(self, *args):\n                return lookup_function(*args)\n        self.parser.set_element_class_lookup( Lookup() )\n\n    def _buildElementClass(self):\n        class LocalElement(etree.ElementBase):\n            pass\n        return LocalElement\n\n    def XML(self, xml):\n        return self.etree.XML(xml, self.parser)\n\n    # --- Test cases\n\n    def test_lookup(self):\n        el_class = self._buildElementClass()\n        el_class.i = 1\n        def lookup(*args):\n            if el_class.i == 1:\n                el_class.i = 2\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(2, el_class.i)\n\n    def test_lookup_keep_ref_assertion(self):\n        el_class = self._buildElementClass()\n        el_class.EL = None\n        def lookup(doc, el):\n            if el_class.EL is None:\n                el_class.EL = el\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertNotEqual(None, el_class.EL)\n        self.assertRaises(ReferenceError, el_class.EL.getchildren)\n\n    def test_lookup_tag(self):\n        el_class = self._buildElementClass()\n        el_class.TAG = None\n        def lookup(doc, el):\n            if el_class.TAG is None:\n                el_class.TAG = el.tag\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertNotEqual(None, root.TAG)\n        self.assertEqual(root.tag, root.TAG)\n\n    def test_lookup_text(self):\n        el_class = self._buildElementClass()\n        el_class.TEXT = None\n        def lookup(doc, el):\n            if el_class.TEXT is None:\n                el_class.TEXT = el.text\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertNotEqual(None, root.TEXT)\n        self.assertEqual(root.text, root.TEXT)\n\n    def test_lookup_tail(self):\n        el_class = self._buildElementClass()\n        el_class.TAIL = None\n        def lookup(doc, el):\n            if el_class.TAIL is None:\n                el_class.TAIL = el.tail\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(root.tail, root.TAIL)\n\n    def test_lookup_attrib(self):\n        el_class = self._buildElementClass()\n        el_class.ATTRIB = None\n        def lookup(doc, el):\n            if el_class.ATTRIB is None:\n                el_class.ATTRIB = el[0].attrib\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        items1 = list(root[0].attrib.items())\n        items1.sort()\n        items2 = list(root.ATTRIB.items())\n        items2.sort()\n        self.assertEqual(items1, items2)\n\n    def test_lookup_prefix(self):\n        el_class = self._buildElementClass()\n        el_class.PREFIX = None\n        def lookup(doc, el):\n            if el_class.PREFIX is None:\n                el_class.PREFIX = el.prefix\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(root.prefix, root.PREFIX)\n\n    def test_lookup_sourceline(self):\n        el_class = self._buildElementClass()\n        el_class.LINE = None\n        def lookup(doc, el):\n            if el_class.LINE is None:\n                el_class.LINE = el.sourceline\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(root.sourceline, root.LINE)\n\n    def test_lookup_getitem(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAG = None\n        def lookup(doc, el):\n            el_class.CHILD_TAG = el[0].tag\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        child_tag = root.CHILD_TAG\n        self.assertNotEqual(None, child_tag)\n        self.assertEqual(root[0].tag, child_tag)\n\n    def test_lookup_getitem_neg(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAG = None\n        def lookup(doc, el):\n            if el_class.CHILD_TAG is None:\n                el_class.CHILD_TAG = el[-1].tag\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        child_tag = root.CHILD_TAG\n        self.assertNotEqual(None, child_tag)\n        self.assertEqual(root[-1].tag, child_tag)\n\n    def test_lookup_getslice(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAGS = None\n        def lookup(doc, el):\n            if el_class.CHILD_TAGS is None:\n                el_class.CHILD_TAGS = [ c.tag for c in el[1:-1] ]\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        child_tags = root.CHILD_TAGS\n        self.assertNotEqual(None, child_tags)\n        self.assertEqual([ c.tag for c in root[1:-1] ],\n                          child_tags)\n\n    def test_lookup_len(self):\n        el_class = self._buildElementClass()\n        el_class.LEN = None\n        def lookup(doc, el):\n            if el_class.LEN is None:\n                el_class.LEN = len(el)\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(1, el_class.LEN)\n\n    def test_lookup_bool(self):\n        el_class = self._buildElementClass()\n        el_class.TRUE = None\n        def lookup(doc, el):\n            if el_class.TRUE is None:\n                el_class.TRUE = bool(el)\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertTrue(el_class.TRUE)\n\n    def test_lookup_get(self):\n        el_class = self._buildElementClass()\n        el_class.VAL = None\n        def lookup(doc, el):\n            if el_class.VAL is None:\n                el_class.VAL = el[0].get('a1')\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertNotEqual(None, el_class.VAL)\n        self.assertEqual(root[0].get('a1'), el_class.VAL)\n\n    def test_lookup_get_default(self):\n        el_class = self._buildElementClass()\n        default = str(id(el_class))\n        el_class.VAL = None\n        def lookup(doc, el):\n            if el_class.VAL is None:\n                el_class.VAL = el[0].get('unknownattribute', default)\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(default, el_class.VAL)\n\n    def test_lookup_getchildren(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAGS = None\n        def lookup(doc, el):\n            if el_class.CHILD_TAGS is None:\n                el_class.CHILD_TAGS = [ c.tag for c in el.getchildren() ]\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        child_tags = root.CHILD_TAGS\n        self.assertNotEqual(None, child_tags)\n        self.assertEqual([ c.tag for c in root.getchildren() ],\n                          child_tags)\n\n    def test_lookup_iter_children(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAGS = None\n        def lookup(doc, el):\n            if el_class.CHILD_TAGS is None:\n                el_class.CHILD_TAGS = [ c.tag for c in el ]\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        child_tags = root.CHILD_TAGS\n        self.assertNotEqual(None, child_tags)\n        self.assertEqual([ c.tag for c in root.getchildren() ],\n                          child_tags)\n\n    def test_lookup_iterchildren(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAGS = None\n        def lookup(doc, el):\n            if el_class.CHILD_TAGS is None:\n                el_class.CHILD_TAGS = [ c.tag for c in el.iterchildren() ]\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        child_tags = root.CHILD_TAGS\n        self.assertNotEqual(None, child_tags)\n        self.assertEqual([ c.tag for c in root.getchildren() ],\n                          child_tags)\n\n    def test_lookup_iterchildren_tag(self):\n        el_class = self._buildElementClass()\n        el_class.CHILD_TAGS = None\n        def lookup(doc, el):\n            if not el_class.CHILD_TAGS:\n                el_class.CHILD_TAGS = [\n                    c.tag for c in el.iterchildren(tag='{objectified}c2') ]\n            return el_class\n        self._setClassLookup(lookup)\n\n        root = self.XML(xml_str)\n        child_tags = root.CHILD_TAGS\n        self.assertNotEqual(None, child_tags)\n        self.assertEqual([], child_tags)\n\n        c1 = root[0]\n        child_tags = root.CHILD_TAGS\n        self.assertNotEqual(None, child_tags)\n        self.assertNotEqual([], child_tags)\n        self.assertEqual(\n            [ c.tag for c in root[0].iterchildren(tag='{objectified}c2') ],\n            child_tags)\n\n    def test_lookup_getparent(self):\n        el_class = self._buildElementClass()\n        el_class.PARENT = None\n        def lookup(doc, el):\n            if el_class.PARENT is None:\n                el_class.PARENT = el[0].getparent().tag\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertEqual(root.tag, root.PARENT)\n\n    def test_lookup_getnext(self):\n        el_class = self._buildElementClass()\n        el_class.NEXT = None\n        def lookup(doc, el):\n            if el_class.NEXT is None:\n                el_class.NEXT = el[0][1].getnext().tag\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertNotEqual(None, el_class.NEXT)\n        self.assertEqual(root[0][1].getnext().tag, el_class.NEXT)\n\n    def test_lookup_getprevious(self):\n        el_class = self._buildElementClass()\n        el_class.PREV = None\n        def lookup(doc, el):\n            if el_class.PREV is None:\n                el_class.PREV = el[0][1].getprevious().tag\n            return el_class\n        self._setClassLookup(lookup)\n        root = self.XML(xml_str)\n        self.assertNotEqual(None, el_class.PREV)\n        self.assertEqual(root[0][1].getprevious().tag, el_class.PREV)\n\n    def test_comments_fallback(self):\n        def return_none(*args):\n            return None\n\n        self._setClassLookup(return_none)\n        el = self.XML('<a><!-- hello world --></a>')\n        self.assertEqual(el[0].tag, self.etree.Comment)\n        self.assertEqual(el[0].text, \" hello world \")\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(PyClassLookupTestCase)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_errors.py": "import unittest\n\n# These tests check that error handling in the Pyrex code is\n# complete.\n# It is likely that if there are errors, instead of failing the code\n# will simply crash.\n\nimport gc\nimport os.path\nimport sys\nimport unittest\nfrom lxml import etree\n\nfrom .common_imports import HelperTestCase, IS_PYPY\n\n\nclass ErrorTestCase(HelperTestCase):\n    etree = etree\n\n    def test_bad_element(self):\n        # attrib argument of Element() should be a dictionary, so if\n        # we pass a string we should get an error.\n        self.assertRaises(TypeError, self.etree.Element, 'a', 'b')\n\n    def test_empty_parse(self):\n        self.assertRaises(etree.XMLSyntaxError, etree.fromstring, '')\n\n    @unittest.skipIf(IS_PYPY, \"needs sys.getrefcount()\")\n    def test_element_cyclic_gc_none(self):\n        # test if cyclic reference can crash etree\n        Element = self.etree.Element\n        getrefcount = sys.getrefcount\n\n        # must disable tracing as it could change the refcounts\n        trace_func = sys.gettrace()\n        try:\n            sys.settrace(None)\n            gc.collect()\n\n            count = getrefcount(None)\n\n            l = [Element('name'), Element('name')]\n            l.append(l)\n\n            del l\n            gc.collect()\n            count = getrefcount(None) - count\n\n            if sys.version_info[:2] == (3, 11) and count == -1:\n                # FIXME: it's currently unclear why this happens, but it's reproducible on Py3.11.\n                self.assertEqual(count, -1)\n            else:\n                self.assertEqual(count, 0)\n        finally:\n            sys.settrace(trace_func)\n\n    def test_xmlsyntaxerror_has_info(self):\n        broken_xml_name = 'test_broken.xml'\n        broken_xml_path = os.path.join(os.path.dirname(__file__), broken_xml_name)\n        fail_msg = 'test_broken.xml should raise an etree.XMLSyntaxError'\n        try:\n            etree.parse(broken_xml_path)\n        except etree.XMLSyntaxError as e:\n            # invariant\n            self.assertEqual(e.position, (e.lineno, e.offset + 1), 'position and lineno/offset out of sync')\n            # SyntaxError info derived from file & contents\n            self.assertTrue(e.filename.endswith(broken_xml_name), 'filename must be preserved')\n            self.assertEqual(e.lineno, 1)\n            self.assertEqual(e.offset, 10)\n        except Exception as e:\n            self.fail(f'{fail_msg}, not {type(e)}')\n        else:\n            self.fail('test_broken.xml should raise an etree.XMLSyntaxError')\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ErrorTestCase)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_threading.py": "\"\"\"\nTests for thread usage in lxml.etree.\n\"\"\"\n\n\nimport re\nimport sys\nimport unittest\nimport threading\n\nfrom .common_imports import etree, HelperTestCase, BytesIO, _bytes\n\ntry:\n    from Queue import Queue\nexcept ImportError:\n    from queue import Queue # Py3\n\n\nclass ThreadingTestCase(HelperTestCase):\n    \"\"\"Threading tests\"\"\"\n    etree = etree\n\n    def _run_thread(self, func):\n        thread = threading.Thread(target=func)\n        thread.start()\n        thread.join()\n\n    def _run_threads(self, count, func, main_func=None):\n        sync = threading.Event()\n        lock = threading.Lock()\n        counter = dict(started=0, finished=0, failed=0)\n\n        def sync_start(func):\n            with lock:\n                started = counter['started'] + 1\n                counter['started'] = started\n            if started < count + (main_func is not None):\n                sync.wait(4)  # wait until the other threads have started up\n                assert sync.is_set()\n            sync.set()  # all waiting => go!\n            try:\n                func()\n            except:\n                with lock:\n                    counter['failed'] += 1\n                raise\n            else:\n                with lock:\n                    counter['finished'] += 1\n\n        threads = [threading.Thread(target=sync_start, args=(func,)) for _ in range(count)]\n        for thread in threads:\n            thread.start()\n        if main_func is not None:\n            sync_start(main_func)\n        for thread in threads:\n            thread.join()\n\n        self.assertEqual(0, counter['failed'])\n        self.assertEqual(counter['finished'], counter['started'])\n\n    def test_subtree_copy_thread(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        xml = b\"<root><threadtag/></root>\"\n        main_root = XML(b\"<root/>\")\n\n        def run_thread():\n            thread_root = XML(xml)\n            main_root.append(thread_root[0])\n            del thread_root\n\n        self._run_thread(run_thread)\n        self.assertEqual(xml, tostring(main_root))\n\n    def test_main_xslt_in_thread(self):\n        XML = self.etree.XML\n        style = XML(b'''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\">\n    <foo><xsl:copy><xsl:value-of select=\"/a/b/text()\" /></xsl:copy></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n        st = etree.XSLT(style)\n\n        result = []\n\n        def run_thread():\n            root = XML(b'<a><b>B</b><c>C</c></a>')\n            result.append( st(root) )\n\n        self._run_thread(run_thread)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo><a>B</a></foo>\n''',\n                          str(result[0]))\n\n    def test_thread_xslt(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        root = XML(b'<a><b>B</b><c>C</c></a>')\n\n        def run_thread():\n            style = XML(b'''\\\n    <xsl:stylesheet version=\"1.0\"\n        xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n      <xsl:template match=\"*\">\n        <foo><xsl:copy><xsl:value-of select=\"/a/b/text()\" /></xsl:copy></foo>\n      </xsl:template>\n    </xsl:stylesheet>''')\n            st = etree.XSLT(style)\n            root.append( st(root).getroot() )\n\n        self._run_thread(run_thread)\n        self.assertEqual(b'<a><b>B</b><c>C</c><foo><a>B</a></foo></a>',\n                          tostring(root))\n\n    def test_thread_xslt_parsing_error_log(self):\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template match=\"tag\" />\n    <!-- extend time for parsing + transform -->\n''' + '\\n'.join('<xsl:template match=\"tag%x\" />' % i for i in range(200)) + '''\n    <xsl:UnExpectedElement />\n</xsl:stylesheet>''')\n        self.assertRaises(etree.XSLTParseError,\n                          etree.XSLT, style)\n\n        error_logs = []\n\n        def run_thread():\n            try:\n                etree.XSLT(style)\n            except etree.XSLTParseError as e:\n                error_logs.append(e.error_log)\n            else:\n                self.assertFalse(True, \"XSLT parsing should have failed but didn't\")\n\n        self._run_threads(16, run_thread)\n\n        self.assertEqual(16, len(error_logs))\n        last_log = None\n        for log in error_logs:\n            self.assertTrue(len(log))\n            if last_log is not None:\n                self.assertEqual(len(last_log), len(log))\n            self.assertTrue(len(log) >= 2, len(log))\n            for error in log:\n                self.assertTrue(':ERROR:XSLT:' in str(error), str(error))\n            self.assertTrue(any('UnExpectedElement' in str(error) for error in log), log)\n            last_log = log\n\n    def test_thread_xslt_apply_error_log(self):\n        tree = self.parse('<tagFF/>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template name=\"tag0\">\n        <xsl:message terminate=\"yes\">FAIL</xsl:message>\n    </xsl:template>\n    <!-- extend time for parsing + transform -->\n''' + '\\n'.join('<xsl:template match=\"tag%X\" name=\"tag%x\"> <xsl:call-template name=\"tag%x\" /> </xsl:template>' % (i, i, i-1)\n                for i in range(1, 256)) + '''\n</xsl:stylesheet>''')\n        self.assertRaises(etree.XSLTApplyError,\n                          etree.XSLT(style), tree)\n\n        error_logs = []\n\n        def run_thread():\n            transform = etree.XSLT(style)\n            try:\n                transform(tree)\n            except etree.XSLTApplyError:\n                error_logs.append(transform.error_log)\n            else:\n                self.assertFalse(True, \"XSLT parsing should have failed but didn't\")\n\n        self._run_threads(16, run_thread)\n\n        self.assertEqual(16, len(error_logs))\n        last_log = None\n        for log in error_logs:\n            self.assertTrue(len(log))\n            if last_log is not None:\n                self.assertEqual(len(last_log), len(log))\n            self.assertEqual(1, len(log))\n            for error in log:\n                self.assertTrue(':ERROR:XSLT:' in str(error))\n            last_log = log\n\n    def test_thread_xslt_attr_replace(self):\n        # this is the only case in XSLT where the result tree can be\n        # modified in-place\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        style = self.etree.XSLT(XML(b'''\\\n    <xsl:stylesheet version=\"1.0\"\n        xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n      <xsl:template match=\"*\">\n        <root class=\"abc\">\n          <xsl:copy-of select=\"@class\" />\n          <xsl:attribute name=\"class\">xyz</xsl:attribute> \n        </root>\n      </xsl:template>\n    </xsl:stylesheet>'''))\n\n        result = []\n        def run_thread():\n            root = XML(b'<ROOT class=\"ABC\" />')\n            result.append( style(root).getroot() )\n\n        self._run_thread(run_thread)\n        self.assertEqual(b'<root class=\"xyz\"/>',\n                          tostring(result[0]))\n\n    def test_thread_create_xslt(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        root = XML(b'<a><b>B</b><c>C</c></a>')\n\n        stylesheets = []\n\n        def run_thread():\n            style = XML(b'''\\\n    <xsl:stylesheet\n        xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n        version=\"1.0\">\n      <xsl:output method=\"xml\" />\n      <xsl:template match=\"/\">\n         <div id=\"test\">\n           <xsl:apply-templates/>\n         </div>\n      </xsl:template>\n    </xsl:stylesheet>''')\n            stylesheets.append( etree.XSLT(style) )\n\n        self._run_thread(run_thread)\n\n        st = stylesheets[0]\n        result = tostring( st(root) )\n\n        self.assertEqual(b'<div id=\"test\">BC</div>',\n                          result)\n\n    def test_thread_error_log(self):\n        XML = self.etree.XML\n        expected_error = [self.etree.ErrorTypes.ERR_TAG_NAME_MISMATCH]\n        children = \"<a>test</a>\" * 100\n\n        def parse_error_test(thread_no):\n            tag = \"tag%d\" % thread_no\n            xml = \"<%s>%s</%s>\" % (tag, children, tag.upper())\n            parser = self.etree.XMLParser()\n            for _ in range(10):\n                errors = None\n                try:\n                    XML(xml, parser)\n                except self.etree.ParseError:\n                    e = sys.exc_info()[1]\n                    errors = e.error_log.filter_types(expected_error)\n                self.assertTrue(errors, \"Expected error not found\")\n                for error in errors:\n                    self.assertTrue(\n                        tag in error.message and tag.upper() in error.message,\n                        \"%s and %s not found in '%s'\" % (\n                        tag, tag.upper(), error.message))\n\n        self.etree.clear_error_log()\n        threads = []\n        for thread_no in range(1, 10):\n            t = threading.Thread(target=parse_error_test,\n                                 args=(thread_no,))\n            threads.append(t)\n            t.start()\n\n        parse_error_test(0)\n\n        for t in threads:\n            t.join()\n\n    def test_thread_mix(self):\n        XML = self.etree.XML\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n        xml = b'<a><b>B</b><c xmlns=\"test\">C</c></a>'\n        root = XML(xml)\n        fragment = XML(b\"<other><tags/></other>\")\n\n        result = self.etree.Element(\"{myns}root\", att = \"someval\")\n\n        def run_XML():\n            thread_root = XML(xml)\n            result.append(thread_root[0])\n            result.append(thread_root[-1])\n\n        def run_parse():\n            thread_root = self.etree.parse(BytesIO(xml)).getroot()\n            result.append(thread_root[0])\n            result.append(thread_root[-1])\n\n        def run_move_main():\n            result.append(fragment[0])\n\n        def run_build():\n            result.append(\n                Element(\"{myns}foo\", attrib={'{test}attr':'val'}))\n            SubElement(result, \"{otherns}tasty\")\n\n        def run_xslt():\n            style = XML(b'''\\\n    <xsl:stylesheet version=\"1.0\"\n        xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n      <xsl:template match=\"*\">\n        <xsl:copy><foo><xsl:value-of select=\"/a/b/text()\" /></foo></xsl:copy>\n      </xsl:template>\n    </xsl:stylesheet>''')\n            st = etree.XSLT(style)\n            result.append( st(root).getroot() )\n\n        for test in (run_XML, run_parse, run_move_main, run_xslt, run_build):\n            tostring(result)\n            self._run_thread(test)\n\n        self.assertEqual(\n            b'<ns0:root xmlns:ns0=\"myns\" att=\"someval\"><b>B</b>'\n                   b'<c xmlns=\"test\">C</c><b>B</b><c xmlns=\"test\">C</c><tags/>'\n                   b'<a><foo>B</foo></a>'\n                   b'<ns0:foo xmlns:ns1=\"test\" ns1:attr=\"val\"/>'\n                   b'<ns1:tasty xmlns:ns1=\"otherns\"/></ns0:root>',\n            tostring(result))\n\n        def strip_first():\n            root = Element(\"newroot\")\n            root.append(result[0])\n\n        while len(result):\n            self._run_thread(strip_first)\n\n        self.assertEqual(\n            b'<ns0:root xmlns:ns0=\"myns\" att=\"someval\"/>',\n            tostring(result))\n\n    def test_concurrent_attribute_names_in_dicts(self):\n        SubElement = self.etree.SubElement\n        names = list('abcdefghijklmnop')\n        runs_per_name = range(50)\n        result_matches = re.compile(\n            br'<thread_root>'\n            br'(?:<[a-p]{5} thread_attr_[a-p]=\"value\" thread_attr2_[a-p]=\"value2\"\\s?/>)+'\n            br'</thread_root>').match\n\n        def testrun():\n            for _ in range(3):\n                root = self.etree.Element('thread_root')\n                for name in names:\n                    tag_name = name * 5\n                    new = []\n                    for _ in runs_per_name:\n                        el = SubElement(root, tag_name, {'thread_attr_' + name: 'value'})\n                        new.append(el)\n                    for el in new:\n                        el.set('thread_attr2_' + name, 'value2')\n                s = etree.tostring(root)\n                self.assertTrue(result_matches(s))\n\n        # first, run only in sub-threads\n        self._run_threads(10, testrun)\n\n        # then, additionally include the main thread (and its parent dict)\n        self._run_threads(10, testrun, main_func=testrun)\n\n    def test_concurrent_proxies(self):\n        XML = self.etree.XML\n        root = XML(b'<root><a>A</a><b xmlns=\"test\">B</b><c/></root>')\n        child_count = len(root)\n        def testrun():\n            for i in range(10000):\n                el = root[i%child_count]\n                del el\n        self._run_threads(10, testrun)\n\n    def test_concurrent_class_lookup(self):\n        XML = self.etree.XML\n\n        class TestElement(etree.ElementBase):\n            pass\n\n        class MyLookup(etree.CustomElementClassLookup):\n            repeat = range(100)\n            def lookup(self, t, d, ns, name):\n                count = 0\n                for i in self.repeat:\n                    # allow other threads to run\n                    count += 1\n                return TestElement\n\n        parser = self.etree.XMLParser()\n        parser.set_element_class_lookup(MyLookup())\n\n        root = XML(b'<root><a>A</a><b xmlns=\"test\">B</b><c/></root>',\n                   parser)\n\n        child_count = len(root)\n        def testrun():\n            for i in range(1000):\n                el = root[i%child_count]\n                del el\n        self._run_threads(10, testrun)\n\n\nclass ThreadPipelineTestCase(HelperTestCase):\n    \"\"\"Threading tests based on a thread worker pipeline.\n    \"\"\"\n    etree = etree\n    item_count = 40\n\n    class Worker(threading.Thread):\n        def __init__(self, in_queue, in_count, **kwargs):\n            threading.Thread.__init__(self)\n            self.in_queue = in_queue\n            self.in_count = in_count\n            self.out_queue = Queue(in_count)\n            self.__dict__.update(kwargs)\n\n        def run(self):\n            get, put = self.in_queue.get, self.out_queue.put\n            handle = self.handle\n            for _ in range(self.in_count):\n                put(handle(get()))\n\n        def handle(self, data):\n            raise NotImplementedError()\n\n    class ParseWorker(Worker):\n        def handle(self, xml, _fromstring=etree.fromstring):\n            return _fromstring(xml)\n\n    class RotateWorker(Worker):\n        def handle(self, element):\n            first = element[0]\n            element[:] = element[1:]\n            element.append(first)\n            return element\n\n    class ReverseWorker(Worker):\n        def handle(self, element):\n            element[:] = element[::-1]\n            return element\n\n    class ParseAndExtendWorker(Worker):\n        def handle(self, element, _fromstring=etree.fromstring):\n            element.extend(_fromstring(self.xml))\n            return element\n\n    class ParseAndInjectWorker(Worker):\n        def handle(self, element, _fromstring=etree.fromstring):\n            root = _fromstring(self.xml)\n            root.extend(element)\n            return root\n\n    class Validate(Worker):\n        def handle(self, element):\n            element.getroottree().docinfo.internalDTD.assertValid(element)\n            return element\n\n    class SerialiseWorker(Worker):\n        def handle(self, element):\n            return etree.tostring(element)\n\n    xml = (b'''\\\n<!DOCTYPE threadtest [\n    <!ELEMENT threadtest (thread-tag1,thread-tag2)+>\n    <!ATTLIST threadtest\n        version    CDATA  \"1.0\"\n    >\n    <!ELEMENT thread-tag1 EMPTY>\n    <!ELEMENT thread-tag2 (div)>\n    <!ELEMENT div (threaded)>\n    <!ATTLIST div\n        huhu  CDATA  #IMPLIED\n    >\n    <!ELEMENT threaded EMPTY>\n    <!ATTLIST threaded\n        host  CDATA  #REQUIRED\n    >\n]>\n<threadtest version=\"123\">\n''' + (b'''\n  <thread-tag1 />\n  <thread-tag2>\n    <div huhu=\"true\">\n       <threaded host=\"here\" />\n    </div>\n  </thread-tag2>\n''') * 20 + b'''\n</threadtest>''')\n\n    def _build_pipeline(self, item_count, *classes, **kwargs):\n        in_queue = Queue(item_count)\n        start = last = classes[0](in_queue, item_count, **kwargs)\n        start.setDaemon(True)\n        for worker_class in classes[1:]:\n            last = worker_class(last.out_queue, item_count, **kwargs)\n            last.setDaemon(True)\n            last.start()\n        return in_queue, start, last\n\n    def test_thread_pipeline_thread_parse(self):\n        item_count = self.item_count\n        xml = self.xml.replace(b'thread', b'THREAD')  # use fresh tag names\n\n        # build and start the pipeline\n        in_queue, start, last = self._build_pipeline(\n            item_count,\n            self.ParseWorker,\n            self.RotateWorker,\n            self.ReverseWorker,\n            self.ParseAndExtendWorker,\n            self.Validate,\n            self.ParseAndInjectWorker,\n            self.SerialiseWorker,\n            xml=xml)\n\n        # fill the queue\n        put = start.in_queue.put\n        for _ in range(item_count):\n            put(xml)\n\n        # start the first thread and thus everything\n        start.start()\n        # make sure the last thread has terminated\n        last.join(60)  # time out after 60 seconds\n        self.assertEqual(item_count, last.out_queue.qsize())\n        # read the results\n        get = last.out_queue.get\n        results = [get() for _ in range(item_count)]\n\n        comparison = results[0]\n        for i, result in enumerate(results[1:]):\n            self.assertEqual(comparison, result)\n\n    def test_thread_pipeline_global_parse(self):\n        item_count = self.item_count\n        xml = self.xml.replace(b'thread', b'GLOBAL')  # use fresh tag names\n        XML = self.etree.XML\n        # build and start the pipeline\n        in_queue, start, last = self._build_pipeline(\n            item_count,\n            self.RotateWorker,\n            self.ReverseWorker,\n            self.ParseAndExtendWorker,\n            self.Validate,\n            self.SerialiseWorker,\n            xml=xml)\n\n        # fill the queue\n        put = start.in_queue.put\n        for _ in range(item_count):\n            put(XML(xml))\n\n        # start the first thread and thus everything\n        start.start()\n        # make sure the last thread has terminated\n        last.join(60)  # time out after 90 seconds\n        self.assertEqual(item_count, last.out_queue.qsize())\n        # read the results\n        get = last.out_queue.get\n        results = [get() for _ in range(item_count)]\n\n        comparison = results[0]\n        for i, result in enumerate(results[1:]):\n            self.assertEqual(comparison, result)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ThreadingTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ThreadPipelineTestCase)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_nsclasses.py": "\"\"\"\nTest cases related to namespace implementation classes and the\nnamespace registry mechanism\n\"\"\"\n\n\nimport unittest\n\nfrom .common_imports import etree, HelperTestCase, _bytes, make_doctest\n\nclass ETreeNamespaceClassesTestCase(HelperTestCase):\n    \n    class default_class(etree.ElementBase):\n        pass\n    class maeh_class(etree.ElementBase):\n        def maeh(self):\n            return 'maeh'\n    class bluff_class(etree.ElementBase):\n        def bluff(self):\n            return 'bluff'\n\n    def setUp(self):\n        super().setUp()\n        lookup = etree.ElementNamespaceClassLookup()\n        self.Namespace = lookup.get_namespace\n        parser = etree.XMLParser()\n        parser.set_element_class_lookup(lookup)\n        etree.set_default_parser(parser)\n\n    def tearDown(self):\n        etree.set_default_parser()\n        del self.Namespace\n        super().tearDown()\n\n    def test_registry(self):\n        ns = self.Namespace('ns01')\n        ns['maeh'] = self.maeh_class\n\n        self.Namespace('ns01').clear()\n\n        self.Namespace('ns02').update({'maeh'  : self.maeh_class})\n        self.Namespace('ns03').update({'bluff' : self.bluff_class}.items())\n        self.Namespace('ns02').clear()\n        self.Namespace('ns03').clear()\n\n    def test_ns_classes(self):\n        bluff_dict = {'bluff' : self.bluff_class}\n        maeh_dict  = {'maeh'  : self.maeh_class}\n\n        self.Namespace('ns10').update(bluff_dict)\n\n        tree = self.parse(b'<bluff xmlns=\"ns10\"><ns11:maeh xmlns:ns11=\"ns11\"/></bluff>')\n\n        el = tree.getroot()\n        self.assertTrue(isinstance(el, etree.ElementBase))\n        self.assertTrue(hasattr(el, 'bluff'))\n        self.assertFalse(hasattr(el[0], 'maeh'))\n        self.assertFalse(hasattr(el[0], 'bluff'))\n        self.assertEqual(el.bluff(), 'bluff')\n        del el\n\n        self.Namespace('ns11').update(maeh_dict)\n        el = tree.getroot()\n        self.assertTrue(hasattr(el, 'bluff'))\n        self.assertTrue(hasattr(el[0], 'maeh'))\n        self.assertEqual(el.bluff(), 'bluff')\n        self.assertEqual(el[0].maeh(), 'maeh')\n        del el\n\n        self.Namespace('ns10').clear()\n\n        tree = self.parse(b'<bluff xmlns=\"ns10\"><ns11:maeh xmlns:ns11=\"ns11\"/></bluff>')\n        el = tree.getroot()\n        self.assertFalse(hasattr(el, 'bluff'))\n        self.assertFalse(hasattr(el, 'maeh'))\n        self.assertFalse(hasattr(el[0], 'bluff'))\n        self.assertTrue(hasattr(el[0], 'maeh'))\n\n        self.Namespace('ns11').clear()\n\n    def test_default_tagname(self):\n        bluff_dict = {\n            None   : self.bluff_class,\n            'maeh' : self.maeh_class\n            }\n\n        ns = self.Namespace(\"uri:nsDefClass\")\n        ns.update(bluff_dict)\n\n        tree = self.parse(b'''\n            <test xmlns=\"bla\" xmlns:ns1=\"uri:nsDefClass\" xmlns:ns2=\"uri:nsDefClass\">\n              <ns2:el1/><ns1:el2/><ns1:maeh/><ns2:maeh/><maeh/>\n            </test>\n            ''')\n\n        el = tree.getroot()\n        self.assertFalse(isinstance(el, etree.ElementBase))\n        for child in el[:-1]:\n            self.assertTrue(isinstance(child, etree.ElementBase), child.tag)\n        self.assertFalse(isinstance(el[-1], etree.ElementBase))\n\n        self.assertTrue(hasattr(el[0], 'bluff'))\n        self.assertTrue(hasattr(el[1], 'bluff'))\n        self.assertTrue(hasattr(el[2], 'maeh'))\n        self.assertTrue(hasattr(el[3], 'maeh'))\n        self.assertFalse(hasattr(el[4], 'maeh'))\n        del el\n\n        ns.clear()\n\n    def test_create_element(self):\n        bluff_dict = {'bluff' : self.bluff_class}\n        self.Namespace('ns20').update(bluff_dict)\n\n        maeh_dict  = {'maeh'  : self.maeh_class}\n        self.Namespace('ns21').update(maeh_dict)\n\n        el = etree.Element(\"{ns20}bluff\")\n        self.assertTrue(hasattr(el, 'bluff'))\n\n        child = etree.SubElement(el, \"{ns21}maeh\")\n        self.assertTrue(hasattr(child, 'maeh'))\n        child = etree.SubElement(el, \"{ns20}bluff\")\n        self.assertTrue(hasattr(child, 'bluff'))\n        child = etree.SubElement(el, \"{ns21}bluff\")\n        self.assertFalse(hasattr(child, 'bluff'))\n        self.assertFalse(hasattr(child, 'maeh'))\n\n        self.assertTrue(hasattr(el[0], 'maeh'))\n        self.assertTrue(hasattr(el[1], 'bluff'))\n        self.assertFalse(hasattr(el[2], 'bluff'))\n        self.assertFalse(hasattr(el[2], 'maeh'))\n\n        self.assertEqual(el.bluff(), 'bluff')\n        self.assertEqual(el[0].maeh(), 'maeh')\n        self.assertEqual(el[1].bluff(), 'bluff')\n\n        self.Namespace('ns20').clear()\n        self.Namespace('ns21').clear()\n\n    def test_create_element_default(self):\n        bluff_dict = {None : self.bluff_class}\n        self.Namespace('ns30').update(bluff_dict)\n\n        maeh_dict  = {'maeh'  : self.maeh_class}\n        self.Namespace(None).update(maeh_dict)\n\n        el = etree.Element(\"{ns30}bluff\")\n        etree.SubElement(el, \"maeh\")\n        self.assertTrue(hasattr(el, 'bluff'))\n        self.assertTrue(hasattr(el[0], 'maeh'))\n        self.assertEqual(el.bluff(), 'bluff')\n        self.assertEqual(el[0].maeh(), 'maeh')\n\n        self.Namespace(None).clear()\n        self.Namespace('ns30').clear()\n\n    def test_element_creation(self):\n        default, bluff, maeh = (\n            self.default_class, self.bluff_class, self.maeh_class)\n\n        class honk(etree.ElementBase):\n            TAG = 'HONK'\n            NAMESPACE = 'http://a.b/c'\n\n        el = default(\n            \"test\",\n            \"text\",\n            bluff(honk, \"TaIL\", maeh),\n            maeh(\"TeXT\", bluff, honk(), \"TAiL\"),\n            \"Tail\")\n\n        self.assertEqual('default_class', el.tag)\n        self.assertEqual('testtext', el.text)\n        self.assertEqual(None, el.tail)\n        self.assertEqual(2, len(el))\n        self.assertEqual(7, len(list(el.iter())))\n\n        self.assertEqual('bluff_class', el[0].tag)\n        self.assertEqual('TaIL', el[0][0].tail)\n        self.assertEqual('TaIL', ''.join(el[0].itertext()))\n        self.assertEqual('{http://a.b/c}HONK',\n                          el[0][0].tag)\n        self.assertEqual('maeh_class',\n                          el[0][1].tag)\n\n        self.assertEqual('maeh_class', el[1].tag)\n        self.assertEqual('TeXT', el[1].text)\n        self.assertEqual('bluff_class', el[1][0].tag)\n        self.assertEqual('{http://a.b/c}HONK', el[1][1].tag)\n        self.assertEqual('TAiL', el[1][1].tail)\n\n        self.assertEqual('TeXTTAiL',\n                          ''.join(el[1].itertext()))\n        self.assertEqual('Tail', el[1].tail)\n        self.assertEqual('TAiL', el[1][1].tail)\n        self.assertEqual('bluff_class', el[1][0].tag)\n        self.assertEqual('{http://a.b/c}HONK', el[1][1].tag)\n        \n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeNamespaceClassesTestCase)])\n    suite.addTests(\n        [make_doctest('element_classes.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/common_imports.py": "\"\"\"\nCommon helpers and adaptations for Py2/3.\nTo be used in tests.\n\"\"\"\n\n# Slows down test runs by factors. Enable to debug proxy handling issues.\nDEBUG_PROXY_ISSUES = False  # True\n\nimport gc\nimport os\nimport os.path\nimport re\nimport sys\nimport tempfile\nimport unittest\n\nfrom contextlib import contextmanager\nfrom io import StringIO, BytesIO\nimport urllib.parse as urlparse\nfrom urllib.request import pathname2url\n\nfrom lxml import etree, html\n\ndef make_version_tuple(version_string):\n    return tuple(\n        int(part) if part.isdigit() else part\n        for part in re.findall('([0-9]+|[^0-9.]+)', version_string)\n    )\n\nIS_PYPY = (getattr(sys, 'implementation', None) == 'pypy' or\n           getattr(sys, 'pypy_version_info', None) is not None)\n\nfrom xml.etree import ElementTree\n\nif hasattr(ElementTree, 'VERSION'):\n    ET_VERSION = make_version_tuple(ElementTree.VERSION)\nelse:\n    ET_VERSION = (0,0,0)\n\nDOC_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))), 'doc')\n\n\ndef filter_by_version(test_class, version_dict, current_version):\n    \"\"\"Remove test methods that do not work with the current lib version.\n    \"\"\"\n    find_required_version = version_dict.get\n    def dummy_test_method(self):\n        pass\n    for name in dir(test_class):\n        expected_version = find_required_version(name, (0,0,0))\n        if expected_version > current_version:\n            setattr(test_class, name, dummy_test_method)\n\n\ndef needs_libxml(*version):\n    return unittest.skipIf(\n        etree.LIBXML_VERSION < version,\n        \"needs libxml2 >= %s.%s.%s\" % (version + (0, 0, 0))[:3])\n\n\nimport doctest\n\ntry:\n    import pytest\nexcept ImportError:\n    class skipif:\n        \"Using a class because a function would bind into a method when used in classes\"\n        def __init__(self, *args): pass\n        def __call__(self, func, *args): return func\nelse:\n    skipif = pytest.mark.skipif\n\n\nunichr_escape = re.compile(r'\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8}')\n\n\n# Python 3\nfrom codecs import unicode_escape_decode\ndef _str(s, encoding=\"UTF-8\"):\n    return unichr_escape.sub(lambda x: unicode_escape_decode(x.group(0))[0], s)\ndef _bytes(s, encoding=\"UTF-8\"):\n    return s.encode(encoding)\n\nfrom io import BytesIO as _BytesIO\n\ndef BytesIO(*args):\n    if args and isinstance(args[0], str):\n        args = (args[0].encode(\"UTF-8\"),)\n    return _BytesIO(*args)\n\ndoctest_parser = doctest.DocTestParser()\n\ndef make_doctest(filename):\n    file_path = os.path.join(DOC_DIR, filename)\n    return doctest.DocFileSuite(file_path, module_relative=False, encoding='utf-8')\n\n\nclass HelperTestCase(unittest.TestCase):\n    def tearDown(self):\n        if DEBUG_PROXY_ISSUES:\n            gc.collect()\n\n    def parse(self, text, parser=None):\n        f = BytesIO(text) if isinstance(text, bytes) else StringIO(text)\n        return etree.parse(f, parser=parser)\n    \n    def _rootstring(self, tree):\n        return etree.tostring(tree.getroot()).replace(\n            b' ', b'').replace(b'\\n', b'')\n\n    try:\n        unittest.TestCase.assertRegex\n    except AttributeError:\n        def assertRegex(self, *args, **kwargs):\n            return self.assertRegex(*args, **kwargs)\n\n\nclass SillyFileLike:\n    def __init__(self, xml_data=b'<foo><bar/></foo>'):\n        self.xml_data = xml_data\n        \n    def read(self, amount=None):\n        if self.xml_data:\n            if amount:\n                data = self.xml_data[:amount]\n                self.xml_data = self.xml_data[amount:]\n            else:\n                data = self.xml_data\n                self.xml_data = b''\n            return data\n        return b''\n\n\nclass LargeFileLike:\n    def __init__(self, charlen=100, depth=4, children=5):\n        self.data = BytesIO()\n        self.chars  = b'a' * charlen\n        self.children = range(children)\n        self.more = self.iterelements(depth)\n\n    def iterelements(self, depth):\n        yield b'<root>'\n        depth -= 1\n        if depth > 0:\n            for child in self.children:\n                yield from self.iterelements(depth)\n                yield self.chars\n        else:\n            yield self.chars\n        yield b'</root>'\n\n    def read(self, amount=None):\n        data = self.data\n        append = data.write\n        if amount:\n            for element in self.more:\n                append(element)\n                if data.tell() >= amount:\n                    break\n        else:\n            for element in self.more:\n                append(element)\n        result = data.getvalue()\n        data.seek(0)\n        data.truncate()\n        if amount:\n            append(result[amount:])\n            result = result[:amount]\n        return result\n\n\nclass LargeFileLikeUnicode(LargeFileLike):\n    def __init__(self, charlen=100, depth=4, children=5):\n        LargeFileLike.__init__(self, charlen, depth, children)\n        self.data = StringIO()\n        self.chars  = 'a' * charlen\n        self.more = self.iterelements(depth)\n\n    def iterelements(self, depth):\n        yield '<root>'\n        depth -= 1\n        if depth > 0:\n            for child in self.children:\n                yield from self.iterelements(depth)\n                yield self.chars\n        else:\n            yield self.chars\n        yield '</root>'\n\n\nclass SimpleFSPath:\n    def __init__(self, path):\n        self.path = path\n    def __fspath__(self):\n        return self.path\n\n\ndef fileInTestDir(name):\n    _testdir = os.path.dirname(__file__)\n    return os.path.join(_testdir, name)\n\n\ndef path2url(path):\n    return urlparse.urljoin(\n        'file:', pathname2url(path))\n\n\ndef fileUrlInTestDir(name):\n    return path2url(fileInTestDir(name))\n\n\ndef read_file(name, mode='r'):\n    with open(name, mode) as f:\n        data = f.read()\n    return data\n\n\ndef write_to_file(name, data, mode='w'):\n    with open(name, mode) as f:\n        f.write(data)\n\n\ndef readFileInTestDir(name, mode='r'):\n    return read_file(fileInTestDir(name), mode)\n\n\ndef canonicalize(xml):\n    tree = etree.parse(BytesIO(xml) if isinstance(xml, bytes) else StringIO(xml))\n    f = BytesIO()\n    tree.write_c14n(f)\n    return f.getvalue()\n\n\n@contextmanager\ndef tmpfile(**kwargs):\n    handle, filename = tempfile.mkstemp(**kwargs)\n    try:\n        yield filename\n    finally:\n        os.close(handle)\n        os.remove(filename)\n", "src/lxml/tests/test_schematron.py": "\"\"\"\nTest cases related to Schematron parsing and validation\n\"\"\"\n\n\nimport unittest\n\nfrom .common_imports import etree, HelperTestCase, make_doctest\n\n\nclass ETreeSchematronTestCase(HelperTestCase):\n    def test_schematron(self):\n        tree_valid = self.parse('<AAA><BBB/><CCC/></AAA>')\n        tree_invalid = self.parse('<AAA><BBB/><CCC/><DDD/></AAA>')\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n     <pattern name=\"Open model\">\n          <rule context=\"AAA\">\n               <assert test=\"BBB\"> BBB element is not present</assert>\n               <assert test=\"CCC\"> CCC element is not present</assert>\n          </rule>\n     </pattern>\n     <pattern name=\"Closed model\">\n          <rule context=\"AAA\">\n               <assert test=\"BBB\"> BBB element is not present</assert>\n               <assert test=\"CCC\"> CCC element is not present</assert>\n               <assert test=\"count(BBB|CCC) = count (*)\">There is an extra element</assert>\n          </rule>\n     </pattern>\n</schema>\n''')\n        schema = etree.Schematron(schema)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.error_log.filter_from_errors())\n\n        self.assertFalse(schema.validate(tree_invalid))\n        self.assertTrue(schema.error_log.filter_from_errors())\n\n        self.assertTrue(schema.validate(tree_valid))             # repeat valid\n        self.assertFalse(schema.error_log.filter_from_errors())  # repeat valid\n\n    def test_schematron_elementtree_error(self):\n        self.assertRaises(ValueError, etree.Schematron, etree.ElementTree())\n\n    def test_schematron_invalid_schema(self):\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n     <pattern name=\"Open model\">\n     </pattern>\n</schema>\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          etree.Schematron, schema)\n\n    def test_schematron_invalid_schema_empty(self):\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" />\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          etree.Schematron, schema)\n\n    def test_schematron_invalid_schema_namespace(self):\n        # segfault\n        schema = self.parse('''\\\n<schema xmlns=\"mynamespace\" />\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          etree.Schematron, schema)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeSchematronTestCase)])\n    suite.addTests(\n        [make_doctest('validation.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_dtd.py": "\"\"\"\nTest cases related to DTD parsing and validation\n\"\"\"\n\nimport unittest, sys\nfrom io import BytesIO\nfrom unittest import skipIf\n\nfrom .common_imports import (\n    etree, html,\n    HelperTestCase, make_doctest,\n    fileInTestDir, fileUrlInTestDir, SimpleFSPath\n)\n\n\nclass ETreeDtdTestCase(HelperTestCase):\n    def test_dtd(self):\n        pass\n\n    def test_dtd_file(self):\n        parse = etree.parse\n        tree = parse(fileInTestDir(\"test.xml\"))\n        root = tree.getroot()\n\n        dtd = etree.DTD(fileInTestDir(\"test.dtd\"))\n        self.assertTrue(dtd.validate(root))\n    \n    def test_dtd_file_pathlike(self):\n        parse = etree.parse\n        tree = parse(fileInTestDir(\"test.xml\"))\n        root = tree.getroot()\n\n        dtd = etree.DTD(SimpleFSPath(fileInTestDir(\"test.dtd\")))\n        self.assertTrue(dtd.validate(root))\n\n    def test_dtd_stringio(self):\n        root = etree.XML(b\"<b/>\")\n        dtd = etree.DTD(BytesIO(b\"<!ELEMENT b EMPTY>\"))\n        self.assertTrue(dtd.validate(root))\n\n    def test_dtd_parse_invalid(self):\n        fromstring = etree.fromstring\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = ('<!DOCTYPE b SYSTEM \"%s\"><b><a/></b>' %\n                     fileInTestDir(\"test.dtd\")).encode('utf-8')\n        self.assertRaises(etree.XMLSyntaxError,\n                          fromstring, xml, parser=parser)\n\n    def test_dtd_parse_file_not_found(self):\n        fromstring = etree.fromstring\n        dtd_filename = fileUrlInTestDir(\"__nosuch.dtd\")\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = '<!DOCTYPE b SYSTEM \"%s\"><b><a/></b>' % dtd_filename\n        self.assertRaises(etree.XMLSyntaxError, fromstring, xml, parser=parser)\n        errors = None\n        try:\n            fromstring(xml, parser=parser)\n        except etree.XMLSyntaxError:\n            e = sys.exc_info()[1]\n            self.assertTrue(e.error_log)\n            self.assertTrue(parser.error_log)\n            errors = [entry.message for entry in e.error_log\n                      if dtd_filename in entry.message]\n        self.assertTrue(errors)\n\n    def test_dtd_parse_valid(self):\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = ('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>' %\n               fileUrlInTestDir(\"test.dtd\"))\n        root = etree.fromstring(xml, parser=parser)\n\n    def test_dtd_parse_valid_file_url(self):\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = ('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>' %\n               fileUrlInTestDir(\"test.dtd\"))\n        root = etree.fromstring(xml, parser=parser)\n\n    def test_dtd_parse_valid_relative(self):\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = '<!DOCTYPE a SYSTEM \"test.dtd\"><a><b/></a>'\n        root = etree.fromstring(\n            xml, parser=parser, base_url=fileUrlInTestDir(\"test.xml\"))\n\n    def test_dtd_parse_valid_relative_file_url(self):\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = '<!DOCTYPE a SYSTEM \"test.dtd\"><a><b/></a>'\n        root = etree.fromstring(\n            xml, parser=parser, base_url=fileUrlInTestDir(\"test.xml\"))\n\n    def test_dtd_invalid(self):\n        root = etree.XML(\"<b><a/></b>\")\n        dtd = etree.DTD(BytesIO(b\"<!ELEMENT b EMPTY>\"))\n        self.assertRaises(etree.DocumentInvalid, dtd.assertValid, root)\n\n    def test_dtd_assertValid(self):\n        root = etree.XML(\"<b><a/></b>\")\n        dtd = etree.DTD(BytesIO(b\"<!ELEMENT b (a)><!ELEMENT a EMPTY>\"))\n        dtd.assertValid(root)\n\n    def test_dtd_internal(self):\n        root = etree.XML(b'''\n        <!DOCTYPE b SYSTEM \"none\" [\n        <!ELEMENT b (a)>\n        <!ELEMENT a EMPTY>\n        ]>\n        <b><a/></b>\n        ''')\n        dtd = etree.ElementTree(root).docinfo.internalDTD\n        self.assertTrue(dtd)\n        dtd.assertValid(root)\n\n    def test_dtd_internal_invalid(self):\n        root = etree.XML(b'''\n        <!DOCTYPE b SYSTEM \"none\" [\n        <!ELEMENT b (a)>\n        <!ELEMENT a (c)>\n        <!ELEMENT c EMPTY>\n        ]>\n        <b><a/></b>\n        ''')\n        dtd = etree.ElementTree(root).docinfo.internalDTD\n        self.assertTrue(dtd)\n        self.assertFalse(dtd.validate(root))\n\n    def test_dtd_invalid_duplicate_id(self):\n        root = etree.XML(b'''\n        <a><b id=\"id1\"/><b id=\"id2\"/><b id=\"id1\"/></a>\n        ''')\n        dtd = etree.DTD(BytesIO(b\"\"\"\n        <!ELEMENT a (b*)>\n        <!ATTLIST b\n            id ID #REQUIRED\n        >\n        <!ELEMENT b EMPTY>\n        \"\"\"))\n        self.assertFalse(dtd.validate(root))\n        self.assertTrue(dtd.error_log)\n        self.assertTrue([error for error in dtd.error_log\n                         if 'id1' in error.message])\n\n    def test_dtd_api_internal(self):\n        root = etree.XML(b'''\n        <!DOCTYPE b SYSTEM \"none\" [\n        <!ATTLIST a\n          attr1 (x | y | z) \"z\"\n          attr2 CDATA #FIXED \"X\"\n        >\n        <!ELEMENT b (a)>\n        <!ELEMENT a EMPTY>\n        ]>\n        <b><a/></b>\n        ''')\n        dtd = etree.ElementTree(root).docinfo.internalDTD\n        self.assertTrue(dtd)\n        dtd.assertValid(root)\n\n        seen = []\n        for el in dtd.iterelements():\n            if el.name == 'a':\n                self.assertEqual(2, len(el.attributes()))\n                for attr in el.iterattributes():\n                    if attr.name == 'attr1':\n                        self.assertEqual('enumeration', attr.type)\n                        self.assertEqual('none', attr.default)\n                        self.assertEqual('z', attr.default_value)\n                        values = attr.values()\n                        values.sort()\n                        self.assertEqual(['x', 'y', 'z'], values)\n                    else:\n                        self.assertEqual('attr2', attr.name)\n                        self.assertEqual('cdata', attr.type)\n                        self.assertEqual('fixed', attr.default)\n                        self.assertEqual('X', attr.default_value)\n            else:\n                self.assertEqual('b', el.name)\n                self.assertEqual(0, len(el.attributes()))\n            seen.append(el.name)\n        seen.sort()\n        self.assertEqual(['a', 'b'], seen)\n        self.assertEqual(2, len(dtd.elements()))\n\n    def test_internal_dtds(self):\n        for el_count in range(2, 5):\n            for attr_count in range(4):\n                root = etree.XML('''\n                <!DOCTYPE el0 SYSTEM \"none\" [\n                ''' + ''.join(['''\n                <!ATTLIST el%d\n                  attr%d (x | y | z) \"z\"\n                >\n                ''' % (e, a) for a in range(attr_count) for e in range(el_count)\n                ]) + ''.join(['''\n                <!ELEMENT el%d EMPTY>\n                ''' % e for e in range(1, el_count)\n                ]) + '''\n                ''' + '<!ELEMENT el0 (%s)>' % '|'.join([\n                    'el%d' % e for e in range(1, el_count)]) + '''\n                ]>\n                <el0><el1 %s /></el0>\n                ''' % ' '.join(['attr%d=\"x\"' % a for a in range(attr_count)]))\n                dtd = etree.ElementTree(root).docinfo.internalDTD\n                self.assertTrue(dtd)\n                dtd.assertValid(root)\n\n                e = -1\n                for e, el in enumerate(dtd.iterelements()):\n                    self.assertEqual(attr_count, len(el.attributes()))\n                    a = -1\n                    for a, attr in enumerate(el.iterattributes()):\n                        self.assertEqual('enumeration', attr.type)\n                        self.assertEqual('none', attr.default)\n                        self.assertEqual('z', attr.default_value)\n                        values = sorted(attr.values())\n                        self.assertEqual(['x', 'y', 'z'], values)\n                    self.assertEqual(attr_count - 1, a)\n                self.assertEqual(el_count - 1, e)\n                self.assertEqual(el_count, len(dtd.elements()))\n\n    def test_dtd_broken(self):\n        self.assertRaises(etree.DTDParseError, etree.DTD,\n                          BytesIO(b\"<!ELEMENT b HONKEY>\"))\n\n    def test_parse_file_dtd(self):\n        parser = etree.XMLParser(attribute_defaults=True)\n\n        tree = etree.parse(fileInTestDir('test.xml'), parser)\n        root = tree.getroot()\n\n        self.assertEqual(\n            \"valueA\",\n            root.get(\"default\"))\n        self.assertEqual(\n            \"valueB\",\n            root[0].get(\"default\"))\n\n    @skipIf(etree.LIBXML_VERSION == (2, 9, 0),\n            \"DTD loading is broken for incremental parsing in libxml2 2.9.0\")\n    def test_iterparse_file_dtd_start(self):\n        iterparse = etree.iterparse\n        iterator = iterparse(fileInTestDir(\"test.xml\"), events=('start',),\n                             attribute_defaults=True)\n        attributes = [ element.get(\"default\")\n                       for event, element in iterator ]\n        self.assertEqual(\n            [\"valueA\", \"valueB\"],\n            attributes)\n\n    @skipIf(etree.LIBXML_VERSION == (2, 9, 0),\n            \"DTD loading is broken for incremental parsing in libxml2 2.9.0\")\n    def test_iterparse_file_dtd_end(self):\n        iterparse = etree.iterparse\n        iterator = iterparse(fileInTestDir(\"test.xml\"), events=('end',),\n                             attribute_defaults=True)\n        attributes = [ element.get(\"default\")\n                       for event, element in iterator ]\n        self.assertEqual(\n            [\"valueB\", \"valueA\"],\n            attributes)\n\n    def test_dtd_attrs(self):\n        dtd = etree.DTD(fileUrlInTestDir(\"test.dtd\"))\n\n        # Test DTD.system_url attribute\n        self.assertTrue(dtd.system_url.endswith(\"test.dtd\"))\n\n        # Test elements and their attributes\n        a = dtd.elements()[0]\n        self.assertEqual(a.name, \"a\")\n        self.assertEqual(a.type, \"element\")\n        self.assertEqual(a.content.name, \"b\")\n        self.assertEqual(a.content.type, \"element\")\n        self.assertEqual(a.content.occur, \"once\")\n\n        aattr = a.attributes()[0]\n        self.assertEqual(aattr.name, \"default\")\n        self.assertEqual(aattr.type, \"enumeration\")\n        self.assertEqual(aattr.values(), [\"valueA\", \"valueB\"])\n        self.assertEqual(aattr.default_value, \"valueA\")\n\n        b = dtd.elements()[1]\n        self.assertEqual(b.name, \"b\")\n        self.assertEqual(b.type, \"empty\")\n        self.assertEqual(b.content, None)\n\n        # Test entities and their attributes\n        c = dtd.entities()[0]\n        self.assertEqual(c.name, \"c\")\n        self.assertEqual(c.orig, \"&#42;\")\n        self.assertEqual(c.content, \"*\")\n\n        # Test DTD.name attribute\n        root = etree.XML(b'''\n        <!DOCTYPE a SYSTEM \"none\" [\n        <!ELEMENT a EMPTY>\n        ]>\n        <a/>\n        ''')\n        dtd = etree.ElementTree(root).docinfo.internalDTD\n        self.assertEqual(dtd.name, \"a\")\n\n        # Test DTD.name and DTD.systemID attributes\n        parser = etree.XMLParser(dtd_validation=True)\n        xml = '<!DOCTYPE a SYSTEM \"test.dtd\"><a><b/></a>'\n        root = etree.fromstring(xml, parser=parser,\n                                base_url=fileUrlInTestDir(\"test.xml\"))\n\n        dtd = root.getroottree().docinfo.internalDTD\n        self.assertEqual(dtd.name, \"a\")\n        self.assertEqual(dtd.system_url, \"test.dtd\")\n\n    def test_declaration_escape_quote_pid(self):\n        # Standard allows quotes in systemliteral, but in that case\n        # systemliteral must be escaped with single quotes.\n        # See http://www.w3.org/TR/REC-xml/#sec-prolog-dtd.\n        root = etree.XML('''<!DOCTYPE a PUBLIC 'foo' '\"'><a/>''')\n        doc = root.getroottree()\n        self.assertEqual(doc.docinfo.doctype,\n                         '''<!DOCTYPE a PUBLIC \"foo\" '\"'>''')\n        self.assertEqual(etree.tostring(doc),\n                         b'''<!DOCTYPE a PUBLIC \"foo\" '\"'>\\n<a/>''')\n\n    def test_declaration_quote_withoutpid(self):\n        root = etree.XML('''<!DOCTYPE a SYSTEM '\"'><a/>''')\n        doc = root.getroottree()\n        self.assertEqual(doc.docinfo.doctype, '''<!DOCTYPE a SYSTEM '\"'>''')\n        self.assertEqual(etree.tostring(doc),\n                         b'''<!DOCTYPE a SYSTEM '\"'>\\n<a/>''')\n\n    def test_declaration_apos(self):\n        root = etree.XML('''<!DOCTYPE a SYSTEM \"'\"><a/>''')\n        doc = root.getroottree()\n        self.assertEqual(doc.docinfo.doctype, '''<!DOCTYPE a SYSTEM \"'\">''')\n        self.assertEqual(etree.tostring(doc),\n                         b'''<!DOCTYPE a SYSTEM \"'\">\\n<a/>''')\n\n    def test_ietf_decl(self):\n        html_data = (\n            '<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\\n'\n            '<html></html>')\n        root = etree.HTML(html_data)\n        doc = root.getroottree()\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//EN\">')\n        self.assertEqual(etree.tostring(doc, method='html'), html_data.encode('utf-8'))\n\n    def test_set_decl_public(self):\n        doc = etree.Element('test').getroottree()\n        doc.docinfo.public_id = 'bar'\n        doc.docinfo.system_url = 'baz'\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE test PUBLIC \"bar\" \"baz\">')\n        self.assertEqual(etree.tostring(doc),\n                         b'<!DOCTYPE test PUBLIC \"bar\" \"baz\">\\n<test/>')\n\n    def test_html_decl(self):\n        # Slightly different to one above: when we create an html element,\n        # we do not start with a blank slate.\n        doc = html.Element('html').getroottree()\n        doc.docinfo.public_id = 'bar'\n        doc.docinfo.system_url = 'baz'\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE html PUBLIC \"bar\" \"baz\">')\n        self.assertEqual(etree.tostring(doc),\n                         b'<!DOCTYPE html PUBLIC \"bar\" \"baz\">\\n<html/>')\n\n    def test_clean_doctype(self):\n        doc = html.Element('html').getroottree()\n        self.assertTrue(doc.docinfo.doctype != '')\n        doc.docinfo.clear()\n        self.assertTrue(doc.docinfo.doctype == '')\n\n    def test_set_decl_system(self):\n        doc = etree.Element('test').getroottree()\n        doc.docinfo.system_url = 'baz'\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE test SYSTEM \"baz\">')\n        self.assertEqual(etree.tostring(doc),\n                         b'<!DOCTYPE test SYSTEM \"baz\">\\n<test/>')\n\n    def test_empty_decl(self):\n        doc = etree.Element('test').getroottree()\n        doc.docinfo.public_id = None\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE test>')\n        self.assertTrue(doc.docinfo.public_id is None)\n        self.assertTrue(doc.docinfo.system_url is None)\n        self.assertEqual(etree.tostring(doc),\n                         b'<!DOCTYPE test>\\n<test/>')\n\n    def test_invalid_decl_1(self):\n        docinfo = etree.Element('test').getroottree().docinfo\n\n        def set_public_id(value):\n            docinfo.public_id = value\n        self.assertRaises(ValueError, set_public_id, '\u00e4')\n        self.assertRaises(ValueError, set_public_id, 'qwerty \u00e4 asdf')\n\n    def test_invalid_decl_2(self):\n        docinfo = etree.Element('test').getroottree().docinfo\n\n        def set_system_url(value):\n            docinfo.system_url = value\n        self.assertRaises(ValueError, set_system_url, '\\'\"')\n        self.assertRaises(ValueError, set_system_url, '\"\\'')\n        self.assertRaises(ValueError, set_system_url, '  \"  \\'  ')\n\n    def test_comment_before_dtd(self):\n        data = '<!--comment--><!DOCTYPE test>\\n<!-- --><test/>'\n        doc = etree.fromstring(data).getroottree()\n        self.assertEqual(etree.tostring(doc),\n                         data.encode('utf-8'))\n\n    def test_entity_system_url(self):\n        xml = etree.parse(BytesIO(b'<!DOCTYPE test [ <!ENTITY TestReference SYSTEM \"./foo.bar\"> ]><a/>'))\n        self.assertEqual(xml.docinfo.internalDTD.entities()[0].system_url, \"./foo.bar\")\n\n    def test_entity_system_url_none(self):\n        xml = etree.parse(BytesIO(b'<!DOCTYPE test [ <!ENTITY TestReference \"testvalue\"> ]><a/>'))\n        self.assertEqual(xml.docinfo.internalDTD.entities()[0].system_url, None)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeDtdTestCase)])\n    suite.addTests(\n        [make_doctest('validation.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_css.py": "import unittest\n\nimport lxml.html\n\nfrom .common_imports import doctest, HelperTestCase, skipif\n\ntry:\n    import cssselect\nexcept ImportError:\n    cssselect = None\n\n\nHTML = '''\n<div>\n  <a href=\"foo\">link</a>\n  <a>anchor</a>\n</div>\n'''\n\n\nclass CSSTestCase(HelperTestCase):\n\n    pytestmark = skipif('cssselect is None')\n\n    def test_cssselect(self):\n        div, = lxml.html.fromstring(HTML).xpath('//div')\n\n        def count(selector, expected_count, **kwargs):\n            result = div.cssselect(selector, **kwargs)\n            self.assertEqual(len(result), expected_count)\n\n        count('div', 1)\n        count('a', 2)\n        count('em', 0)\n        # Element names are case-insensitive in HTML\n        count('DIV', 1)\n        # ... but not in XHTML or XML\n        count('DIV', 0, translator='xhtml')\n        count('DIV', 0, translator='xml')\n\n        # :contains() is case-insensitive in lxml\n        count(':contains(\"link\")', 2)  # div, a\n        count(':contains(\"LInk\")', 2)\n        # Whatever the document language\n        count(':contains(\"LInk\")', 2, translator='xhtml')\n        count(':contains(\"LInk\")', 2, translator='xml')\n        # ... but not in upstream cssselect\n        import cssselect\n        count(':contains(\"link\")', 2, translator=cssselect.HTMLTranslator())\n        count(':contains(\"LInk\")', 0, translator=cssselect.HTMLTranslator())\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    try:\n        import cssselect\n    except ImportError:\n        # no 'cssselect' installed\n        print(\"Skipping tests in lxml.cssselect - external cssselect package is not installed\")\n        return suite\n\n    import lxml.cssselect\n    suite.addTests(doctest.DocTestSuite(lxml.cssselect))\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(CSSTestCase)])\n    return suite\n", "src/lxml/tests/test_objectify.py": "\"\"\"\nTests specific to the lxml.objectify API\n\"\"\"\n\n\nimport operator\nimport random\nimport unittest\n\nfrom .common_imports import (\n    etree, HelperTestCase, fileInTestDir, doctest, make_doctest, _bytes, _str, BytesIO\n)\n\nfrom lxml import objectify\n\nPYTYPE_NAMESPACE = \"http://codespeak.net/lxml/objectify/pytype\"\nXML_SCHEMA_NS = \"http://www.w3.org/2001/XMLSchema\"\nXML_SCHEMA_INSTANCE_NS = \"http://www.w3.org/2001/XMLSchema-instance\"\nXML_SCHEMA_INSTANCE_TYPE_ATTR = \"{%s}type\" % XML_SCHEMA_INSTANCE_NS\nXML_SCHEMA_NIL_ATTR = \"{%s}nil\" % XML_SCHEMA_INSTANCE_NS\nTREE_PYTYPE = \"TREE\"\nDEFAULT_NSMAP = { \"py\"  : PYTYPE_NAMESPACE,\n                  \"xsi\" : XML_SCHEMA_INSTANCE_NS,\n                  \"xsd\" : XML_SCHEMA_NS}\n\nobjectclass2xsitype = {\n    # objectify built-in\n    objectify.IntElement: (\"int\", \"short\", \"byte\", \"unsignedShort\",\n                           \"unsignedByte\", \"integer\", \"nonPositiveInteger\",\n                           \"negativeInteger\", \"long\", \"nonNegativeInteger\",\n                           \"unsignedLong\", \"unsignedInt\", \"positiveInteger\",),\n    objectify.FloatElement: (\"float\", \"double\"),\n    objectify.BoolElement: (\"boolean\",),\n    objectify.StringElement: (\"string\", \"normalizedString\", \"token\", \"language\",\n                              \"Name\", \"NCName\", \"ID\", \"IDREF\", \"ENTITY\",\n                              \"NMTOKEN\", ),\n    # None: xsi:nil=\"true\"\n    }\n\nxsitype2objclass = { v: k\n                     for k in objectclass2xsitype\n                     for v in objectclass2xsitype[k] }\n\nobjectclass2pytype = {\n    # objectify built-in\n    objectify.IntElement: \"int\",\n    objectify.FloatElement: \"float\",\n    objectify.BoolElement: \"bool\",\n    objectify.StringElement: \"str\",\n    # None: xsi:nil=\"true\"\n    }\n\npytype2objclass = { objectclass2pytype[k]: k\n                    for k in objectclass2pytype}\n\nxml_str = '''\\\n<obj:root xmlns:obj=\"objectified\" xmlns:other=\"otherNS\">\n  <obj:c1 a1=\"A1\" a2=\"A2\" other:a3=\"A3\">\n    <obj:c2>0</obj:c2>\n    <obj:c2>1</obj:c2>\n    <obj:c2>2</obj:c2>\n    <other:c2>3</other:c2>\n    <c2>4</c2>\n  </obj:c1>\n</obj:root>'''\n\nclass ObjectifyTestCase(HelperTestCase):\n    \"\"\"Test cases for lxml.objectify\n    \"\"\"\n    etree = etree\n    \n    def XML(self, xml):\n        return self.etree.XML(xml, self.parser)\n\n    def setUp(self):\n        super().setUp()\n        self.parser = self.etree.XMLParser(remove_blank_text=True)\n        self.lookup = etree.ElementNamespaceClassLookup(\n            objectify.ObjectifyElementClassLookup() )\n        self.parser.set_element_class_lookup(self.lookup)\n\n        self.Element = self.parser.makeelement\n\n        ns = self.lookup.get_namespace(\"otherNS\")\n        ns[None] = self.etree.ElementBase\n\n        self._orig_types = objectify.getRegisteredTypes()\n\n    def tearDown(self):\n        self.lookup.get_namespace(\"otherNS\").clear()\n        objectify.set_pytype_attribute_tag()\n        del self.lookup\n        del self.parser\n\n        for pytype in objectify.getRegisteredTypes():\n            pytype.unregister()\n        for pytype in self._orig_types:\n            pytype.register()\n        del self._orig_types\n\n        super().tearDown()\n\n\n    def test_element_nsmap_default(self):\n        elt = objectify.Element(\"test\")\n        self.assertEqual(elt.nsmap, DEFAULT_NSMAP)\n\n    def test_element_nsmap_empty(self):\n        nsmap = {}\n        elt = objectify.Element(\"test\", nsmap=nsmap)\n        self.assertEqual(list(elt.nsmap.values()), [PYTYPE_NAMESPACE])\n\n    def test_element_nsmap_custom_prefixes(self):\n        nsmap = {\"mypy\": PYTYPE_NAMESPACE,\n                 \"myxsi\": XML_SCHEMA_INSTANCE_NS,\n                 \"myxsd\": XML_SCHEMA_NS}\n        elt = objectify.Element(\"test\", nsmap=nsmap)\n        self.assertEqual(elt.nsmap, nsmap)\n        \n    def test_element_nsmap_custom(self):\n        nsmap = {\"my\": \"someNS\",\n                 \"myother\": \"someOtherNS\",\n                 \"myxsd\": XML_SCHEMA_NS}\n        elt = objectify.Element(\"test\", nsmap=nsmap)\n        self.assertTrue(PYTYPE_NAMESPACE in elt.nsmap.values())\n        for prefix, ns in nsmap.items():\n            self.assertTrue(prefix in elt.nsmap)\n            self.assertEqual(nsmap[prefix], elt.nsmap[prefix]) \n        \n    def test_sub_element_nsmap_default(self):\n        root = objectify.Element(\"root\")\n        root.sub = objectify.Element(\"test\")\n        self.assertEqual(root.sub.nsmap, DEFAULT_NSMAP)\n\n    def test_sub_element_nsmap_empty(self):\n        root = objectify.Element(\"root\")\n        nsmap = {}\n        root.sub = objectify.Element(\"test\", nsmap=nsmap)\n        self.assertEqual(root.sub.nsmap, DEFAULT_NSMAP)\n\n    def test_sub_element_nsmap_custom_prefixes(self):\n        root = objectify.Element(\"root\")\n        nsmap = {\"mypy\": PYTYPE_NAMESPACE,\n                 \"myxsi\": XML_SCHEMA_INSTANCE_NS,\n                 \"myxsd\": XML_SCHEMA_NS}\n        root.sub = objectify.Element(\"test\", nsmap=nsmap)\n        self.assertEqual(root.sub.nsmap, DEFAULT_NSMAP)\n        \n    def test_sub_element_nsmap_custom(self):\n        root = objectify.Element(\"root\")\n        nsmap = {\"my\": \"someNS\",\n                 \"myother\": \"someOtherNS\",\n                 \"myxsd\": XML_SCHEMA_NS,}\n        root.sub = objectify.Element(\"test\", nsmap=nsmap)\n        expected = nsmap.copy()\n        del expected[\"myxsd\"]\n        expected.update(DEFAULT_NSMAP)\n        self.assertEqual(root.sub.nsmap, expected) \n        \n    def test_data_element_nsmap_default(self):\n        value = objectify.DataElement(\"test this\")\n        self.assertEqual(value.nsmap, DEFAULT_NSMAP)\n\n    def test_data_element_nsmap_empty(self):\n        nsmap = {}\n        value = objectify.DataElement(\"test this\", nsmap=nsmap)\n        self.assertEqual(list(value.nsmap.values()), [PYTYPE_NAMESPACE])\n\n    def test_data_element_nsmap_custom_prefixes(self):\n        nsmap = {\"mypy\": PYTYPE_NAMESPACE,\n                 \"myxsi\": XML_SCHEMA_INSTANCE_NS,\n                 \"myxsd\": XML_SCHEMA_NS}\n        value = objectify.DataElement(\"test this\", nsmap=nsmap)\n        self.assertEqual(value.nsmap, nsmap)\n        \n    def test_data_element_nsmap_custom(self):\n        nsmap = {\"my\": \"someNS\",\n                 \"myother\": \"someOtherNS\",\n                 \"myxsd\": XML_SCHEMA_NS,}\n        value = objectify.DataElement(\"test\", nsmap=nsmap)\n        self.assertTrue(PYTYPE_NAMESPACE in value.nsmap.values())\n        for prefix, ns in nsmap.items():\n            self.assertTrue(prefix in value.nsmap)\n            self.assertEqual(nsmap[prefix], value.nsmap[prefix]) \n        \n    def test_sub_data_element_nsmap_default(self):\n        root = objectify.Element(\"root\")\n        root.value = objectify.DataElement(\"test this\")\n        self.assertEqual(root.value.nsmap, DEFAULT_NSMAP)\n\n    def test_sub_data_element_nsmap_empty(self):\n        root = objectify.Element(\"root\")\n        nsmap = {}\n        root.value = objectify.DataElement(\"test this\", nsmap=nsmap)\n        self.assertEqual(root.value.nsmap, DEFAULT_NSMAP)\n\n    def test_sub_data_element_nsmap_custom_prefixes(self):\n        root = objectify.Element(\"root\")\n        nsmap = {\"mypy\": PYTYPE_NAMESPACE,\n                 \"myxsi\": XML_SCHEMA_INSTANCE_NS,\n                 \"myxsd\": XML_SCHEMA_NS}\n        root.value = objectify.DataElement(\"test this\", nsmap=nsmap)\n        self.assertEqual(root.value.nsmap, DEFAULT_NSMAP)\n        \n    def test_sub_data_element_nsmap_custom(self):\n        root = objectify.Element(\"root\")\n        nsmap = {\"my\": \"someNS\",\n                 \"myother\": \"someOtherNS\",\n                 \"myxsd\": XML_SCHEMA_NS}\n        root.value = objectify.DataElement(\"test\", nsmap=nsmap)\n        expected = nsmap.copy()\n        del expected[\"myxsd\"]\n        expected.update(DEFAULT_NSMAP)\n        self.assertEqual(root.value.nsmap, expected)\n\n    def test_date_element_efactory_text(self):\n        # ObjectifiedDataElement can also be used as E-Factory\n        value = objectify.ObjectifiedDataElement('test', 'toast')\n        self.assertEqual(value.text, 'testtoast')\n\n    def test_date_element_efactory_tail(self):\n        # ObjectifiedDataElement can also be used as E-Factory\n        value = objectify.ObjectifiedElement(objectify.ObjectifiedDataElement(), 'test', 'toast')\n        self.assertEqual(value.ObjectifiedDataElement.tail, 'testtoast')\n\n    def test_data_element_attrib_attributes_precedence(self):\n        # keyword arguments override attrib entries\n        value = objectify.DataElement(23, _pytype=\"str\", _xsi=\"foobar\",\n                                      attrib={\"gnu\": \"muh\", \"cat\": \"meeow\",\n                                              \"dog\": \"wuff\"},\n                                      bird=\"tchilp\", dog=\"grrr\")\n        self.assertEqual(value.get(\"gnu\"), \"muh\")\n        self.assertEqual(value.get(\"cat\"), \"meeow\")\n        self.assertEqual(value.get(\"dog\"), \"grrr\")\n        self.assertEqual(value.get(\"bird\"), \"tchilp\")\n        \n    def test_data_element_data_element_arg(self):\n        # Check that DataElement preserves all attributes ObjectifiedDataElement\n        # arguments\n        arg = objectify.DataElement(23, _pytype=\"str\", _xsi=\"foobar\",\n                                    attrib={\"gnu\": \"muh\", \"cat\": \"meeow\",\n                                            \"dog\": \"wuff\"},\n                                    bird=\"tchilp\", dog=\"grrr\")\n        value = objectify.DataElement(arg)\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        for attr in arg.attrib:\n            self.assertEqual(value.get(attr), arg.get(attr))\n\n    def test_data_element_data_element_arg_pytype_none(self):\n        # Check that _pytype arg overrides original py:pytype of\n        # ObjectifiedDataElement\n        arg = objectify.DataElement(23, _pytype=\"str\", _xsi=\"foobar\",\n                                    attrib={\"gnu\": \"muh\", \"cat\": \"meeow\",\n                                            \"dog\": \"wuff\"},\n                                    bird=\"tchilp\", dog=\"grrr\")\n        value = objectify.DataElement(arg, _pytype=\"NoneType\")\n        self.assertTrue(isinstance(value, objectify.NoneElement))\n        self.assertEqual(value.get(XML_SCHEMA_NIL_ATTR), \"true\")\n        self.assertEqual(value.text, None)\n        self.assertEqual(value.pyval, None)\n        for attr in arg.attrib:\n            #if not attr == objectify.PYTYPE_ATTRIBUTE:\n            self.assertEqual(value.get(attr), arg.get(attr))\n\n    def test_data_element_data_element_arg_pytype(self):\n        # Check that _pytype arg overrides original py:pytype of\n        # ObjectifiedDataElement\n        arg = objectify.DataElement(23, _pytype=\"str\", _xsi=\"foobar\",\n                                    attrib={\"gnu\": \"muh\", \"cat\": \"meeow\",\n                                            \"dog\": \"wuff\"},\n                                    bird=\"tchilp\", dog=\"grrr\")\n        value = objectify.DataElement(arg, _pytype=\"int\")\n        self.assertTrue(isinstance(value, objectify.IntElement))\n        self.assertEqual(value.get(objectify.PYTYPE_ATTRIBUTE), \"int\")\n        for attr in arg.attrib:\n            if not attr == objectify.PYTYPE_ATTRIBUTE:\n                self.assertEqual(value.get(attr), arg.get(attr))\n\n    def test_data_element_data_element_arg_xsitype(self):\n        # Check that _xsi arg overrides original xsi:type of given\n        # ObjectifiedDataElement\n        arg = objectify.DataElement(23, _pytype=\"str\", _xsi=\"foobar\",\n                                    attrib={\"gnu\": \"muh\", \"cat\": \"meeow\",\n                                            \"dog\": \"wuff\"},\n                                    bird=\"tchilp\", dog=\"grrr\")\n        value = objectify.DataElement(arg, _xsi=\"xsd:int\")\n        self.assertTrue(isinstance(value, objectify.IntElement))\n        self.assertEqual(value.get(XML_SCHEMA_INSTANCE_TYPE_ATTR), \"xsd:int\")\n        self.assertEqual(value.get(objectify.PYTYPE_ATTRIBUTE), \"int\")\n        for attr in arg.attrib:\n            if not attr in [objectify.PYTYPE_ATTRIBUTE,\n                            XML_SCHEMA_INSTANCE_TYPE_ATTR]:\n                self.assertEqual(value.get(attr), arg.get(attr))\n\n    def test_data_element_data_element_arg_pytype_xsitype(self):\n        # Check that _pytype and _xsi args override original py:pytype and\n        # xsi:type attributes of given ObjectifiedDataElement\n        arg = objectify.DataElement(23, _pytype=\"str\", _xsi=\"foobar\",\n                                    attrib={\"gnu\": \"muh\", \"cat\": \"meeow\",\n                                            \"dog\": \"wuff\"},\n                                    bird=\"tchilp\", dog=\"grrr\")\n        value = objectify.DataElement(arg, _pytype=\"int\", _xsi=\"xsd:int\")\n        self.assertTrue(isinstance(value, objectify.IntElement))\n        self.assertEqual(value.get(objectify.PYTYPE_ATTRIBUTE), \"int\")\n        self.assertEqual(value.get(XML_SCHEMA_INSTANCE_TYPE_ATTR), \"xsd:int\")\n        for attr in arg.attrib:\n            if not attr in [objectify.PYTYPE_ATTRIBUTE,\n                            XML_SCHEMA_INSTANCE_TYPE_ATTR]:\n                self.assertEqual(value.get(attr), arg.get(attr))\n\n    def test_data_element_invalid_pytype(self):\n        self.assertRaises(ValueError, objectify.DataElement, 3.1415,\n                          _pytype=\"int\")\n\n    def test_data_element_invalid_xsi(self):\n        self.assertRaises(ValueError, objectify.DataElement, 3.1415,\n                          _xsi=\"xsd:int\")\n        \n    def test_data_element_data_element_arg_invalid_pytype(self):\n        arg = objectify.DataElement(3.1415)\n        self.assertRaises(ValueError, objectify.DataElement, arg,\n                          _pytype=\"int\")\n\n    def test_data_element_data_element_arg_invalid_xsi(self):\n        arg = objectify.DataElement(3.1415)\n        self.assertRaises(ValueError, objectify.DataElement, arg,\n                          _xsi=\"xsd:int\")\n\n    def test_data_element_element_arg(self):\n        arg = objectify.Element('arg')\n        value = objectify.DataElement(arg)\n        self.assertTrue(isinstance(value, objectify.ObjectifiedElement))\n        for attr in arg.attrib:\n            self.assertEqual(value.get(attr), arg.get(attr))\n        \n    def test_root(self):\n        root = self.Element(\"test\")\n        self.assertTrue(isinstance(root, objectify.ObjectifiedElement))\n\n    def test_str(self):\n        root = self.Element(\"test\")\n        self.assertEqual('', str(root))\n\n    def test_child(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\"0\", root.c1.c2.text)\n\n    def test_child_ns_nons(self):\n        root = self.XML(\"\"\"\n            <root>\n                <foo:x xmlns:foo=\"/foo/bar\">1</foo:x>\n                <x>2</x>\n            </root>\n        \"\"\")\n        self.assertEqual(2, root.x)\n\n    def test_countchildren(self):\n        root = self.XML(xml_str)\n        self.assertEqual(1, root.countchildren())\n        self.assertEqual(5, root.c1.countchildren())\n\n    def test_child_getattr(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\"0\", getattr(root.c1, \"{objectified}c2\").text)\n        self.assertEqual(\"3\", getattr(root.c1, \"{otherNS}c2\").text)\n\n    def test_child_nonexistant(self):\n        root = self.XML(xml_str)\n        self.assertRaises(AttributeError, getattr, root.c1, \"NOT_THERE\")\n        self.assertRaises(AttributeError, getattr, root.c1, \"{unknownNS}c2\")\n\n    def test_child_special(self):\n        root = self.XML(xml_str)\n        self.assertEqual(objectify.ObjectifiedElement, root.c1.__class__)\n        self.assertTrue(callable(root.c1.__str__))\n        self.assertTrue(callable(root.c1.__len__))\n        self.assertTrue(callable(root.c1.__getattr__))\n\n    def test_child_getattr_empty_ns(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\"4\", getattr(root.c1, \"{}c2\").text)\n        self.assertEqual(\"0\", getattr(root.c1, \"c2\").text)\n\n    def test_setattr(self):\n        for val in [\n            2, 2**32, 1.2, \"Won't get fooled again\", \n            _str(\"W\\xf6n't get f\\xf6\\xf6led \\xe4g\\xe4in\", 'ISO-8859-1'), True,\n            False, None]: \n            root = self.Element('root')\n            attrname = 'val'\n            setattr(root, attrname, val)\n            result = getattr(root, attrname)\n            self.assertEqual(val, result)\n            self.assertEqual(type(val), type(result.pyval))\n \n    def test_setattr_nonunicode(self):\n        root = self.Element('root')\n        attrname = 'val'\n        val = bytes(\"W\\xf6n't get f\\xf6\\xf6led \\xe4g\\xe4in\", 'ISO-8859-1')\n        self.assertRaises(ValueError, setattr, root, attrname, val)\n        self.assertRaises(AttributeError, getattr, root, attrname) \n \n    def test_addattr(self):\n        root = self.XML(xml_str)\n        self.assertEqual(1, len(root.c1))\n        root.addattr(\"c1\", \"test\")\n        self.assertEqual(2, len(root.c1))\n        self.assertEqual(\"test\", root.c1[1].text)\n\n    def test_addattr_element(self):\n        root = self.XML(xml_str)\n        self.assertEqual(1, len(root.c1))\n\n        new_el = self.Element(\"test\", myattr=\"5\")\n        root.addattr(\"c1\", new_el)\n        self.assertEqual(2, len(root.c1))\n        self.assertEqual(None, root.c1[0].get(\"myattr\"))\n        self.assertEqual(\"5\",  root.c1[1].get(\"myattr\"))\n\n    def test_addattr_list(self):\n        root = self.XML(xml_str)\n        self.assertEqual(1, len(root.c1))\n\n        new_el = self.Element(\"test\")\n        self.etree.SubElement(new_el, \"a\", myattr=\"A\")\n        self.etree.SubElement(new_el, \"a\", myattr=\"B\")\n\n        root.addattr(\"c1\", list(new_el.a))\n        self.assertEqual(3, len(root.c1))\n        self.assertEqual(None, root.c1[0].get(\"myattr\"))\n        self.assertEqual(\"A\",  root.c1[1].get(\"myattr\"))\n        self.assertEqual(\"B\",  root.c1[2].get(\"myattr\"))\n\n    def test_child_addattr(self):\n        root = self.XML(xml_str)\n        self.assertEqual(3, len(root.c1.c2))\n        root.c1.addattr(\"c2\", 3)\n        self.assertEqual(4, len(root.c1.c2))\n        self.assertEqual(\"3\", root.c1.c2[3].text)\n\n    def test_child_index(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\"0\", root.c1.c2[0].text)\n        self.assertEqual(\"1\", root.c1.c2[1].text)\n        self.assertEqual(\"2\", root.c1.c2[2].text)\n        self.assertRaises(IndexError, operator.getitem, root.c1.c2, 3)\n        self.assertEqual(root, root[0])\n        self.assertRaises(IndexError, operator.getitem, root, 1)\n\n        c1 = root.c1\n        del root.c1  # unlink from parent\n        self.assertEqual(c1, c1[0])\n        self.assertRaises(IndexError, operator.getitem, c1, 1)\n\n    def test_child_index_neg(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\"0\", root.c1.c2[0].text)\n        self.assertEqual(\"0\", root.c1.c2[-3].text)\n        self.assertEqual(\"1\", root.c1.c2[-2].text)\n        self.assertEqual(\"2\", root.c1.c2[-1].text)\n        self.assertRaises(IndexError, operator.getitem, root.c1.c2, -4)\n        self.assertEqual(root, root[-1])\n        self.assertRaises(IndexError, operator.getitem, root, -2)\n\n        c1 = root.c1\n        del root.c1  # unlink from parent\n        self.assertEqual(c1, c1[-1])\n        self.assertRaises(IndexError, operator.getitem, c1, -2)\n\n    def test_child_len(self):\n        root = self.XML(xml_str)\n        self.assertEqual(1, len(root))\n        self.assertEqual(1, len(root.c1))\n        self.assertEqual(3, len(root.c1.c2))\n\n    def test_child_iter(self):\n        root = self.XML(xml_str)\n        self.assertEqual([root],\n                          list(iter(root)))\n        self.assertEqual([root.c1],\n                          list(iter(root.c1)))\n        self.assertEqual([root.c1.c2[0], root.c1.c2[1], root.c1.c2[2]],\n                         list(iter(root.c1.c2)))\n\n    def test_class_lookup(self):\n        root = self.XML(xml_str)\n        self.assertTrue(isinstance(root.c1.c2, objectify.ObjectifiedElement))\n        self.assertFalse(isinstance(getattr(root.c1, \"{otherNS}c2\"),\n                                    objectify.ObjectifiedElement))\n\n    def test_dir(self):\n        root = self.XML(xml_str)\n        dir_c1 = dir(objectify.ObjectifiedElement) + ['c1']\n        dir_c1.sort()\n        dir_c2 = dir(objectify.ObjectifiedElement) + ['c2']\n        dir_c2.sort()\n\n        self.assertEqual(dir_c1, dir(root))\n        self.assertEqual(dir_c2, dir(root.c1))\n\n    def test_vars(self):\n        root = self.XML(xml_str)\n        self.assertEqual({'c1' : root.c1},    vars(root))\n        self.assertEqual({'c2' : root.c1.c2}, vars(root.c1))\n\n    def test_child_set_ro(self):\n        root = self.XML(xml_str)\n        self.assertRaises(TypeError, setattr, root.c1.c2, 'text',  \"test\")\n        self.assertRaises(TypeError, setattr, root.c1.c2, 'pyval', \"test\")\n\n    # slicing\n\n    def test_getslice_complete(self):\n        root = self.XML(\"<root><c>c1</c><c>c2</c></root>\")\n        self.assertEqual([\"c1\", \"c2\"],\n                          [ c.text for c in root.c[:] ])\n\n    def test_getslice_partial(self):\n        root = self.XML(\"<root><c>c1</c><c>c2</c><c>c3</c><c>c4</c></root>\")\n        test_list = [\"c1\", \"c2\", \"c3\", \"c4\"]\n\n        self.assertEqual(test_list,\n                          [ c.text for c in root.c[:] ])\n        self.assertEqual(test_list[1:2],\n                          [ c.text for c in root.c[1:2] ])\n        self.assertEqual(test_list[-3:-1],\n                          [ c.text for c in root.c[-3:-1] ])\n        self.assertEqual(test_list[-3:3],\n                          [ c.text for c in root.c[-3:3] ])\n        self.assertEqual(test_list[-3000:3],\n                          [ c.text for c in root.c[-3000:3] ])\n        self.assertEqual(test_list[-3:3000],\n                          [ c.text for c in root.c[-3:3000] ])\n\n    def test_getslice_partial_neg(self):\n        root = self.XML(\"<root><c>c1</c><c>c2</c><c>c3</c><c>c4</c></root>\")\n        test_list = [\"c1\", \"c2\", \"c3\", \"c4\"]\n\n        self.assertEqual(test_list,\n                          [ c.text for c in root.c[:] ])\n        self.assertEqual(test_list[2:1:-1],\n                          [ c.text for c in root.c[2:1:-1] ])\n        self.assertEqual(test_list[-1:-3:-1],\n                          [ c.text for c in root.c[-1:-3:-1] ])\n        self.assertEqual(test_list[2:-3:-1],\n                          [ c.text for c in root.c[2:-3:-1] ])\n        self.assertEqual(test_list[2:-3000:-1],\n                          [ c.text for c in root.c[2:-3000:-1] ])\n\n    # slice assignment\n\n    def test_setslice_complete(self):\n        Element = self.Element\n        root = Element(\"root\")\n        root.c = [\"c1\", \"c2\"]\n\n        c1 = root.c[0]\n        c2 = root.c[1]\n\n        self.assertEqual([c1,c2], list(root.c))\n        self.assertEqual([\"c1\", \"c2\"],\n                          [ c.text for c in root.c ])\n\n    def test_setslice_elements(self):\n        Element = self.Element\n        root = Element(\"root\")\n        root.c = [\"c1\", \"c2\"]\n\n        c1 = root.c[0]\n        c2 = root.c[1]\n\n        self.assertEqual([c1,c2], list(root.c))\n        self.assertEqual([\"c1\", \"c2\"],\n                          [ c.text for c in root.c ])\n\n        root2 = Element(\"root2\")\n        root2.el = [ \"test\", \"test\" ]\n        self.assertEqual([\"test\", \"test\"],\n                          [ el.text for el in root2.el ])\n\n        root.c = [ root2.el, root2.el ]\n        self.assertEqual([\"test\", \"test\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual([\"test\", \"test\"],\n                          [ el.text for el in root2.el ])\n\n        root.c[:] = [ c1, c2, c2, c1 ]\n        self.assertEqual([\"c1\", \"c2\", \"c2\", \"c1\"],\n                          [ c.text for c in root.c ])\n\n    def test_setslice_partial(self):\n        Element = self.Element\n        root = Element(\"root\")\n        l = [\"c1\", \"c2\", \"c3\", \"c4\"]\n        root.c = l\n\n        self.assertEqual([\"c1\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n        new_slice = [\"cA\", \"cB\"]\n        l[1:2] = new_slice\n        root.c[1:2] = new_slice\n\n        self.assertEqual([\"c1\", \"cA\", \"cB\", \"c3\", \"c4\"], l)\n        self.assertEqual([\"c1\", \"cA\", \"cB\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n    def test_setslice_insert(self):\n        Element = self.Element\n        root = Element(\"root\")\n        l = [\"c1\", \"c2\", \"c3\", \"c4\"]\n        root.c = l\n\n        self.assertEqual([\"c1\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n        new_slice = [\"cA\", \"cB\"]\n        l[1:1] = new_slice\n        root.c[1:1] = new_slice\n\n        self.assertEqual([\"c1\", \"cA\", \"cB\", \"c2\", \"c3\", \"c4\"], l)\n        self.assertEqual([\"c1\", \"cA\", \"cB\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n    def test_setslice_insert_neg(self):\n        Element = self.Element\n        root = Element(\"root\")\n        l = [\"c1\", \"c2\", \"c3\", \"c4\"]\n        root.c = l\n\n        self.assertEqual([\"c1\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n        new_slice = [\"cA\", \"cB\"]\n        l[-2:-2] = new_slice\n        root.c[-2:-2] = new_slice\n\n        self.assertEqual([\"c1\", \"c2\", \"cA\", \"cB\", \"c3\", \"c4\"], l)\n        self.assertEqual([\"c1\", \"c2\", \"cA\", \"cB\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n    def test_setslice_empty(self):\n        Element = self.Element\n        root = Element(\"root\")\n\n        root.c = []\n        self.assertRaises(\n            AttributeError, getattr, root, 'c')\n\n    def test_setslice_partial_wrong_length(self):\n        Element = self.Element\n        root = Element(\"root\")\n        l = [\"c1\", \"c2\", \"c3\", \"c4\"]\n        root.c = l\n\n        self.assertEqual([\"c1\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n        new_slice = [\"cA\", \"cB\", \"cC\"]\n        self.assertRaises(\n            ValueError, operator.setitem,\n            l, slice(1,2,-1), new_slice)\n        self.assertRaises(\n            ValueError, operator.setitem,\n            root.c, slice(1,2,-1), new_slice)\n\n    def test_setslice_partial_neg(self):\n        Element = self.Element\n        root = Element(\"root\")\n        l = [\"c1\", \"c2\", \"c3\", \"c4\"]\n        root.c = l\n\n        self.assertEqual([\"c1\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n        new_slice = [\"cA\", \"cB\"]\n        l[-1:1:-1] = new_slice\n        root.c[-1:1:-1] = new_slice\n\n        self.assertEqual([\"c1\", \"c2\", \"cB\", \"cA\"], l)\n        self.assertEqual([\"c1\", \"c2\", \"cB\", \"cA\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n    def test_setslice_partial_allneg(self):\n        Element = self.Element\n        root = Element(\"root\")\n        l = [\"c1\", \"c2\", \"c3\", \"c4\"]\n        root.c = l\n\n        self.assertEqual([\"c1\", \"c2\", \"c3\", \"c4\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n        new_slice = [\"cA\", \"cB\"]\n        l[-1:-4:-2] = new_slice\n        root.c[-1:-4:-2] = new_slice\n\n        self.assertEqual([\"c1\", \"cB\", \"c3\", \"cA\"], l)\n        self.assertEqual([\"c1\", \"cB\", \"c3\", \"cA\"],\n                          [ c.text for c in root.c ])\n        self.assertEqual(l,\n                          [ c.text for c in root.c ])\n\n    # other stuff\n\n    def test_setitem_index(self):\n        Element = self.Element\n        root = Element(\"root\")\n        root['child'] = ['CHILD1', 'CHILD2']\n        self.assertEqual([\"CHILD1\", \"CHILD2\"],\n                          [ c.text for c in root.child ])\n\n        self.assertRaises(IndexError, operator.setitem, root.child, -3, 'oob')\n        self.assertRaises(IndexError, operator.setitem, root.child, -300, 'oob')\n        self.assertRaises(IndexError, operator.setitem, root.child, 2, 'oob')\n        self.assertRaises(IndexError, operator.setitem, root.child, 200, 'oob')\n\n        root.child[0] = \"child0\"\n        root.child[-1] = \"child-1\"\n        self.assertEqual([\"child0\", \"child-1\"],\n                          [ c.text for c in root.child ])\n\n        root.child[1] = \"child1\"\n        root.child[-2] = \"child-2\"\n        self.assertEqual([\"child-2\", \"child1\"],\n                          [ c.text for c in root.child ])\n\n    def test_delitem_index(self):\n        # make sure strings are set as children\n        Element = self.Element\n        root = Element(\"root\")\n        root['child'] = ['CHILD1', 'CHILD2', 'CHILD3', 'CHILD4']\n        self.assertEqual([\"CHILD1\", \"CHILD2\", \"CHILD3\", \"CHILD4\"],\n                          [ c.text for c in root.child ])\n\n        del root.child[-1]\n        self.assertEqual([\"CHILD1\", \"CHILD2\", \"CHILD3\"],\n                          [ c.text for c in root.child ])\n        del root.child[-2]\n        self.assertEqual([\"CHILD1\", \"CHILD3\"],\n                          [ c.text for c in root.child ])\n        del root.child[0]\n        self.assertEqual([\"CHILD3\"],\n                          [ c.text for c in root.child ])\n        del root.child[-1]\n        self.assertRaises(AttributeError, getattr, root, 'child')\n\n    def test_set_string(self):\n        # make sure strings are not handled as sequences\n        Element = self.Element\n        root = Element(\"root\")\n        root.c = \"TEST\"\n        self.assertEqual([\"TEST\"],\n                          [ c.text for c in root.c ])\n\n    def test_setitem_string(self):\n        # make sure strings are set as children\n        Element = self.Element\n        root = Element(\"root\")\n        root[\"c\"] = \"TEST\"\n        self.assertEqual([\"TEST\"],\n                          [ c.text for c in root.c ])\n\n    def test_setitem_string_special(self):\n        # make sure 'text' etc. are set as children\n        Element = self.Element\n        root = Element(\"root\")\n\n        root[\"text\"] = \"TEST\"\n        self.assertEqual([\"TEST\"],\n                          [ c.text for c in root[\"text\"] ])\n\n        root[\"tail\"] = \"TEST\"\n        self.assertEqual([\"TEST\"],\n                          [ c.text for c in root[\"tail\"] ])\n\n        root[\"pyval\"] = \"TEST\"\n        self.assertEqual([\"TEST\"],\n                          [ c.text for c in root[\"pyval\"] ])\n\n        root[\"tag\"] = \"TEST\"\n        self.assertEqual([\"TEST\"],\n                          [ c.text for c in root[\"tag\"] ])\n\n    def test_findall(self):\n        XML = self.XML\n        root = XML('<a><b><c/></b><b/><c><b/></c></a>')\n        self.assertEqual(1, len(root.findall(\"c\")))\n        self.assertEqual(2, len(root.findall(\".//c\")))\n        self.assertEqual(3, len(root.findall(\".//b\")))\n        self.assertTrue(root.findall(\".//b\")[1] is root.getchildren()[1])\n\n    def test_findall_ns(self):\n        XML = self.XML\n        root = XML('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')\n        self.assertEqual(2, len(root.findall(\".//{X}b\")))\n        self.assertEqual(3, len(root.findall(\".//b\")))\n        self.assertEqual(2, len(root.findall(\"b\")))\n\n    def test_build_tree(self):\n        root = self.Element('root')\n        root.a = 5\n        root.b = 6\n        self.assertTrue(isinstance(root, objectify.ObjectifiedElement))\n        self.assertTrue(isinstance(root.a, objectify.IntElement))\n        self.assertTrue(isinstance(root.b, objectify.IntElement))\n\n    def test_type_NoneType(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n\n        nil_attr = XML_SCHEMA_NIL_ATTR\n        root = Element(\"{objectified}root\")\n        SubElement(root, \"{objectified}none\")\n        SubElement(root, \"{objectified}none\", {nil_attr : \"true\"})\n        self.assertFalse(isinstance(root.none, objectify.NoneElement))\n        self.assertFalse(isinstance(root.none[0], objectify.NoneElement))\n        self.assertTrue(isinstance(root.none[1], objectify.NoneElement))\n        self.assertEqual(hash(root.none[1]), hash(None))\n        self.assertEqual(root.none[1], None)\n        self.assertFalse(root.none[1])\n\n    def test_data_element_NoneType(self):\n        value = objectify.DataElement(None)\n        self.assertTrue(isinstance(value, objectify.NoneElement))\n        self.assertEqual(value, None)\n        self.assertEqual(value.get(XML_SCHEMA_NIL_ATTR), \"true\")\n\n    def test_type_bool(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.bool = True\n        self.assertEqual(root.bool, True)\n        self.assertEqual(root.bool + root.bool, True + True)\n        self.assertEqual(True + root.bool, True + root.bool)\n        self.assertEqual(root.bool * root.bool, True * True)\n        self.assertEqual(int(root.bool), int(True))\n        self.assertEqual(hash(root.bool), hash(True))\n        self.assertEqual(complex(root.bool), complex(True))\n        self.assertTrue(isinstance(root.bool, objectify.BoolElement))\n\n        root.bool = False\n        self.assertEqual(root.bool, False)\n        self.assertEqual(root.bool + root.bool, False + False)\n        self.assertEqual(False + root.bool, False + root.bool)\n        self.assertEqual(root.bool * root.bool, False * False)\n        self.assertEqual(int(root.bool), int(False))\n        self.assertEqual(hash(root.bool), hash(False))\n        self.assertEqual(complex(root.bool), complex(False))\n        self.assertTrue(isinstance(root.bool, objectify.BoolElement))\n\n    def test_data_element_bool(self):\n        value = objectify.DataElement(True)\n        self.assertTrue(isinstance(value, objectify.BoolElement))\n        self.assertEqual(value, True)\n\n        value = objectify.DataElement(False)\n        self.assertTrue(isinstance(value, objectify.BoolElement))\n        self.assertEqual(value, False)\n\n    def test_data_element_bool_text(self):\n        self.assertEqual(objectify.DataElement(False).text, \"false\")\n        self.assertEqual(objectify.DataElement(True).text, \"true\")\n\n    def test_type_str(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = \"test\"\n        self.assertTrue(isinstance(root.s, objectify.StringElement))\n\n    def test_type_str_intliteral(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = \"3\"\n        self.assertTrue(isinstance(root.s, objectify.StringElement))\n\n    def test_type_str_floatliteral(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = \"3.72\"\n        self.assertTrue(isinstance(root.s, objectify.StringElement))\n\n    def test_type_str_mul(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = \"test\"\n\n        self.assertEqual(\"test\" * 5, root.s * 5)\n        self.assertEqual(5 * \"test\", 5 * root.s)\n\n        self.assertRaises(TypeError, operator.mul, root.s, \"honk\")\n        self.assertRaises(TypeError, operator.mul, \"honk\", root.s)\n\n    def test_type_str_add(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = \"test\"\n\n        s = \"toast\"\n        self.assertEqual(\"test\" + s, root.s + s)\n        self.assertEqual(s + \"test\", s + root.s)\n            \n    def test_type_str_mod(self):\n        s = \"%d %f %s %r\"\n        el = objectify.DataElement(s)\n        values = (1, 7.0, \"abcd\", None)\n        self.assertEqual(s % values, el % values)\n\n        s = \"%d\"\n        el = objectify.DataElement(s)\n        val = 5\n        self.assertEqual(s % val, el % val)\n\n        s = \"%d %s\"\n        el = objectify.DataElement(s)\n        val = 5\n        self.assertRaises(TypeError, el.__mod__, val)\n\n        s = \"\"\n        el = objectify.DataElement(s)\n        val = 5\n        self.assertRaises(TypeError, el.__mod__, val)\n\n    def test_type_str_hash(self):\n        v = \"1\"\n        el = objectify.DataElement(v)\n        self.assertEqual(hash(el), hash(\"1\"))\n\n    def test_type_str_as_int(self):\n        v = \"1\"\n        el = objectify.DataElement(v)\n        self.assertEqual(int(el), 1)\n            \n    def test_type_str_as_float(self):\n        v = \"1\"\n        el = objectify.DataElement(v)\n        self.assertEqual(float(el), 1)\n\n    def test_type_str_as_complex(self):\n        v = \"1\"\n        el = objectify.DataElement(v)\n        self.assertEqual(complex(el), 1)\n            \n    def test_type_str_mod_data_elements(self):\n        s = \"%d %f %s %r\"\n        el = objectify.DataElement(s)\n        values = (objectify.DataElement(1),\n                  objectify.DataElement(7.0),\n                  objectify.DataElement(\"abcd\"),\n                  objectify.DataElement(None))\n        self.assertEqual(s % values, el % values)\n\n    def test_data_element_str(self):\n        value = objectify.DataElement(\"test\")\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        self.assertEqual(value, \"test\")\n\n    def test_data_element_str_intliteral(self):\n        value = objectify.DataElement(\"3\")\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        self.assertEqual(value, \"3\")\n\n    def test_data_element_str_floatliteral(self):\n        value = objectify.DataElement(\"3.20\")\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        self.assertEqual(value, \"3.20\")\n\n    def test_type_ustr(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = _str(\"test\")\n        self.assertTrue(isinstance(root.s, objectify.StringElement))\n\n    def test_type_ustr_intliteral(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = _str(\"3\")\n        self.assertTrue(isinstance(root.s, objectify.StringElement))\n\n    def test_type_ustr_floatliteral(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = _str(\"3.72\")\n        self.assertTrue(isinstance(root.s, objectify.StringElement))\n\n    def test_type_ustr_mul(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = _str(\"test\")\n\n        self.assertEqual(_str(\"test\") * 5, root.s * 5)\n        self.assertEqual(5 * _str(\"test\"), 5 * root.s)\n\n        self.assertRaises(TypeError, operator.mul, root.s, _str(\"honk\"))\n        self.assertRaises(TypeError, operator.mul, _str(\"honk\"), root.s)\n\n    def test_type_ustr_add(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.s = _str(\"test\")\n\n        s = _str(\"toast\")\n        self.assertEqual(_str(\"test\") + s, root.s + s)\n        self.assertEqual(s + _str(\"test\"), s + root.s)\n\n    def test_data_element_ustr(self):\n        value = objectify.DataElement(_str(\"test\"))\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        self.assertEqual(value, _str(\"test\"))\n\n    def test_data_element_ustr_intliteral(self):\n        value = objectify.DataElement(\"3\")\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        self.assertEqual(value, _str(\"3\"))\n\n    def test_data_element_ustr_floatliteral(self):\n        value = objectify.DataElement(_str(\"3.20\"))\n        self.assertTrue(isinstance(value, objectify.StringElement))\n        self.assertEqual(value, _str(\"3.20\"))\n\n    def test_type_int(self):\n        Element = self.Element\n        root = Element(\"{objectified}root\")\n        root.none = 5\n        self.assertTrue(isinstance(root.none, objectify.IntElement))\n        self.assertEqual(5, root.none.__index__())\n\n    def test_data_element_int(self):\n        value = objectify.DataElement(5)\n        self.assertTrue(isinstance(value, objectify.IntElement))\n        self.assertEqual(value, 5)\n\n    def test_data_element_int_hash(self):\n        value = objectify.DataElement(123)\n        self.assertEqual(hash(value), hash(123))\n\n    def test_type_float(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        root = Element(\"{objectified}root\")\n        root.none = 5.5\n        self.assertTrue(isinstance(root.none, objectify.FloatElement))\n\n    def test_data_element_float(self):\n        value = objectify.DataElement(5.5)\n        self.assertTrue(isinstance(value, objectify.FloatElement))\n        self.assertEqual(value, 5.5)\n\n    def test_data_element_float_hash(self):\n        value = objectify.DataElement(5.5)\n        self.assertEqual(hash(value), hash(5.5))\n\n    def test_type_float_precision(self):\n        # test not losing precision by shortened float str() value\n        # repr(2.305064300557): '2.305064300557'\n        # str(2.305064300557): '2.30506430056'\n        # \"%57.54f\" % 2.305064300557:\n        #     ' 2.305064300556999956626214043353684246540069580078125000'\n        Element = self.Element\n        root = Element(\"{objectified}root\")\n        s = \"2.305064300557\"\n        root.f = float(s)\n        self.assertTrue(isinstance(root.f, objectify.FloatElement))\n        self.assertEqual(root.f.text, s)\n        self.assertEqual(root.f.pyval, float(s))\n\n    def test_type_float_instantiation_precision(self):\n        # test precision preservation for FloatElement instantiation\n        s = \"2.305064300557\"\n        self.assertEqual(objectify.FloatElement(s), float(s))\n  \n    def test_type_float_precision_consistency(self):\n        # test consistent FloatElement values for the different instantiation\n        # possibilities\n        Element = self.Element\n        root = Element(\"{objectified}root\")\n        s = \"2.305064300557\"\n        f = float(s)\n        float_elem = objectify.FloatElement(s)\n        float_data_elem = objectify.DataElement(f)\n        root.float_child = float(f)\n        self.assertTrue(f == float_elem == float_data_elem == root.float_child)\n\n    def test_data_element_float_precision(self):\n        # test not losing precision by shortened float str() value\n        f = 2305064300557.0\n        value = objectify.DataElement(f)\n        self.assertTrue(isinstance(value, objectify.FloatElement))\n        self.assertEqual(value, f)\n\n    def test_data_element_float_hash_repr(self):\n        # test not losing precision by shortened float str() value\n        f = 2305064300557.0\n        value = objectify.DataElement(f)\n        self.assertEqual(hash(value), hash(f))\n\n    def test_data_element_float_special_value_text(self):\n        self.assertEqual(objectify.DataElement(float(\"inf\")).text, \"INF\")\n        self.assertEqual(objectify.DataElement(float(\"-inf\")).text, \"-INF\")\n        self.assertEqual(objectify.DataElement(float(\"nan\")).text, \"NaN\")\n\n    def test_data_element_xsitypes(self):\n        for xsi, objclass in xsitype2objclass.items():\n            # 1 is a valid value for all ObjectifiedDataElement classes\n            pyval = 1\n            value = objectify.DataElement(pyval, _xsi=xsi)\n            self.assertTrue(isinstance(value, objclass),\n                         \"DataElement(%s, _xsi='%s') returns %s, expected %s\"\n                         % (pyval, xsi, type(value), objclass))\n        \n    def test_data_element_xsitypes_xsdprefixed(self):\n        for xsi, objclass in xsitype2objclass.items():\n            # 1 is a valid value for all ObjectifiedDataElement classes\n            pyval = 1\n            value = objectify.DataElement(pyval, _xsi=\"xsd:%s\" % xsi)\n            self.assertTrue(isinstance(value, objclass),\n                         \"DataElement(%s, _xsi='%s') returns %s, expected %s\"\n                         % (pyval, xsi, type(value), objclass))\n        \n    def test_data_element_xsitypes_prefixed(self):\n        for xsi, objclass in xsitype2objclass.items():\n            # 1 is a valid value for all ObjectifiedDataElement classes\n            self.assertRaises(ValueError, objectify.DataElement, 1,\n                              _xsi=\"foo:%s\" % xsi)\n\n    def test_data_element_pytypes(self):\n        for pytype, objclass in pytype2objclass.items():\n            # 1 is a valid value for all ObjectifiedDataElement classes\n            pyval = 1\n            value = objectify.DataElement(pyval, _pytype=pytype)\n            self.assertTrue(isinstance(value, objclass),\n                         \"DataElement(%s, _pytype='%s') returns %s, expected %s\"\n                         % (pyval, pytype, type(value), objclass))\n\n    def test_data_element_pytype_none(self):\n        pyval = 1\n        pytype = \"NoneType\"\n        objclass = objectify.NoneElement\n        value = objectify.DataElement(pyval, _pytype=pytype)\n        self.assertTrue(isinstance(value, objclass),\n                     \"DataElement(%s, _pytype='%s') returns %s, expected %s\"\n                     % (pyval, pytype, type(value), objclass))\n        self.assertEqual(value.text, None)\n        self.assertEqual(value.pyval, None)\n            \n    def test_data_element_pytype_none_compat(self):\n        # pre-2.0 lxml called NoneElement \"none\"\n        pyval = 1\n        pytype = \"none\"\n        objclass = objectify.NoneElement\n        value = objectify.DataElement(pyval, _pytype=pytype)\n        self.assertTrue(isinstance(value, objclass),\n                     \"DataElement(%s, _pytype='%s') returns %s, expected %s\"\n                     % (pyval, pytype, type(value), objclass))\n        self.assertEqual(value.text, None)\n        self.assertEqual(value.pyval, None)\n\n    def test_type_unregistered(self):\n        Element = self.Element\n        SubElement = self.etree.SubElement\n        class MyFloat(float):\n            pass\n        root = Element(\"{objectified}root\")\n        root.myfloat = MyFloat(5.5)\n        self.assertTrue(isinstance(root.myfloat, objectify.FloatElement))\n        self.assertEqual(root.myfloat.get(objectify.PYTYPE_ATTRIBUTE), None)\n\n    def test_data_element_unregistered(self):\n        class MyFloat(float):\n            pass\n        value = objectify.DataElement(MyFloat(5.5))\n        self.assertTrue(isinstance(value, objectify.FloatElement))\n        self.assertEqual(value, 5.5)\n        self.assertEqual(value.get(objectify.PYTYPE_ATTRIBUTE), None)\n\n    def test_schema_types(self):\n        XML = self.XML\n        root = XML('''\\\n        <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n          <b xsi:type=\"boolean\">true</b>\n          <b xsi:type=\"boolean\">false</b>\n          <b xsi:type=\"boolean\">1</b>\n          <b xsi:type=\"boolean\">0</b>\n\n          <f xsi:type=\"float\">5</f>\n          <f xsi:type=\"double\">5</f>\n        \n          <s xsi:type=\"string\">5</s>\n          <s xsi:type=\"normalizedString\">5</s>\n          <s xsi:type=\"token\">5</s>\n          <s xsi:type=\"language\">5</s>\n          <s xsi:type=\"Name\">5</s>\n          <s xsi:type=\"NCName\">5</s>\n          <s xsi:type=\"ID\">5</s>\n          <s xsi:type=\"IDREF\">5</s>\n          <s xsi:type=\"ENTITY\">5</s>\n          <s xsi:type=\"NMTOKEN\">5</s>\n\n          <l xsi:type=\"integer\">5</l>\n          <l xsi:type=\"nonPositiveInteger\">5</l>\n          <l xsi:type=\"negativeInteger\">5</l>\n          <l xsi:type=\"long\">5</l>\n          <l xsi:type=\"nonNegativeInteger\">5</l>\n          <l xsi:type=\"unsignedLong\">5</l>\n          <l xsi:type=\"unsignedInt\">5</l>\n          <l xsi:type=\"positiveInteger\">5</l>\n          \n          <i xsi:type=\"int\">5</i>\n          <i xsi:type=\"short\">5</i>\n          <i xsi:type=\"byte\">5</i>\n          <i xsi:type=\"unsignedShort\">5</i>\n          <i xsi:type=\"unsignedByte\">5</i>\n\n          <n xsi:nil=\"true\"/>\n        </root>\n        ''')\n\n        for b in root.b:\n            self.assertTrue(isinstance(b, objectify.BoolElement))\n        self.assertEqual(True,  root.b[0])\n        self.assertEqual(False, root.b[1])\n        self.assertEqual(True,  root.b[2])\n        self.assertEqual(False, root.b[3])\n\n        for f in root.f:\n            self.assertTrue(isinstance(f, objectify.FloatElement))\n            self.assertEqual(5, f)\n            \n        for s in root.s:\n            self.assertTrue(isinstance(s, objectify.StringElement))\n            self.assertEqual(\"5\", s)\n\n        for i in root.i:\n            self.assertTrue(isinstance(i, objectify.IntElement))\n            self.assertEqual(5, i)\n\n        for l in root.l:\n            self.assertTrue(isinstance(l, objectify.IntElement))\n            self.assertEqual(5, i)\n            \n        self.assertTrue(isinstance(root.n, objectify.NoneElement))\n        self.assertEqual(None, root.n)\n\n    def test_schema_types_prefixed(self):\n        XML = self.XML\n        root = XML('''\\\n        <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n          <b xsi:type=\"xsd:boolean\">true</b>\n          <b xsi:type=\"xsd:boolean\">false</b>\n          <b xsi:type=\"xsd:boolean\">1</b>\n          <b xsi:type=\"xsd:boolean\">0</b>\n\n          <f xsi:type=\"xsd:float\">5</f>\n          <f xsi:type=\"xsd:double\">5</f>\n        \n          <s xsi:type=\"xsd:string\">5</s>\n          <s xsi:type=\"xsd:normalizedString\">5</s>\n          <s xsi:type=\"xsd:token\">5</s>\n          <s xsi:type=\"xsd:language\">5</s>\n          <s xsi:type=\"xsd:Name\">5</s>\n          <s xsi:type=\"xsd:NCName\">5</s>\n          <s xsi:type=\"xsd:ID\">5</s>\n          <s xsi:type=\"xsd:IDREF\">5</s>\n          <s xsi:type=\"xsd:ENTITY\">5</s>\n          <s xsi:type=\"xsd:NMTOKEN\">5</s>\n\n          <l xsi:type=\"xsd:integer\">5</l>\n          <l xsi:type=\"xsd:nonPositiveInteger\">5</l>\n          <l xsi:type=\"xsd:negativeInteger\">5</l>\n          <l xsi:type=\"xsd:long\">5</l>\n          <l xsi:type=\"xsd:nonNegativeInteger\">5</l>\n          <l xsi:type=\"xsd:unsignedLong\">5</l>\n          <l xsi:type=\"xsd:unsignedInt\">5</l>\n          <l xsi:type=\"xsd:positiveInteger\">5</l>\n          \n          <i xsi:type=\"xsd:int\">5</i>\n          <i xsi:type=\"xsd:short\">5</i>\n          <i xsi:type=\"xsd:byte\">5</i>\n          <i xsi:type=\"xsd:unsignedShort\">5</i>\n          <i xsi:type=\"xsd:unsignedByte\">5</i>\n\n          <n xsi:nil=\"true\"/>\n        </root>\n        ''')\n\n        for b in root.b:\n            self.assertTrue(isinstance(b, objectify.BoolElement))\n        self.assertEqual(True,  root.b[0])\n        self.assertEqual(False, root.b[1])\n        self.assertEqual(True,  root.b[2])\n        self.assertEqual(False, root.b[3])\n\n        for f in root.f:\n            self.assertTrue(isinstance(f, objectify.FloatElement))\n            self.assertEqual(5, f)\n            \n        for s in root.s:\n            self.assertTrue(isinstance(s, objectify.StringElement))\n            self.assertEqual(\"5\", s)\n\n        for i in root.i:\n            self.assertTrue(isinstance(i, objectify.IntElement))\n            self.assertEqual(5, i)\n\n        for l in root.l:\n            self.assertTrue(isinstance(l, objectify.IntElement))\n            self.assertEqual(5, l)\n            \n        self.assertTrue(isinstance(root.n, objectify.NoneElement))\n        self.assertEqual(None, root.n)\n        \n    def test_type_str_sequence(self):\n        XML = self.XML\n        root = XML(b'<root><b>why</b><b>try</b></root>')\n        strs = [ str(s) for s in root.b ]\n        self.assertEqual([\"why\", \"try\"],\n                          strs)\n\n    def test_type_str_cmp(self):\n        XML = self.XML\n        root = XML(b'<root><b>test</b><b>taste</b><b></b><b/></root>')\n        self.assertFalse(root.b[0] <  root.b[1])\n        self.assertFalse(root.b[0] <= root.b[1])\n        self.assertFalse(root.b[0] == root.b[1])\n\n        self.assertTrue(root.b[0] != root.b[1])\n        self.assertTrue(root.b[0] >= root.b[1])\n        self.assertTrue(root.b[0] >  root.b[1])\n\n        self.assertEqual(root.b[0], \"test\")\n        self.assertEqual(\"test\", root.b[0])\n\n        self.assertEqual(\"\", root.b[2])\n        self.assertEqual(root.b[2], \"\")\n        self.assertEqual(\"\", root.b[3])\n        self.assertEqual(root.b[3], \"\")\n        self.assertEqual(root.b[2], root.b[3])\n        \n        root.b = \"test\"\n        self.assertTrue(root.b)\n        root.b = \"\"\n        self.assertFalse(root.b)\n        self.assertEqual(root.b, \"\")\n        self.assertEqual(\"\", root.b)\n\n    def test_type_int_cmp(self):\n        XML = self.XML\n        root = XML(b'<root><b>5</b><b>6</b></root>')\n        self.assertTrue(root.b[0] <  root.b[1])\n        self.assertTrue(root.b[0] <= root.b[1])\n        self.assertTrue(root.b[0] != root.b[1])\n\n        self.assertFalse(root.b[0] == root.b[1])\n        self.assertFalse(root.b[0] >= root.b[1])\n        self.assertFalse(root.b[0] >  root.b[1])\n\n        self.assertEqual(root.b[0], 5)\n        self.assertEqual(5, root.b[0])\n        self.assertNotEqual(root.b[0], \"5\")\n\n        root.b = 5\n        self.assertTrue(root.b)\n        root.b = 0\n        self.assertFalse(root.b)\n        \n    # float + long share the NumberElement implementation with int\n\n    def test_type_bool_cmp(self):\n        XML = self.XML\n        root = XML(b'<root><b>false</b><b>true</b></root>')\n        self.assertTrue(root.b[0] <  root.b[1])\n        self.assertTrue(root.b[0] <= root.b[1])\n        self.assertTrue(root.b[0] != root.b[1])\n\n        self.assertFalse(root.b[0] == root.b[1])\n        self.assertFalse(root.b[0] >= root.b[1])\n        self.assertFalse(root.b[0] >  root.b[1])\n\n        self.assertFalse(root.b[0])\n        self.assertTrue(root.b[1])\n\n        self.assertEqual(root.b[0], False)\n        self.assertEqual(False, root.b[0])\n        self.assertTrue(root.b[0] <  5)\n        self.assertTrue(5 > root.b[0])\n\n        root.b = True\n        self.assertTrue(root.b)\n        root.b = False\n        self.assertFalse(root.b)\n\n    def test_type_none_cmp(self):\n        XML = self.XML\n        root = XML(b\"\"\"\n        <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n          <b xsi:nil=\"true\"></b><b xsi:nil=\"true\"/>\n        </root>\"\"\")\n        self.assertTrue(root.b[0] == root.b[1])\n        self.assertFalse(root.b[0])\n        self.assertEqual(root.b[0], None)\n        self.assertEqual(None, root.b[0])\n\n        # doesn't work in Py3:\n\n        #for comparison in [\"abc\", 5, 7.3, True, [], ()]:\n        #    none = root.b[1]\n        #    self.assertTrue(none < comparison, \"%s (%s) should be < %s\" %\n        #                 (none, type(none), comparison) )\n        #    self.assertTrue(comparison > none, \"%s should be > %s (%s)\" %\n        #                 (comparison, none, type(none)) )\n\n    def test_dataelement_xsi(self):\n        el = objectify.DataElement(1, _xsi=\"string\")\n        self.assertEqual(\n            el.get(XML_SCHEMA_INSTANCE_TYPE_ATTR),\n            'xsd:string')\n\n    def test_dataelement_xsi_nsmap(self):\n        el = objectify.DataElement(1, _xsi=\"string\", \n                                   nsmap={'schema': XML_SCHEMA_NS})\n        self.assertEqual(\n            el.get(XML_SCHEMA_INSTANCE_TYPE_ATTR),\n            'schema:string')\n\n    def test_dataelement_xsi_prefix_error(self):\n        self.assertRaises(ValueError, objectify.DataElement, 1,\n                          _xsi=\"foo:string\")\n\n    def test_pytype_annotation(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.annotate(root)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"int\",   child_types[ 0])\n        self.assertEqual(\"str\",   child_types[ 1])\n        self.assertEqual(\"float\", child_types[ 2])\n        self.assertEqual(\"str\",   child_types[ 3])\n        self.assertEqual(\"bool\",  child_types[ 4])\n        self.assertEqual(\"NoneType\",  child_types[ 5])\n        self.assertEqual(None,    child_types[ 6])\n        self.assertEqual(\"float\", child_types[ 7])\n        self.assertEqual(\"float\", child_types[ 8])\n        self.assertEqual(\"str\",   child_types[ 9])\n        self.assertEqual(\"int\",   child_types[10])\n        self.assertEqual(\"int\",   child_types[11])\n        self.assertEqual(\"int\",   child_types[12])\n        self.assertEqual(None,    child_types[13])\n        \n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n    def test_pytype_annotation_empty(self):\n        XML = self.XML\n        root = XML(b'''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <n></n>\n        </a>\n        ''')\n        objectify.annotate(root)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(None,    child_types[0])\n\n        objectify.annotate(root, empty_pytype=\"str\")\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"str\",    child_types[0])\n\n    def test_pytype_annotation_use_old(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.annotate(root, ignore_old=False)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"int\",   child_types[ 0])\n        self.assertEqual(\"str\",   child_types[ 1])\n        self.assertEqual(\"float\", child_types[ 2])\n        self.assertEqual(\"str\",   child_types[ 3])\n        self.assertEqual(\"bool\",  child_types[ 4])\n        self.assertEqual(\"NoneType\",  child_types[ 5])\n        self.assertEqual(None,    child_types[ 6])\n        self.assertEqual(\"float\", child_types[ 7])\n        self.assertEqual(\"float\", child_types[ 8])\n        self.assertEqual(\"str\",   child_types[ 9])\n        self.assertEqual(\"str\",   child_types[10])\n        self.assertEqual(\"float\", child_types[11])\n        self.assertEqual(\"int\",   child_types[12])\n        self.assertEqual(TREE_PYTYPE,  child_types[13])\n        \n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n    def test_pytype_xsitype_annotation(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.annotate(root, ignore_old=False, ignore_xsi=False,\n                           annotate_xsi=1, annotate_pytype=1)\n        \n        # check py annotations\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"int\",   child_types[ 0])\n        self.assertEqual(\"str\",   child_types[ 1])\n        self.assertEqual(\"float\", child_types[ 2])\n        self.assertEqual(\"str\",   child_types[ 3])\n        self.assertEqual(\"bool\",  child_types[ 4])\n        self.assertEqual(\"NoneType\",  child_types[ 5])\n        self.assertEqual(None,    child_types[ 6])\n        self.assertEqual(\"float\", child_types[ 7])\n        self.assertEqual(\"float\", child_types[ 8])\n        self.assertEqual(\"str\",   child_types[ 9])\n        self.assertEqual(\"str\",   child_types[10])\n        self.assertEqual(\"float\",   child_types[11])\n        self.assertEqual(\"int\",     child_types[12])\n        self.assertEqual(TREE_PYTYPE,  child_types[13])\n        \n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n        child_xsitypes = [ c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR)\n                        for c in root.iterchildren() ]\n\n        # check xsi annotations\n        child_types = [ c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"xsd:integer\", child_types[ 0])\n        self.assertEqual(\"xsd:string\",  child_types[ 1])\n        self.assertEqual(\"xsd:double\",  child_types[ 2])\n        self.assertEqual(\"xsd:string\",  child_types[ 3])\n        self.assertEqual(\"xsd:boolean\", child_types[ 4])\n        self.assertEqual(None,          child_types[ 5])\n        self.assertEqual(None,          child_types[ 6])\n        self.assertEqual(\"xsd:double\",  child_types[ 7])\n        self.assertEqual(\"xsd:float\",   child_types[ 8])\n        self.assertEqual(\"xsd:string\",  child_types[ 9])\n        self.assertEqual(\"xsd:string\",  child_types[10])\n        self.assertEqual(\"xsd:double\",  child_types[11])\n        self.assertEqual(\"xsd:integer\", child_types[12])\n        self.assertEqual(None,  child_types[13])\n\n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n    def test_xsiannotate_use_old(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.xsiannotate(root, ignore_old=False)\n\n        child_types = [ c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"xsd:integer\", child_types[ 0])\n        self.assertEqual(\"xsd:string\",  child_types[ 1])\n        self.assertEqual(\"xsd:double\",  child_types[ 2])\n        self.assertEqual(\"xsd:string\",  child_types[ 3])\n        self.assertEqual(\"xsd:boolean\", child_types[ 4])\n        self.assertEqual(None,          child_types[ 5])\n        self.assertEqual(None,          child_types[ 6])\n        self.assertEqual(\"xsd:double\",  child_types[ 7])\n        self.assertEqual(\"xsd:float\",   child_types[ 8])\n        self.assertEqual(\"xsd:string\",  child_types[ 9])\n        self.assertEqual(\"xsd:string\",  child_types[10])\n        self.assertEqual(\"xsd:double\",  child_types[11])\n        self.assertEqual(\"xsd:integer\", child_types[12])\n        self.assertEqual(None,          child_types[13])\n\n    def test_pyannotate_ignore_old(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.pyannotate(root, ignore_old=True)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"int\",   child_types[ 0])\n        self.assertEqual(\"str\",   child_types[ 1])\n        self.assertEqual(\"float\", child_types[ 2])\n        self.assertEqual(\"str\",   child_types[ 3])\n        self.assertEqual(\"bool\",  child_types[ 4])\n        self.assertEqual(\"NoneType\",  child_types[ 5])\n        self.assertEqual(None,    child_types[ 6])\n        self.assertEqual(\"float\", child_types[ 7])\n        self.assertEqual(\"float\", child_types[ 8])\n        self.assertEqual(\"str\",   child_types[ 9])\n        self.assertEqual(\"int\",   child_types[10])\n        self.assertEqual(\"int\",   child_types[11])\n        self.assertEqual(\"int\",   child_types[12])\n        self.assertEqual(None,    child_types[13])\n        \n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n    def test_pyannotate_empty(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <n></n>\n        </a>\n        ''')\n        objectify.pyannotate(root)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(None,    child_types[0])\n\n        objectify.annotate(root, empty_pytype=\"str\")\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"str\",    child_types[0])\n\n    def test_pyannotate_use_old(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.pyannotate(root)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"int\",   child_types[ 0])\n        self.assertEqual(\"str\",   child_types[ 1])\n        self.assertEqual(\"float\", child_types[ 2])\n        self.assertEqual(\"str\",   child_types[ 3])\n        self.assertEqual(\"bool\",  child_types[ 4])\n        self.assertEqual(\"NoneType\",  child_types[ 5])\n        self.assertEqual(None,    child_types[ 6])\n        self.assertEqual(\"float\", child_types[ 7])\n        self.assertEqual(\"float\", child_types[ 8])\n        self.assertEqual(\"str\",   child_types[ 9])\n        self.assertEqual(\"str\",   child_types[10])\n        self.assertEqual(\"float\", child_types[11])\n        self.assertEqual(\"int\",   child_types[12])\n        self.assertEqual(TREE_PYTYPE, child_types[13])\n        \n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n        \n    def test_xsiannotate_ignore_old(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.xsiannotate(root, ignore_old=True)\n\n        child_types = [ c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"xsd:integer\", child_types[ 0])\n        self.assertEqual(\"xsd:string\",  child_types[ 1])\n        self.assertEqual(\"xsd:double\",  child_types[ 2])\n        self.assertEqual(\"xsd:string\",  child_types[ 3])\n        self.assertEqual(\"xsd:boolean\", child_types[ 4])\n        self.assertEqual(None,          child_types[ 5])\n        self.assertEqual(None,          child_types[ 6])\n        self.assertEqual(\"xsd:integer\", child_types[ 7])\n        self.assertEqual(\"xsd:integer\", child_types[ 8])\n        self.assertEqual(\"xsd:integer\", child_types[ 9])\n        self.assertEqual(\"xsd:string\",  child_types[10])\n        self.assertEqual(\"xsd:double\",  child_types[11])\n        self.assertEqual(\"xsd:integer\", child_types[12])\n        self.assertEqual(None,          child_types[13])\n\n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n    def test_deannotate(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.deannotate(root)\n\n        for c in root.getiterator():\n            self.assertEqual(None, c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR))\n            self.assertEqual(None, c.get(objectify.PYTYPE_ATTRIBUTE))\n\n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n    def test_xsinil_deannotate(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n          <b xsi:type=\"float\">5</b>\n          <s xsi:type=\"string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.annotate(\n            root, ignore_old=False, ignore_xsi=False, annotate_xsi=True,\n            empty_pytype='str', empty_type='string')\n        objectify.deannotate(root, pytype=False, xsi=False, xsi_nil=True)\n\n        child_types = [ c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"xsd:integer\",  child_types[ 0])\n        self.assertEqual(\"xsd:string\",   child_types[ 1])\n        self.assertEqual(\"xsd:double\",   child_types[ 2])\n        self.assertEqual(\"xsd:string\",   child_types[ 3])\n        self.assertEqual(\"xsd:boolean\",  child_types[ 4])\n        self.assertEqual(None,           child_types[ 5])\n        self.assertEqual(\"xsd:string\",   child_types[ 6])\n        self.assertEqual(\"xsd:double\",   child_types[ 7])\n        self.assertEqual(\"xsd:float\",    child_types[ 8])\n        self.assertEqual(\"xsd:string\",   child_types[ 9])\n        self.assertEqual(\"xsd:string\",   child_types[10])\n        self.assertEqual(\"xsd:double\",    child_types[11])\n        self.assertEqual(\"xsd:integer\",  child_types[12])\n        self.assertEqual(None,           child_types[13])\n\n        self.assertEqual(None, root.n.get(XML_SCHEMA_NIL_ATTR))\n\n        for c in root.iterchildren():\n            self.assertNotEqual(None, c.get(objectify.PYTYPE_ATTRIBUTE))\n            # these have no equivalent in xsi:type\n            if (c.get(objectify.PYTYPE_ATTRIBUTE) not in [TREE_PYTYPE, \n                \"NoneType\"]):\n                self.assertNotEqual(\n                    None, c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR))\n\n    def test_xsitype_deannotate(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\"\n        xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"xsd:double\">5</b>\n          <b xsi:type=\"xsd:float\">5</b>\n          <s xsi:type=\"xsd:string\">23</s>\n          <s py:pytype=\"str\">42</s>\n          <f py:pytype=\"float\">300</f>\n          <l py:pytype=\"long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.annotate(root)\n        objectify.deannotate(root, pytype=False)\n\n        child_types = [ c.get(objectify.PYTYPE_ATTRIBUTE)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"int\",   child_types[ 0])\n        self.assertEqual(\"str\",   child_types[ 1])\n        self.assertEqual(\"float\", child_types[ 2])\n        self.assertEqual(\"str\",   child_types[ 3])\n        self.assertEqual(\"bool\",  child_types[ 4])\n        self.assertEqual(\"NoneType\",  child_types[ 5])\n        self.assertEqual(None,    child_types[ 6])\n        self.assertEqual(\"float\", child_types[ 7])\n        self.assertEqual(\"float\", child_types[ 8])\n        self.assertEqual(\"str\",   child_types[ 9])\n        self.assertEqual(\"int\",   child_types[10])\n        self.assertEqual(\"int\",   child_types[11])\n        self.assertEqual(\"int\",   child_types[12])\n        self.assertEqual(None,    child_types[13])\n        \n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n        for c in root.getiterator():\n            self.assertEqual(None, c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR))\n\n    def test_pytype_deannotate(self):\n        XML = self.XML\n        root = XML('''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:py=\"http://codespeak.net/lxml/objectify/pytype\"\n        xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n          <b xsi:type=\"xsd:int\">5</b>\n          <b xsi:type=\"xsd:string\">test</b>\n          <c xsi:type=\"xsd:float\">1.1</c>\n          <c xsi:type=\"xsd:string\">\\uF8D2</c>\n          <x xsi:type=\"xsd:boolean\">true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"xsd:double\">5</b>\n          <b xsi:type=\"xsd:float\">5</b>\n          <s xsi:type=\"xsd:string\">23</s>\n          <s xsi:type=\"xsd:string\">42</s>\n          <f xsi:type=\"xsd:float\">300</f>\n          <l xsi:type=\"xsd:long\">2</l>\n          <t py:pytype=\"TREE\"></t>\n        </a>\n        ''')\n        objectify.annotate(root)\n        objectify.deannotate(root, xsi=False)\n\n        child_types = [ c.get(XML_SCHEMA_INSTANCE_TYPE_ATTR)\n                        for c in root.iterchildren() ]\n        self.assertEqual(\"xsd:int\",      child_types[ 0])\n        self.assertEqual(\"xsd:string\",   child_types[ 1])\n        self.assertEqual(\"xsd:float\",    child_types[ 2])\n        self.assertEqual(\"xsd:string\",   child_types[ 3])\n        self.assertEqual(\"xsd:boolean\",  child_types[ 4])\n        self.assertEqual(None,           child_types[ 5])\n        self.assertEqual(None,           child_types[ 6])\n        self.assertEqual(\"xsd:double\",   child_types[ 7])\n        self.assertEqual(\"xsd:float\",    child_types[ 8])\n        self.assertEqual(\"xsd:string\",   child_types[ 9])\n        self.assertEqual(\"xsd:string\",   child_types[10])\n        self.assertEqual(\"xsd:float\",    child_types[11])\n        self.assertEqual(\"xsd:long\",     child_types[12])\n        self.assertEqual(None,           child_types[13])\n\n        self.assertEqual(\"true\", root.n.get(XML_SCHEMA_NIL_ATTR))\n\n        for c in root.getiterator():\n            self.assertEqual(None, c.get(objectify.PYTYPE_ATTRIBUTE))\n\n    def test_change_pytype_attribute(self):\n        XML = self.XML\n\n        xml = '''\\\n        <a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n          <b>5</b>\n          <b>test</b>\n          <c>1.1</c>\n          <c>\\uF8D2</c>\n          <x>true</x>\n          <n xsi:nil=\"true\" />\n          <n></n>\n          <b xsi:type=\"double\">5</b>\n        </a>\n        '''\n\n        pytype_ns, pytype_name = objectify.PYTYPE_ATTRIBUTE[1:].split('}')\n        objectify.set_pytype_attribute_tag(\"{TEST}test\")\n\n        root = XML(xml)\n        objectify.annotate(root)\n\n        attribs = root.xpath(\"//@py:%s\" % pytype_name,\n                             namespaces={\"py\" : pytype_ns})\n        self.assertEqual(0, len(attribs))\n        attribs = root.xpath(\"//@py:test\",\n                             namespaces={\"py\" : \"TEST\"})\n        self.assertEqual(7, len(attribs))\n\n        objectify.set_pytype_attribute_tag()\n        pytype_ns, pytype_name = objectify.PYTYPE_ATTRIBUTE[1:].split('}')\n\n        self.assertNotEqual(\"test\", pytype_ns.lower())\n        self.assertNotEqual(\"test\", pytype_name.lower())\n\n        root = XML(xml)\n        attribs = root.xpath(\"//@py:%s\" % pytype_name,\n                             namespaces={\"py\" : pytype_ns})\n        self.assertEqual(0, len(attribs))\n\n        objectify.annotate(root)\n        attribs = root.xpath(\"//@py:%s\" % pytype_name,\n                             namespaces={\"py\" : pytype_ns})\n        self.assertEqual(7, len(attribs))\n\n    def test_registered_types(self):\n        orig_types = objectify.getRegisteredTypes()\n        orig_types[0].unregister()\n        self.assertEqual(orig_types[1:], objectify.getRegisteredTypes())\n\n        class NewType(objectify.ObjectifiedDataElement):\n            pass\n\n        def checkMyType(s):\n            return True\n\n        pytype = objectify.PyType(\"mytype\", checkMyType, NewType)\n        self.assertTrue(pytype not in objectify.getRegisteredTypes())\n        pytype.register()\n        self.assertTrue(pytype in objectify.getRegisteredTypes())\n        pytype.unregister()\n        self.assertTrue(pytype not in objectify.getRegisteredTypes())\n\n        pytype.register(before = [objectify.getRegisteredTypes()[0].name])\n        self.assertEqual(pytype, objectify.getRegisteredTypes()[0])\n        pytype.unregister()\n\n        pytype.register(after = [objectify.getRegisteredTypes()[0].name])\n        self.assertNotEqual(pytype, objectify.getRegisteredTypes()[0])\n        pytype.unregister()\n\n        self.assertRaises(ValueError, pytype.register,\n                          before = [objectify.getRegisteredTypes()[0].name],\n                          after  = [objectify.getRegisteredTypes()[1].name])\n\n    def test_registered_type_stringify(self):\n        from datetime import datetime\n        def parse_date(value):\n            if len(value) != 14:\n                raise ValueError(value)\n            Y = int(value[0:4])\n            M = int(value[4:6])\n            D = int(value[6:8])\n            h = int(value[8:10])\n            m = int(value[10:12])\n            s = int(value[12:14])\n            return datetime(Y, M, D, h, m, s)\n\n        def stringify_date(date):\n            return date.strftime(\"%Y%m%d%H%M%S\")\n\n        class DatetimeElement(objectify.ObjectifiedDataElement):\n            def pyval(self):\n                return parse_date(self.text)\n            pyval = property(pyval)\n\n        datetime_type = objectify.PyType(\n            \"datetime\", parse_date, DatetimeElement, stringify_date)\n        datetime_type.xmlSchemaTypes = \"dateTime\"\n        datetime_type.register()\n\n        NAMESPACE = \"http://foo.net/xmlns\"\n        NAMESPACE_MAP = {'ns': NAMESPACE}\n\n        r = objectify.Element(\"{%s}root\" % NAMESPACE, nsmap=NAMESPACE_MAP)\n        time = datetime.now()\n        r.date = time\n\n        self.assertTrue(isinstance(r.date, DatetimeElement))\n        self.assertTrue(isinstance(r.date.pyval, datetime))\n\n        self.assertEqual(r.date.pyval, parse_date(stringify_date(time)))\n        self.assertEqual(r.date.text, stringify_date(time))\n\n        r.date = objectify.E.date(time)\n\n        self.assertTrue(isinstance(r.date, DatetimeElement))\n        self.assertTrue(isinstance(r.date.pyval, datetime))\n\n        self.assertEqual(r.date.pyval, parse_date(stringify_date(time)))\n        self.assertEqual(r.date.text, stringify_date(time))\n\n        date = objectify.DataElement(time)\n\n        self.assertTrue(isinstance(date, DatetimeElement))\n        self.assertTrue(isinstance(date.pyval, datetime))\n\n        self.assertEqual(date.pyval, parse_date(stringify_date(time)))\n        self.assertEqual(date.text, stringify_date(time))\n\n    def test_object_path(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n    def test_object_path_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( ['root', 'c1', 'c2'] )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n    def test_object_path_fail(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path, root)\n\n    def test_object_path_default_absolute(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertEqual(None, path(root, None))\n        path = objectify.ObjectPath( \"root.c99.c2\" )\n        self.assertEqual(None, path(root, None))\n        path = objectify.ObjectPath( \"notroot.c99.c2\" )\n        self.assertEqual(None, path(root, None))\n\n    def test_object_path_default_relative(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \".c1.c99\" )\n        self.assertEqual(None, path(root, None))\n        path = objectify.ObjectPath( \".c99.c2\" )\n        self.assertEqual(None, path(root, None))\n\n    def test_object_path_syntax(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath(\"root .    {objectified}c1.   c2\")\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n        path = objectify.ObjectPath(\"   root.{objectified}  c1.c2  [ 0 ]   \")\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n    def test_object_path_fail_parse_empty(self):\n        self.assertRaises(ValueError, objectify.ObjectPath, \"\")\n\n    def test_object_path_fail_parse_empty_list(self):\n        self.assertRaises(ValueError, objectify.ObjectPath, [])\n\n    def test_object_path_hasattr(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root\" )\n        self.assertTrue(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1\" )\n        self.assertTrue(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1.c2\" )\n        self.assertTrue(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1.{otherNS}c2\" )\n        self.assertTrue(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1.c2[1]\" )\n        self.assertTrue(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1.c2[2]\" )\n        self.assertTrue(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1.c2[3]\" )\n        self.assertFalse(path.hasattr(root))\n        path = objectify.ObjectPath( \"root.c1[1].c2\" )\n        self.assertFalse(path.hasattr(root))\n\n    def test_object_path_dot(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \".\" )\n        self.assertEqual(root.c1.c2.text, path(root).c1.c2.text)\n\n    def test_object_path_dot_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( [''] )\n        self.assertEqual(root.c1.c2.text, path(root).c1.c2.text)\n\n    def test_object_path_dot_root(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \".c1.c2\" )\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n    def test_object_path_dot_root_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( ['', 'c1', 'c2'] )\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n    def test_object_path_index(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1[0].c2[0]\" )\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n        path = objectify.ObjectPath( \"root.c1[0].c2\" )\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n        path = objectify.ObjectPath( \"root.c1[0].c2[1]\" )\n        self.assertEqual(root.c1.c2[1].text, path(root).text)\n\n        path = objectify.ObjectPath( \"root.c1.c2[2]\" )\n        self.assertEqual(root.c1.c2[2].text, path(root).text)\n\n        path = objectify.ObjectPath( \"root.c1.c2[-1]\" )\n        self.assertEqual(root.c1.c2[-1].text, path(root).text)\n\n        path = objectify.ObjectPath( \"root.c1.c2[-3]\" )\n        self.assertEqual(root.c1.c2[-3].text, path(root).text)\n\n    def test_object_path_index_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( ['root', 'c1[0]', 'c2[0]'] )\n        self.assertEqual(root.c1.c2.text, path(root).text)\n\n        path = objectify.ObjectPath( ['root', 'c1[0]', 'c2[2]'] )\n        self.assertEqual(root.c1.c2[2].text, path(root).text)\n\n        path = objectify.ObjectPath( ['root', 'c1', 'c2[2]'] )\n        self.assertEqual(root.c1.c2[2].text, path(root).text)\n\n        path = objectify.ObjectPath( ['root', 'c1', 'c2[-1]'] )\n        self.assertEqual(root.c1.c2[-1].text, path(root).text)\n\n        path = objectify.ObjectPath( ['root', 'c1', 'c2[-3]'] )\n        self.assertEqual(root.c1.c2[-3].text, path(root).text)\n\n    def test_object_path_index_fail_parse(self):\n        self.assertRaises(ValueError, objectify.ObjectPath,\n                          \"root.c1[0].c2[-1-2]\")\n        self.assertRaises(ValueError, objectify.ObjectPath,\n                          ['root', 'c1[0]', 'c2[-1-2]'])\n\n        self.assertRaises(ValueError, objectify.ObjectPath,\n                          \"root[2].c1.c2\")\n        self.assertRaises(ValueError, objectify.ObjectPath,\n                          ['root[2]', 'c1', 'c2'])\n\n        self.assertRaises(ValueError, objectify.ObjectPath,\n                          [])\n        self.assertRaises(ValueError, objectify.ObjectPath,\n                          ['', '', ''])\n\n    def test_object_path_index_fail_lookup(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath(\"root.c1[9999].c2\")\n        self.assertRaises(AttributeError, path, root)\n\n        path = objectify.ObjectPath(\"root.c1[0].c2[9999]\")\n        self.assertRaises(AttributeError, path, root)\n\n        path = objectify.ObjectPath(\".c1[9999].c2[0]\")\n        self.assertRaises(AttributeError, path, root)\n\n        path = objectify.ObjectPath(\"root.c1[-2].c2\")\n        self.assertRaises(AttributeError, path, root)\n\n        path = objectify.ObjectPath(\"root.c1[0].c2[-4]\")\n        self.assertRaises(AttributeError, path, root)\n\n    def test_object_path_ns(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"{objectified}root.c1.c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( \"{objectified}root.{objectified}c1.c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( \"root.{objectified}c1.{objectified}c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( \"root.c1.{objectified}c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( \"root.c1.{otherNS}c2\" )\n        self.assertEqual(getattr(root.c1, '{otherNS}c2').text,\n                          path.find(root).text)\n\n    def test_object_path_ns_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( ['{objectified}root', 'c1', 'c2'] )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( ['{objectified}root', '{objectified}c1', 'c2'] )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( ['root', '{objectified}c1', '{objectified}c2'] )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( ['root', '{objectified}c1', '{objectified}c2[2]'] )\n        self.assertEqual(root.c1.c2[2].text, path.find(root).text)\n        path = objectify.ObjectPath( ['root', 'c1', '{objectified}c2'] )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        path = objectify.ObjectPath( ['root', 'c1', '{objectified}c2[2]'] )\n        self.assertEqual(root.c1.c2[2].text, path.find(root).text)\n        path = objectify.ObjectPath( ['root', 'c1', '{otherNS}c2'] )\n        self.assertEqual(getattr(root.c1, '{otherNS}c2').text,\n                          path.find(root).text)\n\n    def test_object_path_set(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        self.assertEqual(\"1\", root.c1.c2[1].text)\n\n        new_value = \"my new value\"\n        path.setattr(root, new_value)\n\n        self.assertEqual(new_value, root.c1.c2.text)\n        self.assertEqual(new_value, path(root).text)\n        self.assertEqual(\"1\", root.c1.c2[1].text)\n\n    def test_object_path_set_element(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c2\" )\n        self.assertEqual(root.c1.c2.text, path.find(root).text)\n        self.assertEqual(\"1\", root.c1.c2[1].text)\n\n        new_el = self.Element(\"{objectified}test\")\n        etree.SubElement(new_el, \"{objectified}sub\", myattr=\"ATTR\").a = \"TEST\"\n        path.setattr(root, new_el.sub)\n\n        self.assertEqual(\"ATTR\", root.c1.c2.get(\"myattr\"))\n        self.assertEqual(\"TEST\", root.c1.c2.a.text)\n        self.assertEqual(\"TEST\", path(root).a.text)\n        self.assertEqual(\"1\", root.c1.c2[1].text)\n\n    def test_object_path_set_create(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path.find, root)\n\n        new_value = \"my new value\"\n        path.setattr(root, new_value)\n\n        self.assertEqual(1, len(root.c1.c99))\n        self.assertEqual(new_value, root.c1.c99.text)\n        self.assertEqual(new_value, path(root).text)\n\n    def test_object_path_set_create_element(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path.find, root)\n\n        new_el = self.Element(\"{objectified}test\")\n        etree.SubElement(new_el, \"{objectified}sub\", myattr=\"ATTR\").a = \"TEST\"\n        path.setattr(root, new_el.sub)\n\n        self.assertEqual(1, len(root.c1.c99))\n        self.assertEqual(\"ATTR\", root.c1.c99.get(\"myattr\"))\n        self.assertEqual(\"TEST\", root.c1.c99.a.text)\n        self.assertEqual(\"TEST\", path(root).a.text)\n\n    def test_object_path_set_create_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path.find, root)\n\n        new_el = self.Element(\"{objectified}test\")\n        new_el.a = [\"TEST1\", \"TEST2\"]\n        new_el.a[0].set(\"myattr\", \"ATTR1\")\n        new_el.a[1].set(\"myattr\", \"ATTR2\")\n\n        path.setattr(root, list(new_el.a))\n\n        self.assertEqual(2, len(root.c1.c99))\n        self.assertEqual(\"ATTR1\", root.c1.c99[0].get(\"myattr\"))\n        self.assertEqual(\"TEST1\", root.c1.c99[0].text)\n        self.assertEqual(\"ATTR2\", root.c1.c99[1].get(\"myattr\"))\n        self.assertEqual(\"TEST2\", root.c1.c99[1].text)\n        self.assertEqual(\"TEST1\", path(root).text)\n\n    def test_object_path_addattr(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c2\" )\n        self.assertEqual(3, len(root.c1.c2))\n        path.addattr(root, \"test\")\n        self.assertEqual(4, len(root.c1.c2))\n        self.assertEqual([\"0\", \"1\", \"2\", \"test\"],\n                          [el.text for el in root.c1.c2])\n\n    def test_object_path_addattr_element(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c2\" )\n        self.assertEqual(3, len(root.c1.c2))\n\n        new_el = self.Element(\"{objectified}test\")\n        etree.SubElement(new_el, \"{objectified}sub\").a = \"TEST\"\n\n        path.addattr(root, new_el.sub)\n        self.assertEqual(4, len(root.c1.c2))\n        self.assertEqual(\"TEST\", root.c1.c2[3].a.text)\n        self.assertEqual([\"0\", \"1\", \"2\"],\n                          [el.text for el in root.c1.c2[:3]])\n\n    def test_object_path_addattr_create(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path.find, root)\n\n        new_value = \"my new value\"\n        path.addattr(root, new_value)\n\n        self.assertEqual(1, len(root.c1.c99))\n        self.assertEqual(new_value, root.c1.c99.text)\n        self.assertEqual(new_value, path(root).text)\n\n    def test_object_path_addattr_create_element(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path.find, root)\n\n        new_el = self.Element(\"{objectified}test\")\n        etree.SubElement(new_el, \"{objectified}sub\", myattr=\"ATTR\").a = \"TEST\"\n\n        path.addattr(root, new_el.sub)\n        self.assertEqual(1, len(root.c1.c99))\n        self.assertEqual(\"TEST\", root.c1.c99.a.text)\n        self.assertEqual(\"TEST\", path(root).a.text)\n        self.assertEqual(\"ATTR\", root.c1.c99.get(\"myattr\"))\n\n    def test_object_path_addattr_create_list(self):\n        root = self.XML(xml_str)\n        path = objectify.ObjectPath( \"root.c1.c99\" )\n        self.assertRaises(AttributeError, path.find, root)\n\n        new_el = self.Element(\"{objectified}test\")\n        new_el.a = [\"TEST1\", \"TEST2\"]\n\n        self.assertEqual(2, len(new_el.a))\n\n        path.addattr(root, list(new_el.a))\n        self.assertEqual(2, len(root.c1.c99))\n        self.assertEqual(\"TEST1\", root.c1.c99.text)\n        self.assertEqual(\"TEST2\", path(root)[1].text)\n\n    def test_descendant_paths(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\n            ['{objectified}root', '{objectified}root.c1',\n             '{objectified}root.c1.c2',\n             '{objectified}root.c1.c2[1]', '{objectified}root.c1.c2[2]',\n             '{objectified}root.c1.{otherNS}c2', '{objectified}root.c1.{}c2'],\n            root.descendantpaths())\n\n    def test_descendant_paths_child(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\n            ['{objectified}c1', '{objectified}c1.c2',\n             '{objectified}c1.c2[1]', '{objectified}c1.c2[2]',\n             '{objectified}c1.{otherNS}c2', '{objectified}c1.{}c2'],\n            root.c1.descendantpaths())\n\n    def test_descendant_paths_prefix(self):\n        root = self.XML(xml_str)\n        self.assertEqual(\n            ['root.{objectified}c1', 'root.{objectified}c1.c2',\n             'root.{objectified}c1.c2[1]', 'root.{objectified}c1.c2[2]',\n             'root.{objectified}c1.{otherNS}c2',\n             'root.{objectified}c1.{}c2'],\n            root.c1.descendantpaths('root'))\n\n    def test_pickle(self):\n        import pickle\n\n        root = self.XML(xml_str)\n        out = BytesIO()\n        pickle.dump(root, out)\n\n        new_root = pickle.loads(out.getvalue())\n        self.assertEqual(\n            etree.tostring(new_root),\n            etree.tostring(root))\n\n    def test_pickle_elementtree(self):\n        import pickle\n\n        tree = etree.ElementTree(self.XML(xml_str + \"<?my pi?>\"))\n        out = BytesIO()\n        pickle.dump(tree, out)\n\n        new_tree = pickle.loads(out.getvalue())\n        self.assertTrue(isinstance(new_tree, etree._ElementTree))\n        self.assertEqual(\n            etree.tostring(new_tree),\n            etree.tostring(tree))\n\n    def test_pickle_intelement(self):\n        self._test_pickle('<x>42</x>')\n        self._test_pickle(objectify.DataElement(42))\n\n    def test_pickle_floattelement(self):\n        self._test_pickle('<x>42.0</x>')\n        self._test_pickle(objectify.DataElement(42.0))\n\n    def test_pickle_strelement(self):\n        self._test_pickle('<x>Pickle me!</x>')\n        self._test_pickle(objectify.DataElement('Pickle me!'))\n\n    def test_pickle_boolelement(self):\n        self._test_pickle('<x>true</x>')\n        self._test_pickle('<x>false</x>')\n        self._test_pickle(objectify.DataElement(True))\n        self._test_pickle(objectify.DataElement(False))\n\n    def test_pickle_noneelement(self):\n        self._test_pickle('''\n<x xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:nil=\"true\"/>''')\n        self._test_pickle(objectify.DataElement(None))\n\n    def _test_pickle(self, stringOrElt):\n        import pickle\n        if isinstance(stringOrElt, (etree._Element, etree._ElementTree)):\n            elt = stringOrElt\n        else:\n            elt = self.XML(stringOrElt)\n        out = BytesIO()\n        pickle.dump(elt, out)\n\n        new_elt = pickle.loads(out.getvalue())\n        self.assertEqual(\n            etree.tostring(new_elt),\n            etree.tostring(elt))\n\n    # E-Factory tests, need to use sub-elements as root element is always\n    # type-looked-up as ObjectifiedElement (no annotations)\n    def test_efactory_int(self):\n        E = objectify.E\n        root = E.root(E.val(23))\n        self.assertTrue(isinstance(root.val, objectify.IntElement))\n\n    def test_efactory_float(self):\n        E = objectify.E\n        root = E.root(E.val(233.23))\n        self.assertTrue(isinstance(root.val, objectify.FloatElement))\n\n    def test_efactory_str(self):\n        E = objectify.E\n        root = E.root(E.val(\"what?\"))\n        self.assertTrue(isinstance(root.val, objectify.StringElement))\n\n    def test_efactory_unicode(self):\n        E = objectify.E\n        root = E.root(E.val(_str(\"bl\u00f6\u00f6dy h\u00e4ll\", encoding=\"ISO-8859-1\")))\n        self.assertTrue(isinstance(root.val, objectify.StringElement))\n\n    def test_efactory_bool(self):\n        E = objectify.E\n        root = E.root(E.val(True))\n        self.assertTrue(isinstance(root.val, objectify.BoolElement))\n\n    def test_efactory_none(self):\n        E = objectify.E\n        root = E.root(E.val(None))\n        self.assertTrue(isinstance(root.val, objectify.NoneElement))\n\n    def test_efactory_value_concatenation(self):\n        E = objectify.E\n        root = E.root(E.val(1, \"foo\", 2.0, \"bar \", True, None))\n        self.assertTrue(isinstance(root.val, objectify.StringElement))\n\n    def test_efactory_attrib(self):\n        E = objectify.E\n        root = E.root(foo=\"bar\")\n        self.assertEqual(root.get(\"foo\"), \"bar\")\n\n    def test_efactory_nested(self):\n        E = objectify.E\n        DataElement = objectify.DataElement\n        root = E.root(\"text\", E.sub(E.subsub()), \"tail\", DataElement(1),\n                      DataElement(2.0))\n        self.assertTrue(isinstance(root, objectify.ObjectifiedElement))\n        self.assertEqual(root.text, \"text\")\n        self.assertTrue(isinstance(root.sub, objectify.ObjectifiedElement))\n        self.assertEqual(root.sub.tail, \"tail\")\n        self.assertTrue(isinstance(root.sub.subsub, objectify.StringElement))\n        self.assertEqual(len(root.value), 2)\n        self.assertTrue(isinstance(root.value[0], objectify.IntElement))\n        self.assertTrue(isinstance(root.value[1], objectify.FloatElement))\n\n    def test_efactory_subtype(self):\n        class Attribute(objectify.ObjectifiedDataElement):\n            def __init__(self):\n                objectify.ObjectifiedDataElement.__init__(self)\n                self.set(\"datatype\", \"TYPE\")\n                self.set(\"range\", \"0.,1.\")\n\n        attr = Attribute()\n        self.assertEqual(attr.text, None)\n        self.assertEqual(attr.get(\"datatype\"), \"TYPE\")\n        self.assertEqual(attr.get(\"range\"), \"0.,1.\")\n\n    def test_XML_base_url_docinfo(self):\n        root = objectify.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n \n    def test_XML_set_base_url_docinfo(self):\n        root = objectify.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n        docinfo.URL = \"https://secret/url\"\n        self.assertEqual(docinfo.URL, \"https://secret/url\")\n \n    def test_parse_stringio_base_url(self):\n        tree = objectify.parse(BytesIO(b\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n \n    def test_parse_base_url_docinfo(self):\n        tree = objectify.parse(fileInTestDir('include/test_xinclude.xml'),\n                               base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_xml_base(self):\n        root = objectify.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.base = \"https://secret/url\"\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n \n    def test_xml_base_attribute(self):\n        root = objectify.XML(b\"<root/>\", base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.set('{http://www.w3.org/XML/1998/namespace}base',\n                 \"https://secret/url\")\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_standard_lookup(self):\n        XML = self.XML\n\n        root = XML('''\\\n        <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n          <i>5</i>\n          <i>-5</i>\n          <l>4294967296</l>\n          <l>-4294967296</l>\n          <f>1.1</f>\n          <f>.1</f>\n          <f>.1E23</f>\n          <f>.1E-23</f>\n          <b>true</b>\n          <b>false</b>\n          <s>Strange things happen, where strings collide</s>\n          <s>True</s>\n          <s>False</s>\n          <s>t</s>\n          <s>f</s>\n          <s></s>\n          <s>\u00b2\u00b2\u00b2\u00b2</s>\n          <s>12_34</s>\n          <s>1.2_34</s>\n          <s>34E</s>\n          <s>.E</s>\n          <s>.</s>\n          <s>None</s>\n          <n xsi:nil=\"true\" />\n        </root>\n        ''')\n\n        for i in root.i:\n            self.assertTrue(isinstance(i, objectify.IntElement), (i.text, type(i)))\n        for l in root.l:\n            self.assertTrue(isinstance(l, objectify.IntElement), (l.text, type(l)))\n        for f in root.f:\n            self.assertTrue(isinstance(f, objectify.FloatElement), (f.text, type(f)))\n        for b in root.b:\n            self.assertTrue(isinstance(b, objectify.BoolElement), (b.text, type(b)))\n        self.assertEqual(True,  root.b[0])\n        self.assertEqual(False, root.b[1])\n        for s in root.s:\n            self.assertTrue(isinstance(s, objectify.StringElement), (s.text, type(s)))\n        self.assertTrue(isinstance(root.n, objectify.NoneElement), root.n)\n        self.assertEqual(None, root.n)\n\n    def test_standard_lookup_fuzz(self):\n        SPACES = ('',) * 10 + ('\\t', 'x', '\\n', '\\r\\n', '\\xA0', '\\x0A', '\\u200A', '\\u200B')\n        DIGITS = ('', '0', '1', '11', '21', '345678', '9'*20)\n\n        def space(_choice=random.choice):\n            return _choice(SPACES)\n\n        fuzz = [\n            '<t>%s</t>\\n' % (space() + sign + digits + point + fraction + exp + exp_sign + exp_digits + special + space())\n            for sign in ('', '+', '-')\n            for digits in DIGITS\n            for point in ('', '.')\n            for fraction in DIGITS\n            for exp in ('', 'E')\n            for exp_sign in ('', '+', '-')\n            for exp_digits in DIGITS\n            for special in ('', 'INF', 'inf', 'NaN', 'nan', 'an', 'na', 'ana', 'nf')\n        ]\n\n        root = self.XML('''\\\n        <root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n        ''' + ''.join(fuzz) + '''\n        </root>\n        ''')\n\n        test_count = 0\n        for el in root.iterchildren():\n            text = el.text\n            expected_type = objectify.ObjectifiedElement\n            if text:\n                try:\n                    int(text)\n                    expected_type = objectify.IntElement\n                except ValueError:\n                    try:\n                        float(text)\n                        expected_type = objectify.FloatElement\n                    except ValueError:\n                        expected_type = objectify.StringElement\n\n            self.assertTrue(isinstance(el, expected_type), (text, expected_type, type(el)))\n            test_count += 1\n        self.assertEqual(len(fuzz), test_count)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ObjectifyTestCase)])\n    suite.addTests(doctest.DocTestSuite(objectify))\n    suite.addTests([make_doctest('objectify.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_elementpath.py": "\"\"\"\nTests for the ElementPath implementation.\n\"\"\"\n\nimport sys\nimport unittest\nfrom copy import deepcopy\nfrom .common_imports import etree, HelperTestCase\n\n\ndef summarize(elem):\n    return elem.tag\n\ndef summarize_list(seq):\n    return list(map(summarize, seq))\n\ndef normalize_crlf(tree):\n    for elem in tree.getiterator():\n        if elem.text: elem.text = elem.text.replace(\"\\r\\n\", \"\\n\")\n        if elem.tail: elem.tail = elem.tail.replace(\"\\r\\n\", \"\\n\")\n\n\nclass EtreeElementPathTestCase(HelperTestCase):\n    etree = etree\n    from lxml import _elementpath\n\n    def test_cache(self):\n        self._elementpath._cache.clear()\n        el = self.etree.XML(b'<a><b><c/><c/></b></a>')\n        self.assertFalse(self._elementpath._cache)\n\n        self.assertTrue(el.findall('b/c'))\n        self.assertEqual(1, len(self._elementpath._cache))\n        self.assertTrue(el.findall('b/c'))\n        self.assertEqual(1, len(self._elementpath._cache))\n        self.assertFalse(el.findall('xxx'))\n        self.assertEqual(2, len(self._elementpath._cache))\n        self.assertFalse(el.findall('xxx'))\n        self.assertEqual(2, len(self._elementpath._cache))\n        self.assertTrue(el.findall('b/c'))\n        self.assertEqual(2, len(self._elementpath._cache))\n\n    def _assert_tokens(self, tokens, path, namespaces=None):\n        self.assertEqual(tokens, list(self._elementpath.xpath_tokenizer(path, namespaces)))\n\n    def test_tokenizer(self):\n        assert_tokens = self._assert_tokens\n        assert_tokens(\n            [('/', '')],\n            '/',\n        )\n        assert_tokens(\n            [('.', ''), ('/', ''), ('', 'a'), ('/', ''), ('', 'b'), ('/', ''), ('', 'c')],\n            './a/b/c',\n        )\n        assert_tokens(\n            [('/', ''), ('', 'a'), ('/', ''), ('', 'b'), ('/', ''), ('', 'c')],\n            '/a/b/c',\n        )\n        assert_tokens(\n            [('/', ''), ('', '{nsx}a'), ('/', ''), ('', '{nsy}b'), ('/', ''), ('', 'c')],\n            '/x:a/y:b/c',\n            {'x': 'nsx', 'y': 'nsy'},\n        )\n        assert_tokens(\n            [('/', ''), ('', '{nsx}a'), ('/', ''), ('', '{nsy}b'), ('/', ''), ('', '{nsnone}c')],\n            '/x:a/y:b/c',\n            {'x': 'nsx', 'y': 'nsy', None: 'nsnone'},\n        )\n\n    def test_tokenizer_predicates(self):\n        assert_tokens = self._assert_tokens\n        assert_tokens(\n            [('', 'a'), ('[', ''), ('', 'b'), (']', '')],\n            'a[b]',\n        )\n        assert_tokens(\n            [('', 'a'), ('[', ''), ('', 'b'), ('=', ''), ('\"abc\"', ''), (']', '')],\n            'a[b=\"abc\"]',\n        )\n        assert_tokens(\n            [('', 'a'), ('[', ''), ('.', ''), ('', ''), ('=', ''), ('', ''), ('\"abc\"', ''), (']', '')],\n            'a[. = \"abc\"]',\n        )\n\n    def test_xpath_tokenizer(self):\n        # Test the XPath tokenizer.  Copied from CPython's \"test_xml_etree.py\"\n        ElementPath = self._elementpath\n\n        def check(p, expected, namespaces=None):\n            self.assertEqual([op or tag\n                              for op, tag in ElementPath.xpath_tokenizer(p, namespaces)],\n                             expected)\n\n        # tests from the xml specification\n        check(\"*\", ['*'])\n        check(\"text()\", ['text', '()'])\n        check(\"@name\", ['@', 'name'])\n        check(\"@*\", ['@', '*'])\n        check(\"para[1]\", ['para', '[', '1', ']'])\n        check(\"para[last()]\", ['para', '[', 'last', '()', ']'])\n        check(\"*/para\", ['*', '/', 'para'])\n        check(\"/doc/chapter[5]/section[2]\",\n              ['/', 'doc', '/', 'chapter', '[', '5', ']',\n               '/', 'section', '[', '2', ']'])\n        check(\"chapter//para\", ['chapter', '//', 'para'])\n        check(\"//para\", ['//', 'para'])\n        check(\"//olist/item\", ['//', 'olist', '/', 'item'])\n        check(\".\", ['.'])\n        check(\".//para\", ['.', '//', 'para'])\n        check(\"..\", ['..'])\n        check(\"../@lang\", ['..', '/', '@', 'lang'])\n        check(\"chapter[title]\", ['chapter', '[', 'title', ']'])\n        check(\"employee[@secretary and @assistant]\", ['employee',\n              '[', '@', 'secretary', '', 'and', '', '@', 'assistant', ']'])\n\n        # additional tests\n        check(\"@{ns}attr\", ['@', '{ns}attr'])\n        check(\"{http://spam}egg\", ['{http://spam}egg'])\n        check(\"./spam.egg\", ['.', '/', 'spam.egg'])\n        check(\".//{http://spam}egg\", ['.', '//', '{http://spam}egg'])\n\n        # wildcard tags\n        check(\"{ns}*\", ['{ns}*'])\n        check(\"{}*\", ['{}*'])\n        check(\"{*}tag\", ['{*}tag'])\n        check(\"{*}*\", ['{*}*'])\n        check(\".//{*}tag\", ['.', '//', '{*}tag'])\n\n        # namespace prefix resolution\n        check(\"./xsd:type\", ['.', '/', '{http://www.w3.org/2001/XMLSchema}type'],\n              {'xsd': 'http://www.w3.org/2001/XMLSchema'})\n        check(\"type\", ['{http://www.w3.org/2001/XMLSchema}type'],\n              {'': 'http://www.w3.org/2001/XMLSchema'})\n        check(\"@xsd:type\", ['@', '{http://www.w3.org/2001/XMLSchema}type'],\n              {'xsd': 'http://www.w3.org/2001/XMLSchema'})\n        check(\"@type\", ['@', 'type'],\n              {'': 'http://www.w3.org/2001/XMLSchema'})\n        check(\"@{*}type\", ['@', '{*}type'],\n              {'': 'http://www.w3.org/2001/XMLSchema'})\n        check(\"@{ns}attr\", ['@', '{ns}attr'],\n              {'': 'http://www.w3.org/2001/XMLSchema',\n               'ns': 'http://www.w3.org/2001/XMLSchema'})\n\n    def test_find(self):\n        \"\"\"\n        Test find methods (including xpath syntax).\n        Originally copied from 'selftest.py'.\n        \"\"\"\n        elem = etree.XML(\"\"\"\n        <body>\n          <tag class='a'>text</tag>\n          <tag class='b' />\n          <section>\n            <tag class='b' id='inner'>subtext</tag>\n          </section>\n        </body>\n        \"\"\")\n\n        self.assertEqual(elem.find(\"tag\").tag,\n                         'tag')\n        self.assertEqual(etree.ElementTree(elem).find(\"tag\").tag,\n                         'tag')\n        self.assertEqual(elem.find(\"section/tag\").tag,\n                         'tag')\n        self.assertEqual(etree.ElementTree(elem).find(\"section/tag\").tag,\n                         'tag')\n\n        self.assertEqual(elem.findtext(\"tag\"),\n                         'text')\n        self.assertEqual(elem.findtext(\"tog\"),\n                         None)\n        self.assertEqual(elem.findtext(\"tog\", \"default\"),\n                         'default')\n        self.assertEqual(etree.ElementTree(elem).findtext(\"tag\"),\n                         'text')\n        self.assertEqual(elem.findtext(\"section/tag\"),\n                         'subtext')\n        self.assertEqual(etree.ElementTree(elem).findtext(\"section/tag\"),\n                         'subtext')\n\n        self.assertEqual(summarize_list(elem.findall(\"tag\")),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\"*\")),\n                         ['tag', 'tag', 'section'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag\")),\n                         ['tag', 'tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\"section/tag\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"section//tag\")),\n                         ['tag'])\n\n        self.assertEqual(summarize_list(elem.findall(\"section/*\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"section//*\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"section/.//*\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"*/*\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"*//*\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"*/tag\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"*/./tag\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\"./tag\")),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag\")),\n                         ['tag', 'tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\"././tag\")),\n                         ['tag', 'tag'])\n\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@class]\")),\n                         ['tag', 'tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[ @class]\")),\n                         ['tag', 'tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@class ]\")),\n                         ['tag', 'tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[  @class  ]\")),\n                         ['tag', 'tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@class='a']\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall('.//tag[@class=\"a\"]')),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@class='b']\")),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall('.//tag[@class=\"b\"]')),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall('.//tag[@class = \"b\"]')),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@id]\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@class][@id]\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//section[tag]\")),\n                         ['section'])\n        self.assertEqual(summarize_list(elem.findall(\".//section[element]\")),\n                         [])\n\n        self.assertEqual(summarize_list(elem.findall(\".//section[tag='subtext']\")),\n                         ['section'])\n        self.assertEqual(summarize_list(elem.findall(\".//section[tag ='subtext']\")),\n                         ['section'])\n        self.assertEqual(summarize_list(elem.findall(\".//section[tag= 'subtext']\")),\n                         ['section'])\n        self.assertEqual(summarize_list(elem.findall(\".//section[tag = 'subtext']\")),\n                         ['section'])\n        self.assertEqual(summarize_list(elem.findall(\".//section[  tag   =   'subtext'  ]\")),\n                         ['section'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[.='subtext']\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[. ='subtext']\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall('.//tag[.= \"subtext\"]')),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[. = 'subtext']\")),\n                         ['tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[. = 'subtext ']\")),\n                         [])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[.= ' subtext']\")),\n                         [])\n\n        self.assertEqual(summarize_list(elem.findall(\"../tag\")),\n                         [])\n        self.assertEqual(summarize_list(elem.findall(\"section/../tag\")),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(etree.ElementTree(elem).findall(\"./tag\")),\n                         ['tag', 'tag'])\n\n        self.assertEqual(summarize_list(etree.ElementTree(elem).findall(\"/tag\")),\n                         ['tag', 'tag'])\n        # This would be correct:\n        if False:\n            self.assertEqual(summarize_list(etree.ElementTree(elem).findall(\"/body\")),\n                            ['body'])\n\n        # duplicate section => 2x tag matches\n        elem[1] = deepcopy(elem[2])\n        self.assertEqual(summarize_list(elem.findall(\".//section[tag = 'subtext']\")),\n                         ['section', 'section'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[. = 'subtext']\")),\n                         ['tag', 'tag'])\n        self.assertEqual(summarize_list(elem.findall(\".//tag[@class][@id]\")),\n                         ['tag', 'tag'])\n\n    def test_find_warning(self):\n        etree = self.etree\n        elem = etree.XML(\"\"\"\n        <body>\n          <tag class='a'>text</tag>\n          <tag class='b' />\n          <section>\n            <tag class='b' id='inner'>subtext</tag>\n          </section>\n        </body>\n        \"\"\")\n\n        # FIXME: ET's Path module handles this case incorrectly; this gives\n        # a warning in 1.3, and the behaviour will be modified in the future.\n        self.assertWarnsRegex(\n            FutureWarning, \".*If you rely on the current behaviour, change it to './tag'\",\n            etree.ElementTree(elem).findall, \"/tag\")\n        self.assertWarnsRegex(\n            FutureWarning, \".*If you rely on the current behaviour, change it to './tag'\",\n            etree.ElementTree(elem).findtext, \"/tag\")\n        self.assertWarnsRegex(\n            FutureWarning, \".*If you rely on the current behaviour, change it to './tag'\",\n            etree.ElementTree(elem).find, \"/tag\")\n        self.assertWarnsRegex(\n            FutureWarning, \".*If you rely on the current behaviour, change it to './tag'\",\n            etree.ElementTree(elem).iterfind, \"/tag\")\n\n\nclass ElementTreeElementPathTestCase(EtreeElementPathTestCase):\n    import xml.etree.ElementTree as etree\n    import xml.etree.ElementPath as _elementpath\n\n    test_cache = unittest.skip(\"lxml-only\")(EtreeElementPathTestCase.test_cache)\n    test_tokenizer = unittest.skip(\"lxml-only\")(EtreeElementPathTestCase.test_tokenizer)\n\n    if sys.version_info < (3, 8):\n        test_xpath_tokenizer = unittest.skip(\"lxml-only\")(EtreeElementPathTestCase.test_xpath_tokenizer)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(EtreeElementPathTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementTreeElementPathTestCase)])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_doctestcompare.py": "import unittest\n\nfrom lxml import etree\nfrom .common_imports import HelperTestCase\nfrom lxml.doctestcompare import LXMLOutputChecker, PARSE_HTML, PARSE_XML\n\n\nclass DummyInput:\n    def __init__(self, **kw):\n        for name, value in kw.items():\n            setattr(self, name, value)\n\n\ndef indent(elem, level=0):\n    i = \"\\n\" + level*\"  \"\n    if len(elem):\n        if not elem.text or not elem.text.strip():\n            elem.text = i + \"  \"\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = i\n        for elem in elem:\n            indent(elem, level+1)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = i\n    else:\n        if level and (not elem.tail or not elem.tail.strip()):\n            elem.tail = i\n\n\nclass DoctestCompareTest(HelperTestCase):\n    _checker = LXMLOutputChecker()\n\n    def compare(self, want, got, html=False):\n        if html:\n            options = PARSE_HTML\n        else:\n            options = PARSE_XML\n\n        parse = self._checker.get_parser(want, got, options)\n        want_doc = parse(want)\n        got_doc = parse(got)\n        return self._checker.collect_diff(\n            want_doc, got_doc, html, indent=0).lstrip()\n\n    def assert_diff(self, want, got, diff, html=False):\n        self.assertEqual(self.compare(want, got, html), diff)\n\n    def assert_nodiff(self, want, got, html=False):\n        root = etree.fromstring(want)\n        root.tail = '\\n'\n        indent(root)\n        diff = etree.tostring(\n            root, encoding='unicode', method=html and 'html' or 'xml')\n        self.assert_diff(want, got, diff, html=html)\n\n    def test_equal_input(self):\n        self.assert_nodiff(\n            '<p title=\"expected\">Expected</p>',\n            '<p title=\"expected\">Expected</p>')\n\n    def test_differing_tags(self):\n        self.assert_diff(\n            '<p title=\"expected\">Expected</p>',\n            '<b title=\"expected\">Expected</b>',\n            '<p (got: b) title=\"expected\">Expected</p (got: b)>\\n')\n\n    def test_tags_upper_lower_case(self):\n        self.assert_diff(\n            '<p title=\"expected\">Expected</p>',\n            '<P title=\"expected\">Expected</P>',\n            '<p (got: P) title=\"expected\">Expected</p (got: P)>\\n')\n\n    def test_tags_upper_lower_case_html(self):\n        self.assert_nodiff(\n            '<html><body><p title=\"expected\">Expected</p></body></html>',\n            '<HTML><BODY><P title=\"expected\">Expected</P></BODY></HTML>',\n            html=True)\n\n    def test_differing_attributes(self):\n        self.assert_diff(\n            '<p title=\"expected\">Expected</p>',\n            '<p title=\"actual\">Actual</p>',\n            '<p title=\"expected (got: actual)\">Expected (got: Actual)</p>\\n')\n\n    def test_extra_children(self):\n        # https://bugs.launchpad.net/lxml/+bug/1238503\n        self.assert_diff(\n            '<p><span>One</span></p>',\n            '<p><span>One</span><b>Two</b><em>Three</em></p>',\n            '<p>\\n'\n            '  <span>One</span>\\n'\n            '  +<b>Two</b>\\n'\n            '  +<em>Three</em>\\n'\n            '</p>\\n')\n\n    def test_missing_children(self):\n        self.assert_diff(\n            '<p><span>One</span><b>Two</b><em>Three</em></p>',\n            '<p><span>One</span></p>',\n            '<p>\\n'\n            '  <span>One</span>\\n'\n            '  -<b>Two</b>\\n'\n            '  -<em>Three</em>\\n'\n            '</p>\\n')\n\n    def test_extra_attributes(self):\n        self.assert_diff(\n            '<p><span class=\"foo\">Text</span></p>',\n            '<p><span class=\"foo\" id=\"bar\">Text</span></p>',\n            '<p>\\n'\n            '  <span class=\"foo\" +id=\"bar\">Text</span>\\n'\n            '</p>\\n')\n\n    def test_missing_attributes(self):\n        self.assert_diff(\n            '<p><span class=\"foo\" id=\"bar\">Text</span></p>',\n            '<p><span class=\"foo\">Text</span></p>',\n            '<p>\\n'\n            '  <span class=\"foo\" -id=\"bar\">Text</span>\\n'\n            '</p>\\n')\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(DoctestCompareTest)])\n    return suite\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/lxml/tests/test_relaxng.py": "\"\"\"\nTest cases related to RelaxNG parsing and validation\n\"\"\"\n\n\nimport unittest\n\nfrom .common_imports import (\n    etree, BytesIO, _bytes, HelperTestCase, fileInTestDir, make_doctest, skipif\n)\n\ntry:\n    import rnc2rng\nexcept ImportError:\n    rnc2rng = None\n\n\nclass ETreeRelaxNGTestCase(HelperTestCase):\n    def test_relaxng(self):\n        tree_valid = self.parse('<a><b></b></a>')\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema = self.parse('''\\\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <zeroOrMore>\n     <element name=\"b\">\n       <text />\n     </element>\n  </zeroOrMore>\n</element>\n''')\n        schema = etree.RelaxNG(schema)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.error_log.filter_from_errors())\n\n        self.assertFalse(schema.validate(tree_invalid))\n        self.assertTrue(schema.error_log.filter_from_errors())\n\n        self.assertTrue(schema.validate(tree_valid))             # repeat valid\n        self.assertFalse(schema.error_log.filter_from_errors())  # repeat valid\n\n    def test_relaxng_stringio(self):\n        tree_valid = self.parse('<a><b></b></a>')\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema_file = BytesIO(b'''\\\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <zeroOrMore>\n     <element name=\"b\">\n       <text />\n     </element>\n  </zeroOrMore>\n</element>\n''')\n        schema = etree.RelaxNG(file=schema_file)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.validate(tree_invalid))\n\n    def test_relaxng_elementtree_error(self):\n        self.assertRaises(ValueError, etree.RelaxNG, etree.ElementTree())\n\n    def test_relaxng_error(self):\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema = self.parse('''\\\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <zeroOrMore>\n     <element name=\"b\">\n       <text />\n     </element>\n  </zeroOrMore>\n</element>\n''')\n        schema = etree.RelaxNG(schema)\n        self.assertFalse(schema.validate(tree_invalid))\n        errors = schema.error_log\n        self.assertTrue([log for log in errors\n                         if log.level_name == \"ERROR\"])\n        self.assertTrue([log for log in errors\n                         if \"not expect\" in log.message])\n\n    def test_relaxng_generic_error(self):\n        tree_invalid = self.parse('''\\\n        <test>\n          <reference id=\"my-ref\">This is my unique ref.</reference>\n          <data ref=\"my-ref\">Valid data</data>\n          <data ref=\"myref\">Invalid data</data>\n        </test>\n        ''')\n        schema = self.parse('''\\\n        <grammar datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\"\n                 xmlns=\"http://relaxng.org/ns/structure/1.0\">\n          <define name=\"by-ref\">\n            <data type=\"IDREF\"/>\n          </define>\n          <start>\n            <element name=\"test\">\n              <zeroOrMore>\n                <element name=\"reference\">\n                  <attribute name=\"id\">\n                    <data type=\"ID\"/>\n                  </attribute>\n                  <text/>\n                </element>\n              </zeroOrMore>\n              <zeroOrMore>\n                <element name=\"data\">\n                  <attribute name=\"ref\">\n                    <data type=\"IDREF\"/>\n                  </attribute>\n                  <text/>\n                </element>\n              </zeroOrMore>\n            </element>\n          </start>\n        </grammar>\n        ''')\n\n        schema = etree.RelaxNG(schema)\n        self.assertFalse(schema.validate(tree_invalid))\n        errors = schema.error_log\n        self.assertTrue(errors)\n        self.assertTrue([log for log in errors if \"IDREF\" in log.message])\n        self.assertTrue([log for log in errors if \"myref\" in log.message])\n\n    def test_relaxng_invalid_schema(self):\n        schema = self.parse('''\\\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <zeroOrMore>\n     <element name=\"b\" />\n  </zeroOrMore>\n</element>\n''')\n        self.assertRaises(etree.RelaxNGParseError,\n                          etree.RelaxNG, schema)\n\n    def test_relaxng_invalid_schema2(self):\n        schema = self.parse('''\\\n<grammar xmlns=\"http://relaxng.org/ns/structure/1.0\" />\n''')\n        self.assertRaises(etree.RelaxNGParseError,\n                          etree.RelaxNG, schema)\n\n    def test_relaxng_invalid_schema3(self):\n        schema = self.parse('''\\\n<grammar xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <define name=\"test\">\n    <element name=\"test\"/>\n  </define>\n</grammar>\n''')\n        self.assertRaises(etree.RelaxNGParseError,\n                          etree.RelaxNG, schema)\n\n    def test_relaxng_invalid_schema4(self):\n        # segfault\n        schema = self.parse('''\\\n<element name=\"a\" xmlns=\"mynamespace\" />\n''')\n        self.assertRaises(etree.RelaxNGParseError,\n                          etree.RelaxNG, schema)\n\n    def test_relaxng_include(self):\n        # this will only work if we access the file through path or\n        # file object..\n        f = open(fileInTestDir('test1.rng'), 'rb')\n        try:\n            schema = etree.RelaxNG(file=f)\n        finally:\n            f.close()\n\n    def test_relaxng_shortcut(self):\n        tree_valid = self.parse('<a><b></b></a>')\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema = self.parse('''\\\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <zeroOrMore>\n     <element name=\"b\">\n       <text />\n     </element>\n  </zeroOrMore>\n</element>\n''')\n        self.assertTrue(tree_valid.relaxng(schema))\n        self.assertFalse(tree_invalid.relaxng(schema))\n\n    def test_multiple_elementrees(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        schema = etree.RelaxNG( self.parse('''\\\n<element name=\"a\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <element name=\"b\">\n    <text />\n  </element>\n  <element name=\"c\">\n    <text />\n  </element>\n</element>\n''') )\n        self.assertTrue(schema.validate(tree))\n        self.assertFalse(schema.error_log.filter_from_errors())\n\n        self.assertTrue(schema.validate(tree))                   # repeat valid\n        self.assertFalse(schema.error_log.filter_from_errors())  # repeat valid\n\n        schema = etree.RelaxNG( self.parse('''\\\n<element name=\"b\" xmlns=\"http://relaxng.org/ns/structure/1.0\">\n  <text />\n</element>\n''') )\n        c_tree = etree.ElementTree(tree.getroot()[1])\n        self.assertEqual(self._rootstring(c_tree), b'<c>C</c>')\n        self.assertFalse(schema.validate(c_tree))\n        self.assertTrue(schema.error_log.filter_from_errors())\n\n        b_tree = etree.ElementTree(tree.getroot()[0])\n        self.assertEqual(self._rootstring(b_tree), b'<b>B</b>')\n        self.assertTrue(schema.validate(b_tree))\n        self.assertFalse(schema.error_log.filter_from_errors())\n\n\nclass RelaxNGCompactTestCase(HelperTestCase):\n\n    pytestmark = skipif('rnc2rng is None')\n\n    def test_relaxng_compact(self):\n        tree_valid = self.parse('<a><b>B</b><c>C</c></a>')\n        tree_invalid = self.parse('<a><b></b></a>')\n        schema = etree.RelaxNG(file=fileInTestDir('test.rnc'))\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.validate(tree_invalid))\n\n    def test_relaxng_compact_file_obj(self):\n        with open(fileInTestDir('test.rnc')) as f:\n            schema = etree.RelaxNG(file=f)\n\n        tree_valid = self.parse('<a><b>B</b><c>C</c></a>')\n        tree_invalid = self.parse('<a><b></b></a>')\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.validate(tree_invalid))\n\n    def test_relaxng_compact_str(self):\n        tree_valid = self.parse('<a><b>B</b></a>')\n        tree_invalid = self.parse('<a><b>X</b></a>')\n        rnc_str = 'element a { element b { \"B\" } }'\n        schema = etree.RelaxNG.from_rnc_string(rnc_str)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.validate(tree_invalid))\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeRelaxNGTestCase)])\n    suite.addTests(\n        [make_doctest('validation.txt')])\n    if rnc2rng is not None:\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(RelaxNGCompactTestCase)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_external_document.py": "\"\"\"\nTest cases related to direct loading of external libxml2 documents\n\"\"\"\n\n\nimport sys\nimport unittest\n\nfrom .common_imports import HelperTestCase, etree\n\nDOC_NAME = b'libxml2:xmlDoc'\nDESTRUCTOR_NAME = b'destructor:xmlFreeDoc'\n\n\nclass ExternalDocumentTestCase(HelperTestCase):\n    def setUp(self):\n        try:\n            import ctypes\n            from ctypes import pythonapi\n            from ctypes.util import find_library\n        except ImportError:\n            raise unittest.SkipTest(\"ctypes support missing\")\n\n        def wrap(func, restype, *argtypes):\n            func.restype = restype\n            func.argtypes = list(argtypes)\n            return func\n\n        self.get_capsule_name = wrap(pythonapi.PyCapsule_GetName,\n                                     ctypes.c_char_p, ctypes.py_object)\n        self.capsule_is_valid = wrap(pythonapi.PyCapsule_IsValid, ctypes.c_int,\n                                     ctypes.py_object, ctypes.c_char_p)\n        self.new_capsule = wrap(pythonapi.PyCapsule_New, ctypes.py_object,\n                                ctypes.c_void_p, ctypes.c_char_p,\n                                ctypes.c_void_p)\n        self.set_capsule_name = wrap(pythonapi.PyCapsule_SetName, ctypes.c_int,\n                                     ctypes.py_object, ctypes.c_char_p)\n        self.set_capsule_context = wrap(pythonapi.PyCapsule_SetContext,\n                                        ctypes.c_int, ctypes.py_object,\n                                        ctypes.c_char_p)\n        self.get_capsule_context = wrap(pythonapi.PyCapsule_GetContext,\n                                        ctypes.c_char_p, ctypes.py_object)\n        self.get_capsule_pointer = wrap(pythonapi.PyCapsule_GetPointer,\n                                        ctypes.c_void_p, ctypes.py_object,\n                                        ctypes.c_char_p)\n        self.set_capsule_pointer = wrap(pythonapi.PyCapsule_SetPointer,\n                                        ctypes.c_int, ctypes.py_object,\n                                        ctypes.c_void_p)\n        self.set_capsule_destructor = wrap(pythonapi.PyCapsule_SetDestructor,\n                                           ctypes.c_int, ctypes.py_object,\n                                           ctypes.c_void_p)\n        self.PyCapsule_Destructor = ctypes.CFUNCTYPE(None, ctypes.py_object)\n        libxml2 = ctypes.CDLL(find_library('xml2'))\n        self.create_doc = wrap(libxml2.xmlReadMemory, ctypes.c_void_p,\n                               ctypes.c_char_p, ctypes.c_int, ctypes.c_char_p,\n                               ctypes.c_char_p, ctypes.c_int)\n        self.free_doc = wrap(libxml2.xmlFreeDoc, None, ctypes.c_void_p)\n\n    def as_capsule(self, text, capsule_name=DOC_NAME):\n        if not isinstance(text, bytes):\n            text = text.encode('utf-8')\n        doc = self.create_doc(text, len(text), b'base.xml', b'utf-8', 0)\n        ans = self.new_capsule(doc, capsule_name, None)\n        self.set_capsule_context(ans, DESTRUCTOR_NAME)\n        return ans\n\n    def test_external_document_adoption(self):\n        xml = '<r a=\"1\">t</r>'\n        self.assertRaises(TypeError, etree.adopt_external_document, None)\n        capsule = self.as_capsule(xml)\n        self.assertTrue(self.capsule_is_valid(capsule, DOC_NAME))\n        self.assertEqual(DOC_NAME, self.get_capsule_name(capsule))\n        # Create an lxml tree from the capsule (this is a move not a copy)\n        root = etree.adopt_external_document(capsule).getroot()\n        self.assertIsNone(self.get_capsule_name(capsule))\n        self.assertEqual(root.text, 't')\n        root.text = 'new text'\n        # Now reset the capsule so we can copy it\n        self.assertEqual(0, self.set_capsule_name(capsule, DOC_NAME))\n        self.assertEqual(0, self.set_capsule_context(capsule, b'invalid'))\n        # Create an lxml tree from the capsule (this is a copy not a move)\n        root2 = etree.adopt_external_document(capsule).getroot()\n        self.assertEqual(self.get_capsule_context(capsule), b'invalid')\n        # Check that the modification to the tree using the transferred\n        # document was successful\n        self.assertEqual(root.text, root2.text)\n        # Check that further modifications do not show up in the copy (they are\n        # disjoint)\n        root.text = 'other text'\n        self.assertNotEqual(root.text, root2.text)\n        # delete root and ensure root2 survives\n        del root\n        self.assertEqual(root2.text, 'new text')\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    if sys.platform != 'win32':\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ExternalDocumentTestCase)])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/fuzz_xml_parse.py": "\"\"\"\nFuzzes the lxml.etree.XML function with the Atheris fuzzer.\n\nThe goal is to catch unhandled exceptions and potential \nmemory corruption issues in auto-generated code.\n\"\"\"\n\nimport atheris\nimport sys\n\nfrom lxml import etree\n\n\ndef test_etree_xml(data):\n    fdp = atheris.FuzzedDataProvider(data)\n    try:\n        etree.XML(fdp.ConsumeUnicode(sys.maxsize))\n    except etree.XMLSyntaxError:\n        pass\n    return\n\n\nif __name__ == \"__main__\":\n    atheris.Setup(sys.argv, test_etree_xml, enable_python_coverage=True)\n    atheris.Fuzz()\n", "src/lxml/tests/test_isoschematron.py": "\"\"\"\nTest cases related to ISO-Schematron parsing and validation\n\"\"\"\n\n\nimport unittest\nfrom lxml import isoschematron\n\nfrom .common_imports import etree, HelperTestCase, fileInTestDir, doctest, make_doctest\n\n\nclass ETreeISOSchematronTestCase(HelperTestCase):\n    def test_schematron(self):\n        tree_valid = self.parse('<AAA><BBB/><CCC/></AAA>')\n        tree_invalid = self.parse('<AAA><BBB/><CCC/><DDD/></AAA>')\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n    <pattern id=\"OpenModel\">\n        <title>Open Model</title>\n        <rule context=\"AAA\">\n            <assert test=\"BBB\"> BBB element is not present</assert>\n            <assert test=\"CCC\"> CCC element is not present</assert>\n        </rule>\n    </pattern>\n    <pattern id=\"ClosedModel\">\n        <title>Closed model\"</title>\n        <rule context=\"AAA\">\n            <assert test=\"BBB\"> BBB element is not present</assert>\n            <assert test=\"CCC\"> CCC element is not present</assert>\n            <assert test=\"count(BBB|CCC) = count (*)\">There is an extra element</assert>\n        </rule>\n    </pattern>\n</schema>\n''')\n\n        schema = isoschematron.Schematron(schema)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertTrue(not schema.validate(tree_invalid))\n\n    def test_schematron_elementtree_error(self):\n        self.assertRaises(ValueError, isoschematron.Schematron, etree.ElementTree())\n\n    # an empty pattern is valid in iso schematron\n    def test_schematron_empty_pattern(self):\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n    <pattern id=\"OpenModel\">\n        <title>Open model</title>\n    </pattern>\n</schema>\n''')\n        schema = isoschematron.Schematron(schema)\n        self.assertTrue(schema)\n\n    @unittest.skipIf(not isoschematron.schematron_schema_valid_supported,\n                     'SchematronParseError is only raised when validate_schema is true')\n    def test_schematron_invalid_schema_empty(self):\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" />\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          isoschematron.Schematron, schema)\n\n    def test_schematron_invalid_schema_namespace(self):\n        schema = self.parse('''\\\n<schema xmlns=\"mynamespace\" />\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          isoschematron.Schematron, schema)\n\n    def test_schematron_invalid_namespace_prefix(self):\n        schema = self.parse('''\\\n<xml:i />\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          isoschematron.Schematron, schema)\n\n    def test_schematron_missing_namespace_prefix(self):\n        schema = self.parse('''\\\n<rr />\n''')\n        self.assertRaises(etree.SchematronParseError,\n                          isoschematron.Schematron, schema)\n\n    def test_schematron_from_tree(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(isinstance(schematron, isoschematron.Schematron))\n\n    def test_schematron_from_element(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        schematron = isoschematron.Schematron(schema.getroot())\n        self.assertTrue(isinstance(schematron, isoschematron.Schematron))\n\n    def test_schematron_from_file(self):\n        schematron = isoschematron.Schematron(file=fileInTestDir('test.sch'))\n        self.assertTrue(isinstance(schematron, isoschematron.Schematron))\n\n    def test_schematron_call(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n\n    def test_schematron_validate(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron.validate(tree_valid), schematron.error_log)\n        valid = schematron.validate(tree_invalid)\n        self.assertTrue(not valid)\n\n    def test_schematron_assertValid(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        self.assertRaises(etree.DocumentInvalid, schematron.assertValid,\n                          tree_invalid)\n\n    def test_schematron_error_log(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(len(schematron.error_log), 1,\n                          'expected single error: %s (%s errors)' %\n                          (schematron.error_log, len(schematron.error_log)))\n\n    def test_schematron_result_report(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        schematron = isoschematron.Schematron(schema, store_report=True)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertTrue(\n            isinstance(schematron.validation_report, etree._ElementTree),\n            'expected a validation report result tree, got: %s' % schematron.validation_report)\n\n        schematron = isoschematron.Schematron(schema, store_report=False)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertTrue(schematron.validation_report is None,\n            'validation reporting switched off, still: %s' % schematron.validation_report)\n\n    def test_schematron_store_schematron(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron.validator_xslt is None)\n\n        schematron = isoschematron.Schematron(schema, store_schematron=True)\n        self.assertTrue(isinstance(schematron.schematron, etree._ElementTree),\n                     'expected schematron schema to be stored')\n\n    def test_schematron_store_xslt(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron.validator_xslt is None)\n\n        schematron = isoschematron.Schematron(schema, store_xslt=True)\n        self.assertTrue(isinstance(schematron.validator_xslt, etree._ElementTree),\n                     'expected validator xslt to be stored')\n\n    def test_schematron_abstract(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:title>iso schematron validation</sch:title>\n  <sch:ns uri=\"http://www.w3.org/2001/XMLSchema-instance\" prefix=\"xsi\"/>\n  <sch:ns uri=\"http://codespeak.net/lxml/objectify/pytype\" prefix=\"py\"/>\n\n  <!-- of course, these only really make sense when combined with a schema that\n       ensures datatype xs:dateTime -->\n\n  <sch:pattern abstract=\"true\" id=\"abstract.dateTime.tz_utc\">\n    <sch:rule context=\"$datetime\">\n      <sch:let name=\"tz\" value=\"concat(substring-after(substring-after(./text(), 'T'), '+'), substring-after(substring-after(./text(), 'T'), '-'))\"/>\n      <sch:let name=\"lastchar\" value=\"substring(./text(), string-length(./text()))\"/>\n      <sch:assert test=\"$lastchar='Z' or $tz='00:00'\">[ERROR] element (<sch:value-of select=\"name(.)\"/>) dateTime value (<sch:value-of select=\".\"/>) is not qualified as UTC (tz: <sch:value-of select=\"$tz\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern abstract=\"true\" id=\"abstract.dateTime.tz_utc_nillable\">\n    <sch:rule context=\"$datetime\">\n      <sch:let name=\"tz\" value=\"concat(substring-after(substring-after(./text(), 'T'), '+'), substring-after(substring-after(./text(), 'T'), '-'))\"/>\n      <sch:let name=\"lastchar\" value=\"substring(./text(), string-length(./text()))\"/>\n      <sch:assert test=\"@xsi:nil='true'  or ($lastchar='Z' or $tz='00:00')\">[ERROR] element (<sch:value-of select=\"name(.)\"/>) dateTime value (<sch:value-of select=\".\"/>) is not qualified as UTC (tz: <sch:value-of select=\"$tz\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern is-a=\"abstract.dateTime.tz_utc\" id=\"datetime\" >\n    <sch:param name=\"datetime\" value=\"datetime\"/>\n  </sch:pattern>\n\n  <sch:pattern is-a=\"abstract.dateTime.tz_utc_nillable\" id=\"nillableDatetime\">\n    <sch:param name=\"datetime\" value=\"nillableDatetime\"/>\n  </sch:pattern>\n\n</sch:schema>\n''')\n        valid_trees = [\n            self.parse('''\\\n<root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime>2009-12-10T15:21:00Z</datetime>\n  <nillableDatetime xsi:nil=\"true\"/>\n</root>\n'''),\n            self.parse('''\\\n<root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime>2009-12-10T15:21:00Z</datetime>\n  <nillableDatetime>2009-12-10T15:21:00Z</nillableDatetime>\n</root>\n'''),\n            self.parse('''\\\n<root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime>2009-12-10T15:21:00+00:00</datetime>\n  <nillableDatetime>2009-12-10T15:21:00-00:00</nillableDatetime>\n</root>\n'''),\n            ]\n\n        schematron = isoschematron.Schematron(schema)\n        for tree_valid in valid_trees:\n            self.assertTrue(schematron(tree_valid), schematron.error_log)\n\n        tree_invalid = self.parse('''\\\n<root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime>2009-12-10T16:21:00+01:00</datetime>\n  <nillableDatetime>2009-12-10T16:21:00+01:00</nillableDatetime>\n</root>\n''')\n        expected = 2\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        tree_invalid = self.parse('''\\\n<root xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime xsi:nil=\"true\"/>\n  <nillableDatetime>2009-12-10T16:21:00Z</nillableDatetime>\n</root>\n''')\n        expected = 1\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n    def test_schematron_phases(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:title>iso schematron validation</sch:title>\n  <sch:ns uri=\"http://www.w3.org/2001/XMLSchema-instance\" prefix=\"xsi\"/>\n  <sch:ns uri=\"http://codespeak.net/lxml/objectify/pytype\" prefix=\"py\"/>\n\n  <sch:phase id=\"mandatory\">\n    <sch:active pattern=\"number_of_entries\"/>\n  </sch:phase>\n\n  <sch:phase id=\"datetime_checks\">\n    <sch:active pattern=\"datetime\"/>\n    <sch:active pattern=\"nillableDatetime\"/>\n  </sch:phase>\n\n  <sch:phase id=\"full\">\n    <sch:active pattern=\"number_of_entries\"/>\n    <sch:active pattern=\"datetime\"/>\n    <sch:active pattern=\"nillableDatetime\"/>\n  </sch:phase>\n\n  <!-- of course, these only really make sense when combined with a schema that\n       ensures datatype xs:dateTime -->\n\n  <sch:pattern abstract=\"true\" id=\"abstract.dateTime.tz_utc\">\n    <sch:rule context=\"$datetime\">\n      <sch:let name=\"tz\" value=\"concat(substring-after(substring-after(./text(), 'T'), '+'), substring-after(substring-after(./text(), 'T'), '-'))\"/>\n      <sch:let name=\"lastchar\" value=\"substring(./text(), string-length(./text()))\"/>\n      <sch:assert test=\"$lastchar='Z' or $tz='00:00'\">[ERROR] element (<sch:value-of select=\"name(.)\"/>) dateTime value (<sch:value-of select=\".\"/>) is not qualified as UTC (tz: <sch:value-of select=\"$tz\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern abstract=\"true\" id=\"abstract.dateTime.tz_utc_nillable\">\n    <sch:rule context=\"$datetime\">\n      <sch:let name=\"tz\" value=\"concat(substring-after(substring-after(./text(), 'T'), '+'), substring-after(substring-after(./text(), 'T'), '-'))\"/>\n      <sch:let name=\"lastchar\" value=\"substring(./text(), string-length(./text()))\"/>\n      <sch:assert test=\"@xsi:nil='true'  or ($lastchar='Z' or $tz='00:00')\">[ERROR] element (<sch:value-of select=\"name(.)\"/>) dateTime value (<sch:value-of select=\".\"/>) is not qualified as UTC (tz: <sch:value-of select=\"$tz\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries test</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern  id=\"datetime\" is-a=\"abstract.dateTime.tz_utc\">\n    <sch:param name=\"datetime\" value=\"datetime\"/>\n  </sch:pattern>\n\n  <sch:pattern  id=\"nillableDatetime\" is-a=\"abstract.dateTime.tz_utc_nillable\">\n    <sch:param name=\"datetime\" value=\"nillableDatetime\"/>\n  </sch:pattern>\n\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime>2009-12-10T15:21:00Z</datetime>\n  <nillableDatetime xsi:nil=\"true\"/>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <datetime>2009-12-10T16:21:00+01:00</datetime>\n  <nillableDatetime>2009-12-10T16:21:00+01:00</nillableDatetime>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        # check everything (default phase #ALL)\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 3\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        # check phase mandatory\n        schematron = isoschematron.Schematron(\n            schema, compile_params={'phase': 'mandatory'})\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 1\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        # check phase datetime_checks\n        schematron = isoschematron.Schematron(\n            schema, compile_params={'phase': 'datetime_checks'})\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 2\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        # check phase full\n        schematron = isoschematron.Schematron(\n            schema, compile_params={'phase': 'full'})\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 3\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n    def test_schematron_phases_kwarg(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:title>iso schematron validation</sch:title>\n  <sch:ns uri=\"http://www.w3.org/2001/XMLSchema-instance\" prefix=\"xsi\"/>\n  <sch:ns uri=\"http://codespeak.net/lxml/objectify/pytype\" prefix=\"py\"/>\n\n  <sch:phase id=\"mandatory\">\n    <sch:active pattern=\"number_of_entries\"/>\n  </sch:phase>\n\n  <sch:phase id=\"datetime_checks\">\n    <sch:active pattern=\"datetime\"/>\n    <sch:active pattern=\"nillableDatetime\"/>\n  </sch:phase>\n\n  <sch:phase id=\"full\">\n    <sch:active pattern=\"number_of_entries\"/>\n    <sch:active pattern=\"datetime\"/>\n    <sch:active pattern=\"nillableDatetime\"/>\n  </sch:phase>\n\n  <!-- of course, these only really make sense when combined with a schema that\n       ensures datatype xs:dateTime -->\n\n  <sch:pattern abstract=\"true\" id=\"abstract.dateTime.tz_utc\">\n    <sch:rule context=\"$datetime\">\n      <sch:let name=\"tz\" value=\"concat(substring-after(substring-after(./text(), 'T'), '+'), substring-after(substring-after(./text(), 'T'), '-'))\"/>\n      <sch:let name=\"lastchar\" value=\"substring(./text(), string-length(./text()))\"/>\n      <sch:assert test=\"$lastchar='Z' or $tz='00:00'\">[ERROR] element (<sch:value-of select=\"name(.)\"/>) dateTime value (<sch:value-of select=\".\"/>) is not qualified as UTC (tz: <sch:value-of select=\"$tz\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern abstract=\"true\" id=\"abstract.dateTime.tz_utc_nillable\">\n    <sch:rule context=\"$datetime\">\n      <sch:let name=\"tz\" value=\"concat(substring-after(substring-after(./text(), 'T'), '+'), substring-after(substring-after(./text(), 'T'), '-'))\"/>\n      <sch:let name=\"lastchar\" value=\"substring(./text(), string-length(./text()))\"/>\n      <sch:assert test=\"@xsi:nil='true'  or ($lastchar='Z' or $tz='00:00')\">[ERROR] element (<sch:value-of select=\"name(.)\"/>) dateTime value (<sch:value-of select=\".\"/>) is not qualified as UTC (tz: <sch:value-of select=\"$tz\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries test</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n\n  <sch:pattern  id=\"datetime\" is-a=\"abstract.dateTime.tz_utc\">\n    <sch:param name=\"datetime\" value=\"datetime\"/>\n  </sch:pattern>\n\n  <sch:pattern  id=\"nillableDatetime\" is-a=\"abstract.dateTime.tz_utc_nillable\">\n    <sch:param name=\"datetime\" value=\"nillableDatetime\"/>\n  </sch:pattern>\n\n</sch:schema>\n''')\n        tree_valid = self.parse('''\\\n<message xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <datetime>2009-12-10T15:21:00Z</datetime>\n  <nillableDatetime xsi:nil=\"true\"/>\n  <number_of_entries>0</number_of_entries>\n  <entries>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <datetime>2009-12-10T16:21:00+01:00</datetime>\n  <nillableDatetime>2009-12-10T16:21:00+01:00</nillableDatetime>\n  <number_of_entries>3</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        # check everything (default phase #ALL)\n        schematron = isoschematron.Schematron(schema)\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 3\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        # check phase mandatory\n        schematron = isoschematron.Schematron(schema, phase='mandatory')\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 1\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        # check phase datetime_checks\n        schematron = isoschematron.Schematron(schema, phase='datetime_checks')\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 2\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected,\n            'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n        # check phase full\n        schematron = isoschematron.Schematron(schema, phase='full')\n        self.assertTrue(schematron(tree_valid), schematron.error_log)\n        expected = 3\n        valid = schematron(tree_invalid)\n        self.assertTrue(not valid)\n        self.assertEqual(\n            len(schematron.error_log), expected, 'expected %s errors: %s (%s errors)' %\n            (expected, schematron.error_log, len(schematron.error_log)))\n\n    def test_schematron_xmlschema_embedded(self):\n        schema = self.parse('''\\\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n    xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n    <xs:element name=\"message\">\n        <xs:complexType>\n            <xs:sequence>\n                <xs:element name=\"number_of_entries\" type=\"xs:positiveInteger\">\n                    <xs:annotation>\n                        <xs:appinfo>\n                            <sch:pattern id=\"number_of_entries\">\n                                <sch:title>mandatory number_of_entries tests</sch:title>\n                                <sch:rule context=\"number_of_entries\">\n                                    <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n                                </sch:rule>\n                            </sch:pattern>\n                        </xs:appinfo>\n                    </xs:annotation>\n                </xs:element>\n                <xs:element name=\"entries\">\n                    <xs:complexType>\n                        <xs:sequence>\n                            <xs:element name=\"entry\" type=\"xs:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n                        </xs:sequence>\n                    </xs:complexType>\n                </xs:element>\n            </xs:sequence>\n        </xs:complexType>\n    </xs:element>\n</xs:schema>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>2</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>1</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        xmlschema = etree.XMLSchema(schema)\n        schematron = isoschematron.Schematron(schema)\n        # fwiw, this must also be XMLSchema-valid\n        self.assertTrue(xmlschema(tree_valid), xmlschema.error_log)\n        self.assertTrue(schematron(tree_valid))\n        # still schema-valid\n        self.assertTrue(xmlschema(tree_invalid), xmlschema.error_log)\n        self.assertTrue(not schematron(tree_invalid))\n\n    def test_schematron_relaxng_embedded(self):\n        schema = self.parse('''\\\n<grammar xmlns=\"http://relaxng.org/ns/structure/1.0\"\n  xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\"\n  datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\">\n  <start>\n    <ref name=\"message\"/>\n  </start>\n  <define name=\"message\">\n    <element name=\"message\">\n      <element name=\"number_of_entries\">\n        <!-- RelaxNG can be mixed freely with stuff from other namespaces -->\n        <sch:pattern id=\"number_of_entries\">\n          <sch:title>mandatory number_of_entries tests</sch:title>\n          <sch:rule context=\"number_of_entries\">\n            <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n          </sch:rule>\n        </sch:pattern>\n        <data type=\"positiveInteger\"/>\n      </element>\n      <element name=\"entries\">\n        <zeroOrMore>\n          <element name=\"entry\"><data type=\"string\"/></element>\n        </zeroOrMore>\n      </element>\n    </element>\n  </define>\n</grammar>\n''')\n        tree_valid = self.parse('''\\\n<message>\n  <number_of_entries>2</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        tree_invalid = self.parse('''\\\n<message>\n  <number_of_entries>1</number_of_entries>\n  <entries>\n    <entry>Entry 1</entry>\n    <entry>Entry 2</entry>\n  </entries>\n</message>\n''')\n        relaxng = etree.RelaxNG(schema)\n        schematron = isoschematron.Schematron(schema)\n        # fwiw, this must also be RelaxNG-valid\n        self.assertTrue(relaxng(tree_valid), relaxng.error_log)\n        self.assertTrue(schematron(tree_valid))\n        # still schema-valid\n        self.assertTrue(relaxng(tree_invalid), relaxng.error_log)\n        self.assertTrue(not schematron(tree_invalid))\n\n    def test_schematron_invalid_args(self):\n        schema = self.parse('''\\\n<sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n  <sch:pattern id=\"number_of_entries\">\n    <sch:title>mandatory number_of_entries tests</sch:title>\n    <sch:rule context=\"number_of_entries\">\n      <sch:assert test=\"text()=count(../entries/entry)\">[ERROR] number_of_entries (<sch:value-of select=\".\"/>) must equal the number of entries/entry elements (<sch:value-of select=\"count(../entries/entry)\"/>)</sch:assert>\n    </sch:rule>\n  </sch:pattern>\n</sch:schema>\n''')\n        # handing phase as keyword arg will *not* raise the type error\n        self.assertRaises(TypeError, isoschematron.Schematron, schema,\n                          compile_params={'phase': None})\n\n    def test_schematron_customization(self):\n        class MySchematron(isoschematron.Schematron):\n            def _extract(self, root):\n                schematron = (root.xpath(\n                    '//sch:schema',\n                    namespaces={'sch': \"http://purl.oclc.org/dsdl/schematron\"})\n                    or [None])[0]\n                return schematron\n\n            def _include(self, schematron, **kwargs):\n                raise RuntimeError('inclusion unsupported')\n\n            def _expand(self, schematron, **kwargs):\n                raise RuntimeError('expansion unsupported')\n\n            def _validation_errors(self, validationReport):\n                valid = etree.XPath(\n                    'count(//svrl:successful-report[@flag=\"critical\"])=1',\n                    namespaces={'svrl': isoschematron.SVRL_NS})(\n                    validationReport)\n                if valid:\n                    return []\n                error = etree.Element('Error')\n                error.text = 'missing critical condition report'\n                return [error]\n\n        tree_valid = self.parse('<AAA><BBB/><CCC/></AAA>')\n        tree_invalid = self.parse('<AAA><BBB/><CCC/><DDD/></AAA>')\n        schema = self.parse('''\\\n<schema xmlns=\"http://www.example.org/yet/another/schema/dialect\">\n  <schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n    <pattern id=\"OpenModel\">\n      <title>Open Model</title>\n      <rule context=\"AAA\">\n        <report test=\"BBB\" flag=\"info\">BBB element must be present</report>\n        <report test=\"CCC\" flag=\"info\">CCC element must be present</report>\n      </rule>\n    </pattern>\n    <pattern id=\"ClosedModel\">\n      <title>Closed model\"</title>\n      <rule context=\"AAA\">\n        <report test=\"BBB\" flag=\"info\">BBB element must be present</report>\n        <report test=\"CCC\" flag=\"info\">CCC element must be present</report>\n        <report test=\"count(BBB|CCC) = count(*)\" flag=\"critical\">Only BBB and CCC children must be present</report>\n      </rule>\n    </pattern>\n  </schema>\n</schema>\n''')\n        # check if overridden _include is run\n        self.assertRaises(RuntimeError, MySchematron, schema, store_report=True)\n        # check if overridden _expand is run\n        self.assertRaises(RuntimeError, MySchematron, schema, store_report=True,\n                          include=False)\n\n        schema = MySchematron(schema, store_report=True, include=False,\n                              expand=False)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertTrue(not schema.validate(tree_invalid))\n\n    #TODO: test xslt parameters for inclusion, expand & compile steps (?)\n\n    def test_schematron_fail_on_report(self):\n        tree_valid = self.parse('<AAA><BBB/><CCC/></AAA>')\n        tree_invalid = self.parse('<AAA><BBB/><CCC/><DDD/></AAA>')\n        schema = self.parse('''\\\n<schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n    <pattern id=\"OpenModel\">\n        <title>Simple Report</title>\n        <rule context=\"AAA\">\n            <report test=\"DDD\"> DDD element must not be present</report>\n        </rule>\n    </pattern>\n</schema>\n''')\n        schema_report = isoschematron.Schematron(\n            schema, error_finder=isoschematron.Schematron.ASSERTS_AND_REPORTS)\n        schema_no_report = isoschematron.Schematron(schema)\n        self.assertTrue(schema_report.validate(tree_valid))\n        self.assertTrue(not schema_report.validate(tree_invalid))\n        self.assertTrue(schema_no_report.validate(tree_valid))\n        self.assertTrue(schema_no_report.validate(tree_invalid))\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeISOSchematronTestCase)])\n    suite.addTests(doctest.DocTestSuite(isoschematron))\n    suite.addTests(\n        [make_doctest('validation.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_elementtree.py": "\"\"\"\nTests for the ElementTree API\n\nOnly test cases that apply equally well to etree and ElementTree\nbelong here. Note that there is a second test module called test_io.py\nfor IO related test cases.\n\"\"\"\n\nimport copy\nimport io\nimport operator\nimport os\nimport pyexpat\nimport re\nimport sys\nimport textwrap\nimport unittest\nfrom contextlib import contextmanager\nfrom functools import wraps, partial\nfrom itertools import islice\n\nfrom .common_imports import (\n    BytesIO, etree, HelperTestCase as helper_base,\n    ElementTree, ET_VERSION, IS_PYPY,\n    filter_by_version, fileInTestDir, canonicalize, tmpfile,\n)\n\nif ElementTree is not None:\n    print(\"Comparing with ElementTree %s\" % getattr(ElementTree, \"VERSION\", \"?\"))\n\n\ndef et_needs_pyversion(*version):\n    def wrap(method):\n        @wraps(method)\n        def testfunc(self, *args):\n            if self.etree is not etree and sys.version_info < version:\n                raise unittest.SkipTest(\"requires ET in Python %s\" % '.'.join(map(str, version)))\n            return method(self, *args)\n        return testfunc\n    return wrap\n\n\ndef et_exclude_pyversion(*version):\n    def wrap(method):\n        @wraps(method)\n        def testfunc(self, *args):\n            if self.etree is not etree and sys.version_info[:len(version)] == version:\n                raise unittest.SkipTest(\"requires ET in Python %s\" % '.'.join(map(str, version)))\n            return method(self, *args)\n        return testfunc\n    return wrap\n\n\nclass _ETreeTestCaseBase(helper_base):\n    etree = None\n    required_versions_ET = {}\n\n    def XMLParser(self, **kwargs):\n        try:\n            XMLParser = self.etree.XMLParser\n        except AttributeError:\n            assert 'ElementTree' in self.etree.__name__\n            XMLParser = self.etree.TreeBuilder\n        return XMLParser(**kwargs)\n\n    @et_needs_pyversion(3, 6)\n    def test_interface(self):\n        # Test element tree interface.\n\n        def check_string(string):\n            len(string)\n            for char in string:\n                self.assertEqual(len(char), 1,\n                        msg=\"expected one-character string, got %r\" % char)\n            new_string = string + \"\"\n            new_string = string + \" \"\n            string[:0]\n\n        def check_mapping(mapping):\n            len(mapping)\n            keys = mapping.keys()\n            items = mapping.items()\n            for key in keys:\n                item = mapping[key]\n            mapping[\"key\"] = \"value\"\n            self.assertEqual(mapping[\"key\"], \"value\",\n                    msg=\"expected value string, got %r\" % mapping[\"key\"])\n\n        def check_element(element):\n            self.assertTrue(self.etree.iselement(element), msg=\"not an element\")\n            direlem = dir(element)\n            for attr in 'tag', 'attrib', 'text', 'tail':\n                self.assertTrue(hasattr(element, attr),\n                        msg='no %s member' % attr)\n                self.assertIn(attr, direlem,\n                        msg='no %s visible by dir' % attr)\n\n            check_string(element.tag)\n            check_mapping(element.attrib)\n            if element.text is not None:\n                check_string(element.text)\n            if element.tail is not None:\n                check_string(element.tail)\n            for elem in element:\n                check_element(elem)\n\n        element = self.etree.Element(\"tag\")\n        check_element(element)\n        tree = self.etree.ElementTree(element)\n        check_element(tree.getroot())\n        element = self.etree.Element(\"t\\xe4g\", key=\"value\")\n        tree = self.etree.ElementTree(element)\n        # lxml and ET Py2: slightly different repr()\n        #self.assertRegex(repr(element), r\"^<Element 't\\xe4g' at 0x.*>$\")\n        element = self.etree.Element(\"tag\", key=\"value\")\n\n        # Make sure all standard element methods exist.\n\n        def check_method(method):\n            self.assertTrue(hasattr(method, '__call__'),\n                    msg=\"%s not callable\" % method)\n\n        check_method(element.append)\n        check_method(element.extend)\n        check_method(element.insert)\n        check_method(element.remove)\n        # Removed in Py3.9\n        #check_method(element.getchildren)\n        check_method(element.find)\n        check_method(element.iterfind)\n        check_method(element.findall)\n        check_method(element.findtext)\n        check_method(element.clear)\n        check_method(element.get)\n        check_method(element.set)\n        check_method(element.keys)\n        check_method(element.items)\n        check_method(element.iter)\n        check_method(element.itertext)\n        # Removed in Py3.9\n        #check_method(element.getiterator)\n\n        # These methods return an iterable. See bug 6472.\n\n        def check_iter(it):\n            check_method(it.__next__)\n\n        check_iter(element.iterfind(\"tag\"))\n        check_iter(element.iterfind(\"*\"))\n        check_iter(tree.iterfind(\"tag\"))\n        check_iter(tree.iterfind(\"*\"))\n\n        # These aliases are provided:\n\n        # not an alias in lxml\n        #self.assertEqual(self.etree.XML, self.etree.fromstring)\n        self.assertEqual(self.etree.PI, self.etree.ProcessingInstruction)\n\n    def test_element(self):\n        for i in range(10):\n            e = self.etree.Element('foo')\n            self.assertEqual(e.tag, 'foo')\n            self.assertEqual(e.text, None)\n            self.assertEqual(e.tail, None)\n\n    def test_simple(self):\n        Element = self.etree.Element\n\n        root = Element('root')\n        root.append(Element('one'))\n        root.append(Element('two'))\n        root.append(Element('three'))\n        self.assertEqual(3, len(root))\n        self.assertEqual('one', root[0].tag)\n        self.assertEqual('two', root[1].tag)\n        self.assertEqual('three', root[2].tag)\n        self.assertRaises(IndexError, operator.getitem, root, 3)\n\n    # test weird dictionary interaction leading to segfault previously\n    def test_weird_dict_interaction(self):\n        root = self.etree.Element('root')\n        self.assertEqual(root.tag, \"root\")\n        add = self.etree.ElementTree(file=BytesIO(b'<foo>Foo</foo>'))\n        self.assertEqual(add.getroot().tag, \"foo\")\n        self.assertEqual(add.getroot().text, \"Foo\")\n        root.append(self.etree.Element('baz'))\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(root[0].tag, \"baz\")\n\n    def test_subelement(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        root = Element('root')\n        SubElement(root, 'one')\n        SubElement(root, 'two')\n        SubElement(root, 'three')\n        self.assertEqual(3, len(root))\n        self.assertEqual('one', root[0].tag)\n        self.assertEqual('two', root[1].tag)\n        self.assertEqual('three', root[2].tag)\n\n    def test_element_contains(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        root1 = Element('root')\n        SubElement(root1, 'one')\n        self.assertTrue(root1[0] in root1)\n\n        root2 = Element('root')\n        SubElement(root2, 'two')\n        SubElement(root2, 'three')\n        self.assertTrue(root2[0] in root2)\n        self.assertTrue(root2[1] in root2)\n\n        self.assertFalse(root1[0] in root2)\n        self.assertFalse(root2[0] in root1)\n        self.assertFalse(None in root2)\n\n    def test_element_indexing_with_text(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc>Test<one>One</one></doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(1, len(root))\n        self.assertEqual('one', root[0].tag)\n        self.assertRaises(IndexError, operator.getitem, root, 1)\n\n    def test_element_indexing_with_text2(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc><one>One</one><two>Two</two>hm<three>Three</three></doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(3, len(root))\n        self.assertEqual('one', root[0].tag)\n        self.assertEqual('two', root[1].tag)\n        self.assertEqual('three', root[2].tag)\n\n    def test_element_indexing_only_text(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc>Test</doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(0, len(root))\n\n    def test_element_indexing_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        self.assertEqual(d, a[-1])\n        self.assertEqual(c, a[-2])\n        self.assertEqual(b, a[-3])\n        self.assertRaises(IndexError, operator.getitem, a, -4)\n        a[-1] = e = Element('e')\n        self.assertEqual(e, a[-1])\n        del a[-1]\n        self.assertEqual(2, len(a))\n\n    def test_elementtree(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc><one>One</one><two>Two</two></doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(2, len(root))\n        self.assertEqual('one', root[0].tag)\n        self.assertEqual('two', root[1].tag)\n\n    def test_text(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc>This is a text</doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual('This is a text', root.text)\n\n    def test_text_empty(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc></doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(None, root.text)\n\n    def test_text_other(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc><one>One</one></doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(None, root.text)\n        self.assertEqual('One', root[0].text)\n\n    def test_text_escape_in(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc>This is &gt; than a text</doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual('This is > than a text', root.text)\n\n    def test_text_escape_out(self):\n        Element = self.etree.Element\n\n        a = Element(\"a\")\n        a.text = \"<>&\"\n        self.assertXML(b'<a>&lt;&gt;&amp;</a>',\n                       a)\n\n    def test_text_escape_tostring(self):\n        tostring = self.etree.tostring\n        Element  = self.etree.Element\n\n        a = Element(\"a\")\n        a.text = \"<>&\"\n        self.assertEqual(b'<a>&lt;&gt;&amp;</a>',\n                         tostring(a))\n\n    def test_text_str_subclass(self):\n        Element = self.etree.Element\n\n        class strTest(str):\n            pass\n\n        a = Element(\"a\")\n        a.text = strTest(\"text\")\n        self.assertXML(b'<a>text</a>',\n                       a)\n\n    def test_tail(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc>This is <i>mixed</i> content.</doc>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual(1, len(root))\n        self.assertEqual('This is ', root.text)\n        self.assertEqual(None, root.tail)\n        self.assertEqual('mixed', root[0].text)\n        self.assertEqual(' content.', root[0].tail)\n\n    def test_tail_str_subclass(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        class strTest(str):\n            pass\n\n        a = Element(\"a\")\n        SubElement(a, \"t\").tail = strTest(\"tail\")\n        self.assertXML(b'<a><t></t>tail</a>',\n                       a)\n\n    def _test_del_tail(self):\n        # this is discouraged for ET compat, should not be tested...\n        XML = self.etree.XML\n\n        root = XML(b'<doc>This is <i>mixed</i> content.</doc>')\n        self.assertEqual(1, len(root))\n        self.assertEqual('This is ', root.text)\n        self.assertEqual(None, root.tail)\n        self.assertEqual('mixed', root[0].text)\n        self.assertEqual(' content.', root[0].tail)\n\n        del root[0].tail\n\n        self.assertEqual(1, len(root))\n        self.assertEqual('This is ', root.text)\n        self.assertEqual(None, root.tail)\n        self.assertEqual('mixed', root[0].text)\n        self.assertEqual(None, root[0].tail)\n\n        root[0].tail = \"TAIL\"\n\n        self.assertEqual(1, len(root))\n        self.assertEqual('This is ', root.text)\n        self.assertEqual(None, root.tail)\n        self.assertEqual('mixed', root[0].text)\n        self.assertEqual('TAIL', root[0].tail)\n\n    def test_ElementTree(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        el = Element('hoi')\n        doc = ElementTree(el)\n        root = doc.getroot()\n        self.assertEqual(None, root.text)\n        self.assertEqual('hoi', root.tag)\n\n    def test_attrib(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual('One', root.attrib['one'])\n        self.assertEqual('Two', root.attrib['two'])\n        self.assertRaises(KeyError, operator.getitem, root.attrib, 'three')\n\n    def test_attrib_get(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual('One', root.attrib.get('one'))\n        self.assertEqual('Two', root.attrib.get('two'))\n        self.assertEqual(None, root.attrib.get('three'))\n        self.assertEqual('foo', root.attrib.get('three', 'foo'))\n\n    def test_attrib_dict(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        attrib = dict(root.attrib)\n        self.assertEqual('One', attrib['one'])\n        self.assertEqual('Two', attrib['two'])\n        self.assertRaises(KeyError, operator.getitem, attrib, 'three')\n\n    def test_attrib_copy(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        attrib = copy.copy(root.attrib)\n        self.assertEqual('One', attrib['one'])\n        self.assertEqual('Two', attrib['two'])\n        self.assertRaises(KeyError, operator.getitem, attrib, 'three')\n\n    def test_attrib_deepcopy(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        attrib = copy.deepcopy(root.attrib)\n        self.assertEqual('One', attrib['one'])\n        self.assertEqual('Two', attrib['two'])\n        self.assertRaises(KeyError, operator.getitem, attrib, 'three')\n\n    def test_attributes_get(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual('One', root.get('one'))\n        self.assertEqual('Two', root.get('two'))\n        self.assertEqual(None, root.get('three'))\n        self.assertEqual('foo', root.get('three', 'foo'))\n\n    def test_attrib_clear(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc one=\"One\" two=\"Two\"/>')\n        self.assertEqual('One', root.get('one'))\n        self.assertEqual('Two', root.get('two'))\n        root.attrib.clear()\n        self.assertEqual(None, root.get('one'))\n        self.assertEqual(None, root.get('two'))\n\n    def test_attrib_set_clear(self):\n        Element = self.etree.Element\n\n        root = Element(\"root\", one=\"One\")\n        root.set(\"two\", \"Two\")\n        self.assertEqual('One', root.get('one'))\n        self.assertEqual('Two', root.get('two'))\n        root.attrib.clear()\n        self.assertEqual(None, root.get('one'))\n        self.assertEqual(None, root.get('two'))\n\n    def test_attrib_ns_clear(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        attribNS = '{http://foo/bar}x'\n\n        parent = Element('parent')\n        parent.set(attribNS, 'a')\n        child = SubElement(parent, 'child')\n        child.set(attribNS, 'b')\n\n        self.assertEqual('a', parent.get(attribNS))\n        self.assertEqual('b', child.get(attribNS))\n\n        parent.clear()\n        self.assertEqual(None, parent.get(attribNS))\n        self.assertEqual('b', child.get(attribNS))\n\n    def test_attrib_pop(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<doc one=\"One\" two=\"Two\"/>')\n        doc = ElementTree(file=f)\n        root = doc.getroot()\n        self.assertEqual('One', root.attrib['one'])\n        self.assertEqual('Two', root.attrib['two'])\n\n        self.assertEqual('One', root.attrib.pop('one'))\n\n        self.assertEqual(None, root.attrib.get('one'))\n        self.assertEqual('Two', root.attrib['two'])\n\n    def test_attrib_pop_unknown(self):\n        root = self.etree.XML(b'<doc one=\"One\" two=\"Two\"/>')\n        self.assertRaises(KeyError, root.attrib.pop, 'NONE')\n\n        self.assertEqual('One', root.attrib['one'])\n        self.assertEqual('Two', root.attrib['two'])\n\n    def test_attrib_pop_default(self):\n        root = self.etree.XML(b'<doc one=\"One\" two=\"Two\"/>')\n        self.assertEqual('Three', root.attrib.pop('three', 'Three'))\n\n    def test_attrib_pop_empty_default(self):\n        root = self.etree.XML(b'<doc/>')\n        self.assertEqual('Three', root.attrib.pop('three', 'Three'))\n\n    def test_attrib_pop_invalid_args(self):\n        root = self.etree.XML(b'<doc one=\"One\" two=\"Two\"/>')\n        self.assertRaises(TypeError, root.attrib.pop, 'One', None, None)\n\n    def test_attribute_update_dict(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\"/>')\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'Alpha'), ('beta', 'Beta')],\n            items)\n\n        root.attrib.update({'alpha' : 'test', 'gamma' : 'Gamma'})\n\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'test'), ('beta', 'Beta'), ('gamma', 'Gamma')],\n            items)\n\n    def test_attribute_update_sequence(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\"/>')\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'Alpha'), ('beta', 'Beta')],\n            items)\n\n        root.attrib.update({'alpha' : 'test', 'gamma' : 'Gamma'}.items())\n\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'test'), ('beta', 'Beta'), ('gamma', 'Gamma')],\n            items)\n\n    def test_attribute_update_iter(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\"/>')\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'Alpha'), ('beta', 'Beta')],\n            items)\n\n        root.attrib.update(iter({'alpha' : 'test', 'gamma' : 'Gamma'}.items()))\n\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'test'), ('beta', 'Beta'), ('gamma', 'Gamma')],\n            items)\n\n    def test_attribute_update_attrib(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\"/>')\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'Alpha'), ('beta', 'Beta')],\n                                                  items)\n\n        other = XML(b'<doc alpha=\"test\" gamma=\"Gamma\"/>')\n        root.attrib.update(other.attrib)\n\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha', 'test'), ('beta', 'Beta'), ('gamma', 'Gamma')],\n                                                                     items)\n\n    def test_attribute_keys(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>')\n        keys = list(root.attrib.keys())\n        keys.sort()\n        self.assertEqual(['alpha', 'beta', 'gamma'], keys)\n\n    def test_attribute_keys2(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>')\n        keys = list(root.keys())\n        keys.sort()\n        self.assertEqual(['alpha', 'beta', 'gamma'], keys)\n\n    def test_attribute_items2(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>')\n        items = list(root.items())\n        items.sort()\n        self.assertEqual(\n            [('alpha','Alpha'), ('beta','Beta'), ('gamma','Gamma')],\n            items)\n\n    def test_attribute_keys_ns(self):\n        XML = self.etree.XML\n\n        root = XML(b'<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />')\n        keys = list(root.keys())\n        keys.sort()\n        self.assertEqual(['bar', '{http://ns.codespeak.net/test}baz'],\n                          keys)\n\n    def test_attribute_values(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>')\n        values = list(root.attrib.values())\n        values.sort()\n        self.assertEqual(['Alpha', 'Beta', 'Gamma'], values)\n\n    def test_attribute_values_ns(self):\n        XML = self.etree.XML\n\n        root = XML(b'<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />')\n        values = list(root.attrib.values())\n        values.sort()\n        self.assertEqual(\n            ['Bar', 'Baz'], values)\n\n    def test_attribute_items(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>')\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual([\n            ('alpha', 'Alpha'),\n            ('beta', 'Beta'),\n            ('gamma', 'Gamma'),\n            ], \n            items)\n\n    def test_attribute_items_ns(self):\n        XML = self.etree.XML\n\n        root = XML(b'<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />')\n        items = list(root.attrib.items())\n        items.sort()\n        self.assertEqual(\n            [('bar', 'Bar'), ('{http://ns.codespeak.net/test}baz', 'Baz')],\n            items)\n\n    def test_attribute_str(self):\n        XML = self.etree.XML\n\n        expected = \"{'{http://ns.codespeak.net/test}baz': 'Baz', 'bar': 'Bar'}\"\n        alternative = \"{'bar': 'Bar', '{http://ns.codespeak.net/test}baz': 'Baz'}\"\n\n        root = XML(b'<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />')\n        try:\n            self.assertEqual(expected, str(root.attrib))\n        except AssertionError:\n            self.assertEqual(alternative, str(root.attrib))\n\n    def test_attribute_contains(self):\n        XML = self.etree.XML\n\n        root = XML(b'<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />')\n        self.assertEqual(\n            True, 'bar' in root.attrib)\n        self.assertEqual(\n            False, 'baz' in root.attrib)\n        self.assertEqual(\n            False, 'hah' in root.attrib)\n        self.assertEqual(\n            True,\n            '{http://ns.codespeak.net/test}baz' in root.attrib)\n\n    def test_attribute_set(self):\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n\n    def test_attrib_as_attrib(self):\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.attrib[\"attr\"])\n\n        root2 = Element(\"root2\", root.attrib)\n        self.assertEqual(\"TEST\", root2.attrib[\"attr\"])\n\n    def test_attribute_iterator(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\" />')\n        result = []\n        for key in root.attrib:\n            result.append(key)\n        result.sort()\n        self.assertEqual(['alpha', 'beta', 'gamma'], result)\n\n    def test_attribute_manipulation(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.attrib['foo'] = 'Foo'\n        a.attrib['bar'] = 'Bar'\n        self.assertEqual('Foo', a.attrib['foo'])\n        del a.attrib['foo']\n        self.assertRaises(KeyError, operator.getitem, a.attrib, 'foo')\n\n    def test_del_attribute_ns(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.attrib['{http://a/}foo'] = 'Foo'\n        a.attrib['{http://a/}bar'] = 'Bar'\n        self.assertEqual(None, a.get('foo'))\n        self.assertEqual('Foo', a.get('{http://a/}foo'))\n        self.assertEqual('Foo', a.attrib['{http://a/}foo'])\n\n        self.assertRaises(KeyError, operator.delitem, a.attrib, 'foo')\n        self.assertEqual('Foo', a.attrib['{http://a/}foo'])\n\n        del a.attrib['{http://a/}foo']\n        self.assertRaises(KeyError, operator.getitem, a.attrib, 'foo')\n\n    def test_del_attribute_ns_parsed(self):\n        XML = self.etree.XML\n\n        a = XML(b'<a xmlns:nsa=\"http://a/\" nsa:foo=\"FooNS\" foo=\"Foo\" />')\n\n        self.assertEqual('Foo', a.attrib['foo'])\n        self.assertEqual('FooNS', a.attrib['{http://a/}foo'])\n\n        del a.attrib['foo']\n        self.assertEqual('FooNS', a.attrib['{http://a/}foo'])\n        self.assertRaises(KeyError, operator.getitem, a.attrib, 'foo')\n        self.assertRaises(KeyError, operator.delitem, a.attrib, 'foo')\n\n        del a.attrib['{http://a/}foo']\n        self.assertRaises(KeyError, operator.getitem, a.attrib, '{http://a/}foo')\n        self.assertRaises(KeyError, operator.getitem, a.attrib, 'foo')\n\n        a = XML(b'<a xmlns:nsa=\"http://a/\" foo=\"Foo\" nsa:foo=\"FooNS\" />')\n\n        self.assertEqual('Foo', a.attrib['foo'])\n        self.assertEqual('FooNS', a.attrib['{http://a/}foo'])\n\n        del a.attrib['foo']\n        self.assertEqual('FooNS', a.attrib['{http://a/}foo'])\n        self.assertRaises(KeyError, operator.getitem, a.attrib, 'foo')\n\n        del a.attrib['{http://a/}foo']\n        self.assertRaises(KeyError, operator.getitem, a.attrib, '{http://a/}foo')\n        self.assertRaises(KeyError, operator.getitem, a.attrib, 'foo')\n\n    def test_XML(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc>This is a text.</doc>')\n        self.assertEqual(0, len(root))\n        self.assertEqual('This is a text.', root.text)\n\n    def test_XMLID(self):\n        XMLID = self.etree.XMLID\n        XML   = self.etree.XML\n        xml_text = b'''\n        <document>\n          <h1 id=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p id=\"warn1\" class=\"warning\">...</p>\n        </document>\n        '''\n\n        root, dic = XMLID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"note1\"    : root[1],\n            \"warn1\"    : root[4]\n            }\n        self.assertEqual(dic, expected)\n\n    def test_fromstring(self):\n        fromstring = self.etree.fromstring\n\n        root = fromstring('<doc>This is a text.</doc>')\n        self.assertEqual(0, len(root))\n        self.assertEqual('This is a text.', root.text)\n\n    required_versions_ET['test_fromstringlist'] = (1,3)\n    def test_fromstringlist(self):\n        fromstringlist = self.etree.fromstringlist\n\n        root = fromstringlist([\"<do\", \"c>T\", \"hi\", \"s is\",\n                               \" a text.<\", \"/doc\", \">\"])\n        self.assertEqual(0, len(root))\n        self.assertEqual('This is a text.', root.text)\n\n    required_versions_ET['test_fromstringlist_characters'] = (1,3)\n    def test_fromstringlist_characters(self):\n        fromstringlist = self.etree.fromstringlist\n\n        root = fromstringlist(list('<doc>This is a text.</doc>'))\n        self.assertEqual(0, len(root))\n        self.assertEqual('This is a text.', root.text)\n\n    required_versions_ET['test_fromstringlist_single'] = (1,3)\n    def test_fromstringlist_single(self):\n        fromstringlist = self.etree.fromstringlist\n\n        root = fromstringlist(['<doc>This is a text.</doc>'])\n        self.assertEqual(0, len(root))\n        self.assertEqual('This is a text.', root.text)\n\n    def test_iselement(self):\n        iselement = self.etree.iselement\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n        XML = self.etree.XML\n        Comment = self.etree.Comment\n        ProcessingInstruction = self.etree.ProcessingInstruction\n\n        el = Element('hoi')\n        self.assertTrue(iselement(el))\n\n        el2 = XML(b'<foo/>')\n        self.assertTrue(iselement(el2))\n\n        tree = ElementTree(element=Element('dag'))\n        self.assertTrue(not iselement(tree))\n        self.assertTrue(iselement(tree.getroot()))\n\n        c = Comment('test')\n        self.assertTrue(iselement(c))\n\n        p = ProcessingInstruction(\"test\", \"some text\")\n        self.assertTrue(iselement(p))\n\n    def test_iteration(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<three/></doc>')\n        result = []\n        for el in root:\n            result.append(el.tag)\n        self.assertEqual(['one', 'two', 'three'], result)\n\n    def test_iteration_empty(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc></doc>')\n        result = []\n        for el in root:\n            result.append(el.tag)\n        self.assertEqual([], result)\n\n    def test_iteration_text_only(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc>Text</doc>')\n        result = []\n        for el in root:\n            result.append(el.tag)\n        self.assertEqual([], result)\n\n    def test_iteration_set_tail_empty(self):\n        # this would cause a crash in the past\n        fromstring = self.etree.fromstring\n        root = fromstring('<html><p></p>x</html>')\n        for elem in root:\n            elem.tail = ''\n\n    def test_iteration_clear_tail(self):\n        # this would cause a crash in the past\n        fromstring = self.etree.fromstring\n        root = fromstring('<html><p></p>x</html>')\n        for elem in root:\n            elem.tail = None\n\n    def test_iteration_reversed(self):\n        XML = self.etree.XML\n        root = XML(b'<doc><one/><two>Two</two>Hm<three/></doc>')\n        result = []\n        for el in reversed(root):\n            result.append(el.tag)\n        self.assertEqual(['three', 'two', 'one'], result)\n\n    def test_iteration_subelement(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<three/></doc>')\n        result = []\n        add = True\n        for el in root:\n            result.append(el.tag)\n            if add:\n                self.etree.SubElement(root, 'four')\n                add = False\n        self.assertEqual(['one', 'two', 'three', 'four'], result)\n\n    def test_iteration_del_child(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two>Two</two>Hm<three/></doc>')\n        result = []\n        for el in root:\n            result.append(el.tag)\n            del root[-1]\n        self.assertEqual(['one', 'two'], result)\n\n    def test_iteration_double(self):\n        XML = self.etree.XML\n\n        root = XML(b'<doc><one/><two/></doc>')\n        result = []\n        for el0 in root:\n            result.append(el0.tag)\n            for el1 in root:\n                result.append(el1.tag)\n        self.assertEqual(['one','one', 'two', 'two', 'one', 'two'], result)\n\n    required_versions_ET['test_itertext'] = (1,3)\n    def test_itertext(self):\n        # ET 1.3+\n        XML = self.etree.XML\n        root = XML(b\"<root>RTEXT<a></a>ATAIL<b/><c>CTEXT</c>CTAIL</root>\")\n\n        text = list(root.itertext())\n        self.assertEqual([\"RTEXT\", \"ATAIL\", \"CTEXT\", \"CTAIL\"],\n                          text)\n\n    required_versions_ET['test_itertext_child'] = (1,3)\n    def test_itertext_child(self):\n        # ET 1.3+\n        XML = self.etree.XML\n        root = XML(b\"<root>RTEXT<a></a>ATAIL<b/><c>CTEXT</c>CTAIL</root>\")\n\n        text = list(root[2].itertext())\n        self.assertEqual([\"CTEXT\"],\n                          text)\n\n    def test_findall(self):\n        XML = self.etree.XML\n        root = XML(b'<a><b><c/></b><b/><c><b/></c></a>')\n        self.assertEqual(len(list(root.findall(\"c\"))), 1)\n        self.assertEqual(len(list(root.findall(\".//c\"))), 2)\n        self.assertEqual(len(list(root.findall(\".//b\"))), 3)\n        self.assertEqual(len(list(root.findall(\".//b\"))[0]), 1)\n        self.assertEqual(len(list(root.findall(\".//b\"))[1]), 0)\n        self.assertEqual(len(list(root.findall(\".//b\"))[2]), 0)\n\n    def test_findall_ns(self):\n        XML = self.etree.XML\n        root = XML(b'<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')\n        self.assertEqual(len(list(root.findall(\".//{X}b\"))), 2)\n        self.assertEqual(len(list(root.findall(\".//b\"))), 3)\n        self.assertEqual(len(list(root.findall(\"b\"))), 2)\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_findall_wildcard(self):\n        def summarize_list(l):\n            return [el.tag for el in l]\n\n        root = self.etree.XML('''\n            <a xmlns:x=\"X\" xmlns:y=\"Y\">\n                <x:b><c/></x:b>\n                <b/>\n                <c><x:b/><b/></c><y:b/>\n            </a>''')\n        root.append(self.etree.Comment('test'))\n\n        self.assertEqual(summarize_list(root.findall(\"{*}b\")),\n                         ['{X}b', 'b', '{Y}b'])\n        self.assertEqual(summarize_list(root.findall(\"{*}c\")),\n                         ['c'])\n        self.assertEqual(summarize_list(root.findall(\"{X}*\")),\n                         ['{X}b'])\n        self.assertEqual(summarize_list(root.findall(\"{Y}*\")),\n                         ['{Y}b'])\n        self.assertEqual(summarize_list(root.findall(\"{}*\")),\n                         ['b', 'c'])\n        self.assertEqual(summarize_list(root.findall(\"{}b\")),  # only for consistency\n                         ['b'])\n        self.assertEqual(summarize_list(root.findall(\"{}b\")),\n                         summarize_list(root.findall(\"b\")))\n        self.assertEqual(summarize_list(root.findall(\"{*}*\")),\n                         ['{X}b', 'b', 'c', '{Y}b'])\n        self.assertEqual(summarize_list(root.findall(\"{*}*\")\n                         + ([] if self.etree is etree else [root[-1]])),\n                         summarize_list(root.findall(\"*\")))\n\n        self.assertEqual(summarize_list(root.findall(\".//{*}b\")),\n                         ['{X}b', 'b', '{X}b', 'b', '{Y}b'])\n        self.assertEqual(summarize_list(root.findall(\".//{*}c\")),\n                         ['c', 'c'])\n        self.assertEqual(summarize_list(root.findall(\".//{X}*\")),\n                         ['{X}b', '{X}b'])\n        self.assertEqual(summarize_list(root.findall(\".//{Y}*\")),\n                         ['{Y}b'])\n        self.assertEqual(summarize_list(root.findall(\".//{}*\")),\n                         ['c', 'b', 'c', 'b'])\n        self.assertEqual(summarize_list(root.findall(\".//{}b\")),\n                         ['b', 'b'])\n\n    def test_element_with_attributes_keywords(self):\n        Element = self.etree.Element\n\n        el = Element('tag', foo='Foo', bar='Bar')\n        self.assertEqual('Foo', el.attrib['foo'])\n        self.assertEqual('Bar', el.attrib['bar'])\n\n    def test_element_with_attributes(self):\n        Element = self.etree.Element\n\n        el = Element('tag', {'foo': 'Foo', 'bar': 'Bar'})\n        self.assertEqual('Foo', el.attrib['foo'])\n        self.assertEqual('Bar', el.attrib['bar'])\n\n    def test_element_with_attributes_extra(self):\n        Element = self.etree.Element\n\n        el = Element('tag', {'foo': 'Foo', 'bar': 'Bar'}, baz='Baz')\n        self.assertEqual('Foo', el.attrib['foo'])\n        self.assertEqual('Bar', el.attrib['bar'])\n        self.assertEqual('Baz', el.attrib['baz'])\n\n    def test_element_with_attributes_extra_duplicate(self):\n        Element = self.etree.Element\n\n        el = Element('tag', {'foo': 'Foo', 'bar': 'Bar'}, bar='Baz')\n        self.assertEqual('Foo', el.attrib['foo'])\n        self.assertEqual('Baz', el.attrib['bar'])\n\n    def test_element_with_attributes_ns(self):\n        Element = self.etree.Element\n\n        el = Element('tag', {'{ns1}foo':'Foo', '{ns2}bar':'Bar'})\n        self.assertEqual('Foo', el.attrib['{ns1}foo'])\n        self.assertEqual('Bar', el.attrib['{ns2}bar'])\n\n    def test_subelement_with_attributes(self):\n        Element =  self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('tag')\n        SubElement(el, 'foo', {'foo':'Foo'}, baz=\"Baz\")\n        self.assertEqual(\"Baz\", el[0].attrib['baz'])\n        self.assertEqual('Foo', el[0].attrib['foo'])\n\n    def test_subelement_with_attributes_ns(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('tag')\n        SubElement(el, 'foo', {'{ns1}foo':'Foo', '{ns2}bar':'Bar'})\n        self.assertEqual('Foo', el[0].attrib['{ns1}foo'])\n        self.assertEqual('Bar', el[0].attrib['{ns2}bar'])\n\n    def test_write(self):\n        ElementTree = self.etree.ElementTree\n        XML = self.etree.XML\n\n        for i in range(10):\n            f = BytesIO() \n            root = XML(b'<doc%d>This is a test.</doc%d>' % (i, i))\n            tree = ElementTree(element=root)\n            tree.write(f)\n            data = f.getvalue()\n            self.assertEqual(\n                b'<doc%d>This is a test.</doc%d>' % (i, i),\n                canonicalize(data))\n\n    required_versions_ET['test_write_method_html'] = (1,3)\n    def test_write_method_html(self):\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        html = Element('html')\n        body = SubElement(html, 'body')\n        p = SubElement(body, 'p')\n        p.text = \"html\"\n        SubElement(p, 'br').tail = \"test\"\n\n        tree = ElementTree(element=html)\n        f = BytesIO() \n        tree.write(f, method=\"html\")\n        data = f.getvalue().replace(b'\\n',b'')\n\n        self.assertEqual(b'<html><body><p>html<br>test</p></body></html>',\n                          data)\n\n    required_versions_ET['test_write_method_text'] = (1,3)\n    def test_write_method_text(self):\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = \"A\"\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = \"TAIL\"\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n\n        tree = ElementTree(element=a)\n        f = BytesIO() \n        tree.write(f, method=\"text\")\n        data = f.getvalue()\n\n        self.assertEqual(b'ABTAILCtail',\n                          data)\n\n    def test_write_fail(self):\n        ElementTree = self.etree.ElementTree\n        XML = self.etree.XML\n\n        tree = ElementTree( XML(b'<doc>This is a test.</doc>') )\n        self.assertRaises(IOError, tree.write,\n                          \"definitely////\\\\-\\\\nonexisting\\\\-\\\\////FILE\")\n\n    # this could trigger a crash, apparently because the document\n    # reference was prematurely garbage collected\n    def test_crash(self):\n        Element = self.etree.Element\n\n        element = Element('tag')\n        for i in range(10):\n            element.attrib['key'] = 'value'\n            value = element.attrib['key']\n            self.assertEqual(value, 'value')\n\n    # from doctest; for some reason this caused crashes too\n    def test_write_ElementTreeDoctest(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO()\n        for i in range(10):\n            element = Element('tag%s' % i)\n            self._check_element(element)\n            tree = ElementTree(element)\n            tree.write(f)\n            self._check_element_tree(tree)\n\n    def test_subelement_reference(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('foo')\n        el2 = SubElement(el, 'bar')\n        el3 = SubElement(el2, 'baz')\n\n        al = Element('foo2')\n        al2 = SubElement(al, 'bar2')\n        al3 = SubElement(al2, 'baz2')\n\n        # now move al2 into el\n        el.append(al2)\n\n        # now change al3 directly\n        al3.text = 'baz2-modified'\n\n        # it should have changed through this route too\n        self.assertEqual(\n            'baz2-modified',\n            el[1][0].text)\n\n    def test_set_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.text = 'hoi'\n        self.assertEqual(\n            'hoi',\n            a.text)\n        self.assertEqual(\n            'b',\n            a[0].tag)\n\n    def test_set_text2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'hoi'\n        b = SubElement(a ,'b')\n        self.assertEqual(\n            'hoi',\n            a.text)\n        self.assertEqual(\n            'b',\n            a[0].tag)\n\n    def test_set_text_none(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n\n        a.text = 'foo'\n        a.text = None\n\n        self.assertEqual(\n            None,\n            a.text)\n        self.assertXML(b'<a></a>', a)\n\n    def test_set_text_empty(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertEqual(None, a.text)\n\n        a.text = ''\n        self.assertEqual('', a.text)\n        self.assertXML(b'<a></a>', a)\n\n    def test_tail1(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.tail = 'dag'\n        self.assertEqual('dag',\n                          a.tail)\n        b = SubElement(a, 'b')\n        b.tail = 'hoi'\n        self.assertEqual('hoi',\n                          b.tail)\n        self.assertEqual('dag',\n                          a.tail)\n\n    def test_tail_append(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        b = Element('b')\n        b.tail = 'b_tail'\n        a.append(b)\n        self.assertEqual('b_tail',\n                          b.tail)\n\n    def test_tail_set_twice(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        b.tail = 'foo'\n        b.tail = 'bar'\n        self.assertEqual('bar',\n                          b.tail)\n        self.assertXML(b'<a><b></b>bar</a>', a)\n\n    def test_tail_set_none(self):\n        Element = self.etree.Element\n        a = Element('a')\n        a.tail = 'foo'\n        a.tail = None\n        self.assertEqual(\n            None,\n            a.tail)\n        self.assertXML(b'<a></a>', a)\n\n    required_versions_ET['test_extend'] = (1,3)\n    def test_extend(self):\n        root = self.etree.Element('foo')\n        for i in range(3):\n            element = self.etree.SubElement(root, 'a%s' % i)\n            element.text = \"text%d\" % i\n            element.tail = \"tail%d\" % i\n\n        elements = []\n        for i in range(3):\n            new_element = self.etree.Element(\"test%s\" % i)\n            new_element.text = \"TEXT%s\" % i\n            new_element.tail = \"TAIL%s\" % i\n            elements.append(new_element)\n\n        root.extend(elements)\n\n        self.assertEqual(\n            [\"a0\", \"a1\", \"a2\", \"test0\", \"test1\", \"test2\"],\n            [ el.tag for el in root ])\n        self.assertEqual(\n            [\"text0\", \"text1\", \"text2\", \"TEXT0\", \"TEXT1\", \"TEXT2\"],\n            [ el.text for el in root ])\n        self.assertEqual(\n            [\"tail0\", \"tail1\", \"tail2\", \"TAIL0\", \"TAIL1\", \"TAIL2\"],\n            [ el.tail for el in root ])\n\n    def test_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n\n        a = Element('a')\n        a.append(Comment('foo'))\n        self.assertEqual(a[0].tag, Comment)\n        self.assertEqual(a[0].text, 'foo')\n\n    # ElementTree < 1.3 adds whitespace around comments\n    required_versions_ET['test_comment_text'] = (1,3)\n    def test_comment_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        a.append(Comment('foo'))\n        self.assertEqual(a[0].text, 'foo')\n\n        self.assertEqual(\n            b'<a><!--foo--></a>',\n            tostring(a))\n\n        a[0].text = \"TEST\"\n        self.assertEqual(a[0].text, 'TEST')\n\n        self.assertEqual(\n            b'<a><!--TEST--></a>',\n            tostring(a))\n\n    # ElementTree < 1.3 adds whitespace around comments\n    required_versions_ET['test_comment_whitespace'] = (1,3)\n    def test_comment_whitespace(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        a.append(Comment(' foo  '))\n        self.assertEqual(a[0].text, ' foo  ')\n        self.assertEqual(\n            b'<a><!-- foo  --></a>',\n            tostring(a))\n\n    def test_comment_nonsense(self):\n        Comment = self.etree.Comment\n        c = Comment('foo')\n        self.assertEqual({}, c.attrib)\n        self.assertEqual([], list(c.keys()))\n        self.assertEqual([], list(c.items()))\n        self.assertEqual(None, c.get('hoi'))\n        self.assertEqual(0, len(c))\n        # should not iterate\n        for i in c:\n            pass\n\n    def test_pi(self):\n        # lxml.etree separates target and text\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ProcessingInstruction = self.etree.ProcessingInstruction\n\n        a = Element('a')\n        a.append(ProcessingInstruction('foo', 'some more text'))\n        self.assertEqual(a[0].tag, ProcessingInstruction)\n        self.assertXML(b\"<a><?foo some more text?></a>\",\n                       a)\n\n    def test_processinginstruction(self):\n        # lxml.etree separates target and text\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ProcessingInstruction = self.etree.PI\n\n        a = Element('a')\n        a.append(ProcessingInstruction('foo', 'some more text'))\n        self.assertEqual(a[0].tag, ProcessingInstruction)\n        self.assertXML(b\"<a><?foo some more text?></a>\",\n                       a)\n\n    def test_pi_nonsense(self):\n        ProcessingInstruction = self.etree.ProcessingInstruction\n        pi = ProcessingInstruction('foo')\n        self.assertEqual({}, pi.attrib)\n        self.assertEqual([], list(pi.keys()))\n        self.assertEqual([], list(pi.items()))\n        self.assertEqual(None, pi.get('hoi'))\n        self.assertEqual(0, len(pi))\n        # should not iterate\n        for i in pi:\n            pass\n\n    def test_setitem(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = Element('c')\n        a[0] = c\n        self.assertEqual(\n            c,\n            a[0])\n        self.assertXML(b'<a><c></c></a>',\n                       a)\n        self.assertXML(b'<b></b>',\n                       b)\n\n    def test_setitem2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        for i in range(5):\n            b = SubElement(a, 'b%s' % i)\n            c = SubElement(b, 'c')\n        for i in range(5):\n            d = Element('d')\n            e = SubElement(d, 'e')\n            a[i] = d\n        self.assertXML(\n            b'<a><d><e></e></d><d><e></e></d><d><e></e></d><d><e></e></d><d><e></e></d></a>',\n            a)\n        self.assertXML(b'<c></c>',\n                       c)\n\n    def test_setitem_replace(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        SubElement(a, 'b')\n        d = Element('d')\n        a[0] = d\n        self.assertXML(b'<a><d></d></a>', a)\n\n    def test_setitem_indexerror(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n\n        self.assertRaises(IndexError, operator.setitem, a, 1, Element('c'))\n\n    def test_setitem_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        b.tail = 'B2'\n        c = Element('c')\n        c.tail = 'C2'\n\n        a[0] = c\n        self.assertXML(\n            b'<a><c></c>C2</a>',\n            a)\n\n    def test_tag_write(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n\n        a.tag = 'c'\n\n        self.assertEqual(\n            'c',\n            a.tag)\n\n        self.assertXML(\n            b'<c><b></b></c>',\n            a)\n\n    def test_tag_reset_ns(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        a = Element('{a}a')\n        b1 = SubElement(a, '{a}b')\n        b2 = SubElement(a, '{b}b')\n\n        self.assertEqual('{a}b',  b1.tag)\n\n        b1.tag = 'c'\n\n        # can't use C14N here!\n        self.assertEqual('c', b1.tag)\n        self.assertEqual(b'<c', tostring(b1)[:2])\n        self.assertTrue(b'<c' in tostring(a))\n\n    def test_tag_reset_root_ns(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        a = Element('{a}a')\n        b1 = SubElement(a, '{a}b')\n        b2 = SubElement(a, '{b}b')\n\n        a.tag = 'c'\n\n        self.assertEqual(\n            'c',\n            a.tag)\n\n        # can't use C14N here!\n        self.assertEqual('c',  a.tag)\n        self.assertEqual(b'<c', tostring(a)[:2])\n\n    def test_tag_str_subclass(self):\n        Element = self.etree.Element\n\n        class strTest(str):\n            pass\n\n        a = Element(\"a\")\n        a.tag = strTest(\"TAG\")\n        self.assertXML(b'<TAG></TAG>',\n                       a)\n\n    def test_delitem(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        del a[1]\n        self.assertXML(\n            b'<a><b></b><d></d></a>',\n            a)\n\n        del a[0]\n        self.assertXML(\n            b'<a><d></d></a>',\n            a)\n\n        del a[0]\n        self.assertXML(\n            b'<a></a>',\n            a)\n        # move deleted element into other tree afterwards\n        other = Element('other')\n        other.append(c)\n        self.assertXML(\n            b'<other><c></c></other>',\n            other)\n\n    def test_del_insert(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        bs = SubElement(b, 'bs')\n        c = SubElement(a, 'c')\n        cs = SubElement(c, 'cs')\n\n        el = a[0]\n        self.assertXML(\n            b'<a><b><bs></bs></b><c><cs></cs></c></a>',\n            a)\n        self.assertXML(b'<b><bs></bs></b>', b)\n        self.assertXML(b'<c><cs></cs></c>', c)\n\n        del a[0]\n        self.assertXML(\n            b'<a><c><cs></cs></c></a>',\n            a)\n        self.assertXML(b'<b><bs></bs></b>', b)\n        self.assertXML(b'<c><cs></cs></c>', c)\n\n        a.insert(0, el)\n        self.assertXML(\n            b'<a><b><bs></bs></b><c><cs></cs></c></a>',\n            a)\n        self.assertXML(b'<b><bs></bs></b>', b)\n        self.assertXML(b'<c><cs></cs></c>', c)\n\n    def test_del_setitem(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        bs = SubElement(b, 'bs')\n        c = SubElement(a, 'c')\n        cs = SubElement(c, 'cs')\n\n        el = a[0]\n        del a[0]\n        a[0] = el\n        self.assertXML(\n            b'<a><b><bs></bs></b></a>',\n            a)\n        self.assertXML(b'<b><bs></bs></b>', b)\n        self.assertXML(b'<c><cs></cs></c>', c)\n\n    def test_del_setslice(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        bs = SubElement(b, 'bs')\n        c = SubElement(a, 'c')\n        cs = SubElement(c, 'cs')\n\n        el = a[0]\n        del a[0]\n        a[0:0] = [el]\n        self.assertXML(\n            b'<a><b><bs></bs></b><c><cs></cs></c></a>',\n            a)\n        self.assertXML(b'<b><bs></bs></b>', b)\n        self.assertXML(b'<c><cs></cs></c>', c)\n\n    def test_replace_slice_tail(self):\n        XML = self.etree.XML\n        a = XML(b'<a><b></b>B2<c></c>C2</a>')\n        b, c = a\n\n        a[:] = []\n\n        self.assertEqual(\"B2\", b.tail)\n        self.assertEqual(\"C2\", c.tail)\n\n    def test_merge_namespaced_subtree_as_slice(self):\n        XML = self.etree.XML\n        root = XML(\n            b'<foo><bar xmlns:baz=\"http://huhu\"><puh><baz:bump1 /><baz:bump2 /></puh></bar></foo>')\n        root[:] = root.findall('.//puh') # delete bar from hierarchy\n\n        # previously, this lost a namespace declaration on bump2\n        result = self.etree.tostring(root)\n        foo = self.etree.fromstring(result)\n\n        self.assertEqual('puh', foo[0].tag)\n        self.assertEqual('{http://huhu}bump1', foo[0][0].tag)\n        self.assertEqual('{http://huhu}bump2', foo[0][1].tag)\n\n    def test_delitem_tail_dealloc(self):\n        ElementTree = self.etree.ElementTree\n        f = BytesIO(b'<a><b></b>B2<c></c>C2</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        del a[0]\n        self.assertXML(\n            b'<a><c></c>C2</a>',\n            a)\n\n    def test_delitem_tail(self):\n        ElementTree = self.etree.ElementTree\n        f = BytesIO(b'<a><b></b>B2<c></c>C2</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        b, c = a\n        del a[0]\n        self.assertXML(\n            b'<a><c></c>C2</a>',\n            a)\n        self.assertEqual(\"B2\", b.tail)\n        self.assertEqual(\"C2\", c.tail)\n\n    def test_clear(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'foo'\n        a.tail = 'bar'\n        a.set('hoi', 'dag')\n        a.clear()\n        self.assertEqual(None, a.text)\n        self.assertEqual(None, a.tail)\n        self.assertEqual(None, a.get('hoi'))\n        self.assertEqual('a', a.tag)\n\n    def test_clear_sub(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'foo'\n        a.tail = 'bar'\n        a.set('hoi', 'dag')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        a.clear()\n        self.assertEqual(None, a.text)\n        self.assertEqual(None, a.tail)\n        self.assertEqual(None, a.get('hoi'))\n        self.assertEqual('a', a.tag)\n        self.assertEqual(0, len(a))\n        self.assertXML(b'<a></a>',\n                       a)\n        self.assertXML(b'<b><c></c></b>',\n                       b)\n\n    def test_clear_tail(self):\n        ElementTree = self.etree.ElementTree\n        f = BytesIO(b'<a><b></b>B2<c></c>C2</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        a.clear()\n        self.assertXML(\n            b'<a></a>',\n            a)\n\n    def test_insert(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = Element('d')\n        a.insert(0, d)\n\n        self.assertEqual(\n            d,\n            a[0])\n\n        self.assertXML(\n            b'<a><d></d><b></b><c></c></a>',\n            a)\n\n        e = Element('e')\n        a.insert(2, e)\n        self.assertEqual(\n            e,\n            a[2])\n        self.assertXML(\n            b'<a><d></d><b></b><e></e><c></c></a>',\n            a)\n\n    def test_insert_name_interning(self):\n        # See GH#268 / LP#1773749.\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        # Use unique names to make sure they are new in the tag name dict.\n        import uuid\n        names = {k: f'tag-{uuid.uuid4()}' for k in 'abcde'}\n\n        a = Element(names['a'])\n        b = SubElement(a, names['b'])\n        c = SubElement(a, names['c'])\n        d = Element(names['d'])\n        a.insert(0, d)\n\n        self.assertEqual(\n            d,\n            a[0])\n\n        self.assertXML(\n            ('<%(a)s><%(d)s></%(d)s><%(b)s></%(b)s><%(c)s></%(c)s></%(a)s>' % names).encode('utf-8'),\n            a)\n\n        e = Element(names['e'])\n        a.insert(2, e)\n        self.assertEqual(\n            e,\n            a[2])\n        self.assertXML(\n            ('<%(a)s><%(d)s></%(d)s><%(b)s></%(b)s><%(e)s></%(e)s><%(c)s></%(c)s></%(a)s>' % names).encode('utf-8'),\n            a)\n\n    def test_insert_beyond_index(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = Element('c')\n\n        a.insert(2, c)\n        self.assertEqual(\n            c,\n            a[1])\n        self.assertXML(\n            b'<a><b></b><c></c></a>',\n            a)\n\n    def test_insert_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        d = Element('d')\n        a.insert(-1, d)\n        self.assertEqual(\n            d,\n            a[-2])\n        self.assertXML(\n            b'<a><b></b><d></d><c></c></a>',\n            a)\n\n    def test_insert_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n\n        c = Element('c')\n        c.tail = 'C2'\n\n        a.insert(0, c)\n        self.assertXML(\n            b'<a><c></c>C2<b></b></a>',\n            a)\n\n    def test_remove(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        a.remove(b)\n        self.assertEqual(\n            c,\n            a[0])\n        self.assertXML(\n            b'<a><c></c></a>',\n            a)\n\n    def test_remove_ns(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('{http://test}a')\n        b = SubElement(a, '{http://test}b')\n        c = SubElement(a, '{http://test}c')\n\n        a.remove(b)\n        self.assertXML(\n            b'<ns0:a xmlns:ns0=\"http://test\"><ns0:c></ns0:c></ns0:a>',\n            a)\n        self.assertXML(\n            b'<ns0:b xmlns:ns0=\"http://test\"></ns0:b>',\n            b)\n\n    def test_remove_nonexisting(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = Element('d')\n        self.assertRaises(\n            ValueError, a.remove, d)\n\n    def test_remove_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        b.tail = 'b2'\n        a.remove(b)\n        self.assertXML(\n            b'<a></a>',\n            a)\n        self.assertEqual('b2', b.tail)\n\n    def test_remove_while_iterating(self):\n        # There is no guarantee that this \"works\", but it should\n        # remove at least one child and not crash.\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        SubElement(a, 'b')\n        SubElement(a, 'c')\n        SubElement(a, 'd')\n        for el in a:\n            a.remove(el)\n        self.assertLess(len(a), 3)\n\n    def test_makeelement(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        b = a.makeelement('c', {'hoi':'dag'})\n        self.assertXML(\n            b'<c hoi=\"dag\"></c>',\n            b)\n\n    required_versions_ET['test_iter'] = (1,3)\n    def test_iter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.iter()))\n        self.assertEqual(\n            [d],\n            list(d.iter()))\n\n    def test_iter_remove_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        a.tail = 'a1' * 100\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1' * 100\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1' * 100\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1' * 100\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1' * 100\n\n        for el in a.iter():\n            el.tail = None\n        el = None\n\n        self.assertEqual(\n            [None] * 5,\n            [el.tail for el in a.iter()])\n\n    def test_getslice(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        self.assertEqual(\n            [b, c],\n            a[0:2])\n        self.assertEqual(\n            [b, c, d],\n            a[:])\n        self.assertEqual(\n            [b, c, d],\n            a[:10])\n        self.assertEqual(\n            [b],\n            a[0:1])\n        self.assertEqual(\n            [],\n            a[10:12])\n\n    def test_getslice_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        self.assertEqual(\n            [d],\n            a[-1:])\n        self.assertEqual(\n            [c, d],\n            a[-2:])\n        self.assertEqual(\n            [c],\n            a[-2:-1])\n        self.assertEqual(\n            [b, c],\n            a[-3:-1])\n        self.assertEqual(\n            [b, c],\n            a[-3:2])\n\n    def test_getslice_step(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        self.assertEqual(\n            [e,d,c,b],\n            a[::-1])\n        self.assertEqual(\n            [b,d],\n            a[::2])\n        self.assertEqual(\n            [e,c],\n            a[::-2])\n        self.assertEqual(\n            [d,c],\n            a[-2:0:-1])\n        self.assertEqual(\n            [e],\n            a[:1:-2])\n\n    def test_getslice_text(self):\n        ElementTree = self.etree.ElementTree\n\n        f = BytesIO(b'<a><b>B</b>B1<c>C</c>C1</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        b = a[0]\n        c = a[1]\n        self.assertEqual(\n            [b, c],\n            a[:])\n        self.assertEqual(\n            [b],\n            a[0:1])\n        self.assertEqual(\n            [c],\n            a[1:])\n\n    def test_comment_getitem_getslice(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        foo = Comment('foo')\n        a.append(foo)\n        c = SubElement(a, 'c')\n        self.assertEqual(\n            [b, foo, c],\n            a[:])\n        self.assertEqual(\n            foo,\n            a[1])\n        a[1] = new = Element('new')\n        self.assertEqual(\n            new,\n            a[1])\n        self.assertXML(\n            b'<a><b></b><new></new><c></c></a>',\n            a)\n\n    def test_delslice(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        del a[1:3]\n        self.assertEqual(\n            [b, e],\n            list(a))\n\n    def test_delslice_negative1(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        del a[1:-1]\n        self.assertEqual(\n            [b, e],\n            list(a))\n\n    def test_delslice_negative2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        del a[-3:-1]\n        self.assertEqual(\n            [b, e],\n            list(a))\n\n    def test_delslice_step(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        del a[1::2]\n        self.assertEqual(\n            [b, d],\n            list(a))\n\n    def test_delslice_step_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        del a[::-1]\n        self.assertEqual(\n            [],\n            list(a))\n\n    def test_delslice_step_negative2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        del a[::-2]\n        self.assertEqual(\n            [b, d],\n            list(a))\n\n    def test_delslice_child_tail_dealloc(self):\n        ElementTree = self.etree.ElementTree\n        f = BytesIO(b'<a><b></b>B2<c></c>C2<d></d>D2<e></e>E2</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        del a[1:3]\n        self.assertXML(\n            b'<a><b></b>B2<e></e>E2</a>',\n            a)\n\n    def test_delslice_child_tail(self):\n        ElementTree = self.etree.ElementTree\n        f = BytesIO(b'<a><b></b>B2<c></c>C2<d></d>D2<e></e>E2</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        b, c, d, e = a\n        del a[1:3]\n        self.assertXML(\n            b'<a><b></b>B2<e></e>E2</a>',\n            a)\n        self.assertEqual(\"B2\", b.tail)\n        self.assertEqual(\"C2\", c.tail)\n        self.assertEqual(\"D2\", d.tail)\n        self.assertEqual(\"E2\", e.tail)\n\n    def test_delslice_tail(self):\n        XML = self.etree.XML\n        a = XML(b'<a><b></b>B2<c></c>C2</a>')\n        b, c = a\n\n        del a[:]\n\n        self.assertEqual(\"B2\", b.tail)\n        self.assertEqual(\"C2\", c.tail)\n\n    def test_delslice_memory(self):\n        # this could trigger a crash\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        del b # no more reference to b\n        del a[:]\n        self.assertEqual('c', c.tag)\n\n    def test_setslice(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        s = [e, f, g]\n        a[1:2] = s\n        self.assertEqual(\n            [b, e, f, g, d],\n            list(a))\n\n    def test_setslice_all(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        s = [e, f, g]\n        a[:] = s\n        self.assertEqual(\n            [e, f, g],\n            list(a))\n\n    def test_setslice_all_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        s = [e, f, g]\n        a[:] = s\n        self.assertEqual(\n            [e, f, g],\n            list(a))\n\n    def test_setslice_all_replace(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        s = [b, c, d]\n        a[:] = s\n        self.assertEqual(\n            [b, c, d],\n            list(a))\n\n    def test_setslice_all_replace_reversed(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        s = [d, c, b]\n        a[:] = s\n        self.assertEqual(\n            [d, c, b],\n            list(a))\n\n    def test_setslice_all_replace_reversed_ns1(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('{ns}a')\n        b = SubElement(a, '{ns}b', {'{ns1}a1': 'test'})\n        c = SubElement(a, '{ns}c', {'{ns2}a2': 'test'})\n        d = SubElement(a, '{ns}d', {'{ns3}a3': 'test'})\n\n        s = [d, c, b]\n        a[:] = s\n        self.assertEqual(\n            [d, c, b],\n            list(a))\n        self.assertEqual(\n            ['{ns}d', '{ns}c', '{ns}b'],\n            [ child.tag for child in a ])\n\n        self.assertEqual(\n            [['{ns3}a3'], ['{ns2}a2'], ['{ns1}a1']],\n            [ list(child.attrib.keys()) for child in a ])\n\n    def test_setslice_all_replace_reversed_ns2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('{ns}a')\n        b = SubElement(a, '{ns1}b', {'{ns}a1': 'test'})\n        c = SubElement(a, '{ns2}c', {'{ns}a2': 'test'})\n        d = SubElement(a, '{ns3}d', {'{ns}a3': 'test'})\n\n        s = [d, c, b]\n        a[:] = s\n        self.assertEqual(\n            [d, c, b],\n            list(a))\n        self.assertEqual(\n            ['{ns3}d', '{ns2}c', '{ns1}b'],\n            [ child.tag for child in a ])\n\n        self.assertEqual(\n            [['{ns}a3'], ['{ns}a2'], ['{ns}a1']],\n            [ list(child.attrib.keys()) for child in a ])\n\n    def test_setslice_end(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n        h = Element('h')\n\n        s = [e, f]\n        a[99:] = s\n        self.assertEqual(\n            [b, c, e, f],\n            list(a))\n\n        s = [g, h]\n        a[:0] = s\n        self.assertEqual(\n            [g, h, b, c, e, f],\n            list(a))\n\n    def test_setslice_end_exact(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        s = [e, f, g]\n        a[3:] = s\n        self.assertEqual(\n            [b, c, d, e, f, g],\n            list(a))\n\n    def test_setslice_single(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        e = Element('e')\n        f = Element('f')\n\n        s = [e]\n        a[0:1] = s\n        self.assertEqual(\n            [e, c],\n            list(a))\n\n        s = [f]\n        a[1:2] = s\n        self.assertEqual(\n            [e, f],\n            list(a))\n\n    def test_setslice_tail(self):\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n        f = BytesIO(b'<a><b></b>B2<c></c>C2<d></d>D2<e></e>E2</a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        x = Element('x')\n        y = Element('y')\n        z = Element('z')\n        x.tail = 'X2'\n        y.tail = 'Y2'\n        z.tail = 'Z2'\n        a[1:3] = [x, y, z]\n        self.assertXML(\n            b'<a><b></b>B2<x></x>X2<y></y>Y2<z></z>Z2<e></e>E2</a>',\n            a)\n\n    def test_setslice_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1:-1] = [x, y]\n        self.assertEqual(\n            [b, x, y, d],\n            list(a))\n\n    def test_setslice_negative2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1:-2] = [x, y]\n        self.assertEqual(\n            [b, x, y, c, d],\n            list(a))\n\n    def test_setslice_empty(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n\n        b = Element('b')\n        c = Element('c')\n\n        a[:] = [b, c]\n        self.assertEqual(\n            [b, c],\n            list(a))\n\n    def test_tail_elementtree_root(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        a = Element('a')\n        a.tail = 'A2'\n        t = ElementTree(element=a)\n        self.assertEqual('A2',\n                          a.tail)\n\n    def test_ns_access(self):\n        ElementTree = self.etree.ElementTree\n        ns = 'http://xml.infrae.com/1'\n        f = BytesIO(('<x:a xmlns:x=\"%s\"><x:b></x:b></x:a>' % ns).encode('utf-8'))\n        t = ElementTree(file=f)\n        a = t.getroot()\n        self.assertEqual('{%s}a' % ns,\n                          a.tag)\n        self.assertEqual('{%s}b' % ns,\n                          a[0].tag)\n\n    def test_ns_access2(self):\n        ElementTree = self.etree.ElementTree\n        ns = 'http://xml.infrae.com/1'\n        ns2 = 'http://xml.infrae.com/2'\n        f = BytesIO(('<x:a xmlns:x=\"%s\" xmlns:y=\"%s\"><x:b></x:b><y:b></y:b></x:a>' % (ns, ns2)).encode('utf-8'))\n        t = ElementTree(file=f)\n        a = t.getroot()\n        self.assertEqual('{%s}a' % ns,\n                          a.tag)\n        self.assertEqual('{%s}b' % ns,\n                          a[0].tag)\n        self.assertEqual('{%s}b' % ns2,\n                          a[1].tag)\n\n    def test_ns_setting(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ns = 'http://xml.infrae.com/1'\n        ns2 = 'http://xml.infrae.com/2'\n        a = Element('{%s}a' % ns)\n        b = SubElement(a, '{%s}b' % ns2)\n        c = SubElement(a, '{%s}c' % ns)\n        self.assertEqual('{%s}a' % ns,\n                          a.tag)\n        self.assertEqual('{%s}b' % ns2,\n                          b.tag)\n        self.assertEqual('{%s}c' % ns,\n                          c.tag)\n        self.assertEqual('{%s}a' % ns,\n                          a.tag)\n        self.assertEqual('{%s}b' % ns2,\n                          b.tag)\n        self.assertEqual('{%s}c' % ns,\n                          c.tag)\n\n    def test_ns_tag_parse(self):\n        ElementTree = self.etree.ElementTree\n\n        ns = 'http://xml.infrae.com/1'\n        ns2 = 'http://xml.infrae.com/2'\n        f = BytesIO(('<a xmlns=\"%s\" xmlns:x=\"%s\"><x:b></x:b><b></b></a>' % (ns, ns2)).encode('utf-8'))\n        t = ElementTree(file=f)\n\n        a = t.getroot()\n        self.assertEqual('{%s}a' % ns,\n                          a.tag)\n        self.assertEqual('{%s}b' % ns2,\n                          a[0].tag)\n        self.assertEqual('{%s}b' % ns,\n                          a[1].tag)\n\n    def test_ns_attr(self):\n        Element = self.etree.Element\n        ns = 'http://xml.infrae.com/1'\n        ns2 = 'http://xml.infrae.com/2'\n        a = Element('a')\n        a.set('{%s}foo' % ns, 'Foo')\n        a.set('{%s}bar' % ns2, 'Bar')\n        self.assertEqual(\n            'Foo',\n            a.get('{%s}foo' % ns))\n        self.assertEqual(\n            'Bar',\n            a.get('{%s}bar' % ns2))\n        try:\n            self.assertXML(\n                ('<a xmlns:ns0=\"%s\" xmlns:ns1=\"%s\" ns0:foo=\"Foo\" ns1:bar=\"Bar\"></a>' % (ns, ns2)).encode('utf-8'),\n                a)\n        except AssertionError:\n            self.assertXML(\n                ('<a xmlns:ns0=\"%s\" xmlns:ns1=\"%s\" ns1:foo=\"Foo\" ns0:bar=\"Bar\"></a>' % (ns2, ns)).encode('utf-8'),\n                a)\n\n    def test_ns_move(self):\n        Element = self.etree.Element\n        one = self.etree.fromstring(\n            b'<foo><bar xmlns:ns=\"http://a.b.c\"><ns:baz/></bar></foo>')\n        baz = one[0][0]\n\n        two = Element('root')\n        two.append(baz)\n        # removing the originating document could cause a crash/error before\n        # as namespace is not moved along with it\n        del one, baz\n        self.assertEqual('{http://a.b.c}baz', two[0].tag)\n\n    def test_ns_decl_tostring(self):\n        tostring = self.etree.tostring\n        root = self.etree.XML(\n            b'<foo><bar xmlns:ns=\"http://a.b.c\"><ns:baz/></bar></foo>')\n        baz = root[0][0]\n\n        nsdecl = re.findall(b\"xmlns(?::[a-z0-9]+)?=[\\\"']([^\\\"']+)[\\\"']\",\n                            tostring(baz))\n        self.assertEqual([b\"http://a.b.c\"], nsdecl)\n\n    def test_ns_decl_tostring_default(self):\n        tostring = self.etree.tostring\n        root = self.etree.XML(\n            b'<foo><bar xmlns=\"http://a.b.c\"><baz/></bar></foo>')\n        baz = root[0][0]\n\n        nsdecl = re.findall(b\"xmlns(?::[a-z0-9]+)?=[\\\"']([^\\\"']+)[\\\"']\",\n                            tostring(baz))\n        self.assertEqual([b\"http://a.b.c\"], nsdecl)\n\n    def test_ns_decl_tostring_root(self):\n        tostring = self.etree.tostring\n        root = self.etree.XML(\n            b'<foo xmlns:ns=\"http://a.b.c\"><bar><ns:baz/></bar></foo>')\n        baz = root[0][0]\n\n        nsdecl = re.findall(b\"xmlns(?::[a-z0-9]+)?=[\\\"']([^\\\"']+)[\\\"']\",\n                            tostring(baz))\n\n        self.assertEqual([b\"http://a.b.c\"], nsdecl)\n\n    def test_ns_decl_tostring_element(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        root = Element(\"foo\")\n        bar = SubElement(root, \"{http://a.b.c}bar\")\n        baz = SubElement(bar, \"{http://a.b.c}baz\")\n\n        nsdecl = re.findall(b\"xmlns(?::[a-z0-9]+)?=[\\\"']([^\\\"']+)[\\\"']\",\n                            self.etree.tostring(baz))\n\n        self.assertEqual([b\"http://a.b.c\"], nsdecl)\n\n    def test_attribute_xmlns_move(self):\n        Element = self.etree.Element\n\n        root = Element('element')\n\n        subelement = Element('subelement',\n                             {\"{http://www.w3.org/XML/1998/namespace}id\": \"foo\"})\n        self.assertEqual(1, len(subelement.attrib))\n        self.assertEqual(\n            \"foo\",\n            subelement.get(\"{http://www.w3.org/XML/1998/namespace}id\"))\n\n        root.append(subelement)\n        self.assertEqual(1, len(subelement.attrib))\n        self.assertEqual(\n            list({\"{http://www.w3.org/XML/1998/namespace}id\" : \"foo\"}.items()),\n            list(subelement.attrib.items()))\n        self.assertEqual(\n            \"foo\",\n            subelement.get(\"{http://www.w3.org/XML/1998/namespace}id\"))\n\n    def test_namespaces_after_serialize(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n\n        ns_href = \"http://a.b.c\"\n        one = parse(\n            BytesIO(('<foo><bar xmlns:ns=\"%s\"><ns:baz/></bar></foo>' % ns_href).encode('utf-8')))\n        baz = one.getroot()[0][0]\n\n        parsed = parse(BytesIO( tostring(baz) )).getroot()\n        self.assertEqual('{%s}baz' % ns_href, parsed.tag)\n\n    def test_attribute_namespace_roundtrip(self):\n        fromstring = self.etree.fromstring\n        tostring = self.etree.tostring\n\n        ns_href = \"http://a.b.c\"\n        xml = '<root xmlns=\"%s\" xmlns:x=\"%s\"><el x:a=\"test\" /></root>' % (\n                ns_href, ns_href)\n        root = fromstring(xml)\n        self.assertEqual('test', root[0].get('{%s}a' % ns_href))\n\n        xml2 = tostring(root)\n        self.assertTrue(b':a=' in xml2, xml2)\n\n        root2 = fromstring(xml2)\n        self.assertEqual('test', root2[0].get('{%s}a' % ns_href))\n\n    def test_attribute_namespace_roundtrip_replaced(self):\n        fromstring = self.etree.fromstring\n        tostring = self.etree.tostring\n\n        ns_href = \"http://a.b.c\"\n        xml = '<root xmlns=\"%s\" xmlns:x=\"%s\"><el x:a=\"test\" /></root>' % (\n                ns_href, ns_href)\n        root = fromstring(xml)\n        self.assertEqual('test', root[0].get('{%s}a' % ns_href))\n\n        root[0].set('{%s}a' % ns_href, 'TEST')\n\n        xml2 = tostring(root)\n        self.assertTrue(b':a=' in xml2, xml2)\n\n        root2 = fromstring(xml2)\n        self.assertEqual('TEST', root2[0].get('{%s}a' % ns_href))\n\n    required_versions_ET['test_register_namespace'] = (1,3)\n    def test_register_namespace(self):\n        # ET 1.3+\n        Element = self.etree.Element\n        prefix = 'TESTPREFIX'\n        namespace = 'http://seriously.unknown/namespace/URI'\n\n        el = Element('{%s}test' % namespace)\n        self.assertEqual(\n            '<ns0:test xmlns:ns0=\"%s\"></ns0:test>' % namespace,\n            self._writeElement(el).decode())\n\n        self.etree.register_namespace(prefix, namespace)\n        el = Element('{%s}test' % namespace)\n        self.assertEqual('<%s:test xmlns:%s=\"%s\"></%s:test>' % (\n                prefix, prefix, namespace, prefix),\n            self._writeElement(el).decode())\n\n        self.assertRaises(ValueError, self.etree.register_namespace, 'ns25', namespace)\n\n    def test_tostring(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        self.assertEqual(b'<a><b></b><c></c></a>',\n                          canonicalize(tostring(a)))\n\n    def test_tostring_element(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertEqual(b'<b></b>',\n                          canonicalize(tostring(b)))\n        self.assertEqual(b'<c><d></d></c>',\n                          canonicalize(tostring(c)))\n\n    def test_tostring_element_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(tostring(b) == b'<b/>Foo' or\n                     tostring(b) == b'<b />Foo')\n\n    required_versions_ET['test_tostring_method_html'] = (1,3)\n    def test_tostring_method_html(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        html = Element('html')\n        body = SubElement(html, 'body')\n        p = SubElement(body, 'p')\n        p.text = \"html\"\n        SubElement(p, 'br').tail = \"test\"\n\n        self.assertEqual(b'<html><body><p>html<br>test</p></body></html>',\n                          tostring(html, method=\"html\"))\n\n    required_versions_ET['test_tostring_method_text'] = (1,3)\n    def test_tostring_method_text(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = \"A\"\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = \"TAIL\"\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n\n        self.assertEqual(b'ABTAILCtail',\n                          tostring(a, method=\"text\"))\n\n    def test_iterparse(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b></b><c/></a>')\n\n        iterator = iterparse(f)\n        self.assertEqual(None,\n                          iterator.root)\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('end', root[0]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterparse_incomplete(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b></b><c/></a>')\n\n        iterator = iterparse(f)\n        self.assertEqual(None,\n                          iterator.root)\n        event, element = next(iter(iterator))\n        self.assertEqual('end', event)\n        self.assertEqual('b', element.tag)\n\n    def test_iterparse_file(self):\n        iterparse = self.etree.iterparse\n        iterator = iterparse(fileInTestDir(\"test.xml\"))\n        self.assertEqual(None,\n                          iterator.root)\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('end', root[0]), ('end', root)],\n            events)\n\n    def test_iterparse_start(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b></b><c/></a>')\n\n        iterator = iterparse(f, events=('start',))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('start', root[1])],\n            events)\n\n    def test_iterparse_start_end(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b></b><c/></a>')\n\n        iterator = iterparse(f, events=('start','end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('end', root[0]),\n             ('start', root[1]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterparse_clear(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b></b><c/></a>')\n\n        iterator = iterparse(f)\n        for event, elem in iterator:\n            elem.clear()\n\n        root = iterator.root\n        self.assertEqual(0,\n                          len(root))\n\n    def test_iterparse_large(self):\n        iterparse = self.etree.iterparse\n        CHILD_COUNT = 12345\n        f = BytesIO(b'<a>%s</a>' % (b'<b>test</b>' * CHILD_COUNT))\n\n        i = 0\n        for key in iterparse(f):\n            event, element = key\n            i += 1\n        self.assertEqual(i, CHILD_COUNT + 1)\n\n    def test_iterparse_set_ns_attribute(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a xmlns=\"http://ns1/\"><b><c xmlns=\"http://ns2/\"/></b></a>')\n\n        attr_name = '{http://testns/}bla'\n        events = []\n        iterator = iterparse(f, events=('start','end','start-ns','end-ns'))\n        for event, elem in iterator:\n            events.append(event)\n            if event == 'start':\n                if elem.tag != '{http://ns1/}a':\n                    elem.set(attr_name, 'value')\n\n        self.assertEqual(\n            ['start-ns', 'start', 'start', 'start-ns', 'start',\n             'end', 'end-ns', 'end', 'end', 'end-ns'],\n            events)\n\n        root = iterator.root\n        self.assertEqual(\n            None,\n            root.get(attr_name))\n        self.assertEqual(\n            'value',\n            root[0].get(attr_name))\n\n    def test_iterparse_only_end_ns(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a xmlns=\"http://ns1/\"><b><c xmlns=\"http://ns2/\"/></b></a>')\n\n        attr_name = '{http://testns/}bla'\n        events = []\n        iterator = iterparse(f, events=('start','end','start-ns','end-ns'))\n        for event, elem in iterator:\n            events.append(event)\n            if event == 'start':\n                if elem.tag != '{http://ns1/}a':\n                    elem.set(attr_name, 'value')\n\n        self.assertEqual(\n            ['start-ns', 'start', 'start', 'start-ns', 'start',\n             'end', 'end-ns', 'end', 'end', 'end-ns'],\n            events)\n\n        root = iterator.root\n        self.assertEqual(\n            None,\n            root.get(attr_name))\n        self.assertEqual(\n            'value',\n            root[0].get(attr_name))\n\n    def test_iterparse_move_elements(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<a><b><d/></b><c/></a>')\n\n        for event, node in etree.iterparse(f): pass\n\n        root = etree.Element('new_root', {})\n        root[:] = node[:]\n\n        self.assertEqual(\n            ['b', 'c'],\n            [ el.tag for el in root ])\n\n    def test_iterparse_cdata(self):\n        tostring = self.etree.tostring\n        f = BytesIO(b'<root><![CDATA[test]]></root>')\n        context = self.etree.iterparse(f)\n        content = [ el.text for event,el in context ]\n\n        self.assertEqual(['test'], content)\n        self.assertEqual(b'<root>test</root>',\n                          tostring(context.root))\n\n    def test_parse_file(self):\n        parse = self.etree.parse\n        # from file\n        tree = parse(fileInTestDir('test.xml'))\n        self.assertXML(\n            b'<a><b></b></a>',\n            tree.getroot())\n\n    def test_parse_file_nonexistent(self):\n        parse = self.etree.parse\n        self.assertRaises(IOError, parse, fileInTestDir('notthere.xml'))  \n\n    def test_parse_error_none(self):\n        parse = self.etree.parse\n        self.assertRaises(TypeError, parse, None)\n\n    required_versions_ET['test_parse_error'] = (1,3)\n    def test_parse_error(self):\n        # ET < 1.3 raises ExpatError\n        parse = self.etree.parse\n        f = BytesIO(b'<a><b></c></b></a>')\n        self.assertRaises(SyntaxError, parse, f)\n        f.close()\n\n    required_versions_ET['test_parse_error_from_file'] = (1,3)\n    def test_parse_error_from_file(self):\n        parse = self.etree.parse\n        # from file\n        f = open(fileInTestDir('test_broken.xml'), 'rb')\n        self.assertRaises(SyntaxError, parse, f)\n        f.close()\n\n    def test_parse_file_object(self):\n        parse = self.etree.parse\n        # from file object\n        f = open(fileInTestDir('test.xml'), 'rb')\n        tree = parse(f)\n        f.close()\n        self.assertXML(\n            b'<a><b></b></a>',\n            tree.getroot())\n\n    def test_parse_stringio(self):\n        parse = self.etree.parse\n        f = BytesIO(b'<a><b></b></a>')\n        tree = parse(f)\n        f.close()\n        self.assertXML(\n            b'<a><b></b></a>',\n            tree.getroot()\n           )\n\n    def test_parse_cdata(self):\n        tostring = self.etree.tostring\n        root = self.etree.XML(b'<root><![CDATA[test]]></root>')\n\n        self.assertEqual('test', root.text)\n        self.assertEqual(b'<root>test</root>',\n                          tostring(root))\n\n    def test_parse_with_encoding(self):\n        # this can fail in libxml2 <= 2.6.22\n        parse = self.etree.parse\n        tree = parse(BytesIO(b'<?xml version=\"1.0\" encoding=\"ascii\"?><html/>'))\n        self.assertXML(b'<html></html>',\n                       tree.getroot())\n\n    def test_encoding(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n        self.assertXML(\n            '<a>S\u00f8k p\u00e5 nettet</a>'.encode(),\n            a, 'utf-8')\n\n    def test_encoding_exact(self):\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n\n        f = BytesIO()\n        tree = ElementTree(element=a)\n        tree.write(f, encoding='utf-8')\n        self.assertEqual('<a>S\u00f8k p\u00e5 nettet</a>'.encode(),\n                          f.getvalue().replace(b'\\n',b''))\n\n    def test_parse_file_encoding(self):\n        parse = self.etree.parse\n        # from file\n        tree = parse(fileInTestDir('test-string.xml'))\n        self.assertXML(\n            '<a>S\u00f8k p\u00e5 nettet</a>'.encode(),\n            tree.getroot(), 'UTF-8')\n\n    def test_parse_file_object_encoding(self):\n        parse = self.etree.parse\n        # from file object\n        f = open(fileInTestDir('test-string.xml'), 'rb')\n        tree = parse(f)\n        f.close()\n        self.assertXML(\n            '<a>S\u00f8k p\u00e5 nettet</a>'.encode(),\n            tree.getroot(), 'UTF-8')\n\n    def test_encoding_8bit_latin1(self):\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n\n        f = BytesIO()\n        tree = ElementTree(element=a)\n        tree.write(f, encoding='iso-8859-1')\n        result = f.getvalue()\n        declaration = b\"<?xml version=\\'1.0\\' encoding=\\'iso-8859-1\\'?>\"\n        self.assertEncodingDeclaration(result, b'iso-8859-1')\n        result = result.split(b'?>', 1)[-1].replace(b'\\n',b'')\n        self.assertEqual('<a>S\u00f8k p\u00e5 nettet</a>'.encode('iso-8859-1'),\n                          result)\n\n    required_versions_ET['test_parse_encoding_8bit_explicit'] = (1,3)\n    def test_parse_encoding_8bit_explicit(self):\n        XMLParser = self.XMLParser\n\n        text = 'S\u00f8k p\u00e5 nettet'\n        xml_latin1 = ('<a>%s</a>' % text).encode('iso-8859-1')\n\n        self.assertRaises(self.etree.ParseError,\n                          self.etree.parse,\n                          BytesIO(xml_latin1))\n\n        tree = self.etree.parse(BytesIO(xml_latin1),\n                                XMLParser(encoding=\"iso-8859-1\"))\n        a = tree.getroot()\n        self.assertEqual(a.text, text)\n\n    required_versions_ET['test_parse_encoding_8bit_override'] = (1,3)\n    def test_parse_encoding_8bit_override(self):\n        XMLParser = self.XMLParser\n\n        text = 'S\u00f8k p\u00e5 nettet'\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = ('%s<a>%s</a>' % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        self.assertRaises(self.etree.ParseError,\n                          self.etree.parse,\n                          BytesIO(xml_latin1))\n\n        tree = self.etree.parse(BytesIO(xml_latin1),\n                                XMLParser(encoding=\"iso-8859-1\"))\n        a = tree.getroot()\n        self.assertEqual(a.text, text)\n\n    def _test_wrong_unicode_encoding(self):\n        # raise error on wrong encoding declaration in unicode strings\n        XML = self.etree.XML\n        test_utf = ('<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>' +\n                    '<a>S\u00f8k p\u00e5 nettet</a>')\n        self.assertRaises(SyntaxError, XML, test_utf)\n\n    def test_encoding_write_default_encoding(self):\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n\n        f = BytesIO()\n        tree = ElementTree(element=a)\n        tree.write(f)\n        data = f.getvalue().replace(b'\\n',b'')\n        self.assertEqual(\n            '<a>S\u00f8k p\u00e5 nettet</a>'.encode('ASCII', 'xmlcharrefreplace'),\n            data)\n\n    def test_encoding_tostring(self):\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n        self.assertEqual('<a>S\u00f8k p\u00e5 nettet</a>'.encode(),\n                         tostring(a, encoding='utf-8'))\n\n    def test_encoding_tostring_unknown(self):\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n        self.assertRaises(LookupError, tostring, a,\n                          encoding='Invalid Encoding')\n\n    def test_encoding_tostring_sub(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        b.text = 'S\u00f8k p\u00e5 nettet'\n        self.assertEqual('<b>S\u00f8k p\u00e5 nettet</b>'.encode(),\n                         tostring(b, encoding='utf-8'))\n\n    def test_encoding_tostring_sub_tail(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        b.text = 'S\u00f8k p\u00e5 nettet'\n        b.tail = 'S\u00f8k'\n        self.assertEqual('<b>S\u00f8k p\u00e5 nettet</b>S\u00f8k'.encode(),\n                         tostring(b, encoding='utf-8'))\n\n    def test_encoding_tostring_default_encoding(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        a.text = 'S\u00f8k p\u00e5 nettet'\n\n        expected = b'<a>S&#248;k p&#229; nettet</a>'\n        self.assertEqual(\n            expected,\n            tostring(a))\n\n    def test_encoding_sub_tostring_default_encoding(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        b.text = 'S\u00f8k p\u00e5 nettet'\n\n        expected = b'<b>S&#248;k p&#229; nettet</b>'\n        self.assertEqual(\n            expected,\n            tostring(b))\n\n    def test_encoding_8bit_xml(self):\n        utext = 'S\u00f8k p\u00e5 nettet'\n        uxml = '<p>%s</p>' % utext\n        prologue = b'<?xml version=\"1.0\" encoding=\"iso-8859-1\" ?>'\n        isoxml = prologue + uxml.encode('iso-8859-1')\n        tree = self.etree.XML(isoxml)\n        self.assertEqual(utext, tree.text)\n\n    def test_encoding_utf8_bom(self):\n        utext = 'S\u00f8k p\u00e5 nettet'\n        uxml = ('<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n                '<p>%s</p>' % utext)\n        bom = b'\\\\xEF\\\\xBB\\\\xBF'.decode(\"unicode_escape\").encode(\"latin1\")\n        xml = bom + uxml.encode(\"utf-8\")\n        tree = etree.XML(xml)\n        self.assertEqual(utext, tree.text)\n\n    def test_encoding_8bit_parse_stringio(self):\n        utext = 'S\u00f8k p\u00e5 nettet'\n        uxml = '<p>%s</p>' % utext\n        prologue = b'<?xml version=\"1.0\" encoding=\"iso-8859-1\" ?>'\n        isoxml = prologue + uxml.encode('iso-8859-1')\n        el = self.etree.parse(BytesIO(isoxml)).getroot()\n        self.assertEqual(utext, el.text)\n\n    def test_deepcopy_elementtree(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        a = Element('a')\n        a.text = \"Foo\"\n        atree = ElementTree(a)\n\n        btree = copy.deepcopy(atree)\n        self.assertEqual(\"Foo\", atree.getroot().text)\n        self.assertEqual(\"Foo\", btree.getroot().text)\n        self.assertFalse(btree is atree)\n        self.assertFalse(btree.getroot() is atree.getroot())\n\n    def test_deepcopy(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'Foo'\n\n        b = copy.deepcopy(a)\n        self.assertEqual('Foo', b.text)\n\n        b.text = 'Bar'\n        self.assertEqual('Bar', b.text)\n        self.assertEqual('Foo', a.text)\n\n        del a\n        self.assertEqual('Bar', b.text)\n\n    def test_deepcopy_tail(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.tail = 'Foo'\n\n        b = copy.deepcopy(a)\n        self.assertEqual('Foo', b.tail)\n\n        b.tail = 'Bar'\n        self.assertEqual('Bar', b.tail)\n        self.assertEqual('Foo', a.tail)\n\n        del a\n        self.assertEqual('Bar', b.tail)\n\n    def test_deepcopy_subelement(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        root = Element('root')\n        a = SubElement(root, 'a')\n        a.text = 'FooText'\n        a.tail = 'FooTail'\n\n        b = copy.deepcopy(a)\n        self.assertEqual('FooText', b.text)\n        self.assertEqual('FooTail', b.tail)\n\n        b.text = 'BarText'\n        b.tail = 'BarTail'\n        self.assertEqual('BarTail', b.tail)\n        self.assertEqual('FooTail', a.tail)\n        self.assertEqual('BarText', b.text)\n        self.assertEqual('FooText', a.text)\n\n        del a\n        self.assertEqual('BarTail', b.tail)\n        self.assertEqual('BarText', b.text)\n\n    def test_deepcopy_namespaces(self):\n        root = self.etree.XML(b'''<doc xmlns=\"dns\" xmlns:t=\"tns\">\n        <parent><node t:foo=\"bar\" /></parent>\n        </doc>''')\n        self.assertEqual(\n            root[0][0].get('{tns}foo'),\n            copy.deepcopy(root[0])[0].get('{tns}foo') )\n        self.assertEqual(\n            root[0][0].get('{tns}foo'),\n            copy.deepcopy(root[0][0]).get('{tns}foo') )\n\n    def test_deepcopy_append(self):\n        # previously caused a crash\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        a = Element('a')\n        b = copy.deepcopy(a)\n        a.append( Element('C') )\n        b.append( Element('X') )\n\n        self.assertEqual(b'<a><C/></a>',\n                          tostring(a).replace(b' ', b''))\n        self.assertEqual(b'<a><X/></a>',\n                          tostring(b).replace(b' ', b''))\n\n    def test_deepcopy_comment(self):\n        # previously caused a crash\n        # not supported by ET < 1.3!\n        Comment = self.etree.Comment\n\n        a = Comment(\"ONE\")\n        b = copy.deepcopy(a)\n        b.text = \"ANOTHER\"\n\n        self.assertEqual('ONE',     a.text)\n        self.assertEqual('ANOTHER', b.text)\n\n    def test_shallowcopy(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        a.text = 'Foo'\n\n        b = copy.copy(a)\n        self.assertEqual('Foo', b.text)\n\n        b.text = 'Bar'\n        self.assertEqual('Bar', b.text)\n        self.assertEqual('Foo', a.text)\n        # XXX ElementTree will share nodes, but lxml.etree won't..\n\n    def test_shallowcopy_elementtree(self):\n        Element = self.etree.Element\n        ElementTree = self.etree.ElementTree\n\n        a = Element('a')\n        a.text = 'Foo'\n        atree = ElementTree(a)\n\n        btree = copy.copy(atree)\n        self.assertFalse(btree is atree)\n        self.assertTrue(btree.getroot() is atree.getroot())\n        self.assertEqual('Foo', atree.getroot().text)\n\n    def _test_element_boolean(self):\n        # deprecated as of ET 1.3/lxml 2.0\n        etree = self.etree\n        e = etree.Element('foo')\n        self.assertEqual(False, bool(e))\n        etree.SubElement(e, 'bar')\n        self.assertEqual(True, bool(e))\n        e = etree.Element('foo')\n        e.text = 'hey'\n        self.assertEqual(False, bool(e))\n        e = etree.Element('foo')\n        e.tail = 'bar'\n        self.assertEqual(False, bool(e))\n        e = etree.Element('foo')\n        e.set('bar', 'Bar')\n        self.assertEqual(False, bool(e))\n\n    def test_multiple_elementrees(self):\n        etree = self.etree\n\n        a = etree.Element('a')\n        b = etree.SubElement(a, 'b')\n\n        t = etree.ElementTree(a)\n        self.assertEqual(self._rootstring(t), b'<a><b/></a>')\n\n        t1 = etree.ElementTree(a)\n        self.assertEqual(self._rootstring(t1), b'<a><b/></a>')\n        self.assertEqual(self._rootstring(t),  b'<a><b/></a>')\n\n        t2 = etree.ElementTree(b)\n        self.assertEqual(self._rootstring(t2), b'<b/>')\n        self.assertEqual(self._rootstring(t1), b'<a><b/></a>')\n        self.assertEqual(self._rootstring(t),  b'<a><b/></a>')\n\n    def test_qname(self):\n        etree = self.etree\n        qname = etree.QName('myns', 'a')\n        a1 = etree.Element(qname)\n        a2 = etree.SubElement(a1, qname)\n        self.assertEqual(a1.tag, \"{myns}a\")\n        self.assertEqual(a2.tag, \"{myns}a\")\n\n    def test_qname_cmp(self):\n        etree = self.etree\n        qname1 = etree.QName('myns', 'a')\n        qname2 = etree.QName('myns', 'a')\n        self.assertEqual(qname1, \"{myns}a\")\n        self.assertEqual(\"{myns}a\", qname2)\n        self.assertEqual(qname1, qname1)\n        self.assertEqual(qname1, qname2)\n\n    def test_qname_attribute_getset(self):\n        etree = self.etree\n        qname = etree.QName('myns', 'a')\n\n        a = etree.Element(qname)\n        a.set(qname, \"value\")\n\n        self.assertEqual(a.get(qname), \"value\")\n        self.assertEqual(a.get(\"{myns}a\"), \"value\")\n\n    def test_qname_attrib(self):\n        etree = self.etree\n        qname = etree.QName('myns', 'a')\n\n        a = etree.Element(qname)\n        a.attrib[qname] = \"value\"\n\n        self.assertEqual(a.attrib[qname], \"value\")\n        self.assertEqual(a.attrib.get(qname), \"value\")\n\n        self.assertEqual(a.attrib[\"{myns}a\"], \"value\")\n        self.assertEqual(a.attrib.get(\"{myns}a\"), \"value\")\n\n    def test_qname_attribute_resolve(self):\n        etree = self.etree\n        qname = etree.QName('http://myns', 'a')\n        a = etree.Element(qname)\n        a.set(qname, qname)\n\n        self.assertXML(\n            b'<ns0:a xmlns:ns0=\"http://myns\" ns0:a=\"ns0:a\"></ns0:a>',\n            a)\n\n    def test_qname_attribute_resolve_new(self):\n        etree = self.etree\n        qname = etree.QName('http://myns', 'a')\n        a = etree.Element('a')\n        a.set('a', qname)\n\n        self.assertXML(\n            b'<a xmlns:ns0=\"http://myns\" a=\"ns0:a\"></a>',\n            a)\n\n    def test_qname_attrib_resolve(self):\n        etree = self.etree\n        qname = etree.QName('http://myns', 'a')\n        a = etree.Element(qname)\n        a.attrib[qname] = qname\n\n        self.assertXML(\n            b'<ns0:a xmlns:ns0=\"http://myns\" ns0:a=\"ns0:a\"></ns0:a>',\n            a)\n\n    def test_parser_version(self):\n        etree = self.etree\n        parser = etree.XMLParser()\n        if hasattr(parser, \"version\"):\n            # ElementTree 1.3+, cET\n            self.assertTrue(re.match(\"[^ ]+ [0-9.]+\", parser.version))\n\n    # feed parser interface\n\n    def test_feed_parser_bytes(self):\n        parser = self.XMLParser()\n\n        parser.feed(b'<?xml version=')\n        parser.feed(b'\"1.0\"?><ro')\n        parser.feed(b'ot><')\n        parser.feed(b'a test=\"works\"/')\n        parser.feed(b'></root')\n        parser.feed(b'>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n\n    def test_feed_parser_unicode_ascii(self):\n        parser = self.XMLParser()\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot><')\n        parser.feed('a test=\"works\"/')\n        parser.feed('></root')\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n\n    @et_needs_pyversion(3)\n    def test_feed_parser_unicode_astral(self):\n        parser = self.XMLParser()\n\n        astral_chunk = '-- \\U00010143 --'  # astral (4 bytes/chr)\n        latin1_chunk = '-- \\xf8 --'  # Latin1 (1 byte/chr)\n\n        parser.feed('<ro')  # ASCII (1 byte/chr)\n        parser.feed('ot><')\n        parser.feed('a test=\"w\\N{DIAMETER SIGN}rks\">')  # BMP (2 bytes/chr)\n        parser.feed(astral_chunk)\n        parser.feed(latin1_chunk)\n        parser.feed('</a></root')\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"w\\N{DIAMETER SIGN}rks\")\n        self.assertEqual(root[0].text, astral_chunk + latin1_chunk)\n\n    def test_feed_parser_unicode_astral_large(self):\n        parser = self.XMLParser()\n\n        astral_chunk = '-- \\U00010143 --' * (2 ** 16)  # astral (4 bytes/chr)\n        latin1_chunk = '-- \\xf8 --'  # Latin1 (1 byte/chr)\n\n        parser.feed('<ro')\n        parser.feed('ot><')  # ASCII (1 byte/chr)\n        parser.feed('a test=\"w\\N{DIAMETER SIGN}rks\">')  # BMP (2 bytes/chr)\n        parser.feed(astral_chunk)\n        parser.feed((astral_chunk + \"</a> <a>\" + astral_chunk) * 16)\n        parser.feed(latin1_chunk)\n        parser.feed('</a></root')\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(root[0].get(\"test\"), \"w\\N{DIAMETER SIGN}rks\")\n        for child in root[:-1]:\n            self.assertEqual(child.tag, \"a\")\n            self.assertEqual(child.text, astral_chunk * 2)\n        self.assertEqual(root[-1].tag, \"a\")\n        self.assertEqual(root[-1].text, astral_chunk + latin1_chunk)\n\n    required_versions_ET['test_feed_parser_error_close_empty'] = (1,3)\n    def test_feed_parser_error_close_empty(self):\n        ParseError = self.etree.ParseError\n        parser = self.XMLParser()\n        self.assertRaises(ParseError, parser.close)\n\n    required_versions_ET['test_feed_parser_error_close_incomplete'] = (1,3)\n    def test_feed_parser_error_close_incomplete(self):\n        ParseError = self.etree.ParseError\n        parser = self.XMLParser()\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n\n        self.assertRaises(ParseError, parser.close)\n\n    required_versions_ET['test_feed_parser_error_broken'] = (1,3)\n    def test_feed_parser_error_broken(self):\n        ParseError = self.etree.ParseError\n        parser = self.XMLParser()\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        try:\n            parser.feed('<><><><><><><')\n        except ParseError:\n            # can raise, but not required before close()\n            pass\n\n        self.assertRaises(ParseError, parser.close)\n\n    required_versions_ET['test_feed_parser_error_position'] = (1,3)\n    def test_feed_parser_error_position(self):\n        ParseError = self.etree.ParseError\n        parser = self.XMLParser()\n        try:\n            parser.close()\n        except ParseError:\n            e = sys.exc_info()[1]\n            self.assertNotEqual(None, e.code)\n            self.assertNotEqual(0, e.code)\n            self.assertTrue(isinstance(e.position, tuple))\n            self.assertTrue(e.position >= (0, 0))\n\n    # parser target interface\n\n    required_versions_ET['test_parser_target_property'] = (1,3)\n    def test_parser_target_property(self):\n        class Target:\n            pass\n\n        target = Target()\n        parser = self.XMLParser(target=target)\n\n        self.assertEqual(target, parser.target)\n\n    def test_parser_target_tag(self):\n        assertEqual = self.assertEqual\n        assertFalse  = self.assertFalse\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertFalse(attrib)\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        parser.feed(\"<TAG/>\")\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_error_in_start(self):\n        assertEqual = self.assertEqual\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertEqual(\"TAG\", tag)\n                raise ValueError(\"TEST\")\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        try:\n            parser.feed(\"<TAG/>\")\n        except ValueError:\n            self.assertTrue('TEST' in str(sys.exc_info()[1]))\n        else:\n            self.assertTrue(False)\n        if 'lxml' in self.etree.__name__:\n            self.assertEqual([\"start\"], events)\n        else:\n            # cElementTree calls end() as well\n            self.assertTrue(\"start\" in events)\n\n    def test_parser_target_error_in_end(self):\n        assertEqual = self.assertEqual\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n                raise ValueError(\"TEST\")\n            def close(self):\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        try:\n            parser.feed(\"<TAG/>\")\n        except ValueError:\n            self.assertTrue('TEST' in str(sys.exc_info()[1]))\n        else:\n            self.assertTrue(False)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_error_in_close(self):\n        assertEqual = self.assertEqual\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                raise ValueError(\"TEST\")\n\n        parser = self.XMLParser(target=Target())\n\n        try:\n            parser.feed(\"<TAG/>\")\n            parser.close()\n        except ValueError:\n            self.assertTrue('TEST' in str(sys.exc_info()[1]))\n        else:\n            self.assertTrue(False)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_error_in_start_and_close(self):\n        assertEqual = self.assertEqual\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertEqual(\"TAG\", tag)\n                raise IndexError(\"TEST-IE\")\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                raise ValueError(\"TEST-VE\")\n\n        parser = self.XMLParser(target=Target())\n\n        try:\n            parser.feed(\"<TAG/>\")\n            parser.close()\n        except IndexError:\n            if 'lxml' in self.etree.__name__:\n                # we try not to swallow the initial exception in Py2\n                self.assertTrue(sys.version_info[0] < 3)\n            self.assertTrue('TEST-IE' in str(sys.exc_info()[1]))\n        except ValueError:\n            if 'lxml' in self.etree.__name__:\n                self.assertTrue(sys.version_info[0] >= 3)\n            self.assertTrue('TEST-VE' in str(sys.exc_info()[1]))\n        else:\n            self.assertTrue(False)\n\n        if 'lxml' in self.etree.__name__:\n            self.assertEqual([\"start\"], events)\n        else:\n            # cElementTree calls end() as well\n            self.assertTrue(\"start\" in events)\n\n    def test_elementtree_parser_target(self):\n        assertEqual = self.assertEqual\n        assertFalse  = self.assertFalse\n        Element = self.etree.Element\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertFalse(attrib)\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                return Element(\"DONE\")\n\n        parser = self.XMLParser(target=Target())\n        tree = self.etree.ElementTree()\n        tree.parse(BytesIO(b\"<TAG/>\"), parser=parser)\n\n        self.assertEqual(\"DONE\", tree.getroot().tag)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_attrib(self):\n        assertEqual = self.assertEqual\n\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n                for name, value in attrib.items():\n                    assertEqual(tag + name, value)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        parser.feed('<root a=\"roota\" b=\"rootb\"><sub c=\"subc\"/></root>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"start-sub\", \"end-sub\", \"end-root\"],\n                          events)\n\n    def test_parser_target_data(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        parser.feed('<root>A<sub/>B</root>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-sub\",\n                           \"end-sub\", \"data-B\", \"end-root\"],\n                          events)\n\n    def test_parser_target_entity(self):\n        events = []\n        class Target:\n            def __init__(self):\n                self._data = []\n            def _flush_data(self):\n                if self._data:\n                    events.append(\"data-\" + ''.join(self._data))\n                    del self._data[:]\n            def start(self, tag, attrib):\n                self._flush_data()\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                self._flush_data()\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                self._data.append(data)\n            def close(self):\n                self._flush_data()\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        dtd = '''\n            <!DOCTYPE root [\n            <!ELEMENT root (sub*)>\n            <!ELEMENT sub (#PCDATA)>\n            <!ENTITY ent \"an entity\">\n        ]>\n        '''\n        parser.feed(dtd+'<root><sub/><sub>this is &ent;</sub><sub/></root>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"start-sub\", \"end-sub\", \"start-sub\",\n                           \"data-this is an entity\",\n                           \"end-sub\", \"start-sub\", \"end-sub\", \"end-root\"],\n                          events)\n\n    required_versions_ET['test_parser_target_entity_unknown'] = (1,3)\n    def test_parser_target_entity_unknown(self):\n        events = []\n        class Target:\n            def __init__(self):\n                self._data = []\n            def _flush_data(self):\n                if self._data:\n                    events.append(\"data-\" + ''.join(self._data))\n                    del self._data[:]\n            def start(self, tag, attrib):\n                self._flush_data()\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                self._flush_data()\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                self._data.append(data)\n            def close(self):\n                self._flush_data()\n                return \"DONE\"\n\n        parser = self.XMLParser(target=Target())\n\n        def feed():\n            parser.feed('<root><sub/><sub>some &ent;</sub><sub/></root>')\n            parser.close()\n\n        self.assertRaises(self.etree.ParseError, feed)\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_parser_target_start_end_ns(self):\n        class Builder(list):\n            def start(self, tag, attrib):\n                self.append((\"start\", tag))\n            def end(self, tag):\n                self.append((\"end\", tag))\n            def data(self, text):\n                pass\n            def pi(self, target, data):\n                self.append((\"pi\", target, data))\n            def comment(self, data):\n                self.append((\"comment\", data))\n            def start_ns(self, prefix, uri):\n                self.append((\"start-ns\", prefix, uri))\n            def end_ns(self, prefix):\n                self.append((\"end-ns\", prefix))\n\n        builder = Builder()\n        parser = self.etree.XMLParser(target=builder)\n        parser.feed(textwrap.dedent(\"\"\"\\\n            <?pi data?>\n            <!-- comment -->\n            <root xmlns='namespace'>\n               <element key='value'>text</element>\n               <element>text</element>tail\n               <empty-element/>\n            </root>\n            \"\"\"))\n        self.assertEqual(builder, [\n                ('pi', 'pi', 'data'),\n                ('comment', ' comment '),\n                ('start-ns', '', 'namespace'),\n                ('start', '{namespace}root'),\n                ('start', '{namespace}element'),\n                ('end', '{namespace}element'),\n                ('start', '{namespace}element'),\n                ('end', '{namespace}element'),\n                ('start', '{namespace}empty-element'),\n                ('end', '{namespace}empty-element'),\n                ('end', '{namespace}root'),\n                ('end-ns', ''),\n            ])\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_parser_target_end_ns(self):\n        class Builder(list):\n            def end_ns(self, prefix):\n                self.append((\"end-ns\", prefix))\n\n        builder = Builder()\n        parser = self.etree.XMLParser(target=builder)\n        parser.feed(textwrap.dedent(\"\"\"\\\n            <?pi data?>\n            <!-- comment -->\n            <root xmlns='namespace' xmlns:p='pns'>\n               <element key='value'>text</element>\n               <p:element>text</p:element>tail\n               <empty-element/>\n            </root>\n            \"\"\"))\n        self.assertEqual(builder, [\n                ('end-ns', 'p'),\n                ('end-ns', ''),\n            ])\n\n    def test_treebuilder(self):\n        builder = self.etree.TreeBuilder()\n        el = builder.start(\"root\", {'a':'A', 'b':'B'})\n        self.assertEqual(\"root\", el.tag)\n        self.assertEqual({'a':'A', 'b':'B'}, el.attrib)\n        builder.data(\"ROOTTEXT\")\n        el = builder.start(\"child\", {'x':'X', 'y':'Y'})\n        self.assertEqual(\"child\", el.tag)\n        self.assertEqual({'x':'X', 'y':'Y'}, el.attrib)\n        builder.data(\"CHILDTEXT\")\n        el = builder.end(\"child\")\n        self.assertEqual(\"child\", el.tag)\n        self.assertEqual({'x':'X', 'y':'Y'}, el.attrib)\n        self.assertEqual(\"CHILDTEXT\", el.text)\n        self.assertEqual(None, el.tail)\n        builder.data(\"CHILDTAIL\")\n        root = builder.end(\"root\")\n\n        self.assertEqual(\"root\", root.tag)\n        self.assertEqual(\"ROOTTEXT\", root.text)\n        self.assertEqual(\"CHILDTEXT\", root[0].text)\n        self.assertEqual(\"CHILDTAIL\", root[0].tail)\n\n    def test_treebuilder_target(self):\n        parser = self.XMLParser(target=self.etree.TreeBuilder())\n        parser.feed('<root>ROOTTEXT<child>CHILDTEXT</child>CHILDTAIL</root>')\n        root = parser.close()\n\n        self.assertEqual(\"root\", root.tag)\n        self.assertEqual(\"ROOTTEXT\", root.text)\n        self.assertEqual(\"CHILDTEXT\", root[0].text)\n        self.assertEqual(\"CHILDTAIL\", root[0].tail)\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_treebuilder_comment(self):\n        ET = self.etree\n        b = ET.TreeBuilder()\n        self.assertEqual(b.comment('ctext').tag, ET.Comment)\n        self.assertEqual(b.comment('ctext').text, 'ctext')\n\n        b = ET.TreeBuilder(comment_factory=ET.Comment)\n        self.assertEqual(b.comment('ctext').tag, ET.Comment)\n        self.assertEqual(b.comment('ctext').text, 'ctext')\n\n        #b = ET.TreeBuilder(comment_factory=len)\n        #self.assertEqual(b.comment('ctext'), len('ctext'))\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_treebuilder_pi(self):\n        ET = self.etree\n        is_lxml = ET.__name__ == 'lxml.etree'\n\n        b = ET.TreeBuilder()\n        self.assertEqual(b.pi('target', None).tag, ET.PI)\n        if is_lxml:\n            self.assertEqual(b.pi('target', None).target, 'target')\n        else:\n            self.assertEqual(b.pi('target', None).text, 'target')\n\n        b = ET.TreeBuilder(pi_factory=ET.PI)\n        self.assertEqual(b.pi('target').tag, ET.PI)\n        if is_lxml:\n            self.assertEqual(b.pi('target').target, \"target\")\n        else:\n            self.assertEqual(b.pi('target').text, \"target\")\n        self.assertEqual(b.pi('pitarget', ' text ').tag, ET.PI)\n        if is_lxml:\n            self.assertEqual(b.pi('pitarget', ' text ').target, \"pitarget\")\n            self.assertEqual(b.pi('pitarget', ' text ').text, \" text \")\n        else:\n            self.assertEqual(b.pi('pitarget', ' text ').text, \"pitarget  text \")\n\n        #b = ET.TreeBuilder(pi_factory=lambda target, text: (len(target), text))\n        #self.assertEqual(b.pi('target'), (len('target'), None))\n        #self.assertEqual(b.pi('pitarget', ' text '), (len('pitarget'), ' text '))\n\n    def test_late_tail(self):\n        # Issue #37399: The tail of an ignored comment could overwrite the text before it.\n        ET = self.etree\n        class TreeBuilderSubclass(ET.TreeBuilder):\n            pass\n\n        if ET.__name__ == 'lxml.etree':\n            def assert_content(a):\n                self.assertEqual(a.text, \"text\")\n                self.assertEqual(a[0].tail, \"tail\")\n        else:\n            def assert_content(a):\n                self.assertEqual(a.text, \"texttail\")\n\n        xml = \"<a>text<!-- comment -->tail</a>\"\n        a = ET.fromstring(xml)\n        assert_content(a)\n\n        parser = ET.XMLParser(target=TreeBuilderSubclass())\n        parser.feed(xml)\n        a = parser.close()\n        assert_content(a)\n\n        xml = \"<a>text<?pi data?>tail</a>\"\n        a = ET.fromstring(xml)\n        assert_content(a)\n\n        xml = \"<a>text<?pi data?>tail</a>\"\n        parser = ET.XMLParser(target=TreeBuilderSubclass())\n        parser.feed(xml)\n        a = parser.close()\n        assert_content(a)\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_late_tail_mix_pi_comments(self):\n        # Issue #37399: The tail of an ignored comment could overwrite the text before it.\n        # Test appending tails to comments/pis.\n        ET = self.etree\n        class TreeBuilderSubclass(ET.TreeBuilder):\n            pass\n\n        xml = \"<a>text<?pi1?> <!-- comment -->\\n<?pi2?>tail</a>\"\n        parser = ET.XMLParser(target=ET.TreeBuilder(insert_comments=True, insert_pis=False))\n        parser.feed(xml)\n        a = parser.close()\n        self.assertEqual(a[0].text, ' comment ')\n        self.assertEqual(a[0].tail, '\\ntail')\n        self.assertEqual(a.text, \"text \")\n\n        parser = ET.XMLParser(target=TreeBuilderSubclass(insert_comments=True, insert_pis=False))\n        parser.feed(xml)\n        a = parser.close()\n        self.assertEqual(a[0].text, ' comment ')\n        self.assertEqual(a[0].tail, '\\ntail')\n        self.assertEqual(a.text, \"text \")\n\n        xml = \"<a>text<!-- comment -->\\n<?pi data?>tail</a>\"\n        parser = ET.XMLParser(target=ET.TreeBuilder(insert_pis=True, insert_comments=False))\n        parser.feed(xml)\n        a = parser.close()\n        self.assertEqual(a[0].text[-4:], 'data')\n        self.assertEqual(a[0].tail, 'tail')\n        self.assertEqual(a.text, \"text\\n\")\n\n        parser = ET.XMLParser(target=TreeBuilderSubclass(insert_pis=True, insert_comments=False))\n        parser.feed(xml)\n        a = parser.close()\n        self.assertEqual(a[0].text[-4:], 'data')\n        self.assertEqual(a[0].tail, 'tail')\n        self.assertEqual(a.text, \"text\\n\")\n\n    # helper methods\n\n    def _writeElement(self, element, encoding='us-ascii'):\n        \"\"\"Write out element for comparison.\n        \"\"\"\n        data = self.etree.tostring(element, encoding=encoding)\n        return canonicalize(data)\n\n    def _writeElementFile(self, element, encoding='us-ascii'):\n        \"\"\"Write out element for comparison, using real file.\n        \"\"\"\n        ElementTree = self.etree.ElementTree\n        with tmpfile() as filename:\n            with open(filename, 'wb') as f:\n                tree = ElementTree(element=element)\n                tree.write(f, encoding=encoding)\n            with open(filename, 'rb') as f:\n                data = f.read()\n        return canonicalize(data)\n\n    def assertXML(self, expected, element, encoding='us-ascii'):\n        \"\"\"Writes element out and checks whether it is expected.\n\n        Does this two ways; once using BytesIO, once using a real file.\n        \"\"\"\n        if isinstance(expected, str):\n            expected = expected.encode(encoding)\n        self.assertEqual(expected, self._writeElement(element, encoding))\n        self.assertEqual(expected, self._writeElementFile(element, encoding))\n\n    def assertEncodingDeclaration(self, result, encoding):\n        \"Checks if the result XML byte string specifies the encoding.\"\n        enc_re = r\"<\\?xml[^>]+ encoding=[\\\"']([^\\\"']+)[\\\"']\"\n        if isinstance(result, str):\n            has_encoding = re.compile(enc_re).match\n        else:\n            has_encoding = re.compile(enc_re.encode('ascii')).match\n        self.assertTrue(has_encoding(result))\n        result_encoding = has_encoding(result).group(1)\n        self.assertEqual(result_encoding.upper(), encoding.upper())\n\n    def _rootstring(self, tree):\n        return self.etree.tostring(tree.getroot()).replace(\n            b' ', b'').replace(b'\\n', b'')\n\n    def _check_element_tree(self, tree):\n        self._check_element(tree.getroot())\n\n    def _check_element(self, element):\n        self.assertTrue(hasattr(element, 'tag'))\n        self.assertTrue(hasattr(element, 'attrib'))\n        self.assertTrue(hasattr(element, 'text'))\n        self.assertTrue(hasattr(element, 'tail'))\n        self._check_string(element.tag)\n        self._check_mapping(element.attrib)\n        if element.text is not None:\n            self._check_string(element.text)\n        if element.tail is not None:\n            self._check_string(element.tail)\n\n    def _check_string(self, string):\n        len(string)\n        for char in string:\n            self.assertEqual(1, len(char))\n        new_string = string + \"\"\n        new_string = string + \" \"\n        string[:0]\n\n    def _check_mapping(self, mapping):\n        len(mapping)\n        keys = mapping.keys()\n        values = mapping.values()\n        items = mapping.items()\n        for key in keys:\n            item = mapping[key]\n        mapping[\"key\"] = \"value\"\n        self.assertEqual(\"value\", mapping[\"key\"])\n\n\nclass _ElementSlicingTest(unittest.TestCase):\n    etree = None\n\n    def _elem_tags(self, elemlist):\n        return [e.tag for e in elemlist]\n\n    def _subelem_tags(self, elem):\n        return self._elem_tags(list(elem))\n\n    def _make_elem_with_children(self, numchildren):\n        \"\"\"Create an Element with a tag 'a', with the given amount of children\n           named 'a0', 'a1' ... and so on.\n\n        \"\"\"\n        e = self.etree.Element('a')\n        for i in range(numchildren):\n            self.etree.SubElement(e, 'a%s' % i)\n        return e\n\n    def test_getslice_single_index(self):\n        e = self._make_elem_with_children(10)\n\n        self.assertEqual(e[1].tag, 'a1')\n        self.assertEqual(e[-2].tag, 'a8')\n\n        self.assertRaises(IndexError, lambda: e[12])\n        self.assertRaises(IndexError, lambda: e[-12])\n\n    def test_getslice_range(self):\n        e = self._make_elem_with_children(6)\n\n        self.assertEqual(self._elem_tags(e[3:]), ['a3', 'a4', 'a5'])\n        self.assertEqual(self._elem_tags(e[3:6]), ['a3', 'a4', 'a5'])\n        self.assertEqual(self._elem_tags(e[3:16]), ['a3', 'a4', 'a5'])\n        self.assertEqual(self._elem_tags(e[3:5]), ['a3', 'a4'])\n        self.assertEqual(self._elem_tags(e[3:-1]), ['a3', 'a4'])\n        self.assertEqual(self._elem_tags(e[:2]), ['a0', 'a1'])\n\n    def test_getslice_steps(self):\n        e = self._make_elem_with_children(10)\n\n        self.assertEqual(self._elem_tags(e[8:10:1]), ['a8', 'a9'])\n        self.assertEqual(self._elem_tags(e[::3]), ['a0', 'a3', 'a6', 'a9'])\n        self.assertEqual(self._elem_tags(e[::8]), ['a0', 'a8'])\n        self.assertEqual(self._elem_tags(e[1::8]), ['a1', 'a9'])\n        self.assertEqual(self._elem_tags(e[3::sys.maxsize]), ['a3'])\n        self.assertEqual(self._elem_tags(e[3::sys.maxsize<<64]), ['a3'])\n\n    def test_getslice_negative_steps(self):\n        e = self._make_elem_with_children(4)\n\n        self.assertEqual(self._elem_tags(e[::-1]), ['a3', 'a2', 'a1', 'a0'])\n        self.assertEqual(self._elem_tags(e[::-2]), ['a3', 'a1'])\n        self.assertEqual(self._elem_tags(e[3::-sys.maxsize]), ['a3'])\n        self.assertEqual(self._elem_tags(e[3::-sys.maxsize-1]), ['a3'])\n        self.assertEqual(self._elem_tags(e[3::-sys.maxsize<<64]), ['a3'])\n\n    def test_delslice(self):\n        e = self._make_elem_with_children(4)\n        del e[0:2]\n        self.assertEqual(self._subelem_tags(e), ['a2', 'a3'])\n\n        e = self._make_elem_with_children(4)\n        del e[0:]\n        self.assertEqual(self._subelem_tags(e), [])\n\n        e = self._make_elem_with_children(4)\n        del e[::-1]\n        self.assertEqual(self._subelem_tags(e), [])\n\n        e = self._make_elem_with_children(4)\n        del e[::-2]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'a2'])\n\n        e = self._make_elem_with_children(4)\n        del e[1::2]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'a2'])\n\n        e = self._make_elem_with_children(2)\n        del e[::2]\n        self.assertEqual(self._subelem_tags(e), ['a1'])\n\n    def test_setslice_single_index(self):\n        e = self._make_elem_with_children(4)\n        e[1] = self.etree.Element('b')\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b', 'a2', 'a3'])\n\n        e[-2] = self.etree.Element('c')\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b', 'c', 'a3'])\n\n        with self.assertRaises(IndexError):\n            e[5] = self.etree.Element('d')\n        with self.assertRaises(IndexError):\n            e[-5] = self.etree.Element('d')\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b', 'c', 'a3'])\n\n    def test_setslice_range(self):\n        e = self._make_elem_with_children(4)\n        e[1:3] = [self.etree.Element('b%s' % i) for i in range(2)]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b0', 'b1', 'a3'])\n\n        e = self._make_elem_with_children(4)\n        e[1:3] = [self.etree.Element('b')]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b', 'a3'])\n\n        e = self._make_elem_with_children(4)\n        e[1:3] = [self.etree.Element('b%s' % i) for i in range(3)]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b0', 'b1', 'b2', 'a3'])\n\n    def test_setslice_steps(self):\n        e = self._make_elem_with_children(6)\n        e[1:5:2] = [self.etree.Element('b%s' % i) for i in range(2)]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b0', 'a2', 'b1', 'a4', 'a5'])\n\n        e = self._make_elem_with_children(6)\n        with self.assertRaises(ValueError):\n            e[1:5:2] = [self.etree.Element('b')]\n        with self.assertRaises(ValueError):\n            e[1:5:2] = [self.etree.Element('b%s' % i) for i in range(3)]\n        with self.assertRaises(ValueError):\n            e[1:5:2] = []\n        self.assertEqual(self._subelem_tags(e), ['a0', 'a1', 'a2', 'a3', 'a4', 'a5'])\n\n        e = self._make_elem_with_children(4)\n        e[1::sys.maxsize] = [self.etree.Element('b')]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b', 'a2', 'a3'])\n        e[1::sys.maxsize<<64] = [self.etree.Element('c')]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'c', 'a2', 'a3'])\n\n    def test_setslice_negative_steps(self):\n        e = self._make_elem_with_children(4)\n        e[2:0:-1] = [self.etree.Element('b%s' % i) for i in range(2)]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b1', 'b0', 'a3'])\n\n        e = self._make_elem_with_children(4)\n        with self.assertRaises(ValueError):\n            e[2:0:-1] = [self.etree.Element('b')]\n        with self.assertRaises(ValueError):\n            e[2:0:-1] = [self.etree.Element('b%s' % i) for i in range(3)]\n        with self.assertRaises(ValueError):\n            e[2:0:-1] = []\n        self.assertEqual(self._subelem_tags(e), ['a0', 'a1', 'a2', 'a3'])\n\n        e = self._make_elem_with_children(4)\n        e[1::-sys.maxsize] = [self.etree.Element('b')]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'b', 'a2', 'a3'])\n        e[1::-sys.maxsize-1] = [self.etree.Element('c')]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'c', 'a2', 'a3'])\n        e[1::-sys.maxsize<<64] = [self.etree.Element('d')]\n        self.assertEqual(self._subelem_tags(e), ['a0', 'd', 'a2', 'a3'])\n\n\nclass _XMLPullParserTest(unittest.TestCase):\n    etree = None\n\n    def _close_and_return_root(self, parser):\n        if 'ElementTree' in self.etree.__name__:\n            # ElementTree's API is a bit unwieldy in Py3.4\n            root = parser._close_and_return_root()\n        else:\n            root = parser.close()\n        return root\n\n    def _feed(self, parser, data, chunk_size=None):\n        if chunk_size is None:\n            parser.feed(data)\n        else:\n            for i in range(0, len(data), chunk_size):\n                parser.feed(data[i:i+chunk_size])\n\n    def assert_events(self, parser, expected, max_events=None):\n        self.assertEqual(\n            [(event, (elem.tag, elem.text))\n             for event, elem in islice(parser.read_events(), max_events)],\n            expected)\n\n    def assert_event_tuples(self, parser, expected, max_events=None):\n        self.assertEqual(\n            list(islice(parser.read_events(), max_events)),\n            expected)\n\n    def assert_event_tags(self, parser, expected, max_events=None):\n        events = islice(parser.read_events(), max_events)\n        self.assertEqual([(action, elem.tag) for action, elem in events],\n                         expected)\n\n    def test_simple_xml(self, chunk_size=None):\n        parser = self.etree.XMLPullParser()\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \"<!-- comment -->\\n\", chunk_size)\n        self.assert_event_tags(parser, [])\n        self._feed(parser,\n                   \"<root>\\n  <element key='value'>text</element\",\n                   chunk_size)\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \">\\n\", chunk_size)\n        self._feed(parser, \"<element>text</element>tail\\n\", chunk_size)\n        self._feed(parser, \"<empty-element/>\\n\", chunk_size)\n        self._feed(parser, \"</root>\\n\", chunk_size)\n        self.assert_event_tags(parser, [\n            ('end', 'element'),\n            ('end', 'element'),\n            ('end', 'empty-element'),\n            ('end', 'root'),\n            ])\n        root = self._close_and_return_root(parser)\n        self.assertEqual(root.tag, 'root')\n\n    def test_simple_xml_chunk_1(self):\n        if self.etree is not etree and pyexpat.version_info >= (2, 6, 0):\n            raise unittest.SkipTest(\n                \"Feeding the parser by too small chunks defers parsing\"\n            )\n        self.test_simple_xml(chunk_size=1)\n\n    def test_simple_xml_chunk_5(self):\n        if self.etree is not etree and pyexpat.version_info >= (2, 6, 0):\n            raise unittest.SkipTest(\n                \"Feeding the parser by too small chunks defers parsing\"\n            )\n        self.test_simple_xml(chunk_size=5)\n\n    def test_simple_xml_chunk_22(self):\n        self.test_simple_xml(chunk_size=22)\n\n    def test_feed_while_iterating(self):\n        parser = self.etree.XMLPullParser()\n        it = parser.read_events()\n        self._feed(parser, \"<root>\\n  <element key='value'>text</element>\\n\")\n        action, elem = next(it)\n        self.assertEqual((action, elem.tag), ('end', 'element'))\n        self._feed(parser, \"</root>\\n\")\n        action, elem = next(it)\n        self.assertEqual((action, elem.tag), ('end', 'root'))\n        with self.assertRaises(StopIteration):\n            next(it)\n\n    def test_simple_xml_with_ns(self):\n        parser = self.etree.XMLPullParser()\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \"<!-- comment -->\\n\")\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \"<root xmlns='namespace'>\\n\")\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \"<element key='value'>text</element\")\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \">\\n\")\n        self.assert_event_tags(parser, [('end', '{namespace}element')])\n        self._feed(parser, \"<element>text</element>tail\\n\")\n        self._feed(parser, \"<empty-element/>\\n\")\n        self.assert_event_tags(parser, [\n            ('end', '{namespace}element'),\n            ('end', '{namespace}empty-element'),\n            ])\n        self._feed(parser, \"</root>\\n\")\n        self.assert_event_tags(parser, [('end', '{namespace}root')])\n        root = self._close_and_return_root(parser)\n        self.assertEqual(root.tag, '{namespace}root')\n\n    def test_ns_events(self):\n        parser = self.etree.XMLPullParser(events=('start-ns', 'end-ns'))\n        self._feed(parser, \"<!-- comment -->\\n\")\n        self._feed(parser, \"<root xmlns='namespace'>\\n\")\n        self.assertEqual(\n            list(parser.read_events()),\n            [('start-ns', ('', 'namespace'))])\n        self._feed(parser, \"<element key='value'>text</element\")\n        self._feed(parser, \">\\n\")\n        self._feed(parser, \"<element>text</element>tail\\n\")\n        self._feed(parser, \"<empty-element/>\\n\")\n        self._feed(parser, \"</root>\\n\")\n        self.assertEqual(list(parser.read_events()), [('end-ns', None)])\n        parser.close()\n\n    def test_ns_events_end_ns_only(self):\n        parser = self.etree.XMLPullParser(events=['end-ns'])\n        self._feed(parser, \"<!-- comment -->\\n\")\n        self._feed(parser, \"<root xmlns='namespace' xmlns:a='abc' xmlns:b='xyz'>\\n\")\n        self.assertEqual(list(parser.read_events()), [])\n        self._feed(parser, \"<a:element key='value'>text</a:element\")\n        self._feed(parser, \">\\n\")\n        self._feed(parser, \"<b:element>text</b:element>tail\\n\")\n        self._feed(parser, \"<empty-element/>\\n\")\n        self.assertEqual(list(parser.read_events()), [])\n        self._feed(parser, \"</root>\\n\")\n        self.assertEqual(list(parser.read_events()), [\n            ('end-ns', None),\n            ('end-ns', None),\n            ('end-ns', None),\n        ])\n        parser.close()\n\n    @et_needs_pyversion(3,8)\n    def test_ns_events_start(self):\n        parser = self.etree.XMLPullParser(events=('start-ns', 'start', 'end'))\n        self._feed(parser, \"<tag xmlns='abc' xmlns:p='xyz'>\\n\")\n        self.assert_event_tuples(parser, [\n            ('start-ns', ('', 'abc')),\n            ('start-ns', ('p', 'xyz')),\n        ], max_events=2)\n        self.assert_event_tags(parser, [\n            ('start', '{abc}tag'),\n        ], max_events=1)\n\n        self._feed(parser, \"<child />\\n\")\n        self.assert_event_tags(parser, [\n            ('start', '{abc}child'),\n            ('end', '{abc}child'),\n        ])\n\n        self._feed(parser, \"</tag>\\n\")\n        parser.close()\n        self.assert_event_tags(parser, [\n            ('end', '{abc}tag'),\n        ])\n\n    @et_needs_pyversion(3,8)\n    def test_ns_events_start_end(self):\n        parser = self.etree.XMLPullParser(events=('start-ns', 'start', 'end', 'end-ns'))\n        self._feed(parser, \"<tag xmlns='abc' xmlns:p='xyz'>\\n\")\n        self.assert_event_tuples(parser, [\n            ('start-ns', ('', 'abc')),\n            ('start-ns', ('p', 'xyz')),\n        ], max_events=2)\n        self.assert_event_tags(parser, [\n            ('start', '{abc}tag'),\n        ], max_events=1)\n\n        self._feed(parser, \"<child />\\n\")\n        self.assert_event_tags(parser, [\n            ('start', '{abc}child'),\n            ('end', '{abc}child'),\n        ])\n\n        self._feed(parser, \"</tag>\\n\")\n        parser.close()\n        self.assert_event_tags(parser, [\n            ('end', '{abc}tag'),\n        ], max_events=1)\n        self.assert_event_tuples(parser, [\n            ('end-ns', None),\n            ('end-ns', None),\n        ])\n\n    def test_events(self):\n        parser = self.etree.XMLPullParser(events=())\n        self._feed(parser, \"<root/>\\n\")\n        self.assert_event_tags(parser, [])\n\n        parser = self.etree.XMLPullParser(events=('start', 'end'))\n        self._feed(parser, \"<!-- text here -->\\n\")\n        self.assert_events(parser, [])\n\n        parser = self.etree.XMLPullParser(events=('start', 'end'))\n        self._feed(parser, \"<root>\\n\")\n        self.assert_event_tags(parser, [('start', 'root')])\n        self._feed(parser, \"<element key='value'>text</element\")\n        self.assert_event_tags(parser, [('start', 'element')])\n        self._feed(parser, \">\\n\")\n        self.assert_event_tags(parser, [('end', 'element')])\n        self._feed(parser,\n                   \"<element xmlns='foo'>text<empty-element/></element>tail\\n\")\n        self.assert_event_tags(parser, [\n            ('start', '{foo}element'),\n            ('start', '{foo}empty-element'),\n            ('end', '{foo}empty-element'),\n            ('end', '{foo}element'),\n            ])\n        self._feed(parser, \"</root>\")\n        root = self._close_and_return_root(parser)\n        self.assert_event_tags(parser, [('end', 'root')])\n        self.assertEqual(root.tag, 'root')\n\n        parser = self.etree.XMLPullParser(events=('start',))\n        self._feed(parser, \"<!-- comment -->\\n\")\n        self.assert_event_tags(parser, [])\n        self._feed(parser, \"<root>\\n\")\n        self.assert_event_tags(parser, [('start', 'root')])\n        self._feed(parser, \"<element key='value'>text</element\")\n        self.assert_event_tags(parser, [('start', 'element')])\n        self._feed(parser, \">\\n\")\n        self.assert_event_tags(parser, [])\n        self._feed(parser,\n                   \"<element xmlns='foo'>text<empty-element/></element>tail\\n\")\n        self.assert_event_tags(parser, [\n            ('start', '{foo}element'),\n            ('start', '{foo}empty-element'),\n            ])\n        self._feed(parser, \"</root>\")\n        root = self._close_and_return_root(parser)\n        self.assertEqual(root.tag, 'root')\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_events_comment(self):\n        parser = self.etree.XMLPullParser(events=('start', 'comment', 'end'))\n        self._feed(parser, \"<!-- text here -->\\n\")\n        self.assert_events(parser, [('comment', (self.etree.Comment, ' text here '))])\n        self._feed(parser, \"<!-- more text here -->\\n\")\n        self.assert_events(parser, [('comment', (self.etree.Comment, ' more text here '))])\n        self._feed(parser, \"<root-tag>text\")\n        self.assert_event_tags(parser, [('start', 'root-tag')])\n        self._feed(parser, \"<!-- inner comment-->\\n\")\n        self.assert_events(parser, [('comment', (self.etree.Comment, ' inner comment'))])\n        self._feed(parser, \"</root-tag>\\n\")\n        self.assert_event_tags(parser, [('end', 'root-tag')])\n        self._feed(parser, \"<!-- outer comment -->\\n\")\n        self.assert_events(parser, [('comment', (self.etree.Comment, ' outer comment '))])\n\n        parser = self.etree.XMLPullParser(events=('comment',))\n        self._feed(parser, \"<!-- text here -->\\n\")\n        self.assert_events(parser, [('comment', (self.etree.Comment, ' text here '))])\n\n    @et_needs_pyversion(3, 8, 0, 'alpha', 4)\n    def test_events_pi(self):\n        # Note: lxml's PIs have target+text, ET's PIs have both in \"text\"\n        parser = self.etree.XMLPullParser(events=('start', 'pi', 'end'))\n        self._feed(parser, \"<?pitarget?>\\n\")\n        self.assert_event_tags(parser, [('pi', self.etree.PI)])\n        parser = self.etree.XMLPullParser(events=('pi',))\n        self._feed(parser, \"<?pitarget some text ?>\\n\")\n        self.assert_event_tags(parser, [('pi', self.etree.PI)])\n\n    def test_events_sequence(self):\n        # Test that events can be some sequence that's not just a tuple or list\n        eventset = {'end', 'start'}\n        parser = self.etree.XMLPullParser(events=eventset)\n        self._feed(parser, \"<foo>bar</foo>\")\n        self.assert_event_tags(parser, [('start', 'foo'), ('end', 'foo')])\n\n        class DummyIter:\n            def __init__(self):\n                self.events = iter(['start', 'end', 'start-ns'])\n            def __iter__(self):\n                return self\n            def __next__(self):\n                return next(self.events)\n            def next(self):\n                return next(self.events)\n\n        parser = self.etree.XMLPullParser(events=DummyIter())\n        self._feed(parser, \"<foo>bar</foo>\")\n        self.assert_event_tags(parser, [('start', 'foo'), ('end', 'foo')])\n\n    def test_unknown_event(self):\n        with self.assertRaises(ValueError):\n            self.etree.XMLPullParser(events=('start', 'end', 'bogus'))\n\n\nclass _C14NTest(unittest.TestCase):\n    etree = None\n    maxDiff = None\n\n    if not hasattr(unittest.TestCase, 'subTest'):\n        @contextmanager\n        def subTest(self, name, **kwargs):\n            try:\n                yield\n            except unittest.SkipTest:\n                raise\n            except Exception as e:\n                print(f\"Subtest {name} failed: {e}\")\n                raise\n\n    def _canonicalize(self, input_file, **options):\n        return self.etree.canonicalize(from_file=input_file, **options)\n\n    #\n    # simple roundtrip tests (from c14n.py)\n\n    def c14n_roundtrip(self, xml, **options):\n        return self.etree.canonicalize(xml, **options)\n\n    def test_simple_roundtrip(self):\n        c14n_roundtrip = self.c14n_roundtrip\n        # Basics\n        self.assertEqual(c14n_roundtrip(\"<doc/>\"), '<doc></doc>')\n        self.assertEqual(c14n_roundtrip(\"<doc xmlns='uri'/>\"), # FIXME\n                '<doc xmlns=\"uri\"></doc>')\n        self.assertEqual(c14n_roundtrip(\"<prefix:doc xmlns:prefix='uri'/>\"),\n            '<prefix:doc xmlns:prefix=\"uri\"></prefix:doc>')\n        self.assertEqual(c14n_roundtrip(\"<doc xmlns:prefix='uri'><prefix:bar/></doc>\"),\n            '<doc><prefix:bar xmlns:prefix=\"uri\"></prefix:bar></doc>')\n        self.assertEqual(c14n_roundtrip(\"<elem xmlns:wsu='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd' xmlns:SOAP-ENV='http://schemas.xmlsoap.org/soap/envelope/' />\"),\n            '<elem></elem>')\n\n        # C14N spec\n        self.assertEqual(c14n_roundtrip(\"<doc>Hello, world!<!-- Comment 1 --></doc>\"),\n            '<doc>Hello, world!</doc>')\n        self.assertEqual(c14n_roundtrip(\"<value>&#x32;</value>\"),\n            '<value>2</value>')\n        self.assertEqual(c14n_roundtrip('<compute><![CDATA[value>\"0\" && value<\"10\" ?\"valid\":\"error\"]]></compute>'),\n            '<compute>value&gt;\"0\" &amp;&amp; value&lt;\"10\" ?\"valid\":\"error\"</compute>')\n        self.assertEqual(c14n_roundtrip('''<compute expr='value>\"0\" &amp;&amp; value&lt;\"10\" ?\"valid\":\"error\"'>valid</compute>'''),\n            '<compute expr=\"value>&quot;0&quot; &amp;&amp; value&lt;&quot;10&quot; ?&quot;valid&quot;:&quot;error&quot;\">valid</compute>')\n        self.assertEqual(c14n_roundtrip(\"<norm attr=' &apos;   &#x20;&#13;&#xa;&#9;   &apos; '/>\"),\n            '<norm attr=\" \\'    &#xD;&#xA;&#x9;   \\' \"></norm>')\n        self.assertEqual(c14n_roundtrip(\"<normNames attr='   A   &#x20;&#13;&#xa;&#9;   B   '/>\"),\n            '<normNames attr=\"   A    &#xD;&#xA;&#x9;   B   \"></normNames>')\n        self.assertEqual(c14n_roundtrip(\"<normId id=' &apos;   &#x20;&#13;&#xa;&#9;   &apos; '/>\"),\n            '<normId id=\" \\'    &#xD;&#xA;&#x9;   \\' \"></normId>')\n\n        # fragments from PJ's tests\n        #self.assertEqual(c14n_roundtrip(\"<doc xmlns:x='http://example.com/x' xmlns='http://example.com/default'><b y:a1='1' xmlns='http://example.com/default' a3='3' xmlns:y='http://example.com/y' y:a2='2'/></doc>\"),\n        #'<doc xmlns:x=\"http://example.com/x\"><b xmlns:y=\"http://example.com/y\" a3=\"3\" y:a1=\"1\" y:a2=\"2\"></b></doc>')\n\n    @et_needs_pyversion(3, 8, 7)\n    @et_exclude_pyversion(3, 9, 0)\n    def test_c14n_namespaces(self):\n        c14n_roundtrip = self.c14n_roundtrip\n        # Namespace issues\n        # https://bugs.launchpad.net/lxml/+bug/1869455\n        xml = '<X xmlns=\"http://nps/a\"><Y targets=\"abc,xyz\"></Y></X>'\n        self.assertEqual(c14n_roundtrip(xml), xml)\n        xml = '<X xmlns=\"http://nps/a\"><Y xmlns=\"http://nsp/b\" targets=\"abc,xyz\"></Y></X>'\n        self.assertEqual(c14n_roundtrip(xml), xml)\n        xml = '<X xmlns=\"http://nps/a\"><Y xmlns:b=\"http://nsp/b\" b:targets=\"abc,xyz\"></Y></X>'\n        self.assertEqual(c14n_roundtrip(xml), xml)\n\n    def test_c14n_exclusion(self):\n        c14n_roundtrip = self.c14n_roundtrip\n        xml = textwrap.dedent(\"\"\"\\\n        <root xmlns:x=\"http://example.com/x\">\n            <a x:attr=\"attrx\">\n                <b>abtext</b>\n            </a>\n            <b>btext</b>\n            <c>\n                <x:d>dtext</x:d>\n            </c>\n        </root>\n        \"\"\")\n        self.assertEqual(\n            c14n_roundtrip(xml, strip_text=True),\n            '<root>'\n            '<a xmlns:x=\"http://example.com/x\" x:attr=\"attrx\"><b>abtext</b></a>'\n            '<b>btext</b>'\n            '<c><x:d xmlns:x=\"http://example.com/x\">dtext</x:d></c>'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, strip_text=True, exclude_attrs=['{http://example.com/x}attr']),\n            '<root>'\n            '<a><b>abtext</b></a>'\n            '<b>btext</b>'\n            '<c><x:d xmlns:x=\"http://example.com/x\">dtext</x:d></c>'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, strip_text=True, exclude_tags=['{http://example.com/x}d']),\n            '<root>'\n            '<a xmlns:x=\"http://example.com/x\" x:attr=\"attrx\"><b>abtext</b></a>'\n            '<b>btext</b>'\n            '<c></c>'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, strip_text=True, exclude_attrs=['{http://example.com/x}attr'],\n                           exclude_tags=['{http://example.com/x}d']),\n            '<root>'\n            '<a><b>abtext</b></a>'\n            '<b>btext</b>'\n            '<c></c>'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, strip_text=True, exclude_tags=['a', 'b']),\n            '<root>'\n            '<c><x:d xmlns:x=\"http://example.com/x\">dtext</x:d></c>'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, exclude_tags=['a', 'b']),\n            '<root>\\n'\n            '    \\n'\n            '    \\n'\n            '    <c>\\n'\n            '        <x:d xmlns:x=\"http://example.com/x\">dtext</x:d>\\n'\n            '    </c>\\n'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, strip_text=True, exclude_tags=['{http://example.com/x}d', 'b']),\n            '<root>'\n            '<a xmlns:x=\"http://example.com/x\" x:attr=\"attrx\"></a>'\n            '<c></c>'\n            '</root>')\n        self.assertEqual(\n            c14n_roundtrip(xml, exclude_tags=['{http://example.com/x}d', 'b']),\n            '<root>\\n'\n            '    <a xmlns:x=\"http://example.com/x\" x:attr=\"attrx\">\\n'\n            '        \\n'\n            '    </a>\\n'\n            '    \\n'\n            '    <c>\\n'\n            '        \\n'\n            '    </c>\\n'\n            '</root>')\n\n    #\n    # basic method=c14n tests from the c14n 2.0 specification.  uses\n    # test files under xmltestdata/c14n-20.\n\n    # note that this uses generated C14N versions of the standard ET.write\n    # output, not roundtripped C14N (see above).\n\n    def test_xml_c14n2(self):\n        datadir = os.path.join(os.path.dirname(__file__), \"c14n-20\")\n        full_path = partial(os.path.join, datadir)\n\n        files = [filename[:-4] for filename in sorted(os.listdir(datadir))\n                 if filename.endswith('.xml')]\n        input_files = [\n            filename for filename in files\n            if filename.startswith('in')\n        ]\n        configs = {\n            filename: {\n                # <c14n2:PrefixRewrite>sequential</c14n2:PrefixRewrite>\n                option.tag.split('}')[-1]: ((option.text or '').strip(), option)\n                for option in self.etree.parse(full_path(filename) + \".xml\").getroot()\n            }\n            for filename in files\n            if filename.startswith('c14n')\n        }\n\n        tests = {\n            input_file: [\n                (filename, configs[filename.rsplit('_', 1)[-1]])\n                for filename in files\n                if filename.startswith('out_%s_' % input_file)\n                and filename.rsplit('_', 1)[-1] in configs\n            ]\n            for input_file in input_files\n        }\n\n        # Make sure we found all test cases.\n        self.assertEqual(30, len([\n            output_file for output_files in tests.values()\n            for output_file in output_files]))\n\n        def get_option(config, option_name, default=None):\n            return config.get(option_name, (default, ()))[0]\n\n        for input_file, output_files in tests.items():\n            for output_file, config in output_files:\n                keep_comments = get_option(\n                    config, 'IgnoreComments') == 'true'  # no, it's right :)\n                strip_text = get_option(\n                    config, 'TrimTextNodes') == 'true'\n                rewrite_prefixes = get_option(\n                    config, 'PrefixRewrite') == 'sequential'\n                if 'QNameAware' in config:\n                    qattrs = [\n                        \"{%s}%s\" % (el.get('NS'), el.get('Name'))\n                        for el in config['QNameAware'][1].findall(\n                            '{http://www.w3.org/2010/xml-c14n2}QualifiedAttr')\n                    ]\n                    qtags = [\n                        \"{%s}%s\" % (el.get('NS'), el.get('Name'))\n                        for el in config['QNameAware'][1].findall(\n                            '{http://www.w3.org/2010/xml-c14n2}Element')\n                    ]\n                else:\n                    qtags = qattrs = None\n\n                # Build subtest description from config.\n                config_descr = ','.join(\n                    \"%s=%s\" % (name, value or ','.join(c.tag.split('}')[-1] for c in children))\n                    for name, (value, children) in sorted(config.items())\n                )\n\n                with self.subTest(f\"{output_file}({config_descr})\"):\n                    if input_file == 'inNsRedecl' and not rewrite_prefixes:\n                        self.skipTest(\n                            \"Redeclared namespace handling is not supported in {}\".format(\n                                output_file))\n                    if input_file == 'inNsSuperfluous' and not rewrite_prefixes:\n                        self.skipTest(\n                            \"Redeclared namespace handling is not supported in {}\".format(\n                                output_file))\n                    if 'QNameAware' in config and config['QNameAware'][1].find(\n                            '{http://www.w3.org/2010/xml-c14n2}XPathElement') is not None:\n                        self.skipTest(\n                            \"QName rewriting in XPath text is not supported in {}\".format(\n                                output_file))\n\n                    f = full_path(input_file + \".xml\")\n                    if input_file == 'inC14N5':\n                        # Hack: avoid setting up external entity resolution in the parser.\n                        with open(full_path('world.txt'), 'rb') as entity_file:\n                            with open(f, 'rb') as f:\n                                f = io.BytesIO(f.read().replace(b'&ent2;', entity_file.read().strip()))\n\n                    text = self._canonicalize(\n                        f,\n                        with_comments=keep_comments,\n                        strip_text=strip_text,\n                        rewrite_prefixes=rewrite_prefixes,\n                        qname_aware_tags=qtags, qname_aware_attrs=qattrs)\n\n                    with open(full_path(output_file + \".xml\"), encoding='utf8') as f:\n                        expected = f.read()\n                    if input_file == 'inC14N3' and self.etree is not etree:\n                        # FIXME: cET resolves default attributes but ET does not!\n                        expected = expected.replace(' attr=\"default\"', '')\n                        text = text.replace(' attr=\"default\"', '')\n                    self.assertEqual(expected, text)\n\n\nif etree:\n    class ETreeTestCase(_ETreeTestCaseBase):\n        etree = etree\n\n    class ETreePullTestCase(_XMLPullParserTest):\n        etree = etree\n\n    class ETreeElementSlicingTest(_ElementSlicingTest):\n        etree = etree\n\n    class ETreeC14NTest(_C14NTest):\n        etree = etree\n\n    class ETreeC14N2WriteTest(ETreeC14NTest):\n        def _canonicalize(self, input_file, with_comments=True, strip_text=False,\n                          rewrite_prefixes=False, qname_aware_tags=None, qname_aware_attrs=None,\n                          **options):\n            if rewrite_prefixes or qname_aware_attrs or qname_aware_tags:\n                self.skipTest(\"C14N 2.0 feature not supported with ElementTree.write()\")\n\n            parser = self.etree.XMLParser(attribute_defaults=True, collect_ids=False)\n            tree = self.etree.parse(input_file, parser)\n            out = io.BytesIO()\n            tree.write(\n                out, method='c14n2',\n                with_comments=with_comments, strip_text=strip_text,\n                **options)\n            return out.getvalue().decode('utf-8')\n\n    class ETreeC14N2TostringTest(ETreeC14NTest):\n        def _canonicalize(self, input_file, with_comments=True, strip_text=False,\n                          rewrite_prefixes=False, qname_aware_tags=None, qname_aware_attrs=None,\n                          **options):\n            if rewrite_prefixes or qname_aware_attrs or qname_aware_tags:\n                self.skipTest(\"C14N 2.0 feature not supported with ElementTree.tostring()\")\n\n            parser = self.etree.XMLParser(attribute_defaults=True, collect_ids=False)\n            tree = self.etree.parse(input_file, parser)\n            return self.etree.tostring(\n                tree, method='c14n2',\n                with_comments=with_comments, strip_text=strip_text,\n                **options).decode('utf-8')\n\n\nif ElementTree:\n    class ElementTreeTestCase(_ETreeTestCaseBase):\n        etree = ElementTree\n\n        @classmethod\n        def setUpClass(cls):\n            if sys.version_info >= (3, 9):\n                return\n            import warnings\n            # ElementTree warns about getiterator() in recent Pythons\n            warnings.filterwarnings(\n                'ignore',\n                r'This method will be removed.*\\.iter\\(\\).*instead',\n                PendingDeprecationWarning)\n\n    filter_by_version(\n        ElementTreeTestCase,\n        ElementTreeTestCase.required_versions_ET, ET_VERSION)\n\n    if hasattr(ElementTree, 'XMLPullParser'):\n        class ElementTreePullTestCase(_XMLPullParserTest):\n            etree = ElementTree\n    else:\n        ElementTreePullTestCase = None\n\n    if hasattr(ElementTree, 'canonicalize'):\n        class ElementTreeC14NTest(_C14NTest):\n            etree = ElementTree\n    else:\n        ElementTreeC14NTest = None\n\n    class ElementTreeElementSlicingTest(_ElementSlicingTest):\n        etree = ElementTree\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    if etree:\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeTestCase)])\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreePullTestCase)])\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeElementSlicingTest)])\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeC14NTest)])\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeC14N2WriteTest)])\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeC14N2TostringTest)])\n    if ElementTree:\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementTreeTestCase)])\n        if ElementTreePullTestCase:\n            suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementTreePullTestCase)])\n        if ElementTreeC14NTest:\n            suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementTreeC14NTest)])\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ElementTreeElementSlicingTest)])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_http_io.py": "\"\"\"\nWeb IO test cases (wsgiref)\n\"\"\"\n\n\nimport unittest\nimport textwrap\nimport sys\nimport gzip\n\nfrom .common_imports import etree, HelperTestCase, BytesIO, _bytes\nfrom .dummy_http_server import webserver, HTTPRequestCollector\n\n\nclass HttpIOTestCase(HelperTestCase):\n    etree = etree\n\n    def _parse_from_http(self, data, code=200, headers=None):\n        parser = self.etree.XMLParser(no_network=False)\n        handler = HTTPRequestCollector(data, code, headers)\n        with webserver(handler) as host_url:\n            tree = self.etree.parse(host_url + 'TEST', parser=parser)\n        self.assertEqual([('/TEST', [])], handler.requests)\n        return tree\n\n    def test_http_client(self):\n        tree = self._parse_from_http(b'<root><a/></root>')\n        self.assertEqual('root', tree.getroot().tag)\n        self.assertEqual('a', tree.getroot()[0].tag)\n\n    def test_http_client_404(self):\n        try:\n            self._parse_from_http(b'<root/>', code=404)\n        except OSError:\n            self.assertTrue(True)\n        else:\n            self.assertTrue(False, \"expected IOError\")\n\n    def test_http_client_gzip(self):\n        f = BytesIO()\n        gz = gzip.GzipFile(fileobj=f, mode='w', filename='test.xml')\n        gz.write(b'<root><a/></root>')\n        gz.close()\n        data = f.getvalue()\n        del f, gz\n\n        headers = [('Content-Encoding', 'gzip')]\n        tree = self._parse_from_http(data, headers=headers)\n        self.assertEqual('root', tree.getroot().tag)\n        self.assertEqual('a', tree.getroot()[0].tag)\n\n    def test_parser_input_mix(self):\n        data = b'<root><a/></root>'\n        handler = HTTPRequestCollector(data)\n        parser = self.etree.XMLParser(no_network=False)\n\n        with webserver(handler) as host_url:\n            tree = self.etree.parse(host_url, parser=parser)\n            root = tree.getroot()\n            self.assertEqual('a', root[0].tag)\n\n            root = self.etree.fromstring(data)\n            self.assertEqual('a', root[0].tag)\n\n            tree = self.etree.parse(host_url, parser=parser)\n            root = tree.getroot()\n            self.assertEqual('a', root[0].tag)\n\n            root = self.etree.fromstring(data)\n            self.assertEqual('a', root[0].tag)\n\n        root = self.etree.fromstring(data)\n        self.assertEqual('a', root[0].tag)\n\n    def test_network_dtd(self):\n        data = [_bytes(textwrap.dedent(s)) for s in [\n            # XML file\n            '''\\\n            <?xml version=\"1.0\"?>\n            <!DOCTYPE root SYSTEM \"./file.dtd\">\n            <root>&myentity;</root>\n            ''',\n            # DTD\n            '<!ENTITY myentity \"DEFINED\">',\n        ]]\n\n        responses = []\n        def handler(environ, start_response):\n            start_response('200 OK', [])\n            return [responses.pop()]\n\n        with webserver(handler) as host_url:\n            # DTD network loading enabled\n            responses = data[::-1]\n            tree = self.etree.parse(\n                host_url + 'dir/test.xml',\n                parser=self.etree.XMLParser(\n                    load_dtd=True, no_network=False))\n            self.assertFalse(responses)  # all read\n            root = tree.getroot()\n            self.assertEqual('DEFINED', root.text)\n\n            # DTD network loading disabled\n            responses = data[::-1]\n            try:\n                self.etree.parse(\n                    host_url + 'dir/test.xml',\n                    parser=self.etree.XMLParser(\n                        load_dtd=True, no_network=True))\n            except self.etree.XMLSyntaxError:\n                self.assertTrue(\"myentity\" in str(sys.exc_info()[1]))\n                self.assertEqual(1, len(responses))  # DTD not read\n            except OSError:\n                self.assertTrue(\"failed to load\" in str(sys.exc_info()[1]))\n                self.assertEqual(2, len(responses))  # nothing read\n            else:\n                self.assertTrue(False)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(HttpIOTestCase)])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/__init__.py": "\"\"\"\nThe lxml test suite for lxml, ElementTree and cElementTree.\n\"\"\"\n\n", "src/lxml/tests/test_htmlparser.py": "\"\"\"\nHTML parser test cases for etree\n\"\"\"\n\n\nimport unittest\nimport tempfile, os, os.path, sys\nfrom io import BytesIO\n\nfrom .common_imports import etree, html, fileInTestDir\nfrom .common_imports import SillyFileLike, HelperTestCase, write_to_file, needs_libxml\n\n\nclass HtmlParserTestCase(HelperTestCase):\n    \"\"\"HTML parser test cases\n    \"\"\"\n    etree = etree\n\n    html_str = b\"<html><head><title>test</title></head><body><h1>page title</h1></body></html>\"\n    html_str_pretty = b\"\"\"\\\n<html>\n<head><title>test</title></head>\n<body><h1>page title</h1></body>\n</html>\n\"\"\"\n    broken_html_str = (\n        b\"<html><head><title>test\"\n        b\"<body><h1>page title</h3></p></html>\")\n    uhtml_str = (\n        \"<html><head><title>test \u00c3\u00a1\uf8d2</title></head>\"\n        \"<body><h1>page \u00c3\u00a1\uf8d2 title</h1></body></html>\"\n    )\n\n    def tearDown(self):\n        super().tearDown()\n        self.etree.set_default_parser()\n\n    def test_module_HTML(self):\n        element = self.etree.HTML(self.html_str)\n        self.assertEqual(self.etree.tostring(element, method=\"html\"),\n                         self.html_str)\n\n    def test_module_HTML_unicode(self):\n        element = self.etree.HTML(self.uhtml_str)\n        self.assertEqual(\n            self.etree.tostring(element, method=\"html\", encoding='unicode'),\n            self.uhtml_str)\n        self.assertEqual(element.findtext('.//h1'),\n                         \"page \u00c3\u00a1\uf8d2 title\")\n\n    @needs_libxml(2, 9, 5)  # not sure, at least 2.9.4 fails\n    def test_wide_unicode_html(self):\n        if sys.maxunicode < 1114111:\n            return  # skip test\n        element = self.etree.HTML('<html><body><p>\\U00026007</p></body></html>')\n        p_text = element.findtext('.//p')\n        self.assertEqual(1, len(p_text))\n        self.assertEqual('\\U00026007',\n                         p_text)\n\n    def test_html_ids(self):\n        parser = self.etree.HTMLParser(recover=False)\n        fromstring = self.etree.fromstring\n        html = fromstring('''\n            <html><body id=\"bodyID\"><p id=\"pID\"></p></body></html>\n        ''', parser=parser)\n        self.assertEqual(len(html.xpath('//p[@id=\"pID\"]')), 1)\n        self.assertEqual(len(html.findall('.//p[@id=\"pID\"]')), 1)\n\n    def test_html_ids_no_collect_ids(self):\n        parser = self.etree.HTMLParser(recover=False, collect_ids=False)\n        fromstring = self.etree.fromstring\n        html = fromstring('''\n            <html><body id=\"bodyID\"><p id=\"pID\"></p></body></html>\n        ''', parser=parser)\n        self.assertEqual(len(html.xpath('//p[@id=\"pID\"]')), 1)\n        self.assertEqual(len(html.findall('.//p[@id=\"pID\"]')), 1)\n\n    def test_module_HTML_pretty_print(self):\n        element = self.etree.HTML(self.html_str)\n        self.assertEqual(self.etree.tostring(element, method=\"html\", pretty_print=True),\n                         self.html_str_pretty)\n\n    def test_module_parse_html_error(self):\n        parser = self.etree.HTMLParser(recover=False)\n        parse = self.etree.parse\n        f = BytesIO(b\"<html></body>\")\n        self.assertRaises(self.etree.XMLSyntaxError,\n                          parse, f, parser)\n\n    def test_html_element_name_empty(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n\n        el = Element('name')\n        self.assertRaises(ValueError, Element, '{}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{}')\n\n        self.assertRaises(ValueError, Element, '{test}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{test}')\n\n    def test_html_element_name_colon(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n\n        pname = Element('p:name')\n        self.assertEqual(pname.tag, 'p:name')\n\n        pname = Element('{test}p:name')\n        self.assertEqual(pname.tag, '{test}p:name')\n\n        pname = Element('name')\n        pname.tag = 'p:name'\n        self.assertEqual(pname.tag, 'p:name')\n\n    def test_html_element_name_quote(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n\n        self.assertRaises(ValueError, Element, 'p\"name')\n        self.assertRaises(ValueError, Element, \"na'me\")\n        self.assertRaises(ValueError, Element, '{test}\"name')\n        self.assertRaises(ValueError, Element, \"{test}name'\")\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', \"pname'\")\n        self.assertRaises(ValueError, setattr, el, 'tag', '\"pname')\n        self.assertEqual(el.tag, \"name\")\n\n    def test_html_element_name_space(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n\n        self.assertRaises(ValueError, Element, ' name ')\n        self.assertRaises(ValueError, Element, 'na me')\n        self.assertRaises(ValueError, Element, '{test} name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', ' name ')\n        self.assertEqual(el.tag, \"name\")\n\n    def test_html_subelement_name_empty(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, '{}')\n        self.assertRaises(ValueError, SubElement, el, '{test}')\n\n    def test_html_subelement_name_colon(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        pname = SubElement(el, 'p:name')\n        self.assertEqual(pname.tag, 'p:name')\n\n        pname = SubElement(el, '{test}p:name')\n        self.assertEqual(pname.tag, '{test}p:name')\n\n    def test_html_subelement_name_quote(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, \"name'\")\n        self.assertRaises(ValueError, SubElement, el, 'na\"me')\n        self.assertRaises(ValueError, SubElement, el, \"{test}na'me\")\n        self.assertRaises(ValueError, SubElement, el, '{test}\"name')\n\n    def test_html_subelement_name_space(self):\n        parser = self.etree.HTMLParser()\n        Element = parser.makeelement\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, ' name ')\n        self.assertRaises(ValueError, SubElement, el, 'na me')\n        self.assertRaises(ValueError, SubElement, el, '{test} name')\n\n    def test_module_parse_html_norecover(self):\n        parser = self.etree.HTMLParser(recover=False)\n        parse = self.etree.parse\n        f = BytesIO(self.broken_html_str)\n        self.assertRaises(self.etree.XMLSyntaxError,\n                          parse, f, parser)\n\n    def test_module_parse_html_default_doctype(self):\n        parser = self.etree.HTMLParser(default_doctype=False)\n        d = html.fromstring('<!DOCTYPE html><h1>S</h1></html>', parser=parser)\n        self.assertEqual(d.getroottree().docinfo.doctype, '<!DOCTYPE html>')\n\n        d = html.fromstring('<html><h1>S</h1></html>', parser=parser)\n        self.assertEqual(d.getroottree().docinfo.doctype, '')\n\n    def test_parse_encoding_8bit_explicit(self):\n        text = 'S\u00f8k p\u00e5 nettet'\n        html_latin1 = ('<p>%s</p>' % text).encode('iso-8859-1')\n\n        tree = self.etree.parse(\n            BytesIO(html_latin1),\n            self.etree.HTMLParser(encoding=\"iso-8859-1\"))\n        p = tree.find(\".//p\")\n        self.assertEqual(p.text, text)\n\n    def test_parse_encoding_8bit_override(self):\n        text = 'S\u00f8k p\u00e5 nettet'\n        wrong_head = '''\n        <head>\n          <meta http-equiv=\"Content-Type\"\n                content=\"text/html; charset=UTF-8\" />\n        </head>'''\n        html_latin1 = ('<html>%s<body><p>%s</p></body></html>' % (wrong_head,\n                                                                        text)\n                      ).encode('iso-8859-1')\n\n        self.assertRaises(self.etree.ParseError,\n                          self.etree.parse,\n                          BytesIO(html_latin1))\n\n        tree = self.etree.parse(\n            BytesIO(html_latin1),\n            self.etree.HTMLParser(encoding=\"iso-8859-1\"))\n        p = tree.find(\".//p\")\n        self.assertEqual(p.text, text)\n\n    def test_module_HTML_broken(self):\n        element = self.etree.HTML(self.broken_html_str)\n        self.assertEqual(self.etree.tostring(element, method=\"html\"),\n                         self.html_str)\n\n    def test_module_HTML_script(self):\n        # by default, libxml2 generates CDATA nodes for <script> content\n        html = b'<html><head><style>foo</style><script>too</script></head></html>'\n        element = self.etree.HTML(html)\n        self.assertEqual(element[0][0].tag, \"style\")\n        self.assertEqual(element[0][0].text, \"foo\")\n\n        self.assertEqual(element[0][1].tag, \"script\")\n        self.assertEqual(element[0][1].text, \"too\")\n\n    def test_module_HTML_cdata_ignored(self):\n        # libxml2 discards CDATA \"content\" since HTML does not know them.\n        import warnings\n        html = b'<html><body><!CDATA[[foo]]></head></html>'\n        element = self.etree.HTML(html)\n        self.assertEqual(element[0].tag, \"body\")\n        self.assertFalse(element[0].text)\n\n        with warnings.catch_warnings(record=True) as warnings_seen:\n            warnings.simplefilter(\"always\")\n            parser = self.etree.HTMLParser(strip_cdata=True)\n        self.assertTrue(warnings_seen)\n\n        element = self.etree.HTML(html, parser)\n        self.assertEqual(element[0].tag, \"body\")\n        self.assertFalse(element[0].text)\n\n        with warnings.catch_warnings(record=True) as warnings_seen:\n            warnings.simplefilter(\"always\")\n            parser = self.etree.HTMLParser(strip_cdata=False)\n        self.assertTrue(warnings_seen)\n\n        element = self.etree.HTML(html, parser)\n        self.assertEqual(element[0].tag, \"body\")\n        self.assertFalse(element[0].text)\n\n    def test_module_HTML_access(self):\n        element = self.etree.HTML(self.html_str)\n        self.assertEqual(element[0][0].tag, 'title')\n\n    def test_module_parse_html(self):\n        parser = self.etree.HTMLParser()\n        filename = tempfile.mktemp(suffix=\".html\")\n        write_to_file(filename, self.html_str, 'wb')\n        try:\n            with open(filename, 'rb') as f:\n                tree = self.etree.parse(f, parser)\n            self.assertEqual(self.etree.tostring(tree.getroot(), method=\"html\"),\n                             self.html_str)\n        finally:\n            os.remove(filename)\n\n    def test_module_parse_html_filelike(self):\n        parser = self.etree.HTMLParser()\n        f = SillyFileLike(self.html_str)\n        tree = self.etree.parse(f, parser)\n        html = self.etree.tostring(tree.getroot(),\n                                   method=\"html\", encoding='UTF-8')\n        self.assertEqual(html, self.html_str)\n\n##     def test_module_parse_html_filelike_unicode(self):\n##         parser = self.etree.HTMLParser()\n##         f = SillyFileLike(self.uhtml_str)\n##         tree = self.etree.parse(f, parser)\n##         html = self.etree.tostring(tree.getroot(), encoding='UTF-8')\n##         self.assertEqual(unicode(html, 'UTF-8'), self.uhtml_str)\n\n    def test_html_file_error(self):\n        parser = self.etree.HTMLParser()\n        parse = self.etree.parse\n        self.assertRaises(IOError,\n                          parse, \"__some_hopefully_nonexisting_file__.html\",\n                          parser)\n\n    def test_default_parser_HTML_broken(self):\n        self.assertRaises(self.etree.XMLSyntaxError,\n                          self.etree.parse, BytesIO(self.broken_html_str))\n\n        self.etree.set_default_parser( self.etree.HTMLParser() )\n\n        tree = self.etree.parse(BytesIO(self.broken_html_str))\n        self.assertEqual(self.etree.tostring(tree.getroot(), method=\"html\"),\n                         self.html_str)\n\n        self.etree.set_default_parser()\n\n        self.assertRaises(self.etree.XMLSyntaxError,\n                          self.etree.parse, BytesIO(self.broken_html_str))\n\n    def test_html_iterparse(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<html><head><title>TITLE</title><body><p>P</p></body></html>')\n\n        iterator = iterparse(f, html=True)\n        self.assertEqual(None, iterator.root)\n\n        events = list(iterator)\n        root = iterator.root\n        self.assertTrue(root is not None)\n        self.assertEqual(\n            [('end', root[0][0]), ('end', root[0]), ('end', root[1][0]),\n             ('end', root[1]), ('end', root)],\n            events)\n\n    def test_html_iterparse_tag(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<html><head><title>TITLE</title><body><p>P</p></body></html>')\n\n        iterator = iterparse(f, html=True, tag=[\"p\", \"title\"])\n        self.assertEqual(None, iterator.root)\n\n        events = list(iterator)\n        root = iterator.root\n        self.assertTrue(root is not None)\n        self.assertEqual(\n            [('end', root[0][0]), ('end', root[1][0])],\n            events)\n\n    def test_html_iterparse_stop_short(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<html><head><title>TITLE</title><body><p>P</p></body></html>')\n\n        iterator = iterparse(f, html=True)\n        self.assertEqual(None, iterator.root)\n\n        event, element = next(iterator)\n        self.assertEqual('end', event)\n        self.assertEqual('title', element.tag)\n        self.assertEqual(None, iterator.root)\n        del element\n\n        event, element = next(iterator)\n        self.assertEqual('end', event)\n        self.assertEqual('head', element.tag)\n        self.assertEqual(None, iterator.root)\n        del element\n        del iterator\n\n    def test_html_iterparse_broken(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<head><title>TEST></head><p>P<br></div>')\n\n        iterator = iterparse(f, html=True)\n        self.assertEqual(None, iterator.root)\n\n        events = list(iterator)\n        root = iterator.root\n        self.assertTrue(root is not None)\n        self.assertEqual('html', root.tag)\n        self.assertEqual('head', root[0].tag)\n        self.assertEqual('body', root[1].tag)\n        self.assertEqual('p', root[1][0].tag)\n        self.assertEqual('br', root[1][0][0].tag)\n        self.assertEqual(\n            [('end', root[0][0]), ('end', root[0]), ('end', root[1][0][0]),\n             ('end', root[1][0]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_html_iterparse_broken_meta(self):\n        # Broken HTML with a misplaced tag before the real html tag.\n        body = '''\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <html>\n            <head></head>\n            <body>\n            </body>\n        </html>\n        '''\n        PARSE_TAGS = {'meta', 'html', 'body'}\n\n        iterator = etree.iterparse(\n            BytesIO(body.encode()), events=('start', 'end'), html=True, recover=True, tag=PARSE_TAGS)\n        parse_events = list(iterator)\n\n    def test_html_iterparse_broken_no_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<p>P<br></div>')\n        iterator = iterparse(f, html=True, recover=False)\n        self.assertRaises(self.etree.XMLSyntaxError, list, iterator)\n\n    def test_html_iterparse_file(self):\n        iterparse = self.etree.iterparse\n        iterator = iterparse(fileInTestDir(\"shakespeare.html\"),\n                             html=True)\n\n        self.assertEqual(None, iterator.root)\n        events = list(iterator)\n        root = iterator.root\n        self.assertTrue(root is not None)\n        self.assertEqual(249, len(events))\n        self.assertFalse(\n            [event for (event, element) in events if event != 'end'])\n\n    def test_html_iterparse_start(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(b'<html><head><title>TITLE</title><body><p>P</p></body></html>')\n\n        iterator = iterparse(f, html=True, events=('start',))\n        self.assertEqual(None, iterator.root)\n\n        events = list(iterator)\n        root = iterator.root\n        self.assertNotEqual(None, root)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('start', root[0][0]),\n                ('start', root[1]), ('start', root[1][0])],\n            events)\n\n    def test_html_feed_parser(self):\n        parser = self.etree.HTMLParser()\n        parser.feed(\"<html><body></\")\n        parser.feed(\"body></html>\")\n        root = parser.close()\n\n        self.assertEqual('html', root.tag)\n        # test that we find all names in the parser dict\n        self.assertEqual([root], list(root.iter('html')))\n        self.assertEqual([root[0]], list(root.iter('body')))\n\n    def test_html_feed_parser_chunky(self):\n        parser = self.etree.HTMLParser()\n        parser.feed(\"<htm\")\n        parser.feed(\"l><body\")\n        parser.feed(\"><\")\n        parser.feed(\"p><\")\n        parser.feed(\"strong\")\n        parser.feed(\">some \")\n        parser.feed(\"text</strong></p><\")\n        parser.feed(\"/body></html>\")\n        root = parser.close()\n\n        self.assertEqual('html', root.tag)\n        # test that we find all names in the parser dict\n        self.assertEqual([root], list(root.iter('html')))\n        self.assertEqual([root[0]], list(root.iter('body')))\n        self.assertEqual([root[0][0]], list(root.iter('p')))\n        self.assertEqual([root[0][0][0]], list(root.iter('strong')))\n\n    def test_html_feed_parser_more_tags(self):\n        parser = self.etree.HTMLParser()\n        parser.feed('<html><head>')\n        parser.feed('<title>TITLE</title><body><p>P</p></body><')\n        parser.feed(\"/html>\")\n        root = parser.close()\n\n        self.assertEqual('html', root.tag)\n        # test that we find all names in the parser dict\n        self.assertEqual([root], list(root.iter('html')))\n        self.assertEqual([root[0]], list(root.iter('head')))\n        self.assertEqual([root[0][0]], list(root.iter('title')))\n        self.assertEqual([root[1]], list(root.iter('body')))\n        self.assertEqual([root[1][0]], list(root.iter('p')))\n\n    def test_html_pull_parser_chunky(self):\n        # See https://bugs.launchpad.net/lxml/+bug/2058828\n        if self.etree.LIBXML_VERSION < (2, 11):\n            return\n        parser = self.etree.HTMLPullParser()\n        parser.feed(b'<html><body><a href=\"2011-03-13_')\n        parser.feed(b'135411/\">2011-03-13_135411/</a></body></html>')\n\n        events = parser.read_events()\n        self.assertEqual(\n            ['a', 'body', 'html'],\n            [el.tag for _, el in events])\n        root = parser.close()\n\n        self.assertEqual('html', root.tag)\n        self.assertEqual('body', root[0].tag)\n        self.assertEqual('a', root[0][0].tag)\n        self.assertEqual('2011-03-13_135411/', root[0][0].get(\"href\"))\n\n    def test_html_parser_target_tag(self):\n        assertFalse  = self.assertFalse\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append((\"start\", tag))\n                assertFalse(attrib)\n            def end(self, tag):\n                events.append((\"end\", tag))\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.HTMLParser(target=Target())\n\n        parser.feed(\"<html><body></body></html>\")\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\n            (\"start\", \"html\"), (\"start\", \"body\"),\n            (\"end\", \"body\"), (\"end\", \"html\")], events)\n\n    def test_html_parser_target_doctype_empty(self):\n        assertFalse  = self.assertFalse\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append((\"start\", tag))\n                assertFalse(attrib)\n            def end(self, tag):\n                events.append((\"end\", tag))\n            def doctype(self, *args):\n                events.append((\"doctype\", args))\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.HTMLParser(target=Target())\n        parser.feed(\"<!DOCTYPE><html><body></body></html>\")\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\n            (\"doctype\", (None, None, None)),\n            (\"start\", \"html\"), (\"start\", \"body\"),\n            (\"end\", \"body\"), (\"end\", \"html\")], events)\n\n    def test_html_parser_target_doctype_html(self):\n        assertFalse  = self.assertFalse\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append((\"start\", tag))\n                assertFalse(attrib)\n            def end(self, tag):\n                events.append((\"end\", tag))\n            def doctype(self, *args):\n                events.append((\"doctype\", args))\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.HTMLParser(target=Target())\n        parser.feed(\"<!DOCTYPE html><html><body></body></html>\")\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\n            (\"doctype\", (\"html\", None, None)),\n            (\"start\", \"html\"), (\"start\", \"body\"),\n            (\"end\", \"body\"), (\"end\", \"html\")], events)\n\n    def test_html_parser_target_doctype_html_full(self):\n        assertFalse  = self.assertFalse\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append((\"start\", tag))\n                assertFalse(attrib)\n            def end(self, tag):\n                events.append((\"end\", tag))\n            def doctype(self, *args):\n                events.append((\"doctype\", args))\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.HTMLParser(target=Target())\n        parser.feed('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"sys.dtd\">'\n                    '<html><body></body></html>')\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\n            (\"doctype\", (\"html\", \"-//W3C//DTD HTML 4.01//EN\", \"sys.dtd\")),\n            (\"start\", \"html\"), (\"start\", \"body\"),\n            (\"end\", \"body\"), (\"end\", \"html\")], events)\n\n    def test_html_parser_target_exceptions(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append((\"start\", tag))\n                raise ValueError(\"START\")\n            def end(self, tag):\n                events.append((\"end\", tag))\n                raise TypeError(\"END\")\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.HTMLParser(target=Target())\n        try:\n            parser.feed('<html><body>')\n            parser.feed('</body></html>')\n        except ValueError as exc:\n            assert \"START\" in str(exc)\n        except TypeError as exc:\n            assert \"END\" in str(exc)\n            self.assertTrue(False, \"wrong exception raised\")\n        else:\n            self.assertTrue(False, \"no exception raised\")\n\n        self.assertTrue((\"start\", \"html\") in events, events)\n        self.assertTrue((\"end\", \"html\") not in events, events)\n\n    def test_html_fromstring_target_exceptions(self):\n        events = []\n        class Target:\n            def start(self, tag, attrib):\n                events.append((\"start\", tag))\n                raise ValueError(\"START\")\n            def end(self, tag):\n                events.append((\"end\", tag))\n                raise TypeError(\"END\")\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.HTMLParser(target=Target())\n        try:\n            self.etree.fromstring('<html><body></body></html>', parser)\n        except ValueError as exc:\n            assert \"START\" in str(exc), str(exc)\n        except TypeError as exc:\n            assert \"END\" in str(exc), str(exc)\n            self.assertTrue(False, \"wrong exception raised\")\n        else:\n            self.assertTrue(False, \"no exception raised\")\n\n        self.assertTrue((\"start\", \"html\") in events, events)\n        self.assertTrue((\"end\", \"html\") not in events, events)\n\n    def test_set_decl_html(self):\n        doc = html.Element('html').getroottree()\n        doc.docinfo.public_id = \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n        doc.docinfo.system_url = \\\n            \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">')\n        self.assertEqual(self.etree.tostring(doc),\n                         b'''<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\"></html>''')\n\n    def test_html5_doctype(self):\n        # document type declaration with neither public if nor system url\n        doc = html.Element('html').getroottree()\n        doc.docinfo.public_id = None\n        doc.docinfo.system_url = None\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE html>')\n        self.assertTrue(doc.docinfo.public_id is None)\n        self.assertEqual(self.etree.tostring(doc),\n                         b'<!DOCTYPE html>\\n<html/>')\n\n    def test_ietf_decl(self):\n        # legacy declaration with public id, no system url\n        doc = html.Element('html').getroottree()\n        doc.docinfo.public_id = '-//IETF//DTD HTML//EN'\n        doc.docinfo.system_url = None\n        self.assertEqual(doc.docinfo.doctype,\n                         '<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//EN\">')\n        self.assertEqual(self.etree.tostring(doc),\n                         b'<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//EN\">\\n<html/>')\n\n    def test_boolean_attribute(self):\n        # ability to serialize boolean attribute by setting value to None\n        form = html.Element('form')\n        form.set('novalidate', None)\n        self.assertEqual(html.tostring(form),\n                         b'<form novalidate></form>')\n        form.set('custom')\n        self.assertEqual(html.tostring(form),\n                         b'<form novalidate custom></form>')\n\n    def test_boolean_attribute_round_trip(self):\n        # ability to pass boolean attributes unmodified\n        fragment = '<tag attribute></tag>'\n        self.assertEqual(html.tostring(html.fragment_fromstring(fragment)),\n                         fragment.encode('utf-8'))\n\n    def test_boolean_attribute_xml_adds_empty_string(self):\n        # html serialized as xml converts boolean attributes to empty strings\n        fragment = '<tag attribute></tag>'\n        self.assertEqual(self.etree.tostring(html.fragment_fromstring(fragment)),\n                         b'<tag attribute=\"\"/>')\n\n    def test_xhtml_as_html_as_xml(self):\n        # parse XHTML as HTML, serialise as XML\n        # See https://bugs.launchpad.net/lxml/+bug/1965070\n        xhtml = (\n            b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n            b'<html xmlns=\"http://www.w3.org/1999/xhtml\"></html>'\n        )\n        root = html.fromstring(xhtml)\n        result = etree.tostring(root)\n        self.assertEqual(result, b'<html xmlns=\"http://www.w3.org/1999/xhtml\"/>')\n\n        # Adding an XHTML doctype makes libxml2 add the namespace, which wasn't parsed as such by the HTML parser.\n        \"\"\"\n        xhtml = (\n            b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n            b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">'\n            b'<html xmlns=\"http://www.w3.org/1999/xhtml\"></html>'\n        )\n        root = html.fromstring(xhtml)\n        result = etree.tostring(root)\n        self.assertEqual(result, b'<html xmlns=\"http://www.w3.org/1999/xhtml\"/>')\n        \"\"\"\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(HtmlParserTestCase)])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/dummy_http_server.py": "\"\"\"\nSimple HTTP request dumper for tests.\n\"\"\"\n\nimport sys\nfrom contextlib import contextmanager\n\ntry:\n    import urlparse\nexcept ImportError:\n    # Python 3\n    import urllib.parse as urlparse\n\n\n@contextmanager\ndef webserver(app, port=0, host=None):\n    \"\"\"Context manager entry point for the 'with' statement.\n\n    Pass 0 as port number to dynamically allocate a free port.\n\n    Usage:\n\n    with webserver(wsgi_app_function, 8080) as host_url:\n        do_ws_calls(host_url)\n    \"\"\"\n    server = build_web_server(app, port, host or '127.0.0.1')\n    host, port = server.socket.getsockname()\n\n    import threading\n    thread = threading.Thread(target=server.serve_forever,\n                              kwargs={'poll_interval': 0.5})\n    thread.setDaemon(True)\n    thread.start()\n    try:\n        yield 'http://%s:%s/' % (host, port)  # yield control to 'with' body\n    finally:\n        server.shutdown()\n        server.server_close()\n    thread.join(timeout=1)\n\n\ntry:\n    from SocketServer import ThreadingMixIn\nexcept ImportError:\n    # Python 3\n    from socketserver import ThreadingMixIn\n\nimport wsgiref.simple_server as wsgiserver\nclass WebServer(wsgiserver.WSGIServer, ThreadingMixIn):\n    \"\"\"A web server that starts a new thread for each request.\n    \"\"\"\n\n\nclass _RequestHandler(wsgiserver.WSGIRequestHandler):\n    def get_stderr(self):\n        # don't write to stderr\n        return sys.stdout\n\n    def log_message(self, format, *args):\n        # message = \"wsmock(%s) %s\" % (self.address_string(), format % args)\n        pass  # don't log messages\n\n\ndef build_web_server(app, port, host=None):\n    server = wsgiserver.make_server(\n        host or '', port, app,\n        server_class=WebServer,\n        handler_class=_RequestHandler)\n    return server\n\n\nclass HTTPRequestCollector:\n    def __init__(self, response_data, response_code=200, headers=()):\n        self.requests = []\n        self.response_code = response_code\n        self.response_data = response_data\n        self.headers = list(headers or ())\n\n    def __call__(self, environ, start_response):\n        self.requests.append((\n            environ.get('PATH_INFO'),\n            urlparse.parse_qsl(environ.get('QUERY_STRING'))))\n        start_response('%s OK' % self.response_code, self.headers)\n        return [self.response_data]\n", "src/lxml/tests/test_xpathevaluator.py": "\"\"\"\nTest cases related to XPath evaluation and the XPath class\n\"\"\"\n\n\nimport unittest, sys\n\nfrom .common_imports import etree, HelperTestCase, _bytes, BytesIO, doctest, make_doctest\n\n\nclass ETreeXPathTestCase(HelperTestCase):\n    \"\"\"XPath tests etree\"\"\"\n\n    def test_xpath_boolean(self):\n        tree = self.parse('<a><b></b><b></b></a>')\n        self.assertTrue(tree.xpath('boolean(/a/b)'))\n        self.assertTrue(not tree.xpath('boolean(/a/c)'))\n\n    def test_xpath_number(self):\n        tree = self.parse('<a>1</a>')\n        self.assertEqual(1.,\n                          tree.xpath('number(/a)'))\n        tree = self.parse('<a>A</a>')\n        actual = str(tree.xpath('number(/a)'))\n        expected = ['nan', '1.#qnan', 'nanq']\n        if not actual.lower() in expected:\n            self.fail('Expected a NAN value, got %s' % actual)\n        \n    def test_xpath_string(self):\n        tree = self.parse('<a>Foo</a>')\n        self.assertEqual('Foo',\n                          tree.xpath('string(/a/text())'))\n\n    def test_xpath_document_root(self):\n        tree = self.parse('<a><b/></a>')\n        self.assertEqual([],\n                          tree.xpath('/'))\n\n    def test_xpath_namespace(self):\n        tree = self.parse('<a xmlns=\"test\" xmlns:p=\"myURI\"/>')\n        self.assertTrue((None, \"test\") in tree.xpath('namespace::*'))\n        self.assertTrue(('p', 'myURI') in tree.xpath('namespace::*'))\n\n    def test_xpath_namespace_empty(self):\n        tree = self.parse('<a/>')\n        self.assertEqual([('xml', 'http://www.w3.org/XML/1998/namespace')],\n                          tree.xpath('namespace::*'))\n\n    def test_xpath_list_elements(self):\n        tree = self.parse('<a><b>Foo</b><b>Bar</b></a>')\n        root = tree.getroot()\n        self.assertEqual([root[0], root[1]],\n                          tree.xpath('/a/b'))\n\n    def test_xpath_list_nothing(self):\n        tree = self.parse('<a><b/></a>')\n        self.assertEqual([],\n                          tree.xpath('/a/c'))\n        # this seems to pass a different code path, also should return nothing\n        self.assertEqual([],\n                          tree.xpath('/a/c/text()'))\n    \n    def test_xpath_list_text(self):\n        tree = self.parse('<a><b>Foo</b><b>Bar</b></a>')\n        root = tree.getroot()\n        self.assertEqual(['Foo', 'Bar'],\n                          tree.xpath('/a/b/text()'))\n\n    def test_xpath_list_text_parent(self):\n        tree = self.parse('<a><b>FooBar</b><b>BarFoo</b></a>')\n        root = tree.getroot()\n        self.assertEqual(['FooBar', 'BarFoo'],\n                          tree.xpath('/a/b/text()'))\n        self.assertEqual([root[0], root[1]],\n                          [r.getparent() for r in tree.xpath('/a/b/text()')])\n\n    def test_xpath_list_text_parent_no_smart_strings(self):\n        tree = self.parse('<a><b>FooBar</b><b>BarFoo</b></a>')\n        root = tree.getroot()\n        self.assertEqual(['FooBar', 'BarFoo'],\n                          tree.xpath('/a/b/text()', smart_strings=True))\n        self.assertEqual([root[0], root[1]],\n                          [r.getparent() for r in\n                           tree.xpath('/a/b/text()', smart_strings=True)])\n        self.assertEqual([None, None],\n                          [r.attrname for r in\n                           tree.xpath('/a/b/text()', smart_strings=True)])\n\n        self.assertEqual(['FooBar', 'BarFoo'],\n                          tree.xpath('/a/b/text()', smart_strings=False))\n        self.assertEqual([False, False],\n                          [hasattr(r, 'getparent') for r in\n                           tree.xpath('/a/b/text()', smart_strings=False)])\n        self.assertEqual([None, None],\n                          [r.attrname for r in\n                           tree.xpath('/a/b/text()', smart_strings=True)])\n\n    def test_xpath_list_unicode_text_parent(self):\n        xml = b'<a><b>FooBar\\\\u0680\\\\u3120</b><b>BarFoo\\\\u0680\\\\u3120</b></a>'.decode(\"unicode_escape\")\n        tree = self.parse(xml.encode('utf-8'))\n        root = tree.getroot()\n        self.assertEqual([b'FooBar\\\\u0680\\\\u3120'.decode(\"unicode_escape\"),\n                           b'BarFoo\\\\u0680\\\\u3120'.decode(\"unicode_escape\")],\n                          tree.xpath('/a/b/text()'))\n        self.assertEqual([root[0], root[1]],\n                          [r.getparent() for r in tree.xpath('/a/b/text()')])\n\n    def test_xpath_list_attribute(self):\n        tree = self.parse('<a b=\"B\" c=\"C\"/>')\n        self.assertEqual(['B'],\n                          tree.xpath('/a/@b'))\n\n    def test_xpath_list_attribute_parent(self):\n        tree = self.parse('<a b=\"BaSdFgHjKl\" c=\"CqWeRtZuI\"/>')\n        results = tree.xpath('/a/@c')\n        self.assertEqual(1, len(results))\n        self.assertEqual('CqWeRtZuI', results[0])\n        self.assertEqual(tree.getroot().tag, results[0].getparent().tag)\n\n    def test_xpath_list_attribute_parent_no_smart_strings(self):\n        tree = self.parse('<a b=\"BaSdFgHjKl\" c=\"CqWeRtZuI\"/>')\n\n        results = tree.xpath('/a/@c', smart_strings=True)\n        self.assertEqual(1, len(results))\n        self.assertEqual('CqWeRtZuI', results[0])\n        self.assertEqual('c', results[0].attrname)\n        self.assertEqual(tree.getroot().tag, results[0].getparent().tag)\n\n        results = tree.xpath('/a/@c', smart_strings=False)\n        self.assertEqual(1, len(results))\n        self.assertEqual('CqWeRtZuI', results[0])\n        self.assertEqual(False, hasattr(results[0], 'getparent'))\n        self.assertEqual(False, hasattr(results[0], 'attrname'))\n\n    def test_xpath_text_from_other_document(self):\n        xml_data = '''\n        <table>\n                <item xml:id=\"k1\"><value>v1</value></item>\n                <item xml:id=\"k2\"><value>v2</value></item>\n        </table>\n        '''\n\n        def lookup(dummy, id):\n            return etree.XML(xml_data).xpath('id(%r)' % id)\n        functions = {(None, 'lookup') : lookup}\n\n        root = etree.XML('<dummy/>')\n        values = root.xpath(\"lookup('k1')/value/text()\",\n                           extensions=functions)\n        self.assertEqual(['v1'], values)\n        self.assertEqual('value', values[0].getparent().tag)\n\n    def test_xpath_list_comment(self):\n        tree = self.parse('<a><!-- Foo --></a>')\n        self.assertEqual(['<!-- Foo -->'],\n                          list(map(repr, tree.xpath('/a/node()'))))\n\n    def test_rel_xpath_boolean(self):\n        root = etree.XML('<a><b><c/></b></a>')\n        el = root[0]\n        self.assertTrue(el.xpath('boolean(c)'))\n        self.assertTrue(not el.xpath('boolean(d)'))\n\n    def test_rel_xpath_list_elements(self):\n        tree = self.parse('<a><c><b>Foo</b><b>Bar</b></c><c><b>Hey</b></c></a>')\n        root = tree.getroot()\n        c = root[0]\n        self.assertEqual([c[0], c[1]],\n                          c.xpath('b'))\n        self.assertEqual([c[0], c[1], root[1][0]],\n                          c.xpath('//b'))\n\n    def test_xpath_ns(self):\n        tree = self.parse('<a xmlns=\"uri:a\"><b></b></a>')\n        root = tree.getroot()\n        self.assertEqual(\n            [root[0]],\n            tree.xpath('//foo:b', namespaces={'foo': 'uri:a'}))\n        self.assertEqual(\n            [],\n            tree.xpath('//foo:b', namespaces={'foo': 'uri:c'}))\n        self.assertEqual(\n            [root[0]],\n            root.xpath('//baz:b', namespaces={'baz': 'uri:a'}))\n\n    def test_xpath_ns_none(self):\n        tree = self.parse('<a xmlns=\"uri:a\"><b></b></a>')\n        root = tree.getroot()\n        self.assertRaises(\n            TypeError,\n            root.xpath, '//b', namespaces={None: 'uri:a'})\n\n    def test_xpath_ns_empty(self):\n        tree = self.parse('<a xmlns=\"uri:a\"><b></b></a>')\n        root = tree.getroot()\n        self.assertRaises(\n            TypeError,\n            root.xpath, '//b', namespaces={'': 'uri:a'})\n\n    def test_xpath_error(self):\n        tree = self.parse('<a/>')\n        self.assertRaises(etree.XPathEvalError, tree.xpath, '\\\\fad')\n\n    def test_xpath_class_error(self):\n        self.assertRaises(SyntaxError, etree.XPath, '\\\\fad')\n        self.assertRaises(etree.XPathSyntaxError, etree.XPath, '\\\\fad')\n\n    def test_xpath_prefix_error(self):\n        tree = self.parse('<a/>')\n        self.assertRaises(etree.XPathEvalError, tree.xpath, '/fa:d')\n\n    def test_xpath_class_prefix_error(self):\n        tree = self.parse('<a/>')\n        xpath = etree.XPath(\"/fa:d\")\n        self.assertRaises(etree.XPathEvalError, xpath, tree)\n\n    def test_elementtree_getpath(self):\n        a  = etree.Element(\"a\")\n        b  = etree.SubElement(a, \"b\")\n        c  = etree.SubElement(a, \"c\")\n        d1 = etree.SubElement(c, \"d\")\n        d2 = etree.SubElement(c, \"d\")\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('/a/c/d',\n                         tree.getpath(d2)[:6])\n        self.assertEqual([d2],\n                         tree.xpath(tree.getpath(d2)))\n\n    def test_elementtree_getpath_partial(self):\n        a  = etree.Element(\"a\")\n        b  = etree.SubElement(a, \"b\")\n        c  = etree.SubElement(a, \"c\")\n        d1 = etree.SubElement(c, \"d\")\n        d2 = etree.SubElement(c, \"d\")\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('/c/d',\n                         tree.getpath(d2)[:4])\n        self.assertEqual([d2],\n                         tree.xpath(tree.getpath(d2)))\n\n    def test_xpath_evaluator(self):\n        tree = self.parse('<a><b><c></c></b></a>')\n        e = etree.XPathEvaluator(tree)\n        root = tree.getroot()\n        self.assertEqual(\n            [root],\n            e('//a'))\n\n    def test_xpath_evaluator_tree(self):\n        tree = self.parse('<a><b><c></c></b></a>')\n        child_tree = etree.ElementTree(tree.getroot()[0])\n        e = etree.XPathEvaluator(child_tree)\n        self.assertEqual(\n            [],\n            e('a'))\n        root = child_tree.getroot()\n        self.assertEqual(\n            [root[0]],\n            e('c'))\n\n    def test_xpath_evaluator_tree_absolute(self):\n        tree = self.parse('<a><b><c></c></b></a>')\n        child_tree = etree.ElementTree(tree.getroot()[0])\n        e = etree.XPathEvaluator(child_tree)\n        self.assertEqual(\n            [],\n            e('/a'))\n        root = child_tree.getroot()\n        self.assertEqual(\n            [root],\n            e('/b'))\n        self.assertEqual(\n            [],\n            e('/c'))\n\n    def test_xpath_evaluator_element(self):\n        tree = self.parse('<a><b><c></c></b></a>')\n        root = tree.getroot()\n        e = etree.XPathEvaluator(root[0])\n        self.assertEqual(\n            [root[0][0]],\n            e('c'))\n        \n    def test_xpath_extensions(self):\n        def foo(evaluator, a):\n            return 'hello %s' % a\n        extension = {(None, 'foo'): foo}\n        tree = self.parse('<a><b></b></a>')\n        e = etree.XPathEvaluator(tree, extensions=[extension])\n        self.assertEqual(\n            \"hello you\", e(\"foo('you')\"))\n\n    def test_xpath_extensions_wrong_args(self):\n        def foo(evaluator, a, b):\n            return \"hello %s and %s\" % (a, b)\n        extension = {(None, 'foo'): foo}\n        tree = self.parse('<a><b></b></a>')\n        e = etree.XPathEvaluator(tree, extensions=[extension])\n        self.assertRaises(TypeError, e, \"foo('you')\")\n\n    def test_xpath_extensions_error(self):\n        def foo(evaluator, a):\n            return 1/0\n        extension = {(None, 'foo'): foo}\n        tree = self.parse('<a/>')\n        e = etree.XPathEvaluator(tree, extensions=[extension])\n        self.assertRaises(ZeroDivisionError, e, \"foo('test')\")\n\n    def test_xpath_extensions_nodes(self):\n        def f(evaluator, arg):\n            r = etree.Element('results')\n            b = etree.SubElement(r, 'result')\n            b.text = 'Hoi'\n            b = etree.SubElement(r, 'result')\n            b.text = 'Dag'\n            return r\n\n        x = self.parse('<a/>')\n        e = etree.XPathEvaluator(x, extensions=[{(None, 'foo'): f}])\n        r = e(\"foo('World')/result\")\n        self.assertEqual(2, len(r))\n        self.assertEqual('Hoi', r[0].text)\n        self.assertEqual('Dag', r[1].text)\n\n    def test_xpath_extensions_nodes_append(self):\n        def f(evaluator, nodes):\n            r = etree.SubElement(nodes[0], 'results')\n            b = etree.SubElement(r, 'result')\n            b.text = 'Hoi'\n            b = etree.SubElement(r, 'result')\n            b.text = 'Dag'\n            return r\n\n        x = self.parse('<a/>')\n        e = etree.XPathEvaluator(x, extensions=[{(None, 'foo'): f}])\n        r = e(\"foo(/*)/result\")\n        self.assertEqual(2, len(r))\n        self.assertEqual('Hoi', r[0].text)\n        self.assertEqual('Dag', r[1].text)\n\n    def test_xpath_extensions_nodes_append2(self):\n        def f(evaluator, nodes):\n            r = etree.Element('results')\n            b = etree.SubElement(r, 'result')\n            b.text = 'Hoi'\n            b = etree.SubElement(r, 'result')\n            b.text = 'Dag'\n            r.append(nodes[0])\n            return r\n\n        x = self.parse('<result>Honk</result>')\n        e = etree.XPathEvaluator(x, extensions=[{(None, 'foo'): f}])\n        r = e(\"foo(/*)/result\")\n        self.assertEqual(3, len(r))\n        self.assertEqual('Hoi',  r[0].text)\n        self.assertEqual('Dag',  r[1].text)\n        self.assertEqual('Honk', r[2].text)\n\n    def test_xpath_context_node(self):\n        tree = self.parse('<root><a/><b><c/></b></root>')\n\n        check_call = []\n        def check_context(ctxt, nodes):\n            self.assertEqual(len(nodes), 1)\n            check_call.append(nodes[0].tag)\n            self.assertEqual(ctxt.context_node, nodes[0])\n            return True\n\n        find = etree.XPath(\"//*[p:foo(.)]\",\n                           namespaces={'p' : 'ns'},\n                           extensions=[{('ns', 'foo') : check_context}])\n        find(tree)\n\n        check_call.sort()\n        self.assertEqual(check_call, [\"a\", \"b\", \"c\", \"root\"])\n\n    def test_xpath_eval_context_propagation(self):\n        tree = self.parse('<root><a/><b><c/></b></root>')\n\n        check_call = {}\n        def check_context(ctxt, nodes):\n            self.assertEqual(len(nodes), 1)\n            tag = nodes[0].tag\n            # empty during the \"b\" call, a \"b\" during the \"c\" call\n            check_call[tag] = ctxt.eval_context.get(\"b\")\n            ctxt.eval_context[tag] = tag\n            return True\n\n        find = etree.XPath(\"//b[p:foo(.)]/c[p:foo(.)]\",\n                           namespaces={'p' : 'ns'},\n                           extensions=[{('ns', 'foo') : check_context}])\n        result = find(tree)\n\n        self.assertEqual(result, [tree.getroot()[1][0]])\n        self.assertEqual(check_call, {'b':None, 'c':'b'})\n\n    def test_xpath_eval_context_clear(self):\n        tree = self.parse('<root><a/><b><c/></b></root>')\n\n        check_call = {}\n        def check_context(ctxt):\n            check_call[\"done\"] = True\n            # context must be empty for each new evaluation\n            self.assertEqual(len(ctxt.eval_context), 0)\n            ctxt.eval_context[\"test\"] = True\n            return True\n\n        find = etree.XPath(\"//b[p:foo()]\",\n                           namespaces={'p' : 'ns'},\n                           extensions=[{('ns', 'foo') : check_context}])\n        result = find(tree)\n\n        self.assertEqual(result, [tree.getroot()[1]])\n        self.assertEqual(check_call[\"done\"], True)\n\n        check_call.clear()\n        find = etree.XPath(\"//b[p:foo()]\",\n                           namespaces={'p' : 'ns'},\n                           extensions=[{('ns', 'foo') : check_context}])\n        result = find(tree)\n\n        self.assertEqual(result, [tree.getroot()[1]])\n        self.assertEqual(check_call[\"done\"], True)\n\n    def test_xpath_variables(self):\n        x = self.parse('<a attr=\"true\"/>')\n        e = etree.XPathEvaluator(x)\n\n        expr = \"/a[@attr=$aval]\"\n        r = e(expr, aval=1)\n        self.assertEqual(0, len(r))\n\n        r = e(expr, aval=\"true\")\n        self.assertEqual(1, len(r))\n        self.assertEqual(\"true\", r[0].get('attr'))\n\n        r = e(expr, aval=True)\n        self.assertEqual(1, len(r))\n        self.assertEqual(\"true\", r[0].get('attr'))\n\n    def test_xpath_variables_nodeset(self):\n        x = self.parse('<a attr=\"true\"/>')\n        e = etree.XPathEvaluator(x)\n\n        element = etree.Element(\"test-el\")\n        etree.SubElement(element, \"test-sub\")\n        expr = \"$value\"\n        r = e(expr, value=element)\n        self.assertEqual(1, len(r))\n        self.assertEqual(element.tag, r[0].tag)\n        self.assertEqual(element[0].tag, r[0][0].tag)\n\n    def test_xpath_extensions_mix(self):\n        x = self.parse('<a attr=\"true\"><test/></a>')\n\n        class LocalException(Exception):\n            pass\n\n        def foo(evaluator, a, varval):\n            etree.Element(\"DUMMY\")\n            if varval == 0:\n                raise LocalException\n            elif varval == 1:\n                return ()\n            elif varval == 2:\n                return None\n            elif varval == 3:\n                return a[0][0]\n            a = a[0]\n            if a.get(\"attr\") == str(varval):\n                return a\n            else:\n                return etree.Element(\"NODE\")\n\n        extension = {(None, 'foo'): foo}\n        e = etree.XPathEvaluator(x, extensions=[extension])\n        del x\n\n        self.assertRaises(LocalException, e, \"foo(., 0)\")\n        self.assertRaises(LocalException, e, \"foo(., $value)\", value=0)\n\n        r = e(\"foo(., $value)\", value=1)\n        self.assertEqual(len(r), 0)\n\n        r = e(\"foo(.,  1)\")\n        self.assertEqual(len(r), 0)\n\n        r = e(\"foo(., $value)\", value=2)\n        self.assertEqual(len(r), 0)\n\n        r = e(\"foo(., $value)\", value=3)\n        self.assertEqual(len(r), 1)\n        self.assertEqual(r[0].tag, \"test\")\n\n        r = e(\"foo(., $value)\", value=\"false\")\n        self.assertEqual(len(r), 1)\n        self.assertEqual(r[0].tag, \"NODE\")\n\n        r = e(\"foo(., 'false')\")\n        self.assertEqual(len(r), 1)\n        self.assertEqual(r[0].tag, \"NODE\")\n\n        r = e(\"foo(., 'true')\")\n        self.assertEqual(len(r), 1)\n        self.assertEqual(r[0].tag, \"a\")\n        self.assertEqual(r[0][0].tag, \"test\")\n\n        r = e(\"foo(., $value)\", value=\"true\")\n        self.assertEqual(len(r), 1)\n        self.assertEqual(r[0].tag, \"a\")\n\n        self.assertRaises(LocalException, e, \"foo(., 0)\")\n        self.assertRaises(LocalException, e, \"foo(., $value)\", value=0)\n\n\nclass ETreeXPathClassTestCase(HelperTestCase):\n    \"Tests for the XPath class\"\n    def test_xpath_compile_doc(self):\n        x = self.parse('<a attr=\"true\"/>')\n\n        expr = etree.XPath(\"/a[@attr != 'true']\")\n        r = expr(x)\n        self.assertEqual(0, len(r))\n\n        expr = etree.XPath(\"/a[@attr = 'true']\")\n        r = expr(x)\n        self.assertEqual(1, len(r))\n\n        expr = etree.XPath( expr.path )\n        r = expr(x)\n        self.assertEqual(1, len(r))\n\n    def test_xpath_compile_element(self):\n        x = self.parse('<a><b/><c/></a>')\n        root = x.getroot()\n\n        expr = etree.XPath(\"./b\")\n        r = expr(root)\n        self.assertEqual(1, len(r))\n        self.assertEqual('b', r[0].tag)\n\n        expr = etree.XPath(\"./*\")\n        r = expr(root)\n        self.assertEqual(2, len(r))\n\n    def test_xpath_compile_vars(self):\n        x = self.parse('<a attr=\"true\"/>')\n\n        expr = etree.XPath(\"/a[@attr=$aval]\")\n        r = expr(x, aval=False)\n        self.assertEqual(0, len(r))\n\n        r = expr(x, aval=True)\n        self.assertEqual(1, len(r))\n\n    def test_xpath_compile_error(self):\n        self.assertRaises(SyntaxError, etree.XPath, '\\\\fad')\n\n    def test_xpath_elementtree_error(self):\n        self.assertRaises(ValueError, etree.XPath('*'), etree.ElementTree())\n\n\nclass ETreeXPathExsltTestCase(HelperTestCase):\n    \"Tests for the EXSLT support in XPath (requires libxslt 1.1.25+)\"\n\n    NSMAP = dict(\n        date = \"http://exslt.org/dates-and-times\",\n        math = \"http://exslt.org/math\",\n        set  = \"http://exslt.org/sets\",\n        str  = \"http://exslt.org/strings\",\n        )\n\n    def test_xpath_exslt_functions_date(self):\n        tree = self.parse('<a><b>2009-11-12</b><b>2008-12-11</b></a>')\n\n        match_dates = tree.xpath('//b[date:year(string()) = 2009]',\n                                 namespaces=self.NSMAP)\n        self.assertTrue(match_dates, str(match_dates))\n        self.assertEqual(len(match_dates), 1, str(match_dates))\n        self.assertEqual(match_dates[0].text, '2009-11-12')\n\n    def test_xpath_exslt_functions_strings(self):\n        tree = self.parse('<a><b>2009-11-12</b><b>2008-12-11</b></a>')\n\n        aligned_date = tree.xpath(\n            'str:align(string(//b[1]), \"%s\", \"center\")' % ('-'*20),\n            namespaces=self.NSMAP)\n        self.assertTrue(aligned_date, str(aligned_date))\n        self.assertEqual(aligned_date, '-----2009-11-12-----')\n\n\nclass ETreeETXPathClassTestCase(HelperTestCase):\n    \"Tests for the ETXPath class\"\n    def test_xpath_compile_ns(self):\n        x = self.parse('<a><b xmlns=\"nsa\"/><b xmlns=\"nsb\"/></a>')\n\n        expr = etree.ETXPath(\"/a/{nsa}b\")\n        r = expr(x)\n        self.assertEqual(1, len(r))\n        self.assertEqual('{nsa}b', r[0].tag)\n\n        expr = etree.ETXPath(\"/a/{nsb}b\")\n        r = expr(x)\n        self.assertEqual(1, len(r))\n        self.assertEqual('{nsb}b', r[0].tag)\n\n    # disabled this test as non-ASCII characters in namespace URIs are\n    # not acceptable\n    def _test_xpath_compile_unicode(self):\n        x = self.parse('<a><b xmlns=\"http://nsa/\\uf8d2\"/><b xmlns=\"http://nsb/\\uf8d1\"/></a>')\n\n        expr = etree.ETXPath(\"/a/{http://nsa/\\uf8d2}b\")\n        r = expr(x)\n        self.assertEqual(1, len(r))\n        self.assertEqual('{http://nsa/\\uf8d2}b', r[0].tag)\n\n        expr = etree.ETXPath(\"/a/{http://nsb/\\\\uf8d1}b\")\n        r = expr(x)\n        self.assertEqual(1, len(r))\n        self.assertEqual('{http://nsb/\\uf8d1}b', r[0].tag)\n\nSAMPLE_XML = etree.parse(BytesIO(b\"\"\"\n<body>\n  <tag>text</tag>\n  <section>\n    <tag>subtext</tag>\n  </section>\n  <tag />\n  <tag />\n</body>\n\"\"\"))\n\ndef tag(elem):\n    return elem.tag\n\ndef tag_or_value(elem):\n    return getattr(elem, 'tag', elem)\n\ndef stringTest(ctxt, s1):\n    return \"Hello \"+s1\n\ndef stringListTest(ctxt, s1):\n    return [\"Hello \"] + list(s1) +  [\"!\"]\n    \ndef floatTest(ctxt, f1):\n    return f1+4\n\ndef booleanTest(ctxt, b1):\n    return not b1\n    \ndef setTest(ctxt, st1):\n    return st1[0]\n    \ndef setTest2(ctxt, st1):\n    return st1[0:2]\n\ndef argsTest1(ctxt, s, f, b, st):\n    return \", \".join(map(str, (s, f, b, list(map(tag, st)))))\n\ndef argsTest2(ctxt, st1, st2):\n    st1.extend(st2)\n    return st1\n\ndef resultTypesTest(ctxt):\n    return [None,None]\n\ndef resultTypesTest2(ctxt):\n    return resultTypesTest\n    \nuri = \"http://www.example.com/\"\n\nextension = {(None, 'stringTest'): stringTest,\n             (None, 'stringListTest'): stringListTest,\n             (None, 'floatTest'): floatTest,\n             (None, 'booleanTest'): booleanTest,\n             (None, 'setTest'): setTest,\n             (None, 'setTest2'): setTest2,\n             (None, 'argsTest1'): argsTest1,\n             (None, 'argsTest2'): argsTest2,\n             (None, 'resultTypesTest'): resultTypesTest,\n             (None, 'resultTypesTest2'): resultTypesTest2,}\n\ndef xpath():\n    \"\"\"\n    Test xpath extension functions.\n    \n    >>> root = SAMPLE_XML\n    >>> e = etree.XPathEvaluator(root, extensions=[extension])\n    >>> e(\"stringTest('you')\")\n    'Hello you'\n    >>> print(e(b\"stringTest('\\\\\\\\xe9lan')\".decode(\"unicode_escape\")))\n    Hello \\xe9lan\n    >>> e(\"stringTest('you','there')\")   #doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    TypeError: stringTest() takes... 2 ...arguments ...\n    >>> e(\"floatTest(2)\")\n    6.0\n    >>> e(\"booleanTest(true())\")\n    False\n    >>> list(map(tag, e(\"setTest(/body/tag)\")))\n    ['tag']\n    >>> list(map(tag, e(\"setTest2(/body/*)\")))\n    ['tag', 'section']\n    >>> list(map(tag_or_value, e(\"stringListTest(/body/tag)\")))\n    ['Hello ', 'tag', 'tag', 'tag', '!']\n    >>> e(\"argsTest1('a',1.5,true(),/body/tag)\")\n    \"a, 1.5, True, ['tag', 'tag', 'tag']\"\n    >>> list(map(tag, e(\"argsTest2(/body/tag, /body/section)\")))\n    ['tag', 'section', 'tag', 'tag']\n    >>> try: e(\"resultTypesTest()\")\n    ... except etree.XPathResultError as exc: print(exc)\n    ... else: print(\"SHOULD HAVE FAILED!\")\n    This is not a supported node-set result: None\n    >>> try:\n    ...     e(\"resultTypesTest2()\")\n    ... except etree.XPathResultError:\n    ...     print(\"Got error\")\n    Got error\n    \"\"\"\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXPathTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXPathClassTestCase)])\n    if etree.LIBXSLT_COMPILED_VERSION >= (1,1,25):\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXPathExsltTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeETXPathClassTestCase)])\n    suite.addTests([doctest.DocTestSuite()])\n    suite.addTests(\n        [make_doctest('xpathxslt.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_sax.py": "\"\"\"\nTest cases related to SAX I/O\n\"\"\"\n\n\nimport unittest\nfrom xml.dom import pulldom\nfrom xml.sax.handler import ContentHandler\n\nfrom .common_imports import HelperTestCase, make_doctest, BytesIO, _bytes\nfrom lxml import sax\n\n\nclass ETreeSaxTestCase(HelperTestCase):\n\n    def test_etree_sax_simple(self):\n        tree = self.parse('<a>ab<b/>ba</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<a>ab<b/>ba</a>',\n                          xml_out)\n\n    def test_etree_sax_double(self):\n        tree = self.parse('<a>ab<b>bb</b>ba</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<a>ab<b>bb</b>ba</a>',\n                          xml_out)\n\n    def test_etree_sax_comment(self):\n        tree = self.parse('<a>ab<!-- TEST -->ba</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<a>abba</a>',\n                          xml_out)\n\n    def test_etree_sax_pi(self):\n        tree = self.parse('<a>ab<?this and that?>ba</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<a>ab<?this and that?>ba</a>',\n                          xml_out)\n\n    def test_etree_sax_comment_root(self):\n        tree = self.parse('<!-- TEST --><a>ab</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<a>ab</a>',\n                          xml_out)\n\n    def test_etree_sax_pi_root(self):\n        tree = self.parse('<?this and that?><a>ab</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<?this and that?><a>ab</a>',\n                          xml_out)\n\n    def test_etree_sax_attributes(self):\n        tree = self.parse('<a aa=\"5\">ab<b b=\"5\"/>ba</a>')\n        xml_out = self._saxify_serialize(tree)\n        self.assertEqual(b'<a aa=\"5\">ab<b b=\"5\"/>ba</a>',\n                          xml_out)\n\n    def test_etree_sax_ns1(self):\n        tree = self.parse('<a xmlns=\"bla\">ab<b>bb</b>ba</a>')\n        new_tree = self._saxify_unsaxify(tree)\n        root = new_tree.getroot()\n        self.assertEqual('{bla}a',\n                         root.tag)\n        self.assertEqual('{bla}b',\n                         root[0].tag)\n\n    def test_etree_sax_ns2(self):\n        tree = self.parse('<a xmlns=\"blaA\">ab<b:b xmlns:b=\"blaB\">bb</b:b>ba</a>')\n        new_tree = self._saxify_unsaxify(tree)\n        root = new_tree.getroot()\n        self.assertEqual('{blaA}a',\n                         root.tag)\n        self.assertEqual('{blaB}b',\n                         root[0].tag)\n\n    def test_sax_to_pulldom(self):\n        tree = self.parse('<a xmlns=\"blaA\">ab<b:b xmlns:b=\"blaB\">bb</b:b>ba</a>')\n        handler = pulldom.SAX2DOM()\n        sax.saxify(tree, handler)\n        dom = handler.document\n\n        self.assertEqual('a',\n                         dom.firstChild.localName)\n        self.assertEqual('blaA',\n                         dom.firstChild.namespaceURI)\n        self.assertEqual(None,\n                         dom.firstChild.prefix)\n\n        children = dom.firstChild.childNodes\n        self.assertEqual('ab',\n                         children[0].nodeValue)\n        self.assertEqual('blaB',\n                         children[1].namespaceURI)\n        self.assertEqual('ba',\n                         children[2].nodeValue)\n\n    def test_sax_to_pulldom_multiple_namespaces(self):\n        tree = self.parse('<a xmlns=\"blaA\" xmlns:a=\"blaA\"></a>')\n        handler = pulldom.SAX2DOM()\n        sax.saxify(tree, handler)\n        dom = handler.document\n\n        # With multiple prefix definitions, the node should keep the one\n        # that was actually used, even if the others also are valid.\n        self.assertEqual('a',\n                         dom.firstChild.localName)\n        self.assertEqual('blaA',\n                         dom.firstChild.namespaceURI)\n        self.assertEqual(None,\n                         dom.firstChild.prefix)\n\n        tree = self.parse('<a:a xmlns=\"blaA\" xmlns:a=\"blaA\"></a:a>')\n        handler = pulldom.SAX2DOM()\n        sax.saxify(tree, handler)\n        dom = handler.document\n\n        self.assertEqual('a',\n                         dom.firstChild.localName)\n        self.assertEqual('blaA',\n                         dom.firstChild.namespaceURI)\n        self.assertEqual('a',\n                         dom.firstChild.prefix)\n\n    def test_element_sax(self):\n        tree = self.parse('<a><b/></a>')\n        a = tree.getroot()\n        b = a[0]\n\n        xml_out = self._saxify_serialize(a)\n        self.assertEqual(b'<a><b/></a>',\n                          xml_out)\n\n        xml_out = self._saxify_serialize(b)\n        self.assertEqual(b'<b/>',\n                          xml_out)\n\n    def test_element_sax_ns(self):\n        tree = self.parse('<a:a xmlns:a=\"blaA\"><b/></a:a>')\n        a = tree.getroot()\n        b = a[0]\n\n        new_tree = self._saxify_unsaxify(a)\n        root = new_tree.getroot()\n        self.assertEqual('{blaA}a',\n                         root.tag)\n        self.assertEqual('b',\n                         root[0].tag)\n\n        new_tree = self._saxify_unsaxify(b)\n        root = new_tree.getroot()\n        self.assertEqual('b',\n                         root.tag)\n        self.assertEqual(0,\n                         len(root))\n\n    def test_etree_sax_handler_default_ns(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startPrefixMapping(None, 'blaA')\n        handler.startElementNS(('blaA', 'a'), 'a', {})\n        handler.startPrefixMapping(None, 'blaB')\n        handler.startElementNS(('blaB', 'b'), 'b', {})\n        handler.endElementNS(  ('blaB', 'b'), 'b')\n        handler.endPrefixMapping(None)\n        handler.startElementNS(('blaA', 'c'), 'c', {})\n        handler.endElementNS(  ('blaA', 'c'), 'c')\n        handler.endElementNS(  ('blaA', 'a'), 'a')\n        handler.endPrefixMapping(None)\n        handler.endDocument()\n\n        new_tree = handler.etree\n        root = new_tree.getroot()\n        self.assertEqual('{blaA}a',\n                         root.tag)\n        self.assertEqual('{blaB}b',\n                         root[0].tag)\n        self.assertEqual('{blaA}c',\n                         root[1].tag)\n\n    def test_etree_sax_handler_default_ns_None(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startPrefixMapping(None, 'blaA')\n        handler.startElementNS((None, 'a'), 'a', {})\n        handler.startPrefixMapping(None, 'blaB')\n        handler.startElementNS((None, 'b'), 'b', {})\n        handler.endElementNS(  (None, 'b'), 'b')\n        handler.endPrefixMapping(None)\n        handler.startElementNS((None, 'c'), 'c', {})\n        handler.endElementNS(  (None, 'c'), 'c')\n        handler.endElementNS(  (None, 'a'), 'a')\n        handler.endPrefixMapping(None)\n        handler.endDocument()\n\n        new_tree = handler.etree\n        root = new_tree.getroot()\n        self.assertEqual('{blaA}a',\n                         root.tag)\n        self.assertEqual('{blaB}b',\n                         root[0].tag)\n        self.assertEqual('{blaA}c',\n                         root[1].tag)\n\n    def test_etree_sax_redefine_ns(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startPrefixMapping('ns', 'blaA')\n        handler.startElementNS(('blaA', 'a'), 'ns:a', {})\n        handler.startPrefixMapping('ns', 'blaB')\n        handler.startElementNS(('blaB', 'b'), 'ns:b', {})\n        handler.endElementNS(  ('blaB', 'b'), 'ns:b')\n        handler.endPrefixMapping('ns')\n        handler.startElementNS(('blaA', 'c'), 'ns:c', {})\n        handler.endElementNS(  ('blaA', 'c'), 'ns:c')\n        handler.endElementNS(  ('blaA', 'a'), 'ns:a')\n        handler.endPrefixMapping('ns')\n        handler.endDocument()\n\n        new_tree = handler.etree\n        root = new_tree.getroot()\n        self.assertEqual('{blaA}a',\n                         root.tag)\n        self.assertEqual('{blaB}b',\n                         root[0].tag)\n        self.assertEqual('{blaA}c',\n                         root[1].tag)\n\n    def test_etree_sax_no_ns(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startElement('a', {})\n        handler.startElement('b', {})\n        handler.endElement('b')\n        handler.startElement('c') # with empty attributes\n        handler.endElement('c')\n        handler.endElement('a')\n        handler.endDocument()\n\n        new_tree = handler.etree\n        root = new_tree.getroot()\n        self.assertEqual('a', root.tag)\n        self.assertEqual('b', root[0].tag)\n        self.assertEqual('c', root[1].tag)\n\n    def test_etree_sax_no_ns_attributes(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startElement('a', {\"attr_a1\": \"a1\"})\n        handler.startElement('b', {\"attr_b1\": \"b1\"})\n        handler.endElement('b')\n        handler.endElement('a')\n        handler.endDocument()\n\n        new_tree = handler.etree\n        root = new_tree.getroot()\n        self.assertEqual('a', root.tag)\n        self.assertEqual('b', root[0].tag)\n        self.assertEqual('a1', root.attrib[\"attr_a1\"])\n        self.assertEqual('b1', root[0].attrib[\"attr_b1\"])\n\n    def test_etree_sax_ns_attributes(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n\n        self.assertRaises(ValueError,\n            handler.startElement,\n            'a', {\"blaA:attr_a1\": \"a1\"}\n        )\n\n    def test_etree_sax_error(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startElement('a')\n        self.assertRaises(sax.SaxError, handler.endElement, 'b')\n\n    def test_etree_sax_error2(self):\n        handler = sax.ElementTreeContentHandler()\n        handler.startDocument()\n        handler.startElement('a')\n        handler.startElement('b')\n        self.assertRaises(sax.SaxError, handler.endElement, 'a')\n\n    def _saxify_unsaxify(self, saxifiable):\n        handler = sax.ElementTreeContentHandler()\n        sax.ElementTreeProducer(saxifiable, handler).saxify()\n        return handler.etree\n\n    def _saxify_serialize(self, tree):\n        new_tree = self._saxify_unsaxify(tree)\n        f = BytesIO()\n        new_tree.write(f)\n        return f.getvalue().replace(b'\\n', b'')\n\n\nclass SimpleContentHandler(ContentHandler):\n    \"\"\"A SAX content handler that just stores the events\"\"\"\n\n    def __init__(self):\n        self.sax_events = []\n        super().__init__()\n\n    def startDocument(self):\n        self.sax_events.append(('startDocument',))\n\n    def endDocument(self):\n        self.sax_events.append(('endDocument',))\n\n    def startPrefixMapping(self, prefix, uri):\n        self.sax_events.append(('startPrefixMapping', prefix, uri))\n\n    def endPrefixMapping(self, prefix):\n        self.sax_events.append(('endPrefixMapping', prefix))\n\n    def startElement(self, name, attrs):\n        self.sax_events.append(('startElement', name, dict(attrs)))\n\n    def endElement(self, name):\n        self.sax_events.append(('endElement', name))\n\n    def startElementNS(self, name, qname, attrs):\n        self.sax_events.append(('startElementNS', name, qname, attrs._qnames))\n\n    def endElementNS(self, name, qname):\n        self.sax_events.append(('endElementNS', name, qname))\n\n    def characters(self, content):\n        self.sax_events.append(('characters', content))\n\n    def ignorableWhitespace(self, whitespace):\n        self.sax_events.append(('ignorableWhitespace', whitespace))\n\n    def processingInstruction(self, target, data):\n        self.sax_events.append(('processingInstruction', target, data))\n\n    def skippedEntity(self, name):\n        self.sax_events.append(('skippedEntity', name))\n\n\nclass NSPrefixSaxTestCase(HelperTestCase):\n    \"\"\"Testing that namespaces generate the right SAX events\"\"\"\n\n    def _saxify(self, tree):\n        handler = SimpleContentHandler()\n        sax.ElementTreeProducer(tree, handler).saxify()\n        return handler.sax_events\n\n    def test_element_sax_ns_prefix(self):\n        # The name of the prefix should be preserved, if the uri is unique\n        tree = self.parse('<a:a xmlns:a=\"blaA\" xmlns:c=\"blaC\">'\n                          '<d a:attr=\"value\" c:attr=\"value\" /></a:a>')\n        a = tree.getroot()\n\n        self.assertEqual(\n            [('startElementNS', ('blaA', 'a'), 'a:a', {}),\n             ('startElementNS', (None, 'd'), 'd',\n              {('blaA', 'attr'): 'a:attr', ('blaC', 'attr'): 'c:attr'}),\n             ('endElementNS', (None, 'd'), 'd'),\n             ('endElementNS', ('blaA', 'a'), 'a:a'),\n            ],\n            self._saxify(a)[3:7])\n\n    def test_element_sax_default_ns_prefix(self):\n        # Default prefixes should also not get a generated prefix\n        tree = self.parse('<a xmlns=\"blaA\"><b attr=\"value\" /></a>')\n        a = tree.getroot()\n\n        self.assertEqual(\n            [('startDocument',),\n             # NS prefix should be None:\n             ('startPrefixMapping', None, 'blaA'),\n             ('startElementNS', ('blaA', 'a'), 'a', {}),\n             # Attribute prefix should be None:\n             ('startElementNS', ('blaA', 'b'), 'b', {(None, 'attr'): 'attr'}),\n             ('endElementNS', ('blaA', 'b'), 'b'),\n             ('endElementNS', ('blaA', 'a'), 'a'),\n             # Prefix should be None again:\n             ('endPrefixMapping', None),\n             ('endDocument',)],\n            self._saxify(a))\n\n        # Except for attributes, if there is both a default namespace\n        # and a named namespace with the same uri\n        tree = self.parse('<a xmlns=\"bla\" xmlns:a=\"bla\">'\n                          '<b a:attr=\"value\" /></a>')\n        a = tree.getroot()\n\n        self.assertEqual(\n            ('startElementNS', ('bla', 'b'), 'b', {('bla', 'attr'): 'a:attr'}),\n            self._saxify(a)[4])\n\n    def test_element_sax_twin_ns_prefix(self):\n        # Make an element with an doubly registered uri\n        tree = self.parse('<a xmlns:b=\"bla\" xmlns:c=\"bla\">'\n                          '<d c:attr=\"attr\" /></a>')\n        a = tree.getroot()\n\n        self.assertEqual(\n            # It should get the b prefix in this case\n            ('startElementNS', (None, 'd'), 'd', {('bla', 'attr'): 'b:attr'}),\n            self._saxify(a)[4])\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeSaxTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(NSPrefixSaxTestCase)])\n    suite.addTests(\n        [make_doctest('sax.txt')])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_unicode.py": "import unittest\nimport sys\nfrom io import StringIO\n\nfrom .common_imports import etree, HelperTestCase, needs_libxml\n\nascii_uni = 'a'\n\nklingon = \"\\uF8D2\"  # not valid for XML names\n\ninvalid_tag = \"test\" + klingon\n\nuni = '\\xc3\\u0680\\u3120'  # some non-ASCII characters\n\nuxml = \"<test><title>test \\xc3\\xa1\\u3120</title><h1>page \\xc3\\xa1\\u3120 title</h1></test>\"\n\n\nclass UnicodeTestCase(HelperTestCase):\n    def test__str(self):\n        # test the testing framework, namely _str from common_imports\n        self.assertEqual('\\x10', '\\u0010')\n        self.assertEqual('\\x10', '\\U00000010')\n        self.assertEqual('\\u1234', '\\U00001234')\n\n    def test_unicode_xml(self):\n        tree = etree.XML('<p>%s</p>' % uni)\n        self.assertEqual(uni, tree.text)\n\n    @needs_libxml(2, 9, 5)  # not sure, at least 2.9.4 fails\n    def test_wide_unicode_xml(self):\n        if sys.maxunicode < 1114111:\n            return  # skip test\n        tree = etree.XML('<p>\\U00026007</p>')\n        self.assertEqual(1, len(tree.text))\n        self.assertEqual('\\U00026007',\n                         tree.text)\n\n    def test_emoji_xml(self):\n        p = etree.XML('<p>\ud83d\ude04</p>')\n        self.assertEqual('\ud83d\ude04', p.text)\n        self.assertEqual(1, len(p.text))\n\n    def test_emoji_html(self):\n        html = etree.HTML('<html><body><p>\ud83d\ude04</p></body></html>')\n        p = html[0][0]\n        self.assertEqual('p', p.tag)\n        self.assertEqual('\ud83d\ude04', p.text)\n        self.assertEqual(1, len(p.text))\n\n    def test_unicode_xml_broken(self):\n        uxml = ('<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n                '<p>%s</p>' % uni)\n        self.assertRaises(ValueError, etree.XML, uxml)\n\n    def test_unicode_tag(self):\n        el = etree.Element(uni)\n        self.assertEqual(uni, el.tag)\n\n    def test_unicode_tag_invalid(self):\n        # sadly, Klingon is not well-formed\n        self.assertRaises(ValueError, etree.Element, invalid_tag)\n\n    def test_unicode_nstag(self):\n        tag = \"{http://abc/}%s\" % uni\n        el = etree.Element(tag)\n        self.assertEqual(tag, el.tag)\n\n    def test_unicode_ns_invalid(self):\n        # namespace URIs must conform to RFC 3986\n        tag = \"{http://%s/}abc\" % uni\n        self.assertRaises(ValueError, etree.Element, tag)\n\n    def test_unicode_nstag_invalid(self):\n        # sadly, Klingon is not well-formed\n        tag = \"{http://abc/}%s\" % invalid_tag\n        self.assertRaises(ValueError, etree.Element, tag)\n\n    def test_unicode_qname(self):\n        qname = etree.QName(uni, uni)\n        tag = \"{%s}%s\" % (uni, uni)\n        self.assertEqual(qname.text, tag)\n        self.assertEqual(str(qname), tag)\n\n    def test_unicode_qname_invalid(self):\n        self.assertRaises(ValueError, etree.QName, invalid_tag)\n\n    def test_unicode_attr(self):\n        el = etree.Element('foo', {'bar': uni})\n        self.assertEqual(uni, el.attrib['bar'])\n\n    def test_unicode_comment(self):\n        el = etree.Comment(uni)\n        self.assertEqual(uni, el.text)\n\n    def test_unicode_repr1(self):\n        x = etree.Element('\u00e5')\n        # must not raise UnicodeEncodeError\n        repr(x)\n\n    def test_unicode_repr2(self):\n        x = etree.Comment('\u00f6')\n        repr(x)\n\n    def test_unicode_repr3(self):\n        x = etree.ProcessingInstruction('\u00c5', '\\u0131')\n        repr(x)\n\n    def test_unicode_repr4(self):\n        x = etree.Entity('\u00e4')\n        repr(x)\n\n    def test_unicode_text(self):\n        e = etree.Element('e')\n\n        def settext(text):\n            e.text = text\n\n        self.assertRaises(ValueError, settext, 'ab\\ufffe')\n        self.assertRaises(ValueError, settext, '\u00f6\\ffff')\n        self.assertRaises(ValueError, settext, '\\u0123\\ud800')\n        self.assertRaises(ValueError, settext, 'x\\ud8ff')\n        self.assertRaises(ValueError, settext, '\\U00010000\\udfff')\n        self.assertRaises(ValueError, settext, 'abd\\x00def')\n        # should not Raise\n        settext('\\ud7ff\\ue000\\U00010000\\U0010FFFF\u00e4\u00f6as')\n\n        for char_val in range(0xD800, 0xDFFF+1):\n            self.assertRaises(ValueError, settext, 'abc' + chr(char_val))\n            self.assertRaises(ValueError, settext, chr(char_val))\n            self.assertRaises(ValueError, settext, chr(char_val) + 'abc')\n\n        self.assertRaises(ValueError, settext, b'\\xe4')\n        self.assertRaises(ValueError, settext, b'\\x80')\n        self.assertRaises(ValueError, settext, b'\\xff')\n        self.assertRaises(ValueError, settext, b'\\x08')\n        self.assertRaises(ValueError, settext, b'\\x19')\n        self.assertRaises(ValueError, settext, b'\\x20\\x00')\n        # should not Raise\n        settext(b'\\x09\\x0A\\x0D\\x20\\x60\\x7f')\n\n    def test_uniname(self):\n        Element = etree.Element\n        def el(name):\n            return Element(name)\n\n        self.assertRaises(ValueError, el, ':')\n        self.assertRaises(ValueError, el, '0a')\n        self.assertRaises(ValueError, el, '\\u203f')\n        # should not Raise\n        el('\\u0132')\n\n    def test_unicode_parse_stringio(self):\n        el = etree.parse(StringIO('<p>%s</p>' % uni)).getroot()\n        self.assertEqual(uni, el.text)\n\n##     def test_parse_fileobject_unicode(self):\n##         # parse unicode from unnamed file object (not supported by ElementTree)\n##         f = SillyFileLike(uxml)\n##         root = etree.parse(f).getroot()\n##         self.assertEqual(etree.tostring(root, 'UTF-8').decode('utf-8'),\n##                           uxml)\n\n\nclass EncodingsTestCase(HelperTestCase):\n    def test_illegal_utf8(self):\n        data = b'<test>\\x80\\x80\\x80</test>'\n        self.assertRaises(etree.XMLSyntaxError, etree.fromstring, data)\n\n    def test_illegal_utf8_recover(self):\n        data = b'<test>\\x80\\x80\\x80</test>'\n        parser = etree.XMLParser(recover=True)\n        if etree.LIBXML_VERSION >= (2, 12, 0):\n            tree = etree.fromstring(data, parser)\n            self.assertEqual('\\ufffd\\ufffd\\ufffd', tree.text)\n        else:\n            self.assertRaises(etree.XMLSyntaxError, etree.fromstring, data, parser)\n\n    def _test_encoding(self, encoding, xml_encoding_name=None):\n        self._test_encoded_input(\"<tag attrib='123'></tag>\", 'tag', encoding, xml_encoding_name)\n        self._test_encoded_input(\"<\u00e4l\u00e4m\u00e4nt \u00f6ttrib='\u0410\u0442\u0440\u0438\u0431\u0443\u0442'></\u00e4l\u00e4m\u00e4nt>\", '\u00e4l\u00e4m\u00e4nt', encoding, xml_encoding_name)\n\n    def _test_encoded_input(self, xml_input, tag_name, encoding, xml_encoding_name=None):\n        foo = \"\"\"<?xml version='1.0' encoding='%s'?>\\n\"\"\" % (\n            xml_encoding_name or encoding) + xml_input\n        root = etree.fromstring(foo.encode(encoding))\n        self.assertEqual(tag_name, root.tag)\n\n        doc_encoding = root.getroottree().docinfo.encoding\n        self.assertTrue(\n            doc_encoding.lower().rstrip('lbe'),\n            (xml_encoding_name or encoding).lower().rstrip('lbe'))\n\n        if 'sig' not in encoding:\n            xml = etree.tostring(root, encoding=encoding)\n            etree.fromstring(xml)  # encoding\n\n    def test_utf8_fromstring(self):\n        self._test_encoding('utf-8')\n\n    def test_utf8sig_fromstring(self):\n        self._test_encoding('utf_8_sig', 'utf-8')\n\n    def test_utf16_fromstring(self):\n        self._test_encoding('utf-16')\n\n    def test_utf16LE_fromstring(self):\n        self._test_encoding('utf-16le', 'utf-16')\n\n    def test_utf16BE_fromstring(self):\n        self._test_encoding('utf-16be', 'utf-16')\n\n    def test_utf32_fromstring(self):\n        self._test_encoding('utf-32', 'utf-32')\n\n    def test_utf32LE_fromstring(self):\n        self._test_encoding('utf-32le', 'utf-32')\n\n    def test_utf32BE_fromstring(self):\n        self._test_encoding('utf-32be', 'utf-32')\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(UnicodeTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(EncodingsTestCase)])\n    return suite\n", "src/lxml/tests/test_xmlschema.py": "\"\"\"\nTest cases related to XML Schema parsing and validation\n\"\"\"\n\n\nimport unittest\n\nfrom .common_imports import etree, BytesIO, HelperTestCase, fileInTestDir, make_doctest, SimpleFSPath\n\n\nclass ETreeXMLSchemaTestCase(HelperTestCase):\n    def test_xmlschema(self):\n        tree_valid = self.parse('<a><b></b></a>')\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.validate(tree_invalid))\n        self.assertTrue(schema.validate(tree_valid))     # retry valid\n        self.assertFalse(schema.validate(tree_invalid))  # retry invalid\n\n    def test_xmlschema_error_log(self):\n        tree_valid = self.parse('<a><b></b></a>')\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.error_log.filter_from_errors())\n\n        self.assertFalse(schema.validate(tree_invalid))\n        self.assertTrue(schema.error_log.filter_from_errors())\n        self.assertTrue(schema.error_log.filter_types(\n            etree.ErrorTypes.SCHEMAV_ELEMENT_CONTENT))\n\n        self.assertTrue(schema.validate(tree_valid))\n        self.assertFalse(schema.error_log.filter_from_errors())\n\n        self.assertFalse(schema.validate(tree_invalid))\n        self.assertTrue(schema.error_log.filter_from_errors())\n        self.assertTrue(schema.error_log.filter_types(\n            etree.ErrorTypes.SCHEMAV_ELEMENT_CONTENT))\n\n    def test_xmlschema_error_log_path(self):\n        \"\"\"We don't have a guarantee that there will always be a path\n        for a _LogEntry object (or even a node for which to determine\n        a path), but at least when this test was created schema validation\n        errors always got a node and an XPath value. If that ever changes,\n        we can modify this test to something like::\n\n            self.assertTrue(error_path is None or tree_path == error_path)\n\n        That way, we can at least verify that if we did get a path value\n        it wasn't bogus.\n        \"\"\"\n        tree = self.parse('<a><b>42</b><b>dada</b></a>')\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:integer\" maxOccurs=\"2\"/>\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        schema.validate(tree)\n        tree_path = tree.getpath(tree.findall('b')[1])\n        error_path = schema.error_log[0].path\n        self.assertTrue(tree_path == error_path)\n\n    def test_xmlschema_default_attributes(self):\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence minOccurs=\"4\" maxOccurs=\"4\">\n      <xsd:element name=\"b\" type=\"BType\" />\n    </xsd:sequence>\n  </xsd:complexType>\n  <xsd:complexType name=\"BType\">\n    <xsd:attribute name=\"hardy\" type=\"xsd:string\" default=\"hey\" />\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema, attribute_defaults=True)\n\n        tree = self.parse('<a><b hardy=\"ho\"/><b/><b hardy=\"ho\"/><b/></a>')\n\n        root = tree.getroot()\n        self.assertEqual('ho', root[0].get('hardy'))\n        self.assertEqual(None, root[1].get('hardy'))\n        self.assertEqual('ho', root[2].get('hardy'))\n        self.assertEqual(None, root[3].get('hardy'))\n\n        self.assertTrue(schema(tree))\n\n        root = tree.getroot()\n        self.assertEqual('ho', root[0].get('hardy'))\n        self.assertEqual('hey', root[1].get('hardy'))\n        self.assertEqual('ho', root[2].get('hardy'))\n        self.assertEqual('hey', root[3].get('hardy'))\n\n    def test_xmlschema_parse(self):\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        parser = etree.XMLParser(schema=schema)\n\n        tree_valid = self.parse('<a><b></b></a>', parser=parser)\n        self.assertEqual('a', tree_valid.getroot().tag)\n\n        self.assertRaises(etree.XMLSyntaxError,\n                          self.parse, '<a><c></c></a>', parser=parser)\n\n    def test_xmlschema_parse_default_attributes(self):\n        # does not work as of libxml2 2.7.3\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence minOccurs=\"4\" maxOccurs=\"4\">\n      <xsd:element name=\"b\" type=\"BType\" />\n    </xsd:sequence>\n  </xsd:complexType>\n  <xsd:complexType name=\"BType\">\n    <xsd:attribute name=\"hardy\" type=\"xsd:string\" default=\"hey\" />\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        parser = etree.XMLParser(schema=schema, attribute_defaults=True)\n\n        tree_valid = self.parse('<a><b hardy=\"ho\"/><b/><b hardy=\"ho\"/><b/></a>',\n                                parser=parser)\n        root = tree_valid.getroot()\n        self.assertEqual('ho', root[0].get('hardy'))\n        self.assertEqual('hey', root[1].get('hardy'))\n        self.assertEqual('ho', root[2].get('hardy'))\n        self.assertEqual('hey', root[3].get('hardy'))\n\n    def test_xmlschema_parse_default_attributes_schema_config(self):\n        # does not work as of libxml2 2.7.3\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence minOccurs=\"4\" maxOccurs=\"4\">\n      <xsd:element name=\"b\" type=\"BType\" />\n    </xsd:sequence>\n  </xsd:complexType>\n  <xsd:complexType name=\"BType\">\n    <xsd:attribute name=\"hardy\" type=\"xsd:string\" default=\"hey\" />\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema, attribute_defaults=True)\n        parser = etree.XMLParser(schema=schema)\n\n        tree_valid = self.parse('<a><b hardy=\"ho\"/><b/><b hardy=\"ho\"/><b/></a>',\n                                parser=parser)\n        root = tree_valid.getroot()\n        self.assertEqual('ho', root[0].get('hardy'))\n        self.assertEqual('hey', root[1].get('hardy'))\n        self.assertEqual('ho', root[2].get('hardy'))\n        self.assertEqual('hey', root[3].get('hardy'))\n\n    def test_xmlschema_parse_fixed_attributes(self):\n        # does not work as of libxml2 2.7.3\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence minOccurs=\"3\" maxOccurs=\"3\">\n      <xsd:element name=\"b\" type=\"BType\" />\n    </xsd:sequence>\n  </xsd:complexType>\n  <xsd:complexType name=\"BType\">\n    <xsd:attribute name=\"hardy\" type=\"xsd:string\" fixed=\"hey\" />\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        parser = etree.XMLParser(schema=schema, attribute_defaults=True)\n\n        tree_valid = self.parse('<a><b/><b hardy=\"hey\"/><b/></a>',\n                                parser=parser)\n        root = tree_valid.getroot()\n        self.assertEqual('hey', root[0].get('hardy'))\n        self.assertEqual('hey', root[1].get('hardy'))\n        self.assertEqual('hey', root[2].get('hardy'))\n\n    def test_xmlschema_stringio(self):\n        schema_file = BytesIO(b'''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(file=schema_file)\n        parser = etree.XMLParser(schema=schema)\n\n        tree_valid = self.parse('<a><b></b></a>', parser=parser)\n        self.assertEqual('a', tree_valid.getroot().tag)\n\n        self.assertRaises(etree.XMLSyntaxError,\n                          self.parse, '<a><c></c></a>', parser=parser)\n\n    def test_xmlschema_iterparse(self):\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        xml = BytesIO(b'<a><b></b></a>')\n        events = [ (event, el.tag)\n                   for (event, el) in etree.iterparse(xml, schema=schema) ]\n\n        self.assertEqual([('end', 'b'), ('end', 'a')],\n                          events)\n\n    def test_xmlschema_iterparse_incomplete(self):\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        xml = BytesIO(b'<a><b></b></a>')\n        event, element = next(iter(etree.iterparse(xml, schema=schema)))\n        self.assertEqual('end', event)\n        self.assertEqual('b', element.tag)\n\n    def test_xmlschema_iterparse_fail(self):\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n        self.assertRaises(\n            etree.XMLSyntaxError,\n            list, etree.iterparse(BytesIO(b'<a><c></c></a>'), schema=schema))\n\n    def test_xmlschema_elementtree_error(self):\n        self.assertRaises(ValueError, etree.XMLSchema, etree.ElementTree())\n\n    def test_xmlschema_comment_error(self):\n        self.assertRaises(ValueError, etree.XMLSchema, etree.Comment('TEST'))\n\n    def test_xmlschema_illegal_validation_error(self):\n        schema = self.parse('''\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:string\"/>\n</xsd:schema>\n''')\n        schema = etree.XMLSchema(schema)\n\n        root = etree.Element('a')\n        root.text = 'TEST'\n        self.assertTrue(schema(root))\n\n        self.assertRaises(ValueError, schema, etree.Comment('TEST'))\n        self.assertRaises(ValueError, schema, etree.PI('a', 'text'))\n        self.assertRaises(ValueError, schema, etree.Entity('text'))\n\n    def test_xmlschema_invalid_schema1(self):\n        schema = self.parse('''\\\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        self.assertRaises(etree.XMLSchemaParseError,\n                          etree.XMLSchema, schema)\n\n    def test_xmlschema_invalid_schema2(self):\n        schema = self.parse('<test/>')\n        self.assertRaises(etree.XMLSchemaParseError,\n                          etree.XMLSchema, schema)\n\n    def test_xmlschema_file(self):\n        # this will only work if we access the file through path or\n        # file object..\n        f = open(fileInTestDir('test.xsd'), 'rb')\n        try:\n            schema = etree.XMLSchema(file=f)\n        finally:\n            f.close()\n        tree_valid = self.parse('<a><b></b></a>')\n        self.assertTrue(schema.validate(tree_valid))\n\n    def test_xmlschema_import_file(self):\n        # this will only work if we access the file through path or\n        # file object..\n        schema = etree.XMLSchema(file=fileInTestDir('test_import.xsd'))\n        tree_valid = self.parse(\n            '<a:x xmlns:a=\"http://codespeak.net/lxml/schema/ns1\"><b></b></a:x>')\n        self.assertTrue(schema.validate(tree_valid))\n\n    def test_xmlschema_shortcut(self):\n        tree_valid = self.parse('<a><b></b></a>')\n        tree_invalid = self.parse('<a><c></c></a>')\n        schema = self.parse('''\\\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"AType\"/>\n  <xsd:complexType name=\"AType\">\n    <xsd:sequence>\n      <xsd:element name=\"b\" type=\"xsd:string\" />\n    </xsd:sequence>\n  </xsd:complexType>\n</xsd:schema>\n''')\n        self.assertTrue(tree_valid.xmlschema(schema))\n        self.assertFalse(tree_invalid.xmlschema(schema))\n\n    def test_create_from_partial_doc(self):\n        # this used to crash because the schema part was not properly copied out\n        wsdl = self.parse('''\\\n<wsdl:definitions\n   xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n <wsdl:types>\n  <xs:schema>\n  </xs:schema>\n </wsdl:types>\n</wsdl:definitions>\n        ''')\n        schema_element = wsdl.find(\n            \"{http://schemas.xmlsoap.org/wsdl/}types/\"\n            \"{http://www.w3.org/2001/XMLSchema}schema\"\n        )\n        etree.XMLSchema(schema_element)\n        etree.XMLSchema(schema_element)\n        etree.XMLSchema(schema_element)\n\n    def test_xmlschema_pathlike(self):\n        schema = etree.XMLSchema(file=SimpleFSPath(fileInTestDir('test.xsd')))\n        tree_valid = self.parse('<a><b></b></a>')\n        self.assertTrue(schema.validate(tree_valid))\n\n\nclass ETreeXMLSchemaResolversTestCase(HelperTestCase):\n    resolver_schema_int = BytesIO(b\"\"\"\\\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n    xmlns:etype=\"http://codespeak.net/lxml/test/external\"\n    targetNamespace=\"http://codespeak.net/lxml/test/internal\">\n        <xsd:import namespace=\"http://codespeak.net/lxml/test/external\" schemaLocation=\"XXX.xsd\" />\n        <xsd:element name=\"a\" type=\"etype:AType\"/>\n</xsd:schema>\"\"\")\n\n    resolver_schema_int2 = BytesIO(b\"\"\"\\\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n    xmlns:etype=\"http://codespeak.net/lxml/test/external\"\n    targetNamespace=\"http://codespeak.net/lxml/test/internal\">\n        <xsd:import namespace=\"http://codespeak.net/lxml/test/external\" schemaLocation=\"YYY.xsd\" />\n        <xsd:element name=\"a\" type=\"etype:AType\"/>\n</xsd:schema>\"\"\")\n\n    resolver_schema_ext = \"\"\"\\\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n    targetNamespace=\"http://codespeak.net/lxml/test/external\">\n    <xsd:complexType name=\"AType\">\n      <xsd:sequence><xsd:element name=\"b\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\" /></xsd:sequence>\n    </xsd:complexType>\n</xsd:schema>\"\"\"\n\n    class simple_resolver(etree.Resolver):\n        def __init__(self, schema):\n            self.schema = schema\n\n        def resolve(self, url, id, context):\n            assert url == 'XXX.xsd'\n            return self.resolve_string(self.schema, context)\n\n    # tests:\n\n    def test_xmlschema_resolvers(self):\n        # test that resolvers work with schema.\n        parser = etree.XMLParser()\n        parser.resolvers.add(self.simple_resolver(self.resolver_schema_ext))\n        schema_doc = etree.parse(self.resolver_schema_int, parser = parser)\n        schema = etree.XMLSchema(schema_doc)\n\n    def test_xmlschema_resolvers_root(self):\n        # test that the default resolver will get called if there's no\n        # specific parser resolver.\n        root_resolver = self.simple_resolver(self.resolver_schema_ext)\n        etree.get_default_parser().resolvers.add(root_resolver)\n        schema_doc = etree.parse(self.resolver_schema_int)\n        schema = etree.XMLSchema(schema_doc)\n        etree.get_default_parser().resolvers.remove(root_resolver)\n\n    def test_xmlschema_resolvers_noroot(self):\n        # test that the default resolver will not get called when a\n        # more specific resolver is registered.\n\n        class res_root(etree.Resolver):\n            def resolve(self, url, id, context):\n                assert False\n                return None\n\n        root_resolver = res_root()\n        etree.get_default_parser().resolvers.add(root_resolver)\n\n        parser = etree.XMLParser()\n        parser.resolvers.add(self.simple_resolver(self.resolver_schema_ext))\n\n        schema_doc = etree.parse(self.resolver_schema_int, parser = parser)\n        schema = etree.XMLSchema(schema_doc)\n        etree.get_default_parser().resolvers.remove(root_resolver)\n\n    def test_xmlschema_nested_resolvers(self):\n        # test that resolvers work in a nested fashion.\n\n        resolver_schema = self.resolver_schema_ext\n\n        class res_nested(etree.Resolver):\n            def __init__(self, ext_schema):\n                self.ext_schema = ext_schema\n\n            def resolve(self, url, id, context):\n                assert url == 'YYY.xsd'\n                return self.resolve_string(self.ext_schema, context)\n\n        class res(etree.Resolver):\n            def __init__(self, ext_schema_1, ext_schema_2):\n                self.ext_schema_1 = ext_schema_1\n                self.ext_schema_2 = ext_schema_2\n\n            def resolve(self, url, id, context):\n                assert url == 'XXX.xsd'\n\n                new_parser = etree.XMLParser()\n                new_parser.resolvers.add(res_nested(self.ext_schema_2))\n                new_schema_doc = etree.parse(self.ext_schema_1, parser = new_parser)\n                new_schema = etree.XMLSchema(new_schema_doc)\n\n                return self.resolve_string(resolver_schema, context)\n\n        parser = etree.XMLParser()\n        parser.resolvers.add(res(self.resolver_schema_int2, self.resolver_schema_ext))\n        schema_doc = etree.parse(self.resolver_schema_int, parser = parser)\n        schema = etree.XMLSchema(schema_doc)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXMLSchemaTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXMLSchemaResolversTestCase)])\n    suite.addTests(\n        [make_doctest('validation.txt')])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_incremental_xmlfile.py": "# coding: utf-8\n\"\"\"\nTests for the incremental XML serialisation API.\n\"\"\"\n\nimport io\nimport os\nimport sys\nimport unittest\nimport textwrap\nimport tempfile\nfrom io import BytesIO\n\nfrom unittest import skipIf\n\nfrom lxml.etree import LxmlSyntaxError\n\nfrom .common_imports import etree, HelperTestCase\n\n\nclass _XmlFileTestCaseBase(HelperTestCase):\n    _file = None  # to be set by specific subtypes below\n\n    def test_element(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                pass\n        self.assertXml('<test></test>')\n\n    def test_element_write_text(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                xf.write('toast')\n        self.assertXml('<test>toast</test>')\n\n    def test_element_write_empty(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                xf.write(None)\n                xf.write('')\n                xf.write('')\n                xf.write(None)\n        self.assertXml('<test></test>')\n\n    def test_element_nested(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                with xf.element('toast'):\n                    with xf.element('taste'):\n                        xf.write('conTent')\n        self.assertXml('<test><toast><taste>conTent</taste></toast></test>')\n\n    def test_element_nested_with_text(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                xf.write('con')\n                with xf.element('toast'):\n                    xf.write('tent')\n                    with xf.element('taste'):\n                        xf.write('inside')\n                    xf.write('tnet')\n                xf.write('noc')\n        self.assertXml('<test>con<toast>tent<taste>inside</taste>'\n                       'tnet</toast>noc</test>')\n\n    def test_write_Element(self):\n        with etree.xmlfile(self._file) as xf:\n            xf.write(etree.Element('test'))\n        self.assertXml('<test/>')\n\n    def test_write_Element_repeatedly(self):\n        element = etree.Element('test')\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                for i in range(100):\n                    xf.write(element)\n\n        tree = self._parse_file()\n        self.assertTrue(tree is not None)\n        self.assertEqual(100, len(tree.getroot()))\n        self.assertEqual({'test'}, {el.tag for el in tree.getroot()})\n\n    def test_namespace_nsmap(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('{nsURI}test', nsmap={'x': 'nsURI'}):\n                pass\n        self.assertXml('<x:test xmlns:x=\"nsURI\"></x:test>')\n\n    def test_namespace_nested_nsmap(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test', nsmap={'x': 'nsURI'}):\n                with xf.element('{nsURI}toast'):\n                    pass\n        self.assertXml('<test xmlns:x=\"nsURI\"><x:toast></x:toast></test>')\n\n    def test_anonymous_namespace(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('{nsURI}test'):\n                pass\n        self.assertXml('<ns0:test xmlns:ns0=\"nsURI\"></ns0:test>')\n\n    def test_namespace_nested_anonymous(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                with xf.element('{nsURI}toast'):\n                    pass\n        self.assertXml('<test><ns0:toast xmlns:ns0=\"nsURI\"></ns0:toast></test>')\n\n    def test_default_namespace(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('{nsURI}test', nsmap={None: 'nsURI'}):\n                pass\n        self.assertXml('<test xmlns=\"nsURI\"></test>')\n\n    def test_nested_default_namespace(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('{nsURI}test', nsmap={None: 'nsURI'}):\n                with xf.element('{nsURI}toast'):\n                    pass\n        self.assertXml('<test xmlns=\"nsURI\"><toast></toast></test>')\n\n    def test_nested_default_namespace_and_other(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('{nsURI}test', nsmap={None: 'nsURI', 'p': 'ns2'}):\n                with xf.element('{nsURI}toast'):\n                    pass\n                with xf.element('{ns2}toast'):\n                    pass\n        self.assertXml(\n            '<test xmlns=\"nsURI\" xmlns:p=\"ns2\"><toast></toast><p:toast></p:toast></test>')\n\n    def test_pi(self):\n        with etree.xmlfile(self._file) as xf:\n            xf.write(etree.ProcessingInstruction('pypi'))\n            with xf.element('test'):\n                pass\n        self.assertXml('<?pypi ?><test></test>')\n\n    def test_comment(self):\n        with etree.xmlfile(self._file) as xf:\n            xf.write(etree.Comment('a comment'))\n            with xf.element('test'):\n                pass\n        self.assertXml('<!--a comment--><test></test>')\n\n    def test_attribute(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test', attrib={'k': 'v'}):\n                pass\n        self.assertXml('<test k=\"v\"></test>')\n\n    def test_attribute_extra(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test', attrib={'k': 'v'}, n='N'):\n                pass\n        self.assertXml('<test k=\"v\" n=\"N\"></test>')\n\n    def test_attribute_extra_duplicate(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test', attrib={'k': 'v'}, k='V'):\n                pass\n        self.assertXml('<test k=\"V\"></test>')\n\n    def test_attribute_unicode(self):\n        with etree.xmlfile(self._file, encoding=\"utf-8\") as xf:\n            with xf.element('\u00e4l\u00e4m\u00e4nt', attrib={\"\u0422\u0435\u0441\u0442\": \"\u0410\u0442\u0440\u0438\u0431\u0443\u0442\"}):\n                el = etree.Element(\"\u00e4l\u00e4m\u00e4nt\", attrib={\"\u0422\u0435\u0441\u0442\": \"\u0410\u0442\u0440\u0438\u0431\u0443\u0442\"})\n                xf.write(el)\n        self.assertXml('<\u00e4l\u00e4m\u00e4nt \u0422\u0435\u0441\u0442=\"\u0410\u0442\u0440\u0438\u0431\u0443\u0442\"><\u00e4l\u00e4m\u00e4nt \u0422\u0435\u0441\u0442=\"\u0410\u0442\u0440\u0438\u0431\u0443\u0442\"/></\u00e4l\u00e4m\u00e4nt>')\n\n    def test_escaping(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                xf.write('Comments: <!-- text -->\\n')\n                xf.write('Entities: &amp;')\n        self.assertXml(\n            '<test>Comments: &lt;!-- text --&gt;\\nEntities: &amp;amp;</test>')\n\n    def test_encoding(self):\n        with etree.xmlfile(self._file, encoding='utf16') as xf:\n            with xf.element('test'):\n                xf.write('toast')\n        self.assertXml('<test>toast</test>', encoding='utf16')\n\n    def test_buffering(self):\n        with etree.xmlfile(self._file, buffered=False) as xf:\n            with xf.element('test'):\n                self.assertXml(\"<test>\", reparse=False)\n                xf.write('toast')\n                self.assertXml(\"<test>toast\", reparse=False)\n                with xf.element('taste'):\n                    self.assertXml(\"<test>toast<taste>\", reparse=False)\n                    xf.write('some', etree.Element(\"more\"), \"toast\")\n                    self.assertXml(\"<test>toast<taste>some<more/>toast\", reparse=False)\n                self.assertXml(\"<test>toast<taste>some<more/>toast</taste>\", reparse=False)\n                xf.write('end')\n                self.assertXml(\"<test>toast<taste>some<more/>toast</taste>end\", reparse=False)\n            self.assertXml(\"<test>toast<taste>some<more/>toast</taste>end</test>\", reparse=False)\n        self.assertXml(\"<test>toast<taste>some<more/>toast</taste>end</test>\")\n\n    def test_flush(self):\n        with etree.xmlfile(self._file, buffered=True) as xf:\n            with xf.element('test'):\n                self.assertXml(\"\", reparse=False)\n                xf.write('toast')\n                self.assertXml(\"\", reparse=False)\n                with xf.element('taste'):\n                    self.assertXml(\"\", reparse=False)\n                    xf.flush()\n                    self.assertXml(\"<test>toast<taste>\", reparse=False)\n                self.assertXml(\"<test>toast<taste>\", reparse=False)\n            self.assertXml(\"<test>toast<taste>\", reparse=False)\n        self.assertXml(\"<test>toast<taste></taste></test>\")\n\n    def test_non_io_exception_continues_closing(self):\n        try:\n            with etree.xmlfile(self._file) as xf:\n                with xf.element('root'):\n                    with xf.element('test'):\n                        xf.write(\"BEFORE\")\n                        raise TypeError(\"FAIL!\")\n                    xf.write(\"AFTER\")\n        except TypeError as exc:\n            self.assertTrue(\"FAIL\" in str(exc), exc)\n        else:\n            self.assertTrue(False, \"exception not propagated\")\n        self.assertXml(\"<root><test>BEFORE</test></root>\")\n\n    def test_generator_close_continues_closing(self):\n        def gen():\n            with etree.xmlfile(self._file) as xf:\n                with xf.element('root'):\n                    while True:\n                        content = (yield)\n                        with xf.element('entry'):\n                            xf.write(content)\n\n        g = gen()\n        next(g)\n        g.send('A')\n        g.send('B')\n        g.send('C')\n        g.close()\n        self.assertXml(\"<root><entry>A</entry><entry>B</entry><entry>C</entry></root>\")\n\n    def test_failure_preceding_text(self):\n        try:\n            with etree.xmlfile(self._file) as xf:\n                xf.write('toast')\n        except etree.LxmlSyntaxError:\n            self.assertTrue(True)\n        else:\n            self.assertTrue(False)\n\n    def test_failure_trailing_text(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                pass\n            try:\n                xf.write('toast')\n            except etree.LxmlSyntaxError:\n                self.assertTrue(True)\n            else:\n                self.assertTrue(False)\n\n    def test_failure_trailing_Element(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                pass\n            try:\n                xf.write(etree.Element('test'))\n            except etree.LxmlSyntaxError:\n                self.assertTrue(True)\n            else:\n                self.assertTrue(False)\n\n    def test_closing_out_of_order_in_error_case(self):\n        cm_exit = None\n        try:\n            with etree.xmlfile(self._file) as xf:\n                x = xf.element('test')\n                cm_exit = x.__exit__\n                x.__enter__()\n                raise ValueError('123')\n        except ValueError:\n            self.assertTrue(cm_exit)\n            try:\n                cm_exit(ValueError, ValueError(\"huhu\"), None)\n            except etree.LxmlSyntaxError:\n                self.assertTrue(True)\n            else:\n                self.assertTrue(False)\n        else:\n            self.assertTrue(False)\n\n    def _read_file(self):\n        pos = self._file.tell()\n        self._file.seek(0)\n        try:\n            return self._file.read()\n        finally:\n            self._file.seek(pos)\n\n    def _parse_file(self):\n        pos = self._file.tell()\n        self._file.seek(0)\n        try:\n            return etree.parse(self._file)\n        finally:\n            self._file.seek(pos)\n\n    def tearDown(self):\n        if self._file is not None:\n            self._file.close()\n\n    def assertXml(self, expected, encoding='utf8', reparse=True):\n        output = self._read_file()\n        self.assertEqual(output.decode(encoding), expected)\n\n        if not reparse:\n            return\n\n        def compare(el1, el2):\n            self.assertEqual(el1.tag, el2.tag)\n            self.assertEqual(el1.text, el2.text)\n            self.assertEqual(el1.tail, el2.tail)\n            self.assertEqual(el1.attrib, el2.attrib)\n\n            self.assertEqual(len(el1), len(el2))\n            for child1, child2 in zip(el1, el2):\n                compare(child1, child2)\n\n        root_out = etree.fromstring(output)\n        root_expected = etree.fromstring(expected)\n        compare(root_out, root_expected)\n\n\nclass BytesIOXmlFileTestCase(_XmlFileTestCaseBase):\n    def setUp(self):\n        self._file = BytesIO()\n\n    def test_filelike_close(self):\n        with etree.xmlfile(self._file, close=True) as xf:\n            with xf.element('test'):\n                pass\n        self.assertRaises(ValueError, self._file.getvalue)\n\n\nclass TempXmlFileTestCase(_XmlFileTestCaseBase):\n    def setUp(self):\n        self._file = tempfile.TemporaryFile()\n\n\n@skipIf(sys.platform.startswith(\"win\"), \"Can't reopen temporary files on Windows\")\nclass TempPathXmlFileTestCase(_XmlFileTestCaseBase):\n    def setUp(self):\n        self._tmpfile = tempfile.NamedTemporaryFile()\n        self._file = self._tmpfile.name\n\n    def tearDown(self):\n        try:\n            self._tmpfile.close()\n        finally:\n            if os.path.exists(self._tmpfile.name):\n                os.unlink(self._tmpfile.name)\n\n    def _read_file(self):\n        self._tmpfile.seek(0)\n        return self._tmpfile.read()\n\n    def _parse_file(self):\n        self._tmpfile.seek(0)\n        return etree.parse(self._tmpfile)\n\n    @skipIf(True, \"temp file behaviour is too platform specific here\")\n    def test_buffering(self):\n        pass\n\n    @skipIf(True, \"temp file behaviour is too platform specific here\")\n    def test_flush(self):\n        pass\n\n\nclass SimpleFileLikeXmlFileTestCase(_XmlFileTestCaseBase):\n    class SimpleFileLike:\n        def __init__(self, target):\n            self._target = target\n            self.write = target.write\n            self.tell = target.tell\n            self.seek = target.seek\n            self.closed = False\n\n        def close(self):\n            assert not self.closed\n            self.closed = True\n            self._target.close()\n\n    def setUp(self):\n        self._target = BytesIO()\n        self._file = self.SimpleFileLike(self._target)\n\n    def _read_file(self):\n        return self._target.getvalue()\n\n    def _parse_file(self):\n        pos = self._file.tell()\n        self._target.seek(0)\n        try:\n            return etree.parse(self._target)\n        finally:\n            self._target.seek(pos)\n\n    def test_filelike_not_closing(self):\n        with etree.xmlfile(self._file) as xf:\n            with xf.element('test'):\n                pass\n        self.assertFalse(self._file.closed)\n\n    def test_filelike_close(self):\n        with etree.xmlfile(self._file, close=True) as xf:\n            with xf.element('test'):\n                pass\n        self.assertTrue(self._file.closed)\n        self._file = None  # prevent closing in tearDown()\n\n    def test_write_fails(self):\n        class WriteError(Exception):\n            pass\n\n        class Writer:\n            def __init__(self, trigger):\n                self._trigger = trigger\n                self._failed = False\n\n            def write(self, data):\n                assert not self._failed, \"write() called again after failure\"\n                if self._trigger in data:\n                    self._failed = True\n                    raise WriteError(\"FAILED: \" + self._trigger.decode('utf8'))\n\n        for trigger in ['text', 'root', 'tag', 'noflush']:\n            try:\n                with etree.xmlfile(Writer(trigger.encode('utf8')), encoding='utf8') as xf:\n                    with xf.element('root'):\n                        xf.flush()\n                        with xf.element('tag'):\n                            xf.write('text')\n                            xf.flush()\n                            xf.write('noflush')\n                        xf.flush()\n                    xf.flush()\n            except WriteError as exc:\n                self.assertTrue('FAILED: ' + trigger in str(exc))\n            else:\n                self.assertTrue(False, \"exception not raised for '%s'\" % trigger)\n\n\nclass HtmlFileTestCase(_XmlFileTestCaseBase):\n    def setUp(self):\n        self._file = BytesIO()\n\n    def assertXml(self, expected, encoding='utf8', reparse=False):\n        super(HtmlFileTestCase, self).assertXml(expected, encoding, reparse=reparse)\n\n    def test_void_elements(self):\n        # http://www.w3.org/TR/html5/syntax.html#elements-0\n        void_elements = {\n            \"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\",\n            \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"}\n\n        # FIXME: These don't get serialized as void elements.\n        void_elements.difference_update([\n            'area', 'embed', 'keygen', 'source', 'track', 'wbr'\n        ])\n\n        for tag in sorted(void_elements):\n            with etree.htmlfile(self._file) as xf:\n                xf.write(etree.Element(tag))\n            self.assertXml('<%s>' % tag)\n            self._file = BytesIO()\n\n    def test_method_context_manager_misuse(self):\n        with etree.htmlfile(self._file) as xf:\n            with xf.element('foo'):\n                cm = xf.method('xml')\n                cm.__enter__()\n\n                self.assertRaises(LxmlSyntaxError, cm.__enter__)\n\n                cm2 = xf.method('xml')\n                cm2.__enter__()\n                cm2.__exit__(None, None, None)\n\n                self.assertRaises(LxmlSyntaxError, cm2.__exit__, None, None, None)\n\n                cm3 = xf.method('xml')\n                cm3.__enter__()\n                with xf.method('html'):\n                    self.assertRaises(LxmlSyntaxError, cm3.__exit__, None, None, None)\n\n    def test_xml_mode_write_inside_html(self):\n        tag = 'foo'\n        attrib = {'selected': 'bar'}\n        elt = etree.Element(tag, attrib=attrib)\n\n        with etree.htmlfile(self._file) as xf:\n            with xf.element(\"root\"):\n                xf.write(elt)  # 1\n\n                assert elt.text is None\n                xf.write(elt, method='xml')  # 2\n\n                elt.text = \"\"\n                xf.write(elt, method='xml')  # 3\n\n                with xf.element(tag, attrib=attrib, method='xml'):\n                    pass # 4\n\n                xf.write(elt)  # 5\n\n                with xf.method('xml'):\n                    xf.write(elt)  # 6\n\n        self.assertXml(\n            '<root>'\n                '<foo selected></foo>'  # 1\n                '<foo selected=\"bar\"/>'  # 2\n                '<foo selected=\"bar\"></foo>'  # 3\n                '<foo selected=\"bar\"></foo>'  # 4\n                '<foo selected></foo>'  # 5\n                '<foo selected=\"bar\"></foo>'  # 6\n            '</root>')\n        self._file = BytesIO()\n\n    def test_xml_mode_element_inside_html(self):\n        # The htmlfile already outputs in xml mode for .element calls. This\n        # test actually illustrates a bug\n\n        with etree.htmlfile(self._file) as xf:\n            with xf.element(\"root\"):\n                with xf.element('foo', attrib={'selected': 'bar'}):\n                    pass\n\n        self.assertXml(\n            '<root>'\n              # '<foo selected></foo>'  # FIXME: this is the correct output\n                                        # in html mode\n              '<foo selected=\"bar\"></foo>'\n            '</root>')\n        self._file = BytesIO()\n\n    def test_attribute_quoting(self):\n        with etree.htmlfile(self._file) as xf:\n            with xf.element(\"tagname\", attrib={\"attr\": '\"misquoted\"'}):\n                xf.write(\"foo\")\n\n        self.assertXml('<tagname attr=\"&quot;misquoted&quot;\">foo</tagname>')\n\n    def test_attribute_quoting_unicode(self):\n        with etree.htmlfile(self._file) as xf:\n            with xf.element(\"tagname\", attrib={\"attr\": '\"misqu\u00f6ted\\u3344\\U00013344\"'}):\n                xf.write(\"foo\")\n\n        self.assertXml('<tagname attr=\"&quot;misqu&#246;ted&#13124;&#78660;&quot;\">foo</tagname>')\n\n    def test_unescaped_script(self):\n        with etree.htmlfile(self._file) as xf:\n            elt = etree.Element('script')\n            elt.text = \"if (a < b);\"\n            xf.write(elt)\n        self.assertXml('<script>if (a < b);</script>')\n\n    def test_unescaped_script_incremental(self):\n        with etree.htmlfile(self._file) as xf:\n            with xf.element('script'):\n                xf.write(\"if (a < b);\")\n\n        self.assertXml('<script>if (a < b);</script>')\n\n    def test_write_declaration(self):\n        with etree.htmlfile(self._file) as xf:\n            try:\n                xf.write_declaration()\n            except etree.LxmlSyntaxError:\n                self.assertTrue(True)\n            else:\n                self.assertTrue(False)\n            xf.write(etree.Element('html'))\n\n    def test_write_namespaced_element(self):\n        with etree.htmlfile(self._file) as xf:\n            xf.write(etree.Element('{some_ns}some_tag'))\n        self.assertXml('<ns0:some_tag xmlns:ns0=\"some_ns\"></ns0:some_tag>')\n\n    def test_open_namespaced_element(self):\n        with etree.htmlfile(self._file) as xf:\n            with xf.element(\"{some_ns}some_tag\"):\n                pass\n        self.assertXml('<ns0:some_tag xmlns:ns0=\"some_ns\"></ns0:some_tag>')\n\n\nclass AsyncXmlFileTestCase(HelperTestCase):\n    def test_async_api(self):\n        out = io.BytesIO()\n        xf = etree.xmlfile(out)\n        scm = xf.__enter__()\n        acm = xf.__aenter__()\n        list(acm.__await__())  # fake await to avoid destructor warning\n\n        def api_of(obj):\n            return sorted(name for name in dir(scm) if not name.startswith('__'))\n\n        a_api = api_of(acm)\n\n        self.assertEqual(api_of(scm), api_of(acm))\n        self.assertTrue('write' in a_api)\n        self.assertTrue('element' in a_api)\n        self.assertTrue('method' in a_api)\n        self.assertTrue(len(a_api) > 5)\n\n    def _run_async(self, coro):\n        while True:\n            try:\n                coro.send(None)\n            except StopIteration as ex:\n                return ex.value\n\n    def test_async(self):\n        code = textwrap.dedent(\"\"\"\\\n        async def test_async_xmlfile(close=True, buffered=True):\n            class Writer(object):\n                def __init__(self):\n                    self._data = []\n                    self._all_data = None\n                    self._calls = 0\n\n                async def write(self, data):\n                    self._calls += 1\n                    self._data.append(data)\n\n                async def close(self):\n                    assert self._all_data is None\n                    assert self._data is not None\n                    self._all_data = b''.join(self._data)\n                    self._data = None  # make writing fail afterwards\n\n            async def generate(out, close=True, buffered=True):\n                async with etree.xmlfile(out, close=close, buffered=buffered) as xf:\n                    async with xf.element('root'):\n                        await xf.write('root-text')\n                        async with xf.method('html'):\n                            await xf.write(etree.Element('img', src='http://huhu.org/'))\n                        await xf.flush()\n                        for i in range(3):\n                            async with xf.element('el'):\n                                await xf.write('text-%d' % i)\n\n            out = Writer()\n            await generate(out, close=close, buffered=buffered)\n            if not close:\n                await out.close()\n            assert out._data is None, out._data\n            return out._all_data, out._calls\n        \"\"\")\n        lns = {}\n        exec(code, globals(), lns)\n        test_async_xmlfile = lns['test_async_xmlfile']\n\n        expected = (\n            b'<root>root-text<img src=\"http://huhu.org/\">'\n            b'<el>text-0</el><el>text-1</el><el>text-2</el></root>'\n        )\n\n        data, calls = self._run_async(test_async_xmlfile(close=True))\n        self.assertEqual(expected, data)\n        self.assertEqual(2, calls)  # only flush() and close()\n\n        data, calls = self._run_async(test_async_xmlfile(close=False))\n        self.assertEqual(expected, data)\n        self.assertEqual(2, calls)  # only flush() and close()\n\n        data, unbuffered_calls = self._run_async(test_async_xmlfile(buffered=False))\n        self.assertEqual(expected, data)\n        self.assertTrue(unbuffered_calls > calls, unbuffered_calls)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([\n        unittest.defaultTestLoader.loadTestsFromTestCase(BytesIOXmlFileTestCase),\n        unittest.defaultTestLoader.loadTestsFromTestCase(TempXmlFileTestCase),\n        unittest.defaultTestLoader.loadTestsFromTestCase(TempPathXmlFileTestCase),\n        unittest.defaultTestLoader.loadTestsFromTestCase(SimpleFileLikeXmlFileTestCase),\n        unittest.defaultTestLoader.loadTestsFromTestCase(HtmlFileTestCase),\n        unittest.defaultTestLoader.loadTestsFromTestCase(AsyncXmlFileTestCase),\n    ])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/tests/test_xslt.py": "\"\"\"\nTest cases related to XSLT processing\n\"\"\"\n\n\nimport io\nimport copy\nimport gzip\nimport os.path\nimport unittest\nimport contextlib\n\nfrom io import BytesIO\nfrom textwrap import dedent\nfrom tempfile import NamedTemporaryFile, mkdtemp\n\nfrom .common_imports import (\n    etree, HelperTestCase, fileInTestDir, make_doctest, SimpleFSPath\n)\n\n\nclass ETreeXSLTTestCase(HelperTestCase):\n    \"\"\"XSLT tests etree\"\"\"\n        \n    def test_xslt(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n    def test_xslt_elementtree_error(self):\n        self.assertRaises(ValueError, etree.XSLT, etree.ElementTree())\n\n    def test_xslt_input_none(self):\n        self.assertRaises(TypeError, etree.XSLT, None)\n\n    def test_xslt_invalid_stylesheet(self):\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n        xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:stylesheet />\n</xsl:stylesheet>''')\n\n        self.assertRaises(\n            etree.XSLTParseError, etree.XSLT, style)\n\n    def test_xslt_copy(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        transform = etree.XSLT(style)\n        res = transform(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n        transform_copy = copy.deepcopy(transform)\n        res = transform_copy(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n        transform = etree.XSLT(style)\n        res = transform(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n    @contextlib.contextmanager\n    def _xslt_setup(\n            self, encoding='UTF-16', expected_encoding=None,\n            expected='<?xml version=\"1.0\" encoding=\"%(ENCODING)s\"?><foo>\\uF8D2</foo>'):\n        tree = self.parse('<a><b>\\uF8D2</b><c>\\uF8D2</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:output encoding=\"%(ENCODING)s\"/>\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''' % {'ENCODING': encoding})\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        expected = dedent(expected).strip().replace('\\n', '') % {\n            'ENCODING': expected_encoding or encoding,\n        }\n\n        data = [res]\n        yield data\n        self.assertEqual(expected, data[0].replace('\\n', ''))\n\n    def test_xslt_utf8(self):\n        with self._xslt_setup(encoding='UTF-8') as res:\n            res[0] = bytes(res[0]).decode('UTF-8')\n            assert 'UTF-8' in res[0]\n\n    def test_xslt_encoding(self):\n        with self._xslt_setup() as res:\n            res[0] = bytes(res[0]).decode('UTF-16')\n            assert 'UTF-16' in res[0]\n\n    def test_xslt_encoding_override(self):\n        with self._xslt_setup(encoding='UTF-8', expected_encoding='UTF-16') as res:\n            f = BytesIO()\n            res[0].write(f, encoding='UTF-16')\n            output = str(f.getvalue(), 'UTF-16')\n            res[0] = output.replace(\"'\", '\"')\n\n    def test_xslt_write_output_bytesio(self):\n        with self._xslt_setup() as res:\n            f = BytesIO()\n            res[0].write_output(f)\n            res[0] = f.getvalue().decode('UTF-16')\n\n    def test_xslt_write_output_failure(self):\n        class Writer:\n            def write(self, data):\n                raise ValueError(\"FAILED!\")\n\n        try:\n            with self._xslt_setup() as res:\n                res[0].write_output(Writer())\n        except ValueError as exc:\n            self.assertTrue(\"FAILED!\" in str(exc), exc)\n        else:\n            self.assertTrue(False, \"exception not raised\")\n\n    def test_xslt_write_output_file(self):\n        with self._xslt_setup() as res:\n            f = NamedTemporaryFile(delete=False)\n            try:\n                try:\n                    res[0].write_output(f)\n                finally:\n                    f.close()\n                with open(f.name, encoding='UTF-16') as f:\n                    res[0] = f.read()\n            finally:\n                os.unlink(f.name)\n\n    def test_xslt_write_output_file_path(self):\n        with self._xslt_setup() as res:\n            f = NamedTemporaryFile(delete=False)\n            try:\n                try:\n                    res[0].write_output(f.name, compression=9)\n                finally:\n                    f.close()\n                with gzip.GzipFile(f.name) as f:\n                    res[0] = f.read().decode(\"UTF-16\")\n            finally:\n                os.unlink(f.name)\n    \n    def test_xslt_write_output_file_pathlike(self):\n        with self._xslt_setup() as res:\n            f = NamedTemporaryFile(delete=False)\n            try:\n                try:\n                    res[0].write_output(SimpleFSPath(f.name), compression=9)\n                finally:\n                    f.close()\n                with gzip.GzipFile(f.name) as f:\n                    res[0] = f.read().decode(\"UTF-16\")\n            finally:\n                os.unlink(f.name)\n\n    def test_xslt_write_output_file_path_urlescaped(self):\n        # libxml2 should not unescape file paths.\n        with self._xslt_setup() as res:\n            f = NamedTemporaryFile(prefix='tmp%2e', suffix='.xml.gz', delete=False)\n            try:\n                try:\n                    res[0].write_output(f.name, compression=3)\n                finally:\n                    f.close()\n                with gzip.GzipFile(f.name) as f:\n                    res[0] = f.read().decode(\"UTF-16\")\n            finally:\n                os.unlink(f.name)\n\n    def test_xslt_write_output_file_path_urlescaped_plus(self):\n        with self._xslt_setup() as res:\n            f = NamedTemporaryFile(prefix='p+%2e', suffix='.xml.gz', delete=False)\n            try:\n                try:\n                    res[0].write_output(f.name, compression=1)\n                finally:\n                    f.close()\n                with gzip.GzipFile(f.name) as f:\n                    res[0] = f.read().decode(\"UTF-16\")\n            finally:\n                os.unlink(f.name)\n\n    def test_xslt_write_output_file_oserror(self):\n        with self._xslt_setup(expected='') as res:\n            tempdir = mkdtemp()\n            try:\n                res[0].write_output(os.path.join(tempdir, 'missing_subdir', 'out.xml'))\n            except OSError:\n                res[0] = ''\n            else:\n                self.fail(\"IOError not raised\")\n            finally:\n                os.rmdir(tempdir)\n\n    def test_xslt_unicode(self):\n        expected = '''\n            <?xml version=\"1.0\"?>\n            <foo>\\uF8D2</foo>\n        '''\n        with self._xslt_setup(expected=expected) as res:\n            res[0] = str(res[0])\n\n    def test_xslt_unicode_standalone(self):\n        tree = self.parse('<a><b>\\uF8D2</b><c>\\uF8D2</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:output encoding=\"UTF-16\" standalone=\"no\"/>\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        expected = '''\\\n<?xml version=\"1.0\" standalone=\"no\"?>\n<foo>\\uF8D2</foo>\n'''\n        self.assertEqual(expected,\n                         str(res))\n\n    def test_xslt_input(self):\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        st = etree.XSLT(style.getroot())\n\n    def test_xslt_input_partial_doc(self):\n        style = self.parse('''\\\n<otherroot>\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>\n</otherroot>''')\n\n        self.assertRaises(etree.XSLTParseError, etree.XSLT, style)\n        root_node = style.getroot()\n        self.assertRaises(etree.XSLTParseError, etree.XSLT, root_node)\n        st = etree.XSLT(root_node[0])\n\n    def test_xslt_broken(self):\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:foo />\n</xsl:stylesheet>''')\n        self.assertRaises(etree.XSLTParseError,\n                          etree.XSLT, style)\n\n    def test_xslt_parsing_error_log(self):\n        tree = self.parse('<a/>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:foo />\n</xsl:stylesheet>''')\n        self.assertRaises(etree.XSLTParseError,\n                          etree.XSLT, style)\n        exc = None\n        try:\n            etree.XSLT(style)\n        except etree.XSLTParseError as e:\n            exc = e\n        else:\n            self.assertFalse(True, \"XSLT processing should have failed but didn't\")\n        self.assertTrue(exc is not None)\n        self.assertTrue(len(exc.error_log))\n        for error in exc.error_log:\n            self.assertTrue(':ERROR:XSLT:' in str(error))\n\n    def test_xslt_apply_error_log(self):\n        tree = self.parse('<a/>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template match=\"a\">\n        <xsl:copy>\n            <xsl:message terminate=\"yes\">FAIL</xsl:message>\n        </xsl:copy>\n    </xsl:template>\n</xsl:stylesheet>''')\n        self.assertRaises(etree.XSLTApplyError,\n                          etree.XSLT(style), tree)\n\n        transform = etree.XSLT(style)\n        exc = None\n        try:\n            transform(tree)\n        except etree.XSLTApplyError as e:\n            exc = e\n        else:\n            self.assertFalse(True, \"XSLT processing should have failed but didn't\")\n\n        self.assertTrue(exc is not None)\n        self.assertTrue(len(exc.error_log))\n        self.assertEqual(len(transform.error_log), len(exc.error_log))\n        for error in exc.error_log:\n            self.assertTrue(':ERROR:XSLT:' in str(error))\n        for error in transform.error_log:\n            self.assertTrue(':ERROR:XSLT:' in str(error))\n\n    def test_xslt_parameters(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree, bar=\"'Bar'\")\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>Bar</foo>\n''',\n                          str(res))\n\n    def test_xslt_string_parameters(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree, bar=etree.XSLT.strparam('''it's me, \"Bar\"'''))\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>it's me, \"Bar\"</foo>\n''',\n                          str(res))\n\n    def test_xslt_parameter_invalid(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:param name=\"bar\"/>\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = self.assertRaises(etree.XSLTApplyError,\n                                st, tree, bar=\"<test/>\")\n        res = self.assertRaises(etree.XSLTApplyError,\n                                st, tree, bar=\"....\")\n\n    def test_xslt_parameter_missing(self):\n        # apply() without needed parameter will lead to XSLTApplyError\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        # at least libxslt 1.1.28 produces this error, earlier ones (e.g. 1.1.18) might not ...\n        self.assertRaises(etree.XSLTApplyError, st, tree)\n\n    def test_xslt_multiple_parameters(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n    <foo><xsl:value-of select=\"$baz\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree, bar=\"'Bar'\", baz=\"'Baz'\")\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>Bar</foo><foo>Baz</foo>\n''',\n                          str(res))\n        \n    def test_xslt_parameter_xpath(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree, bar=\"/a/b/text()\")\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n    def test_xslt_parameter_xpath_object(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree, bar=etree.XPath(\"/a/b/text()\"))\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n        \n    def test_xslt_default_parameters(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:param name=\"bar\" select=\"'Default'\" />\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree, bar=\"'Bar'\")\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>Bar</foo>\n''',\n                          str(res))\n        res = st(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>Default</foo>\n''',\n                          str(res))\n        \n    def test_xslt_html_output(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:output method=\"html\"/>\n  <xsl:strip-space elements=\"*\"/>\n  <xsl:template match=\"/\">\n    <html><body><xsl:value-of select=\"/a/b/text()\" /></body></html>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual('<html><body>B</body></html>',\n                          str(res).strip())\n\n    def test_xslt_include(self):\n        tree = etree.parse(fileInTestDir('test1.xslt'))\n        st = etree.XSLT(tree)\n\n    def test_xslt_include_from_filelike(self):\n        f = open(fileInTestDir('test1.xslt'), 'rb')\n        tree = etree.parse(f)\n        f.close()\n        st = etree.XSLT(tree)\n\n    def test_xslt_multiple_transforms(self):\n        xml = '<a/>'\n        xslt = '''\\\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n    <xsl:template match=\"/\">\n        <response>Some text</response>\n    </xsl:template>\n</xsl:stylesheet>\n'''\n        source = self.parse(xml)\n        styledoc = self.parse(xslt)\n        style = etree.XSLT(styledoc)\n        result = style(source)\n\n        etree.tostring(result.getroot())\n        \n        source = self.parse(xml)\n        styledoc = self.parse(xslt)\n        style = etree.XSLT(styledoc)\n        result = style(source)\n        \n        etree.tostring(result.getroot())\n\n    def test_xslt_repeat_transform(self):\n        xml = '<a/>'\n        xslt = '''\\\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n    <xsl:template match=\"/\">\n        <response>Some text</response>\n    </xsl:template>\n</xsl:stylesheet>\n'''\n        source = self.parse(xml)\n        styledoc = self.parse(xslt)\n        transform = etree.XSLT(styledoc)\n        result = transform(source)\n        result = transform(source)\n        etree.tostring(result.getroot())\n        result = transform(source)\n        etree.tostring(result.getroot())\n        str(result)\n\n        result1 = transform(source)\n        result2 = transform(source)\n        self.assertEqual(str(result1), str(result2))\n        result = transform(source)\n        str(result)\n\n    def test_xslt_empty(self):\n        # could segfault if result contains \"empty document\"\n        xml = '<blah/>'\n        xslt = '''\n        <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n          <xsl:template match=\"/\" />\n        </xsl:stylesheet>\n        '''\n\n        source = self.parse(xml)\n        styledoc = self.parse(xslt)\n        style = etree.XSLT(styledoc)\n        result = style(source)\n        self.assertEqual('', str(result))\n\n    def test_xslt_message(self):\n        xml = '<blah/>'\n        xslt = '''\n        <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n          <xsl:template match=\"/\">\n            <xsl:message>TEST TEST TEST</xsl:message>\n          </xsl:template>\n        </xsl:stylesheet>\n        '''\n\n        source = self.parse(xml)\n        styledoc = self.parse(xslt)\n        style = etree.XSLT(styledoc)\n        result = style(source)\n        self.assertEqual('', str(result))\n        self.assertTrue(\"TEST TEST TEST\" in [entry.message\n                                          for entry in style.error_log])\n\n    def test_xslt_message_terminate(self):\n        xml = '<blah/>'\n        xslt = '''\n        <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n          <xsl:template match=\"/\">\n            <xsl:message terminate=\"yes\">TEST TEST TEST</xsl:message>\n          </xsl:template>\n        </xsl:stylesheet>\n        '''\n\n        source = self.parse(xml)\n        styledoc = self.parse(xslt)\n        style = etree.XSLT(styledoc)\n\n        self.assertRaises(etree.XSLTApplyError, style, source)\n        self.assertTrue(\"TEST TEST TEST\" in [entry.message\n                                          for entry in style.error_log])\n\n    def test_xslt_shortcut(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <doc>\n    <foo><xsl:value-of select=\"$bar\" /></foo>\n    <foo><xsl:value-of select=\"$baz\" /></foo>\n    </doc>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        result = tree.xslt(style, bar=\"'Bar'\", baz=\"'Baz'\")\n        self.assertEqual(\n            b'<doc><foo>Bar</foo><foo>Baz</foo></doc>',\n            etree.tostring(result.getroot()))\n        \n    def test_multiple_elementrees(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"a\"><A><xsl:apply-templates/></A></xsl:template>\n  <xsl:template match=\"b\"><B><xsl:apply-templates/></B></xsl:template>\n  <xsl:template match=\"c\"><C><xsl:apply-templates/></C></xsl:template>\n</xsl:stylesheet>''')\n\n        self.assertEqual(self._rootstring(tree),\n                          b'<a><b>B</b><c>C</c></a>')\n        result = tree.xslt(style)\n        self.assertEqual(self._rootstring(tree),\n                          b'<a><b>B</b><c>C</c></a>')\n        self.assertEqual(self._rootstring(result),\n                          b'<A><B>B</B><C>C</C></A>')\n\n        b_tree = etree.ElementTree(tree.getroot()[0])\n        self.assertEqual(self._rootstring(b_tree),\n                          b'<b>B</b>')\n        result = b_tree.xslt(style)\n        self.assertEqual(self._rootstring(tree),\n                          b'<a><b>B</b><c>C</c></a>')\n        self.assertEqual(self._rootstring(result),\n                          b'<B>B</B>')\n\n        c_tree = etree.ElementTree(tree.getroot()[1])\n        self.assertEqual(self._rootstring(c_tree),\n                          b'<c>C</c>')\n        result = c_tree.xslt(style)\n        self.assertEqual(self._rootstring(tree),\n                          b'<a><b>B</b><c>C</c></a>')\n        self.assertEqual(self._rootstring(result),\n                          b'<C>C</C>')\n\n    def test_xslt_document_XML(self):\n        # make sure document('') works from parsed strings\n        xslt = etree.XSLT(etree.XML(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>TEXT<xsl:copy-of select=\"document('')//test\"/></test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML('<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                          'test')\n        self.assertEqual(root[0].tag,\n                          'test')\n        self.assertEqual(root[0].text,\n                          'TEXT')\n        self.assertEqual(root[0][0].tag,\n                          '{http://www.w3.org/1999/XSL/Transform}copy-of')\n\n    def test_xslt_document_parse(self):\n        # make sure document('') works from loaded files\n        xslt = etree.XSLT(etree.parse(fileInTestDir(\"test-document.xslt\")))\n        result = xslt(etree.XML('<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                          'test')\n        self.assertEqual(root[0].tag,\n                          '{http://www.w3.org/1999/XSL/Transform}stylesheet')\n\n    def test_xslt_document_elementtree(self):\n        # make sure document('') works from loaded files\n        xslt = etree.XSLT(etree.ElementTree(file=fileInTestDir(\"test-document.xslt\")))\n        result = xslt(etree.XML('<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                          'test')\n        self.assertEqual(root[0].tag,\n                          '{http://www.w3.org/1999/XSL/Transform}stylesheet')\n\n    def test_xslt_document_error(self):\n        xslt = etree.XSLT(etree.XML(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>TEXT<xsl:copy-of select=\"document('uri:__junkfood__is__evil__')//test\"/></test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n\n        errors = None\n        try:\n            xslt(etree.XML('<a/>'))\n        except etree.XSLTApplyError as exc:\n            errors = exc.error_log\n        else:\n            self.assertFalse(True, \"XSLT processing should have failed but didn't\")\n\n        self.assertTrue(len(errors))\n        for error in errors:\n            if ':ERROR:XSLT:' in str(error):\n                break\n        else:\n            self.assertFalse(True, 'No XSLT errors found in error log:\\n%s' % errors)\n\n    def test_xslt_document_XML_resolver(self):\n        # make sure document('') works when custom resolvers are in use\n        assertEqual = self.assertEqual\n        called = {'count' : 0}\n        class TestResolver(etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, 'file://ANYTHING')\n                called['count'] += 1\n                return self.resolve_string('<CALLED/>', context)\n\n        parser = etree.XMLParser()\n        parser.resolvers.add(TestResolver())\n\n        xslt = etree.XSLT(etree.XML(b\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n   xmlns:l=\"local\">\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:for-each select=\"document('')//l:data/l:entry\">\n        <xsl:copy-of select=\"document('file://ANYTHING')\"/>\n        <xsl:copy>\n          <xsl:attribute name=\"value\">\n            <xsl:value-of select=\".\"/>\n          </xsl:attribute>\n        </xsl:copy>\n      </xsl:for-each>\n    </test>\n  </xsl:template>\n  <l:data>\n    <l:entry>A</l:entry>\n    <l:entry>B</l:entry>\n  </l:data>\n</xsl:stylesheet>\n\"\"\", parser))\n\n        self.assertEqual(called['count'], 0)\n        result = xslt(etree.XML('<a/>'))\n        self.assertEqual(called['count'], 1)\n\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                          'test')\n        self.assertEqual(len(root), 4)\n\n        self.assertEqual(root[0].tag,\n                          'CALLED')\n        self.assertEqual(root[1].tag,\n                          '{local}entry')\n        self.assertEqual(root[1].text,\n                          None)\n        self.assertEqual(root[1].get(\"value\"),\n                          'A')\n        self.assertEqual(root[2].tag,\n                          'CALLED')\n        self.assertEqual(root[3].tag,\n                          '{local}entry')\n        self.assertEqual(root[3].text,\n                          None)\n        self.assertEqual(root[3].get(\"value\"),\n                          'B')\n\n    def test_xslt_resolver_url_building(self):\n        assertEqual = self.assertEqual\n        called = {'count' : 0}\n        expected_url = None\n        class TestResolver(etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, expected_url)\n                called['count'] += 1\n                return self.resolve_string('<CALLED/>', context)\n\n        stylesheet_xml = b\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n   xmlns:l=\"local\">\n  <xsl:template match=\"/\">\n    <xsl:copy-of select=\"document('test.xml')\"/>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"\n\n        parser = etree.XMLParser()\n        parser.resolvers.add(TestResolver())\n\n        # test without base_url => relative path only\n        expected_url = 'test.xml'\n        xslt = etree.XSLT(etree.XML(stylesheet_xml, parser))\n\n        self.assertEqual(called['count'], 0)\n        result = xslt(etree.XML('<a/>'))\n        self.assertEqual(called['count'], 1)\n\n        # now the same thing with a stylesheet base URL on the filesystem\n        called['count'] = 0\n        expected_url = 'MY/BASE/test.xml'  # seems to be the same on Windows\n        xslt = etree.XSLT(etree.XML(\n            stylesheet_xml, parser,\n            base_url=os.path.join('MY', 'BASE', 'FILE')))\n\n        self.assertEqual(called['count'], 0)\n        result = xslt(etree.XML('<a/>'))\n        self.assertEqual(called['count'], 1)\n\n        # now the same thing with a stylesheet base URL\n        called['count'] = 0\n        expected_url = 'http://server.com/BASE/DIR/test.xml'\n        xslt = etree.XSLT(etree.XML(\n            stylesheet_xml, parser,\n            base_url='http://server.com/BASE/DIR/FILE'))\n\n        self.assertEqual(called['count'], 0)\n        result = xslt(etree.XML('<a/>'))\n        self.assertEqual(called['count'], 1)\n\n        # now the same thing with a stylesheet base file:// URL\n        called['count'] = 0\n        expected_url = 'file://BASE/DIR/test.xml'\n        xslt = etree.XSLT(etree.XML(\n            stylesheet_xml, parser,\n            base_url='file://BASE/DIR/FILE'))\n\n        self.assertEqual(called['count'], 0)\n        result = xslt(etree.XML('<a/>'))\n        self.assertEqual(called['count'], 1)\n\n    def test_xslt_document_parse_allow(self):\n        access_control = etree.XSLTAccessControl(read_file=True)\n        xslt = etree.XSLT(etree.parse(fileInTestDir(\"test-document.xslt\")),\n                          access_control=access_control)\n        result = xslt(etree.XML('<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                         'test')\n        self.assertEqual(root[0].tag,\n                         '{http://www.w3.org/1999/XSL/Transform}stylesheet')\n\n    def test_xslt_document_parse_deny(self):\n        access_control = etree.XSLTAccessControl(read_file=False)\n        xslt = etree.XSLT(etree.parse(fileInTestDir(\"test-document.xslt\")),\n                          access_control=access_control)\n        self.assertRaises(etree.XSLTApplyError, xslt, etree.XML('<a/>'))\n\n    def test_xslt_document_parse_deny_all(self):\n        access_control = etree.XSLTAccessControl.DENY_ALL\n        xslt = etree.XSLT(etree.parse(fileInTestDir(\"test-document.xslt\")),\n                          access_control=access_control)\n        self.assertRaises(etree.XSLTApplyError, xslt, etree.XML('<a/>'))\n\n    def test_xslt_access_control_repr(self):\n        access_control = etree.XSLTAccessControl.DENY_ALL\n        self.assertTrue(repr(access_control).startswith(type(access_control).__name__))\n        self.assertEqual(repr(access_control), repr(access_control))\n        self.assertNotEqual(repr(etree.XSLTAccessControl.DENY_ALL),\n                            repr(etree.XSLTAccessControl.DENY_WRITE))\n        self.assertNotEqual(repr(etree.XSLTAccessControl.DENY_ALL),\n                            repr(etree.XSLTAccessControl()))\n\n    def test_xslt_move_result(self):\n        root = etree.XML(b'''\\\n        <transform>\n          <widget displayType=\"fieldset\"/>\n        </transform>''')\n\n        xslt = etree.XSLT(etree.XML(b'''\\\n        <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n          <xsl:output method=\"html\" indent=\"no\"/>\n          <xsl:template match=\"/\">\n            <html>\n              <xsl:apply-templates/>\n            </html>\n          </xsl:template>\n\n          <xsl:template match=\"widget\">\n            <xsl:element name=\"{@displayType}\"/>\n          </xsl:template>\n\n        </xsl:stylesheet>'''))\n\n        result = xslt(root[0])\n        root[:] = result.getroot()[:]\n        del root # segfaulted before\n        \n    def test_xslt_pi(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''' % fileInTestDir(\"test1.xslt\"))\n\n        style_root = tree.getroot().getprevious().parseXSL().getroot()\n        self.assertEqual(\"{http://www.w3.org/1999/XSL/Transform}stylesheet\",\n                          style_root.tag)\n\n    def test_xslt_pi_embedded_xmlid(self):\n        # test xml:id dictionary lookup mechanism\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"#style\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n  <xsl:stylesheet version=\"1.0\" xml:id=\"style\"\n      xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template match=\"*\" />\n    <xsl:template match=\"/\">\n      <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n    </xsl:template>\n  </xsl:stylesheet>\n</a>''')\n\n        style_root = tree.getroot().getprevious().parseXSL().getroot()\n        self.assertEqual(\"{http://www.w3.org/1999/XSL/Transform}stylesheet\",\n                          style_root.tag)\n\n        st = etree.XSLT(style_root)\n        res = st(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n    def test_xslt_pi_embedded_id(self):\n        # test XPath lookup mechanism\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"#style\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\" xml:id=\"style\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>\n''')\n\n        tree.getroot().append(style.getroot())\n\n        style_root = tree.getroot().getprevious().parseXSL().getroot()\n        self.assertEqual(\"{http://www.w3.org/1999/XSL/Transform}stylesheet\",\n                          style_root.tag)\n\n        st = etree.XSLT(style_root)\n        res = st(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          str(res))\n\n    def test_xslt_pi_get(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"TEST\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        pi = tree.getroot().getprevious()\n        self.assertEqual(\"TEST\", pi.get(\"href\"))\n\n    def test_xslt_pi_get_all(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"TEST\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        pi = tree.getroot().getprevious()\n        self.assertEqual(\"TEST\", pi.get(\"href\"))\n        self.assertEqual(\"text/xsl\", pi.get(\"type\"))\n        self.assertEqual(None, pi.get(\"motz\"))\n\n    def test_xslt_pi_get_all_reversed(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet href=\"TEST\" type=\"text/xsl\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        pi = tree.getroot().getprevious()\n        self.assertEqual(\"TEST\", pi.get(\"href\"))\n        self.assertEqual(\"text/xsl\", pi.get(\"type\"))\n        self.assertEqual(None, pi.get(\"motz\"))\n\n    def test_xslt_pi_get_unknown(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"TEST\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        pi = tree.getroot().getprevious()\n        self.assertEqual(None, pi.get(\"unknownattribute\"))\n\n    def test_xslt_pi_set_replace(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"TEST\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        pi = tree.getroot().getprevious()\n        self.assertEqual(\"TEST\", pi.get(\"href\"))\n\n        pi.set(\"href\", \"TEST123\")\n        self.assertEqual(\"TEST123\", pi.get(\"href\"))\n\n    def test_xslt_pi_set_new(self):\n        tree = self.parse('''\\\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\"?>\n<a>\n  <b>B</b>\n  <c>C</c>\n</a>''')\n\n        pi = tree.getroot().getprevious()\n        self.assertEqual(None, pi.get(\"href\"))\n\n        pi.set(\"href\", \"TEST\")\n        self.assertEqual(\"TEST\", pi.get(\"href\"))\n\nclass ETreeEXSLTTestCase(HelperTestCase):\n    \"\"\"EXSLT tests\"\"\"\n\n    def test_exslt_str(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:str=\"http://exslt.org/strings\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    exclude-result-prefixes=\"str xsl\">\n  <xsl:template match=\"text()\">\n    <xsl:value-of select=\"str:align(string(.), '***', 'center')\" />\n  </xsl:template>\n  <xsl:template match=\"*\">\n    <xsl:copy>\n      <xsl:apply-templates/>\n    </xsl:copy>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<a><b>*B*</b><c>*C*</c></a>\n''',\n                          str(res))\n\n    def test_exslt_str_attribute_replace(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n          <xsl:stylesheet version = \"1.0\"\n              xmlns:xsl='http://www.w3.org/1999/XSL/Transform'\n              xmlns:str=\"http://exslt.org/strings\"\n              extension-element-prefixes=\"str\">\n\n              <xsl:template match=\"/\">\n                <h1 class=\"{str:replace('abc', 'b', 'x')}\">test</h1>\n              </xsl:template>\n\n          </xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual(str(res), '''\\\n<?xml version=\"1.0\"?>\n<h1 class=\"axc\">test</h1>\n''')\n\n    def test_exslt_math(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:math=\"http://exslt.org/math\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    exclude-result-prefixes=\"math xsl\">\n  <xsl:template match=\"*\">\n    <xsl:copy>\n      <xsl:attribute name=\"pi\">\n        <xsl:value-of select=\"math:constant('PI', count(*)+2)\"/>\n      </xsl:attribute>\n      <xsl:apply-templates/>\n    </xsl:copy>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual('''\\\n<?xml version=\"1.0\"?>\n<a pi=\"3.14\"><b pi=\"3\">B</b><c pi=\"3\">C</c></a>\n''',\n                          str(res))\n\n    def test_exslt_regexp_test(self):\n        xslt = etree.XSLT(etree.XML(b\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\">\n    <test><xsl:copy-of select=\"*[regexp:test(string(.), '8.')]\"/></test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a><b>123</b><b>098</b><b>987</b></a>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                          'test')\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag,\n                          'b')\n        self.assertEqual(root[0].text,\n                          '987')\n\n    def test_exslt_regexp_replace(self):\n        xslt = etree.XSLT(etree.XML(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\">\n    <test>\n      <xsl:copy-of select=\"regexp:replace(string(.), 'd.', '',   'XX')\"/>\n      <xsl:text>-</xsl:text>\n      <xsl:copy-of select=\"regexp:replace(string(.), 'd.', 'gi', 'XX')\"/>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a>abdCdEeDed</a>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,\n                          'test')\n        self.assertEqual(len(root), 0)\n        self.assertEqual(root.text, 'abXXdEeDed-abXXXXeXXd')\n\n    def test_exslt_regexp_match(self):\n        xslt = etree.XSLT(etree.XML(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\">\n    <test>\n      <test1><xsl:copy-of  select=\"regexp:match(string(.), 'd.')\"/></test1>\n      <test2><xsl:copy-of  select=\"regexp:match(string(.), 'd.', 'g')\"/></test2>\n      <test2i><xsl:copy-of select=\"regexp:match(string(.), 'd.', 'gi')\"/></test2i>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a>abdCdEeDed</a>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,  'test')\n        self.assertEqual(len(root), 3)\n\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, 'match')\n        self.assertEqual(root[0][0].text, 'dC')\n\n        self.assertEqual(len(root[1]), 2)\n        self.assertEqual(root[1][0].tag, 'match')\n        self.assertEqual(root[1][0].text, 'dC')\n        self.assertEqual(root[1][1].tag, 'match')\n        self.assertEqual(root[1][1].text, 'dE')\n\n        self.assertEqual(len(root[2]), 3)\n        self.assertEqual(root[2][0].tag, 'match')\n        self.assertEqual(root[2][0].text, 'dC')\n        self.assertEqual(root[2][1].tag, 'match')\n        self.assertEqual(root[2][1].text, 'dE')\n        self.assertEqual(root[2][2].tag, 'match')\n        self.assertEqual(root[2][2].text, 'De')\n\n    def test_exslt_regexp_match_groups(self):\n        xslt = etree.XSLT(etree.XML(b\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:for-each select=\"regexp:match(\n            '123abc567', '([0-9]+)([a-z]+)([0-9]+)' )\">\n        <test1><xsl:value-of select=\".\"/></test1>\n      </xsl:for-each>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,  'test')\n        self.assertEqual(len(root), 4)\n\n        self.assertEqual(root[0].text, \"123abc567\")\n        self.assertEqual(root[1].text, \"123\")\n        self.assertEqual(root[2].text, \"abc\")\n        self.assertEqual(root[3].text, \"567\")\n\n    def test_exslt_regexp_match1(self):\n        # taken from http://www.exslt.org/regexp/functions/match/index.html\n        xslt = etree.XSLT(etree.XML(br\"\"\"\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:for-each select=\"regexp:match(\n            'http://www.bayes.co.uk/xml/index.xml?/xml/utils/rechecker.xml',\n            '(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)')\">\n        <test1><xsl:value-of select=\".\"/></test1>\n      </xsl:for-each>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,  'test')\n        self.assertEqual(len(root), 5)\n\n        self.assertEqual(\n            root[0].text,\n            \"http://www.bayes.co.uk/xml/index.xml?/xml/utils/rechecker.xml\")\n        self.assertEqual(\n            root[1].text,\n            \"http\")\n        self.assertEqual(\n            root[2].text,\n            \"www.bayes.co.uk\")\n        self.assertFalse(root[3].text)\n        self.assertEqual(\n            root[4].text,\n            \"/xml/index.xml?/xml/utils/rechecker.xml\")\n\n    def test_exslt_regexp_match2(self):\n        # taken from http://www.exslt.org/regexp/functions/match/index.html\n        xslt = etree.XSLT(self.parse(\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:for-each select=\"regexp:match(\n            'This is a test string', '(\\\\w+)', 'g')\">\n        <test1><xsl:value-of select=\".\"/></test1>\n      </xsl:for-each>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,  'test')\n        self.assertEqual(len(root), 5)\n\n        self.assertEqual(root[0].text, \"This\")\n        self.assertEqual(root[1].text, \"is\")\n        self.assertEqual(root[2].text, \"a\")\n        self.assertEqual(root[3].text, \"test\")\n        self.assertEqual(root[4].text, \"string\")\n\n    def _test_exslt_regexp_match3(self):\n        # taken from http://www.exslt.org/regexp/functions/match/index.html\n        # THIS IS NOT SUPPORTED!\n        xslt = etree.XSLT(etree.XML(b\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:for-each select=\"regexp:match(\n            'This is a test string', '([a-z])+ ', 'g')\">\n        <test1><xsl:value-of select=\".\"/></test1>\n      </xsl:for-each>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,  'test')\n        self.assertEqual(len(root), 4)\n\n        self.assertEqual(root[0].text, \"his\")\n        self.assertEqual(root[1].text, \"is\")\n        self.assertEqual(root[2].text, \"a\")\n        self.assertEqual(root[3].text, \"test\")\n\n    def _test_exslt_regexp_match4(self):\n        # taken from http://www.exslt.org/regexp/functions/match/index.html\n        # THIS IS NOT SUPPORTED!\n        xslt = etree.XSLT(etree.XML(b\"\"\"\\\n<xsl:stylesheet version=\"1.0\"\n   xmlns:regexp=\"http://exslt.org/regular-expressions\"\n   xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"/\">\n    <test>\n      <xsl:for-each select=\"regexp:match(\n            'This is a test string', '([a-z])+ ', 'gi')\">\n        <test1><xsl:value-of select=\".\"/></test1>\n      </xsl:for-each>\n    </test>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\"))\n        result = xslt(etree.XML(b'<a/>'))\n        root = result.getroot()\n        self.assertEqual(root.tag,  'test')\n        self.assertEqual(len(root), 4)\n\n        self.assertEqual(root[0].text, \"This\")\n        self.assertEqual(root[1].text, \"is\")\n        self.assertEqual(root[2].text, \"a\")\n        self.assertEqual(root[3].text, \"test\")\n\n\nclass ETreeXSLTExtFuncTestCase(HelperTestCase):\n    \"\"\"Tests for XPath extension functions in XSLT.\"\"\"\n\n    def test_extensions1(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"a\"><A><xsl:value-of select=\"myns:mytext(b)\"/></A></xsl:template>\n</xsl:stylesheet>''')\n\n        def mytext(ctxt, values):\n            return 'X' * len(values)\n\n        result = tree.xslt(style, {('testns', 'mytext') : mytext})\n        self.assertEqual(self._rootstring(result),\n                          b'<A>X</A>')\n\n    def test_extensions2(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"a\"><A><xsl:value-of select=\"myns:mytext(b)\"/></A></xsl:template>\n</xsl:stylesheet>''')\n\n        def mytext(ctxt, values):\n            return 'X' * len(values)\n\n        namespace = etree.FunctionNamespace('testns')\n        namespace['mytext'] = mytext\n\n        result = tree.xslt(style)\n        self.assertEqual(self._rootstring(result),\n                          b'<A>X</A>')\n\n    def test_variable_result_tree_fragment(self):\n        tree = self.parse('<a><b>B</b><b/></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <xsl:variable name=\"content\">\n       <xsl:apply-templates/>\n    </xsl:variable>\n    <A><xsl:value-of select=\"myns:mytext($content)\"/></A>\n  </xsl:template>\n  <xsl:template match=\"b\"><xsl:copy>BBB</xsl:copy></xsl:template>\n</xsl:stylesheet>''')\n\n        def mytext(ctxt, values):\n            for value in values:\n                self.assertTrue(hasattr(value, 'tag'),\n                             \"%s is not an Element\" % type(value))\n                self.assertEqual(value.tag, 'b')\n                self.assertEqual(value.text, 'BBB')\n            return 'X'.join([el.tag for el in values])\n\n        namespace = etree.FunctionNamespace('testns')\n        namespace['mytext'] = mytext\n\n        result = tree.xslt(style)\n        self.assertEqual(self._rootstring(result),\n                         b'<A>bXb</A>')\n\n    def test_xpath_on_context_node(self):\n        tree = self.parse('<a><b>B<c/>C</b><b/></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"b\">\n    <A><xsl:value-of select=\"myns:myext()\"/></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        def extfunc(ctxt):\n            text_content = ctxt.context_node.xpath('text()')\n            return 'x'.join(text_content)\n\n        namespace = etree.FunctionNamespace('testns')\n        namespace['myext'] = extfunc\n\n        result = tree.xslt(style)\n        self.assertEqual(self._rootstring(result),\n                         b'<A>BxC</A>')\n\n    def test_xpath_on_foreign_context_node(self):\n        # LP ticket 1354652\n        class Resolver(etree.Resolver):\n            def resolve(self, system_url, public_id, context):\n                assert system_url == 'extdoc.xml'\n                return self.resolve_string(b'<a><b>B<c/>C</b><b/></a>', context)\n\n        parser = etree.XMLParser()\n        parser.resolvers.add(Resolver())\n\n        tree = self.parse(b'<a><b/><b/></a>')\n        transform = etree.XSLT(self.parse(b'''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:mypre=\"testns\"\n    exclude-result-prefixes=\"mypre\">\n  <xsl:template match=\"b\">\n    <B><xsl:value-of select=\"mypre:myext()\"/></B>\n  </xsl:template>\n  <xsl:template match=\"a\">\n    <A><xsl:apply-templates select=\"document('extdoc.xml')//b\" /></A>\n  </xsl:template>\n</xsl:stylesheet>''', parser=parser))\n\n        def extfunc(ctxt):\n            text_content = ctxt.context_node.xpath('text()')\n            return 'x'.join(text_content)\n\n        namespace = etree.FunctionNamespace('testns')\n        namespace['myext'] = extfunc\n\n        result = transform(tree)\n        self.assertEqual(self._rootstring(result),\n                         b'<A><B>BxC</B><B/></A>')\n\n\nclass ETreeXSLTExtElementTestCase(HelperTestCase):\n    \"\"\"Tests for extension elements in XSLT.\"\"\"\n\n    def test_extension_element(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                child = etree.Element(self_node.text)\n                child.text = 'X'\n                output_parent.append(child)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A><b>X</b></A>')\n\n    def test_extension_element_doc_context(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"/\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        tags = []\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                tags.append(input_node.tag)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(tags, ['a'])\n\n    def test_extension_element_comment_pi_context(self):\n        tree = self.parse('<?test toast?><a><!--a comment--><?another pi?></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"/\">\n    <ROOT><xsl:apply-templates /></ROOT>\n  </xsl:template>\n  <xsl:template match=\"comment()\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n  <xsl:template match=\"processing-instruction()\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        text = []\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                text.append(input_node.text)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(text, ['toast', 'a comment', 'pi'])\n\n    def _test_extension_element_attribute_context(self):\n        # currently not supported\n        tree = self.parse('<a test=\"A\"><b attr=\"B\"/></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"@test\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n  <xsl:template match=\"@attr\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        text = []\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, attr_value, output_parent):\n                text.append(attr_value)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(text, ['A', 'B'])\n\n    def test_extension_element_content(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext><x>X</x><y>Y</y><z/></myns:myext></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                output_parent.extend(list(self_node)[1:])\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A><y>Y</y><z/></A>')\n\n    def test_extension_element_apply_templates(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext><x>X</x><y>Y</y><z/></myns:myext></A>\n  </xsl:template>\n  <xsl:template match=\"x\" />\n  <xsl:template match=\"z\">XYZ</xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                for child in self_node:\n                    for result in self.apply_templates(context, child):\n                        if isinstance(result, str):\n                            el = etree.Element(\"T\")\n                            el.text = result\n                        else:\n                            el = result\n                        output_parent.append(el)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A><T>Y</T><T>XYZ</T></A>')\n\n    def test_extension_element_apply_templates_elements_only(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext><x>X</x><y>Y</y><z/></myns:myext></A>\n  </xsl:template>\n  <xsl:template match=\"x\"><X/></xsl:template>\n  <xsl:template match=\"z\">XYZ</xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                for child in self_node:\n                    for result in self.apply_templates(context, child,\n                                                       elements_only=True):\n                        assert not isinstance(result, str)\n                        output_parent.append(result)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A><X/></A>')\n\n    def test_extension_element_apply_templates_remove_blank_text(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext><x>X</x><y>Y</y><z/></myns:myext></A>\n  </xsl:template>\n  <xsl:template match=\"x\"><X/></xsl:template>\n  <xsl:template match=\"y\"><xsl:text>   </xsl:text></xsl:template>\n  <xsl:template match=\"z\">XYZ</xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                for child in self_node:\n                    for result in self.apply_templates(context, child,\n                                                       remove_blank_text=True):\n                        if isinstance(result, str):\n                            assert result.strip()\n                            el = etree.Element(\"T\")\n                            el.text = result\n                        else:\n                            el = result\n                        output_parent.append(el)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A><X/><T>XYZ</T></A>')\n\n    def test_extension_element_apply_templates_target_node(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext><x>X</x><y>Y</y><z/></myns:myext></A>\n  </xsl:template>\n  <xsl:template match=\"x\" />\n  <xsl:template match=\"z\">XYZ</xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                for child in self_node:\n                    self.apply_templates(context, child, output_parent)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A>YXYZ</A>')\n\n    def test_extension_element_apply_templates_target_node_doc(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <myns:myext><x>X</x><y>Y</y><z/></myns:myext>\n  </xsl:template>\n  <xsl:template match=\"x\"><xsl:processing-instruction name=\"test\">TEST</xsl:processing-instruction></xsl:template>\n  <xsl:template match=\"y\"><Y>XYZ</Y></xsl:template>\n  <xsl:template match=\"z\"><xsl:comment>TEST</xsl:comment></xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                for child in self_node:\n                    self.apply_templates(context, child, output_parent)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(etree.tostring(result),\n                          b'<?test TEST?><Y>XYZ</Y><!--TEST-->')\n\n    def test_extension_element_process_children(self):\n        tree = self.parse('<a><b>E</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <xsl:variable name=\"testvar\">yo</xsl:variable>\n    <A>\n      <myns:myext>\n        <xsl:attribute name=\"attr\">\n          <xsl:value-of select=\"$testvar\" />\n        </xsl:attribute>\n        <B>\n          <xsl:choose>\n            <xsl:when test=\"1 = 2\"><C/></xsl:when>\n            <xsl:otherwise><D><xsl:value-of select=\"b/text()\" /></D></xsl:otherwise>\n          </xsl:choose>\n        </B>\n      </myns:myext>\n    </A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                el = etree.Element('MY')\n                self.process_children(context, el)\n                output_parent.append(el)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A><MYattr=\"yo\"><B><D>E</D></B></MY></A>')\n\n    def test_extension_element_process_children_to_append_only(self):\n        tree = self.parse('<a/>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <myns:myext>\n      <A/>\n    </myns:myext>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                self.process_children(context, output_parent)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<A/>')\n\n    def test_extension_element_process_children_to_read_only_raise(self):\n        tree = self.parse('<a/>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <myns:myext>\n      <A/>\n    </myns:myext>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                self.process_children(context, self_node)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        self.assertRaises(TypeError, tree.xslt, style, extensions=extensions)\n\n    def test_extension_element_process_children_with_subextension_element(self):\n        tree = self.parse('<a/>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <myns:myext>\n      <A><myns:myext><B/></myns:myext></A>\n    </myns:myext>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyExt(etree.XSLTExtension):\n            callback_call_counter = 0\n            def execute(self, context, self_node, input_node, output_parent):\n                self.callback_call_counter += 1\n                el = etree.Element('MY', n=str(self.callback_call_counter))\n                self.process_children(context, el)\n                output_parent.append(el)\n\n        extensions = { ('testns', 'myext') : MyExt() }\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(self._rootstring(result),\n                          b'<MYn=\"1\"><A><MYn=\"2\"><B/></MY></A></MY>')\n\n    def test_extension_element_raise(self):\n        tree = self.parse('<a><b>B</b></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns:myns=\"testns\"\n    extension-element-prefixes=\"myns\"\n    exclude-result-prefixes=\"myns\">\n  <xsl:template match=\"a\">\n    <A><myns:myext>b</myns:myext></A>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        class MyError(Exception):\n            pass\n\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                raise MyError(\"expected!\")\n\n        extensions = { ('testns', 'myext') : MyExt() }\n        self.assertRaises(MyError, tree.xslt, style, extensions=extensions)\n\n    # FIXME: DISABLED - implementation seems to be broken\n    # if someone cares enough about this feature, I take pull requests that fix it.\n    def _test_multiple_extension_elements_with_output_parent(self):\n        tree = self.parse(\"\"\"\\\n<text>\n  <par>This is <format>arbitrary</format> text in a paragraph</par>\n</text>\"\"\")\n        style = self.parse(\"\"\"\\\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:my=\"my\" extension-element-prefixes=\"my\" version=\"1.0\">\n  <xsl:template match=\"par\">\n    <my:par><xsl:apply-templates /></my:par>\n  </xsl:template>\n  <xsl:template match=\"format\">\n    <my:format><xsl:apply-templates /></my:format>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\")\n        test = self\n        calls = []\n\n        class ExtMyPar(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                calls.append('par')\n                p = etree.Element(\"p\")\n                p.attrib[\"style\"] = \"color:red\"\n                self.process_children(context, p)\n                output_parent.append(p)\n\n        class ExtMyFormat(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                calls.append('format')\n                content = self.process_children(context)\n                test.assertEqual(1, len(content))\n                test.assertEqual('arbitrary', content[0])\n                test.assertEqual('This is ', output_parent.text)\n                output_parent.text += '*-%s-*' % content[0]\n\n        extensions = {(\"my\", \"par\"): ExtMyPar(), (\"my\", \"format\"): ExtMyFormat()}\n        transform = etree.XSLT(style, extensions=extensions)\n        result = transform(tree)\n        self.assertEqual(['par', 'format'], calls)\n        self.assertEqual(\n            b'<p style=\"color:red\">This is *-arbitrary-* text in a paragraph</p>\\n',\n            etree.tostring(result))\n\n    def test_extensions_nsmap(self):\n        tree = self.parse(\"\"\"\\\n<root>\n  <inner xmlns:sha256=\"http://www.w3.org/2001/04/xmlenc#sha256\">\n    <data>test</data>\n  </inner>\n</root>\n\"\"\")\n        style = self.parse(\"\"\"\\\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:my=\"extns\" extension-element-prefixes=\"my\" version=\"1.0\">\n  <xsl:template match=\"node()|@*\">\n    <xsl:copy>\n      <xsl:apply-templates select=\"node()|@*\"/>\n    </xsl:copy>\n  </xsl:template>\n\n  <xsl:template match=\"data\">\n    <my:show-nsmap/>\n  </xsl:template>\n</xsl:stylesheet>\n\"\"\")\n        class MyExt(etree.XSLTExtension):\n            def execute(self, context, self_node, input_node, output_parent):\n                output_parent.text = str(input_node.nsmap)\n\n        extensions = {('extns', 'show-nsmap'): MyExt()}\n\n        result = tree.xslt(style, extensions=extensions)\n        self.assertEqual(etree.tostring(result, pretty_print=True), b\"\"\"\\\n<root>\n  <inner xmlns:sha256=\"http://www.w3.org/2001/04/xmlenc#sha256\">{'sha256': 'http://www.w3.org/2001/04/xmlenc#sha256'}\n  </inner>\n</root>\n\"\"\")\n\n\n\nclass Py3XSLTTestCase(HelperTestCase):\n    \"\"\"XSLT tests for etree under Python 3\"\"\"\n\n    def test_xslt_result_bytes(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual(b'''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          bytes(res))\n\n    def test_xslt_result_bytearray(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual(b'''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          bytearray(res))\n\n    def test_xslt_result_memoryview(self):\n        tree = self.parse('<a><b>B</b><c>C</c></a>')\n        style = self.parse('''\\\n<xsl:stylesheet version=\"1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"*\" />\n  <xsl:template match=\"/\">\n    <foo><xsl:value-of select=\"/a/b/text()\" /></foo>\n  </xsl:template>\n</xsl:stylesheet>''')\n\n        st = etree.XSLT(style)\n        res = st(tree)\n        self.assertEqual(b'''\\\n<?xml version=\"1.0\"?>\n<foo>B</foo>\n''',\n                          bytes(memoryview(res)))\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXSLTTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeEXSLTTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXSLTExtFuncTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(ETreeXSLTExtElementTestCase)])\n    suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(Py3XSLTTestCase)])\n    suite.addTests(\n        [make_doctest('extensions.txt')])\n    suite.addTests(\n        [make_doctest('xpathxslt.txt')])\n    return suite\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n", "src/lxml/isoschematron/__init__.py": "\"\"\"The ``lxml.isoschematron`` package implements ISO Schematron support on top\nof the pure-xslt 'skeleton' implementation.\n\"\"\"\n\nimport sys\nimport os.path\nfrom lxml import etree as _etree # due to validator __init__ signature\n\n\n# some compat stuff, borrowed from lxml.html\ntry:\n    unicode\nexcept NameError:\n    # Python 3\n    unicode = str\ntry:\n    basestring\nexcept NameError:\n    # Python 3\n    basestring = str\n\n\n__all__ = ['extract_xsd', 'extract_rng', 'iso_dsdl_include',\n           'iso_abstract_expand', 'iso_svrl_for_xslt1',\n           'svrl_validation_errors', 'schematron_schema_valid',\n           'stylesheet_params', 'Schematron']\n\n\n# some namespaces\n#FIXME: Maybe lxml should provide a dedicated place for common namespace\n#FIXME: definitions?\nXML_SCHEMA_NS = \"http://www.w3.org/2001/XMLSchema\"\nRELAXNG_NS = \"http://relaxng.org/ns/structure/1.0\"\nSCHEMATRON_NS = \"http://purl.oclc.org/dsdl/schematron\"\nSVRL_NS = \"http://purl.oclc.org/dsdl/svrl\"\n\n\n# some helpers\n_schematron_root = '{%s}schema' % SCHEMATRON_NS\n_xml_schema_root = '{%s}schema' % XML_SCHEMA_NS\n_resources_dir = os.path.join(os.path.dirname(__file__), 'resources')\n\n\n# the iso-schematron skeleton implementation steps aka xsl transformations\nextract_xsd = _etree.XSLT(_etree.parse(\n    os.path.join(_resources_dir, 'xsl', 'XSD2Schtrn.xsl')))\nextract_rng = _etree.XSLT(_etree.parse(\n    os.path.join(_resources_dir, 'xsl', 'RNG2Schtrn.xsl')))\niso_dsdl_include = _etree.XSLT(_etree.parse(\n    os.path.join(_resources_dir, 'xsl', 'iso-schematron-xslt1',\n                 'iso_dsdl_include.xsl')))\niso_abstract_expand = _etree.XSLT(_etree.parse(\n    os.path.join(_resources_dir, 'xsl', 'iso-schematron-xslt1',\n                 'iso_abstract_expand.xsl')))\niso_svrl_for_xslt1 = _etree.XSLT(_etree.parse(\n    os.path.join(_resources_dir,\n                 'xsl', 'iso-schematron-xslt1', 'iso_svrl_for_xslt1.xsl')))\n\n\n# svrl result accessors\nsvrl_validation_errors = _etree.XPath(\n    '//svrl:failed-assert', namespaces={'svrl': SVRL_NS})\n\n# RelaxNG validator for schematron schemas\nschematron_schema_valid_supported = False\ntry:\n    schematron_schema_valid = _etree.RelaxNG(\n        file=os.path.join(_resources_dir, 'rng', 'iso-schematron.rng'))\n    schematron_schema_valid_supported = True\nexcept _etree.RelaxNGParseError:\n    # Some distributions delete the file due to licensing issues.\n    def schematron_schema_valid(arg):\n        raise NotImplementedError(\"Validating the ISO schematron requires iso-schematron.rng\")\n\n\ndef stylesheet_params(**kwargs):\n    \"\"\"Convert keyword args to a dictionary of stylesheet parameters.\n    XSL stylesheet parameters must be XPath expressions, i.e.:\n\n    * string expressions, like \"'5'\"\n    * simple (number) expressions, like \"5\"\n    * valid XPath expressions, like \"/a/b/text()\"\n\n    This function converts native Python keyword arguments to stylesheet\n    parameters following these rules:\n    If an arg is a string wrap it with XSLT.strparam().\n    If an arg is an XPath object use its path string.\n    If arg is None raise TypeError.\n    Else convert arg to string.\n    \"\"\"\n    result = {}\n    for key, val in kwargs.items():\n        if isinstance(val, basestring):\n            val = _etree.XSLT.strparam(val)\n        elif val is None:\n            raise TypeError('None not allowed as a stylesheet parameter')\n        elif not isinstance(val, _etree.XPath):\n            val = unicode(val)\n        result[key] = val\n    return result\n\n\n# helper function for use in Schematron __init__\ndef _stylesheet_param_dict(paramsDict, kwargsDict):\n    \"\"\"Return a copy of paramsDict, updated with kwargsDict entries, wrapped as\n    stylesheet arguments.\n    kwargsDict entries with a value of None are ignored.\n    \"\"\"\n    # beware of changing mutable default arg\n    paramsDict = dict(paramsDict)\n    for k, v in kwargsDict.items():\n        if v is not None: # None values do not override\n            paramsDict[k] = v\n    paramsDict = stylesheet_params(**paramsDict)\n    return paramsDict\n\n\nclass Schematron(_etree._Validator):\n    \"\"\"An ISO Schematron validator.\n\n    Pass a root Element or an ElementTree to turn it into a validator.\n    Alternatively, pass a filename as keyword argument 'file' to parse from\n    the file system.\n\n    Schematron is a less well known, but very powerful schema language.\n    The main idea is to use the capabilities of XPath to put restrictions on\n    the structure and the content of XML documents.\n\n    The standard behaviour is to fail on ``failed-assert`` findings only\n    (``ASSERTS_ONLY``).  To change this, you can either pass a report filter\n    function to the ``error_finder`` parameter (e.g. ``ASSERTS_AND_REPORTS``\n    or a custom ``XPath`` object), or subclass isoschematron.Schematron for\n    complete control of the validation process.\n\n    Built on the Schematron language 'reference' skeleton pure-xslt\n    implementation, the validator is created as an XSLT 1.0 stylesheet using\n    these steps:\n\n     0) (Extract from XML Schema or RelaxNG schema)\n     1) Process inclusions\n     2) Process abstract patterns\n     3) Compile the schematron schema to XSLT\n\n    The ``include`` and ``expand`` keyword arguments can be used to switch off\n    steps 1) and 2).\n    To set parameters for steps 1), 2) and 3) hand parameter dictionaries to the\n    keyword arguments ``include_params``, ``expand_params`` or\n    ``compile_params``.\n    For convenience, the compile-step parameter ``phase`` is also exposed as a\n    keyword argument ``phase``. This takes precedence if the parameter is also\n    given in the parameter dictionary.\n\n    If ``store_schematron`` is set to True, the (included-and-expanded)\n    schematron document tree is stored and available through the ``schematron``\n    property.\n    If ``store_xslt`` is set to True, the validation XSLT document tree will be\n    stored and can be retrieved through the ``validator_xslt`` property.\n    With ``store_report`` set to True (default: False), the resulting validation\n    report document gets stored and can be accessed as the ``validation_report``\n    property.\n\n    If ``validate_schema`` is set to False, the validation of the schema file\n    itself is disabled.  Validation happens by default after building the full\n    schema, unless the schema validation file cannot be found at import time,\n    in which case the validation gets disabled.  Some lxml distributions exclude\n    this file due to licensing issues.  ISO-Schematron validation can then still\n    be used normally, but the schemas themselves cannot be validated.\n\n    Here is a usage example::\n\n      >>> from lxml import etree\n      >>> from lxml.isoschematron import Schematron\n\n      >>> schematron = Schematron(etree.XML('''\n      ... <schema xmlns=\"http://purl.oclc.org/dsdl/schematron\" >\n      ...   <pattern id=\"id_only_attribute\">\n      ...     <title>id is the only permitted attribute name</title>\n      ...     <rule context=\"*\">\n      ...       <report test=\"@*[not(name()='id')]\">Attribute\n      ...         <name path=\"@*[not(name()='id')]\"/> is forbidden<name/>\n      ...       </report>\n      ...     </rule>\n      ...   </pattern>\n      ... </schema>'''),\n      ... error_finder=Schematron.ASSERTS_AND_REPORTS)\n\n      >>> xml = etree.XML('''\n      ... <AAA name=\"aaa\">\n      ...   <BBB id=\"bbb\"/>\n      ...   <CCC color=\"ccc\"/>\n      ... </AAA>\n      ... ''')\n\n      >>> schematron.validate(xml)\n      False\n\n      >>> xml = etree.XML('''\n      ... <AAA id=\"aaa\">\n      ...   <BBB id=\"bbb\"/>\n      ...   <CCC/>\n      ... </AAA>\n      ... ''')\n\n      >>> schematron.validate(xml)\n      True\n    \"\"\"\n\n    # libxml2 error categorization for validation errors\n    _domain = _etree.ErrorDomains.SCHEMATRONV\n    _level = _etree.ErrorLevels.ERROR\n    _error_type = _etree.ErrorTypes.SCHEMATRONV_ASSERT\n\n    # convenience definitions for common behaviours\n    ASSERTS_ONLY = svrl_validation_errors  # Default\n    ASSERTS_AND_REPORTS = _etree.XPath(\n        '//svrl:failed-assert | //svrl:successful-report',\n        namespaces={'svrl': SVRL_NS})\n\n    def _extract(self, element):\n        \"\"\"Extract embedded schematron schema from non-schematron host schema.\n        This method will only be called by __init__ if the given schema document\n        is not a schematron schema by itself.\n        Must return a schematron schema document tree or None.\n        \"\"\"\n        schematron = None\n        if element.tag == _xml_schema_root:\n            schematron = self._extract_xsd(element)\n        elif element.nsmap.get(element.prefix) == RELAXNG_NS:\n            # RelaxNG does not have a single unique root element\n            schematron = self._extract_rng(element)\n        return schematron\n\n    # customization points\n    # etree.XSLT objects that provide the extract, include, expand, compile\n    # steps\n    _extract_xsd = extract_xsd\n    _extract_rng = extract_rng\n    _include = iso_dsdl_include\n    _expand = iso_abstract_expand\n    _compile = iso_svrl_for_xslt1\n\n    # etree.xpath object that determines input document validity when applied to\n    # the svrl result report; must return a list of result elements (empty if\n    # valid)\n    _validation_errors = ASSERTS_ONLY\n\n    def __init__(self, etree=None, file=None, include=True, expand=True,\n                 include_params={}, expand_params={}, compile_params={},\n                 store_schematron=False, store_xslt=False, store_report=False,\n                 phase=None, error_finder=ASSERTS_ONLY,\n                 validate_schema=schematron_schema_valid_supported):\n        super().__init__()\n\n        self._store_report = store_report\n        self._schematron = None\n        self._validator_xslt = None\n        self._validation_report = None\n        if error_finder is not self.ASSERTS_ONLY:\n            self._validation_errors = error_finder\n\n        # parse schema document, may be a schematron schema or an XML Schema or\n        # a RelaxNG schema with embedded schematron rules\n        root = None\n        try:\n            if etree is not None:\n                if _etree.iselement(etree):\n                    root = etree\n                else:\n                    root = etree.getroot()\n            elif file is not None:\n                root = _etree.parse(file).getroot()\n        except Exception:\n            raise _etree.SchematronParseError(\n                \"No tree or file given: %s\" % sys.exc_info()[1])\n        if root is None:\n            raise ValueError(\"Empty tree\")\n        if root.tag == _schematron_root:\n            schematron = root\n        else:\n            schematron = self._extract(root)\n        if schematron is None:\n            raise _etree.SchematronParseError(\n                \"Document is not a schematron schema or schematron-extractable\")\n        # perform the iso-schematron skeleton implementation steps to get a\n        # validating xslt\n        if include:\n            schematron = self._include(schematron, **include_params)\n        if expand:\n            schematron = self._expand(schematron, **expand_params)\n        if validate_schema and not schematron_schema_valid(schematron):\n            raise _etree.SchematronParseError(\n                \"invalid schematron schema: %s\" %\n                schematron_schema_valid.error_log)\n        if store_schematron:\n            self._schematron = schematron\n        # add new compile keyword args here if exposing them\n        compile_kwargs = {'phase': phase}\n        compile_params = _stylesheet_param_dict(compile_params, compile_kwargs)\n        validator_xslt = self._compile(schematron, **compile_params)\n        if store_xslt:\n            self._validator_xslt = validator_xslt\n        self._validator = _etree.XSLT(validator_xslt)\n\n    def __call__(self, etree):\n        \"\"\"Validate doc using Schematron.\n\n        Returns true if document is valid, false if not.\n        \"\"\"\n        self._clear_error_log()\n        result = self._validator(etree)\n        if self._store_report:\n            self._validation_report = result\n        errors = self._validation_errors(result)\n        if errors:\n            if _etree.iselement(etree):\n                fname = etree.getroottree().docinfo.URL or '<file>'\n            else:\n                fname = etree.docinfo.URL or '<file>'\n            for error in errors:\n                # Does svrl report the line number, anywhere? Don't think so.\n                self._append_log_message(\n                    domain=self._domain, type=self._error_type,\n                    level=self._level, line=0,\n                    message=_etree.tostring(error, encoding='unicode'),\n                    filename=fname)\n            return False\n        return True\n\n    @property\n    def schematron(self):\n        \"\"\"ISO-schematron schema document (None if object has been initialized\n        with store_schematron=False).\n        \"\"\"\n        return self._schematron\n\n    @property\n    def validator_xslt(self):\n        \"\"\"ISO-schematron skeleton implementation XSLT validator document (None\n        if object has been initialized with store_xslt=False).\n        \"\"\"\n        return self._validator_xslt\n\n    @property\n    def validation_report(self):\n        \"\"\"ISO-schematron validation result report (None if result-storing has\n        been turned off).\n        \"\"\"\n        return self._validation_report\n", "src/lxml/includes/__init__.py": "", "src/lxml/html/html5parser.py": "\"\"\"\nAn interface to html5lib that mimics the lxml.html interface.\n\"\"\"\nimport sys\nimport string\n\nfrom html5lib import HTMLParser as _HTMLParser\nfrom html5lib.treebuilders.etree_lxml import TreeBuilder\nfrom lxml import etree\nfrom lxml.html import Element, XHTML_NAMESPACE, _contains_block_level_tag\n\n# python3 compatibility\ntry:\n    _strings = basestring\nexcept NameError:\n    _strings = (bytes, str)\ntry:\n    from urllib2 import urlopen\nexcept ImportError:\n    from urllib.request import urlopen\ntry:\n    from urlparse import urlparse\nexcept ImportError:\n    from urllib.parse import urlparse\n\n\nclass HTMLParser(_HTMLParser):\n    \"\"\"An html5lib HTML parser with lxml as tree.\"\"\"\n\n    def __init__(self, strict=False, **kwargs):\n        _HTMLParser.__init__(self, strict=strict, tree=TreeBuilder, **kwargs)\n\n\ntry:\n    from html5lib import XHTMLParser as _XHTMLParser\nexcept ImportError:\n    pass\nelse:\n    class XHTMLParser(_XHTMLParser):\n        \"\"\"An html5lib XHTML Parser with lxml as tree.\"\"\"\n\n        def __init__(self, strict=False, **kwargs):\n            _XHTMLParser.__init__(self, strict=strict, tree=TreeBuilder, **kwargs)\n\n    xhtml_parser = XHTMLParser()\n\n\ndef _find_tag(tree, tag):\n    elem = tree.find(tag)\n    if elem is not None:\n        return elem\n    return tree.find('{%s}%s' % (XHTML_NAMESPACE, tag))\n\n\ndef document_fromstring(html, guess_charset=None, parser=None):\n    \"\"\"\n    Parse a whole document into a string.\n\n    If `guess_charset` is true, or if the input is not Unicode but a\n    byte string, the `chardet` library will perform charset guessing\n    on the string.\n    \"\"\"\n    if not isinstance(html, _strings):\n        raise TypeError('string required')\n\n    if parser is None:\n        parser = html_parser\n\n    options = {}\n    if guess_charset is None and isinstance(html, bytes):\n        # html5lib does not accept useChardet as an argument, if it\n        # detected the html argument would produce unicode objects.\n        guess_charset = True\n    if guess_charset is not None:\n        options['useChardet'] = guess_charset\n    return parser.parse(html, **options).getroot()\n\n\ndef fragments_fromstring(html, no_leading_text=False,\n                         guess_charset=None, parser=None):\n    \"\"\"Parses several HTML elements, returning a list of elements.\n\n    The first item in the list may be a string.  If no_leading_text is true,\n    then it will be an error if there is leading text, and it will always be\n    a list of only elements.\n\n    If `guess_charset` is true, the `chardet` library will perform charset\n    guessing on the string.\n    \"\"\"\n    if not isinstance(html, _strings):\n        raise TypeError('string required')\n\n    if parser is None:\n        parser = html_parser\n\n    options = {}\n    if guess_charset is None and isinstance(html, bytes):\n        # html5lib does not accept useChardet as an argument, if it\n        # detected the html argument would produce unicode objects.\n        guess_charset = False\n    if guess_charset is not None:\n        options['useChardet'] = guess_charset\n    children = parser.parseFragment(html, 'div', **options)\n    if children and isinstance(children[0], _strings):\n        if no_leading_text:\n            if children[0].strip():\n                raise etree.ParserError('There is leading text: %r' %\n                                        children[0])\n            del children[0]\n    return children\n\n\ndef fragment_fromstring(html, create_parent=False,\n                        guess_charset=None, parser=None):\n    \"\"\"Parses a single HTML element; it is an error if there is more than\n    one element, or if anything but whitespace precedes or follows the\n    element.\n\n    If 'create_parent' is true (or is a tag name) then a parent node\n    will be created to encapsulate the HTML in a single element.  In\n    this case, leading or trailing text is allowed.\n\n    If `guess_charset` is true, the `chardet` library will perform charset\n    guessing on the string.\n    \"\"\"\n    if not isinstance(html, _strings):\n        raise TypeError('string required')\n\n    accept_leading_text = bool(create_parent)\n\n    elements = fragments_fromstring(\n        html, guess_charset=guess_charset, parser=parser,\n        no_leading_text=not accept_leading_text)\n\n    if create_parent:\n        if not isinstance(create_parent, _strings):\n            create_parent = 'div'\n        new_root = Element(create_parent)\n        if elements:\n            if isinstance(elements[0], _strings):\n                new_root.text = elements[0]\n                del elements[0]\n            new_root.extend(elements)\n        return new_root\n\n    if not elements:\n        raise etree.ParserError('No elements found')\n    if len(elements) > 1:\n        raise etree.ParserError('Multiple elements found')\n    result = elements[0]\n    if result.tail and result.tail.strip():\n        raise etree.ParserError('Element followed by text: %r' % result.tail)\n    result.tail = None\n    return result\n\n\ndef fromstring(html, guess_charset=None, parser=None):\n    \"\"\"Parse the html, returning a single element/document.\n\n    This tries to minimally parse the chunk of text, without knowing if it\n    is a fragment or a document.\n\n    'base_url' will set the document's base_url attribute (and the tree's\n    docinfo.URL)\n\n    If `guess_charset` is true, or if the input is not Unicode but a\n    byte string, the `chardet` library will perform charset guessing\n    on the string.\n    \"\"\"\n    if not isinstance(html, _strings):\n        raise TypeError('string required')\n    doc = document_fromstring(html, parser=parser,\n                              guess_charset=guess_charset)\n\n    # document starts with doctype or <html>, full document!\n    start = html[:50]\n    if isinstance(start, bytes):\n        # Allow text comparison in python3.\n        # Decode as ascii, that also covers latin-1 and utf-8 for the\n        # characters we need.\n        start = start.decode('ascii', 'replace')\n\n    start = start.lstrip().lower()\n    if start.startswith('<html') or start.startswith('<!doctype'):\n        return doc\n\n    head = _find_tag(doc, 'head')\n\n    # if the head is not empty we have a full document\n    if len(head):\n        return doc\n\n    body = _find_tag(doc, 'body')\n\n    # The body has just one element, so it was probably a single\n    # element passed in\n    if (len(body) == 1 and (not body.text or not body.text.strip())\n        and (not body[-1].tail or not body[-1].tail.strip())):\n        return body[0]\n\n    # Now we have a body which represents a bunch of tags which have the\n    # content that was passed in.  We will create a fake container, which\n    # is the body tag, except <body> implies too much structure.\n    if _contains_block_level_tag(body):\n        body.tag = 'div'\n    else:\n        body.tag = 'span'\n    return body\n\n\ndef parse(filename_url_or_file, guess_charset=None, parser=None):\n    \"\"\"Parse a filename, URL, or file-like object into an HTML document\n    tree.  Note: this returns a tree, not an element.  Use\n    ``parse(...).getroot()`` to get the document root.\n\n    If ``guess_charset`` is true, the ``useChardet`` option is passed into\n    html5lib to enable character detection.  This option is on by default\n    when parsing from URLs, off by default when parsing from file(-like)\n    objects (which tend to return Unicode more often than not), and on by\n    default when parsing from a file path (which is read in binary mode).\n    \"\"\"\n    if parser is None:\n        parser = html_parser\n    if not isinstance(filename_url_or_file, _strings):\n        fp = filename_url_or_file\n        if guess_charset is None:\n            # assume that file-like objects return Unicode more often than bytes\n            guess_charset = False\n    elif _looks_like_url(filename_url_or_file):\n        fp = urlopen(filename_url_or_file)\n        if guess_charset is None:\n            # assume that URLs return bytes\n            guess_charset = True\n    else:\n        fp = open(filename_url_or_file, 'rb')\n        if guess_charset is None:\n            guess_charset = True\n\n    options = {}\n    # html5lib does not accept useChardet as an argument, if it\n    # detected the html argument would produce unicode objects.\n    if guess_charset:\n        options['useChardet'] = guess_charset\n    return parser.parse(fp, **options)\n\n\ndef _looks_like_url(str):\n    scheme = urlparse(str)[0]\n    if not scheme:\n        return False\n    elif (sys.platform == 'win32' and\n            scheme in string.ascii_letters\n            and len(scheme) == 1):\n        # looks like a 'normal' absolute path\n        return False\n    else:\n        return True\n\n\nhtml_parser = HTMLParser()\n", "src/lxml/html/ElementSoup.py": "__doc__ = \"\"\"Legacy interface to the BeautifulSoup HTML parser.\n\"\"\"\n\n__all__ = [\"parse\", \"convert_tree\"]\n\nfrom .soupparser import convert_tree, parse as _parse\n\ndef parse(file, beautifulsoup=None, makeelement=None):\n    root = _parse(file, beautifulsoup=beautifulsoup, makeelement=makeelement)\n    return root.getroot()\n", "src/lxml/html/usedoctest.py": "\"\"\"Doctest module for HTML comparison.\n\nUsage::\n\n   >>> import lxml.html.usedoctest\n   >>> # now do your HTML doctests ...\n\nSee `lxml.doctestcompare`.\n\"\"\"\n\nfrom lxml import doctestcompare\n\ndoctestcompare.temp_install(html=True, del_module=__name__)\n", "src/lxml/html/_html5builder.py": "\"\"\"\nLegacy module - don't use in new code!\n\nhtml5lib now has its own proper implementation.\n\nThis module implements a tree builder for html5lib that generates lxml\nhtml element trees.  This module uses camelCase as it follows the\nhtml5lib style guide.\n\"\"\"\n\nfrom html5lib.treebuilders import _base, etree as etree_builders\nfrom lxml import html, etree\n\n\nclass DocumentType:\n\n    def __init__(self, name, publicId, systemId):\n        self.name = name\n        self.publicId = publicId\n        self.systemId = systemId\n\nclass Document:\n\n    def __init__(self):\n        self._elementTree = None\n        self.childNodes = []\n\n    def appendChild(self, element):\n        self._elementTree.getroot().addnext(element._element)\n\n\nclass TreeBuilder(_base.TreeBuilder):\n    documentClass = Document\n    doctypeClass = DocumentType\n    elementClass = None\n    commentClass = None\n    fragmentClass = Document\n\n    def __init__(self, *args, **kwargs):\n        html_builder = etree_builders.getETreeModule(html, fullTree=False)\n        etree_builder = etree_builders.getETreeModule(etree, fullTree=False)\n        self.elementClass = html_builder.Element\n        self.commentClass = etree_builder.Comment\n        _base.TreeBuilder.__init__(self, *args, **kwargs)\n\n    def reset(self):\n        _base.TreeBuilder.reset(self)\n        self.rootInserted = False\n        self.initialComments = []\n        self.doctype = None\n\n    def getDocument(self):\n        return self.document._elementTree\n\n    def getFragment(self):\n        fragment = []\n        element = self.openElements[0]._element\n        if element.text:\n            fragment.append(element.text)\n        fragment.extend(element.getchildren())\n        if element.tail:\n            fragment.append(element.tail)\n        return fragment\n\n    def insertDoctype(self, name, publicId, systemId):\n        doctype = self.doctypeClass(name, publicId, systemId)\n        self.doctype = doctype\n\n    def insertComment(self, data, parent=None):\n        if not self.rootInserted:\n            self.initialComments.append(data)\n        else:\n            _base.TreeBuilder.insertComment(self, data, parent)\n\n    def insertRoot(self, name):\n        buf = []\n        if self.doctype and self.doctype.name:\n            buf.append('<!DOCTYPE %s' % self.doctype.name)\n            if self.doctype.publicId is not None or self.doctype.systemId is not None:\n                buf.append(' PUBLIC \"%s\" \"%s\"' % (self.doctype.publicId,\n                                                  self.doctype.systemId))\n            buf.append('>')\n        buf.append('<html></html>')\n        root = html.fromstring(''.join(buf))\n\n        # Append the initial comments:\n        for comment in self.initialComments:\n            root.addprevious(etree.Comment(comment))\n\n        # Create the root document and add the ElementTree to it\n        self.document = self.documentClass()\n        self.document._elementTree = root.getroottree()\n\n        # Add the root element to the internal child/open data structures\n        root_element = self.elementClass(name)\n        root_element._element = root\n        self.document.childNodes.append(root_element)\n        self.openElements.append(root_element)\n\n        self.rootInserted = True\n", "src/lxml/html/diff.py": "# cython: language_level=3\n\n\nimport difflib\nfrom lxml import etree\nfrom lxml.html import fragment_fromstring\nimport re\n\n__all__ = ['html_annotate', 'htmldiff']\n\ntry:\n    from html import escape as html_escape\nexcept ImportError:\n    from cgi import escape as html_escape\ntry:\n    _unicode = unicode\nexcept NameError:\n    # Python 3\n    _unicode = str\ntry:\n    basestring\nexcept NameError:\n    # Python 3\n    basestring = str\n\n############################################################\n## Annotation\n############################################################\n\ndef default_markup(text, version):\n    return '<span title=\"%s\">%s</span>' % (\n        html_escape(_unicode(version), 1), text)\n\ndef html_annotate(doclist, markup=default_markup):\n    \"\"\"\n    doclist should be ordered from oldest to newest, like::\n\n        >>> version1 = 'Hello World'\n        >>> version2 = 'Goodbye World'\n        >>> print(html_annotate([(version1, 'version 1'),\n        ...                      (version2, 'version 2')]))\n        <span title=\"version 2\">Goodbye</span> <span title=\"version 1\">World</span>\n\n    The documents must be *fragments* (str/UTF8 or unicode), not\n    complete documents\n\n    The markup argument is a function to markup the spans of words.\n    This function is called like markup('Hello', 'version 2'), and\n    returns HTML.  The first argument is text and never includes any\n    markup.  The default uses a span with a title:\n\n        >>> print(default_markup('Some Text', 'by Joe'))\n        <span title=\"by Joe\">Some Text</span>\n    \"\"\"\n    # The basic strategy we have is to split the documents up into\n    # logical tokens (which are words with attached markup).  We then\n    # do diffs of each of the versions to track when a token first\n    # appeared in the document; the annotation attached to the token\n    # is the version where it first appeared.\n    tokenlist = [tokenize_annotated(doc, version)\n                 for doc, version in doclist]\n    cur_tokens = tokenlist[0]\n    for tokens in tokenlist[1:]:\n        html_annotate_merge_annotations(cur_tokens, tokens)\n        cur_tokens = tokens\n\n    # After we've tracked all the tokens, we can combine spans of text\n    # that are adjacent and have the same annotation\n    cur_tokens = compress_tokens(cur_tokens)\n    # And finally add markup\n    result = markup_serialize_tokens(cur_tokens, markup)\n    return ''.join(result).strip()\n\ndef tokenize_annotated(doc, annotation): \n    \"\"\"Tokenize a document and add an annotation attribute to each token\n    \"\"\"\n    tokens = tokenize(doc, include_hrefs=False)\n    for tok in tokens: \n        tok.annotation = annotation\n    return tokens\n\ndef html_annotate_merge_annotations(tokens_old, tokens_new): \n    \"\"\"Merge the annotations from tokens_old into tokens_new, when the\n    tokens in the new document already existed in the old document.\n    \"\"\"\n    s = InsensitiveSequenceMatcher(a=tokens_old, b=tokens_new)\n    commands = s.get_opcodes()\n\n    for command, i1, i2, j1, j2 in commands:\n        if command == 'equal': \n            eq_old = tokens_old[i1:i2]\n            eq_new = tokens_new[j1:j2]\n            copy_annotations(eq_old, eq_new)\n\ndef copy_annotations(src, dest): \n    \"\"\"\n    Copy annotations from the tokens listed in src to the tokens in dest\n    \"\"\"\n    assert len(src) == len(dest)\n    for src_tok, dest_tok in zip(src, dest): \n        dest_tok.annotation = src_tok.annotation\n\ndef compress_tokens(tokens):\n    \"\"\"\n    Combine adjacent tokens when there is no HTML between the tokens, \n    and they share an annotation\n    \"\"\"\n    result = [tokens[0]] \n    for tok in tokens[1:]: \n        if (not result[-1].post_tags and \n            not tok.pre_tags and \n            result[-1].annotation == tok.annotation): \n            compress_merge_back(result, tok)\n        else: \n            result.append(tok)\n    return result\n\ndef compress_merge_back(tokens, tok): \n    \"\"\" Merge tok into the last element of tokens (modifying the list of\n    tokens in-place).  \"\"\"\n    last = tokens[-1]\n    if type(last) is not token or type(tok) is not token: \n        tokens.append(tok)\n    else:\n        text = _unicode(last)\n        if last.trailing_whitespace:\n            text += last.trailing_whitespace\n        text += tok\n        merged = token(text,\n                       pre_tags=last.pre_tags,\n                       post_tags=tok.post_tags,\n                       trailing_whitespace=tok.trailing_whitespace)\n        merged.annotation = last.annotation\n        tokens[-1] = merged\n    \ndef markup_serialize_tokens(tokens, markup_func):\n    \"\"\"\n    Serialize the list of tokens into a list of text chunks, calling\n    markup_func around text to add annotations.\n    \"\"\"\n    for token in tokens:\n        yield from token.pre_tags\n        html = token.html()\n        html = markup_func(html, token.annotation)\n        if token.trailing_whitespace:\n            html += token.trailing_whitespace\n        yield html\n        yield from token.post_tags\n\n\n############################################################\n## HTML Diffs\n############################################################\n\ndef htmldiff(old_html, new_html):\n    ## FIXME: this should take parsed documents too, and use their body\n    ## or other content.\n    \"\"\" Do a diff of the old and new document.  The documents are HTML\n    *fragments* (str/UTF8 or unicode), they are not complete documents\n    (i.e., no <html> tag).\n\n    Returns HTML with <ins> and <del> tags added around the\n    appropriate text.  \n\n    Markup is generally ignored, with the markup from new_html\n    preserved, and possibly some markup from old_html (though it is\n    considered acceptable to lose some of the old markup).  Only the\n    words in the HTML are diffed.  The exception is <img> tags, which\n    are treated like words, and the href attribute of <a> tags, which\n    are noted inside the tag itself when there are changes.\n    \"\"\" \n    old_html_tokens = tokenize(old_html)\n    new_html_tokens = tokenize(new_html)\n    result = htmldiff_tokens(old_html_tokens, new_html_tokens)\n    result = ''.join(result).strip()\n    return fixup_ins_del_tags(result)\n\ndef htmldiff_tokens(html1_tokens, html2_tokens):\n    \"\"\" Does a diff on the tokens themselves, returning a list of text\n    chunks (not tokens).\n    \"\"\"\n    # There are several passes as we do the differences.  The tokens\n    # isolate the portion of the content we care to diff; difflib does\n    # all the actual hard work at that point.  \n    #\n    # Then we must create a valid document from pieces of both the old\n    # document and the new document.  We generally prefer to take\n    # markup from the new document, and only do a best effort attempt\n    # to keep markup from the old document; anything that we can't\n    # resolve we throw away.  Also we try to put the deletes as close\n    # to the location where we think they would have been -- because\n    # we are only keeping the markup from the new document, it can be\n    # fuzzy where in the new document the old text would have gone.\n    # Again we just do a best effort attempt.\n    s = InsensitiveSequenceMatcher(a=html1_tokens, b=html2_tokens)\n    commands = s.get_opcodes()\n    result = []\n    for command, i1, i2, j1, j2 in commands:\n        if command == 'equal':\n            result.extend(expand_tokens(html2_tokens[j1:j2], equal=True))\n            continue\n        if command == 'insert' or command == 'replace':\n            ins_tokens = expand_tokens(html2_tokens[j1:j2])\n            merge_insert(ins_tokens, result)\n        if command == 'delete' or command == 'replace':\n            del_tokens = expand_tokens(html1_tokens[i1:i2])\n            merge_delete(del_tokens, result)\n    # If deletes were inserted directly as <del> then we'd have an\n    # invalid document at this point.  Instead we put in special\n    # markers, and when the complete diffed document has been created\n    # we try to move the deletes around and resolve any problems.\n    result = cleanup_delete(result)\n\n    return result\n\ndef expand_tokens(tokens, equal=False):\n    \"\"\"Given a list of tokens, return a generator of the chunks of\n    text for the data in the tokens.\n    \"\"\"\n    for token in tokens:\n        yield from token.pre_tags\n        if not equal or not token.hide_when_equal:\n            if token.trailing_whitespace:\n                yield token.html() + token.trailing_whitespace\n            else:\n                yield token.html()\n        yield from token.post_tags\n\ndef merge_insert(ins_chunks, doc):\n    \"\"\" doc is the already-handled document (as a list of text chunks);\n    here we add <ins>ins_chunks</ins> to the end of that.  \"\"\"\n    # Though we don't throw away unbalanced_start or unbalanced_end\n    # (we assume there is accompanying markup later or earlier in the\n    # document), we only put <ins> around the balanced portion.\n    unbalanced_start, balanced, unbalanced_end = split_unbalanced(ins_chunks)\n    doc.extend(unbalanced_start)\n    if doc and not doc[-1].endswith(' '):\n        # Fix up the case where the word before the insert didn't end with \n        # a space\n        doc[-1] += ' '\n    doc.append('<ins>')\n    if balanced and balanced[-1].endswith(' '):\n        # We move space outside of </ins>\n        balanced[-1] = balanced[-1][:-1]\n    doc.extend(balanced)\n    doc.append('</ins> ')\n    doc.extend(unbalanced_end)\n\n# These are sentinels to represent the start and end of a <del>\n# segment, until we do the cleanup phase to turn them into proper\n# markup:\nclass DEL_START:\n    pass\nclass DEL_END:\n    pass\n\nclass NoDeletes(Exception):\n    \"\"\" Raised when the document no longer contains any pending deletes\n    (DEL_START/DEL_END) \"\"\"\n\ndef merge_delete(del_chunks, doc):\n    \"\"\" Adds the text chunks in del_chunks to the document doc (another\n    list of text chunks) with marker to show it is a delete.\n    cleanup_delete later resolves these markers into <del> tags.\"\"\"\n    doc.append(DEL_START)\n    doc.extend(del_chunks)\n    doc.append(DEL_END)\n\ndef cleanup_delete(chunks):\n    \"\"\" Cleans up any DEL_START/DEL_END markers in the document, replacing\n    them with <del></del>.  To do this while keeping the document\n    valid, it may need to drop some tags (either start or end tags).\n\n    It may also move the del into adjacent tags to try to move it to a\n    similar location where it was originally located (e.g., moving a\n    delete into preceding <div> tag, if the del looks like (DEL_START,\n    'Text</div>', DEL_END)\"\"\"\n    while 1:\n        # Find a pending DEL_START/DEL_END, splitting the document\n        # into stuff-preceding-DEL_START, stuff-inside, and\n        # stuff-following-DEL_END\n        try:\n            pre_delete, delete, post_delete = split_delete(chunks)\n        except NoDeletes:\n            # Nothing found, we've cleaned up the entire doc\n            break\n        # The stuff-inside-DEL_START/END may not be well balanced\n        # markup.  First we figure out what unbalanced portions there are:\n        unbalanced_start, balanced, unbalanced_end = split_unbalanced(delete)\n        # Then we move the span forward and/or backward based on these\n        # unbalanced portions:\n        locate_unbalanced_start(unbalanced_start, pre_delete, post_delete)\n        locate_unbalanced_end(unbalanced_end, pre_delete, post_delete)\n        doc = pre_delete\n        if doc and not doc[-1].endswith(' '):\n            # Fix up case where the word before us didn't have a trailing space\n            doc[-1] += ' '\n        doc.append('<del>')\n        if balanced and balanced[-1].endswith(' '):\n            # We move space outside of </del>\n            balanced[-1] = balanced[-1][:-1]\n        doc.extend(balanced)\n        doc.append('</del> ')\n        doc.extend(post_delete)\n        chunks = doc\n    return chunks\n\ndef split_unbalanced(chunks):\n    \"\"\"Return (unbalanced_start, balanced, unbalanced_end), where each is\n    a list of text and tag chunks.\n\n    unbalanced_start is a list of all the tags that are opened, but\n    not closed in this span.  Similarly, unbalanced_end is a list of\n    tags that are closed but were not opened.  Extracting these might\n    mean some reordering of the chunks.\"\"\"\n    start = []\n    end = []\n    tag_stack = []\n    balanced = []\n    for chunk in chunks:\n        if not chunk.startswith('<'):\n            balanced.append(chunk)\n            continue\n        endtag = chunk[1] == '/'\n        name = chunk.split()[0].strip('<>/')\n        if name in empty_tags:\n            balanced.append(chunk)\n            continue\n        if endtag:\n            if tag_stack and tag_stack[-1][0] == name:\n                balanced.append(chunk)\n                name, pos, tag = tag_stack.pop()\n                balanced[pos] = tag\n            elif tag_stack:\n                start.extend([tag for name, pos, tag in tag_stack])\n                tag_stack = []\n                end.append(chunk)\n            else:\n                end.append(chunk)\n        else:\n            tag_stack.append((name, len(balanced), chunk))\n            balanced.append(None)\n    start.extend(\n        [chunk for name, pos, chunk in tag_stack])\n    balanced = [chunk for chunk in balanced if chunk is not None]\n    return start, balanced, end\n\ndef split_delete(chunks):\n    \"\"\" Returns (stuff_before_DEL_START, stuff_inside_DEL_START_END,\n    stuff_after_DEL_END).  Returns the first case found (there may be\n    more DEL_STARTs in stuff_after_DEL_END).  Raises NoDeletes if\n    there's no DEL_START found. \"\"\"\n    try:\n        pos = chunks.index(DEL_START)\n    except ValueError:\n        raise NoDeletes\n    pos2 = chunks.index(DEL_END)\n    return chunks[:pos], chunks[pos+1:pos2], chunks[pos2+1:]\n\ndef locate_unbalanced_start(unbalanced_start, pre_delete, post_delete):\n    \"\"\" pre_delete and post_delete implicitly point to a place in the\n    document (where the two were split).  This moves that point (by\n    popping items from one and pushing them onto the other).  It moves\n    the point to try to find a place where unbalanced_start applies.\n\n    As an example::\n\n        >>> unbalanced_start = ['<div>']\n        >>> doc = ['<p>', 'Text', '</p>', '<div>', 'More Text', '</div>']\n        >>> pre, post = doc[:3], doc[3:]\n        >>> pre, post\n        (['<p>', 'Text', '</p>'], ['<div>', 'More Text', '</div>'])\n        >>> locate_unbalanced_start(unbalanced_start, pre, post)\n        >>> pre, post\n        (['<p>', 'Text', '</p>', '<div>'], ['More Text', '</div>'])\n\n    As you can see, we moved the point so that the dangling <div> that\n    we found will be effectively replaced by the div in the original\n    document.  If this doesn't work out, we just throw away\n    unbalanced_start without doing anything.\n    \"\"\"\n    while 1:\n        if not unbalanced_start:\n            # We have totally succeeded in finding the position\n            break\n        finding = unbalanced_start[0]\n        finding_name = finding.split()[0].strip('<>')\n        if not post_delete:\n            break\n        next = post_delete[0]\n        if next is DEL_START or not next.startswith('<'):\n            # Reached a word, we can't move the delete text forward\n            break\n        if next[1] == '/':\n            # Reached a closing tag, can we go further?  Maybe not...\n            break\n        name = next.split()[0].strip('<>')\n        if name == 'ins':\n            # Can't move into an insert\n            break\n        assert name != 'del', (\n            \"Unexpected delete tag: %r\" % next)\n        if name == finding_name:\n            unbalanced_start.pop(0)\n            pre_delete.append(post_delete.pop(0))\n        else:\n            # Found a tag that doesn't match\n            break\n\ndef locate_unbalanced_end(unbalanced_end, pre_delete, post_delete):\n    \"\"\" like locate_unbalanced_start, except handling end tags and\n    possibly moving the point earlier in the document.  \"\"\"\n    while 1:\n        if not unbalanced_end:\n            # Success\n            break\n        finding = unbalanced_end[-1]\n        finding_name = finding.split()[0].strip('<>/')\n        if not pre_delete:\n            break\n        next = pre_delete[-1]\n        if next is DEL_END or not next.startswith('</'):\n            # A word or a start tag\n            break\n        name = next.split()[0].strip('<>/')\n        if name == 'ins' or name == 'del':\n            # Can't move into an insert or delete\n            break\n        if name == finding_name:\n            unbalanced_end.pop()\n            post_delete.insert(0, pre_delete.pop())\n        else:\n            # Found a tag that doesn't match\n            break\n\nclass token(_unicode):\n    \"\"\" Represents a diffable token, generally a word that is displayed to\n    the user.  Opening tags are attached to this token when they are\n    adjacent (pre_tags) and closing tags that follow the word\n    (post_tags).  Some exceptions occur when there are empty tags\n    adjacent to a word, so there may be close tags in pre_tags, or\n    open tags in post_tags.\n\n    We also keep track of whether the word was originally followed by\n    whitespace, even though we do not want to treat the word as\n    equivalent to a similar word that does not have a trailing\n    space.\"\"\"\n\n    # When this is true, the token will be eliminated from the\n    # displayed diff if no change has occurred:\n    hide_when_equal = False\n\n    def __new__(cls, text, pre_tags=None, post_tags=None, trailing_whitespace=\"\"):\n        obj = _unicode.__new__(cls, text)\n\n        if pre_tags is not None:\n            obj.pre_tags = pre_tags\n        else:\n            obj.pre_tags = []\n\n        if post_tags is not None:\n            obj.post_tags = post_tags\n        else:\n            obj.post_tags = []\n\n        obj.trailing_whitespace = trailing_whitespace\n\n        return obj\n\n    def __repr__(self):\n        return 'token(%s, %r, %r, %r)' % (_unicode.__repr__(self), self.pre_tags,\n                                          self.post_tags, self.trailing_whitespace)\n\n    def html(self):\n        return _unicode(self)\n\nclass tag_token(token):\n\n    \"\"\" Represents a token that is actually a tag.  Currently this is just\n    the <img> tag, which takes up visible space just like a word but\n    is only represented in a document by a tag.  \"\"\"\n\n    def __new__(cls, tag, data, html_repr, pre_tags=None, \n                post_tags=None, trailing_whitespace=\"\"):\n        obj = token.__new__(cls, \"%s: %s\" % (type, data), \n                            pre_tags=pre_tags, \n                            post_tags=post_tags, \n                            trailing_whitespace=trailing_whitespace)\n        obj.tag = tag\n        obj.data = data\n        obj.html_repr = html_repr\n        return obj\n\n    def __repr__(self):\n        return 'tag_token(%s, %s, html_repr=%s, post_tags=%r, pre_tags=%r, trailing_whitespace=%r)' % (\n            self.tag, \n            self.data, \n            self.html_repr, \n            self.pre_tags, \n            self.post_tags, \n            self.trailing_whitespace)\n    def html(self):\n        return self.html_repr\n\nclass href_token(token):\n\n    \"\"\" Represents the href in an anchor tag.  Unlike other words, we only\n    show the href when it changes.  \"\"\"\n\n    hide_when_equal = True\n\n    def html(self):\n        return ' Link: %s' % self\n\ndef tokenize(html, include_hrefs=True):\n    \"\"\"\n    Parse the given HTML and returns token objects (words with attached tags).\n\n    This parses only the content of a page; anything in the head is\n    ignored, and the <head> and <body> elements are themselves\n    optional.  The content is then parsed by lxml, which ensures the\n    validity of the resulting parsed document (though lxml may make\n    incorrect guesses when the markup is particular bad).\n\n    <ins> and <del> tags are also eliminated from the document, as\n    that gets confusing.\n\n    If include_hrefs is true, then the href attribute of <a> tags is\n    included as a special kind of diffable token.\"\"\"\n    if etree.iselement(html):\n        body_el = html\n    else:\n        body_el = parse_html(html, cleanup=True)\n    # Then we split the document into text chunks for each tag, word, and end tag:\n    chunks = flatten_el(body_el, skip_tag=True, include_hrefs=include_hrefs)\n    # Finally re-joining them into token objects:\n    return fixup_chunks(chunks)\n\ndef parse_html(html, cleanup=True):\n    \"\"\"\n    Parses an HTML fragment, returning an lxml element.  Note that the HTML will be\n    wrapped in a <div> tag that was not in the original document.\n\n    If cleanup is true, make sure there's no <head> or <body>, and get\n    rid of any <ins> and <del> tags.\n    \"\"\"\n    if cleanup:\n        # This removes any extra markup or structure like <head>:\n        html = cleanup_html(html)\n    return fragment_fromstring(html, create_parent=True)\n\n_body_re = re.compile(r'<body.*?>', re.I|re.S)\n_end_body_re = re.compile(r'</body.*?>', re.I|re.S)\n_ins_del_re = re.compile(r'</?(ins|del).*?>', re.I|re.S)\n\ndef cleanup_html(html):\n    \"\"\" This 'cleans' the HTML, meaning that any page structure is removed\n    (only the contents of <body> are used, if there is any <body).\n    Also <ins> and <del> tags are removed.  \"\"\"\n    match = _body_re.search(html)\n    if match:\n        html = html[match.end():]\n    match = _end_body_re.search(html)\n    if match:\n        html = html[:match.start()]\n    html = _ins_del_re.sub('', html)\n    return html\n    \n\nend_whitespace_re = re.compile(r'[ \\t\\n\\r]$')\n\ndef split_trailing_whitespace(word):\n    \"\"\"\n    This function takes a word, such as 'test\\n\\n' and returns ('test','\\n\\n')\n    \"\"\"\n    stripped_length = len(word.rstrip())\n    return word[0:stripped_length], word[stripped_length:]\n\n\ndef fixup_chunks(chunks):\n    \"\"\"\n    This function takes a list of chunks and produces a list of tokens.\n    \"\"\"\n    tag_accum = []\n    cur_word = None\n    result = []\n    for chunk in chunks:\n        if isinstance(chunk, tuple):\n            if chunk[0] == 'img':\n                src = chunk[1]\n                tag, trailing_whitespace = split_trailing_whitespace(chunk[2])\n                cur_word = tag_token('img', src, html_repr=tag,\n                                     pre_tags=tag_accum,\n                                     trailing_whitespace=trailing_whitespace)\n                tag_accum = []\n                result.append(cur_word)\n\n            elif chunk[0] == 'href':\n                href = chunk[1]\n                cur_word = href_token(href, pre_tags=tag_accum, trailing_whitespace=\" \")\n                tag_accum = []\n                result.append(cur_word)\n            continue\n\n        if is_word(chunk):\n            chunk, trailing_whitespace = split_trailing_whitespace(chunk)\n            cur_word = token(chunk, pre_tags=tag_accum, trailing_whitespace=trailing_whitespace)\n            tag_accum = []\n            result.append(cur_word)\n\n        elif is_start_tag(chunk):\n            tag_accum.append(chunk)\n\n        elif is_end_tag(chunk):\n            if tag_accum:\n                tag_accum.append(chunk)\n            else:\n                assert cur_word, (\n                    \"Weird state, cur_word=%r, result=%r, chunks=%r of %r\"\n                    % (cur_word, result, chunk, chunks))\n                cur_word.post_tags.append(chunk)\n        else:\n            assert False\n\n    if not result:\n        return [token('', pre_tags=tag_accum)]\n    else:\n        result[-1].post_tags.extend(tag_accum)\n\n    return result\n\n\n# All the tags in HTML that don't require end tags:\nempty_tags = (\n    'param', 'img', 'area', 'br', 'basefont', 'input',\n    'base', 'meta', 'link', 'col')\n\nblock_level_tags = (\n    'address',\n    'blockquote',\n    'center',\n    'dir',\n    'div',\n    'dl',\n    'fieldset',\n    'form',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'hr',\n    'isindex',\n    'menu',\n    'noframes',\n    'noscript',\n    'ol',\n    'p',\n    'pre',\n    'table',\n    'ul',\n    )\n\nblock_level_container_tags = (\n    'dd',\n    'dt',\n    'frameset',\n    'li',\n    'tbody',\n    'td',\n    'tfoot',\n    'th',\n    'thead',\n    'tr',\n    )\n\n\ndef flatten_el(el, include_hrefs, skip_tag=False):\n    \"\"\" Takes an lxml element el, and generates all the text chunks for\n    that tag.  Each start tag is a chunk, each word is a chunk, and each\n    end tag is a chunk.\n\n    If skip_tag is true, then the outermost container tag is\n    not returned (just its contents).\"\"\"\n    if not skip_tag:\n        if el.tag == 'img':\n            yield ('img', el.get('src'), start_tag(el))\n        else:\n            yield start_tag(el)\n    if el.tag in empty_tags and not el.text and not len(el) and not el.tail:\n        return\n    start_words = split_words(el.text)\n    for word in start_words:\n        yield html_escape(word)\n    for child in el:\n        yield from flatten_el(child, include_hrefs=include_hrefs)\n    if el.tag == 'a' and el.get('href') and include_hrefs:\n        yield ('href', el.get('href'))\n    if not skip_tag:\n        yield end_tag(el)\n        end_words = split_words(el.tail)\n        for word in end_words:\n            yield html_escape(word)\n\nsplit_words_re = re.compile(r'\\S+(?:\\s+|$)', re.U)\n\ndef split_words(text):\n    \"\"\" Splits some text into words. Includes trailing whitespace\n    on each word when appropriate.  \"\"\"\n    if not text or not text.strip():\n        return []\n\n    words = split_words_re.findall(text)\n    return words\n\nstart_whitespace_re = re.compile(r'^[ \\t\\n\\r]')\n\ndef start_tag(el):\n    \"\"\"\n    The text representation of the start tag for a tag.\n    \"\"\"\n    return '<%s%s>' % (\n        el.tag, ''.join([' %s=\"%s\"' % (name, html_escape(value, True))\n                         for name, value in el.attrib.items()]))\n\ndef end_tag(el):\n    \"\"\" The text representation of an end tag for a tag.  Includes\n    trailing whitespace when appropriate.  \"\"\"\n    if el.tail and start_whitespace_re.search(el.tail):\n        extra = ' '\n    else:\n        extra = ''\n    return '</%s>%s' % (el.tag, extra)\n\ndef is_word(tok):\n    return not tok.startswith('<')\n\ndef is_end_tag(tok):\n    return tok.startswith('</')\n\ndef is_start_tag(tok):\n    return tok.startswith('<') and not tok.startswith('</')\n\ndef fixup_ins_del_tags(html):\n    \"\"\" Given an html string, move any <ins> or <del> tags inside of any\n    block-level elements, e.g. transform <ins><p>word</p></ins> to\n    <p><ins>word</ins></p> \"\"\"\n    doc = parse_html(html, cleanup=False)\n    _fixup_ins_del_tags(doc)\n    html = serialize_html_fragment(doc, skip_outer=True)\n    return html\n\ndef serialize_html_fragment(el, skip_outer=False):\n    \"\"\" Serialize a single lxml element as HTML.  The serialized form\n    includes the elements tail.  \n\n    If skip_outer is true, then don't serialize the outermost tag\n    \"\"\"\n    assert not isinstance(el, basestring), (\n        \"You should pass in an element, not a string like %r\" % el)\n    html = etree.tostring(el, method=\"html\", encoding=_unicode)\n    if skip_outer:\n        # Get rid of the extra starting tag:\n        html = html[html.find('>')+1:]\n        # Get rid of the extra end tag:\n        html = html[:html.rfind('<')]\n        return html.strip()\n    else:\n        return html\n\ndef _fixup_ins_del_tags(doc):\n    \"\"\"fixup_ins_del_tags that works on an lxml document in-place\n    \"\"\"\n    for tag in ['ins', 'del']:\n        for el in doc.xpath('descendant-or-self::%s' % tag):\n            if not _contains_block_level_tag(el):\n                continue\n            _move_el_inside_block(el, tag=tag)\n            el.drop_tag()\n            #_merge_element_contents(el)\n\ndef _contains_block_level_tag(el):\n    \"\"\"True if the element contains any block-level elements, like <p>, <td>, etc.\n    \"\"\"\n    if el.tag in block_level_tags or el.tag in block_level_container_tags:\n        return True\n    for child in el:\n        if _contains_block_level_tag(child):\n            return True\n    return False\n\ndef _move_el_inside_block(el, tag):\n    \"\"\" helper for _fixup_ins_del_tags; actually takes the <ins> etc tags\n    and moves them inside any block-level tags.  \"\"\"\n    for child in el:\n        if _contains_block_level_tag(child):\n            break\n    else:\n        # No block-level tags in any child\n        children_tag = etree.Element(tag)\n        children_tag.text = el.text\n        el.text = None\n        children_tag.extend(list(el))\n        el[:] = [children_tag]\n        return\n    for child in list(el):\n        if _contains_block_level_tag(child):\n            _move_el_inside_block(child, tag)\n            if child.tail:\n                tail_tag = etree.Element(tag)\n                tail_tag.text = child.tail\n                child.tail = None\n                el.insert(el.index(child)+1, tail_tag)\n        else:\n            child_tag = etree.Element(tag)\n            el.replace(child, child_tag)\n            child_tag.append(child)\n    if el.text:\n        text_tag = etree.Element(tag)\n        text_tag.text = el.text\n        el.text = None\n        el.insert(0, text_tag)\n            \ndef _merge_element_contents(el):\n    \"\"\"\n    Removes an element, but merges its contents into its place, e.g.,\n    given <p>Hi <i>there!</i></p>, if you remove the <i> element you get\n    <p>Hi there!</p>\n    \"\"\"\n    parent = el.getparent()\n    text = el.text or ''\n    if el.tail:\n        if not len(el):\n            text += el.tail\n        else:\n            if el[-1].tail:\n                el[-1].tail += el.tail\n            else:\n                el[-1].tail = el.tail\n    index = parent.index(el)\n    if text:\n        if index == 0:\n            previous = None\n        else:\n            previous = parent[index-1]\n        if previous is None:\n            if parent.text:\n                parent.text += text\n            else:\n                parent.text = text\n        else:\n            if previous.tail:\n                previous.tail += text\n            else:\n                previous.tail = text\n    parent[index:index+1] = el.getchildren()\n\nclass InsensitiveSequenceMatcher(difflib.SequenceMatcher):\n    \"\"\"\n    Acts like SequenceMatcher, but tries not to find very small equal\n    blocks amidst large spans of changes\n    \"\"\"\n\n    threshold = 2\n    \n    def get_matching_blocks(self):\n        size = min(len(self.b), len(self.b))\n        threshold = min(self.threshold, size / 4)\n        actual = difflib.SequenceMatcher.get_matching_blocks(self)\n        return [item for item in actual\n                if item[2] > threshold\n                or not item[2]]\n\nif __name__ == '__main__':\n    from lxml.html import _diffcommand\n    _diffcommand.main()\n    \n", "src/lxml/html/_diffcommand.py": "import optparse\nimport sys\nimport re\nimport os\nfrom .diff import htmldiff\n\ndescription = \"\"\"\\\n\"\"\"\n\nparser = optparse.OptionParser(\n    usage=\"%prog [OPTIONS] FILE1 FILE2\\n\"\n    \"%prog --annotate [OPTIONS] INFO1 FILE1 INFO2 FILE2 ...\",\n    description=description,\n    )\n\nparser.add_option(\n    '-o', '--output',\n    metavar=\"FILE\",\n    dest=\"output\",\n    default=\"-\",\n    help=\"File to write the difference to\",\n    )\n\nparser.add_option(\n    '-a', '--annotation',\n    action=\"store_true\",\n    dest=\"annotation\",\n    help=\"Do an annotation\")\n\ndef main(args=None):\n    if args is None:\n        args = sys.argv[1:]\n    options, args = parser.parse_args(args)\n    if options.annotation:\n        return annotate(options, args)\n    if len(args) != 2:\n        print('Error: you must give two files')\n        parser.print_help()\n        sys.exit(1)\n    file1, file2 = args\n    input1 = read_file(file1)\n    input2 = read_file(file2)\n    body1 = split_body(input1)[1]\n    pre, body2, post = split_body(input2)\n    result = htmldiff(body1, body2)\n    result = pre + result + post\n    if options.output == '-':\n        if not result.endswith('\\n'):\n            result += '\\n'\n        sys.stdout.write(result)\n    else:\n        with open(options.output, 'wb') as f:\n            f.write(result)\n\ndef read_file(filename):\n    if filename == '-':\n        c = sys.stdin.read()\n    elif not os.path.exists(filename):\n        raise OSError(\n            \"Input file %s does not exist\" % filename)\n    else:\n        with open(filename, 'rb') as f:\n            c = f.read()\n    return c\n\nbody_start_re = re.compile(\n    r\"<body.*?>\", re.I|re.S)\nbody_end_re = re.compile(\n    r\"</body.*?>\", re.I|re.S)\n    \ndef split_body(html):\n    pre = post = ''\n    match = body_start_re.search(html)\n    if match:\n        pre = html[:match.end()]\n        html = html[match.end():]\n    match = body_end_re.search(html)\n    if match:\n        post = html[match.start():]\n        html = html[:match.start()]\n    return pre, html, post\n\ndef annotate(options, args):\n    print(\"Not yet implemented\")\n    sys.exit(1)\n    \n", "src/lxml/html/_setmixin.py": "try:\n    from collections.abc import MutableSet\nexcept ImportError:\n    from collections.abc import MutableSet\n\n\nclass SetMixin(MutableSet):\n\n    \"\"\"\n    Mix-in for sets.  You must define __iter__, add, remove\n    \"\"\"\n\n    def __len__(self):\n        length = 0\n        for item in self:\n            length += 1\n        return length\n\n    def __contains__(self, item):\n        for has_item in self:\n            if item == has_item:\n                return True\n        return False\n\n    issubset = MutableSet.__le__\n    issuperset = MutableSet.__ge__\n\n    union = MutableSet.__or__\n    intersection = MutableSet.__and__\n    difference = MutableSet.__sub__\n    symmetric_difference = MutableSet.__xor__\n\n    def copy(self):\n        return set(self)\n\n    def update(self, other):\n        self |= other\n\n    def intersection_update(self, other):\n        self &= other\n\n    def difference_update(self, other):\n        self -= other\n\n    def symmetric_difference_update(self, other):\n        self ^= other\n\n    def discard(self, item):\n        try:\n            self.remove(item)\n        except KeyError:\n            pass\n\n    @classmethod\n    def _from_iterable(cls, it):\n        return set(it)\n", "src/lxml/html/formfill.py": "from lxml.etree import XPath, ElementBase\nfrom lxml.html import fromstring, XHTML_NAMESPACE\nfrom lxml.html import _forms_xpath, _options_xpath, _nons, _transform_result\nfrom lxml.html import defs\nimport copy\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3\n    basestring = str\n\n__all__ = ['FormNotFound', 'fill_form', 'fill_form_html',\n           'insert_errors', 'insert_errors_html',\n           'DefaultErrorCreator']\n\nclass FormNotFound(LookupError):\n    \"\"\"\n    Raised when no form can be found\n    \"\"\"\n\n_form_name_xpath = XPath('descendant-or-self::form[name=$name]|descendant-or-self::x:form[name=$name]', namespaces={'x':XHTML_NAMESPACE})\n_input_xpath = XPath('|'.join(['descendant-or-self::'+_tag for _tag in ('input','select','textarea','x:input','x:select','x:textarea')]),\n                               namespaces={'x':XHTML_NAMESPACE})\n_label_for_xpath = XPath('//label[@for=$for_id]|//x:label[@for=$for_id]',\n                               namespaces={'x':XHTML_NAMESPACE})\n_name_xpath = XPath('descendant-or-self::*[@name=$name]')\n\ndef fill_form(\n    el,\n    values,\n    form_id=None,\n    form_index=None,\n    ):\n    el = _find_form(el, form_id=form_id, form_index=form_index)\n    _fill_form(el, values)\n\ndef fill_form_html(html, values, form_id=None, form_index=None):\n    result_type = type(html)\n    if isinstance(html, basestring):\n        doc = fromstring(html)\n    else:\n        doc = copy.deepcopy(html)\n    fill_form(doc, values, form_id=form_id, form_index=form_index)\n    return _transform_result(result_type, doc)\n\ndef _fill_form(el, values):\n    counts = {}\n    if hasattr(values, 'mixed'):\n        # For Paste request parameters\n        values = values.mixed()\n    inputs = _input_xpath(el)\n    for input in inputs:\n        name = input.get('name')\n        if not name:\n            continue\n        if _takes_multiple(input):\n            value = values.get(name, [])\n            if not isinstance(value, (list, tuple)):\n                value = [value]\n            _fill_multiple(input, value)\n        elif name not in values:\n            continue\n        else:\n            index = counts.get(name, 0)\n            counts[name] = index + 1\n            value = values[name]\n            if isinstance(value, (list, tuple)):\n                try:\n                    value = value[index]\n                except IndexError:\n                    continue\n            elif index > 0:\n                continue\n            _fill_single(input, value)\n\ndef _takes_multiple(input):\n    if _nons(input.tag) == 'select' and input.get('multiple'):\n        # FIXME: multiple=\"0\"?\n        return True\n    type = input.get('type', '').lower()\n    if type in ('radio', 'checkbox'):\n        return True\n    return False\n\ndef _fill_multiple(input, value):\n    type = input.get('type', '').lower()\n    if type == 'checkbox':\n        v = input.get('value')\n        if v is None:\n            if not value:\n                result = False\n            else:\n                result = value[0]\n                if isinstance(value, basestring):\n                    # The only valid \"on\" value for an unnamed checkbox is 'on'\n                    result = result == 'on'\n            _check(input, result)\n        else:\n            _check(input, v in value)\n    elif type == 'radio':\n        v = input.get('value')\n        _check(input, v in value)\n    else:\n        assert _nons(input.tag) == 'select'\n        for option in _options_xpath(input):\n            v = option.get('value')\n            if v is None:\n                # This seems to be the default, at least on IE\n                # FIXME: but I'm not sure\n                v = option.text_content()\n            _select(option, v in value)\n\ndef _check(el, check):\n    if check:\n        el.set('checked', '')\n    else:\n        if 'checked' in el.attrib:\n            del el.attrib['checked']\n\ndef _select(el, select):\n    if select:\n        el.set('selected', '')\n    else:\n        if 'selected' in el.attrib:\n            del el.attrib['selected']\n\ndef _fill_single(input, value):\n    if _nons(input.tag) == 'textarea':\n        input.text = value\n    else:\n        input.set('value', value)\n\ndef _find_form(el, form_id=None, form_index=None):\n    if form_id is None and form_index is None:\n        forms = _forms_xpath(el)\n        for form in forms:\n            return form\n        raise FormNotFound(\n            \"No forms in page\")\n    if form_id is not None:\n        form = el.get_element_by_id(form_id)\n        if form is not None:\n            return form\n        forms = _form_name_xpath(el, name=form_id)\n        if forms:\n            return forms[0]\n        else:\n            raise FormNotFound(\n                \"No form with the name or id of %r (forms: %s)\"\n                % (id, ', '.join(_find_form_ids(el))))               \n    if form_index is not None:\n        forms = _forms_xpath(el)\n        try:\n            return forms[form_index]\n        except IndexError:\n            raise FormNotFound(\n                \"There is no form with the index %r (%i forms found)\"\n                % (form_index, len(forms)))\n\ndef _find_form_ids(el):\n    forms = _forms_xpath(el)\n    if not forms:\n        yield '(no forms)'\n        return\n    for index, form in enumerate(forms):\n        if form.get('id'):\n            if form.get('name'):\n                yield '%s or %s' % (form.get('id'),\n                                     form.get('name'))\n            else:\n                yield form.get('id')\n        elif form.get('name'):\n            yield form.get('name')\n        else:\n            yield '(unnamed form %s)' % index\n\n############################################################\n## Error filling\n############################################################\n\nclass DefaultErrorCreator:\n    insert_before = True\n    block_inside = True\n    error_container_tag = 'div'\n    error_message_class = 'error-message'\n    error_block_class = 'error-block'\n    default_message = \"Invalid\"\n\n    def __init__(self, **kw):\n        for name, value in kw.items():\n            if not hasattr(self, name):\n                raise TypeError(\n                    \"Unexpected keyword argument: %s\" % name)\n            setattr(self, name, value)\n\n    def __call__(self, el, is_block, message):\n        error_el = el.makeelement(self.error_container_tag)\n        if self.error_message_class:\n            error_el.set('class', self.error_message_class)\n        if is_block and self.error_block_class:\n            error_el.set('class', error_el.get('class', '')+' '+self.error_block_class)\n        if message is None or message == '':\n            message = self.default_message\n        if isinstance(message, ElementBase):\n            error_el.append(message)\n        else:\n            assert isinstance(message, basestring), (\n                \"Bad message; should be a string or element: %r\" % message)\n            error_el.text = message or self.default_message\n        if is_block and self.block_inside:\n            if self.insert_before:\n                error_el.tail = el.text\n                el.text = None\n                el.insert(0, error_el)\n            else:\n                el.append(error_el)\n        else:\n            parent = el.getparent()\n            pos = parent.index(el)\n            if self.insert_before:\n                parent.insert(pos, error_el)\n            else:\n                error_el.tail = el.tail\n                el.tail = None\n                parent.insert(pos+1, error_el)\n\ndefault_error_creator = DefaultErrorCreator()\n    \n\ndef insert_errors(\n    el,\n    errors,\n    form_id=None,\n    form_index=None,\n    error_class=\"error\",\n    error_creator=default_error_creator,\n    ):\n    el = _find_form(el, form_id=form_id, form_index=form_index)\n    for name, error in errors.items():\n        if error is None:\n            continue\n        for error_el, message in _find_elements_for_name(el, name, error):\n            assert isinstance(message, (basestring, type(None), ElementBase)), (\n                \"Bad message: %r\" % message)\n            _insert_error(error_el, message, error_class, error_creator)\n\ndef insert_errors_html(html, values, **kw):\n    result_type = type(html)\n    if isinstance(html, basestring):\n        doc = fromstring(html)\n    else:\n        doc = copy.deepcopy(html)\n    insert_errors(doc, values, **kw)\n    return _transform_result(result_type, doc)\n\ndef _insert_error(el, error, error_class, error_creator):\n    if _nons(el.tag) in defs.empty_tags or _nons(el.tag) == 'textarea':\n        is_block = False\n    else:\n        is_block = True\n    if _nons(el.tag) != 'form' and error_class:\n        _add_class(el, error_class)\n    if el.get('id'):\n        labels = _label_for_xpath(el, for_id=el.get('id'))\n        if labels:\n            for label in labels:\n                _add_class(label, error_class)\n    error_creator(el, is_block, error)\n\ndef _add_class(el, class_name):\n    if el.get('class'):\n        el.set('class', el.get('class')+' '+class_name)\n    else:\n        el.set('class', class_name)\n\ndef _find_elements_for_name(form, name, error):\n    if name is None:\n        # An error for the entire form\n        yield form, error\n        return\n    if name.startswith('#'):\n        # By id\n        el = form.get_element_by_id(name[1:])\n        if el is not None:\n            yield el, error\n        return\n    els = _name_xpath(form, name=name)\n    if not els:\n        # FIXME: should this raise an exception?\n        return\n    if not isinstance(error, (list, tuple)):\n        yield els[0], error\n        return\n    # FIXME: if error is longer than els, should it raise an error?\n    for el, err in zip(els, error):\n        if err is None:\n            continue\n        yield el, err\n", "src/lxml/html/defs.py": "# FIXME: this should all be confirmed against what a DTD says\n# (probably in a test; this may not match the DTD exactly, but we\n# should document just how it differs).\n\n\"\"\"\nData taken from https://www.w3.org/TR/html401/index/elements.html\nand https://www.w3.org/community/webed/wiki/HTML/New_HTML5_Elements\nfor html5_tags.\n\"\"\"\n\nempty_tags = frozenset([\n    'area', 'base', 'basefont', 'br', 'col', 'frame', 'hr',\n    'img', 'input', 'isindex', 'link', 'meta', 'param', 'source', 'track'])\n\ndeprecated_tags = frozenset([\n    'applet', 'basefont', 'center', 'dir', 'font', 'isindex',\n    'menu', 's', 'strike', 'u'])\n\n# archive actually takes a space-separated list of URIs\nlink_attrs = frozenset([\n    'action', 'archive', 'background', 'cite', 'classid',\n    'codebase', 'data', 'href', 'longdesc', 'profile', 'src',\n    'usemap',\n    # Not standard:\n    'dynsrc', 'lowsrc',\n    # HTML5 formaction\n    'formaction'\n    ])\n\n# Not in the HTML 4 spec:\n# onerror, onresize\nevent_attrs = frozenset([\n    'onblur', 'onchange', 'onclick', 'ondblclick', 'onerror',\n    'onfocus', 'onkeydown', 'onkeypress', 'onkeyup', 'onload',\n    'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover',\n    'onmouseup', 'onreset', 'onresize', 'onselect', 'onsubmit',\n    'onunload',\n    ])\n\nsafe_attrs = frozenset([\n    'abbr', 'accept', 'accept-charset', 'accesskey', 'action', 'align',\n    'alt', 'axis', 'border', 'cellpadding', 'cellspacing', 'char', 'charoff',\n    'charset', 'checked', 'cite', 'class', 'clear', 'cols', 'colspan',\n    'color', 'compact', 'coords', 'datetime', 'dir', 'disabled', 'enctype',\n    'for', 'frame', 'headers', 'height', 'href', 'hreflang', 'hspace', 'id',\n    'ismap', 'label', 'lang', 'longdesc', 'maxlength', 'media', 'method',\n    'multiple', 'name', 'nohref', 'noshade', 'nowrap', 'prompt', 'readonly',\n    'rel', 'rev', 'rows', 'rowspan', 'rules', 'scope', 'selected', 'shape',\n    'size', 'span', 'src', 'start', 'summary', 'tabindex', 'target', 'title',\n    'type', 'usemap', 'valign', 'value', 'vspace', 'width'])\n\n# From http://htmlhelp.com/reference/html40/olist.html\ntop_level_tags = frozenset([\n    'html', 'head', 'body', 'frameset',\n    ])\n\nhead_tags = frozenset([\n    'base', 'isindex', 'link', 'meta', 'script', 'style', 'title',\n    ])\n\ngeneral_block_tags = frozenset([\n    'address',\n    'blockquote',\n    'center',\n    'del',\n    'div',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'hr',\n    'ins',\n    'isindex',\n    'noscript',\n    'p',\n    'pre',\n    ])\n\nlist_tags = frozenset([\n    'dir', 'dl', 'dt', 'dd', 'li', 'menu', 'ol', 'ul',\n    ])\n\ntable_tags = frozenset([\n    'table', 'caption', 'colgroup', 'col',\n    'thead', 'tfoot', 'tbody', 'tr', 'td', 'th',\n    ])\n\n# just this one from\n# http://www.georgehernandez.com/h/XComputers/HTML/2BlockLevel.htm\nblock_tags = general_block_tags | list_tags | table_tags | frozenset([\n    # Partial form tags\n    'fieldset', 'form', 'legend', 'optgroup', 'option',\n    ])\n\nform_tags = frozenset([\n    'form', 'button', 'fieldset', 'legend', 'input', 'label',\n    'select', 'optgroup', 'option', 'textarea',\n    ])\n\nspecial_inline_tags = frozenset([\n    'a', 'applet', 'basefont', 'bdo', 'br', 'embed', 'font', 'iframe',\n    'img', 'map', 'area', 'object', 'param', 'q', 'script',\n    'span', 'sub', 'sup',\n    ])\n\nphrase_tags = frozenset([\n    'abbr', 'acronym', 'cite', 'code', 'del', 'dfn', 'em',\n    'ins', 'kbd', 'samp', 'strong', 'var',\n    ])\n\nfont_style_tags = frozenset([\n    'b', 'big', 'i', 's', 'small', 'strike', 'tt', 'u',\n    ])\n\nframe_tags = frozenset([\n    'frameset', 'frame', 'noframes',\n    ])\n    \nhtml5_tags = frozenset([\n    'article', 'aside', 'audio', 'canvas', 'command', 'datalist',\n    'details', 'embed', 'figcaption', 'figure', 'footer', 'header',\n    'hgroup', 'keygen', 'mark', 'math', 'meter', 'nav', 'output',\n    'progress', 'rp', 'rt', 'ruby', 'section', 'source', 'summary',\n    'svg', 'time', 'track', 'video', 'wbr'\n    ])\n\n# These tags aren't standard\nnonstandard_tags = frozenset(['blink', 'marquee'])\n\n\ntags = (top_level_tags | head_tags | general_block_tags | list_tags\n        | table_tags | form_tags | special_inline_tags | phrase_tags\n        | font_style_tags | nonstandard_tags | html5_tags)\n", "src/lxml/html/soupparser.py": "\"\"\"External interface to the BeautifulSoup HTML parser.\n\"\"\"\n\n__all__ = [\"fromstring\", \"parse\", \"convert_tree\"]\n\nimport re\nfrom lxml import etree, html\n\ntry:\n    from bs4 import (\n        BeautifulSoup, Tag, Comment, ProcessingInstruction, NavigableString,\n        Declaration, Doctype)\n    _DECLARATION_OR_DOCTYPE = (Declaration, Doctype)\nexcept ImportError:\n    from BeautifulSoup import (\n        BeautifulSoup, Tag, Comment, ProcessingInstruction, NavigableString,\n        Declaration)\n    _DECLARATION_OR_DOCTYPE = Declaration\n\n\ndef fromstring(data, beautifulsoup=None, makeelement=None, **bsargs):\n    \"\"\"Parse a string of HTML data into an Element tree using the\n    BeautifulSoup parser.\n\n    Returns the root ``<html>`` Element of the tree.\n\n    You can pass a different BeautifulSoup parser through the\n    `beautifulsoup` keyword, and a diffent Element factory function\n    through the `makeelement` keyword.  By default, the standard\n    ``BeautifulSoup`` class and the default factory of `lxml.html` are\n    used.\n    \"\"\"\n    return _parse(data, beautifulsoup, makeelement, **bsargs)\n\n\ndef parse(file, beautifulsoup=None, makeelement=None, **bsargs):\n    \"\"\"Parse a file into an ElemenTree using the BeautifulSoup parser.\n\n    You can pass a different BeautifulSoup parser through the\n    `beautifulsoup` keyword, and a diffent Element factory function\n    through the `makeelement` keyword.  By default, the standard\n    ``BeautifulSoup`` class and the default factory of `lxml.html` are\n    used.\n    \"\"\"\n    if not hasattr(file, 'read'):\n        file = open(file)\n    root = _parse(file, beautifulsoup, makeelement, **bsargs)\n    return etree.ElementTree(root)\n\n\ndef convert_tree(beautiful_soup_tree, makeelement=None):\n    \"\"\"Convert a BeautifulSoup tree to a list of Element trees.\n\n    Returns a list instead of a single root Element to support\n    HTML-like soup with more than one root element.\n\n    You can pass a different Element factory through the `makeelement`\n    keyword.\n    \"\"\"\n    root = _convert_tree(beautiful_soup_tree, makeelement)\n    children = root.getchildren()\n    for child in children:\n        root.remove(child)\n    return children\n\n\n# helpers\n\ndef _parse(source, beautifulsoup, makeelement, **bsargs):\n    if beautifulsoup is None:\n        beautifulsoup = BeautifulSoup\n    if hasattr(beautifulsoup, \"HTML_ENTITIES\"):  # bs3\n        if 'convertEntities' not in bsargs:\n            bsargs['convertEntities'] = 'html'\n    if hasattr(beautifulsoup, \"DEFAULT_BUILDER_FEATURES\"):  # bs4\n        if 'features' not in bsargs:\n            bsargs['features'] = 'html.parser'  # use Python html parser\n    tree = beautifulsoup(source, **bsargs)\n    root = _convert_tree(tree, makeelement)\n    # from ET: wrap the document in a html root element, if necessary\n    if len(root) == 1 and root[0].tag == \"html\":\n        return root[0]\n    root.tag = \"html\"\n    return root\n\n\n_parse_doctype_declaration = re.compile(\n    r'(?:\\s|[<!])*DOCTYPE\\s*HTML'\n    r'(?:\\s+PUBLIC)?(?:\\s+(\\'[^\\']*\\'|\"[^\"]*\"))?'\n    r'(?:\\s+(\\'[^\\']*\\'|\"[^\"]*\"))?',\n    re.IGNORECASE).match\n\n\nclass _PseudoTag:\n    # Minimal imitation of BeautifulSoup.Tag\n    def __init__(self, contents):\n        self.name = 'html'\n        self.attrs = []\n        self.contents = contents\n\n    def __iter__(self):\n        return self.contents.__iter__()\n\n\ndef _convert_tree(beautiful_soup_tree, makeelement):\n    if makeelement is None:\n        makeelement = html.html_parser.makeelement\n\n    # Split the tree into three parts:\n    # i) everything before the root element: document type\n    # declaration, comments, processing instructions, whitespace\n    # ii) the root(s),\n    # iii) everything after the root: comments, processing\n    # instructions, whitespace\n    first_element_idx = last_element_idx = None\n    html_root = declaration = None\n    for i, e in enumerate(beautiful_soup_tree):\n        if isinstance(e, Tag):\n            if first_element_idx is None:\n                first_element_idx = i\n            last_element_idx = i\n            if html_root is None and e.name and e.name.lower() == 'html':\n                html_root = e\n        elif declaration is None and isinstance(e, _DECLARATION_OR_DOCTYPE):\n            declaration = e\n\n    # For a nice, well-formatted document, the variable roots below is\n    # a list consisting of a single <html> element. However, the document\n    # may be a soup like '<meta><head><title>Hello</head><body>Hi\n    # all<\\p>'. In this example roots is a list containing meta, head\n    # and body elements.\n    if first_element_idx is None:\n        pre_root = post_root = []\n        roots = beautiful_soup_tree.contents\n    else:\n        pre_root = beautiful_soup_tree.contents[:first_element_idx]\n        roots = beautiful_soup_tree.contents[first_element_idx:last_element_idx+1]\n        post_root = beautiful_soup_tree.contents[last_element_idx+1:]\n\n    # Reorganize so that there is one <html> root...\n    if html_root is not None:\n        # ... use existing one if possible, ...\n        i = roots.index(html_root)\n        html_root.contents = roots[:i] + html_root.contents + roots[i+1:]\n    else:\n        # ... otherwise create a new one.\n        html_root = _PseudoTag(roots)\n\n    convert_node = _init_node_converters(makeelement)\n\n    # Process pre_root\n    res_root = convert_node(html_root)\n    prev = res_root\n    for e in reversed(pre_root):\n        converted = convert_node(e)\n        if converted is not None:\n            prev.addprevious(converted)\n            prev = converted\n\n    # ditto for post_root\n    prev = res_root\n    for e in post_root:\n        converted = convert_node(e)\n        if converted is not None:\n            prev.addnext(converted)\n            prev = converted\n\n    if declaration is not None:\n        try:\n            # bs4 provides full Doctype string\n            doctype_string = declaration.output_ready()\n        except AttributeError:\n            doctype_string = declaration.string\n\n        match = _parse_doctype_declaration(doctype_string)\n        if not match:\n            # Something is wrong if we end up in here. Since soupparser should\n            # tolerate errors, do not raise Exception, just let it pass.\n            pass\n        else:\n            external_id, sys_uri = match.groups()\n            docinfo = res_root.getroottree().docinfo\n            # strip quotes and update DOCTYPE values (any of None, '', '...')\n            docinfo.public_id = external_id and external_id[1:-1]\n            docinfo.system_url = sys_uri and sys_uri[1:-1]\n\n    return res_root\n\n\ndef _init_node_converters(makeelement):\n    converters = {}\n    ordered_node_types = []\n\n    def converter(*types):\n        def add(handler):\n            for t in types:\n                converters[t] = handler\n                ordered_node_types.append(t)\n            return handler\n        return add\n\n    def find_best_converter(node):\n        for t in ordered_node_types:\n            if isinstance(node, t):\n                return converters[t]\n        return None\n\n    def convert_node(bs_node, parent=None):\n        # duplicated in convert_tag() below\n        try:\n            handler = converters[type(bs_node)]\n        except KeyError:\n            handler = converters[type(bs_node)] = find_best_converter(bs_node)\n        if handler is None:\n            return None\n        return handler(bs_node, parent)\n\n    def map_attrs(bs_attrs):\n        if isinstance(bs_attrs, dict):  # bs4\n            attribs = {}\n            for k, v in bs_attrs.items():\n                if isinstance(v, list):\n                    v = \" \".join(v)\n                attribs[k] = unescape(v)\n        else:\n            attribs = {k: unescape(v) for k, v in bs_attrs}\n        return attribs\n\n    def append_text(parent, text):\n        if len(parent) == 0:\n            parent.text = (parent.text or '') + text\n        else:\n            parent[-1].tail = (parent[-1].tail or '') + text\n\n    # converters are tried in order of their definition\n\n    @converter(Tag, _PseudoTag)\n    def convert_tag(bs_node, parent):\n        attrs = bs_node.attrs\n        if parent is not None:\n            attribs = map_attrs(attrs) if attrs else None\n            res = etree.SubElement(parent, bs_node.name, attrib=attribs)\n        else:\n            attribs = map_attrs(attrs) if attrs else {}\n            res = makeelement(bs_node.name, attrib=attribs)\n\n        for child in bs_node:\n            # avoid double recursion by inlining convert_node(), see above\n            try:\n                handler = converters[type(child)]\n            except KeyError:\n                pass\n            else:\n                if handler is not None:\n                    handler(child, res)\n                continue\n            convert_node(child, res)\n        return res\n\n    @converter(Comment)\n    def convert_comment(bs_node, parent):\n        res = html.HtmlComment(bs_node)\n        if parent is not None:\n            parent.append(res)\n        return res\n\n    @converter(ProcessingInstruction)\n    def convert_pi(bs_node, parent):\n        if bs_node.endswith('?'):\n            # The PI is of XML style (<?as df?>) but BeautifulSoup\n            # interpreted it as being SGML style (<?as df>). Fix.\n            bs_node = bs_node[:-1]\n        res = etree.ProcessingInstruction(*bs_node.split(' ', 1))\n        if parent is not None:\n            parent.append(res)\n        return res\n\n    @converter(NavigableString)\n    def convert_text(bs_node, parent):\n        if parent is not None:\n            append_text(parent, unescape(bs_node))\n        return None\n\n    return convert_node\n\n\n# copied from ET's ElementSoup\n\ntry:\n    from html.entities import name2codepoint  # Python 3\nexcept ImportError:\n    from htmlentitydefs import name2codepoint\n\n\nhandle_entities = re.compile(r\"&(\\w+);\").sub\n\n\ntry:\n    unichr\nexcept NameError:\n    # Python 3\n    unichr = chr\n\n\ndef unescape(string):\n    if not string:\n        return ''\n    # work around oddities in BeautifulSoup's entity handling\n    def unescape_entity(m):\n        try:\n            return unichr(name2codepoint[m.group(1)])\n        except KeyError:\n            return m.group(0)  # use as is\n    return handle_entities(unescape_entity, string)\n", "src/lxml/html/clean.py": "# cython: language_level=3str\n\n\"\"\"Backward-compatibility module for lxml_html_clean\"\"\"\n\ntry:\n    from lxml_html_clean import *\n\n    __all__ = [\n        \"clean_html\",\n        \"clean\",\n        \"Cleaner\",\n        \"autolink\",\n        \"autolink_html\",\n        \"word_break\",\n        \"word_break_html\",\n    ]\nexcept ImportError:\n    raise ImportError(\n        \"lxml.html.clean module is now a separate project lxml_html_clean.\\n\"\n        \"Install lxml[html_clean] or lxml_html_clean directly.\"\n    ) from None\n", "src/lxml/html/__init__.py": "# Copyright (c) 2004 Ian Bicking. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# 1. Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n# notice, this list of conditions and the following disclaimer in\n# the documentation and/or other materials provided with the\n# distribution.\n#\n# 3. Neither the name of Ian Bicking nor the names of its contributors may\n# be used to endorse or promote products derived from this software\n# without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL IAN BICKING OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\"\"\"The ``lxml.html`` tool set for HTML handling.\n\"\"\"\n\n\n__all__ = [\n    'document_fromstring', 'fragment_fromstring', 'fragments_fromstring', 'fromstring',\n    'tostring', 'Element', 'defs', 'open_in_browser', 'submit_form',\n    'find_rel_links', 'find_class', 'make_links_absolute',\n    'resolve_base_href', 'iterlinks', 'rewrite_links', 'parse']\n\n\nimport copy\nimport re\n\nfrom collections.abc import MutableMapping, MutableSet\nfrom functools import partial\nfrom urllib.parse import urljoin\n\nfrom .. import etree\nfrom . import defs\nfrom ._setmixin import SetMixin\n\n\ndef __fix_docstring(s):\n    # TODO: remove and clean up doctests\n    if not s:\n        return s\n    sub = re.compile(r\"^(\\s*)u'\", re.M).sub\n    return sub(r\"\\1'\", s)\n\n\nXHTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\"\n\n_rel_links_xpath = etree.XPath(\"descendant-or-self::a[@rel]|descendant-or-self::x:a[@rel]\",\n                               namespaces={'x':XHTML_NAMESPACE})\n_options_xpath = etree.XPath(\"descendant-or-self::option|descendant-or-self::x:option\",\n                             namespaces={'x':XHTML_NAMESPACE})\n_forms_xpath = etree.XPath(\"descendant-or-self::form|descendant-or-self::x:form\",\n                           namespaces={'x':XHTML_NAMESPACE})\n#_class_xpath = etree.XPath(r\"descendant-or-self::*[regexp:match(@class, concat('\\b', $class_name, '\\b'))]\", {'regexp': 'http://exslt.org/regular-expressions'})\n_class_xpath = etree.XPath(\"descendant-or-self::*[@class and contains(concat(' ', normalize-space(@class), ' '), concat(' ', $class_name, ' '))]\")\n_id_xpath = etree.XPath(\"descendant-or-self::*[@id=$id]\")\n_collect_string_content = etree.XPath(\"string()\")\n_iter_css_urls = re.compile(r'url\\(('+'[\"][^\"]*[\"]|'+\"['][^']*[']|\"+r'[^)]*)\\)', re.I).finditer\n_iter_css_imports = re.compile(r'@import \"(.*?)\"').finditer\n_label_xpath = etree.XPath(\"//label[@for=$id]|//x:label[@for=$id]\",\n                           namespaces={'x':XHTML_NAMESPACE})\n_archive_re = re.compile(r'[^ ]+')\n_parse_meta_refresh_url = re.compile(\n    r'[^;=]*;\\s*(?:url\\s*=\\s*)?(?P<url>.*)$', re.I).search\n\n\ndef _unquote_match(s, pos):\n    if s[:1] == '\"' and s[-1:] == '\"' or s[:1] == \"'\" and s[-1:] == \"'\":\n        return s[1:-1], pos+1\n    else:\n        return s,pos\n\n\ndef _transform_result(typ, result):\n    \"\"\"Convert the result back into the input type.\n    \"\"\"\n    if issubclass(typ, bytes):\n        return tostring(result, encoding='utf-8')\n    elif issubclass(typ, str):\n        return tostring(result, encoding='unicode')\n    else:\n        return result\n\n\ndef _nons(tag):\n    if isinstance(tag, str):\n        if tag[0] == '{' and tag[1:len(XHTML_NAMESPACE)+1] == XHTML_NAMESPACE:\n            return tag.split('}')[-1]\n    return tag\n\n\nclass Classes(MutableSet):\n    \"\"\"Provides access to an element's class attribute as a set-like collection.\n    Usage::\n\n        >>> el = fromstring('<p class=\"hidden large\">Text</p>')\n        >>> classes = el.classes  # or: classes = Classes(el.attrib)\n        >>> classes |= ['block', 'paragraph']\n        >>> el.get('class')\n        'hidden large block paragraph'\n        >>> classes.toggle('hidden')\n        False\n        >>> el.get('class')\n        'large block paragraph'\n        >>> classes -= ('some', 'classes', 'block')\n        >>> el.get('class')\n        'large paragraph'\n    \"\"\"\n    def __init__(self, attributes):\n        self._attributes = attributes\n        self._get_class_value = partial(attributes.get, 'class', '')\n\n    def add(self, value):\n        \"\"\"\n        Add a class.\n\n        This has no effect if the class is already present.\n        \"\"\"\n        if not value or re.search(r'\\s', value):\n            raise ValueError(\"Invalid class name: %r\" % value)\n        classes = self._get_class_value().split()\n        if value in classes:\n            return\n        classes.append(value)\n        self._attributes['class'] = ' '.join(classes)\n\n    def discard(self, value):\n        \"\"\"\n        Remove a class if it is currently present.\n\n        If the class is not present, do nothing.\n        \"\"\"\n        if not value or re.search(r'\\s', value):\n            raise ValueError(\"Invalid class name: %r\" % value)\n        classes = [name for name in self._get_class_value().split()\n                   if name != value]\n        if classes:\n            self._attributes['class'] = ' '.join(classes)\n        elif 'class' in self._attributes:\n            del self._attributes['class']\n\n    def remove(self, value):\n        \"\"\"\n        Remove a class; it must currently be present.\n\n        If the class is not present, raise a KeyError.\n        \"\"\"\n        if not value or re.search(r'\\s', value):\n            raise ValueError(\"Invalid class name: %r\" % value)\n        super().remove(value)\n\n    def __contains__(self, name):\n        classes = self._get_class_value()\n        return name in classes and name in classes.split()\n\n    def __iter__(self):\n        return iter(self._get_class_value().split())\n\n    def __len__(self):\n        return len(self._get_class_value().split())\n\n    # non-standard methods\n\n    def update(self, values):\n        \"\"\"\n        Add all names from 'values'.\n        \"\"\"\n        classes = self._get_class_value().split()\n        extended = False\n        for value in values:\n            if value not in classes:\n                classes.append(value)\n                extended = True\n        if extended:\n            self._attributes['class'] = ' '.join(classes)\n\n    def toggle(self, value):\n        \"\"\"\n        Add a class name if it isn't there yet, or remove it if it exists.\n\n        Returns true if the class was added (and is now enabled) and\n        false if it was removed (and is now disabled).\n        \"\"\"\n        if not value or re.search(r'\\s', value):\n            raise ValueError(\"Invalid class name: %r\" % value)\n        classes = self._get_class_value().split()\n        try:\n            classes.remove(value)\n            enabled = False\n        except ValueError:\n            classes.append(value)\n            enabled = True\n        if classes:\n            self._attributes['class'] = ' '.join(classes)\n        else:\n            del self._attributes['class']\n        return enabled\n\n\nclass HtmlMixin:\n\n    def set(self, key, value=None):\n        \"\"\"set(self, key, value=None)\n\n        Sets an element attribute.  If no value is provided, or if the value is None,\n        creates a 'boolean' attribute without value, e.g. \"<form novalidate></form>\"\n        for ``form.set('novalidate')``.\n        \"\"\"\n        super().set(key, value)\n\n    @property\n    def classes(self):\n        \"\"\"\n        A set-like wrapper around the 'class' attribute.\n        \"\"\"\n        return Classes(self.attrib)\n\n    @classes.setter\n    def classes(self, classes):\n        assert isinstance(classes, Classes)  # only allow \"el.classes |= ...\" etc.\n        value = classes._get_class_value()\n        if value:\n            self.set('class', value)\n        elif self.get('class') is not None:\n            del self.attrib['class']\n\n    @property\n    def base_url(self):\n        \"\"\"\n        Returns the base URL, given when the page was parsed.\n\n        Use with ``urlparse.urljoin(el.base_url, href)`` to get\n        absolute URLs.\n        \"\"\"\n        return self.getroottree().docinfo.URL\n\n    @property\n    def forms(self):\n        \"\"\"\n        Return a list of all the forms\n        \"\"\"\n        return _forms_xpath(self)\n\n    @property\n    def body(self):\n        \"\"\"\n        Return the <body> element.  Can be called from a child element\n        to get the document's head.\n        \"\"\"\n        return self.xpath('//body|//x:body', namespaces={'x':XHTML_NAMESPACE})[0]\n\n    @property\n    def head(self):\n        \"\"\"\n        Returns the <head> element.  Can be called from a child\n        element to get the document's head.\n        \"\"\"\n        return self.xpath('//head|//x:head', namespaces={'x':XHTML_NAMESPACE})[0]\n\n    @property\n    def label(self):\n        \"\"\"\n        Get or set any <label> element associated with this element.\n        \"\"\"\n        id = self.get('id')\n        if not id:\n            return None\n        result = _label_xpath(self, id=id)\n        if not result:\n            return None\n        else:\n            return result[0]\n\n    @label.setter\n    def label(self, label):\n        id = self.get('id')\n        if not id:\n            raise TypeError(\n                \"You cannot set a label for an element (%r) that has no id\"\n                % self)\n        if _nons(label.tag) != 'label':\n            raise TypeError(\n                \"You can only assign label to a label element (not %r)\"\n                % label)\n        label.set('for', id)\n\n    @label.deleter\n    def label(self):\n        label = self.label\n        if label is not None:\n            del label.attrib['for']\n\n    def drop_tree(self):\n        \"\"\"\n        Removes this element from the tree, including its children and\n        text.  The tail text is joined to the previous element or\n        parent.\n        \"\"\"\n        parent = self.getparent()\n        assert parent is not None\n        if self.tail:\n            previous = self.getprevious()\n            if previous is None:\n                parent.text = (parent.text or '') + self.tail\n            else:\n                previous.tail = (previous.tail or '') + self.tail\n        parent.remove(self)\n\n    def drop_tag(self):\n        \"\"\"\n        Remove the tag, but not its children or text.  The children and text\n        are merged into the parent.\n\n        Example::\n\n            >>> h = fragment_fromstring('<div>Hello <b>World!</b></div>')\n            >>> h.find('.//b').drop_tag()\n            >>> print(tostring(h, encoding='unicode'))\n            <div>Hello World!</div>\n        \"\"\"\n        parent = self.getparent()\n        assert parent is not None\n        previous = self.getprevious()\n        if self.text and isinstance(self.tag, str):\n            # not a Comment, etc.\n            if previous is None:\n                parent.text = (parent.text or '') + self.text\n            else:\n                previous.tail = (previous.tail or '') + self.text\n        if self.tail:\n            if len(self):\n                last = self[-1]\n                last.tail = (last.tail or '') + self.tail\n            elif previous is None:\n                parent.text = (parent.text or '') + self.tail\n            else:\n                previous.tail = (previous.tail or '') + self.tail\n        index = parent.index(self)\n        parent[index:index+1] = self[:]\n\n    def find_rel_links(self, rel):\n        \"\"\"\n        Find any links like ``<a rel=\"{rel}\">...</a>``; returns a list of elements.\n        \"\"\"\n        rel = rel.lower()\n        return [el for el in _rel_links_xpath(self)\n                if el.get('rel').lower() == rel]\n\n    def find_class(self, class_name):\n        \"\"\"\n        Find any elements with the given class name.\n        \"\"\"\n        return _class_xpath(self, class_name=class_name)\n\n    def get_element_by_id(self, id, *default):\n        \"\"\"\n        Get the first element in a document with the given id.  If none is\n        found, return the default argument if provided or raise KeyError\n        otherwise.\n\n        Note that there can be more than one element with the same id,\n        and this isn't uncommon in HTML documents found in the wild.\n        Browsers return only the first match, and this function does\n        the same.\n        \"\"\"\n        try:\n            # FIXME: should this check for multiple matches?\n            # browsers just return the first one\n            return _id_xpath(self, id=id)[0]\n        except IndexError:\n            if default:\n                return default[0]\n            else:\n                raise KeyError(id)\n\n    def text_content(self):\n        \"\"\"\n        Return the text content of the tag (and the text in any children).\n        \"\"\"\n        return _collect_string_content(self)\n\n    def cssselect(self, expr, translator='html'):\n        \"\"\"\n        Run the CSS expression on this element and its children,\n        returning a list of the results.\n\n        Equivalent to lxml.cssselect.CSSSelect(expr, translator='html')(self)\n        -- note that pre-compiling the expression can provide a substantial\n        speedup.\n        \"\"\"\n        # Do the import here to make the dependency optional.\n        from lxml.cssselect import CSSSelector\n        return CSSSelector(expr, translator=translator)(self)\n\n    ########################################\n    ## Link functions\n    ########################################\n\n    def make_links_absolute(self, base_url=None, resolve_base_href=True,\n                            handle_failures=None):\n        \"\"\"\n        Make all links in the document absolute, given the\n        ``base_url`` for the document (the full URL where the document\n        came from), or if no ``base_url`` is given, then the ``.base_url``\n        of the document.\n\n        If ``resolve_base_href`` is true, then any ``<base href>``\n        tags in the document are used *and* removed from the document.\n        If it is false then any such tag is ignored.\n\n        If ``handle_failures`` is None (default), a failure to process\n        a URL will abort the processing.  If set to 'ignore', errors\n        are ignored.  If set to 'discard', failing URLs will be removed.\n        \"\"\"\n        if base_url is None:\n            base_url = self.base_url\n            if base_url is None:\n                raise TypeError(\n                    \"No base_url given, and the document has no base_url\")\n        if resolve_base_href:\n            self.resolve_base_href()\n\n        if handle_failures == 'ignore':\n            def link_repl(href):\n                try:\n                    return urljoin(base_url, href)\n                except ValueError:\n                    return href\n        elif handle_failures == 'discard':\n            def link_repl(href):\n                try:\n                    return urljoin(base_url, href)\n                except ValueError:\n                    return None\n        elif handle_failures is None:\n            def link_repl(href):\n                return urljoin(base_url, href)\n        else:\n            raise ValueError(\n                \"unexpected value for handle_failures: %r\" % handle_failures)\n\n        self.rewrite_links(link_repl)\n\n    def resolve_base_href(self, handle_failures=None):\n        \"\"\"\n        Find any ``<base href>`` tag in the document, and apply its\n        values to all links found in the document.  Also remove the\n        tag once it has been applied.\n\n        If ``handle_failures`` is None (default), a failure to process\n        a URL will abort the processing.  If set to 'ignore', errors\n        are ignored.  If set to 'discard', failing URLs will be removed.\n        \"\"\"\n        base_href = None\n        basetags = self.xpath('//base[@href]|//x:base[@href]',\n                              namespaces={'x': XHTML_NAMESPACE})\n        for b in basetags:\n            base_href = b.get('href')\n            b.drop_tree()\n        if not base_href:\n            return\n        self.make_links_absolute(base_href, resolve_base_href=False,\n                                 handle_failures=handle_failures)\n\n    def iterlinks(self):\n        \"\"\"\n        Yield (element, attribute, link, pos), where attribute may be None\n        (indicating the link is in the text).  ``pos`` is the position\n        where the link occurs; often 0, but sometimes something else in\n        the case of links in stylesheets or style tags.\n\n        Note: <base href> is *not* taken into account in any way.  The\n        link you get is exactly the link in the document.\n\n        Note: multiple links inside of a single text string or\n        attribute value are returned in reversed order.  This makes it\n        possible to replace or delete them from the text string value\n        based on their reported text positions.  Otherwise, a\n        modification at one text position can change the positions of\n        links reported later on.\n        \"\"\"\n        link_attrs = defs.link_attrs\n        for el in self.iter(etree.Element):\n            attribs = el.attrib\n            tag = _nons(el.tag)\n            if tag == 'object':\n                codebase = None\n                ## <object> tags have attributes that are relative to\n                ## codebase\n                if 'codebase' in attribs:\n                    codebase = el.get('codebase')\n                    yield (el, 'codebase', codebase, 0)\n                for attrib in ('classid', 'data'):\n                    if attrib in attribs:\n                        value = el.get(attrib)\n                        if codebase is not None:\n                            value = urljoin(codebase, value)\n                        yield (el, attrib, value, 0)\n                if 'archive' in attribs:\n                    for match in _archive_re.finditer(el.get('archive')):\n                        value = match.group(0)\n                        if codebase is not None:\n                            value = urljoin(codebase, value)\n                        yield (el, 'archive', value, match.start())\n            else:\n                for attrib in link_attrs:\n                    if attrib in attribs:\n                        yield (el, attrib, attribs[attrib], 0)\n            if tag == 'meta':\n                http_equiv = attribs.get('http-equiv', '').lower()\n                if http_equiv == 'refresh':\n                    content = attribs.get('content', '')\n                    match = _parse_meta_refresh_url(content)\n                    url = (match.group('url') if match else content).strip()\n                    # unexpected content means the redirect won't work, but we might\n                    # as well be permissive and return the entire string.\n                    if url:\n                        url, pos = _unquote_match(\n                            url, match.start('url') if match else content.find(url))\n                        yield (el, 'content', url, pos)\n            elif tag == 'param':\n                valuetype = el.get('valuetype') or ''\n                if valuetype.lower() == 'ref':\n                    ## FIXME: while it's fine we *find* this link,\n                    ## according to the spec we aren't supposed to\n                    ## actually change the value, including resolving\n                    ## it.  It can also still be a link, even if it\n                    ## doesn't have a valuetype=\"ref\" (which seems to be the norm)\n                    ## http://www.w3.org/TR/html401/struct/objects.html#adef-valuetype\n                    yield (el, 'value', el.get('value'), 0)\n            elif tag == 'style' and el.text:\n                urls = [\n                    # (start_pos, url)\n                    _unquote_match(match.group(1), match.start(1))[::-1]\n                    for match in _iter_css_urls(el.text)\n                    ] + [\n                    (match.start(1), match.group(1))\n                    for match in _iter_css_imports(el.text)\n                    ]\n                if urls:\n                    # sort by start pos to bring both match sets back into order\n                    # and reverse the list to report correct positions despite\n                    # modifications\n                    urls.sort(reverse=True)\n                    for start, url in urls:\n                        yield (el, None, url, start)\n            if 'style' in attribs:\n                urls = list(_iter_css_urls(attribs['style']))\n                if urls:\n                    # return in reversed order to simplify in-place modifications\n                    for match in urls[::-1]:\n                        url, start = _unquote_match(match.group(1), match.start(1))\n                        yield (el, 'style', url, start)\n\n    def rewrite_links(self, link_repl_func, resolve_base_href=True,\n                      base_href=None):\n        \"\"\"\n        Rewrite all the links in the document.  For each link\n        ``link_repl_func(link)`` will be called, and the return value\n        will replace the old link.\n\n        Note that links may not be absolute (unless you first called\n        ``make_links_absolute()``), and may be internal (e.g.,\n        ``'#anchor'``).  They can also be values like\n        ``'mailto:email'`` or ``'javascript:expr'``.\n\n        If you give ``base_href`` then all links passed to\n        ``link_repl_func()`` will take that into account.\n\n        If the ``link_repl_func`` returns None, the attribute or\n        tag text will be removed completely.\n        \"\"\"\n        if base_href is not None:\n            # FIXME: this can be done in one pass with a wrapper\n            # around link_repl_func\n            self.make_links_absolute(\n                base_href, resolve_base_href=resolve_base_href)\n        elif resolve_base_href:\n            self.resolve_base_href()\n\n        for el, attrib, link, pos in self.iterlinks():\n            new_link = link_repl_func(link.strip())\n            if new_link == link:\n                continue\n            if new_link is None:\n                # Remove the attribute or element content\n                if attrib is None:\n                    el.text = ''\n                else:\n                    del el.attrib[attrib]\n                continue\n\n            if attrib is None:\n                new = el.text[:pos] + new_link + el.text[pos+len(link):]\n                el.text = new\n            else:\n                cur = el.get(attrib)\n                if not pos and len(cur) == len(link):\n                    new = new_link  # most common case\n                else:\n                    new = cur[:pos] + new_link + cur[pos+len(link):]\n                el.set(attrib, new)\n\n\nclass _MethodFunc:\n    \"\"\"\n    An object that represents a method on an element as a function;\n    the function takes either an element or an HTML string.  It\n    returns whatever the function normally returns, or if the function\n    works in-place (and so returns None) it returns a serialized form\n    of the resulting document.\n    \"\"\"\n    def __init__(self, name, copy=False, source_class=HtmlMixin):\n        self.name = name\n        self.copy = copy\n        self.__doc__ = getattr(source_class, self.name).__doc__\n    def __call__(self, doc, *args, **kw):\n        result_type = type(doc)\n        if isinstance(doc, (str, bytes)):\n            if 'copy' in kw:\n                raise TypeError(\n                    \"The keyword 'copy' can only be used with element inputs to %s, not a string input\" % self.name)\n            doc = fromstring(doc, **kw)\n        else:\n            if 'copy' in kw:\n                make_a_copy = kw.pop('copy')\n            else:\n                make_a_copy = self.copy\n            if make_a_copy:\n                doc = copy.deepcopy(doc)\n        meth = getattr(doc, self.name)\n        result = meth(*args, **kw)\n        # FIXME: this None test is a bit sloppy\n        if result is None:\n            # Then return what we got in\n            return _transform_result(result_type, doc)\n        else:\n            return result\n\n\nfind_rel_links = _MethodFunc('find_rel_links', copy=False)\nfind_class = _MethodFunc('find_class', copy=False)\nmake_links_absolute = _MethodFunc('make_links_absolute', copy=True)\nresolve_base_href = _MethodFunc('resolve_base_href', copy=True)\niterlinks = _MethodFunc('iterlinks', copy=False)\nrewrite_links = _MethodFunc('rewrite_links', copy=True)\n\n\nclass HtmlComment(HtmlMixin, etree.CommentBase):\n    pass\n\n\nclass HtmlElement(HtmlMixin, etree.ElementBase):\n    pass\n\n\nclass HtmlProcessingInstruction(HtmlMixin, etree.PIBase):\n    pass\n\n\nclass HtmlEntity(HtmlMixin, etree.EntityBase):\n    pass\n\n\nclass HtmlElementClassLookup(etree.CustomElementClassLookup):\n    \"\"\"A lookup scheme for HTML Element classes.\n\n    To create a lookup instance with different Element classes, pass a tag\n    name mapping of Element classes in the ``classes`` keyword argument and/or\n    a tag name mapping of Mixin classes in the ``mixins`` keyword argument.\n    The special key '*' denotes a Mixin class that should be mixed into all\n    Element classes.\n    \"\"\"\n    _default_element_classes = {}\n\n    def __init__(self, classes=None, mixins=None):\n        etree.CustomElementClassLookup.__init__(self)\n        if classes is None:\n            classes = self._default_element_classes.copy()\n        if mixins:\n            mixers = {}\n            for name, value in mixins:\n                if name == '*':\n                    for n in classes.keys():\n                        mixers.setdefault(n, []).append(value)\n                else:\n                    mixers.setdefault(name, []).append(value)\n            for name, mix_bases in mixers.items():\n                cur = classes.get(name, HtmlElement)\n                bases = tuple(mix_bases + [cur])\n                classes[name] = type(cur.__name__, bases, {})\n        self._element_classes = classes\n\n    def lookup(self, node_type, document, namespace, name):\n        if node_type == 'element':\n            return self._element_classes.get(name.lower(), HtmlElement)\n        elif node_type == 'comment':\n            return HtmlComment\n        elif node_type == 'PI':\n            return HtmlProcessingInstruction\n        elif node_type == 'entity':\n            return HtmlEntity\n        # Otherwise normal lookup\n        return None\n\n\n################################################################################\n# parsing\n################################################################################\n\n_looks_like_full_html_unicode = re.compile(\n    r'^\\s*<(?:html|!doctype)', re.I).match\n_looks_like_full_html_bytes = re.compile(\n    br'^\\s*<(?:html|!doctype)', re.I).match\n\n\ndef document_fromstring(html, parser=None, ensure_head_body=False, **kw):\n    if parser is None:\n        parser = html_parser\n    value = etree.fromstring(html, parser, **kw)\n    if value is None:\n        raise etree.ParserError(\n            \"Document is empty\")\n    if ensure_head_body and value.find('head') is None:\n        value.insert(0, Element('head'))\n    if ensure_head_body and value.find('body') is None:\n        value.append(Element('body'))\n    return value\n\n\ndef fragments_fromstring(html, no_leading_text=False, base_url=None,\n                         parser=None, **kw):\n    \"\"\"Parses several HTML elements, returning a list of elements.\n\n    The first item in the list may be a string.\n    If no_leading_text is true, then it will be an error if there is\n    leading text, and it will always be a list of only elements.\n\n    base_url will set the document's base_url attribute\n    (and the tree's docinfo.URL).\n    \"\"\"\n    if parser is None:\n        parser = html_parser\n    # FIXME: check what happens when you give html with a body, head, etc.\n    if isinstance(html, bytes):\n        if not _looks_like_full_html_bytes(html):\n            # can't use %-formatting in early Py3 versions\n            html = (b'<html><body>' + html +\n                    b'</body></html>')\n    else:\n        if not _looks_like_full_html_unicode(html):\n            html = '<html><body>%s</body></html>' % html\n    doc = document_fromstring(html, parser=parser, base_url=base_url, **kw)\n    assert _nons(doc.tag) == 'html'\n    bodies = [e for e in doc if _nons(e.tag) == 'body']\n    assert len(bodies) == 1, (\"too many bodies: %r in %r\" % (bodies, html))\n    body = bodies[0]\n    elements = []\n    if no_leading_text and body.text and body.text.strip():\n        raise etree.ParserError(\n            \"There is leading text: %r\" % body.text)\n    if body.text and body.text.strip():\n        elements.append(body.text)\n    elements.extend(body)\n    # FIXME: removing the reference to the parent artificial document\n    # would be nice\n    return elements\n\n\ndef fragment_fromstring(html, create_parent=False, base_url=None,\n                        parser=None, **kw):\n    \"\"\"\n    Parses a single HTML element; it is an error if there is more than\n    one element, or if anything but whitespace precedes or follows the\n    element.\n\n    If ``create_parent`` is true (or is a tag name) then a parent node\n    will be created to encapsulate the HTML in a single element.  In this\n    case, leading or trailing text is also allowed, as are multiple elements\n    as result of the parsing.\n\n    Passing a ``base_url`` will set the document's ``base_url`` attribute\n    (and the tree's docinfo.URL).\n    \"\"\"\n    if parser is None:\n        parser = html_parser\n\n    accept_leading_text = bool(create_parent)\n\n    elements = fragments_fromstring(\n        html, parser=parser, no_leading_text=not accept_leading_text,\n        base_url=base_url, **kw)\n\n    if create_parent:\n        if not isinstance(create_parent, str):\n            create_parent = 'div'\n        new_root = Element(create_parent)\n        if elements:\n            if isinstance(elements[0], str):\n                new_root.text = elements[0]\n                del elements[0]\n            new_root.extend(elements)\n        return new_root\n\n    if not elements:\n        raise etree.ParserError('No elements found')\n    if len(elements) > 1:\n        raise etree.ParserError(\n            \"Multiple elements found (%s)\"\n            % ', '.join([_element_name(e) for e in elements]))\n    el = elements[0]\n    if el.tail and el.tail.strip():\n        raise etree.ParserError(\n            \"Element followed by text: %r\" % el.tail)\n    el.tail = None\n    return el\n\n\ndef fromstring(html, base_url=None, parser=None, **kw):\n    \"\"\"\n    Parse the html, returning a single element/document.\n\n    This tries to minimally parse the chunk of text, without knowing if it\n    is a fragment or a document.\n\n    base_url will set the document's base_url attribute (and the tree's docinfo.URL)\n    \"\"\"\n    if parser is None:\n        parser = html_parser\n    if isinstance(html, bytes):\n        is_full_html = _looks_like_full_html_bytes(html)\n    else:\n        is_full_html = _looks_like_full_html_unicode(html)\n    doc = document_fromstring(html, parser=parser, base_url=base_url, **kw)\n    if is_full_html:\n        return doc\n    # otherwise, lets parse it out...\n    bodies = doc.findall('body')\n    if not bodies:\n        bodies = doc.findall('{%s}body' % XHTML_NAMESPACE)\n    if bodies:\n        body = bodies[0]\n        if len(bodies) > 1:\n            # Somehow there are multiple bodies, which is bad, but just\n            # smash them into one body\n            for other_body in bodies[1:]:\n                if other_body.text:\n                    if len(body):\n                        body[-1].tail = (body[-1].tail or '') + other_body.text\n                    else:\n                        body.text = (body.text or '') + other_body.text\n                body.extend(other_body)\n                # We'll ignore tail\n                # I guess we are ignoring attributes too\n                other_body.drop_tree()\n    else:\n        body = None\n    heads = doc.findall('head')\n    if not heads:\n        heads = doc.findall('{%s}head' % XHTML_NAMESPACE)\n    if heads:\n        # Well, we have some sort of structure, so lets keep it all\n        head = heads[0]\n        if len(heads) > 1:\n            for other_head in heads[1:]:\n                head.extend(other_head)\n                # We don't care about text or tail in a head\n                other_head.drop_tree()\n        return doc\n    if body is None:\n        return doc\n    if (len(body) == 1 and (not body.text or not body.text.strip())\n        and (not body[-1].tail or not body[-1].tail.strip())):\n        # The body has just one element, so it was probably a single\n        # element passed in\n        return body[0]\n    # Now we have a body which represents a bunch of tags which have the\n    # content that was passed in.  We will create a fake container, which\n    # is the body tag, except <body> implies too much structure.\n    if _contains_block_level_tag(body):\n        body.tag = 'div'\n    else:\n        body.tag = 'span'\n    return body\n\n\ndef parse(filename_or_url, parser=None, base_url=None, **kw):\n    \"\"\"\n    Parse a filename, URL, or file-like object into an HTML document\n    tree.  Note: this returns a tree, not an element.  Use\n    ``parse(...).getroot()`` to get the document root.\n\n    You can override the base URL with the ``base_url`` keyword.  This\n    is most useful when parsing from a file-like object.\n    \"\"\"\n    if parser is None:\n        parser = html_parser\n    return etree.parse(filename_or_url, parser, base_url=base_url, **kw)\n\n\ndef _contains_block_level_tag(el):\n    # FIXME: I could do this with XPath, but would that just be\n    # unnecessarily slow?\n    for el in el.iter(etree.Element):\n        if _nons(el.tag) in defs.block_tags:\n            return True\n    return False\n\n\ndef _element_name(el):\n    if isinstance(el, etree.CommentBase):\n        return 'comment'\n    elif isinstance(el, str):\n        return 'string'\n    else:\n        return _nons(el.tag)\n\n\n################################################################################\n# form handling\n################################################################################\n\nclass FormElement(HtmlElement):\n    \"\"\"\n    Represents a <form> element.\n    \"\"\"\n\n    @property\n    def inputs(self):\n        \"\"\"\n        Returns an accessor for all the input elements in the form.\n\n        See `InputGetter` for more information about the object.\n        \"\"\"\n        return InputGetter(self)\n\n    @property\n    def fields(self):\n        \"\"\"\n        Dictionary-like object that represents all the fields in this\n        form.  You can set values in this dictionary to effect the\n        form.\n        \"\"\"\n        return FieldsDict(self.inputs)\n\n    @fields.setter\n    def fields(self, value):\n        fields = self.fields\n        prev_keys = fields.keys()\n        for key, value in value.items():\n            if key in prev_keys:\n                prev_keys.remove(key)\n            fields[key] = value\n        for key in prev_keys:\n            if key is None:\n                # Case of an unnamed input; these aren't really\n                # expressed in form_values() anyway.\n                continue\n            fields[key] = None\n\n    def _name(self):\n        if self.get('name'):\n            return self.get('name')\n        elif self.get('id'):\n            return '#' + self.get('id')\n        iter_tags = self.body.iter\n        forms = list(iter_tags('form'))\n        if not forms:\n            forms = list(iter_tags('{%s}form' % XHTML_NAMESPACE))\n        return str(forms.index(self))\n\n    def form_values(self):\n        \"\"\"\n        Return a list of tuples of the field values for the form.\n        This is suitable to be passed to ``urllib.urlencode()``.\n        \"\"\"\n        results = []\n        for el in self.inputs:\n            name = el.name\n            if not name or 'disabled' in el.attrib:\n                continue\n            tag = _nons(el.tag)\n            if tag == 'textarea':\n                results.append((name, el.value))\n            elif tag == 'select':\n                value = el.value\n                if el.multiple:\n                    for v in value:\n                        results.append((name, v))\n                elif value is not None:\n                    results.append((name, el.value))\n            else:\n                assert tag == 'input', (\n                    \"Unexpected tag: %r\" % el)\n                if el.checkable and not el.checked:\n                    continue\n                if el.type in ('submit', 'image', 'reset', 'file'):\n                    continue\n                value = el.value\n                if value is not None:\n                    results.append((name, el.value))\n        return results\n\n    @property\n    def action(self):\n        \"\"\"\n        Get/set the form's ``action`` attribute.\n        \"\"\"\n        base_url = self.base_url\n        action = self.get('action')\n        if base_url and action is not None:\n            return urljoin(base_url, action)\n        else:\n            return action\n\n    @action.setter\n    def action(self, value):\n        self.set('action', value)\n\n    @action.deleter\n    def action(self):\n        attrib = self.attrib\n        if 'action' in attrib:\n            del attrib['action']\n\n    @property\n    def method(self):\n        \"\"\"\n        Get/set the form's method.  Always returns a capitalized\n        string, and defaults to ``'GET'``\n        \"\"\"\n        return self.get('method', 'GET').upper()\n\n    @method.setter\n    def method(self, value):\n        self.set('method', value.upper())\n\n\nHtmlElementClassLookup._default_element_classes['form'] = FormElement\n\n\ndef submit_form(form, extra_values=None, open_http=None):\n    \"\"\"\n    Helper function to submit a form.  Returns a file-like object, as from\n    ``urllib.urlopen()``.  This object also has a ``.geturl()`` function,\n    which shows the URL if there were any redirects.\n\n    You can use this like::\n\n        form = doc.forms[0]\n        form.inputs['foo'].value = 'bar' # etc\n        response = form.submit()\n        doc = parse(response)\n        doc.make_links_absolute(response.geturl())\n\n    To change the HTTP requester, pass a function as ``open_http`` keyword\n    argument that opens the URL for you.  The function must have the following\n    signature::\n\n        open_http(method, URL, values)\n\n    The action is one of 'GET' or 'POST', the URL is the target URL as a\n    string, and the values are a sequence of ``(name, value)`` tuples with the\n    form data.\n    \"\"\"\n    values = form.form_values()\n    if extra_values:\n        if hasattr(extra_values, 'items'):\n            extra_values = extra_values.items()\n        values.extend(extra_values)\n    if open_http is None:\n        open_http = open_http_urllib\n    if form.action:\n        url = form.action\n    else:\n        url = form.base_url\n    return open_http(form.method, url, values)\n\n\ndef open_http_urllib(method, url, values):\n    if not url:\n        raise ValueError(\"cannot submit, no URL provided\")\n    ## FIXME: should test that it's not a relative URL or something\n    try:\n        from urllib import urlencode, urlopen\n    except ImportError: # Python 3\n        from urllib.request import urlopen\n        from urllib.parse import urlencode\n    if method == 'GET':\n        if '?' in url:\n            url += '&'\n        else:\n            url += '?'\n        url += urlencode(values)\n        data = None\n    else:\n        data = urlencode(values)\n        if not isinstance(data, bytes):\n            data = data.encode('ASCII')\n    return urlopen(url, data)\n\n\nclass FieldsDict(MutableMapping):\n\n    def __init__(self, inputs):\n        self.inputs = inputs\n    def __getitem__(self, item):\n        return self.inputs[item].value\n    def __setitem__(self, item, value):\n        self.inputs[item].value = value\n    def __delitem__(self, item):\n        raise KeyError(\n            \"You cannot remove keys from ElementDict\")\n    def keys(self):\n        return self.inputs.keys()\n    def __contains__(self, item):\n        return item in self.inputs\n    def __iter__(self):\n        return iter(self.inputs.keys())\n    def __len__(self):\n        return len(self.inputs)\n\n    def __repr__(self):\n        return '<%s for form %s>' % (\n            self.__class__.__name__,\n            self.inputs.form._name())\n\n\nclass InputGetter:\n\n    \"\"\"\n    An accessor that represents all the input fields in a form.\n\n    You can get fields by name from this, with\n    ``form.inputs['field_name']``.  If there are a set of checkboxes\n    with the same name, they are returned as a list (a `CheckboxGroup`\n    which also allows value setting).  Radio inputs are handled\n    similarly.  Use ``.keys()`` and ``.items()`` to process all fields\n    in this way.\n\n    You can also iterate over this to get all input elements.  This\n    won't return the same thing as if you get all the names, as\n    checkboxes and radio elements are returned individually.\n    \"\"\"\n\n    def __init__(self, form):\n        self.form = form\n\n    def __repr__(self):\n        return '<%s for form %s>' % (\n            self.__class__.__name__,\n            self.form._name())\n\n    ## FIXME: there should be more methods, and it's unclear if this is\n    ## a dictionary-like object or list-like object\n\n    def __getitem__(self, name):\n        fields = [field for field in self if field.name == name]\n        if not fields:\n            raise KeyError(\"No input element with the name %r\" % name)\n\n        input_type = fields[0].get('type')\n        if input_type == 'radio' and len(fields) > 1:\n            group = RadioGroup(fields)\n            group.name = name\n            return group\n        elif input_type == 'checkbox' and len(fields) > 1:\n            group = CheckboxGroup(fields)\n            group.name = name\n            return group\n        else:\n            # I don't like throwing away elements like this\n            return fields[0]\n\n    def __contains__(self, name):\n        for field in self:\n            if field.name == name:\n                return True\n        return False\n\n    def keys(self):\n        \"\"\"\n        Returns all unique field names, in document order.\n\n        :return: A list of all unique field names.\n        \"\"\"\n        names = []\n        seen = {None}\n        for el in self:\n            name = el.name\n            if name not in seen:\n                names.append(name)\n                seen.add(name)\n        return names\n\n    def items(self):\n        \"\"\"\n        Returns all fields with their names, similar to dict.items().\n\n        :return: A list of (name, field) tuples.\n        \"\"\"\n        items = []\n        seen = set()\n        for el in self:\n            name = el.name\n            if name not in seen:\n                seen.add(name)\n                items.append((name, self[name]))\n        return items\n\n    def __iter__(self):\n        return self.form.iter('select', 'input', 'textarea')\n\n    def __len__(self):\n        return sum(1 for _ in self)\n\n\nclass InputMixin:\n    \"\"\"\n    Mix-in for all input elements (input, select, and textarea)\n    \"\"\"\n    @property\n    def name(self):\n        \"\"\"\n        Get/set the name of the element\n        \"\"\"\n        return self.get('name')\n\n    @name.setter\n    def name(self, value):\n        self.set('name', value)\n\n    @name.deleter\n    def name(self):\n        attrib = self.attrib\n        if 'name' in attrib:\n            del attrib['name']\n\n    def __repr__(self):\n        type_name = getattr(self, 'type', None)\n        if type_name:\n            type_name = ' type=%r' % type_name\n        else:\n            type_name = ''\n        return '<%s %x name=%r%s>' % (\n            self.__class__.__name__, id(self), self.name, type_name)\n\n\nclass TextareaElement(InputMixin, HtmlElement):\n    \"\"\"\n    ``<textarea>`` element.  You can get the name with ``.name`` and\n    get/set the value with ``.value``\n    \"\"\"\n    @property\n    def value(self):\n        \"\"\"\n        Get/set the value (which is the contents of this element)\n        \"\"\"\n        content = self.text or ''\n        if self.tag.startswith(\"{%s}\" % XHTML_NAMESPACE):\n            serialisation_method = 'xml'\n        else:\n            serialisation_method = 'html'\n        for el in self:\n            # it's rare that we actually get here, so let's not use ''.join()\n            content += etree.tostring(\n                el, method=serialisation_method, encoding='unicode')\n        return content\n\n    @value.setter\n    def value(self, value):\n        del self[:]\n        self.text = value\n\n    @value.deleter\n    def value(self):\n        self.text = ''\n        del self[:]\n\n\nHtmlElementClassLookup._default_element_classes['textarea'] = TextareaElement\n\n\nclass SelectElement(InputMixin, HtmlElement):\n    \"\"\"\n    ``<select>`` element.  You can get the name with ``.name``.\n\n    ``.value`` will be the value of the selected option, unless this\n    is a multi-select element (``<select multiple>``), in which case\n    it will be a set-like object.  In either case ``.value_options``\n    gives the possible values.\n\n    The boolean attribute ``.multiple`` shows if this is a\n    multi-select.\n    \"\"\"\n    @property\n    def value(self):\n        \"\"\"\n        Get/set the value of this select (the selected option).\n\n        If this is a multi-select, this is a set-like object that\n        represents all the selected options.\n        \"\"\"\n        if self.multiple:\n            return MultipleSelectOptions(self)\n        options = _options_xpath(self)\n\n        try:\n            selected_option = next(el for el in reversed(options) if el.get('selected') is not None)\n        except StopIteration:\n            try:\n                selected_option = next(el for el in options if el.get('disabled') is None)\n            except StopIteration:\n                return None\n        value = selected_option.get('value')\n        if value is None:\n            value = (selected_option.text or '').strip()\n        return value\n\n    @value.setter\n    def value(self, value):\n        if self.multiple:\n            if isinstance(value, str):\n                raise TypeError(\"You must pass in a sequence\")\n            values = self.value\n            values.clear()\n            values.update(value)\n            return\n        checked_option = None\n        if value is not None:\n            for el in _options_xpath(self):\n                opt_value = el.get('value')\n                if opt_value is None:\n                    opt_value = (el.text or '').strip()\n                if opt_value == value:\n                    checked_option = el\n                    break\n            else:\n                raise ValueError(\n                    \"There is no option with the value of %r\" % value)\n        for el in _options_xpath(self):\n            if 'selected' in el.attrib:\n                del el.attrib['selected']\n        if checked_option is not None:\n            checked_option.set('selected', '')\n\n    @value.deleter\n    def value(self):\n        # FIXME: should del be allowed at all?\n        if self.multiple:\n            self.value.clear()\n        else:\n            self.value = None\n\n    @property\n    def value_options(self):\n        \"\"\"\n        All the possible values this select can have (the ``value``\n        attribute of all the ``<option>`` elements.\n        \"\"\"\n        options = []\n        for el in _options_xpath(self):\n            value = el.get('value')\n            if value is None:\n                value = (el.text or '').strip()\n            options.append(value)\n        return options\n\n    @property\n    def multiple(self):\n        \"\"\"\n        Boolean attribute: is there a ``multiple`` attribute on this element.\n        \"\"\"\n        return 'multiple' in self.attrib\n\n    @multiple.setter\n    def multiple(self, value):\n        if value:\n            self.set('multiple', '')\n        elif 'multiple' in self.attrib:\n            del self.attrib['multiple']\n\n\nHtmlElementClassLookup._default_element_classes['select'] = SelectElement\n\n\nclass MultipleSelectOptions(SetMixin):\n    \"\"\"\n    Represents all the selected options in a ``<select multiple>`` element.\n\n    You can add to this set-like option to select an option, or remove\n    to unselect the option.\n    \"\"\"\n\n    def __init__(self, select):\n        self.select = select\n\n    @property\n    def options(self):\n        \"\"\"\n        Iterator of all the ``<option>`` elements.\n        \"\"\"\n        return iter(_options_xpath(self.select))\n\n    def __iter__(self):\n        for option in self.options:\n            if 'selected' in option.attrib:\n                opt_value = option.get('value')\n                if opt_value is None:\n                    opt_value = (option.text or '').strip()\n                yield opt_value\n\n    def add(self, item):\n        for option in self.options:\n            opt_value = option.get('value')\n            if opt_value is None:\n                opt_value = (option.text or '').strip()\n            if opt_value == item:\n                option.set('selected', '')\n                break\n        else:\n            raise ValueError(\n                \"There is no option with the value %r\" % item)\n\n    def remove(self, item):\n        for option in self.options:\n            opt_value = option.get('value')\n            if opt_value is None:\n                opt_value = (option.text or '').strip()\n            if opt_value == item:\n                if 'selected' in option.attrib:\n                    del option.attrib['selected']\n                else:\n                    raise ValueError(\n                        \"The option %r is not currently selected\" % item)\n                break\n        else:\n            raise ValueError(\n                \"There is not option with the value %r\" % item)\n\n    def __repr__(self):\n        return '<%s {%s} for select name=%r>' % (\n            self.__class__.__name__,\n            ', '.join([repr(v) for v in self]),\n            self.select.name)\n\n\nclass RadioGroup(list):\n    \"\"\"\n    This object represents several ``<input type=radio>`` elements\n    that have the same name.\n\n    You can use this like a list, but also use the property\n    ``.value`` to check/uncheck inputs.  Also you can use\n    ``.value_options`` to get the possible values.\n    \"\"\"\n    @property\n    def value(self):\n        \"\"\"\n        Get/set the value, which checks the radio with that value (and\n        unchecks any other value).\n        \"\"\"\n        for el in self:\n            if 'checked' in el.attrib:\n                return el.get('value')\n        return None\n\n    @value.setter\n    def value(self, value):\n        checked_option = None\n        if value is not None:\n            for el in self:\n                if el.get('value') == value:\n                    checked_option = el\n                    break\n            else:\n                raise ValueError(\"There is no radio input with the value %r\" % value)\n        for el in self:\n            if 'checked' in el.attrib:\n                del el.attrib['checked']\n        if checked_option is not None:\n            checked_option.set('checked', '')\n\n    @value.deleter\n    def value(self):\n        self.value = None\n\n    @property\n    def value_options(self):\n        \"\"\"\n        Returns a list of all the possible values.\n        \"\"\"\n        return [el.get('value') for el in self]\n\n    def __repr__(self):\n        return '%s(%s)' % (\n            self.__class__.__name__,\n            list.__repr__(self))\n\n\nclass CheckboxGroup(list):\n    \"\"\"\n    Represents a group of checkboxes (``<input type=checkbox>``) that\n    have the same name.\n\n    In addition to using this like a list, the ``.value`` attribute\n    returns a set-like object that you can add to or remove from to\n    check and uncheck checkboxes.  You can also use ``.value_options``\n    to get the possible values.\n    \"\"\"\n    @property\n    def value(self):\n        \"\"\"\n        Return a set-like object that can be modified to check or\n        uncheck individual checkboxes according to their value.\n        \"\"\"\n        return CheckboxValues(self)\n\n    @value.setter\n    def value(self, value):\n        values = self.value\n        values.clear()\n        if not hasattr(value, '__iter__'):\n            raise ValueError(\n                \"A CheckboxGroup (name=%r) must be set to a sequence (not %r)\"\n                % (self[0].name, value))\n        values.update(value)\n\n    @value.deleter\n    def value(self):\n        self.value.clear()\n\n    @property\n    def value_options(self):\n        \"\"\"\n        Returns a list of all the possible values.\n        \"\"\"\n        return [el.get('value') for el in self]\n\n    def __repr__(self):\n        return '%s(%s)' % (\n            self.__class__.__name__, list.__repr__(self))\n\n\nclass CheckboxValues(SetMixin):\n    \"\"\"\n    Represents the values of the checked checkboxes in a group of\n    checkboxes with the same name.\n    \"\"\"\n\n    def __init__(self, group):\n        self.group = group\n\n    def __iter__(self):\n        return iter([\n            el.get('value')\n            for el in self.group\n            if 'checked' in el.attrib])\n\n    def add(self, value):\n        for el in self.group:\n            if el.get('value') == value:\n                el.set('checked', '')\n                break\n        else:\n            raise KeyError(\"No checkbox with value %r\" % value)\n\n    def remove(self, value):\n        for el in self.group:\n            if el.get('value') == value:\n                if 'checked' in el.attrib:\n                    del el.attrib['checked']\n                else:\n                    raise KeyError(\n                        \"The checkbox with value %r was already unchecked\" % value)\n                break\n        else:\n            raise KeyError(\n                \"No checkbox with value %r\" % value)\n\n    def __repr__(self):\n        return '<%s {%s} for checkboxes name=%r>' % (\n            self.__class__.__name__,\n            ', '.join([repr(v) for v in self]),\n            self.group.name)\n\n\nclass InputElement(InputMixin, HtmlElement):\n    \"\"\"\n    Represents an ``<input>`` element.\n\n    You can get the type with ``.type`` (which is lower-cased and\n    defaults to ``'text'``).\n\n    Also you can get and set the value with ``.value``\n\n    Checkboxes and radios have the attribute ``input.checkable ==\n    True`` (for all others it is false) and a boolean attribute\n    ``.checked``.\n\n    \"\"\"\n\n    ## FIXME: I'm a little uncomfortable with the use of .checked\n    @property\n    def value(self):\n        \"\"\"\n        Get/set the value of this element, using the ``value`` attribute.\n\n        Also, if this is a checkbox and it has no value, this defaults\n        to ``'on'``.  If it is a checkbox or radio that is not\n        checked, this returns None.\n        \"\"\"\n        if self.checkable:\n            if self.checked:\n                return self.get('value') or 'on'\n            else:\n                return None\n        return self.get('value')\n\n    @value.setter\n    def value(self, value):\n        if self.checkable:\n            if not value:\n                self.checked = False\n            else:\n                self.checked = True\n                if isinstance(value, str):\n                    self.set('value', value)\n        else:\n            self.set('value', value)\n\n    @value.deleter\n    def value(self):\n        if self.checkable:\n            self.checked = False\n        else:\n            if 'value' in self.attrib:\n                del self.attrib['value']\n\n    @property\n    def type(self):\n        \"\"\"\n        Return the type of this element (using the type attribute).\n        \"\"\"\n        return self.get('type', 'text').lower()\n\n    @type.setter\n    def type(self, value):\n        self.set('type', value)\n\n    @property\n    def checkable(self):\n        \"\"\"\n        Boolean: can this element be checked?\n        \"\"\"\n        return self.type in ('checkbox', 'radio')\n\n    @property\n    def checked(self):\n        \"\"\"\n        Boolean attribute to get/set the presence of the ``checked``\n        attribute.\n\n        You can only use this on checkable input types.\n        \"\"\"\n        if not self.checkable:\n            raise AttributeError('Not a checkable input type')\n        return 'checked' in self.attrib\n\n    @checked.setter\n    def checked(self, value):\n        if not self.checkable:\n            raise AttributeError('Not a checkable input type')\n        if value:\n            self.set('checked', '')\n        else:\n            attrib = self.attrib\n            if 'checked' in attrib:\n                del attrib['checked']\n\n\nHtmlElementClassLookup._default_element_classes['input'] = InputElement\n\n\nclass LabelElement(HtmlElement):\n    \"\"\"\n    Represents a ``<label>`` element.\n\n    Label elements are linked to other elements with their ``for``\n    attribute.  You can access this element with ``label.for_element``.\n    \"\"\"\n    @property\n    def for_element(self):\n        \"\"\"\n        Get/set the element this label points to.  Return None if it\n        can't be found.\n        \"\"\"\n        id = self.get('for')\n        if not id:\n            return None\n        return self.body.get_element_by_id(id)\n\n    @for_element.setter\n    def for_element(self, other):\n        id = other.get('id')\n        if not id:\n            raise TypeError(\n                \"Element %r has no id attribute\" % other)\n        self.set('for', id)\n\n    @for_element.deleter\n    def for_element(self):\n        attrib = self.attrib\n        if 'id' in attrib:\n            del attrib['id']\n\n\nHtmlElementClassLookup._default_element_classes['label'] = LabelElement\n\n\n############################################################\n## Serialization\n############################################################\n\ndef html_to_xhtml(html):\n    \"\"\"Convert all tags in an HTML tree to XHTML by moving them to the\n    XHTML namespace.\n    \"\"\"\n    try:\n        html = html.getroot()\n    except AttributeError:\n        pass\n    prefix = \"{%s}\" % XHTML_NAMESPACE\n    for el in html.iter(etree.Element):\n        tag = el.tag\n        if tag[0] != '{':\n            el.tag = prefix + tag\n\n\ndef xhtml_to_html(xhtml):\n    \"\"\"Convert all tags in an XHTML tree to HTML by removing their\n    XHTML namespace.\n    \"\"\"\n    try:\n        xhtml = xhtml.getroot()\n    except AttributeError:\n        pass\n    prefix = \"{%s}\" % XHTML_NAMESPACE\n    prefix_len = len(prefix)\n    for el in xhtml.iter(prefix + \"*\"):\n        el.tag = el.tag[prefix_len:]\n\n\n# This isn't a general match, but it's a match for what libxml2\n# specifically serialises:\n__str_replace_meta_content_type = re.compile(\n    r'<meta http-equiv=\"Content-Type\"[^>]*>').sub\n__bytes_replace_meta_content_type = re.compile(\n    br'<meta http-equiv=\"Content-Type\"[^>]*>').sub\n\n\ndef tostring(doc, pretty_print=False, include_meta_content_type=False,\n             encoding=None, method=\"html\", with_tail=True, doctype=None):\n    \"\"\"Return an HTML string representation of the document.\n\n    Note: if include_meta_content_type is true this will create a\n    ``<meta http-equiv=\"Content-Type\" ...>`` tag in the head;\n    regardless of the value of include_meta_content_type any existing\n    ``<meta http-equiv=\"Content-Type\" ...>`` tag will be removed\n\n    The ``encoding`` argument controls the output encoding (defaults to\n    ASCII, with &#...; character references for any characters outside\n    of ASCII).  Note that you can pass the name ``'unicode'`` as\n    ``encoding`` argument to serialise to a Unicode string.\n\n    The ``method`` argument defines the output method.  It defaults to\n    'html', but can also be 'xml' for xhtml output, or 'text' to\n    serialise to plain text without markup.\n\n    To leave out the tail text of the top-level element that is being\n    serialised, pass ``with_tail=False``.\n\n    The ``doctype`` option allows passing in a plain string that will\n    be serialised before the XML tree.  Note that passing in non\n    well-formed content here will make the XML output non well-formed.\n    Also, an existing doctype in the document tree will not be removed\n    when serialising an ElementTree instance.\n\n    Example::\n\n        >>> from lxml import html\n        >>> root = html.fragment_fromstring('<p>Hello<br>world!</p>')\n\n        >>> html.tostring(root)\n        b'<p>Hello<br>world!</p>'\n        >>> html.tostring(root, method='html')\n        b'<p>Hello<br>world!</p>'\n\n        >>> html.tostring(root, method='xml')\n        b'<p>Hello<br/>world!</p>'\n\n        >>> html.tostring(root, method='text')\n        b'Helloworld!'\n\n        >>> html.tostring(root, method='text', encoding='unicode')\n        u'Helloworld!'\n\n        >>> root = html.fragment_fromstring('<div><p>Hello<br>world!</p>TAIL</div>')\n        >>> html.tostring(root[0], method='text', encoding='unicode')\n        u'Helloworld!TAIL'\n\n        >>> html.tostring(root[0], method='text', encoding='unicode', with_tail=False)\n        u'Helloworld!'\n\n        >>> doc = html.document_fromstring('<p>Hello<br>world!</p>')\n        >>> html.tostring(doc, method='html', encoding='unicode')\n        u'<html><body><p>Hello<br>world!</p></body></html>'\n\n        >>> print(html.tostring(doc, method='html', encoding='unicode',\n        ...          doctype='<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"'\n        ...                  ' \"http://www.w3.org/TR/html4/strict.dtd\">'))\n        <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n        <html><body><p>Hello<br>world!</p></body></html>\n    \"\"\"\n    html = etree.tostring(doc, method=method, pretty_print=pretty_print,\n                          encoding=encoding, with_tail=with_tail,\n                          doctype=doctype)\n    if method == 'html' and not include_meta_content_type:\n        if isinstance(html, str):\n            html = __str_replace_meta_content_type('', html)\n        else:\n            html = __bytes_replace_meta_content_type(b'', html)\n    return html\n\n\ntostring.__doc__ = __fix_docstring(tostring.__doc__)\n\n\ndef open_in_browser(doc, encoding=None):\n    \"\"\"\n    Open the HTML document in a web browser, saving it to a temporary\n    file to open it.  Note that this does not delete the file after\n    use.  This is mainly meant for debugging.\n    \"\"\"\n    import os\n    import webbrowser\n    import tempfile\n    if not isinstance(doc, etree._ElementTree):\n        doc = etree.ElementTree(doc)\n    handle, fn = tempfile.mkstemp(suffix='.html')\n    f = os.fdopen(handle, 'wb')\n    try:\n        doc.write(f, method=\"html\", encoding=encoding or doc.docinfo.encoding or \"UTF-8\")\n    finally:\n        # we leak the file itself here, but we should at least close it\n        f.close()\n    url = 'file://' + fn.replace(os.path.sep, '/')\n    print(url)\n    webbrowser.open(url)\n\n\n################################################################################\n# configure Element class lookup\n################################################################################\n\nclass HTMLParser(etree.HTMLParser):\n    \"\"\"An HTML parser that is configured to return lxml.html Element\n    objects.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_element_class_lookup(HtmlElementClassLookup())\n\n\nclass XHTMLParser(etree.XMLParser):\n    \"\"\"An XML parser that is configured to return lxml.html Element\n    objects.\n\n    Note that this parser is not really XHTML aware unless you let it\n    load a DTD that declares the HTML entities.  To do this, make sure\n    you have the XHTML DTDs installed in your catalogs, and create the\n    parser like this::\n\n        >>> parser = XHTMLParser(load_dtd=True)\n\n    If you additionally want to validate the document, use this::\n\n        >>> parser = XHTMLParser(dtd_validation=True)\n\n    For catalog support, see http://www.xmlsoft.org/catalog.html.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_element_class_lookup(HtmlElementClassLookup())\n\n\ndef Element(*args, **kw):\n    \"\"\"Create a new HTML Element.\n\n    This can also be used for XHTML documents.\n    \"\"\"\n    v = html_parser.makeelement(*args, **kw)\n    return v\n\n\nhtml_parser = HTMLParser()\nxhtml_parser = XHTMLParser()\n", "src/lxml/html/builder.py": "# --------------------------------------------------------------------\n# The ElementTree toolkit is\n# Copyright (c) 1999-2004 by Fredrik Lundh\n# --------------------------------------------------------------------\n\n\"\"\"\nA set of HTML generator tags for building HTML documents.\n\nUsage::\n\n    >>> from lxml.html.builder import *\n    >>> html = HTML(\n    ...            HEAD( TITLE(\"Hello World\") ),\n    ...            BODY( CLASS(\"main\"),\n    ...                  H1(\"Hello World !\")\n    ...            )\n    ...        )\n\n    >>> import lxml.etree\n    >>> print lxml.etree.tostring(html, pretty_print=True)\n    <html>\n      <head>\n        <title>Hello World</title>\n      </head>\n      <body class=\"main\">\n        <h1>Hello World !</h1>\n      </body>\n    </html>\n\n\"\"\"\n\nfrom lxml.builder import ElementMaker\nfrom lxml.html import html_parser\n\nE = ElementMaker(makeelement=html_parser.makeelement)\n\n# elements\nA = E.a  #: anchor\nABBR = E.abbr  #: abbreviated form (e.g., WWW, HTTP, etc.)\nACRONYM = E.acronym  #: \nADDRESS = E.address  #: information on author\nAPPLET = E.applet  #: Java applet (DEPRECATED)\nAREA = E.area  #: client-side image map area\nB = E.b  #: bold text style\nBASE = E.base  #: document base URI\nBASEFONT = E.basefont  #: base font size (DEPRECATED)\nBDO = E.bdo  #: I18N BiDi over-ride\nBIG = E.big  #: large text style\nBLOCKQUOTE = E.blockquote  #: long quotation\nBODY = E.body  #: document body\nBR = E.br  #: forced line break\nBUTTON = E.button  #: push button\nCAPTION = E.caption  #: table caption\nCENTER = E.center  #: shorthand for DIV align=center (DEPRECATED)\nCITE = E.cite  #: citation\nCODE = E.code  #: computer code fragment\nCOL = E.col  #: table column\nCOLGROUP = E.colgroup  #: table column group\nDD = E.dd  #: definition description\nDEL = getattr(E, 'del')  #: deleted text\nDFN = E.dfn  #: instance definition\nDIR = E.dir  #: directory list (DEPRECATED)\nDIV = E.div  #: generic language/style container\nDL = E.dl  #: definition list\nDT = E.dt  #: definition term\nEM = E.em  #: emphasis\nFIELDSET = E.fieldset  #: form control group\nFONT = E.font  #: local change to font (DEPRECATED)\nFORM = E.form  #: interactive form\nFRAME = E.frame  #: subwindow\nFRAMESET = E.frameset  #: window subdivision\nH1 = E.h1  #: heading\nH2 = E.h2  #: heading\nH3 = E.h3  #: heading\nH4 = E.h4  #: heading\nH5 = E.h5  #: heading\nH6 = E.h6  #: heading\nHEAD = E.head  #: document head\nHR = E.hr  #: horizontal rule\nHTML = E.html  #: document root element\nI = E.i  #: italic text style\nIFRAME = E.iframe  #: inline subwindow\nIMG = E.img  #: Embedded image\nINPUT = E.input  #: form control\nINS = E.ins  #: inserted text\nISINDEX = E.isindex  #: single line prompt (DEPRECATED)\nKBD = E.kbd  #: text to be entered by the user\nLABEL = E.label  #: form field label text\nLEGEND = E.legend  #: fieldset legend\nLI = E.li  #: list item\nLINK = E.link  #: a media-independent link\nMAP = E.map  #: client-side image map\nMENU = E.menu  #: menu list (DEPRECATED)\nMETA = E.meta  #: generic metainformation\nNOFRAMES = E.noframes  #: alternate content container for non frame-based rendering\nNOSCRIPT = E.noscript  #: alternate content container for non script-based rendering\nOBJECT = E.object  #: generic embedded object\nOL = E.ol  #: ordered list\nOPTGROUP = E.optgroup  #: option group\nOPTION = E.option  #: selectable choice\nP = E.p  #: paragraph\nPARAM = E.param  #: named property value\nPRE = E.pre  #: preformatted text\nQ = E.q  #: short inline quotation\nS = E.s  #: strike-through text style (DEPRECATED)\nSAMP = E.samp  #: sample program output, scripts, etc.\nSCRIPT = E.script  #: script statements\nSELECT = E.select  #: option selector\nSMALL = E.small  #: small text style\nSPAN = E.span  #: generic language/style container\nSTRIKE = E.strike  #: strike-through text (DEPRECATED)\nSTRONG = E.strong  #: strong emphasis\nSTYLE = E.style  #: style info\nSUB = E.sub  #: subscript\nSUP = E.sup  #: superscript\nTABLE = E.table  #: \nTBODY = E.tbody  #: table body\nTD = E.td  #: table data cell\nTEXTAREA = E.textarea  #: multi-line text field\nTFOOT = E.tfoot  #: table footer\nTH = E.th  #: table header cell\nTHEAD = E.thead  #: table header\nTITLE = E.title  #: document title\nTR = E.tr  #: table row\nTT = E.tt  #: teletype or monospaced text style\nU = E.u  #: underlined text style (DEPRECATED)\nUL = E.ul  #: unordered list\nVAR = E.var  #: instance of a variable or program argument\n\n# attributes (only reserved words are included here)\nATTR = dict\ndef CLASS(v): return {'class': v}\ndef FOR(v): return {'for': v}\n", "src/lxml/html/tests/test_xhtml.py": "import doctest\nimport unittest\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([doctest.DocFileSuite('test_xhtml.txt')])\n    return suite\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/lxml/html/tests/test_feedparser_data.py": "import os\nimport re\ntry:\n    from rfc822 import Message\nexcept ImportError:\n    # Python 3\n    from email import message_from_file as Message\nimport unittest\nfrom lxml.doctestcompare import LHTMLOutputChecker\n\ntry:\n    from lxml.html.clean import clean, Cleaner\n    html_clean_available = True\nexcept ImportError:\n    html_clean_available = False\n\nfeed_dirs = [\n    os.path.join(os.path.dirname(__file__), 'feedparser-data'),\n    os.path.join(os.path.dirname(__file__), 'hackers-org-data'),\n    ]\nbar_re = re.compile(r\"-----+\")\n\nclass DummyInput:\n    def __init__(self, **kw):\n        for name, value in kw.items():\n            setattr(self, name, value)\n\nclass FeedTestCase(unittest.TestCase):\n\n    def __init__(self, filename):\n        self.filename = filename\n        unittest.TestCase.__init__(self)\n\n    def parse(self):\n        with open(self.filename) as f:\n            headers = Message(f)\n            c = f.read()\n        if not c.strip():\n            c = headers.get_payload()\n        if not headers.keys():\n            raise Exception(\n                \"File %s has no headers\" % self.filename)\n        self.description = headers['Description']\n        self.expect = headers.get('Expect', '')\n        self.ignore = headers.get('Ignore')\n        self.options = [\n            o.strip() for o in headers.get('Options', '').split(',')\n            if o.strip()]\n        parts = bar_re.split(c)\n        self.input = parts[0].rstrip() + '\\n'\n        if parts[1:]:\n            self.expect = parts[1].rstrip() + '\\n'\n        else:\n            self.expect = None\n\n    def runTest(self):\n        self.parse()\n        if self.ignore:\n            # We've marked this test to be ignored.\n            return\n        kw = {}\n        for name in self.options:\n            if name.startswith('-'):\n                kw[name[1:]] = False\n            else:\n                kw[name] = True\n        if kw.get('clean', True):\n            transformed = Cleaner(**kw).clean_html(self.input)\n        else:\n            transformed = self.input\n        assert self.expect is not None, (\n            \"No expected output in %s\" % self.filename)\n        checker = LHTMLOutputChecker()\n        if not checker.check_output(self.expect, transformed, 0):\n            result = checker.output_difference(\n                DummyInput(want=self.expect), transformed, 0)\n            #result += '\\noptions: %s %r' % (', '.join(self.options), kw)\n            #result += repr(transformed)\n            raise Exception(\"\\n\"+result)\n\n    def shortDescription(self):\n        return self.filename\n\ndef test_suite():\n    suite = unittest.TestSuite()\n\n    if not html_clean_available:\n        print(\"Skipping tests in feedparser_data - external lxml_html_clean package is not installed\")\n        return suite\n\n    for dir in feed_dirs:\n        for fn in os.listdir(dir):\n            fn = os.path.join(dir, fn)\n            if fn.endswith('.data'):\n                case = FeedTestCase(fn)\n                suite.addTests([case])\n                # This is my lazy way of stopping on first error:\n                try:\n                    case.runTest()\n                except:\n                    break\n    return suite\n", "src/lxml/html/tests/test_basic.py": "import doctest\nimport sys\nimport unittest\nfrom lxml import html\n\nclass TestBasicFeatures(unittest.TestCase):\n    def test_various_mixins(self):\n        base_url = \"http://example.org\"\n        doc = html.fromstring(\"\"\"\n        <root>\n            <!-- comment -->\n            <?pi contents ?>\n            &entity;\n            <el/>\n        </root>\n        \"\"\", base_url=base_url)\n        self.assertEqual(doc.getroottree().docinfo.URL, base_url)\n        self.assertEqual(len(doc), 3)\n        self.assertIsInstance(doc[0], html.HtmlComment)\n        self.assertIsInstance(doc[1], html.HtmlProcessingInstruction)\n        self.assertIsInstance(doc[2], html.HtmlElement)\n        for child in doc:\n            # base_url makes sense on all nodes (kinda) whereas `classes` or\n            # `get_rel_links` not really\n            self.assertEqual(child.base_url, base_url)\n\n    def test_set_empty_attribute(self):\n        e = html.Element('e')\n        e.set('a')\n        e.set('b', None)\n        e.set('c', '')\n        self.assertEqual(\n            html.tostring(e),\n            b'<e a b c=\"\"></e>',\n            \"Attributes set to `None` should yield empty attributes\"\n        )\n        self.assertEqual(e.get('a'), '', \"getting the empty attribute results in an empty string\")\n        self.assertEqual(e.attrib, {\n            'a': '',\n            'b': '',\n            'c': '',\n        })\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([doctest.DocFileSuite('test_basic.txt')])\n    suite.addTests([doctest.DocTestSuite(html)])\n    suite.addTest(unittest.TestLoader().loadTestsFromModule(sys.modules[__name__]))\n    return suite\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/lxml/html/tests/transform_feedparser_data.py": "\"\"\"\nThis takes the feedparser tests from here:\n\n  http://feedparser.org/tests/wellformed/sanitize/\n\nand rewrites them to be easier to handle (not using the internal model\nof feedparser).  The input format is::\n\n  <!--\n  Description: {description}\n  Expect: {expression}\n  -->\n  ...\n  <content ...>{content}</content>\n  ...\n\nThe Expect expression is checked for\n``entries[0]['content'][0]['value'] == {data}``.\n\nThe output format is::\n\n  Description: {description}\n  Expect: {expression} (if data couldn't be parsed)\n  Options: \n\n  {content, unescaped}\n  ----------\n  {data, unescaped, if found}\n\n\"\"\"\n\nimport re\nimport os\nimport traceback\n\n_desc_re = re.compile(r'\\s*Description:\\s*(.*)')\n_expect_re = re.compile(r'\\s*Expect:\\s*(.*)')\n_data_expect_re = re.compile(r\"entries\\[0\\]\\['[^']+'\\](?:\\[0\\]\\['value'\\])?\\s*==\\s*(.*)\")\n_feed_data_expect_re = re.compile(r\"feed\\['[^']+'\\]\\s*==\\s*(.*)\")\n\ndef parse_content(content):\n    match = _desc_re.search(content)\n    desc = match.group(1)\n    match = _expect_re.search(content)\n    expect = match.group(1)\n    data = None\n    for regex in [_data_expect_re, _feed_data_expect_re]:\n        match = regex.search(expect)\n        if match:\n            # Icky, but I'll trust it\n            data = eval(match.group(1).strip())\n            break\n    c = None\n    for tag in ['content', 'summary', 'title', 'copyright', 'tagline', 'info', 'subtitle', 'fullitem', 'body', 'description', 'content:encoded']:\n        regex = re.compile(r\"<%s.*?>(.*)</%s>\" % (tag, tag), re.S)\n        match = regex.search(content)\n        if match:\n            c = match.group(1)\n            break\n    assert c is not None\n    # Seems like body isn't quoted\n    if tag != 'body':\n        c = c.replace('&lt;', '<')\n        c = c.replace('&amp;', '&')\n    # FIXME: I should really do more unescaping...\n    return {\n        'Description': desc,\n        'Expect': expect,\n        'data': data,\n        'content': c}\n\ndef serialize_content(d):\n    s = '''\\\nDescription: %(Description)s\nExpect: %(Expect)s\nOptions: \n\n%(content)s\n''' % d\n    if d.get('data') is not None:\n        s += '----------\\n%s' % d['data']\n    return s\n\ndef translate_file(filename):\n    f = open(filename, 'rb')\n    c = f.read()\n    f.close()\n    try:\n        output = serialize_content(parse_content(c))\n    except:\n        print('Bad data in %s:' % filename)\n        print(c)\n        traceback.print_exc()\n        print('-'*60)\n        return\n    new = os.path.splitext(filename)[0] + '.data'\n    f = open(new, 'wb')\n    f.write(output)\n    f.close()\n\ndef translate_all(dir):\n    for fn in os.listdir(dir):\n        fn = os.path.join(dir, fn)\n        if fn.endswith('.xml'):\n            translate_file(fn)\n        \nif __name__ == '__main__':\n    translate_all(os.path.join(os.path.dirname(__file__), 'feedparser-data'))\n\n", "src/lxml/html/tests/test_html5parser.py": "import os\ntry:\n    from StringIO import StringIO\nexcept ImportError:                     # python 3\n    from io import StringIO\nimport sys\nimport tempfile\nimport unittest\nfrom unittest import skipUnless\n\nfrom lxml.builder import ElementMaker\nfrom lxml.etree import Element, ElementTree, ParserError\nfrom lxml.html import html_parser, XHTML_NAMESPACE\n\ntry:\n    import urlparse\nexcept ImportError:\n    import urllib.parse as urlparse \n    \ntry:\n    from urllib import pathname2url\nexcept ImportError:\n    from urllib.request import pathname2url\n    \n\ndef path2url(path):\n    return urlparse.urljoin(\n        'file:', pathname2url(path))\n\n\ntry:\n    import html5lib\nexcept ImportError:\n    html5lib = None\n\n\nclass Test_HTMLParser(unittest.TestCase):\n    def make_one(self, **kwargs):\n        if html5lib is None:\n            raise unittest.SkipTest(\"html5lib is not installed\")\n        from lxml.html.html5parser import HTMLParser\n        return HTMLParser(**kwargs)\n\n    def test_integration(self):\n        parser = self.make_one(strict=True)\n        tree = parser.parse(XHTML_TEST_DOCUMENT)\n        root = tree.getroot()\n        self.assertEqual(root.tag, xhtml_tag('html'))\n\n\nclass Test_XHTMLParser(unittest.TestCase):\n    def make_one(self, **kwargs):\n        from lxml.html.html5parser import XHTMLParser\n        return XHTMLParser(**kwargs)\n\n    @skipUnless(hasattr(html5lib, 'XHTMLParser'),\n                'xhtml5lib does not have XHTMLParser')\n    def test_integration(self):\n        # XXX: This test are untested. (html5lib no longer has an XHTMLParser)\n        parser = self.make_one(strict=True)\n        tree = parser.parse(XHTML_TEST_DOCUMENT)\n        root = tree.getroot()\n        self.assertEqual(root.tag, xhtml_tag('html'))\n\n\nclass Test_document_fromstring(unittest.TestCase):\n    def call_it(self, *args, **kwargs):\n        if html5lib is None:\n            raise unittest.SkipTest(\"html5lib is not installed\")\n        from lxml.html.html5parser import document_fromstring\n        return document_fromstring(*args, **kwargs)\n\n    def test_basic(self):\n        parser = DummyParser(doc=DummyElementTree(root='dummy root'))\n        elem = self.call_it(b'dummy input', parser=parser)\n        self.assertEqual(elem, 'dummy root')\n        self.assertEqual(parser.parse_args, (b'dummy input',))\n        self.assertEqual(parser.parse_kwargs, {'useChardet': True})\n\n    def test_guess_charset_not_used_for_unicode(self):\n        parser = DummyParser()\n        elem = self.call_it(b''.decode('ascii'), parser=parser)\n        self.assertEqual(parser.parse_kwargs, {})\n\n    def test_guess_charset_arg_gets_passed_to_parser(self):\n        parser = DummyParser()\n        elem = self.call_it(b'', guess_charset='gc_arg', parser=parser)\n        self.assertEqual(parser.parse_kwargs, {'useChardet': 'gc_arg'})\n\n    def test_raises_type_error_on_nonstring_input(self):\n        not_a_string = None\n        self.assertRaises(TypeError, self.call_it, not_a_string)\n\n    def test_integration(self):\n        elem = self.call_it(XHTML_TEST_DOCUMENT)\n        self.assertEqual(elem.tag, xhtml_tag('html'))\n\n\nclass Test_fragments_fromstring(unittest.TestCase):\n    def call_it(self, *args, **kwargs):\n        if html5lib is None:\n            raise unittest.SkipTest(\"html5lib is not installed\")\n        from lxml.html.html5parser import fragments_fromstring\n        return fragments_fromstring(*args, **kwargs)\n\n    def test_basic(self):\n        parser = DummyParser(fragments='fragments')\n        fragments = self.call_it(b'dummy input', parser=parser)\n        self.assertEqual(fragments, 'fragments')\n        self.assertEqual(parser.parseFragment_kwargs, {'useChardet': False})\n\n    def test_guess_charset_arg_gets_passed_to_parser(self):\n        parser = DummyParser()\n        elem = self.call_it(b'', guess_charset='gc_arg', parser=parser)\n        self.assertEqual(parser.parseFragment_kwargs, {'useChardet': 'gc_arg'})\n\n    def test_guess_charset_not_used_for_unicode(self):\n        parser = DummyParser()\n        elem = self.call_it(b''.decode('ascii'), parser=parser)\n        self.assertEqual(parser.parseFragment_kwargs, {})\n\n    def test_raises_type_error_on_nonstring_input(self):\n        not_a_string = None\n        self.assertRaises(TypeError, self.call_it, not_a_string)\n\n    def test_no_leading_text_strips_empty_leading_text(self):\n        parser = DummyParser(fragments=['', 'tail'])\n        fragments = self.call_it('', parser=parser, no_leading_text=True)\n        self.assertEqual(fragments, ['tail'])\n\n    def test_no_leading_text_raises_error_if_leading_text(self):\n        parser = DummyParser(fragments=['leading text', 'tail'])\n        self.assertRaises(ParserError, self.call_it,\n                          '', parser=parser, no_leading_text=True)\n\n    def test_integration(self):\n        fragments = self.call_it('a<b>c</b>')\n        self.assertEqual(len(fragments), 2)\n        self.assertEqual(fragments[0], 'a')\n        self.assertEqual(fragments[1].tag, xhtml_tag('b'))\n\n\nclass Test_fragment_fromstring(unittest.TestCase):\n    def call_it(self, *args, **kwargs):\n        if html5lib is None:\n            raise unittest.SkipTest(\"html5lib is not installed\")\n        from lxml.html.html5parser import fragment_fromstring\n        return fragment_fromstring(*args, **kwargs)\n\n    def test_basic(self):\n        element = DummyElement()\n        parser = DummyParser(fragments=[element])\n        self.assertEqual(self.call_it('html', parser=parser), element)\n\n    def test_raises_type_error_on_nonstring_input(self):\n        not_a_string = None\n        self.assertRaises(TypeError, self.call_it, not_a_string)\n\n    def test_create_parent(self):\n        parser = DummyParser(fragments=['head', Element('child')])\n        elem = self.call_it('html', parser=parser, create_parent='parent')\n        self.assertEqual(elem.tag, 'parent')\n        self.assertEqual(elem.text, 'head')\n        self.assertEqual(elem[0].tag, 'child')\n\n    def test_create_parent_default_type_no_ns(self):\n        parser = DummyParser(fragments=[], namespaceHTMLElements=False)\n        elem = self.call_it('html', parser=parser, create_parent=True)\n        self.assertEqual(elem.tag, 'div')\n\n    def test_raises_error_on_leading_text(self):\n        parser = DummyParser(fragments=['leading text'])\n        self.assertRaises(ParserError, self.call_it, 'html', parser=parser)\n\n    def test_raises_error_if_no_elements_found(self):\n        parser = DummyParser(fragments=[])\n        self.assertRaises(ParserError, self.call_it, 'html', parser=parser)\n\n    def test_raises_error_if_multiple_elements_found(self):\n        parser = DummyParser(fragments=[DummyElement(), DummyElement()])\n        self.assertRaises(ParserError, self.call_it, 'html', parser=parser)\n\n    def test_raises_error_if_tail(self):\n        parser = DummyParser(fragments=[DummyElement(tail='tail')])\n        self.assertRaises(ParserError, self.call_it, 'html', parser=parser)\n\n\nclass Test_fromstring(unittest.TestCase):\n    def call_it(self, *args, **kwargs):\n        if html5lib is None:\n            raise unittest.SkipTest(\"html5lib is not installed\")\n        from lxml.html.html5parser import fromstring\n        return fromstring(*args, **kwargs)\n\n    def test_returns_whole_doc_if_input_contains_html_tag(self):\n        parser = DummyParser(root='the doc')\n        self.assertEqual(self.call_it('<html></html>', parser=parser),\n                         'the doc')\n\n    def test_returns_whole_doc_if_input_contains_doctype(self):\n        parser = DummyParser(root='the doc')\n        self.assertEqual(self.call_it('<!DOCTYPE html>', parser=parser),\n                         'the doc')\n\n    def test_returns_whole_doc_if_input_is_encoded(self):\n        parser = DummyParser(root='the doc')\n        input = b'<!DOCTYPE html>'\n        self.assertEqual(self.call_it(input, parser=parser),\n                         'the doc')\n\n    def test_returns_whole_doc_if_head_not_empty(self, use_ns=True):\n        E = HTMLElementMaker(namespaceHTMLElements=use_ns)\n        root = E.html(E.head(E.title()))\n        parser = DummyParser(root=root)\n        self.assertEqual(self.call_it('', parser=parser), root)\n\n    def test_returns_whole_doc_if_head_not_empty_no_ns(self):\n        self.test_returns_whole_doc_if_head_not_empty(use_ns=False)\n\n    def test_returns_unwraps_body_if_single_element(self):\n        E = HTMLElementMaker()\n        elem = E.p('test')\n        root = E.html(E.head(), E.body(elem))\n        parser = DummyParser(root=root)\n        self.assertEqual(self.call_it('', parser=parser), elem)\n\n    def test_returns_body_if_has_text(self):\n        E = HTMLElementMaker()\n        elem = E.p('test')\n        body = E.body('text', elem)\n        root = E.html(E.head(), body)\n        parser = DummyParser(root=root)\n        self.assertEqual(self.call_it('', parser=parser), body)\n\n    def test_returns_body_if_single_element_has_tail(self):\n        E = HTMLElementMaker()\n        elem = E.p('test')\n        elem.tail = 'tail'\n        body = E.body(elem)\n        root = E.html(E.head(), body)\n        parser = DummyParser(root=root)\n        self.assertEqual(self.call_it('', parser=parser), body)\n\n    def test_wraps_multiple_fragments_in_div_no_ns(self):\n        E = HTMLElementMaker(namespaceHTMLElements=False)\n        parser = DummyParser(root=E.html(E.head(), E.body(E.h1(), E.p())),\n                             namespaceHTMLElements=False)\n        elem = self.call_it('', parser=parser)\n        self.assertEqual(elem.tag, 'div')\n\n    def test_wraps_multiple_fragments_in_span_no_ns(self):\n        E = HTMLElementMaker(namespaceHTMLElements=False)\n        parser = DummyParser(root=E.html(E.head(), E.body('foo', E.a('link'))),\n                             namespaceHTMLElements=False)\n        elem = self.call_it('', parser=parser)\n        self.assertEqual(elem.tag, 'span')\n\n    def test_raises_type_error_on_nonstring_input(self):\n        not_a_string = None\n        self.assertRaises(TypeError, self.call_it, not_a_string)\n\n    def test_integration_whole_doc(self):\n        elem = self.call_it(XHTML_TEST_DOCUMENT)\n        self.assertEqual(elem.tag, xhtml_tag('html'))\n\n    def test_integration_single_fragment(self):\n        elem = self.call_it('<p></p>')\n        self.assertEqual(elem.tag, xhtml_tag('p'))\n\n\nclass Test_parse(unittest.TestCase):\n    def call_it(self, *args, **kwargs):\n        if html5lib is None:\n            raise unittest.SkipTest(\"html5lib is not installed\")\n        from lxml.html.html5parser import parse\n        return parse(*args, **kwargs)\n\n    def make_temp_file(self, contents=''):\n        tmpfile = tempfile.NamedTemporaryFile(delete=False)\n        try:\n            tmpfile.write(contents.encode('utf8'))\n            tmpfile.flush()\n            tmpfile.seek(0)\n            return tmpfile\n        except Exception:\n            try:\n                tmpfile.close()\n            finally:\n                os.unlink(tmpfile.name)\n            raise\n\n    def test_with_file_object(self):\n        parser = DummyParser(doc='the doc')\n        with open(__file__) as fp:\n            self.assertEqual(self.call_it(fp, parser=parser), 'the doc')\n            self.assertEqual(parser.parse_args, (fp,))\n\n    def test_with_file_name(self):\n        parser = DummyParser(doc='the doc')\n        tmpfile = self.make_temp_file('data')\n        try:\n            data = tmpfile.read()\n        finally:\n            tmpfile.close()\n        try:\n            self.assertEqual(self.call_it(tmpfile.name, parser=parser), 'the doc')\n            fp, = parser.parse_args\n            try:\n                self.assertEqual(fp.read(), data)\n            finally:\n                fp.close()\n        finally:\n            os.unlink(tmpfile.name)\n\n    def test_with_url(self):\n        parser = DummyParser(doc='the doc')\n        tmpfile = self.make_temp_file('content')\n        try:\n            data = tmpfile.read()\n        finally:\n            tmpfile.close()\n        try:\n            url = path2url(tmpfile.name)\n            self.assertEqual(self.call_it(url, parser=parser), 'the doc')\n            fp, = parser.parse_args\n            try:\n                self.assertEqual(fp.read(), data)\n            finally:\n                fp.close()\n        finally:\n            os.unlink(tmpfile.name)\n\n    def test_integration(self):\n        doc = self.call_it(StringIO(XHTML_TEST_DOCUMENT))\n        root = doc.getroot()\n        self.assertEqual(root.tag, xhtml_tag('html'))\n\n\ndef test_suite():\n    loader = unittest.TestLoader()\n    return loader.loadTestsFromModule(sys.modules[__name__])\n\n\nclass HTMLElementMaker(ElementMaker):\n    def __init__(self, namespaceHTMLElements=True):\n        initargs = dict(makeelement=html_parser.makeelement)\n        if namespaceHTMLElements:\n            initargs.update(namespace=XHTML_NAMESPACE,\n                            nsmap={None: XHTML_NAMESPACE})\n        ElementMaker.__init__(self, **initargs)\n\n\nclass DummyParser:\n    def __init__(self, doc=None, root=None,\n                 fragments=None, namespaceHTMLElements=True):\n        self.doc = doc or DummyElementTree(root=root)\n        self.fragments = fragments\n        self.tree = DummyTreeBuilder(namespaceHTMLElements)\n\n    def parse(self, *args, **kwargs):\n        self.parse_args = args\n        self.parse_kwargs = kwargs\n        return self.doc\n\n    def parseFragment(self, *args, **kwargs):\n        self.parseFragment_args = args\n        self.parseFragment_kwargs = kwargs\n        return self.fragments\n\n\nclass DummyTreeBuilder:\n    def __init__(self, namespaceHTMLElements=True):\n        self.namespaceHTMLElements = namespaceHTMLElements\n\n\nclass DummyElementTree:\n    def __init__(self, root):\n        self.root = root\n\n    def getroot(self):\n        return self.root\n\n\nclass DummyElement:\n    def __init__(self, tag='tag', tail=None):\n        self.tag = tag\n        self.tail = tail\n\n\ndef xhtml_tag(tag):\n    return '{%s}%s' % (XHTML_NAMESPACE, tag)\n\n\nXHTML_TEST_DOCUMENT = '''\n    <!DOCTYPE html>\n    <html>\n    <head><title>TITLE</title></head>\n    <body></body>\n    </html>\n    '''\n", "src/lxml/html/tests/test_frames.py": "import unittest, sys\nimport lxml.html\n\nclass FrameTest(unittest.TestCase):\n\n    def test_parse_fragments_fromstring(self):\n        parser = lxml.html.HTMLParser(encoding='utf-8', remove_comments=True)\n        html = \"\"\"<frameset>\n            <frame src=\"main.php\" name=\"srcpg\" id=\"srcpg\" frameborder=\"0\" rolling=\"Auto\" marginwidth=\"\" marginheight=\"0\">\n        </frameset>\"\"\"\n        etree_document = lxml.html.fragments_fromstring(html, parser=parser)\n        self.assertEqual(len(etree_document), 1)\n        root = etree_document[0]\n        self.assertEqual(root.tag, \"frameset\")\n        frame_element = root[0]\n        self.assertEqual(frame_element.tag, 'frame')\n\n    def test_parse_fromstring(self):\n        parser = lxml.html.HTMLParser(encoding='utf-8', remove_comments=True)\n        html = \"\"\"<html><frameset>\n            <frame src=\"main.php\" name=\"srcpg\" id=\"srcpg\" frameborder=\"0\" rolling=\"Auto\" marginwidth=\"\" marginheight=\"0\">\n        </frameset></html>\"\"\"\n        etree_document = lxml.html.fromstring(html, parser=parser)\n        self.assertEqual(etree_document.tag, 'html')\n        self.assertEqual(len(etree_document), 1)\n        frameset_element = etree_document[0]\n        self.assertEqual(len(frameset_element), 1)\n        frame_element = frameset_element[0]\n        self.assertEqual(frame_element.tag, 'frame')\n\n\ndef test_suite():\n    loader = unittest.TestLoader()\n    return loader.loadTestsFromModule(sys.modules[__name__])\n", "src/lxml/html/tests/test_forms.py": "import doctest\nimport unittest\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([doctest.DocFileSuite('test_forms.txt')])\n    return suite\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/lxml/html/tests/test_rewritelinks.py": "import doctest\nimport unittest\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([doctest.DocFileSuite('test_rewritelinks.txt')])\n    return suite\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/lxml/html/tests/test_select.py": "import sys\nimport unittest\n\nimport lxml.html\n\n\nclass SelectTest(unittest.TestCase):\n    @staticmethod\n    def _evaluate_select(options, multiple=False):\n        options = ''.join('<option' + (' selected=\"selected\"' if selected else '') + '>' + option + '</option>'\n                          for option, selected in options)\n        string = '<title>test</title><form><select%s>%s</select></form>' % \\\n                 (' multiple=\"multiple\"' if multiple else '', options)\n        return lxml.html.fromstring(string).find('.//select').value\n\n    def test_single_select_value_no_options(self):\n        self.assertEqual(\n            self._evaluate_select([]),\n            None)\n\n    def test_single_select_value_no_selected_option(self):\n        # If no option is selected, the HTML5 specification requires the first option to get selected.\n        self.assertEqual(\n            self._evaluate_select([('a', False), ('b', False)]),\n            'a')\n\n    def test_single_select_value_multiple_selected_options(self):\n        # If multiple options are selected, the proposed HTML 5.1 specification\n        # requires all but the last selected options to get deselected.\n        self.assertEqual(\n            self._evaluate_select([('a', True), ('b', True)]),\n            'b')\n\n    def test_multiple_select_value_no_selected_option(self):\n        self.assertEqual(\n            self._evaluate_select([('a', False), ('b', False)], multiple=True),\n            set())\n\n    def test_multiple_select_value_multiple_selected_options(self):\n        self.assertEqual(\n            self._evaluate_select([('a', True), ('b', True)], multiple=True),\n            {'a', 'b'})\n\n\ndef test_suite():\n    loader = unittest.TestLoader()\n    return loader.loadTestsFromModule(sys.modules[__name__])\n", "src/lxml/html/tests/test_diff.py": "import doctest\nimport unittest\n\nfrom lxml.html import diff\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([doctest.DocFileSuite('test_diff.txt'),\n                    doctest.DocTestSuite(diff)])\n    return suite\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/lxml/html/tests/test_formfill.py": "import doctest\nimport unittest\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([doctest.DocFileSuite('test_formfill.txt')])\n    return suite\n", "src/lxml/html/tests/__init__.py": "#\n", "src/lxml/html/tests/test_elementsoup.py": "import unittest, sys\nfrom ...tests.common_imports import make_doctest, HelperTestCase\n\ntry:\n    import lxml.html.soupparser\n    BS_INSTALLED = True\nexcept ImportError:\n    if 'bs4' in sys.modules or 'BeautifulSoup' in sys.modules:\n        raise  # seems we managed to import BS but not soupparser\n    BS_INSTALLED = False\n\nfrom lxml.html import tostring\n\n\nif BS_INSTALLED:\n    class SoupParserTestCase(HelperTestCase):\n        soupparser = lxml.html.soupparser\n\n        def test_broken_attribute(self):\n            html = \"\"\"\\\n              <html><head></head><body>\n                <form><input type='text' disabled size='10'></form>\n              </body></html>\n            \"\"\"\n            root = self.soupparser.fromstring(html)\n            self.assertTrue(root.find('.//input').get('disabled') is not None)\n\n        def test_empty(self):\n            tree = self.soupparser.fromstring('')\n            res = b'''<html></html>'''\n            self.assertEqual(tostring(tree), res)\n\n        def test_text(self):\n            tree = self.soupparser.fromstring('huhu')\n            res = b'''<html>huhu</html>'''\n            self.assertEqual(tostring(tree), res)\n\n        def test_body(self):\n            html = '''<body><p>test</p></body>'''\n            res = b'''<html><body><p>test</p></body></html>'''\n            tree = self.soupparser.fromstring(html)\n            self.assertEqual(tostring(tree), res)\n\n        def test_head_body(self):\n            # HTML tag missing, parser should fix that\n            html = '<head><title>test</title></head><body><p>test</p></body>'\n            res = b'<html><head><title>test</title></head><body><p>test</p></body></html>'\n            tree = self.soupparser.fromstring(html)\n            self.assertEqual(tostring(tree), res)\n\n        def test_wrap_html(self):\n            # <head> outside <html>, parser should fix that\n            html = '<head><title>title</test></head><html><body/></html>'\n            res = b'<html><head><title>title</title></head><body></body></html>'\n            tree = self.soupparser.fromstring(html)\n            self.assertEqual(tostring(tree), res)\n\n        def test_comment_hyphen(self):\n            # These are really invalid XML as per specification\n            # https://www.w3.org/TR/REC-xml/#sec-comments\n            html = b'<html><!-- comment -- with double-hyphen --></html>'\n            tree = self.soupparser.fromstring(html)\n            self.assertEqual(tostring(tree), html)\n\n            html = b'<html><!-- comment ends with hyphen ---></html>'\n            tree = self.soupparser.fromstring(html)\n            self.assertEqual(tostring(tree), html)\n\n        def test_comment_pi(self):\n            html = '''<!-- comment -->\n<?test asdf?>\n<head><title>test</title></head><body><p>test</p></body>\n<!-- another comment -->'''\n            res = b'''<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<!-- comment --><?test asdf?><html><head><title>test</title></head><body><p>test</p></body></html><!-- another comment -->'''\n            tree = self.soupparser.fromstring(html).getroottree()\n            self.assertEqual(tostring(tree, method='html'), res)\n\n        def test_doctype1(self):\n            # Test document type declaration, comments and PI's\n            # outside the root\n            html = \\\n'''<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<!--another comment--><html><head><title>My first HTML document</title></head><body><p>Hello world!</p></body></html><?foo bar>'''\n\n            res = \\\nb'''<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<!--another comment--><html><head><title>My first HTML document</title></head><body><p>Hello world!</p></body></html><?foo bar?>'''\n\n            tree = self.soupparser.fromstring(html).getroottree()\n            self.assertEqual(tree.docinfo.public_id, \"-//W3C//DTD HTML 4.01//EN\")\n            self.assertEqual(tostring(tree), res)\n\n        def test_doctype2(self):\n            # Test document type declaration, comments and PI's\n            # outside the root\n            html = \\\n'''<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//EN\">\n<!--another comment--><html><head><title>My first HTML document</title></head><body><p>Hello world!</p></body></html><?foo bar?>'''\n\n            res = \\\nb'''<!DOCTYPE html PUBLIC \"-//IETF//DTD HTML//EN\">\n<!--another comment--><html><head><title>My first HTML document</title></head><body><p>Hello world!</p></body></html><?foo bar?>'''\n\n            tree = self.soupparser.fromstring(html).getroottree()\n            self.assertEqual(tree.docinfo.public_id, \"-//IETF//DTD HTML//EN\")\n            self.assertEqual(tostring(tree), res)\n\n        def test_doctype_html5(self):\n            # html 5 doctype declaration\n            html = b'<!DOCTYPE html>\\n<html lang=\"en\"></html>'\n\n            tree = self.soupparser.fromstring(html).getroottree()\n            self.assertTrue(tree.docinfo.public_id is None)\n            self.assertEqual(tostring(tree), html)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    if BS_INSTALLED:\n        suite.addTests([unittest.defaultTestLoader.loadTestsFromTestCase(SoupParserTestCase)])\n        #suite.addTests([make_doctest('elementsoup.txt')])  # FIXME: Py2-only ?\n    return suite\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}