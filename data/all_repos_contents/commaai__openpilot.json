{"tools/__init__.py": "", "tools/plotjuggler/juggle.py": "#!/usr/bin/env python3\nimport os\nimport sys\nimport platform\nimport shutil\nimport subprocess\nimport tarfile\nimport tempfile\nimport requests\nimport argparse\nfrom functools import partial\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.selfdrive.car.fingerprints import MIGRATION\nfrom openpilot.tools.lib.helpers import save_log\nfrom openpilot.tools.lib.logreader import LogReader, ReadMode\n\njuggle_dir = os.path.dirname(os.path.realpath(__file__))\n\nDEMO_ROUTE = \"a2a0ccea32023010|2023-07-27--13-01-19\"\nRELEASES_URL = \"https://github.com/commaai/PlotJuggler/releases/download/latest\"\nINSTALL_DIR = os.path.join(juggle_dir, \"bin\")\nPLOTJUGGLER_BIN = os.path.join(juggle_dir, \"bin/plotjuggler\")\nMINIMUM_PLOTJUGGLER_VERSION = (3, 5, 2)\nMAX_STREAMING_BUFFER_SIZE = 1000\n\n\ndef install():\n  m = f\"{platform.system()}-{platform.machine()}\"\n  supported = (\"Linux-x86_64\", \"Linux-aarch64\", \"Darwin-arm64\", \"Darwin-x86_64\")\n  if m not in supported:\n    raise Exception(f\"Unsupported platform: '{m}'. Supported platforms: {supported}\")\n\n  if os.path.exists(INSTALL_DIR):\n    shutil.rmtree(INSTALL_DIR)\n  os.mkdir(INSTALL_DIR)\n\n  url = os.path.join(RELEASES_URL, m + \".tar.gz\")\n  with requests.get(url, stream=True, timeout=10) as r, tempfile.NamedTemporaryFile() as tmp:\n    r.raise_for_status()\n    with open(tmp.name, 'wb') as tmpf:\n      for chunk in r.iter_content(chunk_size=1024 * 1024):\n        tmpf.write(chunk)\n\n    with tarfile.open(tmp.name) as tar:\n      tar.extractall(path=INSTALL_DIR)\n\n\ndef get_plotjuggler_version():\n  out = subprocess.check_output([PLOTJUGGLER_BIN, \"-v\"], encoding=\"utf-8\").strip()\n  version = out.split(\" \")[1]\n  return tuple(map(int, version.split(\".\")))\n\n\ndef start_juggler(fn=None, dbc=None, layout=None, route_or_segment_name=None):\n  env = os.environ.copy()\n  env[\"BASEDIR\"] = BASEDIR\n  env[\"PATH\"] = f\"{INSTALL_DIR}:{os.getenv('PATH', '')}\"\n  if dbc:\n    env[\"DBC_NAME\"] = dbc\n\n  extra_args = \"\"\n  if fn is not None:\n    extra_args += f\" -d {fn}\"\n  if layout is not None:\n    extra_args += f\" -l {layout}\"\n  if route_or_segment_name is not None:\n    extra_args += f\" --window_title \\\"{route_or_segment_name}\\\"\"\n\n  cmd = f'{PLOTJUGGLER_BIN} --buffer_size {MAX_STREAMING_BUFFER_SIZE} --plugin_folders {INSTALL_DIR}{extra_args}'\n  subprocess.call(cmd, shell=True, env=env, cwd=juggle_dir)\n\n\ndef process(can, lr):\n  return [d for d in lr if can or d.which() not in ['can', 'sendcan']]\n\n\ndef juggle_route(route_or_segment_name, can, layout, dbc=None):\n  sr = LogReader(route_or_segment_name, default_mode=ReadMode.AUTO_INTERACTIVE)\n\n  all_data = sr.run_across_segments(24, partial(process, can))\n\n  # Infer DBC name from logs\n  if dbc is None:\n    for cp in [m for m in all_data if m.which() == 'carParams']:\n      try:\n        DBC = __import__(f\"openpilot.selfdrive.car.{cp.carParams.carName}.values\", fromlist=['DBC']).DBC\n        fingerprint = cp.carParams.carFingerprint\n        dbc = DBC[MIGRATION.get(fingerprint, fingerprint)]['pt']\n      except Exception:\n        pass\n      break\n\n  with tempfile.NamedTemporaryFile(suffix='.rlog', dir=juggle_dir) as tmp:\n    save_log(tmp.name, all_data, compress=False)\n    del all_data\n    start_juggler(tmp.name, dbc, layout, route_or_segment_name)\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"A helper to run PlotJuggler on openpilot routes\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"--demo\", action=\"store_true\", help=\"Use the demo route instead of providing one\")\n  parser.add_argument(\"--can\", action=\"store_true\", help=\"Parse CAN data\")\n  parser.add_argument(\"--stream\", action=\"store_true\", help=\"Start PlotJuggler in streaming mode\")\n  parser.add_argument(\"--layout\", nargs='?', help=\"Run PlotJuggler with a pre-defined layout\")\n  parser.add_argument(\"--install\", action=\"store_true\", help=\"Install or update PlotJuggler + plugins\")\n  parser.add_argument(\"--dbc\", help=\"Set the DBC name to load for parsing CAN data. If not set, the DBC will be automatically inferred from the logs.\")\n  parser.add_argument(\"route_or_segment_name\", nargs='?', help=\"The route or segment name to plot (cabana share URL accepted)\")\n\n  if len(sys.argv) == 1:\n    parser.print_help()\n    sys.exit()\n  args = parser.parse_args()\n\n  if args.install:\n    install()\n    sys.exit()\n\n  if not os.path.exists(PLOTJUGGLER_BIN):\n    print(\"PlotJuggler is missing. Downloading...\")\n    install()\n\n  if get_plotjuggler_version() < MINIMUM_PLOTJUGGLER_VERSION:\n    print(\"PlotJuggler is out of date. Installing update...\")\n    install()\n\n  if args.stream:\n    start_juggler(layout=args.layout)\n  else:\n    route_or_segment_name = DEMO_ROUTE if args.demo else args.route_or_segment_name.strip()\n    juggle_route(route_or_segment_name, args.can, args.layout, args.dbc)\n", "tools/car_porting/auto_fingerprint.py": "#!/usr/bin/env python3\n\nimport argparse\nfrom collections import defaultdict\nfrom openpilot.selfdrive.debug.format_fingerprints import format_brand_fw_versions\n\nfrom openpilot.selfdrive.car.fingerprints import MIGRATION\nfrom openpilot.selfdrive.car.fw_versions import MODEL_TO_BRAND, match_fw_to_car\nfrom openpilot.tools.lib.logreader import LogReader, ReadMode\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Auto fingerprint from a route\")\n  parser.add_argument(\"route\", help=\"The route name to use\")\n  parser.add_argument(\"platform\", help=\"The platform, or leave empty to auto-determine using fuzzy\", default=None, nargs=\"?\")\n  args = parser.parse_args()\n\n  lr = LogReader(args.route, ReadMode.QLOG)\n  CP = lr.first(\"carParams\")\n  assert CP is not None, \"No carParams in route\"\n\n  carPlatform = MIGRATION.get(CP.carFingerprint, CP.carFingerprint)\n\n  if args.platform is not None:\n    platform = args.platform\n  elif carPlatform != \"MOCK\":\n    platform = carPlatform\n  else:\n    _, matches = match_fw_to_car(CP.carFw, CP.carVin, log=False)\n    assert len(matches) == 1, f\"Unable to auto-determine platform, matches: {matches}\"\n    platform = list(matches)[0]\n\n  print(\"Attempting to add fw version for:\", platform)\n\n  fw_versions: dict[str, dict[tuple, list[bytes]]] = defaultdict(lambda: defaultdict(list))\n  brand = MODEL_TO_BRAND[platform]\n\n  for fw in CP.carFw:\n    if fw.brand == brand and not fw.logging:\n      addr = fw.address\n      subAddr = None if fw.subAddress == 0 else fw.subAddress\n      key = (fw.ecu.raw, addr, subAddr)\n\n      fw_versions[platform][key].append(fw.fwVersion)\n\n  format_brand_fw_versions(brand, fw_versions)\n", "tools/replay/ui.py": "#!/usr/bin/env python3\nimport argparse\nimport os\nimport sys\n\nimport cv2\nimport numpy as np\nimport pygame\n\nimport cereal.messaging as messaging\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.transformations.camera import DEVICE_CAMERAS\nfrom openpilot.tools.replay.lib.ui_helpers import (UP,\n                                         BLACK, GREEN,\n                                         YELLOW, Calibration,\n                                         get_blank_lid_overlay, init_plots,\n                                         maybe_update_radar_points, plot_lead,\n                                         plot_model,\n                                         pygame_modules_have_loaded)\nfrom msgq.visionipc import VisionIpcClient, VisionStreamType\n\nos.environ['BASEDIR'] = BASEDIR\n\nANGLE_SCALE = 5.0\n\ndef ui_thread(addr):\n  cv2.setNumThreads(1)\n  pygame.init()\n  pygame.font.init()\n  assert pygame_modules_have_loaded()\n\n  disp_info = pygame.display.Info()\n  max_height = disp_info.current_h\n\n  hor_mode = os.getenv(\"HORIZONTAL\") is not None\n  hor_mode = True if max_height < 960+300 else hor_mode\n\n  if hor_mode:\n    size = (640+384+640, 960)\n    write_x = 5\n    write_y = 680\n  else:\n    size = (640+384, 960+300)\n    write_x = 645\n    write_y = 970\n\n  pygame.display.set_caption(\"openpilot debug UI\")\n  screen = pygame.display.set_mode(size, pygame.DOUBLEBUF)\n\n  alert1_font = pygame.font.SysFont(\"arial\", 30)\n  alert2_font = pygame.font.SysFont(\"arial\", 20)\n  info_font = pygame.font.SysFont(\"arial\", 15)\n\n  camera_surface = pygame.surface.Surface((640, 480), 0, 24).convert()\n  top_down_surface = pygame.surface.Surface((UP.lidar_x, UP.lidar_y), 0, 8)\n\n  sm = messaging.SubMaster(['carState', 'longitudinalPlan', 'carControl', 'radarState', 'liveCalibration', 'controlsState',\n                            'liveTracks', 'modelV2', 'liveParameters', 'roadCameraState'], addr=addr)\n\n  img = np.zeros((480, 640, 3), dtype='uint8')\n  imgff = None\n  num_px = 0\n  calibration = None\n\n  lid_overlay_blank = get_blank_lid_overlay(UP)\n\n  # plots\n  name_to_arr_idx = { \"gas\": 0,\n                      \"computer_gas\": 1,\n                      \"user_brake\": 2,\n                      \"computer_brake\": 3,\n                      \"v_ego\": 4,\n                      \"v_pid\": 5,\n                      \"angle_steers_des\": 6,\n                      \"angle_steers\": 7,\n                      \"angle_steers_k\": 8,\n                      \"steer_torque\": 9,\n                      \"v_override\": 10,\n                      \"v_cruise\": 11,\n                      \"a_ego\": 12,\n                      \"a_target\": 13}\n\n  plot_arr = np.zeros((100, len(name_to_arr_idx.values())))\n\n  plot_xlims = [(0, plot_arr.shape[0]), (0, plot_arr.shape[0]), (0, plot_arr.shape[0]), (0, plot_arr.shape[0])]\n  plot_ylims = [(-0.1, 1.1), (-ANGLE_SCALE, ANGLE_SCALE), (0., 75.), (-3.0, 2.0)]\n  plot_names = [[\"gas\", \"computer_gas\", \"user_brake\", \"computer_brake\"],\n                [\"angle_steers\", \"angle_steers_des\", \"angle_steers_k\", \"steer_torque\"],\n                [\"v_ego\", \"v_override\", \"v_pid\", \"v_cruise\"],\n                [\"a_ego\", \"a_target\"]]\n  plot_colors = [[\"b\", \"b\", \"g\", \"r\", \"y\"],\n                 [\"b\", \"g\", \"y\", \"r\"],\n                 [\"b\", \"g\", \"r\", \"y\"],\n                 [\"b\", \"r\"]]\n  plot_styles = [[\"-\", \"-\", \"-\", \"-\", \"-\"],\n                 [\"-\", \"-\", \"-\", \"-\"],\n                 [\"-\", \"-\", \"-\", \"-\"],\n                 [\"-\", \"-\"]]\n\n  draw_plots = init_plots(plot_arr, name_to_arr_idx, plot_xlims, plot_ylims, plot_names, plot_colors, plot_styles)\n\n  vipc_client = VisionIpcClient(\"camerad\", VisionStreamType.VISION_STREAM_ROAD, True)\n  while True:\n    for event in pygame.event.get():\n      if event.type == pygame.QUIT:\n        pygame.quit()\n        sys.exit()\n\n    screen.fill((64, 64, 64))\n    lid_overlay = lid_overlay_blank.copy()\n    top_down = top_down_surface, lid_overlay\n\n    # ***** frame *****\n    if not vipc_client.is_connected():\n      vipc_client.connect(True)\n\n    yuv_img_raw = vipc_client.recv()\n    if yuv_img_raw is None or not yuv_img_raw.data.any():\n      continue\n\n    sm.update(0)\n\n    camera = DEVICE_CAMERAS[(\"tici\", str(sm['roadCameraState'].sensor))]\n\n    imgff = np.frombuffer(yuv_img_raw.data, dtype=np.uint8).reshape((len(yuv_img_raw.data) // vipc_client.stride, vipc_client.stride))\n    num_px = vipc_client.width * vipc_client.height\n    rgb = cv2.cvtColor(imgff[:vipc_client.height * 3 // 2, :vipc_client.width], cv2.COLOR_YUV2RGB_NV12)\n\n    qcam = \"QCAM\" in os.environ\n    bb_scale = (528 if qcam else camera.fcam.width) / 640.\n    calib_scale = camera.fcam.width / 640.\n    zoom_matrix = np.asarray([\n        [bb_scale, 0., 0.],\n        [0., bb_scale, 0.],\n        [0., 0., 1.]])\n    cv2.warpAffine(rgb, zoom_matrix[:2], (img.shape[1], img.shape[0]), dst=img, flags=cv2.WARP_INVERSE_MAP)\n\n    intrinsic_matrix = camera.fcam.intrinsics\n\n    w = sm['controlsState'].lateralControlState.which()\n    if w == 'lqrStateDEPRECATED':\n      angle_steers_k = sm['controlsState'].lateralControlState.lqrStateDEPRECATED.steeringAngleDeg\n    elif w == 'indiState':\n      angle_steers_k = sm['controlsState'].lateralControlState.indiState.steeringAngleDeg\n    else:\n      angle_steers_k = np.inf\n\n    plot_arr[:-1] = plot_arr[1:]\n    plot_arr[-1, name_to_arr_idx['angle_steers']] = sm['carState'].steeringAngleDeg\n    plot_arr[-1, name_to_arr_idx['angle_steers_des']] = sm['carControl'].actuators.steeringAngleDeg\n    plot_arr[-1, name_to_arr_idx['angle_steers_k']] = angle_steers_k\n    plot_arr[-1, name_to_arr_idx['gas']] = sm['carState'].gas\n    # TODO gas is deprecated\n    plot_arr[-1, name_to_arr_idx['computer_gas']] = clip(sm['carControl'].actuators.accel/4.0, 0.0, 1.0)\n    plot_arr[-1, name_to_arr_idx['user_brake']] = sm['carState'].brake\n    plot_arr[-1, name_to_arr_idx['steer_torque']] = sm['carControl'].actuators.steer * ANGLE_SCALE\n    # TODO brake is deprecated\n    plot_arr[-1, name_to_arr_idx['computer_brake']] = clip(-sm['carControl'].actuators.accel/4.0, 0.0, 1.0)\n    plot_arr[-1, name_to_arr_idx['v_ego']] = sm['carState'].vEgo\n    plot_arr[-1, name_to_arr_idx['v_cruise']] = sm['carState'].cruiseState.speed\n    plot_arr[-1, name_to_arr_idx['a_ego']] = sm['carState'].aEgo\n\n    if len(sm['longitudinalPlan'].accels):\n      plot_arr[-1, name_to_arr_idx['a_target']] = sm['longitudinalPlan'].accels[0]\n\n    if sm.recv_frame['modelV2']:\n      plot_model(sm['modelV2'], img, calibration, top_down)\n\n    if sm.recv_frame['radarState']:\n      plot_lead(sm['radarState'], top_down)\n\n    # draw all radar points\n    maybe_update_radar_points(sm['liveTracks'], top_down[1])\n\n    if sm.updated['liveCalibration'] and num_px:\n      rpyCalib = np.asarray(sm['liveCalibration'].rpyCalib)\n      calibration = Calibration(num_px, rpyCalib, intrinsic_matrix, calib_scale)\n\n    # *** blits ***\n    pygame.surfarray.blit_array(camera_surface, img.swapaxes(0, 1))\n    screen.blit(camera_surface, (0, 0))\n\n    # display alerts\n    alert_line1 = alert1_font.render(sm['controlsState'].alertText1, True, (255, 0, 0))\n    alert_line2 = alert2_font.render(sm['controlsState'].alertText2, True, (255, 0, 0))\n    screen.blit(alert_line1, (180, 150))\n    screen.blit(alert_line2, (180, 190))\n\n    if hor_mode:\n      screen.blit(draw_plots(plot_arr), (640+384, 0))\n    else:\n      screen.blit(draw_plots(plot_arr), (0, 600))\n\n    pygame.surfarray.blit_array(*top_down)\n    screen.blit(top_down[0], (640, 0))\n\n    SPACING = 25\n\n    lines = [\n      info_font.render(\"ENABLED\", True, GREEN if sm['controlsState'].enabled else BLACK),\n      info_font.render(\"SPEED: \" + str(round(sm['carState'].vEgo, 1)) + \" m/s\", True, YELLOW),\n      info_font.render(\"LONG CONTROL STATE: \" + str(sm['controlsState'].longControlState), True, YELLOW),\n      info_font.render(\"LONG MPC SOURCE: \" + str(sm['longitudinalPlan'].longitudinalPlanSource), True, YELLOW),\n      None,\n      info_font.render(\"ANGLE OFFSET (AVG): \" + str(round(sm['liveParameters'].angleOffsetAverageDeg, 2)) + \" deg\", True, YELLOW),\n      info_font.render(\"ANGLE OFFSET (INSTANT): \" + str(round(sm['liveParameters'].angleOffsetDeg, 2)) + \" deg\", True, YELLOW),\n      info_font.render(\"STIFFNESS: \" + str(round(sm['liveParameters'].stiffnessFactor * 100., 2)) + \" %\", True, YELLOW),\n      info_font.render(\"STEER RATIO: \" + str(round(sm['liveParameters'].steerRatio, 2)), True, YELLOW)\n    ]\n\n    for i, line in enumerate(lines):\n      if line is not None:\n        screen.blit(line, (write_x, write_y + i * SPACING))\n\n    # this takes time...vsync or something\n    pygame.display.flip()\n\ndef get_arg_parser():\n  parser = argparse.ArgumentParser(\n    description=\"Show replay data in a UI.\",\n    formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"ip_address\", nargs=\"?\", default=\"127.0.0.1\",\n                      help=\"The ip address on which to receive zmq messages.\")\n\n  parser.add_argument(\"--frame-address\", default=None,\n                      help=\"The frame address (fully qualified ZMQ endpoint for frames) on which to receive zmq messages.\")\n  return parser\n\nif __name__ == \"__main__\":\n  args = get_arg_parser().parse_args(sys.argv[1:])\n\n  if args.ip_address != \"127.0.0.1\":\n    os.environ[\"ZMQ\"] = \"1\"\n    messaging.context = messaging.Context()\n\n  ui_thread(args.ip_address)\n", "tools/replay/unlog_ci_segment.py": "#!/usr/bin/env python3\n\nimport argparse\nimport bisect\nimport select\nimport sys\nimport termios\nimport time\nimport tty\nfrom collections import defaultdict\n\nimport cereal.messaging as messaging\nfrom openpilot.tools.lib.framereader import FrameReader\nfrom openpilot.tools.lib.logreader import LogReader\nfrom openpilot.tools.lib.openpilotci import get_url\n\nIGNORE = ['initData', 'sentinel']\n\n\ndef input_ready():\n  return select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], [])\n\n\ndef replay(route, segment, loop):\n  route = route.replace('|', '/')\n\n  lr = LogReader(get_url(route, segment))\n  fr = FrameReader(get_url(route, segment, \"fcamera\"), readahead=True)\n\n  # Build mapping from frameId to segmentId from roadEncodeIdx, type == fullHEVC\n  msgs = [m for m in lr if m.which() not in IGNORE]\n  msgs = sorted(msgs, key=lambda m: m.logMonoTime)\n  times = [m.logMonoTime for m in msgs]\n  frame_idx = {m.roadEncodeIdx.frameId: m.roadEncodeIdx.segmentId for m in msgs if m.which() == 'roadEncodeIdx' and m.roadEncodeIdx.type == 'fullHEVC'}\n\n  socks = {}\n  lag = 0.0\n  i = 0\n  max_i = len(msgs) - 2\n\n  while True:\n    msg = msgs[i].as_builder()\n    next_msg = msgs[i + 1]\n\n    start_time = time.time()\n    w = msg.which()\n\n    if w == 'roadCameraState':\n      try:\n        img = fr.get(frame_idx[msg.roadCameraState.frameId], pix_fmt=\"rgb24\")\n        img = img[0][:, :, ::-1]  # Convert RGB to BGR, which is what the camera outputs\n        msg.roadCameraState.image = img.flatten().tobytes()\n      except (KeyError, ValueError):\n        pass\n\n    if w not in socks:\n      socks[w] = messaging.pub_sock(w)\n\n    try:\n      if socks[w]:\n        socks[w].send(msg.to_bytes())\n    except messaging.messaging_pyx.MultiplePublishersError:\n      socks[w] = None\n\n    lag += (next_msg.logMonoTime - msg.logMonoTime) / 1e9\n    lag -= time.time() - start_time\n\n    dt = max(lag, 0.0)\n    lag -= dt\n    time.sleep(dt)\n\n    if lag < -1.0 and i % 1000 == 0:\n      print(f\"{-lag:.2f} s behind\")\n\n    if input_ready():\n      key = sys.stdin.read(1)\n\n      # Handle pause\n      if key == \" \":\n        while True:\n          if input_ready() and sys.stdin.read(1) == \" \":\n            break\n          time.sleep(0.01)\n\n      # Handle seek\n      dt = defaultdict(int, s=10, S=-10)[key]\n      new_time = msgs[i].logMonoTime + dt * 1e9\n      i = bisect.bisect_left(times, new_time)\n\n    i = (i + 1) % max_i if loop else min(i + 1, max_i)\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\"--loop\", action='store_true')\n  parser.add_argument(\"route\")\n  parser.add_argument(\"segment\")\n  args = parser.parse_args()\n\n  orig_settings = termios.tcgetattr(sys.stdin)\n  tty.setcbreak(sys.stdin)\n\n  try:\n    replay(args.route, args.segment, args.loop)\n    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, orig_settings)\n  except Exception:\n    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, orig_settings)\n    raise\n", "tools/replay/__init__.py": "", "tools/replay/can_replay.py": "#!/usr/bin/env python3\nimport argparse\nimport os\nimport time\nimport usb1\nimport threading\n\nos.environ['FILEREADER_CACHE'] = '1'\n\nfrom openpilot.common.realtime import config_realtime_process, Ratekeeper, DT_CTRL\nfrom openpilot.selfdrive.pandad import can_capnp_to_can_list\nfrom openpilot.tools.lib.logreader import LogReader\nfrom panda import PandaJungle\n\n# set both to cycle power or ignition\nPWR_ON = int(os.getenv(\"PWR_ON\", \"0\"))\nPWR_OFF = int(os.getenv(\"PWR_OFF\", \"0\"))\nIGN_ON = int(os.getenv(\"ON\", \"0\"))\nIGN_OFF = int(os.getenv(\"OFF\", \"0\"))\nENABLE_IGN = IGN_ON > 0 and IGN_OFF > 0\nENABLE_PWR = PWR_ON > 0 and PWR_OFF > 0\n\n\ndef send_thread(j: PandaJungle, flock):\n  if \"FLASH\" in os.environ:\n    with flock:\n      j.flash()\n\n  j.reset()\n  for i in [0, 1, 2, 3, 0xFFFF]:\n    j.can_clear(i)\n    j.set_can_speed_kbps(i, 500)\n  j.set_ignition(True)\n  j.set_panda_power(True)\n  j.set_can_loopback(False)\n\n  rk = Ratekeeper(1 / DT_CTRL, print_delay_threshold=None)\n  while True:\n    # handle cycling\n    if ENABLE_PWR:\n      i = (rk.frame*DT_CTRL) % (PWR_ON + PWR_OFF) < PWR_ON\n      j.set_panda_power(i)\n    if ENABLE_IGN:\n      i = (rk.frame*DT_CTRL) % (IGN_ON + IGN_OFF) < IGN_ON\n      j.set_ignition(i)\n\n    snd = CAN_MSGS[rk.frame % len(CAN_MSGS)]\n    snd = list(filter(lambda x: x[-1] <= 2, snd))\n    try:\n      j.can_send_many(snd)\n    except usb1.USBErrorTimeout:\n      # timeout is fine, just means the CAN TX buffer is full\n      pass\n\n    # Drain panda message buffer\n    j.can_recv()\n    rk.keep_time()\n\n\ndef connect():\n  config_realtime_process(3, 55)\n\n  serials = {}\n  flashing_lock = threading.Lock()\n  while True:\n    # look for new devices\n    for s in PandaJungle.list():\n      if s not in serials:\n        print(\"starting send thread for\", s)\n        serials[s] = threading.Thread(target=send_thread, args=(PandaJungle(s), flashing_lock))\n        serials[s].start()\n\n    # try to join all send threads\n    cur_serials = serials.copy()\n    for s, t in cur_serials.items():\n      if t is  not None:\n        t.join(0.01)\n        if not t.is_alive():\n          del serials[s]\n\n    time.sleep(1)\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Replay CAN messages from a route to all connected pandas and jungles in a loop.\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"route_or_segment_name\", nargs='?', help=\"The route or segment name to replay. If not specified, a default public route will be used.\")\n  args = parser.parse_args()\n\n  def process(lr):\n    return [can_capnp_to_can_list(m.can) for m in lr if m.which() == 'can']\n\n  print(\"Loading log...\")\n  if args.route_or_segment_name is None:\n    args.route_or_segment_name = \"77611a1fac303767/2020-03-24--09-50-38/1:3\"\n\n  sr = LogReader(args.route_or_segment_name)\n\n  CP = sr.first(\"carParams\")\n\n  print(f\"carFingerprint (for hardcoding fingerprint): '{CP.carFingerprint}'\")\n\n  CAN_MSGS = sr.run_across_segments(24, process)\n\n  print(\"Finished loading...\")\n\n  if ENABLE_PWR:\n    print(f\"Cycling power: on for {PWR_ON}s, off for {PWR_OFF}s\")\n  if ENABLE_IGN:\n    print(f\"Cycling ignition: on for {IGN_ON}s, off for {IGN_OFF}s\")\n\n  connect()\n", "tools/replay/lib/ui_helpers.py": "import itertools\nfrom typing import Any\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pygame\n\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\nfrom openpilot.common.transformations.camera import get_view_frame_from_calib_frame\nfrom openpilot.selfdrive.controls.radard import RADAR_TO_CAMERA\n\n\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\nYELLOW = (255, 255, 0)\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\nclass UIParams:\n  lidar_x, lidar_y, lidar_zoom = 384, 960, 6\n  lidar_car_x, lidar_car_y = lidar_x / 2., lidar_y / 1.1\n  car_hwidth = 1.7272 / 2 * lidar_zoom\n  car_front = 2.6924 * lidar_zoom\n  car_back = 1.8796 * lidar_zoom\n  car_color = 110\nUP = UIParams\n\nMETER_WIDTH = 20\n\nclass Calibration:\n  def __init__(self, num_px, rpy, intrinsic, calib_scale):\n    self.intrinsic = intrinsic\n    self.extrinsics_matrix = get_view_frame_from_calib_frame(rpy[0], rpy[1], rpy[2], 0.0)[:,:3]\n    self.zoom = calib_scale\n\n  def car_space_to_ff(self, x, y, z):\n    car_space_projective = np.column_stack((x, y, z)).T\n\n    ep = self.extrinsics_matrix.dot(car_space_projective)\n    kep = self.intrinsic.dot(ep)\n    return (kep[:-1, :] / kep[-1, :]).T\n\n  def car_space_to_bb(self, x, y, z):\n    pts = self.car_space_to_ff(x, y, z)\n    return pts / self.zoom\n\n\n_COLOR_CACHE : dict[tuple[int, int, int], Any] = {}\ndef find_color(lidar_surface, color):\n  if color in _COLOR_CACHE:\n    return _COLOR_CACHE[color]\n  tcolor = 0\n  ret = 255\n  for x in lidar_surface.get_palette():\n    if x[0:3] == color:\n      ret = tcolor\n      break\n    tcolor += 1\n  _COLOR_CACHE[color] = ret\n  return ret\n\n\ndef to_topdown_pt(y, x):\n  px, py = x * UP.lidar_zoom + UP.lidar_car_x, -y * UP.lidar_zoom + UP.lidar_car_y\n  if px > 0 and py > 0 and px < UP.lidar_x and py < UP.lidar_y:\n    return int(px), int(py)\n  return -1, -1\n\n\ndef draw_path(path, color, img, calibration, top_down, lid_color=None, z_off=0):\n  x, y, z = np.asarray(path.x), np.asarray(path.y), np.asarray(path.z) + z_off\n  pts = calibration.car_space_to_bb(x, y, z)\n  pts = np.round(pts).astype(int)\n\n  # draw lidar path point on lidar\n  # find color in 8 bit\n  if lid_color is not None and top_down is not None:\n    tcolor = find_color(top_down[0], lid_color)\n    for i in range(len(x)):\n      px, py = to_topdown_pt(x[i], y[i])\n      if px != -1:\n        top_down[1][px, py] = tcolor\n\n  height, width = img.shape[:2]\n  for x, y in pts:\n    if 1 < x < width - 1 and 1 < y < height - 1:\n      for a, b in itertools.permutations([-1, 0, -1], 2):\n        img[y + a, x + b] = color\n\n\ndef init_plots(arr, name_to_arr_idx, plot_xlims, plot_ylims, plot_names, plot_colors, plot_styles):\n  color_palette = { \"r\": (1, 0, 0),\n                    \"g\": (0, 1, 0),\n                    \"b\": (0, 0, 1),\n                    \"k\": (0, 0, 0),\n                    \"y\": (1, 1, 0),\n                    \"p\": (0, 1, 1),\n                    \"m\": (1, 0, 1)}\n\n  dpi = 90\n  fig = plt.figure(figsize=(575 / dpi, 600 / dpi), dpi=dpi)\n  canvas = FigureCanvasAgg(fig)\n\n  fig.set_facecolor((0.2, 0.2, 0.2))\n\n  axs = []\n  for pn in range(len(plot_ylims)):\n    ax = fig.add_subplot(len(plot_ylims), 1, len(axs)+1)\n    ax.set_xlim(plot_xlims[pn][0], plot_xlims[pn][1])\n    ax.set_ylim(plot_ylims[pn][0], plot_ylims[pn][1])\n    ax.patch.set_facecolor((0.4, 0.4, 0.4))\n    axs.append(ax)\n\n  plots, idxs, plot_select = [], [], []\n  for i, pl_list in enumerate(plot_names):\n    for j, item in enumerate(pl_list):\n      plot, = axs[i].plot(arr[:, name_to_arr_idx[item]],\n                          label=item,\n                          color=color_palette[plot_colors[i][j]],\n                          linestyle=plot_styles[i][j])\n      plots.append(plot)\n      idxs.append(name_to_arr_idx[item])\n      plot_select.append(i)\n    axs[i].set_title(\", \".join(f\"{nm} ({cl})\"\n                               for (nm, cl) in zip(pl_list, plot_colors[i], strict=False)), fontsize=10)\n    axs[i].tick_params(axis=\"x\", colors=\"white\")\n    axs[i].tick_params(axis=\"y\", colors=\"white\")\n    axs[i].title.set_color(\"white\")\n\n    if i < len(plot_ylims) - 1:\n      axs[i].set_xticks([])\n\n  canvas.draw()\n\n  def draw_plots(arr):\n    for ax in axs:\n      ax.draw_artist(ax.patch)\n    for i in range(len(plots)):\n      plots[i].set_ydata(arr[:, idxs[i]])\n      axs[plot_select[i]].draw_artist(plots[i])\n\n    raw_data = canvas.buffer_rgba()\n    plot_surface = pygame.image.frombuffer(raw_data, canvas.get_width_height(), \"RGBA\").convert()\n    return plot_surface\n\n  return draw_plots\n\n\ndef pygame_modules_have_loaded():\n  return pygame.display.get_init() and pygame.font.get_init()\n\n\ndef plot_model(m, img, calibration, top_down):\n  if calibration is None or top_down is None:\n    return\n\n  for lead in m.leadsV3:\n    if lead.prob < 0.5:\n      continue\n\n    x, y = lead.x[0], lead.y[0]\n    x_std = lead.xStd[0]\n    x -= RADAR_TO_CAMERA\n\n    _, py_top = to_topdown_pt(x + x_std, y)\n    px, py_bottom = to_topdown_pt(x - x_std, y)\n    top_down[1][int(round(px - 4)):int(round(px + 4)), py_top:py_bottom] = find_color(top_down[0], YELLOW)\n\n  for path, prob, _ in zip(m.laneLines, m.laneLineProbs, m.laneLineStds, strict=True):\n    color = (0, int(255 * prob), 0)\n    draw_path(path, color, img, calibration, top_down, YELLOW)\n\n  for edge, std in zip(m.roadEdges, m.roadEdgeStds, strict=True):\n    prob = max(1 - std, 0)\n    color = (int(255 * prob), 0, 0)\n    draw_path(edge, color, img, calibration, top_down, RED)\n\n  color = (255, 0, 0)\n  draw_path(m.position, color, img, calibration, top_down, RED, 1.22)\n\n\ndef plot_lead(rs, top_down):\n  for lead in [rs.leadOne, rs.leadTwo]:\n    if not lead.status:\n      continue\n\n    x = lead.dRel\n    px_left, py = to_topdown_pt(x, -10)\n    px_right, _ = to_topdown_pt(x, 10)\n    top_down[1][px_left:px_right, py] = find_color(top_down[0], RED)\n\n\ndef maybe_update_radar_points(lt, lid_overlay):\n  ar_pts = []\n  if lt is not None:\n    ar_pts = {}\n    for track in lt:\n      ar_pts[track.trackId] = [track.dRel, track.yRel, track.vRel, track.aRel, track.oncoming, track.stationary]\n  for ids, pt in ar_pts.items():\n    # negative here since radar is left positive\n    px, py = to_topdown_pt(pt[0], -pt[1])\n    if px != -1:\n      if pt[-1]:\n        color = 240\n      elif pt[-2]:\n        color = 230\n      else:\n        color = 255\n      if int(ids) == 1:\n        lid_overlay[px - 2:px + 2, py - 10:py + 10] = 100\n      else:\n        lid_overlay[px - 2:px + 2, py - 2:py + 2] = color\n\ndef get_blank_lid_overlay(UP):\n  lid_overlay = np.zeros((UP.lidar_x, UP.lidar_y), 'uint8')\n  # Draw the car.\n  lid_overlay[int(round(UP.lidar_car_x - UP.car_hwidth)):int(\n    round(UP.lidar_car_x + UP.car_hwidth)), int(round(UP.lidar_car_y -\n                                                      UP.car_front))] = UP.car_color\n  lid_overlay[int(round(UP.lidar_car_x - UP.car_hwidth)):int(\n    round(UP.lidar_car_x + UP.car_hwidth)), int(round(UP.lidar_car_y +\n                                                      UP.car_back))] = UP.car_color\n  lid_overlay[int(round(UP.lidar_car_x - UP.car_hwidth)), int(\n    round(UP.lidar_car_y - UP.car_front)):int(round(\n      UP.lidar_car_y + UP.car_back))] = UP.car_color\n  lid_overlay[int(round(UP.lidar_car_x + UP.car_hwidth)), int(\n    round(UP.lidar_car_y - UP.car_front)):int(round(\n      UP.lidar_car_y + UP.car_back))] = UP.car_color\n  return lid_overlay\n", "tools/replay/lib/__init__.py": "", "tools/bodyteleop/web.py": "import asyncio\nimport dataclasses\nimport json\nimport logging\nimport os\nimport ssl\nimport subprocess\n\nimport pyaudio\nimport wave\nfrom aiohttp import web\nfrom aiohttp import ClientSession\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.system.webrtc.webrtcd import StreamRequestBody\nfrom openpilot.common.params import Params\n\nlogger = logging.getLogger(\"bodyteleop\")\nlogging.basicConfig(level=logging.INFO)\n\nTELEOPDIR = f\"{BASEDIR}/tools/bodyteleop\"\nWEBRTCD_HOST, WEBRTCD_PORT = \"localhost\", 5001\n\n\n## UTILS\nasync def play_sound(sound: str):\n  SOUNDS = {\n    \"engage\": \"selfdrive/assets/sounds/engage.wav\",\n    \"disengage\": \"selfdrive/assets/sounds/disengage.wav\",\n    \"error\": \"selfdrive/assets/sounds/warning_immediate.wav\",\n  }\n  assert sound in SOUNDS\n\n  chunk = 5120\n  with wave.open(os.path.join(BASEDIR, SOUNDS[sound]), \"rb\") as wf:\n    def callback(in_data, frame_count, time_info, status):\n      data = wf.readframes(frame_count)\n      return data, pyaudio.paContinue\n\n    p = pyaudio.PyAudio()\n    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),\n                    channels=wf.getnchannels(),\n                    rate=wf.getframerate(),\n                    output=True,\n                    frames_per_buffer=chunk,\n                    stream_callback=callback)\n    stream.start_stream()\n    while stream.is_active():\n      await asyncio.sleep(0)\n    stream.stop_stream()\n    stream.close()\n    p.terminate()\n\n## SSL\ndef create_ssl_cert(cert_path: str, key_path: str):\n  try:\n    proc = subprocess.run(f'openssl req -x509 -newkey rsa:4096 -nodes -out {cert_path} -keyout {key_path} \\\n                          -days 365 -subj \"/C=US/ST=California/O=commaai/OU=comma body\"',\n                          capture_output=True, shell=True)\n    proc.check_returncode()\n  except subprocess.CalledProcessError as ex:\n    raise ValueError(f\"Error creating SSL certificate:\\n[stdout]\\n{proc.stdout.decode()}\\n[stderr]\\n{proc.stderr.decode()}\") from ex\n\n\ndef create_ssl_context():\n  cert_path = os.path.join(TELEOPDIR, \"cert.pem\")\n  key_path = os.path.join(TELEOPDIR, \"key.pem\")\n  if not os.path.exists(cert_path) or not os.path.exists(key_path):\n    logger.info(\"Creating certificate...\")\n    create_ssl_cert(cert_path, key_path)\n  else:\n    logger.info(\"Certificate exists!\")\n  ssl_context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_SERVER)\n  ssl_context.load_cert_chain(cert_path, key_path)\n\n  return ssl_context\n\n## ENDPOINTS\nasync def index(request: 'web.Request'):\n  with open(os.path.join(TELEOPDIR, \"static\", \"index.html\")) as f:\n    content = f.read()\n    return web.Response(content_type=\"text/html\", text=content)\n\n\nasync def ping(request: 'web.Request'):\n  return web.Response(text=\"pong\")\n\n\nasync def sound(request: 'web.Request'):\n  params = await request.json()\n  sound_to_play = params[\"sound\"]\n\n  await play_sound(sound_to_play)\n  return web.json_response({\"status\": \"ok\"})\n\n\nasync def offer(request: 'web.Request'):\n  params = await request.json()\n  body = StreamRequestBody(params[\"sdp\"], [\"driver\"], [\"testJoystick\"], [\"carState\"])\n  body_json = json.dumps(dataclasses.asdict(body))\n\n  logger.info(\"Sending offer to webrtcd...\")\n  webrtcd_url = f\"http://{WEBRTCD_HOST}:{WEBRTCD_PORT}/stream\"\n  async with ClientSession() as session, session.post(webrtcd_url, data=body_json) as resp:\n    assert resp.status == 200\n    answer = await resp.json()\n    return web.json_response(answer)\n\n\ndef main():\n  # Enable joystick debug mode\n  Params().put_bool(\"JoystickDebugMode\", True)\n\n  # App needs to be HTTPS for microphone and audio autoplay to work on the browser\n  ssl_context = create_ssl_context()\n\n  app = web.Application()\n  app.router.add_get(\"/\", index)\n  app.router.add_get(\"/ping\", ping, allow_head=True)\n  app.router.add_post(\"/offer\", offer)\n  app.router.add_post(\"/sound\", sound)\n  app.router.add_static('/static', os.path.join(TELEOPDIR, 'static'))\n  web.run_app(app, access_log=None, host=\"0.0.0.0\", port=5000, ssl_context=ssl_context)\n\n\nif __name__ == \"__main__\":\n  main()\n", "tools/camerastream/compressed_vipc.py": "#!/usr/bin/env python3\nimport av\nimport os\nimport sys\nimport argparse\nimport numpy as np\nimport multiprocessing\nimport time\nimport signal\n\nimport cereal.messaging as messaging\nfrom msgq.visionipc import VisionIpcServer, VisionStreamType\n\nV4L2_BUF_FLAG_KEYFRAME = 8\n\n# start encoderd\n# also start cereal messaging bridge\n# then run this \"./compressed_vipc.py <ip>\"\n\nENCODE_SOCKETS = {\n  VisionStreamType.VISION_STREAM_ROAD: \"roadEncodeData\",\n  VisionStreamType.VISION_STREAM_DRIVER: \"driverEncodeData\",\n  VisionStreamType.VISION_STREAM_WIDE_ROAD: \"wideRoadEncodeData\",\n}\n\ndef decoder(addr, vipc_server, vst, nvidia, W, H, debug=False):\n  sock_name = ENCODE_SOCKETS[vst]\n  if debug:\n    print(f\"start decoder for {sock_name}, {W}x{H}\")\n\n  if nvidia:\n    os.environ[\"NV_LOW_LATENCY\"] = \"3\"    # both bLowLatency and CUVID_PKT_ENDOFPICTURE\n    sys.path += os.environ[\"LD_LIBRARY_PATH\"].split(\":\")\n    import PyNvCodec as nvc\n\n    nvDec = nvc.PyNvDecoder(W, H, nvc.PixelFormat.NV12, nvc.CudaVideoCodec.HEVC, 0)\n    cc1 = nvc.ColorspaceConversionContext(nvc.ColorSpace.BT_709, nvc.ColorRange.JPEG)\n    conv_yuv = nvc.PySurfaceConverter(W, H, nvc.PixelFormat.NV12, nvc.PixelFormat.YUV420, 0)\n    nvDwn_yuv = nvc.PySurfaceDownloader(W, H, nvc.PixelFormat.YUV420, 0)\n    img_yuv = np.ndarray((H*W//2*3), dtype=np.uint8)\n  else:\n    codec = av.CodecContext.create(\"hevc\", \"r\")\n\n  os.environ[\"ZMQ\"] = \"1\"\n  messaging.context = messaging.Context()\n  sock = messaging.sub_sock(sock_name, None, addr=addr, conflate=False)\n  cnt = 0\n  last_idx = -1\n  seen_iframe = False\n\n  time_q = []\n  while 1:\n    msgs = messaging.drain_sock(sock, wait_for_one=True)\n    for evt in msgs:\n      evta = getattr(evt, evt.which())\n      if debug and evta.idx.encodeId != 0 and evta.idx.encodeId != (last_idx+1):\n        print(\"DROP PACKET!\")\n      last_idx = evta.idx.encodeId\n      if not seen_iframe and not (evta.idx.flags & V4L2_BUF_FLAG_KEYFRAME):\n        if debug:\n          print(\"waiting for iframe\")\n        continue\n      time_q.append(time.monotonic())\n      network_latency = (int(time.time()*1e9) - evta.unixTimestampNanos)/1e6\n      frame_latency = ((evta.idx.timestampEof/1e9) - (evta.idx.timestampSof/1e9))*1000\n      process_latency = ((evt.logMonoTime/1e9) - (evta.idx.timestampEof/1e9))*1000\n\n      # put in header (first)\n      if not seen_iframe:\n        if nvidia:\n          nvDec.DecodeSurfaceFromPacket(np.frombuffer(evta.header, dtype=np.uint8))\n        else:\n          codec.decode(av.packet.Packet(evta.header))\n        seen_iframe = True\n\n      if nvidia:\n        rawSurface = nvDec.DecodeSurfaceFromPacket(np.frombuffer(evta.data, dtype=np.uint8))\n        if rawSurface.Empty():\n          if debug:\n            print(\"DROP SURFACE\")\n          continue\n        convSurface = conv_yuv.Execute(rawSurface, cc1)\n        nvDwn_yuv.DownloadSingleSurface(convSurface, img_yuv)\n      else:\n        frames = codec.decode(av.packet.Packet(evta.data))\n        if len(frames) == 0:\n          if debug:\n            print(\"DROP SURFACE\")\n          continue\n        assert len(frames) == 1\n        img_yuv = frames[0].to_ndarray(format=av.video.format.VideoFormat('yuv420p')).flatten()\n        uv_offset = H*W\n        y = img_yuv[:uv_offset]\n        uv = img_yuv[uv_offset:].reshape(2, -1).ravel('F')\n        img_yuv = np.hstack((y, uv))\n\n      vipc_server.send(vst, img_yuv.data, cnt, int(time_q[0]*1e9), int(time.monotonic()*1e9))\n      cnt += 1\n\n      pc_latency = (time.monotonic()-time_q[0])*1000\n      time_q = time_q[1:]\n      if debug:\n        print(\"%2d %4d %.3f %.3f roll %6.2f ms latency %6.2f ms + %6.2f ms + %6.2f ms = %6.2f ms\"\n              % (len(msgs), evta.idx.encodeId, evt.logMonoTime/1e9, evta.idx.timestampEof/1e6, frame_latency,\n                 process_latency, network_latency, pc_latency, process_latency+network_latency+pc_latency ), len(evta.data), sock_name)\n\n\nclass CompressedVipc:\n  def __init__(self, addr, vision_streams, nvidia=False, debug=False):\n    print(\"getting frame sizes\")\n    os.environ[\"ZMQ\"] = \"1\"\n    messaging.context = messaging.Context()\n    sm = messaging.SubMaster([ENCODE_SOCKETS[s] for s in vision_streams], addr=addr)\n    while min(sm.recv_frame.values()) == 0:\n      sm.update(100)\n    os.environ.pop(\"ZMQ\")\n    messaging.context = messaging.Context()\n\n    self.vipc_server = VisionIpcServer(\"camerad\")\n    for vst in vision_streams:\n      ed = sm[ENCODE_SOCKETS[vst]]\n      self.vipc_server.create_buffers(vst, 4, False, ed.width, ed.height)\n    self.vipc_server.start_listener()\n\n    self.procs = []\n    for vst in vision_streams:\n      ed = sm[ENCODE_SOCKETS[vst]]\n      p = multiprocessing.Process(target=decoder, args=(addr, self.vipc_server, vst, nvidia, ed.width, ed.height, debug))\n      p.start()\n      self.procs.append(p)\n\n  def join(self):\n    for p in self.procs:\n      p.join()\n\n  def kill(self):\n    for p in self.procs:\n      p.terminate()\n    self.join()\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Decode video streams and broadcast on VisionIPC\")\n  parser.add_argument(\"addr\", help=\"Address of comma three\")\n  parser.add_argument(\"--nvidia\", action=\"store_true\", help=\"Use nvidia instead of ffmpeg\")\n  parser.add_argument(\"--cams\", default=\"0,1,2\", help=\"Cameras to decode\")\n  parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress debug output\")\n  args = parser.parse_args()\n\n  vision_streams = [\n    VisionStreamType.VISION_STREAM_ROAD,\n    VisionStreamType.VISION_STREAM_DRIVER,\n    VisionStreamType.VISION_STREAM_WIDE_ROAD,\n  ]\n\n  vsts = [vision_streams[int(x)] for x in args.cams.split(\",\")]\n  cvipc = CompressedVipc(args.addr, vsts, args.nvidia, debug=(not args.silent))\n\n  # register exit handler\n  signal.signal(signal.SIGINT, lambda sig, frame: cvipc.kill())\n\n  cvipc.join()\n", "tools/sim/run_bridge.py": "#!/usr/bin/env python\nimport argparse\n\nfrom typing import Any\nfrom multiprocessing import Queue\n\nfrom openpilot.tools.sim.bridge.metadrive.metadrive_bridge import MetaDriveBridge\n\ndef create_bridge(dual_camera, high_quality):\n  queue: Any = Queue()\n\n  simulator_bridge = MetaDriveBridge(dual_camera, high_quality)\n  simulator_process = simulator_bridge.run(queue)\n\n  return queue, simulator_process, simulator_bridge\n\ndef main():\n  _, simulator_process, _ = create_bridge(True, False)\n  simulator_process.join()\n\ndef parse_args(add_args=None):\n  parser = argparse.ArgumentParser(description='Bridge between the simulator and openpilot.')\n  parser.add_argument('--joystick', action='store_true')\n  parser.add_argument('--high_quality', action='store_true')\n  parser.add_argument('--dual_camera', action='store_true')\n\n  return parser.parse_args(add_args)\n\nif __name__ == \"__main__\":\n  args = parse_args()\n\n  queue, simulator_process, simulator_bridge = create_bridge(args.dual_camera, args.high_quality)\n\n  if args.joystick:\n    # start input poll for joystick\n    from openpilot.tools.sim.lib.manual_ctrl import wheel_poll_thread\n\n    wheel_poll_thread(queue)\n  else:\n    # start input poll for keyboard\n    from openpilot.tools.sim.lib.keyboard_ctrl import keyboard_poll_thread\n\n    keyboard_poll_thread(queue)\n\n  simulator_bridge.shutdown()\n\n  simulator_process.join()\n", "tools/sim/__init__.py": "", "tools/sim/bridge/common.py": "import signal\nimport threading\nimport functools\n\nfrom collections import namedtuple\nfrom enum import Enum\nfrom multiprocessing import Process, Queue, Value\nfrom abc import ABC, abstractmethod\n\nfrom openpilot.common.params import Params\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.realtime import Ratekeeper\nfrom openpilot.selfdrive.test.helpers import set_params_enabled\nfrom openpilot.selfdrive.car.honda.values import CruiseButtons\nfrom openpilot.tools.sim.lib.common import SimulatorState, World\nfrom openpilot.tools.sim.lib.simulated_car import SimulatedCar\nfrom openpilot.tools.sim.lib.simulated_sensors import SimulatedSensors\n\nQueueMessage = namedtuple(\"QueueMessage\", [\"type\", \"info\"], defaults=[None])\n\nclass QueueMessageType(Enum):\n  START_STATUS = 0\n  CONTROL_COMMAND = 1\n  TERMINATION_INFO = 2\n  CLOSE_STATUS = 3\n\ndef control_cmd_gen(cmd: str):\n  return QueueMessage(QueueMessageType.CONTROL_COMMAND, cmd)\n\ndef rk_loop(function, hz, exit_event: threading.Event):\n  rk = Ratekeeper(hz, None)\n  while not exit_event.is_set():\n    function()\n    rk.keep_time()\n\n\nclass SimulatorBridge(ABC):\n  TICKS_PER_FRAME = 5\n\n  def __init__(self, dual_camera, high_quality):\n    set_params_enabled()\n    self.params = Params()\n    self.params.put_bool(\"ExperimentalLongitudinalEnabled\", True)\n\n    self.rk = Ratekeeper(100, None)\n\n    self.dual_camera = dual_camera\n    self.high_quality = high_quality\n\n    self._exit_event = threading.Event()\n    self._threads = []\n    self._keep_alive = True\n    self.started = Value('i', False)\n    signal.signal(signal.SIGTERM, self._on_shutdown)\n    self._exit = threading.Event()\n    self.simulator_state = SimulatorState()\n\n    self.world: World | None = None\n\n    self.past_startup_engaged = False\n    self.startup_button_prev = True\n\n    self.test_run = False\n\n  def _on_shutdown(self, signal, frame):\n    self.shutdown()\n\n  def shutdown(self):\n    self._keep_alive = False\n\n  def bridge_keep_alive(self, q: Queue, retries: int):\n    try:\n      self._run(q)\n    finally:\n      self.close(\"bridge terminated\")\n\n  def close(self, reason):\n    self.started.value = False\n    self._exit_event.set()\n\n    if self.world is not None:\n      self.world.close(reason)\n\n  def run(self, queue, retries=-1):\n    bridge_p = Process(name=\"bridge\", target=self.bridge_keep_alive, args=(queue, retries))\n    bridge_p.start()\n    return bridge_p\n\n  def print_status(self):\n    print(\n    f\"\"\"\nState:\nIgnition: {self.simulator_state.ignition} Engaged: {self.simulator_state.is_engaged}\n    \"\"\")\n\n  @abstractmethod\n  def spawn_world(self, q: Queue) -> World:\n    pass\n\n  def _run(self, q: Queue):\n    self.world = self.spawn_world(q)\n\n    self.simulated_car = SimulatedCar()\n    self.simulated_sensors = SimulatedSensors(self.dual_camera)\n\n    self.simulated_car_thread = threading.Thread(target=rk_loop, args=(functools.partial(self.simulated_car.update, self.simulator_state),\n                                                                        100, self._exit_event))\n    self.simulated_car_thread.start()\n\n    self.simulated_camera_thread = threading.Thread(target=rk_loop, args=(functools.partial(self.simulated_sensors.send_camera_images, self.world),\n                                                                        20, self._exit_event))\n    self.simulated_camera_thread.start()\n\n    # Simulation tends to be slow in the initial steps. This prevents lagging later\n    for _ in range(20):\n      self.world.tick()\n\n    while self._keep_alive:\n      throttle_out = steer_out = brake_out = 0.0\n      throttle_op = steer_op = brake_op = 0.0\n\n      self.simulator_state.cruise_button = 0\n      self.simulator_state.left_blinker = False\n      self.simulator_state.right_blinker = False\n\n      throttle_manual = steer_manual = brake_manual = 0.\n\n      # Read manual controls\n      if not q.empty():\n        message = q.get()\n        if message.type == QueueMessageType.CONTROL_COMMAND:\n          m = message.info.split('_')\n          if m[0] == \"steer\":\n            steer_manual = float(m[1])\n          elif m[0] == \"throttle\":\n            throttle_manual = float(m[1])\n          elif m[0] == \"brake\":\n            brake_manual = float(m[1])\n          elif m[0] == \"cruise\":\n            if m[1] == \"down\":\n              self.simulator_state.cruise_button = CruiseButtons.DECEL_SET\n            elif m[1] == \"up\":\n              self.simulator_state.cruise_button = CruiseButtons.RES_ACCEL\n            elif m[1] == \"cancel\":\n              self.simulator_state.cruise_button = CruiseButtons.CANCEL\n            elif m[1] == \"main\":\n              self.simulator_state.cruise_button = CruiseButtons.MAIN\n          elif m[0] == \"blinker\":\n            if m[1] == \"left\":\n              self.simulator_state.left_blinker = True\n            elif m[1] == \"right\":\n              self.simulator_state.right_blinker = True\n          elif m[0] == \"ignition\":\n            self.simulator_state.ignition = not self.simulator_state.ignition\n          elif m[0] == \"reset\":\n            self.world.reset()\n          elif m[0] == \"quit\":\n            break\n\n      self.simulator_state.user_brake = brake_manual\n      self.simulator_state.user_gas = throttle_manual\n      self.simulator_state.user_torque = steer_manual * -10000\n\n      steer_manual = steer_manual * -40\n\n      # Update openpilot on current sensor state\n      self.simulated_sensors.update(self.simulator_state, self.world)\n\n      self.simulated_car.sm.update(0)\n      controlsState = self.simulated_car.sm['controlsState']\n      self.simulator_state.is_engaged = controlsState.active\n\n      if self.simulator_state.is_engaged:\n        throttle_op = clip(self.simulated_car.sm['carControl'].actuators.accel / 1.6, 0.0, 1.0)\n        brake_op = clip(-self.simulated_car.sm['carControl'].actuators.accel / 4.0, 0.0, 1.0)\n        steer_op = self.simulated_car.sm['carControl'].actuators.steeringAngleDeg\n\n        self.past_startup_engaged = True\n      elif not self.past_startup_engaged and controlsState.engageable:\n        self.simulator_state.cruise_button = CruiseButtons.DECEL_SET if self.startup_button_prev else CruiseButtons.MAIN # force engagement on startup\n        self.startup_button_prev = not self.startup_button_prev\n\n      throttle_out = throttle_op if self.simulator_state.is_engaged else throttle_manual\n      brake_out = brake_op if self.simulator_state.is_engaged else brake_manual\n      steer_out = steer_op if self.simulator_state.is_engaged else steer_manual\n\n      self.world.apply_controls(steer_out, throttle_out, brake_out)\n      self.world.read_state()\n      self.world.read_sensors(self.simulator_state)\n\n      if self.world.exit_event.is_set():\n        self.shutdown()\n\n      if self.rk.frame % self.TICKS_PER_FRAME == 0:\n        self.world.tick()\n        self.world.read_cameras()\n\n      # don't print during test, so no print/IO Block between OP and metadrive processes\n      if not self.test_run and self.rk.frame % 25 == 0:\n        self.print_status()\n\n      self.started.value = True\n\n      self.rk.keep_time()\n", "tools/sim/bridge/__init__.py": "", "tools/sim/bridge/metadrive/metadrive_bridge.py": "import math\nfrom multiprocessing import Queue\n\nfrom metadrive.component.sensors.base_camera import _cuda_enable\nfrom metadrive.component.map.pg_map import MapGenerateMethod\n\nfrom openpilot.tools.sim.bridge.common import SimulatorBridge\nfrom openpilot.tools.sim.bridge.metadrive.metadrive_common import RGBCameraRoad, RGBCameraWide\nfrom openpilot.tools.sim.bridge.metadrive.metadrive_world import MetaDriveWorld\nfrom openpilot.tools.sim.lib.camerad import W, H\n\n\ndef straight_block(length):\n  return {\n    \"id\": \"S\",\n    \"pre_block_socket_index\": 0,\n    \"length\": length\n  }\n\ndef curve_block(length, angle=45, direction=0):\n  return {\n    \"id\": \"C\",\n    \"pre_block_socket_index\": 0,\n    \"length\": length,\n    \"radius\": length,\n    \"angle\": angle,\n    \"dir\": direction\n  }\n\ndef create_map(track_size=60):\n  curve_len = track_size * 2\n  return dict(\n    type=MapGenerateMethod.PG_MAP_FILE,\n    lane_num=2,\n    lane_width=4.5,\n    config=[\n      None,\n      straight_block(track_size),\n      curve_block(curve_len, 90),\n      straight_block(track_size),\n      curve_block(curve_len, 90),\n      straight_block(track_size),\n      curve_block(curve_len, 90),\n      straight_block(track_size),\n      curve_block(curve_len, 90),\n    ]\n  )\n\n\nclass MetaDriveBridge(SimulatorBridge):\n  TICKS_PER_FRAME = 5\n\n  def __init__(self, dual_camera, high_quality, test_duration=math.inf, test_run=False):\n    super().__init__(dual_camera, high_quality)\n\n    self.should_render = False\n    self.test_run = test_run\n    self.test_duration = test_duration if self.test_run else math.inf\n\n  def spawn_world(self, queue: Queue):\n    sensors = {\n      \"rgb_road\": (RGBCameraRoad, W, H, )\n    }\n\n    if self.dual_camera:\n      sensors[\"rgb_wide\"] = (RGBCameraWide, W, H)\n\n    config = dict(\n      use_render=self.should_render,\n      vehicle_config=dict(\n        enable_reverse=False,\n        image_source=\"rgb_road\",\n      ),\n      sensors=sensors,\n      image_on_cuda=_cuda_enable,\n      image_observation=True,\n      interface_panel=[],\n      out_of_route_done=False,\n      on_continuous_line_done=False,\n      crash_vehicle_done=False,\n      crash_object_done=False,\n      arrive_dest_done=False,\n      traffic_density=0.0, # traffic is incredibly expensive\n      map_config=create_map(),\n      decision_repeat=1,\n      physics_world_step_size=self.TICKS_PER_FRAME/100,\n      preload_models=False\n    )\n\n    return MetaDriveWorld(queue, config, self.test_duration, self.test_run, self.dual_camera)\n", "tools/sim/bridge/metadrive/metadrive_common.py": "import numpy as np\n\nfrom metadrive.component.sensors.rgb_camera import RGBCamera\nfrom panda3d.core import Texture, GraphicsOutput\n\n\nclass CopyRamRGBCamera(RGBCamera):\n  \"\"\"Camera which copies its content into RAM during the render process, for faster image grabbing.\"\"\"\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.cpu_texture = Texture()\n    self.buffer.addRenderTexture(self.cpu_texture, GraphicsOutput.RTMCopyRam)\n\n  def get_rgb_array_cpu(self):\n    origin_img = self.cpu_texture\n    img = np.frombuffer(origin_img.getRamImage().getData(), dtype=np.uint8)\n    img = img.reshape((origin_img.getYSize(), origin_img.getXSize(), -1))\n    img = img[:,:,:3] # RGBA to RGB\n    # img = np.swapaxes(img, 1, 0)\n    img = img[::-1] # Flip on vertical axis\n    return img\n\n\nclass RGBCameraWide(CopyRamRGBCamera):\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    lens = self.get_lens()\n    lens.setFov(120)\n    lens.setNear(0.1)\n\n\nclass RGBCameraRoad(CopyRamRGBCamera):\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    lens = self.get_lens()\n    lens.setFov(40)\n    lens.setNear(0.1)\n", "tools/sim/bridge/metadrive/metadrive_process.py": "import math\nimport time\nimport numpy as np\n\nfrom collections import namedtuple\nfrom panda3d.core import Vec3\nfrom multiprocessing.connection import Connection\n\nfrom metadrive.engine.core.engine_core import EngineCore\nfrom metadrive.engine.core.image_buffer import ImageBuffer\nfrom metadrive.envs.metadrive_env import MetaDriveEnv\nfrom metadrive.obs.image_obs import ImageObservation\n\nfrom openpilot.common.realtime import Ratekeeper\n\nfrom openpilot.tools.sim.lib.common import vec3\nfrom openpilot.tools.sim.lib.camerad import W, H\n\nC3_POSITION = Vec3(0.0, 0, 1.22)\nC3_HPR = Vec3(0, 0,0)\n\n\nmetadrive_simulation_state = namedtuple(\"metadrive_simulation_state\", [\"running\", \"done\", \"done_info\"])\nmetadrive_vehicle_state = namedtuple(\"metadrive_vehicle_state\", [\"velocity\", \"position\", \"bearing\", \"steering_angle\"])\n\ndef apply_metadrive_patches(arrive_dest_done=True):\n  # By default, metadrive won't try to use cuda images unless it's used as a sensor for vehicles, so patch that in\n  def add_image_sensor_patched(self, name: str, cls, args):\n    if self.global_config[\"image_on_cuda\"]:# and name == self.global_config[\"vehicle_config\"][\"image_source\"]:\n        sensor = cls(*args, self, cuda=True)\n    else:\n        sensor = cls(*args, self, cuda=False)\n    assert isinstance(sensor, ImageBuffer), \"This API is for adding image sensor\"\n    self.sensors[name] = sensor\n\n  EngineCore.add_image_sensor = add_image_sensor_patched\n\n  # we aren't going to use the built-in observation stack, so disable it to save time\n  def observe_patched(self, *args, **kwargs):\n    return self.state\n\n  ImageObservation.observe = observe_patched\n\n  # disable destination, we want to loop forever\n  def arrive_destination_patch(self, *args, **kwargs):\n    return False\n\n  if not arrive_dest_done:\n    MetaDriveEnv._is_arrive_destination = arrive_destination_patch\n\ndef metadrive_process(dual_camera: bool, config: dict, camera_array, wide_camera_array, image_lock,\n                      controls_recv: Connection, simulation_state_send: Connection, vehicle_state_send: Connection,\n                      exit_event, op_engaged, test_duration, test_run):\n  arrive_dest_done = config.pop(\"arrive_dest_done\", True)\n  apply_metadrive_patches(arrive_dest_done)\n\n  road_image = np.frombuffer(camera_array.get_obj(), dtype=np.uint8).reshape((H, W, 3))\n  if dual_camera:\n    assert wide_camera_array is not None\n    wide_road_image = np.frombuffer(wide_camera_array.get_obj(), dtype=np.uint8).reshape((H, W, 3))\n\n  env = MetaDriveEnv(config)\n\n  def get_current_lane_info(vehicle):\n    _, lane_info, on_lane = vehicle.navigation._get_current_lane(vehicle)\n    lane_idx = lane_info[2] if lane_info is not None else None\n    return lane_idx, on_lane\n\n  def reset():\n    env.reset()\n    env.vehicle.config[\"max_speed_km_h\"] = 1000\n    lane_idx_prev, _ = get_current_lane_info(env.vehicle)\n\n    simulation_state = metadrive_simulation_state(\n      running=True,\n      done=False,\n      done_info=None,\n    )\n    simulation_state_send.send(simulation_state)\n\n    return lane_idx_prev\n\n  lane_idx_prev = reset()\n  start_time = None\n\n  def get_cam_as_rgb(cam):\n    cam = env.engine.sensors[cam]\n    cam.get_cam().reparentTo(env.vehicle.origin)\n    cam.get_cam().setPos(C3_POSITION)\n    cam.get_cam().setHpr(C3_HPR)\n    img = cam.perceive(to_float=False)\n    if type(img) != np.ndarray:\n      img = img.get() # convert cupy array to numpy\n    return img\n\n  rk = Ratekeeper(100, None)\n\n  steer_ratio = 8\n  vc = [0,0]\n\n  while not exit_event.is_set():\n    vehicle_state = metadrive_vehicle_state(\n      velocity=vec3(x=float(env.vehicle.velocity[0]), y=float(env.vehicle.velocity[1]), z=0),\n      position=env.vehicle.position,\n      bearing=float(math.degrees(env.vehicle.heading_theta)),\n      steering_angle=env.vehicle.steering * env.vehicle.MAX_STEERING\n    )\n    vehicle_state_send.send(vehicle_state)\n\n    if controls_recv.poll(0):\n      while controls_recv.poll(0):\n        steer_angle, gas, should_reset = controls_recv.recv()\n\n      steer_metadrive = steer_angle * 1 / (env.vehicle.MAX_STEERING * steer_ratio)\n      steer_metadrive = np.clip(steer_metadrive, -1, 1)\n\n      vc = [steer_metadrive, gas]\n\n      if should_reset:\n        lane_idx_prev = reset()\n        start_time = None\n\n    is_engaged = op_engaged.is_set()\n    if is_engaged and start_time is None:\n      start_time = time.monotonic()\n\n    if rk.frame % 5 == 0:\n      _, _, terminated, _, _ = env.step(vc)\n      timeout = True if start_time is not None and time.monotonic() - start_time >= test_duration else False\n      lane_idx_curr, on_lane = get_current_lane_info(env.vehicle)\n      out_of_lane = lane_idx_curr != lane_idx_prev or not on_lane\n      lane_idx_prev = lane_idx_curr\n\n      if terminated or ((out_of_lane or timeout) and test_run):\n        if terminated:\n          done_result = env.done_function(\"default_agent\")\n        elif out_of_lane:\n          done_result = (True, {\"out_of_lane\" : True})\n        elif timeout:\n          done_result = (True, {\"timeout\" : True})\n\n        simulation_state = metadrive_simulation_state(\n          running=False,\n          done=done_result[0],\n          done_info=done_result[1],\n        )\n        simulation_state_send.send(simulation_state)\n\n      if dual_camera:\n        wide_road_image[...] = get_cam_as_rgb(\"rgb_wide\")\n      road_image[...] = get_cam_as_rgb(\"rgb_road\")\n      image_lock.release()\n\n    rk.keep_time()\n", "tools/sim/bridge/metadrive/metadrive_world.py": "import ctypes\nimport functools\nimport multiprocessing\nimport numpy as np\nimport time\n\nfrom multiprocessing import Pipe, Array\n\nfrom openpilot.tools.sim.bridge.common import QueueMessage, QueueMessageType\nfrom openpilot.tools.sim.bridge.metadrive.metadrive_process import (metadrive_process, metadrive_simulation_state,\n                                                                    metadrive_vehicle_state)\nfrom openpilot.tools.sim.lib.common import SimulatorState, World\nfrom openpilot.tools.sim.lib.camerad import W, H\n\n\nclass MetaDriveWorld(World):\n  def __init__(self, status_q, config, test_duration, test_run, dual_camera=False):\n    super().__init__(dual_camera)\n    self.status_q = status_q\n    self.camera_array = Array(ctypes.c_uint8, W*H*3)\n    self.road_image = np.frombuffer(self.camera_array.get_obj(), dtype=np.uint8).reshape((H, W, 3))\n    self.wide_camera_array = None\n    if dual_camera:\n      self.wide_camera_array = Array(ctypes.c_uint8, W*H*3)\n      self.wide_road_image = np.frombuffer(self.wide_camera_array.get_obj(), dtype=np.uint8).reshape((H, W, 3))\n\n    self.controls_send, self.controls_recv = Pipe()\n    self.simulation_state_send, self.simulation_state_recv = Pipe()\n    self.vehicle_state_send, self.vehicle_state_recv = Pipe()\n\n    self.exit_event = multiprocessing.Event()\n    self.op_engaged = multiprocessing.Event()\n\n    self.test_run = test_run\n\n    self.first_engage = None\n    self.last_check_timestamp = 0\n    self.distance_moved = 0\n\n    self.metadrive_process = multiprocessing.Process(name=\"metadrive process\", target=\n                              functools.partial(metadrive_process, dual_camera, config,\n                                                self.camera_array, self.wide_camera_array, self.image_lock,\n                                                self.controls_recv, self.simulation_state_send,\n                                                self.vehicle_state_send, self.exit_event, self.op_engaged, test_duration, self.test_run))\n\n    self.metadrive_process.start()\n    self.status_q.put(QueueMessage(QueueMessageType.START_STATUS, \"starting\"))\n\n    print(\"----------------------------------------------------------\")\n    print(\"---- Spawning Metadrive world, this might take awhile ----\")\n    print(\"----------------------------------------------------------\")\n\n    self.vehicle_last_pos = self.vehicle_state_recv.recv().position # wait for a state message to ensure metadrive is launched\n    self.status_q.put(QueueMessage(QueueMessageType.START_STATUS, \"started\"))\n\n    self.steer_ratio = 15\n    self.vc = [0.0,0.0]\n    self.reset_time = 0\n    self.should_reset = False\n\n  def apply_controls(self, steer_angle, throttle_out, brake_out):\n    if (time.monotonic() - self.reset_time) > 2:\n      self.vc[0] = steer_angle\n\n      if throttle_out:\n        self.vc[1] = throttle_out\n      else:\n        self.vc[1] = -brake_out\n    else:\n      self.vc[0] = 0\n      self.vc[1] = 0\n\n    self.controls_send.send([*self.vc, self.should_reset])\n    self.should_reset = False\n\n  def read_state(self):\n    while self.simulation_state_recv.poll(0):\n      md_state: metadrive_simulation_state = self.simulation_state_recv.recv()\n      if md_state.done:\n        self.status_q.put(QueueMessage(QueueMessageType.TERMINATION_INFO, md_state.done_info))\n        self.exit_event.set()\n\n  def read_sensors(self, state: SimulatorState):\n    while self.vehicle_state_recv.poll(0):\n      md_vehicle: metadrive_vehicle_state = self.vehicle_state_recv.recv()\n      curr_pos = md_vehicle.position\n\n      state.velocity = md_vehicle.velocity\n      state.bearing = md_vehicle.bearing\n      state.steering_angle = md_vehicle.steering_angle\n      state.gps.from_xy(curr_pos)\n      state.valid = True\n\n      is_engaged = state.is_engaged\n      if is_engaged and self.first_engage is None:\n        self.first_engage = time.monotonic()\n        self.op_engaged.set()\n\n      # check moving 5 seconds after engaged, doesn't move right away\n      after_engaged_check = is_engaged and time.monotonic() - self.first_engage >= 5 and self.test_run\n\n      x_dist = abs(curr_pos[0] - self.vehicle_last_pos[0])\n      y_dist = abs(curr_pos[1] - self.vehicle_last_pos[1])\n      dist_threshold = 1\n      if x_dist >= dist_threshold or y_dist >= dist_threshold: # position not the same during staying still, > threshold is considered moving\n        self.distance_moved += x_dist + y_dist\n\n      time_check_threshold = 30\n      current_time = time.monotonic()\n      since_last_check = current_time - self.last_check_timestamp\n      if since_last_check >= time_check_threshold:\n        if after_engaged_check and self.distance_moved == 0:\n          self.status_q.put(QueueMessage(QueueMessageType.TERMINATION_INFO, {\"vehicle_not_moving\" : True}))\n          self.exit_event.set()\n\n        self.last_check_timestamp = current_time\n        self.distance_moved = 0\n        self.vehicle_last_pos = curr_pos\n\n  def read_cameras(self):\n    pass\n\n  def tick(self):\n    pass\n\n  def reset(self):\n    self.should_reset = True\n\n  def close(self, reason: str):\n    self.status_q.put(QueueMessage(QueueMessageType.CLOSE_STATUS, reason))\n    self.exit_event.set()\n    self.metadrive_process.join()\n", "tools/sim/lib/manual_ctrl.py": "#!/usr/bin/env python3\n# set up wheel\nimport array\nimport os\nimport struct\nfrom fcntl import ioctl\nfrom typing import NoReturn\n\nfrom openpilot.tools.sim.bridge.common import control_cmd_gen\n\n# Iterate over the joystick devices.\nprint('Available devices:')\nfor fn in os.listdir('/dev/input'):\n  if fn.startswith('js'):\n    print(f'  /dev/input/{fn}')\n\n# We'll store the states here.\naxis_states: dict[str, float] = {}\nbutton_states: dict[str, float] = {}\n\n# These constants were borrowed from linux/input.h\naxis_names = {\n  0x00 : 'x',\n  0x01 : 'y',\n  0x02 : 'z',\n  0x03 : 'rx',\n  0x04 : 'ry',\n  0x05 : 'rz',\n  0x06 : 'trottle',\n  0x07 : 'rudder',\n  0x08 : 'wheel',\n  0x09 : 'gas',\n  0x0a : 'brake',\n  0x10 : 'hat0x',\n  0x11 : 'hat0y',\n  0x12 : 'hat1x',\n  0x13 : 'hat1y',\n  0x14 : 'hat2x',\n  0x15 : 'hat2y',\n  0x16 : 'hat3x',\n  0x17 : 'hat3y',\n  0x18 : 'pressure',\n  0x19 : 'distance',\n  0x1a : 'tilt_x',\n  0x1b : 'tilt_y',\n  0x1c : 'tool_width',\n  0x20 : 'volume',\n  0x28 : 'misc',\n}\n\nbutton_names = {\n  0x120 : 'trigger',\n  0x121 : 'thumb',\n  0x122 : 'thumb2',\n  0x123 : 'top',\n  0x124 : 'top2',\n  0x125 : 'pinkie',\n  0x126 : 'base',\n  0x127 : 'base2',\n  0x128 : 'base3',\n  0x129 : 'base4',\n  0x12a : 'base5',\n  0x12b : 'base6',\n  0x12f : 'dead',\n  0x130 : 'a',\n  0x131 : 'b',\n  0x132 : 'c',\n  0x133 : 'x',\n  0x134 : 'y',\n  0x135 : 'z',\n  0x136 : 'tl',\n  0x137 : 'tr',\n  0x138 : 'tl2',\n  0x139 : 'tr2',\n  0x13a : 'select',\n  0x13b : 'start',\n  0x13c : 'mode',\n  0x13d : 'thumbl',\n  0x13e : 'thumbr',\n\n  0x220 : 'dpad_up',\n  0x221 : 'dpad_down',\n  0x222 : 'dpad_left',\n  0x223 : 'dpad_right',\n\n  # XBox 360 controller uses these codes.\n  0x2c0 : 'dpad_left',\n  0x2c1 : 'dpad_right',\n  0x2c2 : 'dpad_up',\n  0x2c3 : 'dpad_down',\n}\n\naxis_name_list: list[str] = []\nbutton_name_list: list[str] = []\n\ndef wheel_poll_thread(q: 'Queue[str]') -> NoReturn:\n  # Open the joystick device.\n  fn = '/dev/input/js0'\n  print(f'Opening {fn}...')\n  jsdev = open(fn, 'rb')\n\n  # Get the device name.\n  #buf = bytearray(63)\n  buf = array.array('B', [0] * 64)\n  ioctl(jsdev, 0x80006a13 + (0x10000 * len(buf)), buf)  # JSIOCGNAME(len)\n  js_name = buf.tobytes().rstrip(b'\\x00').decode('utf-8')\n  print(f'Device name: {js_name}')\n\n  # Get number of axes and buttons.\n  buf = array.array('B', [0])\n  ioctl(jsdev, 0x80016a11, buf)  # JSIOCGAXES\n  num_axes = buf[0]\n\n  buf = array.array('B', [0])\n  ioctl(jsdev, 0x80016a12, buf)  # JSIOCGBUTTONS\n  num_buttons = buf[0]\n\n  # Get the axis map.\n  buf = array.array('B', [0] * 0x40)\n  ioctl(jsdev, 0x80406a32, buf)  # JSIOCGAXMAP\n\n  for _axis in buf[:num_axes]:\n    axis_name = axis_names.get(_axis, f'unknown(0x{_axis:02x})')\n    axis_name_list.append(axis_name)\n    axis_states[axis_name] = 0.0\n\n  # Get the button map.\n  buf = array.array('H', [0] * 200)\n  ioctl(jsdev, 0x80406a34, buf)  # JSIOCGBTNMAP\n\n  for btn in buf[:num_buttons]:\n    btn_name = button_names.get(btn, f'unknown(0x{btn:03x})')\n    button_name_list.append(btn_name)\n    button_states[btn_name] = 0\n\n  print('%d axes found: %s' % (num_axes, ', '.join(axis_name_list)))\n  print('%d buttons found: %s' % (num_buttons, ', '.join(button_name_list)))\n\n  # Enable FF\n  import evdev\n  from evdev import ecodes, InputDevice\n  device = evdev.list_devices()[0]\n  evtdev = InputDevice(device)\n  val = 24000\n  evtdev.write(ecodes.EV_FF, ecodes.FF_AUTOCENTER, val)\n\n  while True:\n    evbuf = jsdev.read(8)\n    value, mtype, number = struct.unpack('4xhBB', evbuf)\n    # print(mtype, number, value)\n    if mtype & 0x02:  # wheel & paddles\n      axis = axis_name_list[number]\n\n      if axis == \"z\":  # gas\n        fvalue = value / 32767.0\n        axis_states[axis] = fvalue\n        normalized = (1 - fvalue) * 50\n        q.put(control_cmd_gen(f\"throttle_{normalized:f}\"))\n\n      elif axis == \"rz\":  # brake\n        fvalue = value / 32767.0\n        axis_states[axis] = fvalue\n        normalized = (1 - fvalue) * 50\n        q.put(control_cmd_gen(f\"brake_{normalized:f}\"))\n\n      elif axis == \"x\":  # steer angle\n        fvalue = value / 32767.0\n        axis_states[axis] = fvalue\n        normalized = fvalue\n        q.put(control_cmd_gen(f\"steer_{normalized:f}\"))\n\n    elif mtype & 0x01:  # buttons\n      if value == 1: # press down\n        if number in [0, 19]:  # X\n          q.put(control_cmd_gen(\"cruise_down\"))\n\n        elif number in [3, 18]:  # triangle\n          q.put(control_cmd_gen(\"cruise_up\"))\n\n        elif number in [1, 6]:  # square\n          q.put(control_cmd_gen(\"cruise_cancel\"))\n\n        elif number in [10, 21]:  # R3\n          q.put(control_cmd_gen(\"reverse_switch\"))\n\nif __name__ == '__main__':\n  from multiprocessing import Process, Queue\n  q: 'Queue[str]' = Queue()\n  p = Process(target=wheel_poll_thread, args=(q,))\n  p.start()\n", "tools/sim/lib/common.py": "import math\nimport multiprocessing\nimport numpy as np\n\nfrom abc import ABC, abstractmethod\nfrom collections import namedtuple\n\nW, H = 1928, 1208\n\n\nvec3 = namedtuple(\"vec3\", [\"x\", \"y\", \"z\"])\n\nclass GPSState:\n  def __init__(self):\n    self.latitude = 0\n    self.longitude = 0\n    self.altitude = 0\n\n  def from_xy(self, xy):\n    \"\"\"Simulates a lat/lon from an xy coordinate on a plane, for simple simulation. TODO: proper global projection?\"\"\"\n    BASE_LAT = 32.75308505188913\n    BASE_LON = -117.2095393365393\n    DEG_TO_METERS = 100000\n\n    self.latitude = float(BASE_LAT + xy[0] / DEG_TO_METERS)\n    self.longitude = float(BASE_LON + xy[1] / DEG_TO_METERS)\n    self.altitude = 0\n\n\nclass IMUState:\n  def __init__(self):\n    self.accelerometer: vec3 = vec3(0,0,0)\n    self.gyroscope: vec3 = vec3(0,0,0)\n    self.bearing: float = 0\n\n\nclass SimulatorState:\n  def __init__(self):\n    self.valid = False\n    self.is_engaged = False\n    self.ignition = True\n\n    self.velocity: vec3 = None\n    self.bearing: float = 0\n    self.gps = GPSState()\n    self.imu = IMUState()\n\n    self.steering_angle: float = 0\n\n    self.user_gas: float = 0\n    self.user_brake: float = 0\n    self.user_torque: float = 0\n\n    self.cruise_button = 0\n\n    self.left_blinker = False\n    self.right_blinker = False\n\n  @property\n  def speed(self):\n    return math.sqrt(self.velocity.x ** 2 + self.velocity.y ** 2 + self.velocity.z ** 2)\n\n\nclass World(ABC):\n  def __init__(self, dual_camera):\n    self.dual_camera = dual_camera\n\n    self.image_lock = multiprocessing.Semaphore(value=0)\n    self.road_image = np.zeros((H, W, 3), dtype=np.uint8)\n    self.wide_road_image = np.zeros((H, W, 3), dtype=np.uint8)\n\n    self.exit_event = multiprocessing.Event()\n\n  @abstractmethod\n  def apply_controls(self, steer_sim, throttle_out, brake_out):\n    pass\n\n  @abstractmethod\n  def tick(self):\n    pass\n\n  @abstractmethod\n  def read_state(self):\n    pass\n\n  @abstractmethod\n  def read_sensors(self, simulator_state: SimulatorState):\n    pass\n\n  @abstractmethod\n  def read_cameras(self):\n    pass\n\n  @abstractmethod\n  def close(self, reason: str):\n    pass\n\n  @abstractmethod\n  def reset(self):\n    pass\n", "tools/sim/lib/camerad.py": "import numpy as np\nimport os\nimport pyopencl as cl\nimport pyopencl.array as cl_array\n\nfrom msgq.visionipc import VisionIpcServer, VisionStreamType\nfrom cereal import messaging\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.tools.sim.lib.common import W, H\n\nclass Camerad:\n  \"\"\"Simulates the camerad daemon\"\"\"\n  def __init__(self, dual_camera):\n    self.pm = messaging.PubMaster(['roadCameraState', 'wideRoadCameraState'])\n\n    self.frame_road_id = 0\n    self.frame_wide_id = 0\n    self.vipc_server = VisionIpcServer(\"camerad\")\n\n    self.vipc_server.create_buffers(VisionStreamType.VISION_STREAM_ROAD, 5, False, W, H)\n    if dual_camera:\n      self.vipc_server.create_buffers(VisionStreamType.VISION_STREAM_WIDE_ROAD, 5, False, W, H)\n\n    self.vipc_server.start_listener()\n\n    # set up for pyopencl rgb to yuv conversion\n    self.ctx = cl.create_some_context()\n    self.queue = cl.CommandQueue(self.ctx)\n    cl_arg = f\" -DHEIGHT={H} -DWIDTH={W} -DRGB_STRIDE={W * 3} -DUV_WIDTH={W // 2} -DUV_HEIGHT={H // 2} -DRGB_SIZE={W * H} -DCL_DEBUG \"\n\n    kernel_fn = os.path.join(BASEDIR, \"tools/sim/rgb_to_nv12.cl\")\n    with open(kernel_fn) as f:\n      prg = cl.Program(self.ctx, f.read()).build(cl_arg)\n      self.krnl = prg.rgb_to_nv12\n    self.Wdiv4 = W // 4 if (W % 4 == 0) else (W + (4 - W % 4)) // 4\n    self.Hdiv4 = H // 4 if (H % 4 == 0) else (H + (4 - H % 4)) // 4\n\n  def cam_send_yuv_road(self, yuv):\n    self._send_yuv(yuv, self.frame_road_id, 'roadCameraState', VisionStreamType.VISION_STREAM_ROAD)\n    self.frame_road_id += 1\n\n  def cam_send_yuv_wide_road(self, yuv):\n    self._send_yuv(yuv, self.frame_wide_id, 'wideRoadCameraState', VisionStreamType.VISION_STREAM_WIDE_ROAD)\n    self.frame_wide_id += 1\n\n  # Returns: yuv bytes\n  def rgb_to_yuv(self, rgb):\n    assert rgb.shape == (H, W, 3), f\"{rgb.shape}\"\n    assert rgb.dtype == np.uint8\n\n    rgb_cl = cl_array.to_device(self.queue, rgb)\n    yuv_cl = cl_array.empty_like(rgb_cl)\n    self.krnl(self.queue, (self.Wdiv4, self.Hdiv4), None, rgb_cl.data, yuv_cl.data).wait()\n    yuv = np.resize(yuv_cl.get(), rgb.size // 2)\n    return yuv.data.tobytes()\n\n  def _send_yuv(self, yuv, frame_id, pub_type, yuv_type):\n    eof = int(frame_id * 0.05 * 1e9)\n    self.vipc_server.send(yuv_type, yuv, frame_id, eof, eof)\n\n    dat = messaging.new_message(pub_type, valid=True)\n    msg = {\n      \"frameId\": frame_id,\n      \"transform\": [1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0]\n    }\n    setattr(dat, pub_type, msg)\n    self.pm.send(pub_type, dat)\n", "tools/sim/lib/keyboard_ctrl.py": "import sys\nimport termios\nimport time\n\nfrom multiprocessing import Queue\nfrom termios import (BRKINT, CS8, CSIZE, ECHO, ICANON, ICRNL, IEXTEN, INPCK,\n                     ISTRIP, IXON, PARENB, VMIN, VTIME)\nfrom typing import NoReturn\n\nfrom openpilot.tools.sim.bridge.common import QueueMessage, control_cmd_gen\n\n# Indexes for termios list.\nIFLAG = 0\nOFLAG = 1\nCFLAG = 2\nLFLAG = 3\nISPEED = 4\nOSPEED = 5\nCC = 6\n\n\nKEYBOARD_HELP = \"\"\"\n  | key  |   functionality       |\n  |------|-----------------------|\n  |  1   | Cruise Resume / Accel |\n  |  2   | Cruise Set    / Decel |\n  |  3   | Cruise Cancel         |\n  |  r   | Reset Simulation      |\n  |  i   | Toggle Ignition       |\n  |  q   | Exit all              |\n  | wasd | Control manually      |\n\"\"\"\n\n\ndef getch() -> str:\n  STDIN_FD = sys.stdin.fileno()\n  old_settings = termios.tcgetattr(STDIN_FD)\n  try:\n    # set\n    mode = old_settings.copy()\n    mode[IFLAG] &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON)\n    #mode[OFLAG] &= ~(OPOST)\n    mode[CFLAG] &= ~(CSIZE | PARENB)\n    mode[CFLAG] |= CS8\n    mode[LFLAG] &= ~(ECHO | ICANON | IEXTEN)\n    mode[CC][VMIN] = 1\n    mode[CC][VTIME] = 0\n    termios.tcsetattr(STDIN_FD, termios.TCSAFLUSH, mode)\n\n    ch = sys.stdin.read(1)\n  finally:\n    termios.tcsetattr(STDIN_FD, termios.TCSADRAIN, old_settings)\n  return ch\n\ndef print_keyboard_help():\n  print(f\"Keyboard Commands:\\n{KEYBOARD_HELP}\")\n\ndef keyboard_poll_thread(q: 'Queue[QueueMessage]'):\n  print_keyboard_help()\n\n  while True:\n    c = getch()\n    if c == '1':\n      q.put(control_cmd_gen(\"cruise_up\"))\n    elif c == '2':\n      q.put(control_cmd_gen(\"cruise_down\"))\n    elif c == '3':\n      q.put(control_cmd_gen(\"cruise_cancel\"))\n    elif c == 'w':\n      q.put(control_cmd_gen(f\"throttle_{1.0}\"))\n    elif c == 'a':\n      q.put(control_cmd_gen(f\"steer_{-0.15}\"))\n    elif c == 's':\n      q.put(control_cmd_gen(f\"brake_{1.0}\"))\n    elif c == 'd':\n      q.put(control_cmd_gen(f\"steer_{0.15}\"))\n    elif c == 'z':\n      q.put(control_cmd_gen(\"blinker_left\"))\n    elif c == 'x':\n      q.put(control_cmd_gen(\"blinker_right\"))\n    elif c == 'i':\n      q.put(control_cmd_gen(\"ignition\"))\n    elif c == 'r':\n      q.put(control_cmd_gen(\"reset\"))\n    elif c == 'q':\n      q.put(control_cmd_gen(\"quit\"))\n      break\n    else:\n      print_keyboard_help()\n\ndef test(q: 'Queue[str]') -> NoReturn:\n  while True:\n    print([q.get_nowait() for _ in range(q.qsize())] or None)\n    time.sleep(0.25)\n\nif __name__ == '__main__':\n  from multiprocessing import Process, Queue\n  q: 'Queue[QueueMessage]' = Queue()\n  p = Process(target=test, args=(q,))\n  p.daemon = True\n  p.start()\n\n  keyboard_poll_thread(q)\n", "tools/sim/lib/simulated_car.py": "import cereal.messaging as messaging\n\nfrom opendbc.can.packer import CANPacker\nfrom opendbc.can.parser import CANParser\nfrom openpilot.common.params import Params\nfrom openpilot.selfdrive.pandad.pandad_api_impl import can_list_to_can_capnp\nfrom openpilot.tools.sim.lib.common import SimulatorState\nfrom panda.python import Panda\n\n\nclass SimulatedCar:\n  \"\"\"Simulates a honda civic 2022 (panda state + can messages) to OpenPilot\"\"\"\n  packer = CANPacker(\"honda_civic_ex_2022_can_generated\")\n\n  def __init__(self):\n    self.pm = messaging.PubMaster(['can', 'pandaStates'])\n    self.sm = messaging.SubMaster(['carControl', 'controlsState', 'carParams'])\n    self.cp = self.get_car_can_parser()\n    self.idx = 0\n    self.params = Params()\n    self.obd_multiplexing = False\n\n  @staticmethod\n  def get_car_can_parser():\n    dbc_f = 'honda_civic_ex_2022_can_generated'\n    checks = [\n    ]\n    return CANParser(dbc_f, checks, 0)\n\n  def send_can_messages(self, simulator_state: SimulatorState):\n    if not simulator_state.valid:\n      return\n\n    msg = []\n\n    # *** powertrain bus ***\n\n    speed = simulator_state.speed * 3.6 # convert m/s to kph\n    msg.append(self.packer.make_can_msg(\"ENGINE_DATA\", 0, {\"XMISSION_SPEED\": speed}))\n    msg.append(self.packer.make_can_msg(\"WHEEL_SPEEDS\", 0, {\n      \"WHEEL_SPEED_FL\": speed,\n      \"WHEEL_SPEED_FR\": speed,\n      \"WHEEL_SPEED_RL\": speed,\n      \"WHEEL_SPEED_RR\": speed\n    }))\n\n    msg.append(self.packer.make_can_msg(\"SCM_BUTTONS\", 0, {\"CRUISE_BUTTONS\": simulator_state.cruise_button}))\n\n    msg.append(self.packer.make_can_msg(\"GEARBOX\", 0, {\"GEAR\": 4, \"GEAR_SHIFTER\": 8}))\n    msg.append(self.packer.make_can_msg(\"GAS_PEDAL_2\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"SEATBELT_STATUS\", 0, {\"SEATBELT_DRIVER_LATCHED\": 1}))\n    msg.append(self.packer.make_can_msg(\"STEER_STATUS\", 0, {\"STEER_TORQUE_SENSOR\": simulator_state.user_torque}))\n    msg.append(self.packer.make_can_msg(\"STEERING_SENSORS\", 0, {\"STEER_ANGLE\": simulator_state.steering_angle}))\n    msg.append(self.packer.make_can_msg(\"VSA_STATUS\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"STANDSTILL\", 0, {\"WHEELS_MOVING\": 1 if simulator_state.speed >= 1.0 else 0}))\n    msg.append(self.packer.make_can_msg(\"STEER_MOTOR_TORQUE\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"EPB_STATUS\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"DOORS_STATUS\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"CRUISE_PARAMS\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"CRUISE\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"CRUISE_FAULT_STATUS\", 0, {}))\n    msg.append(self.packer.make_can_msg(\"SCM_FEEDBACK\", 0,\n                                    {\n                                      \"MAIN_ON\": 1,\n                                      \"LEFT_BLINKER\": simulator_state.left_blinker,\n                                      \"RIGHT_BLINKER\": simulator_state.right_blinker\n                                    }))\n    msg.append(self.packer.make_can_msg(\"POWERTRAIN_DATA\", 0,\n                                    {\n                                    \"ACC_STATUS\": int(simulator_state.is_engaged),\n                                    \"PEDAL_GAS\": simulator_state.user_gas,\n                                    \"BRAKE_PRESSED\": simulator_state.user_brake > 0\n                                    }))\n    msg.append(self.packer.make_can_msg(\"CAR_SPEED\", 0, {}))\n\n    # *** cam bus ***\n    msg.append(self.packer.make_can_msg(\"STEERING_CONTROL\", 2, {}))\n    msg.append(self.packer.make_can_msg(\"ACC_HUD\", 2, {}))\n    msg.append(self.packer.make_can_msg(\"LKAS_HUD\", 2, {}))\n\n    self.pm.send('can', can_list_to_can_capnp(msg))\n\n  def send_panda_state(self, simulator_state):\n    self.sm.update(0)\n\n    if self.params.get_bool(\"ObdMultiplexingEnabled\") != self.obd_multiplexing:\n      self.obd_multiplexing = not self.obd_multiplexing\n      self.params.put_bool(\"ObdMultiplexingChanged\", True)\n\n    dat = messaging.new_message('pandaStates', 1)\n    dat.valid = True\n    dat.pandaStates[0] = {\n      'ignitionLine': simulator_state.ignition,\n      'pandaType': \"blackPanda\",\n      'controlsAllowed': True,\n      'safetyModel': 'hondaBosch',\n      'alternativeExperience': self.sm[\"carParams\"].alternativeExperience,\n      'safetyParam': Panda.FLAG_HONDA_RADARLESS | Panda.FLAG_HONDA_BOSCH_LONG,\n    }\n    self.pm.send('pandaStates', dat)\n\n  def update(self, simulator_state: SimulatorState):\n    self.send_can_messages(simulator_state)\n\n    if self.idx % 50 == 0: # only send panda states at 2hz\n      self.send_panda_state(simulator_state)\n\n    self.idx += 1\n", "tools/sim/lib/__init__.py": "", "tools/sim/lib/simulated_sensors.py": "import time\n\nfrom cereal import log\nimport cereal.messaging as messaging\n\nfrom openpilot.common.realtime import DT_DMON\nfrom openpilot.tools.sim.lib.camerad import Camerad\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n  from openpilot.tools.sim.lib.common import World, SimulatorState\n\n\nclass SimulatedSensors:\n  \"\"\"Simulates the C3 sensors (acc, gyro, gps, peripherals, dm state, cameras) to OpenPilot\"\"\"\n\n  def __init__(self, dual_camera=False):\n    self.pm = messaging.PubMaster(['accelerometer', 'gyroscope', 'gpsLocationExternal', 'driverStateV2', 'driverMonitoringState', 'peripheralState'])\n    self.camerad = Camerad(dual_camera=dual_camera)\n    self.last_perp_update = 0\n    self.last_dmon_update = 0\n\n  def send_imu_message(self, simulator_state: 'SimulatorState'):\n    for _ in range(5):\n      dat = messaging.new_message('accelerometer', valid=True)\n      dat.accelerometer.sensor = 4\n      dat.accelerometer.type = 0x10\n      dat.accelerometer.timestamp = dat.logMonoTime  # TODO: use the IMU timestamp\n      dat.accelerometer.init('acceleration')\n      dat.accelerometer.acceleration.v = [simulator_state.imu.accelerometer.x, simulator_state.imu.accelerometer.y, simulator_state.imu.accelerometer.z]\n      self.pm.send('accelerometer', dat)\n\n      # copied these numbers from locationd\n      dat = messaging.new_message('gyroscope', valid=True)\n      dat.gyroscope.sensor = 5\n      dat.gyroscope.type = 0x10\n      dat.gyroscope.timestamp = dat.logMonoTime  # TODO: use the IMU timestamp\n      dat.gyroscope.init('gyroUncalibrated')\n      dat.gyroscope.gyroUncalibrated.v = [simulator_state.imu.gyroscope.x, simulator_state.imu.gyroscope.y, simulator_state.imu.gyroscope.z]\n      self.pm.send('gyroscope', dat)\n\n  def send_gps_message(self, simulator_state: 'SimulatorState'):\n    if not simulator_state.valid:\n      return\n\n    # transform from vel to NED\n    velNED = [\n      -simulator_state.velocity.y,\n      simulator_state.velocity.x,\n      simulator_state.velocity.z,\n    ]\n\n    for _ in range(10):\n      dat = messaging.new_message('gpsLocationExternal', valid=True)\n      dat.gpsLocationExternal = {\n        \"unixTimestampMillis\": int(time.time() * 1000),\n        \"flags\": 1,  # valid fix\n        \"horizontalAccuracy\": 1.0,\n        \"verticalAccuracy\": 1.0,\n        \"speedAccuracy\": 0.1,\n        \"bearingAccuracyDeg\": 0.1,\n        \"vNED\": velNED,\n        \"bearingDeg\": simulator_state.imu.bearing,\n        \"latitude\": simulator_state.gps.latitude,\n        \"longitude\": simulator_state.gps.longitude,\n        \"altitude\": simulator_state.gps.altitude,\n        \"speed\": simulator_state.speed,\n        \"source\": log.GpsLocationData.SensorSource.ublox,\n      }\n\n      self.pm.send('gpsLocationExternal', dat)\n\n  def send_peripheral_state(self):\n    dat = messaging.new_message('peripheralState')\n    dat.valid = True\n    dat.peripheralState = {\n      'pandaType': log.PandaState.PandaType.blackPanda,\n      'voltage': 12000,\n      'current': 5678,\n      'fanSpeedRpm': 1000\n    }\n    self.pm.send('peripheralState', dat)\n\n  def send_fake_driver_monitoring(self):\n    # dmonitoringmodeld output\n    dat = messaging.new_message('driverStateV2')\n    dat.driverStateV2.leftDriverData.faceOrientation = [0., 0., 0.]\n    dat.driverStateV2.leftDriverData.faceProb = 1.0\n    dat.driverStateV2.rightDriverData.faceOrientation = [0., 0., 0.]\n    dat.driverStateV2.rightDriverData.faceProb = 1.0\n    self.pm.send('driverStateV2', dat)\n\n    # dmonitoringd output\n    dat = messaging.new_message('driverMonitoringState', valid=True)\n    dat.driverMonitoringState = {\n      \"faceDetected\": True,\n      \"isDistracted\": False,\n      \"awarenessStatus\": 1.,\n    }\n    self.pm.send('driverMonitoringState', dat)\n\n  def send_camera_images(self, world: 'World'):\n    world.image_lock.acquire()\n    yuv = self.camerad.rgb_to_yuv(world.road_image)\n    self.camerad.cam_send_yuv_road(yuv)\n\n    if world.dual_camera:\n      yuv = self.camerad.rgb_to_yuv(world.wide_road_image)\n      self.camerad.cam_send_yuv_wide_road(yuv)\n\n  def update(self, simulator_state: 'SimulatorState', world: 'World'):\n    now = time.time()\n    self.send_imu_message(simulator_state)\n    self.send_gps_message(simulator_state)\n\n    if (now - self.last_dmon_update) > DT_DMON/2:\n      self.send_fake_driver_monitoring()\n      self.last_dmon_update = now\n\n    if (now - self.last_perp_update) > 0.25:\n      self.send_peripheral_state()\n      self.last_perp_update = now\n", "tools/joystick/joystickd.py": "#!/usr/bin/env python\nimport os\nimport argparse\nimport threading\nfrom inputs import get_gamepad\n\nimport cereal.messaging as messaging\nfrom openpilot.common.realtime import Ratekeeper\nfrom openpilot.common.numpy_fast import interp, clip\nfrom openpilot.common.params import Params\nfrom openpilot.tools.lib.kbhit import KBHit\n\n\nclass Keyboard:\n  def __init__(self):\n    self.kb = KBHit()\n    self.axis_increment = 0.05  # 5% of full actuation each key press\n    self.axes_map = {'w': 'gb', 's': 'gb',\n                     'a': 'steer', 'd': 'steer'}\n    self.axes_values = {'gb': 0., 'steer': 0.}\n    self.axes_order = ['gb', 'steer']\n    self.cancel = False\n\n  def update(self):\n    key = self.kb.getch().lower()\n    self.cancel = False\n    if key == 'r':\n      self.axes_values = {ax: 0. for ax in self.axes_values}\n    elif key == 'c':\n      self.cancel = True\n    elif key in self.axes_map:\n      axis = self.axes_map[key]\n      incr = self.axis_increment if key in ['w', 'a'] else -self.axis_increment\n      self.axes_values[axis] = clip(self.axes_values[axis] + incr, -1, 1)\n    else:\n      return False\n    return True\n\n\nclass Joystick:\n  def __init__(self, gamepad=False):\n    # TODO: find a way to get this from API, perhaps \"inputs\" doesn't support it\n    if gamepad:\n      self.cancel_button = 'BTN_NORTH'  # (BTN_NORTH=X, ABS_RZ=Right Trigger)\n      accel_axis = 'ABS_Y'\n      steer_axis = 'ABS_RX'\n    else:\n      self.cancel_button = 'BTN_TRIGGER'\n      accel_axis = 'ABS_Y'\n      steer_axis = 'ABS_RX'\n    self.min_axis_value = {accel_axis: 0., steer_axis: 0.}\n    self.max_axis_value = {accel_axis: 255., steer_axis: 255.}\n    self.axes_values = {accel_axis: 0., steer_axis: 0.}\n    self.axes_order = [accel_axis, steer_axis]\n    self.cancel = False\n\n  def update(self):\n    joystick_event = get_gamepad()[0]\n    event = (joystick_event.code, joystick_event.state)\n    if event[0] == self.cancel_button:\n      if event[1] == 1:\n        self.cancel = True\n      elif event[1] == 0:   # state 0 is falling edge\n        self.cancel = False\n    elif event[0] in self.axes_values:\n      self.max_axis_value[event[0]] = max(event[1], self.max_axis_value[event[0]])\n      self.min_axis_value[event[0]] = min(event[1], self.min_axis_value[event[0]])\n\n      norm = -interp(event[1], [self.min_axis_value[event[0]], self.max_axis_value[event[0]]], [-1., 1.])\n      self.axes_values[event[0]] = norm if abs(norm) > 0.05 else 0.  # center can be noisy, deadzone of 5%\n    else:\n      return False\n    return True\n\n\ndef send_thread(joystick):\n  joystick_sock = messaging.pub_sock('testJoystick')\n  rk = Ratekeeper(100, print_delay_threshold=None)\n  while 1:\n    dat = messaging.new_message('testJoystick')\n    dat.testJoystick.axes = [joystick.axes_values[a] for a in joystick.axes_order]\n    dat.testJoystick.buttons = [joystick.cancel]\n    joystick_sock.send(dat.to_bytes())\n    print('\\n' + ', '.join(f'{name}: {round(v, 3)}' for name, v in joystick.axes_values.items()))\n    rk.keep_time()\n\ndef joystick_thread(joystick):\n  Params().put_bool('JoystickDebugMode', True)\n  threading.Thread(target=send_thread, args=(joystick,), daemon=True).start()\n  while True:\n    joystick.update()\n\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser(description='Publishes events from your joystick to control your car.\\n' +\n                                               'openpilot must be offroad before starting joysticked.',\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument('--keyboard', action='store_true', help='Use your keyboard instead of a joystick')\n  parser.add_argument('--gamepad', action='store_true', help='Use gamepad configuration instead of joystick')\n  args = parser.parse_args()\n\n  if not Params().get_bool(\"IsOffroad\") and \"ZMQ\" not in os.environ:\n    print(\"The car must be off before running joystickd.\")\n    exit()\n\n  print()\n  if args.keyboard:\n    print('Gas/brake control: `W` and `S` keys')\n    print('Steering control: `A` and `D` keys')\n    print('Buttons')\n    print('- `R`: Resets axes')\n    print('- `C`: Cancel cruise control')\n  else:\n    print('Using joystick, make sure to run cereal/messaging/bridge on your device if running over the network!')\n\n  joystick = Keyboard() if args.keyboard else Joystick(args.gamepad)\n  joystick_thread(joystick)\n", "tools/cabana/dbc/generate_dbc_json.py": "#!/usr/bin/env python3\nimport argparse\nimport json\n\nfrom openpilot.selfdrive.car.fingerprints import MIGRATION\nfrom openpilot.selfdrive.car.values import PLATFORMS\n\n\ndef generate_dbc_json() -> str:\n  dbc_map = {platform.name: platform.config.dbc_dict['pt'] for platform in PLATFORMS.values() if platform != \"MOCK\"}\n\n  for m in MIGRATION:\n    if MIGRATION[m] in dbc_map:\n      dbc_map[m] = dbc_map[MIGRATION[m]]\n\n  return json.dumps(dict(sorted(dbc_map.items())), indent=2)\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Generate mapping for all car fingerprints to DBC names and outputs json file\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"--out\", required=True, help=\"Generated json filepath\")\n  args = parser.parse_args()\n\n  with open(args.out, 'w') as f:\n    f.write(generate_dbc_json())\n  print(f\"Generated and written to {args.out}\")\n", "tools/scripts/fetch_image_from_route.py": "#!/usr/bin/env python3\nimport sys\n\nif len(sys.argv) < 4:\n  print(f\"{sys.argv[0]} <route> <segment> <frame number> [front|wide|driver]\")\n  print('example: ./fetch_image_from_route.py \"02c45f73a2e5c6e9|2020-06-01--18-03-08\" 3 500 driver')\n  exit(0)\n\ncameras = {\n  \"front\": \"cameras\",\n  \"wide\": \"ecameras\",\n  \"driver\": \"dcameras\"\n}\n\nimport requests\nfrom PIL import Image\nfrom openpilot.tools.lib.auth_config import get_token\nfrom openpilot.tools.lib.framereader import FrameReader\n\njwt = get_token()\n\nroute = sys.argv[1]\nsegment = int(sys.argv[2])\nframe = int(sys.argv[3])\ncamera = cameras[sys.argv[4]] if len(sys.argv) > 4 and sys.argv[4] in cameras else \"cameras\"\n\nurl = f'https://api.commadotai.com/v1/route/{route}/files'\nr = requests.get(url, headers={\"Authorization\": f\"JWT {jwt}\"}, timeout=10)\nassert r.status_code == 200\nprint(\"got api response\")\n\nsegments = r.json()[camera]\nif segment >= len(segments):\n  raise Exception(\"segment %d not found, got %d segments\" % (segment, len(segments)))\n\nfr = FrameReader(segments[segment])\nif frame >= fr.frame_count:\n  raise Exception(\"frame %d not found, got %d frames\" % (frame, fr.frame_count))\n\nim = Image.fromarray(fr.get(frame, count=1, pix_fmt=\"rgb24\")[0])\nfn = f\"uxxx_{route.replace('|', '_')}_{segment}_{frame}.png\"\nim.save(fn)\nprint(f\"saved {fn}\")\n", "tools/scripts/save_ubloxraw_stream.py": "#!/usr/bin/env python\nimport argparse\nimport os\nimport sys\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.tools.lib.logreader import LogReader\n\nos.environ['BASEDIR'] = BASEDIR\n\n\ndef get_arg_parser():\n  parser = argparse.ArgumentParser(\n      description=\"Unlogging and save to file\",\n      formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"route\", type=(lambda x: x.replace(\"#\", \"|\")), nargs=\"?\",\n                      help=\"The route whose messages will be published.\")\n  parser.add_argument(\"--out_path\", nargs='?', default='/data/ubloxRaw.stream',\n                      help=\"Output pickle file path\")\n  return parser\n\n\ndef main():\n  args = get_arg_parser().parse_args(sys.argv[1:])\n\n  lr = LogReader(args.route)\n\n  with open(args.out_path, 'wb') as f:\n    try:\n      done = False\n      i = 0\n      while not done:\n        msg = next(lr)\n        if not msg:\n          break\n        smsg = msg.as_builder()\n        typ = smsg.which()\n        if typ == 'ubloxRaw':\n          f.write(smsg.to_bytes())\n          i += 1\n    except StopIteration:\n      print('All done')\n  print(f'Writed {i} msgs')\n\n\nif __name__ == \"__main__\":\n  main()\n", "tools/scripts/setup_ssh_keys.py": "#!/usr/bin/env python3\n\nimport requests\nfrom openpilot.common.params import Params\nimport sys\n\n\nif __name__ == \"__main__\":\n  if len(sys.argv) < 2:\n    print(f\"{sys.argv[0]} <github username>\")\n    exit(1)\n\n  username = sys.argv[1]\n  keys = requests.get(f\"https://github.com/{username}.keys\", timeout=10)\n\n  if keys.status_code == 200:\n    params = Params()\n    params.put_bool(\"SshEnabled\", True)\n    params.put(\"GithubSshKeys\", keys.text)\n    params.put(\"GithubUsername\", username)\n    print(\"Setup ssh keys successfully\")\n  else:\n    print(\"Error getting public keys from github\")\n", "tools/rerun/run.py": "#!/usr/bin/env python3\nimport sys\nimport argparse\nimport multiprocessing\nimport rerun as rr\nimport rerun.blueprint as rrb\nfrom functools import partial\n\nfrom openpilot.tools.lib.logreader import LogReader\nfrom cereal.services import SERVICE_LIST\n\n\nNUM_CPUS = multiprocessing.cpu_count()\nDEMO_ROUTE = \"a2a0ccea32023010|2023-07-27--13-01-19\"\n\ndef log_msg(msg, parent_key=''):\n  stack = [(msg, parent_key)]\n  while stack:\n    current_msg, current_parent_key = stack.pop()\n    if isinstance(current_msg, list):\n      for index, item in enumerate(current_msg):\n        new_key = f\"{current_parent_key}/{index}\"\n        if isinstance(item, (int, float)):\n          rr.log(str(new_key), rr.Scalar(item))\n        elif isinstance(item, dict):\n          stack.append((item, new_key))\n    elif isinstance(current_msg, dict):\n      for key, value in current_msg.items():\n        new_key = f\"{current_parent_key}/{key}\"\n        if isinstance(value, (int, float)):\n          rr.log(str(new_key), rr.Scalar(value))\n        elif isinstance(value, dict):\n          stack.append((value, new_key))\n        elif isinstance(value, list):\n          for index, item in enumerate(value):\n            if isinstance(item, (int, float)):\n              rr.log(f\"{new_key}/{index}\", rr.Scalar(item))\n    else:\n      pass  # Not a plottable value\n\ndef createBlueprint():\n  blueprint = None\n  timeSeriesViews = []\n  for topic in sorted(SERVICE_LIST.keys()):\n    timeSeriesViews.append(rrb.TimeSeriesView(name=topic, origin=f\"/{topic}/\", visible=False))\n    rr.log(topic, rr.SeriesLine(name=topic), timeless=True)\n    blueprint = rrb.Blueprint(rrb.Grid(rrb.Vertical(*timeSeriesViews,rrb.SelectionPanel(expanded=False),rrb.TimePanel(expanded=False)),\n                                        rrb.Spatial2DView(name=\"thumbnail\", origin=\"/thumbnail\")))\n  return blueprint\n\ndef log_thumbnail(thumbnailMsg):\n  bytesImgData = thumbnailMsg.get('thumbnail')\n  rr.log(\"/thumbnail\", rr.ImageEncoded(contents=bytesImgData))\n\n@rr.shutdown_at_exit\ndef process(blueprint, lr):\n  rr.init(\"rerun_test\")\n  rr.connect(default_blueprint=blueprint)\n\n  ret = []\n  for msg in lr:\n    ret.append(msg)\n    rr.set_time_nanos(\"TIMELINE\", msg.logMonoTime)\n    if msg.which() != \"thumbnail\":\n      log_msg(msg.to_dict()[msg.which()], msg.which())\n    else:\n      log_thumbnail(msg.to_dict()[msg.which()])\n  return ret\n\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser(description=\"A helper to run rerun on openpilot routes\",\n                                  formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"--demo\", action=\"store_true\", help=\"Use the demo route instead of providing one\")\n  parser.add_argument(\"route_or_segment_name\", nargs='?', help=\"The route or segment name to plot\")\n\n  if len(sys.argv) == 1:\n    parser.print_help()\n    sys.exit()\n\n  args = parser.parse_args()\n\n  blueprint = createBlueprint()\n  rr.init(\"rerun_test\")\n  rr.spawn(connect=False) # child processes stream data to Viewer\n\n  route_or_segment_name = DEMO_ROUTE if args.demo else args.route_or_segment_name.strip()\n  print(\"Getting route log paths\")\n  lr = LogReader(route_or_segment_name)\n  lr.run_across_segments(NUM_CPUS, partial(process, blueprint))\n", "tools/tuning/measure_steering_accuracy.py": "#!/usr/bin/env python3\n# type: ignore\n\nimport os\nimport time\nimport argparse\nimport signal\nfrom collections import defaultdict\n\nimport cereal.messaging as messaging\nfrom openpilot.tools.lib.logreader import LogReader\n\ndef sigint_handler(signal, frame):\n  exit(0)\nsignal.signal(signal.SIGINT, sigint_handler)\n\nclass SteeringAccuracyTool:\n  all_groups = {\"germany\":  (45, \"45 - up m/s  //  162 - up km/h  //  101 - up mph\"),\n                \"veryfast\": (35, \"35 - 45 m/s  //  126 - 162 km/h  //  78 - 101 mph\"),\n                \"fast\":     (25, \"25 - 35 m/s  //  90 - 126 km/h  //  56 - 78 mph\"),\n                \"medium\":   (15, \"15 - 25 m/s  //  54 - 90 km/h  //  34 - 56 mph\"),\n                \"slow\":     (5,  \" 5 - 15 m/s  //  18 - 54 km/h  //  11 - 34 mph\"),\n                \"crawl\":    (0,  \" 0 - 5 m/s  //  0 - 18 km/h  //  0 - 11 mph\")}\n\n  def __init__(self, args):\n    self.msg_cnt = 0\n    self.cnt = 0\n    self.total_error = 0\n\n    if args.group == \"all\":\n      self.display_groups = self.all_groups.keys()\n    elif args.group in self.all_groups.keys():\n      self.display_groups = [args.group]\n    else:\n      raise ValueError(\"invalid speed group, see help\")\n\n    self.speed_group_stats = {}\n    for group in self.all_groups:\n      self.speed_group_stats[group] = defaultdict(lambda: {'err': 0, \"cnt\": 0, \"=\": 0, \"+\": 0, \"-\": 0, \"steer\": 0, \"limited\": 0, \"saturated\": 0, \"dpp\": 0})\n\n  def update(self, sm):\n    self.msg_cnt += 1\n\n    lateralControlState = sm['controlsState'].lateralControlState\n    control_type = list(lateralControlState.to_dict().keys())[0]\n    control_state = lateralControlState.__getattr__(control_type)\n\n    v_ego = sm['carState'].vEgo\n    active = sm['controlsState'].active\n    steer = sm['carOutput'].actuatorsOutput.steer\n    standstill = sm['carState'].standstill\n    steer_limited = abs(sm['carControl'].actuators.steer - sm['carControl'].actuatorsOutput.steer) > 1e-2\n    overriding = sm['carState'].steeringPressed\n    changing_lanes = sm['modelV2'].meta.laneChangeState != 0\n    model_points = sm['modelV2'].position.y\n    # must be engaged, not at standstill, not overriding steering, and not changing lanes\n    if active and not standstill and not overriding and not changing_lanes:\n      self.cnt += 1\n\n      # wait 5 seconds after engage / standstill / override / lane change\n      if self.cnt >= 500:\n        actual_angle = control_state.steeringAngleDeg\n        desired_angle = control_state.steeringAngleDesiredDeg\n\n        # calculate error before rounding, then round for stats grouping\n        angle_error = abs(desired_angle - actual_angle)\n        actual_angle = round(actual_angle, 1)\n        desired_angle = round(desired_angle, 1)\n        angle_error = round(angle_error, 2)\n        angle_abs = int(abs(round(desired_angle, 0)))\n\n        for group, group_props in self.all_groups.items():\n          if v_ego > group_props[0]:\n            # collect stats\n            self.speed_group_stats[group][angle_abs][\"cnt\"] += 1\n            self.speed_group_stats[group][angle_abs][\"err\"] += angle_error\n            self.speed_group_stats[group][angle_abs][\"steer\"] += abs(steer)\n            if len(model_points):\n              self.speed_group_stats[group][angle_abs][\"dpp\"] += abs(model_points[0])\n            if steer_limited:\n              self.speed_group_stats[group][angle_abs][\"limited\"] += 1\n            if control_state.saturated:\n              self.speed_group_stats[group][angle_abs][\"saturated\"] += 1\n            if actual_angle == desired_angle:\n              self.speed_group_stats[group][angle_abs][\"=\"] += 1\n            else:\n              if desired_angle == 0.:\n                overshoot = True\n              else:\n                overshoot = desired_angle < actual_angle if desired_angle > 0. else desired_angle > actual_angle\n              self.speed_group_stats[group][angle_abs][\"+\" if overshoot else \"-\"] += 1\n            break\n    else:\n      self.cnt = 0\n\n    if self.msg_cnt % 100 == 0:\n      print(chr(27) + \"[2J\")\n      if self.cnt != 0:\n        print(\"COLLECTING ...\\n\")\n      else:\n        print(\"DISABLED (not active, standstill, steering override, or lane change)\\n\")\n      for group in self.display_groups:\n        if len(self.speed_group_stats[group]) > 0:\n          print(f\"speed group: {group:10s} {self.all_groups[group][1]:>96s}\")\n          print(f\"  {'-'*118}\")\n          for k in sorted(self.speed_group_stats[group].keys()):\n            v = self.speed_group_stats[group][k]\n            print(f'  {k:#2}\u00b0 | actuator:{int(v[\"steer\"] / v[\"cnt\"] * 100):#3}% ' +\n                  f'| error: {round(v[\"err\"] / v[\"cnt\"], 2):2.2f}\u00b0 | -:{int(v[\"-\"] / v[\"cnt\"] * 100):#3}% ' +\n                  f'| =:{int(v[\"=\"] / v[\"cnt\"] * 100):#3}% | +:{int(v[\"+\"] / v[\"cnt\"] * 100):#3}% | lim:{v[\"limited\"]:#5} ' +\n                  f'| sat:{v[\"saturated\"]:#5} | path dev: {round(v[\"dpp\"] / v[\"cnt\"], 2):2.2f}m | total: {v[\"cnt\"]:#5}')\n          print(\"\")\n\n\nif __name__ == \"__main__\":\n\n  parser = argparse.ArgumentParser(description='Steering accuracy measurement tool')\n  parser.add_argument('--route', help=\"route name\")\n  parser.add_argument('--addr', default='127.0.0.1', help=\"IP address for optional ZMQ listener, default to msgq\")\n  parser.add_argument('--group', default='all', help=\"speed group to display, [crawl|slow|medium|fast|veryfast|germany|all], default to all\")\n  parser.add_argument('--cache', default=False, action='store_true', help=\"use cached data, default to False\")\n  args = parser.parse_args()\n\n  if args.cache:\n    os.environ['FILEREADER_CACHE'] = '1'\n\n  tool = SteeringAccuracyTool(args)\n\n  if args.route is not None:\n    print(f\"loading {args.route}...\")\n    lr = LogReader(args.route, sort_by_time=True)\n\n    sm = {}\n    for msg in lr:\n      if msg.which() == 'carState':\n        sm['carState'] = msg.carState\n      elif msg.which() == 'carControl':\n        sm['carControl'] = msg.carControl\n      elif msg.which() == 'controlsState':\n        sm['controlsState'] = msg.controlsState\n      elif msg.which() == 'modelV2':\n        sm['modelV2'] = msg.modelV2\n\n      if msg.which() == 'carControl' and 'carState' in sm and 'controlsState' in sm and 'modelV2' in sm:\n        tool.update(sm)\n\n  else:\n    if args.addr != \"127.0.0.1\":\n      os.environ[\"ZMQ\"] = \"1\"\n      messaging.context = messaging.Context()\n\n    carControl = messaging.sub_sock('carControl', addr=args.addr, conflate=True)\n    sm = messaging.SubMaster(['carState', 'carControl', 'carOutput', 'controlsState', 'modelV2'], addr=args.addr)\n    time.sleep(1)  # Make sure all submaster data is available before going further\n\n    print(\"waiting for messages...\")\n    while messaging.recv_one(carControl):\n      sm.update()\n      tool.update(sm)\n", "tools/webcam/camera.py": "import cv2 as cv\nimport numpy as np\n\nclass Camera:\n  def __init__(self, cam_type_state, stream_type, camera_id):\n    try:\n      camera_id = int(camera_id)\n    except ValueError: # allow strings, ex: /dev/video0\n      pass\n    self.cam_type_state = cam_type_state\n    self.stream_type = stream_type\n    self.cur_frame_id = 0\n\n    self.cap = cv.VideoCapture(camera_id)\n    self.W = self.cap.get(cv.CAP_PROP_FRAME_WIDTH)\n    self.H = self.cap.get(cv.CAP_PROP_FRAME_HEIGHT)\n\n  @classmethod\n  def bgr2nv12(self, bgr):\n    yuv = cv.cvtColor(bgr, cv.COLOR_BGR2YUV_I420)\n    uv_row_cnt = yuv.shape[0] // 3\n    uv_plane = np.transpose(yuv[uv_row_cnt * 2:].reshape(2, -1), [1, 0])\n    yuv[uv_row_cnt * 2:] = uv_plane.reshape(uv_row_cnt, -1)\n    return yuv\n\n  def read_frames(self):\n    while True:\n      sts , frame = self.cap.read()\n      if not sts:\n        break\n      yuv = Camera.bgr2nv12(frame)\n      yield yuv.data.tobytes()\n    self.cap.release()\n", "tools/webcam/camerad.py": "#!/usr/bin/env python3\nimport threading\nimport os\nfrom collections import namedtuple\n\nfrom msgq.visionipc import VisionIpcServer, VisionStreamType\nfrom cereal import messaging\n\nfrom openpilot.tools.webcam.camera import Camera\nfrom openpilot.common.realtime import Ratekeeper\n\nDUAL_CAM = os.getenv(\"DUAL_CAMERA\")\nCameraType = namedtuple(\"CameraType\", [\"msg_name\", \"stream_type\", \"cam_id\"])\nCAMERAS = [\n  CameraType(\"roadCameraState\", VisionStreamType.VISION_STREAM_ROAD, os.getenv(\"CAMERA_ROAD_ID\", \"0\")),\n  CameraType(\"driverCameraState\", VisionStreamType.VISION_STREAM_DRIVER, os.getenv(\"CAMERA_DRIVER_ID\", \"1\")),\n]\nif DUAL_CAM:\n  CAMERAS.append(CameraType(\"wideRoadCameraState\", VisionStreamType.VISION_STREAM_WIDE_ROAD, DUAL_CAM))\n\nclass Camerad:\n  def __init__(self):\n    self.pm = messaging.PubMaster([c.msg_name for c in CAMERAS])\n    self.vipc_server = VisionIpcServer(\"camerad\")\n\n    self.cameras = []\n    for c in CAMERAS:\n      cam = Camera(c.msg_name, c.stream_type, c.cam_id)\n      assert cam.cap.isOpened(), f\"Can't find camera {c}\"\n      self.cameras.append(cam)\n      self.vipc_server.create_buffers(c.stream_type, 20, False, cam.W, cam.H)\n\n    self.vipc_server.start_listener()\n\n  def _send_yuv(self, yuv, frame_id, pub_type, yuv_type):\n    eof = int(frame_id * 0.05 * 1e9)\n    self.vipc_server.send(yuv_type, yuv, frame_id, eof, eof)\n    dat = messaging.new_message(pub_type, valid=True)\n    msg = {\n      \"frameId\": frame_id,\n      \"transform\": [1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0]\n    }\n    setattr(dat, pub_type, msg)\n    self.pm.send(pub_type, dat)\n\n  def camera_runner(self, cam):\n    rk = Ratekeeper(20, None)\n    while cam.cap.isOpened():\n      for yuv in cam.read_frames():\n        self._send_yuv(yuv, cam.cur_frame_id, cam.cam_type_state, cam.stream_type)\n        cam.cur_frame_id += 1\n        rk.keep_time()\n\n  def run(self):\n    threads = []\n    for cam in self.cameras:\n      cam_thread = threading.Thread(target=self.camera_runner, args=(cam,))\n      cam_thread.start()\n      threads.append(cam_thread)\n\n    for t in threads:\n      t.join()\n\n\ndef main():\n  camerad = Camerad()\n  camerad.run()\n\n\nif __name__ == \"__main__\":\n  main()\n", "tools/lib/auth.py": "#!/usr/bin/env python3\n\"\"\"\nUsage::\n\n  usage: auth.py [-h] [{google,apple,github,jwt}] [jwt]\n\n  Login to your comma account\n\n  positional arguments:\n    {google,apple,github,jwt}\n    jwt\n\n  optional arguments:\n    -h, --help            show this help message and exit\n\n\nExamples::\n\n  ./auth.py  # Log in with google account\n  ./auth.py github  # Log in with GitHub Account\n  ./auth.py jwt ey......hw  # Log in with a JWT from https://jwt.comma.ai, for use in CI\n\"\"\"\n\nimport argparse\nimport sys\nimport pprint\nimport webbrowser\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom typing import Any\nfrom urllib.parse import parse_qs, urlencode\n\nfrom openpilot.tools.lib.api import APIError, CommaApi, UnauthorizedError\nfrom openpilot.tools.lib.auth_config import set_token, get_token\n\nPORT = 3000\n\n\nclass ClientRedirectServer(HTTPServer):\n  query_params: dict[str, Any] = {}\n\n\nclass ClientRedirectHandler(BaseHTTPRequestHandler):\n  def do_GET(self):\n    if not self.path.startswith('/auth'):\n      self.send_response(204)\n      return\n\n    query = self.path.split('?', 1)[-1]\n    query_parsed = parse_qs(query, keep_blank_values=True)\n    self.server.query_params = query_parsed\n\n    self.send_response(200)\n    self.send_header('Content-type', 'text/plain')\n    self.end_headers()\n    self.wfile.write(b'Return to the CLI to continue')\n\n  def log_message(self, *args):\n    pass  # this prevent http server from dumping messages to stdout\n\n\ndef auth_redirect_link(method):\n  provider_id = {\n    'google': 'g',\n    'apple': 'a',\n    'github': 'h',\n  }[method]\n\n  params = {\n    'redirect_uri': f\"https://api.comma.ai/v2/auth/{provider_id}/redirect/\",\n    'state': f'service,localhost:{PORT}',\n  }\n\n  if method == 'google':\n    params.update({\n      'type': 'web_server',\n      'client_id': '45471411055-ornt4svd2miog6dnopve7qtmh5mnu6id.apps.googleusercontent.com',\n      'response_type': 'code',\n      'scope': 'https://www.googleapis.com/auth/userinfo.email',\n      'prompt': 'select_account',\n    })\n    return 'https://accounts.google.com/o/oauth2/auth?' + urlencode(params)\n  elif method == 'github':\n    params.update({\n      'client_id': '28c4ecb54bb7272cb5a4',\n      'scope': 'read:user',\n    })\n    return 'https://github.com/login/oauth/authorize?' + urlencode(params)\n  elif method == 'apple':\n    params.update({\n      'client_id': 'ai.comma.login',\n      'response_type': 'code',\n      'response_mode': 'form_post',\n      'scope': 'name email',\n    })\n    return 'https://appleid.apple.com/auth/authorize?' + urlencode(params)\n  else:\n    raise NotImplementedError(f\"no redirect implemented for method {method}\")\n\n\ndef login(method):\n  oauth_uri = auth_redirect_link(method)\n\n  web_server = ClientRedirectServer(('localhost', PORT), ClientRedirectHandler)\n  print(f'To sign in, use your browser and navigate to {oauth_uri}')\n  webbrowser.open(oauth_uri, new=2)\n\n  while True:\n    web_server.handle_request()\n    if 'code' in web_server.query_params:\n      break\n    elif 'error' in web_server.query_params:\n      print('Authentication Error: \"{}\". Description: \"{}\" '.format(\n        web_server.query_params['error'],\n        web_server.query_params.get('error_description')), file=sys.stderr)\n      break\n\n  try:\n    auth_resp = CommaApi().post('v2/auth/', data={'code': web_server.query_params['code'], 'provider': web_server.query_params['provider']})\n    set_token(auth_resp['access_token'])\n  except APIError as e:\n    print(f'Authentication Error: {e}', file=sys.stderr)\n\n\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser(description='Login to your comma account')\n  parser.add_argument('method', default='google', const='google', nargs='?', choices=['google', 'apple', 'github', 'jwt'])\n  parser.add_argument('jwt', nargs='?')\n\n  args = parser.parse_args()\n  if args.method == 'jwt':\n    if args.jwt is None:\n      print(\"method JWT selected, but no JWT was provided\")\n      exit(1)\n\n    set_token(args.jwt)\n  else:\n    login(args.method)\n\n  try:\n    me = CommaApi(token=get_token()).get('/v1/me')\n    print(\"Authenticated!\")\n    pprint.pprint(me)\n  except UnauthorizedError:\n    print(\"Got invalid JWT\")\n    exit(1)\n", "tools/lib/azure_container.py": "import os\nfrom datetime import datetime, timedelta, UTC\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import IO\n\n\nTOKEN_PATH = Path(\"/data/azure_token\")\n\n@lru_cache\ndef get_azure_credential():\n  if \"AZURE_TOKEN\" in os.environ:\n    return os.environ[\"AZURE_TOKEN\"]\n  elif TOKEN_PATH.is_file():\n    return TOKEN_PATH.read_text().strip()\n  else:\n    from azure.identity import AzureCliCredential\n    return AzureCliCredential()\n\n@lru_cache\ndef get_container_sas(account_name: str, container_name: str):\n  from azure.storage.blob import BlobServiceClient, ContainerSasPermissions, generate_container_sas\n  start_time = datetime.now(UTC).replace(tzinfo=None)\n  expiry_time = start_time + timedelta(hours=1)\n  blob_service = BlobServiceClient(\n    account_url=f\"https://{account_name}.blob.core.windows.net\",\n    credential=get_azure_credential(),\n  )\n  return generate_container_sas(\n    account_name,\n    container_name,\n    user_delegation_key=blob_service.get_user_delegation_key(start_time, expiry_time),\n    permission=ContainerSasPermissions(read=True, write=True, list=True),\n    expiry=expiry_time,\n  )\n\nclass AzureContainer:\n  def __init__(self, account, container):\n    self.ACCOUNT = account\n    self.CONTAINER = container\n\n  @property\n  def ACCOUNT_URL(self) -> str:\n    return f\"https://{self.ACCOUNT}.blob.core.windows.net\"\n\n  @property\n  def BASE_URL(self) -> str:\n    return f\"{self.ACCOUNT_URL}/{self.CONTAINER}/\"\n\n  def get_client_and_key(self):\n    from azure.storage.blob import ContainerClient\n    client = ContainerClient(self.ACCOUNT_URL, self.CONTAINER, credential=get_azure_credential())\n    key = get_container_sas(self.ACCOUNT, self.CONTAINER)\n    return client, key\n\n  def get_url(self, route_name: str, segment_num, log_type=\"rlog\") -> str:\n    ext = \"hevc\" if log_type.endswith('camera') else \"bz2\"\n    return self.BASE_URL + f\"{route_name.replace('|', '/')}/{segment_num}/{log_type}.{ext}\"\n\n  def upload_bytes(self, data: bytes | IO, blob_name: str, overwrite=False) -> str:\n    from azure.storage.blob import BlobClient\n    blob = BlobClient(\n      account_url=self.ACCOUNT_URL,\n      container_name=self.CONTAINER,\n      blob_name=blob_name,\n      credential=get_azure_credential(),\n      overwrite=overwrite,\n    )\n    blob.upload_blob(data, overwrite=overwrite)\n    return self.BASE_URL + blob_name\n\n  def upload_file(self, path: str | os.PathLike, blob_name: str, overwrite=False) -> str:\n    with open(path, \"rb\") as f:\n      return self.upload_bytes(f, blob_name, overwrite)\n", "tools/lib/exceptions.py": "class DataUnreadableError(Exception):\n  pass\n", "tools/lib/sanitizer.py": "# Utilities for sanitizing routes of only essential data for testing car ports and doing validation.\n\nfrom openpilot.tools.lib.logreader import LogIterable, LogMessage\n\n\ndef sanitize_vin(vin: str):\n  # (last 6 digits of vin are serial number https://en.wikipedia.org/wiki/Vehicle_identification_number)\n  VIN_SENSITIVE = 6\n  return vin[:-VIN_SENSITIVE] + \"X\" * VIN_SENSITIVE\n\n\ndef sanitize_msg(msg: LogMessage) -> LogMessage:\n  if msg.which() == \"carParams\":\n    msg = msg.as_builder()\n    msg.carParams.carVin = sanitize_vin(msg.carParams.carVin)\n    msg = msg.as_reader()\n  return msg\n\n\nPRESERVE_SERVICES = [\"can\", \"carParams\", \"pandaStates\", \"pandaStateDEPRECATED\"]\n\n\ndef sanitize(lr: LogIterable) -> LogIterable:\n  filtered = filter(lambda msg: msg.which() in PRESERVE_SERVICES, lr)\n  sanitized = map(sanitize_msg, filtered)\n  return sanitized\n", "tools/lib/api.py": "import os\nimport requests\nAPI_HOST = os.getenv('API_HOST', 'https://api.commadotai.com')\n\nclass CommaApi:\n  def __init__(self, token=None):\n    self.session = requests.Session()\n    self.session.headers['User-agent'] = 'OpenpilotTools'\n    if token:\n      self.session.headers['Authorization'] = 'JWT ' + token\n\n  def request(self, method, endpoint, **kwargs):\n    resp = self.session.request(method, API_HOST + '/' + endpoint, **kwargs)\n    resp_json = resp.json()\n    if isinstance(resp_json, dict) and resp_json.get('error'):\n      if resp.status_code in [401, 403]:\n        raise UnauthorizedError('Unauthorized. Authenticate with tools/lib/auth.py')\n\n      e = APIError(str(resp.status_code) + \":\" + resp_json.get('description', str(resp_json['error'])))\n      e.status_code = resp.status_code\n      raise e\n    return resp_json\n\n  def get(self, endpoint, **kwargs):\n    return self.request('GET', endpoint, **kwargs)\n\n  def post(self, endpoint, **kwargs):\n    return self.request('POST', endpoint, **kwargs)\n\nclass APIError(Exception):\n  pass\n\nclass UnauthorizedError(Exception):\n  pass\n", "tools/lib/comma_car_segments.py": "import os\nimport requests\n\n\n# Forks with additional car support can fork the commaCarSegments repo on huggingface or host the LFS files themselves\nCOMMA_CAR_SEGMENTS_REPO = os.environ.get(\"COMMA_CAR_SEGMENTS_REPO\", \"https://huggingface.co/datasets/commaai/commaCarSegments\")\nCOMMA_CAR_SEGMENTS_BRANCH = os.environ.get(\"COMMA_CAR_SEGMENTS_BRANCH\", \"main\")\nCOMMA_CAR_SEGMENTS_LFS_INSTANCE = os.environ.get(\"COMMA_CAR_SEGMENTS_LFS_INSTANCE\", COMMA_CAR_SEGMENTS_REPO)\n\ndef get_comma_car_segments_database():\n  from openpilot.selfdrive.car.fingerprints import MIGRATION\n\n  database = requests.get(get_repo_raw_url(\"database.json\")).json()\n\n  ret = {}\n  for platform in database:\n    ret[MIGRATION.get(platform, platform)] = database[platform]\n\n  return ret\n\n\n# Helpers related to interfacing with the commaCarSegments repository, which contains a collection of public segments for users to perform validation on.\n\ndef parse_lfs_pointer(text):\n  header, lfs_version = text.splitlines()[0].split(\" \")\n  assert header == \"version\"\n  assert lfs_version == \"https://git-lfs.github.com/spec/v1\"\n\n  header, oid_raw = text.splitlines()[1].split(\" \")\n  assert header == \"oid\"\n  header, oid = oid_raw.split(\":\")\n  assert header == \"sha256\"\n\n  header, size = text.splitlines()[2].split(\" \")\n  assert header == \"size\"\n\n  return oid, size\n\ndef get_lfs_file_url(oid, size):\n  data = {\n    \"operation\": \"download\",\n    \"transfers\": [ \"basic\" ],\n    \"objects\": [\n      {\n        \"oid\": oid,\n        \"size\": int(size)\n      }\n    ],\n    \"hash_algo\": \"sha256\"\n  }\n\n  headers = {\n    \"Accept\": \"application/vnd.git-lfs+json\",\n    \"Content-Type\": \"application/vnd.git-lfs+json\"\n  }\n\n  response = requests.post(f\"{COMMA_CAR_SEGMENTS_LFS_INSTANCE}.git/info/lfs/objects/batch\", json=data, headers=headers)\n\n  assert response.ok\n\n  obj = response.json()[\"objects\"][0]\n\n  assert \"error\" not in obj, obj\n\n  return obj[\"actions\"][\"download\"][\"href\"]\n\ndef get_repo_raw_url(path):\n  if \"huggingface\" in COMMA_CAR_SEGMENTS_REPO:\n    return f\"{COMMA_CAR_SEGMENTS_REPO}/raw/{COMMA_CAR_SEGMENTS_BRANCH}/{path}\"\n\ndef get_repo_url(path):\n  # Automatically switch to LFS if we are requesting a file that is stored in LFS\n\n  response = requests.head(get_repo_raw_url(path))\n\n  if \"text/plain\" in response.headers.get(\"content-type\"):\n    # This is an LFS pointer, so download the raw data from lfs\n    response = requests.get(get_repo_raw_url(path))\n    assert response.status_code == 200\n    oid, size = parse_lfs_pointer(response.text)\n\n    return get_lfs_file_url(oid, size)\n  else:\n    # File has not been uploaded to LFS yet\n    # (either we are on a fork where the data hasn't been pushed to LFS yet, or the CI job to push hasn't finished)\n    return get_repo_raw_url(path)\n\n\ndef get_url(route, segment, file=\"rlog.bz2\"):\n  return get_repo_url(f\"segments/{route.replace('|', '/')}/{segment}/{file}\")\n", "tools/lib/openpilotci.py": "from openpilot.tools.lib.openpilotcontainers import OpenpilotCIContainer\n\ndef get_url(*args, **kwargs):\n  return OpenpilotCIContainer.get_url(*args, **kwargs)\n\ndef upload_file(*args, **kwargs):\n  return OpenpilotCIContainer.upload_file(*args, **kwargs)\n\ndef upload_bytes(*args, **kwargs):\n  return OpenpilotCIContainer.upload_bytes(*args, **kwargs)\n\nBASE_URL = OpenpilotCIContainer.BASE_URL\n", "tools/lib/live_logreader.py": "import os\nfrom cereal import log as capnp_log, messaging\nfrom cereal.services import SERVICE_LIST\n\nfrom openpilot.tools.lib.logreader import LogIterable, RawLogIterable\n\n\nALL_SERVICES = list(SERVICE_LIST.keys())\n\ndef raw_live_logreader(services: list[str] = ALL_SERVICES, addr: str = '127.0.0.1') -> RawLogIterable:\n  if addr != \"127.0.0.1\":\n    os.environ[\"ZMQ\"] = \"1\"\n    messaging.context = messaging.Context()\n\n  poller = messaging.Poller()\n\n  for m in services:\n    messaging.sub_sock(m, poller, addr=addr)\n\n  while True:\n    polld = poller.poll(100)\n    for sock in polld:\n      msg = sock.receive()\n      yield msg\n\n\ndef live_logreader(services: list[str] = ALL_SERVICES, addr: str = '127.0.0.1') -> LogIterable:\n  for m in raw_live_logreader(services, addr):\n    with capnp_log.Event.from_bytes(m) as evt:\n      yield evt\n", "tools/lib/bootlog.py": "import functools\nimport re\n\nfrom openpilot.tools.lib.auth_config import get_token\nfrom openpilot.tools.lib.api import CommaApi\nfrom openpilot.tools.lib.helpers import RE\n\n\n@functools.total_ordering\nclass Bootlog:\n  def __init__(self, url: str):\n    self._url = url\n\n    r = re.search(RE.BOOTLOG_NAME, url)\n    if not r:\n      raise Exception(f\"Unable to parse: {url}\")\n\n    self._id = r.group('log_id')\n    self._dongle_id = r.group('dongle_id')\n\n  @property\n  def url(self) -> str:\n    return self._url\n\n  @property\n  def dongle_id(self) -> str:\n    return self._dongle_id\n\n  @property\n  def id(self) -> str:\n    return self._id\n\n  def __str__(self):\n    return f\"{self._dongle_id}/{self._id}\"\n\n  def __eq__(self, b) -> bool:\n    if not isinstance(b, Bootlog):\n      return False\n    return self.id == b.id\n\n  def __lt__(self, b) -> bool:\n    if not isinstance(b, Bootlog):\n      return False\n    return self.id < b.id\n\ndef get_bootlog_from_id(bootlog_id: str) -> Bootlog | None:\n  # TODO: implement an API endpoint for this\n  bl = Bootlog(bootlog_id)\n  for b in get_bootlogs(bl.dongle_id):\n    if b == bl:\n      return b\n  return None\n\ndef get_bootlogs(dongle_id: str) -> list[Bootlog]:\n  api = CommaApi(get_token())\n  r = api.get(f'v1/devices/{dongle_id}/bootlogs')\n  return [Bootlog(b) for b in r]\n", "tools/lib/vidindex.py": "#!/usr/bin/env python3\nimport argparse\nimport os\nimport struct\nfrom enum import IntEnum\n\nfrom openpilot.tools.lib.filereader import FileReader\n\nDEBUG = int(os.getenv(\"DEBUG\", \"0\"))\n\n# compare to ffmpeg parsing\n# ffmpeg -i <input.hevc> -c copy -bsf:v trace_headers -f null - 2>&1 | grep -B4 -A32 '] 0 '\n\n# H.265 specification\n# https://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-H.265-201802-S!!PDF-E&type=items\n\nNAL_UNIT_START_CODE = b\"\\x00\\x00\\x01\"\nNAL_UNIT_START_CODE_SIZE = len(NAL_UNIT_START_CODE)\nNAL_UNIT_HEADER_SIZE = 2\n\nclass HevcNalUnitType(IntEnum):\n  TRAIL_N = 0         # RBSP structure: slice_segment_layer_rbsp( )\n  TRAIL_R = 1         # RBSP structure: slice_segment_layer_rbsp( )\n  TSA_N = 2           # RBSP structure: slice_segment_layer_rbsp( )\n  TSA_R = 3           # RBSP structure: slice_segment_layer_rbsp( )\n  STSA_N = 4          # RBSP structure: slice_segment_layer_rbsp( )\n  STSA_R = 5          # RBSP structure: slice_segment_layer_rbsp( )\n  RADL_N = 6          # RBSP structure: slice_segment_layer_rbsp( )\n  RADL_R = 7          # RBSP structure: slice_segment_layer_rbsp( )\n  RASL_N = 8          # RBSP structure: slice_segment_layer_rbsp( )\n  RASL_R = 9          # RBSP structure: slice_segment_layer_rbsp( )\n  RSV_VCL_N10 = 10\n  RSV_VCL_R11 = 11\n  RSV_VCL_N12 = 12\n  RSV_VCL_R13 = 13\n  RSV_VCL_N14 = 14\n  RSV_VCL_R15 = 15\n  BLA_W_LP = 16       # RBSP structure: slice_segment_layer_rbsp( )\n  BLA_W_RADL = 17     # RBSP structure: slice_segment_layer_rbsp( )\n  BLA_N_LP = 18       # RBSP structure: slice_segment_layer_rbsp( )\n  IDR_W_RADL = 19     # RBSP structure: slice_segment_layer_rbsp( )\n  IDR_N_LP = 20       # RBSP structure: slice_segment_layer_rbsp( )\n  CRA_NUT = 21        # RBSP structure: slice_segment_layer_rbsp( )\n  RSV_IRAP_VCL22 = 22\n  RSV_IRAP_VCL23 = 23\n  RSV_VCL24 = 24\n  RSV_VCL25 = 25\n  RSV_VCL26 = 26\n  RSV_VCL27 = 27\n  RSV_VCL28 = 28\n  RSV_VCL29 = 29\n  RSV_VCL30 = 30\n  RSV_VCL31 = 31\n  VPS_NUT = 32        # RBSP structure: video_parameter_set_rbsp( )\n  SPS_NUT = 33        # RBSP structure: seq_parameter_set_rbsp( )\n  PPS_NUT = 34        # RBSP structure: pic_parameter_set_rbsp( )\n  AUD_NUT = 35\n  EOS_NUT = 36\n  EOB_NUT = 37\n  FD_NUT = 38\n  PREFIX_SEI_NUT = 39\n  SUFFIX_SEI_NUT = 40\n  RSV_NVCL41 = 41\n  RSV_NVCL42 = 42\n  RSV_NVCL43 = 43\n  RSV_NVCL44 = 44\n  RSV_NVCL45 = 45\n  RSV_NVCL46 = 46\n  RSV_NVCL47 = 47\n  UNSPEC48 = 48\n  UNSPEC49 = 49\n  UNSPEC50 = 50\n  UNSPEC51 = 51\n  UNSPEC52 = 52\n  UNSPEC53 = 53\n  UNSPEC54 = 54\n  UNSPEC55 = 55\n  UNSPEC56 = 56\n  UNSPEC57 = 57\n  UNSPEC58 = 58\n  UNSPEC59 = 59\n  UNSPEC60 = 60\n  UNSPEC61 = 61\n  UNSPEC62 = 62\n  UNSPEC63 = 63\n\n# B.2.2 Byte stream NAL unit semantics\n# - The nal_unit_type within the nal_unit( ) syntax structure is equal to VPS_NUT, SPS_NUT or PPS_NUT.\n# - The byte stream NAL unit syntax structure contains the first NAL unit of an access unit in decoding\n#   order, as specified in clause 7.4.2.4.4.\nHEVC_PARAMETER_SET_NAL_UNITS = (\n  HevcNalUnitType.VPS_NUT,\n  HevcNalUnitType.SPS_NUT,\n  HevcNalUnitType.PPS_NUT,\n)\n\n# 3.29 coded slice segment NAL unit: A NAL unit that has nal_unit_type in the range of TRAIL_N to RASL_R,\n# inclusive, or in the range of BLA_W_LP to RSV_IRAP_VCL23, inclusive, which indicates that the NAL unit\n# contains a coded slice segment\nHEVC_CODED_SLICE_SEGMENT_NAL_UNITS = (\n  HevcNalUnitType.TRAIL_N,\n  HevcNalUnitType.TRAIL_R,\n  HevcNalUnitType.TSA_N,\n  HevcNalUnitType.TSA_R,\n  HevcNalUnitType.STSA_N,\n  HevcNalUnitType.STSA_R,\n  HevcNalUnitType.RADL_N,\n  HevcNalUnitType.RADL_R,\n  HevcNalUnitType.RASL_N,\n  HevcNalUnitType.RASL_R,\n  HevcNalUnitType.BLA_W_LP,\n  HevcNalUnitType.BLA_W_RADL,\n  HevcNalUnitType.BLA_N_LP,\n  HevcNalUnitType.IDR_W_RADL,\n  HevcNalUnitType.IDR_N_LP,\n  HevcNalUnitType.CRA_NUT,\n)\n\nclass VideoFileInvalid(Exception):\n  pass\n\ndef get_ue(dat: bytes, start_idx: int, skip_bits: int) -> tuple[int, int]:\n  prefix_val = 0\n  prefix_len = 0\n  suffix_val = 0\n  suffix_len = 0\n\n  i = start_idx\n  while i < len(dat):\n    j = 7\n    while j >= 0:\n      if skip_bits > 0:\n        skip_bits -= 1\n      elif prefix_val == 0:\n        prefix_val = (dat[i] >> j) & 1\n        prefix_len += 1\n      else:\n        suffix_val = (suffix_val << 1) | ((dat[i] >> j) & 1)\n        suffix_len += 1\n      j -= 1\n\n      if prefix_val == 1 and prefix_len - 1 == suffix_len:\n        val = 2**(prefix_len-1) - 1 + suffix_val\n        size = prefix_len + suffix_len\n        return val, size\n    i += 1\n\n  raise VideoFileInvalid(\"invalid exponential-golomb code\")\n\ndef require_nal_unit_start(dat: bytes, nal_unit_start: int) -> None:\n  if nal_unit_start < 1:\n    raise ValueError(\"start index must be greater than zero\")\n\n  if dat[nal_unit_start:nal_unit_start + NAL_UNIT_START_CODE_SIZE] != NAL_UNIT_START_CODE:\n    raise VideoFileInvalid(\"data must begin with start code\")\n\ndef get_hevc_nal_unit_length(dat: bytes, nal_unit_start: int) -> int:\n  try:\n    pos = dat.index(NAL_UNIT_START_CODE, nal_unit_start + NAL_UNIT_START_CODE_SIZE)\n  except ValueError:\n    pos = -1\n\n  # length of NAL unit is byte count up to next NAL unit start index\n  nal_unit_len = (pos if pos != -1 else len(dat)) - nal_unit_start\n  if DEBUG:\n    print(\"  nal_unit_len:\", nal_unit_len)\n  return nal_unit_len\n\ndef get_hevc_nal_unit_type(dat: bytes, nal_unit_start: int) -> HevcNalUnitType:\n  # 7.3.1.2 NAL unit header syntax\n  # nal_unit_header( ) {    // descriptor\n  #   forbidden_zero_bit    f(1)\n  #   nal_unit_type         u(6)\n  #   nuh_layer_id          u(6)\n  #   nuh_temporal_id_plus1 u(3)\n  # }\n  header_start = nal_unit_start + NAL_UNIT_START_CODE_SIZE\n  nal_unit_header = dat[header_start:header_start + NAL_UNIT_HEADER_SIZE]\n  if len(nal_unit_header) != 2:\n    raise VideoFileInvalid(\"data to short to contain nal unit header\")\n  nal_unit_type = HevcNalUnitType((nal_unit_header[0] >> 1) & 0x3F)\n  if DEBUG:\n    print(\"  nal_unit_type:\", nal_unit_type.name, f\"({nal_unit_type.value})\")\n  return nal_unit_type\n\ndef get_hevc_slice_type(dat: bytes, nal_unit_start: int, nal_unit_type: HevcNalUnitType) -> tuple[int, bool]:\n  # 7.3.2.9 Slice segment layer RBSP syntax\n  # slice_segment_layer_rbsp( ) {\n  #   slice_segment_header( )\n  #   slice_segment_data( )\n  #   rbsp_slice_segment_trailing_bits( )\n  # }\n  # ...\n  # 7.3.6.1 General slice segment header syntax\n  # slice_segment_header( ) {                                             // descriptor\n  #   first_slice_segment_in_pic_flag                                     u(1)\n  #   if( nal_unit_type >= BLA_W_LP && nal_unit_type <= RSV_IRAP_VCL23 )\n  #     no_output_of_prior_pics_flag                                      u(1)\n  #   slice_pic_parameter_set_id                                         ue(v)\n  #   if( !first_slice_segment_in_pic_flag ) {\n  #     if( dependent_slice_segments_enabled_flag )\n  #       dependent_slice_segment_flag                                    u(1)\n  #     slice_segment_address                                             u(v)\n  #   }\n  #   if( !dependent_slice_segment_flag ) {\n  #     for( i = 0; i < num_extra_slice_header_bits; i++ )\n  #       slice_reserved_flag[ i ]                                        u(1)\n  #     slice_type                                                       ue(v)\n  # ...\n\n  rbsp_start = nal_unit_start + NAL_UNIT_START_CODE_SIZE + NAL_UNIT_HEADER_SIZE\n  skip_bits = 0\n\n  # 7.4.7.1 General slice segment header semantics\n  # first_slice_segment_in_pic_flag equal to 1 specifies that the slice segment is the first slice segment of the picture in\n  # decoding order. first_slice_segment_in_pic_flag equal to 0 specifies that the slice segment is not the first slice segment\n  # of the picture in decoding order.\n  is_first_slice = dat[rbsp_start] >> 7 & 1 == 1\n  if not is_first_slice:\n    # TODO: parse dependent_slice_segment_flag and slice_segment_address and get real slice_type\n    # for now since we don't use it return -1 for slice_type\n    return (-1, is_first_slice)\n  skip_bits += 1 # skip past first_slice_segment_in_pic_flag\n\n  if nal_unit_type >= HevcNalUnitType.BLA_W_LP and nal_unit_type <= HevcNalUnitType.RSV_IRAP_VCL23:\n    # 7.4.7.1 General slice segment header semantics\n    # no_output_of_prior_pics_flag affects the output of previously-decoded pictures in the decoded picture buffer after the\n    # decoding of an IDR or a BLA picture that is not the first picture in the bitstream as specified in Annex C.\n    skip_bits += 1 # skip past no_output_of_prior_pics_flag\n\n  # 7.4.7.1 General slice segment header semantics\n  # slice_pic_parameter_set_id specifies the value of pps_pic_parameter_set_id for the PPS in use.\n  # The value of slice_pic_parameter_set_id shall be in the range of 0 to 63, inclusive.\n  _, size = get_ue(dat, rbsp_start, skip_bits)\n  skip_bits += size # skip past slice_pic_parameter_set_id\n\n  # 7.4.3.3.1 General picture parameter set RBSP semanal_unit_lenntics\n  # num_extra_slice_header_bits specifies the number of extra slice header bits that are present in the slice header RBSP\n  # for coded pictures referring to the PPS. The value of num_extra_slice_header_bits shall be in the range of 0 to 2, inclusive,\n  # in bitstreams conforming to this version of this Specification. Other values for num_extra_slice_header_bits are reserved\n  # for future use by ITU-T | ISO/IEC. However, decoders shall allow num_extra_slice_header_bits to have any value.\n  # TODO: get from PPS_NUT pic_parameter_set_rbsp( ) for corresponding slice_pic_parameter_set_id\n  num_extra_slice_header_bits = 0\n  skip_bits += num_extra_slice_header_bits\n\n  # 7.4.7.1 General slice segment header semantics\n  # slice_type specifies the coding type of the slice according to Table 7-7.\n  # Table 7-7 - Name association to slice_type\n  # slice_type | Name of slice_type\n  #     0      | B (B slice)\n  #     1      | P (P slice)\n  #     2      | I (I slice)\n  # unsigned integer 0-th order Exp-Golomb-coded syntax element with the left bit first\n  slice_type, _ = get_ue(dat, rbsp_start, skip_bits)\n  if DEBUG:\n    print(\"  slice_type:\", slice_type, f\"(first slice: {is_first_slice})\")\n  if slice_type > 2:\n    raise VideoFileInvalid(\"slice_type must be 0, 1, or 2\")\n  return slice_type, is_first_slice\n\ndef hevc_index(hevc_file_name: str, allow_corrupt: bool=False) -> tuple[list, int, bytes]:\n  with FileReader(hevc_file_name) as f:\n    dat = f.read()\n\n  if len(dat) < NAL_UNIT_START_CODE_SIZE + 1:\n    raise VideoFileInvalid(\"data is too short\")\n\n  if dat[0] != 0x00:\n    raise VideoFileInvalid(\"first byte must be 0x00\")\n\n  prefix_dat = b\"\"\n  frame_types = list()\n\n  i = 1 # skip past first byte 0x00\n  try:\n    while i < len(dat):\n      require_nal_unit_start(dat, i)\n      nal_unit_len = get_hevc_nal_unit_length(dat, i)\n      nal_unit_type = get_hevc_nal_unit_type(dat, i)\n      if nal_unit_type in HEVC_PARAMETER_SET_NAL_UNITS:\n        prefix_dat += dat[i:i+nal_unit_len]\n      elif nal_unit_type in HEVC_CODED_SLICE_SEGMENT_NAL_UNITS:\n        slice_type, is_first_slice = get_hevc_slice_type(dat, i, nal_unit_type)\n        if is_first_slice:\n          frame_types.append((slice_type, i))\n      i += nal_unit_len\n  except Exception as e:\n    if not allow_corrupt:\n      raise\n    print(f\"ERROR: NAL unit skipped @ {i}\\n\", str(e))\n\n  return frame_types, len(dat), prefix_dat\n\ndef main() -> None:\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\"input_file\", type=str)\n  parser.add_argument(\"output_prefix_file\", type=str)\n  parser.add_argument(\"output_index_file\", type=str)\n  args = parser.parse_args()\n\n  frame_types, dat_len, prefix_dat = hevc_index(args.input_file)\n  with open(args.output_prefix_file, \"wb\") as f:\n    f.write(prefix_dat)\n\n  with open(args.output_index_file, \"wb\") as f:\n    for ft, fp in frame_types:\n      f.write(struct.pack(\"<II\", ft, fp))\n    f.write(struct.pack(\"<II\", 0xFFFFFFFF, dat_len))\n\nif __name__ == \"__main__\":\n  main()\n", "tools/lib/helpers.py": "import bz2\n\n\n# regex patterns\nclass RE:\n  DONGLE_ID = r'(?P<dongle_id>[a-f0-9]{16})'\n  TIMESTAMP = r'(?P<timestamp>[0-9]{4}-[0-9]{2}-[0-9]{2}--[0-9]{2}-[0-9]{2}-[0-9]{2})'\n  LOG_ID_V2 = r'(?P<count>[a-f0-9]{8})--(?P<uid>[a-z0-9]{10})'\n  LOG_ID = fr'(?P<log_id>(?:{TIMESTAMP}|{LOG_ID_V2}))'\n  ROUTE_NAME = fr'(?P<route_name>{DONGLE_ID}[|_/]{LOG_ID})'\n  SEGMENT_NAME = fr'{ROUTE_NAME}(?:--|/)(?P<segment_num>[0-9]+)'\n\n  INDEX = r'-?[0-9]+'\n  SLICE = fr'(?P<start>{INDEX})?:?(?P<end>{INDEX})?:?(?P<step>{INDEX})?'\n  SEGMENT_RANGE = fr'{ROUTE_NAME}(?:(--|/)(?P<slice>({SLICE})))?(?:/(?P<selector>([qras])))?'\n\n  BOOTLOG_NAME = ROUTE_NAME\n\n  EXPLORER_FILE = fr'^(?P<segment_name>{SEGMENT_NAME})--(?P<file_name>[a-z]+\\.[a-z0-9]+)$'\n  OP_SEGMENT_DIR = fr'^(?P<segment_name>{SEGMENT_NAME})$'\n\n\ndef save_log(dest, log_msgs, compress=True):\n  dat = b\"\".join(msg.as_builder().to_bytes() for msg in log_msgs)\n\n  if compress:\n    dat = bz2.compress(dat)\n\n  with open(dest, \"wb\") as f:\n    f.write(dat)\n", "tools/lib/url_file.py": "import logging\nimport os\nimport socket\nimport time\nfrom hashlib import sha256\nfrom urllib3 import PoolManager, Retry\nfrom urllib3.response import BaseHTTPResponse\nfrom urllib3.util import Timeout\n\nfrom openpilot.common.file_helpers import atomic_write_in_dir\nfrom openpilot.system.hardware.hw import Paths\n#  Cache chunk size\nK = 1000\nCHUNK_SIZE = 1000 * K\n\nlogging.getLogger(\"urllib3\").setLevel(logging.WARNING)\n\ndef hash_256(link: str) -> str:\n  hsh = str(sha256((link.split(\"?\")[0]).encode('utf-8')).hexdigest())\n  return hsh\n\n\nclass URLFileException(Exception):\n  pass\n\n\nclass URLFile:\n  _pool_manager: PoolManager|None = None\n\n  @staticmethod\n  def reset() -> None:\n    URLFile._pool_manager = None\n\n  @staticmethod\n  def pool_manager() -> PoolManager:\n    if URLFile._pool_manager is None:\n      socket_options = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),]\n      retries = Retry(total=5, backoff_factor=0.5, status_forcelist=[409, 429, 503, 504])\n      URLFile._pool_manager = PoolManager(num_pools=10, maxsize=100, socket_options=socket_options, retries=retries)\n    return URLFile._pool_manager\n\n  def __init__(self, url: str, timeout: int=10, debug: bool=False, cache: bool|None=None):\n    self._url = url\n    self._timeout = Timeout(connect=timeout, read=timeout)\n    self._pos = 0\n    self._length: int|None = None\n    self._debug = debug\n    #  True by default, false if FILEREADER_CACHE is defined, but can be overwritten by the cache input\n    self._force_download = not int(os.environ.get(\"FILEREADER_CACHE\", \"0\"))\n    if cache is not None:\n      self._force_download = not cache\n\n    if not self._force_download:\n      os.makedirs(Paths.download_cache_root(), exist_ok=True)\n\n  def __enter__(self):\n    return self\n\n  def __exit__(self, exc_type, exc_value, traceback) -> None:\n    pass\n\n  def _request(self, method: str, url: str, headers: dict[str, str]|None=None) -> BaseHTTPResponse:\n    return URLFile.pool_manager().request(method, url, timeout=self._timeout, headers=headers)\n\n  def get_length_online(self) -> int:\n    response = self._request('HEAD', self._url)\n    if not (200 <= response.status <= 299):\n      return -1\n    length = response.headers.get('content-length', 0)\n    return int(length)\n\n  def get_length(self) -> int:\n    if self._length is not None:\n      return self._length\n\n    file_length_path = os.path.join(Paths.download_cache_root(), hash_256(self._url) + \"_length\")\n    if not self._force_download and os.path.exists(file_length_path):\n      with open(file_length_path) as file_length:\n        content = file_length.read()\n        self._length = int(content)\n        return self._length\n\n    self._length = self.get_length_online()\n    if not self._force_download and self._length != -1:\n      with atomic_write_in_dir(file_length_path, mode=\"w\") as file_length:\n        file_length.write(str(self._length))\n    return self._length\n\n  def read(self, ll: int|None=None) -> bytes:\n    if self._force_download:\n      return self.read_aux(ll=ll)\n\n    file_begin = self._pos\n    file_end = self._pos + ll if ll is not None else self.get_length()\n    assert file_end != -1, f\"Remote file is empty or doesn't exist: {self._url}\"\n    #  We have to align with chunks we store. Position is the begginiing of the latest chunk that starts before or at our file\n    position = (file_begin // CHUNK_SIZE) * CHUNK_SIZE\n    response = b\"\"\n    while True:\n      self._pos = position\n      chunk_number = self._pos / CHUNK_SIZE\n      file_name = hash_256(self._url) + \"_\" + str(chunk_number)\n      full_path = os.path.join(Paths.download_cache_root(), str(file_name))\n      data = None\n      #  If we don't have a file, download it\n      if not os.path.exists(full_path):\n        data = self.read_aux(ll=CHUNK_SIZE)\n        with atomic_write_in_dir(full_path, mode=\"wb\") as new_cached_file:\n          new_cached_file.write(data)\n      else:\n        with open(full_path, \"rb\") as cached_file:\n          data = cached_file.read()\n\n      response += data[max(0, file_begin - position): min(CHUNK_SIZE, file_end - position)]\n\n      position += CHUNK_SIZE\n      if position >= file_end:\n        self._pos = file_end\n        return response\n\n  def read_aux(self, ll: int|None=None) -> bytes:\n    download_range = False\n    headers = {}\n    if self._pos != 0 or ll is not None:\n      if ll is None:\n        end = self.get_length() - 1\n      else:\n        end = min(self._pos + ll, self.get_length()) - 1\n      if self._pos >= end:\n        return b\"\"\n      headers['Range'] = f\"bytes={self._pos}-{end}\"\n      download_range = True\n\n    if self._debug:\n      t1 = time.time()\n\n    response = self._request('GET', self._url, headers=headers)\n    ret = response.data\n\n    if self._debug:\n      t2 = time.time()\n      if t2 - t1 > 0.1:\n        print(f\"get {self._url} {headers!r} {t2 - t1:.3f} slow\")\n\n    response_code = response.status\n    if response_code == 416:  # Requested Range Not Satisfiable\n      raise URLFileException(f\"Error, range out of bounds {response_code} {headers} ({self._url}): {repr(ret)[:500]}\")\n    if download_range and response_code != 206:  # Partial Content\n      raise URLFileException(f\"Error, requested range but got unexpected response {response_code} {headers} ({self._url}): {repr(ret)[:500]}\")\n    if (not download_range) and response_code != 200:  # OK\n      raise URLFileException(f\"Error {response_code} {headers} ({self._url}): {repr(ret)[:500]}\")\n\n    self._pos += len(ret)\n    return ret\n\n  def seek(self, pos:int) -> None:\n    self._pos = pos\n\n  @property\n  def name(self) -> str:\n    return self._url\n\n\nos.register_at_fork(after_in_child=URLFile.reset)\n", "tools/lib/openpilotcontainers.py": "#!/usr/bin/env python3\nfrom openpilot.tools.lib.azure_container import AzureContainer\n\nOpenpilotCIContainer = AzureContainer(\"commadataci\", \"openpilotci\")\nDataCIContainer = AzureContainer(\"commadataci\", \"commadataci\")\nDataProdContainer = AzureContainer(\"commadata2\", \"commadata2\")\n", "tools/lib/route.py": "import os\nimport re\nfrom functools import cache\nfrom urllib.parse import urlparse\nfrom collections import defaultdict\nfrom itertools import chain\n\nfrom openpilot.tools.lib.auth_config import get_token\nfrom openpilot.tools.lib.api import CommaApi\nfrom openpilot.tools.lib.helpers import RE\n\nQLOG_FILENAMES = ['qlog', 'qlog.bz2', 'qlog.zst']\nQCAMERA_FILENAMES = ['qcamera.ts']\nLOG_FILENAMES = ['rlog', 'rlog.bz2', 'raw_log.bz2']\nCAMERA_FILENAMES = ['fcamera.hevc', 'video.hevc']\nDCAMERA_FILENAMES = ['dcamera.hevc']\nECAMERA_FILENAMES = ['ecamera.hevc']\n\n\nclass Route:\n  def __init__(self, name, data_dir=None):\n    self._name = RouteName(name)\n    self.files = None\n    if data_dir is not None:\n      self._segments = self._get_segments_local(data_dir)\n    else:\n      self._segments = self._get_segments_remote()\n    self.max_seg_number = self._segments[-1].name.segment_num\n\n  @property\n  def name(self):\n    return self._name\n\n  @property\n  def segments(self):\n    return self._segments\n\n  def log_paths(self):\n    log_path_by_seg_num = {s.name.segment_num: s.log_path for s in self._segments}\n    return [log_path_by_seg_num.get(i, None) for i in range(self.max_seg_number + 1)]\n\n  def qlog_paths(self):\n    qlog_path_by_seg_num = {s.name.segment_num: s.qlog_path for s in self._segments}\n    return [qlog_path_by_seg_num.get(i, None) for i in range(self.max_seg_number + 1)]\n\n  def camera_paths(self):\n    camera_path_by_seg_num = {s.name.segment_num: s.camera_path for s in self._segments}\n    return [camera_path_by_seg_num.get(i, None) for i in range(self.max_seg_number + 1)]\n\n  def dcamera_paths(self):\n    dcamera_path_by_seg_num = {s.name.segment_num: s.dcamera_path for s in self._segments}\n    return [dcamera_path_by_seg_num.get(i, None) for i in range(self.max_seg_number + 1)]\n\n  def ecamera_paths(self):\n    ecamera_path_by_seg_num = {s.name.segment_num: s.ecamera_path for s in self._segments}\n    return [ecamera_path_by_seg_num.get(i, None) for i in range(self.max_seg_number + 1)]\n\n  def qcamera_paths(self):\n    qcamera_path_by_seg_num = {s.name.segment_num: s.qcamera_path for s in self._segments}\n    return [qcamera_path_by_seg_num.get(i, None) for i in range(self.max_seg_number + 1)]\n\n  # TODO: refactor this, it's super repetitive\n  def _get_segments_remote(self):\n    api = CommaApi(get_token())\n    route_files = api.get('v1/route/' + self.name.canonical_name + '/files')\n    self.files = list(chain.from_iterable(route_files.values()))\n\n    segments = {}\n    for url in self.files:\n      _, dongle_id, time_str, segment_num, fn = urlparse(url).path.rsplit('/', maxsplit=4)\n      segment_name = f'{dongle_id}|{time_str}--{segment_num}'\n      if segments.get(segment_name):\n        segments[segment_name] = Segment(\n          segment_name,\n          url if fn in LOG_FILENAMES else segments[segment_name].log_path,\n          url if fn in QLOG_FILENAMES else segments[segment_name].qlog_path,\n          url if fn in CAMERA_FILENAMES else segments[segment_name].camera_path,\n          url if fn in DCAMERA_FILENAMES else segments[segment_name].dcamera_path,\n          url if fn in ECAMERA_FILENAMES else segments[segment_name].ecamera_path,\n          url if fn in QCAMERA_FILENAMES else segments[segment_name].qcamera_path,\n        )\n      else:\n        segments[segment_name] = Segment(\n          segment_name,\n          url if fn in LOG_FILENAMES else None,\n          url if fn in QLOG_FILENAMES else None,\n          url if fn in CAMERA_FILENAMES else None,\n          url if fn in DCAMERA_FILENAMES else None,\n          url if fn in ECAMERA_FILENAMES else None,\n          url if fn in QCAMERA_FILENAMES else None,\n        )\n\n    return sorted(segments.values(), key=lambda seg: seg.name.segment_num)\n\n  def _get_segments_local(self, data_dir):\n    files = os.listdir(data_dir)\n    segment_files = defaultdict(list)\n\n    for f in files:\n      fullpath = os.path.join(data_dir, f)\n      explorer_match = re.match(RE.EXPLORER_FILE, f)\n      op_match = re.match(RE.OP_SEGMENT_DIR, f)\n\n      if explorer_match:\n        segment_name = explorer_match.group('segment_name')\n        fn = explorer_match.group('file_name')\n        if segment_name.replace('_', '|').startswith(self.name.canonical_name):\n          segment_files[segment_name].append((fullpath, fn))\n      elif op_match and os.path.isdir(fullpath):\n        segment_name = op_match.group('segment_name')\n        if segment_name.startswith(self.name.canonical_name):\n          for seg_f in os.listdir(fullpath):\n            segment_files[segment_name].append((os.path.join(fullpath, seg_f), seg_f))\n      elif f == self.name.canonical_name:\n        for seg_num in os.listdir(fullpath):\n          if not seg_num.isdigit():\n            continue\n\n          segment_name = f'{self.name.canonical_name}--{seg_num}'\n          for seg_f in os.listdir(os.path.join(fullpath, seg_num)):\n            segment_files[segment_name].append((os.path.join(fullpath, seg_num, seg_f), seg_f))\n\n    segments = []\n    for segment, files in segment_files.items():\n\n      try:\n        log_path = next(path for path, filename in files if filename in LOG_FILENAMES)\n      except StopIteration:\n        log_path = None\n\n      try:\n        qlog_path = next(path for path, filename in files if filename in QLOG_FILENAMES)\n      except StopIteration:\n        qlog_path = None\n\n      try:\n        camera_path = next(path for path, filename in files if filename in CAMERA_FILENAMES)\n      except StopIteration:\n        camera_path = None\n\n      try:\n        dcamera_path = next(path for path, filename in files if filename in DCAMERA_FILENAMES)\n      except StopIteration:\n        dcamera_path = None\n\n      try:\n        ecamera_path = next(path for path, filename in files if filename in ECAMERA_FILENAMES)\n      except StopIteration:\n        ecamera_path = None\n\n      try:\n        qcamera_path = next(path for path, filename in files if filename in QCAMERA_FILENAMES)\n      except StopIteration:\n        qcamera_path = None\n\n      segments.append(Segment(segment, log_path, qlog_path, camera_path, dcamera_path, ecamera_path, qcamera_path))\n\n    if len(segments) == 0:\n      raise ValueError(f'Could not find segments for route {self.name.canonical_name} in data directory {data_dir}')\n    return sorted(segments, key=lambda seg: seg.name.segment_num)\n\n\nclass Segment:\n  def __init__(self, name, log_path, qlog_path, camera_path, dcamera_path, ecamera_path, qcamera_path):\n    self._name = SegmentName(name)\n    self.log_path = log_path\n    self.qlog_path = qlog_path\n    self.camera_path = camera_path\n    self.dcamera_path = dcamera_path\n    self.ecamera_path = ecamera_path\n    self.qcamera_path = qcamera_path\n\n  @property\n  def name(self):\n    return self._name\n\n\nclass RouteName:\n  def __init__(self, name_str: str):\n    self._name_str = name_str\n    delim = next(c for c in self._name_str if c in (\"|\", \"/\"))\n    self._dongle_id, self._time_str = self._name_str.split(delim)\n\n    assert len(self._dongle_id) == 16, self._name_str\n    assert len(self._time_str) == 20, self._name_str\n    self._canonical_name = f\"{self._dongle_id}|{self._time_str}\"\n\n  @property\n  def canonical_name(self) -> str: return self._canonical_name\n\n  @property\n  def dongle_id(self) -> str: return self._dongle_id\n\n  @property\n  def time_str(self) -> str: return self._time_str\n\n  def __str__(self) -> str: return self._canonical_name\n\n\nclass SegmentName:\n  # TODO: add constructor that takes dongle_id, time_str, segment_num and then create instances\n  # of this class instead of manually constructing a segment name (use canonical_name prop instead)\n  def __init__(self, name_str: str, allow_route_name=False):\n    data_dir_path_separator_index = name_str.rsplit(\"|\", 1)[0].rfind(\"/\")\n    use_data_dir = (data_dir_path_separator_index != -1) and (\"|\" in name_str)\n    self._name_str = name_str[data_dir_path_separator_index + 1:] if use_data_dir else name_str\n    self._data_dir = name_str[:data_dir_path_separator_index] if use_data_dir else None\n\n    seg_num_delim = \"--\" if self._name_str.count(\"--\") == 2 else \"/\"\n    name_parts = self._name_str.rsplit(seg_num_delim, 1)\n    if allow_route_name and len(name_parts) == 1:\n      name_parts.append(\"-1\")  # no segment number\n    self._route_name = RouteName(name_parts[0])\n    self._num = int(name_parts[1])\n    self._canonical_name = f\"{self._route_name._dongle_id}|{self._route_name._time_str}--{self._num}\"\n\n  @property\n  def canonical_name(self) -> str: return self._canonical_name\n\n  @property\n  def dongle_id(self) -> str: return self._route_name.dongle_id\n\n  @property\n  def time_str(self) -> str: return self._route_name.time_str\n\n  @property\n  def segment_num(self) -> int: return self._num\n\n  @property\n  def route_name(self) -> RouteName: return self._route_name\n\n  @property\n  def data_dir(self) -> str | None: return self._data_dir\n\n  def __str__(self) -> str: return self._canonical_name\n\n\n@cache\ndef get_max_seg_number_cached(sr: 'SegmentRange') -> int:\n  try:\n    api = CommaApi(get_token())\n    max_seg_number = api.get(\"/v1/route/\" + sr.route_name.replace(\"/\", \"|\"))[\"maxqlog\"]\n    assert isinstance(max_seg_number, int)\n    return max_seg_number\n  except Exception as e:\n    raise Exception(\"unable to get max_segment_number. ensure you have access to this route or the route is public.\") from e\n\n\nclass SegmentRange:\n  def __init__(self, segment_range: str):\n    m = re.fullmatch(RE.SEGMENT_RANGE, segment_range)\n    assert m is not None, f\"Segment range is not valid {segment_range}\"\n    self.m = m\n\n  @property\n  def route_name(self) -> str:\n    return self.m.group(\"route_name\")\n\n  @property\n  def dongle_id(self) -> str:\n    return self.m.group(\"dongle_id\")\n\n  @property\n  def log_id(self) -> str:\n    return self.m.group(\"log_id\")\n\n  @property\n  def slice(self) -> str:\n    return self.m.group(\"slice\") or \"\"\n\n  @property\n  def selector(self) -> str | None:\n    return self.m.group(\"selector\")\n\n  @property\n  def seg_idxs(self) -> list[int]:\n    m = re.fullmatch(RE.SLICE, self.slice)\n    assert m is not None, f\"Invalid slice: {self.slice}\"\n    start, end, step = (None if s is None else int(s) for s in m.groups())\n\n    # one segment specified\n    if start is not None and end is None and ':' not in self.slice:\n      if start < 0:\n        start += get_max_seg_number_cached(self) + 1\n      return [start]\n\n    s = slice(start, end, step)\n    # no specified end or using relative indexing, need number of segments\n    if end is None or end < 0 or (start is not None and start < 0):\n      return list(range(get_max_seg_number_cached(self) + 1))[s]\n    else:\n      return list(range(end + 1))[s]\n\n  def __str__(self) -> str:\n    return f\"{self.dongle_id}/{self.log_id}\" + (f\"/{self.slice}\" if self.slice else \"\") + (f\"/{self.selector}\" if self.selector else \"\")\n\n  def __repr__(self) -> str:\n    return self.__str__()\n", "tools/lib/logreader.py": "#!/usr/bin/env python3\nimport bz2\nfrom functools import partial\nimport multiprocessing\nimport capnp\nimport enum\nimport os\nimport pathlib\nimport sys\nimport tqdm\nimport urllib.parse\nimport warnings\nimport zstd\n\nfrom collections.abc import Callable, Iterable, Iterator\nfrom urllib.parse import parse_qs, urlparse\n\nfrom cereal import log as capnp_log\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.tools.lib.comma_car_segments import get_url as get_comma_segments_url\nfrom openpilot.tools.lib.openpilotci import get_url\nfrom openpilot.tools.lib.filereader import FileReader, file_exists, internal_source_available\nfrom openpilot.tools.lib.route import Route, SegmentRange\n\nLogMessage = type[capnp._DynamicStructReader]\nLogIterable = Iterable[LogMessage]\nRawLogIterable = Iterable[bytes]\n\n\nclass _LogFileReader:\n  def __init__(self, fn, canonicalize=True, only_union_types=False, sort_by_time=False, dat=None):\n    self.data_version = None\n    self._only_union_types = only_union_types\n\n    ext = None\n    if not dat:\n      _, ext = os.path.splitext(urllib.parse.urlparse(fn).path)\n      if ext not in ('', '.bz2', '.zst'):\n        # old rlogs weren't compressed\n        raise Exception(f\"unknown extension {ext}\")\n\n      with FileReader(fn) as f:\n        dat = f.read()\n\n    if ext == \".bz2\" or dat.startswith(b'BZh9'):\n      dat = bz2.decompress(dat)\n    elif ext == \".zst\" or dat.startswith(b'\\x28\\xB5\\x2F\\xFD'):\n      # https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#zstandard-frames\n      dat = zstd.decompress(dat)\n\n    ents = capnp_log.Event.read_multiple_bytes(dat)\n\n    self._ents = []\n    try:\n      for e in ents:\n        self._ents.append(e)\n    except capnp.KjException:\n      warnings.warn(\"Corrupted events detected\", RuntimeWarning, stacklevel=1)\n\n    if sort_by_time:\n      self._ents.sort(key=lambda x: x.logMonoTime)\n\n  def __iter__(self) -> Iterator[capnp._DynamicStructReader]:\n    for ent in self._ents:\n      if self._only_union_types:\n        try:\n          ent.which()\n          yield ent\n        except capnp.lib.capnp.KjException:\n          pass\n      else:\n        yield ent\n\n\nclass ReadMode(enum.StrEnum):\n  RLOG = \"r\"  # only read rlogs\n  QLOG = \"q\"  # only read qlogs\n  SANITIZED = \"s\"  # read from the commaCarSegments database\n  AUTO = \"a\"  # default to rlogs, fallback to qlogs\n  AUTO_INTERACTIVE = \"i\"  # default to rlogs, fallback to qlogs with a prompt from the user\n\n\nLogPath = str | None\nLogPaths = list[LogPath]\nValidFileCallable = Callable[[LogPath], bool]\nSource = Callable[[SegmentRange, ReadMode], LogPaths]\n\nInternalUnavailableException = Exception(\"Internal source not available\")\n\ndef default_valid_file(fn: LogPath) -> bool:\n  return fn is not None and file_exists(fn)\n\n\ndef auto_strategy(rlog_paths: LogPaths, qlog_paths: LogPaths, interactive: bool, valid_file: ValidFileCallable) -> LogPaths:\n  # auto select logs based on availability\n  if any(rlog is None or not valid_file(rlog) for rlog in rlog_paths) and all(qlog is not None and valid_file(qlog) for qlog in qlog_paths):\n    if interactive:\n      if input(\"Some rlogs were not found, would you like to fallback to qlogs for those segments? (y/n) \").lower() != \"y\":\n        return rlog_paths\n    else:\n      cloudlog.warning(\"Some rlogs were not found, falling back to qlogs for those segments...\")\n\n    return [rlog if valid_file(rlog) else (qlog if valid_file(qlog) else None)\n            for (rlog, qlog) in zip(rlog_paths, qlog_paths, strict=True)]\n  return rlog_paths\n\n\ndef apply_strategy(mode: ReadMode, rlog_paths: LogPaths, qlog_paths: LogPaths, valid_file: ValidFileCallable = default_valid_file) -> LogPaths:\n  if mode == ReadMode.RLOG:\n    return rlog_paths\n  elif mode == ReadMode.QLOG:\n    return qlog_paths\n  elif mode == ReadMode.AUTO:\n    return auto_strategy(rlog_paths, qlog_paths, False, valid_file)\n  elif mode == ReadMode.AUTO_INTERACTIVE:\n    return auto_strategy(rlog_paths, qlog_paths, True, valid_file)\n  raise Exception(f\"invalid mode: {mode}\")\n\n\ndef comma_api_source(sr: SegmentRange, mode: ReadMode) -> LogPaths:\n  route = Route(sr.route_name)\n\n  rlog_paths = [route.log_paths()[seg] for seg in sr.seg_idxs]\n  qlog_paths = [route.qlog_paths()[seg] for seg in sr.seg_idxs]\n\n  # comma api will have already checked if the file exists\n  def valid_file(fn):\n    return fn is not None\n\n  return apply_strategy(mode, rlog_paths, qlog_paths, valid_file=valid_file)\n\n\ndef internal_source(sr: SegmentRange, mode: ReadMode, file_ext: str = \"bz2\") -> LogPaths:\n  if not internal_source_available():\n    raise InternalUnavailableException\n\n  def get_internal_url(sr: SegmentRange, seg, file):\n    return f\"cd:/{sr.dongle_id}/{sr.log_id}/{seg}/{file}.{file_ext}\"\n\n  rlog_paths = [get_internal_url(sr, seg, \"rlog\") for seg in sr.seg_idxs]\n  qlog_paths = [get_internal_url(sr, seg, \"qlog\") for seg in sr.seg_idxs]\n\n  return apply_strategy(mode, rlog_paths, qlog_paths)\n\n\ndef internal_source_zst(sr: SegmentRange, mode: ReadMode, file_ext: str = \"zst\") -> LogPaths:\n  return internal_source(sr, mode, file_ext)\n\n\ndef openpilotci_source(sr: SegmentRange, mode: ReadMode) -> LogPaths:\n  rlog_paths = [get_url(sr.route_name, seg, \"rlog\") for seg in sr.seg_idxs]\n  qlog_paths = [get_url(sr.route_name, seg, \"qlog\") for seg in sr.seg_idxs]\n\n  return apply_strategy(mode, rlog_paths, qlog_paths)\n\n\ndef comma_car_segments_source(sr: SegmentRange, mode=ReadMode.RLOG) -> LogPaths:\n  return [get_comma_segments_url(sr.route_name, seg) for seg in sr.seg_idxs]\n\n\ndef direct_source(file_or_url: str) -> LogPaths:\n  return [file_or_url]\n\n\ndef get_invalid_files(files):\n  for f in files:\n    if f is None or not file_exists(f):\n      yield f\n\n\ndef check_source(source: Source, *args) -> LogPaths:\n  files = source(*args)\n  assert len(files) > 0, \"No files on source\"\n  assert next(get_invalid_files(files), False) is False, \"Some files are invalid\"\n  return files\n\n\ndef auto_source(sr: SegmentRange, mode=ReadMode.RLOG) -> LogPaths:\n  if mode == ReadMode.SANITIZED:\n    return comma_car_segments_source(sr, mode)\n\n  SOURCES: list[Source] = [internal_source, internal_source_zst, openpilotci_source, comma_api_source, comma_car_segments_source,]\n  exceptions = {}\n\n  # for automatic fallback modes, auto_source needs to first check if rlogs exist for any source\n  if mode in [ReadMode.AUTO, ReadMode.AUTO_INTERACTIVE]:\n    for source in SOURCES:\n      try:\n        return check_source(source, sr, ReadMode.RLOG)\n      except Exception:\n        pass\n\n  # Automatically determine viable source\n  for source in SOURCES:\n    try:\n      return check_source(source, sr, mode)\n    except Exception as e:\n      exceptions[source.__name__] = e\n\n  raise Exception(\"auto_source could not find any valid source, exceptions for sources:\\n  - \" +\n                  \"\\n  - \".join([f\"{k}: {repr(v)}\" for k, v in exceptions.items()]))\n\n\ndef parse_useradmin(identifier: str):\n  if \"useradmin.comma.ai\" in identifier:\n    query = parse_qs(urlparse(identifier).query)\n    return query[\"onebox\"][0]\n  return None\n\n\ndef parse_cabana(identifier: str):\n  if \"cabana.comma.ai\" in identifier:\n    query = parse_qs(urlparse(identifier).query)\n    return query[\"route\"][0]\n  return None\n\n\ndef parse_direct(identifier: str):\n  if identifier.startswith((\"http://\", \"https://\", \"cd:/\")) or pathlib.Path(identifier).exists():\n    return identifier\n  return None\n\n\ndef parse_indirect(identifier: str):\n  parsed = parse_useradmin(identifier) or parse_cabana(identifier)\n\n  if parsed is not None:\n    return parsed, comma_api_source, True\n\n  return identifier, None, False\n\n\nclass LogReader:\n  def _parse_identifiers(self, identifier: str | list[str]):\n    if isinstance(identifier, list):\n      return [i for j in identifier for i in self._parse_identifiers(j)]\n\n    parsed, source, is_indirect = parse_indirect(identifier)\n\n    if not is_indirect:\n      direct_parsed = parse_direct(identifier)\n      if direct_parsed is not None:\n        return direct_source(identifier)\n\n    sr = SegmentRange(parsed)\n    mode = self.default_mode if sr.selector is None else ReadMode(sr.selector)\n    source = self.default_source if source is None else source\n\n    identifiers = source(sr, mode)\n\n    invalid_count = len(list(get_invalid_files(identifiers)))\n    assert invalid_count == 0, f\"{invalid_count}/{len(identifiers)} invalid log(s) found, please ensure all logs \\\nare uploaded or auto fallback to qlogs with '/a' selector at the end of the route name.\"\n    return identifiers\n\n  def __init__(self, identifier: str | list[str], default_mode: ReadMode = ReadMode.RLOG,\n               default_source=auto_source, sort_by_time=False, only_union_types=False):\n    self.default_mode = default_mode\n    self.default_source = default_source\n    self.identifier = identifier\n\n    self.sort_by_time = sort_by_time\n    self.only_union_types = only_union_types\n\n    self.__lrs: dict[int, _LogFileReader] = {}\n    self.reset()\n\n  def _get_lr(self, i):\n    if i not in self.__lrs:\n      self.__lrs[i] = _LogFileReader(self.logreader_identifiers[i], sort_by_time=self.sort_by_time, only_union_types=self.only_union_types)\n    return self.__lrs[i]\n\n  def __iter__(self):\n    for i in range(len(self.logreader_identifiers)):\n      yield from self._get_lr(i)\n\n  def _run_on_segment(self, func, i):\n    return func(self._get_lr(i))\n\n  def run_across_segments(self, num_processes, func):\n    with multiprocessing.Pool(num_processes) as pool:\n      ret = []\n      num_segs = len(self.logreader_identifiers)\n      for p in tqdm.tqdm(pool.imap(partial(self._run_on_segment, func), range(num_segs)), total=num_segs):\n        ret.extend(p)\n      return ret\n\n  def reset(self):\n    self.logreader_identifiers = self._parse_identifiers(self.identifier)\n\n  @staticmethod\n  def from_bytes(dat):\n    return _LogFileReader(\"\", dat=dat)\n\n  def filter(self, msg_type: str):\n    return (getattr(m, m.which()) for m in filter(lambda m: m.which() == msg_type, self))\n\n  def first(self, msg_type: str):\n    return next(self.filter(msg_type), None)\n\n\nif __name__ == \"__main__\":\n  import codecs\n\n  # capnproto <= 0.8.0 throws errors converting byte data to string\n  # below line catches those errors and replaces the bytes with \\x__\n  codecs.register_error(\"strict\", codecs.backslashreplace_errors)\n  log_path = sys.argv[1]\n  lr = LogReader(log_path, sort_by_time=True)\n  for msg in lr:\n    print(msg)\n", "tools/lib/cache.py": "import os\nimport urllib.parse\n\nDEFAULT_CACHE_DIR = os.getenv(\"CACHE_ROOT\", os.path.expanduser(\"~/.commacache\"))\n\ndef cache_path_for_file_path(fn, cache_dir=DEFAULT_CACHE_DIR):\n  dir_ = os.path.join(cache_dir, \"local\")\n  os.makedirs(dir_, exist_ok=True)\n  fn_parsed = urllib.parse.urlparse(fn)\n  if fn_parsed.scheme == '':\n    cache_fn = os.path.abspath(fn).replace(\"/\", \"_\")\n  else:\n    cache_fn = f'{fn_parsed.hostname}_{fn_parsed.path.replace(\"/\", \"_\")}'\n  return os.path.join(dir_, cache_fn)\n", "tools/lib/__init__.py": "", "tools/lib/kbhit.py": "#!/usr/bin/env python\nimport sys\nimport termios\nimport atexit\nfrom select import select\n\nSTDIN_FD = sys.stdin.fileno()\n\nclass KBHit:\n  def __init__(self) -> None:\n    ''' Creates a KBHit object that you can call to do various keyboard things.\n    '''\n\n    self.set_kbhit_terminal()\n\n  def set_kbhit_terminal(self) -> None:\n    ''' Save old terminal settings for closure, remove ICANON & ECHO flags.\n    '''\n\n    # Save the terminal settings\n    self.old_term = termios.tcgetattr(STDIN_FD)\n    self.new_term = self.old_term.copy()\n\n    # New terminal setting unbuffered\n    self.new_term[3] &= ~(termios.ICANON | termios.ECHO)\n    termios.tcsetattr(STDIN_FD, termios.TCSAFLUSH, self.new_term)\n\n    # Support normal-terminal reset at exit\n    atexit.register(self.set_normal_term)\n\n  def set_normal_term(self) -> None:\n    ''' Resets to normal terminal. On Windows this is a no-op.\n    '''\n\n    termios.tcsetattr(STDIN_FD, termios.TCSAFLUSH, self.old_term)\n\n  @staticmethod\n  def getch() -> str:\n    ''' Returns a keyboard character after kbhit() has been called.\n      Should not be called in the same program as getarrow().\n    '''\n    return sys.stdin.read(1)\n\n  @staticmethod\n  def getarrow() -> int:\n    ''' Returns an arrow-key code after kbhit() has been called. Codes are\n    0 : up\n    1 : right\n    2 : down\n    3 : left\n    Should not be called in the same program as getch().\n    '''\n\n    c = sys.stdin.read(3)[2]\n    vals = [65, 67, 66, 68]\n\n    return vals.index(ord(c))\n\n  @staticmethod\n  def kbhit():\n    ''' Returns True if keyboard character was hit, False otherwise.\n    '''\n    return select([sys.stdin], [], [], 0)[0] != []\n\n\n# Test\nif __name__ == \"__main__\":\n\n  kb = KBHit()\n\n  print('Hit any key, or ESC to exit')\n\n  while True:\n\n    if kb.kbhit():\n      c = kb.getch()\n      if c == '\\x1b':  # ESC\n        break\n      print(c)\n\n  kb.set_normal_term()\n", "tools/lib/filereader.py": "import os\nimport socket\nfrom urllib.parse import urlparse\n\nfrom openpilot.tools.lib.url_file import URLFile\n\nDATA_ENDPOINT = os.getenv(\"DATA_ENDPOINT\", \"http://data-raw.comma.internal/\")\n\n\ndef internal_source_available():\n  try:\n    hostname = urlparse(DATA_ENDPOINT).hostname\n    port = urlparse(DATA_ENDPOINT).port or 80\n    with socket.socket(socket.AF_INET,socket.SOCK_STREAM) as s:\n      s.connect((hostname, port))\n    return True\n  except (socket.gaierror, ConnectionRefusedError):\n    pass\n  return False\n\n\ndef resolve_name(fn):\n  if fn.startswith(\"cd:/\"):\n    return fn.replace(\"cd:/\", DATA_ENDPOINT)\n  return fn\n\n\ndef file_exists(fn):\n  fn = resolve_name(fn)\n  if fn.startswith((\"http://\", \"https://\")):\n    return URLFile(fn).get_length_online() != -1\n  return os.path.exists(fn)\n\n\ndef FileReader(fn, debug=False):\n  fn = resolve_name(fn)\n  if fn.startswith((\"http://\", \"https://\")):\n    return URLFile(fn, debug=debug)\n  return open(fn, \"rb\")\n", "tools/lib/framereader.py": "import json\nimport os\nimport pickle\nimport struct\nimport subprocess\nimport threading\nfrom enum import IntEnum\nfrom functools import wraps\n\nimport numpy as np\nfrom lru import LRU\n\nimport _io\nfrom openpilot.tools.lib.cache import cache_path_for_file_path, DEFAULT_CACHE_DIR\nfrom openpilot.tools.lib.exceptions import DataUnreadableError\nfrom openpilot.tools.lib.vidindex import hevc_index\nfrom openpilot.common.file_helpers import atomic_write_in_dir\n\nfrom openpilot.tools.lib.filereader import FileReader, resolve_name\n\nHEVC_SLICE_B = 0\nHEVC_SLICE_P = 1\nHEVC_SLICE_I = 2\n\n\nclass GOPReader:\n  def get_gop(self, num):\n    # returns (start_frame_num, num_frames, frames_to_skip, gop_data)\n    raise NotImplementedError\n\n\nclass DoNothingContextManager:\n  def __enter__(self):\n    return self\n\n  def __exit__(self, *x):\n    pass\n\n\nclass FrameType(IntEnum):\n  raw = 1\n  h265_stream = 2\n\n\ndef fingerprint_video(fn):\n  with FileReader(fn) as f:\n    header = f.read(4)\n  if len(header) == 0:\n    raise DataUnreadableError(f\"{fn} is empty\")\n  elif header == b\"\\x00\\xc0\\x12\\x00\":\n    return FrameType.raw\n  elif header == b\"\\x00\\x00\\x00\\x01\":\n    if 'hevc' in fn:\n      return FrameType.h265_stream\n    else:\n      raise NotImplementedError(fn)\n  else:\n    raise NotImplementedError(fn)\n\n\ndef ffprobe(fn, fmt=None):\n  fn = resolve_name(fn)\n  cmd = [\"ffprobe\", \"-v\", \"quiet\", \"-print_format\", \"json\", \"-show_format\", \"-show_streams\"]\n  if fmt:\n    cmd += [\"-f\", fmt]\n  cmd += [\"-i\", \"-\"]\n\n  try:\n    with FileReader(fn) as f:\n      ffprobe_output = subprocess.check_output(cmd, input=f.read(4096))\n  except subprocess.CalledProcessError as e:\n    raise DataUnreadableError(fn) from e\n\n  return json.loads(ffprobe_output)\n\n\ndef cache_fn(func):\n  @wraps(func)\n  def cache_inner(fn, *args, **kwargs):\n    if kwargs.pop('no_cache', None):\n      cache_path = None\n    else:\n      cache_dir = kwargs.pop('cache_dir', DEFAULT_CACHE_DIR)\n      cache_path = cache_path_for_file_path(fn, cache_dir)\n\n    if cache_path and os.path.exists(cache_path):\n      with open(cache_path, \"rb\") as cache_file:\n        cache_value = pickle.load(cache_file)\n    else:\n      cache_value = func(fn, *args, **kwargs)\n      if cache_path:\n        with atomic_write_in_dir(cache_path, mode=\"wb\", overwrite=True) as cache_file:\n          pickle.dump(cache_value, cache_file, -1)\n\n    return cache_value\n\n  return cache_inner\n\n\n@cache_fn\ndef index_stream(fn, ft):\n  if ft != FrameType.h265_stream:\n    raise NotImplementedError(\"Only h265 supported\")\n\n  frame_types, dat_len, prefix = hevc_index(fn)\n  index = np.array(frame_types + [(0xFFFFFFFF, dat_len)], dtype=np.uint32)\n  probe = ffprobe(fn, \"hevc\")\n\n  return {\n    'index': index,\n    'global_prefix': prefix,\n    'probe': probe\n  }\n\n\ndef get_video_index(fn, frame_type, cache_dir=DEFAULT_CACHE_DIR):\n  return index_stream(fn, frame_type, cache_dir=cache_dir)\n\ndef read_file_check_size(f, sz, cookie):\n  buff = bytearray(sz)\n  bytes_read = f.readinto(buff)\n  assert bytes_read == sz, (bytes_read, sz)\n  return buff\n\n\ndef rgb24toyuv(rgb):\n  yuv_from_rgb = np.array([[ 0.299     ,  0.587     ,  0.114      ],\n                           [-0.14714119, -0.28886916,  0.43601035 ],\n                           [ 0.61497538, -0.51496512, -0.10001026 ]])\n  img = np.dot(rgb.reshape(-1, 3), yuv_from_rgb.T).reshape(rgb.shape)\n\n\n\n  ys = img[:, :, 0]\n  us = (img[::2, ::2, 1] + img[1::2, ::2, 1] + img[::2, 1::2, 1] + img[1::2, 1::2, 1]) / 4 + 128\n  vs = (img[::2, ::2, 2] + img[1::2, ::2, 2] + img[::2, 1::2, 2] + img[1::2, 1::2, 2]) / 4 + 128\n\n  return ys, us, vs\n\n\ndef rgb24toyuv420(rgb):\n  ys, us, vs = rgb24toyuv(rgb)\n\n  y_len = rgb.shape[0] * rgb.shape[1]\n  uv_len = y_len // 4\n\n  yuv420 = np.empty(y_len + 2 * uv_len, dtype=rgb.dtype)\n  yuv420[:y_len] = ys.reshape(-1)\n  yuv420[y_len:y_len + uv_len] = us.reshape(-1)\n  yuv420[y_len + uv_len:y_len + 2 * uv_len] = vs.reshape(-1)\n\n  return yuv420.clip(0, 255).astype('uint8')\n\n\ndef rgb24tonv12(rgb):\n  ys, us, vs = rgb24toyuv(rgb)\n\n  y_len = rgb.shape[0] * rgb.shape[1]\n  uv_len = y_len // 4\n\n  nv12 = np.empty(y_len + 2 * uv_len, dtype=rgb.dtype)\n  nv12[:y_len] = ys.reshape(-1)\n  nv12[y_len::2] = us.reshape(-1)\n  nv12[y_len+1::2] = vs.reshape(-1)\n\n  return nv12.clip(0, 255).astype('uint8')\n\n\ndef decompress_video_data(rawdat, vid_fmt, w, h, pix_fmt):\n  threads = os.getenv(\"FFMPEG_THREADS\", \"0\")\n  cuda = os.getenv(\"FFMPEG_CUDA\", \"0\") == \"1\"\n  args = [\"ffmpeg\", \"-v\", \"quiet\",\n          \"-threads\", threads,\n          \"-hwaccel\", \"none\" if not cuda else \"cuda\",\n          \"-c:v\", \"hevc\",\n          \"-vsync\", \"0\",\n          \"-f\", vid_fmt,\n          \"-flags2\", \"showall\",\n          \"-i\", \"-\",\n          \"-threads\", threads,\n          \"-f\", \"rawvideo\",\n          \"-pix_fmt\", pix_fmt,\n          \"-\"]\n  dat = subprocess.check_output(args, input=rawdat)\n\n  if pix_fmt == \"rgb24\":\n    ret = np.frombuffer(dat, dtype=np.uint8).reshape(-1, h, w, 3)\n  elif pix_fmt == \"nv12\":\n    ret = np.frombuffer(dat, dtype=np.uint8).reshape(-1, (h*w*3//2))\n  elif pix_fmt == \"yuv420p\":\n    ret = np.frombuffer(dat, dtype=np.uint8).reshape(-1, (h*w*3//2))\n  elif pix_fmt == \"yuv444p\":\n    ret = np.frombuffer(dat, dtype=np.uint8).reshape(-1, 3, h, w)\n  else:\n    raise NotImplementedError\n\n  return ret\n\n\nclass BaseFrameReader:\n  # properties: frame_type, frame_count, w, h\n\n  def __enter__(self):\n    return self\n\n  def __exit__(self, *args):\n    self.close()\n\n  def close(self):\n    pass\n\n  def get(self, num, count=1, pix_fmt=\"yuv420p\"):\n    raise NotImplementedError\n\n\ndef FrameReader(fn, cache_dir=DEFAULT_CACHE_DIR, readahead=False, readbehind=False, index_data=None):\n  frame_type = fingerprint_video(fn)\n  if frame_type == FrameType.raw:\n    return RawFrameReader(fn)\n  elif frame_type in (FrameType.h265_stream,):\n    if not index_data:\n      index_data = get_video_index(fn, frame_type, cache_dir)\n    return StreamFrameReader(fn, frame_type, index_data, readahead=readahead, readbehind=readbehind)\n  else:\n    raise NotImplementedError(frame_type)\n\n\nclass RawData:\n  def __init__(self, f):\n    self.f = _io.FileIO(f, 'rb')\n    self.lenn = struct.unpack(\"I\", self.f.read(4))[0]\n    self.count = os.path.getsize(f) / (self.lenn+4)\n\n  def read(self, i):\n    self.f.seek((self.lenn+4)*i + 4)\n    return self.f.read(self.lenn)\n\n\nclass RawFrameReader(BaseFrameReader):\n  def __init__(self, fn):\n    # raw camera\n    self.fn = fn\n    self.frame_type = FrameType.raw\n    self.rawfile = RawData(self.fn)\n    self.frame_count = self.rawfile.count\n    self.w, self.h = 640, 480\n\n  def load_and_debayer(self, img):\n    img = np.frombuffer(img, dtype='uint8').reshape(960, 1280)\n    cimg = np.dstack([img[0::2, 1::2], ((img[0::2, 0::2].astype(\"uint16\") + img[1::2, 1::2].astype(\"uint16\")) >> 1).astype(\"uint8\"), img[1::2, 0::2]])\n    return cimg\n\n  def get(self, num, count=1, pix_fmt=\"yuv420p\"):\n    assert self.frame_count is not None\n    assert num+count <= self.frame_count\n\n    if pix_fmt not in (\"nv12\", \"yuv420p\", \"rgb24\"):\n      raise ValueError(f\"Unsupported pixel format {pix_fmt!r}\")\n\n    app = []\n    for i in range(num, num+count):\n      dat = self.rawfile.read(i)\n      rgb_dat = self.load_and_debayer(dat)\n      if pix_fmt == \"rgb24\":\n        app.append(rgb_dat)\n      elif pix_fmt == \"nv12\":\n        app.append(rgb24tonv12(rgb_dat))\n      elif pix_fmt == \"yuv420p\":\n        app.append(rgb24toyuv420(rgb_dat))\n      else:\n        raise NotImplementedError\n\n    return app\n\n\nclass VideoStreamDecompressor:\n  def __init__(self, fn, vid_fmt, w, h, pix_fmt):\n    self.fn = fn\n    self.vid_fmt = vid_fmt\n    self.w = w\n    self.h = h\n    self.pix_fmt = pix_fmt\n\n    if pix_fmt in (\"nv12\", \"yuv420p\"):\n      self.out_size = w*h*3//2  # yuv420p\n    elif pix_fmt in (\"rgb24\", \"yuv444p\"):\n      self.out_size = w*h*3\n    else:\n      raise NotImplementedError\n\n    self.proc = None\n    self.t = threading.Thread(target=self.write_thread)\n    self.t.daemon = True\n\n  def write_thread(self):\n    try:\n      with FileReader(self.fn) as f:\n        while True:\n          r = f.read(1024*1024)\n          if len(r) == 0:\n            break\n          self.proc.stdin.write(r)\n    except BrokenPipeError:\n      pass\n    finally:\n      self.proc.stdin.close()\n\n  def read(self):\n    threads = os.getenv(\"FFMPEG_THREADS\", \"0\")\n    cuda = os.getenv(\"FFMPEG_CUDA\", \"0\") == \"1\"\n    cmd = [\n      \"ffmpeg\",\n      \"-threads\", threads,\n      \"-hwaccel\", \"none\" if not cuda else \"cuda\",\n      \"-c:v\", \"hevc\",\n      # \"-avioflags\", \"direct\",\n      \"-analyzeduration\", \"0\",\n      \"-probesize\", \"32\",\n      \"-flush_packets\", \"0\",\n      # \"-fflags\", \"nobuffer\",\n      \"-vsync\", \"0\",\n      \"-f\", self.vid_fmt,\n      \"-i\", \"pipe:0\",\n      \"-threads\", threads,\n      \"-f\", \"rawvideo\",\n      \"-pix_fmt\", self.pix_fmt,\n      \"pipe:1\"\n    ]\n    self.proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)\n    try:\n      self.t.start()\n\n      while True:\n        dat = self.proc.stdout.read(self.out_size)\n        if len(dat) == 0:\n          break\n        assert len(dat) == self.out_size\n        if self.pix_fmt == \"rgb24\":\n          ret = np.frombuffer(dat, dtype=np.uint8).reshape((self.h, self.w, 3))\n        elif self.pix_fmt == \"yuv420p\":\n          ret = np.frombuffer(dat, dtype=np.uint8)\n        elif self.pix_fmt == \"nv12\":\n          ret = np.frombuffer(dat, dtype=np.uint8)\n        elif self.pix_fmt == \"yuv444p\":\n          ret = np.frombuffer(dat, dtype=np.uint8).reshape((3, self.h, self.w))\n        else:\n          raise RuntimeError(f\"unknown pix_fmt: {self.pix_fmt}\")\n        yield ret\n\n      result_code = self.proc.wait()\n      assert result_code == 0, result_code\n    finally:\n      self.proc.kill()\n      self.t.join()\n\nclass StreamGOPReader(GOPReader):\n  def __init__(self, fn, frame_type, index_data):\n    assert frame_type == FrameType.h265_stream\n\n    self.fn = fn\n\n    self.frame_type = frame_type\n    self.frame_count = None\n    self.w, self.h = None, None\n\n    self.prefix = None\n    self.index = None\n\n    self.index = index_data['index']\n    self.prefix = index_data['global_prefix']\n    probe = index_data['probe']\n\n    self.prefix_frame_data = None\n    self.num_prefix_frames = 0\n    self.vid_fmt = \"hevc\"\n\n    i = 0\n    while i < self.index.shape[0] and self.index[i, 0] != HEVC_SLICE_I:\n      i += 1\n    self.first_iframe = i\n\n    assert self.first_iframe == 0\n\n    self.frame_count = len(self.index) - 1\n\n    self.w = probe['streams'][0]['width']\n    self.h = probe['streams'][0]['height']\n\n  def _lookup_gop(self, num):\n    frame_b = num\n    while frame_b > 0 and self.index[frame_b, 0] != HEVC_SLICE_I:\n      frame_b -= 1\n\n    frame_e = num + 1\n    while frame_e < (len(self.index) - 1) and self.index[frame_e, 0] != HEVC_SLICE_I:\n      frame_e += 1\n\n    offset_b = self.index[frame_b, 1]\n    offset_e = self.index[frame_e, 1]\n\n    return (frame_b, frame_e, offset_b, offset_e)\n\n  def get_gop(self, num):\n    frame_b, frame_e, offset_b, offset_e = self._lookup_gop(num)\n    assert frame_b <= num < frame_e\n\n    num_frames = frame_e - frame_b\n\n    with FileReader(self.fn) as f:\n      f.seek(offset_b)\n      rawdat = f.read(offset_e - offset_b)\n\n      if num < self.first_iframe:\n        assert self.prefix_frame_data\n        rawdat = self.prefix_frame_data + rawdat\n\n      rawdat = self.prefix + rawdat\n\n    skip_frames = 0\n    if num < self.first_iframe:\n      skip_frames = self.num_prefix_frames\n\n    return frame_b, num_frames, skip_frames, rawdat\n\n\nclass GOPFrameReader(BaseFrameReader):\n  #FrameReader with caching and readahead for formats that are group-of-picture based\n\n  def __init__(self, readahead=False, readbehind=False):\n    self.open_ = True\n\n    self.readahead = readahead\n    self.readbehind = readbehind\n    self.frame_cache = LRU(64)\n\n    if self.readahead:\n      self.cache_lock = threading.RLock()\n      self.readahead_last = None\n      self.readahead_len = 30\n      self.readahead_c = threading.Condition()\n      self.readahead_thread = threading.Thread(target=self._readahead_thread)\n      self.readahead_thread.daemon = True\n      self.readahead_thread.start()\n    else:\n      self.cache_lock = DoNothingContextManager()\n\n  def close(self):\n    if not self.open_:\n      return\n    self.open_ = False\n\n    if self.readahead:\n      self.readahead_c.acquire()\n      self.readahead_c.notify()\n      self.readahead_c.release()\n      self.readahead_thread.join()\n\n  def _readahead_thread(self):\n    while True:\n      self.readahead_c.acquire()\n      try:\n        if not self.open_:\n          break\n        self.readahead_c.wait()\n      finally:\n        self.readahead_c.release()\n      if not self.open_:\n        break\n      assert self.readahead_last\n      num, pix_fmt = self.readahead_last\n\n      if self.readbehind:\n        for k in range(num - 1, max(0, num - self.readahead_len), -1):\n          self._get_one(k, pix_fmt)\n      else:\n        for k in range(num, min(self.frame_count, num + self.readahead_len)):\n          self._get_one(k, pix_fmt)\n\n  def _get_one(self, num, pix_fmt):\n    assert num < self.frame_count\n\n    if (num, pix_fmt) in self.frame_cache:\n      return self.frame_cache[(num, pix_fmt)]\n\n    with self.cache_lock:\n      if (num, pix_fmt) in self.frame_cache:\n        return self.frame_cache[(num, pix_fmt)]\n\n      frame_b, num_frames, skip_frames, rawdat = self.get_gop(num)\n\n      ret = decompress_video_data(rawdat, self.vid_fmt, self.w, self.h, pix_fmt)\n      ret = ret[skip_frames:]\n      assert ret.shape[0] == num_frames\n\n      for i in range(ret.shape[0]):\n        self.frame_cache[(frame_b+i, pix_fmt)] = ret[i]\n\n      return self.frame_cache[(num, pix_fmt)]\n\n  def get(self, num, count=1, pix_fmt=\"yuv420p\"):\n    assert self.frame_count is not None\n\n    if num + count > self.frame_count:\n      raise ValueError(f\"{num + count} > {self.frame_count}\")\n\n    if pix_fmt not in (\"nv12\", \"yuv420p\", \"rgb24\", \"yuv444p\"):\n      raise ValueError(f\"Unsupported pixel format {pix_fmt!r}\")\n\n    ret = [self._get_one(num + i, pix_fmt) for i in range(count)]\n\n    if self.readahead:\n      self.readahead_last = (num+count, pix_fmt)\n      self.readahead_c.acquire()\n      self.readahead_c.notify()\n      self.readahead_c.release()\n\n    return ret\n\n\nclass StreamFrameReader(StreamGOPReader, GOPFrameReader):\n  def __init__(self, fn, frame_type, index_data, readahead=False, readbehind=False):\n    StreamGOPReader.__init__(self, fn, frame_type, index_data)\n    GOPFrameReader.__init__(self, readahead, readbehind)\n\n\ndef GOPFrameIterator(gop_reader, pix_fmt):\n  dec = VideoStreamDecompressor(gop_reader.fn, gop_reader.vid_fmt, gop_reader.w, gop_reader.h, pix_fmt)\n  yield from dec.read()\n\n\ndef FrameIterator(fn, pix_fmt, **kwargs):\n  fr = FrameReader(fn, **kwargs)\n  if isinstance(fr, GOPReader):\n    yield from GOPFrameIterator(fr, pix_fmt)\n  else:\n    for i in range(fr.frame_count):\n      yield fr.get(i, pix_fmt=pix_fmt)[0]\n", "tools/lib/auth_config.py": "import json\nimport os\nfrom openpilot.system.hardware.hw import Paths\n\n\nclass MissingAuthConfigError(Exception):\n  pass\n\n\ndef get_token():\n  try:\n    with open(os.path.join(Paths.config_root(), 'auth.json')) as f:\n      auth = json.load(f)\n      return auth['access_token']\n  except Exception:\n    return None\n\n\ndef set_token(token):\n  os.makedirs(Paths.config_root(), exist_ok=True)\n  with open(os.path.join(Paths.config_root(), 'auth.json'), 'w') as f:\n    json.dump({'access_token': token}, f)\n\n\ndef clear_token():\n  try:\n    os.unlink(os.path.join(Paths.config_root(), 'auth.json'))\n  except FileNotFoundError:\n    pass\n", "tools/latencylogger/latency_logger.py": "#!/usr/bin/env python3\nimport argparse\nimport json\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport mpld3\nimport sys\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\n\nfrom openpilot.tools.lib.logreader import LogReader\n\nDEMO_ROUTE = \"9f583b1d93915c31|2022-05-18--10-49-51--0\"\n\nSERVICES = ['camerad', 'modeld', 'plannerd', 'controlsd', 'pandad']\nMONOTIME_KEYS = ['modelMonoTime', 'lateralPlanMonoTime']\nMSGQ_TO_SERVICE = {\n  'roadCameraState': 'camerad',\n  'wideRoadCameraState': 'camerad',\n  'modelV2': 'modeld',\n  'longitudinalPlan': 'plannerd',\n  'sendcan': 'controlsd',\n  'controlsState': 'controlsd'\n}\nSERVICE_TO_DURATIONS = {\n  'camerad': ['processingTime'],\n  'modeld': ['modelExecutionTime', 'gpuExecutionTime'],\n  'plannerd': ['solverExecutionTime'],\n}\n\ndef read_logs(lr):\n  data = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\n  mono_to_frame = {}\n  frame_mismatches = []\n  frame_id_fails = 0\n  latest_sendcan_monotime = 0\n  for msg in lr:\n    if msg.which() == 'sendcan':\n      latest_sendcan_monotime = msg.logMonoTime\n      continue\n\n    if msg.which() in MSGQ_TO_SERVICE:\n      service = MSGQ_TO_SERVICE[msg.which()]\n      msg_obj = getattr(msg, msg.which())\n\n      frame_id = -1\n      if hasattr(msg_obj, \"frameId\"):\n        frame_id = msg_obj.frameId\n      else:\n        continue_outer = False\n        for key in MONOTIME_KEYS:\n          if hasattr(msg_obj, key):\n            if getattr(msg_obj, key) == 0:\n              # Filter out controlsd messages which arrive before the camera loop\n              continue_outer = True\n            elif getattr(msg_obj, key) in mono_to_frame:\n              frame_id = mono_to_frame[getattr(msg_obj, key)]\n        if continue_outer:\n          continue\n      if frame_id == -1:\n        frame_id_fails += 1\n        continue\n      mono_to_frame[msg.logMonoTime] = frame_id\n      data['timestamp'][frame_id][service].append((msg.which()+\" published\", msg.logMonoTime))\n\n      next_service = SERVICES[SERVICES.index(service)+1]\n      if not data['start'][frame_id][next_service]:\n        data['start'][frame_id][next_service] = msg.logMonoTime\n      data['end'][frame_id][service] = msg.logMonoTime\n\n      if service in SERVICE_TO_DURATIONS:\n        for duration in SERVICE_TO_DURATIONS[service]:\n          data['duration'][frame_id][service].append((msg.which()+\".\"+duration, getattr(msg_obj, duration)))\n\n      if service == SERVICES[0]:\n        data['timestamp'][frame_id][service].append((msg.which()+\" start of frame\", msg_obj.timestampSof))\n        if not data['start'][frame_id][service]:\n          data['start'][frame_id][service] = msg_obj.timestampSof\n      elif msg.which() == 'controlsState':\n        # Sendcan is published before controlsState, but the frameId is retrieved in CS\n        data['timestamp'][frame_id][service].append((\"sendcan published\", latest_sendcan_monotime))\n      elif msg.which() == 'modelV2':\n        if msg_obj.frameIdExtra != frame_id:\n          frame_mismatches.append(frame_id)\n\n  if frame_id_fails > 20:\n    print(\"Warning, many frameId fetch fails\", frame_id_fails)\n  if len(frame_mismatches) > 20:\n    print(\"Warning, many frame mismatches\", len(frame_mismatches))\n  return (data, frame_mismatches)\n\n# This is not needed in 3.10 as a \"key\" parameter is added to bisect\nclass KeyifyList:\n  def __init__(self, inner, key):\n    self.inner = inner\n    self.key = key\n  def __len__(self):\n    return len(self.inner)\n  def __getitem__(self, k):\n    return self.key(self.inner[k])\n\ndef find_frame_id(time, service, start_times, end_times):\n  left = bisect_left(KeyifyList(list(start_times.items()),\n                     lambda x: x[1][service] if x[1][service] else -1), time) - 1\n  right = bisect_right(KeyifyList(list(end_times.items()),\n                      lambda x: x[1][service] if x[1][service] else float(\"inf\")), time)\n  return left, right\n\ndef find_t0(start_times, frame_id=-1):\n  frame_id = frame_id if frame_id > -1 else min(start_times.keys())\n  m = max(start_times.keys())\n  while frame_id <= m:\n    for service in SERVICES:\n      if start_times[frame_id][service]:\n        return start_times[frame_id][service]\n    frame_id += 1\n  raise Exception('No start time has been set')\n\ndef insert_cloudlogs(lr, timestamps, start_times, end_times):\n  # at least one cloudlog must be made in controlsd\n\n  t0 = find_t0(start_times)\n  failed_inserts = 0\n  latest_controls_frameid = 0\n  for msg in lr:\n    if msg.which() == \"logMessage\":\n      jmsg = json.loads(msg.logMessage)\n      if \"timestamp\" in jmsg['msg']:\n        time = int(jmsg['msg']['timestamp']['time'])\n        service = jmsg['ctx']['daemon']\n        event = jmsg['msg']['timestamp']['event']\n        if time < t0:\n          # Filter out controlsd messages which arrive before the camera loop\n          continue\n\n        if \"frame_id\" in jmsg['msg']['timestamp']:\n          timestamps[int(jmsg['msg']['timestamp']['frame_id'])][service].append((event, time))\n          continue\n\n        if service == \"pandad\":\n          timestamps[latest_controls_frameid][service].append((event, time))\n          end_times[latest_controls_frameid][service] = time\n        else:\n          frame_id = find_frame_id(time, service, start_times, end_times)\n          if frame_id:\n            if frame_id[0] != frame_id[1]:\n              event += \" (warning: ambiguity)\"\n            frame_id = frame_id[0]\n            if service == 'controlsd':\n              latest_controls_frameid = frame_id\n            timestamps[frame_id][service].append((event, time))\n          else:\n            failed_inserts += 1\n\n  if latest_controls_frameid == 0:\n    print(\"Warning: failed to bind pandad logs to a frame ID. Add a timestamp cloudlog in controlsd.\")\n  elif failed_inserts > len(timestamps):\n    print(f\"Warning: failed to bind {failed_inserts} cloudlog timestamps to a frame ID\")\n\ndef print_timestamps(timestamps, durations, start_times, relative):\n  t0 = find_t0(start_times)\n  for frame_id in timestamps.keys():\n    print('='*80)\n    print(\"Frame ID:\", frame_id)\n    if relative:\n      t0 = find_t0(start_times, frame_id)\n\n    for service in SERVICES:\n      print(\"  \"+service)\n      events = timestamps[frame_id][service]\n      for event, time in sorted(events, key = lambda x: x[1]):\n        print(\"    \"+'%-53s%-53s' %(event, str((time-t0)/1e6)))\n      for event, time in durations[frame_id][service]:\n        print(\"    \"+'%-53s%-53s' %(event, str(time*1000)))\n\ndef graph_timestamps(timestamps, start_times, end_times, relative, offset_services=False, title=\"\"):\n  # mpld3 doesn't convert properly to D3 font sizes\n  plt.rcParams.update({'font.size': 18})\n\n  t0 = find_t0(start_times)\n  fig, ax = plt.subplots()\n  ax.set_xlim(0, 130 if relative else 750)\n  ax.set_ylim(0, 17)\n  ax.set_xlabel('Time (milliseconds)')\n  colors = ['blue', 'green', 'red', 'yellow', 'purple']\n  offsets = [[0, -5*j] for j in range(len(SERVICES))] if offset_services else None\n  height = 0.3 if offset_services else 0.9\n  assert len(colors) == len(SERVICES), 'Each service needs a color'\n\n  points = {\"x\": [], \"y\": [], \"labels\": []}\n  for i, (frame_id, services) in enumerate(timestamps.items()):\n    if relative:\n      t0 = find_t0(start_times, frame_id)\n    service_bars = []\n    for service, events in services.items():\n      if start_times[frame_id][service] and end_times[frame_id][service]:\n        start = start_times[frame_id][service]\n        end = end_times[frame_id][service]\n        service_bars.append(((start-t0)/1e6,(end-start)/1e6))\n        for event in events:\n          points['x'].append((event[1]-t0)/1e6)\n          points['y'].append(i)\n          points['labels'].append(event[0])\n    ax.broken_barh(service_bars, (i-height/2, height), facecolors=(colors), alpha=0.5, offsets=offsets)\n\n  scatter = ax.scatter(points['x'], points['y'], marker='d', edgecolor='black')\n  tooltip = mpld3.plugins.PointLabelTooltip(scatter, labels=points['labels'])\n  mpld3.plugins.connect(fig, tooltip)\n\n  plt.title(title)\n  # Set size relative window size is not trivial: https://github.com/mpld3/mpld3/issues/65\n  fig.set_size_inches(18, 9)\n  plt.legend(handles=[mpatches.Patch(color=colors[i], label=SERVICES[i]) for i in range(len(SERVICES))])\n  return fig\n\ndef get_timestamps(lr):\n  lr = list(lr)\n  data, frame_mismatches = read_logs(lr)\n  insert_cloudlogs(lr, data['timestamp'], data['start'], data['end'])\n  return data, frame_mismatches\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"A tool for analyzing openpilot's end-to-end latency\",\n                                   formatter_class = argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"--relative\", action=\"store_true\", help=\"Make timestamps relative to the start of each frame\")\n  parser.add_argument(\"--demo\", action=\"store_true\", help=\"Use the demo route instead of providing one\")\n  parser.add_argument(\"--plot\", action=\"store_true\", help=\"If a plot should be generated\")\n  parser.add_argument(\"--offset\", action=\"store_true\", help=\"Vertically offset service to better visualize overlap\")\n  parser.add_argument(\"route_or_segment_name\", nargs='?', help=\"The route to print\")\n\n  if len(sys.argv) == 1:\n    parser.print_help()\n    sys.exit()\n  args = parser.parse_args()\n\n  r = DEMO_ROUTE if args.demo else args.route_or_segment_name.strip()\n  lr = LogReader(r, sort_by_time=True)\n\n  data, _ = get_timestamps(lr)\n  print_timestamps(data['timestamp'], data['duration'], data['start'], args.relative)\n  if args.plot:\n    mpld3.show(graph_timestamps(data['timestamp'], data['start'], data['end'], args.relative, offset_services=args.offset, title=r))\n", "selfdrive/__init__.py": "", "selfdrive/locationd/paramsd.py": "#!/usr/bin/env python3\nimport os\nimport math\nimport json\nimport numpy as np\n\nimport cereal.messaging as messaging\nfrom cereal import car\nfrom cereal import log\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import config_realtime_process, DT_MDL\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.selfdrive.locationd.models.car_kf import CarKalman, ObservationKind, States\nfrom openpilot.selfdrive.locationd.models.constants import GENERATED_DIR\nfrom openpilot.common.swaglog import cloudlog\n\n\nMAX_ANGLE_OFFSET_DELTA = 20 * DT_MDL  # Max 20 deg/s\nROLL_MAX_DELTA = math.radians(20.0) * DT_MDL  # 20deg in 1 second is well within curvature limits\nROLL_MIN, ROLL_MAX = math.radians(-10), math.radians(10)\nROLL_LOWERED_MAX = math.radians(8)\nROLL_STD_MAX = math.radians(1.5)\nLATERAL_ACC_SENSOR_THRESHOLD = 4.0\nOFFSET_MAX = 10.0\nOFFSET_LOWERED_MAX = 8.0\nMIN_ACTIVE_SPEED = 1.0\nLOW_ACTIVE_SPEED = 10.0\n\n\nclass ParamsLearner:\n  def __init__(self, CP, steer_ratio, stiffness_factor, angle_offset, P_initial=None):\n    self.kf = CarKalman(GENERATED_DIR, steer_ratio, stiffness_factor, angle_offset, P_initial)\n\n    self.kf.filter.set_global(\"mass\", CP.mass)\n    self.kf.filter.set_global(\"rotational_inertia\", CP.rotationalInertia)\n    self.kf.filter.set_global(\"center_to_front\", CP.centerToFront)\n    self.kf.filter.set_global(\"center_to_rear\", CP.wheelbase - CP.centerToFront)\n    self.kf.filter.set_global(\"stiffness_front\", CP.tireStiffnessFront)\n    self.kf.filter.set_global(\"stiffness_rear\", CP.tireStiffnessRear)\n\n    self.active = False\n\n    self.speed = 0.0\n    self.yaw_rate = 0.0\n    self.yaw_rate_std = 0.0\n    self.roll = 0.0\n    self.steering_angle = 0.0\n    self.roll_valid = False\n\n  def handle_log(self, t, which, msg):\n    if which == 'liveLocationKalman':\n      self.yaw_rate = msg.angularVelocityCalibrated.value[2]\n      self.yaw_rate_std = msg.angularVelocityCalibrated.std[2]\n\n      localizer_roll = msg.orientationNED.value[0]\n      localizer_roll_std = np.radians(1) if np.isnan(msg.orientationNED.std[0]) else msg.orientationNED.std[0]\n      self.roll_valid = (localizer_roll_std < ROLL_STD_MAX) and (ROLL_MIN < localizer_roll < ROLL_MAX) and msg.sensorsOK\n      if self.roll_valid:\n        roll = localizer_roll\n        # Experimentally found multiplier of 2 to be best trade-off between stability and accuracy or similar?\n        roll_std = 2 * localizer_roll_std\n      else:\n        # This is done to bound the road roll estimate when localizer values are invalid\n        roll = 0.0\n        roll_std = np.radians(10.0)\n      self.roll = clip(roll, self.roll - ROLL_MAX_DELTA, self.roll + ROLL_MAX_DELTA)\n\n      yaw_rate_valid = msg.angularVelocityCalibrated.valid\n      yaw_rate_valid = yaw_rate_valid and 0 < self.yaw_rate_std < 10  # rad/s\n      yaw_rate_valid = yaw_rate_valid and abs(self.yaw_rate) < 1  # rad/s\n\n      if self.active:\n        if msg.posenetOK:\n\n          if yaw_rate_valid:\n            self.kf.predict_and_observe(t,\n                                        ObservationKind.ROAD_FRAME_YAW_RATE,\n                                        np.array([[-self.yaw_rate]]),\n                                        np.array([np.atleast_2d(self.yaw_rate_std**2)]))\n\n          self.kf.predict_and_observe(t,\n                                      ObservationKind.ROAD_ROLL,\n                                      np.array([[self.roll]]),\n                                      np.array([np.atleast_2d(roll_std**2)]))\n        self.kf.predict_and_observe(t, ObservationKind.ANGLE_OFFSET_FAST, np.array([[0]]))\n\n        # We observe the current stiffness and steer ratio (with a high observation noise) to bound\n        # the respective estimate STD. Otherwise the STDs keep increasing, causing rapid changes in the\n        # states in longer routes (especially straight stretches).\n        stiffness = float(self.kf.x[States.STIFFNESS].item())\n        steer_ratio = float(self.kf.x[States.STEER_RATIO].item())\n        self.kf.predict_and_observe(t, ObservationKind.STIFFNESS, np.array([[stiffness]]))\n        self.kf.predict_and_observe(t, ObservationKind.STEER_RATIO, np.array([[steer_ratio]]))\n\n    elif which == 'carState':\n      self.steering_angle = msg.steeringAngleDeg\n      self.speed = msg.vEgo\n\n      in_linear_region = abs(self.steering_angle) < 45\n      self.active = self.speed > MIN_ACTIVE_SPEED and in_linear_region\n\n      if self.active:\n        self.kf.predict_and_observe(t, ObservationKind.STEER_ANGLE, np.array([[math.radians(msg.steeringAngleDeg)]]))\n        self.kf.predict_and_observe(t, ObservationKind.ROAD_FRAME_X_SPEED, np.array([[self.speed]]))\n\n    if not self.active:\n      # Reset time when stopped so uncertainty doesn't grow\n      self.kf.filter.set_filter_time(t)\n      self.kf.filter.reset_rewind()\n\n\ndef check_valid_with_hysteresis(current_valid: bool, val: float, threshold: float, lowered_threshold: float):\n  if current_valid:\n    current_valid = abs(val) < threshold\n  else:\n    current_valid = abs(val) < lowered_threshold\n  return current_valid\n\n\ndef main():\n  config_realtime_process([0, 1, 2, 3], 5)\n\n  DEBUG = bool(int(os.getenv(\"DEBUG\", \"0\")))\n  REPLAY = bool(int(os.getenv(\"REPLAY\", \"0\")))\n\n  pm = messaging.PubMaster(['liveParameters'])\n  sm = messaging.SubMaster(['liveLocationKalman', 'carState'], poll='liveLocationKalman')\n\n  params_reader = Params()\n  # wait for stats about the car to come in from controls\n  cloudlog.info(\"paramsd is waiting for CarParams\")\n  with car.CarParams.from_bytes(params_reader.get(\"CarParams\", block=True)) as msg:\n    CP = msg\n  cloudlog.info(\"paramsd got CarParams\")\n\n  min_sr, max_sr = 0.5 * CP.steerRatio, 2.0 * CP.steerRatio\n\n  params = params_reader.get(\"LiveParameters\")\n\n  # Check if car model matches\n  if params is not None:\n    params = json.loads(params)\n    if params.get('carFingerprint', None) != CP.carFingerprint:\n      cloudlog.info(\"Parameter learner found parameters for wrong car.\")\n      params = None\n\n  # Check if starting values are sane\n  if params is not None:\n    try:\n      steer_ratio_sane = min_sr <= params['steerRatio'] <= max_sr\n      if not steer_ratio_sane:\n        cloudlog.info(f\"Invalid starting values found {params}\")\n        params = None\n    except Exception as e:\n      cloudlog.info(f\"Error reading params {params}: {str(e)}\")\n      params = None\n\n  # TODO: cache the params with the capnp struct\n  if params is None:\n    params = {\n      'carFingerprint': CP.carFingerprint,\n      'steerRatio': CP.steerRatio,\n      'stiffnessFactor': 1.0,\n      'angleOffsetAverageDeg': 0.0,\n    }\n    cloudlog.info(\"Parameter learner resetting to default values\")\n\n  if not REPLAY:\n    # When driving in wet conditions the stiffness can go down, and then be too low on the next drive\n    # Without a way to detect this we have to reset the stiffness every drive\n    params['stiffnessFactor'] = 1.0\n\n  pInitial = None\n  if DEBUG:\n    pInitial = np.array(params['filterState']['std']) if 'filterState' in params else None\n\n  learner = ParamsLearner(CP, params['steerRatio'], params['stiffnessFactor'], math.radians(params['angleOffsetAverageDeg']), pInitial)\n  angle_offset_average = params['angleOffsetAverageDeg']\n  angle_offset = angle_offset_average\n  roll = 0.0\n  avg_offset_valid = True\n  total_offset_valid = True\n  roll_valid = True\n\n  while True:\n    sm.update()\n    if sm.all_checks():\n      for which in sorted(sm.updated.keys(), key=lambda x: sm.logMonoTime[x]):\n        if sm.updated[which]:\n          t = sm.logMonoTime[which] * 1e-9\n          learner.handle_log(t, which, sm[which])\n\n    if sm.updated['liveLocationKalman']:\n      x = learner.kf.x\n      P = np.sqrt(learner.kf.P.diagonal())\n      if not all(map(math.isfinite, x)):\n        cloudlog.error(\"NaN in liveParameters estimate. Resetting to default values\")\n        learner = ParamsLearner(CP, CP.steerRatio, 1.0, 0.0)\n        x = learner.kf.x\n\n      angle_offset_average = clip(math.degrees(x[States.ANGLE_OFFSET].item()),\n                                  angle_offset_average - MAX_ANGLE_OFFSET_DELTA, angle_offset_average + MAX_ANGLE_OFFSET_DELTA)\n      angle_offset = clip(math.degrees(x[States.ANGLE_OFFSET].item() + x[States.ANGLE_OFFSET_FAST].item()),\n                          angle_offset - MAX_ANGLE_OFFSET_DELTA, angle_offset + MAX_ANGLE_OFFSET_DELTA)\n      roll = clip(float(x[States.ROAD_ROLL].item()), roll - ROLL_MAX_DELTA, roll + ROLL_MAX_DELTA)\n      roll_std = float(P[States.ROAD_ROLL].item())\n      if learner.active and learner.speed > LOW_ACTIVE_SPEED:\n        # Account for the opposite signs of the yaw rates\n        # At low speeds, bumping into a curb can cause the yaw rate to be very high\n        sensors_valid = bool(abs(learner.speed * (x[States.YAW_RATE].item() + learner.yaw_rate)) < LATERAL_ACC_SENSOR_THRESHOLD)\n      else:\n        sensors_valid = True\n      avg_offset_valid = check_valid_with_hysteresis(avg_offset_valid, angle_offset_average, OFFSET_MAX, OFFSET_LOWERED_MAX)\n      total_offset_valid = check_valid_with_hysteresis(total_offset_valid, angle_offset, OFFSET_MAX, OFFSET_LOWERED_MAX)\n      roll_valid = check_valid_with_hysteresis(roll_valid, roll, ROLL_MAX, ROLL_LOWERED_MAX)\n\n      msg = messaging.new_message('liveParameters')\n\n      liveParameters = msg.liveParameters\n      liveParameters.posenetValid = True\n      liveParameters.sensorValid = sensors_valid\n      liveParameters.steerRatio = float(x[States.STEER_RATIO].item())\n      liveParameters.stiffnessFactor = float(x[States.STIFFNESS].item())\n      liveParameters.roll = roll\n      liveParameters.angleOffsetAverageDeg = angle_offset_average\n      liveParameters.angleOffsetDeg = angle_offset\n      liveParameters.valid = all((\n        avg_offset_valid,\n        total_offset_valid,\n        roll_valid,\n        roll_std < ROLL_STD_MAX,\n        0.2 <= liveParameters.stiffnessFactor <= 5.0,\n        min_sr <= liveParameters.steerRatio <= max_sr,\n      ))\n      liveParameters.steerRatioStd = float(P[States.STEER_RATIO].item())\n      liveParameters.stiffnessFactorStd = float(P[States.STIFFNESS].item())\n      liveParameters.angleOffsetAverageStd = float(P[States.ANGLE_OFFSET].item())\n      liveParameters.angleOffsetFastStd = float(P[States.ANGLE_OFFSET_FAST].item())\n      if DEBUG:\n        liveParameters.filterState = log.LiveLocationKalman.Measurement.new_message()\n        liveParameters.filterState.value = x.tolist()\n        liveParameters.filterState.std = P.tolist()\n        liveParameters.filterState.valid = True\n\n      msg.valid = sm.all_checks()\n\n      if sm.frame % 1200 == 0:  # once a minute\n        params = {\n          'carFingerprint': CP.carFingerprint,\n          'steerRatio': liveParameters.steerRatio,\n          'stiffnessFactor': liveParameters.stiffnessFactor,\n          'angleOffsetAverageDeg': liveParameters.angleOffsetAverageDeg,\n        }\n        params_reader.put_nonblocking(\"LiveParameters\", json.dumps(params))\n\n      pm.send('liveParameters', msg)\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/locationd/torqued.py": "#!/usr/bin/env python3\nimport numpy as np\nfrom collections import deque, defaultdict\n\nimport cereal.messaging as messaging\nfrom cereal import car, log\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import config_realtime_process, DT_MDL\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.selfdrive.controls.lib.vehicle_model import ACCELERATION_DUE_TO_GRAVITY\nfrom openpilot.selfdrive.locationd.helpers import PointBuckets, ParameterEstimator\n\nHISTORY = 5  # secs\nPOINTS_PER_BUCKET = 1500\nMIN_POINTS_TOTAL = 4000\nMIN_POINTS_TOTAL_QLOG = 600\nFIT_POINTS_TOTAL = 2000\nFIT_POINTS_TOTAL_QLOG = 600\nMIN_VEL = 15  # m/s\nFRICTION_FACTOR = 1.5  # ~85% of data coverage\nFACTOR_SANITY = 0.3\nFACTOR_SANITY_QLOG = 0.5\nFRICTION_SANITY = 0.5\nFRICTION_SANITY_QLOG = 0.8\nSTEER_MIN_THRESHOLD = 0.02\nMIN_FILTER_DECAY = 50\nMAX_FILTER_DECAY = 250\nLAT_ACC_THRESHOLD = 1\nSTEER_BUCKET_BOUNDS = [(-0.5, -0.3), (-0.3, -0.2), (-0.2, -0.1), (-0.1, 0), (0, 0.1), (0.1, 0.2), (0.2, 0.3), (0.3, 0.5)]\nMIN_BUCKET_POINTS = np.array([100, 300, 500, 500, 500, 500, 300, 100])\nMIN_ENGAGE_BUFFER = 2  # secs\n\nVERSION = 1  # bump this to invalidate old parameter caches\nALLOWED_CARS = ['toyota', 'hyundai']\n\n\ndef slope2rot(slope):\n  sin = np.sqrt(slope**2 / (slope**2 + 1))\n  cos = np.sqrt(1 / (slope**2 + 1))\n  return np.array([[cos, -sin], [sin, cos]])\n\n\nclass TorqueBuckets(PointBuckets):\n  def add_point(self, x, y):\n    for bound_min, bound_max in self.x_bounds:\n      if (x >= bound_min) and (x < bound_max):\n        self.buckets[(bound_min, bound_max)].append([x, 1.0, y])\n        break\n\n\nclass TorqueEstimator(ParameterEstimator):\n  def __init__(self, CP, decimated=False):\n    self.hist_len = int(HISTORY / DT_MDL)\n    self.lag = CP.steerActuatorDelay + .2   # from controlsd\n    if decimated:\n      self.min_bucket_points = MIN_BUCKET_POINTS / 10\n      self.min_points_total = MIN_POINTS_TOTAL_QLOG\n      self.fit_points = FIT_POINTS_TOTAL_QLOG\n      self.factor_sanity = FACTOR_SANITY_QLOG\n      self.friction_sanity = FRICTION_SANITY_QLOG\n\n    else:\n      self.min_bucket_points = MIN_BUCKET_POINTS\n      self.min_points_total = MIN_POINTS_TOTAL\n      self.fit_points = FIT_POINTS_TOTAL\n      self.factor_sanity = FACTOR_SANITY\n      self.friction_sanity = FRICTION_SANITY\n\n    self.offline_friction = 0.0\n    self.offline_latAccelFactor = 0.0\n    self.resets = 0.0\n    self.use_params = CP.carName in ALLOWED_CARS and CP.lateralTuning.which() == 'torque'\n\n    if CP.lateralTuning.which() == 'torque':\n      self.offline_friction = CP.lateralTuning.torque.friction\n      self.offline_latAccelFactor = CP.lateralTuning.torque.latAccelFactor\n\n    self.reset()\n\n    initial_params = {\n      'latAccelFactor': self.offline_latAccelFactor,\n      'latAccelOffset': 0.0,\n      'frictionCoefficient': self.offline_friction,\n      'points': []\n    }\n    self.decay = MIN_FILTER_DECAY\n    self.min_lataccel_factor = (1.0 - self.factor_sanity) * self.offline_latAccelFactor\n    self.max_lataccel_factor = (1.0 + self.factor_sanity) * self.offline_latAccelFactor\n    self.min_friction = (1.0 - self.friction_sanity) * self.offline_friction\n    self.max_friction = (1.0 + self.friction_sanity) * self.offline_friction\n\n    # try to restore cached params\n    params = Params()\n    params_cache = params.get(\"CarParamsPrevRoute\")\n    torque_cache = params.get(\"LiveTorqueParameters\")\n    if params_cache is not None and torque_cache is not None:\n      try:\n        with log.Event.from_bytes(torque_cache) as log_evt:\n          cache_ltp = log_evt.liveTorqueParameters\n        with car.CarParams.from_bytes(params_cache) as msg:\n          cache_CP = msg\n        if self.get_restore_key(cache_CP, cache_ltp.version) == self.get_restore_key(CP, VERSION):\n          if cache_ltp.liveValid:\n            initial_params = {\n              'latAccelFactor': cache_ltp.latAccelFactorFiltered,\n              'latAccelOffset': cache_ltp.latAccelOffsetFiltered,\n              'frictionCoefficient': cache_ltp.frictionCoefficientFiltered\n            }\n          initial_params['points'] = cache_ltp.points\n          self.decay = cache_ltp.decay\n          self.filtered_points.load_points(initial_params['points'])\n          cloudlog.info(\"restored torque params from cache\")\n      except Exception:\n        cloudlog.exception(\"failed to restore cached torque params\")\n        params.remove(\"LiveTorqueParameters\")\n\n    self.filtered_params = {}\n    for param in initial_params:\n      self.filtered_params[param] = FirstOrderFilter(initial_params[param], self.decay, DT_MDL)\n\n  def get_restore_key(self, CP, version):\n    a, b = None, None\n    if CP.lateralTuning.which() == 'torque':\n      a = CP.lateralTuning.torque.friction\n      b = CP.lateralTuning.torque.latAccelFactor\n    return (CP.carFingerprint, CP.lateralTuning.which(), a, b, version)\n\n  def reset(self):\n    self.resets += 1.0\n    self.decay = MIN_FILTER_DECAY\n    self.raw_points = defaultdict(lambda: deque(maxlen=self.hist_len))\n    self.filtered_points = TorqueBuckets(x_bounds=STEER_BUCKET_BOUNDS,\n                                         min_points=self.min_bucket_points,\n                                         min_points_total=self.min_points_total,\n                                         points_per_bucket=POINTS_PER_BUCKET,\n                                         rowsize=3)\n\n  def estimate_params(self):\n    points = self.filtered_points.get_points(self.fit_points)\n    # total least square solution as both x and y are noisy observations\n    # this is empirically the slope of the hysteresis parallelogram as opposed to the line through the diagonals\n    try:\n      _, _, v = np.linalg.svd(points, full_matrices=False)\n      slope, offset = -v.T[0:2, 2] / v.T[2, 2]\n      _, spread = np.matmul(points[:, [0, 2]], slope2rot(slope)).T\n      friction_coeff = np.std(spread) * FRICTION_FACTOR\n    except np.linalg.LinAlgError as e:\n      cloudlog.exception(f\"Error computing live torque params: {e}\")\n      slope = offset = friction_coeff = np.nan\n    return slope, offset, friction_coeff\n\n  def update_params(self, params):\n    self.decay = min(self.decay + DT_MDL, MAX_FILTER_DECAY)\n    for param, value in params.items():\n      self.filtered_params[param].update(value)\n      self.filtered_params[param].update_alpha(self.decay)\n\n  def handle_log(self, t, which, msg):\n    if which == \"carControl\":\n      self.raw_points[\"carControl_t\"].append(t + self.lag)\n      self.raw_points[\"active\"].append(msg.latActive)\n    elif which == \"carOutput\":\n      self.raw_points[\"carOutput_t\"].append(t + self.lag)\n      self.raw_points[\"steer_torque\"].append(-msg.actuatorsOutput.steer)\n    elif which == \"carState\":\n      self.raw_points[\"carState_t\"].append(t + self.lag)\n      self.raw_points[\"vego\"].append(msg.vEgo)\n      self.raw_points[\"steer_override\"].append(msg.steeringPressed)\n    elif which == \"liveLocationKalman\":\n      if len(self.raw_points['steer_torque']) == self.hist_len:\n        yaw_rate = msg.angularVelocityCalibrated.value[2]\n        roll = msg.orientationNED.value[0]\n        active = np.interp(np.arange(t - MIN_ENGAGE_BUFFER, t, DT_MDL), self.raw_points['carControl_t'], self.raw_points['active']).astype(bool)\n        steer_override = np.interp(np.arange(t - MIN_ENGAGE_BUFFER, t, DT_MDL), self.raw_points['carState_t'], self.raw_points['steer_override']).astype(bool)\n        vego = np.interp(t, self.raw_points['carState_t'], self.raw_points['vego'])\n        steer = np.interp(t, self.raw_points['carOutput_t'], self.raw_points['steer_torque'])\n        lateral_acc = (vego * yaw_rate) - (np.sin(roll) * ACCELERATION_DUE_TO_GRAVITY)\n        if all(active) and (not any(steer_override)) and (vego > MIN_VEL) and (abs(steer) > STEER_MIN_THRESHOLD) and (abs(lateral_acc) <= LAT_ACC_THRESHOLD):\n          self.filtered_points.add_point(float(steer), float(lateral_acc))\n\n  def get_msg(self, valid=True, with_points=False):\n    msg = messaging.new_message('liveTorqueParameters')\n    msg.valid = valid\n    liveTorqueParameters = msg.liveTorqueParameters\n    liveTorqueParameters.version = VERSION\n    liveTorqueParameters.useParams = self.use_params\n\n    # Calculate raw estimates when possible, only update filters when enough points are gathered\n    if self.filtered_points.is_calculable():\n      latAccelFactor, latAccelOffset, frictionCoeff = self.estimate_params()\n      liveTorqueParameters.latAccelFactorRaw = float(latAccelFactor)\n      liveTorqueParameters.latAccelOffsetRaw = float(latAccelOffset)\n      liveTorqueParameters.frictionCoefficientRaw = float(frictionCoeff)\n\n      if self.filtered_points.is_valid():\n        if any(val is None or np.isnan(val) for val in [latAccelFactor, latAccelOffset, frictionCoeff]):\n          cloudlog.exception(\"Live torque parameters are invalid.\")\n          liveTorqueParameters.liveValid = False\n          self.reset()\n        else:\n          liveTorqueParameters.liveValid = True\n          latAccelFactor = np.clip(latAccelFactor, self.min_lataccel_factor, self.max_lataccel_factor)\n          frictionCoeff = np.clip(frictionCoeff, self.min_friction, self.max_friction)\n          self.update_params({'latAccelFactor': latAccelFactor, 'latAccelOffset': latAccelOffset, 'frictionCoefficient': frictionCoeff})\n\n    if with_points:\n      liveTorqueParameters.points = self.filtered_points.get_points()[:, [0, 2]].tolist()\n\n    liveTorqueParameters.latAccelFactorFiltered = float(self.filtered_params['latAccelFactor'].x)\n    liveTorqueParameters.latAccelOffsetFiltered = float(self.filtered_params['latAccelOffset'].x)\n    liveTorqueParameters.frictionCoefficientFiltered = float(self.filtered_params['frictionCoefficient'].x)\n    liveTorqueParameters.totalBucketPoints = len(self.filtered_points)\n    liveTorqueParameters.decay = self.decay\n    liveTorqueParameters.maxResets = self.resets\n    return msg\n\n\ndef main(demo=False):\n  config_realtime_process([0, 1, 2, 3], 5)\n\n  pm = messaging.PubMaster(['liveTorqueParameters'])\n  sm = messaging.SubMaster(['carControl', 'carOutput', 'carState', 'liveLocationKalman'], poll='liveLocationKalman')\n\n  params = Params()\n  with car.CarParams.from_bytes(params.get(\"CarParams\", block=True)) as CP:\n    estimator = TorqueEstimator(CP)\n\n  while True:\n    sm.update()\n    if sm.all_checks():\n      for which in sm.updated.keys():\n        if sm.updated[which]:\n          t = sm.logMonoTime[which] * 1e-9\n          estimator.handle_log(t, which, sm[which])\n\n    # 4Hz driven by liveLocationKalman\n    if sm.frame % 5 == 0:\n      pm.send('liveTorqueParameters', estimator.get_msg(valid=sm.all_checks()))\n\n    # Cache points every 60 seconds while onroad\n    if sm.frame % 240 == 0:\n      msg = estimator.get_msg(valid=sm.all_checks(), with_points=True)\n      params.put_nonblocking(\"LiveTorqueParameters\", msg.to_bytes())\n\nif __name__ == \"__main__\":\n  import argparse\n  parser = argparse.ArgumentParser(description='Process the --demo argument.')\n  parser.add_argument('--demo', action='store_true', help='A boolean for demo mode.')\n  args = parser.parse_args()\n  main(demo=args.demo)\n", "selfdrive/locationd/calibrationd.py": "#!/usr/bin/env python3\n'''\nThis process finds calibration values. More info on what these calibration values\nare can be found here https://github.com/commaai/openpilot/tree/master/common/transformations\nWhile the roll calibration is a real value that can be estimated, here we assume it's zero,\nand the image input into the neural network is not corrected for roll.\n'''\n\nimport gc\nimport os\nimport capnp\nimport numpy as np\nfrom typing import NoReturn\n\nfrom cereal import log\nimport cereal.messaging as messaging\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import set_realtime_priority\nfrom openpilot.common.transformations.orientation import rot_from_euler, euler_from_rot\nfrom openpilot.common.swaglog import cloudlog\n\nMIN_SPEED_FILTER = 15 * CV.MPH_TO_MS\nMAX_VEL_ANGLE_STD = np.radians(0.25)\nMAX_YAW_RATE_FILTER = np.radians(2)  # per second\n\nMAX_HEIGHT_STD = np.exp(-3.5)\n\n# This is at model frequency, blocks needed for efficiency\nSMOOTH_CYCLES = 10\nBLOCK_SIZE = 100\nINPUTS_NEEDED = 5   # Minimum blocks needed for valid calibration\nINPUTS_WANTED = 50   # We want a little bit more than we need for stability\nMAX_ALLOWED_YAW_SPREAD = np.radians(2)\nMAX_ALLOWED_PITCH_SPREAD = np.radians(4)\nRPY_INIT = np.array([0.0,0.0,0.0])\nWIDE_FROM_DEVICE_EULER_INIT = np.array([0.0, 0.0, 0.0])\nHEIGHT_INIT = np.array([1.22])\n\n# These values are needed to accommodate the model frame in the narrow cam of the C3\nPITCH_LIMITS = np.array([-0.09074112085129739, 0.17])\nYAW_LIMITS = np.array([-0.06912048084718224, 0.06912048084718235])\nDEBUG = os.getenv(\"DEBUG\") is not None\n\n\ndef is_calibration_valid(rpy: np.ndarray) -> bool:\n  return (PITCH_LIMITS[0] < rpy[1] < PITCH_LIMITS[1]) and (YAW_LIMITS[0] < rpy[2] < YAW_LIMITS[1])  # type: ignore\n\n\ndef sanity_clip(rpy: np.ndarray) -> np.ndarray:\n  if np.isnan(rpy).any():\n    rpy = RPY_INIT\n  return np.array([rpy[0],\n                   np.clip(rpy[1], PITCH_LIMITS[0] - .005, PITCH_LIMITS[1] + .005),\n                   np.clip(rpy[2], YAW_LIMITS[0] - .005, YAW_LIMITS[1] + .005)])\n\ndef moving_avg_with_linear_decay(prev_mean: np.ndarray, new_val: np.ndarray, idx: int, block_size: float) -> np.ndarray:\n  return (idx*prev_mean + (block_size - idx) * new_val) / block_size\n\nclass Calibrator:\n  def __init__(self, param_put: bool = False):\n    self.param_put = param_put\n\n    self.not_car = False\n\n    # Read saved calibration\n    self.params = Params()\n    calibration_params = self.params.get(\"CalibrationParams\")\n    rpy_init = RPY_INIT\n    wide_from_device_euler = WIDE_FROM_DEVICE_EULER_INIT\n    height = HEIGHT_INIT\n    valid_blocks = 0\n    self.cal_status = log.LiveCalibrationData.Status.uncalibrated\n\n    if param_put and calibration_params:\n      try:\n        with log.Event.from_bytes(calibration_params) as msg:\n          rpy_init = np.array(msg.liveCalibration.rpyCalib)\n          valid_blocks = msg.liveCalibration.validBlocks\n          wide_from_device_euler = np.array(msg.liveCalibration.wideFromDeviceEuler)\n          height = np.array(msg.liveCalibration.height)\n      except Exception:\n        cloudlog.exception(\"Error reading cached CalibrationParams\")\n\n    self.reset(rpy_init, valid_blocks, wide_from_device_euler, height)\n    self.update_status()\n\n  def reset(self, rpy_init: np.ndarray = RPY_INIT,\n                  valid_blocks: int = 0,\n                  wide_from_device_euler_init: np.ndarray = WIDE_FROM_DEVICE_EULER_INIT,\n                  height_init: np.ndarray = HEIGHT_INIT,\n                  smooth_from: np.ndarray = None) -> None:\n    if not np.isfinite(rpy_init).all():\n      self.rpy = RPY_INIT.copy()\n    else:\n      self.rpy = rpy_init.copy()\n\n    if not np.isfinite(height_init).all() or len(height_init) != 1:\n      self.height = HEIGHT_INIT.copy()\n    else:\n      self.height = height_init.copy()\n\n    if not np.isfinite(wide_from_device_euler_init).all() or len(wide_from_device_euler_init) != 3:\n      self.wide_from_device_euler = WIDE_FROM_DEVICE_EULER_INIT.copy()\n    else:\n      self.wide_from_device_euler = wide_from_device_euler_init.copy()\n\n    if not np.isfinite(valid_blocks) or valid_blocks < 0:\n      self.valid_blocks = 0\n    else:\n      self.valid_blocks = valid_blocks\n\n    self.rpys = np.tile(self.rpy, (INPUTS_WANTED, 1))\n    self.wide_from_device_eulers = np.tile(self.wide_from_device_euler, (INPUTS_WANTED, 1))\n    self.heights = np.tile(self.height, (INPUTS_WANTED, 1))\n\n    self.idx = 0\n    self.block_idx = 0\n    self.v_ego = 0.0\n\n    if smooth_from is None:\n      self.old_rpy = RPY_INIT\n      self.old_rpy_weight = 0.0\n    else:\n      self.old_rpy = smooth_from\n      self.old_rpy_weight = 1.0\n\n  def get_valid_idxs(self) -> list[int]:\n    # exclude current block_idx from validity window\n    before_current = list(range(self.block_idx))\n    after_current = list(range(min(self.valid_blocks, self.block_idx + 1), self.valid_blocks))\n    return before_current + after_current\n\n  def update_status(self) -> None:\n    valid_idxs = self.get_valid_idxs()\n    if valid_idxs:\n      self.wide_from_device_euler = np.mean(self.wide_from_device_eulers[valid_idxs], axis=0)\n      self.height = np.mean(self.heights[valid_idxs], axis=0)\n      rpys = self.rpys[valid_idxs]\n      self.rpy = np.mean(rpys, axis=0)\n      max_rpy_calib = np.array(np.max(rpys, axis=0))\n      min_rpy_calib = np.array(np.min(rpys, axis=0))\n      self.calib_spread = np.abs(max_rpy_calib - min_rpy_calib)\n    else:\n      self.calib_spread = np.zeros(3)\n\n    if self.valid_blocks < INPUTS_NEEDED:\n      if self.cal_status == log.LiveCalibrationData.Status.recalibrating:\n        self.cal_status = log.LiveCalibrationData.Status.recalibrating\n      else:\n        self.cal_status = log.LiveCalibrationData.Status.uncalibrated\n    elif is_calibration_valid(self.rpy):\n      self.cal_status = log.LiveCalibrationData.Status.calibrated\n    else:\n      self.cal_status = log.LiveCalibrationData.Status.invalid\n\n    # If spread is too high, assume mounting was changed and reset to last block.\n    # Make the transition smooth. Abrupt transitions are not good for feedback loop through supercombo model.\n    # TODO: add height spread check with smooth transition too\n    spread_too_high = self.calib_spread[1] > MAX_ALLOWED_PITCH_SPREAD or self.calib_spread[2] > MAX_ALLOWED_YAW_SPREAD\n    if spread_too_high and self.cal_status == log.LiveCalibrationData.Status.calibrated:\n      self.reset(self.rpys[self.block_idx - 1], valid_blocks=1, smooth_from=self.rpy)\n      self.cal_status = log.LiveCalibrationData.Status.recalibrating\n\n    write_this_cycle = (self.idx == 0) and (self.block_idx % (INPUTS_WANTED//5) == 5)\n    if self.param_put and write_this_cycle:\n      self.params.put_nonblocking(\"CalibrationParams\", self.get_msg(True).to_bytes())\n\n  def handle_v_ego(self, v_ego: float) -> None:\n    self.v_ego = v_ego\n\n  def get_smooth_rpy(self) -> np.ndarray:\n    if self.old_rpy_weight > 0:\n      return self.old_rpy_weight * self.old_rpy + (1.0 - self.old_rpy_weight) * self.rpy\n    else:\n      return self.rpy\n\n  def handle_cam_odom(self, trans: list[float],\n                            rot: list[float],\n                            wide_from_device_euler: list[float],\n                            trans_std: list[float],\n                            road_transform_trans: list[float],\n                            road_transform_trans_std: list[float]) -> np.ndarray | None:\n    self.old_rpy_weight = max(0.0, self.old_rpy_weight - 1/SMOOTH_CYCLES)\n\n    straight_and_fast = ((self.v_ego > MIN_SPEED_FILTER) and (trans[0] > MIN_SPEED_FILTER) and (abs(rot[2]) < MAX_YAW_RATE_FILTER))\n    angle_std_threshold = MAX_VEL_ANGLE_STD\n    height_std_threshold = MAX_HEIGHT_STD\n    rpy_certain = np.arctan2(trans_std[1], trans[0]) < angle_std_threshold\n    if len(road_transform_trans_std) == 3:\n      height_certain = road_transform_trans_std[2] < height_std_threshold\n    else:\n      height_certain = True\n\n    certain_if_calib = (rpy_certain and height_certain) or (self.valid_blocks < INPUTS_NEEDED)\n    if not (straight_and_fast and certain_if_calib):\n      return None\n\n    observed_rpy = np.array([0,\n                             -np.arctan2(trans[2], trans[0]),\n                             np.arctan2(trans[1], trans[0])])\n    new_rpy = euler_from_rot(rot_from_euler(self.get_smooth_rpy()).dot(rot_from_euler(observed_rpy)))\n    new_rpy = sanity_clip(new_rpy)\n\n    if len(wide_from_device_euler) == 3:\n      new_wide_from_device_euler = np.array(wide_from_device_euler)\n    else:\n      new_wide_from_device_euler = WIDE_FROM_DEVICE_EULER_INIT\n\n    if (len(road_transform_trans) == 3):\n      new_height = np.array([road_transform_trans[2]])\n    else:\n      new_height = HEIGHT_INIT\n\n    self.rpys[self.block_idx] = moving_avg_with_linear_decay(self.rpys[self.block_idx], new_rpy, self.idx, float(BLOCK_SIZE))\n    self.wide_from_device_eulers[self.block_idx] = moving_avg_with_linear_decay(self.wide_from_device_eulers[self.block_idx],\n                                                                                new_wide_from_device_euler, self.idx, float(BLOCK_SIZE))\n    self.heights[self.block_idx] = moving_avg_with_linear_decay(self.heights[self.block_idx], new_height, self.idx, float(BLOCK_SIZE))\n\n    self.idx = (self.idx + 1) % BLOCK_SIZE\n    if self.idx == 0:\n      self.block_idx += 1\n      self.valid_blocks = max(self.block_idx, self.valid_blocks)\n      self.block_idx = self.block_idx % INPUTS_WANTED\n\n    self.update_status()\n\n    return new_rpy\n\n  def get_msg(self, valid: bool) -> capnp.lib.capnp._DynamicStructBuilder:\n    smooth_rpy = self.get_smooth_rpy()\n\n    msg = messaging.new_message('liveCalibration')\n    msg.valid = valid\n\n    liveCalibration = msg.liveCalibration\n    liveCalibration.validBlocks = self.valid_blocks\n    liveCalibration.calStatus = self.cal_status\n    liveCalibration.calPerc = min(100 * (self.valid_blocks * BLOCK_SIZE + self.idx) // (INPUTS_NEEDED * BLOCK_SIZE), 100)\n    liveCalibration.rpyCalib = smooth_rpy.tolist()\n    liveCalibration.rpyCalibSpread = self.calib_spread.tolist()\n    liveCalibration.wideFromDeviceEuler = self.wide_from_device_euler.tolist()\n    liveCalibration.height = self.height.tolist()\n\n    if self.not_car:\n      liveCalibration.validBlocks = INPUTS_NEEDED\n      liveCalibration.calStatus = log.LiveCalibrationData.Status.calibrated\n      liveCalibration.calPerc = 100.\n      liveCalibration.rpyCalib = [0, 0, 0]\n      liveCalibration.rpyCalibSpread = self.calib_spread.tolist()\n\n    return msg\n\n  def send_data(self, pm: messaging.PubMaster, valid: bool) -> None:\n    pm.send('liveCalibration', self.get_msg(valid))\n\n\ndef main() -> NoReturn:\n  gc.disable()\n  set_realtime_priority(1)\n\n  pm = messaging.PubMaster(['liveCalibration'])\n  sm = messaging.SubMaster(['cameraOdometry', 'carState', 'carParams'], poll='cameraOdometry')\n\n  calibrator = Calibrator(param_put=True)\n\n  while 1:\n    timeout = 0 if sm.frame == -1 else 100\n    sm.update(timeout)\n\n    calibrator.not_car = sm['carParams'].notCar\n\n    if sm.updated['cameraOdometry']:\n      calibrator.handle_v_ego(sm['carState'].vEgo)\n      new_rpy = calibrator.handle_cam_odom(sm['cameraOdometry'].trans,\n                                           sm['cameraOdometry'].rot,\n                                           sm['cameraOdometry'].wideFromDeviceEuler,\n                                           sm['cameraOdometry'].transStd,\n                                           sm['cameraOdometry'].roadTransformTrans,\n                                           sm['cameraOdometry'].roadTransformTransStd)\n\n      if DEBUG and new_rpy is not None:\n        print('got new rpy', new_rpy)\n\n    # 4Hz driven by cameraOdometry\n    if sm.frame % 5 == 0:\n      calibrator.send_data(pm, sm.all_checks())\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/locationd/helpers.py": "import numpy as np\nfrom typing import Any\n\nfrom cereal import log\n\n\nclass NPQueue:\n  def __init__(self, maxlen: int, rowsize: int) -> None:\n    self.maxlen = maxlen\n    self.arr = np.empty((0, rowsize))\n\n  def __len__(self) -> int:\n    return len(self.arr)\n\n  def append(self, pt: list[float]) -> None:\n    if len(self.arr) < self.maxlen:\n      self.arr = np.append(self.arr, [pt], axis=0)\n    else:\n      self.arr[:-1] = self.arr[1:]\n      self.arr[-1] = pt\n\n\nclass PointBuckets:\n  def __init__(self, x_bounds: list[tuple[float, float]], min_points: list[float], min_points_total: int, points_per_bucket: int, rowsize: int) -> None:\n    self.x_bounds = x_bounds\n    self.buckets = {bounds: NPQueue(maxlen=points_per_bucket, rowsize=rowsize) for bounds in x_bounds}\n    self.buckets_min_points = dict(zip(x_bounds, min_points, strict=True))\n    self.min_points_total = min_points_total\n\n  def __len__(self) -> int:\n    return sum([len(v) for v in self.buckets.values()])\n\n  def is_valid(self) -> bool:\n    individual_buckets_valid = all(len(v) >= min_pts for v, min_pts in zip(self.buckets.values(), self.buckets_min_points.values(), strict=True))\n    total_points_valid = self.__len__() >= self.min_points_total\n    return individual_buckets_valid and total_points_valid\n\n  def is_calculable(self) -> bool:\n    return all(len(v) > 0 for v in self.buckets.values())\n\n  def add_point(self, x: float, y: float, bucket_val: float) -> None:\n    raise NotImplementedError\n\n  def get_points(self, num_points: int = None) -> Any:\n    points = np.vstack([x.arr for x in self.buckets.values()])\n    if num_points is None:\n      return points\n    return points[np.random.choice(np.arange(len(points)), min(len(points), num_points), replace=False)]\n\n  def load_points(self, points: list[list[float]]) -> None:\n    for point in points:\n      self.add_point(*point)\n\n\nclass ParameterEstimator:\n  \"\"\" Base class for parameter estimators \"\"\"\n  def reset(self) -> None:\n    raise NotImplementedError\n\n  def handle_log(self, t: int, which: str, msg: log.Event) -> None:\n    raise NotImplementedError\n\n  def get_msg(self, valid: bool, with_points: bool) -> log.Event:\n    raise NotImplementedError\n", "selfdrive/locationd/__init__.py": "", "selfdrive/locationd/models/live_kf.py": "#!/usr/bin/env python3\n\nimport sys\nimport os\nimport numpy as np\n\nfrom openpilot.selfdrive.locationd.models.constants import ObservationKind\n\nimport sympy as sp\nimport inspect\nfrom rednose.helpers.sympy_helpers import euler_rotate, quat_matrix_r, quat_rotate\nfrom rednose.helpers.ekf_sym import gen_code\n\nEARTH_GM = 3.986005e14  # m^3/s^2 (gravitational constant * mass of earth)\n\n\ndef numpy2eigenstring(arr):\n  assert(len(arr.shape) == 1)\n  arr_str = np.array2string(arr, precision=20, separator=',')[1:-1].replace(' ', '').replace('\\n', '')\n  return f\"(Eigen::VectorXd({len(arr)}) << {arr_str}).finished()\"\n\n\nclass States:\n  ECEF_POS = slice(0, 3)  # x, y and z in ECEF in meters\n  ECEF_ORIENTATION = slice(3, 7)  # quat for pose of phone in ecef\n  ECEF_VELOCITY = slice(7, 10)  # ecef velocity in m/s\n  ANGULAR_VELOCITY = slice(10, 13)  # roll, pitch and yaw rates in device frame in radians/s\n  GYRO_BIAS = slice(13, 16)  # roll, pitch and yaw biases\n  ACCELERATION = slice(16, 19)  # Acceleration in device frame in m/s**2\n  ACC_BIAS = slice(19, 22)  # Acceletometer bias in m/s**2\n\n  # Error-state has different slices because it is an ESKF\n  ECEF_POS_ERR = slice(0, 3)\n  ECEF_ORIENTATION_ERR = slice(3, 6)  # euler angles for orientation error\n  ECEF_VELOCITY_ERR = slice(6, 9)\n  ANGULAR_VELOCITY_ERR = slice(9, 12)\n  GYRO_BIAS_ERR = slice(12, 15)\n  ACCELERATION_ERR = slice(15, 18)\n  ACC_BIAS_ERR = slice(18, 21)\n\n\nclass LiveKalman:\n  name = 'live'\n\n  initial_x = np.array([3.88e6, -3.37e6, 3.76e6,\n                        0.42254641, -0.31238054, -0.83602975, -0.15788347,  # NED [0,0,0] -> ECEF Quat\n                        0, 0, 0,\n                        0, 0, 0,\n                        0, 0, 0,\n                        0, 0, 0,\n                        0, 0, 0])\n\n  # state covariance\n  initial_P_diag = np.array([10**2, 10**2, 10**2,\n                             0.01**2, 0.01**2, 0.01**2,\n                             10**2, 10**2, 10**2,\n                             1**2, 1**2, 1**2,\n                             1**2, 1**2, 1**2,\n                             100**2, 100**2, 100**2,\n                             0.01**2, 0.01**2, 0.01**2])\n\n  # state covariance when resetting midway in a segment\n  reset_orientation_diag = np.array([1**2, 1**2, 1**2])\n\n  # fake observation covariance, to ensure the uncertainty estimate of the filter is under control\n  fake_gps_pos_cov_diag = np.array([1000**2, 1000**2, 1000**2])\n  fake_gps_vel_cov_diag = np.array([10**2, 10**2, 10**2])\n\n  # process noise\n  Q_diag = np.array([0.03**2, 0.03**2, 0.03**2,\n                     0.001**2, 0.001**2, 0.001**2,\n                     0.01**2, 0.01**2, 0.01**2,\n                     0.1**2, 0.1**2, 0.1**2,\n                     (0.005 / 100)**2, (0.005 / 100)**2, (0.005 / 100)**2,\n                     3**2, 3**2, 3**2,\n                     0.005**2, 0.005**2, 0.005**2])\n\n  obs_noise_diag = {ObservationKind.PHONE_GYRO: np.array([0.025**2, 0.025**2, 0.025**2]),\n                    ObservationKind.PHONE_ACCEL: np.array([.5**2, .5**2, .5**2]),\n                    ObservationKind.CAMERA_ODO_ROTATION: np.array([0.05**2, 0.05**2, 0.05**2]),\n                    ObservationKind.NO_ROT: np.array([0.005**2, 0.005**2, 0.005**2]),\n                    ObservationKind.NO_ACCEL: np.array([0.05**2, 0.05**2, 0.05**2]),\n                    ObservationKind.ECEF_POS: np.array([5**2, 5**2, 5**2]),\n                    ObservationKind.ECEF_VEL: np.array([.5**2, .5**2, .5**2]),\n                    ObservationKind.ECEF_ORIENTATION_FROM_GPS: np.array([.2**2, .2**2, .2**2, .2**2])}\n\n  @staticmethod\n  def generate_code(generated_dir):\n    name = LiveKalman.name\n    dim_state = LiveKalman.initial_x.shape[0]\n    dim_state_err = LiveKalman.initial_P_diag.shape[0]\n\n    state_sym = sp.MatrixSymbol('state', dim_state, 1)\n    state = sp.Matrix(state_sym)\n    x, y, z = state[States.ECEF_POS, :]\n    q = state[States.ECEF_ORIENTATION, :]\n    v = state[States.ECEF_VELOCITY, :]\n    vx, vy, vz = v\n    omega = state[States.ANGULAR_VELOCITY, :]\n    vroll, vpitch, vyaw = omega\n    roll_bias, pitch_bias, yaw_bias = state[States.GYRO_BIAS, :]\n    acceleration = state[States.ACCELERATION, :]\n    acc_bias = state[States.ACC_BIAS, :]\n\n    dt = sp.Symbol('dt')\n\n    # calibration and attitude rotation matrices\n    quat_rot = quat_rotate(*q)\n\n    # Got the quat predict equations from here\n    # A New Quaternion-Based Kalman Filter for\n    # Real-Time Attitude Estimation Using the Two-Step\n    # Geometrically-Intuitive Correction Algorithm\n    A = 0.5 * sp.Matrix([[0, -vroll, -vpitch, -vyaw],\n                         [vroll, 0, vyaw, -vpitch],\n                         [vpitch, -vyaw, 0, vroll],\n                         [vyaw, vpitch, -vroll, 0]])\n    q_dot = A * q\n\n    # Time derivative of the state as a function of state\n    state_dot = sp.Matrix(np.zeros((dim_state, 1)))\n    state_dot[States.ECEF_POS, :] = v\n    state_dot[States.ECEF_ORIENTATION, :] = q_dot\n    state_dot[States.ECEF_VELOCITY, 0] = quat_rot * acceleration\n\n    # Basic descretization, 1st order intergrator\n    # Can be pretty bad if dt is big\n    f_sym = state + dt * state_dot\n\n    state_err_sym = sp.MatrixSymbol('state_err', dim_state_err, 1)\n    state_err = sp.Matrix(state_err_sym)\n    quat_err = state_err[States.ECEF_ORIENTATION_ERR, :]\n    v_err = state_err[States.ECEF_VELOCITY_ERR, :]\n    omega_err = state_err[States.ANGULAR_VELOCITY_ERR, :]\n    acceleration_err = state_err[States.ACCELERATION_ERR, :]\n\n    # Time derivative of the state error as a function of state error and state\n    quat_err_matrix = euler_rotate(quat_err[0], quat_err[1], quat_err[2])\n    q_err_dot = quat_err_matrix * quat_rot * (omega + omega_err)\n    state_err_dot = sp.Matrix(np.zeros((dim_state_err, 1)))\n    state_err_dot[States.ECEF_POS_ERR, :] = v_err\n    state_err_dot[States.ECEF_ORIENTATION_ERR, :] = q_err_dot\n    state_err_dot[States.ECEF_VELOCITY_ERR, :] = quat_err_matrix * quat_rot * (acceleration + acceleration_err)\n    f_err_sym = state_err + dt * state_err_dot\n\n    # Observation matrix modifier\n    H_mod_sym = sp.Matrix(np.zeros((dim_state, dim_state_err)))\n    H_mod_sym[States.ECEF_POS, States.ECEF_POS_ERR] = np.eye(States.ECEF_POS.stop - States.ECEF_POS.start)\n    H_mod_sym[States.ECEF_ORIENTATION, States.ECEF_ORIENTATION_ERR] = 0.5 * quat_matrix_r(state[3:7])[:, 1:]\n    H_mod_sym[States.ECEF_ORIENTATION.stop:, States.ECEF_ORIENTATION_ERR.stop:] = np.eye(dim_state - States.ECEF_ORIENTATION.stop)\n\n    # these error functions are defined so that say there\n    # is a nominal x and true x:\n    # true x = err_function(nominal x, delta x)\n    # delta x = inv_err_function(nominal x, true x)\n    nom_x = sp.MatrixSymbol('nom_x', dim_state, 1)\n    true_x = sp.MatrixSymbol('true_x', dim_state, 1)\n    delta_x = sp.MatrixSymbol('delta_x', dim_state_err, 1)\n\n    err_function_sym = sp.Matrix(np.zeros((dim_state, 1)))\n    delta_quat = sp.Matrix(np.ones(4))\n    delta_quat[1:, :] = sp.Matrix(0.5 * delta_x[States.ECEF_ORIENTATION_ERR, :])\n    err_function_sym[States.ECEF_POS, :] = sp.Matrix(nom_x[States.ECEF_POS, :] + delta_x[States.ECEF_POS_ERR, :])\n    err_function_sym[States.ECEF_ORIENTATION, 0] = quat_matrix_r(nom_x[States.ECEF_ORIENTATION, 0]) * delta_quat\n    err_function_sym[States.ECEF_ORIENTATION.stop:, :] = sp.Matrix(nom_x[States.ECEF_ORIENTATION.stop:, :] + delta_x[States.ECEF_ORIENTATION_ERR.stop:, :])\n\n    inv_err_function_sym = sp.Matrix(np.zeros((dim_state_err, 1)))\n    inv_err_function_sym[States.ECEF_POS_ERR, 0] = sp.Matrix(-nom_x[States.ECEF_POS, 0] + true_x[States.ECEF_POS, 0])\n    delta_quat = quat_matrix_r(nom_x[States.ECEF_ORIENTATION, 0]).T * true_x[States.ECEF_ORIENTATION, 0]\n    inv_err_function_sym[States.ECEF_ORIENTATION_ERR, 0] = sp.Matrix(2 * delta_quat[1:])\n    inv_err_function_sym[States.ECEF_ORIENTATION_ERR.stop:, 0] = sp.Matrix(-nom_x[States.ECEF_ORIENTATION.stop:, 0] + true_x[States.ECEF_ORIENTATION.stop:, 0])\n\n    eskf_params = [[err_function_sym, nom_x, delta_x],\n                   [inv_err_function_sym, nom_x, true_x],\n                   H_mod_sym, f_err_sym, state_err_sym]\n    #\n    # Observation functions\n    #\n    h_gyro_sym = sp.Matrix([\n      vroll + roll_bias,\n      vpitch + pitch_bias,\n      vyaw + yaw_bias])\n\n    pos = sp.Matrix([x, y, z])\n    gravity = quat_rot.T * ((EARTH_GM / ((x**2 + y**2 + z**2)**(3.0 / 2.0))) * pos)\n    h_acc_sym = (gravity + acceleration + acc_bias)\n    h_acc_stationary_sym = acceleration\n    h_phone_rot_sym = sp.Matrix([vroll, vpitch, vyaw])\n    h_pos_sym = sp.Matrix([x, y, z])\n    h_vel_sym = sp.Matrix([vx, vy, vz])\n    h_orientation_sym = q\n    h_relative_motion = sp.Matrix(quat_rot.T * v)\n\n    obs_eqs = [[h_gyro_sym, ObservationKind.PHONE_GYRO, None],\n               [h_phone_rot_sym, ObservationKind.NO_ROT, None],\n               [h_acc_sym, ObservationKind.PHONE_ACCEL, None],\n               [h_pos_sym, ObservationKind.ECEF_POS, None],\n               [h_vel_sym, ObservationKind.ECEF_VEL, None],\n               [h_orientation_sym, ObservationKind.ECEF_ORIENTATION_FROM_GPS, None],\n               [h_relative_motion, ObservationKind.CAMERA_ODO_TRANSLATION, None],\n               [h_phone_rot_sym, ObservationKind.CAMERA_ODO_ROTATION, None],\n               [h_acc_stationary_sym, ObservationKind.NO_ACCEL, None]]\n\n    # this returns a sympy routine for the jacobian of the observation function of the local vel\n    in_vec = sp.MatrixSymbol('in_vec', 6, 1)  # roll, pitch, yaw, vx, vy, vz\n    h = euler_rotate(in_vec[0], in_vec[1], in_vec[2]).T * (sp.Matrix([in_vec[3], in_vec[4], in_vec[5]]))\n    extra_routines = [('H', h.jacobian(in_vec), [in_vec])]\n\n    gen_code(generated_dir, name, f_sym, dt, state_sym, obs_eqs, dim_state, dim_state_err, eskf_params, extra_routines=extra_routines)\n\n    # write constants to extra header file for use in cpp\n    live_kf_header = \"#pragma once\\n\\n\"\n    live_kf_header += \"#include <unordered_map>\\n\"\n    live_kf_header += \"#include <eigen3/Eigen/Dense>\\n\\n\"\n    for state, slc in inspect.getmembers(States, lambda x: isinstance(x, slice)):\n      assert(slc.step is None)  # unsupported\n      live_kf_header += f'#define STATE_{state}_START {slc.start}\\n'\n      live_kf_header += f'#define STATE_{state}_END {slc.stop}\\n'\n      live_kf_header += f'#define STATE_{state}_LEN {slc.stop - slc.start}\\n'\n    live_kf_header += \"\\n\"\n\n    for kind, val in inspect.getmembers(ObservationKind, lambda x: isinstance(x, int)):\n      live_kf_header += f'#define OBSERVATION_{kind} {val}\\n'\n    live_kf_header += \"\\n\"\n\n    live_kf_header += f\"static const Eigen::VectorXd live_initial_x = {numpy2eigenstring(LiveKalman.initial_x)};\\n\"\n    live_kf_header += f\"static const Eigen::VectorXd live_initial_P_diag = {numpy2eigenstring(LiveKalman.initial_P_diag)};\\n\"\n    live_kf_header += f\"static const Eigen::VectorXd live_fake_gps_pos_cov_diag = {numpy2eigenstring(LiveKalman.fake_gps_pos_cov_diag)};\\n\"\n    live_kf_header += f\"static const Eigen::VectorXd live_fake_gps_vel_cov_diag = {numpy2eigenstring(LiveKalman.fake_gps_vel_cov_diag)};\\n\"\n    live_kf_header += f\"static const Eigen::VectorXd live_reset_orientation_diag = {numpy2eigenstring(LiveKalman.reset_orientation_diag)};\\n\"\n    live_kf_header += f\"static const Eigen::VectorXd live_Q_diag = {numpy2eigenstring(LiveKalman.Q_diag)};\\n\"\n    live_kf_header += \"static const std::unordered_map<int, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> live_obs_noise_diag = {\\n\"\n    for kind, noise in LiveKalman.obs_noise_diag.items():\n      live_kf_header += f\"  {{ {kind}, {numpy2eigenstring(noise)} }},\\n\"\n    live_kf_header += \"};\\n\\n\"\n\n    open(os.path.join(generated_dir, \"live_kf_constants.h\"), 'w').write(live_kf_header)\n\n\nif __name__ == \"__main__\":\n  generated_dir = sys.argv[2]\n  LiveKalman.generate_code(generated_dir)\n", "selfdrive/locationd/models/car_kf.py": "#!/usr/bin/env python3\nimport math\nimport sys\nfrom typing import Any\n\nimport numpy as np\n\nfrom openpilot.selfdrive.controls.lib.vehicle_model import ACCELERATION_DUE_TO_GRAVITY\nfrom openpilot.selfdrive.locationd.models.constants import ObservationKind\nfrom openpilot.common.swaglog import cloudlog\n\nfrom rednose.helpers.kalmanfilter import KalmanFilter\n\nif __name__ == '__main__':  # Generating sympy\n  import sympy as sp\n  from rednose.helpers.ekf_sym import gen_code\nelse:\n  from rednose.helpers.ekf_sym_pyx import EKF_sym_pyx\n\n\ni = 0\n\ndef _slice(n):\n  global i\n  s = slice(i, i + n)\n  i += n\n\n  return s\n\n\nclass States:\n  # Vehicle model params\n  STIFFNESS = _slice(1)  # [-]\n  STEER_RATIO = _slice(1)  # [-]\n  ANGLE_OFFSET = _slice(1)  # [rad]\n  ANGLE_OFFSET_FAST = _slice(1)  # [rad]\n\n  VELOCITY = _slice(2)  # (x, y) [m/s]\n  YAW_RATE = _slice(1)  # [rad/s]\n  STEER_ANGLE = _slice(1)  # [rad]\n  ROAD_ROLL = _slice(1)  # [rad]\n\n\nclass CarKalman(KalmanFilter):\n  name = 'car'\n\n  initial_x = np.array([\n    1.0,\n    15.0,\n    0.0,\n    0.0,\n\n    10.0, 0.0,\n    0.0,\n    0.0,\n    0.0\n  ])\n\n  # process noise\n  Q = np.diag([\n    (.05 / 100)**2,\n    .01**2,\n    math.radians(0.02)**2,\n    math.radians(0.25)**2,\n\n    .1**2, .01**2,\n    math.radians(0.1)**2,\n    math.radians(0.1)**2,\n    math.radians(1)**2,\n  ])\n  P_initial = Q.copy()\n\n  obs_noise: dict[int, Any] = {\n    ObservationKind.STEER_ANGLE: np.atleast_2d(math.radians(0.05)**2),\n    ObservationKind.ANGLE_OFFSET_FAST: np.atleast_2d(math.radians(10.0)**2),\n    ObservationKind.ROAD_ROLL: np.atleast_2d(math.radians(1.0)**2),\n    ObservationKind.STEER_RATIO: np.atleast_2d(5.0**2),\n    ObservationKind.STIFFNESS: np.atleast_2d(0.5**2),\n    ObservationKind.ROAD_FRAME_X_SPEED: np.atleast_2d(0.1**2),\n  }\n\n  global_vars = [\n    'mass',\n    'rotational_inertia',\n    'center_to_front',\n    'center_to_rear',\n    'stiffness_front',\n    'stiffness_rear',\n  ]\n\n  @staticmethod\n  def generate_code(generated_dir):\n    dim_state = CarKalman.initial_x.shape[0]\n    name = CarKalman.name\n\n    # vehicle models comes from The Science of Vehicle Dynamics: Handling, Braking, and Ride of Road and Race Cars\n    # Model used is in 6.15 with formula from 6.198\n\n    # globals\n    global_vars = [sp.Symbol(name) for name in CarKalman.global_vars]\n    m, j, aF, aR, cF_orig, cR_orig = global_vars\n\n    # make functions and jacobians with sympy\n    # state variables\n    state_sym = sp.MatrixSymbol('state', dim_state, 1)\n    state = sp.Matrix(state_sym)\n\n    # Vehicle model constants\n    sf = state[States.STIFFNESS, :][0, 0]\n\n    cF, cR = sf * cF_orig, sf * cR_orig\n    angle_offset = state[States.ANGLE_OFFSET, :][0, 0]\n    angle_offset_fast = state[States.ANGLE_OFFSET_FAST, :][0, 0]\n    theta = state[States.ROAD_ROLL, :][0, 0]\n    sa = state[States.STEER_ANGLE, :][0, 0]\n\n    sR = state[States.STEER_RATIO, :][0, 0]\n    u, v = state[States.VELOCITY, :]\n    r = state[States.YAW_RATE, :][0, 0]\n\n    A = sp.Matrix(np.zeros((2, 2)))\n    A[0, 0] = -(cF + cR) / (m * u)\n    A[0, 1] = -(cF * aF - cR * aR) / (m * u) - u\n    A[1, 0] = -(cF * aF - cR * aR) / (j * u)\n    A[1, 1] = -(cF * aF**2 + cR * aR**2) / (j * u)\n\n    B = sp.Matrix(np.zeros((2, 1)))\n    B[0, 0] = cF / m / sR\n    B[1, 0] = (cF * aF) / j / sR\n\n    C = sp.Matrix(np.zeros((2, 1)))\n    C[0, 0] = ACCELERATION_DUE_TO_GRAVITY\n    C[1, 0] = 0\n\n    x = sp.Matrix([v, r])  # lateral velocity, yaw rate\n    x_dot = A * x + B * (sa - angle_offset - angle_offset_fast) - C * theta\n\n    dt = sp.Symbol('dt')\n    state_dot = sp.Matrix(np.zeros((dim_state, 1)))\n    state_dot[States.VELOCITY.start + 1, 0] = x_dot[0]\n    state_dot[States.YAW_RATE.start, 0] = x_dot[1]\n\n    # Basic descretization, 1st order integrator\n    # Can be pretty bad if dt is big\n    f_sym = state + dt * state_dot\n\n    #\n    # Observation functions\n    #\n    obs_eqs = [\n      [sp.Matrix([r]), ObservationKind.ROAD_FRAME_YAW_RATE, None],\n      [sp.Matrix([u, v]), ObservationKind.ROAD_FRAME_XY_SPEED, None],\n      [sp.Matrix([u]), ObservationKind.ROAD_FRAME_X_SPEED, None],\n      [sp.Matrix([sa]), ObservationKind.STEER_ANGLE, None],\n      [sp.Matrix([angle_offset_fast]), ObservationKind.ANGLE_OFFSET_FAST, None],\n      [sp.Matrix([sR]), ObservationKind.STEER_RATIO, None],\n      [sp.Matrix([sf]), ObservationKind.STIFFNESS, None],\n      [sp.Matrix([theta]), ObservationKind.ROAD_ROLL, None],\n    ]\n\n    gen_code(generated_dir, name, f_sym, dt, state_sym, obs_eqs, dim_state, dim_state, global_vars=global_vars)\n\n  def __init__(self, generated_dir, steer_ratio=15, stiffness_factor=1, angle_offset=0, P_initial=None):\n    dim_state = self.initial_x.shape[0]\n    dim_state_err = self.P_initial.shape[0]\n    x_init = self.initial_x\n    x_init[States.STEER_RATIO] = steer_ratio\n    x_init[States.STIFFNESS] = stiffness_factor\n    x_init[States.ANGLE_OFFSET] = angle_offset\n\n    if P_initial is not None:\n      self.P_initial = P_initial\n    # init filter\n    self.filter = EKF_sym_pyx(generated_dir, self.name, self.Q, self.initial_x, self.P_initial,\n                              dim_state, dim_state_err, global_vars=self.global_vars, logger=cloudlog)\n\n\nif __name__ == \"__main__\":\n  generated_dir = sys.argv[2]\n  CarKalman.generate_code(generated_dir)\n", "selfdrive/locationd/models/constants.py": "import os\n\nGENERATED_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), 'generated'))\n\nclass ObservationKind:\n  UNKNOWN = 0\n  NO_OBSERVATION = 1\n  GPS_NED = 2\n  ODOMETRIC_SPEED = 3\n  PHONE_GYRO = 4\n  GPS_VEL = 5\n  PSEUDORANGE_GPS = 6\n  PSEUDORANGE_RATE_GPS = 7\n  SPEED = 8\n  NO_ROT = 9\n  PHONE_ACCEL = 10\n  ORB_POINT = 11\n  ECEF_POS = 12\n  CAMERA_ODO_TRANSLATION = 13\n  CAMERA_ODO_ROTATION = 14\n  ORB_FEATURES = 15\n  MSCKF_TEST = 16\n  FEATURE_TRACK_TEST = 17\n  LANE_PT = 18\n  IMU_FRAME = 19\n  PSEUDORANGE_GLONASS = 20\n  PSEUDORANGE_RATE_GLONASS = 21\n  PSEUDORANGE = 22\n  PSEUDORANGE_RATE = 23\n  ECEF_VEL = 35\n  ECEF_ORIENTATION_FROM_GPS = 32\n  NO_ACCEL = 33\n  ORB_FEATURES_WIDE = 34\n\n  ROAD_FRAME_XY_SPEED = 24  # (x, y) [m/s]\n  ROAD_FRAME_YAW_RATE = 25  # [rad/s]\n  STEER_ANGLE = 26  # [rad]\n  ANGLE_OFFSET_FAST = 27  # [rad]\n  STIFFNESS = 28  # [-]\n  STEER_RATIO = 29  # [-]\n  ROAD_FRAME_X_SPEED = 30  # (x) [m/s]\n  ROAD_ROLL = 31  # [rad]\n\n  names = [\n    'Unknown',\n    'No observation',\n    'GPS NED',\n    'Odometric speed',\n    'Phone gyro',\n    'GPS velocity',\n    'GPS pseudorange',\n    'GPS pseudorange rate',\n    'Speed',\n    'No rotation',\n    'Phone acceleration',\n    'ORB point',\n    'ECEF pos',\n    'camera odometric translation',\n    'camera odometric rotation',\n    'ORB features',\n    'MSCKF test',\n    'Feature track test',\n    'Lane ecef point',\n    'imu frame eulers',\n    'GLONASS pseudorange',\n    'GLONASS pseudorange rate',\n    'pseudorange',\n    'pseudorange rate',\n\n    'Road Frame x,y speed',\n    'Road Frame yaw rate',\n    'Steer Angle',\n    'Fast Angle Offset',\n    'Stiffness',\n    'Steer Ratio',\n    'Road Frame x speed',\n    'Road Roll',\n    'ECEF orientation from GPS',\n    'NO accel',\n    'ORB features wide camera',\n    'ECEF_VEL',\n  ]\n\n  @classmethod\n  def to_string(cls, kind):\n    return cls.names[kind]\n\n\nSAT_OBS = [ObservationKind.PSEUDORANGE_GPS,\n           ObservationKind.PSEUDORANGE_RATE_GPS,\n           ObservationKind.PSEUDORANGE_GLONASS,\n           ObservationKind.PSEUDORANGE_RATE_GLONASS]\n", "selfdrive/locationd/models/__init__.py": "", "selfdrive/debug/check_lag.py": "#!/usr/bin/env python3\n\nimport cereal.messaging as messaging\nfrom cereal.services import SERVICE_LIST\n\nTO_CHECK = ['carState']\n\n\nif __name__ == \"__main__\":\n  sm = messaging.SubMaster(TO_CHECK)\n\n  prev_t: dict[str, float] = {}\n\n  while True:\n    sm.update()\n\n    for s in TO_CHECK:\n      if sm.updated[s]:\n        t = sm.logMonoTime[s] / 1e9\n\n        if s in prev_t:\n          expected = 1.0 / (SERVICE_LIST[s].frequency)\n          dt = t - prev_t[s]\n          if dt > 10 * expected:\n            print(t, s, dt)\n\n        prev_t[s] = t\n", "selfdrive/debug/check_can_parser_performance.py": "#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom tqdm import tqdm\n\nfrom cereal import car\nfrom openpilot.selfdrive.car.tests.routes import CarTestRoute\nfrom openpilot.selfdrive.car.tests.test_models import TestCarModelBase\nfrom openpilot.tools.plotjuggler.juggle import DEMO_ROUTE\n\nN_RUNS = 10\n\n\nclass CarModelTestCase(TestCarModelBase):\n  test_route = CarTestRoute(DEMO_ROUTE, None)\n  ci = False\n\n\nif __name__ == '__main__':\n  # Get CAN messages and parsers\n  tm = CarModelTestCase()\n  tm.setUpClass()\n  tm.setUp()\n\n  CC = car.CarControl.new_message()\n  ets = []\n  for _ in tqdm(range(N_RUNS)):\n    msgs = [(m.as_builder().to_bytes(),) for m in tm.can_msgs]\n    start_t = time.process_time_ns()\n    for msg in msgs:\n      for cp in tm.CI.can_parsers:\n        if cp is not None:\n          cp.update_strings(msg)\n    ets.append((time.process_time_ns() - start_t) * 1e-6)\n\n  print(f'{len(tm.can_msgs)} CAN packets, {N_RUNS} runs')\n  print(f'{np.mean(ets):.2f} mean ms, {max(ets):.2f} max ms, {min(ets):.2f} min ms, {np.std(ets):.2f} std ms')\n  print(f'{np.mean(ets) / len(tm.can_msgs):.4f} mean ms / CAN packet')\n", "selfdrive/debug/read_dtc_status.py": "#!/usr/bin/env python3\nimport sys\nimport argparse\nfrom subprocess import check_output, CalledProcessError\nfrom panda import Panda\nfrom panda.python.uds import UdsClient, SESSION_TYPE, DTC_REPORT_TYPE, DTC_STATUS_MASK_TYPE\nfrom panda.python.uds import get_dtc_num_as_str, get_dtc_status_names\n\nparser = argparse.ArgumentParser(description=\"read DTC status\")\nparser.add_argument(\"addr\", type=lambda x: int(x,0))\nparser.add_argument(\"--bus\", type=int, default=0)\nparser.add_argument('--debug', action='store_true')\nargs = parser.parse_args()\n\ntry:\n  check_output([\"pidof\", \"pandad\"])\n  print(\"pandad is running, please kill openpilot before running this script! (aborted)\")\n  sys.exit(1)\nexcept CalledProcessError as e:\n  if e.returncode != 1: # 1 == no process found (pandad not running)\n    raise e\n\npanda = Panda()\npanda.set_safety_mode(Panda.SAFETY_ELM327)\nuds_client = UdsClient(panda, args.addr, bus=args.bus, debug=args.debug)\nprint(\"extended diagnostic session ...\")\nuds_client.diagnostic_session_control(SESSION_TYPE.EXTENDED_DIAGNOSTIC)\nprint(\"read diagnostic codes ...\")\ndata = uds_client.read_dtc_information(DTC_REPORT_TYPE.DTC_BY_STATUS_MASK, DTC_STATUS_MASK_TYPE.ALL)\nprint(\"status availability:\", \" \".join(get_dtc_status_names(data[0])))\nprint(\"DTC status:\")\nfor i in range(1, len(data), 4):\n  dtc_num = get_dtc_num_as_str(data[i:i+3])\n  dtc_status = \" \".join(get_dtc_status_names(data[i+3]))\n  print(dtc_num, dtc_status)\n", "selfdrive/debug/debug_fw_fingerprinting_offline.py": "#!/usr/bin/env python3\nimport argparse\n\nfrom openpilot.tools.lib.live_logreader import live_logreader\nfrom openpilot.tools.lib.logreader import LogReader, ReadMode\nfrom panda.python import uds\n\n\ndef main(route: str | None, addrs: list[int]):\n  \"\"\"\n  TODO:\n  - highlight TX vs RX clearly\n  - disambiguate sendcan and can (useful to know if something sent on sendcan made it to the bus on can->128)\n  - print as fixed width table, easier to read\n  \"\"\"\n\n  if route is None:\n    lr = live_logreader()\n  else:\n    lr = LogReader(route, default_mode=ReadMode.RLOG, sort_by_time=True)\n\n  start_mono_time = None\n  prev_mono_time = 0\n\n  # include rx addresses\n  addrs = addrs + [uds.get_rx_addr_for_tx_addr(addr) for addr in addrs]\n\n  for msg in lr:\n    if msg.which() == 'can':\n      if start_mono_time is None:\n        start_mono_time = msg.logMonoTime\n\n    if msg.which() in (\"can\", 'sendcan'):\n      for can in getattr(msg, msg.which()):\n        if can.address in addrs or not len(addrs):\n          if msg.logMonoTime != prev_mono_time:\n            print()\n            prev_mono_time = msg.logMonoTime\n          print(f\"{msg.which():>7}: rxaddr={can.address}, bus={can.src}, {round((msg.logMonoTime - start_mono_time) * 1e-6, 2)} ms, \" +\n                f\"0x{can.dat.hex()}, {can.dat}, {len(can.dat)=}\")\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description='View back and forth ISO-TP communication between various ECUs given an address')\n  parser.add_argument('route', nargs='?', help='Route name, live if not specified')\n  parser.add_argument('--addrs', nargs='*', default=[], help='List of tx address to view (0x7e0 for engine)')\n  args = parser.parse_args()\n\n  addrs = [int(addr, base=16) if addr.startswith('0x') else int(addr) for addr in args.addrs]\n  main(args.route, addrs)\n", "selfdrive/debug/show_matching_cars.py": "#!/usr/bin/env python3\nfrom openpilot.selfdrive.car.fingerprints import eliminate_incompatible_cars, all_legacy_fingerprint_cars\nimport cereal.messaging as messaging\n\n\n# rav4 2019 and corolla tss2\nfingerprint = {896: 8, 898: 8, 900: 6, 976: 1, 1541: 8, 902: 6, 905: 8, 810: 2, 1164: 8, 1165: 8, 1166: 8, 1167: 8, 1552: 8, 1553: 8, 1556: 8, 1571: 8, 921: 8, 1056: 8, 544: 4, 1570: 8, 1059: 1, 36: 8, 37: 8, 550: 8, 935: 8, 552: 4, 170: 8, 812: 8, 944: 8, 945: 8, 562: 6, 180: 8, 1077: 8, 951: 8, 1592: 8, 1076: 8, 186: 4, 955: 8, 956: 8, 1001: 8, 705: 8, 452: 8, 1788: 8, 464: 8, 824: 8, 466: 8, 467: 8, 761: 8, 728: 8, 1572: 8, 1114: 8, 933: 8, 800: 8, 608: 8, 865: 8, 610: 8, 1595: 8, 934: 8, 998: 5, 1745: 8, 1000: 8, 764: 8, 1002: 8, 999: 7, 1789: 8, 1649: 8, 1779: 8, 1568: 8, 1017: 8, 1786: 8, 1787: 8, 1020: 8, 426: 6, 1279: 8} # noqa: E501\n\ncandidate_cars = all_legacy_fingerprint_cars()\n\n\nfor addr, l in fingerprint.items():\n  dat = messaging.new_message('can', 1)\n\n  msg = dat.can[0]\n  msg.address = addr\n  msg.dat = \" \" * l\n\n  candidate_cars = eliminate_incompatible_cars(msg, candidate_cars)\n  print(candidate_cars)\n", "selfdrive/debug/cpu_usage_stat.py": "#!/usr/bin/env python3\n# type: ignore\n'''\nSystem tools like top/htop can only show current cpu usage values, so I write this script to do statistics jobs.\n  Features:\n    Use psutil library to sample cpu usage(avergage for all cores) of openpilot processes, at a rate of 5 samples/sec.\n    Do cpu usage statistics periodically, 5 seconds as a cycle.\n    Calculate the average cpu usage within this cycle.\n    Calculate minumium/maximum/accumulated_average cpu usage as long term inspections.\n    Monitor multiple processes simuteneously.\n  Sample usage:\n    root@localhost:/data/openpilot$ python selfdrive/debug/cpu_usage_stat.py pandad,ubloxd\n    ('Add monitored proc:', './pandad')\n    ('Add monitored proc:', 'python locationd/ubloxd.py')\n    pandad: 1.96%, min: 1.96%, max: 1.96%, acc: 1.96%\n    ubloxd.py: 0.39%, min: 0.39%, max: 0.39%, acc: 0.39%\n'''\nimport psutil\nimport time\nimport os\nimport sys\nimport numpy as np\nimport argparse\nimport re\nfrom collections import defaultdict\n\nfrom openpilot.system.manager.process_config import managed_processes\n\n# Do statistics every 5 seconds\nPRINT_INTERVAL = 5\nSLEEP_INTERVAL = 0.2\n\nmonitored_proc_names = [\n  # android procs\n  'SurfaceFlinger', 'sensors.qcom'\n] + list(managed_processes.keys())\n\ncpu_time_names = ['user', 'system', 'children_user', 'children_system']\n\ntimer = getattr(time, 'monotonic', time.time)\n\n\ndef get_arg_parser():\n  parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"proc_names\", nargs=\"?\", default='',\n                      help=\"Process names to be monitored, comma separated\")\n  parser.add_argument(\"--list_all\", action='store_true',\n                      help=\"Show all running processes' cmdline\")\n  parser.add_argument(\"--detailed_times\", action='store_true',\n                      help=\"show cpu time details (split by user, system, child user, child system)\")\n  return parser\n\n\nif __name__ == \"__main__\":\n  args = get_arg_parser().parse_args(sys.argv[1:])\n  if args.list_all:\n    for p in psutil.process_iter():\n      print('cmdline', p.cmdline(), 'name', p.name())\n    sys.exit(0)\n\n  if len(args.proc_names) > 0:\n    monitored_proc_names = args.proc_names.split(',')\n  monitored_procs = []\n  stats = {}\n  for p in psutil.process_iter():\n    if p == psutil.Process():\n      continue\n    matched = any(l for l in p.cmdline() if any(pn for pn in monitored_proc_names if re.match(fr'.*{pn}.*', l, re.M | re.I)))\n    if matched:\n      k = ' '.join(p.cmdline())\n      print('Add monitored proc:', k)\n      stats[k] = {'cpu_samples': defaultdict(list), 'min': defaultdict(lambda: None), 'max': defaultdict(lambda: None),\n                  'avg': defaultdict(float), 'last_cpu_times': None, 'last_sys_time': None}\n      stats[k]['last_sys_time'] = timer()\n      stats[k]['last_cpu_times'] = p.cpu_times()\n      monitored_procs.append(p)\n  i = 0\n  interval_int = int(PRINT_INTERVAL / SLEEP_INTERVAL)\n  while True:\n    for p in monitored_procs:\n      k = ' '.join(p.cmdline())\n      cur_sys_time = timer()\n      cur_cpu_times = p.cpu_times()\n      cpu_times = np.subtract(cur_cpu_times, stats[k]['last_cpu_times']) / (cur_sys_time - stats[k]['last_sys_time'])\n      stats[k]['last_sys_time'] = cur_sys_time\n      stats[k]['last_cpu_times'] = cur_cpu_times\n      cpu_percent = 0\n      for num, name in enumerate(cpu_time_names):\n        stats[k]['cpu_samples'][name].append(cpu_times[num])\n        cpu_percent += cpu_times[num]\n      stats[k]['cpu_samples']['total'].append(cpu_percent)\n    time.sleep(SLEEP_INTERVAL)\n    i += 1\n    if i % interval_int == 0:\n      l = []\n      for k, stat in stats.items():\n        if len(stat['cpu_samples']) <= 0:\n          continue\n        for name, samples in stat['cpu_samples'].items():\n          samples = np.array(samples)\n          avg = samples.mean()\n          c = samples.size\n          min_cpu = np.amin(samples)\n          max_cpu = np.amax(samples)\n          if stat['min'][name] is None or min_cpu < stat['min'][name]:\n            stat['min'][name] = min_cpu\n          if stat['max'][name] is None or max_cpu > stat['max'][name]:\n            stat['max'][name] = max_cpu\n          stat['avg'][name] = (stat['avg'][name] * (i - c) + avg * c) / (i)\n          stat['cpu_samples'][name] = []\n\n        msg = f\"avg: {stat['avg']['total']:.2%}, min: {stat['min']['total']:.2%}, max: {stat['max']['total']:.2%} {os.path.basename(k)}\"\n        if args.detailed_times:\n          for stat_type in ['avg', 'min', 'max']:\n            msg += f\"\\n {stat_type}: {[(name + ':' + str(round(stat[stat_type][name] * 100, 2))) for name in cpu_time_names]}\"\n        l.append((os.path.basename(k), stat['avg']['total'], msg))\n      l.sort(key=lambda x: -x[1])\n      for x in l:\n        print(x[2])\n      print('avg sum: {:.2%} over {} samples {} seconds\\n'.format(\n        sum(stat['avg']['total'] for k, stat in stats.items()), i, i * SLEEP_INTERVAL\n      ))\n", "selfdrive/debug/format_fingerprints.py": "#!/usr/bin/env python3\nimport jinja2\nimport os\n\nfrom cereal import car\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.selfdrive.car.interfaces import get_interface_attr\n\nEcu = car.CarParams.Ecu\n\nCARS = get_interface_attr('CAR')\nFW_VERSIONS = get_interface_attr('FW_VERSIONS')\nFINGERPRINTS = get_interface_attr('FINGERPRINTS')\nECU_NAME = {v: k for k, v in Ecu.schema.enumerants.items()}\n\nFINGERPRINTS_PY_TEMPLATE = jinja2.Template(\"\"\"\n{%- if FINGERPRINTS[brand] %}\n# ruff: noqa: E501\n{% endif %}\n{% if FW_VERSIONS[brand] %}\nfrom cereal import car\n{% endif %}\nfrom openpilot.selfdrive.car.{{brand}}.values import CAR\n{% if FW_VERSIONS[brand] %}\n\nEcu = car.CarParams.Ecu\n{% endif %}\n{% if comments +%}\n{{ comments | join() }}\n{% endif %}\n{% if FINGERPRINTS[brand] %}\n\nFINGERPRINTS = {\n{% for car, fingerprints in FINGERPRINTS[brand].items() %}\n  CAR.{{car.name}}: [{\n{% for fingerprint in fingerprints %}\n{% if not loop.first %}\n  {{ \"{\" }}\n{% endif %}\n    {% for key, value in fingerprint.items() %}{{key}}: {{value}}{% if not loop.last %}, {% endif %}{% endfor %}\n\n  }{% if loop.last %}]{% endif %},\n{% endfor %}\n{% endfor %}\n}\n{% endif %}\n\nFW_VERSIONS{% if not FW_VERSIONS[brand] %}: dict[str, dict[tuple, list[bytes]]]{% endif %} = {\n{% for car, _ in FW_VERSIONS[brand].items() %}\n  CAR.{{car.name}}: {\n{% for key, fw_versions in FW_VERSIONS[brand][car].items() %}\n    (Ecu.{{ECU_NAME[key[0]]}}, 0x{{\"%0x\" | format(key[1] | int)}}, \\\n{% if key[2] %}0x{{\"%0x\" | format(key[2] | int)}}{% else %}{{key[2]}}{% endif %}): [\n  {% for fw_version in (fw_versions + extra_fw_versions.get(car, {}).get(key, [])) | unique | sort %}\n    {{fw_version}},\n  {% endfor %}\n  ],\n{% endfor %}\n  },\n{% endfor %}\n}\n\n\"\"\", trim_blocks=True)\n\n\ndef format_brand_fw_versions(brand, extra_fw_versions: None | dict[str, dict[tuple, list[bytes]]] = None):\n  extra_fw_versions = extra_fw_versions or {}\n\n  fingerprints_file = os.path.join(BASEDIR, f\"selfdrive/car/{brand}/fingerprints.py\")\n  with open(fingerprints_file) as f:\n    comments = [line for line in f.readlines() if line.startswith(\"#\") and \"noqa\" not in line]\n\n  with open(fingerprints_file, \"w\") as f:\n    f.write(FINGERPRINTS_PY_TEMPLATE.render(brand=brand, comments=comments, ECU_NAME=ECU_NAME,\n                                            FINGERPRINTS=FINGERPRINTS, FW_VERSIONS=FW_VERSIONS,\n                                            extra_fw_versions=extra_fw_versions))\n\n\nif __name__ == \"__main__\":\n  for brand in FW_VERSIONS.keys():\n    format_brand_fw_versions(brand)\n", "selfdrive/debug/get_fingerprint.py": "#!/usr/bin/env python3\n\n# simple script to get a vehicle fingerprint.\n\n# Instructions:\n# - connect to a Panda\n# - run selfdrive/pandad/pandad\n# - launching this script\n#   Note: it's very important that the car is in stock mode, in order to collect a complete fingerprint\n# - since some messages are published at low frequency, keep this script running for at least 30s,\n#   until all messages are received at least once\n\nimport cereal.messaging as messaging\n\nlogcan = messaging.sub_sock('can')\nmsgs = {}\nwhile True:\n  lc = messaging.recv_sock(logcan, True)\n  if lc is None:\n    continue\n\n  for c in lc.can:\n    # read also msgs sent by EON on CAN bus 0x80 and filter out the\n    # addr with more than 11 bits\n    if c.src % 0x80 == 0 and c.address < 0x800 and c.address not in (0x7df, 0x7e0, 0x7e8):\n      msgs[c.address] = len(c.dat)\n\n  fingerprint = ', '.join(\"%d: %d\" % v for v in sorted(msgs.items()))\n\n  print(f\"number of messages {len(msgs)}:\")\n  print(f\"fingerprint {fingerprint}\")\n", "selfdrive/debug/dump.py": "#!/usr/bin/env python3\nimport sys\nimport argparse\nimport json\nimport codecs\n\nfrom hexdump import hexdump\nfrom cereal import log\nfrom cereal.services import SERVICE_LIST\nfrom openpilot.tools.lib.live_logreader import raw_live_logreader\n\n\ncodecs.register_error(\"strict\", codecs.backslashreplace_errors)\n\nif __name__ == \"__main__\":\n\n  parser = argparse.ArgumentParser(description='Dump communication sockets. See cereal/services.py for a complete list of available sockets.')\n  parser.add_argument('--pipe', action='store_true')\n  parser.add_argument('--raw', action='store_true')\n  parser.add_argument('--json', action='store_true')\n  parser.add_argument('--dump-json', action='store_true')\n  parser.add_argument('--no-print', action='store_true')\n  parser.add_argument('--addr', default='127.0.0.1')\n  parser.add_argument('--values', help='values to monitor (instead of entire event)')\n  parser.add_argument(\"socket\", type=str, nargs='*', default=list(SERVICE_LIST.keys()), help=\"socket names to dump. defaults to all services defined in cereal\")\n  args = parser.parse_args()\n\n  lr = raw_live_logreader(args.socket, args.addr)\n\n  values = None\n  if args.values:\n    values = [s.strip().split(\".\") for s in args.values.split(\",\")]\n\n  for msg in lr:\n    with log.Event.from_bytes(msg) as evt:\n      if not args.no_print:\n        if args.pipe:\n          sys.stdout.write(str(msg))\n          sys.stdout.flush()\n        elif args.raw:\n          hexdump(msg)\n        elif args.json:\n          print(json.loads(msg))\n        elif args.dump_json:\n          print(json.dumps(evt.to_dict()))\n        elif values:\n          print(f\"logMonotime = {evt.logMonoTime}\")\n          for value in values:\n            if hasattr(evt, value[0]):\n              item = evt\n              for key in value:\n                item = getattr(item, key)\n              print(f\"{'.'.join(value)} = {item}\")\n          print(\"\")\n        else:\n          try:\n            print(evt)\n          except UnicodeDecodeError:\n            w = evt.which()\n            s = f\"( logMonoTime {evt.logMonoTime} \\n  {w} = \"\n            s += str(evt.__getattr__(w))\n            s += f\"\\n  valid = {evt.valid} )\"\n            print(s)\n", "selfdrive/debug/set_car_params.py": "#!/usr/bin/env python3\nimport sys\n\nfrom cereal import car\nfrom openpilot.common.params import Params\nfrom openpilot.tools.lib.route import Route\nfrom openpilot.tools.lib.logreader import LogReader\n\nif __name__ == \"__main__\":\n  CP = None\n  if len(sys.argv) > 1:\n    r = Route(sys.argv[1])\n    cps = [m for m in LogReader(r.qlog_paths()[0]) if m.which() == 'carParams']\n    CP = cps[0].carParams.as_builder()\n  else:\n    CP = car.CarParams.new_message()\n    CP.openpilotLongitudinalControl = True\n    CP.experimentalLongitudinalAvailable = False\n\n  cp_bytes = CP.to_bytes()\n  for p in (\"CarParams\", \"CarParamsCache\", \"CarParamsPersistent\"):\n    Params().put(p, cp_bytes)\n", "selfdrive/debug/live_cpu_and_temp.py": "#!/usr/bin/env python3\nimport argparse\nimport capnp\nfrom collections import defaultdict\n\nfrom cereal.messaging import SubMaster\nfrom openpilot.common.numpy_fast import mean\n\ndef cputime_total(ct):\n  return ct.user + ct.nice + ct.system + ct.idle + ct.iowait + ct.irq + ct.softirq\n\n\ndef cputime_busy(ct):\n  return ct.user + ct.nice + ct.system + ct.irq + ct.softirq\n\n\ndef proc_cputime_total(ct):\n  return ct.cpuUser + ct.cpuSystem + ct.cpuChildrenUser + ct.cpuChildrenSystem\n\n\ndef proc_name(proc):\n  name = proc.name\n  if len(proc.cmdline):\n    name = proc.cmdline[0]\n  if len(proc.exe):\n    name = proc.exe + \" - \" + name\n\n  return name\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--mem', action='store_true')\n  parser.add_argument('--cpu', action='store_true')\n  args = parser.parse_args()\n\n  sm = SubMaster(['deviceState', 'procLog'])\n\n  last_temp = 0.0\n  last_mem = 0.0\n  total_times = [0.]*8\n  busy_times = [0.]*8\n\n  prev_proclog: capnp._DynamicStructReader | None = None\n  prev_proclog_t: int | None = None\n\n  while True:\n    sm.update()\n\n    if sm.updated['deviceState']:\n      t = sm['deviceState']\n      last_temp = mean(t.cpuTempC)\n      last_mem = t.memoryUsagePercent\n\n    if sm.updated['procLog']:\n      m = sm['procLog']\n\n      cores = [0.]*8\n      total_times_new = [0.]*8\n      busy_times_new = [0.]*8\n\n      for c in m.cpuTimes:\n        n = c.cpuNum\n        total_times_new[n] = cputime_total(c)\n        busy_times_new[n] = cputime_busy(c)\n\n      for n in range(8):\n        t_busy = busy_times_new[n] - busy_times[n]\n        t_total = total_times_new[n] - total_times[n]\n        cores[n] = t_busy / t_total\n\n      total_times = total_times_new[:]\n      busy_times = busy_times_new[:]\n\n      print(f\"CPU {100.0 * mean(cores):.2f}% - RAM: {last_mem:.2f}% - Temp {last_temp:.2f}C\")\n\n      if args.cpu and prev_proclog is not None and prev_proclog_t is not None:\n        procs: dict[str, float] = defaultdict(float)\n        dt = (sm.logMonoTime['procLog'] - prev_proclog_t) / 1e9\n        for proc in m.procs:\n          try:\n            name = proc_name(proc)\n            prev_proc = [p for p in prev_proclog.procs if proc.pid == p.pid][0]\n            cpu_time = proc_cputime_total(proc) - proc_cputime_total(prev_proc)\n            cpu_usage = cpu_time / dt * 100.\n            procs[name] += cpu_usage\n          except IndexError:\n            pass\n\n        print(\"Top CPU usage:\")\n        for k, v in sorted(procs.items(), key=lambda item: item[1], reverse=True)[:10]:\n          print(f\"{k.rjust(70)}   {v:.2f} %\")\n        print()\n\n      if args.mem:\n        mems = {}\n        for proc in m.procs:\n          name = proc_name(proc)\n          mems[name] = float(proc.memRss) / 1e6\n        print(\"Top memory usage:\")\n        for k, v in sorted(mems.items(), key=lambda item: item[1], reverse=True)[:10]:\n          print(f\"{k.rjust(70)}   {v:.2f} MB\")\n        print()\n\n      prev_proclog = m\n      prev_proclog_t = sm.logMonoTime['procLog']\n", "selfdrive/debug/filter_log_message.py": "#!/usr/bin/env python3\nimport argparse\nimport json\n\nimport cereal.messaging as messaging\nfrom openpilot.tools.lib.logreader import LogReader\n\nLEVELS = {\n  \"DEBUG\": 10,\n  \"INFO\": 20,\n  \"WARNING\": 30,\n  \"ERROR\": 40,\n  \"CRITICAL\": 50,\n}\n\nANDROID_LOG_SOURCE = {\n  0: \"MAIN\",\n  1: \"RADIO\",\n  2: \"EVENTS\",\n  3: \"SYSTEM\",\n  4: \"CRASH\",\n  5: \"KERNEL\",\n}\n\n\ndef print_logmessage(t, msg, min_level):\n  try:\n    log = json.loads(msg)\n    if log['levelnum'] >= min_level:\n      print(f\"[{t / 1e9:.6f}] {log['filename']}:{log.get('lineno', '')} - {log.get('funcname', '')}: {log['msg']}\")\n      if 'exc_info' in log:\n        print(log['exc_info'])\n  except json.decoder.JSONDecodeError:\n    print(f\"[{t / 1e9:.6f}] decode error: {msg}\")\n\n\ndef print_androidlog(t, msg):\n  source = ANDROID_LOG_SOURCE[msg.id]\n  try:\n    m = json.loads(msg.message)['MESSAGE']\n  except Exception:\n    m = msg.message\n\n  print(f\"[{t / 1e9:.6f}] {source} {msg.pid} {msg.tag} - {m}\")\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--absolute', action='store_true')\n  parser.add_argument('--level', default='DEBUG')\n  parser.add_argument('--addr', default='127.0.0.1')\n  parser.add_argument(\"route\", type=str, nargs='*', help=\"route name + segment number for offline usage\")\n  args = parser.parse_args()\n\n  min_level = LEVELS[args.level]\n\n  if args.route:\n    st = None if not args.absolute else 0\n    for route in args.route:\n      lr = LogReader(route, sort_by_time=True)\n      for m in lr:\n        if st is None:\n          st = m.logMonoTime\n        if m.which() == 'logMessage':\n          print_logmessage(m.logMonoTime-st, m.logMessage, min_level)\n        elif m.which() == 'errorLogMessage':\n          print_logmessage(m.logMonoTime-st, m.errorLogMessage, min_level)\n        elif m.which() == 'androidLog':\n          print_androidlog(m.logMonoTime-st, m.androidLog)\n  else:\n    sm = messaging.SubMaster(['logMessage', 'androidLog'], addr=args.addr)\n    while True:\n      sm.update()\n\n      if sm.updated['logMessage']:\n        print_logmessage(sm.logMonoTime['logMessage'], sm['logMessage'], min_level)\n\n      if sm.updated['androidLog']:\n        print_androidlog(sm.logMonoTime['androidLog'], sm['androidLog'])\n", "selfdrive/debug/can_table.py": "#!/usr/bin/env python3\nimport argparse\nimport pandas as pd\n\nimport cereal.messaging as messaging\n\n\ndef can_table(dat):\n  rows = []\n  for b in dat:\n    r = list(bin(b).lstrip('0b').zfill(8))\n    r += [hex(b)]\n    rows.append(r)\n\n  df = pd.DataFrame(data=rows)\n  df.columns = [str(n) for n in range(7, -1, -1)] + [' ']\n  table = df.to_markdown(tablefmt='grid')\n  return table\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Cabana-like table of bits for your terminal\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"addr\", type=str, nargs=1)\n  parser.add_argument(\"bus\", type=int, default=0, nargs='?')\n\n  args = parser.parse_args()\n\n  addr = int(args.addr[0], 0)\n  can = messaging.sub_sock('can', conflate=False, timeout=None)\n\n  print(f\"waiting for {hex(addr)} ({addr}) on bus {args.bus}...\")\n\n  latest = None\n  while True:\n    for msg in messaging.drain_sock(can, wait_for_one=True):\n      for m in msg.can:\n        if m.address == addr and m.src == args.bus:\n          latest = m\n\n    if latest is None:\n      continue\n\n    table = can_table(latest.dat)\n    print(f\"\\n\\n{hex(addr)} ({addr}) on bus {args.bus}\\n{table}\")\n", "selfdrive/debug/hyundai_enable_radar_points.py": "#!/usr/bin/env python3\n\"\"\"Some Hyundai radars can be reconfigured to output (debug) radar points on bus 1.\nReconfiguration is done over UDS by reading/writing to 0x0142 using the Read/Write Data By Identifier\nendpoints (0x22 & 0x2E). This script checks your radar firmware version against a list of known\nfirmware versions. If you want to try on a new radar make sure to note the default config value\nin case it's different from the other radars and you need to revert the changes.\n\nAfter changing the config the car should not show any faults when openpilot is not running.\nThese config changes are persistent across car reboots. You need to run this script again\nto go back to the default values.\n\nUSE AT YOUR OWN RISK! Safety features, like AEB and FCW, might be affected by these changes.\"\"\"\n\nimport sys\nimport argparse\nfrom typing import NamedTuple\nfrom subprocess import check_output, CalledProcessError\n\nfrom panda.python import Panda\nfrom panda.python.uds import UdsClient, SESSION_TYPE, DATA_IDENTIFIER_TYPE\n\nclass ConfigValues(NamedTuple):\n  default_config: bytes\n  tracks_enabled: bytes\n\n# If your radar supports changing data identifier 0x0142 as well make a PR to\n# this file to add your firmware version. Make sure to post a drive as proof!\n# NOTE: these firmware versions do not match what openpilot uses\n#       because this script uses a different diagnostic session type\nSUPPORTED_FW_VERSIONS = {\n  # 2020 SONATA\n  b\"DN8_ SCC FHCUP      1.00 1.00 99110-L0000\\x19\\x08)\\x15T    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  b\"DN8_ SCC F-CUP      1.00 1.00 99110-L0000\\x19\\x08)\\x15T    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2021 SONATA HYBRID\n  b\"DNhe SCC FHCUP      1.00 1.00 99110-L5000\\x19\\x04&\\x13'    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  b\"DNhe SCC FHCUP      1.00 1.02 99110-L5000 \\x01#\\x15#    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2020 PALISADE\n  b\"LX2_ SCC FHCUP      1.00 1.04 99110-S8100\\x19\\x05\\x02\\x16V    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2022 PALISADE\n  b\"LX2_ SCC FHCUP      1.00 1.00 99110-S8110!\\x04\\x05\\x17\\x01    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2020 SANTA FE\n  b\"TM__ SCC F-CUP      1.00 1.03 99110-S2000\\x19\\x050\\x13'    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2020 GENESIS G70\n  b'IK__ SCC F-CUP      1.00 1.02 96400-G9100\\x18\\x07\\x06\\x17\\x12    ': ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2019 SANTA FE\n  b\"TM__ SCC F-CUP      1.00 1.00 99110-S1210\\x19\\x01%\\x168    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  b\"TM__ SCC F-CUP      1.00 1.02 99110-S2000\\x18\\x07\\x08\\x18W    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n  # 2021 K5 HEV\n  b\"DLhe SCC FHCUP      1.00 1.02 99110-L7000 \\x01 \\x102    \": ConfigValues(\n    default_config=b\"\\x00\\x00\\x00\\x01\\x00\\x00\",\n    tracks_enabled=b\"\\x00\\x00\\x00\\x01\\x00\\x01\"),\n}\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description='configure radar to output points (or reset to default)')\n  parser.add_argument('--default', action=\"store_true\", default=False, help='reset to default configuration (default: false)')\n  parser.add_argument('--debug', action=\"store_true\", default=False, help='enable debug output (default: false)')\n  parser.add_argument('--bus', type=int, default=0, help='can bus to use (default: 0)')\n  args = parser.parse_args()\n\n  try:\n    check_output([\"pidof\", \"pandad\"])\n    print(\"pandad is running, please kill openpilot before running this script! (aborted)\")\n    sys.exit(1)\n  except CalledProcessError as e:\n    if e.returncode != 1: # 1 == no process found (pandad not running)\n      raise e\n\n  confirm = input(\"power on the vehicle keeping the engine off (press start button twice) then type OK to continue: \").upper().strip()\n  if confirm != \"OK\":\n    print(\"\\nyou didn't type 'OK! (aborted)\")\n    sys.exit(0)\n\n  panda = Panda()\n  panda.set_safety_mode(Panda.SAFETY_ELM327)\n  uds_client = UdsClient(panda, 0x7D0, bus=args.bus, debug=args.debug)\n\n  print(\"\\n[START DIAGNOSTIC SESSION]\")\n  session_type : SESSION_TYPE = 0x07 # type: ignore\n  uds_client.diagnostic_session_control(session_type)\n\n  print(\"[HARDWARE/SOFTWARE VERSION]\")\n  fw_version_data_id : DATA_IDENTIFIER_TYPE = 0xf100 # type: ignore\n  fw_version = uds_client.read_data_by_identifier(fw_version_data_id)\n  print(fw_version)\n  if fw_version not in SUPPORTED_FW_VERSIONS.keys():\n    print(\"radar not supported! (aborted)\")\n    sys.exit(1)\n\n  print(\"[GET CONFIGURATION]\")\n  config_data_id : DATA_IDENTIFIER_TYPE = 0x0142 # type: ignore\n  current_config = uds_client.read_data_by_identifier(config_data_id)\n  config_values = SUPPORTED_FW_VERSIONS[fw_version]\n  new_config = config_values.default_config if args.default else config_values.tracks_enabled\n  print(f\"current config: 0x{current_config.hex()}\")\n  if current_config != new_config:\n    print(\"[CHANGE CONFIGURATION]\")\n    print(f\"new config:     0x{new_config.hex()}\")\n    uds_client.write_data_by_identifier(config_data_id, new_config)\n    if not args.default and current_config != SUPPORTED_FW_VERSIONS[fw_version].default_config:\n      print(\"\\ncurrent config does not match expected default! (aborted)\")\n      sys.exit(1)\n\n    print(\"[DONE]\")\n    print(\"\\nrestart your vehicle and ensure there are no faults\")\n    if not args.default:\n      print(\"you can run this script again with --default to go back to the original (factory) settings\")\n  else:\n    print(\"[DONE]\")\n    print(\"\\ncurrent config is already the desired configuration\")\n    sys.exit(0)\n", "selfdrive/debug/can_printer.py": "#!/usr/bin/env python3\nimport argparse\nimport binascii\nimport time\nfrom collections import defaultdict\n\nimport cereal.messaging as messaging\n\n\ndef can_printer(bus, max_msg, addr, ascii_decode):\n  logcan = messaging.sub_sock('can', addr=addr)\n\n  start = time.monotonic()\n  lp = time.monotonic()\n  msgs = defaultdict(list)\n  while 1:\n    can_recv = messaging.drain_sock(logcan, wait_for_one=True)\n    for x in can_recv:\n      for y in x.can:\n        if y.src == bus:\n          msgs[y.address].append(y.dat)\n\n    if time.monotonic() - lp > 0.1:\n      dd = chr(27) + \"[2J\"\n      dd += f\"{time.monotonic() - start:5.2f}\\n\"\n      for addr in sorted(msgs.keys()):\n        a = f\"\\\"{msgs[addr][-1].decode('ascii', 'backslashreplace')}\\\"\" if ascii_decode else \"\"\n        x = binascii.hexlify(msgs[addr][-1]).decode('ascii')\n        freq = len(msgs[addr]) / (time.monotonic() - start)\n        if max_msg is None or addr < max_msg:\n          dd += \"%04X(%4d)(%6d)(%3dHz) %s %s\\n\" % (addr, addr, len(msgs[addr]), freq, x.ljust(20), a)\n      print(dd)\n      lp = time.monotonic()\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"simple CAN data viewer\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"--bus\", type=int, help=\"CAN bus to print out\", default=0)\n  parser.add_argument(\"--max_msg\", type=int, help=\"max addr\")\n  parser.add_argument(\"--ascii\", action='store_true', help=\"decode as ascii\")\n  parser.add_argument(\"--addr\", default=\"127.0.0.1\")\n\n  args = parser.parse_args()\n  can_printer(args.bus, args.max_msg, args.addr, args.ascii)\n", "selfdrive/debug/can_print_changes.py": "#!/usr/bin/env python3\nimport argparse\nimport binascii\nimport time\nfrom collections import defaultdict\n\nimport cereal.messaging as messaging\nfrom openpilot.selfdrive.debug.can_table import can_table\nfrom openpilot.tools.lib.logreader import LogIterable, LogReader\n\nRED = '\\033[91m'\nCLEAR = '\\033[0m'\n\ndef update(msgs, bus, dat, low_to_high, high_to_low, quiet=False):\n  for x in msgs:\n    if x.which() != 'can':\n      continue\n\n    for y in x.can:\n      if y.src == bus:\n        dat[y.address] = y.dat\n\n        i = int.from_bytes(y.dat, byteorder='big')\n        l_h = low_to_high[y.address]\n        h_l = high_to_low[y.address]\n\n        change = None\n        if (i | l_h) != l_h:\n          low_to_high[y.address] = i | l_h\n          change = \"+\"\n\n        if (~i | h_l) != h_l:\n          high_to_low[y.address] = ~i | h_l\n          change = \"-\"\n\n        if change and not quiet:\n          print(f\"{time.monotonic():.2f}\\t{hex(y.address)} ({y.address})\\t{change}{binascii.hexlify(y.dat)}\")\n\n\ndef can_printer(bus=0, init_msgs=None, new_msgs=None, table=False):\n  logcan = messaging.sub_sock('can', timeout=10)\n\n  dat = defaultdict(int)\n  low_to_high = defaultdict(int)\n  high_to_low = defaultdict(int)\n\n  if init_msgs is not None:\n    update(init_msgs, bus, dat, low_to_high, high_to_low, quiet=True)\n\n  low_to_high_init = low_to_high.copy()\n  high_to_low_init = high_to_low.copy()\n\n  if new_msgs is not None:\n    update(new_msgs, bus, dat, low_to_high, high_to_low)\n  else:\n    # Live mode\n    print(f\"Waiting for messages on bus {bus}\")\n    try:\n      while 1:\n        can_recv = messaging.drain_sock(logcan)\n        update(can_recv, bus, dat, low_to_high, high_to_low)\n        time.sleep(0.02)\n    except KeyboardInterrupt:\n      pass\n\n  print(\"\\n\\n\")\n  tables = \"\"\n  for addr in sorted(dat.keys()):\n    init = low_to_high_init[addr] & high_to_low_init[addr]\n    now = low_to_high[addr] & high_to_low[addr]\n    d = now & ~init\n    if d == 0:\n      continue\n    b = d.to_bytes(len(dat[addr]), byteorder='big')\n\n    byts = ''.join([(c if c == '0' else f'{RED}{c}{CLEAR}') for c in str(binascii.hexlify(b))[2:-1]])\n    header = f\"{hex(addr).ljust(6)}({str(addr).ljust(4)})\"\n    print(header, byts)\n    tables += f\"{header}\\n\"\n    tables += can_table(b) + \"\\n\\n\"\n\n  if table:\n    print(tables)\n\nif __name__ == \"__main__\":\n  desc = \"\"\"Collects messages and prints when a new bit transition is observed.\n  This is very useful to find signals based on user triggered actions, such as blinkers and seatbelt.\n  Leave the script running until no new transitions are seen, then perform the action.\"\"\"\n  parser = argparse.ArgumentParser(description=desc,\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"--bus\", type=int, help=\"CAN bus to print out\", default=0)\n  parser.add_argument(\"--table\", action=\"store_true\", help=\"Print a cabana-like table\")\n  parser.add_argument(\"init\", type=str, nargs='?', help=\"Route or segment to initialize with. Use empty quotes to compare against all zeros.\")\n  parser.add_argument(\"comp\", type=str, nargs='?', help=\"Route or segment to compare against init\")\n\n  args = parser.parse_args()\n\n  init_lr: LogIterable | None = None\n  new_lr: LogIterable | None = None\n\n  if args.init:\n    if args.init == '':\n      init_lr = []\n    else:\n      init_lr = LogReader(args.init)\n  if args.comp:\n    new_lr = LogReader(args.comp)\n\n  can_printer(args.bus, init_msgs=init_lr, new_msgs=new_lr, table=args.table)\n", "selfdrive/debug/toyota_eps_factor.py": "#!/usr/bin/env python3\nimport sys\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import linear_model\nfrom openpilot.selfdrive.car.toyota.values import STEER_THRESHOLD\n\nfrom openpilot.tools.lib.logreader import LogReader\n\nMIN_SAMPLES = 30 * 100\n\n\ndef to_signed(n, bits):\n  if n >= (1 << max((bits - 1), 0)):\n    n = n - (1 << max(bits, 0))\n  return n\n\n\ndef get_eps_factor(lr, plot=False):\n  engaged = False\n  steering_pressed = False\n  torque_cmd, eps_torque = None, None\n  cmds, eps = [], []\n\n  for msg in lr:\n    if msg.which() != 'can':\n      continue\n\n    for m in msg.can:\n      if m.address == 0x2e4 and m.src == 128:\n        engaged = bool(m.dat[0] & 1)\n        torque_cmd = to_signed((m.dat[1] << 8) | m.dat[2], 16)\n      elif m.address == 0x260 and m.src == 0:\n        eps_torque = to_signed((m.dat[5] << 8) | m.dat[6], 16)\n        steering_pressed = abs(to_signed((m.dat[1] << 8) | m.dat[2], 16)) > STEER_THRESHOLD\n\n    if engaged and torque_cmd is not None and eps_torque is not None and not steering_pressed:\n      cmds.append(torque_cmd)\n      eps.append(eps_torque)\n    else:\n      if len(cmds) > MIN_SAMPLES:\n        break\n      cmds, eps = [], []\n\n  if len(cmds) < MIN_SAMPLES:\n    raise Exception(\"too few samples found in route\")\n\n  lm = linear_model.LinearRegression(fit_intercept=False)\n  lm.fit(np.array(cmds).reshape(-1, 1), eps)\n  scale_factor = 1. / lm.coef_[0]\n\n  if plot:\n    plt.plot(np.array(eps) * scale_factor)\n    plt.plot(cmds)\n    plt.show()\n  return scale_factor\n\n\nif __name__ == \"__main__\":\n  lr = LogReader(sys.argv[1])\n  n = get_eps_factor(lr, plot=\"--plot\" in sys.argv)\n  print(\"EPS torque factor: \", n)\n", "selfdrive/debug/clear_dtc.py": "#!/usr/bin/env python3\nimport sys\nimport argparse\nfrom subprocess import check_output, CalledProcessError\nfrom panda import Panda\nfrom panda.python.uds import UdsClient, MessageTimeoutError, SESSION_TYPE, DTC_GROUP_TYPE\n\nparser = argparse.ArgumentParser(description=\"clear DTC status\")\nparser.add_argument(\"addr\", type=lambda x: int(x,0), nargs=\"?\", default=0x7DF) # default is functional (broadcast) address\nparser.add_argument(\"--bus\", type=int, default=0)\nparser.add_argument('--debug', action='store_true')\nargs = parser.parse_args()\n\ntry:\n  check_output([\"pidof\", \"pandad\"])\n  print(\"pandad is running, please kill openpilot before running this script! (aborted)\")\n  sys.exit(1)\nexcept CalledProcessError as e:\n  if e.returncode != 1: # 1 == no process found (pandad not running)\n    raise e\n\npanda = Panda()\npanda.set_safety_mode(Panda.SAFETY_ELM327)\nuds_client = UdsClient(panda, args.addr, bus=args.bus, debug=args.debug)\nprint(\"extended diagnostic session ...\")\ntry:\n  uds_client.diagnostic_session_control(SESSION_TYPE.EXTENDED_DIAGNOSTIC)\nexcept MessageTimeoutError:\n  # functional address isn't properly handled so a timeout occurs\n  if args.addr != 0x7DF:\n    raise\nprint(\"clear diagnostic info ...\")\ntry:\n  uds_client.clear_diagnostic_information(DTC_GROUP_TYPE.ALL)\nexcept MessageTimeoutError:\n  # functional address isn't properly handled so a timeout occurs\n  if args.addr != 0x7DF:\n    pass\nprint(\"\")\nprint(\"you may need to power cycle your vehicle now\")\n", "selfdrive/debug/fingerprint_from_route.py": "#!/usr/bin/env python3\n\nimport sys\nfrom openpilot.tools.lib.logreader import LogReader, ReadMode\n\n\ndef get_fingerprint(lr):\n  # TODO: make this a nice tool for car ports. should also work with qlogs for FW\n\n  fw = None\n  msgs = {}\n  for msg in lr:\n    if msg.which() == 'carParams':\n      fw = msg.carParams.carFw\n    elif msg.which() == 'can':\n      for c in msg.can:\n        # read also msgs sent by EON on CAN bus 0x80 and filter out the\n        # addr with more than 11 bits\n        if c.src % 0x80 == 0 and c.address < 0x800 and c.address not in (0x7df, 0x7e0, 0x7e8):\n          msgs[c.address] = len(c.dat)\n\n  # show CAN fingerprint\n  fingerprint = ', '.join(\"%d: %d\" % v for v in sorted(msgs.items()))\n  print(f\"\\nfound {len(msgs)} messages. CAN fingerprint:\\n\")\n  print(fingerprint)\n\n  # TODO: also print the fw fingerprint merged with the existing ones\n  # show FW fingerprint\n  print(\"\\nFW fingerprint:\\n\")\n  for f in fw:\n    print(f\"    (Ecu.{f.ecu}, {hex(f.address)}, {None if f.subAddress == 0 else f.subAddress}): [\")\n    print(f\"      {f.fwVersion},\")\n    print(\"    ],\")\n  print()\n\n\nif __name__ == \"__main__\":\n  if len(sys.argv) < 2:\n    print(\"Usage: ./fingerprint_from_route.py <route>\")\n    sys.exit(1)\n\n  lr = LogReader(sys.argv[1], ReadMode.QLOG)\n  get_fingerprint(lr)\n", "selfdrive/debug/count_events.py": "#!/usr/bin/env python3\nimport sys\nimport math\nimport datetime\nfrom collections import Counter\nfrom pprint import pprint\nfrom typing import cast\n\nfrom cereal.services import SERVICE_LIST\nfrom openpilot.tools.lib.logreader import LogReader, ReadMode\n\nif __name__ == \"__main__\":\n  cnt_events: Counter = Counter()\n\n  cams = [s for s in SERVICE_LIST if s.endswith('CameraState')]\n  cnt_cameras = dict.fromkeys(cams, 0)\n\n  events: list[tuple[float, set[str]]] = []\n  alerts: list[tuple[float, str]] = []\n  start_time = math.inf\n  end_time = -math.inf\n  ignition_off = None\n  for msg in LogReader(sys.argv[1], ReadMode.QLOG):\n    t = (msg.logMonoTime - start_time) / 1e9\n    end_time = max(end_time, msg.logMonoTime)\n    start_time = min(start_time, msg.logMonoTime)\n\n    if msg.which() == 'onroadEvents':\n      for e in msg.onroadEvents:\n        cnt_events[e.name] += 1\n\n      ae = {str(e.name) for e in msg.onroadEvents if e.name not in ('pedalPressed', 'steerOverride', 'gasPressedOverride')}\n      if len(events) == 0 or ae != events[-1][1]:\n        events.append((t, ae))\n\n    elif msg.which() == 'controlsState':\n      at = msg.controlsState.alertType\n      if \"/override\" not in at or \"lanechange\" in at.lower():\n        if len(alerts) == 0 or alerts[-1][1] != at:\n          alerts.append((t, at))\n    elif msg.which() == 'pandaStates':\n      if ignition_off is None:\n        ign = any(ps.ignitionLine or ps.ignitionCan for ps in msg.pandaStates)\n        if not ign:\n          ignition_off = msg.logMonoTime\n          break\n    elif msg.which() in cams:\n      cnt_cameras[msg.which()] += 1\n\n  duration = (end_time - start_time) / 1e9\n\n  print(\"Events\")\n  pprint(cnt_events)\n\n  print(\"\\n\")\n  print(\"Events\")\n  for t, evt in events:\n    print(f\"{t:8.2f} {evt}\")\n\n  print(\"\\n\")\n  print(\"Cameras\")\n  for k, v in cnt_cameras.items():\n    s = SERVICE_LIST[k]\n    expected_frames = int(s.frequency * duration / cast(float, s.decimation))\n    print(\"  \", k.ljust(20), f\"{v}, {v/expected_frames:.1%} of expected\")\n\n  print(\"\\n\")\n  print(\"Alerts\")\n  for t, a in alerts:\n    print(f\"{t:8.2f} {a}\")\n\n  print(\"\\n\")\n  if ignition_off is not None:\n    ignition_off = round((ignition_off - start_time) / 1e9, 2)\n  print(\"Ignition off at\",  ignition_off)\n  print(\"Route duration\", datetime.timedelta(seconds=duration))\n", "selfdrive/debug/__init__.py": "", "selfdrive/debug/check_freq.py": "#!/usr/bin/env python3\nimport argparse\nimport numpy as np\nimport time\nfrom collections import defaultdict, deque\nfrom collections.abc import MutableSequence\n\nimport cereal.messaging as messaging\n\n\nif __name__ == \"__main__\":\n  context = messaging.Context()\n  poller = messaging.Poller()\n\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\"socket\", type=str, nargs='*', help=\"socket name\")\n  args = parser.parse_args()\n\n  socket_names = args.socket\n  sockets = {}\n\n  rcv_times: defaultdict[str, MutableSequence[float]] = defaultdict(lambda: deque(maxlen=100))\n  valids: defaultdict[str, deque[bool]] = defaultdict(lambda: deque(maxlen=100))\n\n  t = time.monotonic()\n  for name in socket_names:\n    sock = messaging.sub_sock(name, poller=poller)\n    sockets[sock] = name\n\n  prev_print = t\n  while True:\n    for socket in poller.poll(100):\n      msg = messaging.recv_one(socket)\n      if msg is None:\n        continue\n\n      name = msg.which()\n\n      t = time.monotonic()\n      rcv_times[name].append(msg.logMonoTime / 1e9)\n      valids[name].append(msg.valid)\n\n    if t - prev_print > 1:\n      print()\n      for name in socket_names:\n        dts = np.diff(rcv_times[name])\n        mean = np.mean(dts)\n        print(f\"{name}: Freq {1.0 / mean:.2f} Hz, Min {np.min(dts) / mean * 100:.2f}%, Max {np.max(dts) / mean * 100:.2f}%, valid \", all(valids[name]))\n\n      prev_print = t\n", "selfdrive/debug/cycle_alerts.py": "#!/usr/bin/env python3\nimport time\nimport random\n\nfrom cereal import car, log\nimport cereal.messaging as messaging\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.car.honda.interface import CarInterface\nfrom openpilot.selfdrive.controls.lib.events import ET, Events\nfrom openpilot.selfdrive.controls.lib.alertmanager import AlertManager\nfrom openpilot.system.manager.process_config import managed_processes\n\nEventName = car.CarEvent.EventName\n\ndef randperc() -> float:\n  return 100. * random.random()\n\ndef cycle_alerts(duration=200, is_metric=False):\n  # all alerts\n  #alerts = list(EVENTS.keys())\n\n  # this plays each type of audible alert\n  alerts = [\n    (EventName.buttonEnable, ET.ENABLE),\n    (EventName.buttonCancel, ET.USER_DISABLE),\n    (EventName.wrongGear, ET.NO_ENTRY),\n\n    (EventName.locationdTemporaryError, ET.SOFT_DISABLE),\n    (EventName.paramsdTemporaryError, ET.SOFT_DISABLE),\n    (EventName.accFaulted, ET.IMMEDIATE_DISABLE),\n\n    # DM sequence\n    (EventName.preDriverDistracted, ET.WARNING),\n    (EventName.promptDriverDistracted, ET.WARNING),\n    (EventName.driverDistracted, ET.WARNING),\n  ]\n\n  # debug alerts\n  alerts = [\n    #(EventName.highCpuUsage, ET.NO_ENTRY),\n    #(EventName.lowMemory, ET.PERMANENT),\n    #(EventName.overheat, ET.PERMANENT),\n    #(EventName.outOfSpace, ET.PERMANENT),\n    #(EventName.modeldLagging, ET.PERMANENT),\n    #(EventName.processNotRunning, ET.NO_ENTRY),\n    #(EventName.commIssue, ET.NO_ENTRY),\n    #(EventName.calibrationInvalid, ET.PERMANENT),\n    (EventName.cameraMalfunction, ET.PERMANENT),\n    (EventName.cameraFrameRate, ET.PERMANENT),\n  ]\n\n  cameras = ['roadCameraState', 'wideRoadCameraState', 'driverCameraState']\n\n  CS = car.CarState.new_message()\n  CP = CarInterface.get_non_essential_params(\"HONDA_CIVIC\")\n  sm = messaging.SubMaster(['deviceState', 'pandaStates', 'roadCameraState', 'modelV2', 'liveCalibration',\n                            'driverMonitoringState', 'longitudinalPlan', 'liveLocationKalman',\n                            'managerState'] + cameras)\n\n  pm = messaging.PubMaster(['controlsState', 'pandaStates', 'deviceState'])\n\n  events = Events()\n  AM = AlertManager()\n\n  frame = 0\n  while True:\n    for alert, et in alerts:\n      events.clear()\n      events.add(alert)\n\n      sm['deviceState'].freeSpacePercent = randperc()\n      sm['deviceState'].memoryUsagePercent = int(randperc())\n      sm['deviceState'].cpuTempC = [randperc() for _ in range(3)]\n      sm['deviceState'].gpuTempC = [randperc() for _ in range(3)]\n      sm['deviceState'].cpuUsagePercent = [int(randperc()) for _ in range(8)]\n      sm['modelV2'].frameDropPerc = randperc()\n\n      if random.random() > 0.25:\n        sm['modelV2'].velocity.x = [random.random(), ]\n      if random.random() > 0.25:\n        CS.vEgo = random.random()\n\n      procs = [p.get_process_state_msg() for p in managed_processes.values()]\n      random.shuffle(procs)\n      for i in range(random.randint(0, 10)):\n        procs[i].shouldBeRunning = True\n      sm['managerState'].processes = procs\n\n      sm['liveCalibration'].rpyCalib = [-1 * random.random() for _ in range(random.randint(0, 3))]\n\n      for s in sm.data.keys():\n        prob = 0.3 if s in cameras else 0.08\n        sm.alive[s] = random.random() > prob\n        sm.valid[s] = random.random() > prob\n        sm.freq_ok[s] = random.random() > prob\n\n      a = events.create_alerts([et, ], [CP, CS, sm, is_metric, 0])\n      AM.add_many(frame, a)\n      alert = AM.process_alerts(frame, [])\n      print(alert)\n      for _ in range(duration):\n        dat = messaging.new_message()\n        dat.init('controlsState')\n        dat.controlsState.enabled = False\n\n        if alert:\n          dat.controlsState.alertText1 = alert.alert_text_1\n          dat.controlsState.alertText2 = alert.alert_text_2\n          dat.controlsState.alertSize = alert.alert_size\n          dat.controlsState.alertStatus = alert.alert_status\n          dat.controlsState.alertBlinkingRate = alert.alert_rate\n          dat.controlsState.alertType = alert.alert_type\n          dat.controlsState.alertSound = alert.audible_alert\n        pm.send('controlsState', dat)\n\n        dat = messaging.new_message()\n        dat.init('deviceState')\n        dat.deviceState.started = True\n        pm.send('deviceState', dat)\n\n        dat = messaging.new_message('pandaStates', 1)\n        dat.pandaStates[0].ignitionLine = True\n        dat.pandaStates[0].pandaType = log.PandaState.PandaType.uno\n        pm.send('pandaStates', dat)\n\n        frame += 1\n        time.sleep(DT_CTRL)\n\nif __name__ == '__main__':\n  cycle_alerts()\n", "selfdrive/debug/print_flags.py": "#!/usr/bin/env python3\nfrom openpilot.selfdrive.car.values import BRANDS\n\nfor brand in BRANDS:\n  all_flags = set()\n  for platform in brand:\n    if platform.config.flags != 0:\n      all_flags |= set(platform.config.flags)\n\n  if len(all_flags):\n    print(brand.__module__.split('.')[-2].upper() + ':')\n    for flag in sorted(all_flags):\n      print(f'  {flag.name:<24}:', {platform.name for platform in brand.with_flags(flag)})\n    print()\n", "selfdrive/debug/uiview.py": "#!/usr/bin/env python3\nimport time\n\nfrom cereal import car, log, messaging\nfrom openpilot.common.params import Params\nfrom openpilot.system.manager.process_config import managed_processes\nfrom openpilot.system.hardware import HARDWARE\n\nif __name__ == \"__main__\":\n  CP = car.CarParams(notCar=True, wheelbase=1, steerRatio=10)\n  Params().put(\"CarParams\", CP.to_bytes())\n\n  procs = ['camerad', 'ui', 'modeld', 'calibrationd', 'plannerd', 'dmonitoringmodeld', 'dmonitoringd']\n  for p in procs:\n    managed_processes[p].start()\n\n  pm = messaging.PubMaster(['controlsState', 'deviceState', 'pandaStates', 'carParams'])\n\n  msgs = {s: messaging.new_message(s) for s in ['controlsState', 'deviceState', 'carParams']}\n  msgs['deviceState'].deviceState.started = True\n  msgs['deviceState'].deviceState.deviceType = HARDWARE.get_device_type()\n  msgs['carParams'].carParams.openpilotLongitudinalControl = True\n\n  msgs['pandaStates'] = messaging.new_message('pandaStates', 1)\n  msgs['pandaStates'].pandaStates[0].ignitionLine = True\n  msgs['pandaStates'].pandaStates[0].pandaType = log.PandaState.PandaType.uno\n\n  try:\n    while True:\n      time.sleep(1 / 100)  # continually send, rate doesn't matter\n      for s in msgs:\n        pm.send(s, msgs[s])\n  except KeyboardInterrupt:\n    for p in procs:\n      managed_processes[p].stop()\n", "selfdrive/debug/vw_mqb_config.py": "#!/usr/bin/env python3\n\nimport argparse\nimport struct\nfrom enum import IntEnum\nfrom panda import Panda\nfrom panda.python.uds import UdsClient, MessageTimeoutError, NegativeResponseError, SESSION_TYPE,\\\n  DATA_IDENTIFIER_TYPE, ACCESS_TYPE\nfrom datetime import date\n\n# TODO: extend UDS library to allow custom/vendor-defined data identifiers without ignoring type checks\nclass VOLKSWAGEN_DATA_IDENTIFIER_TYPE(IntEnum):\n  CODING = 0x0600\n\n# TODO: extend UDS library security_access() to take an access level offset per ISO 14229-1:2020 10.4 and remove this\nclass ACCESS_TYPE_LEVEL_1(IntEnum):\n  REQUEST_SEED = ACCESS_TYPE.REQUEST_SEED + 2\n  SEND_KEY = ACCESS_TYPE.SEND_KEY + 2\n\nMQB_EPS_CAN_ADDR = 0x712\nRX_OFFSET = 0x6a\n\nif __name__ == \"__main__\":\n  desc_text =   \"Shows Volkswagen EPS software and coding info, and enables or disables Heading Control Assist \" + \\\n                \"(Lane Assist). Useful for enabling HCA on cars without factory Lane Assist that want to use \" + \\\n                \"openpilot integrated at the CAN gateway (J533).\"\n  epilog_text = \"This tool is meant to run directly on a vehicle-installed comma three, with the \" + \\\n                \"openpilot/tmux processes stopped. It should also work on a separate PC with a USB-attached comma \" + \\\n                \"panda. Vehicle ignition must be on. Recommend engine not be running when making changes. Must \" + \\\n                \"turn ignition off and on again for any changes to take effect.\"\n  parser = argparse.ArgumentParser(description=desc_text, epilog=epilog_text)\n  parser.add_argument(\"--debug\", action=\"store_true\", help=\"enable ISO-TP/UDS stack debugging output\")\n  parser.add_argument(\"action\", choices={\"show\", \"enable\", \"disable\"}, help=\"show or modify current EPS HCA config\")\n  args = parser.parse_args()\n\n  panda = Panda()\n  panda.set_safety_mode(Panda.SAFETY_ELM327)\n  bus = 1 if panda.has_obd() else 0\n  uds_client = UdsClient(panda, MQB_EPS_CAN_ADDR, MQB_EPS_CAN_ADDR + RX_OFFSET, bus, timeout=0.2, debug=args.debug)\n\n  try:\n    uds_client.diagnostic_session_control(SESSION_TYPE.EXTENDED_DIAGNOSTIC)\n  except MessageTimeoutError:\n    print(\"Timeout opening session with EPS\")\n    quit()\n\n  odx_file, current_coding = None, None\n  try:\n    hw_pn = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_ECU_HARDWARE_NUMBER).decode(\"utf-8\")\n    sw_pn = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_SPARE_PART_NUMBER).decode(\"utf-8\")\n    sw_ver = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_ECU_SOFTWARE_VERSION_NUMBER).decode(\"utf-8\")\n    component = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.SYSTEM_NAME_OR_ENGINE_TYPE).decode(\"utf-8\")\n    odx_file = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.ODX_FILE).decode(\"utf-8\").rstrip('\\x00')\n    current_coding = uds_client.read_data_by_identifier(VOLKSWAGEN_DATA_IDENTIFIER_TYPE.CODING)  # type: ignore\n    coding_text = current_coding.hex()\n\n    print(\"\\nEPS diagnostic data\\n\")\n    print(f\"   Part No HW:   {hw_pn}\")\n    print(f\"   Part No SW:   {sw_pn}\")\n    print(f\"   SW Version:   {sw_ver}\")\n    print(f\"   Component:    {component}\")\n    print(f\"   Coding:       {coding_text}\")\n    print(f\"   ASAM Dataset: {odx_file}\")\n  except NegativeResponseError:\n    print(\"Error fetching data from EPS\")\n    quit()\n  except MessageTimeoutError:\n    print(\"Timeout fetching data from EPS\")\n    quit()\n\n  coding_variant, current_coding_array, coding_byte, coding_bit = None, None, 0, 0\n  coding_length = len(current_coding)\n\n  # EPS_MQB_ZFLS\n  if odx_file in (\"EV_SteerAssisMQB\", \"EV_SteerAssisMNB\"):\n    coding_variant = \"ZFLS\"\n    coding_byte = 0\n    coding_bit = 4\n\n  # MQB_PP_APA, MQB_VWBS_GEN2\n  elif odx_file in (\"EV_SteerAssisVWBSMQBA\", \"EV_SteerAssisVWBSMQBGen2\"):\n    coding_variant = \"APA\"\n    coding_byte = 3\n    coding_bit = 0\n\n  else:\n    print(\"Configuration changes not yet supported on this EPS!\")\n    quit()\n\n  current_coding_array = struct.unpack(f\"!{coding_length}B\", current_coding)\n  hca_enabled = (current_coding_array[coding_byte] & (1 << coding_bit) != 0)\n  hca_text = (\"DISABLED\", \"ENABLED\")[hca_enabled]\n  print(f\"   Lane Assist:  {hca_text}\")\n\n  try:\n    params = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.APPLICATION_DATA_IDENTIFICATION).decode(\"utf-8\")\n    param_version_system_params = params[1:3]\n    param_vehicle_type = params[3:5]\n    param_index_char_curve = params[5:7]\n    param_version_char_values = params[7:9]\n    param_version_memory_map = params[9:11]\n    print(\"\\nEPS parameterization (per-vehicle calibration) data\\n\")\n    print(f\"   Version of system parameters:     {param_version_system_params}\")\n    print(f\"   Vehicle type:                     {param_vehicle_type}\")\n    print(f\"   Index of characteristic curve:    {param_index_char_curve}\")\n    print(f\"   Version of characteristic values: {param_version_char_values}\")\n    print(f\"   Version of memory map:            {param_version_memory_map}\")\n  except (NegativeResponseError, MessageTimeoutError):\n    print(\"Error fetching parameterization data from EPS!\")\n    quit()\n\n  if args.action in [\"enable\", \"disable\"]:\n    print(\"\\nAttempting configuration update\")\n\n    assert(coding_variant in (\"ZFLS\", \"APA\"))\n    # ZFLS EPS config coding length can be anywhere from 1 to 4 bytes, but the\n    # bit we care about is always in the same place in the first byte\n    if args.action == \"enable\":\n      new_byte = current_coding_array[coding_byte] | (1 << coding_bit)\n    else:\n      new_byte = current_coding_array[coding_byte] & ~(1 << coding_bit)\n    new_coding = current_coding[0:coding_byte] + new_byte.to_bytes(1, \"little\") + current_coding[coding_byte+1:]\n\n    try:\n      seed = uds_client.security_access(ACCESS_TYPE_LEVEL_1.REQUEST_SEED)  # type: ignore\n      key = struct.unpack(\"!I\", seed)[0] + 28183  # yeah, it's like that\n      uds_client.security_access(ACCESS_TYPE_LEVEL_1.SEND_KEY, struct.pack(\"!I\", key))  # type: ignore\n    except (NegativeResponseError, MessageTimeoutError):\n      print(\"Security access failed!\")\n      print(\"Open the hood and retry (disables the \\\"diagnostic firewall\\\" on newer vehicles)\")\n      quit()\n\n    try:\n      # Programming date and tester number must be written before making\n      # a change, or write to CODING will fail with request sequence error\n      # Encoding on tester is unclear, it contains the workshop code in the\n      # last two bytes, but not the VZ/importer or tester serial number\n      # Can't seem to read it back, but we can read the calibration tester,\n      # so fib a little and say that same tester did the programming\n      current_date = date.today()\n      formatted_date = current_date.strftime('%y-%m-%d')\n      year, month, day = (int(part) for part in formatted_date.split('-'))\n      prog_date = bytes([year, month, day])\n      uds_client.write_data_by_identifier(DATA_IDENTIFIER_TYPE.PROGRAMMING_DATE, prog_date)\n      tester_num = uds_client.read_data_by_identifier(DATA_IDENTIFIER_TYPE.CALIBRATION_REPAIR_SHOP_CODE_OR_CALIBRATION_EQUIPMENT_SERIAL_NUMBER)\n      uds_client.write_data_by_identifier(DATA_IDENTIFIER_TYPE.REPAIR_SHOP_CODE_OR_TESTER_SERIAL_NUMBER, tester_num)\n      uds_client.write_data_by_identifier(VOLKSWAGEN_DATA_IDENTIFIER_TYPE.CODING, new_coding)  # type: ignore\n    except (NegativeResponseError, MessageTimeoutError):\n      print(\"Writing new configuration failed!\")\n      print(\"Make sure the comma processes are stopped: tmux kill-session -t comma\")\n      quit()\n\n    try:\n      # Read back result just to make 100% sure everything worked\n      current_coding_text = uds_client.read_data_by_identifier(VOLKSWAGEN_DATA_IDENTIFIER_TYPE.CODING).hex()  # type: ignore\n      print(f\"   New coding:   {current_coding_text}\")\n    except (NegativeResponseError, MessageTimeoutError):\n      print(\"Reading back updated coding failed!\")\n      quit()\n    print(\"EPS configuration successfully updated\")\n", "selfdrive/debug/check_timings.py": "#!/usr/bin/env python3\nimport sys\nimport time\nimport numpy as np\nimport datetime\nfrom collections.abc import MutableSequence\nfrom collections import defaultdict\n\nimport cereal.messaging as messaging\n\n\nif __name__ == \"__main__\":\n  ts: defaultdict[str, MutableSequence[float]] = defaultdict(list)\n  socks = {s: messaging.sub_sock(s, conflate=False) for s in sys.argv[1:]}\n  try:\n    st = time.monotonic()\n    while True:\n      print()\n      for s, sock in socks.items():\n        msgs = messaging.drain_sock(sock)\n        for m in msgs:\n          ts[s].append(m.logMonoTime / 1e6)\n\n        if len(ts[s]) > 2:\n          d = np.diff(ts[s])[-100:]\n          print(f\"{s:25} {np.mean(d):7.2f} {np.std(d):7.2f} {np.max(d):7.2f} {np.min(d):7.2f}\")\n      time.sleep(1)\n  except KeyboardInterrupt:\n    print(\"\\n\")\n    print(\"=\"*5, \"timing summary\", \"=\"*5)\n    for s, sock in socks.items():\n      msgs = messaging.drain_sock(sock)\n      if len(ts[s]) > 2:\n        d = np.diff(ts[s])\n        print(f\"{s:25} {np.mean(d):7.2f} {np.std(d):7.2f} {np.max(d):7.2f} {np.min(d):7.2f}\")\n    print(\"=\"*5, datetime.timedelta(seconds=time.monotonic()-st), \"=\"*5)\n", "selfdrive/debug/run_process_on_route.py": "#!/usr/bin/env python3\n\nimport argparse\n\nfrom openpilot.selfdrive.test.process_replay.process_replay import CONFIGS, replay_process\nfrom openpilot.tools.lib.helpers import save_log\nfrom openpilot.tools.lib.logreader import LogReader\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Run process on route and create new logs\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"--fingerprint\", help=\"The fingerprint to use\")\n  parser.add_argument(\"route\", help=\"The route name to use\")\n  parser.add_argument(\"process\", help=\"The process to run\")\n  args = parser.parse_args()\n\n  cfg = [c for c in CONFIGS if c.proc_name == args.process][0]\n\n  lr = LogReader(args.route)\n  inputs = list(lr)\n\n  outputs = replay_process(cfg, inputs, fingerprint=args.fingerprint)\n\n  # Remove message generated by the process under test and merge in the new messages\n  produces = {o.which() for o in outputs}\n  inputs = [i for i in inputs if i.which() not in produces]\n  outputs = sorted(inputs + outputs, key=lambda x: x.logMonoTime)\n\n  fn = f\"{args.route.replace('/', '_')}_{args.process}.bz2\"\n  print(f\"Saved log to {fn}\")\n  save_log(fn, outputs)\n", "selfdrive/debug/internal/fuzz_fw_fingerprint.py": "#!/usr/bin/env python3\n# type: ignore\nimport random\nfrom collections import defaultdict\n\nfrom tqdm import tqdm\n\nfrom openpilot.selfdrive.car.fw_versions import match_fw_to_car_fuzzy\nfrom openpilot.selfdrive.car.toyota.values import FW_VERSIONS as TOYOTA_FW_VERSIONS\nfrom openpilot.selfdrive.car.honda.values import FW_VERSIONS as HONDA_FW_VERSIONS\nfrom openpilot.selfdrive.car.hyundai.values import FW_VERSIONS as HYUNDAI_FW_VERSIONS\nfrom openpilot.selfdrive.car.volkswagen.values import FW_VERSIONS as VW_FW_VERSIONS\n\n\nFWS = {}\nFWS.update(TOYOTA_FW_VERSIONS)\nFWS.update(HONDA_FW_VERSIONS)\nFWS.update(HYUNDAI_FW_VERSIONS)\nFWS.update(VW_FW_VERSIONS)\n\nif __name__ == \"__main__\":\n  total = 0\n  match = 0\n  wrong_match = 0\n  confusions = defaultdict(set)\n\n  for _ in tqdm(range(1000)):\n    for candidate, fws in FWS.items():\n      fw_dict = {}\n      for (_, addr, subaddr), fw_list in fws.items():\n        fw_dict[(addr, subaddr)] = [random.choice(fw_list)]\n\n      matches = match_fw_to_car_fuzzy(fw_dict, log=False, exclude=candidate)\n\n      total += 1\n      if len(matches) == 1:\n        if list(matches)[0] == candidate:\n          match += 1\n        else:\n          confusions[candidate] |= matches\n          wrong_match += 1\n\n  print()\n  for candidate, wrong_matches in sorted(confusions.items()):\n    print(candidate, wrong_matches)\n\n  print()\n  print(f\"Total fuzz cases: {total}\")\n  print(f\"Correct matches:  {match}\")\n  print(f\"Wrong matches:    {wrong_match}\")\n\n\n", "selfdrive/debug/internal/measure_modeld_packet_drop.py": "#!/usr/bin/env python3\nimport cereal.messaging as messaging\n\nif __name__ == \"__main__\":\n  modeld_sock = messaging.sub_sock(\"modelV2\")\n\n  last_frame_id = None\n  start_t: int | None = None\n  frame_cnt = 0\n  dropped = 0\n\n  while True:\n    m = messaging.recv_one(modeld_sock)\n    if m is None:\n      continue\n\n    frame_id = m.modelV2.frameId\n    t = m.logMonoTime / 1e9\n    frame_cnt += 1\n\n    if start_t is None:\n      start_t = t\n      last_frame_id = frame_id\n      continue\n\n    d_frame = frame_id - last_frame_id\n    dropped += d_frame - 1\n\n    expected_num_frames = int((t - start_t) * 20)\n    frame_drop = 100 * (1 - (expected_num_frames / frame_cnt))\n    print(f\"Num dropped {dropped}, Drop compared to 20Hz: {frame_drop:.2f}%\")\n\n    last_frame_id = frame_id\n", "selfdrive/debug/internal/qlog_size.py": "#!/usr/bin/env python3\nimport argparse\nimport bz2\nfrom collections import defaultdict\n\nimport matplotlib.pyplot as plt\n\nfrom openpilot.tools.lib.logreader import LogReader\nfrom tqdm import tqdm\n\nMIN_SIZE = 0.5  # Percent size of total to show as separate entry\n\n\ndef make_pie(msgs, typ):\n  msgs_by_type = defaultdict(list)\n  for m in msgs:\n    msgs_by_type[m.which()].append(m.as_builder().to_bytes())\n\n  total = len(bz2.compress(b\"\".join([m.as_builder().to_bytes() for m in msgs])))\n  uncompressed_total = len(b\"\".join([m.as_builder().to_bytes() for m in msgs]))\n\n  length_by_type = {k: len(b\"\".join(v)) for k, v in msgs_by_type.items()}\n  # calculate compressed size by calculating diff when removed from the segment\n  compressed_length_by_type = {}\n  for k in tqdm(msgs_by_type.keys(), desc=\"Compressing\"):\n    compressed_length_by_type[k] = total - len(bz2.compress(b\"\".join([m.as_builder().to_bytes() for m in msgs if m.which() != k])))\n\n  sizes = sorted(compressed_length_by_type.items(), key=lambda kv: kv[1])\n\n  print(\"name - comp. size (uncomp. size)\")\n  for (name, sz) in sizes:\n    print(f\"{name:<22} - {sz / 1024:.2f} kB ({length_by_type[name] / 1024:.2f} kB)\")\n  print()\n  print(f\"{typ} - Real total {total / 1024:.2f} kB\")\n  print(f\"{typ} - Breakdown total {sum(compressed_length_by_type.values()) / 1024:.2f} kB\")\n  print(f\"{typ} - Uncompressed total {uncompressed_total / 1024 / 1024:.2f} MB\")\n\n  sizes_large = [(k, sz) for (k, sz) in sizes if sz >= total * MIN_SIZE / 100]\n  sizes_large += [('other', sum(sz for (_, sz) in sizes if sz < total * MIN_SIZE / 100))]\n\n  labels, sizes = zip(*sizes_large, strict=True)\n\n  plt.figure()\n  plt.title(f\"{typ}\")\n  plt.pie(sizes, labels=labels, autopct='%1.1f%%')\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description='View log size breakdown by message type')\n  parser.add_argument('route', help='route to use')\n  args = parser.parse_args()\n\n  msgs = list(LogReader(args.route))\n\n  make_pie(msgs, 'qlog')\n  plt.show()\n", "selfdrive/debug/internal/measure_torque_time_to_max.py": "#!/usr/bin/env python3\n# type: ignore\n\nimport os\nimport argparse\nimport struct\nfrom collections import deque\nfrom statistics import mean\n\nfrom cereal import log\nimport cereal.messaging as messaging\n\nif __name__ == \"__main__\":\n\n  parser = argparse.ArgumentParser(description='Sniff a communication socket')\n  parser.add_argument('--addr', default='127.0.0.1')\n  args = parser.parse_args()\n\n  if args.addr != \"127.0.0.1\":\n    os.environ[\"ZMQ\"] = \"1\"\n    messaging.context = messaging.Context()\n\n  poller = messaging.Poller()\n  messaging.sub_sock('can', poller, addr=args.addr)\n\n  active = 0\n  start_t = 0\n  start_v = 0\n  max_v = 0\n  max_t = 0\n  window = deque(maxlen=10)\n  avg = 0\n  while 1:\n    polld = poller.poll(1000)\n    for sock in polld:\n      msg = sock.receive()\n      with log.Event.from_bytes(msg) as log_evt:\n        evt = log_evt\n\n      for item in evt.can:\n        if item.address == 0xe4 and item.src == 128:\n          torque_req = struct.unpack('!h', item.dat[0:2])[0]\n          # print(torque_req)\n          active = abs(torque_req) > 0\n          if abs(torque_req) < 100:\n            if max_v > 5:\n              print(f'{start_v} -> {max_v} = {round(max_v - start_v, 2)} over {round(max_t - start_t, 2)}s')\n            start_t = evt.logMonoTime / 1e9\n            start_v = avg\n            max_t = 0\n            max_v = 0\n        if item.address == 0x1ab and item.src == 0:\n          motor_torque = ((item.dat[0] & 0x3) << 8) + item.dat[1]\n          window.append(motor_torque)\n          avg = mean(window)\n          #print(f'{evt.logMonoTime}: {avg}')\n          if active and avg > max_v + 0.5:\n            max_v = avg\n            max_t = evt.logMonoTime / 1e9\n", "selfdrive/debug/internal/__init__.py": "", "selfdrive/controls/plannerd.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import Priority, config_realtime_process\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.selfdrive.controls.lib.longitudinal_planner import LongitudinalPlanner\nimport cereal.messaging as messaging\n\n\ndef plannerd_thread():\n  config_realtime_process(5, Priority.CTRL_LOW)\n\n  cloudlog.info(\"plannerd is waiting for CarParams\")\n  params = Params()\n  with car.CarParams.from_bytes(params.get(\"CarParams\", block=True)) as msg:\n    CP = msg\n  cloudlog.info(\"plannerd got CarParams: %s\", CP.carName)\n\n  longitudinal_planner = LongitudinalPlanner(CP)\n  pm = messaging.PubMaster(['longitudinalPlan'])\n  sm = messaging.SubMaster(['carControl', 'carState', 'controlsState', 'radarState', 'modelV2'],\n                           poll='modelV2', ignore_avg_freq=['radarState'])\n\n  while True:\n    sm.update()\n    if sm.updated['modelV2']:\n      longitudinal_planner.update(sm)\n      longitudinal_planner.publish(sm, pm)\n\n\ndef main():\n  plannerd_thread()\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/controls/__init__.py": "", "selfdrive/controls/controlsd.py": "#!/usr/bin/env python3\nimport os\nimport math\nimport time\nimport threading\nfrom typing import SupportsFloat\n\nimport cereal.messaging as messaging\n\nfrom cereal import car, log\nfrom msgq.visionipc import VisionIpcClient, VisionStreamType\n\n\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.git import get_short_branch\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import config_realtime_process, Priority, Ratekeeper, DT_CTRL\nfrom openpilot.common.swaglog import cloudlog\n\nfrom openpilot.selfdrive.car.car_helpers import get_car_interface, get_startup_event\nfrom openpilot.selfdrive.controls.lib.alertmanager import AlertManager, set_offroad_alert\nfrom openpilot.selfdrive.controls.lib.drive_helpers import VCruiseHelper, clip_curvature\nfrom openpilot.selfdrive.controls.lib.events import Events, ET\nfrom openpilot.selfdrive.controls.lib.latcontrol import LatControl, MIN_LATERAL_CONTROL_SPEED\nfrom openpilot.selfdrive.controls.lib.latcontrol_pid import LatControlPID\nfrom openpilot.selfdrive.controls.lib.latcontrol_angle import LatControlAngle, STEER_ANGLE_SATURATION_THRESHOLD\nfrom openpilot.selfdrive.controls.lib.latcontrol_torque import LatControlTorque\nfrom openpilot.selfdrive.controls.lib.longcontrol import LongControl\nfrom openpilot.selfdrive.controls.lib.vehicle_model import VehicleModel\n\nfrom openpilot.system.hardware import HARDWARE\n\nSOFT_DISABLE_TIME = 3  # seconds\nLDW_MIN_SPEED = 31 * CV.MPH_TO_MS\nLANE_DEPARTURE_THRESHOLD = 0.1\nCAMERA_OFFSET = 0.04\n\nREPLAY = \"REPLAY\" in os.environ\nSIMULATION = \"SIMULATION\" in os.environ\nTESTING_CLOSET = \"TESTING_CLOSET\" in os.environ\nIGNORE_PROCESSES = {\"loggerd\", \"encoderd\", \"statsd\"}\n\nThermalStatus = log.DeviceState.ThermalStatus\nState = log.ControlsState.OpenpilotState\nPandaType = log.PandaState.PandaType\nDesire = log.Desire\nLaneChangeState = log.LaneChangeState\nLaneChangeDirection = log.LaneChangeDirection\nEventName = car.CarEvent.EventName\nButtonType = car.CarState.ButtonEvent.Type\nSafetyModel = car.CarParams.SafetyModel\n\nIGNORED_SAFETY_MODES = (SafetyModel.silent, SafetyModel.noOutput)\nCSID_MAP = {\"1\": EventName.roadCameraError, \"2\": EventName.wideRoadCameraError, \"0\": EventName.driverCameraError}\nACTUATOR_FIELDS = tuple(car.CarControl.Actuators.schema.fields.keys())\nACTIVE_STATES = (State.enabled, State.softDisabling, State.overriding)\nENABLED_STATES = (State.preEnabled, *ACTIVE_STATES)\n\n\nclass Controls:\n  def __init__(self, CI=None):\n    self.params = Params()\n\n    if CI is None:\n      cloudlog.info(\"controlsd is waiting for CarParams\")\n      with car.CarParams.from_bytes(self.params.get(\"CarParams\", block=True)) as msg:\n        # TODO: this shouldn't need to be a builder\n        self.CP = msg.as_builder()\n      cloudlog.info(\"controlsd got CarParams\")\n\n      # Uses car interface helper functions, altering state won't be considered by card for actuation\n      self.CI = get_car_interface(self.CP)\n    else:\n      self.CI, self.CP = CI, CI.CP\n\n    # Ensure the current branch is cached, otherwise the first iteration of controlsd lags\n    self.branch = get_short_branch()\n\n    # Setup sockets\n    self.pm = messaging.PubMaster(['controlsState', 'carControl', 'onroadEvents'])\n\n    self.sensor_packets = [\"accelerometer\", \"gyroscope\"]\n    self.camera_packets = [\"roadCameraState\", \"driverCameraState\", \"wideRoadCameraState\"]\n\n    self.log_sock = messaging.sub_sock('androidLog')\n\n    # TODO: de-couple controlsd with card/conflate on carState without introducing controls mismatches\n    self.car_state_sock = messaging.sub_sock('carState', timeout=20)\n\n    ignore = self.sensor_packets + ['testJoystick']\n    if SIMULATION:\n      ignore += ['driverCameraState', 'managerState']\n    if REPLAY:\n      # no vipc in replay will make them ignored anyways\n      ignore += ['roadCameraState', 'wideRoadCameraState']\n    self.sm = messaging.SubMaster(['deviceState', 'pandaStates', 'peripheralState', 'modelV2', 'liveCalibration',\n                                   'carOutput', 'driverMonitoringState', 'longitudinalPlan', 'liveLocationKalman',\n                                   'managerState', 'liveParameters', 'radarState', 'liveTorqueParameters',\n                                   'testJoystick'] + self.camera_packets + self.sensor_packets,\n                                  ignore_alive=ignore, ignore_avg_freq=ignore+['radarState', 'testJoystick'], ignore_valid=['testJoystick', ],\n                                  frequency=int(1/DT_CTRL))\n\n    self.joystick_mode = self.params.get_bool(\"JoystickDebugMode\")\n\n    # read params\n    self.is_metric = self.params.get_bool(\"IsMetric\")\n    self.is_ldw_enabled = self.params.get_bool(\"IsLdwEnabled\")\n\n    # detect sound card presence and ensure successful init\n    sounds_available = HARDWARE.get_sound_card_online()\n\n    car_recognized = self.CP.carName != 'mock'\n\n    # cleanup old params\n    if not self.CP.experimentalLongitudinalAvailable:\n      self.params.remove(\"ExperimentalLongitudinalEnabled\")\n    if not self.CP.openpilotLongitudinalControl:\n      self.params.remove(\"ExperimentalMode\")\n\n    self.CS_prev = car.CarState.new_message()\n    self.AM = AlertManager()\n    self.events = Events()\n\n    self.LoC = LongControl(self.CP)\n    self.VM = VehicleModel(self.CP)\n\n    self.LaC: LatControl\n    if self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n      self.LaC = LatControlAngle(self.CP, self.CI)\n    elif self.CP.lateralTuning.which() == 'pid':\n      self.LaC = LatControlPID(self.CP, self.CI)\n    elif self.CP.lateralTuning.which() == 'torque':\n      self.LaC = LatControlTorque(self.CP, self.CI)\n\n    self.initialized = False\n    self.state = State.disabled\n    self.enabled = False\n    self.active = False\n    self.soft_disable_timer = 0\n    self.mismatch_counter = 0\n    self.cruise_mismatch_counter = 0\n    self.last_blinker_frame = 0\n    self.last_steering_pressed_frame = 0\n    self.distance_traveled = 0\n    self.last_functional_fan_frame = 0\n    self.events_prev = []\n    self.current_alert_types = [ET.PERMANENT]\n    self.logged_comm_issue = None\n    self.not_running_prev = None\n    self.steer_limited = False\n    self.desired_curvature = 0.0\n    self.experimental_mode = False\n    self.personality = self.read_personality_param()\n    self.v_cruise_helper = VCruiseHelper(self.CP)\n    self.recalibrating_seen = False\n\n    self.can_log_mono_time = 0\n\n    self.startup_event = get_startup_event(car_recognized, not self.CP.passive, len(self.CP.carFw) > 0)\n\n    if not sounds_available:\n      self.events.add(EventName.soundsUnavailable, static=True)\n    if not car_recognized:\n      self.events.add(EventName.carUnrecognized, static=True)\n      if len(self.CP.carFw) > 0:\n        set_offroad_alert(\"Offroad_CarUnrecognized\", True)\n      else:\n        set_offroad_alert(\"Offroad_NoFirmware\", True)\n    elif self.CP.passive:\n      self.events.add(EventName.dashcamMode, static=True)\n\n    # controlsd is driven by carState, expected at 100Hz\n    self.rk = Ratekeeper(100, print_delay_threshold=None)\n\n  def set_initial_state(self):\n    if REPLAY:\n      controls_state = self.params.get(\"ReplayControlsState\")\n      if controls_state is not None:\n        with log.ControlsState.from_bytes(controls_state) as controls_state:\n          self.v_cruise_helper.v_cruise_kph = controls_state.vCruise\n\n      if any(ps.controlsAllowed for ps in self.sm['pandaStates']):\n        self.state = State.enabled\n\n  def update_events(self, CS):\n    \"\"\"Compute onroadEvents from carState\"\"\"\n\n    self.events.clear()\n\n    # Add joystick event, static on cars, dynamic on nonCars\n    if self.joystick_mode:\n      self.events.add(EventName.joystickDebug)\n      self.startup_event = None\n\n    # Add startup event\n    if self.startup_event is not None:\n      self.events.add(self.startup_event)\n      self.startup_event = None\n\n    # Don't add any more events if not initialized\n    if not self.initialized:\n      self.events.add(EventName.controlsInitializing)\n      return\n\n    # no more events while in dashcam mode\n    if self.CP.passive:\n      return\n\n    # Block resume if cruise never previously enabled\n    resume_pressed = any(be.type in (ButtonType.accelCruise, ButtonType.resumeCruise) for be in CS.buttonEvents)\n    if not self.CP.pcmCruise and not self.v_cruise_helper.v_cruise_initialized and resume_pressed:\n      self.events.add(EventName.resumeBlocked)\n\n    if not self.CP.notCar:\n      self.events.add_from_msg(self.sm['driverMonitoringState'].events)\n\n    # Add car events, ignore if CAN isn't valid\n    if CS.canValid:\n      self.events.add_from_msg(CS.events)\n\n    # Create events for temperature, disk space, and memory\n    if self.sm['deviceState'].thermalStatus >= ThermalStatus.red:\n      self.events.add(EventName.overheat)\n    if self.sm['deviceState'].freeSpacePercent < 7 and not SIMULATION:\n      # under 7% of space free no enable allowed\n      self.events.add(EventName.outOfSpace)\n    if self.sm['deviceState'].memoryUsagePercent > 90 and not SIMULATION:\n      self.events.add(EventName.lowMemory)\n\n    # TODO: enable this once loggerd CPU usage is more reasonable\n    #cpus = list(self.sm['deviceState'].cpuUsagePercent)\n    #if max(cpus, default=0) > 95 and not SIMULATION:\n    #  self.events.add(EventName.highCpuUsage)\n\n    # Alert if fan isn't spinning for 5 seconds\n    if self.sm['peripheralState'].pandaType != log.PandaState.PandaType.unknown:\n      if self.sm['peripheralState'].fanSpeedRpm < 500 and self.sm['deviceState'].fanSpeedPercentDesired > 50:\n        # allow enough time for the fan controller in the panda to recover from stalls\n        if (self.sm.frame - self.last_functional_fan_frame) * DT_CTRL > 15.0:\n          self.events.add(EventName.fanMalfunction)\n      else:\n        self.last_functional_fan_frame = self.sm.frame\n\n    # Handle calibration status\n    cal_status = self.sm['liveCalibration'].calStatus\n    if cal_status != log.LiveCalibrationData.Status.calibrated:\n      if cal_status == log.LiveCalibrationData.Status.uncalibrated:\n        self.events.add(EventName.calibrationIncomplete)\n      elif cal_status == log.LiveCalibrationData.Status.recalibrating:\n        if not self.recalibrating_seen:\n          set_offroad_alert(\"Offroad_Recalibration\", True)\n        self.recalibrating_seen = True\n        self.events.add(EventName.calibrationRecalibrating)\n      else:\n        self.events.add(EventName.calibrationInvalid)\n\n    # Handle lane change\n    if self.sm['modelV2'].meta.laneChangeState == LaneChangeState.preLaneChange:\n      direction = self.sm['modelV2'].meta.laneChangeDirection\n      if (CS.leftBlindspot and direction == LaneChangeDirection.left) or \\\n         (CS.rightBlindspot and direction == LaneChangeDirection.right):\n        self.events.add(EventName.laneChangeBlocked)\n      else:\n        if direction == LaneChangeDirection.left:\n          self.events.add(EventName.preLaneChangeLeft)\n        else:\n          self.events.add(EventName.preLaneChangeRight)\n    elif self.sm['modelV2'].meta.laneChangeState in (LaneChangeState.laneChangeStarting,\n                                                    LaneChangeState.laneChangeFinishing):\n      self.events.add(EventName.laneChange)\n\n    for i, pandaState in enumerate(self.sm['pandaStates']):\n      # All pandas must match the list of safetyConfigs, and if outside this list, must be silent or noOutput\n      if i < len(self.CP.safetyConfigs):\n        safety_mismatch = pandaState.safetyModel != self.CP.safetyConfigs[i].safetyModel or \\\n                          pandaState.safetyParam != self.CP.safetyConfigs[i].safetyParam or \\\n                          pandaState.alternativeExperience != self.CP.alternativeExperience\n      else:\n        safety_mismatch = pandaState.safetyModel not in IGNORED_SAFETY_MODES\n\n      # safety mismatch allows some time for pandad to set the safety mode and publish it back from panda\n      if (safety_mismatch and self.sm.frame*DT_CTRL > 10.) or pandaState.safetyRxChecksInvalid or self.mismatch_counter >= 200:\n        self.events.add(EventName.controlsMismatch)\n\n      if log.PandaState.FaultType.relayMalfunction in pandaState.faults:\n        self.events.add(EventName.relayMalfunction)\n\n    # Handle HW and system malfunctions\n    # Order is very intentional here. Be careful when modifying this.\n    # All events here should at least have NO_ENTRY and SOFT_DISABLE.\n    num_events = len(self.events)\n\n    not_running = {p.name for p in self.sm['managerState'].processes if not p.running and p.shouldBeRunning}\n    if self.sm.recv_frame['managerState'] and (not_running - IGNORE_PROCESSES):\n      self.events.add(EventName.processNotRunning)\n      if not_running != self.not_running_prev:\n        cloudlog.event(\"process_not_running\", not_running=not_running, error=True)\n      self.not_running_prev = not_running\n    else:\n      if not SIMULATION and not self.rk.lagging:\n        if not self.sm.all_alive(self.camera_packets):\n          self.events.add(EventName.cameraMalfunction)\n        elif not self.sm.all_freq_ok(self.camera_packets):\n          self.events.add(EventName.cameraFrameRate)\n    if not REPLAY and self.rk.lagging:\n      self.events.add(EventName.controlsdLagging)\n    if len(self.sm['radarState'].radarErrors) or ((not self.rk.lagging or REPLAY) and not self.sm.all_checks(['radarState'])):\n      self.events.add(EventName.radarFault)\n    if not self.sm.valid['pandaStates']:\n      self.events.add(EventName.usbError)\n    if CS.canTimeout:\n      self.events.add(EventName.canBusMissing)\n    elif not CS.canValid:\n      self.events.add(EventName.canError)\n\n    # generic catch-all. ideally, a more specific event should be added above instead\n    has_disable_events = self.events.contains(ET.NO_ENTRY) and (self.events.contains(ET.SOFT_DISABLE) or self.events.contains(ET.IMMEDIATE_DISABLE))\n    no_system_errors = (not has_disable_events) or (len(self.events) == num_events)\n    if not self.sm.all_checks() and no_system_errors:\n      if not self.sm.all_alive():\n        self.events.add(EventName.commIssue)\n      elif not self.sm.all_freq_ok():\n        self.events.add(EventName.commIssueAvgFreq)\n      else:\n        self.events.add(EventName.commIssue)\n\n      logs = {\n        'invalid': [s for s, valid in self.sm.valid.items() if not valid],\n        'not_alive': [s for s, alive in self.sm.alive.items() if not alive],\n        'not_freq_ok': [s for s, freq_ok in self.sm.freq_ok.items() if not freq_ok],\n      }\n      if logs != self.logged_comm_issue:\n        cloudlog.event(\"commIssue\", error=True, **logs)\n        self.logged_comm_issue = logs\n    else:\n      self.logged_comm_issue = None\n\n    if not (self.CP.notCar and self.joystick_mode):\n      if not self.sm['liveLocationKalman'].posenetOK:\n        self.events.add(EventName.posenetInvalid)\n      if not self.sm['liveLocationKalman'].deviceStable:\n        self.events.add(EventName.deviceFalling)\n      if not self.sm['liveLocationKalman'].inputsOK:\n        self.events.add(EventName.locationdTemporaryError)\n      if not self.sm['liveParameters'].valid and not TESTING_CLOSET and (not SIMULATION or REPLAY):\n        self.events.add(EventName.paramsdTemporaryError)\n\n    # conservative HW alert. if the data or frequency are off, locationd will throw an error\n    if any((self.sm.frame - self.sm.recv_frame[s])*DT_CTRL > 10. for s in self.sensor_packets):\n      self.events.add(EventName.sensorDataInvalid)\n\n    if not REPLAY:\n      # Check for mismatch between openpilot and car's PCM\n      cruise_mismatch = CS.cruiseState.enabled and (not self.enabled or not self.CP.pcmCruise)\n      self.cruise_mismatch_counter = self.cruise_mismatch_counter + 1 if cruise_mismatch else 0\n      if self.cruise_mismatch_counter > int(6. / DT_CTRL):\n        self.events.add(EventName.cruiseMismatch)\n\n    # Check for FCW\n    stock_long_is_braking = self.enabled and not self.CP.openpilotLongitudinalControl and CS.aEgo < -1.25\n    model_fcw = self.sm['modelV2'].meta.hardBrakePredicted and not CS.brakePressed and not stock_long_is_braking\n    planner_fcw = self.sm['longitudinalPlan'].fcw and self.enabled\n    if (planner_fcw or model_fcw) and not (self.CP.notCar and self.joystick_mode):\n      self.events.add(EventName.fcw)\n\n    for m in messaging.drain_sock(self.log_sock, wait_for_one=False):\n      try:\n        msg = m.androidLog.message\n        if any(err in msg for err in (\"ERROR_CRC\", \"ERROR_ECC\", \"ERROR_STREAM_UNDERFLOW\", \"APPLY FAILED\")):\n          csid = msg.split(\"CSID:\")[-1].split(\" \")[0]\n          evt = CSID_MAP.get(csid, None)\n          if evt is not None:\n            self.events.add(evt)\n      except UnicodeDecodeError:\n        pass\n\n    # TODO: fix simulator\n    if not SIMULATION or REPLAY:\n      # Not show in first 1 km to allow for driving out of garage. This event shows after 5 minutes\n      if not self.sm['liveLocationKalman'].gpsOK and self.sm['liveLocationKalman'].inputsOK and (self.distance_traveled > 1500):\n        self.events.add(EventName.noGps)\n      if self.sm['liveLocationKalman'].gpsOK:\n        self.distance_traveled = 0\n      self.distance_traveled += CS.vEgo * DT_CTRL\n\n      if self.sm['modelV2'].frameDropPerc > 20:\n        self.events.add(EventName.modeldLagging)\n\n  def data_sample(self):\n    \"\"\"Receive data from sockets\"\"\"\n\n    car_state = messaging.recv_one(self.car_state_sock)\n    CS = car_state.carState if car_state else self.CS_prev\n\n    self.sm.update(0)\n\n    if not self.initialized:\n      all_valid = CS.canValid and self.sm.all_checks()\n      timed_out = self.sm.frame * DT_CTRL > 6.\n      if all_valid or timed_out or (SIMULATION and not REPLAY):\n        available_streams = VisionIpcClient.available_streams(\"camerad\", block=False)\n        if VisionStreamType.VISION_STREAM_ROAD not in available_streams:\n          self.sm.ignore_alive.append('roadCameraState')\n        if VisionStreamType.VISION_STREAM_WIDE_ROAD not in available_streams:\n          self.sm.ignore_alive.append('wideRoadCameraState')\n\n        self.initialized = True\n        self.set_initial_state()\n\n        cloudlog.event(\n          \"controlsd.initialized\",\n          dt=self.sm.frame*DT_CTRL,\n          timeout=timed_out,\n          canValid=CS.canValid,\n          invalid=[s for s, valid in self.sm.valid.items() if not valid],\n          not_alive=[s for s, alive in self.sm.alive.items() if not alive],\n          not_freq_ok=[s for s, freq_ok in self.sm.freq_ok.items() if not freq_ok],\n          error=True,\n        )\n\n    # When the panda and controlsd do not agree on controls_allowed\n    # we want to disengage openpilot. However the status from the panda goes through\n    # another socket other than the CAN messages and one can arrive earlier than the other.\n    # Therefore we allow a mismatch for two samples, then we trigger the disengagement.\n    if not self.enabled:\n      self.mismatch_counter = 0\n\n    # All pandas not in silent mode must have controlsAllowed when openpilot is enabled\n    if self.enabled and any(not ps.controlsAllowed for ps in self.sm['pandaStates']\n           if ps.safetyModel not in IGNORED_SAFETY_MODES):\n      self.mismatch_counter += 1\n\n    return CS\n\n  def state_transition(self, CS):\n    \"\"\"Compute conditional state transitions and execute actions on state transitions\"\"\"\n\n    self.v_cruise_helper.update_v_cruise(CS, self.enabled, self.is_metric)\n\n    # decrement the soft disable timer at every step, as it's reset on\n    # entrance in SOFT_DISABLING state\n    self.soft_disable_timer = max(0, self.soft_disable_timer - 1)\n\n    self.current_alert_types = [ET.PERMANENT]\n\n    # ENABLED, SOFT DISABLING, PRE ENABLING, OVERRIDING\n    if self.state != State.disabled:\n      # user and immediate disable always have priority in a non-disabled state\n      if self.events.contains(ET.USER_DISABLE):\n        self.state = State.disabled\n        self.current_alert_types.append(ET.USER_DISABLE)\n\n      elif self.events.contains(ET.IMMEDIATE_DISABLE):\n        self.state = State.disabled\n        self.current_alert_types.append(ET.IMMEDIATE_DISABLE)\n\n      else:\n        # ENABLED\n        if self.state == State.enabled:\n          if self.events.contains(ET.SOFT_DISABLE):\n            self.state = State.softDisabling\n            self.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n\n          elif self.events.contains(ET.OVERRIDE_LATERAL) or self.events.contains(ET.OVERRIDE_LONGITUDINAL):\n            self.state = State.overriding\n            self.current_alert_types += [ET.OVERRIDE_LATERAL, ET.OVERRIDE_LONGITUDINAL]\n\n        # SOFT DISABLING\n        elif self.state == State.softDisabling:\n          if not self.events.contains(ET.SOFT_DISABLE):\n            # no more soft disabling condition, so go back to ENABLED\n            self.state = State.enabled\n\n          elif self.soft_disable_timer > 0:\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n\n          elif self.soft_disable_timer <= 0:\n            self.state = State.disabled\n\n        # PRE ENABLING\n        elif self.state == State.preEnabled:\n          if not self.events.contains(ET.PRE_ENABLE):\n            self.state = State.enabled\n          else:\n            self.current_alert_types.append(ET.PRE_ENABLE)\n\n        # OVERRIDING\n        elif self.state == State.overriding:\n          if self.events.contains(ET.SOFT_DISABLE):\n            self.state = State.softDisabling\n            self.soft_disable_timer = int(SOFT_DISABLE_TIME / DT_CTRL)\n            self.current_alert_types.append(ET.SOFT_DISABLE)\n          elif not (self.events.contains(ET.OVERRIDE_LATERAL) or self.events.contains(ET.OVERRIDE_LONGITUDINAL)):\n            self.state = State.enabled\n          else:\n            self.current_alert_types += [ET.OVERRIDE_LATERAL, ET.OVERRIDE_LONGITUDINAL]\n\n    # DISABLED\n    elif self.state == State.disabled:\n      if self.events.contains(ET.ENABLE):\n        if self.events.contains(ET.NO_ENTRY):\n          self.current_alert_types.append(ET.NO_ENTRY)\n\n        else:\n          if self.events.contains(ET.PRE_ENABLE):\n            self.state = State.preEnabled\n          elif self.events.contains(ET.OVERRIDE_LATERAL) or self.events.contains(ET.OVERRIDE_LONGITUDINAL):\n            self.state = State.overriding\n          else:\n            self.state = State.enabled\n          self.current_alert_types.append(ET.ENABLE)\n          self.v_cruise_helper.initialize_v_cruise(CS, self.experimental_mode)\n\n    # Check if openpilot is engaged and actuators are enabled\n    self.enabled = self.state in ENABLED_STATES\n    self.active = self.state in ACTIVE_STATES\n    if self.active:\n      self.current_alert_types.append(ET.WARNING)\n\n  def state_control(self, CS):\n    \"\"\"Given the state, this function returns a CarControl packet\"\"\"\n\n    # Update VehicleModel\n    lp = self.sm['liveParameters']\n    x = max(lp.stiffnessFactor, 0.1)\n    sr = max(lp.steerRatio, 0.1)\n    self.VM.update_params(x, sr)\n\n    # Update Torque Params\n    if self.CP.lateralTuning.which() == 'torque':\n      torque_params = self.sm['liveTorqueParameters']\n      if self.sm.all_checks(['liveTorqueParameters']) and torque_params.useParams:\n        self.LaC.update_live_torque_params(torque_params.latAccelFactorFiltered, torque_params.latAccelOffsetFiltered,\n                                           torque_params.frictionCoefficientFiltered)\n\n    long_plan = self.sm['longitudinalPlan']\n    model_v2 = self.sm['modelV2']\n\n    CC = car.CarControl.new_message()\n    CC.enabled = self.enabled\n\n    # Check which actuators can be enabled\n    standstill = CS.vEgo <= max(self.CP.minSteerSpeed, MIN_LATERAL_CONTROL_SPEED) or CS.standstill\n    CC.latActive = self.active and not CS.steerFaultTemporary and not CS.steerFaultPermanent and \\\n                   (not standstill or self.joystick_mode)\n    CC.longActive = self.enabled and not self.events.contains(ET.OVERRIDE_LONGITUDINAL) and self.CP.openpilotLongitudinalControl\n\n    actuators = CC.actuators\n    actuators.longControlState = self.LoC.long_control_state\n\n    # Enable blinkers while lane changing\n    if model_v2.meta.laneChangeState != LaneChangeState.off:\n      CC.leftBlinker = model_v2.meta.laneChangeDirection == LaneChangeDirection.left\n      CC.rightBlinker = model_v2.meta.laneChangeDirection == LaneChangeDirection.right\n\n    if CS.leftBlinker or CS.rightBlinker:\n      self.last_blinker_frame = self.sm.frame\n\n    # State specific actions\n\n    if not CC.latActive:\n      self.LaC.reset()\n    if not CC.longActive:\n      self.LoC.reset()\n\n    if not self.joystick_mode:\n      # accel PID loop\n      pid_accel_limits = self.CI.get_pid_accel_limits(self.CP, CS.vEgo, self.v_cruise_helper.v_cruise_kph * CV.KPH_TO_MS)\n      actuators.accel = self.LoC.update(CC.longActive, CS, long_plan.aTarget, long_plan.shouldStop, pid_accel_limits)\n\n      # Steering PID loop and lateral MPC\n      self.desired_curvature = clip_curvature(CS.vEgo, self.desired_curvature, model_v2.action.desiredCurvature)\n      actuators.curvature = self.desired_curvature\n      actuators.steer, actuators.steeringAngleDeg, lac_log = self.LaC.update(CC.latActive, CS, self.VM, lp,\n                                                                             self.steer_limited, self.desired_curvature,\n                                                                             self.sm['liveLocationKalman'])\n    else:\n      lac_log = log.ControlsState.LateralDebugState.new_message()\n      if self.sm.recv_frame['testJoystick'] > 0:\n        # reset joystick if it hasn't been received in a while\n        should_reset_joystick = (self.sm.frame - self.sm.recv_frame['testJoystick'])*DT_CTRL > 0.2\n        if not should_reset_joystick:\n          joystick_axes = self.sm['testJoystick'].axes\n        else:\n          joystick_axes = [0.0, 0.0]\n\n        if CC.longActive:\n          actuators.accel = 4.0*clip(joystick_axes[0], -1, 1)\n\n        if CC.latActive:\n          steer = clip(joystick_axes[1], -1, 1)\n          # max angle is 45 for angle-based cars, max curvature is 0.02\n          actuators.steer, actuators.steeringAngleDeg, actuators.curvature = steer, steer * 90., steer * -0.02\n\n        lac_log.active = self.active\n        lac_log.steeringAngleDeg = CS.steeringAngleDeg\n        lac_log.output = actuators.steer\n        lac_log.saturated = abs(actuators.steer) >= 0.9\n\n    if CS.steeringPressed:\n      self.last_steering_pressed_frame = self.sm.frame\n    recent_steer_pressed = (self.sm.frame - self.last_steering_pressed_frame)*DT_CTRL < 2.0\n\n    # Send a \"steering required alert\" if saturation count has reached the limit\n    if lac_log.active and not recent_steer_pressed and not self.CP.notCar:\n      if self.CP.lateralTuning.which() == 'torque' and not self.joystick_mode:\n        undershooting = abs(lac_log.desiredLateralAccel) / abs(1e-3 + lac_log.actualLateralAccel) > 1.2\n        turning = abs(lac_log.desiredLateralAccel) > 1.0\n        good_speed = CS.vEgo > 5\n        max_torque = abs(self.sm['carOutput'].actuatorsOutput.steer) > 0.99\n        if undershooting and turning and good_speed and max_torque:\n          lac_log.active and self.events.add(EventName.steerSaturated)\n      elif lac_log.saturated:\n        # TODO probably should not use dpath_points but curvature\n        dpath_points = model_v2.position.y\n        if len(dpath_points):\n          # Check if we deviated from the path\n          # TODO use desired vs actual curvature\n          if self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n            steering_value = actuators.steeringAngleDeg\n          else:\n            steering_value = actuators.steer\n\n          left_deviation = steering_value > 0 and dpath_points[0] < -0.20\n          right_deviation = steering_value < 0 and dpath_points[0] > 0.20\n\n          if left_deviation or right_deviation:\n            self.events.add(EventName.steerSaturated)\n\n    # Ensure no NaNs/Infs\n    for p in ACTUATOR_FIELDS:\n      attr = getattr(actuators, p)\n      if not isinstance(attr, SupportsFloat):\n        continue\n\n      if not math.isfinite(attr):\n        cloudlog.error(f\"actuators.{p} not finite {actuators.to_dict()}\")\n        setattr(actuators, p, 0.0)\n\n    # decrement personality on distance button press\n    if self.CP.openpilotLongitudinalControl:\n      if any(not be.pressed and be.type == ButtonType.gapAdjustCruise for be in CS.buttonEvents):\n        self.personality = (self.personality - 1) % 3\n        self.params.put_nonblocking('LongitudinalPersonality', str(self.personality))\n\n    return CC, lac_log\n\n  def publish_logs(self, CS, start_time, CC, lac_log):\n    \"\"\"Send actuators and hud commands to the car, send controlsstate and MPC logging\"\"\"\n\n    # Orientation and angle rates can be useful for carcontroller\n    # Only calibrated (car) frame is relevant for the carcontroller\n    orientation_value = list(self.sm['liveLocationKalman'].calibratedOrientationNED.value)\n    if len(orientation_value) > 2:\n      CC.orientationNED = orientation_value\n    angular_rate_value = list(self.sm['liveLocationKalman'].angularVelocityCalibrated.value)\n    if len(angular_rate_value) > 2:\n      CC.angularVelocity = angular_rate_value\n\n    CC.cruiseControl.override = self.enabled and not CC.longActive and self.CP.openpilotLongitudinalControl\n    CC.cruiseControl.cancel = CS.cruiseState.enabled and (not self.enabled or not self.CP.pcmCruise)\n    if self.joystick_mode and self.sm.recv_frame['testJoystick'] > 0 and self.sm['testJoystick'].buttons[0]:\n      CC.cruiseControl.cancel = True\n\n    speeds = self.sm['longitudinalPlan'].speeds\n    if len(speeds):\n      CC.cruiseControl.resume = self.enabled and CS.cruiseState.standstill and speeds[-1] > 0.1\n\n    hudControl = CC.hudControl\n    hudControl.setSpeed = float(self.v_cruise_helper.v_cruise_cluster_kph * CV.KPH_TO_MS)\n    hudControl.speedVisible = self.enabled\n    hudControl.lanesVisible = self.enabled\n    hudControl.leadVisible = self.sm['longitudinalPlan'].hasLead\n    hudControl.leadDistanceBars = self.personality + 1\n\n    hudControl.rightLaneVisible = True\n    hudControl.leftLaneVisible = True\n\n    recent_blinker = (self.sm.frame - self.last_blinker_frame) * DT_CTRL < 5.0  # 5s blinker cooldown\n    ldw_allowed = self.is_ldw_enabled and CS.vEgo > LDW_MIN_SPEED and not recent_blinker \\\n                  and not CC.latActive and self.sm['liveCalibration'].calStatus == log.LiveCalibrationData.Status.calibrated\n\n    model_v2 = self.sm['modelV2']\n    desire_prediction = model_v2.meta.desirePrediction\n    if len(desire_prediction) and ldw_allowed:\n      right_lane_visible = model_v2.laneLineProbs[2] > 0.5\n      left_lane_visible = model_v2.laneLineProbs[1] > 0.5\n      l_lane_change_prob = desire_prediction[Desire.laneChangeLeft]\n      r_lane_change_prob = desire_prediction[Desire.laneChangeRight]\n\n      lane_lines = model_v2.laneLines\n      l_lane_close = left_lane_visible and (lane_lines[1].y[0] > -(1.08 + CAMERA_OFFSET))\n      r_lane_close = right_lane_visible and (lane_lines[2].y[0] < (1.08 - CAMERA_OFFSET))\n\n      hudControl.leftLaneDepart = bool(l_lane_change_prob > LANE_DEPARTURE_THRESHOLD and l_lane_close)\n      hudControl.rightLaneDepart = bool(r_lane_change_prob > LANE_DEPARTURE_THRESHOLD and r_lane_close)\n\n    if hudControl.rightLaneDepart or hudControl.leftLaneDepart:\n      self.events.add(EventName.ldw)\n\n    clear_event_types = set()\n    if ET.WARNING not in self.current_alert_types:\n      clear_event_types.add(ET.WARNING)\n    if self.enabled:\n      clear_event_types.add(ET.NO_ENTRY)\n\n    alerts = self.events.create_alerts(self.current_alert_types, [self.CP, CS, self.sm, self.is_metric, self.soft_disable_timer])\n    self.AM.add_many(self.sm.frame, alerts)\n    current_alert = self.AM.process_alerts(self.sm.frame, clear_event_types)\n    if current_alert:\n      hudControl.visualAlert = current_alert.visual_alert\n\n    if not self.CP.passive and self.initialized:\n      CO = self.sm['carOutput']\n      if self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n        self.steer_limited = abs(CC.actuators.steeringAngleDeg - CO.actuatorsOutput.steeringAngleDeg) > \\\n                             STEER_ANGLE_SATURATION_THRESHOLD\n      else:\n        self.steer_limited = abs(CC.actuators.steer - CO.actuatorsOutput.steer) > 1e-2\n\n    force_decel = (self.sm['driverMonitoringState'].awarenessStatus < 0.) or \\\n                  (self.state == State.softDisabling)\n\n    # Curvature & Steering angle\n    lp = self.sm['liveParameters']\n\n    steer_angle_without_offset = math.radians(CS.steeringAngleDeg - lp.angleOffsetDeg)\n    curvature = -self.VM.calc_curvature(steer_angle_without_offset, CS.vEgo, lp.roll)\n\n    # controlsState\n    dat = messaging.new_message('controlsState')\n    dat.valid = CS.canValid\n    controlsState = dat.controlsState\n    if current_alert:\n      controlsState.alertText1 = current_alert.alert_text_1\n      controlsState.alertText2 = current_alert.alert_text_2\n      controlsState.alertSize = current_alert.alert_size\n      controlsState.alertStatus = current_alert.alert_status\n      controlsState.alertBlinkingRate = current_alert.alert_rate\n      controlsState.alertType = current_alert.alert_type\n      controlsState.alertSound = current_alert.audible_alert\n\n    controlsState.longitudinalPlanMonoTime = self.sm.logMonoTime['longitudinalPlan']\n    controlsState.lateralPlanMonoTime = self.sm.logMonoTime['modelV2']\n    controlsState.enabled = self.enabled\n    controlsState.active = self.active\n    controlsState.curvature = curvature\n    controlsState.desiredCurvature = self.desired_curvature\n    controlsState.state = self.state\n    controlsState.engageable = not self.events.contains(ET.NO_ENTRY)\n    controlsState.longControlState = self.LoC.long_control_state\n    controlsState.vCruise = float(self.v_cruise_helper.v_cruise_kph)\n    controlsState.vCruiseCluster = float(self.v_cruise_helper.v_cruise_cluster_kph)\n    controlsState.upAccelCmd = float(self.LoC.pid.p)\n    controlsState.uiAccelCmd = float(self.LoC.pid.i)\n    controlsState.ufAccelCmd = float(self.LoC.pid.f)\n    controlsState.cumLagMs = -self.rk.remaining * 1000.\n    controlsState.startMonoTime = int(start_time * 1e9)\n    controlsState.forceDecel = bool(force_decel)\n    controlsState.experimentalMode = self.experimental_mode\n    controlsState.personality = self.personality\n\n    lat_tuning = self.CP.lateralTuning.which()\n    if self.joystick_mode:\n      controlsState.lateralControlState.debugState = lac_log\n    elif self.CP.steerControlType == car.CarParams.SteerControlType.angle:\n      controlsState.lateralControlState.angleState = lac_log\n    elif lat_tuning == 'pid':\n      controlsState.lateralControlState.pidState = lac_log\n    elif lat_tuning == 'torque':\n      controlsState.lateralControlState.torqueState = lac_log\n\n    self.pm.send('controlsState', dat)\n\n    # onroadEvents - logged every second or on change\n    if (self.sm.frame % int(1. / DT_CTRL) == 0) or (self.events.names != self.events_prev):\n      ce_send = messaging.new_message('onroadEvents', len(self.events))\n      ce_send.valid = True\n      ce_send.onroadEvents = self.events.to_msg()\n      self.pm.send('onroadEvents', ce_send)\n    self.events_prev = self.events.names.copy()\n\n    # carControl\n    cc_send = messaging.new_message('carControl')\n    cc_send.valid = CS.canValid\n    cc_send.carControl = CC\n    self.pm.send('carControl', cc_send)\n\n  def step(self):\n    start_time = time.monotonic()\n\n    # Sample data from sockets and get a carState\n    CS = self.data_sample()\n    cloudlog.timestamp(\"Data sampled\")\n\n    self.update_events(CS)\n    cloudlog.timestamp(\"Events updated\")\n\n    if not self.CP.passive and self.initialized:\n      # Update control state\n      self.state_transition(CS)\n\n    # Compute actuators (runs PID loops and lateral MPC)\n    CC, lac_log = self.state_control(CS)\n\n    # Publish data\n    self.publish_logs(CS, start_time, CC, lac_log)\n\n    self.CS_prev = CS\n\n  def read_personality_param(self):\n    try:\n      return int(self.params.get('LongitudinalPersonality'))\n    except (ValueError, TypeError):\n      return log.LongitudinalPersonality.standard\n\n  def params_thread(self, evt):\n    while not evt.is_set():\n      self.is_metric = self.params.get_bool(\"IsMetric\")\n      self.experimental_mode = self.params.get_bool(\"ExperimentalMode\") and self.CP.openpilotLongitudinalControl\n      self.personality = self.read_personality_param()\n      if self.CP.notCar:\n        self.joystick_mode = self.params.get_bool(\"JoystickDebugMode\")\n      time.sleep(0.1)\n\n  def controlsd_thread(self):\n    e = threading.Event()\n    t = threading.Thread(target=self.params_thread, args=(e, ))\n    try:\n      t.start()\n      while True:\n        self.step()\n        self.rk.monitor_time()\n    finally:\n      e.set()\n      t.join()\n\n\ndef main():\n  config_realtime_process(4, Priority.CTRL_HIGH)\n  controls = Controls()\n  controls.controlsd_thread()\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/controls/radard.py": "#!/usr/bin/env python3\nimport importlib\nimport math\nfrom collections import deque\nfrom typing import Any\n\nimport capnp\nfrom cereal import messaging, log, car\nfrom openpilot.common.numpy_fast import interp\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import DT_CTRL, Ratekeeper, Priority, config_realtime_process\nfrom openpilot.common.swaglog import cloudlog\n\nfrom openpilot.common.simple_kalman import KF1D\n\n\n# Default lead acceleration decay set to 50% at 1s\n_LEAD_ACCEL_TAU = 1.5\n\n# radar tracks\nSPEED, ACCEL = 0, 1     # Kalman filter states enum\n\n# stationary qualification parameters\nV_EGO_STATIONARY = 4.   # no stationary object flag below this speed\n\nRADAR_TO_CENTER = 2.7   # (deprecated) RADAR is ~ 2.7m ahead from center of car\nRADAR_TO_CAMERA = 1.52  # RADAR is ~ 1.5m ahead from center of mesh frame\n\n\nclass KalmanParams:\n  def __init__(self, dt: float):\n    # Lead Kalman Filter params, calculating K from A, C, Q, R requires the control library.\n    # hardcoding a lookup table to compute K for values of radar_ts between 0.01s and 0.2s\n    assert dt > .01 and dt < .2, \"Radar time step must be between .01s and 0.2s\"\n    self.A = [[1.0, dt], [0.0, 1.0]]\n    self.C = [1.0, 0.0]\n    #Q = np.matrix([[10., 0.0], [0.0, 100.]])\n    #R = 1e3\n    #K = np.matrix([[ 0.05705578], [ 0.03073241]])\n    dts = [dt * 0.01 for dt in range(1, 21)]\n    K0 = [0.12287673, 0.14556536, 0.16522756, 0.18281627, 0.1988689,  0.21372394,\n          0.22761098, 0.24069424, 0.253096,   0.26491023, 0.27621103, 0.28705801,\n          0.29750003, 0.30757767, 0.31732515, 0.32677158, 0.33594201, 0.34485814,\n          0.35353899, 0.36200124]\n    K1 = [0.29666309, 0.29330885, 0.29042818, 0.28787125, 0.28555364, 0.28342219,\n          0.28144091, 0.27958406, 0.27783249, 0.27617149, 0.27458948, 0.27307714,\n          0.27162685, 0.27023228, 0.26888809, 0.26758976, 0.26633338, 0.26511557,\n          0.26393339, 0.26278425]\n    self.K = [[interp(dt, dts, K0)], [interp(dt, dts, K1)]]\n\n\nclass Track:\n  def __init__(self, identifier: int, v_lead: float, kalman_params: KalmanParams):\n    self.identifier = identifier\n    self.cnt = 0\n    self.aLeadTau = _LEAD_ACCEL_TAU\n    self.K_A = kalman_params.A\n    self.K_C = kalman_params.C\n    self.K_K = kalman_params.K\n    self.kf = KF1D([[v_lead], [0.0]], self.K_A, self.K_C, self.K_K)\n\n  def update(self, d_rel: float, y_rel: float, v_rel: float, v_lead: float, measured: float):\n    # relative values, copy\n    self.dRel = d_rel   # LONG_DIST\n    self.yRel = y_rel   # -LAT_DIST\n    self.vRel = v_rel   # REL_SPEED\n    self.vLead = v_lead\n    self.measured = measured   # measured or estimate\n\n    # computed velocity and accelerations\n    if self.cnt > 0:\n      self.kf.update(self.vLead)\n\n    self.vLeadK = float(self.kf.x[SPEED][0])\n    self.aLeadK = float(self.kf.x[ACCEL][0])\n\n    # Learn if constant acceleration\n    if abs(self.aLeadK) < 0.5:\n      self.aLeadTau = _LEAD_ACCEL_TAU\n    else:\n      self.aLeadTau *= 0.9\n\n    self.cnt += 1\n\n  def get_key_for_cluster(self):\n    # Weigh y higher since radar is inaccurate in this dimension\n    return [self.dRel, self.yRel*2, self.vRel]\n\n  def reset_a_lead(self, aLeadK: float, aLeadTau: float):\n    self.kf = KF1D([[self.vLead], [aLeadK]], self.K_A, self.K_C, self.K_K)\n    self.aLeadK = aLeadK\n    self.aLeadTau = aLeadTau\n\n  def get_RadarState(self, model_prob: float = 0.0):\n    return {\n      \"dRel\": float(self.dRel),\n      \"yRel\": float(self.yRel),\n      \"vRel\": float(self.vRel),\n      \"vLead\": float(self.vLead),\n      \"vLeadK\": float(self.vLeadK),\n      \"aLeadK\": float(self.aLeadK),\n      \"aLeadTau\": float(self.aLeadTau),\n      \"status\": True,\n      \"fcw\": self.is_potential_fcw(model_prob),\n      \"modelProb\": model_prob,\n      \"radar\": True,\n      \"radarTrackId\": self.identifier,\n    }\n\n  def potential_low_speed_lead(self, v_ego: float):\n    # stop for stuff in front of you and low speed, even without model confirmation\n    # Radar points closer than 0.75, are almost always glitches on toyota radars\n    return abs(self.yRel) < 1.0 and (v_ego < V_EGO_STATIONARY) and (0.75 < self.dRel < 25)\n\n  def is_potential_fcw(self, model_prob: float):\n    return model_prob > .9\n\n  def __str__(self):\n    ret = f\"x: {self.dRel:4.1f}  y: {self.yRel:4.1f}  v: {self.vRel:4.1f}  a: {self.aLeadK:4.1f}\"\n    return ret\n\n\ndef laplacian_pdf(x: float, mu: float, b: float):\n  b = max(b, 1e-4)\n  return math.exp(-abs(x-mu)/b)\n\n\ndef match_vision_to_track(v_ego: float, lead: capnp._DynamicStructReader, tracks: dict[int, Track]):\n  offset_vision_dist = lead.x[0] - RADAR_TO_CAMERA\n\n  def prob(c):\n    prob_d = laplacian_pdf(c.dRel, offset_vision_dist, lead.xStd[0])\n    prob_y = laplacian_pdf(c.yRel, -lead.y[0], lead.yStd[0])\n    prob_v = laplacian_pdf(c.vRel + v_ego, lead.v[0], lead.vStd[0])\n\n    # This isn't exactly right, but it's a good heuristic\n    return prob_d * prob_y * prob_v\n\n  track = max(tracks.values(), key=prob)\n\n  # if no 'sane' match is found return -1\n  # stationary radar points can be false positives\n  dist_sane = abs(track.dRel - offset_vision_dist) < max([(offset_vision_dist)*.25, 5.0])\n  vel_sane = (abs(track.vRel + v_ego - lead.v[0]) < 10) or (v_ego + track.vRel > 3)\n  if dist_sane and vel_sane:\n    return track\n  else:\n    return None\n\n\ndef get_RadarState_from_vision(lead_msg: capnp._DynamicStructReader, v_ego: float, model_v_ego: float):\n  lead_v_rel_pred = lead_msg.v[0] - model_v_ego\n  return {\n    \"dRel\": float(lead_msg.x[0] - RADAR_TO_CAMERA),\n    \"yRel\": float(-lead_msg.y[0]),\n    \"vRel\": float(lead_v_rel_pred),\n    \"vLead\": float(v_ego + lead_v_rel_pred),\n    \"vLeadK\": float(v_ego + lead_v_rel_pred),\n    \"aLeadK\": 0.0,\n    \"aLeadTau\": 0.3,\n    \"fcw\": False,\n    \"modelProb\": float(lead_msg.prob),\n    \"status\": True,\n    \"radar\": False,\n    \"radarTrackId\": -1,\n  }\n\n\ndef get_lead(v_ego: float, ready: bool, tracks: dict[int, Track], lead_msg: capnp._DynamicStructReader,\n             model_v_ego: float, low_speed_override: bool = True) -> dict[str, Any]:\n  # Determine leads, this is where the essential logic happens\n  if len(tracks) > 0 and ready and lead_msg.prob > .5:\n    track = match_vision_to_track(v_ego, lead_msg, tracks)\n  else:\n    track = None\n\n  lead_dict = {'status': False}\n  if track is not None:\n    lead_dict = track.get_RadarState(lead_msg.prob)\n  elif (track is None) and ready and (lead_msg.prob > .5):\n    lead_dict = get_RadarState_from_vision(lead_msg, v_ego, model_v_ego)\n\n  if low_speed_override:\n    low_speed_tracks = [c for c in tracks.values() if c.potential_low_speed_lead(v_ego)]\n    if len(low_speed_tracks) > 0:\n      closest_track = min(low_speed_tracks, key=lambda c: c.dRel)\n\n      # Only choose new track if it is actually closer than the previous one\n      if (not lead_dict['status']) or (closest_track.dRel < lead_dict['dRel']):\n        lead_dict = closest_track.get_RadarState()\n\n  return lead_dict\n\n\nclass RadarD:\n  def __init__(self, radar_ts: float, delay: int = 0):\n    self.current_time = 0.0\n\n    self.tracks: dict[int, Track] = {}\n    self.kalman_params = KalmanParams(radar_ts)\n\n    self.v_ego = 0.0\n    self.v_ego_hist = deque([0.0], maxlen=delay+1)\n    self.last_v_ego_frame = -1\n\n    self.radar_state: capnp._DynamicStructBuilder | None = None\n    self.radar_state_valid = False\n\n    self.ready = False\n\n  def update(self, sm: messaging.SubMaster, rr):\n    self.ready = sm.seen['modelV2']\n    self.current_time = 1e-9*max(sm.logMonoTime.values())\n\n    radar_points = []\n    radar_errors = []\n    if rr is not None:\n      radar_points = rr.points\n      radar_errors = rr.errors\n\n    if sm.recv_frame['carState'] != self.last_v_ego_frame:\n      self.v_ego = sm['carState'].vEgo\n      self.v_ego_hist.append(self.v_ego)\n      self.last_v_ego_frame = sm.recv_frame['carState']\n\n    ar_pts = {}\n    for pt in radar_points:\n      ar_pts[pt.trackId] = [pt.dRel, pt.yRel, pt.vRel, pt.measured]\n\n    # *** remove missing points from meta data ***\n    for ids in list(self.tracks.keys()):\n      if ids not in ar_pts:\n        self.tracks.pop(ids, None)\n\n    # *** compute the tracks ***\n    for ids in ar_pts:\n      rpt = ar_pts[ids]\n\n      # align v_ego by a fixed time to align it with the radar measurement\n      v_lead = rpt[2] + self.v_ego_hist[0]\n\n      # create the track if it doesn't exist or it's a new track\n      if ids not in self.tracks:\n        self.tracks[ids] = Track(ids, v_lead, self.kalman_params)\n      self.tracks[ids].update(rpt[0], rpt[1], rpt[2], v_lead, rpt[3])\n\n    # *** publish radarState ***\n    self.radar_state_valid = sm.all_checks() and len(radar_errors) == 0\n    self.radar_state = log.RadarState.new_message()\n    self.radar_state.mdMonoTime = sm.logMonoTime['modelV2']\n    self.radar_state.radarErrors = list(radar_errors)\n    self.radar_state.carStateMonoTime = sm.logMonoTime['carState']\n\n    if len(sm['modelV2'].temporalPose.trans):\n      model_v_ego = sm['modelV2'].temporalPose.trans[0]\n    else:\n      model_v_ego = self.v_ego\n    leads_v3 = sm['modelV2'].leadsV3\n    if len(leads_v3) > 1:\n      self.radar_state.leadOne = get_lead(self.v_ego, self.ready, self.tracks, leads_v3[0], model_v_ego, low_speed_override=True)\n      self.radar_state.leadTwo = get_lead(self.v_ego, self.ready, self.tracks, leads_v3[1], model_v_ego, low_speed_override=False)\n\n  def publish(self, pm: messaging.PubMaster, lag_ms: float):\n    assert self.radar_state is not None\n\n    radar_msg = messaging.new_message(\"radarState\")\n    radar_msg.valid = self.radar_state_valid\n    radar_msg.radarState = self.radar_state\n    radar_msg.radarState.cumLagMs = lag_ms\n    pm.send(\"radarState\", radar_msg)\n\n    # publish tracks for UI debugging (keep last)\n    tracks_msg = messaging.new_message('liveTracks', len(self.tracks))\n    tracks_msg.valid = self.radar_state_valid\n    for index, tid in enumerate(sorted(self.tracks.keys())):\n      tracks_msg.liveTracks[index] = {\n        \"trackId\": tid,\n        \"dRel\": float(self.tracks[tid].dRel),\n        \"yRel\": float(self.tracks[tid].yRel),\n        \"vRel\": float(self.tracks[tid].vRel),\n      }\n    pm.send('liveTracks', tracks_msg)\n\n\n# fuses camera and radar data for best lead detection\ndef main():\n  config_realtime_process(5, Priority.CTRL_LOW)\n\n  # wait for stats about the car to come in from controls\n  cloudlog.info(\"radard is waiting for CarParams\")\n  with car.CarParams.from_bytes(Params().get(\"CarParams\", block=True)) as msg:\n    CP = msg\n  cloudlog.info(\"radard got CarParams\")\n\n  # import the radar from the fingerprint\n  cloudlog.info(\"radard is importing %s\", CP.carName)\n  RadarInterface = importlib.import_module(f'selfdrive.car.{CP.carName}.radar_interface').RadarInterface\n\n  # *** setup messaging\n  can_sock = messaging.sub_sock('can')\n  sm = messaging.SubMaster(['modelV2', 'carState'], frequency=int(1./DT_CTRL))\n  pm = messaging.PubMaster(['radarState', 'liveTracks'])\n\n  RI = RadarInterface(CP)\n\n  rk = Ratekeeper(1.0 / CP.radarTimeStep, print_delay_threshold=None)\n  RD = RadarD(CP.radarTimeStep, RI.delay)\n\n  while 1:\n    can_strings = messaging.drain_sock_raw(can_sock, wait_for_one=True)\n    rr = RI.update(can_strings)\n    sm.update(0)\n    if rr is None:\n      continue\n\n    RD.update(sm, rr)\n    RD.publish(pm, -rk.remaining*1000.0)\n\n    rk.monitor_time()\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/controls/lib/drive_helpers.py": "import math\n\nfrom cereal import car, log\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import clip, interp\nfrom openpilot.common.realtime import DT_CTRL\n\n# WARNING: this value was determined based on the model's training distribution,\n#          model predictions above this speed can be unpredictable\n# V_CRUISE's are in kph\nV_CRUISE_MIN = 8\nV_CRUISE_MAX = 145\nV_CRUISE_UNSET = 255\nV_CRUISE_INITIAL = 40\nV_CRUISE_INITIAL_EXPERIMENTAL_MODE = 105\nIMPERIAL_INCREMENT = 1.6  # should be CV.MPH_TO_KPH, but this causes rounding errors\n\nMIN_SPEED = 1.0\nCONTROL_N = 17\nCAR_ROTATION_RADIUS = 0.0\n\n# EU guidelines\nMAX_LATERAL_JERK = 5.0\nMAX_VEL_ERR = 5.0\n\nButtonEvent = car.CarState.ButtonEvent\nButtonType = car.CarState.ButtonEvent.Type\nCRUISE_LONG_PRESS = 50\nCRUISE_NEAREST_FUNC = {\n  ButtonType.accelCruise: math.ceil,\n  ButtonType.decelCruise: math.floor,\n}\nCRUISE_INTERVAL_SIGN = {\n  ButtonType.accelCruise: +1,\n  ButtonType.decelCruise: -1,\n}\n\n\nclass VCruiseHelper:\n  def __init__(self, CP):\n    self.CP = CP\n    self.v_cruise_kph = V_CRUISE_UNSET\n    self.v_cruise_cluster_kph = V_CRUISE_UNSET\n    self.v_cruise_kph_last = 0\n    self.button_timers = {ButtonType.decelCruise: 0, ButtonType.accelCruise: 0}\n    self.button_change_states = {btn: {\"standstill\": False, \"enabled\": False} for btn in self.button_timers}\n\n  @property\n  def v_cruise_initialized(self):\n    return self.v_cruise_kph != V_CRUISE_UNSET\n\n  def update_v_cruise(self, CS, enabled, is_metric):\n    self.v_cruise_kph_last = self.v_cruise_kph\n\n    if CS.cruiseState.available:\n      if not self.CP.pcmCruise:\n        # if stock cruise is completely disabled, then we can use our own set speed logic\n        self._update_v_cruise_non_pcm(CS, enabled, is_metric)\n        self.v_cruise_cluster_kph = self.v_cruise_kph\n        self.update_button_timers(CS, enabled)\n      else:\n        self.v_cruise_kph = CS.cruiseState.speed * CV.MS_TO_KPH\n        self.v_cruise_cluster_kph = CS.cruiseState.speedCluster * CV.MS_TO_KPH\n    else:\n      self.v_cruise_kph = V_CRUISE_UNSET\n      self.v_cruise_cluster_kph = V_CRUISE_UNSET\n\n  def _update_v_cruise_non_pcm(self, CS, enabled, is_metric):\n    # handle button presses. TODO: this should be in state_control, but a decelCruise press\n    # would have the effect of both enabling and changing speed is checked after the state transition\n    if not enabled:\n      return\n\n    long_press = False\n    button_type = None\n\n    v_cruise_delta = 1. if is_metric else IMPERIAL_INCREMENT\n\n    for b in CS.buttonEvents:\n      if b.type.raw in self.button_timers and not b.pressed:\n        if self.button_timers[b.type.raw] > CRUISE_LONG_PRESS:\n          return  # end long press\n        button_type = b.type.raw\n        break\n    else:\n      for k in self.button_timers.keys():\n        if self.button_timers[k] and self.button_timers[k] % CRUISE_LONG_PRESS == 0:\n          button_type = k\n          long_press = True\n          break\n\n    if button_type is None:\n      return\n\n    # Don't adjust speed when pressing resume to exit standstill\n    cruise_standstill = self.button_change_states[button_type][\"standstill\"] or CS.cruiseState.standstill\n    if button_type == ButtonType.accelCruise and cruise_standstill:\n      return\n\n    # Don't adjust speed if we've enabled since the button was depressed (some ports enable on rising edge)\n    if not self.button_change_states[button_type][\"enabled\"]:\n      return\n\n    v_cruise_delta = v_cruise_delta * (5 if long_press else 1)\n    if long_press and self.v_cruise_kph % v_cruise_delta != 0:  # partial interval\n      self.v_cruise_kph = CRUISE_NEAREST_FUNC[button_type](self.v_cruise_kph / v_cruise_delta) * v_cruise_delta\n    else:\n      self.v_cruise_kph += v_cruise_delta * CRUISE_INTERVAL_SIGN[button_type]\n\n    # If set is pressed while overriding, clip cruise speed to minimum of vEgo\n    if CS.gasPressed and button_type in (ButtonType.decelCruise, ButtonType.setCruise):\n      self.v_cruise_kph = max(self.v_cruise_kph, CS.vEgo * CV.MS_TO_KPH)\n\n    self.v_cruise_kph = clip(round(self.v_cruise_kph, 1), V_CRUISE_MIN, V_CRUISE_MAX)\n\n  def update_button_timers(self, CS, enabled):\n    # increment timer for buttons still pressed\n    for k in self.button_timers:\n      if self.button_timers[k] > 0:\n        self.button_timers[k] += 1\n\n    for b in CS.buttonEvents:\n      if b.type.raw in self.button_timers:\n        # Start/end timer and store current state on change of button pressed\n        self.button_timers[b.type.raw] = 1 if b.pressed else 0\n        self.button_change_states[b.type.raw] = {\"standstill\": CS.cruiseState.standstill, \"enabled\": enabled}\n\n  def initialize_v_cruise(self, CS, experimental_mode: bool) -> None:\n    # initializing is handled by the PCM\n    if self.CP.pcmCruise:\n      return\n\n    initial = V_CRUISE_INITIAL_EXPERIMENTAL_MODE if experimental_mode else V_CRUISE_INITIAL\n\n    # 250kph or above probably means we never had a set speed\n    if any(b.type in (ButtonType.accelCruise, ButtonType.resumeCruise) for b in CS.buttonEvents) and self.v_cruise_kph_last < 250:\n      self.v_cruise_kph = self.v_cruise_kph_last\n    else:\n      self.v_cruise_kph = int(round(clip(CS.vEgo * CV.MS_TO_KPH, initial, V_CRUISE_MAX)))\n\n    self.v_cruise_cluster_kph = self.v_cruise_kph\n\n\ndef apply_center_deadzone(error, deadzone):\n  if (error > - deadzone) and (error < deadzone):\n    error = 0.\n  return error\n\n\ndef rate_limit(new_value, last_value, dw_step, up_step):\n  return clip(new_value, last_value + dw_step, last_value + up_step)\n\n\ndef clip_curvature(v_ego, prev_curvature, new_curvature):\n  v_ego = max(MIN_SPEED, v_ego)\n  max_curvature_rate = MAX_LATERAL_JERK / (v_ego**2) # inexact calculation, check https://github.com/commaai/openpilot/pull/24755\n  safe_desired_curvature = clip(new_curvature,\n                                prev_curvature - max_curvature_rate * DT_CTRL,\n                                prev_curvature + max_curvature_rate * DT_CTRL)\n\n  return safe_desired_curvature\n\n\ndef get_friction(lateral_accel_error: float, lateral_accel_deadzone: float, friction_threshold: float,\n                 torque_params: car.CarParams.LateralTorqueTuning, friction_compensation: bool) -> float:\n  friction_interp = interp(\n    apply_center_deadzone(lateral_accel_error, lateral_accel_deadzone),\n    [-friction_threshold, friction_threshold],\n    [-torque_params.friction, torque_params.friction]\n  )\n  friction = float(friction_interp) if friction_compensation else 0.0\n  return friction\n\n\ndef get_speed_error(modelV2: log.ModelDataV2, v_ego: float) -> float:\n  # ToDo: Try relative error, and absolute speed\n  if len(modelV2.temporalPose.trans):\n    vel_err = clip(modelV2.temporalPose.trans[0] - v_ego, -MAX_VEL_ERR, MAX_VEL_ERR)\n    return float(vel_err)\n  return 0.0\n", "selfdrive/controls/lib/longitudinal_planner.py": "#!/usr/bin/env python3\nimport math\nimport numpy as np\nfrom openpilot.common.numpy_fast import clip, interp\n\nimport cereal.messaging as messaging\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.realtime import DT_MDL\nfrom openpilot.selfdrive.modeld.constants import ModelConstants\nfrom openpilot.selfdrive.car.interfaces import ACCEL_MIN, ACCEL_MAX\nfrom openpilot.selfdrive.controls.lib.longcontrol import LongCtrlState\nfrom openpilot.selfdrive.controls.lib.longitudinal_mpc_lib.long_mpc import LongitudinalMpc\nfrom openpilot.selfdrive.controls.lib.longitudinal_mpc_lib.long_mpc import T_IDXS as T_IDXS_MPC\nfrom openpilot.selfdrive.controls.lib.drive_helpers import V_CRUISE_MAX, CONTROL_N, get_speed_error\nfrom openpilot.common.swaglog import cloudlog\n\nLON_MPC_STEP = 0.2  # first step is 0.2s\nA_CRUISE_MIN = -1.2\nA_CRUISE_MAX_VALS = [1.6, 1.2, 0.8, 0.6]\nA_CRUISE_MAX_BP = [0., 10.0, 25., 40.]\nCONTROL_N_T_IDX = ModelConstants.T_IDXS[:CONTROL_N]\n\n# Lookup table for turns\n_A_TOTAL_MAX_V = [1.7, 3.2]\n_A_TOTAL_MAX_BP = [20., 40.]\n\n\ndef get_max_accel(v_ego):\n  return interp(v_ego, A_CRUISE_MAX_BP, A_CRUISE_MAX_VALS)\n\n\ndef limit_accel_in_turns(v_ego, angle_steers, a_target, CP):\n  \"\"\"\n  This function returns a limited long acceleration allowed, depending on the existing lateral acceleration\n  this should avoid accelerating when losing the target in turns\n  \"\"\"\n  # FIXME: This function to calculate lateral accel is incorrect and should use the VehicleModel\n  # The lookup table for turns should also be updated if we do this\n  a_total_max = interp(v_ego, _A_TOTAL_MAX_BP, _A_TOTAL_MAX_V)\n  a_y = v_ego ** 2 * angle_steers * CV.DEG_TO_RAD / (CP.steerRatio * CP.wheelbase)\n  a_x_allowed = math.sqrt(max(a_total_max ** 2 - a_y ** 2, 0.))\n\n  return [a_target[0], min(a_target[1], a_x_allowed)]\n\n\ndef get_accel_from_plan(CP, speeds, accels):\n    if len(speeds) == CONTROL_N:\n      v_target_now = interp(DT_MDL, CONTROL_N_T_IDX, speeds)\n      a_target_now = interp(DT_MDL, CONTROL_N_T_IDX, accels)\n\n      v_target = interp(CP.longitudinalActuatorDelay + DT_MDL, CONTROL_N_T_IDX, speeds)\n      a_target = 2 * (v_target - v_target_now) / CP.longitudinalActuatorDelay - a_target_now\n\n      v_target_1sec = interp(CP.longitudinalActuatorDelay + DT_MDL + 1.0, CONTROL_N_T_IDX, speeds)\n    else:\n      v_target = 0.0\n      v_target_now = 0.0\n      v_target_1sec = 0.0\n      a_target = 0.0\n    should_stop = (v_target < CP.vEgoStopping and\n                    v_target_1sec < CP.vEgoStopping)\n    return a_target, should_stop\n\n\nclass LongitudinalPlanner:\n  def __init__(self, CP, init_v=0.0, init_a=0.0, dt=DT_MDL):\n    self.CP = CP\n    self.mpc = LongitudinalMpc(dt=dt)\n    self.fcw = False\n    self.dt = dt\n\n    self.a_desired = init_a\n    self.v_desired_filter = FirstOrderFilter(init_v, 2.0, self.dt)\n    self.v_model_error = 0.0\n\n    self.v_desired_trajectory = np.zeros(CONTROL_N)\n    self.a_desired_trajectory = np.zeros(CONTROL_N)\n    self.j_desired_trajectory = np.zeros(CONTROL_N)\n    self.solverExecutionTime = 0.0\n\n  @staticmethod\n  def parse_model(model_msg, model_error):\n    if (len(model_msg.position.x) == ModelConstants.IDX_N and\n       len(model_msg.velocity.x) == ModelConstants.IDX_N and\n       len(model_msg.acceleration.x) == ModelConstants.IDX_N):\n      x = np.interp(T_IDXS_MPC, ModelConstants.T_IDXS, model_msg.position.x) - model_error * T_IDXS_MPC\n      v = np.interp(T_IDXS_MPC, ModelConstants.T_IDXS, model_msg.velocity.x) - model_error\n      a = np.interp(T_IDXS_MPC, ModelConstants.T_IDXS, model_msg.acceleration.x)\n      j = np.zeros(len(T_IDXS_MPC))\n    else:\n      x = np.zeros(len(T_IDXS_MPC))\n      v = np.zeros(len(T_IDXS_MPC))\n      a = np.zeros(len(T_IDXS_MPC))\n      j = np.zeros(len(T_IDXS_MPC))\n    return x, v, a, j\n\n  def update(self, sm):\n    self.mpc.mode = 'blended' if sm['controlsState'].experimentalMode else 'acc'\n\n    v_ego = sm['carState'].vEgo\n    v_cruise_kph = min(sm['controlsState'].vCruise, V_CRUISE_MAX)\n    v_cruise = v_cruise_kph * CV.KPH_TO_MS\n\n    long_control_off = sm['controlsState'].longControlState == LongCtrlState.off\n    force_slow_decel = sm['controlsState'].forceDecel\n\n    # Reset current state when not engaged, or user is controlling the speed\n    reset_state = long_control_off if self.CP.openpilotLongitudinalControl else not sm['controlsState'].enabled\n\n    # No change cost when user is controlling the speed, or when standstill\n    prev_accel_constraint = not (reset_state or sm['carState'].standstill)\n\n    if self.mpc.mode == 'acc':\n      accel_limits = [A_CRUISE_MIN, get_max_accel(v_ego)]\n      accel_limits_turns = limit_accel_in_turns(v_ego, sm['carState'].steeringAngleDeg, accel_limits, self.CP)\n    else:\n      accel_limits = [ACCEL_MIN, ACCEL_MAX]\n      accel_limits_turns = [ACCEL_MIN, ACCEL_MAX]\n\n    if reset_state:\n      self.v_desired_filter.x = v_ego\n      # Clip aEgo to cruise limits to prevent large accelerations when becoming active\n      self.a_desired = clip(sm['carState'].aEgo, accel_limits[0], accel_limits[1])\n\n    # Prevent divergence, smooth in current v_ego\n    self.v_desired_filter.x = max(0.0, self.v_desired_filter.update(v_ego))\n    # Compute model v_ego error\n    self.v_model_error = get_speed_error(sm['modelV2'], v_ego)\n\n    if force_slow_decel:\n      v_cruise = 0.0\n    # clip limits, cannot init MPC outside of bounds\n    accel_limits_turns[0] = min(accel_limits_turns[0], self.a_desired + 0.05)\n    accel_limits_turns[1] = max(accel_limits_turns[1], self.a_desired - 0.05)\n\n    self.mpc.set_weights(prev_accel_constraint, personality=sm['controlsState'].personality)\n    self.mpc.set_accel_limits(accel_limits_turns[0], accel_limits_turns[1])\n    self.mpc.set_cur_state(self.v_desired_filter.x, self.a_desired)\n    x, v, a, j = self.parse_model(sm['modelV2'], self.v_model_error)\n    self.mpc.update(sm['radarState'], v_cruise, x, v, a, j, personality=sm['controlsState'].personality)\n\n    self.v_desired_trajectory = np.interp(CONTROL_N_T_IDX, T_IDXS_MPC, self.mpc.v_solution)\n    self.a_desired_trajectory = np.interp(CONTROL_N_T_IDX, T_IDXS_MPC, self.mpc.a_solution)\n    self.j_desired_trajectory = np.interp(CONTROL_N_T_IDX, T_IDXS_MPC[:-1], self.mpc.j_solution)\n\n    # TODO counter is only needed because radar is glitchy, remove once radar is gone\n    self.fcw = self.mpc.crash_cnt > 2 and not sm['carState'].standstill\n    if self.fcw:\n      cloudlog.info(\"FCW triggered\")\n\n    # Interpolate 0.05 seconds and save as starting point for next iteration\n    a_prev = self.a_desired\n    self.a_desired = float(interp(self.dt, CONTROL_N_T_IDX, self.a_desired_trajectory))\n    self.v_desired_filter.x = self.v_desired_filter.x + self.dt * (self.a_desired + a_prev) / 2.0\n\n  def publish(self, sm, pm):\n    plan_send = messaging.new_message('longitudinalPlan')\n\n    plan_send.valid = sm.all_checks(service_list=['carState', 'controlsState'])\n\n\n    longitudinalPlan = plan_send.longitudinalPlan\n    longitudinalPlan.modelMonoTime = sm.logMonoTime['modelV2']\n    longitudinalPlan.processingDelay = (plan_send.logMonoTime / 1e9) - sm.logMonoTime['modelV2']\n    longitudinalPlan.solverExecutionTime = self.mpc.solve_time\n\n    longitudinalPlan.allowBrake = True\n    longitudinalPlan.allowThrottle = True\n\n    longitudinalPlan.speeds = self.v_desired_trajectory.tolist()\n    longitudinalPlan.accels = self.a_desired_trajectory.tolist()\n    longitudinalPlan.jerks = self.j_desired_trajectory.tolist()\n\n    longitudinalPlan.hasLead = sm['radarState'].leadOne.status\n    longitudinalPlan.longitudinalPlanSource = self.mpc.source\n    longitudinalPlan.fcw = self.fcw\n\n    a_target, should_stop = get_accel_from_plan(self.CP, longitudinalPlan.speeds, longitudinalPlan.accels)\n    longitudinalPlan.aTarget = a_target\n    longitudinalPlan.shouldStop = should_stop\n    longitudinalPlan.allowBrake = True\n    longitudinalPlan.allowThrottle = True\n\n    pm.send('longitudinalPlan', plan_send)\n", "selfdrive/controls/lib/events.py": "#!/usr/bin/env python3\nimport bisect\nimport math\nimport os\nfrom enum import IntEnum\nfrom collections.abc import Callable\n\nfrom cereal import log, car\nimport cereal.messaging as messaging\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.git import get_short_branch\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.locationd.calibrationd import MIN_SPEED_FILTER\n\nAlertSize = log.ControlsState.AlertSize\nAlertStatus = log.ControlsState.AlertStatus\nVisualAlert = car.CarControl.HUDControl.VisualAlert\nAudibleAlert = car.CarControl.HUDControl.AudibleAlert\nEventName = car.CarEvent.EventName\n\n\n# Alert priorities\nclass Priority(IntEnum):\n  LOWEST = 0\n  LOWER = 1\n  LOW = 2\n  MID = 3\n  HIGH = 4\n  HIGHEST = 5\n\n\n# Event types\nclass ET:\n  ENABLE = 'enable'\n  PRE_ENABLE = 'preEnable'\n  OVERRIDE_LATERAL = 'overrideLateral'\n  OVERRIDE_LONGITUDINAL = 'overrideLongitudinal'\n  NO_ENTRY = 'noEntry'\n  WARNING = 'warning'\n  USER_DISABLE = 'userDisable'\n  SOFT_DISABLE = 'softDisable'\n  IMMEDIATE_DISABLE = 'immediateDisable'\n  PERMANENT = 'permanent'\n\n\n# get event name from enum\nEVENT_NAME = {v: k for k, v in EventName.schema.enumerants.items()}\n\n\nclass Events:\n  def __init__(self):\n    self.events: list[int] = []\n    self.static_events: list[int] = []\n    self.event_counters = dict.fromkeys(EVENTS.keys(), 0)\n\n  @property\n  def names(self) -> list[int]:\n    return self.events\n\n  def __len__(self) -> int:\n    return len(self.events)\n\n  def add(self, event_name: int, static: bool=False) -> None:\n    if static:\n      bisect.insort(self.static_events, event_name)\n    bisect.insort(self.events, event_name)\n\n  def clear(self) -> None:\n    self.event_counters = {k: (v + 1 if k in self.events else 0) for k, v in self.event_counters.items()}\n    self.events = self.static_events.copy()\n\n  def contains(self, event_type: str) -> bool:\n    return any(event_type in EVENTS.get(e, {}) for e in self.events)\n\n  def create_alerts(self, event_types: list[str], callback_args=None):\n    if callback_args is None:\n      callback_args = []\n\n    ret = []\n    for e in self.events:\n      types = EVENTS[e].keys()\n      for et in event_types:\n        if et in types:\n          alert = EVENTS[e][et]\n          if not isinstance(alert, Alert):\n            alert = alert(*callback_args)\n\n          if DT_CTRL * (self.event_counters[e] + 1) >= alert.creation_delay:\n            alert.alert_type = f\"{EVENT_NAME[e]}/{et}\"\n            alert.event_type = et\n            ret.append(alert)\n    return ret\n\n  def add_from_msg(self, events):\n    for e in events:\n      bisect.insort(self.events, e.name.raw)\n\n  def to_msg(self):\n    ret = []\n    for event_name in self.events:\n      event = car.CarEvent.new_message()\n      event.name = event_name\n      for event_type in EVENTS.get(event_name, {}):\n        setattr(event, event_type, True)\n      ret.append(event)\n    return ret\n\n\nclass Alert:\n  def __init__(self,\n               alert_text_1: str,\n               alert_text_2: str,\n               alert_status: log.ControlsState.AlertStatus,\n               alert_size: log.ControlsState.AlertSize,\n               priority: Priority,\n               visual_alert: car.CarControl.HUDControl.VisualAlert,\n               audible_alert: car.CarControl.HUDControl.AudibleAlert,\n               duration: float,\n               alert_rate: float = 0.,\n               creation_delay: float = 0.):\n\n    self.alert_text_1 = alert_text_1\n    self.alert_text_2 = alert_text_2\n    self.alert_status = alert_status\n    self.alert_size = alert_size\n    self.priority = priority\n    self.visual_alert = visual_alert\n    self.audible_alert = audible_alert\n\n    self.duration = int(duration / DT_CTRL)\n\n    self.alert_rate = alert_rate\n    self.creation_delay = creation_delay\n\n    self.alert_type = \"\"\n    self.event_type: str | None = None\n\n  def __str__(self) -> str:\n    return f\"{self.alert_text_1}/{self.alert_text_2} {self.priority} {self.visual_alert} {self.audible_alert}\"\n\n  def __gt__(self, alert2) -> bool:\n    if not isinstance(alert2, Alert):\n      return False\n    return self.priority > alert2.priority\n\n\nclass NoEntryAlert(Alert):\n  def __init__(self, alert_text_2: str,\n               alert_text_1: str = \"openpilot Unavailable\",\n               visual_alert: car.CarControl.HUDControl.VisualAlert=VisualAlert.none):\n    super().__init__(alert_text_1, alert_text_2, AlertStatus.normal,\n                     AlertSize.mid, Priority.LOW, visual_alert,\n                     AudibleAlert.refuse, 3.)\n\n\nclass SoftDisableAlert(Alert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(\"TAKE CONTROL IMMEDIATELY\", alert_text_2,\n                     AlertStatus.userPrompt, AlertSize.full,\n                     Priority.MID, VisualAlert.steerRequired,\n                     AudibleAlert.warningSoft, 2.),\n\n\n# less harsh version of SoftDisable, where the condition is user-triggered\nclass UserSoftDisableAlert(SoftDisableAlert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(alert_text_2),\n    self.alert_text_1 = \"openpilot will disengage\"\n\n\nclass ImmediateDisableAlert(Alert):\n  def __init__(self, alert_text_2: str):\n    super().__init__(\"TAKE CONTROL IMMEDIATELY\", alert_text_2,\n                     AlertStatus.critical, AlertSize.full,\n                     Priority.HIGHEST, VisualAlert.steerRequired,\n                     AudibleAlert.warningImmediate, 4.),\n\n\nclass EngagementAlert(Alert):\n  def __init__(self, audible_alert: car.CarControl.HUDControl.AudibleAlert):\n    super().__init__(\"\", \"\",\n                     AlertStatus.normal, AlertSize.none,\n                     Priority.MID, VisualAlert.none,\n                     audible_alert, .2),\n\n\nclass NormalPermanentAlert(Alert):\n  def __init__(self, alert_text_1: str, alert_text_2: str = \"\", duration: float = 0.2, priority: Priority = Priority.LOWER, creation_delay: float = 0.):\n    super().__init__(alert_text_1, alert_text_2,\n                     AlertStatus.normal, AlertSize.mid if len(alert_text_2) else AlertSize.small,\n                     priority, VisualAlert.none, AudibleAlert.none, duration, creation_delay=creation_delay),\n\n\nclass StartupAlert(Alert):\n  def __init__(self, alert_text_1: str, alert_text_2: str = \"Always keep hands on wheel and eyes on road\", alert_status=AlertStatus.normal):\n    super().__init__(alert_text_1, alert_text_2,\n                     alert_status, AlertSize.mid,\n                     Priority.LOWER, VisualAlert.none, AudibleAlert.none, 5.),\n\n\n# ********** helper functions **********\ndef get_display_speed(speed_ms: float, metric: bool) -> str:\n  speed = int(round(speed_ms * (CV.MS_TO_KPH if metric else CV.MS_TO_MPH)))\n  unit = 'km/h' if metric else 'mph'\n  return f\"{speed} {unit}\"\n\n\n# ********** alert callback functions **********\n\nAlertCallbackType = Callable[[car.CarParams, car.CarState, messaging.SubMaster, bool, int], Alert]\n\n\ndef soft_disable_alert(alert_text_2: str) -> AlertCallbackType:\n  def func(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n    if soft_disable_time < int(0.5 / DT_CTRL):\n      return ImmediateDisableAlert(alert_text_2)\n    return SoftDisableAlert(alert_text_2)\n  return func\n\ndef user_soft_disable_alert(alert_text_2: str) -> AlertCallbackType:\n  def func(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n    if soft_disable_time < int(0.5 / DT_CTRL):\n      return ImmediateDisableAlert(alert_text_2)\n    return UserSoftDisableAlert(alert_text_2)\n  return func\n\ndef startup_master_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  branch = get_short_branch()  # Ensure get_short_branch is cached to avoid lags on startup\n  if \"REPLAY\" in os.environ:\n    branch = \"replay\"\n\n  return StartupAlert(\"WARNING: This branch is not tested\", branch, alert_status=AlertStatus.userPrompt)\n\ndef below_engage_speed_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  return NoEntryAlert(f\"Drive above {get_display_speed(CP.minEnableSpeed, metric)} to engage\")\n\n\ndef below_steer_speed_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  return Alert(\n    f\"Steer Unavailable Below {get_display_speed(CP.minSteerSpeed, metric)}\",\n    \"\",\n    AlertStatus.userPrompt, AlertSize.small,\n    Priority.LOW, VisualAlert.steerRequired, AudibleAlert.prompt, 0.4)\n\n\ndef calibration_incomplete_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  first_word = 'Recalibration' if sm['liveCalibration'].calStatus == log.LiveCalibrationData.Status.recalibrating else 'Calibration'\n  return Alert(\n    f\"{first_word} in Progress: {sm['liveCalibration'].calPerc:.0f}%\",\n    f\"Drive Above {get_display_speed(MIN_SPEED_FILTER, metric)}\",\n    AlertStatus.normal, AlertSize.mid,\n    Priority.LOWEST, VisualAlert.none, AudibleAlert.none, .2)\n\n\n# *** debug alerts ***\n\ndef out_of_space_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  full_perc = round(100. - sm['deviceState'].freeSpacePercent)\n  return NormalPermanentAlert(\"Out of Storage\", f\"{full_perc}% full\")\n\n\ndef posenet_invalid_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  mdl = sm['modelV2'].velocity.x[0] if len(sm['modelV2'].velocity.x) else math.nan\n  err = CS.vEgo - mdl\n  msg = f\"Speed Error: {err:.1f} m/s\"\n  return NoEntryAlert(msg, alert_text_1=\"Posenet Speed Invalid\")\n\n\ndef process_not_running_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  not_running = [p.name for p in sm['managerState'].processes if not p.running and p.shouldBeRunning]\n  msg = ', '.join(not_running)\n  return NoEntryAlert(msg, alert_text_1=\"Process Not Running\")\n\n\ndef comm_issue_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  bs = [s for s in sm.data.keys() if not sm.all_checks([s, ])]\n  msg = ', '.join(bs[:4])  # can't fit too many on one line\n  return NoEntryAlert(msg, alert_text_1=\"Communication Issue Between Processes\")\n\n\ndef camera_malfunction_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  all_cams = ('roadCameraState', 'driverCameraState', 'wideRoadCameraState')\n  bad_cams = [s.replace('State', '') for s in all_cams if s in sm.data.keys() and not sm.all_checks([s, ])]\n  return NormalPermanentAlert(\"Camera Malfunction\", ', '.join(bad_cams))\n\n\ndef calibration_invalid_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  rpy = sm['liveCalibration'].rpyCalib\n  yaw = math.degrees(rpy[2] if len(rpy) == 3 else math.nan)\n  pitch = math.degrees(rpy[1] if len(rpy) == 3 else math.nan)\n  angles = f\"Remount Device (Pitch: {pitch:.1f}\u00b0, Yaw: {yaw:.1f}\u00b0)\"\n  return NormalPermanentAlert(\"Calibration Invalid\", angles)\n\n\ndef overheat_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  cpu = max(sm['deviceState'].cpuTempC, default=0.)\n  gpu = max(sm['deviceState'].gpuTempC, default=0.)\n  temp = max((cpu, gpu, sm['deviceState'].memoryTempC))\n  return NormalPermanentAlert(\"System Overheated\", f\"{temp:.0f} \u00b0C\")\n\n\ndef low_memory_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  return NormalPermanentAlert(\"Low Memory\", f\"{sm['deviceState'].memoryUsagePercent}% used\")\n\n\ndef high_cpu_usage_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  x = max(sm['deviceState'].cpuUsagePercent, default=0.)\n  return NormalPermanentAlert(\"High CPU Usage\", f\"{x}% used\")\n\n\ndef modeld_lagging_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  return NormalPermanentAlert(\"Driving Model Lagging\", f\"{sm['modelV2'].frameDropPerc:.1f}% frames dropped\")\n\n\ndef wrong_car_mode_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  text = \"Enable Adaptive Cruise to Engage\"\n  if CP.carName == \"honda\":\n    text = \"Enable Main Switch to Engage\"\n  return NoEntryAlert(text)\n\n\ndef joystick_alert(CP: car.CarParams, CS: car.CarState, sm: messaging.SubMaster, metric: bool, soft_disable_time: int) -> Alert:\n  axes = sm['testJoystick'].axes\n  gb, steer = list(axes)[:2] if len(axes) else (0., 0.)\n  vals = f\"Gas: {round(gb * 100.)}%, Steer: {round(steer * 100.)}%\"\n  return NormalPermanentAlert(\"Joystick Mode\", vals)\n\n\n\nEVENTS: dict[int, dict[str, Alert | AlertCallbackType]] = {\n  # ********** events with no alerts **********\n\n  EventName.stockFcw: {},\n  EventName.actuatorsApiUnavailable: {},\n\n  # ********** events only containing alerts displayed in all states **********\n\n  EventName.joystickDebug: {\n    ET.WARNING: joystick_alert,\n    ET.PERMANENT: NormalPermanentAlert(\"Joystick Mode\"),\n  },\n\n  EventName.controlsInitializing: {\n    ET.NO_ENTRY: NoEntryAlert(\"System Initializing\"),\n  },\n\n  EventName.startup: {\n    ET.PERMANENT: StartupAlert(\"Be ready to take over at any time\")\n  },\n\n  EventName.startupMaster: {\n    ET.PERMANENT: startup_master_alert,\n  },\n\n  # Car is recognized, but marked as dashcam only\n  EventName.startupNoControl: {\n    ET.PERMANENT: StartupAlert(\"Dashcam mode\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Dashcam mode\"),\n  },\n\n  # Car is not recognized\n  EventName.startupNoCar: {\n    ET.PERMANENT: StartupAlert(\"Dashcam mode for unsupported car\"),\n  },\n\n  EventName.startupNoFw: {\n    ET.PERMANENT: StartupAlert(\"Car Unrecognized\",\n                               \"Check comma power connections\",\n                               alert_status=AlertStatus.userPrompt),\n  },\n\n  EventName.dashcamMode: {\n    ET.PERMANENT: NormalPermanentAlert(\"Dashcam Mode\",\n                                       priority=Priority.LOWEST),\n  },\n\n  EventName.invalidLkasSetting: {\n    ET.PERMANENT: NormalPermanentAlert(\"Stock LKAS is on\",\n                                       \"Turn off stock LKAS to engage\"),\n  },\n\n  EventName.cruiseMismatch: {\n    #ET.PERMANENT: ImmediateDisableAlert(\"openpilot failed to cancel cruise\"),\n  },\n\n  # openpilot doesn't recognize the car. This switches openpilot into a\n  # read-only mode. This can be solved by adding your fingerprint.\n  # See https://github.com/commaai/openpilot/wiki/Fingerprinting for more information\n  EventName.carUnrecognized: {\n    ET.PERMANENT: NormalPermanentAlert(\"Dashcam Mode\",\n                                       \"Car Unrecognized\",\n                                       priority=Priority.LOWEST),\n  },\n\n  EventName.stockAeb: {\n    ET.PERMANENT: Alert(\n      \"BRAKE!\",\n      \"Stock AEB: Risk of Collision\",\n      AlertStatus.critical, AlertSize.full,\n      Priority.HIGHEST, VisualAlert.fcw, AudibleAlert.none, 2.),\n    ET.NO_ENTRY: NoEntryAlert(\"Stock AEB: Risk of Collision\"),\n  },\n\n  EventName.fcw: {\n    ET.PERMANENT: Alert(\n      \"BRAKE!\",\n      \"Risk of Collision\",\n      AlertStatus.critical, AlertSize.full,\n      Priority.HIGHEST, VisualAlert.fcw, AudibleAlert.warningSoft, 2.),\n  },\n\n  EventName.ldw: {\n    ET.PERMANENT: Alert(\n      \"Lane Departure Detected\",\n      \"\",\n      AlertStatus.userPrompt, AlertSize.small,\n      Priority.LOW, VisualAlert.ldw, AudibleAlert.prompt, 3.),\n  },\n\n  # ********** events only containing alerts that display while engaged **********\n\n  EventName.steerTempUnavailableSilent: {\n    ET.WARNING: Alert(\n      \"Steering Temporarily Unavailable\",\n      \"\",\n      AlertStatus.userPrompt, AlertSize.small,\n      Priority.LOW, VisualAlert.steerRequired, AudibleAlert.prompt, 1.8),\n  },\n\n  EventName.preDriverDistracted: {\n    ET.PERMANENT: Alert(\n      \"Pay Attention\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, .1),\n  },\n\n  EventName.promptDriverDistracted: {\n    ET.PERMANENT: Alert(\n      \"Pay Attention\",\n      \"Driver Distracted\",\n      AlertStatus.userPrompt, AlertSize.mid,\n      Priority.MID, VisualAlert.steerRequired, AudibleAlert.promptDistracted, .1),\n  },\n\n  EventName.driverDistracted: {\n    ET.PERMANENT: Alert(\n      \"DISENGAGE IMMEDIATELY\",\n      \"Driver Distracted\",\n      AlertStatus.critical, AlertSize.full,\n      Priority.HIGH, VisualAlert.steerRequired, AudibleAlert.warningImmediate, .1),\n  },\n\n  EventName.preDriverUnresponsive: {\n    ET.PERMANENT: Alert(\n      \"Touch Steering Wheel: No Face Detected\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.steerRequired, AudibleAlert.none, .1, alert_rate=0.75),\n  },\n\n  EventName.promptDriverUnresponsive: {\n    ET.PERMANENT: Alert(\n      \"Touch Steering Wheel\",\n      \"Driver Unresponsive\",\n      AlertStatus.userPrompt, AlertSize.mid,\n      Priority.MID, VisualAlert.steerRequired, AudibleAlert.promptDistracted, .1),\n  },\n\n  EventName.driverUnresponsive: {\n    ET.PERMANENT: Alert(\n      \"DISENGAGE IMMEDIATELY\",\n      \"Driver Unresponsive\",\n      AlertStatus.critical, AlertSize.full,\n      Priority.HIGH, VisualAlert.steerRequired, AudibleAlert.warningImmediate, .1),\n  },\n\n  EventName.manualRestart: {\n    ET.WARNING: Alert(\n      \"TAKE CONTROL\",\n      \"Resume Driving Manually\",\n      AlertStatus.userPrompt, AlertSize.mid,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, .2),\n  },\n\n  EventName.resumeRequired: {\n    ET.WARNING: Alert(\n      \"Press Resume to Exit Standstill\",\n      \"\",\n      AlertStatus.userPrompt, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, .2),\n  },\n\n  EventName.belowSteerSpeed: {\n    ET.WARNING: below_steer_speed_alert,\n  },\n\n  EventName.preLaneChangeLeft: {\n    ET.WARNING: Alert(\n      \"Steer Left to Start Lane Change Once Safe\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, .1, alert_rate=0.75),\n  },\n\n  EventName.preLaneChangeRight: {\n    ET.WARNING: Alert(\n      \"Steer Right to Start Lane Change Once Safe\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, .1, alert_rate=0.75),\n  },\n\n  EventName.laneChangeBlocked: {\n    ET.WARNING: Alert(\n      \"Car Detected in Blindspot\",\n      \"\",\n      AlertStatus.userPrompt, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.prompt, .1),\n  },\n\n  EventName.laneChange: {\n    ET.WARNING: Alert(\n      \"Changing Lanes\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, .1),\n  },\n\n  EventName.steerSaturated: {\n    ET.WARNING: Alert(\n      \"Take Control\",\n      \"Turn Exceeds Steering Limit\",\n      AlertStatus.userPrompt, AlertSize.mid,\n      Priority.LOW, VisualAlert.steerRequired, AudibleAlert.promptRepeat, 2.),\n  },\n\n  # Thrown when the fan is driven at >50% but is not rotating\n  EventName.fanMalfunction: {\n    ET.PERMANENT: NormalPermanentAlert(\"Fan Malfunction\", \"Likely Hardware Issue\"),\n  },\n\n  # Camera is not outputting frames\n  EventName.cameraMalfunction: {\n    ET.PERMANENT: camera_malfunction_alert,\n    ET.SOFT_DISABLE: soft_disable_alert(\"Camera Malfunction\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Camera Malfunction: Reboot Your Device\"),\n  },\n  # Camera framerate too low\n  EventName.cameraFrameRate: {\n    ET.PERMANENT: NormalPermanentAlert(\"Camera Frame Rate Low\", \"Reboot your Device\"),\n    ET.SOFT_DISABLE: soft_disable_alert(\"Camera Frame Rate Low\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Camera Frame Rate Low: Reboot Your Device\"),\n  },\n\n  # Unused\n\n  EventName.locationdTemporaryError: {\n    ET.NO_ENTRY: NoEntryAlert(\"locationd Temporary Error\"),\n    ET.SOFT_DISABLE: soft_disable_alert(\"locationd Temporary Error\"),\n  },\n\n  EventName.locationdPermanentError: {\n    ET.NO_ENTRY: NoEntryAlert(\"locationd Permanent Error\"),\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"locationd Permanent Error\"),\n    ET.PERMANENT: NormalPermanentAlert(\"locationd Permanent Error\"),\n  },\n\n  # openpilot tries to learn certain parameters about your car by observing\n  # how the car behaves to steering inputs from both human and openpilot driving.\n  # This includes:\n  # - steer ratio: gear ratio of the steering rack. Steering angle divided by tire angle\n  # - tire stiffness: how much grip your tires have\n  # - angle offset: most steering angle sensors are offset and measure a non zero angle when driving straight\n  # This alert is thrown when any of these values exceed a sanity check. This can be caused by\n  # bad alignment or bad sensor data. If this happens consistently consider creating an issue on GitHub\n  EventName.paramsdTemporaryError: {\n    ET.NO_ENTRY: NoEntryAlert(\"paramsd Temporary Error\"),\n    ET.SOFT_DISABLE: soft_disable_alert(\"paramsd Temporary Error\"),\n  },\n\n  EventName.paramsdPermanentError: {\n    ET.NO_ENTRY: NoEntryAlert(\"paramsd Permanent Error\"),\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"paramsd Permanent Error\"),\n    ET.PERMANENT: NormalPermanentAlert(\"paramsd Permanent Error\"),\n  },\n\n  # ********** events that affect controls state transitions **********\n\n  EventName.pcmEnable: {\n    ET.ENABLE: EngagementAlert(AudibleAlert.engage),\n  },\n\n  EventName.buttonEnable: {\n    ET.ENABLE: EngagementAlert(AudibleAlert.engage),\n  },\n\n  EventName.pcmDisable: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n  },\n\n  EventName.buttonCancel: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n    ET.NO_ENTRY: NoEntryAlert(\"Cancel Pressed\"),\n  },\n\n  EventName.brakeHold: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n    ET.NO_ENTRY: NoEntryAlert(\"Brake Hold Active\"),\n  },\n\n  EventName.parkBrake: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n    ET.NO_ENTRY: NoEntryAlert(\"Parking Brake Engaged\"),\n  },\n\n  EventName.pedalPressed: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n    ET.NO_ENTRY: NoEntryAlert(\"Pedal Pressed\",\n                              visual_alert=VisualAlert.brakePressed),\n  },\n\n  EventName.preEnableStandstill: {\n    ET.PRE_ENABLE: Alert(\n      \"Release Brake to Engage\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOWEST, VisualAlert.none, AudibleAlert.none, .1, creation_delay=1.),\n  },\n\n  EventName.gasPressedOverride: {\n    ET.OVERRIDE_LONGITUDINAL: Alert(\n      \"\",\n      \"\",\n      AlertStatus.normal, AlertSize.none,\n      Priority.LOWEST, VisualAlert.none, AudibleAlert.none, .1),\n  },\n\n  EventName.steerOverride: {\n    ET.OVERRIDE_LATERAL: Alert(\n      \"\",\n      \"\",\n      AlertStatus.normal, AlertSize.none,\n      Priority.LOWEST, VisualAlert.none, AudibleAlert.none, .1),\n  },\n\n  EventName.wrongCarMode: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n    ET.NO_ENTRY: wrong_car_mode_alert,\n  },\n\n  EventName.resumeBlocked: {\n    ET.NO_ENTRY: NoEntryAlert(\"Press Set to Engage\"),\n  },\n\n  EventName.wrongCruiseMode: {\n    ET.USER_DISABLE: EngagementAlert(AudibleAlert.disengage),\n    ET.NO_ENTRY: NoEntryAlert(\"Adaptive Cruise Disabled\"),\n  },\n\n  EventName.steerTempUnavailable: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Steering Temporarily Unavailable\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Steering Temporarily Unavailable\"),\n  },\n\n  EventName.steerTimeLimit: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Vehicle Steering Time Limit\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Vehicle Steering Time Limit\"),\n  },\n\n  EventName.outOfSpace: {\n    ET.PERMANENT: out_of_space_alert,\n    ET.NO_ENTRY: NoEntryAlert(\"Out of Storage\"),\n  },\n\n  EventName.belowEngageSpeed: {\n    ET.NO_ENTRY: below_engage_speed_alert,\n  },\n\n  EventName.sensorDataInvalid: {\n    ET.PERMANENT: Alert(\n      \"Sensor Data Invalid\",\n      \"Possible Hardware Issue\",\n      AlertStatus.normal, AlertSize.mid,\n      Priority.LOWER, VisualAlert.none, AudibleAlert.none, .2, creation_delay=1.),\n    ET.NO_ENTRY: NoEntryAlert(\"Sensor Data Invalid\"),\n    ET.SOFT_DISABLE: soft_disable_alert(\"Sensor Data Invalid\"),\n  },\n\n  EventName.noGps: {\n    ET.PERMANENT: Alert(\n      \"Poor GPS reception\",\n      \"Ensure device has a clear view of the sky\",\n      AlertStatus.normal, AlertSize.mid,\n      Priority.LOWER, VisualAlert.none, AudibleAlert.none, .2, creation_delay=600.)\n  },\n\n  EventName.soundsUnavailable: {\n    ET.PERMANENT: NormalPermanentAlert(\"Speaker not found\", \"Reboot your Device\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Speaker not found\"),\n  },\n\n  EventName.tooDistracted: {\n    ET.NO_ENTRY: NoEntryAlert(\"Distraction Level Too High\"),\n  },\n\n  EventName.overheat: {\n    ET.PERMANENT: overheat_alert,\n    ET.SOFT_DISABLE: soft_disable_alert(\"System Overheated\"),\n    ET.NO_ENTRY: NoEntryAlert(\"System Overheated\"),\n  },\n\n  EventName.wrongGear: {\n    ET.SOFT_DISABLE: user_soft_disable_alert(\"Gear not D\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Gear not D\"),\n  },\n\n  # This alert is thrown when the calibration angles are outside of the acceptable range.\n  # For example if the device is pointed too much to the left or the right.\n  # Usually this can only be solved by removing the mount from the windshield completely,\n  # and attaching while making sure the device is pointed straight forward and is level.\n  # See https://comma.ai/setup for more information\n  EventName.calibrationInvalid: {\n    ET.PERMANENT: calibration_invalid_alert,\n    ET.SOFT_DISABLE: soft_disable_alert(\"Calibration Invalid: Remount Device & Recalibrate\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Calibration Invalid: Remount Device & Recalibrate\"),\n  },\n\n  EventName.calibrationIncomplete: {\n    ET.PERMANENT: calibration_incomplete_alert,\n    ET.SOFT_DISABLE: soft_disable_alert(\"Calibration Incomplete\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Calibration in Progress\"),\n  },\n\n  EventName.calibrationRecalibrating: {\n    ET.PERMANENT: calibration_incomplete_alert,\n    ET.SOFT_DISABLE: soft_disable_alert(\"Device Remount Detected: Recalibrating\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Remount Detected: Recalibrating\"),\n  },\n\n  EventName.doorOpen: {\n    ET.SOFT_DISABLE: user_soft_disable_alert(\"Door Open\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Door Open\"),\n  },\n\n  EventName.seatbeltNotLatched: {\n    ET.SOFT_DISABLE: user_soft_disable_alert(\"Seatbelt Unlatched\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Seatbelt Unlatched\"),\n  },\n\n  EventName.espDisabled: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Electronic Stability Control Disabled\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Electronic Stability Control Disabled\"),\n  },\n\n  EventName.lowBattery: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Low Battery\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Low Battery\"),\n  },\n\n  # Different openpilot services communicate between each other at a certain\n  # interval. If communication does not follow the regular schedule this alert\n  # is thrown. This can mean a service crashed, did not broadcast a message for\n  # ten times the regular interval, or the average interval is more than 10% too high.\n  EventName.commIssue: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Communication Issue Between Processes\"),\n    ET.NO_ENTRY: comm_issue_alert,\n  },\n  EventName.commIssueAvgFreq: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Low Communication Rate Between Processes\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Low Communication Rate Between Processes\"),\n  },\n\n  EventName.controlsdLagging: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Controls Lagging\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Controls Process Lagging: Reboot Your Device\"),\n  },\n\n  # Thrown when manager detects a service exited unexpectedly while driving\n  EventName.processNotRunning: {\n    ET.NO_ENTRY: process_not_running_alert,\n    ET.SOFT_DISABLE: soft_disable_alert(\"Process Not Running\"),\n  },\n\n  EventName.radarFault: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Radar Error: Restart the Car\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Radar Error: Restart the Car\"),\n  },\n\n  # Every frame from the camera should be processed by the model. If modeld\n  # is not processing frames fast enough they have to be dropped. This alert is\n  # thrown when over 20% of frames are dropped.\n  EventName.modeldLagging: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Driving Model Lagging\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Driving Model Lagging\"),\n    ET.PERMANENT: modeld_lagging_alert,\n  },\n\n  # Besides predicting the path, lane lines and lead car data the model also\n  # predicts the current velocity and rotation speed of the car. If the model is\n  # very uncertain about the current velocity while the car is moving, this\n  # usually means the model has trouble understanding the scene. This is used\n  # as a heuristic to warn the driver.\n  EventName.posenetInvalid: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Posenet Speed Invalid\"),\n    ET.NO_ENTRY: posenet_invalid_alert,\n  },\n\n  # When the localizer detects an acceleration of more than 40 m/s^2 (~4G) we\n  # alert the driver the device might have fallen from the windshield.\n  EventName.deviceFalling: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Device Fell Off Mount\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Device Fell Off Mount\"),\n  },\n\n  EventName.lowMemory: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"Low Memory: Reboot Your Device\"),\n    ET.PERMANENT: low_memory_alert,\n    ET.NO_ENTRY: NoEntryAlert(\"Low Memory: Reboot Your Device\"),\n  },\n\n  EventName.highCpuUsage: {\n    #ET.SOFT_DISABLE: soft_disable_alert(\"System Malfunction: Reboot Your Device\"),\n    #ET.PERMANENT: NormalPermanentAlert(\"System Malfunction\", \"Reboot your Device\"),\n    ET.NO_ENTRY: high_cpu_usage_alert,\n  },\n\n  EventName.accFaulted: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"Cruise Fault: Restart the Car\"),\n    ET.PERMANENT: NormalPermanentAlert(\"Cruise Fault: Restart the car to engage\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Cruise Fault: Restart the Car\"),\n  },\n\n  EventName.espActive: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"Electronic Stability Control Active\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Electronic Stability Control Active\"),\n  },\n\n  EventName.controlsMismatch: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"Controls Mismatch\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Controls Mismatch\"),\n  },\n\n  EventName.roadCameraError: {\n    ET.PERMANENT: NormalPermanentAlert(\"Camera CRC Error - Road\",\n                                       duration=1.,\n                                       creation_delay=30.),\n  },\n\n  EventName.wideRoadCameraError: {\n    ET.PERMANENT: NormalPermanentAlert(\"Camera CRC Error - Road Fisheye\",\n                                       duration=1.,\n                                       creation_delay=30.),\n  },\n\n  EventName.driverCameraError: {\n    ET.PERMANENT: NormalPermanentAlert(\"Camera CRC Error - Driver\",\n                                       duration=1.,\n                                       creation_delay=30.),\n  },\n\n  # Sometimes the USB stack on the device can get into a bad state\n  # causing the connection to the panda to be lost\n  EventName.usbError: {\n    ET.SOFT_DISABLE: soft_disable_alert(\"USB Error: Reboot Your Device\"),\n    ET.PERMANENT: NormalPermanentAlert(\"USB Error: Reboot Your Device\", \"\"),\n    ET.NO_ENTRY: NoEntryAlert(\"USB Error: Reboot Your Device\"),\n  },\n\n  # This alert can be thrown for the following reasons:\n  # - No CAN data received at all\n  # - CAN data is received, but some message are not received at the right frequency\n  # If you're not writing a new car port, this is usually cause by faulty wiring\n  EventName.canError: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"CAN Error\"),\n    ET.PERMANENT: Alert(\n      \"CAN Error: Check Connections\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, 1., creation_delay=1.),\n    ET.NO_ENTRY: NoEntryAlert(\"CAN Error: Check Connections\"),\n  },\n\n  EventName.canBusMissing: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"CAN Bus Disconnected\"),\n    ET.PERMANENT: Alert(\n      \"CAN Bus Disconnected: Likely Faulty Cable\",\n      \"\",\n      AlertStatus.normal, AlertSize.small,\n      Priority.LOW, VisualAlert.none, AudibleAlert.none, 1., creation_delay=1.),\n    ET.NO_ENTRY: NoEntryAlert(\"CAN Bus Disconnected: Check Connections\"),\n  },\n\n  EventName.steerUnavailable: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"LKAS Fault: Restart the Car\"),\n    ET.PERMANENT: NormalPermanentAlert(\"LKAS Fault: Restart the car to engage\"),\n    ET.NO_ENTRY: NoEntryAlert(\"LKAS Fault: Restart the Car\"),\n  },\n\n  EventName.reverseGear: {\n    ET.PERMANENT: Alert(\n      \"Reverse\\nGear\",\n      \"\",\n      AlertStatus.normal, AlertSize.full,\n      Priority.LOWEST, VisualAlert.none, AudibleAlert.none, .2, creation_delay=0.5),\n    ET.USER_DISABLE: ImmediateDisableAlert(\"Reverse Gear\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Reverse Gear\"),\n  },\n\n  # On cars that use stock ACC the car can decide to cancel ACC for various reasons.\n  # When this happens we can no long control the car so the user needs to be warned immediately.\n  EventName.cruiseDisabled: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"Cruise Is Off\"),\n  },\n\n  # When the relay in the harness box opens the CAN bus between the LKAS camera\n  # and the rest of the car is separated. When messages from the LKAS camera\n  # are received on the car side this usually means the relay hasn't opened correctly\n  # and this alert is thrown.\n  EventName.relayMalfunction: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"Harness Relay Malfunction\"),\n    ET.PERMANENT: NormalPermanentAlert(\"Harness Relay Malfunction\", \"Check Hardware\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Harness Relay Malfunction\"),\n  },\n\n  EventName.speedTooLow: {\n    ET.IMMEDIATE_DISABLE: Alert(\n      \"openpilot Canceled\",\n      \"Speed too low\",\n      AlertStatus.normal, AlertSize.mid,\n      Priority.HIGH, VisualAlert.none, AudibleAlert.disengage, 3.),\n  },\n\n  # When the car is driving faster than most cars in the training data, the model outputs can be unpredictable.\n  EventName.speedTooHigh: {\n    ET.WARNING: Alert(\n      \"Speed Too High\",\n      \"Model uncertain at this speed\",\n      AlertStatus.userPrompt, AlertSize.mid,\n      Priority.HIGH, VisualAlert.steerRequired, AudibleAlert.promptRepeat, 4.),\n    ET.NO_ENTRY: NoEntryAlert(\"Slow down to engage\"),\n  },\n\n  EventName.lowSpeedLockout: {\n    ET.PERMANENT: NormalPermanentAlert(\"Cruise Fault: Restart the car to engage\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Cruise Fault: Restart the Car\"),\n  },\n\n  EventName.lkasDisabled: {\n    ET.PERMANENT: NormalPermanentAlert(\"LKAS Disabled: Enable LKAS to engage\"),\n    ET.NO_ENTRY: NoEntryAlert(\"LKAS Disabled\"),\n  },\n\n  EventName.vehicleSensorsInvalid: {\n    ET.IMMEDIATE_DISABLE: ImmediateDisableAlert(\"Vehicle Sensors Invalid\"),\n    ET.PERMANENT: NormalPermanentAlert(\"Vehicle Sensors Calibrating\", \"Drive to Calibrate\"),\n    ET.NO_ENTRY: NoEntryAlert(\"Vehicle Sensors Calibrating\"),\n  },\n\n}\n\n\nif __name__ == '__main__':\n  # print all alerts by type and priority\n  from cereal.services import SERVICE_LIST\n  from collections import defaultdict\n\n  event_names = {v: k for k, v in EventName.schema.enumerants.items()}\n  alerts_by_type: dict[str, dict[Priority, list[str]]] = defaultdict(lambda: defaultdict(list))\n\n  CP = car.CarParams.new_message()\n  CS = car.CarState.new_message()\n  sm = messaging.SubMaster(list(SERVICE_LIST.keys()))\n\n  for i, alerts in EVENTS.items():\n    for et, alert in alerts.items():\n      if callable(alert):\n        alert = alert(CP, CS, sm, False, 1)\n      alerts_by_type[et][alert.priority].append(event_names[i])\n\n  all_alerts: dict[str, list[tuple[Priority, list[str]]]] = {}\n  for et, priority_alerts in alerts_by_type.items():\n    all_alerts[et] = sorted(priority_alerts.items(), key=lambda x: x[0], reverse=True)\n\n  for status, evs in sorted(all_alerts.items(), key=lambda x: x[0]):\n    print(f\"**** {status} ****\")\n    for p, alert_list in evs:\n      print(f\"  {repr(p)}:\")\n      print(\"   \", ', '.join(alert_list), \"\\n\")\n", "selfdrive/controls/lib/latcontrol_torque.py": "import math\n\nfrom cereal import log\nfrom openpilot.common.numpy_fast import interp\nfrom openpilot.selfdrive.car.interfaces import LatControlInputs\nfrom openpilot.selfdrive.controls.lib.latcontrol import LatControl\nfrom openpilot.selfdrive.controls.lib.pid import PIDController\nfrom openpilot.selfdrive.controls.lib.vehicle_model import ACCELERATION_DUE_TO_GRAVITY\n\n# At higher speeds (25+mph) we can assume:\n# Lateral acceleration achieved by a specific car correlates to\n# torque applied to the steering rack. It does not correlate to\n# wheel slip, or to speed.\n\n# This controller applies torque to achieve desired lateral\n# accelerations. To compensate for the low speed effects we\n# use a LOW_SPEED_FACTOR in the error. Additionally, there is\n# friction in the steering wheel that needs to be overcome to\n# move it at all, this is compensated for too.\n\nLOW_SPEED_X = [0, 10, 20, 30]\nLOW_SPEED_Y = [15, 13, 10, 5]\n\n\nclass LatControlTorque(LatControl):\n  def __init__(self, CP, CI):\n    super().__init__(CP, CI)\n    self.torque_params = CP.lateralTuning.torque\n    self.pid = PIDController(self.torque_params.kp, self.torque_params.ki,\n                             k_f=self.torque_params.kf, pos_limit=self.steer_max, neg_limit=-self.steer_max)\n    self.torque_from_lateral_accel = CI.torque_from_lateral_accel()\n    self.use_steering_angle = self.torque_params.useSteeringAngle\n    self.steering_angle_deadzone_deg = self.torque_params.steeringAngleDeadzoneDeg\n\n  def update_live_torque_params(self, latAccelFactor, latAccelOffset, friction):\n    self.torque_params.latAccelFactor = latAccelFactor\n    self.torque_params.latAccelOffset = latAccelOffset\n    self.torque_params.friction = friction\n\n  def update(self, active, CS, VM, params, steer_limited, desired_curvature, llk):\n    pid_log = log.ControlsState.LateralTorqueState.new_message()\n    if not active:\n      output_torque = 0.0\n      pid_log.active = False\n    else:\n      actual_curvature_vm = -VM.calc_curvature(math.radians(CS.steeringAngleDeg - params.angleOffsetDeg), CS.vEgo, params.roll)\n      roll_compensation = params.roll * ACCELERATION_DUE_TO_GRAVITY\n      if self.use_steering_angle:\n        actual_curvature = actual_curvature_vm\n        curvature_deadzone = abs(VM.calc_curvature(math.radians(self.steering_angle_deadzone_deg), CS.vEgo, 0.0))\n      else:\n        actual_curvature_llk = llk.angularVelocityCalibrated.value[2] / CS.vEgo\n        actual_curvature = interp(CS.vEgo, [2.0, 5.0], [actual_curvature_vm, actual_curvature_llk])\n        curvature_deadzone = 0.0\n      desired_lateral_accel = desired_curvature * CS.vEgo ** 2\n\n      # desired rate is the desired rate of change in the setpoint, not the absolute desired curvature\n      # desired_lateral_jerk = desired_curvature_rate * CS.vEgo ** 2\n      actual_lateral_accel = actual_curvature * CS.vEgo ** 2\n      lateral_accel_deadzone = curvature_deadzone * CS.vEgo ** 2\n\n      low_speed_factor = interp(CS.vEgo, LOW_SPEED_X, LOW_SPEED_Y)**2\n      setpoint = desired_lateral_accel + low_speed_factor * desired_curvature\n      measurement = actual_lateral_accel + low_speed_factor * actual_curvature\n      gravity_adjusted_lateral_accel = desired_lateral_accel - roll_compensation\n      torque_from_setpoint = self.torque_from_lateral_accel(LatControlInputs(setpoint, roll_compensation, CS.vEgo, CS.aEgo), self.torque_params,\n                                                            setpoint, lateral_accel_deadzone, friction_compensation=False, gravity_adjusted=False)\n      torque_from_measurement = self.torque_from_lateral_accel(LatControlInputs(measurement, roll_compensation, CS.vEgo, CS.aEgo), self.torque_params,\n                                                               measurement, lateral_accel_deadzone, friction_compensation=False, gravity_adjusted=False)\n      pid_log.error = torque_from_setpoint - torque_from_measurement\n      ff = self.torque_from_lateral_accel(LatControlInputs(gravity_adjusted_lateral_accel, roll_compensation, CS.vEgo, CS.aEgo), self.torque_params,\n                                          desired_lateral_accel - actual_lateral_accel, lateral_accel_deadzone, friction_compensation=True,\n                                          gravity_adjusted=True)\n\n      freeze_integrator = steer_limited or CS.steeringPressed or CS.vEgo < 5\n      output_torque = self.pid.update(pid_log.error,\n                                      feedforward=ff,\n                                      speed=CS.vEgo,\n                                      freeze_integrator=freeze_integrator)\n\n      pid_log.active = True\n      pid_log.p = self.pid.p\n      pid_log.i = self.pid.i\n      pid_log.d = self.pid.d\n      pid_log.f = self.pid.f\n      pid_log.output = -output_torque\n      pid_log.actualLateralAccel = actual_lateral_accel\n      pid_log.desiredLateralAccel = desired_lateral_accel\n      pid_log.saturated = self._check_saturation(self.steer_max - abs(output_torque) < 1e-3, CS, steer_limited)\n\n    # TODO left is positive in this convention\n    return -output_torque, 0.0, pid_log\n", "selfdrive/controls/lib/latcontrol_pid.py": "import math\n\nfrom cereal import log\nfrom openpilot.selfdrive.controls.lib.latcontrol import LatControl\nfrom openpilot.selfdrive.controls.lib.pid import PIDController\n\n\nclass LatControlPID(LatControl):\n  def __init__(self, CP, CI):\n    super().__init__(CP, CI)\n    self.pid = PIDController((CP.lateralTuning.pid.kpBP, CP.lateralTuning.pid.kpV),\n                             (CP.lateralTuning.pid.kiBP, CP.lateralTuning.pid.kiV),\n                             k_f=CP.lateralTuning.pid.kf, pos_limit=self.steer_max, neg_limit=-self.steer_max)\n    self.get_steer_feedforward = CI.get_steer_feedforward_function()\n\n  def reset(self):\n    super().reset()\n    self.pid.reset()\n\n  def update(self, active, CS, VM, params, steer_limited, desired_curvature, llk):\n    pid_log = log.ControlsState.LateralPIDState.new_message()\n    pid_log.steeringAngleDeg = float(CS.steeringAngleDeg)\n    pid_log.steeringRateDeg = float(CS.steeringRateDeg)\n\n    angle_steers_des_no_offset = math.degrees(VM.get_steer_from_curvature(-desired_curvature, CS.vEgo, params.roll))\n    angle_steers_des = angle_steers_des_no_offset + params.angleOffsetDeg\n    error = angle_steers_des - CS.steeringAngleDeg\n\n    pid_log.steeringAngleDesiredDeg = angle_steers_des\n    pid_log.angleError = error\n    if not active:\n      output_steer = 0.0\n      pid_log.active = False\n      self.pid.reset()\n    else:\n      # offset does not contribute to resistive torque\n      steer_feedforward = self.get_steer_feedforward(angle_steers_des_no_offset, CS.vEgo)\n\n      output_steer = self.pid.update(error, override=CS.steeringPressed,\n                                     feedforward=steer_feedforward, speed=CS.vEgo)\n      pid_log.active = True\n      pid_log.p = self.pid.p\n      pid_log.i = self.pid.i\n      pid_log.f = self.pid.f\n      pid_log.output = output_steer\n      pid_log.saturated = self._check_saturation(self.steer_max - abs(output_steer) < 1e-3, CS, steer_limited)\n\n    return output_steer, angle_steers_des, pid_log\n", "selfdrive/controls/lib/latcontrol_angle.py": "import math\n\nfrom cereal import log\nfrom openpilot.selfdrive.controls.lib.latcontrol import LatControl\n\nSTEER_ANGLE_SATURATION_THRESHOLD = 2.5  # Degrees\n\n\nclass LatControlAngle(LatControl):\n  def __init__(self, CP, CI):\n    super().__init__(CP, CI)\n    self.sat_check_min_speed = 5.\n\n  def update(self, active, CS, VM, params, steer_limited, desired_curvature, llk):\n    angle_log = log.ControlsState.LateralAngleState.new_message()\n\n    if not active:\n      angle_log.active = False\n      angle_steers_des = float(CS.steeringAngleDeg)\n    else:\n      angle_log.active = True\n      angle_steers_des = math.degrees(VM.get_steer_from_curvature(-desired_curvature, CS.vEgo, params.roll))\n      angle_steers_des += params.angleOffsetDeg\n\n    angle_control_saturated = abs(angle_steers_des - CS.steeringAngleDeg) > STEER_ANGLE_SATURATION_THRESHOLD\n    angle_log.saturated = self._check_saturation(angle_control_saturated, CS, False)\n    angle_log.steeringAngleDeg = float(CS.steeringAngleDeg)\n    angle_log.steeringAngleDesiredDeg = angle_steers_des\n    return 0, float(angle_steers_des), angle_log\n", "selfdrive/controls/lib/vehicle_model.py": "#!/usr/bin/env python3\n\"\"\"\nDynamic bicycle model from \"The Science of Vehicle Dynamics (2014), M. Guiggiani\"\n\nThe state is x = [v, r]^T\nwith v lateral speed [m/s], and r rotational speed [rad/s]\n\nThe input u is the steering angle [rad], and roll [rad]\n\nThe system is defined by\nx_dot = A*x + B*u\n\nA depends on longitudinal speed, u [m/s], and vehicle parameters CP\n\"\"\"\n\nimport numpy as np\nfrom numpy.linalg import solve\n\nfrom cereal import car\n\nACCELERATION_DUE_TO_GRAVITY = 9.8\n\n\nclass VehicleModel:\n  def __init__(self, CP: car.CarParams):\n    \"\"\"\n    Args:\n      CP: Car Parameters\n    \"\"\"\n    # for math readability, convert long names car params into short names\n    self.m: float = CP.mass\n    self.j: float = CP.rotationalInertia\n    self.l: float = CP.wheelbase\n    self.aF: float = CP.centerToFront\n    self.aR: float = CP.wheelbase - CP.centerToFront\n    self.chi: float = CP.steerRatioRear\n\n    self.cF_orig: float = CP.tireStiffnessFront\n    self.cR_orig: float = CP.tireStiffnessRear\n    self.update_params(1.0, CP.steerRatio)\n\n  def update_params(self, stiffness_factor: float, steer_ratio: float) -> None:\n    \"\"\"Update the vehicle model with a new stiffness factor and steer ratio\"\"\"\n    self.cF: float = stiffness_factor * self.cF_orig\n    self.cR: float = stiffness_factor * self.cR_orig\n    self.sR: float = steer_ratio\n\n  def steady_state_sol(self, sa: float, u: float, roll: float) -> np.ndarray:\n    \"\"\"Returns the steady state solution.\n\n    If the speed is too low we can't use the dynamic model (tire slip is undefined),\n    we then have to use the kinematic model\n\n    Args:\n      sa: Steering wheel angle [rad]\n      u: Speed [m/s]\n      roll: Road Roll [rad]\n\n    Returns:\n      2x1 matrix with steady state solution (lateral speed, rotational speed)\n    \"\"\"\n    if u > 0.1:\n      return dyn_ss_sol(sa, u, roll, self)\n    else:\n      return kin_ss_sol(sa, u, self)\n\n  def calc_curvature(self, sa: float, u: float, roll: float) -> float:\n    \"\"\"Returns the curvature. Multiplied by the speed this will give the yaw rate.\n\n    Args:\n      sa: Steering wheel angle [rad]\n      u: Speed [m/s]\n      roll: Road Roll [rad]\n\n    Returns:\n      Curvature factor [1/m]\n    \"\"\"\n    return (self.curvature_factor(u) * sa / self.sR) + self.roll_compensation(roll, u)\n\n  def curvature_factor(self, u: float) -> float:\n    \"\"\"Returns the curvature factor.\n    Multiplied by wheel angle (not steering wheel angle) this will give the curvature.\n\n    Args:\n      u: Speed [m/s]\n\n    Returns:\n      Curvature factor [1/m]\n    \"\"\"\n    sf = calc_slip_factor(self)\n    return (1. - self.chi) / (1. - sf * u**2) / self.l\n\n  def get_steer_from_curvature(self, curv: float, u: float, roll: float) -> float:\n    \"\"\"Calculates the required steering wheel angle for a given curvature\n\n    Args:\n      curv: Desired curvature [1/m]\n      u: Speed [m/s]\n      roll: Road Roll [rad]\n\n    Returns:\n      Steering wheel angle [rad]\n    \"\"\"\n\n    return (curv - self.roll_compensation(roll, u)) * self.sR * 1.0 / self.curvature_factor(u)\n\n  def roll_compensation(self, roll: float, u: float) -> float:\n    \"\"\"Calculates the roll-compensation to curvature\n\n    Args:\n      roll: Road Roll [rad]\n      u: Speed [m/s]\n\n    Returns:\n      Roll compensation curvature [rad]\n    \"\"\"\n    sf = calc_slip_factor(self)\n\n    if abs(sf) < 1e-6:\n      return 0\n    else:\n      return (ACCELERATION_DUE_TO_GRAVITY * roll) / ((1 / sf) - u**2)\n\n  def get_steer_from_yaw_rate(self, yaw_rate: float, u: float, roll: float) -> float:\n    \"\"\"Calculates the required steering wheel angle for a given yaw_rate\n\n    Args:\n      yaw_rate: Desired yaw rate [rad/s]\n      u: Speed [m/s]\n      roll: Road Roll [rad]\n\n    Returns:\n      Steering wheel angle [rad]\n    \"\"\"\n    curv = yaw_rate / u\n    return self.get_steer_from_curvature(curv, u, roll)\n\n  def yaw_rate(self, sa: float, u: float, roll: float) -> float:\n    \"\"\"Calculate yaw rate\n\n    Args:\n      sa: Steering wheel angle [rad]\n      u: Speed [m/s]\n      roll: Road Roll [rad]\n\n    Returns:\n      Yaw rate [rad/s]\n    \"\"\"\n    return self.calc_curvature(sa, u, roll) * u\n\n\ndef kin_ss_sol(sa: float, u: float, VM: VehicleModel) -> np.ndarray:\n  \"\"\"Calculate the steady state solution at low speeds\n  At low speeds the tire slip is undefined, so a kinematic\n  model is used.\n\n  Args:\n    sa: Steering angle [rad]\n    u: Speed [m/s]\n    VM: Vehicle model\n\n  Returns:\n    2x1 matrix with steady state solution\n  \"\"\"\n  K = np.zeros((2, 1))\n  K[0, 0] = VM.aR / VM.sR / VM.l * u\n  K[1, 0] = 1. / VM.sR / VM.l * u\n  return K * sa\n\n\ndef create_dyn_state_matrices(u: float, VM: VehicleModel) -> tuple[np.ndarray, np.ndarray]:\n  \"\"\"Returns the A and B matrix for the dynamics system\n\n  Args:\n    u: Vehicle speed [m/s]\n    VM: Vehicle model\n\n  Returns:\n    A tuple with the 2x2 A matrix, and 2x2 B matrix\n\n  Parameters in the vehicle model:\n    cF: Tire stiffness Front [N/rad]\n    cR: Tire stiffness Front [N/rad]\n    aF: Distance from CG to front wheels [m]\n    aR: Distance from CG to rear wheels [m]\n    m: Mass [kg]\n    j: Rotational inertia [kg m^2]\n    sR: Steering ratio [-]\n    chi: Steer ratio rear [-]\n  \"\"\"\n  A = np.zeros((2, 2))\n  B = np.zeros((2, 2))\n  A[0, 0] = - (VM.cF + VM.cR) / (VM.m * u)\n  A[0, 1] = - (VM.cF * VM.aF - VM.cR * VM.aR) / (VM.m * u) - u\n  A[1, 0] = - (VM.cF * VM.aF - VM.cR * VM.aR) / (VM.j * u)\n  A[1, 1] = - (VM.cF * VM.aF**2 + VM.cR * VM.aR**2) / (VM.j * u)\n\n  # Steering input\n  B[0, 0] = (VM.cF + VM.chi * VM.cR) / VM.m / VM.sR\n  B[1, 0] = (VM.cF * VM.aF - VM.chi * VM.cR * VM.aR) / VM.j / VM.sR\n\n  # Roll input\n  B[0, 1] = -ACCELERATION_DUE_TO_GRAVITY\n\n  return A, B\n\n\ndef dyn_ss_sol(sa: float, u: float, roll: float, VM: VehicleModel) -> np.ndarray:\n  \"\"\"Calculate the steady state solution when x_dot = 0,\n  Ax + Bu = 0 => x = -A^{-1} B u\n\n  Args:\n    sa: Steering angle [rad]\n    u: Speed [m/s]\n    roll: Road Roll [rad]\n    VM: Vehicle model\n\n  Returns:\n    2x1 matrix with steady state solution\n  \"\"\"\n  A, B = create_dyn_state_matrices(u, VM)\n  inp = np.array([[sa], [roll]])\n  return -solve(A, B) @ inp  # type: ignore\n\n\ndef calc_slip_factor(VM: VehicleModel) -> float:\n  \"\"\"The slip factor is a measure of how the curvature changes with speed\n  it's positive for Oversteering vehicle, negative (usual case) otherwise.\n  \"\"\"\n  return VM.m * (VM.cF * VM.aF - VM.cR * VM.aR) / (VM.l**2 * VM.cF * VM.cR)\n", "selfdrive/controls/lib/desire_helper.py": "from cereal import log\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.realtime import DT_MDL\n\nLaneChangeState = log.LaneChangeState\nLaneChangeDirection = log.LaneChangeDirection\n\nLANE_CHANGE_SPEED_MIN = 20 * CV.MPH_TO_MS\nLANE_CHANGE_TIME_MAX = 10.\n\nDESIRES = {\n  LaneChangeDirection.none: {\n    LaneChangeState.off: log.Desire.none,\n    LaneChangeState.preLaneChange: log.Desire.none,\n    LaneChangeState.laneChangeStarting: log.Desire.none,\n    LaneChangeState.laneChangeFinishing: log.Desire.none,\n  },\n  LaneChangeDirection.left: {\n    LaneChangeState.off: log.Desire.none,\n    LaneChangeState.preLaneChange: log.Desire.none,\n    LaneChangeState.laneChangeStarting: log.Desire.laneChangeLeft,\n    LaneChangeState.laneChangeFinishing: log.Desire.laneChangeLeft,\n  },\n  LaneChangeDirection.right: {\n    LaneChangeState.off: log.Desire.none,\n    LaneChangeState.preLaneChange: log.Desire.none,\n    LaneChangeState.laneChangeStarting: log.Desire.laneChangeRight,\n    LaneChangeState.laneChangeFinishing: log.Desire.laneChangeRight,\n  },\n}\n\n\nclass DesireHelper:\n  def __init__(self):\n    self.lane_change_state = LaneChangeState.off\n    self.lane_change_direction = LaneChangeDirection.none\n    self.lane_change_timer = 0.0\n    self.lane_change_ll_prob = 1.0\n    self.keep_pulse_timer = 0.0\n    self.prev_one_blinker = False\n    self.desire = log.Desire.none\n\n  def update(self, carstate, lateral_active, lane_change_prob):\n    v_ego = carstate.vEgo\n    one_blinker = carstate.leftBlinker != carstate.rightBlinker\n    below_lane_change_speed = v_ego < LANE_CHANGE_SPEED_MIN\n\n    if not lateral_active or self.lane_change_timer > LANE_CHANGE_TIME_MAX:\n      self.lane_change_state = LaneChangeState.off\n      self.lane_change_direction = LaneChangeDirection.none\n    else:\n      # LaneChangeState.off\n      if self.lane_change_state == LaneChangeState.off and one_blinker and not self.prev_one_blinker and not below_lane_change_speed:\n        self.lane_change_state = LaneChangeState.preLaneChange\n        self.lane_change_ll_prob = 1.0\n\n      # LaneChangeState.preLaneChange\n      elif self.lane_change_state == LaneChangeState.preLaneChange:\n        # Set lane change direction\n        self.lane_change_direction = LaneChangeDirection.left if \\\n          carstate.leftBlinker else LaneChangeDirection.right\n\n        torque_applied = carstate.steeringPressed and \\\n                         ((carstate.steeringTorque > 0 and self.lane_change_direction == LaneChangeDirection.left) or\n                          (carstate.steeringTorque < 0 and self.lane_change_direction == LaneChangeDirection.right))\n\n        blindspot_detected = ((carstate.leftBlindspot and self.lane_change_direction == LaneChangeDirection.left) or\n                              (carstate.rightBlindspot and self.lane_change_direction == LaneChangeDirection.right))\n\n        if not one_blinker or below_lane_change_speed:\n          self.lane_change_state = LaneChangeState.off\n          self.lane_change_direction = LaneChangeDirection.none\n        elif torque_applied and not blindspot_detected:\n          self.lane_change_state = LaneChangeState.laneChangeStarting\n\n      # LaneChangeState.laneChangeStarting\n      elif self.lane_change_state == LaneChangeState.laneChangeStarting:\n        # fade out over .5s\n        self.lane_change_ll_prob = max(self.lane_change_ll_prob - 2 * DT_MDL, 0.0)\n\n        # 98% certainty\n        if lane_change_prob < 0.02 and self.lane_change_ll_prob < 0.01:\n          self.lane_change_state = LaneChangeState.laneChangeFinishing\n\n      # LaneChangeState.laneChangeFinishing\n      elif self.lane_change_state == LaneChangeState.laneChangeFinishing:\n        # fade in laneline over 1s\n        self.lane_change_ll_prob = min(self.lane_change_ll_prob + DT_MDL, 1.0)\n\n        if self.lane_change_ll_prob > 0.99:\n          self.lane_change_direction = LaneChangeDirection.none\n          if one_blinker:\n            self.lane_change_state = LaneChangeState.preLaneChange\n          else:\n            self.lane_change_state = LaneChangeState.off\n\n    if self.lane_change_state in (LaneChangeState.off, LaneChangeState.preLaneChange):\n      self.lane_change_timer = 0.0\n    else:\n      self.lane_change_timer += DT_MDL\n\n    self.prev_one_blinker = one_blinker\n\n    self.desire = DESIRES[self.lane_change_direction][self.lane_change_state]\n\n    # Send keep pulse once per second during LaneChangeStart.preLaneChange\n    if self.lane_change_state in (LaneChangeState.off, LaneChangeState.laneChangeStarting):\n      self.keep_pulse_timer = 0.0\n    elif self.lane_change_state == LaneChangeState.preLaneChange:\n      self.keep_pulse_timer += DT_MDL\n      if self.keep_pulse_timer > 1.0:\n        self.keep_pulse_timer = 0.0\n      elif self.desire in (log.Desire.keepLeft, log.Desire.keepRight):\n        self.desire = log.Desire.none\n", "selfdrive/controls/lib/pid.py": "import numpy as np\nfrom numbers import Number\n\nfrom openpilot.common.numpy_fast import clip, interp\n\n\nclass PIDController:\n  def __init__(self, k_p, k_i, k_f=0., k_d=0., pos_limit=1e308, neg_limit=-1e308, rate=100):\n    self._k_p = k_p\n    self._k_i = k_i\n    self._k_d = k_d\n    self.k_f = k_f   # feedforward gain\n    if isinstance(self._k_p, Number):\n      self._k_p = [[0], [self._k_p]]\n    if isinstance(self._k_i, Number):\n      self._k_i = [[0], [self._k_i]]\n    if isinstance(self._k_d, Number):\n      self._k_d = [[0], [self._k_d]]\n\n    self.pos_limit = pos_limit\n    self.neg_limit = neg_limit\n\n    self.i_unwind_rate = 0.3 / rate\n    self.i_rate = 1.0 / rate\n    self.speed = 0.0\n\n    self.reset()\n\n  @property\n  def k_p(self):\n    return interp(self.speed, self._k_p[0], self._k_p[1])\n\n  @property\n  def k_i(self):\n    return interp(self.speed, self._k_i[0], self._k_i[1])\n\n  @property\n  def k_d(self):\n    return interp(self.speed, self._k_d[0], self._k_d[1])\n\n  @property\n  def error_integral(self):\n    return self.i/self.k_i\n\n  def reset(self):\n    self.p = 0.0\n    self.i = 0.0\n    self.d = 0.0\n    self.f = 0.0\n    self.control = 0\n\n  def update(self, error, error_rate=0.0, speed=0.0, override=False, feedforward=0., freeze_integrator=False):\n    self.speed = speed\n\n    self.p = float(error) * self.k_p\n    self.f = feedforward * self.k_f\n    self.d = error_rate * self.k_d\n\n    if override:\n      self.i -= self.i_unwind_rate * float(np.sign(self.i))\n    else:\n      i = self.i + error * self.k_i * self.i_rate\n      control = self.p + i + self.d + self.f\n\n      # Update when changing i will move the control away from the limits\n      # or when i will move towards the sign of the error\n      if ((error >= 0 and (control <= self.pos_limit or i < 0.0)) or\n          (error <= 0 and (control >= self.neg_limit or i > 0.0))) and \\\n         not freeze_integrator:\n        self.i = i\n\n    control = self.p + self.i + self.d + self.f\n\n    self.control = clip(control, self.neg_limit, self.pos_limit)\n    return self.control\n", "selfdrive/controls/lib/alertmanager.py": "import copy\nimport os\nimport json\nfrom collections import defaultdict\nfrom dataclasses import dataclass\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.params import Params\nfrom openpilot.selfdrive.controls.lib.events import Alert\n\n\nwith open(os.path.join(BASEDIR, \"selfdrive/controls/lib/alerts_offroad.json\")) as f:\n  OFFROAD_ALERTS = json.load(f)\n\n\ndef set_offroad_alert(alert: str, show_alert: bool, extra_text: str = None) -> None:\n  if show_alert:\n    a = copy.copy(OFFROAD_ALERTS[alert])\n    a['extra'] = extra_text or ''\n    Params().put(alert, json.dumps(a))\n  else:\n    Params().remove(alert)\n\n\n@dataclass\nclass AlertEntry:\n  alert: Alert | None = None\n  start_frame: int = -1\n  end_frame: int = -1\n\n  def active(self, frame: int) -> bool:\n    return frame <= self.end_frame\n\nclass AlertManager:\n  def __init__(self):\n    self.alerts: dict[str, AlertEntry] = defaultdict(AlertEntry)\n\n  def add_many(self, frame: int, alerts: list[Alert]) -> None:\n    for alert in alerts:\n      entry = self.alerts[alert.alert_type]\n      entry.alert = alert\n      if not entry.active(frame):\n        entry.start_frame = frame\n      min_end_frame = entry.start_frame + alert.duration\n      entry.end_frame = max(frame + 1, min_end_frame)\n\n  def process_alerts(self, frame: int, clear_event_types: set) -> Alert | None:\n    current_alert = AlertEntry()\n    for v in self.alerts.values():\n      if not v.alert:\n        continue\n\n      if v.alert.event_type in clear_event_types:\n        v.end_frame = -1\n\n      # sort by priority first and then by start_frame\n      greater = current_alert.alert is None or (v.alert.priority, v.start_frame) > (current_alert.alert.priority, current_alert.start_frame)\n      if v.active(frame) and greater:\n        current_alert = v\n\n    return current_alert.alert\n", "selfdrive/controls/lib/latcontrol.py": "from abc import abstractmethod, ABC\n\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.realtime import DT_CTRL\n\nMIN_LATERAL_CONTROL_SPEED = 0.3  # m/s\n\n\nclass LatControl(ABC):\n  def __init__(self, CP, CI):\n    self.sat_count_rate = 1.0 * DT_CTRL\n    self.sat_limit = CP.steerLimitTimer\n    self.sat_count = 0.\n    self.sat_check_min_speed = 10.\n\n    # we define the steer torque scale as [-1.0...1.0]\n    self.steer_max = 1.0\n\n  @abstractmethod\n  def update(self, active, CS, VM, params, steer_limited, desired_curvature, llk):\n    pass\n\n  def reset(self):\n    self.sat_count = 0.\n\n  def _check_saturation(self, saturated, CS, steer_limited):\n    if saturated and CS.vEgo > self.sat_check_min_speed and not steer_limited and not CS.steeringPressed:\n      self.sat_count += self.sat_count_rate\n    else:\n      self.sat_count -= self.sat_count_rate\n    self.sat_count = clip(self.sat_count, 0.0, self.sat_limit)\n    return self.sat_count > (self.sat_limit - 1e-3)\n", "selfdrive/controls/lib/longcontrol.py": "from cereal import car\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.controls.lib.drive_helpers import CONTROL_N\nfrom openpilot.selfdrive.controls.lib.pid import PIDController\nfrom openpilot.selfdrive.modeld.constants import ModelConstants\n\nCONTROL_N_T_IDX = ModelConstants.T_IDXS[:CONTROL_N]\n\nLongCtrlState = car.CarControl.Actuators.LongControlState\n\n\ndef long_control_state_trans(CP, active, long_control_state, v_ego,\n                             should_stop, brake_pressed, cruise_standstill):\n  stopping_condition = should_stop\n  starting_condition = (not should_stop and\n                        not cruise_standstill and\n                        not brake_pressed)\n  started_condition = v_ego > CP.vEgoStarting\n\n  if not active:\n    long_control_state = LongCtrlState.off\n\n  else:\n    if long_control_state in (LongCtrlState.off, LongCtrlState.pid):\n      long_control_state = LongCtrlState.pid\n      if stopping_condition:\n        long_control_state = LongCtrlState.stopping\n    elif long_control_state == LongCtrlState.stopping:\n      if starting_condition and CP.startingState:\n        long_control_state = LongCtrlState.starting\n      elif starting_condition:\n        long_control_state = LongCtrlState.pid\n\n    elif long_control_state == LongCtrlState.starting:\n      if stopping_condition:\n        long_control_state = LongCtrlState.stopping\n      elif started_condition:\n        long_control_state = LongCtrlState.pid\n\n  return long_control_state\n\nclass LongControl:\n  def __init__(self, CP):\n    self.CP = CP\n    self.long_control_state = LongCtrlState.off\n    self.pid = PIDController((CP.longitudinalTuning.kpBP, CP.longitudinalTuning.kpV),\n                             (CP.longitudinalTuning.kiBP, CP.longitudinalTuning.kiV),\n                             k_f=CP.longitudinalTuning.kf, rate=1 / DT_CTRL)\n    self.last_output_accel = 0.0\n\n  def reset(self):\n    self.pid.reset()\n\n  def update(self, active, CS, a_target, should_stop, accel_limits):\n    \"\"\"Update longitudinal control. This updates the state machine and runs a PID loop\"\"\"\n    self.pid.neg_limit = accel_limits[0]\n    self.pid.pos_limit = accel_limits[1]\n\n    self.long_control_state = long_control_state_trans(self.CP, active, self.long_control_state, CS.vEgo,\n                                                       should_stop, CS.brakePressed,\n                                                       CS.cruiseState.standstill)\n    if self.long_control_state == LongCtrlState.off:\n      self.reset()\n      output_accel = 0.\n\n    elif self.long_control_state == LongCtrlState.stopping:\n      output_accel = self.last_output_accel\n      if output_accel > self.CP.stopAccel:\n        output_accel = min(output_accel, 0.0)\n        output_accel -= self.CP.stoppingDecelRate * DT_CTRL\n      self.reset()\n\n    elif self.long_control_state == LongCtrlState.starting:\n      output_accel = self.CP.startAccel\n      self.reset()\n\n    else:  # LongCtrlState.pid\n      error = a_target - CS.aEgo\n      output_accel = self.pid.update(error, speed=CS.vEgo,\n                                     feedforward=a_target)\n\n    self.last_output_accel = clip(output_accel, accel_limits[0], accel_limits[1])\n    return self.last_output_accel\n", "selfdrive/controls/lib/__init__.py": "", "selfdrive/controls/lib/longitudinal_mpc_lib/long_mpc.py": "#!/usr/bin/env python3\nimport os\nimport time\nimport numpy as np\nfrom cereal import log\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.realtime import DT_MDL\nfrom openpilot.common.swaglog import cloudlog\n# WARNING: imports outside of constants will not trigger a rebuild\nfrom openpilot.selfdrive.modeld.constants import index_function\nfrom openpilot.selfdrive.car.interfaces import ACCEL_MIN\nfrom openpilot.selfdrive.controls.radard import _LEAD_ACCEL_TAU\n\nif __name__ == '__main__':  # generating code\n  from openpilot.third_party.acados.acados_template import AcadosModel, AcadosOcp, AcadosOcpSolver\nelse:\n  from openpilot.selfdrive.controls.lib.longitudinal_mpc_lib.c_generated_code.acados_ocp_solver_pyx import AcadosOcpSolverCython\n\nfrom casadi import SX, vertcat\n\nMODEL_NAME = 'long'\nLONG_MPC_DIR = os.path.dirname(os.path.abspath(__file__))\nEXPORT_DIR = os.path.join(LONG_MPC_DIR, \"c_generated_code\")\nJSON_FILE = os.path.join(LONG_MPC_DIR, \"acados_ocp_long.json\")\n\nSOURCES = ['lead0', 'lead1', 'cruise', 'e2e']\n\nX_DIM = 3\nU_DIM = 1\nPARAM_DIM = 6\nCOST_E_DIM = 5\nCOST_DIM = COST_E_DIM + 1\nCONSTR_DIM = 4\n\nX_EGO_OBSTACLE_COST = 3.\nX_EGO_COST = 0.\nV_EGO_COST = 0.\nA_EGO_COST = 0.\nJ_EGO_COST = 5.0\nA_CHANGE_COST = 200.\nDANGER_ZONE_COST = 100.\nCRASH_DISTANCE = .25\nLEAD_DANGER_FACTOR = 0.75\nLIMIT_COST = 1e6\nACADOS_SOLVER_TYPE = 'SQP_RTI'\n\n\n# Fewer timestamps don't hurt performance and lead to\n# much better convergence of the MPC with low iterations\nN = 12\nMAX_T = 10.0\nT_IDXS_LST = [index_function(idx, max_val=MAX_T, max_idx=N) for idx in range(N+1)]\n\nT_IDXS = np.array(T_IDXS_LST)\nFCW_IDXS = T_IDXS < 5.0\nT_DIFFS = np.diff(T_IDXS, prepend=[0.])\nCOMFORT_BRAKE = 2.5\nSTOP_DISTANCE = 6.0\n\ndef get_jerk_factor(personality=log.LongitudinalPersonality.standard):\n  if personality==log.LongitudinalPersonality.relaxed:\n    return 1.0\n  elif personality==log.LongitudinalPersonality.standard:\n    return 1.0\n  elif personality==log.LongitudinalPersonality.aggressive:\n    return 0.5\n  else:\n    raise NotImplementedError(\"Longitudinal personality not supported\")\n\n\ndef get_T_FOLLOW(personality=log.LongitudinalPersonality.standard):\n  if personality==log.LongitudinalPersonality.relaxed:\n    return 1.75\n  elif personality==log.LongitudinalPersonality.standard:\n    return 1.45\n  elif personality==log.LongitudinalPersonality.aggressive:\n    return 1.25\n  else:\n    raise NotImplementedError(\"Longitudinal personality not supported\")\n\ndef get_stopped_equivalence_factor(v_lead):\n  return (v_lead**2) / (2 * COMFORT_BRAKE)\n\ndef get_safe_obstacle_distance(v_ego, t_follow):\n  return (v_ego**2) / (2 * COMFORT_BRAKE) + t_follow * v_ego + STOP_DISTANCE\n\ndef desired_follow_distance(v_ego, v_lead, t_follow=None):\n  if t_follow is None:\n    t_follow = get_T_FOLLOW()\n  return get_safe_obstacle_distance(v_ego, t_follow) - get_stopped_equivalence_factor(v_lead)\n\n\ndef gen_long_model():\n  model = AcadosModel()\n  model.name = MODEL_NAME\n\n  # set up states & controls\n  x_ego = SX.sym('x_ego')\n  v_ego = SX.sym('v_ego')\n  a_ego = SX.sym('a_ego')\n  model.x = vertcat(x_ego, v_ego, a_ego)\n\n  # controls\n  j_ego = SX.sym('j_ego')\n  model.u = vertcat(j_ego)\n\n  # xdot\n  x_ego_dot = SX.sym('x_ego_dot')\n  v_ego_dot = SX.sym('v_ego_dot')\n  a_ego_dot = SX.sym('a_ego_dot')\n  model.xdot = vertcat(x_ego_dot, v_ego_dot, a_ego_dot)\n\n  # live parameters\n  a_min = SX.sym('a_min')\n  a_max = SX.sym('a_max')\n  x_obstacle = SX.sym('x_obstacle')\n  prev_a = SX.sym('prev_a')\n  lead_t_follow = SX.sym('lead_t_follow')\n  lead_danger_factor = SX.sym('lead_danger_factor')\n  model.p = vertcat(a_min, a_max, x_obstacle, prev_a, lead_t_follow, lead_danger_factor)\n\n  # dynamics model\n  f_expl = vertcat(v_ego, a_ego, j_ego)\n  model.f_impl_expr = model.xdot - f_expl\n  model.f_expl_expr = f_expl\n  return model\n\n\ndef gen_long_ocp():\n  ocp = AcadosOcp()\n  ocp.model = gen_long_model()\n\n  Tf = T_IDXS[-1]\n\n  # set dimensions\n  ocp.dims.N = N\n\n  # set cost module\n  ocp.cost.cost_type = 'NONLINEAR_LS'\n  ocp.cost.cost_type_e = 'NONLINEAR_LS'\n\n  QR = np.zeros((COST_DIM, COST_DIM))\n  Q = np.zeros((COST_E_DIM, COST_E_DIM))\n\n  ocp.cost.W = QR\n  ocp.cost.W_e = Q\n\n  x_ego, v_ego, a_ego = ocp.model.x[0], ocp.model.x[1], ocp.model.x[2]\n  j_ego = ocp.model.u[0]\n\n  a_min, a_max = ocp.model.p[0], ocp.model.p[1]\n  x_obstacle = ocp.model.p[2]\n  prev_a = ocp.model.p[3]\n  lead_t_follow = ocp.model.p[4]\n  lead_danger_factor = ocp.model.p[5]\n\n  ocp.cost.yref = np.zeros((COST_DIM, ))\n  ocp.cost.yref_e = np.zeros((COST_E_DIM, ))\n\n  desired_dist_comfort = get_safe_obstacle_distance(v_ego, lead_t_follow)\n\n  # The main cost in normal operation is how close you are to the \"desired\" distance\n  # from an obstacle at every timestep. This obstacle can be a lead car\n  # or other object. In e2e mode we can use x_position targets as a cost\n  # instead.\n  costs = [((x_obstacle - x_ego) - (desired_dist_comfort)) / (v_ego + 10.),\n           x_ego,\n           v_ego,\n           a_ego,\n           a_ego - prev_a,\n           j_ego]\n  ocp.model.cost_y_expr = vertcat(*costs)\n  ocp.model.cost_y_expr_e = vertcat(*costs[:-1])\n\n  # Constraints on speed, acceleration and desired distance to\n  # the obstacle, which is treated as a slack constraint so it\n  # behaves like an asymmetrical cost.\n  constraints = vertcat(v_ego,\n                        (a_ego - a_min),\n                        (a_max - a_ego),\n                        ((x_obstacle - x_ego) - lead_danger_factor * (desired_dist_comfort)) / (v_ego + 10.))\n  ocp.model.con_h_expr = constraints\n\n  x0 = np.zeros(X_DIM)\n  ocp.constraints.x0 = x0\n  ocp.parameter_values = np.array([-1.2, 1.2, 0.0, 0.0, get_T_FOLLOW(), LEAD_DANGER_FACTOR])\n\n\n  # We put all constraint cost weights to 0 and only set them at runtime\n  cost_weights = np.zeros(CONSTR_DIM)\n  ocp.cost.zl = cost_weights\n  ocp.cost.Zl = cost_weights\n  ocp.cost.Zu = cost_weights\n  ocp.cost.zu = cost_weights\n\n  ocp.constraints.lh = np.zeros(CONSTR_DIM)\n  ocp.constraints.uh = 1e4*np.ones(CONSTR_DIM)\n  ocp.constraints.idxsh = np.arange(CONSTR_DIM)\n\n  # The HPIPM solver can give decent solutions even when it is stopped early\n  # Which is critical for our purpose where compute time is strictly bounded\n  # We use HPIPM in the SPEED_ABS mode, which ensures fastest runtime. This\n  # does not cause issues since the problem is well bounded.\n  ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'\n  ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'\n  ocp.solver_options.integrator_type = 'ERK'\n  ocp.solver_options.nlp_solver_type = ACADOS_SOLVER_TYPE\n  ocp.solver_options.qp_solver_cond_N = 1\n\n  # More iterations take too much time and less lead to inaccurate convergence in\n  # some situations. Ideally we would run just 1 iteration to ensure fixed runtime.\n  ocp.solver_options.qp_solver_iter_max = 10\n  ocp.solver_options.qp_tol = 1e-3\n\n  # set prediction horizon\n  ocp.solver_options.tf = Tf\n  ocp.solver_options.shooting_nodes = T_IDXS\n\n  ocp.code_export_directory = EXPORT_DIR\n  return ocp\n\n\nclass LongitudinalMpc:\n  def __init__(self, mode='acc', dt=DT_MDL):\n    self.mode = mode\n    self.dt = dt\n    self.solver = AcadosOcpSolverCython(MODEL_NAME, ACADOS_SOLVER_TYPE, N)\n    self.reset()\n    self.source = SOURCES[2]\n\n  def reset(self):\n    # self.solver = AcadosOcpSolverCython(MODEL_NAME, ACADOS_SOLVER_TYPE, N)\n    self.solver.reset()\n    # self.solver.options_set('print_level', 2)\n    self.v_solution = np.zeros(N+1)\n    self.a_solution = np.zeros(N+1)\n    self.prev_a = np.array(self.a_solution)\n    self.j_solution = np.zeros(N)\n    self.yref = np.zeros((N+1, COST_DIM))\n    for i in range(N):\n      self.solver.cost_set(i, \"yref\", self.yref[i])\n    self.solver.cost_set(N, \"yref\", self.yref[N][:COST_E_DIM])\n    self.x_sol = np.zeros((N+1, X_DIM))\n    self.u_sol = np.zeros((N,1))\n    self.params = np.zeros((N+1, PARAM_DIM))\n    for i in range(N+1):\n      self.solver.set(i, 'x', np.zeros(X_DIM))\n    self.last_cloudlog_t = 0\n    self.status = False\n    self.crash_cnt = 0.0\n    self.solution_status = 0\n    # timers\n    self.solve_time = 0.0\n    self.time_qp_solution = 0.0\n    self.time_linearization = 0.0\n    self.time_integrator = 0.0\n    self.x0 = np.zeros(X_DIM)\n    self.set_weights()\n\n  def set_cost_weights(self, cost_weights, constraint_cost_weights):\n    W = np.asfortranarray(np.diag(cost_weights))\n    for i in range(N):\n      # TODO don't hardcode A_CHANGE_COST idx\n      # reduce the cost on (a-a_prev) later in the horizon.\n      W[4,4] = cost_weights[4] * np.interp(T_IDXS[i], [0.0, 1.0, 2.0], [1.0, 1.0, 0.0])\n      self.solver.cost_set(i, 'W', W)\n    # Setting the slice without the copy make the array not contiguous,\n    # causing issues with the C interface.\n    self.solver.cost_set(N, 'W', np.copy(W[:COST_E_DIM, :COST_E_DIM]))\n\n    # Set L2 slack cost on lower bound constraints\n    Zl = np.array(constraint_cost_weights)\n    for i in range(N):\n      self.solver.cost_set(i, 'Zl', Zl)\n\n  def set_weights(self, prev_accel_constraint=True, personality=log.LongitudinalPersonality.standard):\n    jerk_factor = get_jerk_factor(personality)\n    if self.mode == 'acc':\n      a_change_cost = A_CHANGE_COST if prev_accel_constraint else 0\n      cost_weights = [X_EGO_OBSTACLE_COST, X_EGO_COST, V_EGO_COST, A_EGO_COST, jerk_factor * a_change_cost, jerk_factor * J_EGO_COST]\n      constraint_cost_weights = [LIMIT_COST, LIMIT_COST, LIMIT_COST, DANGER_ZONE_COST]\n    elif self.mode == 'blended':\n      a_change_cost = 40.0 if prev_accel_constraint else 0\n      cost_weights = [0., 0.1, 0.2, 5.0, a_change_cost, 1.0]\n      constraint_cost_weights = [LIMIT_COST, LIMIT_COST, LIMIT_COST, 50.0]\n    else:\n      raise NotImplementedError(f'Planner mode {self.mode} not recognized in planner cost set')\n    self.set_cost_weights(cost_weights, constraint_cost_weights)\n\n  def set_cur_state(self, v, a):\n    v_prev = self.x0[1]\n    self.x0[1] = v\n    self.x0[2] = a\n    if abs(v_prev - v) > 2.:  # probably only helps if v < v_prev\n      for i in range(N+1):\n        self.solver.set(i, 'x', self.x0)\n\n  @staticmethod\n  def extrapolate_lead(x_lead, v_lead, a_lead, a_lead_tau):\n    a_lead_traj = a_lead * np.exp(-a_lead_tau * (T_IDXS**2)/2.)\n    v_lead_traj = np.clip(v_lead + np.cumsum(T_DIFFS * a_lead_traj), 0.0, 1e8)\n    x_lead_traj = x_lead + np.cumsum(T_DIFFS * v_lead_traj)\n    lead_xv = np.column_stack((x_lead_traj, v_lead_traj))\n    return lead_xv\n\n  def process_lead(self, lead):\n    v_ego = self.x0[1]\n    if lead is not None and lead.status:\n      x_lead = lead.dRel\n      v_lead = lead.vLead\n      a_lead = lead.aLeadK\n      a_lead_tau = lead.aLeadTau\n    else:\n      # Fake a fast lead car, so mpc can keep running in the same mode\n      x_lead = 50.0\n      v_lead = v_ego + 10.0\n      a_lead = 0.0\n      a_lead_tau = _LEAD_ACCEL_TAU\n\n    # MPC will not converge if immediate crash is expected\n    # Clip lead distance to what is still possible to brake for\n    min_x_lead = ((v_ego + v_lead)/2) * (v_ego - v_lead) / (-ACCEL_MIN * 2)\n    x_lead = clip(x_lead, min_x_lead, 1e8)\n    v_lead = clip(v_lead, 0.0, 1e8)\n    a_lead = clip(a_lead, -10., 5.)\n    lead_xv = self.extrapolate_lead(x_lead, v_lead, a_lead, a_lead_tau)\n    return lead_xv\n\n  def set_accel_limits(self, min_a, max_a):\n    # TODO this sets a max accel limit, but the minimum limit is only for cruise decel\n    # needs refactor\n    self.cruise_min_a = min_a\n    self.max_a = max_a\n\n  def update(self, radarstate, v_cruise, x, v, a, j, personality=log.LongitudinalPersonality.standard):\n    t_follow = get_T_FOLLOW(personality)\n    v_ego = self.x0[1]\n    self.status = radarstate.leadOne.status or radarstate.leadTwo.status\n\n    lead_xv_0 = self.process_lead(radarstate.leadOne)\n    lead_xv_1 = self.process_lead(radarstate.leadTwo)\n\n    # To estimate a safe distance from a moving lead, we calculate how much stopping\n    # distance that lead needs as a minimum. We can add that to the current distance\n    # and then treat that as a stopped car/obstacle at this new distance.\n    lead_0_obstacle = lead_xv_0[:,0] + get_stopped_equivalence_factor(lead_xv_0[:,1])\n    lead_1_obstacle = lead_xv_1[:,0] + get_stopped_equivalence_factor(lead_xv_1[:,1])\n\n    self.params[:,0] = ACCEL_MIN\n    self.params[:,1] = self.max_a\n\n    # Update in ACC mode or ACC/e2e blend\n    if self.mode == 'acc':\n      self.params[:,5] = LEAD_DANGER_FACTOR\n\n      # Fake an obstacle for cruise, this ensures smooth acceleration to set speed\n      # when the leads are no factor.\n      v_lower = v_ego + (T_IDXS * self.cruise_min_a * 1.05)\n      v_upper = v_ego + (T_IDXS * self.max_a * 1.05)\n      v_cruise_clipped = np.clip(v_cruise * np.ones(N+1),\n                                 v_lower,\n                                 v_upper)\n      cruise_obstacle = np.cumsum(T_DIFFS * v_cruise_clipped) + get_safe_obstacle_distance(v_cruise_clipped, t_follow)\n      x_obstacles = np.column_stack([lead_0_obstacle, lead_1_obstacle, cruise_obstacle])\n      self.source = SOURCES[np.argmin(x_obstacles[0])]\n\n      # These are not used in ACC mode\n      x[:], v[:], a[:], j[:] = 0.0, 0.0, 0.0, 0.0\n\n    elif self.mode == 'blended':\n      self.params[:,5] = 1.0\n\n      x_obstacles = np.column_stack([lead_0_obstacle,\n                                     lead_1_obstacle])\n      cruise_target = T_IDXS * np.clip(v_cruise, v_ego - 2.0, 1e3) + x[0]\n      xforward = ((v[1:] + v[:-1]) / 2) * (T_IDXS[1:] - T_IDXS[:-1])\n      x = np.cumsum(np.insert(xforward, 0, x[0]))\n\n      x_and_cruise = np.column_stack([x, cruise_target])\n      x = np.min(x_and_cruise, axis=1)\n\n      self.source = 'e2e' if x_and_cruise[1,0] < x_and_cruise[1,1] else 'cruise'\n\n    else:\n      raise NotImplementedError(f'Planner mode {self.mode} not recognized in planner update')\n\n    self.yref[:,1] = x\n    self.yref[:,2] = v\n    self.yref[:,3] = a\n    self.yref[:,5] = j\n    for i in range(N):\n      self.solver.set(i, \"yref\", self.yref[i])\n    self.solver.set(N, \"yref\", self.yref[N][:COST_E_DIM])\n\n    self.params[:,2] = np.min(x_obstacles, axis=1)\n    self.params[:,3] = np.copy(self.prev_a)\n    self.params[:,4] = t_follow\n\n    self.run()\n    if (np.any(lead_xv_0[FCW_IDXS,0] - self.x_sol[FCW_IDXS,0] < CRASH_DISTANCE) and\n            radarstate.leadOne.modelProb > 0.9):\n      self.crash_cnt += 1\n    else:\n      self.crash_cnt = 0\n\n    # Check if it got within lead comfort range\n    # TODO This should be done cleaner\n    if self.mode == 'blended':\n      if any((lead_0_obstacle - get_safe_obstacle_distance(self.x_sol[:,1], t_follow))- self.x_sol[:,0] < 0.0):\n        self.source = 'lead0'\n      if any((lead_1_obstacle - get_safe_obstacle_distance(self.x_sol[:,1], t_follow))- self.x_sol[:,0] < 0.0) and \\\n         (lead_1_obstacle[0] - lead_0_obstacle[0]):\n        self.source = 'lead1'\n\n  def run(self):\n    # t0 = time.monotonic()\n    # reset = 0\n    for i in range(N+1):\n      self.solver.set(i, 'p', self.params[i])\n    self.solver.constraints_set(0, \"lbx\", self.x0)\n    self.solver.constraints_set(0, \"ubx\", self.x0)\n\n    self.solution_status = self.solver.solve()\n    self.solve_time = float(self.solver.get_stats('time_tot')[0])\n    self.time_qp_solution = float(self.solver.get_stats('time_qp')[0])\n    self.time_linearization = float(self.solver.get_stats('time_lin')[0])\n    self.time_integrator = float(self.solver.get_stats('time_sim')[0])\n\n    # qp_iter = self.solver.get_stats('statistics')[-1][-1] # SQP_RTI specific\n    # print(f\"long_mpc timings: tot {self.solve_time:.2e}, qp {self.time_qp_solution:.2e}, lin {self.time_linearization:.2e}, \\\n    # integrator {self.time_integrator:.2e}, qp_iter {qp_iter}\")\n    # res = self.solver.get_residuals()\n    # print(f\"long_mpc residuals: {res[0]:.2e}, {res[1]:.2e}, {res[2]:.2e}, {res[3]:.2e}\")\n    # self.solver.print_statistics()\n\n    for i in range(N+1):\n      self.x_sol[i] = self.solver.get(i, 'x')\n    for i in range(N):\n      self.u_sol[i] = self.solver.get(i, 'u')\n\n    self.v_solution = self.x_sol[:,1]\n    self.a_solution = self.x_sol[:,2]\n    self.j_solution = self.u_sol[:,0]\n\n    self.prev_a = np.interp(T_IDXS + self.dt, T_IDXS, self.a_solution)\n\n    t = time.monotonic()\n    if self.solution_status != 0:\n      if t > self.last_cloudlog_t + 5.0:\n        self.last_cloudlog_t = t\n        cloudlog.warning(f\"Long mpc reset, solution_status: {self.solution_status}\")\n      self.reset()\n      # reset = 1\n    # print(f\"long_mpc timings: total internal {self.solve_time:.2e}, external: {(time.monotonic() - t0):.2e} qp {self.time_qp_solution:.2e}, \\\n    # lin {self.time_linearization:.2e} qp_iter {qp_iter}, reset {reset}\")\n\n\nif __name__ == \"__main__\":\n  ocp = gen_long_ocp()\n  AcadosOcpSolver.generate(ocp, json_file=JSON_FILE)\n  # AcadosOcpSolver.build(ocp.code_export_directory, with_cython=True)\n", "selfdrive/controls/lib/longitudinal_mpc_lib/__init__.py": "", "selfdrive/controls/lib/lateral_mpc_lib/lat_mpc.py": "#!/usr/bin/env python3\nimport os\nimport time\nimport numpy as np\n\nfrom casadi import SX, vertcat, sin, cos\n# WARNING: imports outside of constants will not trigger a rebuild\nfrom openpilot.selfdrive.modeld.constants import ModelConstants\n\nif __name__ == '__main__':  # generating code\n  from openpilot.third_party.acados.acados_template import AcadosModel, AcadosOcp, AcadosOcpSolver\nelse:\n  from openpilot.selfdrive.controls.lib.lateral_mpc_lib.c_generated_code.acados_ocp_solver_pyx import AcadosOcpSolverCython\n\nLAT_MPC_DIR = os.path.dirname(os.path.abspath(__file__))\nEXPORT_DIR = os.path.join(LAT_MPC_DIR, \"c_generated_code\")\nJSON_FILE = os.path.join(LAT_MPC_DIR, \"acados_ocp_lat.json\")\nX_DIM = 4\nP_DIM = 2\nCOST_E_DIM = 3\nCOST_DIM = COST_E_DIM + 2\nSPEED_OFFSET = 10.0\nMODEL_NAME = 'lat'\nACADOS_SOLVER_TYPE = 'SQP_RTI'\nN = 32\n\ndef gen_lat_model():\n  model = AcadosModel()\n  model.name = MODEL_NAME\n\n  # set up states & controls\n  x_ego = SX.sym('x_ego')\n  y_ego = SX.sym('y_ego')\n  psi_ego = SX.sym('psi_ego')\n  psi_rate_ego = SX.sym('psi_rate_ego')\n  model.x = vertcat(x_ego, y_ego, psi_ego, psi_rate_ego)\n\n  # parameters\n  v_ego = SX.sym('v_ego')\n  rotation_radius = SX.sym('rotation_radius')\n  model.p = vertcat(v_ego, rotation_radius)\n\n  # controls\n  psi_accel_ego = SX.sym('psi_accel_ego')\n  model.u = vertcat(psi_accel_ego)\n\n  # xdot\n  x_ego_dot = SX.sym('x_ego_dot')\n  y_ego_dot = SX.sym('y_ego_dot')\n  psi_ego_dot = SX.sym('psi_ego_dot')\n  psi_rate_ego_dot = SX.sym('psi_rate_ego_dot')\n\n  model.xdot = vertcat(x_ego_dot, y_ego_dot, psi_ego_dot, psi_rate_ego_dot)\n\n  # dynamics model\n  f_expl = vertcat(v_ego * cos(psi_ego) - rotation_radius * sin(psi_ego) * psi_rate_ego,\n                   v_ego * sin(psi_ego) + rotation_radius * cos(psi_ego) * psi_rate_ego,\n                   psi_rate_ego,\n                   psi_accel_ego)\n  model.f_impl_expr = model.xdot - f_expl\n  model.f_expl_expr = f_expl\n  return model\n\n\ndef gen_lat_ocp():\n  ocp = AcadosOcp()\n  ocp.model = gen_lat_model()\n\n  Tf = np.array(ModelConstants.T_IDXS)[N]\n\n  # set dimensions\n  ocp.dims.N = N\n\n  # set cost module\n  ocp.cost.cost_type = 'NONLINEAR_LS'\n  ocp.cost.cost_type_e = 'NONLINEAR_LS'\n\n  Q = np.diag(np.zeros(COST_E_DIM))\n  QR = np.diag(np.zeros(COST_DIM))\n\n  ocp.cost.W = QR\n  ocp.cost.W_e = Q\n\n  y_ego, psi_ego, psi_rate_ego = ocp.model.x[1], ocp.model.x[2], ocp.model.x[3]\n  psi_rate_ego_dot = ocp.model.u[0]\n  v_ego = ocp.model.p[0]\n\n  ocp.parameter_values = np.zeros((P_DIM, ))\n\n  ocp.cost.yref = np.zeros((COST_DIM, ))\n  ocp.cost.yref_e = np.zeros((COST_E_DIM, ))\n  # Add offset to smooth out low speed control\n  # TODO unclear if this right solution long term\n  v_ego_offset = v_ego + SPEED_OFFSET\n  # TODO there are two costs on psi_rate_ego_dot, one\n  # is correlated to jerk the other to steering wheel movement\n  # the steering wheel movement cost is added to prevent excessive\n  # wheel movements\n  ocp.model.cost_y_expr = vertcat(y_ego,\n                                  v_ego_offset * psi_ego,\n                                  v_ego_offset * psi_rate_ego,\n                                  v_ego_offset * psi_rate_ego_dot,\n                                  psi_rate_ego_dot / (v_ego + 0.1))\n  ocp.model.cost_y_expr_e = vertcat(y_ego,\n                                   v_ego_offset * psi_ego,\n                                   v_ego_offset * psi_rate_ego)\n\n  # set constraints\n  ocp.constraints.constr_type = 'BGH'\n  ocp.constraints.idxbx = np.array([2,3])\n  ocp.constraints.ubx = np.array([np.radians(90), np.radians(50)])\n  ocp.constraints.lbx = np.array([-np.radians(90), -np.radians(50)])\n  x0 = np.zeros((X_DIM,))\n  ocp.constraints.x0 = x0\n\n  ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'\n  ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'\n  ocp.solver_options.integrator_type = 'ERK'\n  ocp.solver_options.nlp_solver_type = ACADOS_SOLVER_TYPE\n  ocp.solver_options.qp_solver_iter_max = 1\n  ocp.solver_options.qp_solver_cond_N = 1\n\n  # set prediction horizon\n  ocp.solver_options.tf = Tf\n  ocp.solver_options.shooting_nodes = np.array(ModelConstants.T_IDXS)[:N+1]\n\n  ocp.code_export_directory = EXPORT_DIR\n  return ocp\n\n\nclass LateralMpc:\n  def __init__(self, x0=None):\n    if x0 is None:\n      x0 = np.zeros(X_DIM)\n    self.solver = AcadosOcpSolverCython(MODEL_NAME, ACADOS_SOLVER_TYPE, N)\n    self.reset(x0)\n\n  def reset(self, x0=None):\n    if x0 is None:\n      x0 = np.zeros(X_DIM)\n    self.x_sol = np.zeros((N+1, X_DIM))\n    self.u_sol = np.zeros((N, 1))\n    self.yref = np.zeros((N+1, COST_DIM))\n    for i in range(N):\n      self.solver.cost_set(i, \"yref\", self.yref[i])\n    self.solver.cost_set(N, \"yref\", self.yref[N][:COST_E_DIM])\n\n    # Somehow needed for stable init\n    for i in range(N+1):\n      self.solver.set(i, 'x', np.zeros(X_DIM))\n      self.solver.set(i, 'p', np.zeros(P_DIM))\n    self.solver.constraints_set(0, \"lbx\", x0)\n    self.solver.constraints_set(0, \"ubx\", x0)\n    self.solver.solve()\n    self.solution_status = 0\n    self.solve_time = 0.0\n    self.cost = 0\n\n  def set_weights(self, path_weight, heading_weight,\n                  lat_accel_weight, lat_jerk_weight,\n                  steering_rate_weight):\n    W = np.asfortranarray(np.diag([path_weight, heading_weight,\n                                   lat_accel_weight, lat_jerk_weight,\n                                   steering_rate_weight]))\n    for i in range(N):\n      self.solver.cost_set(i, 'W', W)\n    self.solver.cost_set(N, 'W', W[:COST_E_DIM,:COST_E_DIM])\n\n  def run(self, x0, p, y_pts, heading_pts, yaw_rate_pts):\n    x0_cp = np.copy(x0)\n    p_cp = np.copy(p)\n    self.solver.constraints_set(0, \"lbx\", x0_cp)\n    self.solver.constraints_set(0, \"ubx\", x0_cp)\n    self.yref[:,0] = y_pts\n    v_ego = p_cp[0, 0]\n    # rotation_radius = p_cp[1]\n    self.yref[:,1] = heading_pts * (v_ego + SPEED_OFFSET)\n    self.yref[:,2] = yaw_rate_pts * (v_ego + SPEED_OFFSET)\n    for i in range(N):\n      self.solver.cost_set(i, \"yref\", self.yref[i])\n      self.solver.set(i, \"p\", p_cp[i])\n    self.solver.set(N, \"p\", p_cp[N])\n    self.solver.cost_set(N, \"yref\", self.yref[N][:COST_E_DIM])\n\n    t = time.monotonic()\n    self.solution_status = self.solver.solve()\n    self.solve_time = time.monotonic() - t\n\n    for i in range(N+1):\n      self.x_sol[i] = self.solver.get(i, 'x')\n    for i in range(N):\n      self.u_sol[i] = self.solver.get(i, 'u')\n    self.cost = self.solver.get_cost()\n\n\nif __name__ == \"__main__\":\n  ocp = gen_lat_ocp()\n  AcadosOcpSolver.generate(ocp, json_file=JSON_FILE)\n  # AcadosOcpSolver.build(ocp.code_export_directory, with_cython=True)\n", "selfdrive/controls/lib/lateral_mpc_lib/__init__.py": "", "selfdrive/ui/update_translations.py": "#!/usr/bin/env python3\nimport argparse\nimport json\nimport os\n\nfrom openpilot.common.basedir import BASEDIR\n\nUI_DIR = os.path.join(BASEDIR, \"selfdrive\", \"ui\")\nTRANSLATIONS_DIR = os.path.join(UI_DIR, \"translations\")\nLANGUAGES_FILE = os.path.join(TRANSLATIONS_DIR, \"languages.json\")\nTRANSLATIONS_INCLUDE_FILE = os.path.join(TRANSLATIONS_DIR, \"alerts_generated.h\")\nPLURAL_ONLY = [\"main_en\"]  # base language, only create entries for strings with plural forms\n\n\ndef generate_translations_include():\n  # offroad alerts\n  # TODO translate events from openpilot.selfdrive/controls/lib/events.py\n  content = \"// THIS IS AN AUTOGENERATED FILE, PLEASE EDIT alerts_offroad.json\\n\"\n  with open(os.path.join(BASEDIR, \"selfdrive/controls/lib/alerts_offroad.json\")) as f:\n    for alert in json.load(f).values():\n      content += f'QT_TRANSLATE_NOOP(\"OffroadAlert\", R\"({alert[\"text\"]})\");\\n'\n\n  with open(TRANSLATIONS_INCLUDE_FILE, \"w\") as f:\n    f.write(content)\n\n\ndef update_translations(vanish: bool = False, translation_files: None | list[str] = None, translations_dir: str = TRANSLATIONS_DIR):\n  generate_translations_include()\n\n  if translation_files is None:\n    with open(LANGUAGES_FILE) as f:\n      translation_files = json.load(f).values()\n\n  for file in translation_files:\n    tr_file = os.path.join(translations_dir, f\"{file}.ts\")\n    args = f\"lupdate -locations none -recursive {UI_DIR} -ts {tr_file} -I {BASEDIR}\"\n    if vanish:\n      args += \" -no-obsolete\"\n    if file in PLURAL_ONLY:\n      args += \" -pluralonly\"\n    ret = os.system(args)\n    assert ret == 0\n\n\nif __name__ == \"__main__\":\n  parser = argparse.ArgumentParser(description=\"Update translation files for UI\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n  parser.add_argument(\"--vanish\", action=\"store_true\", help=\"Remove translations with source text no longer found\")\n  args = parser.parse_args()\n\n  update_translations(args.vanish)\n", "selfdrive/ui/soundd.py": "import math\nimport numpy as np\nimport time\nimport wave\n\n\nfrom cereal import car, messaging\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.realtime import Ratekeeper\nfrom openpilot.common.retry import retry\nfrom openpilot.common.swaglog import cloudlog\n\nfrom openpilot.system import micd\n\nSAMPLE_RATE = 48000\nSAMPLE_BUFFER = 4096 # (approx 100ms)\nMAX_VOLUME = 1.0\nMIN_VOLUME = 0.1\nCONTROLS_TIMEOUT = 5 # 5 seconds\nFILTER_DT = 1. / (micd.SAMPLE_RATE / micd.FFT_SAMPLES)\n\nAMBIENT_DB = 30 # DB where MIN_VOLUME is applied\nDB_SCALE = 30 # AMBIENT_DB + DB_SCALE is where MAX_VOLUME is applied\n\nAudibleAlert = car.CarControl.HUDControl.AudibleAlert\n\n\nsound_list: dict[int, tuple[str, int | None, float]] = {\n  # AudibleAlert, file name, play count (none for infinite)\n  AudibleAlert.engage: (\"engage.wav\", 1, MAX_VOLUME),\n  AudibleAlert.disengage: (\"disengage.wav\", 1, MAX_VOLUME),\n  AudibleAlert.refuse: (\"refuse.wav\", 1, MAX_VOLUME),\n\n  AudibleAlert.prompt: (\"prompt.wav\", 1, MAX_VOLUME),\n  AudibleAlert.promptRepeat: (\"prompt.wav\", None, MAX_VOLUME),\n  AudibleAlert.promptDistracted: (\"prompt_distracted.wav\", None, MAX_VOLUME),\n\n  AudibleAlert.warningSoft: (\"warning_soft.wav\", None, MAX_VOLUME),\n  AudibleAlert.warningImmediate: (\"warning_immediate.wav\", None, MAX_VOLUME),\n}\n\ndef check_controls_timeout_alert(sm):\n  controls_missing = time.monotonic() - sm.recv_time['controlsState']\n\n  if controls_missing > CONTROLS_TIMEOUT:\n    if sm['controlsState'].enabled and (controls_missing - CONTROLS_TIMEOUT) < 10:\n      return True\n\n  return False\n\n\nclass Soundd:\n  def __init__(self):\n    self.load_sounds()\n\n    self.current_alert = AudibleAlert.none\n    self.current_volume = MIN_VOLUME\n    self.current_sound_frame = 0\n\n    self.controls_timeout_alert = False\n\n    self.spl_filter_weighted = FirstOrderFilter(0, 2.5, FILTER_DT, initialized=False)\n\n  def load_sounds(self):\n    self.loaded_sounds: dict[int, np.ndarray] = {}\n\n    # Load all sounds\n    for sound in sound_list:\n      filename, play_count, volume = sound_list[sound]\n\n      wavefile = wave.open(BASEDIR + \"/selfdrive/assets/sounds/\" + filename, 'r')\n\n      assert wavefile.getnchannels() == 1\n      assert wavefile.getsampwidth() == 2\n      assert wavefile.getframerate() == SAMPLE_RATE\n\n      length = wavefile.getnframes()\n      self.loaded_sounds[sound] = np.frombuffer(wavefile.readframes(length), dtype=np.int16).astype(np.float32) / (2**16/2)\n\n  def get_sound_data(self, frames): # get \"frames\" worth of data from the current alert sound, looping when required\n\n    ret = np.zeros(frames, dtype=np.float32)\n\n    if self.current_alert != AudibleAlert.none:\n      num_loops = sound_list[self.current_alert][1]\n      sound_data = self.loaded_sounds[self.current_alert]\n      written_frames = 0\n\n      current_sound_frame = self.current_sound_frame % len(sound_data)\n      loops = self.current_sound_frame // len(sound_data)\n\n      while written_frames < frames and (num_loops is None or loops < num_loops):\n        available_frames = sound_data.shape[0] - current_sound_frame\n        frames_to_write = min(available_frames, frames - written_frames)\n        ret[written_frames:written_frames+frames_to_write] = sound_data[current_sound_frame:current_sound_frame+frames_to_write]\n        written_frames += frames_to_write\n        self.current_sound_frame += frames_to_write\n\n    return ret * self.current_volume\n\n  def callback(self, data_out: np.ndarray, frames: int, time, status) -> None:\n    if status:\n      cloudlog.warning(f\"soundd stream over/underflow: {status}\")\n    data_out[:frames, 0] = self.get_sound_data(frames)\n\n  def update_alert(self, new_alert):\n    current_alert_played_once = self.current_alert == AudibleAlert.none or self.current_sound_frame > len(self.loaded_sounds[self.current_alert])\n    if self.current_alert != new_alert and (new_alert != AudibleAlert.none or current_alert_played_once):\n      self.current_alert = new_alert\n      self.current_sound_frame = 0\n\n  def get_audible_alert(self, sm):\n    if sm.updated['controlsState']:\n      new_alert = sm['controlsState'].alertSound.raw\n      self.update_alert(new_alert)\n    elif check_controls_timeout_alert(sm):\n      self.update_alert(AudibleAlert.warningImmediate)\n      self.controls_timeout_alert = True\n    elif self.controls_timeout_alert:\n      self.update_alert(AudibleAlert.none)\n      self.controls_timeout_alert = False\n\n  def calculate_volume(self, weighted_db):\n    volume = ((weighted_db - AMBIENT_DB) / DB_SCALE) * (MAX_VOLUME - MIN_VOLUME) + MIN_VOLUME\n    return math.pow(10, (np.clip(volume, MIN_VOLUME, MAX_VOLUME) - 1))\n\n  @retry(attempts=7, delay=3)\n  def get_stream(self, sd):\n    # reload sounddevice to reinitialize portaudio\n    sd._terminate()\n    sd._initialize()\n    return sd.OutputStream(channels=1, samplerate=SAMPLE_RATE, callback=self.callback, blocksize=SAMPLE_BUFFER)\n\n  def soundd_thread(self):\n    # sounddevice must be imported after forking processes\n    import sounddevice as sd\n\n    sm = messaging.SubMaster(['controlsState', 'microphone'])\n\n    with self.get_stream(sd) as stream:\n      rk = Ratekeeper(20)\n\n      cloudlog.info(f\"soundd stream started: {stream.samplerate=} {stream.channels=} {stream.dtype=} {stream.device=}, {stream.blocksize=}\")\n      while True:\n        sm.update(0)\n\n        if sm.updated['microphone'] and self.current_alert == AudibleAlert.none: # only update volume filter when not playing alert\n          self.spl_filter_weighted.update(sm[\"microphone\"].soundPressureWeightedDb)\n          self.current_volume = self.calculate_volume(float(self.spl_filter_weighted.x))\n\n        self.get_audible_alert(sm)\n\n        rk.keep_time()\n\n        assert stream.active\n\n\ndef main():\n  s = Soundd()\n  s.soundd_thread()\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/ui/ui.py": "#!/usr/bin/env python3\nimport os\nimport signal\n\nsignal.signal(signal.SIGINT, signal.SIG_DFL)\n\nimport cereal.messaging as messaging\nfrom openpilot.system.hardware import HARDWARE\n\nfrom PyQt5.QtCore import Qt, QTimer\nfrom PyQt5.QtWidgets import QLabel, QWidget, QVBoxLayout, QStackedLayout, QApplication\nfrom openpilot.selfdrive.ui.qt.python_helpers import set_main_window\n\n\nif __name__ == \"__main__\":\n  app = QApplication([])\n  win = QWidget()\n  set_main_window(win)\n\n  bg = QLabel(\"\", alignment=Qt.AlignCenter)\n\n  alert1 = QLabel()\n  alert2 = QLabel()\n  vlayout = QVBoxLayout()\n  vlayout.addWidget(alert1, alignment=Qt.AlignCenter)\n  vlayout.addWidget(alert2, alignment=Qt.AlignCenter)\n\n  tmp = QWidget()\n  tmp.setLayout(vlayout)\n\n  stack = QStackedLayout(win)\n  stack.addWidget(tmp)\n  stack.addWidget(bg)\n  stack.setStackingMode(QStackedLayout.StackAll)\n\n  win.setObjectName(\"win\")\n  win.setStyleSheet(\"\"\"\n    #win {\n      background-color: black;\n    }\n    QLabel {\n      color: white;\n      font-size: 40px;\n    }\n  \"\"\")\n\n  sm = messaging.SubMaster(['deviceState', 'controlsState'])\n\n  def update():\n    sm.update(0)\n\n    onroad = sm.all_checks(['deviceState']) and sm['deviceState'].started\n    if onroad:\n      cs = sm['controlsState']\n      color = (\"grey\" if str(cs.state) in (\"overriding\", \"preEnabled\") else \"green\") if cs.enabled else \"blue\"\n      bg.setText(\"\\U0001F44D\" if cs.engageable else \"\\U0001F6D1\")\n      bg.setStyleSheet(f\"font-size: 100px; background-color: {color};\")\n      bg.show()\n\n      alert1.setText(cs.alertText1)\n      alert2.setText(cs.alertText2)\n\n      if not sm.alive['controlsState']:\n        alert1.setText(\"waiting for controls...\")\n    else:\n      bg.hide()\n      alert1.setText(\"\")\n      alert2.setText(\"offroad\")\n\n    HARDWARE.set_screen_brightness(100 if onroad else 40)\n    os.system(\"echo 0 > /sys/class/backlight/panel0-backlight/bl_power\")\n\n  timer = QTimer()\n  timer.timeout.connect(update)\n  timer.start(50)\n\n  app.exec_()\n", "selfdrive/ui/__init__.py": "", "selfdrive/ui/qt/python_helpers.py": "import os\nfrom cffi import FFI\n\nimport sip\n\nfrom openpilot.common.ffi_wrapper import suffix\nfrom openpilot.common.basedir import BASEDIR\n\n\ndef get_ffi():\n  lib = os.path.join(BASEDIR, \"selfdrive\", \"ui\", \"qt\", \"libpython_helpers\" + suffix())\n\n  ffi = FFI()\n  ffi.cdef(\"void set_main_window(void *w);\")\n  return ffi, ffi.dlopen(lib)\n\n\ndef set_main_window(widget):\n  ffi, lib = get_ffi()\n  lib.set_main_window(ffi.cast('void*', sip.unwrapinstance(widget)))\n", "selfdrive/ui/translations/auto_translate.py": "#!/usr/bin/env python3\n\nimport argparse\nimport json\nimport os\nimport pathlib\nimport xml.etree.ElementTree as ET\nfrom typing import cast\n\nimport requests\n\nTRANSLATIONS_DIR = pathlib.Path(__file__).resolve().parent\nTRANSLATIONS_LANGUAGES = TRANSLATIONS_DIR / \"languages.json\"\n\nOPENAI_MODEL = \"gpt-4\"\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\nOPENAI_PROMPT = \"You are a professional translator from English to {language} (ISO 639 language code). \" + \\\n                \"The following sentence or word is in the GUI of a software called openpilot, translate it accordingly.\"\n\n\ndef get_language_files(languages: list[str] = None) -> dict[str, pathlib.Path]:\n  files = {}\n\n  with open(TRANSLATIONS_LANGUAGES) as fp:\n    language_dict = json.load(fp)\n\n    for filename in language_dict.values():\n      path = TRANSLATIONS_DIR / f\"{filename}.ts\"\n      language = path.stem.split(\"main_\")[1]\n\n      if languages is None or language in languages:\n        files[language] = path\n\n  return files\n\n\ndef translate_phrase(text: str, language: str) -> str:\n  response = requests.post(\n    \"https://api.openai.com/v1/chat/completions\",\n    json={\n      \"model\": OPENAI_MODEL,\n      \"messages\": [\n        {\n          \"role\": \"system\",\n          \"content\": OPENAI_PROMPT.format(language=language),\n        },\n        {\n          \"role\": \"user\",\n          \"content\": text,\n        },\n      ],\n      \"temperature\": 0.8,\n      \"max_tokens\": 1024,\n      \"top_p\": 1,\n    },\n    headers={\n      \"Authorization\": f\"Bearer {OPENAI_API_KEY}\",\n      \"Content-Type\": \"application/json\",\n    },\n  )\n\n  if 400 <= response.status_code < 600:\n    raise requests.HTTPError(f'Error {response.status_code}: {response.json()}', response=response)\n\n  data = response.json()\n\n  return cast(str, data[\"choices\"][0][\"message\"][\"content\"])\n\n\ndef translate_file(path: pathlib.Path, language: str, all_: bool) -> None:\n  tree = ET.parse(path)\n\n  root = tree.getroot()\n\n  for context in root.findall(\"./context\"):\n    name = context.find(\"name\")\n    if name is None:\n      raise ValueError(\"name not found\")\n\n    print(f\"Context: {name.text}\")\n\n    for message in context.findall(\"./message\"):\n      source = message.find(\"source\")\n      translation = message.find(\"translation\")\n\n      if source is None or translation is None:\n        raise ValueError(\"source or translation not found\")\n\n      if not all_ and translation.attrib.get(\"type\") != \"unfinished\":\n        continue\n\n      llm_translation = translate_phrase(cast(str, source.text), language)\n\n      print(f\"Source: {source.text}\\n\" +\n            f\"Current translation: {translation.text}\\n\" +\n            f\"LLM translation: {llm_translation}\")\n\n      translation.text = llm_translation\n\n  with path.open(\"w\", encoding=\"utf-8\") as fp:\n    fp.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' +\n             '<!DOCTYPE TS>\\n' +\n             ET.tostring(root, encoding=\"utf-8\").decode())\n\n\ndef main():\n  arg_parser = argparse.ArgumentParser(\"Auto translate\")\n\n  group = arg_parser.add_mutually_exclusive_group(required=True)\n  group.add_argument(\"-a\", \"--all-files\", action=\"store_true\", help=\"Translate all files\")\n  group.add_argument(\"-f\", \"--file\", nargs=\"+\", help=\"Translate the selected files. (Example: -f fr de)\")\n\n  arg_parser.add_argument(\"-t\", \"--all-translations\", action=\"store_true\", default=False, help=\"Translate all sections. (Default: only unfinished)\")\n\n  args = arg_parser.parse_args()\n\n  if OPENAI_API_KEY is None:\n    print(\"OpenAI API key is missing. (Hint: use `export OPENAI_API_KEY=YOUR-KEY` before you run the script).\\n\" +\n          \"If you don't have one go to: https://beta.openai.com/account/api-keys.\")\n    exit(1)\n\n  files = get_language_files(None if args.all_files else args.file)\n\n  if args.file:\n    missing_files = set(args.file) - set(files)\n    if len(missing_files):\n      print(f\"No language files found: {missing_files}\")\n      exit(1)\n\n  print(f\"Translation mode: {'all' if args.all_translations else 'only unfinished'}. Files: {list(files)}\")\n\n  for lang, path in files.items():\n    print(f\"Translate {lang} ({path})\")\n    translate_file(path, lang, args.all_translations)\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/ui/translations/create_badges.py": "#!/usr/bin/env python3\nimport json\nimport os\nimport requests\nimport xml.etree.ElementTree as ET\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.selfdrive.ui.tests.test_translations import UNFINISHED_TRANSLATION_TAG\nfrom openpilot.selfdrive.ui.update_translations import LANGUAGES_FILE, TRANSLATIONS_DIR\n\nTRANSLATION_TAG = \"<translation\"\nBADGE_HEIGHT = 20 + 8\nSHIELDS_URL = \"https://img.shields.io/badge\"\n\nif __name__ == \"__main__\":\n  with open(LANGUAGES_FILE) as f:\n    translation_files = json.load(f)\n\n  badge_svg = []\n  max_badge_width = 0  # keep track of max width to set parent element\n  for idx, (name, file) in enumerate(translation_files.items()):\n    with open(os.path.join(TRANSLATIONS_DIR, f\"{file}.ts\")) as tr_f:\n      tr_file = tr_f.read()\n\n    total_translations = 0\n    unfinished_translations = 0\n    for line in tr_file.splitlines():\n      if TRANSLATION_TAG in line:\n        total_translations += 1\n      if UNFINISHED_TRANSLATION_TAG in line:\n        unfinished_translations += 1\n\n    percent_finished = int(100 - (unfinished_translations / total_translations * 100.))\n    color = \"green\" if percent_finished == 100 else \"orange\" if percent_finished > 90 else \"red\"\n\n    # Download badge\n    badge_label = f\"LANGUAGE {name}\"\n    badge_message = f\"{percent_finished}% complete\"\n    if unfinished_translations != 0:\n      badge_message += f\" ({unfinished_translations} unfinished)\"\n\n    r = requests.get(f\"{SHIELDS_URL}/{badge_label}-{badge_message}-{color}\", timeout=10)\n    assert r.status_code == 200, \"Error downloading badge\"\n    content_svg = r.content.decode(\"utf-8\")\n\n    xml = ET.fromstring(content_svg)\n    assert \"width\" in xml.attrib\n    max_badge_width = max(max_badge_width, int(xml.attrib[\"width\"]))\n\n    # Make tag ids in each badge unique to combine them into one svg\n    for tag in (\"r\", \"s\"):\n      content_svg = content_svg.replace(f'id=\"{tag}\"', f'id=\"{tag}{idx}\"')\n      content_svg = content_svg.replace(f'\"url(#{tag})\"', f'\"url(#{tag}{idx})\"')\n\n    badge_svg.extend([f'<g transform=\"translate(0, {idx * BADGE_HEIGHT})\">', content_svg, \"</g>\"])\n\n  badge_svg.insert(0, '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n                   f'height=\"{len(translation_files) * BADGE_HEIGHT}\" width=\"{max_badge_width}\">')\n  badge_svg.append(\"</svg>\")\n\n  with open(os.path.join(BASEDIR, \"translation_badge.svg\"), \"w\") as badge_f:\n    badge_f.write(\"\\n\".join(badge_svg))\n", "selfdrive/car/isotp_parallel_query.py": "import time\nfrom collections import defaultdict\nfrom functools import partial\n\nimport cereal.messaging as messaging\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.selfdrive.pandad import can_list_to_can_capnp\nfrom openpilot.selfdrive.car.fw_query_definitions import AddrType\nfrom panda.python.uds import CanClient, IsoTpMessage, FUNCTIONAL_ADDRS, get_rx_addr_for_tx_addr\n\n\nclass IsoTpParallelQuery:\n  def __init__(self, sendcan: messaging.PubSocket, logcan: messaging.SubSocket, bus: int, addrs: list[int] | list[AddrType],\n               request: list[bytes], response: list[bytes], response_offset: int = 0x8,\n               functional_addrs: list[int] = None, debug: bool = False, response_pending_timeout: float = 10) -> None:\n    self.sendcan = sendcan\n    self.logcan = logcan\n    self.bus = bus\n    self.request = request\n    self.response = response\n    self.functional_addrs = functional_addrs or []\n    self.debug = debug\n    self.response_pending_timeout = response_pending_timeout\n\n    real_addrs = [a if isinstance(a, tuple) else (a, None) for a in addrs]\n    for tx_addr, _ in real_addrs:\n      assert tx_addr not in FUNCTIONAL_ADDRS, f\"Functional address should be defined in functional_addrs: {hex(tx_addr)}\"\n\n    self.msg_addrs = {tx_addr: get_rx_addr_for_tx_addr(tx_addr[0], rx_offset=response_offset) for tx_addr in real_addrs}\n    self.msg_buffer: dict[int, list[tuple[int, int, bytes, int]]] = defaultdict(list)\n\n  def rx(self):\n    \"\"\"Drain can socket and sort messages into buffers based on address\"\"\"\n    can_packets = messaging.drain_sock(self.logcan, wait_for_one=True)\n\n    for packet in can_packets:\n      for msg in packet.can:\n        if msg.src == self.bus and msg.address in self.msg_addrs.values():\n          self.msg_buffer[msg.address].append((msg.address, msg.busTime, msg.dat, msg.src))\n\n  def _can_tx(self, tx_addr, dat, bus):\n    \"\"\"Helper function to send single message\"\"\"\n    msg = [tx_addr, 0, dat, bus]\n    self.sendcan.send(can_list_to_can_capnp([msg], msgtype='sendcan'))\n\n  def _can_rx(self, addr, sub_addr=None):\n    \"\"\"Helper function to retrieve message with specified address and subadress from buffer\"\"\"\n    keep_msgs = []\n\n    if sub_addr is None:\n      msgs = self.msg_buffer[addr]\n    else:\n      # Filter based on subadress\n      msgs = []\n      for m in self.msg_buffer[addr]:\n        first_byte = m[2][0]\n        if first_byte == sub_addr:\n          msgs.append(m)\n        else:\n          keep_msgs.append(m)\n\n    self.msg_buffer[addr] = keep_msgs\n    return msgs\n\n  def _drain_rx(self):\n    messaging.drain_sock_raw(self.logcan)\n    self.msg_buffer = defaultdict(list)\n\n  def _create_isotp_msg(self, tx_addr: int, sub_addr: int | None, rx_addr: int):\n    can_client = CanClient(self._can_tx, partial(self._can_rx, rx_addr, sub_addr=sub_addr), tx_addr, rx_addr,\n                           self.bus, sub_addr=sub_addr, debug=self.debug)\n\n    max_len = 8 if sub_addr is None else 7\n    # uses iso-tp frame separation time of 10 ms\n    # TODO: use single_frame_mode so ECUs can send as fast as they want,\n    # as well as reduces chances we process messages from previous queries\n    return IsoTpMessage(can_client, timeout=0, separation_time=0.01, debug=self.debug, max_len=max_len)\n\n  def get_data(self, timeout: float, total_timeout: float = 60.) -> dict[AddrType, bytes]:\n    self._drain_rx()\n\n    # Create message objects\n    msgs = {}\n    request_counter = {}\n    request_done = {}\n    for tx_addr, rx_addr in self.msg_addrs.items():\n      msgs[tx_addr] = self._create_isotp_msg(*tx_addr, rx_addr)\n      request_counter[tx_addr] = 0\n      request_done[tx_addr] = False\n\n    # Send first request to functional addrs, subsequent responses are handled on physical addrs\n    if len(self.functional_addrs):\n      for addr in self.functional_addrs:\n        self._create_isotp_msg(addr, None, -1).send(self.request[0])\n\n    # Send first frame (single or first) to all addresses and receive asynchronously in the loop below.\n    # If querying functional addrs, only set up physical IsoTpMessages to send consecutive frames\n    for msg in msgs.values():\n      msg.send(self.request[0], setup_only=len(self.functional_addrs) > 0)\n\n    results = {}\n    start_time = time.monotonic()\n    addrs_responded = set()  # track addresses that have ever sent a valid iso-tp frame for timeout logging\n    response_timeouts = {tx_addr: start_time + timeout for tx_addr in self.msg_addrs}\n    while True:\n      self.rx()\n\n      for tx_addr, msg in msgs.items():\n        try:\n          dat, rx_in_progress = msg.recv()\n        except Exception:\n          cloudlog.exception(f\"Error processing UDS response: {tx_addr}\")\n          request_done[tx_addr] = True\n          continue\n\n        # Extend timeout for each consecutive ISO-TP frame to avoid timing out on long responses\n        if rx_in_progress:\n          addrs_responded.add(tx_addr)\n          response_timeouts[tx_addr] = time.monotonic() + timeout\n\n        if dat is None:\n          continue\n\n        # Log unexpected empty responses\n        if len(dat) == 0:\n          cloudlog.error(f\"iso-tp query empty response: {tx_addr}\")\n          request_done[tx_addr] = True\n          continue\n\n        counter = request_counter[tx_addr]\n        expected_response = self.response[counter]\n        response_valid = dat.startswith(expected_response)\n\n        if response_valid:\n          if counter + 1 < len(self.request):\n            response_timeouts[tx_addr] = time.monotonic() + timeout\n            msg.send(self.request[counter + 1])\n            request_counter[tx_addr] += 1\n          else:\n            results[tx_addr] = dat[len(expected_response):]\n            request_done[tx_addr] = True\n        else:\n          error_code = dat[2] if len(dat) > 2 else -1\n          if error_code == 0x78:\n            response_timeouts[tx_addr] = time.monotonic() + self.response_pending_timeout\n            cloudlog.error(f\"iso-tp query response pending: {tx_addr}\")\n          else:\n            request_done[tx_addr] = True\n            cloudlog.error(f\"iso-tp query bad response: {tx_addr} - 0x{dat.hex()}\")\n\n      # Mark request done if address timed out\n      cur_time = time.monotonic()\n      for tx_addr in response_timeouts:\n        if cur_time - response_timeouts[tx_addr] > 0:\n          if not request_done[tx_addr]:\n            if request_counter[tx_addr] > 0:\n              cloudlog.error(f\"iso-tp query timeout after receiving partial response: {tx_addr}\")\n            elif tx_addr in addrs_responded:\n              cloudlog.error(f\"iso-tp query timeout while receiving response: {tx_addr}\")\n            # TODO: handle functional addresses\n            # else:\n            #   cloudlog.error(f\"iso-tp query timeout with no response: {tx_addr}\")\n          request_done[tx_addr] = True\n\n      # Break if all requests are done (finished or timed out)\n      if all(request_done.values()):\n        break\n\n      if cur_time - start_time > total_timeout:\n        cloudlog.error(\"iso-tp query timeout while receiving data\")\n        break\n\n    return results\n", "selfdrive/car/ecu_addrs.py": "#!/usr/bin/env python3\nimport capnp\nimport time\n\nimport cereal.messaging as messaging\nfrom panda.python.uds import SERVICE_TYPE\nfrom openpilot.selfdrive.car import make_can_msg\nfrom openpilot.selfdrive.car.fw_query_definitions import EcuAddrBusType\nfrom openpilot.selfdrive.pandad import can_list_to_can_capnp\nfrom openpilot.common.swaglog import cloudlog\n\n\ndef make_tester_present_msg(addr, bus, subaddr=None):\n  dat = [0x02, SERVICE_TYPE.TESTER_PRESENT, 0x0]\n  if subaddr is not None:\n    dat.insert(0, subaddr)\n\n  dat.extend([0x0] * (8 - len(dat)))\n  return make_can_msg(addr, bytes(dat), bus)\n\n\ndef is_tester_present_response(msg: capnp.lib.capnp._DynamicStructReader, subaddr: int = None) -> bool:\n  # ISO-TP messages are always padded to 8 bytes\n  # tester present response is always a single frame\n  dat_offset = 1 if subaddr is not None else 0\n  if len(msg.dat) == 8 and 1 <= msg.dat[dat_offset] <= 7:\n    # success response\n    if msg.dat[dat_offset + 1] == (SERVICE_TYPE.TESTER_PRESENT + 0x40):\n      return True\n    # error response\n    if msg.dat[dat_offset + 1] == 0x7F and msg.dat[dat_offset + 2] == SERVICE_TYPE.TESTER_PRESENT:\n      return True\n  return False\n\n\ndef get_all_ecu_addrs(logcan: messaging.SubSocket, sendcan: messaging.PubSocket, bus: int, timeout: float = 1, debug: bool = True) -> set[EcuAddrBusType]:\n  addr_list = [0x700 + i for i in range(256)] + [0x18da00f1 + (i << 8) for i in range(256)]\n  queries: set[EcuAddrBusType] = {(addr, None, bus) for addr in addr_list}\n  responses = queries\n  return get_ecu_addrs(logcan, sendcan, queries, responses, timeout=timeout, debug=debug)\n\n\ndef get_ecu_addrs(logcan: messaging.SubSocket, sendcan: messaging.PubSocket, queries: set[EcuAddrBusType],\n                  responses: set[EcuAddrBusType], timeout: float = 1, debug: bool = False) -> set[EcuAddrBusType]:\n  ecu_responses: set[EcuAddrBusType] = set()  # set((addr, subaddr, bus),)\n  try:\n    msgs = [make_tester_present_msg(addr, bus, subaddr) for addr, subaddr, bus in queries]\n\n    messaging.drain_sock_raw(logcan)\n    sendcan.send(can_list_to_can_capnp(msgs, msgtype='sendcan'))\n    start_time = time.monotonic()\n    while time.monotonic() - start_time < timeout:\n      can_packets = messaging.drain_sock(logcan, wait_for_one=True)\n      for packet in can_packets:\n        for msg in packet.can:\n          if not len(msg.dat):\n            cloudlog.warning(\"ECU addr scan: skipping empty remote frame\")\n            continue\n\n          subaddr = None if (msg.address, None, msg.src) in responses else msg.dat[0]\n          if (msg.address, subaddr, msg.src) in responses and is_tester_present_response(msg, subaddr):\n            if debug:\n              print(f\"CAN-RX: {hex(msg.address)} - 0x{bytes.hex(msg.dat)}\")\n              if (msg.address, subaddr, msg.src) in ecu_responses:\n                print(f\"Duplicate ECU address: {hex(msg.address)}\")\n            ecu_responses.add((msg.address, subaddr, msg.src))\n  except Exception:\n    cloudlog.exception(\"ECU addr scan exception\")\n  return ecu_responses\n\n\nif __name__ == \"__main__\":\n  import argparse\n  from openpilot.common.params import Params\n  from openpilot.selfdrive.car.fw_versions import set_obd_multiplexing\n\n  parser = argparse.ArgumentParser(description='Get addresses of all ECUs')\n  parser.add_argument('--debug', action='store_true')\n  parser.add_argument('--bus', type=int, default=1)\n  parser.add_argument('--no-obd', action='store_true')\n  parser.add_argument('--timeout', type=float, default=1.0)\n  args = parser.parse_args()\n\n  logcan = messaging.sub_sock('can')\n  sendcan = messaging.pub_sock('sendcan')\n\n  # Set up params for pandad\n  params = Params()\n  params.remove(\"FirmwareQueryDone\")\n  params.put_bool(\"IsOnroad\", False)\n  time.sleep(0.2)  # thread is 10 Hz\n  params.put_bool(\"IsOnroad\", True)\n\n  set_obd_multiplexing(params, not args.no_obd)\n\n  print(\"Getting ECU addresses ...\")\n  ecu_addrs = get_all_ecu_addrs(logcan, sendcan, args.bus, args.timeout, debug=args.debug)\n\n  print()\n  print(\"Found ECUs on rx addresses:\")\n  for addr, subaddr, _ in ecu_addrs:\n    msg = f\"  {hex(addr)}\"\n    if subaddr is not None:\n      msg += f\" (sub-address: {hex(subaddr)})\"\n    print(msg)\n", "selfdrive/car/disable_ecu.py": "#!/usr/bin/env python3\nfrom openpilot.selfdrive.car.isotp_parallel_query import IsoTpParallelQuery\nfrom openpilot.common.swaglog import cloudlog\n\nEXT_DIAG_REQUEST = b'\\x10\\x03'\nEXT_DIAG_RESPONSE = b'\\x50\\x03'\n\nCOM_CONT_RESPONSE = b''\n\n\ndef disable_ecu(logcan, sendcan, bus=0, addr=0x7d0, sub_addr=None, com_cont_req=b'\\x28\\x83\\x01', timeout=0.1, retry=10, debug=False):\n  \"\"\"Silence an ECU by disabling sending and receiving messages using UDS 0x28.\n  The ECU will stay silent as long as openpilot keeps sending Tester Present.\n\n  This is used to disable the radar in some cars. Openpilot will emulate the radar.\n  WARNING: THIS DISABLES AEB!\"\"\"\n  cloudlog.warning(f\"ecu disable {hex(addr), sub_addr} ...\")\n\n  for i in range(retry):\n    try:\n      query = IsoTpParallelQuery(sendcan, logcan, bus, [(addr, sub_addr)], [EXT_DIAG_REQUEST], [EXT_DIAG_RESPONSE], debug=debug)\n\n      for _, _ in query.get_data(timeout).items():\n        cloudlog.warning(\"communication control disable tx/rx ...\")\n\n        query = IsoTpParallelQuery(sendcan, logcan, bus, [(addr, sub_addr)], [com_cont_req], [COM_CONT_RESPONSE], debug=debug)\n        query.get_data(0)\n\n        cloudlog.warning(\"ecu disabled\")\n        return True\n\n    except Exception:\n      cloudlog.exception(\"ecu disable exception\")\n\n    cloudlog.error(f\"ecu disable retry ({i + 1}) ...\")\n  cloudlog.error(\"ecu disable failed\")\n  return False\n\n\nif __name__ == \"__main__\":\n  import time\n  import cereal.messaging as messaging\n  sendcan = messaging.pub_sock('sendcan')\n  logcan = messaging.sub_sock('can')\n  time.sleep(1)\n\n  # honda bosch radar disable\n  disabled = disable_ecu(logcan, sendcan, bus=1, addr=0x18DAB0F1, com_cont_req=b'\\x28\\x83\\x03', timeout=0.5, debug=False)\n  print(f\"disabled: {disabled}\")\n", "selfdrive/car/fingerprints.py": "from openpilot.selfdrive.car.interfaces import get_interface_attr\nfrom openpilot.selfdrive.car.body.values import CAR as BODY\nfrom openpilot.selfdrive.car.chrysler.values import CAR as CHRYSLER\nfrom openpilot.selfdrive.car.ford.values import CAR as FORD\nfrom openpilot.selfdrive.car.gm.values import CAR as GM\nfrom openpilot.selfdrive.car.honda.values import CAR as HONDA\nfrom openpilot.selfdrive.car.hyundai.values import CAR as HYUNDAI\nfrom openpilot.selfdrive.car.mazda.values import CAR as MAZDA\nfrom openpilot.selfdrive.car.mock.values import CAR as MOCK\nfrom openpilot.selfdrive.car.nissan.values import CAR as NISSAN\nfrom openpilot.selfdrive.car.subaru.values import CAR as SUBARU\nfrom openpilot.selfdrive.car.tesla.values import CAR as TESLA\nfrom openpilot.selfdrive.car.toyota.values import CAR as TOYOTA\nfrom openpilot.selfdrive.car.volkswagen.values import CAR as VW\n\nFW_VERSIONS = get_interface_attr('FW_VERSIONS', combine_brands=True, ignore_none=True)\n_FINGERPRINTS = get_interface_attr('FINGERPRINTS', combine_brands=True, ignore_none=True)\n\n_DEBUG_ADDRESS = {1880: 8}   # reserved for debug purposes\n\n\ndef is_valid_for_fingerprint(msg, car_fingerprint: dict[int, int]):\n  adr = msg.address\n  # ignore addresses that are more than 11 bits\n  return (adr in car_fingerprint and car_fingerprint[adr] == len(msg.dat)) or adr >= 0x800\n\n\ndef eliminate_incompatible_cars(msg, candidate_cars):\n  \"\"\"Removes cars that could not have sent msg.\n\n     Inputs:\n      msg: A cereal/log CanData message from the car.\n      candidate_cars: A list of cars to consider.\n\n     Returns:\n      A list containing the subset of candidate_cars that could have sent msg.\n  \"\"\"\n  compatible_cars = []\n\n  for car_name in candidate_cars:\n    car_fingerprints = _FINGERPRINTS[car_name]\n\n    for fingerprint in car_fingerprints:\n      # add alien debug address\n      if is_valid_for_fingerprint(msg, fingerprint | _DEBUG_ADDRESS):\n        compatible_cars.append(car_name)\n        break\n\n  return compatible_cars\n\n\ndef all_known_cars():\n  \"\"\"Returns a list of all known car strings.\"\"\"\n  return list({*FW_VERSIONS.keys(), *_FINGERPRINTS.keys()})\n\n\ndef all_legacy_fingerprint_cars():\n  \"\"\"Returns a list of all known car strings, FPv1 only.\"\"\"\n  return list(_FINGERPRINTS.keys())\n\n\n# A dict that maps old platform strings to their latest representations\nMIGRATION = {\n  \"ACURA ILX 2016 ACURAWATCH PLUS\": HONDA.ACURA_ILX,\n  \"ACURA RDX 2018 ACURAWATCH PLUS\": HONDA.ACURA_RDX,\n  \"ACURA RDX 2020 TECH\": HONDA.ACURA_RDX_3G,\n  \"AUDI A3\": VW.AUDI_A3_MK3,\n  \"HONDA ACCORD 2018 HYBRID TOURING\": HONDA.HONDA_ACCORD,\n  \"HONDA ACCORD 1.5T 2018\": HONDA.HONDA_ACCORD,\n  \"HONDA ACCORD 2018 LX 1.5T\": HONDA.HONDA_ACCORD,\n  \"HONDA ACCORD 2018 SPORT 2T\": HONDA.HONDA_ACCORD,\n  \"HONDA ACCORD 2T 2018\": HONDA.HONDA_ACCORD,\n  \"HONDA ACCORD HYBRID 2018\": HONDA.HONDA_ACCORD,\n  \"HONDA CIVIC 2016 TOURING\": HONDA.HONDA_CIVIC,\n  \"HONDA CIVIC HATCHBACK 2017 SEDAN/COUPE 2019\": HONDA.HONDA_CIVIC_BOSCH,\n  \"HONDA CIVIC SEDAN 1.6 DIESEL\": HONDA.HONDA_CIVIC_BOSCH_DIESEL,\n  \"HONDA CR-V 2016 EXECUTIVE\": HONDA.HONDA_CRV_EU,\n  \"HONDA CR-V 2016 TOURING\": HONDA.HONDA_CRV,\n  \"HONDA CR-V 2017 EX\": HONDA.HONDA_CRV_5G,\n  \"HONDA CR-V 2019 HYBRID\": HONDA.HONDA_CRV_HYBRID,\n  \"HONDA FIT 2018 EX\": HONDA.HONDA_FIT,\n  \"HONDA HRV 2019 TOURING\": HONDA.HONDA_HRV,\n  \"HONDA INSIGHT 2019 TOURING\": HONDA.HONDA_INSIGHT,\n  \"HONDA ODYSSEY 2018 EX-L\": HONDA.HONDA_ODYSSEY,\n  \"HONDA ODYSSEY 2019 EXCLUSIVE CHN\": HONDA.HONDA_ODYSSEY_CHN,\n  \"HONDA PILOT 2017 TOURING\": HONDA.HONDA_PILOT,\n  \"HONDA PILOT 2019 ELITE\": HONDA.HONDA_PILOT,\n  \"HONDA PILOT 2019\": HONDA.HONDA_PILOT,\n  \"HONDA PASSPORT 2021\": HONDA.HONDA_PILOT,\n  \"HONDA RIDGELINE 2017 BLACK EDITION\": HONDA.HONDA_RIDGELINE,\n  \"HYUNDAI ELANTRA LIMITED ULTIMATE 2017\": HYUNDAI.HYUNDAI_ELANTRA,\n  \"HYUNDAI SANTA FE LIMITED 2019\": HYUNDAI.HYUNDAI_SANTA_FE,\n  \"HYUNDAI TUCSON DIESEL 2019\": HYUNDAI.HYUNDAI_TUCSON,\n  \"KIA OPTIMA 2016\": HYUNDAI.KIA_OPTIMA_G4,\n  \"KIA OPTIMA 2019\": HYUNDAI.KIA_OPTIMA_G4_FL,\n  \"KIA OPTIMA SX 2019 & 2016\": HYUNDAI.KIA_OPTIMA_G4_FL,\n  \"LEXUS CT 200H 2018\": TOYOTA.LEXUS_CTH,\n  \"LEXUS ES 300H 2018\": TOYOTA.LEXUS_ES,\n  \"LEXUS ES 300H 2019\": TOYOTA.LEXUS_ES_TSS2,\n  \"LEXUS IS300 2018\": TOYOTA.LEXUS_IS,\n  \"LEXUS NX300 2018\": TOYOTA.LEXUS_NX,\n  \"LEXUS NX300H 2018\": TOYOTA.LEXUS_NX,\n  \"LEXUS RX 350 2016\": TOYOTA.LEXUS_RX,\n  \"LEXUS RX350 2020\": TOYOTA.LEXUS_RX_TSS2,\n  \"LEXUS RX450 HYBRID 2020\": TOYOTA.LEXUS_RX_TSS2,\n  \"TOYOTA SIENNA XLE 2018\": TOYOTA.TOYOTA_SIENNA,\n  \"TOYOTA C-HR HYBRID 2018\": TOYOTA.TOYOTA_CHR,\n  \"TOYOTA COROLLA HYBRID TSS2 2019\": TOYOTA.TOYOTA_COROLLA_TSS2,\n  \"TOYOTA RAV4 HYBRID 2019\": TOYOTA.TOYOTA_RAV4_TSS2,\n  \"LEXUS ES HYBRID 2019\": TOYOTA.LEXUS_ES_TSS2,\n  \"LEXUS NX HYBRID 2018\": TOYOTA.LEXUS_NX,\n  \"LEXUS NX HYBRID 2020\": TOYOTA.LEXUS_NX_TSS2,\n  \"LEXUS RX HYBRID 2020\": TOYOTA.LEXUS_RX_TSS2,\n  \"TOYOTA ALPHARD HYBRID 2021\": TOYOTA.TOYOTA_ALPHARD_TSS2,\n  \"TOYOTA AVALON HYBRID 2019\": TOYOTA.TOYOTA_AVALON_2019,\n  \"TOYOTA AVALON HYBRID 2022\": TOYOTA.TOYOTA_AVALON_TSS2,\n  \"TOYOTA CAMRY HYBRID 2018\": TOYOTA.TOYOTA_CAMRY,\n  \"TOYOTA CAMRY HYBRID 2021\": TOYOTA.TOYOTA_CAMRY_TSS2,\n  \"TOYOTA C-HR HYBRID 2022\": TOYOTA.TOYOTA_CHR_TSS2,\n  \"TOYOTA HIGHLANDER HYBRID 2020\": TOYOTA.TOYOTA_HIGHLANDER_TSS2,\n  \"TOYOTA RAV4 HYBRID 2022\": TOYOTA.TOYOTA_RAV4_TSS2_2022,\n  \"TOYOTA RAV4 HYBRID 2023\": TOYOTA.TOYOTA_RAV4_TSS2_2023,\n  \"TOYOTA HIGHLANDER HYBRID 2018\": TOYOTA.TOYOTA_HIGHLANDER,\n  \"LEXUS ES HYBRID 2018\": TOYOTA.LEXUS_ES,\n  \"LEXUS RX HYBRID 2017\": TOYOTA.LEXUS_RX,\n  \"HYUNDAI TUCSON HYBRID 4TH GEN\": HYUNDAI.HYUNDAI_TUCSON_4TH_GEN,\n  \"KIA SPORTAGE HYBRID 5TH GEN\": HYUNDAI.KIA_SPORTAGE_5TH_GEN,\n  \"KIA SORENTO PLUG-IN HYBRID 4TH GEN\": HYUNDAI.KIA_SORENTO_HEV_4TH_GEN,\n  \"CADILLAC ESCALADE ESV PLATINUM 2019\": GM.CADILLAC_ESCALADE_ESV_2019,\n\n  # Removal of platform_str, see https://github.com/commaai/openpilot/pull/31868/\n  \"COMMA BODY\": BODY.COMMA_BODY,\n  \"CHRYSLER PACIFICA HYBRID 2017\": CHRYSLER.CHRYSLER_PACIFICA_2017_HYBRID,\n  \"CHRYSLER PACIFICA HYBRID 2018\": CHRYSLER.CHRYSLER_PACIFICA_2018_HYBRID,\n  \"CHRYSLER PACIFICA HYBRID 2019\": CHRYSLER.CHRYSLER_PACIFICA_2019_HYBRID,\n  \"CHRYSLER PACIFICA 2018\": CHRYSLER.CHRYSLER_PACIFICA_2018,\n  \"CHRYSLER PACIFICA 2020\": CHRYSLER.CHRYSLER_PACIFICA_2020,\n  \"DODGE DURANGO 2021\": CHRYSLER.DODGE_DURANGO,\n  \"JEEP GRAND CHEROKEE V6 2018\": CHRYSLER.JEEP_GRAND_CHEROKEE,\n  \"JEEP GRAND CHEROKEE 2019\": CHRYSLER.JEEP_GRAND_CHEROKEE_2019,\n  \"RAM 1500 5TH GEN\": CHRYSLER.RAM_1500_5TH_GEN,\n  \"RAM HD 5TH GEN\": CHRYSLER.RAM_HD_5TH_GEN,\n  \"FORD BRONCO SPORT 1ST GEN\": FORD.FORD_BRONCO_SPORT_MK1,\n  \"FORD ESCAPE 4TH GEN\": FORD.FORD_ESCAPE_MK4,\n  \"FORD EXPLORER 6TH GEN\": FORD.FORD_EXPLORER_MK6,\n  \"FORD F-150 14TH GEN\": FORD.FORD_F_150_MK14,\n  \"FORD F-150 LIGHTNING 1ST GEN\": FORD.FORD_F_150_LIGHTNING_MK1,\n  \"FORD FOCUS 4TH GEN\": FORD.FORD_FOCUS_MK4,\n  \"FORD MAVERICK 1ST GEN\": FORD.FORD_MAVERICK_MK1,\n  \"FORD MUSTANG MACH-E 1ST GEN\": FORD.FORD_MUSTANG_MACH_E_MK1,\n  \"HOLDEN ASTRA RS-V BK 2017\": GM.HOLDEN_ASTRA,\n  \"CHEVROLET VOLT PREMIER 2017\": GM.CHEVROLET_VOLT,\n  \"CADILLAC ATS Premium Performance 2018\": GM.CADILLAC_ATS,\n  \"CHEVROLET MALIBU PREMIER 2017\": GM.CHEVROLET_MALIBU,\n  \"GMC ACADIA DENALI 2018\": GM.GMC_ACADIA,\n  \"BUICK LACROSSE 2017\": GM.BUICK_LACROSSE,\n  \"BUICK REGAL ESSENCE 2018\": GM.BUICK_REGAL,\n  \"CADILLAC ESCALADE 2017\": GM.CADILLAC_ESCALADE,\n  \"CADILLAC ESCALADE ESV 2016\": GM.CADILLAC_ESCALADE_ESV,\n  \"CADILLAC ESCALADE ESV 2019\": GM.CADILLAC_ESCALADE_ESV_2019,\n  \"CHEVROLET BOLT EUV 2022\": GM.CHEVROLET_BOLT_EUV,\n  \"CHEVROLET SILVERADO 1500 2020\": GM.CHEVROLET_SILVERADO,\n  \"CHEVROLET EQUINOX 2019\": GM.CHEVROLET_EQUINOX,\n  \"CHEVROLET TRAILBLAZER 2021\": GM.CHEVROLET_TRAILBLAZER,\n  \"HONDA ACCORD 2018\": HONDA.HONDA_ACCORD,\n  \"HONDA CIVIC (BOSCH) 2019\": HONDA.HONDA_CIVIC_BOSCH,\n  \"HONDA CIVIC SEDAN 1.6 DIESEL 2019\": HONDA.HONDA_CIVIC_BOSCH_DIESEL,\n  \"HONDA CIVIC 2022\": HONDA.HONDA_CIVIC_2022,\n  \"HONDA CR-V 2017\": HONDA.HONDA_CRV_5G,\n  \"HONDA CR-V HYBRID 2019\": HONDA.HONDA_CRV_HYBRID,\n  \"HONDA HR-V 2023\": HONDA.HONDA_HRV_3G,\n  \"ACURA RDX 2020\": HONDA.ACURA_RDX_3G,\n  \"HONDA INSIGHT 2019\": HONDA.HONDA_INSIGHT,\n  \"HONDA E 2020\": HONDA.HONDA_E,\n  \"ACURA ILX 2016\": HONDA.ACURA_ILX,\n  \"HONDA CR-V 2016\": HONDA.HONDA_CRV,\n  \"HONDA CR-V EU 2016\": HONDA.HONDA_CRV_EU,\n  \"HONDA FIT 2018\": HONDA.HONDA_FIT,\n  \"HONDA FREED 2020\": HONDA.HONDA_FREED,\n  \"HONDA HRV 2019\": HONDA.HONDA_HRV,\n  \"HONDA ODYSSEY 2018\": HONDA.HONDA_ODYSSEY,\n  \"HONDA ODYSSEY CHN 2019\": HONDA.HONDA_ODYSSEY_CHN,\n  \"ACURA RDX 2018\": HONDA.ACURA_RDX,\n  \"HONDA PILOT 2017\": HONDA.HONDA_PILOT,\n  \"HONDA RIDGELINE 2017\": HONDA.HONDA_RIDGELINE,\n  \"HONDA CIVIC 2016\": HONDA.HONDA_CIVIC,\n  \"HYUNDAI AZERA 6TH GEN\": HYUNDAI.HYUNDAI_AZERA_6TH_GEN,\n  \"HYUNDAI AZERA HYBRID 6TH GEN\": HYUNDAI.HYUNDAI_AZERA_HEV_6TH_GEN,\n  \"HYUNDAI ELANTRA 2017\": HYUNDAI.HYUNDAI_ELANTRA,\n  \"HYUNDAI I30 N LINE 2019 & GT 2018 DCT\": HYUNDAI.HYUNDAI_ELANTRA_GT_I30,\n  \"HYUNDAI ELANTRA 2021\": HYUNDAI.HYUNDAI_ELANTRA_2021,\n  \"HYUNDAI ELANTRA HYBRID 2021\": HYUNDAI.HYUNDAI_ELANTRA_HEV_2021,\n  \"HYUNDAI GENESIS 2015-2016\": HYUNDAI.HYUNDAI_GENESIS,\n  \"HYUNDAI IONIQ HYBRID 2017-2019\": HYUNDAI.HYUNDAI_IONIQ,\n  \"HYUNDAI IONIQ HYBRID 2020-2022\": HYUNDAI.HYUNDAI_IONIQ_HEV_2022,\n  \"HYUNDAI IONIQ ELECTRIC LIMITED 2019\": HYUNDAI.HYUNDAI_IONIQ_EV_LTD,\n  \"HYUNDAI IONIQ ELECTRIC 2020\": HYUNDAI.HYUNDAI_IONIQ_EV_2020,\n  \"HYUNDAI IONIQ PLUG-IN HYBRID 2019\": HYUNDAI.HYUNDAI_IONIQ_PHEV_2019,\n  \"HYUNDAI IONIQ PHEV 2020\": HYUNDAI.HYUNDAI_IONIQ_PHEV,\n  \"HYUNDAI KONA 2020\": HYUNDAI.HYUNDAI_KONA,\n  \"HYUNDAI KONA ELECTRIC 2019\": HYUNDAI.HYUNDAI_KONA_EV,\n  \"HYUNDAI KONA ELECTRIC 2022\": HYUNDAI.HYUNDAI_KONA_EV_2022,\n  \"HYUNDAI KONA ELECTRIC 2ND GEN\": HYUNDAI.HYUNDAI_KONA_EV_2ND_GEN,\n  \"HYUNDAI KONA HYBRID 2020\": HYUNDAI.HYUNDAI_KONA_HEV,\n  \"HYUNDAI SANTA FE 2019\": HYUNDAI.HYUNDAI_SANTA_FE,\n  \"HYUNDAI SANTA FE 2022\": HYUNDAI.HYUNDAI_SANTA_FE_2022,\n  \"HYUNDAI SANTA FE HYBRID 2022\": HYUNDAI.HYUNDAI_SANTA_FE_HEV_2022,\n  \"HYUNDAI SANTA FE PlUG-IN HYBRID 2022\": HYUNDAI.HYUNDAI_SANTA_FE_PHEV_2022,\n  \"HYUNDAI SONATA 2020\": HYUNDAI.HYUNDAI_SONATA,\n  \"HYUNDAI SONATA 2019\": HYUNDAI.HYUNDAI_SONATA_LF,\n  \"HYUNDAI STARIA 4TH GEN\": HYUNDAI.HYUNDAI_STARIA_4TH_GEN,\n  \"HYUNDAI TUCSON 2019\": HYUNDAI.HYUNDAI_TUCSON,\n  \"HYUNDAI PALISADE 2020\": HYUNDAI.HYUNDAI_PALISADE,\n  \"HYUNDAI VELOSTER 2019\": HYUNDAI.HYUNDAI_VELOSTER,\n  \"HYUNDAI SONATA HYBRID 2021\": HYUNDAI.HYUNDAI_SONATA_HYBRID,\n  \"HYUNDAI IONIQ 5 2022\": HYUNDAI.HYUNDAI_IONIQ_5,\n  \"HYUNDAI IONIQ 6 2023\": HYUNDAI.HYUNDAI_IONIQ_6,\n  \"HYUNDAI TUCSON 4TH GEN\": HYUNDAI.HYUNDAI_TUCSON_4TH_GEN,\n  \"HYUNDAI SANTA CRUZ 1ST GEN\": HYUNDAI.HYUNDAI_SANTA_CRUZ_1ST_GEN,\n  \"HYUNDAI CUSTIN 1ST GEN\": HYUNDAI.HYUNDAI_CUSTIN_1ST_GEN,\n  \"KIA FORTE E 2018 & GT 2021\": HYUNDAI.KIA_FORTE,\n  \"KIA K5 2021\": HYUNDAI.KIA_K5_2021,\n  \"KIA K5 HYBRID 2020\": HYUNDAI.KIA_K5_HEV_2020,\n  \"KIA K8 HYBRID 1ST GEN\": HYUNDAI.KIA_K8_HEV_1ST_GEN,\n  \"KIA NIRO EV 2020\": HYUNDAI.KIA_NIRO_EV,\n  \"KIA NIRO EV 2ND GEN\": HYUNDAI.KIA_NIRO_EV_2ND_GEN,\n  \"KIA NIRO HYBRID 2019\": HYUNDAI.KIA_NIRO_PHEV,\n  \"KIA NIRO PLUG-IN HYBRID 2022\": HYUNDAI.KIA_NIRO_PHEV_2022,\n  \"KIA NIRO HYBRID 2021\": HYUNDAI.KIA_NIRO_HEV_2021,\n  \"KIA NIRO HYBRID 2ND GEN\": HYUNDAI.KIA_NIRO_HEV_2ND_GEN,\n  \"KIA OPTIMA 4TH GEN\": HYUNDAI.KIA_OPTIMA_G4,\n  \"KIA OPTIMA 4TH GEN FACELIFT\": HYUNDAI.KIA_OPTIMA_G4_FL,\n  \"KIA OPTIMA HYBRID 2017 & SPORTS 2019\": HYUNDAI.KIA_OPTIMA_H,\n  \"KIA OPTIMA HYBRID 4TH GEN FACELIFT\": HYUNDAI.KIA_OPTIMA_H_G4_FL,\n  \"KIA SELTOS 2021\": HYUNDAI.KIA_SELTOS,\n  \"KIA SPORTAGE 5TH GEN\": HYUNDAI.KIA_SPORTAGE_5TH_GEN,\n  \"KIA SORENTO GT LINE 2018\": HYUNDAI.KIA_SORENTO,\n  \"KIA SORENTO 4TH GEN\": HYUNDAI.KIA_SORENTO_4TH_GEN,\n  \"KIA SORENTO HYBRID 4TH GEN\": HYUNDAI.KIA_SORENTO_HEV_4TH_GEN,\n  \"KIA STINGER GT2 2018\": HYUNDAI.KIA_STINGER,\n  \"KIA STINGER 2022\": HYUNDAI.KIA_STINGER_2022,\n  \"KIA CEED INTRO ED 2019\": HYUNDAI.KIA_CEED,\n  \"KIA EV6 2022\": HYUNDAI.KIA_EV6,\n  \"KIA CARNIVAL 4TH GEN\": HYUNDAI.KIA_CARNIVAL_4TH_GEN,\n  \"GENESIS GV60 ELECTRIC 1ST GEN\": HYUNDAI.GENESIS_GV60_EV_1ST_GEN,\n  \"GENESIS G70 2018\": HYUNDAI.GENESIS_G70,\n  \"GENESIS G70 2020\": HYUNDAI.GENESIS_G70_2020,\n  \"GENESIS GV70 1ST GEN\": HYUNDAI.GENESIS_GV70_1ST_GEN,\n  \"GENESIS G80 2017\": HYUNDAI.GENESIS_G80,\n  \"GENESIS G90 2017\": HYUNDAI.GENESIS_G90,\n  \"GENESIS GV80 2023\": HYUNDAI.GENESIS_GV80,\n  \"MAZDA CX-5\": MAZDA.MAZDA_CX5,\n  \"MAZDA CX-9\": MAZDA.MAZDA_CX9,\n  \"MAZDA 3\": MAZDA.MAZDA_3,\n  \"MAZDA 6\": MAZDA.MAZDA_6,\n  \"MAZDA CX-9 2021\": MAZDA.MAZDA_CX9_2021,\n  \"MAZDA CX-5 2022\": MAZDA.MAZDA_CX5_2022,\n  \"NISSAN X-TRAIL 2017\": NISSAN.NISSAN_XTRAIL,\n  \"NISSAN LEAF 2018\": NISSAN.NISSAN_LEAF,\n  \"NISSAN LEAF 2018 Instrument Cluster\": NISSAN.NISSAN_LEAF_IC,\n  \"NISSAN ROGUE 2019\": NISSAN.NISSAN_ROGUE,\n  \"NISSAN ALTIMA 2020\": NISSAN.NISSAN_ALTIMA,\n  \"SUBARU ASCENT LIMITED 2019\": SUBARU.SUBARU_ASCENT,\n  \"SUBARU OUTBACK 6TH GEN\": SUBARU.SUBARU_OUTBACK,\n  \"SUBARU LEGACY 7TH GEN\": SUBARU.SUBARU_LEGACY,\n  \"SUBARU IMPREZA LIMITED 2019\": SUBARU.SUBARU_IMPREZA,\n  \"SUBARU IMPREZA SPORT 2020\": SUBARU.SUBARU_IMPREZA_2020,\n  \"SUBARU CROSSTREK HYBRID 2020\": SUBARU.SUBARU_CROSSTREK_HYBRID,\n  \"SUBARU FORESTER 2019\": SUBARU.SUBARU_FORESTER,\n  \"SUBARU FORESTER HYBRID 2020\": SUBARU.SUBARU_FORESTER_HYBRID,\n  \"SUBARU FORESTER 2017 - 2018\": SUBARU.SUBARU_FORESTER_PREGLOBAL,\n  \"SUBARU LEGACY 2015 - 2018\": SUBARU.SUBARU_LEGACY_PREGLOBAL,\n  \"SUBARU OUTBACK 2015 - 2017\": SUBARU.SUBARU_OUTBACK_PREGLOBAL,\n  \"SUBARU OUTBACK 2018 - 2019\": SUBARU.SUBARU_OUTBACK_PREGLOBAL_2018,\n  \"SUBARU FORESTER 2022\": SUBARU.SUBARU_FORESTER_2022,\n  \"SUBARU OUTBACK 7TH GEN\": SUBARU.SUBARU_OUTBACK_2023,\n  \"SUBARU ASCENT 2023\": SUBARU.SUBARU_ASCENT_2023,\n  'TESLA AP1 MODEL S': TESLA.TESLA_AP1_MODELS,\n  'TESLA AP2 MODEL S': TESLA.TESLA_AP2_MODELS,\n  'TESLA MODEL S RAVEN': TESLA.TESLA_MODELS_RAVEN,\n  \"TOYOTA ALPHARD 2020\": TOYOTA.TOYOTA_ALPHARD_TSS2,\n  \"TOYOTA AVALON 2016\": TOYOTA.TOYOTA_AVALON,\n  \"TOYOTA AVALON 2019\": TOYOTA.TOYOTA_AVALON_2019,\n  \"TOYOTA AVALON 2022\": TOYOTA.TOYOTA_AVALON_TSS2,\n  \"TOYOTA CAMRY 2018\": TOYOTA.TOYOTA_CAMRY,\n  \"TOYOTA CAMRY 2021\": TOYOTA.TOYOTA_CAMRY_TSS2,\n  \"TOYOTA C-HR 2018\": TOYOTA.TOYOTA_CHR,\n  \"TOYOTA C-HR 2021\": TOYOTA.TOYOTA_CHR_TSS2,\n  \"TOYOTA COROLLA 2017\": TOYOTA.TOYOTA_COROLLA,\n  \"TOYOTA COROLLA TSS2 2019\": TOYOTA.TOYOTA_COROLLA_TSS2,\n  \"TOYOTA HIGHLANDER 2017\": TOYOTA.TOYOTA_HIGHLANDER,\n  \"TOYOTA HIGHLANDER 2020\": TOYOTA.TOYOTA_HIGHLANDER_TSS2,\n  \"TOYOTA PRIUS 2017\": TOYOTA.TOYOTA_PRIUS,\n  \"TOYOTA PRIUS v 2017\": TOYOTA.TOYOTA_PRIUS_V,\n  \"TOYOTA PRIUS TSS2 2021\": TOYOTA.TOYOTA_PRIUS_TSS2,\n  \"TOYOTA RAV4 2017\": TOYOTA.TOYOTA_RAV4,\n  \"TOYOTA RAV4 HYBRID 2017\": TOYOTA.TOYOTA_RAV4H,\n  \"TOYOTA RAV4 2019\": TOYOTA.TOYOTA_RAV4_TSS2,\n  \"TOYOTA RAV4 2022\": TOYOTA.TOYOTA_RAV4_TSS2_2022,\n  \"TOYOTA RAV4 2023\": TOYOTA.TOYOTA_RAV4_TSS2_2023,\n  \"TOYOTA MIRAI 2021\": TOYOTA.TOYOTA_MIRAI,\n  \"TOYOTA SIENNA 2018\": TOYOTA.TOYOTA_SIENNA,\n  \"LEXUS CT HYBRID 2018\": TOYOTA.LEXUS_CTH,\n  \"LEXUS ES 2018\": TOYOTA.LEXUS_ES,\n  \"LEXUS ES 2019\": TOYOTA.LEXUS_ES_TSS2,\n  \"LEXUS IS 2018\": TOYOTA.LEXUS_IS,\n  \"LEXUS IS 2023\": TOYOTA.LEXUS_IS_TSS2,\n  \"LEXUS NX 2018\": TOYOTA.LEXUS_NX,\n  \"LEXUS NX 2020\": TOYOTA.LEXUS_NX_TSS2,\n  \"LEXUS LC 2024\": TOYOTA.LEXUS_LC_TSS2,\n  \"LEXUS RC 2020\": TOYOTA.LEXUS_RC,\n  \"LEXUS RX 2016\": TOYOTA.LEXUS_RX,\n  \"LEXUS RX 2020\": TOYOTA.LEXUS_RX_TSS2,\n  \"LEXUS GS F 2016\": TOYOTA.LEXUS_GS_F,\n  \"VOLKSWAGEN ARTEON 1ST GEN\": VW.VOLKSWAGEN_ARTEON_MK1,\n  \"VOLKSWAGEN ATLAS 1ST GEN\": VW.VOLKSWAGEN_ATLAS_MK1,\n  \"VOLKSWAGEN CADDY 3RD GEN\": VW.VOLKSWAGEN_CADDY_MK3,\n  \"VOLKSWAGEN CRAFTER 2ND GEN\": VW.VOLKSWAGEN_CRAFTER_MK2,\n  \"VOLKSWAGEN GOLF 7TH GEN\": VW.VOLKSWAGEN_GOLF_MK7,\n  \"VOLKSWAGEN JETTA 7TH GEN\": VW.VOLKSWAGEN_JETTA_MK7,\n  \"VOLKSWAGEN PASSAT 8TH GEN\": VW.VOLKSWAGEN_PASSAT_MK8,\n  \"VOLKSWAGEN PASSAT NMS\": VW.VOLKSWAGEN_PASSAT_NMS,\n  \"VOLKSWAGEN POLO 6TH GEN\": VW.VOLKSWAGEN_POLO_MK6,\n  \"VOLKSWAGEN SHARAN 2ND GEN\": VW.VOLKSWAGEN_SHARAN_MK2,\n  \"VOLKSWAGEN TAOS 1ST GEN\": VW.VOLKSWAGEN_TAOS_MK1,\n  \"VOLKSWAGEN T-CROSS 1ST GEN\": VW.VOLKSWAGEN_TCROSS_MK1,\n  \"VOLKSWAGEN TIGUAN 2ND GEN\": VW.VOLKSWAGEN_TIGUAN_MK2,\n  \"VOLKSWAGEN TOURAN 2ND GEN\": VW.VOLKSWAGEN_TOURAN_MK2,\n  \"VOLKSWAGEN TRANSPORTER T6.1\": VW.VOLKSWAGEN_TRANSPORTER_T61,\n  \"VOLKSWAGEN T-ROC 1ST GEN\": VW.VOLKSWAGEN_TROC_MK1,\n  \"AUDI A3 3RD GEN\": VW.AUDI_A3_MK3,\n  \"AUDI Q2 1ST GEN\": VW.AUDI_Q2_MK1,\n  \"AUDI Q3 2ND GEN\": VW.AUDI_Q3_MK2,\n  \"SEAT ATECA 1ST GEN\": VW.SEAT_ATECA_MK1,\n  \"SEAT LEON 3RD GEN\": VW.SEAT_ATECA_MK1,\n  \"SEAT_LEON_MK3\": VW.SEAT_ATECA_MK1,\n  \"SKODA FABIA 4TH GEN\": VW.SKODA_FABIA_MK4,\n  \"SKODA KAMIQ 1ST GEN\": VW.SKODA_KAMIQ_MK1,\n  \"SKODA KAROQ 1ST GEN\": VW.SKODA_KAROQ_MK1,\n  \"SKODA KODIAQ 1ST GEN\": VW.SKODA_KODIAQ_MK1,\n  \"SKODA OCTAVIA 3RD GEN\": VW.SKODA_OCTAVIA_MK3,\n  \"SKODA SCALA 1ST GEN\": VW.SKODA_KAMIQ_MK1,\n  \"SKODA_SCALA_MK1\": VW.SKODA_KAMIQ_MK1,\n  \"SKODA SUPERB 3RD GEN\": VW.SKODA_SUPERB_MK3,\n\n  \"mock\": MOCK.MOCK,\n}\n", "selfdrive/car/interfaces.py": "import json\nimport os\nimport numpy as np\nimport tomllib\nfrom abc import abstractmethod, ABC\nfrom enum import StrEnum\nfrom typing import Any, NamedTuple\nfrom collections.abc import Callable\nfrom functools import cache\n\nfrom cereal import car\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.simple_kalman import KF1D, get_kalman_gain\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.car import apply_hysteresis, gen_empty_fingerprint, scale_rot_inertia, scale_tire_stiffness, STD_CARGO_KG\nfrom openpilot.selfdrive.car.values import PLATFORMS\nfrom openpilot.selfdrive.controls.lib.drive_helpers import V_CRUISE_MAX, get_friction\nfrom openpilot.selfdrive.controls.lib.events import Events\nfrom openpilot.selfdrive.controls.lib.vehicle_model import VehicleModel\n\nButtonType = car.CarState.ButtonEvent.Type\nGearShifter = car.CarState.GearShifter\nEventName = car.CarEvent.EventName\n\nMAX_CTRL_SPEED = (V_CRUISE_MAX + 4) * CV.KPH_TO_MS\nACCEL_MAX = 2.0\nACCEL_MIN = -3.5\nFRICTION_THRESHOLD = 0.3\n\nTORQUE_PARAMS_PATH = os.path.join(BASEDIR, 'selfdrive/car/torque_data/params.toml')\nTORQUE_OVERRIDE_PATH = os.path.join(BASEDIR, 'selfdrive/car/torque_data/override.toml')\nTORQUE_SUBSTITUTE_PATH = os.path.join(BASEDIR, 'selfdrive/car/torque_data/substitute.toml')\n\nGEAR_SHIFTER_MAP: dict[str, car.CarState.GearShifter] = {\n  'P': GearShifter.park, 'PARK': GearShifter.park,\n  'R': GearShifter.reverse, 'REVERSE': GearShifter.reverse,\n  'N': GearShifter.neutral, 'NEUTRAL': GearShifter.neutral,\n  'E': GearShifter.eco, 'ECO': GearShifter.eco,\n  'T': GearShifter.manumatic, 'MANUAL': GearShifter.manumatic,\n  'D': GearShifter.drive, 'DRIVE': GearShifter.drive,\n  'S': GearShifter.sport, 'SPORT': GearShifter.sport,\n  'L': GearShifter.low, 'LOW': GearShifter.low,\n  'B': GearShifter.brake, 'BRAKE': GearShifter.brake,\n}\n\n\nclass LatControlInputs(NamedTuple):\n  lateral_acceleration: float\n  roll_compensation: float\n  vego: float\n  aego: float\n\n\nTorqueFromLateralAccelCallbackType = Callable[[LatControlInputs, car.CarParams.LateralTorqueTuning, float, float, bool, bool], float]\n\n\n@cache\ndef get_torque_params():\n  with open(TORQUE_SUBSTITUTE_PATH, 'rb') as f:\n    sub = tomllib.load(f)\n  with open(TORQUE_PARAMS_PATH, 'rb') as f:\n    params = tomllib.load(f)\n  with open(TORQUE_OVERRIDE_PATH, 'rb') as f:\n    override = tomllib.load(f)\n\n  torque_params = {}\n  for candidate in (sub.keys() | params.keys() | override.keys()) - {'legend'}:\n    if sum([candidate in x for x in [sub, params, override]]) > 1:\n      raise RuntimeError(f'{candidate} is defined twice in torque config')\n\n    sub_candidate = sub.get(candidate, candidate)\n\n    if sub_candidate in override:\n      out = override[sub_candidate]\n    elif sub_candidate in params:\n      out = params[sub_candidate]\n    else:\n      raise NotImplementedError(f\"Did not find torque params for {sub_candidate}\")\n\n    torque_params[sub_candidate] = {key: out[i] for i, key in enumerate(params['legend'])}\n    if candidate in sub:\n      torque_params[candidate] = torque_params[sub_candidate]\n\n  return torque_params\n\n# generic car and radar interfaces\n\nclass CarInterfaceBase(ABC):\n  def __init__(self, CP, CarController, CarState):\n    self.CP = CP\n    self.VM = VehicleModel(CP)\n\n    self.frame = 0\n    self.steering_unpressed = 0\n    self.low_speed_alert = False\n    self.no_steer_warning = False\n    self.silent_steer_warning = True\n    self.v_ego_cluster_seen = False\n\n    self.CS = CarState(CP)\n    self.cp = self.CS.get_can_parser(CP)\n    self.cp_cam = self.CS.get_cam_can_parser(CP)\n    self.cp_adas = self.CS.get_adas_can_parser(CP)\n    self.cp_body = self.CS.get_body_can_parser(CP)\n    self.cp_loopback = self.CS.get_loopback_can_parser(CP)\n    self.can_parsers = [self.cp, self.cp_cam, self.cp_adas, self.cp_body, self.cp_loopback]\n\n    dbc_name = \"\" if self.cp is None else self.cp.dbc_name\n    self.CC: CarControllerBase = CarController(dbc_name, CP, self.VM)\n\n  def apply(self, c: car.CarControl, now_nanos: int) -> tuple[car.CarControl.Actuators, list[tuple[int, int, bytes, int]]]:\n    return self.CC.update(c, self.CS, now_nanos)\n\n  @staticmethod\n  def get_pid_accel_limits(CP, current_speed, cruise_speed):\n    return ACCEL_MIN, ACCEL_MAX\n\n  @classmethod\n  def get_non_essential_params(cls, candidate: str):\n    \"\"\"\n    Parameters essential to controlling the car may be incomplete or wrong without FW versions or fingerprints.\n    \"\"\"\n    return cls.get_params(candidate, gen_empty_fingerprint(), list(), False, False)\n\n  @classmethod\n  def get_params(cls, candidate: str, fingerprint: dict[int, dict[int, int]], car_fw: list[car.CarParams.CarFw], experimental_long: bool, docs: bool):\n    ret = CarInterfaceBase.get_std_params(candidate)\n\n    platform = PLATFORMS[candidate]\n    ret.mass = platform.config.specs.mass\n    ret.wheelbase = platform.config.specs.wheelbase\n    ret.steerRatio = platform.config.specs.steerRatio\n    ret.centerToFront = ret.wheelbase * platform.config.specs.centerToFrontRatio\n    ret.minEnableSpeed = platform.config.specs.minEnableSpeed\n    ret.minSteerSpeed = platform.config.specs.minSteerSpeed\n    ret.tireStiffnessFactor = platform.config.specs.tireStiffnessFactor\n    ret.flags |= int(platform.config.flags)\n\n    ret = cls._get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs)\n\n    # Vehicle mass is published curb weight plus assumed payload such as a human driver; notCars have no assumed payload\n    if not ret.notCar:\n      ret.mass = ret.mass + STD_CARGO_KG\n\n    # Set params dependent on values set by the car interface\n    ret.rotationalInertia = scale_rot_inertia(ret.mass, ret.wheelbase)\n    ret.tireStiffnessFront, ret.tireStiffnessRear = scale_tire_stiffness(ret.mass, ret.wheelbase, ret.centerToFront, ret.tireStiffnessFactor)\n\n    return ret\n\n  @staticmethod\n  @abstractmethod\n  def _get_params(ret: car.CarParams, candidate, fingerprint: dict[int, dict[int, int]],\n                  car_fw: list[car.CarParams.CarFw], experimental_long: bool, docs: bool):\n    raise NotImplementedError\n\n  @staticmethod\n  def init(CP, logcan, sendcan):\n    pass\n\n  @staticmethod\n  def get_steer_feedforward_default(desired_angle, v_ego):\n    # Proportional to realigning tire momentum: lateral acceleration.\n    return desired_angle * (v_ego**2)\n\n  def get_steer_feedforward_function(self):\n    return self.get_steer_feedforward_default\n\n  def torque_from_lateral_accel_linear(self, latcontrol_inputs: LatControlInputs, torque_params: car.CarParams.LateralTorqueTuning,\n                                       lateral_accel_error: float, lateral_accel_deadzone: float, friction_compensation: bool, gravity_adjusted: bool) -> float:\n    # The default is a linear relationship between torque and lateral acceleration (accounting for road roll and steering friction)\n    friction = get_friction(lateral_accel_error, lateral_accel_deadzone, FRICTION_THRESHOLD, torque_params, friction_compensation)\n    return (latcontrol_inputs.lateral_acceleration / float(torque_params.latAccelFactor)) + friction\n\n  def torque_from_lateral_accel(self) -> TorqueFromLateralAccelCallbackType:\n    return self.torque_from_lateral_accel_linear\n\n  # returns a set of default params to avoid repetition in car specific params\n  @staticmethod\n  def get_std_params(candidate):\n    ret = car.CarParams.new_message()\n    ret.carFingerprint = candidate\n\n    # Car docs fields\n    ret.maxLateralAccel = get_torque_params()[candidate]['MAX_LAT_ACCEL_MEASURED']\n    ret.autoResumeSng = True  # describes whether car can resume from a stop automatically\n\n    # standard ALC params\n    ret.tireStiffnessFactor = 1.0\n    ret.steerControlType = car.CarParams.SteerControlType.torque\n    ret.minSteerSpeed = 0.\n    ret.wheelSpeedFactor = 1.0\n\n    ret.pcmCruise = True     # openpilot's state is tied to the PCM's cruise state on most cars\n    ret.minEnableSpeed = -1. # enable is done by stock ACC, so ignore this\n    ret.steerRatioRear = 0.  # no rear steering, at least on the listed cars aboveA\n    ret.openpilotLongitudinalControl = False\n    ret.stopAccel = -2.0\n    ret.stoppingDecelRate = 0.8 # brake_travel/s while trying to stop\n    ret.vEgoStopping = 0.5\n    ret.vEgoStarting = 0.5\n    ret.stoppingControl = True\n    ret.longitudinalTuning.kf = 1.\n    ret.longitudinalTuning.kpBP = [0.]\n    ret.longitudinalTuning.kpV = [0.]\n    ret.longitudinalTuning.kiBP = [0.]\n    ret.longitudinalTuning.kiV = [0.]\n    # TODO estimate car specific lag, use .15s for now\n    ret.longitudinalActuatorDelay = 0.15\n    ret.steerLimitTimer = 1.0\n    return ret\n\n  @staticmethod\n  def configure_torque_tune(candidate, tune, steering_angle_deadzone_deg=0.0, use_steering_angle=True):\n    params = get_torque_params()[candidate]\n\n    tune.init('torque')\n    tune.torque.useSteeringAngle = use_steering_angle\n    tune.torque.kp = 1.0\n    tune.torque.kf = 1.0\n    tune.torque.ki = 0.1\n    tune.torque.friction = params['FRICTION']\n    tune.torque.latAccelFactor = params['LAT_ACCEL_FACTOR']\n    tune.torque.latAccelOffset = 0.0\n    tune.torque.steeringAngleDeadzoneDeg = steering_angle_deadzone_deg\n\n  @abstractmethod\n  def _update(self, c: car.CarControl) -> car.CarState:\n    pass\n\n  def update(self, c: car.CarControl, can_strings: list[bytes]) -> car.CarState:\n    # parse can\n    for cp in self.can_parsers:\n      if cp is not None:\n        cp.update_strings(can_strings)\n\n    # get CarState\n    ret = self._update(c)\n\n    ret.canValid = all(cp.can_valid for cp in self.can_parsers if cp is not None)\n    ret.canTimeout = any(cp.bus_timeout for cp in self.can_parsers if cp is not None)\n\n    if ret.vEgoCluster == 0.0 and not self.v_ego_cluster_seen:\n      ret.vEgoCluster = ret.vEgo\n    else:\n      self.v_ego_cluster_seen = True\n\n    # Many cars apply hysteresis to the ego dash speed\n    if self.CS is not None:\n      ret.vEgoCluster = apply_hysteresis(ret.vEgoCluster, self.CS.out.vEgoCluster, self.CS.cluster_speed_hyst_gap)\n      if abs(ret.vEgo) < self.CS.cluster_min_speed:\n        ret.vEgoCluster = 0.0\n\n    if ret.cruiseState.speedCluster == 0:\n      ret.cruiseState.speedCluster = ret.cruiseState.speed\n\n    # copy back for next iteration\n    if self.CS is not None:\n      self.CS.out = ret.as_reader()\n\n    return ret\n\n\n  def create_common_events(self, cs_out, extra_gears=None, pcm_enable=True, allow_enable=True,\n                           enable_buttons=(ButtonType.accelCruise, ButtonType.decelCruise)):\n    events = Events()\n\n    if cs_out.doorOpen:\n      events.add(EventName.doorOpen)\n    if cs_out.seatbeltUnlatched:\n      events.add(EventName.seatbeltNotLatched)\n    if cs_out.gearShifter != GearShifter.drive and (extra_gears is None or\n       cs_out.gearShifter not in extra_gears):\n      events.add(EventName.wrongGear)\n    if cs_out.gearShifter == GearShifter.reverse:\n      events.add(EventName.reverseGear)\n    if not cs_out.cruiseState.available:\n      events.add(EventName.wrongCarMode)\n    if cs_out.espDisabled:\n      events.add(EventName.espDisabled)\n    if cs_out.espActive:\n      events.add(EventName.espActive)\n    if cs_out.stockFcw:\n      events.add(EventName.stockFcw)\n    if cs_out.stockAeb:\n      events.add(EventName.stockAeb)\n    if cs_out.vEgo > MAX_CTRL_SPEED:\n      events.add(EventName.speedTooHigh)\n    if cs_out.cruiseState.nonAdaptive:\n      events.add(EventName.wrongCruiseMode)\n    if cs_out.brakeHoldActive and self.CP.openpilotLongitudinalControl:\n      events.add(EventName.brakeHold)\n    if cs_out.parkingBrake:\n      events.add(EventName.parkBrake)\n    if cs_out.accFaulted:\n      events.add(EventName.accFaulted)\n    if cs_out.steeringPressed:\n      events.add(EventName.steerOverride)\n    if cs_out.brakePressed and cs_out.standstill:\n      events.add(EventName.preEnableStandstill)\n    if cs_out.gasPressed:\n      events.add(EventName.gasPressedOverride)\n\n    # Handle button presses\n    for b in cs_out.buttonEvents:\n      # Enable OP long on falling edge of enable buttons (defaults to accelCruise and decelCruise, overridable per-port)\n      if not self.CP.pcmCruise and (b.type in enable_buttons and not b.pressed):\n        events.add(EventName.buttonEnable)\n      # Disable on rising and falling edge of cancel for both stock and OP long\n      if b.type == ButtonType.cancel:\n        events.add(EventName.buttonCancel)\n\n    # Handle permanent and temporary steering faults\n    self.steering_unpressed = 0 if cs_out.steeringPressed else self.steering_unpressed + 1\n    if cs_out.steerFaultTemporary:\n      if cs_out.steeringPressed and (not self.CS.out.steerFaultTemporary or self.no_steer_warning):\n        self.no_steer_warning = True\n      else:\n        self.no_steer_warning = False\n\n        # if the user overrode recently, show a less harsh alert\n        if self.silent_steer_warning or cs_out.standstill or self.steering_unpressed < int(1.5 / DT_CTRL):\n          self.silent_steer_warning = True\n          events.add(EventName.steerTempUnavailableSilent)\n        else:\n          events.add(EventName.steerTempUnavailable)\n    else:\n      self.no_steer_warning = False\n      self.silent_steer_warning = False\n    if cs_out.steerFaultPermanent:\n      events.add(EventName.steerUnavailable)\n\n    # we engage when pcm is active (rising edge)\n    # enabling can optionally be blocked by the car interface\n    if pcm_enable:\n      if cs_out.cruiseState.enabled and not self.CS.out.cruiseState.enabled and allow_enable:\n        events.add(EventName.pcmEnable)\n      elif not cs_out.cruiseState.enabled:\n        events.add(EventName.pcmDisable)\n\n    return events\n\n\nclass RadarInterfaceBase(ABC):\n  def __init__(self, CP):\n    self.rcp = None\n    self.pts = {}\n    self.delay = 0\n    self.radar_ts = CP.radarTimeStep\n    self.frame = 0\n\n  def update(self, can_strings):\n    self.frame += 1\n    if (self.frame % int(100 * self.radar_ts)) == 0:\n      return car.RadarData.new_message()\n    return None\n\n\nclass CarStateBase(ABC):\n  def __init__(self, CP):\n    self.CP = CP\n    self.car_fingerprint = CP.carFingerprint\n    self.out = car.CarState.new_message()\n\n    self.cruise_buttons = 0\n    self.left_blinker_cnt = 0\n    self.right_blinker_cnt = 0\n    self.steering_pressed_cnt = 0\n    self.left_blinker_prev = False\n    self.right_blinker_prev = False\n    self.cluster_speed_hyst_gap = 0.0\n    self.cluster_min_speed = 0.0  # min speed before dropping to 0\n\n    Q = [[0.0, 0.0], [0.0, 100.0]]\n    R = 0.3\n    A = [[1.0, DT_CTRL], [0.0, 1.0]]\n    C = [[1.0, 0.0]]\n    x0=[[0.0], [0.0]]\n    K = get_kalman_gain(DT_CTRL, np.array(A), np.array(C), np.array(Q), R)\n    self.v_ego_kf = KF1D(x0=x0, A=A, C=C[0], K=K)\n\n  def update_speed_kf(self, v_ego_raw):\n    if abs(v_ego_raw - self.v_ego_kf.x[0][0]) > 2.0:  # Prevent large accelerations when car starts at non zero speed\n      self.v_ego_kf.set_x([[v_ego_raw], [0.0]])\n\n    v_ego_x = self.v_ego_kf.update(v_ego_raw)\n    return float(v_ego_x[0]), float(v_ego_x[1])\n\n  def get_wheel_speeds(self, fl, fr, rl, rr, unit=CV.KPH_TO_MS):\n    factor = unit * self.CP.wheelSpeedFactor\n\n    wheelSpeeds = car.CarState.WheelSpeeds.new_message()\n    wheelSpeeds.fl = fl * factor\n    wheelSpeeds.fr = fr * factor\n    wheelSpeeds.rl = rl * factor\n    wheelSpeeds.rr = rr * factor\n    return wheelSpeeds\n\n  def update_blinker_from_lamp(self, blinker_time: int, left_blinker_lamp: bool, right_blinker_lamp: bool):\n    \"\"\"Update blinkers from lights. Enable output when light was seen within the last `blinker_time`\n    iterations\"\"\"\n    # TODO: Handle case when switching direction. Now both blinkers can be on at the same time\n    self.left_blinker_cnt = blinker_time if left_blinker_lamp else max(self.left_blinker_cnt - 1, 0)\n    self.right_blinker_cnt = blinker_time if right_blinker_lamp else max(self.right_blinker_cnt - 1, 0)\n    return self.left_blinker_cnt > 0, self.right_blinker_cnt > 0\n\n  def update_steering_pressed(self, steering_pressed, steering_pressed_min_count):\n    \"\"\"Applies filtering on steering pressed for noisy driver torque signals.\"\"\"\n    self.steering_pressed_cnt += 1 if steering_pressed else -1\n    self.steering_pressed_cnt = clip(self.steering_pressed_cnt, 0, steering_pressed_min_count * 2)\n    return self.steering_pressed_cnt > steering_pressed_min_count\n\n  def update_blinker_from_stalk(self, blinker_time: int, left_blinker_stalk: bool, right_blinker_stalk: bool):\n    \"\"\"Update blinkers from stalk position. When stalk is seen the blinker will be on for at least blinker_time,\n    or until the stalk is turned off, whichever is longer. If the opposite stalk direction is seen the blinker\n    is forced to the other side. On a rising edge of the stalk the timeout is reset.\"\"\"\n\n    if left_blinker_stalk:\n      self.right_blinker_cnt = 0\n      if not self.left_blinker_prev:\n        self.left_blinker_cnt = blinker_time\n\n    if right_blinker_stalk:\n      self.left_blinker_cnt = 0\n      if not self.right_blinker_prev:\n        self.right_blinker_cnt = blinker_time\n\n    self.left_blinker_cnt = max(self.left_blinker_cnt - 1, 0)\n    self.right_blinker_cnt = max(self.right_blinker_cnt - 1, 0)\n\n    self.left_blinker_prev = left_blinker_stalk\n    self.right_blinker_prev = right_blinker_stalk\n\n    return bool(left_blinker_stalk or self.left_blinker_cnt > 0), bool(right_blinker_stalk or self.right_blinker_cnt > 0)\n\n  @staticmethod\n  def parse_gear_shifter(gear: str | None) -> car.CarState.GearShifter:\n    if gear is None:\n      return GearShifter.unknown\n    return GEAR_SHIFTER_MAP.get(gear.upper(), GearShifter.unknown)\n\n  @staticmethod\n  def get_can_parser(CP):\n    return None\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    return None\n\n  @staticmethod\n  def get_adas_can_parser(CP):\n    return None\n\n  @staticmethod\n  def get_body_can_parser(CP):\n    return None\n\n  @staticmethod\n  def get_loopback_can_parser(CP):\n    return None\n\n\nSendCan = tuple[int, int, bytes, int]\n\n\nclass CarControllerBase(ABC):\n  def __init__(self, dbc_name: str, CP, VM):\n    pass\n\n  @abstractmethod\n  def update(self, CC: car.CarControl.Actuators, CS: car.CarState, now_nanos: int) -> tuple[car.CarControl.Actuators, list[SendCan]]:\n    pass\n\n\nINTERFACE_ATTR_FILE = {\n  \"FINGERPRINTS\": \"fingerprints\",\n  \"FW_VERSIONS\": \"fingerprints\",\n}\n\n# interface-specific helpers\n\ndef get_interface_attr(attr: str, combine_brands: bool = False, ignore_none: bool = False) -> dict[str | StrEnum, Any]:\n  # read all the folders in selfdrive/car and return a dict where:\n  # - keys are all the car models or brand names\n  # - values are attr values from all car folders\n  result = {}\n  for car_folder in sorted([x[0] for x in os.walk(BASEDIR + '/selfdrive/car')]):\n    try:\n      brand_name = car_folder.split('/')[-1]\n      brand_values = __import__(f'openpilot.selfdrive.car.{brand_name}.{INTERFACE_ATTR_FILE.get(attr, \"values\")}', fromlist=[attr])\n      if hasattr(brand_values, attr) or not ignore_none:\n        attr_data = getattr(brand_values, attr, None)\n      else:\n        continue\n\n      if combine_brands:\n        if isinstance(attr_data, dict):\n          for f, v in attr_data.items():\n            result[f] = v\n      else:\n        result[brand_name] = attr_data\n    except (ImportError, OSError):\n      pass\n\n  return result\n\n\nclass NanoFFModel:\n  def __init__(self, weights_loc: str, platform: str):\n    self.weights_loc = weights_loc\n    self.platform = platform\n    self.load_weights(platform)\n\n  def load_weights(self, platform: str):\n    with open(self.weights_loc) as fob:\n      self.weights = {k: np.array(v) for k, v in json.load(fob)[platform].items()}\n\n  def relu(self, x: np.ndarray):\n    return np.maximum(0.0, x)\n\n  def forward(self, x: np.ndarray):\n    assert x.ndim == 1\n    x = (x - self.weights['input_norm_mat'][:, 0]) / (self.weights['input_norm_mat'][:, 1] - self.weights['input_norm_mat'][:, 0])\n    x = self.relu(np.dot(x, self.weights['w_1']) + self.weights['b_1'])\n    x = self.relu(np.dot(x, self.weights['w_2']) + self.weights['b_2'])\n    x = self.relu(np.dot(x, self.weights['w_3']) + self.weights['b_3'])\n    x = np.dot(x, self.weights['w_4']) + self.weights['b_4']\n    return x\n\n  def predict(self, x: list[float], do_sample: bool = False):\n    x = self.forward(np.array(x))\n    if do_sample:\n      pred = np.random.laplace(x[0], np.exp(x[1]) / self.weights['temperature'])\n    else:\n      pred = x[0]\n    pred = pred * (self.weights['output_norm_mat'][1] - self.weights['output_norm_mat'][0]) + self.weights['output_norm_mat'][0]\n    return pred\n", "selfdrive/car/car_helpers.py": "import os\nimport time\nfrom collections.abc import Callable\n\nfrom cereal import car\nfrom openpilot.common.params import Params\nfrom openpilot.selfdrive.car.interfaces import get_interface_attr\nfrom openpilot.selfdrive.car.fingerprints import eliminate_incompatible_cars, all_legacy_fingerprint_cars\nfrom openpilot.selfdrive.car.vin import get_vin, is_valid_vin, VIN_UNKNOWN\nfrom openpilot.selfdrive.car.fw_versions import get_fw_versions_ordered, get_present_ecus, match_fw_to_car, set_obd_multiplexing\nfrom openpilot.selfdrive.car.mock.values import CAR as MOCK\nfrom openpilot.common.swaglog import cloudlog\nimport cereal.messaging as messaging\nfrom openpilot.selfdrive.car import gen_empty_fingerprint\nfrom openpilot.system.version import get_build_metadata\n\nFRAME_FINGERPRINT = 100  # 1s\n\nEventName = car.CarEvent.EventName\n\n\ndef get_startup_event(car_recognized, controller_available, fw_seen):\n  build_metadata = get_build_metadata()\n  if build_metadata.openpilot.comma_remote and build_metadata.tested_channel:\n    event = EventName.startup\n  else:\n    event = EventName.startupMaster\n\n  if not car_recognized:\n    if fw_seen:\n      event = EventName.startupNoCar\n    else:\n      event = EventName.startupNoFw\n  elif car_recognized and not controller_available:\n    event = EventName.startupNoControl\n  return event\n\n\ndef get_one_can(logcan):\n  while True:\n    can = messaging.recv_one_retry(logcan)\n    if len(can.can) > 0:\n      return can\n\n\ndef load_interfaces(brand_names):\n  ret = {}\n  for brand_name in brand_names:\n    path = f'openpilot.selfdrive.car.{brand_name}'\n    CarInterface = __import__(path + '.interface', fromlist=['CarInterface']).CarInterface\n    CarState = __import__(path + '.carstate', fromlist=['CarState']).CarState\n    CarController = __import__(path + '.carcontroller', fromlist=['CarController']).CarController\n    for model_name in brand_names[brand_name]:\n      ret[model_name] = (CarInterface, CarController, CarState)\n  return ret\n\n\ndef _get_interface_names() -> dict[str, list[str]]:\n  # returns a dict of brand name and its respective models\n  brand_names = {}\n  for brand_name, brand_models in get_interface_attr(\"CAR\").items():\n    brand_names[brand_name] = [model.value for model in brand_models]\n\n  return brand_names\n\n\n# imports from directory selfdrive/car/<name>/\ninterface_names = _get_interface_names()\ninterfaces = load_interfaces(interface_names)\n\n\ndef can_fingerprint(next_can: Callable) -> tuple[str | None, dict[int, dict]]:\n  finger = gen_empty_fingerprint()\n  candidate_cars = {i: all_legacy_fingerprint_cars() for i in [0, 1]}  # attempt fingerprint on both bus 0 and 1\n  frame = 0\n  car_fingerprint = None\n  done = False\n\n  while not done:\n    a = next_can()\n\n    for can in a.can:\n      # The fingerprint dict is generated for all buses, this way the car interface\n      # can use it to detect a (valid) multipanda setup and initialize accordingly\n      if can.src < 128:\n        if can.src not in finger:\n          finger[can.src] = {}\n        finger[can.src][can.address] = len(can.dat)\n\n      for b in candidate_cars:\n        # Ignore extended messages and VIN query response.\n        if can.src == b and can.address < 0x800 and can.address not in (0x7df, 0x7e0, 0x7e8):\n          candidate_cars[b] = eliminate_incompatible_cars(can, candidate_cars[b])\n\n    # if we only have one car choice and the time since we got our first\n    # message has elapsed, exit\n    for b in candidate_cars:\n      if len(candidate_cars[b]) == 1 and frame > FRAME_FINGERPRINT:\n        # fingerprint done\n        car_fingerprint = candidate_cars[b][0]\n\n    # bail if no cars left or we've been waiting for more than 2s\n    failed = (all(len(cc) == 0 for cc in candidate_cars.values()) and frame > FRAME_FINGERPRINT) or frame > 200\n    succeeded = car_fingerprint is not None\n    done = failed or succeeded\n\n    frame += 1\n\n  return car_fingerprint, finger\n\n\n# **** for use live only ****\ndef fingerprint(logcan, sendcan, num_pandas):\n  fixed_fingerprint = os.environ.get('FINGERPRINT', \"\")\n  skip_fw_query = os.environ.get('SKIP_FW_QUERY', False)\n  disable_fw_cache = os.environ.get('DISABLE_FW_CACHE', False)\n  ecu_rx_addrs = set()\n  params = Params()\n\n  start_time = time.monotonic()\n  if not skip_fw_query:\n    cached_params = params.get(\"CarParamsCache\")\n    if cached_params is not None:\n      with car.CarParams.from_bytes(cached_params) as cached_params:\n        if cached_params.carName == \"mock\":\n          cached_params = None\n\n    if cached_params is not None and len(cached_params.carFw) > 0 and \\\n       cached_params.carVin is not VIN_UNKNOWN and not disable_fw_cache:\n      cloudlog.warning(\"Using cached CarParams\")\n      vin_rx_addr, vin_rx_bus, vin = -1, -1, cached_params.carVin\n      car_fw = list(cached_params.carFw)\n      cached = True\n    else:\n      cloudlog.warning(\"Getting VIN & FW versions\")\n      # enable OBD multiplexing for VIN query\n      # NOTE: this takes ~0.1s and is relied on to allow sendcan subscriber to connect in time\n      set_obd_multiplexing(params, True)\n      # VIN query only reliably works through OBDII\n      vin_rx_addr, vin_rx_bus, vin = get_vin(logcan, sendcan, (0, 1))\n      ecu_rx_addrs = get_present_ecus(logcan, sendcan, num_pandas=num_pandas)\n      car_fw = get_fw_versions_ordered(logcan, sendcan, vin, ecu_rx_addrs, num_pandas=num_pandas)\n      cached = False\n\n    exact_fw_match, fw_candidates = match_fw_to_car(car_fw, vin)\n  else:\n    vin_rx_addr, vin_rx_bus, vin = -1, -1, VIN_UNKNOWN\n    exact_fw_match, fw_candidates, car_fw = True, set(), []\n    cached = False\n\n  if not is_valid_vin(vin):\n    cloudlog.event(\"Malformed VIN\", vin=vin, error=True)\n    vin = VIN_UNKNOWN\n  cloudlog.warning(\"VIN %s\", vin)\n  params.put(\"CarVin\", vin)\n\n  # disable OBD multiplexing for CAN fingerprinting and potential ECU knockouts\n  set_obd_multiplexing(params, False)\n  params.put_bool(\"FirmwareQueryDone\", True)\n\n  fw_query_time = time.monotonic() - start_time\n\n  # CAN fingerprint\n  # drain CAN socket so we get the latest messages\n  messaging.drain_sock_raw(logcan)\n  car_fingerprint, finger = can_fingerprint(lambda: get_one_can(logcan))\n\n  exact_match = True\n  source = car.CarParams.FingerprintSource.can\n\n  # If FW query returns exactly 1 candidate, use it\n  if len(fw_candidates) == 1:\n    car_fingerprint = list(fw_candidates)[0]\n    source = car.CarParams.FingerprintSource.fw\n    exact_match = exact_fw_match\n\n  if fixed_fingerprint:\n    car_fingerprint = fixed_fingerprint\n    source = car.CarParams.FingerprintSource.fixed\n\n  cloudlog.event(\"fingerprinted\", car_fingerprint=car_fingerprint, source=source, fuzzy=not exact_match, cached=cached,\n                 fw_count=len(car_fw), ecu_responses=list(ecu_rx_addrs), vin_rx_addr=vin_rx_addr, vin_rx_bus=vin_rx_bus,\n                 fingerprints=repr(finger), fw_query_time=fw_query_time, error=True)\n\n  return car_fingerprint, finger, vin, car_fw, source, exact_match\n\n\ndef get_car_interface(CP):\n  CarInterface, CarController, CarState = interfaces[CP.carFingerprint]\n  return CarInterface(CP, CarController, CarState)\n\n\ndef get_car(logcan, sendcan, experimental_long_allowed, num_pandas=1):\n  candidate, fingerprints, vin, car_fw, source, exact_match = fingerprint(logcan, sendcan, num_pandas)\n\n  if candidate is None:\n    cloudlog.event(\"car doesn't match any fingerprints\", fingerprints=repr(fingerprints), error=True)\n    candidate = \"MOCK\"\n\n  CarInterface, _, _ = interfaces[candidate]\n  CP = CarInterface.get_params(candidate, fingerprints, car_fw, experimental_long_allowed, docs=False)\n  CP.carVin = vin\n  CP.carFw = car_fw\n  CP.fingerprintSource = source\n  CP.fuzzyFingerprint = not exact_match\n\n  return get_car_interface(CP), CP\n\ndef write_car_param(platform=MOCK.MOCK):\n  params = Params()\n  CarInterface, _, _ = interfaces[platform]\n  CP = CarInterface.get_non_essential_params(platform)\n  params.put(\"CarParams\", CP.to_bytes())\n\ndef get_demo_car_params():\n  platform = MOCK.MOCK\n  CarInterface, _, _ = interfaces[platform]\n  CP = CarInterface.get_non_essential_params(platform)\n  return CP\n", "selfdrive/car/values.py": "from typing import get_args\nfrom openpilot.selfdrive.car.body.values import CAR as BODY\nfrom openpilot.selfdrive.car.chrysler.values import CAR as CHRYSLER\nfrom openpilot.selfdrive.car.ford.values import CAR as FORD\nfrom openpilot.selfdrive.car.gm.values import CAR as GM\nfrom openpilot.selfdrive.car.honda.values import CAR as HONDA\nfrom openpilot.selfdrive.car.hyundai.values import CAR as HYUNDAI\nfrom openpilot.selfdrive.car.mazda.values import CAR as MAZDA\nfrom openpilot.selfdrive.car.mock.values import CAR as MOCK\nfrom openpilot.selfdrive.car.nissan.values import CAR as NISSAN\nfrom openpilot.selfdrive.car.subaru.values import CAR as SUBARU\nfrom openpilot.selfdrive.car.tesla.values import CAR as TESLA\nfrom openpilot.selfdrive.car.toyota.values import CAR as TOYOTA\nfrom openpilot.selfdrive.car.volkswagen.values import CAR as VOLKSWAGEN\n\nPlatform = BODY | CHRYSLER | FORD | GM | HONDA | HYUNDAI | MAZDA | MOCK | NISSAN | SUBARU | TESLA | TOYOTA | VOLKSWAGEN\nBRANDS = get_args(Platform)\n\nPLATFORMS: dict[str, Platform] = {str(platform): platform for brand in BRANDS for platform in brand}\n", "selfdrive/car/card.py": "#!/usr/bin/env python3\nimport os\nimport time\n\nimport cereal.messaging as messaging\n\nfrom cereal import car\n\nfrom panda import ALTERNATIVE_EXPERIENCE\n\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import config_realtime_process, Priority, Ratekeeper, DT_CTRL\n\nfrom openpilot.selfdrive.pandad import can_list_to_can_capnp\nfrom openpilot.selfdrive.car.car_helpers import get_car, get_one_can\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.controls.lib.events import Events\n\nREPLAY = \"REPLAY\" in os.environ\n\nEventName = car.CarEvent.EventName\n\n\nclass Car:\n  CI: CarInterfaceBase\n\n  def __init__(self, CI=None):\n    self.can_sock = messaging.sub_sock('can', timeout=20)\n    self.sm = messaging.SubMaster(['pandaStates', 'carControl', 'onroadEvents'])\n    self.pm = messaging.PubMaster(['sendcan', 'carState', 'carParams', 'carOutput'])\n\n    self.can_rcv_cum_timeout_counter = 0\n\n    self.CC_prev = car.CarControl.new_message()\n    self.CS_prev = car.CarState.new_message()\n    self.initialized_prev = False\n\n    self.last_actuators_output = car.CarControl.Actuators.new_message()\n\n    self.params = Params()\n\n    if CI is None:\n      # wait for one pandaState and one CAN packet\n      print(\"Waiting for CAN messages...\")\n      get_one_can(self.can_sock)\n\n      num_pandas = len(messaging.recv_one_retry(self.sm.sock['pandaStates']).pandaStates)\n      experimental_long_allowed = self.params.get_bool(\"ExperimentalLongitudinalEnabled\")\n      self.CI, self.CP = get_car(self.can_sock, self.pm.sock['sendcan'], experimental_long_allowed, num_pandas)\n    else:\n      self.CI, self.CP = CI, CI.CP\n\n    # set alternative experiences from parameters\n    self.disengage_on_accelerator = self.params.get_bool(\"DisengageOnAccelerator\")\n    self.CP.alternativeExperience = 0\n    if not self.disengage_on_accelerator:\n      self.CP.alternativeExperience |= ALTERNATIVE_EXPERIENCE.DISABLE_DISENGAGE_ON_GAS\n\n    openpilot_enabled_toggle = self.params.get_bool(\"OpenpilotEnabledToggle\")\n\n    controller_available = self.CI.CC is not None and openpilot_enabled_toggle and not self.CP.dashcamOnly\n\n    self.CP.passive = not controller_available or self.CP.dashcamOnly\n    if self.CP.passive:\n      safety_config = car.CarParams.SafetyConfig.new_message()\n      safety_config.safetyModel = car.CarParams.SafetyModel.noOutput\n      self.CP.safetyConfigs = [safety_config]\n\n    # Write previous route's CarParams\n    prev_cp = self.params.get(\"CarParamsPersistent\")\n    if prev_cp is not None:\n      self.params.put(\"CarParamsPrevRoute\", prev_cp)\n\n    # Write CarParams for controls and radard\n    cp_bytes = self.CP.to_bytes()\n    self.params.put(\"CarParams\", cp_bytes)\n    self.params.put_nonblocking(\"CarParamsCache\", cp_bytes)\n    self.params.put_nonblocking(\"CarParamsPersistent\", cp_bytes)\n\n    self.events = Events()\n\n    # card is driven by can recv, expected at 100Hz\n    self.rk = Ratekeeper(100, print_delay_threshold=None)\n\n  def state_update(self) -> car.CarState:\n    \"\"\"carState update loop, driven by can\"\"\"\n\n    # Update carState from CAN\n    can_strs = messaging.drain_sock_raw(self.can_sock, wait_for_one=True)\n    CS = self.CI.update(self.CC_prev, can_strs)\n\n    self.sm.update(0)\n\n    can_rcv_valid = len(can_strs) > 0\n\n    # Check for CAN timeout\n    if not can_rcv_valid:\n      self.can_rcv_cum_timeout_counter += 1\n\n    if can_rcv_valid and REPLAY:\n      self.can_log_mono_time = messaging.log_from_bytes(can_strs[0]).logMonoTime\n\n    return CS\n\n  def update_events(self, CS: car.CarState) -> car.CarState:\n    self.events.clear()\n\n    self.events.add_from_msg(CS.events)\n\n    # Disable on rising edge of accelerator or brake. Also disable on brake when speed > 0\n    if (CS.gasPressed and not self.CS_prev.gasPressed and self.disengage_on_accelerator) or \\\n      (CS.brakePressed and (not self.CS_prev.brakePressed or not CS.standstill)) or \\\n      (CS.regenBraking and (not self.CS_prev.regenBraking or not CS.standstill)):\n      self.events.add(EventName.pedalPressed)\n\n    CS.events = self.events.to_msg()\n\n  def state_publish(self, CS: car.CarState):\n    \"\"\"carState and carParams publish loop\"\"\"\n\n    # carParams - logged every 50 seconds (> 1 per segment)\n    if self.sm.frame % int(50. / DT_CTRL) == 0:\n      cp_send = messaging.new_message('carParams')\n      cp_send.valid = True\n      cp_send.carParams = self.CP\n      self.pm.send('carParams', cp_send)\n\n    # publish new carOutput\n    co_send = messaging.new_message('carOutput')\n    co_send.valid = self.sm.all_checks(['carControl'])\n    co_send.carOutput.actuatorsOutput = self.last_actuators_output\n    self.pm.send('carOutput', co_send)\n\n    # kick off controlsd step while we actuate the latest carControl packet\n    cs_send = messaging.new_message('carState')\n    cs_send.valid = CS.canValid\n    cs_send.carState = CS\n    cs_send.carState.canErrorCounter = self.can_rcv_cum_timeout_counter\n    cs_send.carState.cumLagMs = -self.rk.remaining * 1000.\n    self.pm.send('carState', cs_send)\n\n  def controls_update(self, CS: car.CarState, CC: car.CarControl):\n    \"\"\"control update loop, driven by carControl\"\"\"\n\n    if not self.initialized_prev:\n      # Initialize CarInterface, once controls are ready\n      # TODO: this can make us miss at least a few cycles when doing an ECU knockout\n      self.CI.init(self.CP, self.can_sock, self.pm.sock['sendcan'])\n      # signal pandad to switch to car safety mode\n      self.params.put_bool_nonblocking(\"ControlsReady\", True)\n\n    if self.sm.all_alive(['carControl']):\n      # send car controls over can\n      now_nanos = self.can_log_mono_time if REPLAY else int(time.monotonic() * 1e9)\n      self.last_actuators_output, can_sends = self.CI.apply(CC, now_nanos)\n      self.pm.send('sendcan', can_list_to_can_capnp(can_sends, msgtype='sendcan', valid=CS.canValid))\n\n      self.CC_prev = CC\n\n  def step(self):\n    CS = self.state_update()\n\n    self.update_events(CS)\n\n    self.state_publish(CS)\n\n    initialized = (not any(e.name == EventName.controlsInitializing for e in self.sm['onroadEvents']) and\n                   self.sm.seen['onroadEvents'])\n    if not self.CP.passive and initialized:\n      self.controls_update(CS, self.sm['carControl'])\n\n    self.initialized_prev = initialized\n    self.CS_prev = CS.as_reader()\n\n  def card_thread(self):\n    while True:\n      self.step()\n      self.rk.monitor_time()\n\n\ndef main():\n  config_realtime_process(4, Priority.CTRL_HIGH)\n  car = Car()\n  car.card_thread()\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/car/vin.py": "#!/usr/bin/env python3\nimport re\n\nimport cereal.messaging as messaging\nfrom panda.python.uds import get_rx_addr_for_tx_addr, FUNCTIONAL_ADDRS\nfrom openpilot.selfdrive.car.isotp_parallel_query import IsoTpParallelQuery\nfrom openpilot.selfdrive.car.fw_query_definitions import STANDARD_VIN_ADDRS, StdQueries\nfrom openpilot.common.swaglog import cloudlog\n\nVIN_UNKNOWN = \"0\" * 17\nVIN_RE = \"[A-HJ-NPR-Z0-9]{17}\"\n\n\ndef is_valid_vin(vin: str):\n  return re.fullmatch(VIN_RE, vin) is not None\n\n\ndef get_vin(logcan, sendcan, buses, timeout=0.1, retry=2, debug=False):\n  for i in range(retry):\n    for bus in buses:\n      for request, response, valid_buses, vin_addrs, functional_addrs, rx_offset in (\n        (StdQueries.UDS_VIN_REQUEST, StdQueries.UDS_VIN_RESPONSE, (0, 1), STANDARD_VIN_ADDRS, FUNCTIONAL_ADDRS, 0x8),\n        (StdQueries.OBD_VIN_REQUEST, StdQueries.OBD_VIN_RESPONSE, (0, 1), STANDARD_VIN_ADDRS, FUNCTIONAL_ADDRS, 0x8),\n        (StdQueries.GM_VIN_REQUEST, StdQueries.GM_VIN_RESPONSE, (0,), [0x24b], None, 0x400),  # Bolt fwdCamera\n        (StdQueries.KWP_VIN_REQUEST, StdQueries.KWP_VIN_RESPONSE, (0,), [0x797], None, 0x3),  # Nissan Leaf VCM\n        (StdQueries.UDS_VIN_REQUEST, StdQueries.UDS_VIN_RESPONSE, (0,), [0x74f], None, 0x6a),  # Volkswagen fwdCamera\n      ):\n        if bus not in valid_buses:\n          continue\n\n        # When querying functional addresses, ideally we respond to everything that sends a first frame to avoid leaving the\n        # ECU in a temporary bad state. Note that we may not cover all ECUs and response offsets. TODO: query physical addrs\n        tx_addrs = vin_addrs\n        if functional_addrs is not None:\n          tx_addrs = [a for a in range(0x700, 0x800) if a != 0x7DF] + list(range(0x18DA00F1, 0x18DB00F1, 0x100))\n\n        try:\n          query = IsoTpParallelQuery(sendcan, logcan, bus, tx_addrs, [request, ], [response, ], response_offset=rx_offset,\n                                     functional_addrs=functional_addrs, debug=debug)\n          results = query.get_data(timeout)\n\n          for addr in vin_addrs:\n            vin = results.get((addr, None))\n            if vin is not None:\n              # Ford and Nissan pads with null bytes\n              if len(vin) in (19, 24):\n                vin = re.sub(b'\\x00*$', b'', vin)\n\n              # Honda Bosch response starts with a length, trim to correct length\n              if vin.startswith(b'\\x11'):\n                vin = vin[1:18]\n\n              cloudlog.error(f\"got vin with {request=}\")\n              return get_rx_addr_for_tx_addr(addr, rx_offset=rx_offset), bus, vin.decode()\n        except Exception:\n          cloudlog.exception(\"VIN query exception\")\n\n    cloudlog.error(f\"vin query retry ({i+1}) ...\")\n\n  return -1, -1, VIN_UNKNOWN\n\n\nif __name__ == \"__main__\":\n  import argparse\n  import time\n\n  parser = argparse.ArgumentParser(description='Get VIN of the car')\n  parser.add_argument('--debug', action='store_true')\n  parser.add_argument('--bus', type=int, default=1)\n  parser.add_argument('--timeout', type=float, default=0.1)\n  parser.add_argument('--retry', type=int, default=5)\n  args = parser.parse_args()\n\n  sendcan = messaging.pub_sock('sendcan')\n  logcan = messaging.sub_sock('can')\n  time.sleep(1)\n\n  vin_rx_addr, vin_rx_bus, vin = get_vin(logcan, sendcan, (args.bus,), args.timeout, args.retry, debug=args.debug)\n  print(f'RX: {hex(vin_rx_addr)}, BUS: {vin_rx_bus}, VIN: {vin}')\n", "selfdrive/car/fw_query_definitions.py": "#!/usr/bin/env python3\nimport capnp\nimport copy\nfrom dataclasses import dataclass, field\nimport struct\nfrom collections.abc import Callable\n\nimport panda.python.uds as uds\n\nAddrType = tuple[int, int | None]\nEcuAddrBusType = tuple[int, int | None, int]\nEcuAddrSubAddr = tuple[int, int, int | None]\n\nLiveFwVersions = dict[AddrType, set[bytes]]\nOfflineFwVersions = dict[str, dict[EcuAddrSubAddr, list[bytes]]]\n\n# A global list of addresses we will only ever consider for VIN responses\n# engine, hybrid controller, Ford abs, Hyundai CAN FD cluster, 29-bit engine, PGM-FI\n# TODO: move these to each brand's FW query config\nSTANDARD_VIN_ADDRS = [0x7e0, 0x7e2, 0x760, 0x7c6, 0x18da10f1, 0x18da0ef1]\n\n\ndef p16(val):\n  return struct.pack(\"!H\", val)\n\n\nclass StdQueries:\n  # FW queries\n  TESTER_PRESENT_REQUEST = bytes([uds.SERVICE_TYPE.TESTER_PRESENT, 0x0])\n  TESTER_PRESENT_RESPONSE = bytes([uds.SERVICE_TYPE.TESTER_PRESENT + 0x40, 0x0])\n\n  SHORT_TESTER_PRESENT_REQUEST = bytes([uds.SERVICE_TYPE.TESTER_PRESENT])\n  SHORT_TESTER_PRESENT_RESPONSE = bytes([uds.SERVICE_TYPE.TESTER_PRESENT + 0x40])\n\n  DEFAULT_DIAGNOSTIC_REQUEST = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL,\n                                      uds.SESSION_TYPE.DEFAULT])\n  DEFAULT_DIAGNOSTIC_RESPONSE = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL + 0x40,\n                                      uds.SESSION_TYPE.DEFAULT, 0x0, 0x32, 0x1, 0xf4])\n\n  EXTENDED_DIAGNOSTIC_REQUEST = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL,\n                                       uds.SESSION_TYPE.EXTENDED_DIAGNOSTIC])\n  EXTENDED_DIAGNOSTIC_RESPONSE = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL + 0x40,\n                                        uds.SESSION_TYPE.EXTENDED_DIAGNOSTIC, 0x0, 0x32, 0x1, 0xf4])\n\n  MANUFACTURER_SOFTWARE_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n    p16(uds.DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_ECU_SOFTWARE_NUMBER)\n  MANUFACTURER_SOFTWARE_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n    p16(uds.DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_ECU_SOFTWARE_NUMBER)\n\n  SUPPLIER_SOFTWARE_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n    p16(uds.DATA_IDENTIFIER_TYPE.SYSTEM_SUPPLIER_ECU_SOFTWARE_VERSION_NUMBER)\n  SUPPLIER_SOFTWARE_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n    p16(uds.DATA_IDENTIFIER_TYPE.SYSTEM_SUPPLIER_ECU_SOFTWARE_VERSION_NUMBER)\n\n  UDS_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n    p16(uds.DATA_IDENTIFIER_TYPE.APPLICATION_SOFTWARE_IDENTIFICATION)\n  UDS_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n    p16(uds.DATA_IDENTIFIER_TYPE.APPLICATION_SOFTWARE_IDENTIFICATION)\n\n  OBD_VERSION_REQUEST = b'\\x09\\x04'\n  OBD_VERSION_RESPONSE = b'\\x49\\x04'\n\n  # VIN queries\n  OBD_VIN_REQUEST = b'\\x09\\x02'\n  OBD_VIN_RESPONSE = b'\\x49\\x02\\x01'\n\n  UDS_VIN_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + p16(uds.DATA_IDENTIFIER_TYPE.VIN)\n  UDS_VIN_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + p16(uds.DATA_IDENTIFIER_TYPE.VIN)\n\n  GM_VIN_REQUEST = b'\\x1a\\x90'\n  GM_VIN_RESPONSE = b'\\x5a\\x90'\n\n  KWP_VIN_REQUEST = b'\\x21\\x81'\n  KWP_VIN_RESPONSE = b'\\x61\\x81'\n\n\n@dataclass\nclass Request:\n  request: list[bytes]\n  response: list[bytes]\n  whitelist_ecus: list[int] = field(default_factory=list)\n  rx_offset: int = 0x8\n  bus: int = 1\n  # Whether this query should be run on the first auxiliary panda (CAN FD cars for example)\n  auxiliary: bool = False\n  # FW responses from these queries will not be used for fingerprinting\n  logging: bool = False\n  # pandad toggles OBD multiplexing on/off as needed\n  obd_multiplexing: bool = True\n\n\n@dataclass\nclass FwQueryConfig:\n  requests: list[Request]\n  # TODO: make this automatic and remove hardcoded lists, or do fingerprinting with ecus\n  # Overrides and removes from essential ecus for specific models and ecus (exact matching)\n  non_essential_ecus: dict[capnp.lib.capnp._EnumModule, list[str]] = field(default_factory=dict)\n  # Ecus added for data collection, not to be fingerprinted on\n  extra_ecus: list[tuple[capnp.lib.capnp._EnumModule, int, int | None]] = field(default_factory=list)\n  # Function a brand can implement to provide better fuzzy matching. Takes in FW versions and VIN,\n  # returns set of candidates. Only will match if one candidate is returned\n  match_fw_to_car_fuzzy: Callable[[LiveFwVersions, str, OfflineFwVersions], set[str]] | None = None\n\n  def __post_init__(self):\n    for i in range(len(self.requests)):\n      if self.requests[i].auxiliary:\n        new_request = copy.deepcopy(self.requests[i])\n        new_request.bus += 4\n        self.requests.append(new_request)\n\n  def get_all_ecus(self, offline_fw_versions: OfflineFwVersions,\n                   include_extra_ecus: bool = True) -> set[EcuAddrSubAddr]:\n    # Add ecus in database + extra ecus\n    brand_ecus = {ecu for ecus in offline_fw_versions.values() for ecu in ecus}\n\n    if include_extra_ecus:\n      brand_ecus |= set(self.extra_ecus)\n\n    return brand_ecus\n", "selfdrive/car/fw_versions.py": "#!/usr/bin/env python3\nfrom collections import defaultdict\nfrom collections.abc import Iterator\nfrom typing import Any, Protocol, TypeVar\n\nfrom tqdm import tqdm\nimport capnp\n\nimport panda.python.uds as uds\nfrom cereal import car\nfrom openpilot.common.params import Params\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.selfdrive.car.ecu_addrs import get_ecu_addrs\nfrom openpilot.selfdrive.car.fingerprints import FW_VERSIONS\nfrom openpilot.selfdrive.car.fw_query_definitions import AddrType, EcuAddrBusType, FwQueryConfig, LiveFwVersions, OfflineFwVersions\nfrom openpilot.selfdrive.car.interfaces import get_interface_attr\nfrom openpilot.selfdrive.car.isotp_parallel_query import IsoTpParallelQuery\n\nEcu = car.CarParams.Ecu\nESSENTIAL_ECUS = [Ecu.engine, Ecu.eps, Ecu.abs, Ecu.fwdRadar, Ecu.fwdCamera, Ecu.vsa]\nFUZZY_EXCLUDE_ECUS = [Ecu.fwdCamera, Ecu.fwdRadar, Ecu.eps, Ecu.debug]\n\nFW_QUERY_CONFIGS: dict[str, FwQueryConfig] = get_interface_attr('FW_QUERY_CONFIG', ignore_none=True)\nVERSIONS = get_interface_attr('FW_VERSIONS', ignore_none=True)\n\nMODEL_TO_BRAND = {c: b for b, e in VERSIONS.items() for c in e}\nREQUESTS = [(brand, config, r) for brand, config in FW_QUERY_CONFIGS.items() for r in config.requests]\n\nT = TypeVar('T')\n\n\ndef chunks(l: list[T], n: int = 128) -> Iterator[list[T]]:\n  for i in range(0, len(l), n):\n    yield l[i:i + n]\n\n\ndef is_brand(brand: str, filter_brand: str | None) -> bool:\n  \"\"\"Returns if brand matches filter_brand or no brand filter is specified\"\"\"\n  return filter_brand is None or brand == filter_brand\n\n\ndef build_fw_dict(fw_versions: list[capnp.lib.capnp._DynamicStructBuilder], filter_brand: str = None) -> dict[AddrType, set[bytes]]:\n  fw_versions_dict: defaultdict[AddrType, set[bytes]] = defaultdict(set)\n  for fw in fw_versions:\n    if is_brand(fw.brand, filter_brand) and not fw.logging:\n      sub_addr = fw.subAddress if fw.subAddress != 0 else None\n      fw_versions_dict[(fw.address, sub_addr)].add(fw.fwVersion)\n  return dict(fw_versions_dict)\n\n\nclass MatchFwToCar(Protocol):\n  def __call__(self, live_fw_versions: LiveFwVersions, match_brand: str = None, log: bool = True) -> set[str]:\n    ...\n\n\ndef match_fw_to_car_fuzzy(live_fw_versions: LiveFwVersions, match_brand: str = None, log: bool = True, exclude: str = None) -> set[str]:\n  \"\"\"Do a fuzzy FW match. This function will return a match, and the number of firmware version\n  that were matched uniquely to that specific car. If multiple ECUs uniquely match to different cars\n  the match is rejected.\"\"\"\n\n  # Build lookup table from (addr, sub_addr, fw) to list of candidate cars\n  all_fw_versions = defaultdict(list)\n  for candidate, fw_by_addr in FW_VERSIONS.items():\n    if not is_brand(MODEL_TO_BRAND[candidate], match_brand):\n      continue\n\n    if candidate == exclude:\n      continue\n\n    for addr, fws in fw_by_addr.items():\n      # These ECUs are known to be shared between models (EPS only between hybrid/ICE version)\n      # Getting this exactly right isn't crucial, but excluding camera and radar makes it almost\n      # impossible to get 3 matching versions, even if two models with shared parts are released at the same\n      # time and only one is in our database.\n      if addr[0] in FUZZY_EXCLUDE_ECUS:\n        continue\n      for f in fws:\n        all_fw_versions[(addr[1], addr[2], f)].append(candidate)\n\n  matched_ecus = set()\n  match: str | None = None\n  for addr, versions in live_fw_versions.items():\n    ecu_key = (addr[0], addr[1])\n    for version in versions:\n      # All cars that have this FW response on the specified address\n      candidates = all_fw_versions[(*ecu_key, version)]\n\n      if len(candidates) == 1:\n        matched_ecus.add(ecu_key)\n        if match is None:\n          match = candidates[0]\n        # We uniquely matched two different cars. No fuzzy match possible\n        elif match != candidates[0]:\n          return set()\n\n  # Note that it is possible to match to a candidate without all its ECUs being present\n  # if there are enough matches. FIXME: parameterize this or require all ECUs to exist like exact matching\n  if match and len(matched_ecus) >= 2:\n    if log:\n      cloudlog.error(f\"Fingerprinted {match} using fuzzy match. {len(matched_ecus)} matching ECUs\")\n    return {match}\n  else:\n    return set()\n\n\ndef match_fw_to_car_exact(live_fw_versions: LiveFwVersions, match_brand: str = None, log: bool = True, extra_fw_versions: dict = None) -> set[str]:\n  \"\"\"Do an exact FW match. Returns all cars that match the given\n  FW versions for a list of \"essential\" ECUs. If an ECU is not considered\n  essential the FW version can be missing to get a fingerprint, but if it's present it\n  needs to match the database.\"\"\"\n  if extra_fw_versions is None:\n    extra_fw_versions = {}\n\n  invalid = set()\n  candidates = {c: f for c, f in FW_VERSIONS.items() if\n                is_brand(MODEL_TO_BRAND[c], match_brand)}\n\n  for candidate, fws in candidates.items():\n    config = FW_QUERY_CONFIGS[MODEL_TO_BRAND[candidate]]\n    for ecu, expected_versions in fws.items():\n      expected_versions = expected_versions + extra_fw_versions.get(candidate, {}).get(ecu, [])\n      ecu_type = ecu[0]\n      addr = ecu[1:]\n\n      found_versions = live_fw_versions.get(addr, set())\n      if not len(found_versions):\n        # Some models can sometimes miss an ecu, or show on two different addresses\n        # FIXME: this logic can be improved to be more specific, should require one of the two addresses\n        if candidate in config.non_essential_ecus.get(ecu_type, []):\n          continue\n\n        # Ignore non essential ecus\n        if ecu_type not in ESSENTIAL_ECUS:\n          continue\n\n      # Virtual debug ecu doesn't need to match the database\n      if ecu_type == Ecu.debug:\n        continue\n\n      if not any(found_version in expected_versions for found_version in found_versions):\n        invalid.add(candidate)\n        break\n\n  return set(candidates.keys()) - invalid\n\n\ndef match_fw_to_car(fw_versions: list[capnp.lib.capnp._DynamicStructBuilder], vin: str,\n                    allow_exact: bool = True, allow_fuzzy: bool = True, log: bool = True) -> tuple[bool, set[str]]:\n  # Try exact matching first\n  exact_matches: list[tuple[bool, MatchFwToCar]] = []\n  if allow_exact:\n    exact_matches = [(True, match_fw_to_car_exact)]\n  if allow_fuzzy:\n    exact_matches.append((False, match_fw_to_car_fuzzy))\n\n  for exact_match, match_func in exact_matches:\n    # For each brand, attempt to fingerprint using all FW returned from its queries\n    matches: set[str] = set()\n    for brand in VERSIONS.keys():\n      fw_versions_dict = build_fw_dict(fw_versions, filter_brand=brand)\n      matches |= match_func(fw_versions_dict, match_brand=brand, log=log)\n\n      # If specified and no matches so far, fall back to brand's fuzzy fingerprinting function\n      config = FW_QUERY_CONFIGS[brand]\n      if not exact_match and not len(matches) and config.match_fw_to_car_fuzzy is not None:\n        matches |= config.match_fw_to_car_fuzzy(fw_versions_dict, vin, VERSIONS[brand])\n\n    if len(matches):\n      return exact_match, matches\n\n  return True, set()\n\n\ndef get_present_ecus(logcan, sendcan, num_pandas: int = 1) -> set[EcuAddrBusType]:\n  params = Params()\n  # queries are split by OBD multiplexing mode\n  queries: dict[bool, list[list[EcuAddrBusType]]] = {True: [], False: []}\n  parallel_queries: dict[bool, list[EcuAddrBusType]] = {True: [], False: []}\n  responses: set[EcuAddrBusType] = set()\n\n  for brand, config, r in REQUESTS:\n    # Skip query if no panda available\n    if r.bus > num_pandas * 4 - 1:\n      continue\n\n    for ecu_type, addr, sub_addr in config.get_all_ecus(VERSIONS[brand]):\n      # Only query ecus in whitelist if whitelist is not empty\n      if len(r.whitelist_ecus) == 0 or ecu_type in r.whitelist_ecus:\n        a = (addr, sub_addr, r.bus)\n        # Build set of queries\n        if sub_addr is None:\n          if a not in parallel_queries[r.obd_multiplexing]:\n            parallel_queries[r.obd_multiplexing].append(a)\n        else:  # subaddresses must be queried one by one\n          if [a] not in queries[r.obd_multiplexing]:\n            queries[r.obd_multiplexing].append([a])\n\n        # Build set of expected responses to filter\n        response_addr = uds.get_rx_addr_for_tx_addr(addr, r.rx_offset)\n        responses.add((response_addr, sub_addr, r.bus))\n\n  for obd_multiplexing in queries:\n    queries[obd_multiplexing].insert(0, parallel_queries[obd_multiplexing])\n\n  ecu_responses = set()\n  for obd_multiplexing in queries:\n    set_obd_multiplexing(params, obd_multiplexing)\n    for query in queries[obd_multiplexing]:\n      ecu_responses.update(get_ecu_addrs(logcan, sendcan, set(query), responses, timeout=0.1))\n  return ecu_responses\n\n\ndef get_brand_ecu_matches(ecu_rx_addrs: set[EcuAddrBusType]) -> dict[str, set[AddrType]]:\n  \"\"\"Returns dictionary of brands and matches with ECUs in their FW versions\"\"\"\n\n  brand_addrs = {brand: {(addr, subaddr) for _, addr, subaddr in config.get_all_ecus(VERSIONS[brand])} for\n                 brand, config in FW_QUERY_CONFIGS.items()}\n  brand_matches: dict[str, set[AddrType]] = {brand: set() for brand, _, _ in REQUESTS}\n\n  brand_rx_offsets = {(brand, r.rx_offset) for brand, _, r in REQUESTS}\n  for addr, sub_addr, _ in ecu_rx_addrs:\n    # Since we can't know what request an ecu responded to, add matches for all possible rx offsets\n    for brand, rx_offset in brand_rx_offsets:\n      a = (uds.get_rx_addr_for_tx_addr(addr, -rx_offset), sub_addr)\n      if a in brand_addrs[brand]:\n        brand_matches[brand].add(a)\n\n  return brand_matches\n\n\ndef set_obd_multiplexing(params: Params, obd_multiplexing: bool):\n  if params.get_bool(\"ObdMultiplexingEnabled\") != obd_multiplexing:\n    cloudlog.warning(f\"Setting OBD multiplexing to {obd_multiplexing}\")\n    params.remove(\"ObdMultiplexingChanged\")\n    params.put_bool(\"ObdMultiplexingEnabled\", obd_multiplexing)\n    params.get_bool(\"ObdMultiplexingChanged\", block=True)\n    cloudlog.warning(\"OBD multiplexing set successfully\")\n\n\ndef get_fw_versions_ordered(logcan, sendcan, vin: str, ecu_rx_addrs: set[EcuAddrBusType], timeout: float = 0.1, num_pandas: int = 1,\n                            debug: bool = False, progress: bool = False) -> list[capnp.lib.capnp._DynamicStructBuilder]:\n  \"\"\"Queries for FW versions ordering brands by likelihood, breaks when exact match is found\"\"\"\n\n  all_car_fw = []\n  brand_matches = get_brand_ecu_matches(ecu_rx_addrs)\n\n  for brand in sorted(brand_matches, key=lambda b: len(brand_matches[b]), reverse=True):\n    # Skip this brand if there are no matching present ECUs\n    if not len(brand_matches[brand]):\n      continue\n\n    car_fw = get_fw_versions(logcan, sendcan, query_brand=brand, timeout=timeout, num_pandas=num_pandas, debug=debug, progress=progress)\n    all_car_fw.extend(car_fw)\n\n    # If there is a match using this brand's FW alone, finish querying early\n    _, matches = match_fw_to_car(car_fw, vin, log=False)\n    if len(matches) == 1:\n      break\n\n  return all_car_fw\n\n\ndef get_fw_versions(logcan, sendcan, query_brand: str = None, extra: OfflineFwVersions = None, timeout: float = 0.1, num_pandas: int = 1,\n                    debug: bool = False, progress: bool = False) -> list[capnp.lib.capnp._DynamicStructBuilder]:\n  versions = VERSIONS.copy()\n  params = Params()\n\n  if query_brand is not None:\n    versions = {query_brand: versions[query_brand]}\n\n  if extra is not None:\n    versions.update(extra)\n\n  # Extract ECU addresses to query from fingerprints\n  # ECUs using a subaddress need be queried one by one, the rest can be done in parallel\n  addrs = []\n  parallel_addrs = []\n  ecu_types = {}\n\n  for brand, brand_versions in versions.items():\n    config = FW_QUERY_CONFIGS[brand]\n    for ecu_type, addr, sub_addr in config.get_all_ecus(brand_versions):\n      a = (brand, addr, sub_addr)\n      if a not in ecu_types:\n        ecu_types[a] = ecu_type\n\n      if sub_addr is None:\n        if a not in parallel_addrs:\n          parallel_addrs.append(a)\n      else:\n        if [a] not in addrs:\n          addrs.append([a])\n\n  addrs.insert(0, parallel_addrs)\n\n  # Get versions and build capnp list to put into CarParams\n  car_fw = []\n  requests = [(brand, config, r) for brand, config, r in REQUESTS if is_brand(brand, query_brand)]\n  for addr_group in tqdm(addrs, disable=not progress):  # split by subaddr, if any\n    for addr_chunk in chunks(addr_group):\n      for brand, config, r in requests:\n        # Skip query if no panda available\n        if r.bus > num_pandas * 4 - 1:\n          continue\n\n        # Toggle OBD multiplexing for each request\n        if r.bus % 4 == 1:\n          set_obd_multiplexing(params, r.obd_multiplexing)\n\n        try:\n          query_addrs = [(a, s) for (b, a, s) in addr_chunk if b in (brand, 'any') and\n                         (len(r.whitelist_ecus) == 0 or ecu_types[(b, a, s)] in r.whitelist_ecus)]\n\n          if query_addrs:\n            query = IsoTpParallelQuery(sendcan, logcan, r.bus, query_addrs, r.request, r.response, r.rx_offset, debug=debug)\n            for (tx_addr, sub_addr), version in query.get_data(timeout).items():\n              f = car.CarParams.CarFw.new_message()\n\n              f.ecu = ecu_types.get((brand, tx_addr, sub_addr), Ecu.unknown)\n              f.fwVersion = version\n              f.address = tx_addr\n              f.responseAddress = uds.get_rx_addr_for_tx_addr(tx_addr, r.rx_offset)\n              f.request = r.request\n              f.brand = brand\n              f.bus = r.bus\n              f.logging = r.logging or (f.ecu, tx_addr, sub_addr) in config.extra_ecus\n              f.obdMultiplexing = r.obd_multiplexing\n\n              if sub_addr is not None:\n                f.subAddress = sub_addr\n\n              car_fw.append(f)\n        except Exception:\n          cloudlog.exception(\"FW query exception\")\n\n  return car_fw\n\n\nif __name__ == \"__main__\":\n  import time\n  import argparse\n  import cereal.messaging as messaging\n  from openpilot.selfdrive.car.vin import get_vin\n\n  parser = argparse.ArgumentParser(description='Get firmware version of ECUs')\n  parser.add_argument('--scan', action='store_true')\n  parser.add_argument('--debug', action='store_true')\n  parser.add_argument('--brand', help='Only query addresses/with requests for this brand')\n  args = parser.parse_args()\n\n  logcan = messaging.sub_sock('can')\n  pandaStates_sock = messaging.sub_sock('pandaStates')\n  sendcan = messaging.pub_sock('sendcan')\n\n  # Set up params for pandad\n  params = Params()\n  params.remove(\"FirmwareQueryDone\")\n  params.put_bool(\"IsOnroad\", False)\n  time.sleep(0.2)  # thread is 10 Hz\n  params.put_bool(\"IsOnroad\", True)\n\n  extra: Any = None\n  if args.scan:\n    extra = {}\n    # Honda\n    for i in range(256):\n      extra[(Ecu.unknown, 0x18da00f1 + (i << 8), None)] = []\n      extra[(Ecu.unknown, 0x700 + i, None)] = []\n      extra[(Ecu.unknown, 0x750, i)] = []\n    extra = {\"any\": {\"debug\": extra}}\n\n  num_pandas = len(messaging.recv_one_retry(pandaStates_sock).pandaStates)\n\n  t = time.time()\n  print(\"Getting vin...\")\n  set_obd_multiplexing(params, True)\n  vin_rx_addr, vin_rx_bus, vin = get_vin(logcan, sendcan, (0, 1), debug=args.debug)\n  print(f'RX: {hex(vin_rx_addr)}, BUS: {vin_rx_bus}, VIN: {vin}')\n  print(f\"Getting VIN took {time.time() - t:.3f} s\")\n  print()\n\n  t = time.time()\n  fw_vers = get_fw_versions(logcan, sendcan, query_brand=args.brand, extra=extra, num_pandas=num_pandas, debug=args.debug, progress=True)\n  _, candidates = match_fw_to_car(fw_vers, vin)\n\n  print()\n  print(\"Found FW versions\")\n  print(\"{\")\n  padding = max([len(fw.brand) for fw in fw_vers] or [0])\n  for version in fw_vers:\n    subaddr = None if version.subAddress == 0 else hex(version.subAddress)\n    print(f\"  Brand: {version.brand:{padding}}, bus: {version.bus}, OBD: {version.obdMultiplexing} - \" +\n          f\"(Ecu.{version.ecu}, {hex(version.address)}, {subaddr}): [{version.fwVersion}]\")\n  print(\"}\")\n\n  print()\n  print(\"Possible matches:\", candidates)\n  print(f\"Getting fw took {time.time() - t:.3f} s\")\n", "selfdrive/car/__init__.py": "# functions common among cars\nfrom collections import namedtuple\nfrom dataclasses import dataclass\nfrom enum import IntFlag, ReprEnum, EnumType\nfrom dataclasses import replace\n\nimport capnp\n\nfrom cereal import car\nfrom openpilot.common.numpy_fast import clip, interp\nfrom openpilot.common.utils import Freezable\nfrom openpilot.selfdrive.car.docs_definitions import CarDocs\n\n\n# kg of standard extra cargo to count for drive, gas, etc...\nSTD_CARGO_KG = 136.\n\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\nAngleRateLimit = namedtuple('AngleRateLimit', ['speed_bp', 'angle_v'])\n\n\ndef apply_hysteresis(val: float, val_steady: float, hyst_gap: float) -> float:\n  if val > val_steady + hyst_gap:\n    val_steady = val - hyst_gap\n  elif val < val_steady - hyst_gap:\n    val_steady = val + hyst_gap\n  return val_steady\n\n\ndef create_button_events(cur_btn: int, prev_btn: int, buttons_dict: dict[int, capnp.lib.capnp._EnumModule],\n                         unpressed_btn: int = 0) -> list[capnp.lib.capnp._DynamicStructBuilder]:\n  events: list[capnp.lib.capnp._DynamicStructBuilder] = []\n\n  if cur_btn == prev_btn:\n    return events\n\n  # Add events for button presses, multiple when a button switches without going to unpressed\n  for pressed, btn in ((False, prev_btn), (True, cur_btn)):\n    if btn != unpressed_btn:\n      events.append(car.CarState.ButtonEvent(pressed=pressed,\n                                             type=buttons_dict.get(btn, ButtonType.unknown)))\n  return events\n\n\ndef gen_empty_fingerprint():\n  return {i: {} for i in range(8)}\n\n\n# these params were derived for the Civic and used to calculate params for other cars\nclass VehicleDynamicsParams:\n  MASS = 1326. + STD_CARGO_KG\n  WHEELBASE = 2.70\n  CENTER_TO_FRONT = WHEELBASE * 0.4\n  CENTER_TO_REAR = WHEELBASE - CENTER_TO_FRONT\n  ROTATIONAL_INERTIA = 2500\n  TIRE_STIFFNESS_FRONT = 192150\n  TIRE_STIFFNESS_REAR = 202500\n\n\n# TODO: get actual value, for now starting with reasonable value for\n# civic and scaling by mass and wheelbase\ndef scale_rot_inertia(mass, wheelbase):\n  return VehicleDynamicsParams.ROTATIONAL_INERTIA * mass * wheelbase ** 2 / (VehicleDynamicsParams.MASS * VehicleDynamicsParams.WHEELBASE ** 2)\n\n\n# TODO: start from empirically derived lateral slip stiffness for the civic and scale by\n# mass and CG position, so all cars will have approximately similar dyn behaviors\ndef scale_tire_stiffness(mass, wheelbase, center_to_front, tire_stiffness_factor):\n  center_to_rear = wheelbase - center_to_front\n  tire_stiffness_front = (VehicleDynamicsParams.TIRE_STIFFNESS_FRONT * tire_stiffness_factor) * mass / VehicleDynamicsParams.MASS * \\\n                         (center_to_rear / wheelbase) / (VehicleDynamicsParams.CENTER_TO_REAR / VehicleDynamicsParams.WHEELBASE)\n\n  tire_stiffness_rear = (VehicleDynamicsParams.TIRE_STIFFNESS_REAR * tire_stiffness_factor) * mass / VehicleDynamicsParams.MASS * \\\n                        (center_to_front / wheelbase) / (VehicleDynamicsParams.CENTER_TO_FRONT / VehicleDynamicsParams.WHEELBASE)\n\n  return tire_stiffness_front, tire_stiffness_rear\n\n\nDbcDict = dict[str, str]\n\n\ndef dbc_dict(pt_dbc, radar_dbc, chassis_dbc=None, body_dbc=None) -> DbcDict:\n  return {'pt': pt_dbc, 'radar': radar_dbc, 'chassis': chassis_dbc, 'body': body_dbc}\n\n\ndef apply_driver_steer_torque_limits(apply_torque, apply_torque_last, driver_torque, LIMITS):\n\n  # limits due to driver torque\n  driver_max_torque = LIMITS.STEER_MAX + (LIMITS.STEER_DRIVER_ALLOWANCE + driver_torque * LIMITS.STEER_DRIVER_FACTOR) * LIMITS.STEER_DRIVER_MULTIPLIER\n  driver_min_torque = -LIMITS.STEER_MAX + (-LIMITS.STEER_DRIVER_ALLOWANCE + driver_torque * LIMITS.STEER_DRIVER_FACTOR) * LIMITS.STEER_DRIVER_MULTIPLIER\n  max_steer_allowed = max(min(LIMITS.STEER_MAX, driver_max_torque), 0)\n  min_steer_allowed = min(max(-LIMITS.STEER_MAX, driver_min_torque), 0)\n  apply_torque = clip(apply_torque, min_steer_allowed, max_steer_allowed)\n\n  # slow rate if steer torque increases in magnitude\n  if apply_torque_last > 0:\n    apply_torque = clip(apply_torque, max(apply_torque_last - LIMITS.STEER_DELTA_DOWN, -LIMITS.STEER_DELTA_UP),\n                        apply_torque_last + LIMITS.STEER_DELTA_UP)\n  else:\n    apply_torque = clip(apply_torque, apply_torque_last - LIMITS.STEER_DELTA_UP,\n                        min(apply_torque_last + LIMITS.STEER_DELTA_DOWN, LIMITS.STEER_DELTA_UP))\n\n  return int(round(float(apply_torque)))\n\n\ndef apply_dist_to_meas_limits(val, val_last, val_meas,\n                              STEER_DELTA_UP, STEER_DELTA_DOWN,\n                              STEER_ERROR_MAX, STEER_MAX):\n  # limits due to comparison of commanded val VS measured val (torque/angle/curvature)\n  max_lim = min(max(val_meas + STEER_ERROR_MAX, STEER_ERROR_MAX), STEER_MAX)\n  min_lim = max(min(val_meas - STEER_ERROR_MAX, -STEER_ERROR_MAX), -STEER_MAX)\n\n  val = clip(val, min_lim, max_lim)\n\n  # slow rate if val increases in magnitude\n  if val_last > 0:\n    val = clip(val,\n               max(val_last - STEER_DELTA_DOWN, -STEER_DELTA_UP),\n               val_last + STEER_DELTA_UP)\n  else:\n    val = clip(val,\n               val_last - STEER_DELTA_UP,\n               min(val_last + STEER_DELTA_DOWN, STEER_DELTA_UP))\n\n  return float(val)\n\n\ndef apply_meas_steer_torque_limits(apply_torque, apply_torque_last, motor_torque, LIMITS):\n  return int(round(apply_dist_to_meas_limits(apply_torque, apply_torque_last, motor_torque,\n                                             LIMITS.STEER_DELTA_UP, LIMITS.STEER_DELTA_DOWN,\n                                             LIMITS.STEER_ERROR_MAX, LIMITS.STEER_MAX)))\n\n\ndef apply_std_steer_angle_limits(apply_angle, apply_angle_last, v_ego, LIMITS):\n  # pick angle rate limits based on wind up/down\n  steer_up = apply_angle_last * apply_angle >= 0. and abs(apply_angle) > abs(apply_angle_last)\n  rate_limits = LIMITS.ANGLE_RATE_LIMIT_UP if steer_up else LIMITS.ANGLE_RATE_LIMIT_DOWN\n\n  angle_rate_lim = interp(v_ego, rate_limits.speed_bp, rate_limits.angle_v)\n  return clip(apply_angle, apply_angle_last - angle_rate_lim, apply_angle_last + angle_rate_lim)\n\n\ndef common_fault_avoidance(fault_condition: bool, request: bool, above_limit_frames: int,\n                           max_above_limit_frames: int, max_mismatching_frames: int = 1):\n  \"\"\"\n  Several cars have the ability to work around their EPS limits by cutting the\n  request bit of their LKAS message after a certain number of frames above the limit.\n  \"\"\"\n\n  # Count up to max_above_limit_frames, at which point we need to cut the request for above_limit_frames to avoid a fault\n  if request and fault_condition:\n    above_limit_frames += 1\n  else:\n    above_limit_frames = 0\n\n  # Once we cut the request bit, count additionally to max_mismatching_frames before setting the request bit high again.\n  # Some brands do not respect our workaround without multiple messages on the bus, for example\n  if above_limit_frames > max_above_limit_frames:\n    request = False\n\n  if above_limit_frames >= max_above_limit_frames + max_mismatching_frames:\n    above_limit_frames = 0\n\n  return above_limit_frames, request\n\n\ndef make_can_msg(addr, dat, bus):\n  return [addr, 0, dat, bus]\n\n\ndef get_safety_config(safety_model, safety_param = None):\n  ret = car.CarParams.SafetyConfig.new_message()\n  ret.safetyModel = safety_model\n  if safety_param is not None:\n    ret.safetyParam = safety_param\n  return ret\n\n\nclass CanBusBase:\n  offset: int\n\n  def __init__(self, CP, fingerprint: dict[int, dict[int, int]] | None) -> None:\n    if CP is None:\n      assert fingerprint is not None\n      num = max([k for k, v in fingerprint.items() if len(v)], default=0) // 4 + 1\n    else:\n      num = len(CP.safetyConfigs)\n    self.offset = 4 * (num - 1)\n\n\nclass CanSignalRateCalculator:\n  \"\"\"\n  Calculates the instantaneous rate of a CAN signal by using the counter\n  variable and the known frequency of the CAN message that contains it.\n  \"\"\"\n  def __init__(self, frequency):\n    self.frequency = frequency\n    self.previous_counter = 0\n    self.previous_value = 0\n    self.rate = 0\n\n  def update(self, current_value, current_counter):\n    if current_counter != self.previous_counter:\n      self.rate = (current_value - self.previous_value) * self.frequency\n\n    self.previous_counter = current_counter\n    self.previous_value = current_value\n\n    return self.rate\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CarSpecs:\n  mass: float  # kg, curb weight\n  wheelbase: float  # meters\n  steerRatio: float\n  centerToFrontRatio: float = 0.5\n  minSteerSpeed: float = 0.0  # m/s\n  minEnableSpeed: float = -1.0  # m/s\n  tireStiffnessFactor: float = 1.0\n\n  def override(self, **kwargs):\n    return replace(self, **kwargs)\n\n\n@dataclass(order=True)\nclass PlatformConfig(Freezable):\n  car_docs: list[CarDocs]\n  specs: CarSpecs\n\n  dbc_dict: DbcDict\n\n  flags: int = 0\n\n  platform_str: str | None = None\n\n  def __hash__(self) -> int:\n    return hash(self.platform_str)\n\n  def override(self, **kwargs):\n    return replace(self, **kwargs)\n\n  def init(self):\n    pass\n\n  def __post_init__(self):\n    self.init()\n\n\nclass PlatformsType(EnumType):\n  def __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds):\n    for key in classdict._member_names.keys():\n      cfg: PlatformConfig = classdict[key]\n      cfg.platform_str = key\n      cfg.freeze()\n    return super().__new__(metacls, cls, bases, classdict, boundary=boundary, _simple=_simple, **kwds)\n\n\nclass Platforms(str, ReprEnum, metaclass=PlatformsType):\n  config: PlatformConfig\n\n  def __new__(cls, platform_config: PlatformConfig):\n    member = str.__new__(cls, platform_config.platform_str)\n    member.config = platform_config\n    member._value_ = platform_config.platform_str\n    return member\n\n  def __repr__(self):\n    return f\"<{self.__class__.__name__}.{self.name}>\"\n\n  @classmethod\n  def create_dbc_map(cls) -> dict[str, DbcDict]:\n    return {p: p.config.dbc_dict for p in cls}\n\n  @classmethod\n  def with_flags(cls, flags: IntFlag) -> set['Platforms']:\n    return {p for p in cls if p.config.flags & flags}\n", "selfdrive/car/tesla/carstate.py": "import copy\nfrom collections import deque\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.tesla.values import CAR, DBC, CANBUS, GEAR_MAP, DOORS, BUTTONS\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom opendbc.can.parser import CANParser\nfrom opendbc.can.can_define import CANDefine\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.button_states = {button.event_type: False for button in BUTTONS}\n    self.can_define = CANDefine(DBC[CP.carFingerprint]['chassis'])\n\n    # Needed by carcontroller\n    self.msg_stw_actn_req = None\n    self.hands_on_level = 0\n    self.steer_warning = None\n    self.acc_state = 0\n    self.das_control_counters = deque(maxlen=32)\n\n  def update(self, cp, cp_cam):\n    ret = car.CarState.new_message()\n\n    # Vehicle speed\n    ret.vEgoRaw = cp.vl[\"ESP_B\"][\"ESP_vehicleSpeed\"] * CV.KPH_TO_MS\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = (ret.vEgo < 0.1)\n\n    # Gas pedal\n    ret.gas = cp.vl[\"DI_torque1\"][\"DI_pedalPos\"] / 100.0\n    ret.gasPressed = (ret.gas > 0)\n\n    # Brake pedal\n    ret.brake = 0\n    ret.brakePressed = bool(cp.vl[\"BrakeMessage\"][\"driverBrakeStatus\"] != 1)\n\n    # Steering wheel\n    epas_status = cp_cam.vl[\"EPAS3P_sysStatus\"] if self.CP.carFingerprint == CAR.TESLA_MODELS_RAVEN else cp.vl[\"EPAS_sysStatus\"]\n\n    self.hands_on_level = epas_status[\"EPAS_handsOnLevel\"]\n    self.steer_warning = self.can_define.dv[\"EPAS_sysStatus\"][\"EPAS_eacErrorCode\"].get(int(epas_status[\"EPAS_eacErrorCode\"]), None)\n    steer_status = self.can_define.dv[\"EPAS_sysStatus\"][\"EPAS_eacStatus\"].get(int(epas_status[\"EPAS_eacStatus\"]), None)\n\n    ret.steeringAngleDeg = -epas_status[\"EPAS_internalSAS\"]\n    ret.steeringRateDeg = -cp.vl[\"STW_ANGLHP_STAT\"][\"StW_AnglHP_Spd\"] # This is from a different angle sensor, and at different rate\n    ret.steeringTorque = -epas_status[\"EPAS_torsionBarTorque\"]\n    ret.steeringPressed = (self.hands_on_level > 0)\n    ret.steerFaultPermanent = steer_status == \"EAC_FAULT\"\n    ret.steerFaultTemporary = (self.steer_warning not in (\"EAC_ERROR_IDLE\", \"EAC_ERROR_HANDS_ON\"))\n\n    # Cruise state\n    cruise_state = self.can_define.dv[\"DI_state\"][\"DI_cruiseState\"].get(int(cp.vl[\"DI_state\"][\"DI_cruiseState\"]), None)\n    speed_units = self.can_define.dv[\"DI_state\"][\"DI_speedUnits\"].get(int(cp.vl[\"DI_state\"][\"DI_speedUnits\"]), None)\n\n    acc_enabled = (cruise_state in (\"ENABLED\", \"STANDSTILL\", \"OVERRIDE\", \"PRE_FAULT\", \"PRE_CANCEL\"))\n\n    ret.cruiseState.enabled = acc_enabled\n    if speed_units == \"KPH\":\n      ret.cruiseState.speed = cp.vl[\"DI_state\"][\"DI_digitalSpeed\"] * CV.KPH_TO_MS\n    elif speed_units == \"MPH\":\n      ret.cruiseState.speed = cp.vl[\"DI_state\"][\"DI_digitalSpeed\"] * CV.MPH_TO_MS\n    ret.cruiseState.available = ((cruise_state == \"STANDBY\") or ret.cruiseState.enabled)\n    ret.cruiseState.standstill = False # This needs to be false, since we can resume from stop without sending anything special\n\n    # Gear\n    ret.gearShifter = GEAR_MAP[self.can_define.dv[\"DI_torque2\"][\"DI_gear\"].get(int(cp.vl[\"DI_torque2\"][\"DI_gear\"]), \"DI_GEAR_INVALID\")]\n\n    # Buttons\n    buttonEvents = []\n    for button in BUTTONS:\n      state = (cp.vl[button.can_addr][button.can_msg] in button.values)\n      if self.button_states[button.event_type] != state:\n        event = car.CarState.ButtonEvent.new_message()\n        event.type = button.event_type\n        event.pressed = state\n        buttonEvents.append(event)\n      self.button_states[button.event_type] = state\n    ret.buttonEvents = buttonEvents\n\n    # Doors\n    ret.doorOpen = any((self.can_define.dv[\"GTW_carState\"][door].get(int(cp.vl[\"GTW_carState\"][door]), \"OPEN\") == \"OPEN\") for door in DOORS)\n\n    # Blinkers\n    ret.leftBlinker = (cp.vl[\"GTW_carState\"][\"BC_indicatorLStatus\"] == 1)\n    ret.rightBlinker = (cp.vl[\"GTW_carState\"][\"BC_indicatorRStatus\"] == 1)\n\n    # Seatbelt\n    if self.CP.carFingerprint == CAR.TESLA_MODELS_RAVEN:\n      ret.seatbeltUnlatched = (cp.vl[\"DriverSeat\"][\"buckleStatus\"] != 1)\n    else:\n      ret.seatbeltUnlatched = (cp.vl[\"SDM1\"][\"SDM_bcklDrivStatus\"] != 1)\n\n    # TODO: blindspot\n\n    # AEB\n    ret.stockAeb = (cp_cam.vl[\"DAS_control\"][\"DAS_aebEvent\"] == 1)\n\n    # Messages needed by carcontroller\n    self.msg_stw_actn_req = copy.copy(cp.vl[\"STW_ACTN_RQ\"])\n    self.acc_state = cp_cam.vl[\"DAS_control\"][\"DAS_accState\"]\n    self.das_control_counters.extend(cp_cam.vl_all[\"DAS_control\"][\"DAS_controlCounter\"])\n\n    return ret\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"ESP_B\", 50),\n      (\"DI_torque1\", 100),\n      (\"DI_torque2\", 100),\n      (\"STW_ANGLHP_STAT\", 100),\n      (\"EPAS_sysStatus\", 25),\n      (\"DI_state\", 10),\n      (\"STW_ACTN_RQ\", 10),\n      (\"GTW_carState\", 10),\n      (\"BrakeMessage\", 50),\n    ]\n\n    if CP.carFingerprint == CAR.TESLA_MODELS_RAVEN:\n      messages.append((\"DriverSeat\", 20))\n    else:\n      messages.append((\"SDM1\", 10))\n\n    return CANParser(DBC[CP.carFingerprint]['chassis'], messages, CANBUS.chassis)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"DAS_control\", 40),\n    ]\n\n    if CP.carFingerprint == CAR.TESLA_MODELS_RAVEN:\n      messages.append((\"EPAS3P_sysStatus\", 100))\n\n    return CANParser(DBC[CP.carFingerprint]['chassis'], messages, CANBUS.autopilot_chassis)\n", "selfdrive/car/tesla/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.tesla.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFW_VERSIONS = {\n  CAR.TESLA_AP2_MODELS: {\n    (Ecu.adas, 0x649, None): [\n      b'\\x01\\x00\\x8b\\x07\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x11',\n    ],\n    (Ecu.electricBrakeBooster, 0x64d, None): [\n      b'1037123-00-A',\n    ],\n    (Ecu.fwdRadar, 0x671, None): [\n      b'\\x01\\x00W\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x08\\x01\\x00\\x00\\x00\\x07\\xff\\xfe',\n    ],\n    (Ecu.eps, 0x730, None): [\n      b'\\x10#\\x01',\n    ],\n  },\n  CAR.TESLA_MODELS_RAVEN: {\n    (Ecu.electricBrakeBooster, 0x64d, None): [\n      b'1037123-00-A',\n    ],\n    (Ecu.fwdRadar, 0x671, None): [\n      b'\\x01\\x00\\x99\\x02\\x01\\x00\\x10\\x00\\x00AP8.3.03\\x00\\x10',\n    ],\n    (Ecu.eps, 0x730, None): [\n      b'SX_0.0.0 (99),SR013.7',\n    ],\n  },\n}\n", "selfdrive/car/tesla/values.py": "from collections import namedtuple\n\nfrom cereal import car\nfrom openpilot.selfdrive.car import AngleRateLimit, CarSpecs, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarDocs\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries\n\nEcu = car.CarParams.Ecu\n\nButton = namedtuple('Button', ['event_type', 'can_addr', 'can_msg', 'values'])\n\nclass CAR(Platforms):\n  TESLA_AP1_MODELS = PlatformConfig(\n    [CarDocs(\"Tesla AP1 Model S\", \"All\")],\n    CarSpecs(mass=2100., wheelbase=2.959, steerRatio=15.0),\n    dbc_dict('tesla_powertrain', 'tesla_radar_bosch_generated', chassis_dbc='tesla_can')\n  )\n  TESLA_AP2_MODELS = PlatformConfig(\n    [CarDocs(\"Tesla AP2 Model S\", \"All\")],\n    TESLA_AP1_MODELS.specs,\n    TESLA_AP1_MODELS.dbc_dict\n  )\n  TESLA_MODELS_RAVEN = PlatformConfig(\n    [CarDocs(\"Tesla Model S Raven\", \"All\")],\n    TESLA_AP1_MODELS.specs,\n    dbc_dict('tesla_powertrain', 'tesla_radar_continental_generated', chassis_dbc='tesla_can')\n  )\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.UDS_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.eps],\n      rx_offset=0x08,\n      bus=0,\n    ),\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.SUPPLIER_SOFTWARE_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.SUPPLIER_SOFTWARE_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.eps],\n      rx_offset=0x08,\n      bus=0,\n    ),\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.UDS_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.adas, Ecu.electricBrakeBooster, Ecu.fwdRadar],\n      rx_offset=0x10,\n      bus=0,\n    ),\n  ]\n)\n\nclass CANBUS:\n  # Lateral harness\n  chassis = 0\n  radar = 1\n  autopilot_chassis = 2\n\n  # Longitudinal harness\n  powertrain = 4\n  private = 5\n  autopilot_powertrain = 6\n\nGEAR_MAP = {\n  \"DI_GEAR_INVALID\": car.CarState.GearShifter.unknown,\n  \"DI_GEAR_P\": car.CarState.GearShifter.park,\n  \"DI_GEAR_R\": car.CarState.GearShifter.reverse,\n  \"DI_GEAR_N\": car.CarState.GearShifter.neutral,\n  \"DI_GEAR_D\": car.CarState.GearShifter.drive,\n  \"DI_GEAR_SNA\": car.CarState.GearShifter.unknown,\n}\n\nDOORS = [\"DOOR_STATE_FL\", \"DOOR_STATE_FR\", \"DOOR_STATE_RL\", \"DOOR_STATE_RR\", \"DOOR_STATE_FrontTrunk\", \"BOOT_STATE\"]\n\n# Make sure the message and addr is also in the CAN parser!\nBUTTONS = [\n  Button(car.CarState.ButtonEvent.Type.leftBlinker, \"STW_ACTN_RQ\", \"TurnIndLvr_Stat\", [1]),\n  Button(car.CarState.ButtonEvent.Type.rightBlinker, \"STW_ACTN_RQ\", \"TurnIndLvr_Stat\", [2]),\n  Button(car.CarState.ButtonEvent.Type.accelCruise, \"STW_ACTN_RQ\", \"SpdCtrlLvr_Stat\", [4, 16]),\n  Button(car.CarState.ButtonEvent.Type.decelCruise, \"STW_ACTN_RQ\", \"SpdCtrlLvr_Stat\", [8, 32]),\n  Button(car.CarState.ButtonEvent.Type.cancel, \"STW_ACTN_RQ\", \"SpdCtrlLvr_Stat\", [1]),\n  Button(car.CarState.ButtonEvent.Type.resumeCruise, \"STW_ACTN_RQ\", \"SpdCtrlLvr_Stat\", [2]),\n]\n\nclass CarControllerParams:\n  ANGLE_RATE_LIMIT_UP = AngleRateLimit(speed_bp=[0., 5., 15.], angle_v=[10., 1.6, .3])\n  ANGLE_RATE_LIMIT_DOWN = AngleRateLimit(speed_bp=[0., 5., 15.], angle_v=[10., 7.0, 0.8])\n  JERK_LIMIT_MAX = 8\n  JERK_LIMIT_MIN = -8\n  ACCEL_TO_SPEED_MULTIPLIER = 3\n\n  def __init__(self, CP):\n    pass\n\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/tesla/teslacan.py": "import crcmod\n\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.tesla.values import CANBUS, CarControllerParams\n\n\nclass TeslaCAN:\n  def __init__(self, packer, pt_packer):\n    self.packer = packer\n    self.pt_packer = pt_packer\n    self.crc = crcmod.mkCrcFun(0x11d, initCrc=0x00, rev=False, xorOut=0xff)\n\n  @staticmethod\n  def checksum(msg_id, dat):\n    # TODO: get message ID from name instead\n    ret = (msg_id & 0xFF) + ((msg_id >> 8) & 0xFF)\n    ret += sum(dat)\n    return ret & 0xFF\n\n  def create_steering_control(self, angle, enabled, counter):\n    values = {\n      \"DAS_steeringAngleRequest\": -angle,\n      \"DAS_steeringHapticRequest\": 0,\n      \"DAS_steeringControlType\": 1 if enabled else 0,\n      \"DAS_steeringControlCounter\": counter,\n    }\n\n    data = self.packer.make_can_msg(\"DAS_steeringControl\", CANBUS.chassis, values)[2]\n    values[\"DAS_steeringControlChecksum\"] = self.checksum(0x488, data[:3])\n    return self.packer.make_can_msg(\"DAS_steeringControl\", CANBUS.chassis, values)\n\n  def create_action_request(self, msg_stw_actn_req, cancel, bus, counter):\n    # We copy this whole message when spamming cancel\n    values = {s: msg_stw_actn_req[s] for s in [\n      \"SpdCtrlLvr_Stat\",\n      \"VSL_Enbl_Rq\",\n      \"SpdCtrlLvrStat_Inv\",\n      \"DTR_Dist_Rq\",\n      \"TurnIndLvr_Stat\",\n      \"HiBmLvr_Stat\",\n      \"WprWashSw_Psd\",\n      \"WprWash_R_Sw_Posn_V2\",\n      \"StW_Lvr_Stat\",\n      \"StW_Cond_Flt\",\n      \"StW_Cond_Psd\",\n      \"HrnSw_Psd\",\n      \"StW_Sw00_Psd\",\n      \"StW_Sw01_Psd\",\n      \"StW_Sw02_Psd\",\n      \"StW_Sw03_Psd\",\n      \"StW_Sw04_Psd\",\n      \"StW_Sw05_Psd\",\n      \"StW_Sw06_Psd\",\n      \"StW_Sw07_Psd\",\n      \"StW_Sw08_Psd\",\n      \"StW_Sw09_Psd\",\n      \"StW_Sw10_Psd\",\n      \"StW_Sw11_Psd\",\n      \"StW_Sw12_Psd\",\n      \"StW_Sw13_Psd\",\n      \"StW_Sw14_Psd\",\n      \"StW_Sw15_Psd\",\n      \"WprSw6Posn\",\n      \"MC_STW_ACTN_RQ\",\n      \"CRC_STW_ACTN_RQ\",\n    ]}\n\n    if cancel:\n      values[\"SpdCtrlLvr_Stat\"] = 1\n      values[\"MC_STW_ACTN_RQ\"] = counter\n\n    data = self.packer.make_can_msg(\"STW_ACTN_RQ\", bus, values)[2]\n    values[\"CRC_STW_ACTN_RQ\"] = self.crc(data[:7])\n    return self.packer.make_can_msg(\"STW_ACTN_RQ\", bus, values)\n\n  def create_longitudinal_commands(self, acc_state, speed, min_accel, max_accel, cnt):\n    messages = []\n    values = {\n      \"DAS_setSpeed\": speed * CV.MS_TO_KPH,\n      \"DAS_accState\": acc_state,\n      \"DAS_aebEvent\": 0,\n      \"DAS_jerkMin\": CarControllerParams.JERK_LIMIT_MIN,\n      \"DAS_jerkMax\": CarControllerParams.JERK_LIMIT_MAX,\n      \"DAS_accelMin\": min_accel,\n      \"DAS_accelMax\": max_accel,\n      \"DAS_controlCounter\": cnt,\n      \"DAS_controlChecksum\": 0,\n    }\n\n    for packer, bus in [(self.packer, CANBUS.chassis), (self.pt_packer, CANBUS.powertrain)]:\n      data = packer.make_can_msg(\"DAS_control\", bus, values)[2]\n      values[\"DAS_controlChecksum\"] = self.checksum(0x2b9, data[:7])\n      messages.append(packer.make_can_msg(\"DAS_control\", bus, values))\n    return messages\n", "selfdrive/car/tesla/carcontroller.py": "from openpilot.common.numpy_fast import clip\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car import apply_std_steer_angle_limits\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.car.tesla.teslacan import TeslaCAN\nfrom openpilot.selfdrive.car.tesla.values import DBC, CANBUS, CarControllerParams\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.frame = 0\n    self.apply_angle_last = 0\n    self.packer = CANPacker(dbc_name)\n    self.pt_packer = CANPacker(DBC[CP.carFingerprint]['pt'])\n    self.tesla_can = TeslaCAN(self.packer, self.pt_packer)\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    pcm_cancel_cmd = CC.cruiseControl.cancel\n\n    can_sends = []\n\n    # Temp disable steering on a hands_on_fault, and allow for user override\n    hands_on_fault = CS.steer_warning == \"EAC_ERROR_HANDS_ON\" and CS.hands_on_level >= 3\n    lkas_enabled = CC.latActive and not hands_on_fault\n\n    if self.frame % 2 == 0:\n      if lkas_enabled:\n        # Angular rate limit based on speed\n        apply_angle = apply_std_steer_angle_limits(actuators.steeringAngleDeg, self.apply_angle_last, CS.out.vEgo, CarControllerParams)\n\n        # To not fault the EPS\n        apply_angle = clip(apply_angle, CS.out.steeringAngleDeg - 20, CS.out.steeringAngleDeg + 20)\n      else:\n        apply_angle = CS.out.steeringAngleDeg\n\n      self.apply_angle_last = apply_angle\n      can_sends.append(self.tesla_can.create_steering_control(apply_angle, lkas_enabled, (self.frame // 2) % 16))\n\n    # Longitudinal control (in sync with stock message, about 40Hz)\n    if self.CP.openpilotLongitudinalControl:\n      target_accel = actuators.accel\n      target_speed = max(CS.out.vEgo + (target_accel * CarControllerParams.ACCEL_TO_SPEED_MULTIPLIER), 0)\n      max_accel = 0 if target_accel < 0 else target_accel\n      min_accel = 0 if target_accel > 0 else target_accel\n\n      while len(CS.das_control_counters) > 0:\n        can_sends.extend(self.tesla_can.create_longitudinal_commands(CS.acc_state, target_speed, min_accel, max_accel, CS.das_control_counters.popleft()))\n\n    # Cancel on user steering override, since there is no steering torque blending\n    if hands_on_fault:\n      pcm_cancel_cmd = True\n\n    if self.frame % 10 == 0 and pcm_cancel_cmd:\n      # Spam every possible counter value, otherwise it might not be accepted\n      for counter in range(16):\n        can_sends.append(self.tesla_can.create_action_request(CS.msg_stw_actn_req, pcm_cancel_cmd, CANBUS.chassis, counter))\n        can_sends.append(self.tesla_can.create_action_request(CS.msg_stw_actn_req, pcm_cancel_cmd, CANBUS.autopilot_chassis, counter))\n\n    # TODO: HUD control\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steeringAngleDeg = self.apply_angle_last\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/tesla/radar_interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.tesla.values import CAR, DBC, CANBUS\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.CP = CP\n\n    if CP.carFingerprint == CAR.TESLA_MODELS_RAVEN:\n      messages = [('RadarStatus', 16)]\n      self.num_points = 40\n      self.trigger_msg = 1119\n    else:\n      messages = [('TeslaRadarSguInfo', 10)]\n      self.num_points = 32\n      self.trigger_msg = 878\n\n    for i in range(self.num_points):\n      messages.extend([\n        (f'RadarPoint{i}_A', 16),\n        (f'RadarPoint{i}_B', 16),\n      ])\n\n    self.rcp = CANParser(DBC[CP.carFingerprint]['radar'], messages, CANBUS.radar)\n    self.updated_messages = set()\n    self.track_id = 0\n\n  def update(self, can_strings):\n    if self.rcp is None:\n      return super().update(None)\n\n    values = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(values)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    ret = car.RadarData.new_message()\n\n    # Errors\n    errors = []\n    if not self.rcp.can_valid:\n      errors.append('canError')\n\n    if self.CP.carFingerprint == CAR.TESLA_MODELS_RAVEN:\n      radar_status = self.rcp.vl['RadarStatus']\n      if radar_status['sensorBlocked'] or radar_status['shortTermUnavailable'] or radar_status['vehDynamicsError']:\n        errors.append('fault')\n    else:\n      radar_status = self.rcp.vl['TeslaRadarSguInfo']\n      if radar_status['RADC_HWFail'] or radar_status['RADC_SGUFail'] or radar_status['RADC_SensorDirty']:\n        errors.append('fault')\n\n    ret.errors = errors\n\n    # Radar tracks\n    for i in range(self.num_points):\n      msg_a = self.rcp.vl[f'RadarPoint{i}_A']\n      msg_b = self.rcp.vl[f'RadarPoint{i}_B']\n\n      # Make sure msg A and B are together\n      if msg_a['Index'] != msg_b['Index2']:\n        continue\n\n      # Check if it's a valid track\n      if not msg_a['Tracked']:\n        if i in self.pts:\n          del self.pts[i]\n        continue\n\n      # New track!\n      if i not in self.pts:\n        self.pts[i] = car.RadarData.RadarPoint.new_message()\n        self.pts[i].trackId = self.track_id\n        self.track_id += 1\n\n      # Parse track data\n      self.pts[i].dRel = msg_a['LongDist']\n      self.pts[i].yRel = msg_a['LatDist']\n      self.pts[i].vRel = msg_a['LongSpeed']\n      self.pts[i].aRel = msg_a['LongAccel']\n      self.pts[i].yvRel = msg_b['LatSpeed']\n      self.pts[i].measured = bool(msg_a['Meas'])\n\n    ret.points = list(self.pts.values())\n    self.updated_messages.clear()\n    return ret\n", "selfdrive/car/tesla/__init__.py": "", "selfdrive/car/tesla/interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom panda import Panda\nfrom openpilot.selfdrive.car.tesla.values import CANBUS, CAR\nfrom openpilot.selfdrive.car import get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"tesla\"\n\n    # There is no safe way to do steer blending with user torque,\n    # so the steering behaves like autopilot. This is not\n    # how openpilot should be, hence dashcamOnly\n    ret.dashcamOnly = True\n\n    ret.steerControlType = car.CarParams.SteerControlType.angle\n\n    ret.longitudinalActuatorDelay = 0.5 # s\n    ret.radarTimeStep = (1.0 / 8) # 8Hz\n\n    # Check if we have messages on an auxiliary panda, and that 0x2bf (DAS_control) is present on the AP powertrain bus\n    # If so, we assume that it is connected to the longitudinal harness.\n    flags = (Panda.FLAG_TESLA_RAVEN if candidate == CAR.TESLA_MODELS_RAVEN else 0)\n    if (CANBUS.autopilot_powertrain in fingerprint.keys()) and (0x2bf in fingerprint[CANBUS.autopilot_powertrain].keys()):\n      ret.openpilotLongitudinalControl = True\n      flags |= Panda.FLAG_TESLA_LONG_CONTROL\n      ret.safetyConfigs = [\n        get_safety_config(car.CarParams.SafetyModel.tesla, flags),\n        get_safety_config(car.CarParams.SafetyModel.tesla, flags | Panda.FLAG_TESLA_POWERTRAIN),\n      ]\n    else:\n      ret.openpilotLongitudinalControl = False\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.tesla, flags)]\n\n    ret.steerLimitTimer = 1.0\n    ret.steerActuatorDelay = 0.25\n    return ret\n\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam)\n\n    ret.events = self.create_common_events(ret).to_msg()\n\n    return ret\n", "selfdrive/car/honda/carstate.py": "from collections import defaultdict\n\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import interp\nfrom opendbc.can.can_define import CANDefine\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.honda.hondacan import CanBus, get_cruise_speed_conversion\nfrom openpilot.selfdrive.car.honda.values import CAR, DBC, STEER_THRESHOLD, HONDA_BOSCH, \\\n                                                 HONDA_NIDEC_ALT_SCM_MESSAGES, HONDA_BOSCH_RADARLESS, \\\n                                                 HondaFlags\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\n\nTransmissionType = car.CarParams.TransmissionType\n\n\ndef get_can_messages(CP, gearbox_msg):\n  messages = [\n    (\"ENGINE_DATA\", 100),\n    (\"WHEEL_SPEEDS\", 50),\n    (\"STEERING_SENSORS\", 100),\n    (\"SEATBELT_STATUS\", 10),\n    (\"CRUISE\", 10),\n    (\"POWERTRAIN_DATA\", 100),\n    (\"CAR_SPEED\", 10),\n    (\"VSA_STATUS\", 50),\n    (\"STEER_STATUS\", 100),\n    (\"STEER_MOTOR_TORQUE\", 0),  # TODO: not on every car\n  ]\n\n  if CP.carFingerprint == CAR.HONDA_ODYSSEY_CHN:\n    messages += [\n      (\"SCM_FEEDBACK\", 25),\n      (\"SCM_BUTTONS\", 50),\n    ]\n  else:\n    messages += [\n      (\"SCM_FEEDBACK\", 10),\n      (\"SCM_BUTTONS\", 25),\n    ]\n\n  if CP.carFingerprint in (CAR.HONDA_CRV_HYBRID, CAR.HONDA_CIVIC_BOSCH_DIESEL, CAR.ACURA_RDX_3G, CAR.HONDA_E):\n    messages.append((gearbox_msg, 50))\n  else:\n    messages.append((gearbox_msg, 100))\n\n  if CP.flags & HondaFlags.BOSCH_ALT_BRAKE:\n    messages.append((\"BRAKE_MODULE\", 50))\n\n  if CP.carFingerprint in (HONDA_BOSCH | {CAR.HONDA_CIVIC, CAR.HONDA_ODYSSEY, CAR.HONDA_ODYSSEY_CHN}):\n    messages.append((\"EPB_STATUS\", 50))\n\n  if CP.carFingerprint in HONDA_BOSCH:\n    # these messages are on camera bus on radarless cars\n    if not CP.openpilotLongitudinalControl and CP.carFingerprint not in HONDA_BOSCH_RADARLESS:\n      messages += [\n        (\"ACC_HUD\", 10),\n        (\"ACC_CONTROL\", 50),\n      ]\n  else:  # Nidec signals\n    if CP.carFingerprint == CAR.HONDA_ODYSSEY_CHN:\n      messages.append((\"CRUISE_PARAMS\", 10))\n    else:\n      messages.append((\"CRUISE_PARAMS\", 50))\n\n  # TODO: clean this up\n  if CP.carFingerprint in (CAR.HONDA_ACCORD, CAR.HONDA_CIVIC_BOSCH, CAR.HONDA_CIVIC_BOSCH_DIESEL, CAR.HONDA_CRV_HYBRID, CAR.HONDA_INSIGHT,\n                           CAR.ACURA_RDX_3G, CAR.HONDA_E, CAR.HONDA_CIVIC_2022, CAR.HONDA_HRV_3G):\n    pass\n  elif CP.carFingerprint in (CAR.HONDA_ODYSSEY_CHN, CAR.HONDA_FREED, CAR.HONDA_HRV):\n    pass\n  else:\n    messages.append((\"DOORS_STATUS\", 3))\n\n  if CP.carFingerprint in HONDA_BOSCH_RADARLESS:\n    messages.append((\"CRUISE_FAULT_STATUS\", 50))\n  elif CP.openpilotLongitudinalControl:\n    messages.append((\"STANDSTILL\", 50))\n\n  return messages\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n    self.gearbox_msg = \"GEARBOX\"\n    if CP.carFingerprint == CAR.HONDA_ACCORD and CP.transmissionType == TransmissionType.cvt:\n      self.gearbox_msg = \"GEARBOX_15T\"\n\n    self.main_on_sig_msg = \"SCM_FEEDBACK\"\n    if CP.carFingerprint in HONDA_NIDEC_ALT_SCM_MESSAGES:\n      self.main_on_sig_msg = \"SCM_BUTTONS\"\n\n    self.shifter_values = can_define.dv[self.gearbox_msg][\"GEAR_SHIFTER\"]\n    self.steer_status_values = defaultdict(lambda: \"UNKNOWN\", can_define.dv[\"STEER_STATUS\"][\"STEER_STATUS\"])\n\n    self.brake_switch_prev = False\n    self.brake_switch_active = False\n    self.cruise_setting = 0\n    self.v_cruise_pcm_prev = 0\n\n    # When available we use cp.vl[\"CAR_SPEED\"][\"ROUGH_CAR_SPEED_2\"] to populate vEgoCluster\n    # However, on cars without a digital speedometer this is not always present (HRV, FIT, CRV 2016, ILX and RDX)\n    self.dash_speed_seen = False\n\n  def update(self, cp, cp_cam, cp_body):\n    ret = car.CarState.new_message()\n\n    # car params\n    v_weight_v = [0., 1.]  # don't trust smooth speed at low values to avoid premature zero snapping\n    v_weight_bp = [1., 6.]   # smooth blending, below ~0.6m/s the smooth speed snaps to zero\n\n    # update prevs, update must run once per loop\n    self.prev_cruise_buttons = self.cruise_buttons\n    self.prev_cruise_setting = self.cruise_setting\n    self.cruise_setting = cp.vl[\"SCM_BUTTONS\"][\"CRUISE_SETTING\"]\n    self.cruise_buttons = cp.vl[\"SCM_BUTTONS\"][\"CRUISE_BUTTONS\"]\n\n    # used for car hud message\n    self.is_metric = not cp.vl[\"CAR_SPEED\"][\"IMPERIAL_UNIT\"]\n\n    # ******************* parse out can *******************\n    # STANDSTILL->WHEELS_MOVING bit can be noisy around zero, so use XMISSION_SPEED\n    # panda checks if the signal is non-zero\n    ret.standstill = cp.vl[\"ENGINE_DATA\"][\"XMISSION_SPEED\"] < 1e-5\n    # TODO: find a common signal across all cars\n    if self.CP.carFingerprint in (CAR.HONDA_ACCORD, CAR.HONDA_CIVIC_BOSCH, CAR.HONDA_CIVIC_BOSCH_DIESEL, CAR.HONDA_CRV_HYBRID, CAR.HONDA_INSIGHT,\n                                  CAR.ACURA_RDX_3G, CAR.HONDA_E, CAR.HONDA_CIVIC_2022, CAR.HONDA_HRV_3G):\n      ret.doorOpen = bool(cp.vl[\"SCM_FEEDBACK\"][\"DRIVERS_DOOR_OPEN\"])\n    elif self.CP.carFingerprint in (CAR.HONDA_ODYSSEY_CHN, CAR.HONDA_FREED, CAR.HONDA_HRV):\n      ret.doorOpen = bool(cp.vl[\"SCM_BUTTONS\"][\"DRIVERS_DOOR_OPEN\"])\n    else:\n      ret.doorOpen = any([cp.vl[\"DOORS_STATUS\"][\"DOOR_OPEN_FL\"], cp.vl[\"DOORS_STATUS\"][\"DOOR_OPEN_FR\"],\n                          cp.vl[\"DOORS_STATUS\"][\"DOOR_OPEN_RL\"], cp.vl[\"DOORS_STATUS\"][\"DOOR_OPEN_RR\"]])\n    ret.seatbeltUnlatched = bool(cp.vl[\"SEATBELT_STATUS\"][\"SEATBELT_DRIVER_LAMP\"] or not cp.vl[\"SEATBELT_STATUS\"][\"SEATBELT_DRIVER_LATCHED\"])\n\n    steer_status = self.steer_status_values[cp.vl[\"STEER_STATUS\"][\"STEER_STATUS\"]]\n    ret.steerFaultPermanent = steer_status not in (\"NORMAL\", \"NO_TORQUE_ALERT_1\", \"NO_TORQUE_ALERT_2\", \"LOW_SPEED_LOCKOUT\", \"TMP_FAULT\")\n    # LOW_SPEED_LOCKOUT is not worth a warning\n    # NO_TORQUE_ALERT_2 can be caused by bump or steering nudge from driver\n    ret.steerFaultTemporary = steer_status not in (\"NORMAL\", \"LOW_SPEED_LOCKOUT\", \"NO_TORQUE_ALERT_2\")\n\n    if self.CP.carFingerprint in HONDA_BOSCH_RADARLESS:\n      ret.accFaulted = bool(cp.vl[\"CRUISE_FAULT_STATUS\"][\"CRUISE_FAULT\"])\n    else:\n      # On some cars, these two signals are always 1, this flag is masking a bug in release\n      # FIXME: find and set the ACC faulted signals on more platforms\n      if self.CP.openpilotLongitudinalControl:\n        ret.accFaulted = bool(cp.vl[\"STANDSTILL\"][\"BRAKE_ERROR_1\"] or cp.vl[\"STANDSTILL\"][\"BRAKE_ERROR_2\"])\n\n      # Log non-critical stock ACC/LKAS faults if Nidec (camera)\n      if self.CP.carFingerprint not in HONDA_BOSCH:\n        ret.carFaultedNonCritical = bool(cp_cam.vl[\"ACC_HUD\"][\"ACC_PROBLEM\"] or cp_cam.vl[\"LKAS_HUD\"][\"LKAS_PROBLEM\"])\n\n    ret.espDisabled = cp.vl[\"VSA_STATUS\"][\"ESP_DISABLED\"] != 0\n\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_FL\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_FR\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_RL\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_RR\"],\n    )\n    v_wheel = (ret.wheelSpeeds.fl + ret.wheelSpeeds.fr + ret.wheelSpeeds.rl + ret.wheelSpeeds.rr) / 4.0\n\n    # blend in transmission speed at low speed, since it has more low speed accuracy\n    v_weight = interp(v_wheel, v_weight_bp, v_weight_v)\n    ret.vEgoRaw = (1. - v_weight) * cp.vl[\"ENGINE_DATA\"][\"XMISSION_SPEED\"] * CV.KPH_TO_MS * self.CP.wheelSpeedFactor + v_weight * v_wheel\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n\n    self.dash_speed_seen = self.dash_speed_seen or cp.vl[\"CAR_SPEED\"][\"ROUGH_CAR_SPEED_2\"] > 1e-3\n    if self.dash_speed_seen:\n      conversion = CV.KPH_TO_MS if self.is_metric else CV.MPH_TO_MS\n      ret.vEgoCluster = cp.vl[\"CAR_SPEED\"][\"ROUGH_CAR_SPEED_2\"] * conversion\n\n    ret.steeringAngleDeg = cp.vl[\"STEERING_SENSORS\"][\"STEER_ANGLE\"]\n    ret.steeringRateDeg = cp.vl[\"STEERING_SENSORS\"][\"STEER_ANGLE_RATE\"]\n\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_stalk(\n      250, cp.vl[\"SCM_FEEDBACK\"][\"LEFT_BLINKER\"], cp.vl[\"SCM_FEEDBACK\"][\"RIGHT_BLINKER\"])\n    ret.brakeHoldActive = cp.vl[\"VSA_STATUS\"][\"BRAKE_HOLD_ACTIVE\"] == 1\n\n    # TODO: set for all cars\n    if self.CP.carFingerprint in (HONDA_BOSCH | {CAR.HONDA_CIVIC, CAR.HONDA_ODYSSEY, CAR.HONDA_ODYSSEY_CHN}):\n      ret.parkingBrake = cp.vl[\"EPB_STATUS\"][\"EPB_STATE\"] != 0\n\n    gear = int(cp.vl[self.gearbox_msg][\"GEAR_SHIFTER\"])\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(gear, None))\n\n    ret.gas = cp.vl[\"POWERTRAIN_DATA\"][\"PEDAL_GAS\"]\n    ret.gasPressed = ret.gas > 1e-5\n\n    ret.steeringTorque = cp.vl[\"STEER_STATUS\"][\"STEER_TORQUE_SENSOR\"]\n    ret.steeringTorqueEps = cp.vl[\"STEER_MOTOR_TORQUE\"][\"MOTOR_TORQUE\"]\n    ret.steeringPressed = abs(ret.steeringTorque) > STEER_THRESHOLD.get(self.CP.carFingerprint, 1200)\n\n    if self.CP.carFingerprint in HONDA_BOSCH:\n      # The PCM always manages its own cruise control state, but doesn't publish it\n      if self.CP.carFingerprint in HONDA_BOSCH_RADARLESS:\n        ret.cruiseState.nonAdaptive = cp_cam.vl[\"ACC_HUD\"][\"CRUISE_CONTROL_LABEL\"] != 0\n\n      if not self.CP.openpilotLongitudinalControl:\n        # ACC_HUD is on camera bus on radarless cars\n        acc_hud = cp_cam.vl[\"ACC_HUD\"] if self.CP.carFingerprint in HONDA_BOSCH_RADARLESS else cp.vl[\"ACC_HUD\"]\n        ret.cruiseState.nonAdaptive = acc_hud[\"CRUISE_CONTROL_LABEL\"] != 0\n        ret.cruiseState.standstill = acc_hud[\"CRUISE_SPEED\"] == 252.\n\n        conversion = get_cruise_speed_conversion(self.CP.carFingerprint, self.is_metric)\n        # On set, cruise set speed pulses between 254~255 and the set speed prev is set to avoid this.\n        ret.cruiseState.speed = self.v_cruise_pcm_prev if acc_hud[\"CRUISE_SPEED\"] > 160.0 else acc_hud[\"CRUISE_SPEED\"] * conversion\n        self.v_cruise_pcm_prev = ret.cruiseState.speed\n    else:\n      ret.cruiseState.speed = cp.vl[\"CRUISE\"][\"CRUISE_SPEED_PCM\"] * CV.KPH_TO_MS\n\n    if self.CP.flags & HondaFlags.BOSCH_ALT_BRAKE:\n      ret.brakePressed = cp.vl[\"BRAKE_MODULE\"][\"BRAKE_PRESSED\"] != 0\n    else:\n      # brake switch has shown some single time step noise, so only considered when\n      # switch is on for at least 2 consecutive CAN samples\n      # brake switch rises earlier than brake pressed but is never 1 when in park\n      brake_switch_vals = cp.vl_all[\"POWERTRAIN_DATA\"][\"BRAKE_SWITCH\"]\n      if len(brake_switch_vals):\n        brake_switch = cp.vl[\"POWERTRAIN_DATA\"][\"BRAKE_SWITCH\"] != 0\n        if len(brake_switch_vals) > 1:\n          self.brake_switch_prev = brake_switch_vals[-2] != 0\n        self.brake_switch_active = brake_switch and self.brake_switch_prev\n        self.brake_switch_prev = brake_switch\n      ret.brakePressed = (cp.vl[\"POWERTRAIN_DATA\"][\"BRAKE_PRESSED\"] != 0) or self.brake_switch_active\n\n    ret.brake = cp.vl[\"VSA_STATUS\"][\"USER_BRAKE\"]\n    ret.cruiseState.enabled = cp.vl[\"POWERTRAIN_DATA\"][\"ACC_STATUS\"] != 0\n    ret.cruiseState.available = bool(cp.vl[self.main_on_sig_msg][\"MAIN_ON\"])\n\n    # Gets rid of Pedal Grinding noise when brake is pressed at slow speeds for some models\n    if self.CP.carFingerprint in (CAR.HONDA_PILOT, CAR.HONDA_RIDGELINE):\n      if ret.brake > 0.1:\n        ret.brakePressed = True\n\n    if self.CP.carFingerprint in HONDA_BOSCH:\n      # TODO: find the radarless AEB_STATUS bit and make sure ACCEL_COMMAND is correct to enable AEB alerts\n      if self.CP.carFingerprint not in HONDA_BOSCH_RADARLESS:\n        ret.stockAeb = (not self.CP.openpilotLongitudinalControl) and bool(cp.vl[\"ACC_CONTROL\"][\"AEB_STATUS\"] and cp.vl[\"ACC_CONTROL\"][\"ACCEL_COMMAND\"] < -1e-5)\n    else:\n      ret.stockAeb = bool(cp_cam.vl[\"BRAKE_COMMAND\"][\"AEB_REQ_1\"] and cp_cam.vl[\"BRAKE_COMMAND\"][\"COMPUTER_BRAKE\"] > 1e-5)\n\n    self.acc_hud = False\n    self.lkas_hud = False\n    if self.CP.carFingerprint not in HONDA_BOSCH:\n      ret.stockFcw = cp_cam.vl[\"BRAKE_COMMAND\"][\"FCW\"] != 0\n      self.acc_hud = cp_cam.vl[\"ACC_HUD\"]\n      self.stock_brake = cp_cam.vl[\"BRAKE_COMMAND\"]\n    if self.CP.carFingerprint in HONDA_BOSCH_RADARLESS:\n      self.lkas_hud = cp_cam.vl[\"LKAS_HUD\"]\n\n    if self.CP.enableBsm:\n      # BSM messages are on B-CAN, requires a panda forwarding B-CAN messages to CAN 0\n      # more info here: https://github.com/commaai/openpilot/pull/1867\n      ret.leftBlindspot = cp_body.vl[\"BSM_STATUS_LEFT\"][\"BSM_ALERT\"] == 1\n      ret.rightBlindspot = cp_body.vl[\"BSM_STATUS_RIGHT\"][\"BSM_ALERT\"] == 1\n\n    return ret\n\n  def get_can_parser(self, CP):\n    messages = get_can_messages(CP, self.gearbox_msg)\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus(CP).pt)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = [\n      (\"STEERING_CONTROL\", 100),\n    ]\n\n    if CP.carFingerprint in HONDA_BOSCH_RADARLESS:\n      messages += [\n        (\"ACC_HUD\", 10),\n        (\"LKAS_HUD\", 10),\n      ]\n\n    elif CP.carFingerprint not in HONDA_BOSCH:\n      messages += [\n        (\"ACC_HUD\", 10),\n        (\"LKAS_HUD\", 10),\n        (\"BRAKE_COMMAND\", 50),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus(CP).camera)\n\n  @staticmethod\n  def get_body_can_parser(CP):\n    if CP.enableBsm:\n      messages = [\n        (\"BSM_STATUS_LEFT\", 3),\n        (\"BSM_STATUS_RIGHT\", 3),\n      ]\n      bus_body = CanBus(CP).radar # B-CAN is forwarded to ACC-CAN radar side (CAN 0 on fake ethernet port)\n      return CANParser(DBC[CP.carFingerprint][\"body\"], messages, bus_body)\n    return None\n", "selfdrive/car/honda/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.honda.values import CAR\n\nEcu = car.CarParams.Ecu\n\n# Modified FW can be identified by the second dash being replaced by a comma\n# For example: `b'39990-TVA,A150\\x00\\x00'`\n#\n# TODO: vsa is \"essential\" for fpv2 but doesn't appear on some CAR.FREED models\n\n\nFW_VERSIONS = {\n  CAR.HONDA_ACCORD: {\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TVC-A910\\x00\\x00',\n      b'54008-TWA-A910\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-6A7-A220\\x00\\x00',\n      b'28101-6A7-A230\\x00\\x00',\n      b'28101-6A7-A320\\x00\\x00',\n      b'28101-6A7-A330\\x00\\x00',\n      b'28101-6A7-A410\\x00\\x00',\n      b'28101-6A7-A510\\x00\\x00',\n      b'28101-6A7-A610\\x00\\x00',\n      b'28101-6A7-A710\\x00\\x00',\n      b'28101-6A9-H140\\x00\\x00',\n      b'28101-6A9-H420\\x00\\x00',\n      b'28102-6B8-A560\\x00\\x00',\n      b'28102-6B8-A570\\x00\\x00',\n      b'28102-6B8-A700\\x00\\x00',\n      b'28102-6B8-A800\\x00\\x00',\n      b'28102-6B8-C560\\x00\\x00',\n      b'28102-6B8-C570\\x00\\x00',\n      b'28102-6B8-M520\\x00\\x00',\n      b'28102-6B8-R700\\x00\\x00',\n    ],\n    (Ecu.electricBrakeBooster, 0x18da2bf1, None): [\n      b'46114-TVA-A050\\x00\\x00',\n      b'46114-TVA-A060\\x00\\x00',\n      b'46114-TVA-A080\\x00\\x00',\n      b'46114-TVA-A120\\x00\\x00',\n      b'46114-TVA-A320\\x00\\x00',\n      b'46114-TVE-H550\\x00\\x00',\n      b'46114-TVE-H560\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TVA-B040\\x00\\x00',\n      b'57114-TVA-B050\\x00\\x00',\n      b'57114-TVA-B060\\x00\\x00',\n      b'57114-TVA-B530\\x00\\x00',\n      b'57114-TVA-C040\\x00\\x00',\n      b'57114-TVA-C050\\x00\\x00',\n      b'57114-TVA-C060\\x00\\x00',\n      b'57114-TVA-C530\\x00\\x00',\n      b'57114-TVA-E520\\x00\\x00',\n      b'57114-TVE-H250\\x00\\x00',\n      b'57114-TWA-A040\\x00\\x00',\n      b'57114-TWA-A050\\x00\\x00',\n      b'57114-TWA-A530\\x00\\x00',\n      b'57114-TWA-B520\\x00\\x00',\n      b'57114-TWA-C510\\x00\\x00',\n      b'57114-TWB-H030\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TBX-H120\\x00\\x00',\n      b'39990-TVA,A150\\x00\\x00',\n      b'39990-TVA-A140\\x00\\x00',\n      b'39990-TVA-A150\\x00\\x00',\n      b'39990-TVA-A160\\x00\\x00',\n      b'39990-TVA-A340\\x00\\x00',\n      b'39990-TVA-X030\\x00\\x00',\n      b'39990-TVA-X040\\x00\\x00',\n      b'39990-TVE-H130\\x00\\x00',\n      b'39990-TWB-H120\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TBX-H230\\x00\\x00',\n      b'77959-TVA-A460\\x00\\x00',\n      b'77959-TVA-F330\\x00\\x00',\n      b'77959-TVA-H230\\x00\\x00',\n      b'77959-TVA-L420\\x00\\x00',\n      b'77959-TVA-X330\\x00\\x00',\n      b'77959-TWA-A440\\x00\\x00',\n      b'77959-TWA-L420\\x00\\x00',\n      b'77959-TWB-H220\\x00\\x00',\n    ],\n    (Ecu.hud, 0x18da61f1, None): [\n      b'78209-TVA-A010\\x00\\x00',\n      b'78209-TVA-A110\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TBX-H140\\x00\\x00',\n      b'36802-TVA-A150\\x00\\x00',\n      b'36802-TVA-A160\\x00\\x00',\n      b'36802-TVA-A170\\x00\\x00',\n      b'36802-TVA-A180\\x00\\x00',\n      b'36802-TVA-A330\\x00\\x00',\n      b'36802-TVC-A330\\x00\\x00',\n      b'36802-TVE-H070\\x00\\x00',\n      b'36802-TWA-A070\\x00\\x00',\n      b'36802-TWA-A080\\x00\\x00',\n      b'36802-TWA-A210\\x00\\x00',\n      b'36802-TWA-A330\\x00\\x00',\n      b'36802-TWB-H060\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TBX-H130\\x00\\x00',\n      b'36161-TVA-A060\\x00\\x00',\n      b'36161-TVA-A330\\x00\\x00',\n      b'36161-TVC-A330\\x00\\x00',\n      b'36161-TVE-H050\\x00\\x00',\n      b'36161-TWA-A070\\x00\\x00',\n      b'36161-TWA-A330\\x00\\x00',\n      b'36161-TWB-H040\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TVA-A010\\x00\\x00',\n      b'38897-TVA-A020\\x00\\x00',\n      b'38897-TVA-A230\\x00\\x00',\n      b'38897-TVA-A240\\x00\\x00',\n      b'38897-TWA-A120\\x00\\x00',\n      b'38897-TWD-J020\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CIVIC: {\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-5CG-A040\\x00\\x00',\n      b'28101-5CG-A050\\x00\\x00',\n      b'28101-5CG-A070\\x00\\x00',\n      b'28101-5CG-A080\\x00\\x00',\n      b'28101-5CG-A320\\x00\\x00',\n      b'28101-5CG-A810\\x00\\x00',\n      b'28101-5CG-A820\\x00\\x00',\n      b'28101-5DJ-A040\\x00\\x00',\n      b'28101-5DJ-A060\\x00\\x00',\n      b'28101-5DJ-A510\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TBA-A540\\x00\\x00',\n      b'57114-TBA-A550\\x00\\x00',\n      b'57114-TBA-A560\\x00\\x00',\n      b'57114-TBA-A570\\x00\\x00',\n      b'57114-TEA-Q220\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TBA,A030\\x00\\x00',\n      b'39990-TBA-A030\\x00\\x00',\n      b'39990-TBG-A030\\x00\\x00',\n      b'39990-TEA-T020\\x00\\x00',\n      b'39990-TEG-A010\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TBA-A030\\x00\\x00',\n      b'77959-TBA-A040\\x00\\x00',\n      b'77959-TBG-A020\\x00\\x00',\n      b'77959-TBG-A030\\x00\\x00',\n      b'77959-TEA-Q820\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-TBA-A020\\x00\\x00',\n      b'36161-TBA-A030\\x00\\x00',\n      b'36161-TBA-A040\\x00\\x00',\n      b'36161-TBC-A020\\x00\\x00',\n      b'36161-TBC-A030\\x00\\x00',\n      b'36161-TED-Q320\\x00\\x00',\n      b'36161-TEG-A010\\x00\\x00',\n      b'36161-TEG-A020\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TBA-A010\\x00\\x00',\n      b'38897-TBA-A020\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CIVIC_BOSCH: {\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-5CG-A920\\x00\\x00',\n      b'28101-5CG-AB10\\x00\\x00',\n      b'28101-5CG-C110\\x00\\x00',\n      b'28101-5CG-C220\\x00\\x00',\n      b'28101-5CG-C320\\x00\\x00',\n      b'28101-5CG-G020\\x00\\x00',\n      b'28101-5CG-L020\\x00\\x00',\n      b'28101-5CK-A130\\x00\\x00',\n      b'28101-5CK-A140\\x00\\x00',\n      b'28101-5CK-A150\\x00\\x00',\n      b'28101-5CK-C130\\x00\\x00',\n      b'28101-5CK-C140\\x00\\x00',\n      b'28101-5CK-C150\\x00\\x00',\n      b'28101-5CK-G210\\x00\\x00',\n      b'28101-5CK-J710\\x00\\x00',\n      b'28101-5CK-Q610\\x00\\x00',\n      b'28101-5DJ-A610\\x00\\x00',\n      b'28101-5DJ-A710\\x00\\x00',\n      b'28101-5DV-E330\\x00\\x00',\n      b'28101-5DV-E610\\x00\\x00',\n      b'28101-5DV-E820\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TBG-A330\\x00\\x00',\n      b'57114-TBG-A340\\x00\\x00',\n      b'57114-TBG-A350\\x00\\x00',\n      b'57114-TGG-A340\\x00\\x00',\n      b'57114-TGG-C320\\x00\\x00',\n      b'57114-TGG-G320\\x00\\x00',\n      b'57114-TGG-L320\\x00\\x00',\n      b'57114-TGG-L330\\x00\\x00',\n      b'57114-TGH-L130\\x00\\x00',\n      b'57114-TGK-T320\\x00\\x00',\n      b'57114-TGL-G330\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TBA-C020\\x00\\x00',\n      b'39990-TBA-C120\\x00\\x00',\n      b'39990-TEA-T820\\x00\\x00',\n      b'39990-TEZ-T020\\x00\\x00',\n      b'39990-TGG,A020\\x00\\x00',\n      b'39990-TGG,A120\\x00\\x00',\n      b'39990-TGG-A020\\x00\\x00',\n      b'39990-TGG-A120\\x00\\x00',\n      b'39990-TGG-J510\\x00\\x00',\n      b'39990-TGH-J530\\x00\\x00',\n      b'39990-TGL-E130\\x00\\x00',\n      b'39990-TGN-E120\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TBA-A060\\x00\\x00',\n      b'77959-TBG-A050\\x00\\x00',\n      b'77959-TEA-G020\\x00\\x00',\n      b'77959-TGG-A020\\x00\\x00',\n      b'77959-TGG-A030\\x00\\x00',\n      b'77959-TGG-E010\\x00\\x00',\n      b'77959-TGG-G010\\x00\\x00',\n      b'77959-TGG-G110\\x00\\x00',\n      b'77959-TGG-J320\\x00\\x00',\n      b'77959-TGG-Z820\\x00\\x00',\n      b'77959-TGH-J110\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TBA-A150\\x00\\x00',\n      b'36802-TBA-A160\\x00\\x00',\n      b'36802-TFJ-G060\\x00\\x00',\n      b'36802-TGG-A050\\x00\\x00',\n      b'36802-TGG-A060\\x00\\x00',\n      b'36802-TGG-A070\\x00\\x00',\n      b'36802-TGG-A130\\x00\\x00',\n      b'36802-TGG-G040\\x00\\x00',\n      b'36802-TGG-G130\\x00\\x00',\n      b'36802-TGH-A140\\x00\\x00',\n      b'36802-TGK-Q120\\x00\\x00',\n      b'36802-TGL-G040\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TBA-A130\\x00\\x00',\n      b'36161-TBA-A140\\x00\\x00',\n      b'36161-TFJ-G070\\x00\\x00',\n      b'36161-TGG-A060\\x00\\x00',\n      b'36161-TGG-A080\\x00\\x00',\n      b'36161-TGG-A120\\x00\\x00',\n      b'36161-TGG-G050\\x00\\x00',\n      b'36161-TGG-G070\\x00\\x00',\n      b'36161-TGG-G130\\x00\\x00',\n      b'36161-TGG-G140\\x00\\x00',\n      b'36161-TGH-A140\\x00\\x00',\n      b'36161-TGK-Q120\\x00\\x00',\n      b'36161-TGL-G050\\x00\\x00',\n      b'36161-TGL-G070\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TBA-A020\\x00\\x00',\n      b'38897-TBA-A110\\x00\\x00',\n      b'38897-TGH-A010\\x00\\x00',\n    ],\n    (Ecu.electricBrakeBooster, 0x18da2bf1, None): [\n      b'39494-TGL-G030\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CIVIC_BOSCH_DIESEL: {\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-59Y-G220\\x00\\x00',\n      b'28101-59Y-G620\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TGN-E320\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TFK-G020\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TFK-G210\\x00\\x00',\n      b'77959-TGN-G220\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TFK-G130\\x00\\x00',\n      b'36802-TGN-G130\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TGN-E010\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TFK-G130\\x00\\x00',\n      b'36161-TGN-G130\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TBA-A020\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CRV: {\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-T1W-A230\\x00\\x00',\n      b'57114-T1W-A240\\x00\\x00',\n      b'57114-TFF-A940\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T0A-A230\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T1W-A830\\x00\\x00',\n      b'36161-T1W-C830\\x00\\x00',\n      b'36161-T1X-A830\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CRV_5G: {\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-5RG-A020\\x00\\x00',\n      b'28101-5RG-A030\\x00\\x00',\n      b'28101-5RG-A040\\x00\\x00',\n      b'28101-5RG-A120\\x00\\x00',\n      b'28101-5RG-A220\\x00\\x00',\n      b'28101-5RH-A020\\x00\\x00',\n      b'28101-5RH-A030\\x00\\x00',\n      b'28101-5RH-A040\\x00\\x00',\n      b'28101-5RH-A120\\x00\\x00',\n      b'28101-5RH-A220\\x00\\x00',\n      b'28101-5RL-Q010\\x00\\x00',\n      b'28101-5RM-F010\\x00\\x00',\n      b'28101-5RM-K010\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TLA-A040\\x00\\x00',\n      b'57114-TLA-A050\\x00\\x00',\n      b'57114-TLA-A060\\x00\\x00',\n      b'57114-TLB-A830\\x00\\x00',\n      b'57114-TMC-Z040\\x00\\x00',\n      b'57114-TMC-Z050\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TLA,A040\\x00\\x00',\n      b'39990-TLA-A040\\x00\\x00',\n      b'39990-TLA-A110\\x00\\x00',\n      b'39990-TLA-A220\\x00\\x00',\n      b'39990-TME-T030\\x00\\x00',\n      b'39990-TME-T120\\x00\\x00',\n      b'39990-TMT-T010\\x00\\x00',\n    ],\n    (Ecu.electricBrakeBooster, 0x18da2bf1, None): [\n      b'46114-TLA-A040\\x00\\x00',\n      b'46114-TLA-A050\\x00\\x00',\n      b'46114-TLA-A930\\x00\\x00',\n      b'46114-TMC-U020\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TLA-A010\\x00\\x00',\n      b'38897-TLA-A110\\x00\\x00',\n      b'38897-TNY-G010\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TLA-A040\\x00\\x00',\n      b'36802-TLA-A050\\x00\\x00',\n      b'36802-TLA-A060\\x00\\x00',\n      b'36802-TLA-A070\\x00\\x00',\n      b'36802-TMC-Q040\\x00\\x00',\n      b'36802-TMC-Q070\\x00\\x00',\n      b'36802-TNY-A030\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TLA-A060\\x00\\x00',\n      b'36161-TLA-A070\\x00\\x00',\n      b'36161-TLA-A080\\x00\\x00',\n      b'36161-TMC-Q020\\x00\\x00',\n      b'36161-TMC-Q030\\x00\\x00',\n      b'36161-TMC-Q040\\x00\\x00',\n      b'36161-TNY-A020\\x00\\x00',\n      b'36161-TNY-A030\\x00\\x00',\n      b'36161-TNY-A040\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TLA-A240\\x00\\x00',\n      b'77959-TLA-A250\\x00\\x00',\n      b'77959-TLA-A320\\x00\\x00',\n      b'77959-TLA-A410\\x00\\x00',\n      b'77959-TLA-A420\\x00\\x00',\n      b'77959-TLA-Q040\\x00\\x00',\n      b'77959-TLA-Z040\\x00\\x00',\n      b'77959-TMM-F040\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CRV_EU: {\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-T1V-G920\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T1V-G520\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-T1V-G010\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-5LH-E120\\x00\\x00',\n      b'28103-5LH-E100\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T1G-G940\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CRV_HYBRID: {\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TMB-H030\\x00\\x00',\n      b'57114-TPA-G020\\x00\\x00',\n      b'57114-TPG-A020\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TMA-H020\\x00\\x00',\n      b'39990-TPA-G030\\x00\\x00',\n      b'39990-TPG-A020\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TMA-H110\\x00\\x00',\n      b'38897-TPG-A110\\x00\\x00',\n      b'38897-TPG-A210\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TMB-H510\\x00\\x00',\n      b'54008-TMB-H610\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TMB-H040\\x00\\x00',\n      b'36161-TPA-E050\\x00\\x00',\n      b'36161-TPG-A030\\x00\\x00',\n      b'36161-TPG-A040\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TMB-H040\\x00\\x00',\n      b'36802-TPA-E040\\x00\\x00',\n      b'36802-TPG-A020\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TLA-C320\\x00\\x00',\n      b'77959-TLA-C410\\x00\\x00',\n      b'77959-TLA-C420\\x00\\x00',\n      b'77959-TLA-G220\\x00\\x00',\n      b'77959-TLA-H240\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_FIT: {\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-T5R-L020\\x00\\x00',\n      b'57114-T5R-L220\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-T5R-C020\\x00\\x00',\n      b'39990-T5R-C030\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-T5A-J010\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T5R-A040\\x00\\x00',\n      b'36161-T5R-A240\\x00\\x00',\n      b'36161-T5R-A520\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T5R-A230\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_FREED: {\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TDK-J010\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TDK-J050\\x00\\x00',\n      b'39990-TDK-N020\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TDK-J120\\x00\\x00',\n      b'57114-TDK-J330\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-TDK-J070\\x00\\x00',\n      b'36161-TDK-J080\\x00\\x00',\n      b'36161-TDK-J530\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_ODYSSEY: {\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-THR-A010\\x00\\x00',\n      b'38897-THR-A020\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-THR-A020\\x00\\x00',\n      b'39990-THR-A030\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-THR-A010\\x00\\x00',\n      b'77959-THR-A110\\x00\\x00',\n      b'77959-THR-X010\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-THR-A020\\x00\\x00',\n      b'36161-THR-A030\\x00\\x00',\n      b'36161-THR-A110\\x00\\x00',\n      b'36161-THR-A720\\x00\\x00',\n      b'36161-THR-A730\\x00\\x00',\n      b'36161-THR-A810\\x00\\x00',\n      b'36161-THR-A910\\x00\\x00',\n      b'36161-THR-C010\\x00\\x00',\n      b'36161-THR-D110\\x00\\x00',\n      b'36161-THR-K020\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-5NZ-A110\\x00\\x00',\n      b'28101-5NZ-A310\\x00\\x00',\n      b'28101-5NZ-C310\\x00\\x00',\n      b'28102-5MX-A001\\x00\\x00',\n      b'28102-5MX-A600\\x00\\x00',\n      b'28102-5MX-A610\\x00\\x00',\n      b'28102-5MX-A700\\x00\\x00',\n      b'28102-5MX-A710\\x00\\x00',\n      b'28102-5MX-A900\\x00\\x00',\n      b'28102-5MX-A910\\x00\\x00',\n      b'28102-5MX-C001\\x00\\x00',\n      b'28102-5MX-C910\\x00\\x00',\n      b'28102-5MX-D001\\x00\\x00',\n      b'28102-5MX-D710\\x00\\x00',\n      b'28102-5MX-K610\\x00\\x00',\n      b'28103-5NZ-A100\\x00\\x00',\n      b'28103-5NZ-A300\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-THR-A040\\x00\\x00',\n      b'57114-THR-A110\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-THR-A020\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_ODYSSEY_CHN: {\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-T6D-H220\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-T6A-J010\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T6A-P040\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T6A-P110\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_PILOT: {\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TG7-A520\\x00\\x00',\n      b'54008-TG7-A530\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-5EY-A040\\x00\\x00',\n      b'28101-5EY-A050\\x00\\x00',\n      b'28101-5EY-A100\\x00\\x00',\n      b'28101-5EY-A430\\x00\\x00',\n      b'28101-5EY-A500\\x00\\x00',\n      b'28101-5EZ-A050\\x00\\x00',\n      b'28101-5EZ-A060\\x00\\x00',\n      b'28101-5EZ-A100\\x00\\x00',\n      b'28101-5EZ-A210\\x00\\x00',\n      b'28101-5EZ-A330\\x00\\x00',\n      b'28101-5EZ-A430\\x00\\x00',\n      b'28101-5EZ-A500\\x00\\x00',\n      b'28101-5EZ-A600\\x00\\x00',\n      b'28101-5EZ-A700\\x00\\x00',\n      b'28103-5EY-A110\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TG7-A030\\x00\\x00',\n      b'38897-TG7-A040\\x00\\x00',\n      b'38897-TG7-A110\\x00\\x00',\n      b'38897-TG7-A210\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TG7-A030\\x00\\x00',\n      b'39990-TG7-A040\\x00\\x00',\n      b'39990-TG7-A060\\x00\\x00',\n      b'39990-TG7-A070\\x00\\x00',\n      b'39990-TGS-A230\\x00\\x00',\n      b'39990-TGS-A320\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-TG7-A310\\x00\\x00',\n      b'36161-TG7-A520\\x00\\x00',\n      b'36161-TG7-A630\\x00\\x00',\n      b'36161-TG7-A720\\x00\\x00',\n      b'36161-TG7-A820\\x00\\x00',\n      b'36161-TG7-A930\\x00\\x00',\n      b'36161-TG7-C520\\x00\\x00',\n      b'36161-TG7-D520\\x00\\x00',\n      b'36161-TG7-D630\\x00\\x00',\n      b'36161-TG7-Y630\\x00\\x00',\n      b'36161-TG8-A410\\x00\\x00',\n      b'36161-TG8-A520\\x00\\x00',\n      b'36161-TG8-A630\\x00\\x00',\n      b'36161-TG8-A720\\x00\\x00',\n      b'36161-TG8-A830\\x00\\x00',\n      b'36161-TGS-A030\\x00\\x00',\n      b'36161-TGS-A130\\x00\\x00',\n      b'36161-TGS-A220\\x00\\x00',\n      b'36161-TGS-A320\\x00\\x00',\n      b'36161-TGT-A030\\x00\\x00',\n      b'36161-TGT-A130\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TG7-A020\\x00\\x00',\n      b'77959-TG7-A110\\x00\\x00',\n      b'77959-TG7-A210\\x00\\x00',\n      b'77959-TG7-Y210\\x00\\x00',\n      b'77959-TGS-A010\\x00\\x00',\n      b'77959-TGS-A110\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TG7-A130\\x00\\x00',\n      b'57114-TG7-A140\\x00\\x00',\n      b'57114-TG7-A230\\x00\\x00',\n      b'57114-TG7-A240\\x00\\x00',\n      b'57114-TG7-A630\\x00\\x00',\n      b'57114-TG7-A730\\x00\\x00',\n      b'57114-TG8-A140\\x00\\x00',\n      b'57114-TG8-A230\\x00\\x00',\n      b'57114-TG8-A240\\x00\\x00',\n      b'57114-TG8-A630\\x00\\x00',\n      b'57114-TG8-A730\\x00\\x00',\n      b'57114-TGS-A530\\x00\\x00',\n      b'57114-TGT-A530\\x00\\x00',\n    ],\n  },\n  CAR.ACURA_RDX: {\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TX4-A220\\x00\\x00',\n      b'57114-TX5-A220\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-TX4-A030\\x00\\x00',\n      b'36161-TX5-A030\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TX4-B010\\x00\\x00',\n      b'77959-TX4-C010\\x00\\x00',\n      b'77959-TX4-C020\\x00\\x00',\n    ],\n  },\n  CAR.ACURA_RDX_3G: {\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TJB-A030\\x00\\x00',\n      b'57114-TJB-A040\\x00\\x00',\n      b'57114-TJB-A120\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TJB-A040\\x00\\x00',\n      b'36802-TJB-A050\\x00\\x00',\n      b'36802-TJB-A540\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TJB-A040\\x00\\x00',\n      b'36161-TJB-A530\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TJB-A520\\x00\\x00',\n      b'54008-TJB-A530\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28102-5YK-A610\\x00\\x00',\n      b'28102-5YK-A620\\x00\\x00',\n      b'28102-5YK-A630\\x00\\x00',\n      b'28102-5YK-A700\\x00\\x00',\n      b'28102-5YK-A711\\x00\\x00',\n      b'28102-5YK-A800\\x00\\x00',\n      b'28102-5YL-A620\\x00\\x00',\n      b'28102-5YL-A700\\x00\\x00',\n      b'28102-5YL-A711\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TJB-A040\\x00\\x00',\n      b'77959-TJB-A120\\x00\\x00',\n      b'77959-TJB-A210\\x00\\x00',\n    ],\n    (Ecu.electricBrakeBooster, 0x18da2bf1, None): [\n      b'46114-TJB-A040\\x00\\x00',\n      b'46114-TJB-A050\\x00\\x00',\n      b'46114-TJB-A060\\x00\\x00',\n      b'46114-TJB-A120\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TJB-A040\\x00\\x00',\n      b'38897-TJB-A110\\x00\\x00',\n      b'38897-TJB-A120\\x00\\x00',\n      b'38897-TJB-A220\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TJB-A030\\x00\\x00',\n      b'39990-TJB-A040\\x00\\x00',\n      b'39990-TJB-A070\\x00\\x00',\n      b'39990-TJB-A130\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_RIDGELINE: {\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-T6Z-A020\\x00\\x00',\n      b'39990-T6Z-A030\\x00\\x00',\n      b'39990-T6Z-A050\\x00\\x00',\n      b'39990-T6Z-A110\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T6Z-A020\\x00\\x00',\n      b'36161-T6Z-A310\\x00\\x00',\n      b'36161-T6Z-A420\\x00\\x00',\n      b'36161-T6Z-A520\\x00\\x00',\n      b'36161-T6Z-A620\\x00\\x00',\n      b'36161-T6Z-A720\\x00\\x00',\n      b'36161-TJZ-A120\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-T6Z-A010\\x00\\x00',\n      b'38897-T6Z-A110\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T6Z-A020\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-T6Z-A120\\x00\\x00',\n      b'57114-T6Z-A130\\x00\\x00',\n      b'57114-T6Z-A520\\x00\\x00',\n      b'57114-T6Z-A610\\x00\\x00',\n      b'57114-TJZ-A520\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_INSIGHT: {\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TXM-A040\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TXM-A070\\x00\\x00',\n      b'36802-TXM-A080\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TXM-A050\\x00\\x00',\n      b'36161-TXM-A060\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TXM-A230\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TXM-A030\\x00\\x00',\n      b'57114-TXM-A040\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TWA-A910\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TXM-A020\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_HRV: {\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-T7A-A010\\x00\\x00',\n      b'38897-T7A-A110\\x00\\x00',\n    ],\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-THX-A020\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T7A-A040\\x00\\x00',\n      b'36161-T7A-A140\\x00\\x00',\n      b'36161-T7A-A240\\x00\\x00',\n      b'36161-T7A-C440\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T7A-A230\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_HRV_3G: {\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-3M0-G110\\x00\\x00',\n      b'39990-3W0-A030\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-3M0-M110\\x00\\x00',\n      b'38897-3W1-A010\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-3M0-K840\\x00\\x00',\n      b'77959-3V0-A820\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'8S102-3M6-P030\\x00\\x00',\n      b'8S102-3W0-A060\\x00\\x00',\n      b'8S102-3W0-AB10\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-3M6-M010\\x00\\x00',\n      b'57114-3W0-A040\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-6EH-A010\\x00\\x00',\n      b'28101-6JC-M310\\x00\\x00',\n    ],\n    (Ecu.electricBrakeBooster, 0x18da2bf1, None): [\n      b'46114-3W0-A020\\x00\\x00',\n    ],\n  },\n  CAR.ACURA_ILX: {\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TX6-A010\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-TV9-A140\\x00\\x00',\n      b'36161-TX6-A030\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TX6-A230\\x00\\x00',\n      b'77959-TX6-C210\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_E: {\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-TYF-N030\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-TYF-E140\\x00\\x00',\n    ],\n    (Ecu.shiftByWire, 0x18da0bf1, None): [\n      b'54008-TYF-E010\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-TYF-G430\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36802-TYF-E030\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x18dab5f1, None): [\n      b'36161-TYF-E020\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-TYF-E030\\x00\\x00',\n    ],\n  },\n  CAR.HONDA_CIVIC_2022: {\n    (Ecu.eps, 0x18da30f1, None): [\n      b'39990-T24-T120\\x00\\x00',\n      b'39990-T39-A130\\x00\\x00',\n      b'39990-T43-J020\\x00\\x00',\n    ],\n    (Ecu.gateway, 0x18daeff1, None): [\n      b'38897-T20-A020\\x00\\x00',\n      b'38897-T20-A210\\x00\\x00',\n      b'38897-T20-A310\\x00\\x00',\n      b'38897-T20-A510\\x00\\x00',\n      b'38897-T21-A010\\x00\\x00',\n      b'38897-T24-Z120\\x00\\x00',\n    ],\n    (Ecu.srs, 0x18da53f1, None): [\n      b'77959-T20-A970\\x00\\x00',\n      b'77959-T20-A980\\x00\\x00',\n      b'77959-T20-M820\\x00\\x00',\n      b'77959-T47-A940\\x00\\x00',\n      b'77959-T47-A950\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x18dab0f1, None): [\n      b'36161-T20-A060\\x00\\x00',\n      b'36161-T20-A070\\x00\\x00',\n      b'36161-T20-A080\\x00\\x00',\n      b'36161-T24-T070\\x00\\x00',\n      b'36161-T47-A050\\x00\\x00',\n      b'36161-T47-A070\\x00\\x00',\n      b'8S102-T20-AA10\\x00\\x00',\n      b'8S102-T47-AA10\\x00\\x00',\n    ],\n    (Ecu.vsa, 0x18da28f1, None): [\n      b'57114-T20-AB40\\x00\\x00',\n      b'57114-T24-TB30\\x00\\x00',\n      b'57114-T43-JB30\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x18da1ef1, None): [\n      b'28101-65D-A020\\x00\\x00',\n      b'28101-65D-A120\\x00\\x00',\n      b'28101-65H-A020\\x00\\x00',\n      b'28101-65H-A120\\x00\\x00',\n      b'28101-65J-N010\\x00\\x00',\n    ],\n  },\n}\n", "selfdrive/car/honda/hondacan.py": "from openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import CanBusBase\nfrom openpilot.selfdrive.car.honda.values import HondaFlags, HONDA_BOSCH, HONDA_BOSCH_RADARLESS, CAR, CarControllerParams\n\n# CAN bus layout with relay\n# 0 = ACC-CAN - radar side\n# 1 = F-CAN B - powertrain\n# 2 = ACC-CAN - camera side\n# 3 = F-CAN A - OBDII port\n\n\nclass CanBus(CanBusBase):\n  def __init__(self, CP=None, fingerprint=None) -> None:\n    # use fingerprint if specified\n    super().__init__(CP if fingerprint is None else None, fingerprint)\n\n    if CP.carFingerprint in (HONDA_BOSCH - HONDA_BOSCH_RADARLESS):\n      self._pt, self._radar = self.offset + 1, self.offset\n    else:\n      self._pt, self._radar = self.offset, self.offset + 1\n\n  @property\n  def pt(self) -> int:\n    return self._pt\n\n  @property\n  def radar(self) -> int:\n    return self._radar\n\n  @property\n  def camera(self) -> int:\n    return self.offset + 2\n\n\ndef get_lkas_cmd_bus(CAN, car_fingerprint, radar_disabled=False):\n  no_radar = car_fingerprint in HONDA_BOSCH_RADARLESS\n  if radar_disabled or no_radar:\n    # when radar is disabled, steering commands are sent directly to powertrain bus\n    return CAN.pt\n  # normally steering commands are sent to radar, which forwards them to powertrain bus\n  return 0\n\n\ndef get_cruise_speed_conversion(car_fingerprint: str, is_metric: bool) -> float:\n  # on certain cars, CRUISE_SPEED changes to imperial with car's unit setting\n  return CV.MPH_TO_MS if car_fingerprint in HONDA_BOSCH_RADARLESS and not is_metric else CV.KPH_TO_MS\n\n\ndef create_brake_command(packer, CAN, apply_brake, pump_on, pcm_override, pcm_cancel_cmd, fcw, car_fingerprint, stock_brake):\n  # TODO: do we loose pressure if we keep pump off for long?\n  brakelights = apply_brake > 0\n  brake_rq = apply_brake > 0\n  pcm_fault_cmd = False\n\n  values = {\n    \"COMPUTER_BRAKE\": apply_brake,\n    \"BRAKE_PUMP_REQUEST\": pump_on,\n    \"CRUISE_OVERRIDE\": pcm_override,\n    \"CRUISE_FAULT_CMD\": pcm_fault_cmd,\n    \"CRUISE_CANCEL_CMD\": pcm_cancel_cmd,\n    \"COMPUTER_BRAKE_REQUEST\": brake_rq,\n    \"SET_ME_1\": 1,\n    \"BRAKE_LIGHTS\": brakelights,\n    \"CHIME\": stock_brake[\"CHIME\"] if fcw else 0,  # send the chime for stock fcw\n    \"FCW\": fcw << 1,  # TODO: Why are there two bits for fcw?\n    \"AEB_REQ_1\": 0,\n    \"AEB_REQ_2\": 0,\n    \"AEB_STATUS\": 0,\n  }\n  return packer.make_can_msg(\"BRAKE_COMMAND\", CAN.pt, values)\n\n\ndef create_acc_commands(packer, CAN, enabled, active, accel, gas, stopping_counter, car_fingerprint):\n  commands = []\n  min_gas_accel = CarControllerParams.BOSCH_GAS_LOOKUP_BP[0]\n\n  control_on = 5 if enabled else 0\n  gas_command = gas if active and accel > min_gas_accel else -30000\n  accel_command = accel if active else 0\n  braking = 1 if active and accel < min_gas_accel else 0\n  standstill = 1 if active and stopping_counter > 0 else 0\n  standstill_release = 1 if active and stopping_counter == 0 else 0\n\n  # common ACC_CONTROL values\n  acc_control_values = {\n    'ACCEL_COMMAND': accel_command,\n    'STANDSTILL': standstill,\n  }\n\n  if car_fingerprint in HONDA_BOSCH_RADARLESS:\n    acc_control_values.update({\n      \"CONTROL_ON\": enabled,\n      \"IDLESTOP_ALLOW\": stopping_counter > 200,  # allow idle stop after 4 seconds (50 Hz)\n    })\n  else:\n    acc_control_values.update({\n      # setting CONTROL_ON causes car to set POWERTRAIN_DATA->ACC_STATUS = 1\n      \"CONTROL_ON\": control_on,\n      \"GAS_COMMAND\": gas_command,  # used for gas\n      \"BRAKE_LIGHTS\": braking,\n      \"BRAKE_REQUEST\": braking,\n      \"STANDSTILL_RELEASE\": standstill_release,\n    })\n    acc_control_on_values = {\n      \"SET_TO_3\": 0x03,\n      \"CONTROL_ON\": enabled,\n      \"SET_TO_FF\": 0xff,\n      \"SET_TO_75\": 0x75,\n      \"SET_TO_30\": 0x30,\n    }\n    commands.append(packer.make_can_msg(\"ACC_CONTROL_ON\", CAN.pt, acc_control_on_values))\n\n  commands.append(packer.make_can_msg(\"ACC_CONTROL\", CAN.pt, acc_control_values))\n  return commands\n\n\ndef create_steering_control(packer, CAN, apply_steer, lkas_active, car_fingerprint, radar_disabled):\n  values = {\n    \"STEER_TORQUE\": apply_steer if lkas_active else 0,\n    \"STEER_TORQUE_REQUEST\": lkas_active,\n  }\n  bus = get_lkas_cmd_bus(CAN, car_fingerprint, radar_disabled)\n  return packer.make_can_msg(\"STEERING_CONTROL\", bus, values)\n\n\ndef create_bosch_supplemental_1(packer, CAN, car_fingerprint):\n  # non-active params\n  values = {\n    \"SET_ME_X04\": 0x04,\n    \"SET_ME_X80\": 0x80,\n    \"SET_ME_X10\": 0x10,\n  }\n  bus = get_lkas_cmd_bus(CAN, car_fingerprint)\n  return packer.make_can_msg(\"BOSCH_SUPPLEMENTAL_1\", bus, values)\n\n\ndef create_ui_commands(packer, CAN, CP, enabled, pcm_speed, hud, is_metric, acc_hud, lkas_hud):\n  commands = []\n  radar_disabled = CP.carFingerprint in (HONDA_BOSCH - HONDA_BOSCH_RADARLESS) and CP.openpilotLongitudinalControl\n  bus_lkas = get_lkas_cmd_bus(CAN, CP.carFingerprint, radar_disabled)\n\n  if CP.openpilotLongitudinalControl:\n    acc_hud_values = {\n      'CRUISE_SPEED': hud.v_cruise,\n      'ENABLE_MINI_CAR': 1 if enabled else 0,\n      # only moves the lead car without ACC_ON\n      'HUD_DISTANCE': (hud.lead_distance_bars + 1) % 4,  # wraps to 0 at 4 bars\n      'IMPERIAL_UNIT': int(not is_metric),\n      'HUD_LEAD': 2 if enabled and hud.lead_visible else 1 if enabled else 0,\n      'SET_ME_X01_2': 1,\n    }\n\n    if CP.carFingerprint in HONDA_BOSCH:\n      acc_hud_values['ACC_ON'] = int(enabled)\n      acc_hud_values['FCM_OFF'] = 1\n      acc_hud_values['FCM_OFF_2'] = 1\n    else:\n      # Shows the distance bars, TODO: stock camera shows updates temporarily while disabled\n      acc_hud_values['ACC_ON'] = int(enabled)\n      acc_hud_values['PCM_SPEED'] = pcm_speed * CV.MS_TO_KPH\n      acc_hud_values['PCM_GAS'] = hud.pcm_accel\n      acc_hud_values['SET_ME_X01'] = 1\n      acc_hud_values['FCM_OFF'] = acc_hud['FCM_OFF']\n      acc_hud_values['FCM_OFF_2'] = acc_hud['FCM_OFF_2']\n      acc_hud_values['FCM_PROBLEM'] = acc_hud['FCM_PROBLEM']\n      acc_hud_values['ICONS'] = acc_hud['ICONS']\n    commands.append(packer.make_can_msg(\"ACC_HUD\", CAN.pt, acc_hud_values))\n\n  lkas_hud_values = {\n    'SET_ME_X41': 0x41,\n    'STEERING_REQUIRED': hud.steer_required,\n    'SOLID_LANES': hud.lanes_visible,\n    'BEEP': 0,\n  }\n\n  if CP.carFingerprint in HONDA_BOSCH_RADARLESS:\n    lkas_hud_values['LANE_LINES'] = 3\n    lkas_hud_values['DASHED_LANES'] = hud.lanes_visible\n    # car likely needs to see LKAS_PROBLEM fall within a specific time frame, so forward from camera\n    lkas_hud_values['LKAS_PROBLEM'] = lkas_hud['LKAS_PROBLEM']\n\n  if not (CP.flags & HondaFlags.BOSCH_EXT_HUD):\n    lkas_hud_values['SET_ME_X48'] = 0x48\n\n  if CP.flags & HondaFlags.BOSCH_EXT_HUD and not CP.openpilotLongitudinalControl:\n    commands.append(packer.make_can_msg('LKAS_HUD_A', bus_lkas, lkas_hud_values))\n    commands.append(packer.make_can_msg('LKAS_HUD_B', bus_lkas, lkas_hud_values))\n  else:\n    commands.append(packer.make_can_msg('LKAS_HUD', bus_lkas, lkas_hud_values))\n\n  if radar_disabled:\n    radar_hud_values = {\n      'CMBS_OFF': 0x01,\n      'SET_TO_1': 0x01,\n    }\n    commands.append(packer.make_can_msg('RADAR_HUD', CAN.pt, radar_hud_values))\n\n    if CP.carFingerprint == CAR.HONDA_CIVIC_BOSCH:\n      commands.append(packer.make_can_msg(\"LEGACY_BRAKE_COMMAND\", CAN.pt, {}))\n\n  return commands\n\n\ndef spam_buttons_command(packer, CAN, button_val, car_fingerprint):\n  values = {\n    'CRUISE_BUTTONS': button_val,\n    'CRUISE_SETTING': 0,\n  }\n  # send buttons to camera on radarless cars\n  bus = CAN.camera if car_fingerprint in HONDA_BOSCH_RADARLESS else CAN.pt\n  return packer.make_can_msg(\"SCM_BUTTONS\", bus, values)\n", "selfdrive/car/honda/values.py": "from dataclasses import dataclass\nfrom enum import Enum, IntFlag\n\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom panda.python import uds\nfrom openpilot.selfdrive.car import CarSpecs, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarFootnote, CarHarness, CarDocs, CarParts, Column\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries, p16\n\nEcu = car.CarParams.Ecu\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\n\nclass CarControllerParams:\n  # Allow small margin below -3.5 m/s^2 from ISO 15622:2018 since we\n  # perform the closed loop control, and might need some\n  # to apply some more braking if we're on a downhill slope.\n  # Our controller should still keep the 2 second average above\n  # -3.5 m/s^2 as per planner limits\n  NIDEC_ACCEL_MIN = -4.0  # m/s^2\n  NIDEC_ACCEL_MAX = 1.6  # m/s^2, lower than 2.0 m/s^2 for tuning reasons\n\n  NIDEC_ACCEL_LOOKUP_BP = [-1., 0., .6]\n  NIDEC_ACCEL_LOOKUP_V = [-4.8, 0., 2.0]\n\n  NIDEC_MAX_ACCEL_V = [0.5, 2.4, 1.4, 0.6]\n  NIDEC_MAX_ACCEL_BP = [0.0, 4.0, 10., 20.]\n\n  NIDEC_GAS_MAX = 198  # 0xc6\n  NIDEC_BRAKE_MAX = 1024 // 4\n\n  BOSCH_ACCEL_MIN = -3.5  # m/s^2\n  BOSCH_ACCEL_MAX = 2.0  # m/s^2\n\n  BOSCH_GAS_LOOKUP_BP = [-0.2, 2.0]  # 2m/s^2\n  BOSCH_GAS_LOOKUP_V = [0, 1600]\n\n  def __init__(self, CP):\n    self.STEER_MAX = CP.lateralParams.torqueBP[-1]\n    # mirror of list (assuming first item is zero) for interp of signed request values\n    assert(CP.lateralParams.torqueBP[0] == 0)\n    assert(CP.lateralParams.torqueBP[0] == 0)\n    self.STEER_LOOKUP_BP = [v * -1 for v in CP.lateralParams.torqueBP][1:][::-1] + list(CP.lateralParams.torqueBP)\n    self.STEER_LOOKUP_V = [v * -1 for v in CP.lateralParams.torqueV][1:][::-1] + list(CP.lateralParams.torqueV)\n\n\nclass HondaFlags(IntFlag):\n  # Detected flags\n  # Bosch models with alternate set of LKAS_HUD messages\n  BOSCH_EXT_HUD = 1\n  BOSCH_ALT_BRAKE = 2\n\n  # Static flags\n  BOSCH = 4\n  BOSCH_RADARLESS = 8\n\n  NIDEC = 16\n  NIDEC_ALT_PCM_ACCEL = 32\n  NIDEC_ALT_SCM_MESSAGES = 64\n\n\n# Car button codes\nclass CruiseButtons:\n  RES_ACCEL = 4\n  DECEL_SET = 3\n  CANCEL = 2\n  MAIN = 1\n\n\nclass CruiseSettings:\n  DISTANCE = 3\n  LKAS = 1\n\n\n# See dbc files for info on values\nVISUAL_HUD = {\n  VisualAlert.none: 0,\n  VisualAlert.fcw: 1,\n  VisualAlert.steerRequired: 1,\n  VisualAlert.ldw: 1,\n  VisualAlert.brakePressed: 10,\n  VisualAlert.wrongGear: 6,\n  VisualAlert.seatbeltUnbuckled: 5,\n  VisualAlert.speedTooHigh: 8\n}\n\n\n@dataclass\nclass HondaCarDocs(CarDocs):\n  package: str = \"Honda Sensing\"\n\n  def init_make(self, CP: car.CarParams):\n    if CP.flags & HondaFlags.BOSCH:\n      self.car_parts = CarParts.common([CarHarness.bosch_b]) if CP.flags & HondaFlags.BOSCH_RADARLESS else CarParts.common([CarHarness.bosch_a])\n    else:\n      self.car_parts = CarParts.common([CarHarness.nidec])\n\n\nclass Footnote(Enum):\n  CIVIC_DIESEL = CarFootnote(\n    \"2019 Honda Civic 1.6L Diesel Sedan does not have ALC below 12mph.\",\n    Column.FSR_STEERING)\n\n\nclass HondaBoschPlatformConfig(PlatformConfig):\n  def init(self):\n    self.flags |= HondaFlags.BOSCH\n\n\nclass HondaNidecPlatformConfig(PlatformConfig):\n  def init(self):\n    self.flags |= HondaFlags.NIDEC\n\n\nclass CAR(Platforms):\n  # Bosch Cars\n  HONDA_ACCORD = HondaBoschPlatformConfig(\n    [\n      HondaCarDocs(\"Honda Accord 2018-22\", \"All\", video_link=\"https://www.youtube.com/watch?v=mrUwlj3Mi58\", min_steer_speed=3. * CV.MPH_TO_MS),\n      HondaCarDocs(\"Honda Inspire 2018\", \"All\", min_steer_speed=3. * CV.MPH_TO_MS),\n      HondaCarDocs(\"Honda Accord Hybrid 2018-22\", \"All\", min_steer_speed=3. * CV.MPH_TO_MS),\n    ],\n    # steerRatio: 11.82 is spec end-to-end\n    CarSpecs(mass=3279 * CV.LB_TO_KG, wheelbase=2.83, steerRatio=16.33, centerToFrontRatio=0.39, tireStiffnessFactor=0.8467),\n    dbc_dict('honda_accord_2018_can_generated', None),\n  )\n  HONDA_CIVIC_BOSCH = HondaBoschPlatformConfig(\n    [\n      HondaCarDocs(\"Honda Civic 2019-21\", \"All\", video_link=\"https://www.youtube.com/watch?v=4Iz1Mz5LGF8\",\n                   footnotes=[Footnote.CIVIC_DIESEL], min_steer_speed=2. * CV.MPH_TO_MS),\n      HondaCarDocs(\"Honda Civic Hatchback 2017-21\", min_steer_speed=12. * CV.MPH_TO_MS),\n    ],\n    CarSpecs(mass=1326, wheelbase=2.7, steerRatio=15.38, centerToFrontRatio=0.4),  # steerRatio: 10.93 is end-to-end spec\n    dbc_dict('honda_civic_hatchback_ex_2017_can_generated', None),\n  )\n  HONDA_CIVIC_BOSCH_DIESEL = HondaBoschPlatformConfig(\n    [],  # don't show in docs\n    HONDA_CIVIC_BOSCH.specs,\n    dbc_dict('honda_accord_2018_can_generated', None),\n  )\n  HONDA_CIVIC_2022 = HondaBoschPlatformConfig(\n    [\n      HondaCarDocs(\"Honda Civic 2022-24\", \"All\", video_link=\"https://youtu.be/ytiOT5lcp6Q\"),\n      HondaCarDocs(\"Honda Civic Hatchback 2022-24\", \"All\", video_link=\"https://youtu.be/ytiOT5lcp6Q\"),\n    ],\n    HONDA_CIVIC_BOSCH.specs,\n    dbc_dict('honda_civic_ex_2022_can_generated', None),\n    flags=HondaFlags.BOSCH_RADARLESS,\n  )\n  HONDA_CRV_5G = HondaBoschPlatformConfig(\n    [HondaCarDocs(\"Honda CR-V 2017-22\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    # steerRatio: 12.3 is spec end-to-end\n    CarSpecs(mass=3410 * CV.LB_TO_KG, wheelbase=2.66, steerRatio=16.0, centerToFrontRatio=0.41, tireStiffnessFactor=0.677),\n    dbc_dict('honda_crv_ex_2017_can_generated', None, body_dbc='honda_crv_ex_2017_body_generated'),\n    flags=HondaFlags.BOSCH_ALT_BRAKE,\n  )\n  HONDA_CRV_HYBRID = HondaBoschPlatformConfig(\n    [HondaCarDocs(\"Honda CR-V Hybrid 2017-21\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    # mass: mean of 4 models in kg, steerRatio: 12.3 is spec end-to-end\n    CarSpecs(mass=1667, wheelbase=2.66, steerRatio=16, centerToFrontRatio=0.41, tireStiffnessFactor=0.677),\n    dbc_dict('honda_accord_2018_can_generated', None),\n  )\n  HONDA_HRV_3G = HondaBoschPlatformConfig(\n    [HondaCarDocs(\"Honda HR-V 2023\", \"All\")],\n    CarSpecs(mass=3125 * CV.LB_TO_KG, wheelbase=2.61, steerRatio=15.2, centerToFrontRatio=0.41, tireStiffnessFactor=0.5),\n    dbc_dict('honda_civic_ex_2022_can_generated', None),\n    flags=HondaFlags.BOSCH_RADARLESS,\n  )\n  ACURA_RDX_3G = HondaBoschPlatformConfig(\n    [HondaCarDocs(\"Acura RDX 2019-22\", \"All\", min_steer_speed=3. * CV.MPH_TO_MS)],\n    CarSpecs(mass=4068 * CV.LB_TO_KG, wheelbase=2.75, steerRatio=11.95, centerToFrontRatio=0.41, tireStiffnessFactor=0.677),  # as spec\n    dbc_dict('acura_rdx_2020_can_generated', None),\n    flags=HondaFlags.BOSCH_ALT_BRAKE,\n  )\n  HONDA_INSIGHT = HondaBoschPlatformConfig(\n    [HondaCarDocs(\"Honda Insight 2019-22\", \"All\", min_steer_speed=3. * CV.MPH_TO_MS)],\n    CarSpecs(mass=2987 * CV.LB_TO_KG, wheelbase=2.7, steerRatio=15.0, centerToFrontRatio=0.39, tireStiffnessFactor=0.82),  # as spec\n    dbc_dict('honda_insight_ex_2019_can_generated', None),\n  )\n  HONDA_E = HondaBoschPlatformConfig(\n    [HondaCarDocs(\"Honda e 2020\", \"All\", min_steer_speed=3. * CV.MPH_TO_MS)],\n    CarSpecs(mass=3338.8 * CV.LB_TO_KG, wheelbase=2.5, centerToFrontRatio=0.5, steerRatio=16.71, tireStiffnessFactor=0.82),\n    dbc_dict('acura_rdx_2020_can_generated', None),\n  )\n\n  # Nidec Cars\n  ACURA_ILX = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Acura ILX 2016-19\", \"AcuraWatch Plus\", min_steer_speed=25. * CV.MPH_TO_MS)],\n    CarSpecs(mass=3095 * CV.LB_TO_KG, wheelbase=2.67, steerRatio=18.61, centerToFrontRatio=0.37, tireStiffnessFactor=0.72),  # 15.3 is spec end-to-end\n    dbc_dict('acura_ilx_2016_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_CRV = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda CR-V 2015-16\", \"Touring Trim\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    CarSpecs(mass=3572 * CV.LB_TO_KG, wheelbase=2.62, steerRatio=16.89, centerToFrontRatio=0.41, tireStiffnessFactor=0.444),  # as spec\n    dbc_dict('honda_crv_touring_2016_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_CRV_EU = HondaNidecPlatformConfig(\n    [],  # Euro version of CRV Touring, don't show in docs\n    HONDA_CRV.specs,\n    dbc_dict('honda_crv_executive_2016_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_FIT = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda Fit 2018-20\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    CarSpecs(mass=2644 * CV.LB_TO_KG, wheelbase=2.53, steerRatio=13.06, centerToFrontRatio=0.39, tireStiffnessFactor=0.75),\n    dbc_dict('honda_fit_ex_2018_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_FREED = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda Freed 2020\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    CarSpecs(mass=3086. * CV.LB_TO_KG, wheelbase=2.74, steerRatio=13.06, centerToFrontRatio=0.39, tireStiffnessFactor=0.75),  # mostly copied from FIT\n    dbc_dict('honda_fit_ex_2018_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_HRV = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda HR-V 2019-22\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    HONDA_HRV_3G.specs,\n    dbc_dict('honda_fit_ex_2018_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_ODYSSEY = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda Odyssey 2018-20\")],\n    CarSpecs(mass=1900, wheelbase=3.0, steerRatio=14.35, centerToFrontRatio=0.41, tireStiffnessFactor=0.82),\n    dbc_dict('honda_odyssey_exl_2018_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_PCM_ACCEL,\n  )\n  HONDA_ODYSSEY_CHN = HondaNidecPlatformConfig(\n    [],  # Chinese version of Odyssey, don't show in docs\n    HONDA_ODYSSEY.specs,\n    dbc_dict('honda_odyssey_extreme_edition_2018_china_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  ACURA_RDX = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Acura RDX 2016-18\", \"AcuraWatch Plus\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    CarSpecs(mass=3925 * CV.LB_TO_KG, wheelbase=2.68, steerRatio=15.0, centerToFrontRatio=0.38, tireStiffnessFactor=0.444),  # as spec\n    dbc_dict('acura_rdx_2018_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_PILOT = HondaNidecPlatformConfig(\n    [\n      HondaCarDocs(\"Honda Pilot 2016-22\", min_steer_speed=12. * CV.MPH_TO_MS),\n      HondaCarDocs(\"Honda Passport 2019-23\", \"All\", min_steer_speed=12. * CV.MPH_TO_MS),\n    ],\n    CarSpecs(mass=4278 * CV.LB_TO_KG, wheelbase=2.86, centerToFrontRatio=0.428, steerRatio=16.0, tireStiffnessFactor=0.444),  # as spec\n    dbc_dict('acura_ilx_2016_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_RIDGELINE = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda Ridgeline 2017-24\", min_steer_speed=12. * CV.MPH_TO_MS)],\n    CarSpecs(mass=4515 * CV.LB_TO_KG, wheelbase=3.18, centerToFrontRatio=0.41, steerRatio=15.59, tireStiffnessFactor=0.444),  # as spec\n    dbc_dict('acura_ilx_2016_can_generated', 'acura_ilx_2016_nidec'),\n    flags=HondaFlags.NIDEC_ALT_SCM_MESSAGES,\n  )\n  HONDA_CIVIC = HondaNidecPlatformConfig(\n    [HondaCarDocs(\"Honda Civic 2016-18\", min_steer_speed=12. * CV.MPH_TO_MS, video_link=\"https://youtu.be/-IkImTe1NYE\")],\n    CarSpecs(mass=1326, wheelbase=2.70, centerToFrontRatio=0.4, steerRatio=15.38),  # 10.93 is end-to-end spec\n    dbc_dict('honda_civic_touring_2016_can_generated', 'acura_ilx_2016_nidec'),\n  )\n\n\nHONDA_ALT_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(0xF112)\nHONDA_ALT_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n  p16(0xF112)\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    # Currently used to fingerprint\n    Request(\n      [StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.UDS_VERSION_RESPONSE],\n      bus=1,\n    ),\n\n    # Data collection requests:\n    # Log manufacturer-specific identifier for current ECUs\n    Request(\n      [HONDA_ALT_VERSION_REQUEST],\n      [HONDA_ALT_VERSION_RESPONSE],\n      bus=1,\n      logging=True,\n    ),\n    # Nidec PT bus\n    Request(\n      [StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.UDS_VERSION_RESPONSE],\n      bus=0,\n    ),\n    # Bosch PT bus\n    Request(\n      [StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.UDS_VERSION_RESPONSE],\n      bus=1,\n      obd_multiplexing=False,\n    ),\n  ],\n  # We lose these ECUs without the comma power on these cars.\n  # Note that we still attempt to match with them when they are present\n  # This is or'd with (ALL_ECUS - ESSENTIAL_ECUS) from fw_versions.py\n  non_essential_ecus={\n    Ecu.eps: [CAR.ACURA_RDX_3G, CAR.HONDA_ACCORD, CAR.HONDA_CIVIC_2022, CAR.HONDA_E, CAR.HONDA_HRV_3G],\n    Ecu.vsa: [CAR.ACURA_RDX_3G, CAR.HONDA_ACCORD, CAR.HONDA_CIVIC, CAR.HONDA_CIVIC_BOSCH, CAR.HONDA_CIVIC_2022, CAR.HONDA_CRV_5G, CAR.HONDA_CRV_HYBRID,\n              CAR.HONDA_E, CAR.HONDA_HRV_3G, CAR.HONDA_INSIGHT],\n  },\n  extra_ecus=[\n    (Ecu.combinationMeter, 0x18da60f1, None),\n    (Ecu.programmedFuelInjection, 0x18da10f1, None),\n    # The only other ECU on PT bus accessible by camera on radarless Civic\n    # This is likely a manufacturer-specific sub-address implementation: the camera responds to this and 0x18dab0f1\n    # Unclear what the part number refers to: 8S103 is 'Camera Set Mono', while 36160 is 'Camera Monocular - Honda'\n    # TODO: add query back, camera does not support querying both in parallel and 0x18dab0f1 often fails to respond\n    # (Ecu.unknown, 0x18DAB3F1, None),\n  ],\n)\n\nSTEER_THRESHOLD = {\n  # default is 1200, overrides go here\n  CAR.ACURA_RDX: 400,\n  CAR.HONDA_CRV_EU: 400,\n}\n\nHONDA_NIDEC_ALT_PCM_ACCEL = CAR.with_flags(HondaFlags.NIDEC_ALT_PCM_ACCEL)\nHONDA_NIDEC_ALT_SCM_MESSAGES = CAR.with_flags(HondaFlags.NIDEC_ALT_SCM_MESSAGES)\nHONDA_BOSCH = CAR.with_flags(HondaFlags.BOSCH)\nHONDA_BOSCH_RADARLESS = CAR.with_flags(HondaFlags.BOSCH_RADARLESS)\n\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/honda/carcontroller.py": "from collections import namedtuple\n\nfrom cereal import car\nfrom openpilot.common.numpy_fast import clip, interp\nfrom openpilot.common.realtime import DT_CTRL\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car.honda import hondacan\nfrom openpilot.selfdrive.car.honda.values import CruiseButtons, VISUAL_HUD, HONDA_BOSCH, HONDA_BOSCH_RADARLESS, HONDA_NIDEC_ALT_PCM_ACCEL, CarControllerParams\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.controls.lib.drive_helpers import rate_limit\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\nLongCtrlState = car.CarControl.Actuators.LongControlState\n\n\ndef compute_gb_honda_bosch(accel, speed):\n  # TODO returns 0s, is unused\n  return 0.0, 0.0\n\n\ndef compute_gb_honda_nidec(accel, speed):\n  creep_brake = 0.0\n  creep_speed = 2.3\n  creep_brake_value = 0.15\n  if speed < creep_speed:\n    creep_brake = (creep_speed - speed) / creep_speed * creep_brake_value\n  gb = float(accel) / 4.8 - creep_brake\n  return clip(gb, 0.0, 1.0), clip(-gb, 0.0, 1.0)\n\n\ndef compute_gas_brake(accel, speed, fingerprint):\n  if fingerprint in HONDA_BOSCH:\n    return compute_gb_honda_bosch(accel, speed)\n  else:\n    return compute_gb_honda_nidec(accel, speed)\n\n\n# TODO not clear this does anything useful\ndef actuator_hysteresis(brake, braking, brake_steady, v_ego, car_fingerprint):\n  # hyst params\n  brake_hyst_on = 0.02    # to activate brakes exceed this value\n  brake_hyst_off = 0.005  # to deactivate brakes below this value\n  brake_hyst_gap = 0.01   # don't change brake command for small oscillations within this value\n\n  # *** hysteresis logic to avoid brake blinking. go above 0.1 to trigger\n  if (brake < brake_hyst_on and not braking) or brake < brake_hyst_off:\n    brake = 0.\n  braking = brake > 0.\n\n  # for small brake oscillations within brake_hyst_gap, don't change the brake command\n  if brake == 0.:\n    brake_steady = 0.\n  elif brake > brake_steady + brake_hyst_gap:\n    brake_steady = brake - brake_hyst_gap\n  elif brake < brake_steady - brake_hyst_gap:\n    brake_steady = brake + brake_hyst_gap\n  brake = brake_steady\n\n  return brake, braking, brake_steady\n\n\ndef brake_pump_hysteresis(apply_brake, apply_brake_last, last_pump_ts, ts):\n  pump_on = False\n\n  # reset pump timer if:\n  # - there is an increment in brake request\n  # - we are applying steady state brakes and we haven't been running the pump\n  #   for more than 20s (to prevent pressure bleeding)\n  if apply_brake > apply_brake_last or (ts - last_pump_ts > 20. and apply_brake > 0):\n    last_pump_ts = ts\n\n  # once the pump is on, run it for at least 0.2s\n  if ts - last_pump_ts < 0.2 and apply_brake > 0:\n    pump_on = True\n\n  return pump_on, last_pump_ts\n\n\ndef process_hud_alert(hud_alert):\n  # initialize to no alert\n  fcw_display = 0\n  steer_required = 0\n  acc_alert = 0\n\n  # priority is: FCW, steer required, all others\n  if hud_alert == VisualAlert.fcw:\n    fcw_display = VISUAL_HUD[hud_alert.raw]\n  elif hud_alert in (VisualAlert.steerRequired, VisualAlert.ldw):\n    steer_required = VISUAL_HUD[hud_alert.raw]\n  else:\n    acc_alert = VISUAL_HUD[hud_alert.raw]\n\n  return fcw_display, steer_required, acc_alert\n\n\nHUDData = namedtuple(\"HUDData\",\n                     [\"pcm_accel\", \"v_cruise\", \"lead_visible\",\n                      \"lanes_visible\", \"fcw\", \"acc_alert\", \"steer_required\", \"lead_distance_bars\"])\n\n\ndef rate_limit_steer(new_steer, last_steer):\n  # TODO just hardcoded ramp to min/max in 0.33s for all Honda\n  MAX_DELTA = 3 * DT_CTRL\n  return clip(new_steer, last_steer - MAX_DELTA, last_steer + MAX_DELTA)\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.packer = CANPacker(dbc_name)\n    self.params = CarControllerParams(CP)\n    self.CAN = hondacan.CanBus(CP)\n    self.frame = 0\n\n    self.braking = False\n    self.brake_steady = 0.\n    self.brake_last = 0.\n    self.apply_brake_last = 0\n    self.last_pump_ts = 0.\n    self.stopping_counter = 0\n\n    self.accel = 0.0\n    self.speed = 0.0\n    self.gas = 0.0\n    self.brake = 0.0\n    self.last_steer = 0.0\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n    conversion = hondacan.get_cruise_speed_conversion(self.CP.carFingerprint, CS.is_metric)\n    hud_v_cruise = hud_control.setSpeed / conversion if hud_control.speedVisible else 255\n    pcm_cancel_cmd = CC.cruiseControl.cancel\n\n    if CC.longActive:\n      accel = actuators.accel\n      gas, brake = compute_gas_brake(actuators.accel, CS.out.vEgo, self.CP.carFingerprint)\n    else:\n      accel = 0.0\n      gas, brake = 0.0, 0.0\n\n    # *** rate limit steer ***\n    limited_steer = rate_limit_steer(actuators.steer, self.last_steer)\n    self.last_steer = limited_steer\n\n    # *** apply brake hysteresis ***\n    pre_limit_brake, self.braking, self.brake_steady = actuator_hysteresis(brake, self.braking, self.brake_steady,\n                                                                           CS.out.vEgo, self.CP.carFingerprint)\n\n    # *** rate limit after the enable check ***\n    self.brake_last = rate_limit(pre_limit_brake, self.brake_last, -2., DT_CTRL)\n\n    # vehicle hud display, wait for one update from 10Hz 0x304 msg\n    fcw_display, steer_required, acc_alert = process_hud_alert(hud_control.visualAlert)\n\n    # **** process the car messages ****\n\n    # steer torque is converted back to CAN reference (positive when steering right)\n    apply_steer = int(interp(-limited_steer * self.params.STEER_MAX,\n                             self.params.STEER_LOOKUP_BP, self.params.STEER_LOOKUP_V))\n\n    # Send CAN commands\n    can_sends = []\n\n    # tester present - w/ no response (keeps radar disabled)\n    if self.CP.carFingerprint in (HONDA_BOSCH - HONDA_BOSCH_RADARLESS) and self.CP.openpilotLongitudinalControl:\n      if self.frame % 10 == 0:\n        can_sends.append((0x18DAB0F1, 0, b\"\\x02\\x3E\\x80\\x00\\x00\\x00\\x00\\x00\", 1))\n\n    # Send steering command.\n    can_sends.append(hondacan.create_steering_control(self.packer, self.CAN, apply_steer, CC.latActive, self.CP.carFingerprint,\n                                                      CS.CP.openpilotLongitudinalControl))\n\n    # wind brake from air resistance decel at high speed\n    wind_brake = interp(CS.out.vEgo, [0.0, 2.3, 35.0], [0.001, 0.002, 0.15])\n    # all of this is only relevant for HONDA NIDEC\n    max_accel = interp(CS.out.vEgo, self.params.NIDEC_MAX_ACCEL_BP, self.params.NIDEC_MAX_ACCEL_V)\n    # TODO this 1.44 is just to maintain previous behavior\n    pcm_speed_BP = [-wind_brake,\n                    -wind_brake * (3 / 4),\n                    0.0,\n                    0.5]\n    # The Honda ODYSSEY seems to have different PCM_ACCEL\n    # msgs, is it other cars too?\n    if not CC.longActive:\n      pcm_speed = 0.0\n      pcm_accel = int(0.0)\n    elif self.CP.carFingerprint in HONDA_NIDEC_ALT_PCM_ACCEL:\n      pcm_speed_V = [0.0,\n                     clip(CS.out.vEgo - 3.0, 0.0, 100.0),\n                     clip(CS.out.vEgo + 0.0, 0.0, 100.0),\n                     clip(CS.out.vEgo + 5.0, 0.0, 100.0)]\n      pcm_speed = interp(gas - brake, pcm_speed_BP, pcm_speed_V)\n      pcm_accel = int(1.0 * self.params.NIDEC_GAS_MAX)\n    else:\n      pcm_speed_V = [0.0,\n                     clip(CS.out.vEgo - 2.0, 0.0, 100.0),\n                     clip(CS.out.vEgo + 2.0, 0.0, 100.0),\n                     clip(CS.out.vEgo + 5.0, 0.0, 100.0)]\n      pcm_speed = interp(gas - brake, pcm_speed_BP, pcm_speed_V)\n      pcm_accel = int(clip((accel / 1.44) / max_accel, 0.0, 1.0) * self.params.NIDEC_GAS_MAX)\n\n    if not self.CP.openpilotLongitudinalControl:\n      if self.frame % 2 == 0 and self.CP.carFingerprint not in HONDA_BOSCH_RADARLESS:  # radarless cars don't have supplemental message\n        can_sends.append(hondacan.create_bosch_supplemental_1(self.packer, self.CAN, self.CP.carFingerprint))\n      # If using stock ACC, spam cancel command to kill gas when OP disengages.\n      if pcm_cancel_cmd:\n        can_sends.append(hondacan.spam_buttons_command(self.packer, self.CAN, CruiseButtons.CANCEL, self.CP.carFingerprint))\n      elif CC.cruiseControl.resume:\n        can_sends.append(hondacan.spam_buttons_command(self.packer, self.CAN, CruiseButtons.RES_ACCEL, self.CP.carFingerprint))\n\n    else:\n      # Send gas and brake commands.\n      if self.frame % 2 == 0:\n        ts = self.frame * DT_CTRL\n\n        if self.CP.carFingerprint in HONDA_BOSCH:\n          self.accel = clip(accel, self.params.BOSCH_ACCEL_MIN, self.params.BOSCH_ACCEL_MAX)\n          self.gas = interp(accel, self.params.BOSCH_GAS_LOOKUP_BP, self.params.BOSCH_GAS_LOOKUP_V)\n\n          stopping = actuators.longControlState == LongCtrlState.stopping\n          self.stopping_counter = self.stopping_counter + 1 if stopping else 0\n          can_sends.extend(hondacan.create_acc_commands(self.packer, self.CAN, CC.enabled, CC.longActive, self.accel, self.gas,\n                                                        self.stopping_counter, self.CP.carFingerprint))\n        else:\n          apply_brake = clip(self.brake_last - wind_brake, 0.0, 1.0)\n          apply_brake = int(clip(apply_brake * self.params.NIDEC_BRAKE_MAX, 0, self.params.NIDEC_BRAKE_MAX - 1))\n          pump_on, self.last_pump_ts = brake_pump_hysteresis(apply_brake, self.apply_brake_last, self.last_pump_ts, ts)\n\n          pcm_override = True\n          can_sends.append(hondacan.create_brake_command(self.packer, self.CAN, apply_brake, pump_on,\n                                                         pcm_override, pcm_cancel_cmd, fcw_display,\n                                                         self.CP.carFingerprint, CS.stock_brake))\n          self.apply_brake_last = apply_brake\n          self.brake = apply_brake / self.params.NIDEC_BRAKE_MAX\n\n    # Send dashboard UI commands.\n    if self.frame % 10 == 0:\n      hud = HUDData(int(pcm_accel), int(round(hud_v_cruise)), hud_control.leadVisible,\n                    hud_control.lanesVisible, fcw_display, acc_alert, steer_required, hud_control.leadDistanceBars)\n      can_sends.extend(hondacan.create_ui_commands(self.packer, self.CAN, self.CP, CC.enabled, pcm_speed, hud, CS.is_metric, CS.acc_hud, CS.lkas_hud))\n\n      if self.CP.openpilotLongitudinalControl and self.CP.carFingerprint not in HONDA_BOSCH:\n        self.speed = pcm_speed\n        self.gas = pcm_accel / self.params.NIDEC_GAS_MAX\n\n    new_actuators = actuators.as_builder()\n    new_actuators.speed = self.speed\n    new_actuators.accel = self.accel\n    new_actuators.gas = self.gas\n    new_actuators.brake = self.brake\n    new_actuators.steer = self.last_steer\n    new_actuators.steerOutputCan = apply_steer\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/honda/radar_interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\nfrom openpilot.selfdrive.car.honda.values import DBC\n\n\ndef _create_nidec_can_parser(car_fingerprint):\n  radar_messages = [0x400] + list(range(0x430, 0x43A)) + list(range(0x440, 0x446))\n  messages = [(m, 20) for m in radar_messages]\n  return CANParser(DBC[car_fingerprint]['radar'], messages, 1)\n\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.track_id = 0\n    self.radar_fault = False\n    self.radar_wrong_config = False\n    self.radar_off_can = CP.radarUnavailable\n    self.radar_ts = CP.radarTimeStep\n\n    self.delay = int(round(0.1 / CP.radarTimeStep))   # 0.1s delay of radar\n\n    # Nidec\n    if self.radar_off_can:\n      self.rcp = None\n    else:\n      self.rcp = _create_nidec_can_parser(CP.carFingerprint)\n    self.trigger_msg = 0x445\n    self.updated_messages = set()\n\n  def update(self, can_strings):\n    # in Bosch radar and we are only steering for now, so sleep 0.05s to keep\n    # radard at 20Hz and return no points\n    if self.radar_off_can:\n      return super().update(None)\n\n    vls = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(vls)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    rr = self._update(self.updated_messages)\n    self.updated_messages.clear()\n    return rr\n\n  def _update(self, updated_messages):\n    ret = car.RadarData.new_message()\n\n    for ii in sorted(updated_messages):\n      cpt = self.rcp.vl[ii]\n      if ii == 0x400:\n        # check for radar faults\n        self.radar_fault = cpt['RADAR_STATE'] != 0x79\n        self.radar_wrong_config = cpt['RADAR_STATE'] == 0x69\n      elif cpt['LONG_DIST'] < 255:\n        if ii not in self.pts or cpt['NEW_TRACK']:\n          self.pts[ii] = car.RadarData.RadarPoint.new_message()\n          self.pts[ii].trackId = self.track_id\n          self.track_id += 1\n        self.pts[ii].dRel = cpt['LONG_DIST']  # from front of car\n        self.pts[ii].yRel = -cpt['LAT_DIST']  # in car frame's y axis, left is positive\n        self.pts[ii].vRel = cpt['REL_SPEED']\n        self.pts[ii].aRel = float('nan')\n        self.pts[ii].yvRel = float('nan')\n        self.pts[ii].measured = True\n      else:\n        if ii in self.pts:\n          del self.pts[ii]\n\n    errors = []\n    if not self.rcp.can_valid:\n      errors.append(\"canError\")\n    if self.radar_fault:\n      errors.append(\"fault\")\n    if self.radar_wrong_config:\n      errors.append(\"wrongConfig\")\n    ret.errors = errors\n\n    ret.points = list(self.pts.values())\n\n    return ret\n", "selfdrive/car/honda/__init__.py": "", "selfdrive/car/honda/interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom panda import Panda\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import interp\nfrom openpilot.selfdrive.car.honda.hondacan import CanBus\nfrom openpilot.selfdrive.car.honda.values import CarControllerParams, CruiseButtons, CruiseSettings, HondaFlags, CAR, HONDA_BOSCH, \\\n                                                 HONDA_NIDEC_ALT_SCM_MESSAGES, HONDA_BOSCH_RADARLESS\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.car.disable_ecu import disable_ecu\n\n\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\nTransmissionType = car.CarParams.TransmissionType\nBUTTONS_DICT = {CruiseButtons.RES_ACCEL: ButtonType.accelCruise, CruiseButtons.DECEL_SET: ButtonType.decelCruise,\n                CruiseButtons.MAIN: ButtonType.altButton3, CruiseButtons.CANCEL: ButtonType.cancel}\nSETTINGS_BUTTONS_DICT = {CruiseSettings.DISTANCE: ButtonType.gapAdjustCruise, CruiseSettings.LKAS: ButtonType.altButton1}\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def get_pid_accel_limits(CP, current_speed, cruise_speed):\n    if CP.carFingerprint in HONDA_BOSCH:\n      return CarControllerParams.BOSCH_ACCEL_MIN, CarControllerParams.BOSCH_ACCEL_MAX\n    else:\n      # NIDECs don't allow acceleration near cruise_speed,\n      # so limit limits of pid to prevent windup\n      ACCEL_MAX_VALS = [CarControllerParams.NIDEC_ACCEL_MAX, 0.2]\n      ACCEL_MAX_BP = [cruise_speed - 2., cruise_speed - .2]\n      return CarControllerParams.NIDEC_ACCEL_MIN, interp(current_speed, ACCEL_MAX_BP, ACCEL_MAX_VALS)\n\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"honda\"\n\n    CAN = CanBus(ret, fingerprint)\n\n    if candidate in HONDA_BOSCH:\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.hondaBosch)]\n      ret.radarUnavailable = True\n      # Disable the radar and let openpilot control longitudinal\n      # WARNING: THIS DISABLES AEB!\n      # If Bosch radarless, this blocks ACC messages from the camera\n      ret.experimentalLongitudinalAvailable = True\n      ret.openpilotLongitudinalControl = experimental_long\n      ret.pcmCruise = not ret.openpilotLongitudinalControl\n    else:\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.hondaNidec)]\n      ret.openpilotLongitudinalControl = True\n\n      ret.pcmCruise = True\n\n    if candidate == CAR.HONDA_CRV_5G:\n      ret.enableBsm = 0x12f8bfa7 in fingerprint[CAN.radar]\n\n    # Detect Bosch cars with new HUD msgs\n    if any(0x33DA in f for f in fingerprint.values()):\n      ret.flags |= HondaFlags.BOSCH_EXT_HUD.value\n\n    # Accord ICE 1.5T CVT has different gearbox message\n    if candidate == CAR.HONDA_ACCORD and 0x191 in fingerprint[CAN.pt]:\n      ret.transmissionType = TransmissionType.cvt\n\n    # Certain Hondas have an extra steering sensor at the bottom of the steering rack,\n    # which improves controls quality as it removes the steering column torsion from feedback.\n    # Tire stiffness factor fictitiously lower if it includes the steering column torsion effect.\n    # For modeling details, see p.198-200 in \"The Science of Vehicle Dynamics (2014), M. Guiggiani\"\n    ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0], [0]]\n    ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[0.], [0.]]\n    ret.lateralTuning.pid.kf = 0.00006  # conservative feed-forward\n\n    if candidate in HONDA_BOSCH:\n      ret.longitudinalActuatorDelay = 0.5 # s\n      if candidate in HONDA_BOSCH_RADARLESS:\n        ret.stopAccel = CarControllerParams.BOSCH_ACCEL_MIN  # stock uses -4.0 m/s^2 once stopped but limited by safety model\n    else:\n      # default longitudinal tuning for all hondas\n      ret.longitudinalTuning.kiBP = [0., 5., 35.]\n      ret.longitudinalTuning.kiV = [1.2, 0.8, 0.5]\n\n    eps_modified = False\n    for fw in car_fw:\n      if fw.ecu == \"eps\" and b\",\" in fw.fwVersion:\n        eps_modified = True\n\n    if candidate == CAR.HONDA_CIVIC:\n      if eps_modified:\n        # stock request input values:     0x0000, 0x00DE, 0x014D, 0x01EF, 0x0290, 0x0377, 0x0454, 0x0610, 0x06EE\n        # stock request output values:    0x0000, 0x0917, 0x0DC5, 0x1017, 0x119F, 0x140B, 0x1680, 0x1680, 0x1680\n        # modified request output values: 0x0000, 0x0917, 0x0DC5, 0x1017, 0x119F, 0x140B, 0x1680, 0x2880, 0x3180\n        # stock filter output values:     0x009F, 0x0108, 0x0108, 0x0108, 0x0108, 0x0108, 0x0108, 0x0108, 0x0108\n        # modified filter output values:  0x009F, 0x0108, 0x0108, 0x0108, 0x0108, 0x0108, 0x0108, 0x0400, 0x0480\n        # note: max request allowed is 4096, but request is capped at 3840 in firmware, so modifications result in 2x max\n        ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 2560, 8000], [0, 2560, 3840]]\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.3], [0.1]]\n      else:\n        ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 2560], [0, 2560]]\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[1.1], [0.33]]\n\n    elif candidate in (CAR.HONDA_CIVIC_BOSCH, CAR.HONDA_CIVIC_BOSCH_DIESEL, CAR.HONDA_CIVIC_2022):\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.8], [0.24]]\n\n    elif candidate == CAR.HONDA_ACCORD:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n\n      if eps_modified:\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.3], [0.09]]\n      else:\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.6], [0.18]]\n\n    elif candidate == CAR.ACURA_ILX:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 3840], [0, 3840]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.8], [0.24]]\n\n    elif candidate in (CAR.HONDA_CRV, CAR.HONDA_CRV_EU):\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 1000], [0, 1000]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.8], [0.24]]\n      ret.wheelSpeedFactor = 1.025\n\n    elif candidate == CAR.HONDA_CRV_5G:\n      if eps_modified:\n        # stock request input values:     0x0000, 0x00DB, 0x01BB, 0x0296, 0x0377, 0x0454, 0x0532, 0x0610, 0x067F\n        # stock request output values:    0x0000, 0x0500, 0x0A15, 0x0E6D, 0x1100, 0x1200, 0x129A, 0x134D, 0x1400\n        # modified request output values: 0x0000, 0x0500, 0x0A15, 0x0E6D, 0x1100, 0x1200, 0x1ACD, 0x239A, 0x2800\n        ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 2560, 10000], [0, 2560, 3840]]\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.21], [0.07]]\n      else:\n        ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 3840], [0, 3840]]\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.64], [0.192]]\n      ret.wheelSpeedFactor = 1.025\n\n    elif candidate == CAR.HONDA_CRV_HYBRID:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.6], [0.18]]\n      ret.wheelSpeedFactor = 1.025\n\n    elif candidate == CAR.HONDA_FIT:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.2], [0.05]]\n\n    elif candidate == CAR.HONDA_FREED:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.2], [0.05]]\n\n    elif candidate in (CAR.HONDA_HRV, CAR.HONDA_HRV_3G):\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]\n      if candidate == CAR.HONDA_HRV:\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.16], [0.025]]\n        ret.wheelSpeedFactor = 1.025\n      else:\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.8], [0.24]]  # TODO: can probably use some tuning\n\n    elif candidate == CAR.ACURA_RDX:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 1000], [0, 1000]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.8], [0.24]]\n\n    elif candidate == CAR.ACURA_RDX_3G:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 3840], [0, 3840]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.2], [0.06]]\n\n    elif candidate in (CAR.HONDA_ODYSSEY, CAR.HONDA_ODYSSEY_CHN):\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.28], [0.08]]\n      if candidate == CAR.HONDA_ODYSSEY_CHN:\n        ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 32767], [0, 32767]]  # TODO: determine if there is a dead zone at the top end\n      else:\n        ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n\n    elif candidate == CAR.HONDA_PILOT:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.38], [0.11]]\n\n    elif candidate == CAR.HONDA_RIDGELINE:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.38], [0.11]]\n\n    elif candidate == CAR.HONDA_INSIGHT:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.6], [0.18]]\n\n    elif candidate == CAR.HONDA_E:\n      ret.lateralParams.torqueBP, ret.lateralParams.torqueV = [[0, 4096], [0, 4096]]  # TODO: determine if there is a dead zone at the top end\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.6], [0.18]] # TODO: can probably use some tuning\n\n    else:\n      raise ValueError(f\"unsupported car {candidate}\")\n\n    # These cars use alternate user brake msg (0x1BE)\n    # TODO: Only detect feature for Accord/Accord Hybrid, not all Bosch DBCs have BRAKE_MODULE\n    if 0x1BE in fingerprint[CAN.pt] and candidate in (CAR.HONDA_ACCORD, CAR.HONDA_HRV_3G):\n      ret.flags |= HondaFlags.BOSCH_ALT_BRAKE.value\n\n    if ret.flags & HondaFlags.BOSCH_ALT_BRAKE:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_HONDA_ALT_BRAKE\n\n    # These cars use alternate SCM messages (SCM_FEEDBACK AND SCM_BUTTON)\n    if candidate in HONDA_NIDEC_ALT_SCM_MESSAGES:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_HONDA_NIDEC_ALT\n\n    if ret.openpilotLongitudinalControl and candidate in HONDA_BOSCH:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_HONDA_BOSCH_LONG\n\n    if candidate in HONDA_BOSCH_RADARLESS:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_HONDA_RADARLESS\n\n    # min speed to enable ACC. if car can do stop and go, then set enabling speed\n    # to a negative value, so it won't matter. Otherwise, add 0.5 mph margin to not\n    # conflict with PCM acc\n    ret.autoResumeSng = candidate in (HONDA_BOSCH | {CAR.HONDA_CIVIC})\n    ret.minEnableSpeed = -1. if ret.autoResumeSng else 25.5 * CV.MPH_TO_MS\n\n    ret.steerActuatorDelay = 0.1\n    ret.steerLimitTimer = 0.8\n\n    return ret\n\n  @staticmethod\n  def init(CP, logcan, sendcan):\n    if CP.carFingerprint in (HONDA_BOSCH - HONDA_BOSCH_RADARLESS) and CP.openpilotLongitudinalControl:\n      disable_ecu(logcan, sendcan, bus=1, addr=0x18DAB0F1, com_cont_req=b'\\x28\\x83\\x03')\n\n  # returns a car.CarState\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam, self.cp_body)\n\n    ret.buttonEvents = [\n      *create_button_events(self.CS.cruise_buttons, self.CS.prev_cruise_buttons, BUTTONS_DICT),\n      *create_button_events(self.CS.cruise_setting, self.CS.prev_cruise_setting, SETTINGS_BUTTONS_DICT),\n    ]\n\n    # events\n    events = self.create_common_events(ret, pcm_enable=False)\n    if self.CP.pcmCruise and ret.vEgo < self.CP.minEnableSpeed:\n      events.add(EventName.belowEngageSpeed)\n\n    if self.CP.pcmCruise:\n      # we engage when pcm is active (rising edge)\n      if ret.cruiseState.enabled and not self.CS.out.cruiseState.enabled:\n        events.add(EventName.pcmEnable)\n      elif not ret.cruiseState.enabled and (c.actuators.accel >= 0. or not self.CP.openpilotLongitudinalControl):\n        # it can happen that car cruise disables while comma system is enabled: need to\n        # keep braking if needed or if the speed is very low\n        if ret.vEgo < self.CP.minEnableSpeed + 2.:\n          # non loud alert if cruise disables below 25mph as expected (+ a little margin)\n          events.add(EventName.speedTooLow)\n        else:\n          events.add(EventName.cruiseDisabled)\n    if self.CS.CP.minEnableSpeed > 0 and ret.vEgo < 0.001:\n      events.add(EventName.manualRestart)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/mock/carstate.py": "from openpilot.selfdrive.car.interfaces import CarStateBase\n\nclass CarState(CarStateBase):\n  pass\n", "selfdrive/car/mock/values.py": "from openpilot.selfdrive.car import CarSpecs, PlatformConfig, Platforms\n\n\nclass CAR(Platforms):\n  MOCK = PlatformConfig(\n    [],\n    CarSpecs(mass=1700, wheelbase=2.7, steerRatio=13),\n    {}\n  )\n", "selfdrive/car/mock/carcontroller.py": "from openpilot.selfdrive.car.interfaces import CarControllerBase\n\nclass CarController(CarControllerBase):\n  def update(self, CC, CS, now_nanos):\n    return CC.actuators.as_builder(), []\n", "selfdrive/car/mock/radar_interface.py": "from openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nclass RadarInterface(RadarInterfaceBase):\n  pass\n", "selfdrive/car/mock/__init__.py": "", "selfdrive/car/mock/interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nimport cereal.messaging as messaging\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\n\n# mocked car interface for dashcam mode\nclass CarInterface(CarInterfaceBase):\n  def __init__(self, CP, CarController, CarState):\n    super().__init__(CP, CarController, CarState)\n\n    self.speed = 0.\n    self.sm = messaging.SubMaster(['gpsLocation', 'gpsLocationExternal'])\n\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"mock\"\n    ret.mass = 1700.\n    ret.wheelbase = 2.70\n    ret.centerToFront = ret.wheelbase * 0.5\n    ret.steerRatio = 13.\n    ret.dashcamOnly = True\n    return ret\n\n  def _update(self, c):\n    self.sm.update(0)\n    gps_sock = 'gpsLocationExternal' if self.sm.recv_frame['gpsLocationExternal'] > 1 else 'gpsLocation'\n\n    ret = car.CarState.new_message()\n    ret.vEgo = self.sm[gps_sock].speed\n    ret.vEgoRaw = self.sm[gps_sock].speed\n\n    return ret\n", "selfdrive/car/mazda/carstate.py": "from cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom opendbc.can.can_define import CANDefine\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom openpilot.selfdrive.car.mazda.values import DBC, LKAS_LIMITS, MazdaFlags\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n    self.shifter_values = can_define.dv[\"GEAR\"][\"GEAR\"]\n\n    self.crz_btns_counter = 0\n    self.acc_active_last = False\n    self.low_speed_alert = False\n    self.lkas_allowed_speed = False\n    self.lkas_disabled = False\n\n    self.prev_distance_button = 0\n    self.distance_button = 0\n\n  def update(self, cp, cp_cam):\n\n    ret = car.CarState.new_message()\n\n    self.prev_distance_button = self.distance_button\n    self.distance_button = cp.vl[\"CRZ_BTNS\"][\"DISTANCE_LESS\"]\n\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"WHEEL_SPEEDS\"][\"FL\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"FR\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"RL\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"RR\"],\n    )\n    ret.vEgoRaw = (ret.wheelSpeeds.fl + ret.wheelSpeeds.fr + ret.wheelSpeeds.rl + ret.wheelSpeeds.rr) / 4.\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n\n    # Match panda speed reading\n    speed_kph = cp.vl[\"ENGINE_DATA\"][\"SPEED\"]\n    ret.standstill = speed_kph <= .1\n\n    can_gear = int(cp.vl[\"GEAR\"][\"GEAR\"])\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(can_gear, None))\n\n    ret.genericToggle = bool(cp.vl[\"BLINK_INFO\"][\"HIGH_BEAMS\"])\n    ret.leftBlindspot = cp.vl[\"BSM\"][\"LEFT_BS_STATUS\"] != 0\n    ret.rightBlindspot = cp.vl[\"BSM\"][\"RIGHT_BS_STATUS\"] != 0\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_lamp(40, cp.vl[\"BLINK_INFO\"][\"LEFT_BLINK\"] == 1,\n                                                                      cp.vl[\"BLINK_INFO\"][\"RIGHT_BLINK\"] == 1)\n\n    ret.steeringAngleDeg = cp.vl[\"STEER\"][\"STEER_ANGLE\"]\n    ret.steeringTorque = cp.vl[\"STEER_TORQUE\"][\"STEER_TORQUE_SENSOR\"]\n    ret.steeringPressed = abs(ret.steeringTorque) > LKAS_LIMITS.STEER_THRESHOLD\n\n    ret.steeringTorqueEps = cp.vl[\"STEER_TORQUE\"][\"STEER_TORQUE_MOTOR\"]\n    ret.steeringRateDeg = cp.vl[\"STEER_RATE\"][\"STEER_ANGLE_RATE\"]\n\n    # TODO: this should be from 0 - 1.\n    ret.brakePressed = cp.vl[\"PEDALS\"][\"BRAKE_ON\"] == 1\n    ret.brake = cp.vl[\"BRAKE\"][\"BRAKE_PRESSURE\"]\n\n    ret.seatbeltUnlatched = cp.vl[\"SEATBELT\"][\"DRIVER_SEATBELT\"] == 0\n    ret.doorOpen = any([cp.vl[\"DOORS\"][\"FL\"], cp.vl[\"DOORS\"][\"FR\"],\n                        cp.vl[\"DOORS\"][\"BL\"], cp.vl[\"DOORS\"][\"BR\"]])\n\n    # TODO: this should be from 0 - 1.\n    ret.gas = cp.vl[\"ENGINE_DATA\"][\"PEDAL_GAS\"]\n    ret.gasPressed = ret.gas > 0\n\n    # Either due to low speed or hands off\n    lkas_blocked = cp.vl[\"STEER_RATE\"][\"LKAS_BLOCK\"] == 1\n\n    if self.CP.minSteerSpeed > 0:\n      # LKAS is enabled at 52kph going up and disabled at 45kph going down\n      # wait for LKAS_BLOCK signal to clear when going up since it lags behind the speed sometimes\n      if speed_kph > LKAS_LIMITS.ENABLE_SPEED and not lkas_blocked:\n        self.lkas_allowed_speed = True\n      elif speed_kph < LKAS_LIMITS.DISABLE_SPEED:\n        self.lkas_allowed_speed = False\n    else:\n      self.lkas_allowed_speed = True\n\n    # TODO: the signal used for available seems to be the adaptive cruise signal, instead of the main on\n    #       it should be used for carState.cruiseState.nonAdaptive instead\n    ret.cruiseState.available = cp.vl[\"CRZ_CTRL\"][\"CRZ_AVAILABLE\"] == 1\n    ret.cruiseState.enabled = cp.vl[\"CRZ_CTRL\"][\"CRZ_ACTIVE\"] == 1\n    ret.cruiseState.standstill = cp.vl[\"PEDALS\"][\"STANDSTILL\"] == 1\n    ret.cruiseState.speed = cp.vl[\"CRZ_EVENTS\"][\"CRZ_SPEED\"] * CV.KPH_TO_MS\n\n    if ret.cruiseState.enabled:\n      if not self.lkas_allowed_speed and self.acc_active_last:\n        self.low_speed_alert = True\n      else:\n        self.low_speed_alert = False\n\n    # Check if LKAS is disabled due to lack of driver torque when all other states indicate\n    # it should be enabled (steer lockout). Don't warn until we actually get lkas active\n    # and lose it again, i.e, after initial lkas activation\n    ret.steerFaultTemporary = self.lkas_allowed_speed and lkas_blocked\n\n    self.acc_active_last = ret.cruiseState.enabled\n\n    self.crz_btns_counter = cp.vl[\"CRZ_BTNS\"][\"CTR\"]\n\n    # camera signals\n    self.lkas_disabled = cp_cam.vl[\"CAM_LANEINFO\"][\"LANE_LINES\"] == 0\n    self.cam_lkas = cp_cam.vl[\"CAM_LKAS\"]\n    self.cam_laneinfo = cp_cam.vl[\"CAM_LANEINFO\"]\n    ret.steerFaultPermanent = cp_cam.vl[\"CAM_LKAS\"][\"ERR_BIT_1\"] == 1\n\n    return ret\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"BLINK_INFO\", 10),\n      (\"STEER\", 67),\n      (\"STEER_RATE\", 83),\n      (\"STEER_TORQUE\", 83),\n      (\"WHEEL_SPEEDS\", 100),\n    ]\n\n    if CP.flags & MazdaFlags.GEN1:\n      messages += [\n        (\"ENGINE_DATA\", 100),\n        (\"CRZ_CTRL\", 50),\n        (\"CRZ_EVENTS\", 50),\n        (\"CRZ_BTNS\", 10),\n        (\"PEDALS\", 50),\n        (\"BRAKE\", 50),\n        (\"SEATBELT\", 10),\n        (\"DOORS\", 10),\n        (\"GEAR\", 20),\n        (\"BSM\", 10),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = []\n\n    if CP.flags & MazdaFlags.GEN1:\n      messages += [\n        # sig_address, frequency\n        (\"CAM_LANEINFO\", 2),\n        (\"CAM_LKAS\", 16),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 2)\n", "selfdrive/car/mazda/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.mazda.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFW_VERSIONS = {\n  CAR.MAZDA_CX5_2022: {\n    (Ecu.eps, 0x730, None): [\n      b'KSD5-3210X-C-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'PEW5-188K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PW67-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2D-188K2-G\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2G-188K2-H\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2H-188K2-H\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2H-188K2-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX85-188K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXFG-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXFG-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'SH54-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'K131-67XK2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'KGWD-437K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KSD5-437K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'GSH7-67XK2-S\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-T\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-U\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'PG69-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PW66-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXDL-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXFG-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXFG-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-H\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYJ3-21PS1-H\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'SH51-21PS1-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.MAZDA_CX5: {\n    (Ecu.eps, 0x730, None): [\n      b'K319-3210X-A-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KCB8-3210X-B-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KJ01-3210X-G-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KJ01-3210X-J-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KJ01-3210X-M-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'PA53-188K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PAR4-188K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2E-188K2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2F-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2G-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2H-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2H-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2H-188K2-G\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX2K-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX38-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX42-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX68-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFA-188K2-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFC-188K2-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFD-188K2-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYNF-188K2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'SHKT-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'K123-67XK2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'K123-437K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KBJ5-437K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KL2K-437K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KN0W-437K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'B61L-67XK2-R\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-S\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-T\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-V\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-M\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-N\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-R\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'PA66-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PA66-21PS1-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX39-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX39-21PS1-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX68-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB1-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB1-21PS1-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB1-21PS1-G\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-G\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYB2-21PS1-H\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYNC-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'SH9T-21PS1-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.MAZDA_CX9: {\n    (Ecu.eps, 0x730, None): [\n      b'K070-3210X-C-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KJ01-3210X-G-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KJ01-3210X-L-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'PX23-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX24-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM4-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXN8-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXN8-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYD7-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYD8-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFM-188K2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFM-188K2-H\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'K123-67XK2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TK80-67XK2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TK80-67XK2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'TA0B-437K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TK79-437K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TK79-437K2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TM53-437K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TN40-437K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'B61L-67XK2-P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-V\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-J\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-K\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'TK80-67XK2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'PXM4-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM7-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM7-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYD5-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYD5-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYD6-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYD6-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFM-21PS1-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYFM-21PS1-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.MAZDA_3: {\n    (Ecu.eps, 0x730, None): [\n      b'BHN1-3210X-J-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K070-3210X-C-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'KR11-3210X-K-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'P5JD-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PY2P-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYJW-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYKC-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYKE-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'B63C-67XK2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GHP9-67Y10---41\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'B45A-437AS-0-08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'B61L-67XK2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-Q\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-T\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'P52G-21PS1-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PY2S-21PS1-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYKA-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYKE-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYKE-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.MAZDA_6: {\n    (Ecu.eps, 0x730, None): [\n      b'GBEF-3210X-B-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GBEF-3210X-C-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GFBC-3210X-A-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'PA34-188K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PX4F-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYH7-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYH7-188K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'K131-67XK2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'GBVH-437K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GBVH-437K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GDDM-437K2-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'B61L-67XK2-S\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'B61L-67XK2-T\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'PA28-21PS1-A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYH3-21PS1-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PYH7-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.MAZDA_CX9_2021: {\n    (Ecu.eps, 0x730, None): [\n      b'TC3M-3210X-A-00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'PXGW-188K2-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXGW-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM4-188K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM4-188K2-D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM6-188K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM7-188K2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'K131-67XK2-E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'K131-67XK2-F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'TA0B-437K2-C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'GSH7-67XK2-M\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-N\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-S\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-T\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'GSH7-67XK2-U\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'PXM4-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM6-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PXM7-21PS1-B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n}\n", "selfdrive/car/mazda/mazdacan.py": "from openpilot.selfdrive.car.mazda.values import Buttons, MazdaFlags\n\n\ndef create_steering_control(packer, CP, frame, apply_steer, lkas):\n\n  tmp = apply_steer + 2048\n\n  lo = tmp & 0xFF\n  hi = tmp >> 8\n\n  # copy values from camera\n  b1 = int(lkas[\"BIT_1\"])\n  er1 = int(lkas[\"ERR_BIT_1\"])\n  lnv = 0\n  ldw = 0\n  er2 = int(lkas[\"ERR_BIT_2\"])\n\n  # Some older models do have these, newer models don't.\n  # Either way, they all work just fine if set to zero.\n  steering_angle = 0\n  b2 = 0\n\n  tmp = steering_angle + 2048\n  ahi = tmp >> 10\n  amd = (tmp & 0x3FF) >> 2\n  amd = (amd >> 4) | (( amd & 0xF) << 4)\n  alo = (tmp & 0x3) << 2\n\n  ctr = frame % 16\n  # bytes:     [    1  ] [ 2 ] [             3               ]  [           4         ]\n  csum = 249 - ctr - hi - lo - (lnv << 3) - er1 - (ldw << 7) - ( er2 << 4) - (b1 << 5)\n\n  # bytes      [ 5 ] [ 6 ] [    7   ]\n  csum = csum - ahi - amd - alo - b2\n\n  if ahi == 1:\n    csum = csum + 15\n\n  if csum < 0:\n    if csum < -256:\n      csum = csum + 512\n    else:\n      csum = csum + 256\n\n  csum = csum % 256\n\n  values = {}\n  if CP.flags & MazdaFlags.GEN1:\n    values = {\n      \"LKAS_REQUEST\": apply_steer,\n      \"CTR\": ctr,\n      \"ERR_BIT_1\": er1,\n      \"LINE_NOT_VISIBLE\" : lnv,\n      \"LDW\": ldw,\n      \"BIT_1\": b1,\n      \"ERR_BIT_2\": er2,\n      \"STEERING_ANGLE\": steering_angle,\n      \"ANGLE_ENABLED\": b2,\n      \"CHKSUM\": csum\n    }\n\n  return packer.make_can_msg(\"CAM_LKAS\", 0, values)\n\n\ndef create_alert_command(packer, cam_msg: dict, ldw: bool, steer_required: bool):\n  values = {s: cam_msg[s] for s in [\n    \"LINE_VISIBLE\",\n    \"LINE_NOT_VISIBLE\",\n    \"LANE_LINES\",\n    \"BIT1\",\n    \"BIT2\",\n    \"BIT3\",\n    \"NO_ERR_BIT\",\n    \"S1\",\n    \"S1_HBEAM\",\n  ]}\n  values.update({\n    # TODO: what's the difference between all these? do we need to send all?\n    \"HANDS_WARN_3_BITS\": 0b111 if steer_required else 0,\n    \"HANDS_ON_STEER_WARN\": steer_required,\n    \"HANDS_ON_STEER_WARN_2\": steer_required,\n\n    # TODO: right lane works, left doesn't\n    # TODO: need to do something about L/R\n    \"LDW_WARN_LL\": 0,\n    \"LDW_WARN_RL\": 0,\n  })\n  return packer.make_can_msg(\"CAM_LANEINFO\", 0, values)\n\n\ndef create_button_cmd(packer, CP, counter, button):\n\n  can = int(button == Buttons.CANCEL)\n  res = int(button == Buttons.RESUME)\n\n  if CP.flags & MazdaFlags.GEN1:\n    values = {\n      \"CAN_OFF\": can,\n      \"CAN_OFF_INV\": (can + 1) % 2,\n\n      \"SET_P\": 0,\n      \"SET_P_INV\": 1,\n\n      \"RES\": res,\n      \"RES_INV\": (res + 1) % 2,\n\n      \"SET_M\": 0,\n      \"SET_M_INV\": 1,\n\n      \"DISTANCE_LESS\": 0,\n      \"DISTANCE_LESS_INV\": 1,\n\n      \"DISTANCE_MORE\": 0,\n      \"DISTANCE_MORE_INV\": 1,\n\n      \"MODE_X\": 0,\n      \"MODE_X_INV\": 1,\n\n      \"MODE_Y\": 0,\n      \"MODE_Y_INV\": 1,\n\n      \"BIT1\": 1,\n      \"BIT2\": 1,\n      \"BIT3\": 1,\n      \"CTR\": (counter + 1) % 16,\n    }\n\n    return packer.make_can_msg(\"CRZ_BTNS\", 0, values)\n", "selfdrive/car/mazda/values.py": "from dataclasses import dataclass, field\nfrom enum import IntFlag\n\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import CarSpecs, DbcDict, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarHarness, CarDocs, CarParts\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries\n\nEcu = car.CarParams.Ecu\n\n\n# Steer torque limits\n\nclass CarControllerParams:\n  STEER_MAX = 800                # theoretical max_steer 2047\n  STEER_DELTA_UP = 10             # torque increase per refresh\n  STEER_DELTA_DOWN = 25           # torque decrease per refresh\n  STEER_DRIVER_ALLOWANCE = 15     # allowed driver torque before start limiting\n  STEER_DRIVER_MULTIPLIER = 1     # weight driver torque\n  STEER_DRIVER_FACTOR = 1         # from dbc\n  STEER_ERROR_MAX = 350           # max delta between torque cmd and torque motor\n  STEER_STEP = 1  # 100 Hz\n\n  def __init__(self, CP):\n    pass\n\n\n@dataclass\nclass MazdaCarDocs(CarDocs):\n  package: str = \"All\"\n  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.mazda]))\n\n\n@dataclass(frozen=True, kw_only=True)\nclass MazdaCarSpecs(CarSpecs):\n  tireStiffnessFactor: float = 0.7  # not optimized yet\n\n\nclass MazdaFlags(IntFlag):\n  # Static flags\n  # Gen 1 hardware: same CAN messages and same camera\n  GEN1 = 1\n\n\n@dataclass\nclass MazdaPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('mazda_2017', None))\n  flags: int = MazdaFlags.GEN1\n\n\nclass CAR(Platforms):\n  MAZDA_CX5 = MazdaPlatformConfig(\n    [MazdaCarDocs(\"Mazda CX-5 2017-21\")],\n    MazdaCarSpecs(mass=3655 * CV.LB_TO_KG, wheelbase=2.7, steerRatio=15.5)\n  )\n  MAZDA_CX9 = MazdaPlatformConfig(\n    [MazdaCarDocs(\"Mazda CX-9 2016-20\")],\n    MazdaCarSpecs(mass=4217 * CV.LB_TO_KG, wheelbase=3.1, steerRatio=17.6)\n  )\n  MAZDA_3 = MazdaPlatformConfig(\n    [MazdaCarDocs(\"Mazda 3 2017-18\")],\n    MazdaCarSpecs(mass=2875 * CV.LB_TO_KG, wheelbase=2.7, steerRatio=14.0)\n  )\n  MAZDA_6 = MazdaPlatformConfig(\n    [MazdaCarDocs(\"Mazda 6 2017-20\")],\n    MazdaCarSpecs(mass=3443 * CV.LB_TO_KG, wheelbase=2.83, steerRatio=15.5)\n  )\n  MAZDA_CX9_2021 = MazdaPlatformConfig(\n    [MazdaCarDocs(\"Mazda CX-9 2021-23\", video_link=\"https://youtu.be/dA3duO4a0O4\")],\n    MAZDA_CX9.specs\n  )\n  MAZDA_CX5_2022 = MazdaPlatformConfig(\n    [MazdaCarDocs(\"Mazda CX-5 2022-24\")],\n    MAZDA_CX5.specs,\n  )\n\n\nclass LKAS_LIMITS:\n  STEER_THRESHOLD = 15\n  DISABLE_SPEED = 45    # kph\n  ENABLE_SPEED = 52     # kph\n\n\nclass Buttons:\n  NONE = 0\n  SET_PLUS = 1\n  SET_MINUS = 2\n  RESUME = 3\n  CANCEL = 4\n\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    # TODO: check data to ensure ABS does not skip ISO-TP frames on bus 0\n    Request(\n      [StdQueries.MANUFACTURER_SOFTWARE_VERSION_REQUEST],\n      [StdQueries.MANUFACTURER_SOFTWARE_VERSION_RESPONSE],\n      bus=0,\n    ),\n  ],\n)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/mazda/carcontroller.py": "from cereal import car\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car import apply_driver_steer_torque_limits\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.car.mazda import mazdacan\nfrom openpilot.selfdrive.car.mazda.values import CarControllerParams, Buttons\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.apply_steer_last = 0\n    self.packer = CANPacker(dbc_name)\n    self.brake_counter = 0\n    self.frame = 0\n\n  def update(self, CC, CS, now_nanos):\n    can_sends = []\n\n    apply_steer = 0\n\n    if CC.latActive:\n      # calculate steer and also set limits due to driver torque\n      new_steer = int(round(CC.actuators.steer * CarControllerParams.STEER_MAX))\n      apply_steer = apply_driver_steer_torque_limits(new_steer, self.apply_steer_last,\n                                                     CS.out.steeringTorque, CarControllerParams)\n\n    if CC.cruiseControl.cancel:\n      # If brake is pressed, let us wait >70ms before trying to disable crz to avoid\n      # a race condition with the stock system, where the second cancel from openpilot\n      # will disable the crz 'main on'. crz ctrl msg runs at 50hz. 70ms allows us to\n      # read 3 messages and most likely sync state before we attempt cancel.\n      self.brake_counter = self.brake_counter + 1\n      if self.frame % 10 == 0 and not (CS.out.brakePressed and self.brake_counter < 7):\n        # Cancel Stock ACC if it's enabled while OP is disengaged\n        # Send at a rate of 10hz until we sync with stock ACC state\n        can_sends.append(mazdacan.create_button_cmd(self.packer, self.CP, CS.crz_btns_counter, Buttons.CANCEL))\n    else:\n      self.brake_counter = 0\n      if CC.cruiseControl.resume and self.frame % 5 == 0:\n        # Mazda Stop and Go requires a RES button (or gas) press if the car stops more than 3 seconds\n        # Send Resume button when planner wants car to move\n        can_sends.append(mazdacan.create_button_cmd(self.packer, self.CP, CS.crz_btns_counter, Buttons.RESUME))\n\n    self.apply_steer_last = apply_steer\n\n    # send HUD alerts\n    if self.frame % 50 == 0:\n      ldw = CC.hudControl.visualAlert == VisualAlert.ldw\n      steer_required = CC.hudControl.visualAlert == VisualAlert.steerRequired\n      # TODO: find a way to silence audible warnings so we can add more hud alerts\n      steer_required = steer_required and CS.lkas_allowed_speed\n      can_sends.append(mazdacan.create_alert_command(self.packer, CS.cam_laneinfo, ldw, steer_required))\n\n    # send steering command\n    can_sends.append(mazdacan.create_steering_control(self.packer, self.CP,\n                                                      self.frame, apply_steer, CS.cam_lkas))\n\n    new_actuators = CC.actuators.as_builder()\n    new_actuators.steer = apply_steer / CarControllerParams.STEER_MAX\n    new_actuators.steerOutputCan = apply_steer\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/mazda/radar_interface.py": "#!/usr/bin/env python3\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nclass RadarInterface(RadarInterfaceBase):\n  pass\n", "selfdrive/car/mazda/__init__.py": "", "selfdrive/car/mazda/interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.mazda.values import CAR, LKAS_LIMITS\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\n\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\n\nclass CarInterface(CarInterfaceBase):\n\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"mazda\"\n    ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.mazda)]\n    ret.radarUnavailable = True\n\n    ret.dashcamOnly = candidate not in (CAR.MAZDA_CX5_2022, CAR.MAZDA_CX9_2021)\n\n    ret.steerActuatorDelay = 0.1\n    ret.steerLimitTimer = 0.8\n\n    CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    if candidate not in (CAR.MAZDA_CX5_2022, ):\n      ret.minSteerSpeed = LKAS_LIMITS.DISABLE_SPEED * CV.KPH_TO_MS\n\n    ret.centerToFront = ret.wheelbase * 0.41\n\n    return ret\n\n  # returns a car.CarState\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam)\n\n     # TODO: add button types for inc and dec\n    ret.buttonEvents = create_button_events(self.CS.distance_button, self.CS.prev_distance_button, {1: ButtonType.gapAdjustCruise})\n\n    # events\n    events = self.create_common_events(ret)\n\n    if self.CS.lkas_disabled:\n      events.add(EventName.lkasDisabled)\n    elif self.CS.low_speed_alert:\n      events.add(EventName.belowSteerSpeed)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/ford/fordcan.py": "from cereal import car\nfrom openpilot.selfdrive.car import CanBusBase\n\nHUDControl = car.CarControl.HUDControl\n\n\nclass CanBus(CanBusBase):\n  def __init__(self, CP=None, fingerprint=None) -> None:\n    super().__init__(CP, fingerprint)\n\n  @property\n  def main(self) -> int:\n    return self.offset\n\n  @property\n  def radar(self) -> int:\n    return self.offset + 1\n\n  @property\n  def camera(self) -> int:\n    return self.offset + 2\n\n\ndef calculate_lat_ctl2_checksum(mode: int, counter: int, dat: bytearray) -> int:\n  curvature = (dat[2] << 3) | ((dat[3]) >> 5)\n  curvature_rate = (dat[6] << 3) | ((dat[7]) >> 5)\n  path_angle = ((dat[3] & 0x1F) << 6) | ((dat[4]) >> 2)\n  path_offset = ((dat[4] & 0x3) << 8) | dat[5]\n\n  checksum = mode + counter\n  for sig_val in (curvature, curvature_rate, path_angle, path_offset):\n    checksum += sig_val + (sig_val >> 8)\n\n  return 0xFF - (checksum & 0xFF)\n\n\ndef create_lka_msg(packer, CAN: CanBus):\n  \"\"\"\n  Creates an empty CAN message for the Ford LKA Command.\n\n  This command can apply \"Lane Keeping Aid\" manoeuvres, which are subject to the PSCM lockout.\n\n  Frequency is 33Hz.\n  \"\"\"\n\n  return packer.make_can_msg(\"Lane_Assist_Data1\", CAN.main, {})\n\n\ndef create_lat_ctl_msg(packer, CAN: CanBus, lat_active: bool, path_offset: float, path_angle: float, curvature: float,\n                       curvature_rate: float):\n  \"\"\"\n  Creates a CAN message for the Ford TJA/LCA Command.\n\n  This command can apply \"Lane Centering\" manoeuvres: continuous lane centering for traffic jam assist and highway\n  driving. It is not subject to the PSCM lockout.\n\n  Ford lane centering command uses a third order polynomial to describe the road centerline. The polynomial is defined\n  by the following coefficients:\n    c0: lateral offset between the vehicle and the centerline (positive is right)\n    c1: heading angle between the vehicle and the centerline (positive is right)\n    c2: curvature of the centerline (positive is left)\n    c3: rate of change of curvature of the centerline\n  As the PSCM combines this information with other sensor data, such as the vehicle's yaw rate and speed, the steering\n  angle cannot be easily controlled.\n\n  The PSCM should be configured to accept TJA/LCA commands before these commands will be processed. This can be done\n  using tools such as Forscan.\n\n  Frequency is 20Hz.\n  \"\"\"\n\n  values = {\n    \"LatCtlRng_L_Max\": 0,                       # Unknown [0|126] meter\n    \"HandsOffCnfm_B_Rq\": 0,                     # Unknown: 0=Inactive, 1=Active [0|1]\n    \"LatCtl_D_Rq\": 1 if lat_active else 0,      # Mode: 0=None, 1=ContinuousPathFollowing, 2=InterventionLeft,\n                                                #       3=InterventionRight, 4-7=NotUsed [0|7]\n    \"LatCtlRampType_D_Rq\": 0,                   # Ramp speed: 0=Slow, 1=Medium, 2=Fast, 3=Immediate [0|3]\n                                                #             Makes no difference with curvature control\n    \"LatCtlPrecision_D_Rq\": 1,                  # Precision: 0=Comfortable, 1=Precise, 2/3=NotUsed [0|3]\n                                                #            The stock system always uses comfortable\n    \"LatCtlPathOffst_L_Actl\": path_offset,      # Path offset [-5.12|5.11] meter\n    \"LatCtlPath_An_Actl\": path_angle,           # Path angle [-0.5|0.5235] radians\n    \"LatCtlCurv_NoRate_Actl\": curvature_rate,   # Curvature rate [-0.001024|0.00102375] 1/meter^2\n    \"LatCtlCurv_No_Actl\": curvature,            # Curvature [-0.02|0.02094] 1/meter\n  }\n  return packer.make_can_msg(\"LateralMotionControl\", CAN.main, values)\n\n\ndef create_lat_ctl2_msg(packer, CAN: CanBus, mode: int, path_offset: float, path_angle: float, curvature: float,\n                        curvature_rate: float, counter: int):\n  \"\"\"\n  Create a CAN message for the new Ford Lane Centering command.\n\n  This message is used on the CAN FD platform and replaces the old LateralMotionControl message. It is similar but has\n  additional signals for a counter and checksum.\n\n  Frequency is 20Hz.\n  \"\"\"\n\n  values = {\n    \"LatCtl_D2_Rq\": mode,                       # Mode: 0=None, 1=PathFollowingLimitedMode, 2=PathFollowingExtendedMode,\n                                                #       3=SafeRampOut, 4-7=NotUsed [0|7]\n    \"LatCtlRampType_D_Rq\": 0,                   # 0=Slow, 1=Medium, 2=Fast, 3=Immediate [0|3]\n    \"LatCtlPrecision_D_Rq\": 1,                  # 0=Comfortable, 1=Precise, 2/3=NotUsed [0|3]\n    \"LatCtlPathOffst_L_Actl\": path_offset,      # [-5.12|5.11] meter\n    \"LatCtlPath_An_Actl\": path_angle,           # [-0.5|0.5235] radians\n    \"LatCtlCurv_No_Actl\": curvature,            # [-0.02|0.02094] 1/meter\n    \"LatCtlCrv_NoRate2_Actl\": curvature_rate,   # [-0.001024|0.001023] 1/meter^2\n    \"HandsOffCnfm_B_Rq\": 0,                     # 0=Inactive, 1=Active [0|1]\n    \"LatCtlPath_No_Cnt\": counter,               # [0|15]\n    \"LatCtlPath_No_Cs\": 0,                      # [0|255]\n  }\n\n  # calculate checksum\n  dat = packer.make_can_msg(\"LateralMotionControl2\", 0, values)[2]\n  values[\"LatCtlPath_No_Cs\"] = calculate_lat_ctl2_checksum(mode, counter, dat)\n\n  return packer.make_can_msg(\"LateralMotionControl2\", CAN.main, values)\n\n\ndef create_acc_msg(packer, CAN: CanBus, long_active: bool, gas: float, accel: float, stopping: bool, v_ego_kph: float):\n  \"\"\"\n  Creates a CAN message for the Ford ACC Command.\n\n  This command can be used to enable ACC, to set the ACC gas/brake/decel values\n  and to disable ACC.\n\n  Frequency is 50Hz.\n  \"\"\"\n  decel = accel < 0 and long_active\n  values = {\n    \"AccBrkTot_A_Rq\": accel,                          # Brake total accel request: [-20|11.9449] m/s^2\n    \"Cmbb_B_Enbl\": 1 if long_active else 0,           # Enabled: 0=No, 1=Yes\n    \"AccPrpl_A_Rq\": gas,                              # Acceleration request: [-5|5.23] m/s^2\n    \"AccPrpl_A_Pred\": -5.0,                           # Acceleration request: [-5|5.23] m/s^2\n    \"AccResumEnbl_B_Rq\": 1 if long_active else 0,\n    \"AccVeh_V_Trg\": v_ego_kph,                        # Target speed: [0|255] km/h\n    # TODO: we may be able to improve braking response by utilizing pre-charging better\n    \"AccBrkPrchg_B_Rq\": 1 if decel else 0,            # Pre-charge brake request: 0=No, 1=Yes\n    \"AccBrkDecel_B_Rq\": 1 if decel else 0,            # Deceleration request: 0=Inactive, 1=Active\n    \"AccStopStat_B_Rq\": 1 if stopping else 0,\n  }\n  return packer.make_can_msg(\"ACCDATA\", CAN.main, values)\n\n\ndef create_acc_ui_msg(packer, CAN: CanBus, CP, main_on: bool, enabled: bool, fcw_alert: bool, standstill: bool,\n                      hud_control, stock_values: dict):\n  \"\"\"\n  Creates a CAN message for the Ford IPC adaptive cruise, forward collision warning and traffic jam\n  assist status.\n\n  Stock functionality is maintained by passing through unmodified signals.\n\n  Frequency is 5Hz.\n  \"\"\"\n\n  # Tja_D_Stat\n  if enabled:\n    if hud_control.leftLaneDepart:\n      status = 3  # ActiveInterventionLeft\n    elif hud_control.rightLaneDepart:\n      status = 4  # ActiveInterventionRight\n    else:\n      status = 2  # Active\n  elif main_on:\n    if hud_control.leftLaneDepart:\n      status = 5  # ActiveWarningLeft\n    elif hud_control.rightLaneDepart:\n      status = 6  # ActiveWarningRight\n    else:\n      status = 1  # Standby\n  else:\n    status = 0    # Off\n\n  values = {s: stock_values[s] for s in [\n    \"HaDsply_No_Cs\",\n    \"HaDsply_No_Cnt\",\n    \"AccStopStat_D_Dsply\",       # ACC stopped status message\n    \"AccTrgDist2_D_Dsply\",       # ACC target distance\n    \"AccStopRes_B_Dsply\",\n    \"TjaWarn_D_Rq\",              # TJA warning\n    \"TjaMsgTxt_D_Dsply\",         # TJA text\n    \"IaccLamp_D_Rq\",             # iACC status icon\n    \"AccMsgTxt_D2_Rq\",           # ACC text\n    \"FcwDeny_B_Dsply\",           # FCW disabled\n    \"FcwMemStat_B_Actl\",         # FCW enabled setting\n    \"AccTGap_B_Dsply\",           # ACC time gap display setting\n    \"CadsAlignIncplt_B_Actl\",\n    \"AccFllwMde_B_Dsply\",        # ACC follow mode display setting\n    \"CadsRadrBlck_B_Actl\",\n    \"CmbbPostEvnt_B_Dsply\",      # AEB event status\n    \"AccStopMde_B_Dsply\",        # ACC stop mode display setting\n    \"FcwMemSens_D_Actl\",         # FCW sensitivity setting\n    \"FcwMsgTxt_D_Rq\",            # FCW text\n    \"AccWarn_D_Dsply\",           # ACC warning\n    \"FcwVisblWarn_B_Rq\",         # FCW visible alert\n    \"FcwAudioWarn_B_Rq\",         # FCW audio alert\n    \"AccTGap_D_Dsply\",           # ACC time gap\n    \"AccMemEnbl_B_RqDrv\",        # ACC adaptive/normal setting\n    \"FdaMem_B_Stat\",             # FDA enabled setting\n  ]}\n\n  values.update({\n    \"Tja_D_Stat\": status,        # TJA status\n  })\n\n  if CP.openpilotLongitudinalControl:\n    values.update({\n      \"AccStopStat_D_Dsply\": 2 if standstill else 0,              # Stopping status text\n      \"AccMsgTxt_D2_Rq\": 0,                                       # ACC text\n      \"AccTGap_B_Dsply\": 0,                                       # Show time gap control UI\n      \"AccFllwMde_B_Dsply\": 1 if hud_control.leadVisible else 0,  # Lead indicator\n      \"AccStopMde_B_Dsply\": 1 if standstill else 0,\n      \"AccWarn_D_Dsply\": 0,                                       # ACC warning\n      \"AccTGap_D_Dsply\": hud_control.leadDistanceBars,            # Time gap\n    })\n\n  # Forwards FCW alert from IPMA\n  if fcw_alert:\n    values[\"FcwVisblWarn_B_Rq\"] = 1  # FCW visible alert\n\n  return packer.make_can_msg(\"ACCDATA_3\", CAN.main, values)\n\n\ndef create_lkas_ui_msg(packer, CAN: CanBus, main_on: bool, enabled: bool, steer_alert: bool, hud_control,\n                       stock_values: dict):\n  \"\"\"\n  Creates a CAN message for the Ford IPC IPMA/LKAS status.\n\n  Show the LKAS status with the \"driver assist\" lines in the IPC.\n\n  Stock functionality is maintained by passing through unmodified signals.\n\n  Frequency is 1Hz.\n  \"\"\"\n\n  # LaActvStats_D_Dsply\n  #    R  Intvn Warn Supprs Avail No\n  # L\n  # Intvn  24    19    14     9   4\n  # Warn   23    18    13     8   3\n  # Supprs 22    17    12     7   2\n  # Avail  21    16    11     6   1\n  # No     20    15    10     5   0\n  #\n  # TODO: test suppress state\n  if enabled:\n    lines = 0  # NoLeft_NoRight\n    if hud_control.leftLaneDepart:\n      lines += 4\n    elif hud_control.leftLaneVisible:\n      lines += 1\n    if hud_control.rightLaneDepart:\n      lines += 20\n    elif hud_control.rightLaneVisible:\n      lines += 5\n  elif main_on:\n    lines = 0\n  else:\n    if hud_control.leftLaneDepart:\n      lines = 3  # WarnLeft_NoRight\n    elif hud_control.rightLaneDepart:\n      lines = 15  # NoLeft_WarnRight\n    else:\n      lines = 30  # LA_Off\n\n  hands_on_wheel_dsply = 1 if steer_alert else 0\n\n  values = {s: stock_values[s] for s in [\n    \"FeatConfigIpmaActl\",\n    \"FeatNoIpmaActl\",\n    \"PersIndexIpma_D_Actl\",\n    \"AhbcRampingV_D_Rq\",     # AHB ramping\n    \"LaDenyStats_B_Dsply\",   # LKAS error\n    \"CamraDefog_B_Req\",      # Windshield heater?\n    \"CamraStats_D_Dsply\",    # Camera status\n    \"DasAlrtLvl_D_Dsply\",    # DAS alert level\n    \"DasStats_D_Dsply\",      # DAS status\n    \"DasWarn_D_Dsply\",       # DAS warning\n    \"AhbHiBeam_D_Rq\",        # AHB status\n    \"Passthru_63\",\n    \"Passthru_48\",\n  ]}\n\n  values.update({\n    \"LaActvStats_D_Dsply\": lines,                 # LKAS status (lines) [0|31]\n    \"LaHandsOff_D_Dsply\": hands_on_wheel_dsply,   # 0=HandsOn, 1=Level1 (w/o chime), 2=Level2 (w/ chime), 3=Suppressed\n  })\n  return packer.make_can_msg(\"IPMA_Data\", CAN.main, values)\n\n\ndef create_button_msg(packer, bus: int, stock_values: dict, cancel=False, resume=False, tja_toggle=False):\n  \"\"\"\n  Creates a CAN message for the Ford SCCM buttons/switches.\n\n  Includes cruise control buttons, turn lights and more.\n\n  Frequency is 10Hz.\n  \"\"\"\n\n  values = {s: stock_values[s] for s in [\n    \"HeadLghtHiFlash_D_Stat\",  # SCCM Passthrough the remaining buttons\n    \"TurnLghtSwtch_D_Stat\",    # SCCM Turn signal switch\n    \"WiprFront_D_Stat\",\n    \"LghtAmb_D_Sns\",\n    \"AccButtnGapDecPress\",\n    \"AccButtnGapIncPress\",\n    \"AslButtnOnOffCnclPress\",\n    \"AslButtnOnOffPress\",\n    \"LaSwtchPos_D_Stat\",\n    \"CcAslButtnCnclResPress\",\n    \"CcAslButtnDeny_B_Actl\",\n    \"CcAslButtnIndxDecPress\",\n    \"CcAslButtnIndxIncPress\",\n    \"CcAslButtnOffCnclPress\",\n    \"CcAslButtnOnOffCncl\",\n    \"CcAslButtnOnPress\",\n    \"CcAslButtnResDecPress\",\n    \"CcAslButtnResIncPress\",\n    \"CcAslButtnSetDecPress\",\n    \"CcAslButtnSetIncPress\",\n    \"CcAslButtnSetPress\",\n    \"CcButtnOffPress\",\n    \"CcButtnOnOffCnclPress\",\n    \"CcButtnOnOffPress\",\n    \"CcButtnOnPress\",\n    \"HeadLghtHiFlash_D_Actl\",\n    \"HeadLghtHiOn_B_StatAhb\",\n    \"AhbStat_B_Dsply\",\n    \"AccButtnGapTogglePress\",\n    \"WiprFrontSwtch_D_Stat\",\n    \"HeadLghtHiCtrl_D_RqAhb\",\n  ]}\n\n  values.update({\n    \"CcAslButtnCnclPress\": 1 if cancel else 0,      # CC cancel button\n    \"CcAsllButtnResPress\": 1 if resume else 0,      # CC resume button\n    \"TjaButtnOnOffPress\": 1 if tja_toggle else 0,   # LCA/TJA toggle button\n  })\n  return packer.make_can_msg(\"Steering_Data_FD1\", bus, values)\n", "selfdrive/car/ford/carstate.py": "from cereal import car\nfrom opendbc.can.can_define import CANDefine\nfrom opendbc.can.parser import CANParser\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.ford.fordcan import CanBus\nfrom openpilot.selfdrive.car.ford.values import DBC, CarControllerParams, FordFlags\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\n\nGearShifter = car.CarState.GearShifter\nTransmissionType = car.CarParams.TransmissionType\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n    if CP.transmissionType == TransmissionType.automatic:\n      self.shifter_values = can_define.dv[\"Gear_Shift_by_Wire_FD1\"][\"TrnRng_D_RqGsm\"]\n\n    self.vehicle_sensors_valid = False\n\n    self.prev_distance_button = 0\n    self.distance_button = 0\n\n  def update(self, cp, cp_cam):\n    ret = car.CarState.new_message()\n\n    # Occasionally on startup, the ABS module recalibrates the steering pinion offset, so we need to block engagement\n    # The vehicle usually recovers out of this state within a minute of normal driving\n    self.vehicle_sensors_valid = cp.vl[\"SteeringPinion_Data\"][\"StePinCompAnEst_D_Qf\"] == 3\n\n    # car speed\n    ret.vEgoRaw = cp.vl[\"BrakeSysFeatures\"][\"Veh_V_ActlBrk\"] * CV.KPH_TO_MS\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.yawRate = cp.vl[\"Yaw_Data_FD1\"][\"VehYaw_W_Actl\"]\n    ret.standstill = cp.vl[\"DesiredTorqBrk\"][\"VehStop_D_Stat\"] == 1\n\n    # gas pedal\n    ret.gas = cp.vl[\"EngVehicleSpThrottle\"][\"ApedPos_Pc_ActlArb\"] / 100.\n    ret.gasPressed = ret.gas > 1e-6\n\n    # brake pedal\n    ret.brake = cp.vl[\"BrakeSnData_4\"][\"BrkTot_Tq_Actl\"] / 32756.  # torque in Nm\n    ret.brakePressed = cp.vl[\"EngBrakeData\"][\"BpedDrvAppl_D_Actl\"] == 2\n    ret.parkingBrake = cp.vl[\"DesiredTorqBrk\"][\"PrkBrkStatus\"] in (1, 2)\n\n    # steering wheel\n    ret.steeringAngleDeg = cp.vl[\"SteeringPinion_Data\"][\"StePinComp_An_Est\"]\n    ret.steeringTorque = cp.vl[\"EPAS_INFO\"][\"SteeringColumnTorque\"]\n    ret.steeringPressed = self.update_steering_pressed(abs(ret.steeringTorque) > CarControllerParams.STEER_DRIVER_ALLOWANCE, 5)\n    ret.steerFaultTemporary = cp.vl[\"EPAS_INFO\"][\"EPAS_Failure\"] == 1\n    ret.steerFaultPermanent = cp.vl[\"EPAS_INFO\"][\"EPAS_Failure\"] in (2, 3)\n    ret.espDisabled = cp.vl[\"Cluster_Info1_FD1\"][\"DrvSlipCtlMde_D_Rq\"] != 0  # 0 is default mode\n\n    if self.CP.flags & FordFlags.CANFD:\n      # this signal is always 0 on non-CAN FD cars\n      ret.steerFaultTemporary |= cp.vl[\"Lane_Assist_Data3_FD1\"][\"LatCtlSte_D_Stat\"] not in (1, 2, 3)\n\n    # cruise state\n    is_metric = cp.vl[\"INSTRUMENT_PANEL\"][\"METRIC_UNITS\"] == 1 if not self.CP.flags & FordFlags.CANFD else False\n    ret.cruiseState.speed = cp.vl[\"EngBrakeData\"][\"Veh_V_DsplyCcSet\"] * (CV.KPH_TO_MS if is_metric else CV.MPH_TO_MS)\n    ret.cruiseState.enabled = cp.vl[\"EngBrakeData\"][\"CcStat_D_Actl\"] in (4, 5)\n    ret.cruiseState.available = cp.vl[\"EngBrakeData\"][\"CcStat_D_Actl\"] in (3, 4, 5)\n    ret.cruiseState.nonAdaptive = cp.vl[\"Cluster_Info1_FD1\"][\"AccEnbl_B_RqDrv\"] == 0\n    ret.cruiseState.standstill = cp.vl[\"EngBrakeData\"][\"AccStopMde_D_Rq\"] == 3\n    ret.accFaulted = cp.vl[\"EngBrakeData\"][\"CcStat_D_Actl\"] in (1, 2)\n    if not self.CP.openpilotLongitudinalControl:\n      ret.accFaulted = ret.accFaulted or cp_cam.vl[\"ACCDATA\"][\"CmbbDeny_B_Actl\"] == 1\n\n    # gear\n    if self.CP.transmissionType == TransmissionType.automatic:\n      gear = self.shifter_values.get(cp.vl[\"Gear_Shift_by_Wire_FD1\"][\"TrnRng_D_RqGsm\"])\n      ret.gearShifter = self.parse_gear_shifter(gear)\n    elif self.CP.transmissionType == TransmissionType.manual:\n      ret.clutchPressed = cp.vl[\"Engine_Clutch_Data\"][\"CluPdlPos_Pc_Meas\"] > 0\n      if bool(cp.vl[\"BCM_Lamp_Stat_FD1\"][\"RvrseLghtOn_B_Stat\"]):\n        ret.gearShifter = GearShifter.reverse\n      else:\n        ret.gearShifter = GearShifter.drive\n\n    # safety\n    ret.stockFcw = bool(cp_cam.vl[\"ACCDATA_3\"][\"FcwVisblWarn_B_Rq\"])\n    ret.stockAeb = bool(cp_cam.vl[\"ACCDATA_2\"][\"CmbbBrkDecel_B_Rq\"])\n\n    # button presses\n    ret.leftBlinker = cp.vl[\"Steering_Data_FD1\"][\"TurnLghtSwtch_D_Stat\"] == 1\n    ret.rightBlinker = cp.vl[\"Steering_Data_FD1\"][\"TurnLghtSwtch_D_Stat\"] == 2\n    # TODO: block this going to the camera otherwise it will enable stock TJA\n    ret.genericToggle = bool(cp.vl[\"Steering_Data_FD1\"][\"TjaButtnOnOffPress\"])\n    self.prev_distance_button = self.distance_button\n    self.distance_button = cp.vl[\"Steering_Data_FD1\"][\"AccButtnGapTogglePress\"]\n\n    # lock info\n    ret.doorOpen = any([cp.vl[\"BodyInfo_3_FD1\"][\"DrStatDrv_B_Actl\"], cp.vl[\"BodyInfo_3_FD1\"][\"DrStatPsngr_B_Actl\"],\n                        cp.vl[\"BodyInfo_3_FD1\"][\"DrStatRl_B_Actl\"], cp.vl[\"BodyInfo_3_FD1\"][\"DrStatRr_B_Actl\"]])\n    ret.seatbeltUnlatched = cp.vl[\"RCMStatusMessage2_FD1\"][\"FirstRowBuckleDriver\"] == 2\n\n    # blindspot sensors\n    if self.CP.enableBsm:\n      cp_bsm = cp_cam if self.CP.flags & FordFlags.CANFD else cp\n      ret.leftBlindspot = cp_bsm.vl[\"Side_Detect_L_Stat\"][\"SodDetctLeft_D_Stat\"] != 0\n      ret.rightBlindspot = cp_bsm.vl[\"Side_Detect_R_Stat\"][\"SodDetctRight_D_Stat\"] != 0\n\n    # Stock steering buttons so that we can passthru blinkers etc.\n    self.buttons_stock_values = cp.vl[\"Steering_Data_FD1\"]\n    # Stock values from IPMA so that we can retain some stock functionality\n    self.acc_tja_status_stock_values = cp_cam.vl[\"ACCDATA_3\"]\n    self.lkas_status_stock_values = cp_cam.vl[\"IPMA_Data\"]\n\n    return ret\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"VehicleOperatingModes\", 100),\n      (\"BrakeSysFeatures\", 50),\n      (\"Yaw_Data_FD1\", 100),\n      (\"DesiredTorqBrk\", 50),\n      (\"EngVehicleSpThrottle\", 100),\n      (\"BrakeSnData_4\", 50),\n      (\"EngBrakeData\", 10),\n      (\"Cluster_Info1_FD1\", 10),\n      (\"SteeringPinion_Data\", 100),\n      (\"EPAS_INFO\", 50),\n      (\"Steering_Data_FD1\", 10),\n      (\"BodyInfo_3_FD1\", 2),\n      (\"RCMStatusMessage2_FD1\", 10),\n    ]\n\n    if CP.flags & FordFlags.CANFD:\n      messages += [\n        (\"Lane_Assist_Data3_FD1\", 33),\n      ]\n    else:\n      messages += [\n        (\"INSTRUMENT_PANEL\", 1),\n      ]\n\n    if CP.transmissionType == TransmissionType.automatic:\n      messages += [\n        (\"Gear_Shift_by_Wire_FD1\", 10),\n      ]\n    elif CP.transmissionType == TransmissionType.manual:\n      messages += [\n        (\"Engine_Clutch_Data\", 33),\n        (\"BCM_Lamp_Stat_FD1\", 1),\n      ]\n\n    if CP.enableBsm and not (CP.flags & FordFlags.CANFD):\n      messages += [\n        (\"Side_Detect_L_Stat\", 5),\n        (\"Side_Detect_R_Stat\", 5),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus(CP).main)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"ACCDATA\", 50),\n      (\"ACCDATA_2\", 50),\n      (\"ACCDATA_3\", 5),\n      (\"IPMA_Data\", 1),\n    ]\n\n    if CP.enableBsm and CP.flags & FordFlags.CANFD:\n      messages += [\n        (\"Side_Detect_L_Stat\", 5),\n        (\"Side_Detect_R_Stat\", 5),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus(CP).camera)\n", "selfdrive/car/ford/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.ford.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFW_VERSIONS = {\n  CAR.FORD_BRONCO_SPORT_MK1: {\n    (Ecu.eps, 0x730, None): [\n      b'LX6C-14D003-AH\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-14D003-AK\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-14D003-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'LX6C-2D053-RD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-2D053-RE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-2D053-RF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'LB5T-14D049-AB\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'M1PT-14F397-AC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'M1PT-14F397-AD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_ESCAPE_MK4: {\n    (Ecu.eps, 0x730, None): [\n      b'LX6C-14D003-AF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-14D003-AH\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-14D003-AK\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-14D003-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'LX6C-2D053-NS\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-2D053-NT\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-2D053-NY\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-2D053-SA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LX6C-2D053-SD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'LB5T-14D049-AB\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'LJ6T-14F397-AD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LJ6T-14F397-AE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LV4T-14F397-GG\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_EXPLORER_MK6: {\n    (Ecu.eps, 0x730, None): [\n      b'L1MC-14D003-AJ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-14D003-AK\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-14D003-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'M1MC-14D003-AB\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'M1MC-14D003-AC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'P1MC-14D003-AA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'L1MC-2D053-AJ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-2D053-BA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-2D053-BB\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-2D053-BD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-2D053-BF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-2D053-BJ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'L1MC-2D053-KB\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'LB5T-14D049-AB\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'LB5T-14F397-AD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LB5T-14F397-AE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LB5T-14F397-AF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LC5T-14F397-AE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LC5T-14F397-AH\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_F_150_MK14: {\n    (Ecu.eps, 0x730, None): [\n      b'ML3V-14D003-BC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'PL34-2D053-CA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'ML3T-14D049-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'ML3T-14H102-ABR\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PJ6T-14H102-ABJ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_F_150_LIGHTNING_MK1: {\n    (Ecu.abs, 0x760, None): [\n      b'PL38-2D053-AA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'ML3T-14H102-ABT\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'ML3T-14D049-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_MUSTANG_MACH_E_MK1: {\n    (Ecu.eps, 0x730, None): [\n      b'LJ9C-14D003-AM\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'LJ9C-14D003-CC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'LK9C-2D053-CK\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'ML3T-14D049-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'ML3T-14H102-ABS\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_FOCUS_MK4: {\n    (Ecu.eps, 0x730, None): [\n      b'JX6C-14D003-AH\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'JX61-2D053-CJ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'JX7T-14D049-AC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'JX7T-14F397-AH\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_MAVERICK_MK1: {\n    (Ecu.eps, 0x730, None): [\n      b'NZ6C-14D003-AK\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'NZ6C-14D003-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'NZ6C-2D053-AE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'NZ6C-2D053-AG\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PZ6C-2D053-ED\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PZ6C-2D053-EE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'PZ6C-2D053-EF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'NZ6T-14D049-AA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'NZ6T-14F397-AC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.FORD_RANGER_MK2: {\n    (Ecu.eps, 0x730, None): [\n      b'NL14-14D003-AE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x760, None): [\n      b'PB3C-2D053-ZD\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x764, None): [\n      b'ML3T-14D049-AL\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x706, None): [\n      b'PJ6T-14H102-ABJ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n  },\n}\n", "selfdrive/car/ford/values.py": "import copy\nimport re\nfrom dataclasses import dataclass, field, replace\nfrom enum import Enum, IntFlag\n\nimport panda.python.uds as uds\nfrom cereal import car\nfrom openpilot.selfdrive.car import AngleRateLimit, CarSpecs, dbc_dict, DbcDict, PlatformConfig, Platforms\nfrom openpilot.selfdrive.car.docs_definitions import CarFootnote, CarHarness, CarDocs, CarParts, Column, \\\n                                                     Device\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, LiveFwVersions, OfflineFwVersions, Request, StdQueries, p16\n\nEcu = car.CarParams.Ecu\n\n\nclass CarControllerParams:\n  STEER_STEP = 5        # LateralMotionControl, 20Hz\n  LKA_STEP = 3          # Lane_Assist_Data1, 33Hz\n  ACC_CONTROL_STEP = 2  # ACCDATA, 50Hz\n  LKAS_UI_STEP = 100    # IPMA_Data, 1Hz\n  ACC_UI_STEP = 20      # ACCDATA_3, 5Hz\n  BUTTONS_STEP = 5      # Steering_Data_FD1, 10Hz, but send twice as fast\n\n  CURVATURE_MAX = 0.02  # Max curvature for steering command, m^-1\n  STEER_DRIVER_ALLOWANCE = 1.0  # Driver intervention threshold, Nm\n\n  # Curvature rate limits\n  # The curvature signal is limited to 0.003 to 0.009 m^-1/sec by the EPS depending on speed and direction\n  # Limit to ~2 m/s^3 up, ~3 m/s^3 down at 75 mph\n  # Worst case, the low speed limits will allow 4.3 m/s^3 up, 4.9 m/s^3 down at 75 mph\n  ANGLE_RATE_LIMIT_UP = AngleRateLimit(speed_bp=[5, 25], angle_v=[0.0002, 0.0001])\n  ANGLE_RATE_LIMIT_DOWN = AngleRateLimit(speed_bp=[5, 25], angle_v=[0.000225, 0.00015])\n  CURVATURE_ERROR = 0.002  # ~6 degrees at 10 m/s, ~10 degrees at 35 m/s\n\n  ACCEL_MAX = 2.0               # m/s^2 max acceleration\n  ACCEL_MIN = -3.5              # m/s^2 max deceleration\n  MIN_GAS = -0.5\n  INACTIVE_GAS = -5.0\n\n  def __init__(self, CP):\n    pass\n\n\nclass FordFlags(IntFlag):\n  # Static flags\n  CANFD = 1\n\n\nclass RADAR:\n  DELPHI_ESR = 'ford_fusion_2018_adas'\n  DELPHI_MRR = 'FORD_CADS'\n\n\nclass Footnote(Enum):\n  FOCUS = CarFootnote(\n    \"Refers only to the Focus Mk4 (C519) available in Europe/China/Taiwan/Australasia, not the Focus Mk3 (C346) in \" +\n    \"North and South America/Southeast Asia.\",\n    Column.MODEL,\n  )\n\n\n@dataclass\nclass FordCarDocs(CarDocs):\n  package: str = \"Co-Pilot360 Assist+\"\n  hybrid: bool = False\n  plug_in_hybrid: bool = False\n\n  def init_make(self, CP: car.CarParams):\n    harness = CarHarness.ford_q4 if CP.flags & FordFlags.CANFD else CarHarness.ford_q3\n    if CP.carFingerprint in (CAR.FORD_BRONCO_SPORT_MK1, CAR.FORD_MAVERICK_MK1, CAR.FORD_F_150_MK14, CAR.FORD_F_150_LIGHTNING_MK1):\n      self.car_parts = CarParts([Device.threex_angled_mount, harness])\n    else:\n      self.car_parts = CarParts([Device.threex, harness])\n\n\n@dataclass\nclass FordPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('ford_lincoln_base_pt', RADAR.DELPHI_MRR))\n\n  def init(self):\n    for car_docs in list(self.car_docs):\n      if car_docs.hybrid:\n        name = f\"{car_docs.make} {car_docs.model} Hybrid {car_docs.years}\"\n        self.car_docs.append(replace(copy.deepcopy(car_docs), name=name))\n      if car_docs.plug_in_hybrid:\n        name = f\"{car_docs.make} {car_docs.model} Plug-in Hybrid {car_docs.years}\"\n        self.car_docs.append(replace(copy.deepcopy(car_docs), name=name))\n\n\n@dataclass\nclass FordCANFDPlatformConfig(FordPlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('ford_lincoln_base_pt', None))\n\n  def init(self):\n    super().init()\n    self.flags |= FordFlags.CANFD\n\n\nclass CAR(Platforms):\n  FORD_BRONCO_SPORT_MK1 = FordPlatformConfig(\n    [FordCarDocs(\"Ford Bronco Sport 2021-23\")],\n    CarSpecs(mass=1625, wheelbase=2.67, steerRatio=17.7),\n  )\n  FORD_ESCAPE_MK4 = FordPlatformConfig(\n    [\n      FordCarDocs(\"Ford Escape 2020-22\", hybrid=True, plug_in_hybrid=True),\n      FordCarDocs(\"Ford Kuga 2020-22\", \"Adaptive Cruise Control with Lane Centering\", hybrid=True, plug_in_hybrid=True),\n    ],\n    CarSpecs(mass=1750, wheelbase=2.71, steerRatio=16.7),\n  )\n  FORD_EXPLORER_MK6 = FordPlatformConfig(\n    [\n      FordCarDocs(\"Ford Explorer 2020-23\", hybrid=True),  # Hybrid: Limited and Platinum only\n      FordCarDocs(\"Lincoln Aviator 2020-23\", \"Co-Pilot360 Plus\", plug_in_hybrid=True),  # Hybrid: Grand Touring only\n    ],\n    CarSpecs(mass=2050, wheelbase=3.025, steerRatio=16.8),\n  )\n  FORD_F_150_MK14 = FordCANFDPlatformConfig(\n    [FordCarDocs(\"Ford F-150 2022-23\", \"Co-Pilot360 Active 2.0\", hybrid=True)],\n    CarSpecs(mass=2000, wheelbase=3.69, steerRatio=17.0),\n  )\n  FORD_F_150_LIGHTNING_MK1 = FordCANFDPlatformConfig(\n    [FordCarDocs(\"Ford F-150 Lightning 2021-23\", \"Co-Pilot360 Active 2.0\")],\n    CarSpecs(mass=2948, wheelbase=3.70, steerRatio=16.9),\n  )\n  FORD_FOCUS_MK4 = FordPlatformConfig(\n    [FordCarDocs(\"Ford Focus 2018\", \"Adaptive Cruise Control with Lane Centering\", footnotes=[Footnote.FOCUS], hybrid=True)],  # mHEV only\n    CarSpecs(mass=1350, wheelbase=2.7, steerRatio=15.0),\n  )\n  FORD_MAVERICK_MK1 = FordPlatformConfig(\n    [\n      FordCarDocs(\"Ford Maverick 2022\", \"LARIAT Luxury\", hybrid=True),\n      FordCarDocs(\"Ford Maverick 2023-24\", \"Co-Pilot360 Assist\", hybrid=True),\n    ],\n    CarSpecs(mass=1650, wheelbase=3.076, steerRatio=17.0),\n  )\n  FORD_MUSTANG_MACH_E_MK1 = FordCANFDPlatformConfig(\n    [FordCarDocs(\"Ford Mustang Mach-E 2021-23\", \"Co-Pilot360 Active 2.0\")],\n    CarSpecs(mass=2200, wheelbase=2.984, steerRatio=17.0),  # TODO: check steer ratio\n  )\n  FORD_RANGER_MK2 = FordCANFDPlatformConfig(\n    [FordCarDocs(\"Ford Ranger 2024\", \"Adaptive Cruise Control with Lane Centering\")],\n    CarSpecs(mass=2000, wheelbase=3.27, steerRatio=17.0),\n  )\n\n\n# FW response contains a combined software and part number\n# A-Z except no I, O or W\n# e.g. NZ6A-14C204-AAA\n#      1222-333333-444\n# 1 = Model year hint (approximates model year/generation)\n# 2 = Platform hint\n# 3 = Part number\n# 4 = Software version\nFW_ALPHABET = b'A-HJ-NP-VX-Z'\nFW_PATTERN = re.compile(b'^(?P<model_year_hint>[' + FW_ALPHABET + b'])' +\n                        b'(?P<platform_hint>[0-9' + FW_ALPHABET + b']{3})-' +\n                        b'(?P<part_number>[0-9' + FW_ALPHABET + b']{5,6})-' +\n                        b'(?P<software_revision>[' + FW_ALPHABET + b']{2,})\\x00*$')\n\n\ndef get_platform_codes(fw_versions: list[bytes] | set[bytes]) -> set[tuple[bytes, bytes]]:\n  codes = set()\n  for fw in fw_versions:\n    match = FW_PATTERN.match(fw)\n    if match is not None:\n      codes.add((match.group('platform_hint'), match.group('model_year_hint')))\n\n  return codes\n\n\ndef match_fw_to_car_fuzzy(live_fw_versions: LiveFwVersions, vin: str, offline_fw_versions: OfflineFwVersions) -> set[str]:\n  candidates: set[str] = set()\n\n  for candidate, fws in offline_fw_versions.items():\n    # Keep track of ECUs which pass all checks (platform hint, within model year hint range)\n    valid_found_ecus = set()\n    valid_expected_ecus = {ecu[1:] for ecu in fws if ecu[0] in PLATFORM_CODE_ECUS}\n    for ecu, expected_versions in fws.items():\n      addr = ecu[1:]\n      # Only check ECUs expected to have platform codes\n      if ecu[0] not in PLATFORM_CODE_ECUS:\n        continue\n\n      # Expected platform codes & model year hints\n      codes = get_platform_codes(expected_versions)\n      expected_platform_codes = {code for code, _ in codes}\n      expected_model_year_hints = {model_year_hint for _, model_year_hint in codes}\n\n      # Found platform codes & model year hints\n      codes = get_platform_codes(live_fw_versions.get(addr, set()))\n      found_platform_codes = {code for code, _ in codes}\n      found_model_year_hints = {model_year_hint for _, model_year_hint in codes}\n\n      # Check platform code matches for any found versions\n      if not any(found_platform_code in expected_platform_codes for found_platform_code in found_platform_codes):\n        break\n\n      # Check any model year hint within range in the database. Note that some models have more than one\n      # platform code per ECU which we don't consider as separate ranges\n      if not any(min(expected_model_year_hints) <= found_model_year_hint <= max(expected_model_year_hints) for\n                 found_model_year_hint in found_model_year_hints):\n        break\n\n      valid_found_ecus.add(addr)\n\n    # If all live ECUs pass all checks for candidate, add it as a match\n    if valid_expected_ecus.issubset(valid_found_ecus):\n      candidates.add(candidate)\n\n  return candidates\n\n\n# All of these ECUs must be present and are expected to have platform codes we can match\nPLATFORM_CODE_ECUS = (Ecu.abs, Ecu.fwdCamera, Ecu.fwdRadar, Ecu.eps)\n\nDATA_IDENTIFIER_FORD_ASBUILT = 0xDE00\n\nASBUILT_BLOCKS: list[tuple[int, list]] = [\n  (1, [Ecu.debug, Ecu.fwdCamera, Ecu.eps]),\n  (2, [Ecu.abs, Ecu.debug, Ecu.eps]),\n  (3, [Ecu.abs, Ecu.debug, Ecu.eps]),\n  (4, [Ecu.debug, Ecu.fwdCamera]),\n  (5, [Ecu.debug]),\n  (6, [Ecu.debug]),\n  (7, [Ecu.debug]),\n  (8, [Ecu.debug]),\n  (9, [Ecu.debug]),\n  (16, [Ecu.debug, Ecu.fwdCamera]),\n  (18, [Ecu.fwdCamera]),\n  (20, [Ecu.fwdCamera]),\n  (21, [Ecu.fwdCamera]),\n]\n\n\ndef ford_asbuilt_block_request(block_id: int):\n  return bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + p16(DATA_IDENTIFIER_FORD_ASBUILT + block_id - 1)\n\n\ndef ford_asbuilt_block_response(block_id: int):\n  return bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + p16(DATA_IDENTIFIER_FORD_ASBUILT + block_id - 1)\n\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    # CAN and CAN FD queries are combined.\n    # FIXME: For CAN FD, ECUs respond with frames larger than 8 bytes on the powertrain bus\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.MANUFACTURER_SOFTWARE_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.MANUFACTURER_SOFTWARE_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.debug, Ecu.engine, Ecu.eps, Ecu.fwdCamera, Ecu.fwdRadar, Ecu.shiftByWire],\n      logging=True,\n    ),\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.MANUFACTURER_SOFTWARE_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.MANUFACTURER_SOFTWARE_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.debug, Ecu.engine, Ecu.eps, Ecu.fwdCamera, Ecu.fwdRadar, Ecu.shiftByWire],\n      bus=0,\n      auxiliary=True,\n    ),\n    *[Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, ford_asbuilt_block_request(block_id)],\n      [StdQueries.TESTER_PRESENT_RESPONSE, ford_asbuilt_block_response(block_id)],\n      whitelist_ecus=ecus,\n      bus=0,\n      logging=True,\n    ) for block_id, ecus in ASBUILT_BLOCKS],\n  ],\n  extra_ecus=[\n    (Ecu.engine, 0x7e0, None),        # Powertrain Control Module\n                                      # Note: We are unlikely to get a response from behind the gateway\n    (Ecu.shiftByWire, 0x732, None),   # Gear Shift Module\n    (Ecu.debug, 0x7d0, None),         # Accessory Protocol Interface Module\n  ],\n  # Custom fuzzy fingerprinting function using platform and model year hints\n  match_fw_to_car_fuzzy=match_fw_to_car_fuzzy,\n)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/ford/carcontroller.py": "from cereal import car\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.selfdrive.car import apply_std_steer_angle_limits\nfrom openpilot.selfdrive.car.ford import fordcan\nfrom openpilot.selfdrive.car.ford.values import CarControllerParams, FordFlags\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.controls.lib.drive_helpers import V_CRUISE_MAX\n\nLongCtrlState = car.CarControl.Actuators.LongControlState\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\n\ndef apply_ford_curvature_limits(apply_curvature, apply_curvature_last, current_curvature, v_ego_raw):\n  # No blending at low speed due to lack of torque wind-up and inaccurate current curvature\n  if v_ego_raw > 9:\n    apply_curvature = clip(apply_curvature, current_curvature - CarControllerParams.CURVATURE_ERROR,\n                           current_curvature + CarControllerParams.CURVATURE_ERROR)\n\n  # Curvature rate limit after driver torque limit\n  apply_curvature = apply_std_steer_angle_limits(apply_curvature, apply_curvature_last, v_ego_raw, CarControllerParams)\n\n  return clip(apply_curvature, -CarControllerParams.CURVATURE_MAX, CarControllerParams.CURVATURE_MAX)\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.VM = VM\n    self.packer = CANPacker(dbc_name)\n    self.CAN = fordcan.CanBus(CP)\n    self.frame = 0\n\n    self.apply_curvature_last = 0\n    self.main_on_last = False\n    self.lkas_enabled_last = False\n    self.steer_alert_last = False\n    self.lead_distance_bars_last = None\n\n  def update(self, CC, CS, now_nanos):\n    can_sends = []\n\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n\n    main_on = CS.out.cruiseState.available\n    steer_alert = hud_control.visualAlert in (VisualAlert.steerRequired, VisualAlert.ldw)\n    fcw_alert = hud_control.visualAlert == VisualAlert.fcw\n\n    ### acc buttons ###\n    if CC.cruiseControl.cancel:\n      can_sends.append(fordcan.create_button_msg(self.packer, self.CAN.camera, CS.buttons_stock_values, cancel=True))\n      can_sends.append(fordcan.create_button_msg(self.packer, self.CAN.main, CS.buttons_stock_values, cancel=True))\n    elif CC.cruiseControl.resume and (self.frame % CarControllerParams.BUTTONS_STEP) == 0:\n      can_sends.append(fordcan.create_button_msg(self.packer, self.CAN.camera, CS.buttons_stock_values, resume=True))\n      can_sends.append(fordcan.create_button_msg(self.packer, self.CAN.main, CS.buttons_stock_values, resume=True))\n    # if stock lane centering isn't off, send a button press to toggle it off\n    # the stock system checks for steering pressed, and eventually disengages cruise control\n    elif CS.acc_tja_status_stock_values[\"Tja_D_Stat\"] != 0 and (self.frame % CarControllerParams.ACC_UI_STEP) == 0:\n      can_sends.append(fordcan.create_button_msg(self.packer, self.CAN.camera, CS.buttons_stock_values, tja_toggle=True))\n\n    ### lateral control ###\n    # send steer msg at 20Hz\n    if (self.frame % CarControllerParams.STEER_STEP) == 0:\n      if CC.latActive:\n        # apply rate limits, curvature error limit, and clip to signal range\n        current_curvature = -CS.out.yawRate / max(CS.out.vEgoRaw, 0.1)\n        apply_curvature = apply_ford_curvature_limits(actuators.curvature, self.apply_curvature_last, current_curvature, CS.out.vEgoRaw)\n      else:\n        apply_curvature = 0.\n\n      self.apply_curvature_last = apply_curvature\n\n      if self.CP.flags & FordFlags.CANFD:\n        # TODO: extended mode\n        mode = 1 if CC.latActive else 0\n        counter = (self.frame // CarControllerParams.STEER_STEP) % 0x10\n        can_sends.append(fordcan.create_lat_ctl2_msg(self.packer, self.CAN, mode, 0., 0., -apply_curvature, 0., counter))\n      else:\n        can_sends.append(fordcan.create_lat_ctl_msg(self.packer, self.CAN, CC.latActive, 0., 0., -apply_curvature, 0.))\n\n    # send lka msg at 33Hz\n    if (self.frame % CarControllerParams.LKA_STEP) == 0:\n      can_sends.append(fordcan.create_lka_msg(self.packer, self.CAN))\n\n    ### longitudinal control ###\n    # send acc msg at 50Hz\n    if self.CP.openpilotLongitudinalControl and (self.frame % CarControllerParams.ACC_CONTROL_STEP) == 0:\n      # Both gas and accel are in m/s^2, accel is used solely for braking\n      accel = clip(actuators.accel, CarControllerParams.ACCEL_MIN, CarControllerParams.ACCEL_MAX)\n      gas = accel\n      if not CC.longActive or gas < CarControllerParams.MIN_GAS:\n        gas = CarControllerParams.INACTIVE_GAS\n      stopping = CC.actuators.longControlState == LongCtrlState.stopping\n      can_sends.append(fordcan.create_acc_msg(self.packer, self.CAN, CC.longActive, gas, accel, stopping, v_ego_kph=V_CRUISE_MAX))\n\n    ### ui ###\n    send_ui = (self.main_on_last != main_on) or (self.lkas_enabled_last != CC.latActive) or (self.steer_alert_last != steer_alert)\n    # send lkas ui msg at 1Hz or if ui state changes\n    if (self.frame % CarControllerParams.LKAS_UI_STEP) == 0 or send_ui:\n      can_sends.append(fordcan.create_lkas_ui_msg(self.packer, self.CAN, main_on, CC.latActive, steer_alert, hud_control, CS.lkas_status_stock_values))\n\n    # send acc ui msg at 5Hz or if ui state changes\n    if hud_control.leadDistanceBars != self.lead_distance_bars_last:\n      send_ui = True\n    if (self.frame % CarControllerParams.ACC_UI_STEP) == 0 or send_ui:\n      can_sends.append(fordcan.create_acc_ui_msg(self.packer, self.CAN, self.CP, main_on, CC.latActive,\n                                                 fcw_alert, CS.out.cruiseState.standstill, hud_control,\n                                                 CS.acc_tja_status_stock_values))\n\n    self.main_on_last = main_on\n    self.lkas_enabled_last = CC.latActive\n    self.steer_alert_last = steer_alert\n    self.lead_distance_bars_last = hud_control.leadDistanceBars\n\n    new_actuators = actuators.as_builder()\n    new_actuators.curvature = self.apply_curvature_last\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/ford/radar_interface.py": "from math import cos, sin\nfrom cereal import car\nfrom opendbc.can.parser import CANParser\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.ford.fordcan import CanBus\nfrom openpilot.selfdrive.car.ford.values import DBC, RADAR\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nDELPHI_ESR_RADAR_MSGS = list(range(0x500, 0x540))\n\nDELPHI_MRR_RADAR_START_ADDR = 0x120\nDELPHI_MRR_RADAR_MSG_COUNT = 64\n\n\ndef _create_delphi_esr_radar_can_parser(CP) -> CANParser:\n  msg_n = len(DELPHI_ESR_RADAR_MSGS)\n  messages = list(zip(DELPHI_ESR_RADAR_MSGS, [20] * msg_n, strict=True))\n\n  return CANParser(RADAR.DELPHI_ESR, messages, CanBus(CP).radar)\n\n\ndef _create_delphi_mrr_radar_can_parser(CP) -> CANParser:\n  messages = []\n\n  for i in range(1, DELPHI_MRR_RADAR_MSG_COUNT + 1):\n    msg = f\"MRR_Detection_{i:03d}\"\n    messages += [(msg, 20)]\n\n  return CANParser(RADAR.DELPHI_MRR, messages, CanBus(CP).radar)\n\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n\n    self.updated_messages = set()\n    self.track_id = 0\n    self.radar = DBC[CP.carFingerprint]['radar']\n    if self.radar is None or CP.radarUnavailable:\n      self.rcp = None\n    elif self.radar == RADAR.DELPHI_ESR:\n      self.rcp = _create_delphi_esr_radar_can_parser(CP)\n      self.trigger_msg = DELPHI_ESR_RADAR_MSGS[-1]\n      self.valid_cnt = {key: 0 for key in DELPHI_ESR_RADAR_MSGS}\n    elif self.radar == RADAR.DELPHI_MRR:\n      self.rcp = _create_delphi_mrr_radar_can_parser(CP)\n      self.trigger_msg = DELPHI_MRR_RADAR_START_ADDR + DELPHI_MRR_RADAR_MSG_COUNT - 1\n    else:\n      raise ValueError(f\"Unsupported radar: {self.radar}\")\n\n  def update(self, can_strings):\n    if self.rcp is None:\n      return super().update(None)\n\n    vls = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(vls)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    ret = car.RadarData.new_message()\n    errors = []\n    if not self.rcp.can_valid:\n      errors.append(\"canError\")\n    ret.errors = errors\n\n    if self.radar == RADAR.DELPHI_ESR:\n      self._update_delphi_esr()\n    elif self.radar == RADAR.DELPHI_MRR:\n      self._update_delphi_mrr()\n\n    ret.points = list(self.pts.values())\n    self.updated_messages.clear()\n    return ret\n\n  def _update_delphi_esr(self):\n    for ii in sorted(self.updated_messages):\n      cpt = self.rcp.vl[ii]\n\n      if cpt['X_Rel'] > 0.00001:\n        self.valid_cnt[ii] = 0    # reset counter\n\n      if cpt['X_Rel'] > 0.00001:\n        self.valid_cnt[ii] += 1\n      else:\n        self.valid_cnt[ii] = max(self.valid_cnt[ii] - 1, 0)\n      #print ii, self.valid_cnt[ii], cpt['VALID'], cpt['X_Rel'], cpt['Angle']\n\n      # radar point only valid if there have been enough valid measurements\n      if self.valid_cnt[ii] > 0:\n        if ii not in self.pts:\n          self.pts[ii] = car.RadarData.RadarPoint.new_message()\n          self.pts[ii].trackId = self.track_id\n          self.track_id += 1\n        self.pts[ii].dRel = cpt['X_Rel']  # from front of car\n        self.pts[ii].yRel = cpt['X_Rel'] * cpt['Angle'] * CV.DEG_TO_RAD  # in car frame's y axis, left is positive\n        self.pts[ii].vRel = cpt['V_Rel']\n        self.pts[ii].aRel = float('nan')\n        self.pts[ii].yvRel = float('nan')\n        self.pts[ii].measured = True\n      else:\n        if ii in self.pts:\n          del self.pts[ii]\n\n  def _update_delphi_mrr(self):\n    for ii in range(1, DELPHI_MRR_RADAR_MSG_COUNT + 1):\n      msg = self.rcp.vl[f\"MRR_Detection_{ii:03d}\"]\n\n      # SCAN_INDEX rotates through 0..3 on each message\n      # treat these as separate points\n      scanIndex = msg[f\"CAN_SCAN_INDEX_2LSB_{ii:02d}\"]\n      i = (ii - 1) * 4 + scanIndex\n\n      if i not in self.pts:\n        self.pts[i] = car.RadarData.RadarPoint.new_message()\n        self.pts[i].trackId = self.track_id\n        self.pts[i].aRel = float('nan')\n        self.pts[i].yvRel = float('nan')\n        self.track_id += 1\n\n      valid = bool(msg[f\"CAN_DET_VALID_LEVEL_{ii:02d}\"])\n\n      if valid:\n        azimuth = msg[f\"CAN_DET_AZIMUTH_{ii:02d}\"]              # rad [-3.1416|3.13964]\n        dist = msg[f\"CAN_DET_RANGE_{ii:02d}\"]                   # m [0|255.984]\n        distRate = msg[f\"CAN_DET_RANGE_RATE_{ii:02d}\"]          # m/s [-128|127.984]\n        dRel = cos(azimuth) * dist                              # m from front of car\n        yRel = -sin(azimuth) * dist                             # in car frame's y axis, left is positive\n\n        # delphi doesn't notify of track switches, so do it manually\n        # TODO: refactor this to radard if more radars behave this way\n        if abs(self.pts[i].vRel - distRate) > 2 or abs(self.pts[i].dRel - dRel) > 5:\n          self.track_id += 1\n          self.pts[i].trackId = self.track_id\n\n        self.pts[i].dRel = dRel\n        self.pts[i].yRel = yRel\n        self.pts[i].vRel = distRate\n\n        self.pts[i].measured = True\n\n      else:\n        del self.pts[i]\n", "selfdrive/car/ford/__init__.py": "", "selfdrive/car/ford/interface.py": "from cereal import car\nfrom panda import Panda\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.ford.fordcan import CanBus\nfrom openpilot.selfdrive.car.ford.values import Ecu, FordFlags\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\n\nButtonType = car.CarState.ButtonEvent.Type\nTransmissionType = car.CarParams.TransmissionType\nGearShifter = car.CarState.GearShifter\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"ford\"\n    ret.dashcamOnly = bool(ret.flags & FordFlags.CANFD)\n\n    ret.radarUnavailable = True\n    ret.steerControlType = car.CarParams.SteerControlType.angle\n    ret.steerActuatorDelay = 0.2\n    ret.steerLimitTimer = 1.0\n\n    CAN = CanBus(fingerprint=fingerprint)\n    cfgs = [get_safety_config(car.CarParams.SafetyModel.ford)]\n    if CAN.main >= 4:\n      cfgs.insert(0, get_safety_config(car.CarParams.SafetyModel.noOutput))\n    ret.safetyConfigs = cfgs\n\n    ret.experimentalLongitudinalAvailable = True\n    if experimental_long:\n      ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_FORD_LONG_CONTROL\n      ret.openpilotLongitudinalControl = True\n\n    if ret.flags & FordFlags.CANFD:\n      ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_FORD_CANFD\n    else:\n      # Lock out if the car does not have needed lateral and longitudinal control APIs.\n      # Note that we also check CAN for adaptive cruise, but no known signal for LCA exists\n      pscm_config = next((fw for fw in car_fw if fw.ecu == Ecu.eps and b'\\x22\\xDE\\x01' in fw.request), None)\n      if pscm_config:\n        if len(pscm_config.fwVersion) != 24:\n          ret.dashcamOnly = True\n        else:\n          config_tja = pscm_config.fwVersion[7]  # Traffic Jam Assist\n          config_lca = pscm_config.fwVersion[8]  # Lane Centering Assist\n          if config_tja != 0xFF or config_lca != 0xFF:\n            ret.dashcamOnly = True\n\n    # Auto Transmission: 0x732 ECU or Gear_Shift_by_Wire_FD1\n    found_ecus = [fw.ecu for fw in car_fw]\n    if Ecu.shiftByWire in found_ecus or 0x5A in fingerprint[CAN.main] or docs:\n      ret.transmissionType = TransmissionType.automatic\n    else:\n      ret.transmissionType = TransmissionType.manual\n      ret.minEnableSpeed = 20.0 * CV.MPH_TO_MS\n\n    # BSM: Side_Detect_L_Stat, Side_Detect_R_Stat\n    # TODO: detect bsm in car_fw?\n    ret.enableBsm = 0x3A6 in fingerprint[CAN.main] and 0x3A7 in fingerprint[CAN.main]\n\n    # LCA can steer down to zero\n    ret.minSteerSpeed = 0.\n\n    ret.autoResumeSng = ret.minEnableSpeed == -1.\n    ret.centerToFront = ret.wheelbase * 0.44\n    return ret\n\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam)\n\n    ret.buttonEvents = create_button_events(self.CS.distance_button, self.CS.prev_distance_button, {1: ButtonType.gapAdjustCruise})\n\n    events = self.create_common_events(ret, extra_gears=[GearShifter.manumatic])\n    if not self.CS.vehicle_sensors_valid:\n      events.add(car.CarEvent.EventName.vehicleSensorsInvalid)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/volkswagen/carstate.py": "import numpy as np\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.volkswagen.values import DBC, CANBUS, NetworkLocation, TransmissionType, GearShifter, \\\n                                            CarControllerParams, VolkswagenFlags\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.frame = 0\n    self.eps_init_complete = False\n    self.CCP = CarControllerParams(CP)\n    self.button_states = {button.event_type: False for button in self.CCP.BUTTONS}\n    self.esp_hold_confirmation = False\n    self.upscale_lead_car_signal = False\n    self.eps_stock_values = False\n\n  def create_button_events(self, pt_cp, buttons):\n    button_events = []\n\n    for button in buttons:\n      state = pt_cp.vl[button.can_addr][button.can_msg] in button.values\n      if self.button_states[button.event_type] != state:\n        event = car.CarState.ButtonEvent.new_message()\n        event.type = button.event_type\n        event.pressed = state\n        button_events.append(event)\n      self.button_states[button.event_type] = state\n\n    return button_events\n\n  def update(self, pt_cp, cam_cp, ext_cp, trans_type):\n    if self.CP.flags & VolkswagenFlags.PQ:\n      return self.update_pq(pt_cp, cam_cp, ext_cp, trans_type)\n\n    ret = car.CarState.new_message()\n    # Update vehicle speed and acceleration from ABS wheel speeds.\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      pt_cp.vl[\"ESP_19\"][\"ESP_VL_Radgeschw_02\"],\n      pt_cp.vl[\"ESP_19\"][\"ESP_VR_Radgeschw_02\"],\n      pt_cp.vl[\"ESP_19\"][\"ESP_HL_Radgeschw_02\"],\n      pt_cp.vl[\"ESP_19\"][\"ESP_HR_Radgeschw_02\"],\n    )\n\n    ret.vEgoRaw = float(np.mean([ret.wheelSpeeds.fl, ret.wheelSpeeds.fr, ret.wheelSpeeds.rl, ret.wheelSpeeds.rr]))\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = ret.vEgoRaw == 0\n\n    # Update EPS position and state info. For signed values, VW sends the sign in a separate signal.\n    ret.steeringAngleDeg = pt_cp.vl[\"LWI_01\"][\"LWI_Lenkradwinkel\"] * (1, -1)[int(pt_cp.vl[\"LWI_01\"][\"LWI_VZ_Lenkradwinkel\"])]\n    ret.steeringRateDeg = pt_cp.vl[\"LWI_01\"][\"LWI_Lenkradw_Geschw\"] * (1, -1)[int(pt_cp.vl[\"LWI_01\"][\"LWI_VZ_Lenkradw_Geschw\"])]\n    ret.steeringTorque = pt_cp.vl[\"LH_EPS_03\"][\"EPS_Lenkmoment\"] * (1, -1)[int(pt_cp.vl[\"LH_EPS_03\"][\"EPS_VZ_Lenkmoment\"])]\n    ret.steeringPressed = abs(ret.steeringTorque) > self.CCP.STEER_DRIVER_ALLOWANCE\n    ret.yawRate = pt_cp.vl[\"ESP_02\"][\"ESP_Gierrate\"] * (1, -1)[int(pt_cp.vl[\"ESP_02\"][\"ESP_VZ_Gierrate\"])] * CV.DEG_TO_RAD\n    hca_status = self.CCP.hca_status_values.get(pt_cp.vl[\"LH_EPS_03\"][\"EPS_HCA_Status\"])\n    ret.steerFaultTemporary, ret.steerFaultPermanent = self.update_hca_state(hca_status)\n\n    # VW Emergency Assist status tracking and mitigation\n    self.eps_stock_values = pt_cp.vl[\"LH_EPS_03\"]\n    if self.CP.flags & VolkswagenFlags.STOCK_HCA_PRESENT:\n      ret.carFaultedNonCritical = bool(cam_cp.vl[\"HCA_01\"][\"EA_Ruckfreigabe\"]) or cam_cp.vl[\"HCA_01\"][\"EA_ACC_Sollstatus\"] > 0\n\n    # Update gas, brakes, and gearshift.\n    ret.gas = pt_cp.vl[\"Motor_20\"][\"MO_Fahrpedalrohwert_01\"] / 100.0\n    ret.gasPressed = ret.gas > 0\n    ret.brake = pt_cp.vl[\"ESP_05\"][\"ESP_Bremsdruck\"] / 250.0  # FIXME: this is pressure in Bar, not sure what OP expects\n    brake_pedal_pressed = bool(pt_cp.vl[\"Motor_14\"][\"MO_Fahrer_bremst\"])\n    brake_pressure_detected = bool(pt_cp.vl[\"ESP_05\"][\"ESP_Fahrer_bremst\"])\n    ret.brakePressed = brake_pedal_pressed or brake_pressure_detected\n    ret.parkingBrake = bool(pt_cp.vl[\"Kombi_01\"][\"KBI_Handbremse\"])  # FIXME: need to include an EPB check as well\n\n    # Update gear and/or clutch position data.\n    if trans_type == TransmissionType.automatic:\n      ret.gearShifter = self.parse_gear_shifter(self.CCP.shifter_values.get(pt_cp.vl[\"Getriebe_11\"][\"GE_Fahrstufe\"], None))\n    elif trans_type == TransmissionType.direct:\n      ret.gearShifter = self.parse_gear_shifter(self.CCP.shifter_values.get(pt_cp.vl[\"EV_Gearshift\"][\"GearPosition\"], None))\n    elif trans_type == TransmissionType.manual:\n      ret.clutchPressed = not pt_cp.vl[\"Motor_14\"][\"MO_Kuppl_schalter\"]\n      if bool(pt_cp.vl[\"Gateway_72\"][\"BCM1_Rueckfahrlicht_Schalter\"]):\n        ret.gearShifter = GearShifter.reverse\n      else:\n        ret.gearShifter = GearShifter.drive\n\n    # Update door and trunk/hatch lid open status.\n    ret.doorOpen = any([pt_cp.vl[\"Gateway_72\"][\"ZV_FT_offen\"],\n                        pt_cp.vl[\"Gateway_72\"][\"ZV_BT_offen\"],\n                        pt_cp.vl[\"Gateway_72\"][\"ZV_HFS_offen\"],\n                        pt_cp.vl[\"Gateway_72\"][\"ZV_HBFS_offen\"],\n                        pt_cp.vl[\"Gateway_72\"][\"ZV_HD_offen\"]])\n\n    # Update seatbelt fastened status.\n    ret.seatbeltUnlatched = pt_cp.vl[\"Airbag_02\"][\"AB_Gurtschloss_FA\"] != 3\n\n    # Consume blind-spot monitoring info/warning LED states, if available.\n    # Infostufe: BSM LED on, Warnung: BSM LED flashing\n    if self.CP.enableBsm:\n      ret.leftBlindspot = bool(ext_cp.vl[\"SWA_01\"][\"SWA_Infostufe_SWA_li\"]) or bool(ext_cp.vl[\"SWA_01\"][\"SWA_Warnung_SWA_li\"])\n      ret.rightBlindspot = bool(ext_cp.vl[\"SWA_01\"][\"SWA_Infostufe_SWA_re\"]) or bool(ext_cp.vl[\"SWA_01\"][\"SWA_Warnung_SWA_re\"])\n\n    # Consume factory LDW data relevant for factory SWA (Lane Change Assist)\n    # and capture it for forwarding to the blind spot radar controller\n    self.ldw_stock_values = cam_cp.vl[\"LDW_02\"] if self.CP.networkLocation == NetworkLocation.fwdCamera else {}\n\n    # Stock FCW is considered active if the release bit for brake-jerk warning\n    # is set. Stock AEB considered active if the partial braking or target\n    # braking release bits are set.\n    # Refer to VW Self Study Program 890253: Volkswagen Driver Assistance\n    # Systems, chapter on Front Assist with Braking: Golf Family for all MQB\n    ret.stockFcw = bool(ext_cp.vl[\"ACC_10\"][\"AWV2_Freigabe\"])\n    ret.stockAeb = bool(ext_cp.vl[\"ACC_10\"][\"ANB_Teilbremsung_Freigabe\"]) or bool(ext_cp.vl[\"ACC_10\"][\"ANB_Zielbremsung_Freigabe\"])\n\n    # Update ACC radar status.\n    self.acc_type = ext_cp.vl[\"ACC_06\"][\"ACC_Typ\"]\n\n    # ACC okay but disabled (1), ACC ready (2), a radar visibility or other fault/disruption (6 or 7)\n    # currently regulating speed (3), driver accel override (4), brake only (5)\n    ret.cruiseState.available = pt_cp.vl[\"TSK_06\"][\"TSK_Status\"] in (2, 3, 4, 5)\n    ret.cruiseState.enabled = pt_cp.vl[\"TSK_06\"][\"TSK_Status\"] in (3, 4, 5)\n\n    if self.CP.pcmCruise:\n      # Cruise Control mode; check for distance UI setting from the radar.\n      # ECM does not manage this, so do not need to check for openpilot longitudinal\n      ret.cruiseState.nonAdaptive = ext_cp.vl[\"ACC_02\"][\"ACC_Gesetzte_Zeitluecke\"] == 0\n    else:\n      # Speed limiter mode; ECM faults if we command ACC while not pcmCruise\n      ret.cruiseState.nonAdaptive = bool(pt_cp.vl[\"TSK_06\"][\"TSK_Limiter_ausgewaehlt\"])\n\n    ret.accFaulted = pt_cp.vl[\"TSK_06\"][\"TSK_Status\"] in (6, 7)\n\n    self.esp_hold_confirmation = bool(pt_cp.vl[\"ESP_21\"][\"ESP_Haltebestaetigung\"])\n    ret.cruiseState.standstill = self.CP.pcmCruise and self.esp_hold_confirmation\n\n    # Update ACC setpoint. When the setpoint is zero or there's an error, the\n    # radar sends a set-speed of ~90.69 m/s / 203mph.\n    if self.CP.pcmCruise:\n      ret.cruiseState.speed = ext_cp.vl[\"ACC_02\"][\"ACC_Wunschgeschw_02\"] * CV.KPH_TO_MS\n      if ret.cruiseState.speed > 90:\n        ret.cruiseState.speed = 0\n\n    # Update button states for turn signals and ACC controls, capture all ACC button state/config for passthrough\n    ret.leftBlinker = bool(pt_cp.vl[\"Blinkmodi_02\"][\"Comfort_Signal_Left\"])\n    ret.rightBlinker = bool(pt_cp.vl[\"Blinkmodi_02\"][\"Comfort_Signal_Right\"])\n    ret.buttonEvents = self.create_button_events(pt_cp, self.CCP.BUTTONS)\n    self.gra_stock_values = pt_cp.vl[\"GRA_ACC_01\"]\n\n    # Additional safety checks performed in CarInterface.\n    ret.espDisabled = pt_cp.vl[\"ESP_21\"][\"ESP_Tastung_passiv\"] != 0\n\n    # Digital instrument clusters expect the ACC HUD lead car distance to be scaled differently\n    self.upscale_lead_car_signal = bool(pt_cp.vl[\"Kombi_03\"][\"KBI_Variante\"])\n\n    self.frame += 1\n    return ret\n\n  def update_pq(self, pt_cp, cam_cp, ext_cp, trans_type):\n    ret = car.CarState.new_message()\n    # Update vehicle speed and acceleration from ABS wheel speeds.\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      pt_cp.vl[\"Bremse_3\"][\"Radgeschw__VL_4_1\"],\n      pt_cp.vl[\"Bremse_3\"][\"Radgeschw__VR_4_1\"],\n      pt_cp.vl[\"Bremse_3\"][\"Radgeschw__HL_4_1\"],\n      pt_cp.vl[\"Bremse_3\"][\"Radgeschw__HR_4_1\"],\n    )\n\n    # vEgo obtained from Bremse_1 vehicle speed rather than Bremse_3 wheel speeds because Bremse_3 isn't present on NSF\n    ret.vEgoRaw = pt_cp.vl[\"Bremse_1\"][\"Geschwindigkeit_neu__Bremse_1_\"] * CV.KPH_TO_MS\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = ret.vEgoRaw == 0\n\n    # Update EPS position and state info. For signed values, VW sends the sign in a separate signal.\n    ret.steeringAngleDeg = pt_cp.vl[\"Lenkhilfe_3\"][\"LH3_BLW\"] * (1, -1)[int(pt_cp.vl[\"Lenkhilfe_3\"][\"LH3_BLWSign\"])]\n    ret.steeringRateDeg = pt_cp.vl[\"Lenkwinkel_1\"][\"Lenkradwinkel_Geschwindigkeit\"] * (1, -1)[int(pt_cp.vl[\"Lenkwinkel_1\"][\"Lenkradwinkel_Geschwindigkeit_S\"])]\n    ret.steeringTorque = pt_cp.vl[\"Lenkhilfe_3\"][\"LH3_LM\"] * (1, -1)[int(pt_cp.vl[\"Lenkhilfe_3\"][\"LH3_LMSign\"])]\n    ret.steeringPressed = abs(ret.steeringTorque) > self.CCP.STEER_DRIVER_ALLOWANCE\n    ret.yawRate = pt_cp.vl[\"Bremse_5\"][\"Giergeschwindigkeit\"] * (1, -1)[int(pt_cp.vl[\"Bremse_5\"][\"Vorzeichen_der_Giergeschwindigk\"])] * CV.DEG_TO_RAD\n    hca_status = self.CCP.hca_status_values.get(pt_cp.vl[\"Lenkhilfe_2\"][\"LH2_Sta_HCA\"])\n    ret.steerFaultTemporary, ret.steerFaultPermanent = self.update_hca_state(hca_status)\n\n    # Update gas, brakes, and gearshift.\n    ret.gas = pt_cp.vl[\"Motor_3\"][\"Fahrpedal_Rohsignal\"] / 100.0\n    ret.gasPressed = ret.gas > 0\n    ret.brake = pt_cp.vl[\"Bremse_5\"][\"Bremsdruck\"] / 250.0  # FIXME: this is pressure in Bar, not sure what OP expects\n    ret.brakePressed = bool(pt_cp.vl[\"Motor_2\"][\"Bremslichtschalter\"])\n    ret.parkingBrake = bool(pt_cp.vl[\"Kombi_1\"][\"Bremsinfo\"])\n\n    # Update gear and/or clutch position data.\n    if trans_type == TransmissionType.automatic:\n      ret.gearShifter = self.parse_gear_shifter(self.CCP.shifter_values.get(pt_cp.vl[\"Getriebe_1\"][\"Waehlhebelposition__Getriebe_1_\"], None))\n    elif trans_type == TransmissionType.manual:\n      ret.clutchPressed = not pt_cp.vl[\"Motor_1\"][\"Kupplungsschalter\"]\n      reverse_light = bool(pt_cp.vl[\"Gate_Komf_1\"][\"GK1_Rueckfahr\"])\n      if reverse_light:\n        ret.gearShifter = GearShifter.reverse\n      else:\n        ret.gearShifter = GearShifter.drive\n\n    # Update door and trunk/hatch lid open status.\n    ret.doorOpen = any([pt_cp.vl[\"Gate_Komf_1\"][\"GK1_Fa_Tuerkont\"],\n                        pt_cp.vl[\"Gate_Komf_1\"][\"BSK_BT_geoeffnet\"],\n                        pt_cp.vl[\"Gate_Komf_1\"][\"BSK_HL_geoeffnet\"],\n                        pt_cp.vl[\"Gate_Komf_1\"][\"BSK_HR_geoeffnet\"],\n                        pt_cp.vl[\"Gate_Komf_1\"][\"BSK_HD_Hauptraste\"]])\n\n    # Update seatbelt fastened status.\n    ret.seatbeltUnlatched = not bool(pt_cp.vl[\"Airbag_1\"][\"Gurtschalter_Fahrer\"])\n\n    # Consume blind-spot monitoring info/warning LED states, if available.\n    # Infostufe: BSM LED on, Warnung: BSM LED flashing\n    if self.CP.enableBsm:\n      ret.leftBlindspot = bool(ext_cp.vl[\"SWA_1\"][\"SWA_Infostufe_SWA_li\"]) or bool(ext_cp.vl[\"SWA_1\"][\"SWA_Warnung_SWA_li\"])\n      ret.rightBlindspot = bool(ext_cp.vl[\"SWA_1\"][\"SWA_Infostufe_SWA_re\"]) or bool(ext_cp.vl[\"SWA_1\"][\"SWA_Warnung_SWA_re\"])\n\n    # Consume factory LDW data relevant for factory SWA (Lane Change Assist)\n    # and capture it for forwarding to the blind spot radar controller\n    self.ldw_stock_values = cam_cp.vl[\"LDW_Status\"] if self.CP.networkLocation == NetworkLocation.fwdCamera else {}\n\n    # Stock FCW is considered active if the release bit for brake-jerk warning\n    # is set. Stock AEB considered active if the partial braking or target\n    # braking release bits are set.\n    # Refer to VW Self Study Program 890253: Volkswagen Driver Assistance\n    # Systems, chapters on Front Assist with Braking and City Emergency\n    # Braking for the 2016 Passat NMS\n    # TODO: deferred until we can collect data on pre-MY2016 behavior, AWV message may be shorter with fewer signals\n    ret.stockFcw = False\n    ret.stockAeb = False\n\n    # Update ACC radar status.\n    self.acc_type = ext_cp.vl[\"ACC_System\"][\"ACS_Typ_ACC\"]\n    ret.cruiseState.available = bool(pt_cp.vl[\"Motor_5\"][\"GRA_Hauptschalter\"])\n    ret.cruiseState.enabled = pt_cp.vl[\"Motor_2\"][\"GRA_Status\"] in (1, 2)\n    if self.CP.pcmCruise:\n      ret.accFaulted = ext_cp.vl[\"ACC_GRA_Anzeige\"][\"ACA_StaACC\"] in (6, 7)\n    else:\n      ret.accFaulted = pt_cp.vl[\"Motor_2\"][\"GRA_Status\"] == 3\n\n    # Update ACC setpoint. When the setpoint reads as 255, the driver has not\n    # yet established an ACC setpoint, so treat it as zero.\n    ret.cruiseState.speed = ext_cp.vl[\"ACC_GRA_Anzeige\"][\"ACA_V_Wunsch\"] * CV.KPH_TO_MS\n    if ret.cruiseState.speed > 70:  # 255 kph in m/s == no current setpoint\n      ret.cruiseState.speed = 0\n\n    # Update button states for turn signals and ACC controls, capture all ACC button state/config for passthrough\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_stalk(300, pt_cp.vl[\"Gate_Komf_1\"][\"GK1_Blinker_li\"],\n                                                                            pt_cp.vl[\"Gate_Komf_1\"][\"GK1_Blinker_re\"])\n    ret.buttonEvents = self.create_button_events(pt_cp, self.CCP.BUTTONS)\n    self.gra_stock_values = pt_cp.vl[\"GRA_Neu\"]\n\n    # Additional safety checks performed in CarInterface.\n    ret.espDisabled = bool(pt_cp.vl[\"Bremse_1\"][\"ESP_Passiv_getastet\"])\n\n    self.frame += 1\n    return ret\n\n  def update_hca_state(self, hca_status):\n    # Treat INITIALIZING and FAULT as temporary for worst likely EPS recovery time, for cars without factory Lane Assist\n    # DISABLED means the EPS hasn't been configured to support Lane Assist\n    self.eps_init_complete = self.eps_init_complete or (hca_status in (\"DISABLED\", \"READY\", \"ACTIVE\") or self.frame > 600)\n    perm_fault = hca_status == \"DISABLED\" or (self.eps_init_complete and hca_status in (\"INITIALIZING\", \"FAULT\"))\n    temp_fault = hca_status in (\"REJECTED\", \"PREEMPTED\") or not self.eps_init_complete\n    return temp_fault, perm_fault\n\n  @staticmethod\n  def get_can_parser(CP):\n    if CP.flags & VolkswagenFlags.PQ:\n      return CarState.get_can_parser_pq(CP)\n\n    messages = [\n      # sig_address, frequency\n      (\"LWI_01\", 100),      # From J500 Steering Assist with integrated sensors\n      (\"LH_EPS_03\", 100),   # From J500 Steering Assist with integrated sensors\n      (\"ESP_19\", 100),      # From J104 ABS/ESP controller\n      (\"ESP_05\", 50),       # From J104 ABS/ESP controller\n      (\"ESP_21\", 50),       # From J104 ABS/ESP controller\n      (\"Motor_20\", 50),     # From J623 Engine control module\n      (\"TSK_06\", 50),       # From J623 Engine control module\n      (\"ESP_02\", 50),       # From J104 ABS/ESP controller\n      (\"GRA_ACC_01\", 33),   # From J533 CAN gateway (via LIN from steering wheel controls)\n      (\"Gateway_72\", 10),   # From J533 CAN gateway (aggregated data)\n      (\"Motor_14\", 10),     # From J623 Engine control module\n      (\"Airbag_02\", 5),     # From J234 Airbag control module\n      (\"Kombi_01\", 2),      # From J285 Instrument cluster\n      (\"Blinkmodi_02\", 1),  # From J519 BCM (sent at 1Hz when no lights active, 50Hz when active)\n      (\"Kombi_03\", 0),      # From J285 instrument cluster (not present on older cars, 1Hz when present)\n    ]\n\n    if CP.transmissionType == TransmissionType.automatic:\n      messages.append((\"Getriebe_11\", 20))  # From J743 Auto transmission control module\n    elif CP.transmissionType == TransmissionType.direct:\n      messages.append((\"EV_Gearshift\", 10))  # From J??? unknown EV control module\n\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      # Radars are here on CANBUS.pt\n      messages += MqbExtraSignals.fwd_radar_messages\n      if CP.enableBsm:\n        messages += MqbExtraSignals.bsm_radar_messages\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CANBUS.pt)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    if CP.flags & VolkswagenFlags.PQ:\n      return CarState.get_cam_can_parser_pq(CP)\n\n    messages = []\n\n    if CP.flags & VolkswagenFlags.STOCK_HCA_PRESENT:\n      messages += [\n        (\"HCA_01\", 1),  # From R242 Driver assistance camera, 50Hz if steering/1Hz if not\n      ]\n\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      messages += [\n        # sig_address, frequency\n        (\"LDW_02\", 10)      # From R242 Driver assistance camera\n      ]\n    else:\n      # Radars are here on CANBUS.cam\n      messages += MqbExtraSignals.fwd_radar_messages\n      if CP.enableBsm:\n        messages += MqbExtraSignals.bsm_radar_messages\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CANBUS.cam)\n\n  @staticmethod\n  def get_can_parser_pq(CP):\n    messages = [\n      # sig_address, frequency\n      (\"Bremse_1\", 100),    # From J104 ABS/ESP controller\n      (\"Bremse_3\", 100),    # From J104 ABS/ESP controller\n      (\"Lenkhilfe_3\", 100),  # From J500 Steering Assist with integrated sensors\n      (\"Lenkwinkel_1\", 100),  # From J500 Steering Assist with integrated sensors\n      (\"Motor_3\", 100),     # From J623 Engine control module\n      (\"Airbag_1\", 50),     # From J234 Airbag control module\n      (\"Bremse_5\", 50),     # From J104 ABS/ESP controller\n      (\"GRA_Neu\", 50),      # From J??? steering wheel control buttons\n      (\"Kombi_1\", 50),      # From J285 Instrument cluster\n      (\"Motor_2\", 50),      # From J623 Engine control module\n      (\"Motor_5\", 50),      # From J623 Engine control module\n      (\"Lenkhilfe_2\", 20),  # From J500 Steering Assist with integrated sensors\n      (\"Gate_Komf_1\", 10),  # From J533 CAN gateway\n    ]\n\n    if CP.transmissionType == TransmissionType.automatic:\n      messages += [(\"Getriebe_1\", 100)]  # From J743 Auto transmission control module\n    elif CP.transmissionType == TransmissionType.manual:\n      messages += [(\"Motor_1\", 100)]  # From J623 Engine control module\n\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      # Extended CAN devices other than the camera are here on CANBUS.pt\n      messages += PqExtraSignals.fwd_radar_messages\n      if CP.enableBsm:\n        messages += PqExtraSignals.bsm_radar_messages\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CANBUS.pt)\n\n  @staticmethod\n  def get_cam_can_parser_pq(CP):\n\n    messages = []\n\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      messages += [\n        # sig_address, frequency\n        (\"LDW_Status\", 10)      # From R242 Driver assistance camera\n      ]\n\n    if CP.networkLocation == NetworkLocation.gateway:\n      # Radars are here on CANBUS.cam\n      messages += PqExtraSignals.fwd_radar_messages\n      if CP.enableBsm:\n        messages += PqExtraSignals.bsm_radar_messages\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CANBUS.cam)\n\n\nclass MqbExtraSignals:\n  # Additional signal and message lists for optional or bus-portable controllers\n  fwd_radar_messages = [\n    (\"ACC_06\", 50),                              # From J428 ACC radar control module\n    (\"ACC_10\", 50),                              # From J428 ACC radar control module\n    (\"ACC_02\", 17),                              # From J428 ACC radar control module\n  ]\n  bsm_radar_messages = [\n    (\"SWA_01\", 20),                              # From J1086 Lane Change Assist\n  ]\n\nclass PqExtraSignals:\n  # Additional signal and message lists for optional or bus-portable controllers\n  fwd_radar_messages = [\n    (\"ACC_System\", 50),                          # From J428 ACC radar control module\n    (\"ACC_GRA_Anzeige\", 25),                     # From J428 ACC radar control module\n  ]\n  bsm_radar_messages = [\n    (\"SWA_1\", 20),                               # From J1086 Lane Change Assist\n  ]\n", "selfdrive/car/volkswagen/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.volkswagen.values import CAR\n\nEcu = car.CarParams.Ecu\n\n# TODO: Sharan Mk2 EPS and DQ250 auto trans both require KWP2000 support for fingerprinting\n\n\nFW_VERSIONS = {\n  CAR.VOLKSWAGEN_ARTEON_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x873G0906259AH\\xf1\\x890001',\n      b'\\xf1\\x873G0906259F \\xf1\\x890004',\n      b'\\xf1\\x873G0906259G \\xf1\\x890004',\n      b'\\xf1\\x873G0906259G \\xf1\\x890005',\n      b'\\xf1\\x873G0906259M \\xf1\\x890003',\n      b'\\xf1\\x873G0906259N \\xf1\\x890004',\n      b'\\xf1\\x873G0906259P \\xf1\\x890001',\n      b'\\xf1\\x875NA907115H \\xf1\\x890002',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158L \\xf1\\x893611',\n      b'\\xf1\\x870DL300014C \\xf1\\x893704',\n      b'\\xf1\\x870GC300011L \\xf1\\x891401',\n      b'\\xf1\\x870GC300014M \\xf1\\x892802',\n      b'\\xf1\\x870GC300019G \\xf1\\x892804',\n      b'\\xf1\\x870GC300040P \\xf1\\x891401',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655BK\\xf1\\x890703\\xf1\\x82\\x0e1616001613121157161111572900',\n      b'\\xf1\\x873Q0959655BK\\xf1\\x890703\\xf1\\x82\\x0e1616001613121177161113772900',\n      b'\\xf1\\x873Q0959655CK\\xf1\\x890711\\xf1\\x82\\x0e1712141712141105121122052900',\n      b'\\xf1\\x873Q0959655DA\\xf1\\x890720\\xf1\\x82\\x0e1712141712141105121122052900',\n      b'\\xf1\\x873Q0959655DL\\xf1\\x890732\\xf1\\x82\\x0e1812141812171105141123052J00',\n      b'\\xf1\\x875QF959655AP\\xf1\\x890755\\xf1\\x82\\x1311110011111311111100110200--1611125F49',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144K \\xf1\\x895072\\xf1\\x82\\x0571B41815A1',\n      b'\\xf1\\x873Q0909144L \\xf1\\x895081\\xf1\\x82\\x0571B00817A1',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567B0020800',\n      b'\\xf1\\x875WA907145M \\xf1\\x891051\\xf1\\x82\\x002MB4092M7N',\n      b'\\xf1\\x875WA907145M \\xf1\\x891051\\xf1\\x82\\x002NB4202N7N',\n      b'\\xf1\\x875WA907145Q \\xf1\\x891063\\xf1\\x82\\x002KB4092KOM',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n      b'\\xf1\\x875Q0907572J \\xf1\\x890654',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n    ],\n  },\n  CAR.VOLKSWAGEN_ATLAS_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8703H906026AA\\xf1\\x899970',\n      b'\\xf1\\x8703H906026AG\\xf1\\x899973',\n      b'\\xf1\\x8703H906026AJ\\xf1\\x890638',\n      b'\\xf1\\x8703H906026AJ\\xf1\\x891017',\n      b'\\xf1\\x8703H906026AT\\xf1\\x891922',\n      b'\\xf1\\x8703H906026BC\\xf1\\x892664',\n      b'\\xf1\\x8703H906026F \\xf1\\x896696',\n      b'\\xf1\\x8703H906026F \\xf1\\x899970',\n      b'\\xf1\\x8703H906026J \\xf1\\x896026',\n      b'\\xf1\\x8703H906026J \\xf1\\x899970',\n      b'\\xf1\\x8703H906026J \\xf1\\x899971',\n      b'\\xf1\\x8703H906026S \\xf1\\x896693',\n      b'\\xf1\\x8703H906026S \\xf1\\x899970',\n      b'\\xf1\\x873CN906259  \\xf1\\x890005',\n      b'\\xf1\\x873CN906259F \\xf1\\x890002',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158A \\xf1\\x893387',\n      b'\\xf1\\x8709G927158DR\\xf1\\x893536',\n      b'\\xf1\\x8709G927158DR\\xf1\\x893742',\n      b'\\xf1\\x8709G927158EN\\xf1\\x893691',\n      b'\\xf1\\x8709G927158F \\xf1\\x893489',\n      b'\\xf1\\x8709G927158FT\\xf1\\x893835',\n      b'\\xf1\\x8709G927158GL\\xf1\\x893939',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655BC\\xf1\\x890503\\xf1\\x82\\x0e1914151912001103111122031200',\n      b'\\xf1\\x873Q0959655BN\\xf1\\x890713\\xf1\\x82\\x0e2214152212001105141122052900',\n      b'\\xf1\\x873Q0959655DB\\xf1\\x890720\\xf1\\x82\\x0e1114151112001105111122052900',\n      b'\\xf1\\x873Q0959655DB\\xf1\\x890720\\xf1\\x82\\x0e2214152212001105141122052900',\n      b'\\xf1\\x873Q0959655DM\\xf1\\x890732\\xf1\\x82\\x0e1114151112001105111122052J00',\n      b'\\xf1\\x873Q0959655DM\\xf1\\x890732\\xf1\\x82\\x0e1114151112001105161122052J00',\n      b'\\xf1\\x873Q0959655DM\\xf1\\x890732\\xf1\\x82\\x0e1115151112001105171122052J00',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873QF909144B \\xf1\\x891582\\xf1\\x82\\x0571B60924A1',\n      b'\\xf1\\x873QF909144B \\xf1\\x891582\\xf1\\x82\\x0571B6G920A1',\n      b'\\xf1\\x873QF909144B \\xf1\\x891582\\xf1\\x82\\x0571B6M921A1',\n      b'\\xf1\\x873QF909144B \\xf1\\x891582\\xf1\\x82\\x0571B6N920A1',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820528B6080105',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820528B6090105',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n      b'\\xf1\\x875Q0907572H \\xf1\\x890620',\n      b'\\xf1\\x875Q0907572J \\xf1\\x890654',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n      b'\\xf1\\x875Q0907572S \\xf1\\x890780',\n    ],\n  },\n  CAR.VOLKSWAGEN_CADDY_MK3: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906027T \\xf1\\x892363',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x872K5959655E \\xf1\\x890018\\xf1\\x82\\x05000P037605',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x877N0907572C \\xf1\\x890211\\xf1\\x82\\x0155',\n    ],\n  },\n  CAR.VOLKSWAGEN_CRAFTER_MK2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704L906056BP\\xf1\\x894729',\n      b'\\xf1\\x8704L906056EK\\xf1\\x896391',\n      b'\\xf1\\x8705L906023BC\\xf1\\x892688',\n      b'\\xf1\\x8705L906023MH\\xf1\\x892588',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655AL\\xf1\\x890505\\xf1\\x82\\x0e1411001413001203151311031100',\n      b'\\xf1\\x873Q0959655BG\\xf1\\x890703\\xf1\\x82\\x0e16120016130012051G1313052900',\n      b'\\xf1\\x875QF959655AS\\xf1\\x890755\\xf1\\x82\\x1315140015150011111100050200--1311120749',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x872N0909143D\\x00\\xf1\\x897010\\xf1\\x82\\x05183AZ306A2',\n      b'\\xf1\\x872N0909143E \\xf1\\x897021\\xf1\\x82\\x05163AZ306A2',\n      b'\\xf1\\x872N0909143H \\xf1\\x897045\\xf1\\x82\\x05263AZ309A2',\n      b'\\xf1\\x872N0909144K \\xf1\\x897045\\xf1\\x82\\x05233AZ810A2',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572J \\xf1\\x890156',\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n    ],\n  },\n  CAR.VOLKSWAGEN_GOLF_MK7: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906016A \\xf1\\x897697',\n      b'\\xf1\\x8704E906016AD\\xf1\\x895758',\n      b'\\xf1\\x8704E906016CE\\xf1\\x899096',\n      b'\\xf1\\x8704E906016CH\\xf1\\x899226',\n      b'\\xf1\\x8704E906016N \\xf1\\x899105',\n      b'\\xf1\\x8704E906023AG\\xf1\\x891726',\n      b'\\xf1\\x8704E906023BN\\xf1\\x894518',\n      b'\\xf1\\x8704E906024K \\xf1\\x896811',\n      b'\\xf1\\x8704E906024K \\xf1\\x899970',\n      b'\\xf1\\x8704E906027GR\\xf1\\x892394',\n      b'\\xf1\\x8704E906027HD\\xf1\\x892603',\n      b'\\xf1\\x8704E906027HD\\xf1\\x893742',\n      b'\\xf1\\x8704E906027MA\\xf1\\x894958',\n      b'\\xf1\\x8704L906021DT\\xf1\\x895520',\n      b'\\xf1\\x8704L906021DT\\xf1\\x898127',\n      b'\\xf1\\x8704L906021N \\xf1\\x895518',\n      b'\\xf1\\x8704L906021N \\xf1\\x898138',\n      b'\\xf1\\x8704L906026BN\\xf1\\x891197',\n      b'\\xf1\\x8704L906026BP\\xf1\\x897608',\n      b'\\xf1\\x8704L906026NF\\xf1\\x899528',\n      b'\\xf1\\x8704L906056CL\\xf1\\x893823',\n      b'\\xf1\\x8704L906056CR\\xf1\\x895813',\n      b'\\xf1\\x8704L906056HE\\xf1\\x893758',\n      b'\\xf1\\x8704L906056HN\\xf1\\x896590',\n      b'\\xf1\\x8704L906056HT\\xf1\\x896591',\n      b'\\xf1\\x8704L997022N \\xf1\\x899459',\n      b'\\xf1\\x870EA906016A \\xf1\\x898343',\n      b'\\xf1\\x870EA906016E \\xf1\\x894219',\n      b'\\xf1\\x870EA906016F \\xf1\\x894238',\n      b'\\xf1\\x870EA906016F \\xf1\\x895002',\n      b'\\xf1\\x870EA906016Q \\xf1\\x895993',\n      b'\\xf1\\x870EA906016S \\xf1\\x897207',\n      b'\\xf1\\x875G0906259  \\xf1\\x890007',\n      b'\\xf1\\x875G0906259D \\xf1\\x890002',\n      b'\\xf1\\x875G0906259J \\xf1\\x890002',\n      b'\\xf1\\x875G0906259L \\xf1\\x890002',\n      b'\\xf1\\x875G0906259N \\xf1\\x890003',\n      b'\\xf1\\x875G0906259Q \\xf1\\x890002',\n      b'\\xf1\\x875G0906259Q \\xf1\\x892313',\n      b'\\xf1\\x875G0906259T \\xf1\\x890003',\n      b'\\xf1\\x878V0906259H \\xf1\\x890002',\n      b'\\xf1\\x878V0906259J \\xf1\\x890003',\n      b'\\xf1\\x878V0906259J \\xf1\\x890103',\n      b'\\xf1\\x878V0906259K \\xf1\\x890001',\n      b'\\xf1\\x878V0906259K \\xf1\\x890003',\n      b'\\xf1\\x878V0906259P \\xf1\\x890001',\n      b'\\xf1\\x878V0906259Q \\xf1\\x890002',\n      b'\\xf1\\x878V0906259R \\xf1\\x890002',\n      b'\\xf1\\x878V0906264F \\xf1\\x890003',\n      b'\\xf1\\x878V0906264L \\xf1\\x890002',\n      b'\\xf1\\x878V0906264M \\xf1\\x890001',\n      b'\\xf1\\x878V09C0BB01 \\xf1\\x890001',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927749AP\\xf1\\x892943',\n      b'\\xf1\\x8709S927158A \\xf1\\x893585',\n      b'\\xf1\\x870CW300040H \\xf1\\x890606',\n      b'\\xf1\\x870CW300041D \\xf1\\x891004',\n      b'\\xf1\\x870CW300041H \\xf1\\x891010',\n      b'\\xf1\\x870CW300042F \\xf1\\x891604',\n      b'\\xf1\\x870CW300043B \\xf1\\x891601',\n      b'\\xf1\\x870CW300043E \\xf1\\x891603',\n      b'\\xf1\\x870CW300044S \\xf1\\x894530',\n      b'\\xf1\\x870CW300044T \\xf1\\x895245',\n      b'\\xf1\\x870CW300045  \\xf1\\x894531',\n      b'\\xf1\\x870CW300047D \\xf1\\x895261',\n      b'\\xf1\\x870CW300047E \\xf1\\x895261',\n      b'\\xf1\\x870CW300048J \\xf1\\x890611',\n      b'\\xf1\\x870CW300049H \\xf1\\x890905',\n      b'\\xf1\\x870CW300050G \\xf1\\x891905',\n      b'\\xf1\\x870D9300012  \\xf1\\x894904',\n      b'\\xf1\\x870D9300012  \\xf1\\x894913',\n      b'\\xf1\\x870D9300012  \\xf1\\x894937',\n      b'\\xf1\\x870D9300012  \\xf1\\x895045',\n      b'\\xf1\\x870D9300012  \\xf1\\x895046',\n      b'\\xf1\\x870D9300014M \\xf1\\x895004',\n      b'\\xf1\\x870D9300014Q \\xf1\\x895006',\n      b'\\xf1\\x870D9300018  \\xf1\\x895201',\n      b'\\xf1\\x870D9300020J \\xf1\\x894902',\n      b'\\xf1\\x870D9300020Q \\xf1\\x895201',\n      b'\\xf1\\x870D9300020S \\xf1\\x895201',\n      b'\\xf1\\x870D9300040A \\xf1\\x893613',\n      b'\\xf1\\x870D9300040S \\xf1\\x894311',\n      b'\\xf1\\x870D9300041H \\xf1\\x895220',\n      b'\\xf1\\x870D9300041N \\xf1\\x894512',\n      b'\\xf1\\x870D9300041P \\xf1\\x894507',\n      b'\\xf1\\x870DD300045K \\xf1\\x891120',\n      b'\\xf1\\x870DD300046F \\xf1\\x891601',\n      b'\\xf1\\x870GC300012A \\xf1\\x891401',\n      b'\\xf1\\x870GC300012A \\xf1\\x891403',\n      b'\\xf1\\x870GC300012A \\xf1\\x891422',\n      b'\\xf1\\x870GC300012M \\xf1\\x892301',\n      b'\\xf1\\x870GC300014B \\xf1\\x892401',\n      b'\\xf1\\x870GC300014B \\xf1\\x892403',\n      b'\\xf1\\x870GC300014B \\xf1\\x892405',\n      b'\\xf1\\x870GC300020G \\xf1\\x892401',\n      b'\\xf1\\x870GC300020G \\xf1\\x892403',\n      b'\\xf1\\x870GC300020G \\xf1\\x892404',\n      b'\\xf1\\x870GC300020N \\xf1\\x892804',\n      b'\\xf1\\x870GC300043T \\xf1\\x899999',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655AA\\xf1\\x890386\\xf1\\x82\\x111413001113120043114317121C111C9113',\n      b'\\xf1\\x875Q0959655AA\\xf1\\x890386\\xf1\\x82\\x111413001113120053114317121C111C9113',\n      b'\\xf1\\x875Q0959655AA\\xf1\\x890388\\xf1\\x82\\x111413001113120043114317121C111C9113',\n      b'\\xf1\\x875Q0959655AA\\xf1\\x890388\\xf1\\x82\\x111413001113120043114417121411149113',\n      b'\\xf1\\x875Q0959655AA\\xf1\\x890388\\xf1\\x82\\x111413001113120053114317121C111C9113',\n      b'\\xf1\\x875Q0959655AR\\xf1\\x890317\\xf1\\x82\\x13141500111233003142114A2131219333313100',\n      b'\\xf1\\x875Q0959655BH\\xf1\\x890336\\xf1\\x82\\x1314160011123300314211012230229333423100',\n      b'\\xf1\\x875Q0959655BH\\xf1\\x890336\\xf1\\x82\\x1314160011123300314211012230229333463100',\n      b'\\xf1\\x875Q0959655BJ\\xf1\\x890339\\xf1\\x82\\x13141600111233003142115A2232229333463100',\n      b'\\xf1\\x875Q0959655BS\\xf1\\x890403\\xf1\\x82\\x1314160011123300314240012250229333463100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x13141600111233003142404A2251229333463100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x13141600111233003142404A2252229333463100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x13141600111233003142405A2251229333463100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x13141600111233003142405A2252229333463100',\n      b'\\xf1\\x875Q0959655C \\xf1\\x890361\\xf1\\x82\\x111413001112120004110415121610169112',\n      b'\\xf1\\x875Q0959655CA\\xf1\\x890403\\xf1\\x82\\x1314160011123300314240012250229333463100',\n      b'\\xf1\\x875Q0959655D \\xf1\\x890388\\xf1\\x82\\x111413001113120006110417121A101A9113',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890825\\xf1\\x82\\x13271112111312--071104171825102591131211',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13271112111312--071104171825102591131211',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13271212111312--071104171838103891131211',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13272512111312--07110417182C102C91131211',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13341512112212--071104172328102891131211',\n      b'\\xf1\\x875Q0959655M \\xf1\\x890361\\xf1\\x82\\x111413001112120041114115121611169112',\n      b'\\xf1\\x875Q0959655S \\xf1\\x890870\\xf1\\x82\\x1315120011211200061104171717101791132111',\n      b'\\xf1\\x875Q0959655S \\xf1\\x890870\\xf1\\x82\\x1315120011211200621143171717111791132111',\n      b'\\xf1\\x875Q0959655S \\xf1\\x890870\\xf1\\x82\\x1324230011211200061104171724102491132111',\n      b'\\xf1\\x875Q0959655S \\xf1\\x890870\\xf1\\x82\\x1324230011211200621143171724112491132111',\n      b'\\xf1\\x875Q0959655S \\xf1\\x890870\\xf1\\x82\\x1324230011211200631143171724122491132111',\n      b'\\xf1\\x875Q0959655T \\xf1\\x890825\\xf1\\x82\\x13271200111312--071104171837103791132111',\n      b'\\xf1\\x875Q0959655T \\xf1\\x890830\\xf1\\x82\\x13271100111312--071104171826102691131211',\n      b'\\xf1\\x875QD959655  \\xf1\\x890388\\xf1\\x82\\x111413001113120006110417121D101D9112',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144F \\xf1\\x895043\\xf1\\x82\\x0561A01612A0',\n      b'\\xf1\\x873Q0909144H \\xf1\\x895061\\xf1\\x82\\x0566A0J612A1',\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566A00514A1',\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566A01613A1',\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566A0J712A1',\n      b'\\xf1\\x873Q0909144K \\xf1\\x895072\\xf1\\x82\\x0571A0J714A1',\n      b'\\xf1\\x873Q0909144L \\xf1\\x895081\\xf1\\x82\\x0571A0JA15A1',\n      b'\\xf1\\x873Q0909144M \\xf1\\x895082\\xf1\\x82\\x0571A01A18A1',\n      b'\\xf1\\x873Q0909144M \\xf1\\x895082\\xf1\\x82\\x0571A02A16A1',\n      b'\\xf1\\x873Q0909144M \\xf1\\x895082\\xf1\\x82\\x0571A0JA16A1',\n      b'\\xf1\\x873QM909144  \\xf1\\x895072\\xf1\\x82\\x0571A01714A1',\n      b'\\xf1\\x875Q0909143K \\xf1\\x892033\\xf1\\x820519A9040203',\n      b'\\xf1\\x875Q0909144AA\\xf1\\x891081\\xf1\\x82\\x0521A00441A1',\n      b'\\xf1\\x875Q0909144AA\\xf1\\x891081\\xf1\\x82\\x0521A00608A1',\n      b'\\xf1\\x875Q0909144AA\\xf1\\x891081\\xf1\\x82\\x0521A00641A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521A00442A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521A00642A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521A07B05A1',\n      b'\\xf1\\x875Q0909144L \\xf1\\x891021\\xf1\\x82\\x0521A00502A0',\n      b'\\xf1\\x875Q0909144L \\xf1\\x891021\\xf1\\x82\\x0521A00602A0',\n      b'\\xf1\\x875Q0909144L \\xf1\\x891021\\xf1\\x82\\x0522A00402A0',\n      b'\\xf1\\x875Q0909144P \\xf1\\x891043\\xf1\\x82\\x0511A00403A0',\n      b'\\xf1\\x875Q0909144R \\xf1\\x891061\\xf1\\x82\\x0516A00604A1',\n      b'\\xf1\\x875Q0909144S \\xf1\\x891063\\xf1\\x82\\x0516A00404A1',\n      b'\\xf1\\x875Q0909144S \\xf1\\x891063\\xf1\\x82\\x0516A00504A1',\n      b'\\xf1\\x875Q0909144S \\xf1\\x891063\\xf1\\x82\\x0516A00604A1',\n      b'\\xf1\\x875Q0909144S \\xf1\\x891063\\xf1\\x82\\x0516A07A02A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521A00407A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521A00507A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521A07B04A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521A20B03A1',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567A2000400',\n      b'\\xf1\\x875QD909144B \\xf1\\x891072\\xf1\\x82\\x0521A00507A1',\n      b'\\xf1\\x875QM909144A \\xf1\\x891072\\xf1\\x82\\x0521A20B03A1',\n      b'\\xf1\\x875QM909144B \\xf1\\x891081\\xf1\\x82\\x0521A00442A1',\n      b'\\xf1\\x875QM909144B \\xf1\\x891081\\xf1\\x82\\x0521A00642A1',\n      b'\\xf1\\x875QN909144A \\xf1\\x895081\\xf1\\x82\\x0571A01A16A1',\n      b'\\xf1\\x875QN909144A \\xf1\\x895081\\xf1\\x82\\x0571A01A17A1',\n      b'\\xf1\\x875QN909144A \\xf1\\x895081\\xf1\\x82\\x0571A01A18A1',\n      b'\\xf1\\x875QN909144B \\xf1\\x895082\\xf1\\x82\\x0571A01A18A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x875Q0907567G \\xf1\\x890390\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907567J \\xf1\\x890396\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907567L \\xf1\\x890098\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572A \\xf1\\x890141\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572B \\xf1\\x890200\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572C \\xf1\\x890210\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572D \\xf1\\x890304\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572E \\xf1\\x89X310\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572F \\xf1\\x890400\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572G \\xf1\\x890571',\n      b'\\xf1\\x875Q0907572H \\xf1\\x890620',\n      b'\\xf1\\x875Q0907572J \\xf1\\x890653',\n      b'\\xf1\\x875Q0907572J \\xf1\\x890654',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n      b'\\xf1\\x875Q0907572S \\xf1\\x890780',\n    ],\n  },\n  CAR.VOLKSWAGEN_JETTA_MK7: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906024AK\\xf1\\x899937',\n      b'\\xf1\\x8704E906024AS\\xf1\\x899912',\n      b'\\xf1\\x8704E906024B \\xf1\\x895594',\n      b'\\xf1\\x8704E906024BC\\xf1\\x899971',\n      b'\\xf1\\x8704E906024BG\\xf1\\x891057',\n      b'\\xf1\\x8704E906024C \\xf1\\x899970',\n      b'\\xf1\\x8704E906024C \\xf1\\x899971',\n      b'\\xf1\\x8704E906024L \\xf1\\x895595',\n      b'\\xf1\\x8704E906024L \\xf1\\x899970',\n      b'\\xf1\\x8704E906027MS\\xf1\\x896223',\n      b'\\xf1\\x8705E906013DB\\xf1\\x893361',\n      b'\\xf1\\x875G0906259T \\xf1\\x890003',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158BQ\\xf1\\x893545',\n      b'\\xf1\\x8709S927158BS\\xf1\\x893642',\n      b'\\xf1\\x8709S927158BS\\xf1\\x893694',\n      b'\\xf1\\x8709S927158CK\\xf1\\x893770',\n      b'\\xf1\\x8709S927158JC\\xf1\\x894113',\n      b'\\xf1\\x8709S927158R \\xf1\\x893552',\n      b'\\xf1\\x8709S927158R \\xf1\\x893587',\n      b'\\xf1\\x870GC300020N \\xf1\\x892803',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655AG\\xf1\\x890336\\xf1\\x82\\x1314171231313500314611011630169333463100',\n      b'\\xf1\\x875Q0959655AG\\xf1\\x890338\\xf1\\x82\\x1314171231313500314611011630169333463100',\n      b'\\xf1\\x875Q0959655BM\\xf1\\x890403\\xf1\\x82\\x1314171231313500314642011650169333463100',\n      b'\\xf1\\x875Q0959655BM\\xf1\\x890403\\xf1\\x82\\x1314171231313500314643011650169333463100',\n      b'\\xf1\\x875Q0959655BR\\xf1\\x890403\\xf1\\x82\\x1311170031313300314240011150119333433100',\n      b'\\xf1\\x875Q0959655BR\\xf1\\x890403\\xf1\\x82\\x1319170031313300314240011550159333463100',\n      b'\\xf1\\x875Q0959655CB\\xf1\\x890421\\xf1\\x82\\x1314171231313500314642021650169333613100',\n      b'\\xf1\\x875Q0959655CB\\xf1\\x890421\\xf1\\x82\\x1314171231313500314643021650169333613100',\n      b'\\xf1\\x875Q0959655CB\\xf1\\x890421\\xf1\\x82\\x1317171231313500314642023050309333613100',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144M \\xf1\\x895082\\xf1\\x82\\x0571A10A11A1',\n      b'\\xf1\\x875QM907144D \\xf1\\x891063\\xf1\\x82\\x000_A1080_OM',\n      b'\\xf1\\x875QM909144B \\xf1\\x891081\\xf1\\x82\\x0521A10A01A1',\n      b'\\xf1\\x875QM909144B \\xf1\\x891081\\xf1\\x82\\x0521B00404A1',\n      b'\\xf1\\x875QM909144C \\xf1\\x891082\\xf1\\x82\\x0521A00642A1',\n      b'\\xf1\\x875QM909144C \\xf1\\x891082\\xf1\\x82\\x0521A10A01A1',\n      b'\\xf1\\x875QN909144B \\xf1\\x895082\\xf1\\x82\\x0571A10A11A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x875Q0907572N \\xf1\\x890681',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n    ],\n  },\n  CAR.VOLKSWAGEN_PASSAT_MK8: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8703N906026E \\xf1\\x892114',\n      b'\\xf1\\x8704E906023AH\\xf1\\x893379',\n      b'\\xf1\\x8704E906023BM\\xf1\\x894522',\n      b'\\xf1\\x8704L906026DP\\xf1\\x891538',\n      b'\\xf1\\x8704L906026ET\\xf1\\x891990',\n      b'\\xf1\\x8704L906026FP\\xf1\\x892012',\n      b'\\xf1\\x8704L906026GA\\xf1\\x892013',\n      b'\\xf1\\x8704L906026GK\\xf1\\x899971',\n      b'\\xf1\\x8704L906026KD\\xf1\\x894798',\n      b'\\xf1\\x8705L906022A \\xf1\\x890827',\n      b'\\xf1\\x873G0906259  \\xf1\\x890004',\n      b'\\xf1\\x873G0906259B \\xf1\\x890002',\n      b'\\xf1\\x873G0906264  \\xf1\\x890004',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300041E \\xf1\\x891006',\n      b'\\xf1\\x870CW300042H \\xf1\\x891601',\n      b'\\xf1\\x870CW300042H \\xf1\\x891607',\n      b'\\xf1\\x870CW300043H \\xf1\\x891601',\n      b'\\xf1\\x870CW300048R \\xf1\\x890610',\n      b'\\xf1\\x870D9300013A \\xf1\\x894905',\n      b'\\xf1\\x870D9300014L \\xf1\\x895002',\n      b'\\xf1\\x870D9300018C \\xf1\\x895297',\n      b'\\xf1\\x870D9300041A \\xf1\\x894801',\n      b'\\xf1\\x870D9300042H \\xf1\\x894901',\n      b'\\xf1\\x870DD300045T \\xf1\\x891601',\n      b'\\xf1\\x870DD300046H \\xf1\\x891601',\n      b'\\xf1\\x870DL300011H \\xf1\\x895201',\n      b'\\xf1\\x870GC300042H \\xf1\\x891404',\n      b'\\xf1\\x870GC300043  \\xf1\\x892301',\n      b'\\xf1\\x870GC300046P \\xf1\\x892805',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655AE\\xf1\\x890195\\xf1\\x82\\r56140056130012416612124111',\n      b'\\xf1\\x873Q0959655AF\\xf1\\x890195\\xf1\\x82\\r56140056130012026612120211',\n      b'\\xf1\\x873Q0959655AN\\xf1\\x890305\\xf1\\x82\\r58160058140013036914110311',\n      b'\\xf1\\x873Q0959655AN\\xf1\\x890306\\xf1\\x82\\r58160058140013036914110311',\n      b'\\xf1\\x873Q0959655BA\\xf1\\x890195\\xf1\\x82\\r56140056130012416612124111',\n      b'\\xf1\\x873Q0959655BA\\xf1\\x890195\\xf1\\x82\\r56140056130012516612125111',\n      b'\\xf1\\x873Q0959655BB\\xf1\\x890195\\xf1\\x82\\r56140056130012026612120211',\n      b'\\xf1\\x873Q0959655BG\\xf1\\x890712\\xf1\\x82\\x0e5915005914001305701311052900',\n      b'\\xf1\\x873Q0959655BJ\\xf1\\x890703\\xf1\\x82\\x0e5915005914001305701311052900',\n      b'\\xf1\\x873Q0959655BK\\xf1\\x890703\\xf1\\x82\\x0e5915005914001344701311442900',\n      b'\\xf1\\x873Q0959655BK\\xf1\\x890703\\xf1\\x82\\x0e5915005914001354701311542900',\n      b'\\xf1\\x873Q0959655CN\\xf1\\x890720\\xf1\\x82\\x0e5915005914001305701311052900',\n      b'\\xf1\\x875Q0959655S \\xf1\\x890870\\xf1\\x82\\x1315120011111200631145171716121691132111',\n      b'\\xf1\\x875QF959655S \\xf1\\x890639\\xf1\\x82\\x13131100131300111111000120----2211114A48',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566B00611A1',\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566B00711A1',\n      b'\\xf1\\x875Q0909143K \\xf1\\x892033\\xf1\\x820514B0060703',\n      b'\\xf1\\x875Q0909143M \\xf1\\x892041\\xf1\\x820522B0060803',\n      b'\\xf1\\x875Q0909143M \\xf1\\x892041\\xf1\\x820522B0080803',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820526B0060905',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820531B0062105',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521B00606A1',\n      b'\\xf1\\x875Q0909144S \\xf1\\x891063\\xf1\\x82\\x0516B00501A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521B00603A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521B00703A1',\n      b'\\xf1\\x875Q0910143B \\xf1\\x892201\\xf1\\x82\\x0563B0000600',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567B0020600',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x873Q0907572A \\xf1\\x890126',\n      b'\\xf1\\x873Q0907572A \\xf1\\x890130',\n      b'\\xf1\\x873Q0907572B \\xf1\\x890192',\n      b'\\xf1\\x873Q0907572B \\xf1\\x890194',\n      b'\\xf1\\x873Q0907572C \\xf1\\x890195',\n      b'\\xf1\\x873Q0907572C \\xf1\\x890196',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n      b'\\xf1\\x875Q0907572S \\xf1\\x890780',\n    ],\n  },\n  CAR.VOLKSWAGEN_PASSAT_NMS: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8706K906016C \\xf1\\x899609',\n      b'\\xf1\\x8706K906016E \\xf1\\x899830',\n      b'\\xf1\\x8706K906016G \\xf1\\x891124',\n      b'\\xf1\\x8706K906071BJ\\xf1\\x894891',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158AB\\xf1\\x893318',\n      b'\\xf1\\x8709G927158BD\\xf1\\x893121',\n      b'\\xf1\\x8709G927158DK\\xf1\\x893594',\n      b'\\xf1\\x8709G927158FQ\\xf1\\x893745',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x87561959655  \\xf1\\x890210\\xf1\\x82\\x1212121111113000102011--121012--101312',\n      b'\\xf1\\x87561959655C \\xf1\\x890508\\xf1\\x82\\x1215141111121100314919--153015--304831',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x87561907567A \\xf1\\x890132',\n      b'\\xf1\\x877N0907572C \\xf1\\x890211\\xf1\\x82\\x0152',\n    ],\n  },\n  CAR.VOLKSWAGEN_POLO_MK6: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704C906025H \\xf1\\x895177',\n      b'\\xf1\\x8705C906032J \\xf1\\x891702',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300042D \\xf1\\x891612',\n      b'\\xf1\\x870CW300050D \\xf1\\x891908',\n      b'\\xf1\\x870CW300051G \\xf1\\x891909',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x872Q0959655AG\\xf1\\x890248\\xf1\\x82\\x1218130411110411--04040404231811152H14',\n      b'\\xf1\\x872Q0959655AJ\\xf1\\x890250\\xf1\\x82\\x1248130411110416--04040404784811152H14',\n      b'\\xf1\\x872Q0959655AS\\xf1\\x890411\\xf1\\x82\\x1384830511110516041405820599841215391471',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x872Q1909144M \\xf1\\x896041',\n      b'\\xf1\\x872Q2909144AB\\xf1\\x896050',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n    ],\n  },\n  CAR.VOLKSWAGEN_SHARAN_MK2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704L906016HE\\xf1\\x894635',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x877N0959655D \\xf1\\x890016\\xf1\\x82\\x0801100705----10--',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x877N0907572C \\xf1\\x890211\\xf1\\x82\\x0153',\n    ],\n  },\n  CAR.VOLKSWAGEN_TAOS_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906025CK\\xf1\\x892228',\n      b'\\xf1\\x8704E906027NJ\\xf1\\x891445',\n      b'\\xf1\\x8704E906027NP\\xf1\\x891286',\n      b'\\xf1\\x8705E906013BD\\xf1\\x892496',\n      b'\\xf1\\x8705E906013E \\xf1\\x891624',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158EM\\xf1\\x893812',\n      b'\\xf1\\x8709S927158BL\\xf1\\x893791',\n      b'\\xf1\\x8709S927158CR\\xf1\\x893924',\n      b'\\xf1\\x8709S927158DN\\xf1\\x893946',\n      b'\\xf1\\x8709S927158FF\\xf1\\x893876',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655CB\\xf1\\x890421\\xf1\\x82\\x1311111111333500314646021450149333613100',\n      b'\\xf1\\x875Q0959655CB\\xf1\\x890421\\xf1\\x82\\x1312111111333500314646021550159333613100',\n      b'\\xf1\\x875Q0959655CE\\xf1\\x890421\\xf1\\x82\\x1311110011333300314240021350139333613100',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875QM907144D \\xf1\\x891063\\xf1\\x82\\x001O06081OOM',\n      b'\\xf1\\x875QM909144C \\xf1\\x891082\\xf1\\x82\\x0521060405A1',\n      b'\\xf1\\x875QM909144C \\xf1\\x891082\\xf1\\x82\\x0521060605A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.VOLKSWAGEN_TCROSS_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704C906025AK\\xf1\\x897053',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300050E \\xf1\\x891903',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x872Q0959655AJ\\xf1\\x890250\\xf1\\x82\\x1212130411110411--04041104141311152H14',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x872Q1909144M \\xf1\\x896041',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.VOLKSWAGEN_TIGUAN_MK2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8703N906026D \\xf1\\x893680',\n      b'\\xf1\\x8704E906024AP\\xf1\\x891461',\n      b'\\xf1\\x8704E906027NB\\xf1\\x899504',\n      b'\\xf1\\x8704L906026EJ\\xf1\\x893661',\n      b'\\xf1\\x8704L906026EJ\\xf1\\x893916',\n      b'\\xf1\\x8704L906027G \\xf1\\x899893',\n      b'\\xf1\\x8705E906018BS\\xf1\\x890914',\n      b'\\xf1\\x875N0906259  \\xf1\\x890002',\n      b'\\xf1\\x875NA906259H \\xf1\\x890002',\n      b'\\xf1\\x875NA907115E \\xf1\\x890003',\n      b'\\xf1\\x875NA907115E \\xf1\\x890005',\n      b'\\xf1\\x875NA907115J \\xf1\\x890002',\n      b'\\xf1\\x875NA907115K \\xf1\\x890004',\n      b'\\xf1\\x8783A907115  \\xf1\\x890007',\n      b'\\xf1\\x8783A907115B \\xf1\\x890005',\n      b'\\xf1\\x8783A907115F \\xf1\\x890002',\n      b'\\xf1\\x8783A907115G \\xf1\\x890001',\n      b'\\xf1\\x8783A907115K \\xf1\\x890001',\n      b'\\xf1\\x8783A907115K \\xf1\\x890002',\n      b'\\xf1\\x8783A907115Q \\xf1\\x890001',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158DS\\xf1\\x893699',\n      b'\\xf1\\x8709G927158DT\\xf1\\x893698',\n      b'\\xf1\\x8709G927158FM\\xf1\\x893757',\n      b'\\xf1\\x8709G927158GC\\xf1\\x893821',\n      b'\\xf1\\x8709G927158GD\\xf1\\x893820',\n      b'\\xf1\\x8709G927158GM\\xf1\\x893936',\n      b'\\xf1\\x8709G927158GN\\xf1\\x893938',\n      b'\\xf1\\x8709G927158HB\\xf1\\x894069',\n      b'\\xf1\\x8709G927158HC\\xf1\\x894070',\n      b'\\xf1\\x870D9300043  \\xf1\\x895202',\n      b'\\xf1\\x870DD300046K \\xf1\\x892302',\n      b'\\xf1\\x870DL300011N \\xf1\\x892001',\n      b'\\xf1\\x870DL300011N \\xf1\\x892012',\n      b'\\xf1\\x870DL300011N \\xf1\\x892014',\n      b'\\xf1\\x870DL300012M \\xf1\\x892107',\n      b'\\xf1\\x870DL300012P \\xf1\\x892103',\n      b'\\xf1\\x870DL300013A \\xf1\\x893005',\n      b'\\xf1\\x870DL300013G \\xf1\\x892119',\n      b'\\xf1\\x870DL300013G \\xf1\\x892120',\n      b'\\xf1\\x870DL300014C \\xf1\\x893703',\n      b'\\xf1\\x870GC300013P \\xf1\\x892401',\n      b'\\xf1\\x870GC300046Q \\xf1\\x892802',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655AG\\xf1\\x890336\\xf1\\x82\\x1316143231313500314617011730179333423100',\n      b'\\xf1\\x875Q0959655AG\\xf1\\x890338\\xf1\\x82\\x1316143231313500314617011730179333423100',\n      b'\\xf1\\x875Q0959655AR\\xf1\\x890317\\xf1\\x82\\x1331310031333334313132573732379333313100',\n      b'\\xf1\\x875Q0959655BJ\\xf1\\x890336\\xf1\\x82\\x1311140031333300314232583632369333423100',\n      b'\\xf1\\x875Q0959655BJ\\xf1\\x890336\\xf1\\x82\\x1312110031333300314232583732379333423100',\n      b'\\xf1\\x875Q0959655BJ\\xf1\\x890339\\xf1\\x82\\x1331310031333334313132013730379333423100',\n      b'\\xf1\\x875Q0959655BM\\xf1\\x890403\\xf1\\x82\\x1316143231313500314641011750179333423100',\n      b'\\xf1\\x875Q0959655BS\\xf1\\x890403\\xf1\\x82\\x1312110031333300314240013750379333423100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x1312110031333300314240583752379333423100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x1331310031333334313140013750379333423100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x1331310031333334313140573752379333423100',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x1331310031333336313140013950399333423100',\n      b'\\xf1\\x875Q0959655CB\\xf1\\x890421\\xf1\\x82\\x1316143231313500314647021750179333613100',\n      b'\\xf1\\x875Q0959655CD\\xf1\\x890421\\xf1\\x82\\x13123112313333003145406F6154619333613100',\n      b'\\xf1\\x875Q0959655CG\\xf1\\x890421\\xf1\\x82\\x1331310031333300314240024050409333613100',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0909143M \\xf1\\x892041\\xf1\\x820529A6060603',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820527A6050705',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820527A6070705',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521A60604A1',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567A6000600',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567A6017A00',\n      b'\\xf1\\x875QF909144  \\xf1\\x895572\\xf1\\x82\\x0571A60833A1',\n      b'\\xf1\\x875QF909144A \\xf1\\x895581\\xf1\\x82\\x0571A60834A1',\n      b'\\xf1\\x875QF909144B \\xf1\\x895582\\xf1\\x82\\x0571A60634A1',\n      b'\\xf1\\x875QF909144B \\xf1\\x895582\\xf1\\x82\\x0571A62A32A1',\n      b'\\xf1\\x875QM907144D \\xf1\\x891063\\xf1\\x82\\x002RA60A2ROM',\n      b'\\xf1\\x875QM907144D \\xf1\\x891063\\xf1\\x82\\x002SA6092SOM',\n      b'\\xf1\\x875QM909144B \\xf1\\x891081\\xf1\\x82\\x0521A60604A1',\n      b'\\xf1\\x875QM909144B \\xf1\\x891081\\xf1\\x82\\x0521A60804A1',\n      b'\\xf1\\x875QM909144C \\xf1\\x891082\\xf1\\x82\\x0521A60604A1',\n      b'\\xf1\\x875QM909144C \\xf1\\x891082\\xf1\\x82\\x0521A60804A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572AB\\xf1\\x890397',\n      b'\\xf1\\x872Q0907572J \\xf1\\x890156',\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n      b'\\xf1\\x872Q0907572Q \\xf1\\x890342',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.VOLKSWAGEN_TOURAN_MK2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906025BE\\xf1\\x890720',\n      b'\\xf1\\x8704E906027HQ\\xf1\\x893746',\n      b'\\xf1\\x8704L906026HM\\xf1\\x893017',\n      b'\\xf1\\x8705E906018CQ\\xf1\\x890808',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300020A \\xf1\\x891936',\n      b'\\xf1\\x870CW300041E \\xf1\\x891005',\n      b'\\xf1\\x870CW300041Q \\xf1\\x891606',\n      b'\\xf1\\x870CW300051M \\xf1\\x891926',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655AS\\xf1\\x890318\\xf1\\x82\\x1336350021353335314132014730479333313100',\n      b'\\xf1\\x875Q0959655AS\\xf1\\x890318\\xf1\\x82\\x13363500213533353141324C4732479333313100',\n      b'\\xf1\\x875Q0959655CH\\xf1\\x890421\\xf1\\x82\\x1336350021353336314740025250529333613100',\n      b'\\xf1\\x875QD959655AJ\\xf1\\x890421\\xf1\\x82\\x1336350021313300314240023330339333663100',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820531B0062105',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567A8090400',\n      b'\\xf1\\x875QD909144F \\xf1\\x891082\\xf1\\x82\\x0521A00642A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x873Q0907572C \\xf1\\x890195',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n    ],\n  },\n  CAR.VOLKSWAGEN_TRANSPORTER_T61: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704L906056AG\\xf1\\x899970',\n      b'\\xf1\\x8704L906056AL\\xf1\\x899970',\n      b'\\xf1\\x8704L906057AP\\xf1\\x891186',\n      b'\\xf1\\x8704L906057N \\xf1\\x890413',\n      b'\\xf1\\x8705L906023E \\xf1\\x891352',\n      b'\\xf1\\x8705L906023MR\\xf1\\x892582',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870BT300012E \\xf1\\x893105',\n      b'\\xf1\\x870BT300012G \\xf1\\x893102',\n      b'\\xf1\\x870BT300046R \\xf1\\x893102',\n      b'\\xf1\\x870DV300012B \\xf1\\x893701',\n      b'\\xf1\\x870DV300012B \\xf1\\x893702',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x872Q0959655AE\\xf1\\x890506\\xf1\\x82\\x1316170411110411--04041704161611152S1411',\n      b'\\xf1\\x872Q0959655AE\\xf1\\x890506\\xf1\\x82\\x1316170411110411--04041704171711152S1411',\n      b'\\xf1\\x872Q0959655AF\\xf1\\x890506\\xf1\\x82\\x1316171111110411--04041711121211152S1413',\n      b'\\xf1\\x872Q0959655AQ\\xf1\\x890511\\xf1\\x82\\x1316170411110411--0404170426261215391421',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x877LA909144F \\xf1\\x897150\\xf1\\x82\\x0532380518A2',\n      b'\\xf1\\x877LA909144F \\xf1\\x897150\\xf1\\x82\\x05323A5519A2',\n      b'\\xf1\\x877LA909144G \\xf1\\x897160\\xf1\\x82\\x05333A5519A2',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n    ],\n  },\n  CAR.VOLKSWAGEN_TROC_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8705E906018AT\\xf1\\x899640',\n      b'\\xf1\\x8705E906018CK\\xf1\\x890863',\n      b'\\xf1\\x8705E906018P \\xf1\\x896020',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300041S \\xf1\\x891615',\n      b'\\xf1\\x870CW300050J \\xf1\\x891911',\n      b'\\xf1\\x870CW300051M \\xf1\\x891925',\n      b'\\xf1\\x870CW300051M \\xf1\\x891928',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890712\\xf1\\x82\\x0e1111001111001105111111052900',\n      b'\\xf1\\x875Q0959655BT\\xf1\\x890403\\xf1\\x82\\x1311110012333300314240681152119333463100',\n      b'\\xf1\\x875Q0959655CF\\xf1\\x890421\\xf1\\x82\\x1311110012333300314240021150119333613100',\n      b'\\xf1\\x875Q0959655CG\\xf1\\x890421\\xf1\\x82\\x13111100123333003142404M1152119333613100',\n      b'\\xf1\\x875Q0959655CG\\xf1\\x890421\\xf1\\x82\\x13111100123333003142404M1154119333613100',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0909144AA\\xf1\\x891081\\xf1\\x82\\x0521060403A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521060405A1',\n      b'\\xf1\\x875WA907144M \\xf1\\x891051\\xf1\\x82\\x001T06081T7N',\n      b'\\xf1\\x875WA907144Q \\xf1\\x891063\\xf1\\x82\\x001O06081OOM',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.AUDI_A3_MK3: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906023AN\\xf1\\x893695',\n      b'\\xf1\\x8704E906023AR\\xf1\\x893440',\n      b'\\xf1\\x8704E906023BL\\xf1\\x895190',\n      b'\\xf1\\x8704E906027CJ\\xf1\\x897798',\n      b'\\xf1\\x8704L997022N \\xf1\\x899459',\n      b'\\xf1\\x875G0906259A \\xf1\\x890004',\n      b'\\xf1\\x875G0906259D \\xf1\\x890002',\n      b'\\xf1\\x875G0906259L \\xf1\\x890002',\n      b'\\xf1\\x875G0906259Q \\xf1\\x890002',\n      b'\\xf1\\x878V0906259E \\xf1\\x890001',\n      b'\\xf1\\x878V0906259F \\xf1\\x890002',\n      b'\\xf1\\x878V0906259H \\xf1\\x890002',\n      b'\\xf1\\x878V0906259J \\xf1\\x890002',\n      b'\\xf1\\x878V0906259K \\xf1\\x890001',\n      b'\\xf1\\x878V0906264B \\xf1\\x890003',\n      b'\\xf1\\x878V0907115B \\xf1\\x890007',\n      b'\\xf1\\x878V0907404A \\xf1\\x890005',\n      b'\\xf1\\x878V0907404G \\xf1\\x890005',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300044T \\xf1\\x895245',\n      b'\\xf1\\x870CW300048  \\xf1\\x895201',\n      b'\\xf1\\x870D9300012  \\xf1\\x894912',\n      b'\\xf1\\x870D9300012  \\xf1\\x894931',\n      b'\\xf1\\x870D9300012K \\xf1\\x894513',\n      b'\\xf1\\x870D9300012L \\xf1\\x894521',\n      b'\\xf1\\x870D9300013B \\xf1\\x894902',\n      b'\\xf1\\x870D9300013B \\xf1\\x894931',\n      b'\\xf1\\x870D9300041N \\xf1\\x894512',\n      b'\\xf1\\x870D9300043T \\xf1\\x899699',\n      b'\\xf1\\x870DD300046  \\xf1\\x891604',\n      b'\\xf1\\x870DD300046A \\xf1\\x891602',\n      b'\\xf1\\x870DD300046F \\xf1\\x891602',\n      b'\\xf1\\x870DD300046G \\xf1\\x891601',\n      b'\\xf1\\x870DL300012E \\xf1\\x892012',\n      b'\\xf1\\x870DL300012H \\xf1\\x892112',\n      b'\\xf1\\x870GC300011  \\xf1\\x890403',\n      b'\\xf1\\x870GC300013M \\xf1\\x892402',\n      b'\\xf1\\x870GC300042J \\xf1\\x891402',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655AB\\xf1\\x890388\\xf1\\x82\\x111111001111111206110412111321139114',\n      b'\\xf1\\x875Q0959655AM\\xf1\\x890315\\xf1\\x82\\x1311111111111111311411011231129321212100',\n      b'\\xf1\\x875Q0959655AM\\xf1\\x890318\\xf1\\x82\\x1311111111111112311411011531159321212100',\n      b'\\xf1\\x875Q0959655AR\\xf1\\x890315\\xf1\\x82\\x1311110011131115311211012331239321212100',\n      b'\\xf1\\x875Q0959655BJ\\xf1\\x890339\\xf1\\x82\\x1311110011131100311111011731179321342100',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890825\\xf1\\x82\\x13111112111111--171115141112221291163221',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890825\\xf1\\x82\\x13111112111111--241115141112221291163221',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13111112111111--241115141112221291163221',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13121111111111--341117141212231291163221',\n      b'\\xf1\\x875Q0959655J \\xf1\\x890830\\xf1\\x82\\x13121111111211--261117141112231291163221',\n      b'\\xf1\\x875Q0959655N \\xf1\\x890361\\xf1\\x82\\x111212001112110004110411111421149114',\n      b'\\xf1\\x875Q0959655N \\xf1\\x890361\\xf1\\x82\\x111212001112111104110411111521159114',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144F \\xf1\\x895043\\xf1\\x82\\x0561G01A13A0',\n      b'\\xf1\\x873Q0909144H \\xf1\\x895061\\xf1\\x82\\x0566G0HA14A1',\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566G0HA14A1',\n      b'\\xf1\\x873Q0909144K \\xf1\\x895072\\xf1\\x82\\x0571G01A16A1',\n      b'\\xf1\\x873Q0909144K \\xf1\\x895072\\xf1\\x82\\x0571G0HA16A1',\n      b'\\xf1\\x873Q0909144K \\xf1\\x895072\\xf1\\x82\\x0571G0JA13A1',\n      b'\\xf1\\x873Q0909144L \\xf1\\x895081\\xf1\\x82\\x0571G0JA14A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521G0G809A1',\n      b'\\xf1\\x875Q0909144P \\xf1\\x891043\\xf1\\x82\\x0503G00303A0',\n      b'\\xf1\\x875Q0909144P \\xf1\\x891043\\xf1\\x82\\x0503G00803A0',\n      b'\\xf1\\x875Q0909144P \\xf1\\x891043\\xf1\\x82\\x0503G0G803A0',\n      b'\\xf1\\x875Q0909144R \\xf1\\x891061\\xf1\\x82\\x0516G00804A1',\n      b'\\xf1\\x875Q0909144S \\xf1\\x891063\\xf1\\x82\\x0516G00804A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521G00807A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x875Q0907567M \\xf1\\x890398\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907567N \\xf1\\x890400\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572D \\xf1\\x890304\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572F \\xf1\\x890400\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572G \\xf1\\x890571',\n      b'\\xf1\\x875Q0907572H \\xf1\\x890620',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n    ],\n  },\n  CAR.AUDI_Q2_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906027JT\\xf1\\x894145',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300041F \\xf1\\x891006',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655BD\\xf1\\x890336\\xf1\\x82\\x1311111111111100311211011231129321312111',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144K \\xf1\\x895072\\xf1\\x82\\x0571F60511A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n    ],\n  },\n  CAR.AUDI_Q3_MK2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8705E906018N \\xf1\\x899970',\n      b'\\xf1\\x8705L906022M \\xf1\\x890901',\n      b'\\xf1\\x8783A906259  \\xf1\\x890001',\n      b'\\xf1\\x8783A906259  \\xf1\\x890005',\n      b'\\xf1\\x8783A906259C \\xf1\\x890002',\n      b'\\xf1\\x8783A906259D \\xf1\\x890001',\n      b'\\xf1\\x8783A906259F \\xf1\\x890001',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x8709G927158CN\\xf1\\x893608',\n      b'\\xf1\\x8709G927158FL\\xf1\\x893758',\n      b'\\xf1\\x8709G927158GG\\xf1\\x893825',\n      b'\\xf1\\x8709G927158GP\\xf1\\x893937',\n      b'\\xf1\\x870GC300045D \\xf1\\x892802',\n      b'\\xf1\\x870GC300046F \\xf1\\x892701',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655BF\\xf1\\x890403\\xf1\\x82\\x1321211111211200311121232152219321422111',\n      b'\\xf1\\x875Q0959655BQ\\xf1\\x890421\\xf1\\x82\\x132121111121120031112124218A219321532111',\n      b'\\xf1\\x875Q0959655BQ\\xf1\\x890421\\xf1\\x82\\x132121111121120031112124218C219321532111',\n      b'\\xf1\\x875Q0959655CC\\xf1\\x890421\\xf1\\x82\\x131111111111120031111224118A119321532111',\n      b'\\xf1\\x875Q0959655CC\\xf1\\x890421\\xf1\\x82\\x131111111111120031111237116A119321532111',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567G6000300',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567G6000800',\n      b'\\xf1\\x875QF909144B \\xf1\\x895582\\xf1\\x82\\x0571G60533A1',\n      b'\\xf1\\x875QF909144B \\xf1\\x895582\\xf1\\x82\\x0571G60733A1',\n      b'\\xf1\\x875TA907145D \\xf1\\x891051\\xf1\\x82\\x001PG60A1P7N',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.SEAT_ATECA_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906027KA\\xf1\\x893749',\n      b'\\xf1\\x8704L906021EL\\xf1\\x897542',\n      b'\\xf1\\x8704L906026BP\\xf1\\x891198',\n      b'\\xf1\\x8704L906026BP\\xf1\\x897608',\n      b'\\xf1\\x8704L906056CR\\xf1\\x892181',\n      b'\\xf1\\x8704L906056CR\\xf1\\x892797',\n      b'\\xf1\\x8705E906018AS\\xf1\\x899596',\n      b'\\xf1\\x8781A906259B \\xf1\\x890003',\n      b'\\xf1\\x878V0906264H \\xf1\\x890005',\n      b'\\xf1\\x878V0907115E \\xf1\\x890002',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300041D \\xf1\\x891004',\n      b'\\xf1\\x870CW300041G \\xf1\\x891003',\n      b'\\xf1\\x870CW300050J \\xf1\\x891908',\n      b'\\xf1\\x870D9300014S \\xf1\\x895202',\n      b'\\xf1\\x870D9300042M \\xf1\\x895016',\n      b'\\xf1\\x870GC300014P \\xf1\\x892801',\n      b'\\xf1\\x870GC300043A \\xf1\\x892304',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655AC\\xf1\\x890189\\xf1\\x82\\r11110011110011021511110200',\n      b'\\xf1\\x873Q0959655AS\\xf1\\x890200\\xf1\\x82\\r11110011110011021511110200',\n      b'\\xf1\\x873Q0959655AS\\xf1\\x890200\\xf1\\x82\\r12110012120012021612110200',\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890703\\xf1\\x82\\x0e1212001211001305121211052900',\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890703\\xf1\\x82\\x0e1312001313001305171311052900',\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890712\\xf1\\x82\\x0e1312001313001305171311052900',\n      b'\\xf1\\x873Q0959655CM\\xf1\\x890720\\xf1\\x82\\x0e1312001313001305171311052900',\n      b'\\xf1\\x875QF959655AT\\xf1\\x890755\\xf1\\x82\\x1311110011110011111100110200--1113121149',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144L \\xf1\\x895081\\xf1\\x82\\x0571N60511A1',\n      b'\\xf1\\x875Q0909144AA\\xf1\\x891081\\xf1\\x82\\x0521N01842A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521N01342A1',\n      b'\\xf1\\x875Q0909144P \\xf1\\x891043\\xf1\\x82\\x0511N01805A0',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521N01309A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521N05808A1',\n      b'\\xf1\\x875WA907145M \\xf1\\x891051\\xf1\\x82\\x0013N619137N',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n      b'\\xf1\\x875Q0907572B \\xf1\\x890200\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572H \\xf1\\x890620',\n      b'\\xf1\\x875Q0907572K \\xf1\\x890402\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n    ],\n  },\n  CAR.SKODA_FABIA_MK4: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8705E906018CF\\xf1\\x891905',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300051M \\xf1\\x891936',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875QF959655AT\\xf1\\x890755\\xf1\\x82\\x1311110011110011111100110200--1111120749',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x872Q1909144S \\xf1\\x896042',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n    ],\n  },\n  CAR.SKODA_KAMIQ_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704C906025AK\\xf1\\x897053',\n      b'\\xf1\\x8705C906032M \\xf1\\x891333',\n      b'\\xf1\\x8705C906032M \\xf1\\x892365',\n      b'\\xf1\\x8705E906013CK\\xf1\\x892540',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300020  \\xf1\\x891906',\n      b'\\xf1\\x870CW300020  \\xf1\\x891907',\n      b'\\xf1\\x870CW300020T \\xf1\\x892204',\n      b'\\xf1\\x870CW300050  \\xf1\\x891709',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x872Q0959655AJ\\xf1\\x890250\\xf1\\x82\\x1211110411110411--04040404131111112H14',\n      b'\\xf1\\x872Q0959655AM\\xf1\\x890351\\xf1\\x82\\x12111104111104112104040404111111112H14',\n      b'\\xf1\\x872Q0959655AM\\xf1\\x890351\\xf1\\x82\\x122221042111042121040404042E2711152H14',\n      b'\\xf1\\x872Q0959655AS\\xf1\\x890411\\xf1\\x82\\x1311150411110411210404040417151215391413',\n      b'\\xf1\\x872Q0959655BJ\\xf1\\x890412\\xf1\\x82\\x132223042111042121040404042B251215391423',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x872Q1909144AB\\xf1\\x896050',\n      b'\\xf1\\x872Q1909144M \\xf1\\x896041',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.SKODA_KAROQ_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8705E906013CL\\xf1\\x892541',\n      b'\\xf1\\x8705E906013H \\xf1\\x892407',\n      b'\\xf1\\x8705E906018P \\xf1\\x895472',\n      b'\\xf1\\x8705E906018P \\xf1\\x896020',\n      b'\\xf1\\x8705L906022BS\\xf1\\x890913',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300020T \\xf1\\x892202',\n      b'\\xf1\\x870CW300041S \\xf1\\x891615',\n      b'\\xf1\\x870GC300014L \\xf1\\x892802',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890703\\xf1\\x82\\x0e1213001211001101131112012100',\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890712\\xf1\\x82\\x0e1213001211001101131122012100',\n      b'\\xf1\\x873Q0959655DE\\xf1\\x890731\\xf1\\x82\\x0e1213001211001101131121012J00',\n      b'\\xf1\\x875QF959655AT\\xf1\\x890755\\xf1\\x82\\x1312110012120011111100010200--2521210749',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0910143B \\xf1\\x892201\\xf1\\x82\\x0563T6090500',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567T6100500',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567T6100600',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567T6100700',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572AB\\xf1\\x890397',\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.SKODA_KODIAQ_MK1: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906027DD\\xf1\\x893123',\n      b'\\xf1\\x8704E906027LD\\xf1\\x893433',\n      b'\\xf1\\x8704E906027NB\\xf1\\x896517',\n      b'\\xf1\\x8704E906027NB\\xf1\\x899504',\n      b'\\xf1\\x8704L906026DE\\xf1\\x895418',\n      b'\\xf1\\x8704L906026EJ\\xf1\\x893661',\n      b'\\xf1\\x8704L906026HT\\xf1\\x893617',\n      b'\\xf1\\x8705E906018DJ\\xf1\\x890915',\n      b'\\xf1\\x8705E906018DJ\\xf1\\x891903',\n      b'\\xf1\\x8705L906022GM\\xf1\\x893411',\n      b'\\xf1\\x875NA906259E \\xf1\\x890003',\n      b'\\xf1\\x875NA907115D \\xf1\\x890003',\n      b'\\xf1\\x875NA907115E \\xf1\\x890003',\n      b'\\xf1\\x875NA907115E \\xf1\\x890005',\n      b'\\xf1\\x8783A907115E \\xf1\\x890001',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870D9300014S \\xf1\\x895201',\n      b'\\xf1\\x870D9300043  \\xf1\\x895202',\n      b'\\xf1\\x870DL300011N \\xf1\\x892014',\n      b'\\xf1\\x870DL300012G \\xf1\\x892006',\n      b'\\xf1\\x870DL300012M \\xf1\\x892107',\n      b'\\xf1\\x870DL300012N \\xf1\\x892110',\n      b'\\xf1\\x870DL300013G \\xf1\\x892119',\n      b'\\xf1\\x870GC300014N \\xf1\\x892801',\n      b'\\xf1\\x870GC300018S \\xf1\\x892803',\n      b'\\xf1\\x870GC300019H \\xf1\\x892806',\n      b'\\xf1\\x870GC300046Q \\xf1\\x892802',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655AN\\xf1\\x890306\\xf1\\x82\\r11110011110011031111310311',\n      b'\\xf1\\x873Q0959655AP\\xf1\\x890306\\xf1\\x82\\r11110011110011421111314211',\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890703\\xf1\\x82\\x0e1213001211001205212111052100',\n      b'\\xf1\\x873Q0959655BJ\\xf1\\x890703\\xf1\\x82\\x0e1213001211001205212111052100',\n      b'\\xf1\\x873Q0959655BK\\xf1\\x890703\\xf1\\x82\\x0e1213001211001244212111442100',\n      b'\\xf1\\x873Q0959655CN\\xf1\\x890720\\xf1\\x82\\x0e1213001211001205212112052100',\n      b'\\xf1\\x873Q0959655CQ\\xf1\\x890720\\xf1\\x82\\x0e1213111211001205212112052111',\n      b'\\xf1\\x873Q0959655DJ\\xf1\\x890731\\xf1\\x82\\x0e1513001511001205232113052J00',\n      b'\\xf1\\x875QF959655AT\\xf1\\x890755\\xf1\\x82\\x1311110011110011111100010200--1121240749',\n      b'\\xf1\\x875QF959655AT\\xf1\\x890755\\xf1\\x82\\x1311110011110011111100010200--1121246149',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820527T6050405',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820527T6060405',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820527T6070405',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567T600G500',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567T600G600',\n      b'\\xf1\\x875TA907145F \\xf1\\x891063\\xf1\\x82\\x0025T6BA25OM',\n      b'\\xf1\\x875TA907145F \\xf1\\x891063\\xf1\\x82\\x002LT61A2LOM',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x872Q0907572AA\\xf1\\x890396',\n      b'\\xf1\\x872Q0907572AB\\xf1\\x890397',\n      b'\\xf1\\x872Q0907572M \\xf1\\x890233',\n      b'\\xf1\\x872Q0907572Q \\xf1\\x890342',\n      b'\\xf1\\x872Q0907572R \\xf1\\x890372',\n      b'\\xf1\\x872Q0907572T \\xf1\\x890383',\n    ],\n  },\n  CAR.SKODA_OCTAVIA_MK3: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704C906025L \\xf1\\x896198',\n      b'\\xf1\\x8704E906016ER\\xf1\\x895823',\n      b'\\xf1\\x8704E906027HD\\xf1\\x893742',\n      b'\\xf1\\x8704E906027MH\\xf1\\x894786',\n      b'\\xf1\\x8704L906021DT\\xf1\\x898127',\n      b'\\xf1\\x8704L906021ER\\xf1\\x898361',\n      b'\\xf1\\x8704L906026BP\\xf1\\x897608',\n      b'\\xf1\\x8704L906026BS\\xf1\\x891541',\n      b'\\xf1\\x8704L906026BT\\xf1\\x897612',\n      b'\\xf1\\x875G0906259C \\xf1\\x890002',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300041L \\xf1\\x891601',\n      b'\\xf1\\x870CW300041N \\xf1\\x891605',\n      b'\\xf1\\x870CW300043B \\xf1\\x891601',\n      b'\\xf1\\x870CW300043P \\xf1\\x891605',\n      b'\\xf1\\x870D9300012H \\xf1\\x894518',\n      b'\\xf1\\x870D9300014T \\xf1\\x895221',\n      b'\\xf1\\x870D9300041C \\xf1\\x894936',\n      b'\\xf1\\x870D9300041H \\xf1\\x895220',\n      b'\\xf1\\x870D9300041J \\xf1\\x894902',\n      b'\\xf1\\x870D9300041P \\xf1\\x894507',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x873Q0959655AC\\xf1\\x890200\\xf1\\x82\\r11120011100010022212110200',\n      b'\\xf1\\x873Q0959655AK\\xf1\\x890306\\xf1\\x82\\r31210031210021033733310331',\n      b'\\xf1\\x873Q0959655AP\\xf1\\x890305\\xf1\\x82\\r11110011110011213331312131',\n      b'\\xf1\\x873Q0959655AQ\\xf1\\x890200\\xf1\\x82\\r11120011100010312212113100',\n      b'\\xf1\\x873Q0959655AS\\xf1\\x890200\\xf1\\x82\\r11120011100010022212110200',\n      b'\\xf1\\x873Q0959655BH\\xf1\\x890703\\xf1\\x82\\x0e3221003221002105755331052100',\n      b'\\xf1\\x873Q0959655CM\\xf1\\x890720\\xf1\\x82\\x0e3221003221002105755331052100',\n      b'\\xf1\\x873Q0959655CN\\xf1\\x890720\\xf1\\x82\\x0e3221003221002105755331052100',\n      b'\\xf1\\x875QD959655  \\xf1\\x890388\\xf1\\x82\\x111101000011110006110411111111119111',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x873Q0909144J \\xf1\\x895063\\xf1\\x82\\x0566A01513A1',\n      b'\\xf1\\x875Q0909144AA\\xf1\\x891081\\xf1\\x82\\x0521T00403A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521T00403A1',\n      b'\\xf1\\x875Q0909144AB\\xf1\\x891082\\xf1\\x82\\x0521T00603A1',\n      b'\\xf1\\x875Q0909144R \\xf1\\x891061\\xf1\\x82\\x0516A00604A1',\n      b'\\xf1\\x875Q0909144T \\xf1\\x891072\\xf1\\x82\\x0521T00601A1',\n      b'\\xf1\\x875QD909144E \\xf1\\x891081\\xf1\\x82\\x0521T00503A1',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x875Q0907567P \\xf1\\x890100\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572D \\xf1\\x890304\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572F \\xf1\\x890400\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572H \\xf1\\x890620',\n      b'\\xf1\\x875Q0907572J \\xf1\\x890654',\n      b'\\xf1\\x875Q0907572K \\xf1\\x890402\\xf1\\x82\\x0101',\n      b'\\xf1\\x875Q0907572P \\xf1\\x890682',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n    ],\n  },\n  CAR.SKODA_SUPERB_MK3: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xf1\\x8704E906027BS\\xf1\\x892887',\n      b'\\xf1\\x8704E906027BT\\xf1\\x899042',\n      b'\\xf1\\x8704L906026ET\\xf1\\x891343',\n      b'\\xf1\\x8704L906026ET\\xf1\\x891990',\n      b'\\xf1\\x8704L906026FP\\xf1\\x891196',\n      b'\\xf1\\x8704L906026KA\\xf1\\x896014',\n      b'\\xf1\\x8704L906026KB\\xf1\\x894071',\n      b'\\xf1\\x8704L906026KD\\xf1\\x894798',\n      b'\\xf1\\x8704L906026MT\\xf1\\x893076',\n      b'\\xf1\\x8705L906022BK\\xf1\\x899971',\n      b'\\xf1\\x873G0906259  \\xf1\\x890004',\n      b'\\xf1\\x873G0906259B \\xf1\\x890002',\n      b'\\xf1\\x873G0906259L \\xf1\\x890003',\n      b'\\xf1\\x873G0906264A \\xf1\\x890002',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xf1\\x870CW300042H \\xf1\\x891601',\n      b'\\xf1\\x870CW300043B \\xf1\\x891603',\n      b'\\xf1\\x870CW300049Q \\xf1\\x890906',\n      b'\\xf1\\x870D9300011T \\xf1\\x894801',\n      b'\\xf1\\x870D9300012  \\xf1\\x894940',\n      b'\\xf1\\x870D9300013A \\xf1\\x894905',\n      b'\\xf1\\x870D9300014K \\xf1\\x895006',\n      b'\\xf1\\x870D9300041H \\xf1\\x894905',\n      b'\\xf1\\x870D9300042M \\xf1\\x895013',\n      b'\\xf1\\x870D9300043F \\xf1\\x895202',\n      b'\\xf1\\x870GC300013K \\xf1\\x892403',\n      b'\\xf1\\x870GC300014M \\xf1\\x892801',\n      b'\\xf1\\x870GC300019G \\xf1\\x892803',\n      b'\\xf1\\x870GC300043  \\xf1\\x892301',\n      b'\\xf1\\x870GC300046D \\xf1\\x892402',\n    ],\n    (Ecu.srs, 0x715, None): [\n      b'\\xf1\\x875Q0959655AE\\xf1\\x890130\\xf1\\x82\\x12111200111121001121110012211292221111',\n      b'\\xf1\\x875Q0959655AE\\xf1\\x890130\\xf1\\x82\\x12111200111121001121118112231292221111',\n      b'\\xf1\\x875Q0959655AK\\xf1\\x890130\\xf1\\x82\\x12111200111121001121110012211292221111',\n      b'\\xf1\\x875Q0959655AS\\xf1\\x890317\\xf1\\x82\\x1331310031313100313131823133319331313100',\n      b'\\xf1\\x875Q0959655AT\\xf1\\x890317\\xf1\\x82\\x1331310031313100313131013131319331313100',\n      b'\\xf1\\x875Q0959655BH\\xf1\\x890336\\xf1\\x82\\x1331310031313100313131013141319331413100',\n      b'\\xf1\\x875Q0959655BK\\xf1\\x890336\\xf1\\x82\\x1331310031313100313131013141319331413100',\n      b'\\xf1\\x875Q0959655BS\\xf1\\x890403\\xf1\\x82\\x1333310031313100313152015351539331423100',\n      b'\\xf1\\x875Q0959655CA\\xf1\\x890403\\xf1\\x82\\x1331310031313100313151013141319331423100',\n      b'\\xf1\\x875Q0959655CA\\xf1\\x890403\\xf1\\x82\\x1331310031313100313151823143319331423100',\n      b'\\xf1\\x875Q0959655CH\\xf1\\x890421\\xf1\\x82\\x1333310031313100313152025350539331463100',\n      b'\\xf1\\x875Q0959655CH\\xf1\\x890421\\xf1\\x82\\x1333310031313100313152855372539331463100',\n    ],\n    (Ecu.eps, 0x712, None): [\n      b'\\xf1\\x875Q0909143K \\xf1\\x892033\\xf1\\x820514UZ070203',\n      b'\\xf1\\x875Q0909143M \\xf1\\x892041\\xf1\\x820522UZ050303',\n      b'\\xf1\\x875Q0909143M \\xf1\\x892041\\xf1\\x820522UZ070303',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820526UZ060505',\n      b'\\xf1\\x875Q0909143P \\xf1\\x892051\\xf1\\x820526UZ070505',\n      b'\\xf1\\x875Q0910143B \\xf1\\x892201\\xf1\\x82\\x0563UZ060600',\n      b'\\xf1\\x875Q0910143B \\xf1\\x892201\\xf1\\x82\\x0563UZ060700',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567UZ070500',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567UZ070600',\n      b'\\xf1\\x875Q0910143C \\xf1\\x892211\\xf1\\x82\\x0567UZ070700',\n    ],\n    (Ecu.fwdRadar, 0x757, None): [\n      b'\\xf1\\x873Q0907572B \\xf1\\x890192',\n      b'\\xf1\\x873Q0907572B \\xf1\\x890194',\n      b'\\xf1\\x873Q0907572C \\xf1\\x890195',\n      b'\\xf1\\x875Q0907572R \\xf1\\x890771',\n      b'\\xf1\\x875Q0907572S \\xf1\\x890780',\n    ],\n  },\n}\n", "selfdrive/car/volkswagen/mqbcan.py": "def create_steering_control(packer, bus, apply_steer, lkas_enabled):\n  values = {\n    \"HCA_01_Status_HCA\": 5 if lkas_enabled else 3,\n    \"HCA_01_LM_Offset\": abs(apply_steer),\n    \"HCA_01_LM_OffSign\": 1 if apply_steer < 0 else 0,\n    \"HCA_01_Vib_Freq\": 18,\n    \"HCA_01_Sendestatus\": 1 if lkas_enabled else 0,\n    \"EA_ACC_Wunschgeschwindigkeit\": 327.36,\n  }\n  return packer.make_can_msg(\"HCA_01\", bus, values)\n\n\ndef create_eps_update(packer, bus, eps_stock_values, ea_simulated_torque):\n  values = {s: eps_stock_values[s] for s in [\n    \"COUNTER\",                     # Sync counter value to EPS output\n    \"EPS_Lenkungstyp\",             # EPS rack type\n    \"EPS_Berechneter_LW\",          # Absolute raw steering angle\n    \"EPS_VZ_BLW\",                  # Raw steering angle sign\n    \"EPS_HCA_Status\",              # EPS HCA control status\n  ]}\n\n  values.update({\n    # Absolute driver torque input and sign, with EA inactivity mitigation\n    \"EPS_Lenkmoment\": abs(ea_simulated_torque),\n    \"EPS_VZ_Lenkmoment\": 1 if ea_simulated_torque < 0 else 0,\n  })\n\n  return packer.make_can_msg(\"LH_EPS_03\", bus, values)\n\n\ndef create_lka_hud_control(packer, bus, ldw_stock_values, lat_active, steering_pressed, hud_alert, hud_control):\n  values = {}\n  if len(ldw_stock_values):\n    values = {s: ldw_stock_values[s] for s in [\n      \"LDW_SW_Warnung_links\",   # Blind spot in warning mode on left side due to lane departure\n      \"LDW_SW_Warnung_rechts\",  # Blind spot in warning mode on right side due to lane departure\n      \"LDW_Seite_DLCTLC\",       # Direction of most likely lane departure (left or right)\n      \"LDW_DLC\",                # Lane departure, distance to line crossing\n      \"LDW_TLC\",                # Lane departure, time to line crossing\n    ]}\n\n  values.update({\n    \"LDW_Status_LED_gelb\": 1 if lat_active and steering_pressed else 0,\n    \"LDW_Status_LED_gruen\": 1 if lat_active and not steering_pressed else 0,\n    \"LDW_Lernmodus_links\": 3 if hud_control.leftLaneDepart else 1 + hud_control.leftLaneVisible,\n    \"LDW_Lernmodus_rechts\": 3 if hud_control.rightLaneDepart else 1 + hud_control.rightLaneVisible,\n    \"LDW_Texte\": hud_alert,\n  })\n  return packer.make_can_msg(\"LDW_02\", bus, values)\n\n\ndef create_acc_buttons_control(packer, bus, gra_stock_values, cancel=False, resume=False):\n  values = {s: gra_stock_values[s] for s in [\n    \"GRA_Hauptschalter\",           # ACC button, on/off\n    \"GRA_Typ_Hauptschalter\",       # ACC main button type\n    \"GRA_Codierung\",               # ACC button configuration/coding\n    \"GRA_Tip_Stufe_2\",             # unknown related to stalk type\n    \"GRA_ButtonTypeInfo\",          # unknown related to stalk type\n  ]}\n\n  values.update({\n    \"COUNTER\": (gra_stock_values[\"COUNTER\"] + 1) % 16,\n    \"GRA_Abbrechen\": cancel,\n    \"GRA_Tip_Wiederaufnahme\": resume,\n  })\n\n  return packer.make_can_msg(\"GRA_ACC_01\", bus, values)\n\n\ndef acc_control_value(main_switch_on, acc_faulted, long_active):\n  if acc_faulted:\n    acc_control = 6\n  elif long_active:\n    acc_control = 3\n  elif main_switch_on:\n    acc_control = 2\n  else:\n    acc_control = 0\n\n  return acc_control\n\n\ndef acc_hud_status_value(main_switch_on, acc_faulted, long_active):\n  # TODO: happens to resemble the ACC control value for now, but extend this for init/gas override later\n  return acc_control_value(main_switch_on, acc_faulted, long_active)\n\n\ndef create_acc_accel_control(packer, bus, acc_type, acc_enabled, accel, acc_control, stopping, starting, esp_hold):\n  commands = []\n\n  acc_06_values = {\n    \"ACC_Typ\": acc_type,\n    \"ACC_Status_ACC\": acc_control,\n    \"ACC_StartStopp_Info\": acc_enabled,\n    \"ACC_Sollbeschleunigung_02\": accel if acc_enabled else 3.01,\n    \"ACC_zul_Regelabw_unten\": 0.2,  # TODO: dynamic adjustment of comfort-band\n    \"ACC_zul_Regelabw_oben\": 0.2,  # TODO: dynamic adjustment of comfort-band\n    \"ACC_neg_Sollbeschl_Grad_02\": 4.0 if acc_enabled else 0,  # TODO: dynamic adjustment of jerk limits\n    \"ACC_pos_Sollbeschl_Grad_02\": 4.0 if acc_enabled else 0,  # TODO: dynamic adjustment of jerk limits\n    \"ACC_Anfahren\": starting,\n    \"ACC_Anhalten\": stopping,\n  }\n  commands.append(packer.make_can_msg(\"ACC_06\", bus, acc_06_values))\n\n  if starting:\n    acc_hold_type = 4  # hold release / startup\n  elif esp_hold:\n    acc_hold_type = 3  # hold standby\n  elif stopping:\n    acc_hold_type = 1  # hold request\n  else:\n    acc_hold_type = 0\n\n  acc_07_values = {\n    \"ACC_Anhalteweg\": 0.3 if stopping else 20.46,  # Distance to stop (stopping coordinator handles terminal roll-out)\n    \"ACC_Freilauf_Info\": 2 if acc_enabled else 0,\n    \"ACC_Folgebeschl\": 3.02,  # Not using secondary controller accel unless and until we understand its impact\n    \"ACC_Sollbeschleunigung_02\": accel if acc_enabled else 3.01,\n    \"ACC_Anforderung_HMS\": acc_hold_type,\n    \"ACC_Anfahren\": starting,\n    \"ACC_Anhalten\": stopping,\n  }\n  commands.append(packer.make_can_msg(\"ACC_07\", bus, acc_07_values))\n\n  return commands\n\n\ndef create_acc_hud_control(packer, bus, acc_hud_status, set_speed, lead_distance, distance):\n  values = {\n    \"ACC_Status_Anzeige\": acc_hud_status,\n    \"ACC_Wunschgeschw_02\": set_speed if set_speed < 250 else 327.36,\n    \"ACC_Gesetzte_Zeitluecke\": distance + 2,\n    \"ACC_Display_Prio\": 3,\n    \"ACC_Abstandsindex\": lead_distance,\n  }\n\n  return packer.make_can_msg(\"ACC_02\", bus, values)\n", "selfdrive/car/volkswagen/values.py": "from collections import defaultdict, namedtuple\nfrom dataclasses import dataclass, field\nfrom enum import Enum, IntFlag, StrEnum\n\nfrom cereal import car\nfrom panda.python import uds\nfrom opendbc.can.can_define import CANDefine\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import dbc_dict, CarSpecs, DbcDict, PlatformConfig, Platforms\nfrom openpilot.selfdrive.car.docs_definitions import CarFootnote, CarHarness, CarDocs, CarParts, Column, \\\n                                                     Device\nfrom openpilot.selfdrive.car.fw_query_definitions import EcuAddrSubAddr, FwQueryConfig, Request, p16\n\nEcu = car.CarParams.Ecu\nNetworkLocation = car.CarParams.NetworkLocation\nTransmissionType = car.CarParams.TransmissionType\nGearShifter = car.CarState.GearShifter\nButton = namedtuple('Button', ['event_type', 'can_addr', 'can_msg', 'values'])\n\n\nclass CarControllerParams:\n  STEER_STEP = 2                           # HCA_01/HCA_1 message frequency 50Hz\n  ACC_CONTROL_STEP = 2                     # ACC_06/ACC_07/ACC_System frequency 50Hz\n\n  # Documented lateral limits: 3.00 Nm max, rate of change 5.00 Nm/sec.\n  # MQB vs PQ maximums are shared, but rate-of-change limited differently\n  # based on safety requirements driven by lateral accel testing.\n\n  STEER_MAX = 300                          # Max heading control assist torque 3.00 Nm\n  STEER_DRIVER_MULTIPLIER = 3              # weight driver torque heavily\n  STEER_DRIVER_FACTOR = 1                  # from dbc\n\n  STEER_TIME_MAX = 360                     # Max time that EPS allows uninterrupted HCA steering control\n  STEER_TIME_ALERT = STEER_TIME_MAX - 10   # If mitigation fails, time to soft disengage before EPS timer expires\n  STEER_TIME_STUCK_TORQUE = 1.9            # EPS limits same torque to 6 seconds, reset timer 3x within that period\n\n  DEFAULT_MIN_STEER_SPEED = 0.4            # m/s, newer EPS racks fault below this speed, don't show a low speed alert\n\n  ACCEL_MAX = 2.0                          # 2.0 m/s max acceleration\n  ACCEL_MIN = -3.5                         # 3.5 m/s max deceleration\n\n  def __init__(self, CP):\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n\n    if CP.flags & VolkswagenFlags.PQ:\n      self.LDW_STEP = 5                   # LDW_1 message frequency 20Hz\n      self.ACC_HUD_STEP = 4               # ACC_GRA_Anzeige frequency 25Hz\n      self.STEER_DRIVER_ALLOWANCE = 80    # Driver intervention threshold 0.8 Nm\n      self.STEER_DELTA_UP = 6             # Max HCA reached in 1.00s (STEER_MAX / (50Hz * 1.00))\n      self.STEER_DELTA_DOWN = 10          # Min HCA reached in 0.60s (STEER_MAX / (50Hz * 0.60))\n\n      if CP.transmissionType == TransmissionType.automatic:\n        self.shifter_values = can_define.dv[\"Getriebe_1\"][\"Waehlhebelposition__Getriebe_1_\"]\n      self.hca_status_values = can_define.dv[\"Lenkhilfe_2\"][\"LH2_Sta_HCA\"]\n\n      self.BUTTONS = [\n        Button(car.CarState.ButtonEvent.Type.setCruise, \"GRA_Neu\", \"GRA_Neu_Setzen\", [1]),\n        Button(car.CarState.ButtonEvent.Type.resumeCruise, \"GRA_Neu\", \"GRA_Recall\", [1]),\n        Button(car.CarState.ButtonEvent.Type.accelCruise, \"GRA_Neu\", \"GRA_Up_kurz\", [1]),\n        Button(car.CarState.ButtonEvent.Type.decelCruise, \"GRA_Neu\", \"GRA_Down_kurz\", [1]),\n        Button(car.CarState.ButtonEvent.Type.cancel, \"GRA_Neu\", \"GRA_Abbrechen\", [1]),\n        Button(car.CarState.ButtonEvent.Type.gapAdjustCruise, \"GRA_Neu\", \"GRA_Zeitluecke\", [1]),\n      ]\n\n      self.LDW_MESSAGES = {\n        \"none\": 0,  # Nothing to display\n        \"laneAssistUnavail\": 1,  # \"Lane Assist currently not available.\"\n        \"laneAssistUnavailSysError\": 2,  # \"Lane Assist system error\"\n        \"laneAssistUnavailNoSensorView\": 3,  # \"Lane Assist not available. No sensor view.\"\n        \"laneAssistTakeOver\": 4,  # \"Lane Assist: Please Take Over Steering\"\n        \"laneAssistDeactivTrailer\": 5,  # \"Lane Assist: no function with trailer\"\n      }\n\n    else:\n      self.LDW_STEP = 10                  # LDW_02 message frequency 10Hz\n      self.ACC_HUD_STEP = 6               # ACC_02 message frequency 16Hz\n      self.STEER_DRIVER_ALLOWANCE = 80    # Driver intervention threshold 0.8 Nm\n      self.STEER_DELTA_UP = 4             # Max HCA reached in 1.50s (STEER_MAX / (50Hz * 1.50))\n      self.STEER_DELTA_DOWN = 10          # Min HCA reached in 0.60s (STEER_MAX / (50Hz * 0.60))\n\n      if CP.transmissionType == TransmissionType.automatic:\n        self.shifter_values = can_define.dv[\"Getriebe_11\"][\"GE_Fahrstufe\"]\n      elif CP.transmissionType == TransmissionType.direct:\n        self.shifter_values = can_define.dv[\"EV_Gearshift\"][\"GearPosition\"]\n      self.hca_status_values = can_define.dv[\"LH_EPS_03\"][\"EPS_HCA_Status\"]\n\n      self.BUTTONS = [\n        Button(car.CarState.ButtonEvent.Type.setCruise, \"GRA_ACC_01\", \"GRA_Tip_Setzen\", [1]),\n        Button(car.CarState.ButtonEvent.Type.resumeCruise, \"GRA_ACC_01\", \"GRA_Tip_Wiederaufnahme\", [1]),\n        Button(car.CarState.ButtonEvent.Type.accelCruise, \"GRA_ACC_01\", \"GRA_Tip_Hoch\", [1]),\n        Button(car.CarState.ButtonEvent.Type.decelCruise, \"GRA_ACC_01\", \"GRA_Tip_Runter\", [1]),\n        Button(car.CarState.ButtonEvent.Type.cancel, \"GRA_ACC_01\", \"GRA_Abbrechen\", [1]),\n        Button(car.CarState.ButtonEvent.Type.gapAdjustCruise, \"GRA_ACC_01\", \"GRA_Verstellung_Zeitluecke\", [1]),\n      ]\n\n      self.LDW_MESSAGES = {\n        \"none\": 0,                            # Nothing to display\n        \"laneAssistUnavailChime\": 1,          # \"Lane Assist currently not available.\" with chime\n        \"laneAssistUnavailNoSensorChime\": 3,  # \"Lane Assist not available. No sensor view.\" with chime\n        \"laneAssistTakeOverUrgent\": 4,        # \"Lane Assist: Please Take Over Steering\" with urgent beep\n        \"emergencyAssistUrgent\": 6,           # \"Emergency Assist: Please Take Over Steering\" with urgent beep\n        \"laneAssistTakeOverChime\": 7,         # \"Lane Assist: Please Take Over Steering\" with chime\n        \"laneAssistTakeOver\": 8,              # \"Lane Assist: Please Take Over Steering\" silent\n        \"emergencyAssistChangingLanes\": 9,    # \"Emergency Assist: Changing lanes...\" with urgent beep\n        \"laneAssistDeactivated\": 10,          # \"Lane Assist deactivated.\" silent with persistent icon afterward\n      }\n\n\nclass CANBUS:\n  pt = 0\n  cam = 2\n\n\nclass WMI(StrEnum):\n  VOLKSWAGEN_USA_SUV = \"1V2\"\n  VOLKSWAGEN_USA_CAR = \"1VW\"\n  VOLKSWAGEN_MEXICO_SUV = \"3VV\"\n  VOLKSWAGEN_MEXICO_CAR = \"3VW\"\n  VOLKSWAGEN_ARGENTINA = \"8AW\"\n  VOLKSWAGEN_BRASIL = \"9BW\"\n  SAIC_VOLKSWAGEN = \"LSV\"\n  SKODA = \"TMB\"\n  SEAT = \"VSS\"\n  AUDI_EUROPE_MPV = \"WA1\"\n  AUDI_GERMANY_CAR = \"WAU\"\n  MAN = \"WMA\"\n  AUDI_SPORT = \"WUA\"\n  VOLKSWAGEN_COMMERCIAL = \"WV1\"\n  VOLKSWAGEN_COMMERCIAL_BUS_VAN = \"WV2\"\n  VOLKSWAGEN_EUROPE_SUV = \"WVG\"\n  VOLKSWAGEN_EUROPE_CAR = \"WVW\"\n  VOLKSWAGEN_GROUP_RUS = \"XW8\"\n\n\nclass VolkswagenFlags(IntFlag):\n  # Detected flags\n  STOCK_HCA_PRESENT = 1\n\n  # Static flags\n  PQ = 2\n\n\n@dataclass\nclass VolkswagenMQBPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('vw_mqb_2010', None))\n  # Volkswagen uses the VIN WMI and chassis code to match in the absence of the comma power\n  # on camera-integrated cars, as we lose too many ECUs to reliably identify the vehicle\n  chassis_codes: set[str] = field(default_factory=set)\n  wmis: set[WMI] = field(default_factory=set)\n\n\n@dataclass\nclass VolkswagenPQPlatformConfig(VolkswagenMQBPlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('vw_golf_mk4', None))\n\n  def init(self):\n    self.flags |= VolkswagenFlags.PQ\n\n\n@dataclass(frozen=True, kw_only=True)\nclass VolkswagenCarSpecs(CarSpecs):\n  centerToFrontRatio: float = 0.45\n  steerRatio: float = 15.6\n  minSteerSpeed: float = CarControllerParams.DEFAULT_MIN_STEER_SPEED\n\n\nclass Footnote(Enum):\n  KAMIQ = CarFootnote(\n    \"Not including the China market Kamiq, which is based on the (currently) unsupported PQ34 platform.\",\n    Column.MODEL)\n  PASSAT = CarFootnote(\n    \"Refers only to the MQB-based European B8 Passat, not the NMS Passat in the USA/China/Mideast markets.\",\n    Column.MODEL)\n  SKODA_HEATED_WINDSHIELD = CarFootnote(\n    \"Some \u0160koda vehicles are equipped with heated windshields, which are known \" +\n    \"to block GPS signal needed for some comma 3X functionality.\",\n    Column.MODEL)\n  VW_EXP_LONG = CarFootnote(\n    \"Only available for vehicles using a gateway (J533) harness. At this time, vehicles using a camera harness \" +\n    \"are limited to using stock ACC.\",\n    Column.LONGITUDINAL)\n  VW_MQB_A0 = CarFootnote(\n    \"Model-years 2022 and beyond may have a combined CAN gateway and BCM, which is supported by openpilot \" +\n    \"in software, but doesn't yet have a harness available from the comma store.\",\n    Column.HARDWARE)\n\n\n@dataclass\nclass VWCarDocs(CarDocs):\n  package: str = \"Adaptive Cruise Control (ACC) & Lane Assist\"\n  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.vw_j533]))\n\n  def init_make(self, CP: car.CarParams):\n    self.footnotes.append(Footnote.VW_EXP_LONG)\n    if \"SKODA\" in CP.carFingerprint:\n      self.footnotes.append(Footnote.SKODA_HEATED_WINDSHIELD)\n\n    if CP.carFingerprint in (CAR.VOLKSWAGEN_CRAFTER_MK2, CAR.VOLKSWAGEN_TRANSPORTER_T61):\n      self.car_parts = CarParts([Device.threex_angled_mount, CarHarness.vw_j533])\n\n    if abs(CP.minSteerSpeed - CarControllerParams.DEFAULT_MIN_STEER_SPEED) < 1e-3:\n      self.min_steer_speed = 0\n\n\n# Check the 7th and 8th characters of the VIN before adding a new CAR. If the\n# chassis code is already listed below, don't add a new CAR, just add to the\n# FW_VERSIONS for that existing CAR.\n\nclass CAR(Platforms):\n  config: VolkswagenMQBPlatformConfig | VolkswagenPQPlatformConfig\n\n  VOLKSWAGEN_ARTEON_MK1 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Arteon 2018-23\", video_link=\"https://youtu.be/FAomFKPFlDA\"),\n      VWCarDocs(\"Volkswagen Arteon R 2020-23\", video_link=\"https://youtu.be/FAomFKPFlDA\"),\n      VWCarDocs(\"Volkswagen Arteon eHybrid 2020-23\", video_link=\"https://youtu.be/FAomFKPFlDA\"),\n      VWCarDocs(\"Volkswagen Arteon Shooting Brake 2020-23\", video_link=\"https://youtu.be/FAomFKPFlDA\"),\n      VWCarDocs(\"Volkswagen CC 2018-22\", video_link=\"https://youtu.be/FAomFKPFlDA\"),\n    ],\n    VolkswagenCarSpecs(mass=1733, wheelbase=2.84),\n    chassis_codes={\"AN\", \"3H\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_CAR},\n  )\n  VOLKSWAGEN_ATLAS_MK1 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Atlas 2018-23\"),\n      VWCarDocs(\"Volkswagen Atlas Cross Sport 2020-22\"),\n      VWCarDocs(\"Volkswagen Teramont 2018-22\"),\n      VWCarDocs(\"Volkswagen Teramont Cross Sport 2021-22\"),\n      VWCarDocs(\"Volkswagen Teramont X 2021-22\"),\n    ],\n    VolkswagenCarSpecs(mass=2011, wheelbase=2.98),\n    chassis_codes={\"CA\"},\n    wmis={WMI.VOLKSWAGEN_USA_SUV, WMI.VOLKSWAGEN_EUROPE_SUV},\n  )\n  VOLKSWAGEN_CADDY_MK3 = VolkswagenPQPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Caddy 2019\"),\n      VWCarDocs(\"Volkswagen Caddy Maxi 2019\"),\n    ],\n    VolkswagenCarSpecs(mass=1613, wheelbase=2.6, minSteerSpeed=21 * CV.KPH_TO_MS),\n    chassis_codes={\"2K\"},\n    wmis={WMI.VOLKSWAGEN_COMMERCIAL_BUS_VAN},\n  )\n  VOLKSWAGEN_CRAFTER_MK2 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Crafter 2017-24\", video_link=\"https://youtu.be/4100gLeabmo\"),\n      VWCarDocs(\"Volkswagen e-Crafter 2018-24\", video_link=\"https://youtu.be/4100gLeabmo\"),\n      VWCarDocs(\"Volkswagen Grand California 2019-24\", video_link=\"https://youtu.be/4100gLeabmo\"),\n      VWCarDocs(\"MAN TGE 2017-24\", video_link=\"https://youtu.be/4100gLeabmo\"),\n      VWCarDocs(\"MAN eTGE 2020-24\", video_link=\"https://youtu.be/4100gLeabmo\"),\n    ],\n    VolkswagenCarSpecs(mass=2100, wheelbase=3.64, minSteerSpeed=50 * CV.KPH_TO_MS),\n    chassis_codes={\"SY\", \"SZ\", \"UY\", \"UZ\"},\n    wmis={WMI.VOLKSWAGEN_COMMERCIAL, WMI.MAN},\n  )\n  VOLKSWAGEN_GOLF_MK7 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen e-Golf 2014-20\"),\n      VWCarDocs(\"Volkswagen Golf 2015-20\", auto_resume=False),\n      VWCarDocs(\"Volkswagen Golf Alltrack 2015-19\", auto_resume=False),\n      VWCarDocs(\"Volkswagen Golf GTD 2015-20\"),\n      VWCarDocs(\"Volkswagen Golf GTE 2015-20\"),\n      VWCarDocs(\"Volkswagen Golf GTI 2015-21\", auto_resume=False),\n      VWCarDocs(\"Volkswagen Golf R 2015-19\"),\n      VWCarDocs(\"Volkswagen Golf SportsVan 2015-20\"),\n    ],\n    VolkswagenCarSpecs(mass=1397, wheelbase=2.62),\n    chassis_codes={\"5G\", \"AU\", \"BA\", \"BE\"},\n    wmis={WMI.VOLKSWAGEN_MEXICO_CAR, WMI.VOLKSWAGEN_EUROPE_CAR},\n  )\n  VOLKSWAGEN_JETTA_MK7 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Jetta 2018-24\"),\n      VWCarDocs(\"Volkswagen Jetta GLI 2021-24\"),\n    ],\n    VolkswagenCarSpecs(mass=1328, wheelbase=2.71),\n    chassis_codes={\"BU\"},\n    wmis={WMI.VOLKSWAGEN_MEXICO_CAR, WMI.VOLKSWAGEN_EUROPE_CAR},\n  )\n  VOLKSWAGEN_PASSAT_MK8 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Passat 2015-22\", footnotes=[Footnote.PASSAT]),\n      VWCarDocs(\"Volkswagen Passat Alltrack 2015-22\"),\n      VWCarDocs(\"Volkswagen Passat GTE 2015-22\"),\n    ],\n    VolkswagenCarSpecs(mass=1551, wheelbase=2.79),\n    chassis_codes={\"3C\", \"3G\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_CAR},\n  )\n  VOLKSWAGEN_PASSAT_NMS = VolkswagenPQPlatformConfig(\n    [VWCarDocs(\"Volkswagen Passat NMS 2017-22\")],\n    VolkswagenCarSpecs(mass=1503, wheelbase=2.80, minSteerSpeed=50 * CV.KPH_TO_MS, minEnableSpeed=20 * CV.KPH_TO_MS),\n    chassis_codes={\"A3\"},\n    wmis={WMI.VOLKSWAGEN_USA_CAR},\n  )\n  VOLKSWAGEN_POLO_MK6 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Polo 2018-23\", footnotes=[Footnote.VW_MQB_A0]),\n      VWCarDocs(\"Volkswagen Polo GTI 2018-23\", footnotes=[Footnote.VW_MQB_A0]),\n    ],\n    VolkswagenCarSpecs(mass=1230, wheelbase=2.55),\n    chassis_codes={\"AW\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_CAR},\n  )\n  VOLKSWAGEN_SHARAN_MK2 = VolkswagenPQPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Sharan 2018-22\"),\n      VWCarDocs(\"SEAT Alhambra 2018-20\"),\n    ],\n    VolkswagenCarSpecs(mass=1639, wheelbase=2.92, minSteerSpeed=50 * CV.KPH_TO_MS),\n    chassis_codes={\"7N\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_CAR},\n  )\n  VOLKSWAGEN_TAOS_MK1 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"Volkswagen Taos 2022-23\")],\n    VolkswagenCarSpecs(mass=1498, wheelbase=2.69),\n    chassis_codes={\"B2\"},\n    wmis={WMI.VOLKSWAGEN_MEXICO_SUV, WMI.VOLKSWAGEN_ARGENTINA},\n  )\n  VOLKSWAGEN_TCROSS_MK1 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"Volkswagen T-Cross 2021\", footnotes=[Footnote.VW_MQB_A0])],\n    VolkswagenCarSpecs(mass=1150, wheelbase=2.60),\n    chassis_codes={\"C1\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_SUV},\n  )\n  VOLKSWAGEN_TIGUAN_MK2 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Tiguan 2018-24\"),\n      VWCarDocs(\"Volkswagen Tiguan eHybrid 2021-23\"),\n    ],\n    VolkswagenCarSpecs(mass=1715, wheelbase=2.74),\n    chassis_codes={\"5N\", \"AD\", \"AX\", \"BW\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_SUV, WMI.VOLKSWAGEN_MEXICO_SUV},\n  )\n  VOLKSWAGEN_TOURAN_MK2 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"Volkswagen Touran 2016-23\")],\n    VolkswagenCarSpecs(mass=1516, wheelbase=2.79),\n    chassis_codes={\"1T\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_SUV},\n  )\n  VOLKSWAGEN_TRANSPORTER_T61 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Volkswagen Caravelle 2020\"),\n      VWCarDocs(\"Volkswagen California 2021-23\"),\n    ],\n    VolkswagenCarSpecs(mass=1926, wheelbase=3.00, minSteerSpeed=14.0),\n    chassis_codes={\"7H\", \"7L\"},\n    wmis={WMI.VOLKSWAGEN_COMMERCIAL_BUS_VAN},\n  )\n  VOLKSWAGEN_TROC_MK1 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"Volkswagen T-Roc 2018-23\")],\n    VolkswagenCarSpecs(mass=1413, wheelbase=2.63),\n    chassis_codes={\"A1\"},\n    wmis={WMI.VOLKSWAGEN_EUROPE_SUV},\n  )\n  AUDI_A3_MK3 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"Audi A3 2014-19\"),\n      VWCarDocs(\"Audi A3 Sportback e-tron 2017-18\"),\n      VWCarDocs(\"Audi RS3 2018\"),\n      VWCarDocs(\"Audi S3 2015-17\"),\n    ],\n    VolkswagenCarSpecs(mass=1335, wheelbase=2.61),\n    chassis_codes={\"8V\", \"FF\"},\n    wmis={WMI.AUDI_GERMANY_CAR, WMI.AUDI_SPORT},\n  )\n  AUDI_Q2_MK1 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"Audi Q2 2018\")],\n    VolkswagenCarSpecs(mass=1205, wheelbase=2.61),\n    chassis_codes={\"GA\"},\n    wmis={WMI.AUDI_GERMANY_CAR},\n  )\n  AUDI_Q3_MK2 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"Audi Q3 2019-23\")],\n    VolkswagenCarSpecs(mass=1623, wheelbase=2.68),\n    chassis_codes={\"8U\", \"F3\", \"FS\"},\n    wmis={WMI.AUDI_EUROPE_MPV, WMI.AUDI_GERMANY_CAR},\n  )\n  SEAT_ATECA_MK1 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"CUPRA Ateca 2018-23\"),\n      VWCarDocs(\"SEAT Ateca 2016-23\"),\n      VWCarDocs(\"SEAT Leon 2014-20\"),\n    ],\n    VolkswagenCarSpecs(mass=1300, wheelbase=2.64),\n    chassis_codes={\"5F\"},\n    wmis={WMI.SEAT},\n  )\n  SKODA_FABIA_MK4 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"\u0160koda Fabia 2022-23\", footnotes=[Footnote.VW_MQB_A0])],\n    VolkswagenCarSpecs(mass=1266, wheelbase=2.56),\n    chassis_codes={\"PJ\"},\n    wmis={WMI.SKODA},\n  )\n  SKODA_KAMIQ_MK1 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"\u0160koda Kamiq 2021-23\", footnotes=[Footnote.VW_MQB_A0, Footnote.KAMIQ]),\n      VWCarDocs(\"\u0160koda Scala 2020-23\", footnotes=[Footnote.VW_MQB_A0]),\n    ],\n    VolkswagenCarSpecs(mass=1230, wheelbase=2.66),\n    chassis_codes={\"NW\"},\n    wmis={WMI.SKODA},\n  )\n  SKODA_KAROQ_MK1 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"\u0160koda Karoq 2019-23\")],\n    VolkswagenCarSpecs(mass=1278, wheelbase=2.66),\n    chassis_codes={\"NU\"},\n    wmis={WMI.SKODA},\n  )\n  SKODA_KODIAQ_MK1 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"\u0160koda Kodiaq 2017-23\")],\n    VolkswagenCarSpecs(mass=1569, wheelbase=2.79),\n    chassis_codes={\"NS\"},\n    wmis={WMI.SKODA, WMI.VOLKSWAGEN_GROUP_RUS},\n  )\n  SKODA_OCTAVIA_MK3 = VolkswagenMQBPlatformConfig(\n    [\n      VWCarDocs(\"\u0160koda Octavia 2015-19\"),\n      VWCarDocs(\"\u0160koda Octavia RS 2016\"),\n      VWCarDocs(\"\u0160koda Octavia Scout 2017-19\"),\n    ],\n    VolkswagenCarSpecs(mass=1388, wheelbase=2.68),\n    chassis_codes={\"NE\"},\n    wmis={WMI.SKODA},\n  )\n  SKODA_SUPERB_MK3 = VolkswagenMQBPlatformConfig(\n    [VWCarDocs(\"\u0160koda Superb 2015-22\")],\n    VolkswagenCarSpecs(mass=1505, wheelbase=2.84),\n    chassis_codes={\"3V\", \"NP\"},\n    wmis={WMI.SKODA},\n  )\n\n\ndef match_fw_to_car_fuzzy(live_fw_versions, vin, offline_fw_versions) -> set[str]:\n  candidates = set()\n\n  # Compile all FW versions for each ECU\n  all_ecu_versions: dict[EcuAddrSubAddr, set[str]] = defaultdict(set)\n  for ecus in offline_fw_versions.values():\n    for ecu, versions in ecus.items():\n      all_ecu_versions[ecu] |= set(versions)\n\n  # Check the WMI and chassis code to determine the platform\n  wmi = vin[:3]\n  chassis_code = vin[6:8]\n\n  for platform in CAR:\n    valid_ecus = set()\n    for ecu in offline_fw_versions[platform]:\n      addr = ecu[1:]\n      if ecu[0] not in CHECK_FUZZY_ECUS:\n        continue\n\n      # Sanity check that live FW is in the superset of all FW, Volkswagen ECU part numbers are commonly shared\n      found_versions = live_fw_versions.get(addr, [])\n      expected_versions = all_ecu_versions[ecu]\n      if not any(found_version in expected_versions for found_version in found_versions):\n        break\n\n      valid_ecus.add(ecu[0])\n\n    if valid_ecus != CHECK_FUZZY_ECUS:\n      continue\n\n    if wmi in platform.config.wmis and chassis_code in platform.config.chassis_codes:\n      candidates.add(platform)\n\n  return {str(c) for c in candidates}\n\n\n# These ECUs are required to match to gain a VIN match\n# TODO: do we want to check camera when we add its FW?\nCHECK_FUZZY_ECUS = {Ecu.fwdRadar}\n\n# All supported cars should return FW from the engine, srs, eps, and fwdRadar. Cars\n# with a manual trans won't return transmission firmware, but all other cars will.\n#\n# The 0xF187 SW part number query should return in the form of N[NX][NX] NNN NNN [X[X]],\n# where N=number, X=letter, and the trailing two letters are optional. Performance\n# tuners sometimes tamper with that field (e.g. 8V0 9C0 BB0 1 from COBB/EQT). Tampered\n# ECU SW part numbers are invalid for vehicle ID and compatibility checks. Try to have\n# them repaired by the tuner before including them in openpilot.\n\nVOLKSWAGEN_VERSION_REQUEST_MULTI = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_SPARE_PART_NUMBER) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.VEHICLE_MANUFACTURER_ECU_SOFTWARE_VERSION_NUMBER) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.APPLICATION_DATA_IDENTIFICATION)\nVOLKSWAGEN_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40])\n\nVOLKSWAGEN_RX_OFFSET = 0x6a\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[request for bus, obd_multiplexing in [(1, True), (1, False), (0, False)] for request in [\n    Request(\n      [VOLKSWAGEN_VERSION_REQUEST_MULTI],\n      [VOLKSWAGEN_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.srs, Ecu.eps, Ecu.fwdRadar, Ecu.fwdCamera],\n      rx_offset=VOLKSWAGEN_RX_OFFSET,\n      bus=bus,\n      obd_multiplexing=obd_multiplexing,\n    ),\n    Request(\n      [VOLKSWAGEN_VERSION_REQUEST_MULTI],\n      [VOLKSWAGEN_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.engine, Ecu.transmission],\n      bus=bus,\n      obd_multiplexing=obd_multiplexing,\n    ),\n  ]],\n  non_essential_ecus={Ecu.eps: list(CAR)},\n  extra_ecus=[(Ecu.fwdCamera, 0x74f, None)],\n  match_fw_to_car_fuzzy=match_fw_to_car_fuzzy,\n)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/volkswagen/pqcan.py": "def create_steering_control(packer, bus, apply_steer, lkas_enabled):\n  values = {\n    \"LM_Offset\": abs(apply_steer),\n    \"LM_OffSign\": 1 if apply_steer < 0 else 0,\n    \"HCA_Status\": 5 if (lkas_enabled and apply_steer != 0) else 3,\n    \"Vib_Freq\": 16,\n  }\n\n  return packer.make_can_msg(\"HCA_1\", bus, values)\n\n\ndef create_lka_hud_control(packer, bus, ldw_stock_values, lat_active, steering_pressed, hud_alert, hud_control):\n  values = {}\n  if len(ldw_stock_values):\n    values = {s: ldw_stock_values[s] for s in [\n      \"LDW_SW_Warnung_links\",   # Blind spot in warning mode on left side due to lane departure\n      \"LDW_SW_Warnung_rechts\",  # Blind spot in warning mode on right side due to lane departure\n      \"LDW_Seite_DLCTLC\",       # Direction of most likely lane departure (left or right)\n      \"LDW_DLC\",                # Lane departure, distance to line crossing\n      \"LDW_TLC\",                # Lane departure, time to line crossing\n    ]}\n\n  values.update({\n    \"LDW_Lampe_gelb\": 1 if lat_active and steering_pressed else 0,\n    \"LDW_Lampe_gruen\": 1 if lat_active and not steering_pressed else 0,\n    \"LDW_Lernmodus_links\": 3 if hud_control.leftLaneDepart else 1 + hud_control.leftLaneVisible,\n    \"LDW_Lernmodus_rechts\": 3 if hud_control.rightLaneDepart else 1 + hud_control.rightLaneVisible,\n    \"LDW_Textbits\": hud_alert,\n  })\n\n  return packer.make_can_msg(\"LDW_Status\", bus, values)\n\n\ndef create_acc_buttons_control(packer, bus, gra_stock_values, cancel=False, resume=False):\n  values = {s: gra_stock_values[s] for s in [\n    \"GRA_Hauptschalt\",      # ACC button, on/off\n    \"GRA_Typ_Hauptschalt\",  # ACC button, momentary vs latching\n    \"GRA_Kodierinfo\",       # ACC button, configuration\n    \"GRA_Sender\",           # ACC button, CAN message originator\n  ]}\n\n  values.update({\n    \"COUNTER\": (gra_stock_values[\"COUNTER\"] + 1) % 16,\n    \"GRA_Abbrechen\": cancel,\n    \"GRA_Recall\": resume,\n  })\n\n  return packer.make_can_msg(\"GRA_Neu\", bus, values)\n\n\ndef acc_control_value(main_switch_on, acc_faulted, long_active):\n  if long_active:\n    acc_control = 1\n  elif main_switch_on:\n    acc_control = 2\n  else:\n    acc_control = 0\n\n  return acc_control\n\n\ndef acc_hud_status_value(main_switch_on, acc_faulted, long_active):\n  if acc_faulted:\n    hud_status = 6\n  elif long_active:\n    hud_status = 3\n  elif main_switch_on:\n    hud_status = 2\n  else:\n    hud_status = 0\n\n  return hud_status\n\n\ndef create_acc_accel_control(packer, bus, acc_type, acc_enabled, accel, acc_control, stopping, starting, esp_hold):\n  commands = []\n\n  values = {\n    \"ACS_Sta_ADR\": acc_control,\n    \"ACS_StSt_Info\": acc_enabled,\n    \"ACS_Typ_ACC\": acc_type,\n    \"ACS_Anhaltewunsch\": acc_type == 1 and stopping,\n    \"ACS_FreigSollB\": acc_enabled,\n    \"ACS_Sollbeschl\": accel if acc_enabled else 3.01,\n    \"ACS_zul_Regelabw\": 0.2 if acc_enabled else 1.27,\n    \"ACS_max_AendGrad\": 3.0 if acc_enabled else 5.08,\n  }\n\n  commands.append(packer.make_can_msg(\"ACC_System\", bus, values))\n\n  return commands\n\n\ndef create_acc_hud_control(packer, bus, acc_hud_status, set_speed, lead_distance, distance):\n  values = {\n    \"ACA_StaACC\": acc_hud_status,\n    \"ACA_Zeitluecke\": distance + 2,\n    \"ACA_V_Wunsch\": set_speed,\n    \"ACA_gemZeitl\": lead_distance,\n    \"ACA_PrioDisp\": 3,\n    # TODO: restore dynamic pop-to-foreground/highlight behavior with ACA_PrioDisp and ACA_AnzDisplay\n    # TODO: ACA_kmh_mph handling probably needed to resolve rounding errors in displayed setpoint\n  }\n\n  return packer.make_can_msg(\"ACC_GRA_Anzeige\", bus, values)\n", "selfdrive/car/volkswagen/carcontroller.py": "from cereal import car\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.car import apply_driver_steer_torque_limits\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.car.volkswagen import mqbcan, pqcan\nfrom openpilot.selfdrive.car.volkswagen.values import CANBUS, CarControllerParams, VolkswagenFlags\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\nLongCtrlState = car.CarControl.Actuators.LongControlState\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.CCP = CarControllerParams(CP)\n    self.CCS = pqcan if CP.flags & VolkswagenFlags.PQ else mqbcan\n    self.packer_pt = CANPacker(dbc_name)\n    self.ext_bus = CANBUS.pt if CP.networkLocation == car.CarParams.NetworkLocation.fwdCamera else CANBUS.cam\n\n    self.apply_steer_last = 0\n    self.gra_acc_counter_last = None\n    self.frame = 0\n    self.eps_timer_soft_disable_alert = False\n    self.hca_frame_timer_running = 0\n    self.hca_frame_same_torque = 0\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n    can_sends = []\n\n    # **** Steering Controls ************************************************ #\n\n    if self.frame % self.CCP.STEER_STEP == 0:\n      # Logic to avoid HCA state 4 \"refused\":\n      #   * Don't steer unless HCA is in state 3 \"ready\" or 5 \"active\"\n      #   * Don't steer at standstill\n      #   * Don't send > 3.00 Newton-meters torque\n      #   * Don't send the same torque for > 6 seconds\n      #   * Don't send uninterrupted steering for > 360 seconds\n      # MQB racks reset the uninterrupted steering timer after a single frame\n      # of HCA disabled; this is done whenever output happens to be zero.\n\n      if CC.latActive:\n        new_steer = int(round(actuators.steer * self.CCP.STEER_MAX))\n        apply_steer = apply_driver_steer_torque_limits(new_steer, self.apply_steer_last, CS.out.steeringTorque, self.CCP)\n        self.hca_frame_timer_running += self.CCP.STEER_STEP\n        if self.apply_steer_last == apply_steer:\n          self.hca_frame_same_torque += self.CCP.STEER_STEP\n          if self.hca_frame_same_torque > self.CCP.STEER_TIME_STUCK_TORQUE / DT_CTRL:\n            apply_steer -= (1, -1)[apply_steer < 0]\n            self.hca_frame_same_torque = 0\n        else:\n          self.hca_frame_same_torque = 0\n        hca_enabled = abs(apply_steer) > 0\n      else:\n        hca_enabled = False\n        apply_steer = 0\n\n      if not hca_enabled:\n        self.hca_frame_timer_running = 0\n\n      self.eps_timer_soft_disable_alert = self.hca_frame_timer_running > self.CCP.STEER_TIME_ALERT / DT_CTRL\n      self.apply_steer_last = apply_steer\n      can_sends.append(self.CCS.create_steering_control(self.packer_pt, CANBUS.pt, apply_steer, hca_enabled))\n\n      if self.CP.flags & VolkswagenFlags.STOCK_HCA_PRESENT:\n        # Pacify VW Emergency Assist driver inactivity detection by changing its view of driver steering input torque\n        # to the greatest of actual driver input or 2x openpilot's output (1x openpilot output is not enough to\n        # consistently reset inactivity detection on straight level roads). See commaai/openpilot#23274 for background.\n        ea_simulated_torque = clip(apply_steer * 2, -self.CCP.STEER_MAX, self.CCP.STEER_MAX)\n        if abs(CS.out.steeringTorque) > abs(ea_simulated_torque):\n          ea_simulated_torque = CS.out.steeringTorque\n        can_sends.append(self.CCS.create_eps_update(self.packer_pt, CANBUS.cam, CS.eps_stock_values, ea_simulated_torque))\n\n    # **** Acceleration Controls ******************************************** #\n\n    if self.frame % self.CCP.ACC_CONTROL_STEP == 0 and self.CP.openpilotLongitudinalControl:\n      acc_control = self.CCS.acc_control_value(CS.out.cruiseState.available, CS.out.accFaulted, CC.longActive)\n      accel = clip(actuators.accel, self.CCP.ACCEL_MIN, self.CCP.ACCEL_MAX) if CC.longActive else 0\n      stopping = actuators.longControlState == LongCtrlState.stopping\n      starting = actuators.longControlState == LongCtrlState.pid and (CS.esp_hold_confirmation or CS.out.vEgo < self.CP.vEgoStopping)\n      can_sends.extend(self.CCS.create_acc_accel_control(self.packer_pt, CANBUS.pt, CS.acc_type, CC.longActive, accel,\n                                                         acc_control, stopping, starting, CS.esp_hold_confirmation))\n\n    # **** HUD Controls ***************************************************** #\n\n    if self.frame % self.CCP.LDW_STEP == 0:\n      hud_alert = 0\n      if hud_control.visualAlert in (VisualAlert.steerRequired, VisualAlert.ldw):\n        hud_alert = self.CCP.LDW_MESSAGES[\"laneAssistTakeOver\"]\n      can_sends.append(self.CCS.create_lka_hud_control(self.packer_pt, CANBUS.pt, CS.ldw_stock_values, CC.latActive,\n                                                       CS.out.steeringPressed, hud_alert, hud_control))\n\n    if self.frame % self.CCP.ACC_HUD_STEP == 0 and self.CP.openpilotLongitudinalControl:\n      lead_distance = 0\n      if hud_control.leadVisible and self.frame * DT_CTRL > 1.0:  # Don't display lead until we know the scaling factor\n        lead_distance = 512 if CS.upscale_lead_car_signal else 8\n      acc_hud_status = self.CCS.acc_hud_status_value(CS.out.cruiseState.available, CS.out.accFaulted, CC.longActive)\n      # FIXME: follow the recent displayed-speed updates, also use mph_kmh toggle to fix display rounding problem?\n      set_speed = hud_control.setSpeed * CV.MS_TO_KPH\n      can_sends.append(self.CCS.create_acc_hud_control(self.packer_pt, CANBUS.pt, acc_hud_status, set_speed,\n                                                       lead_distance, hud_control.leadDistanceBars))\n\n    # **** Stock ACC Button Controls **************************************** #\n\n    gra_send_ready = self.CP.pcmCruise and CS.gra_stock_values[\"COUNTER\"] != self.gra_acc_counter_last\n    if gra_send_ready and (CC.cruiseControl.cancel or CC.cruiseControl.resume):\n      can_sends.append(self.CCS.create_acc_buttons_control(self.packer_pt, self.ext_bus, CS.gra_stock_values,\n                                                           cancel=CC.cruiseControl.cancel, resume=CC.cruiseControl.resume))\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steer = self.apply_steer_last / self.CCP.STEER_MAX\n    new_actuators.steerOutputCan = self.apply_steer_last\n\n    self.gra_acc_counter_last = CS.gra_stock_values[\"COUNTER\"]\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/volkswagen/radar_interface.py": "from openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nclass RadarInterface(RadarInterfaceBase):\n  pass\n", "selfdrive/car/volkswagen/__init__.py": "", "selfdrive/car/volkswagen/interface.py": "from cereal import car\nfrom panda import Panda\nfrom openpilot.selfdrive.car import get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.car.volkswagen.values import CAR, CANBUS, CarControllerParams, NetworkLocation, TransmissionType, GearShifter, VolkswagenFlags\n\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\n\n\nclass CarInterface(CarInterfaceBase):\n  def __init__(self, CP, CarController, CarState):\n    super().__init__(CP, CarController, CarState)\n\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      self.ext_bus = CANBUS.pt\n      self.cp_ext = self.cp\n    else:\n      self.ext_bus = CANBUS.cam\n      self.cp_ext = self.cp_cam\n\n  @staticmethod\n  def _get_params(ret, candidate: CAR, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"volkswagen\"\n    ret.radarUnavailable = True\n\n    if ret.flags & VolkswagenFlags.PQ:\n      # Set global PQ35/PQ46/NMS parameters\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.volkswagenPq)]\n      ret.enableBsm = 0x3BA in fingerprint[0]  # SWA_1\n\n      if 0x440 in fingerprint[0] or docs:  # Getriebe_1\n        ret.transmissionType = TransmissionType.automatic\n      else:\n        ret.transmissionType = TransmissionType.manual\n\n      if any(msg in fingerprint[1] for msg in (0x1A0, 0xC2)):  # Bremse_1, Lenkwinkel_1\n        ret.networkLocation = NetworkLocation.gateway\n      else:\n        ret.networkLocation = NetworkLocation.fwdCamera\n\n      # The PQ port is in dashcam-only mode due to a fixed six-minute maximum timer on HCA steering. An unsupported\n      # EPS flash update to work around this timer, and enable steering down to zero, is available from:\n      #   https://github.com/pd0wm/pq-flasher\n      # It is documented in a four-part blog series:\n      #   https://blog.willemmelching.nl/carhacking/2022/01/02/vw-part1/\n      # Panda ALLOW_DEBUG firmware required.\n      ret.dashcamOnly = True\n\n    else:\n      # Set global MQB parameters\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.volkswagen)]\n      ret.enableBsm = 0x30F in fingerprint[0]  # SWA_01\n\n      if 0xAD in fingerprint[0] or docs:  # Getriebe_11\n        ret.transmissionType = TransmissionType.automatic\n      elif 0x187 in fingerprint[0]:  # EV_Gearshift\n        ret.transmissionType = TransmissionType.direct\n      else:\n        ret.transmissionType = TransmissionType.manual\n\n      if any(msg in fingerprint[1] for msg in (0x40, 0x86, 0xB2, 0xFD)):  # Airbag_01, LWI_01, ESP_19, ESP_21\n        ret.networkLocation = NetworkLocation.gateway\n      else:\n        ret.networkLocation = NetworkLocation.fwdCamera\n\n      if 0x126 in fingerprint[2]:  # HCA_01\n        ret.flags |= VolkswagenFlags.STOCK_HCA_PRESENT.value\n\n    # Global lateral tuning defaults, can be overridden per-vehicle\n\n    ret.steerLimitTimer = 0.4\n    if ret.flags & VolkswagenFlags.PQ:\n      ret.steerActuatorDelay = 0.2\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n    else:\n      ret.steerActuatorDelay = 0.1\n      ret.lateralTuning.pid.kpBP = [0.]\n      ret.lateralTuning.pid.kiBP = [0.]\n      ret.lateralTuning.pid.kf = 0.00006\n      ret.lateralTuning.pid.kpV = [0.6]\n      ret.lateralTuning.pid.kiV = [0.2]\n\n    # Global longitudinal tuning defaults, can be overridden per-vehicle\n\n    ret.experimentalLongitudinalAvailable = ret.networkLocation == NetworkLocation.gateway or docs\n    if experimental_long:\n      # Proof-of-concept, prep for E2E only. No radar points available. Panda ALLOW_DEBUG firmware required.\n      ret.openpilotLongitudinalControl = True\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_VOLKSWAGEN_LONG_CONTROL\n      if ret.transmissionType == TransmissionType.manual:\n        ret.minEnableSpeed = 4.5\n\n    ret.pcmCruise = not ret.openpilotLongitudinalControl\n    ret.stoppingControl = True\n    ret.stopAccel = -0.55\n    ret.vEgoStarting = 0.1\n    ret.vEgoStopping = 0.5\n    ret.autoResumeSng = ret.minEnableSpeed == -1\n\n    return ret\n\n  # returns a car.CarState\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam, self.cp_ext, self.CP.transmissionType)\n\n    events = self.create_common_events(ret, extra_gears=[GearShifter.eco, GearShifter.sport, GearShifter.manumatic],\n                                       pcm_enable=not self.CS.CP.openpilotLongitudinalControl,\n                                       enable_buttons=(ButtonType.setCruise, ButtonType.resumeCruise))\n\n    # Low speed steer alert hysteresis logic\n    if (self.CP.minSteerSpeed - 1e-3) > CarControllerParams.DEFAULT_MIN_STEER_SPEED and ret.vEgo < (self.CP.minSteerSpeed + 1.):\n      self.low_speed_alert = True\n    elif ret.vEgo > (self.CP.minSteerSpeed + 2.):\n      self.low_speed_alert = False\n    if self.low_speed_alert:\n      events.add(EventName.belowSteerSpeed)\n\n    if self.CS.CP.openpilotLongitudinalControl:\n      if ret.vEgo < self.CP.minEnableSpeed + 0.5:\n        events.add(EventName.belowEngageSpeed)\n      if c.enabled and ret.vEgo < self.CP.minEnableSpeed:\n        events.add(EventName.speedTooLow)\n\n    if self.CC.eps_timer_soft_disable_alert:\n      events.add(EventName.steerTimeLimit)\n\n    ret.events = events.to_msg()\n\n    return ret\n\n", "selfdrive/car/gm/gmcan.py": "from openpilot.selfdrive.car import make_can_msg\nfrom openpilot.selfdrive.car.gm.values import CAR\n\n\ndef create_buttons(packer, bus, idx, button):\n  values = {\n    \"ACCButtons\": button,\n    \"RollingCounter\": idx,\n    \"ACCAlwaysOne\": 1,\n    \"DistanceButton\": 0,\n  }\n\n  checksum = 240 + int(values[\"ACCAlwaysOne\"] * 0xf)\n  checksum += values[\"RollingCounter\"] * (0x4ef if values[\"ACCAlwaysOne\"] != 0 else 0x3f0)\n  checksum -= int(values[\"ACCButtons\"] - 1) << 4  # not correct if value is 0\n  checksum -= 2 * values[\"DistanceButton\"]\n\n  values[\"SteeringButtonChecksum\"] = checksum\n  return packer.make_can_msg(\"ASCMSteeringButton\", bus, values)\n\n\ndef create_pscm_status(packer, bus, pscm_status):\n  values = {s: pscm_status[s] for s in [\n    \"HandsOffSWDetectionMode\",\n    \"HandsOffSWlDetectionStatus\",\n    \"LKATorqueDeliveredStatus\",\n    \"LKADriverAppldTrq\",\n    \"LKATorqueDelivered\",\n    \"LKATotalTorqueDelivered\",\n    \"RollingCounter\",\n    \"PSCMStatusChecksum\",\n  ]}\n  checksum_mod = int(1 - values[\"HandsOffSWlDetectionStatus\"]) << 5\n  values[\"HandsOffSWlDetectionStatus\"] = 1\n  values[\"PSCMStatusChecksum\"] += checksum_mod\n  return packer.make_can_msg(\"PSCMStatus\", bus, values)\n\n\ndef create_steering_control(packer, bus, apply_steer, idx, lkas_active):\n  values = {\n    \"LKASteeringCmdActive\": lkas_active,\n    \"LKASteeringCmd\": apply_steer,\n    \"RollingCounter\": idx,\n    \"LKASteeringCmdChecksum\": 0x1000 - (lkas_active << 11) - (apply_steer & 0x7ff) - idx\n  }\n\n  return packer.make_can_msg(\"ASCMLKASteeringCmd\", bus, values)\n\n\ndef create_adas_keepalive(bus):\n  dat = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  return [make_can_msg(0x409, dat, bus), make_can_msg(0x40a, dat, bus)]\n\n\ndef create_gas_regen_command(packer, bus, throttle, idx, enabled, at_full_stop):\n  values = {\n    \"GasRegenCmdActive\": enabled,\n    \"RollingCounter\": idx,\n    \"GasRegenCmdActiveInv\": 1 - enabled,\n    \"GasRegenCmd\": throttle,\n    \"GasRegenFullStopActive\": at_full_stop,\n    \"GasRegenAlwaysOne\": 1,\n    \"GasRegenAlwaysOne2\": 1,\n    \"GasRegenAlwaysOne3\": 1,\n  }\n\n  dat = packer.make_can_msg(\"ASCMGasRegenCmd\", bus, values)[2]\n  values[\"GasRegenChecksum\"] = (((0xff - dat[1]) & 0xff) << 16) | \\\n                               (((0xff - dat[2]) & 0xff) << 8) | \\\n                               ((0x100 - dat[3] - idx) & 0xff)\n\n  return packer.make_can_msg(\"ASCMGasRegenCmd\", bus, values)\n\n\ndef create_friction_brake_command(packer, bus, apply_brake, idx, enabled, near_stop, at_full_stop, CP):\n  mode = 0x1\n\n  # TODO: Understand this better. Volts and ICE Camera ACC cars are 0x1 when enabled with no brake\n  if enabled and CP.carFingerprint in (CAR.CHEVROLET_BOLT_EUV,):\n    mode = 0x9\n\n  if apply_brake > 0:\n    mode = 0xa\n    if at_full_stop:\n      mode = 0xd\n\n    # TODO: this is to have GM bringing the car to complete stop,\n    # but currently it conflicts with OP controls, so turned off. Not set by all cars\n    #elif near_stop:\n    #  mode = 0xb\n\n  brake = (0x1000 - apply_brake) & 0xfff\n  checksum = (0x10000 - (mode << 12) - brake - idx) & 0xffff\n\n  values = {\n    \"RollingCounter\": idx,\n    \"FrictionBrakeMode\": mode,\n    \"FrictionBrakeChecksum\": checksum,\n    \"FrictionBrakeCmd\": -apply_brake\n  }\n\n  return packer.make_can_msg(\"EBCMFrictionBrakeCmd\", bus, values)\n\n\ndef create_acc_dashboard_command(packer, bus, enabled, target_speed_kph, hud_control, fcw):\n  target_speed = min(target_speed_kph, 255)\n\n  values = {\n    \"ACCAlwaysOne\": 1,\n    \"ACCResumeButton\": 0,\n    \"ACCSpeedSetpoint\": target_speed,\n    \"ACCGapLevel\": hud_control.leadDistanceBars * enabled,  # 3 \"far\", 0 \"inactive\"\n    \"ACCCmdActive\": enabled,\n    \"ACCAlwaysOne2\": 1,\n    \"ACCLeadCar\": hud_control.leadVisible,\n    \"FCWAlert\": 0x3 if fcw else 0\n  }\n\n  return packer.make_can_msg(\"ASCMActiveCruiseControlStatus\", bus, values)\n\n\ndef create_adas_time_status(bus, tt, idx):\n  dat = [(tt >> 20) & 0xff, (tt >> 12) & 0xff, (tt >> 4) & 0xff,\n         ((tt & 0xf) << 4) + (idx << 2)]\n  chksum = 0x1000 - dat[0] - dat[1] - dat[2] - dat[3]\n  chksum = chksum & 0xfff\n  dat += [0x40 + (chksum >> 8), chksum & 0xff, 0x12]\n  return make_can_msg(0xa1, bytes(dat), bus)\n\n\ndef create_adas_steering_status(bus, idx):\n  dat = [idx << 6, 0xf0, 0x20, 0, 0, 0]\n  chksum = 0x60 + sum(dat)\n  dat += [chksum >> 8, chksum & 0xff]\n  return make_can_msg(0x306, bytes(dat), bus)\n\n\ndef create_adas_accelerometer_speed_status(bus, speed_ms, idx):\n  spd = int(speed_ms * 16) & 0xfff\n  accel = 0 & 0xfff\n  # 0 if in park/neutral, 0x10 if in reverse, 0x08 for D/L\n  #stick = 0x08\n  near_range_cutoff = 0x27\n  near_range_mode = 1 if spd <= near_range_cutoff else 0\n  far_range_mode = 1 - near_range_mode\n  dat = [0x08, spd >> 4, ((spd & 0xf) << 4) | (accel >> 8), accel & 0xff, 0]\n  chksum = 0x62 + far_range_mode + (idx << 2) + dat[0] + dat[1] + dat[2] + dat[3] + dat[4]\n  dat += [(idx << 5) + (far_range_mode << 4) + (near_range_mode << 3) + (chksum >> 8), chksum & 0xff]\n  return make_can_msg(0x308, bytes(dat), bus)\n\n\ndef create_adas_headlights_status(packer, bus):\n  values = {\n    \"Always42\": 0x42,\n    \"Always4\": 0x4,\n  }\n  return packer.make_can_msg(\"ASCMHeadlight\", bus, values)\n\n\ndef create_lka_icon_command(bus, active, critical, steer):\n  if active and steer == 1:\n    if critical:\n      dat = b\"\\x50\\xc0\\x14\"\n    else:\n      dat = b\"\\x50\\x40\\x18\"\n  elif active:\n    if critical:\n      dat = b\"\\x40\\xc0\\x14\"\n    else:\n      dat = b\"\\x40\\x40\\x18\"\n  else:\n    dat = b\"\\x00\\x00\\x00\"\n  return make_can_msg(0x104c006c, dat, bus)\n", "selfdrive/car/gm/carstate.py": "import copy\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import mean\nfrom opendbc.can.can_define import CANDefine\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom openpilot.selfdrive.car.gm.values import DBC, AccState, CanBus, STEER_THRESHOLD\n\nTransmissionType = car.CarParams.TransmissionType\nNetworkLocation = car.CarParams.NetworkLocation\nSTANDSTILL_THRESHOLD = 10 * 0.0311 * CV.KPH_TO_MS\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n    self.shifter_values = can_define.dv[\"ECMPRDNL2\"][\"PRNDL2\"]\n    self.cluster_speed_hyst_gap = CV.KPH_TO_MS / 2.\n    self.cluster_min_speed = CV.KPH_TO_MS / 2.\n\n    self.loopback_lka_steering_cmd_updated = False\n    self.loopback_lka_steering_cmd_ts_nanos = 0\n    self.pt_lka_steering_cmd_counter = 0\n    self.cam_lka_steering_cmd_counter = 0\n    self.buttons_counter = 0\n\n    self.prev_distance_button = 0\n    self.distance_button = 0\n\n  def update(self, pt_cp, cam_cp, loopback_cp):\n    ret = car.CarState.new_message()\n\n    self.prev_cruise_buttons = self.cruise_buttons\n    self.prev_distance_button = self.distance_button\n    self.cruise_buttons = pt_cp.vl[\"ASCMSteeringButton\"][\"ACCButtons\"]\n    self.distance_button = pt_cp.vl[\"ASCMSteeringButton\"][\"DistanceButton\"]\n    self.buttons_counter = pt_cp.vl[\"ASCMSteeringButton\"][\"RollingCounter\"]\n    self.pscm_status = copy.copy(pt_cp.vl[\"PSCMStatus\"])\n    # This is to avoid a fault where you engage while still moving backwards after shifting to D.\n    # An Equinox has been seen with an unsupported status (3), so only check if either wheel is in reverse (2)\n    self.moving_backward = (pt_cp.vl[\"EBCMWheelSpdRear\"][\"RLWheelDir\"] == 2) or (pt_cp.vl[\"EBCMWheelSpdRear\"][\"RRWheelDir\"] == 2)\n\n    # Variables used for avoiding LKAS faults\n    self.loopback_lka_steering_cmd_updated = len(loopback_cp.vl_all[\"ASCMLKASteeringCmd\"][\"RollingCounter\"]) > 0\n    if self.loopback_lka_steering_cmd_updated:\n      self.loopback_lka_steering_cmd_ts_nanos = loopback_cp.ts_nanos[\"ASCMLKASteeringCmd\"][\"RollingCounter\"]\n    if self.CP.networkLocation == NetworkLocation.fwdCamera:\n      self.pt_lka_steering_cmd_counter = pt_cp.vl[\"ASCMLKASteeringCmd\"][\"RollingCounter\"]\n      self.cam_lka_steering_cmd_counter = cam_cp.vl[\"ASCMLKASteeringCmd\"][\"RollingCounter\"]\n\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      pt_cp.vl[\"EBCMWheelSpdFront\"][\"FLWheelSpd\"],\n      pt_cp.vl[\"EBCMWheelSpdFront\"][\"FRWheelSpd\"],\n      pt_cp.vl[\"EBCMWheelSpdRear\"][\"RLWheelSpd\"],\n      pt_cp.vl[\"EBCMWheelSpdRear\"][\"RRWheelSpd\"],\n    )\n    ret.vEgoRaw = mean([ret.wheelSpeeds.fl, ret.wheelSpeeds.fr, ret.wheelSpeeds.rl, ret.wheelSpeeds.rr])\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    # sample rear wheel speeds, standstill=True if ECM allows engagement with brake\n    ret.standstill = ret.wheelSpeeds.rl <= STANDSTILL_THRESHOLD and ret.wheelSpeeds.rr <= STANDSTILL_THRESHOLD\n\n    if pt_cp.vl[\"ECMPRDNL2\"][\"ManualMode\"] == 1:\n      ret.gearShifter = self.parse_gear_shifter(\"T\")\n    else:\n      ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(pt_cp.vl[\"ECMPRDNL2\"][\"PRNDL2\"], None))\n\n    ret.brake = pt_cp.vl[\"ECMAcceleratorPos\"][\"BrakePedalPos\"]\n    if self.CP.networkLocation == NetworkLocation.fwdCamera:\n      ret.brakePressed = pt_cp.vl[\"ECMEngineStatus\"][\"BrakePressed\"] != 0\n    else:\n      # Some Volt 2016-17 have loose brake pedal push rod retainers which causes the ECM to believe\n      # that the brake is being intermittently pressed without user interaction.\n      # To avoid a cruise fault we need to use a conservative brake position threshold\n      # https://static.nhtsa.gov/odi/tsbs/2017/MC-10137629-9999.pdf\n      ret.brakePressed = ret.brake >= 8\n\n    # Regen braking is braking\n    if self.CP.transmissionType == TransmissionType.direct:\n      ret.regenBraking = pt_cp.vl[\"EBCMRegenPaddle\"][\"RegenPaddle\"] != 0\n\n    ret.gas = pt_cp.vl[\"AcceleratorPedal2\"][\"AcceleratorPedal2\"] / 254.\n    ret.gasPressed = ret.gas > 1e-5\n\n    ret.steeringAngleDeg = pt_cp.vl[\"PSCMSteeringAngle\"][\"SteeringWheelAngle\"]\n    ret.steeringRateDeg = pt_cp.vl[\"PSCMSteeringAngle\"][\"SteeringWheelRate\"]\n    ret.steeringTorque = pt_cp.vl[\"PSCMStatus\"][\"LKADriverAppldTrq\"]\n    ret.steeringTorqueEps = pt_cp.vl[\"PSCMStatus\"][\"LKATorqueDelivered\"]\n    ret.steeringPressed = abs(ret.steeringTorque) > STEER_THRESHOLD\n\n    # 0 inactive, 1 active, 2 temporarily limited, 3 failed\n    self.lkas_status = pt_cp.vl[\"PSCMStatus\"][\"LKATorqueDeliveredStatus\"]\n    ret.steerFaultTemporary = self.lkas_status == 2\n    ret.steerFaultPermanent = self.lkas_status == 3\n\n    # 1 - open, 0 - closed\n    ret.doorOpen = (pt_cp.vl[\"BCMDoorBeltStatus\"][\"FrontLeftDoor\"] == 1 or\n                    pt_cp.vl[\"BCMDoorBeltStatus\"][\"FrontRightDoor\"] == 1 or\n                    pt_cp.vl[\"BCMDoorBeltStatus\"][\"RearLeftDoor\"] == 1 or\n                    pt_cp.vl[\"BCMDoorBeltStatus\"][\"RearRightDoor\"] == 1)\n\n    # 1 - latched\n    ret.seatbeltUnlatched = pt_cp.vl[\"BCMDoorBeltStatus\"][\"LeftSeatBelt\"] == 0\n    ret.leftBlinker = pt_cp.vl[\"BCMTurnSignals\"][\"TurnSignals\"] == 1\n    ret.rightBlinker = pt_cp.vl[\"BCMTurnSignals\"][\"TurnSignals\"] == 2\n\n    ret.parkingBrake = pt_cp.vl[\"BCMGeneralPlatformStatus\"][\"ParkBrakeSwActive\"] == 1\n    ret.cruiseState.available = pt_cp.vl[\"ECMEngineStatus\"][\"CruiseMainOn\"] != 0\n    ret.espDisabled = pt_cp.vl[\"ESPStatus\"][\"TractionControlOn\"] != 1\n    ret.accFaulted = (pt_cp.vl[\"AcceleratorPedal2\"][\"CruiseState\"] == AccState.FAULTED or\n                      pt_cp.vl[\"EBCMFrictionBrakeStatus\"][\"FrictionBrakeUnavailable\"] == 1)\n\n    ret.cruiseState.enabled = pt_cp.vl[\"AcceleratorPedal2\"][\"CruiseState\"] != AccState.OFF\n    ret.cruiseState.standstill = pt_cp.vl[\"AcceleratorPedal2\"][\"CruiseState\"] == AccState.STANDSTILL\n    if self.CP.networkLocation == NetworkLocation.fwdCamera:\n      ret.cruiseState.speed = cam_cp.vl[\"ASCMActiveCruiseControlStatus\"][\"ACCSpeedSetpoint\"] * CV.KPH_TO_MS\n      ret.stockAeb = cam_cp.vl[\"AEBCmd\"][\"AEBCmdActive\"] != 0\n      # openpilot controls nonAdaptive when not pcmCruise\n      if self.CP.pcmCruise:\n        ret.cruiseState.nonAdaptive = cam_cp.vl[\"ASCMActiveCruiseControlStatus\"][\"ACCCruiseState\"] not in (2, 3)\n\n    if self.CP.enableBsm:\n      ret.leftBlindspot = pt_cp.vl[\"BCMBlindSpotMonitor\"][\"LeftBSM\"] == 1\n      ret.rightBlindspot = pt_cp.vl[\"BCMBlindSpotMonitor\"][\"RightBSM\"] == 1\n\n    return ret\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = []\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      messages += [\n        (\"AEBCmd\", 10),\n        (\"ASCMLKASteeringCmd\", 10),\n        (\"ASCMActiveCruiseControlStatus\", 25),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus.CAMERA)\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      (\"BCMTurnSignals\", 1),\n      (\"ECMPRDNL2\", 10),\n      (\"PSCMStatus\", 10),\n      (\"ESPStatus\", 10),\n      (\"BCMDoorBeltStatus\", 10),\n      (\"BCMGeneralPlatformStatus\", 10),\n      (\"EBCMWheelSpdFront\", 20),\n      (\"EBCMWheelSpdRear\", 20),\n      (\"EBCMFrictionBrakeStatus\", 20),\n      (\"AcceleratorPedal2\", 33),\n      (\"ASCMSteeringButton\", 33),\n      (\"ECMEngineStatus\", 100),\n      (\"PSCMSteeringAngle\", 100),\n      (\"ECMAcceleratorPos\", 80),\n    ]\n\n    if CP.enableBsm:\n      messages.append((\"BCMBlindSpotMonitor\", 10))\n\n    # Used to read back last counter sent to PT by camera\n    if CP.networkLocation == NetworkLocation.fwdCamera:\n      messages += [\n        (\"ASCMLKASteeringCmd\", 0),\n      ]\n\n    if CP.transmissionType == TransmissionType.direct:\n      messages.append((\"EBCMRegenPaddle\", 50))\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus.POWERTRAIN)\n\n  @staticmethod\n  def get_loopback_can_parser(CP):\n    messages = [\n      (\"ASCMLKASteeringCmd\", 0),\n    ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus.LOOPBACK)\n", "selfdrive/car/gm/fingerprints.py": "# ruff: noqa: E501\nfrom openpilot.selfdrive.car.gm.values import CAR\n\n# Trailblazer also matches as a SILVERADO, TODO: split with fw versions\n# FIXME: There are Equinox users with different message lengths, specifically 304 and 320\n\n\nFINGERPRINTS = {\n  CAR.HOLDEN_ASTRA: [{\n    190: 8, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 8, 241: 6, 249: 8, 288: 5, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 328: 1, 352: 5, 381: 6, 384: 4, 386: 8, 388: 8, 393: 8, 398: 8, 401: 8, 413: 8, 417: 8, 419: 8, 422: 1, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 8, 455: 7, 456: 8, 458: 5, 479: 8, 481: 7, 485: 8, 489: 8, 497: 8, 499: 3, 500: 8, 501: 8, 508: 8, 528: 5, 532: 6, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 567: 5, 647: 5, 707: 8, 715: 8, 723: 8, 753: 5, 761: 7, 806: 1, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 961: 8, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1009: 8, 1011: 6, 1017: 8, 1019: 3, 1020: 8, 1105: 6, 1217: 8, 1221: 5, 1225: 8, 1233: 8, 1249: 8, 1257: 6, 1259: 8, 1261: 7, 1263: 4, 1265: 8, 1267: 8, 1280: 4, 1300: 8, 1328: 4, 1417: 8, 1906: 7, 1907: 7, 1908: 7, 1912: 7, 1919: 7\n  }],\n  CAR.CHEVROLET_VOLT: [{\n    170: 8, 171: 8, 189: 7, 190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 2, 241: 6, 288: 5, 289: 8, 298: 8, 304: 1, 308: 4, 309: 8, 311: 8, 313: 8, 320: 3, 328: 1, 352: 5, 381: 6, 384: 4, 386: 8, 388: 8, 389: 2, 390: 7, 417: 7, 419: 1, 426: 7, 451: 8, 452: 8, 453: 6, 454: 8, 456: 8, 479: 3, 481: 7, 485: 8, 489: 8, 493: 8, 495: 4, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 528: 4, 532: 6, 546: 7, 550: 8, 554: 3, 558: 8, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 566: 5, 567: 3, 568: 1, 573: 1, 577: 8, 647: 3, 707: 8, 711: 6, 715: 8, 761: 7, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 961: 8, 969: 8, 977: 8, 979: 7, 988: 6, 989: 8, 995: 7, 1001: 8, 1005: 6, 1009: 8, 1017: 8, 1019: 2, 1020: 8, 1105: 6, 1187: 4, 1217: 8, 1221: 5, 1223: 3, 1225: 7, 1227: 4, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1273: 3, 1275: 3, 1280: 4, 1300: 8, 1322: 6, 1323: 4, 1328: 4, 1417: 8, 1601: 8, 1905: 7, 1906: 7, 1907: 7, 1910: 7, 1912: 7, 1922: 7, 1927: 7, 1928: 7, 2016: 8, 2020: 8, 2024: 8, 2028: 8\n  },\n  {\n    170: 8, 171: 8, 189: 7, 190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 2, 241: 6, 288: 5, 298: 8, 304: 1, 308: 4, 309: 8, 311: 8, 313: 8, 320: 3, 328: 1, 352: 5, 381: 6, 384: 4, 386: 8, 388: 8, 389: 2, 390: 7, 417: 7, 419: 1, 426: 7, 451: 8, 452: 8, 453: 6, 454: 8, 456: 8, 479: 3, 481: 7, 485: 8, 489: 8, 493: 8, 495: 4, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 528: 4, 532: 6, 546: 7, 550: 8, 554: 3, 558: 8, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 566: 5, 567: 3, 568: 1, 573: 1, 577: 8, 578: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 3, 707: 8, 711: 6, 715: 8, 717: 5, 761: 7, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 961: 8, 967: 4, 969: 8, 977: 8, 979: 7, 988: 6, 989: 8, 995: 7, 1001: 8, 1005: 6, 1009: 8, 1017: 8, 1019: 2, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1187: 4, 1217: 8, 1221: 5, 1223: 3, 1225: 7, 1227: 4, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1273: 3, 1275: 3, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1323: 4, 1328: 4, 1417: 8, 1516: 8, 1601: 8, 1618: 8, 1905: 7, 1906: 7, 1907: 7, 1910: 7, 1912: 7, 1922: 7, 1927: 7, 1930: 7, 2016: 8, 2018: 8, 2020: 8, 2024: 8, 2028: 8\n  },\n  {\n    170: 8, 171: 8, 189: 7, 190: 6, 192: 5, 193: 8, 197: 8, 199: 4, 201: 6, 209: 7, 211: 2, 241: 6, 288: 5, 289: 1, 290: 1, 298: 2, 304: 1, 308: 4, 309: 8, 311: 8, 313: 8, 320: 3, 328: 1, 352: 5, 368: 8, 381: 2, 384: 8, 386: 5, 388: 8, 389: 2, 390: 7, 417: 7, 419: 1, 426: 7, 451: 8, 452: 8, 453: 6, 454: 8, 456: 8, 458: 8, 479: 3, 481: 7, 485: 8, 489: 5, 493: 8, 495: 4, 497: 8, 499: 3, 500: 6, 501: 3, 508: 8, 512: 3, 528: 4, 530: 8, 532: 6, 537: 5, 539: 8, 542: 7, 546: 7, 550: 8, 554: 3, 558: 8, 560: 6, 562: 4, 563: 5, 564: 5, 565: 5, 566: 5, 567: 3, 568: 1, 573: 1, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 3, 707: 8, 711: 6, 761: 7, 810: 8, 821: 4, 823: 7, 832: 8, 840: 5, 842: 5, 844: 8, 853: 8, 866: 4, 961: 8, 967: 4, 969: 8, 977: 8, 979: 7, 988: 6, 989: 8, 995: 7, 1001: 5, 1003: 5, 1005: 6, 1009: 8, 1017: 8, 1019: 2, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1187: 4, 1217: 8, 1221: 5, 1223: 3, 1225: 7, 1227: 4, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1273: 3, 1275: 3, 1280: 4, 1300: 8, 1322: 6, 1323: 4, 1328: 4, 1417: 8, 1905: 7, 1906: 7, 1907: 7, 1910: 7, 1912: 7, 1922: 7, 1927: 7\n  }],\n  CAR.BUICK_LACROSSE: [{\n    190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 2, 241: 6, 249: 8, 288: 5, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 322: 7, 328: 1, 352: 5, 353: 3, 381: 6, 386: 8, 388: 8, 393: 7, 398: 8, 407: 7, 413: 8, 417: 7, 419: 1, 422: 4, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 6, 455: 7, 456: 8, 463: 3, 479: 3, 481: 7, 485: 8, 487: 8, 489: 8, 495: 4, 497: 8, 499: 3, 500: 6, 501: 8, 503: 1, 508: 8, 510: 8, 528: 5, 532: 6, 534: 2, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 567: 5, 573: 1, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 5, 707: 8, 753: 5, 761: 7, 801: 8, 804: 3, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 872: 1, 882: 8, 890: 1, 892: 2, 893: 1, 894: 1, 961: 8, 967: 4, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1005: 6, 1009: 8, 1011: 6, 1013: 3, 1017: 8, 1019: 2, 1020: 8, 1022: 1, 1105: 6, 1217: 8, 1221: 5, 1223: 2, 1225: 7, 1233: 8, 1243: 3, 1249: 8, 1257: 6, 1259: 8, 1261: 7, 1263: 4, 1265: 8, 1267: 1, 1280: 4, 1300: 8, 1322: 6, 1328: 4, 1417: 8, 1609: 8, 1613: 8, 1649: 8, 1792: 8, 1798: 8, 1824: 8, 1825: 8, 1840: 8, 1842: 8, 1858: 8, 1860: 8, 1863: 8, 1872: 8, 1875: 8, 1882: 8, 1888: 8, 1889: 8, 1892: 8, 1904: 7, 1906: 7, 1907: 7, 1912: 7, 1913: 7, 1914: 7, 1916: 7, 1918: 7, 1919: 7, 1937: 8, 1953: 8, 1968: 8, 2001: 8, 2017: 8, 2018: 8, 2020: 8, 2026: 8\n  }],\n  CAR.BUICK_REGAL: [{\n    190: 8, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 8, 241: 6, 249: 8, 288: 5, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 322: 7, 328: 1, 352: 5, 381: 6, 384: 4, 386: 8, 388: 8, 393: 7, 398: 8, 407: 7, 413: 8, 417: 8, 419: 8, 422: 4, 426: 8, 431: 8, 442: 8, 451: 8, 452: 8, 453: 8, 455: 7, 456: 8, 463: 3, 479: 8, 481: 7, 485: 8, 487: 8, 489: 8, 495: 8, 497: 8, 499: 3, 500: 8, 501: 8, 508: 8, 528: 5, 532: 6, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 567: 5, 569: 3, 573: 1, 577: 8, 578: 8, 579: 8, 587: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 3, 707: 8, 715: 8, 717: 5, 753: 5, 761: 7, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 882: 8, 884: 8, 890: 1, 892: 2, 893: 2, 894: 1, 961: 8, 967: 8, 969: 8, 977: 8, 979: 8, 985: 8, 1001: 8, 1005: 6, 1009: 8, 1011: 8, 1013: 3, 1017: 8, 1020: 8, 1024: 8, 1025: 8, 1026: 8, 1027: 8, 1028: 8, 1029: 8, 1030: 8, 1031: 8, 1032: 2, 1033: 7, 1034: 7, 1105: 6, 1217: 8, 1221: 5, 1223: 8, 1225: 7, 1233: 8, 1249: 8, 1257: 6, 1259: 8, 1261: 8, 1263: 8, 1265: 8, 1267: 8, 1271: 8, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1328: 4, 1417: 8, 1601: 8, 1602: 8, 1603: 7, 1611: 8, 1618: 8, 1906: 8, 1907: 7, 1912: 7, 1914: 7, 1916: 7, 1919: 7, 1930: 7, 2016: 8, 2018: 8, 2019: 8, 2024: 8, 2026: 8\n  }],\n  CAR.CADILLAC_ATS: [{\n    190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 2, 241: 6, 249: 8, 288: 5, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 322: 7, 328: 1, 352: 5, 368: 3, 381: 6, 384: 4, 386: 8, 388: 8, 393: 7, 398: 8, 401: 8, 407: 7, 413: 8, 417: 7, 419: 1, 422: 4, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 6, 455: 7, 456: 8, 462: 4, 479: 3, 481: 7, 485: 8, 487: 8, 489: 8, 491: 2, 493: 8, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 510: 8, 528: 5, 532: 6, 534: 2, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 567: 5, 573: 1, 577: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 6, 707: 8, 715: 8, 717: 5, 719: 5, 723: 2, 753: 5, 761: 7, 801: 8, 804: 3, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 882: 8, 890: 1, 892: 2, 893: 2, 894: 1, 961: 8, 967: 4, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1005: 6, 1009: 8, 1011: 6, 1013: 3, 1017: 8, 1019: 2, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1217: 8, 1221: 5, 1223: 3, 1225: 7, 1233: 8, 1241: 3, 1249: 8, 1257: 6, 1259: 8, 1261: 7, 1263: 4, 1265: 8, 1267: 1, 1271: 8, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1323: 4, 1328: 4, 1417: 8, 1601: 8, 1904: 7, 1906: 7, 1907: 7, 1912: 7, 1916: 7, 1917: 7, 1918: 7, 1919: 7, 1920: 7, 1930: 7, 2016: 8, 2024: 8\n  }],\n  CAR.CHEVROLET_MALIBU: [{\n    190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 209: 7, 211: 2, 241: 6, 249: 8, 288: 5, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 328: 1, 352: 5, 381: 6, 384: 4, 386: 8, 388: 8, 393: 7, 398: 8, 407: 7, 413: 8, 417: 7, 419: 1, 422: 4, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 6, 455: 7, 456: 8, 479: 3, 481: 7, 485: 8, 487: 8, 489: 8, 495: 4, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 510: 8, 528: 5, 532: 6, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 565: 5, 567: 5, 573: 1, 577: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 6, 707: 8, 715: 8, 717: 5, 753: 5, 761: 7, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 961: 8, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1005: 6, 1009: 8, 1013: 3, 1017: 8, 1019: 2, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1217: 8, 1221: 5, 1223: 2, 1225: 7, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1323: 4, 1328: 4, 1417: 8, 1601: 8, 1906: 7, 1907: 7, 1912: 7, 1919: 7, 1930: 7, 2016: 8, 2024: 8\n  }],\n  CAR.GMC_ACADIA: [{\n    190: 6, 192: 5, 193: 8, 197: 8, 199: 4, 201: 6, 208: 8, 209: 7, 211: 2, 241: 6, 249: 8, 288: 5, 289: 1, 290: 1, 298: 8, 304: 8, 309: 8, 313: 8, 320: 8, 322: 7, 328: 1, 352: 7, 368: 8, 381: 8, 384: 8, 386: 8, 388: 8, 393: 8, 398: 8, 413: 8, 417: 7, 419: 1, 422: 4, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 6, 454: 8, 455: 7, 458: 8, 460: 4, 462: 4, 463: 3, 479: 3, 481: 7, 485: 8, 489: 5, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 510: 8, 512: 3, 530: 8, 532: 6, 534: 2, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 567: 5, 568: 2, 573: 1, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 6, 707: 8, 715: 8, 717: 5, 753: 5, 761: 7, 789: 5, 800: 6, 801: 8, 803: 8, 804: 3, 805: 8, 832: 8, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 961: 8, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1003: 5, 1005: 6, 1009: 8, 1017: 8, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1217: 8, 1221: 5, 1225: 8, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1328: 4, 1417: 8, 1906: 7, 1907: 7, 1912: 7, 1914: 7, 1918: 7, 1919: 7, 1920: 7, 1930: 7\n  },\n  {\n    190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 208: 8, 209: 7, 211: 2, 241: 6, 249: 8, 288: 5, 289: 8, 298: 8, 304: 1, 309: 8, 313: 8, 320: 3, 322: 7, 328: 1, 338: 6, 340: 6, 352: 5, 381: 8, 384: 4, 386: 8, 388: 8, 393: 8, 398: 8, 413: 8, 417: 7, 419: 1, 422: 4, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 6, 454: 8, 455: 7, 462: 4, 463: 3, 479: 3, 481: 7, 485: 8, 489: 8, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 510: 8, 532: 6, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 567: 5, 573: 1, 577: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 6, 707: 8, 715: 8, 717: 5, 753: 5, 761: 7, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 961: 8, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1005: 6, 1009: 8, 1017: 8, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1217: 8, 1221: 5, 1225: 8, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1328: 4, 1417: 8, 1601: 8, 1906: 7, 1907: 7, 1912: 7, 1914: 7, 1919: 7, 1920: 7, 1930: 7, 2016: 8, 2024: 8\n  }],\n  CAR.CADILLAC_ESCALADE: [{\n    170: 8, 190: 6, 193: 8, 197: 8, 199: 4, 201: 8, 208: 8, 209: 7, 211: 2, 241: 6, 249: 8, 288: 5, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 322: 7, 328: 1, 352: 5, 381: 6, 384: 4, 386: 8, 388: 8, 393: 7, 398: 8, 407: 4, 413: 8, 417: 7, 419: 1, 422: 4, 426: 7, 431: 8, 442: 8, 451: 8, 452: 8, 453: 6, 454: 8, 455: 7, 460: 5, 462: 4, 463: 3, 479: 3, 481: 7, 485: 8, 487: 8, 489: 8, 497: 8, 499: 3, 500: 6, 501: 8, 508: 8, 510: 8, 532: 6, 534: 2, 554: 3, 560: 8, 562: 8, 563: 5, 564: 5, 573: 1, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 647: 6, 707: 8, 715: 8, 717: 5, 719: 5, 761: 7, 801: 8, 804: 3, 810: 8, 840: 5, 842: 5, 844: 8, 866: 4, 869: 4, 880: 6, 961: 8, 967: 4, 969: 8, 977: 8, 979: 8, 985: 5, 1001: 8, 1005: 6, 1009: 8, 1017: 8, 1019: 2, 1020: 8, 1033: 7, 1034: 7, 1105: 6, 1217: 8, 1221: 5, 1223: 2, 1225: 7, 1233: 8, 1249: 8, 1257: 6, 1265: 8, 1267: 1, 1280: 4, 1296: 4, 1300: 8, 1322: 6, 1323: 4, 1328: 4, 1417: 8, 1609: 8, 1613: 8, 1649: 8, 1792: 8, 1798: 8, 1824: 8, 1825: 8, 1840: 8, 1842: 8, 1858: 8, 1860: 8, 1863: 8, 1872: 8, 1875: 8, 1882: 8, 1888: 8, 1889: 8, 1892: 8, 1906: 7, 1907: 7, 1912: 7, 1914: 7, 1917: 7, 1918: 7, 1919: 7, 1920: 7, 1930: 7, 1937: 8, 1953: 8, 1968: 8, 2001: 8, 2017: 8, 2018: 8, 2020: 8, 2026: 8\n  }],\n  CAR.CADILLAC_ESCALADE_ESV: [{\n    309: 1, 848: 8, 849: 8, 850: 8, 851: 8, 852: 8, 853: 8, 854: 3, 1056: 6, 1057: 8, 1058: 8, 1059: 8, 1060: 8, 1061: 8, 1062: 8, 1063: 8, 1064: 8, 1065: 8, 1066: 8, 1067: 8, 1068: 8, 1120: 8, 1121: 8, 1122: 8, 1123: 8, 1124: 8, 1125: 8, 1126: 8, 1127: 8, 1128: 8, 1129: 8, 1130: 8, 1131: 8, 1132: 8, 1133: 8, 1134: 8, 1135: 8, 1136: 8, 1137: 8, 1138: 8, 1139: 8, 1140: 8, 1141: 8, 1142: 8, 1143: 8, 1146: 8, 1147: 8, 1148: 8, 1149: 8, 1150: 8, 1151: 8, 1216: 8, 1217: 8, 1218: 8, 1219: 8, 1220: 8, 1221: 8, 1222: 8, 1223: 8, 1224: 8, 1225: 8, 1226: 8, 1232: 8, 1233: 8, 1234: 8, 1235: 8, 1236: 8, 1237: 8, 1238: 8, 1239: 8, 1240: 8, 1241: 8, 1242: 8, 1787: 8, 1788: 8\n  }],\n  CAR.CADILLAC_ESCALADE_ESV_2019: [{\n    715: 8, 840: 5, 717: 5, 869: 4, 880: 6, 289: 8, 454: 8, 842: 5, 460: 5, 463: 3, 801: 8, 170: 8, 190: 6, 241: 6, 201: 8, 417: 7, 211: 2, 419: 1, 398: 8, 426: 7, 487: 8, 442: 8, 451: 8, 452: 8, 453: 6, 479: 3, 311: 8, 500: 6, 647: 6, 193: 8, 707: 8, 197: 8, 209: 7, 199: 4, 455: 7, 313: 8, 481: 7, 485: 8, 489: 8, 249: 8, 393: 7, 407: 7, 413: 8, 422: 4, 431: 8, 501: 8, 499: 3, 810: 8, 508: 8, 381: 8, 462: 4, 532: 6, 562: 8, 386: 8, 761: 7, 573: 1, 554: 3, 719: 5, 560: 8, 1279: 4, 388: 8, 288: 5, 1005: 6, 497: 8, 844: 8, 961: 8, 967: 4, 977: 8, 979: 8, 985: 5, 1001: 8, 1017: 8, 1019: 2, 1020: 8, 1217: 8, 510: 8, 866: 4, 304: 1, 969: 8, 384: 4, 1033: 7, 1009: 8, 1034: 7, 1296: 4, 1930: 7, 1105: 5, 1013: 5, 1225: 7, 1919: 7, 320: 3, 534: 2, 352: 5, 298: 8, 1223: 2, 1233: 8, 608: 8, 1265: 8, 609: 6, 1267: 1, 1417: 8, 610: 6, 1906: 7, 611: 6, 612: 8, 613: 8, 208: 8, 564: 5, 309: 8, 1221: 5, 1280: 4, 1249: 8, 1907: 7, 1257: 6, 1300: 8, 1920: 7, 563: 5, 1322: 6, 1323: 4, 1328: 4, 1917: 7, 328: 1, 1912: 7, 1914: 7, 804: 3, 1918: 7\n  }],\n  CAR.CHEVROLET_BOLT_EUV: [{\n    189: 7, 190: 7, 193: 8, 197: 8, 201: 8, 209: 7, 211: 3, 241: 6, 257: 8, 288: 5, 289: 8, 298: 8, 304: 3, 309: 8, 311: 8, 313: 8, 320: 4, 322: 7, 328: 1, 352: 5, 381: 8, 384: 4, 386: 8, 388: 8, 451: 8, 452: 8, 453: 6, 458: 5, 463: 3, 479: 3, 481: 7, 485: 8, 489: 8, 497: 8, 500: 6, 501: 8, 528: 5, 532: 6, 560: 8, 562: 8, 563: 5, 565: 5, 566: 8, 587: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 707: 8, 715: 8, 717: 5, 753: 5, 761: 7, 789: 5, 800: 6, 810: 8, 840: 5, 842: 5, 844: 8, 848: 4, 869: 4, 880: 6, 977: 8, 1001: 8, 1017: 8, 1020: 8, 1217: 8, 1221: 5, 1233: 8, 1249: 8, 1265: 8, 1280: 4, 1296: 4, 1300: 8, 1611: 8, 1930: 7\n  }],\n  CAR.CHEVROLET_SILVERADO: [{\n    190: 6, 193: 8, 197: 8, 201: 8, 208: 8, 209: 7, 211: 2, 241: 6, 249: 8, 257: 8, 288: 5, 289: 8, 298: 8, 304: 3, 309: 8, 311: 8, 313: 8, 320: 4, 322: 7, 328: 1, 352: 5, 381: 8, 384: 4, 386: 8, 388: 8, 413: 8, 451: 8, 452: 8, 453: 6, 455: 7, 460: 5, 463: 3, 479: 3, 481: 7, 485: 8, 489: 8, 497: 8, 500: 6, 501: 8, 528: 5, 532: 6, 534: 2, 560: 8, 562: 8, 563: 5, 565: 5, 587: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 707: 8, 715: 8, 717: 5, 761: 7, 789: 5, 800: 6, 801: 8, 810: 8, 840: 5, 842: 5, 844: 8, 848: 4, 869: 4, 880: 6, 977: 8, 1001: 8, 1011: 6, 1017: 8, 1020: 8, 1033: 7, 1034: 7, 1217: 8, 1221: 5, 1233: 8, 1249: 8, 1259: 8, 1261: 7, 1263: 4, 1265: 8, 1267: 1, 1271: 8, 1280: 4, 1296: 4, 1300: 8, 1611: 8, 1930: 7\n  }],\n  CAR.CHEVROLET_EQUINOX: [{\n    190: 6, 193: 8, 197: 8, 201: 8, 209: 7, 211: 2, 241: 6, 249: 8, 257: 8, 288: 5, 289: 8, 298: 8, 304: 1, 309: 8, 311: 8, 313: 8, 320: 3, 328: 1, 352: 5, 381: 8, 384: 4, 386: 8, 388: 8, 413: 8, 451: 8, 452: 8, 453: 6, 455: 7, 463: 3, 479: 3, 481: 7, 485: 8, 489: 8, 497: 8, 500: 6, 501: 8, 510: 8, 528: 5, 532: 6, 560: 8, 562: 8, 563: 5, 565: 5, 587: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 707: 8, 715: 8, 717: 5, 753: 5, 761: 7, 789: 5, 800: 6, 810: 8, 840: 5, 842: 5, 844: 8, 869: 4, 880: 6, 977: 8, 1001: 8, 1011: 6, 1017: 8, 1020: 8, 1033: 7, 1034: 7, 1217: 8, 1221: 5, 1233: 8, 1249: 8, 1259: 8, 1261: 7, 1263: 4, 1265: 8, 1267: 1, 1271: 8, 1280: 4, 1296: 4, 1300: 8, 1611: 8, 1930: 7\n  },\n  {\n    190: 6, 201: 8, 211: 2, 717: 5, 241: 6, 451: 8, 298: 8, 452: 8, 453: 6, 479: 3, 485: 8, 249: 8, 500: 6, 587: 8, 1611: 8, 289: 8, 481: 7, 193: 8, 197: 8, 209: 7, 455: 7, 489: 8, 309: 8, 413: 8, 501: 8, 608: 8, 609: 6, 610: 6, 611: 6, 612: 8, 613: 8, 311: 8, 510: 8, 528: 5, 532: 6, 715: 8, 560: 8, 562: 8, 707: 8, 789: 5, 869: 4, 880: 6, 761: 7, 840: 5, 842: 5, 844: 8, 313: 8, 381: 8, 386: 8, 810: 8, 322: 7, 384: 4, 800: 6, 1033: 7, 1034: 7, 1296: 4, 753: 5, 388: 8, 288: 5, 497: 8, 463: 3, 304: 3, 977: 8, 1001: 8, 1280: 4, 320: 4, 352: 5, 563: 5, 565: 5, 1221: 5, 1011: 6, 1017: 8, 1020: 8, 1249: 8, 1300: 8, 328: 1, 1217: 8, 1233: 8, 1259: 8, 1261: 7, 1263: 4, 1265: 8, 1267: 1, 1930: 7, 1271: 8\n  }],\n}\n\nFW_VERSIONS: dict[str, dict[tuple, list[bytes]]] = {\n}\n", "selfdrive/car/gm/values.py": "from dataclasses import dataclass, field\n\nfrom cereal import car\nfrom openpilot.selfdrive.car import dbc_dict, PlatformConfig, DbcDict, Platforms, CarSpecs\nfrom openpilot.selfdrive.car.docs_definitions import CarHarness, CarDocs, CarParts\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries\n\nEcu = car.CarParams.Ecu\n\n\nclass CarControllerParams:\n  STEER_MAX = 300  # GM limit is 3Nm. Used by carcontroller to generate LKA output\n  STEER_STEP = 3  # Active control frames per command (~33hz)\n  INACTIVE_STEER_STEP = 10  # Inactive control frames per command (10hz)\n  STEER_DELTA_UP = 10  # Delta rates require review due to observed EPS weakness\n  STEER_DELTA_DOWN = 15\n  STEER_DRIVER_ALLOWANCE = 65\n  STEER_DRIVER_MULTIPLIER = 4\n  STEER_DRIVER_FACTOR = 100\n  NEAR_STOP_BRAKE_PHASE = 0.5  # m/s\n\n  # Heartbeat for dash \"Service Adaptive Cruise\" and \"Service Front Camera\"\n  ADAS_KEEPALIVE_STEP = 100\n  CAMERA_KEEPALIVE_STEP = 100\n\n  # Allow small margin below -3.5 m/s^2 from ISO 15622:2018 since we\n  # perform the closed loop control, and might need some\n  # to apply some more braking if we're on a downhill slope.\n  # Our controller should still keep the 2 second average above\n  # -3.5 m/s^2 as per planner limits\n  ACCEL_MAX = 2.  # m/s^2\n  ACCEL_MIN = -4.  # m/s^2\n\n  def __init__(self, CP):\n    # Gas/brake lookups\n    self.ZERO_GAS = 2048  # Coasting\n    self.MAX_BRAKE = 400  # ~ -4.0 m/s^2 with regen\n\n    if CP.carFingerprint in CAMERA_ACC_CAR:\n      self.MAX_GAS = 3400\n      self.MAX_ACC_REGEN = 1514\n      self.INACTIVE_REGEN = 1554\n      # Camera ACC vehicles have no regen while enabled.\n      # Camera transitions to MAX_ACC_REGEN from ZERO_GAS and uses friction brakes instantly\n      max_regen_acceleration = 0.\n\n    else:\n      self.MAX_GAS = 3072  # Safety limit, not ACC max. Stock ACC >4096 from standstill.\n      self.MAX_ACC_REGEN = 1404  # Max ACC regen is slightly less than max paddle regen\n      self.INACTIVE_REGEN = 1404\n      # ICE has much less engine braking force compared to regen in EVs,\n      # lower threshold removes some braking deadzone\n      max_regen_acceleration = -1. if CP.carFingerprint in EV_CAR else -0.1\n\n    self.GAS_LOOKUP_BP = [max_regen_acceleration, 0., self.ACCEL_MAX]\n    self.GAS_LOOKUP_V = [self.MAX_ACC_REGEN, self.ZERO_GAS, self.MAX_GAS]\n\n    self.BRAKE_LOOKUP_BP = [self.ACCEL_MIN, max_regen_acceleration]\n    self.BRAKE_LOOKUP_V = [self.MAX_BRAKE, 0.]\n\n\n@dataclass\nclass GMCarDocs(CarDocs):\n  package: str = \"Adaptive Cruise Control (ACC)\"\n\n  def init_make(self, CP: car.CarParams):\n    if CP.networkLocation == car.CarParams.NetworkLocation.fwdCamera:\n      self.car_parts = CarParts.common([CarHarness.gm])\n    else:\n      self.car_parts = CarParts.common([CarHarness.obd_ii])\n\n\n@dataclass(frozen=True, kw_only=True)\nclass GMCarSpecs(CarSpecs):\n  tireStiffnessFactor: float = 0.444  # not optimized yet\n\n\n@dataclass\nclass GMPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('gm_global_a_powertrain_generated', 'gm_global_a_object', chassis_dbc='gm_global_a_chassis'))\n\n\n@dataclass\nclass GMASCMPlatformConfig(GMPlatformConfig):\n  def init(self):\n    # ASCM is supported, but due to a janky install and hardware configuration, we are not showing in the car docs\n    self.car_docs = []\n\n\nclass CAR(Platforms):\n  HOLDEN_ASTRA = GMASCMPlatformConfig(\n    [GMCarDocs(\"Holden Astra 2017\")],\n    GMCarSpecs(mass=1363, wheelbase=2.662, steerRatio=15.7, centerToFrontRatio=0.4),\n  )\n  CHEVROLET_VOLT = GMASCMPlatformConfig(\n    [GMCarDocs(\"Chevrolet Volt 2017-18\", min_enable_speed=0, video_link=\"https://youtu.be/QeMCN_4TFfQ\")],\n    GMCarSpecs(mass=1607, wheelbase=2.69, steerRatio=17.7, centerToFrontRatio=0.45, tireStiffnessFactor=0.469),\n  )\n  CADILLAC_ATS = GMASCMPlatformConfig(\n    [GMCarDocs(\"Cadillac ATS Premium Performance 2018\")],\n    GMCarSpecs(mass=1601, wheelbase=2.78, steerRatio=15.3),\n  )\n  CHEVROLET_MALIBU = GMASCMPlatformConfig(\n    [GMCarDocs(\"Chevrolet Malibu Premier 2017\")],\n    GMCarSpecs(mass=1496, wheelbase=2.83, steerRatio=15.8, centerToFrontRatio=0.4),\n  )\n  GMC_ACADIA = GMASCMPlatformConfig(\n    [GMCarDocs(\"GMC Acadia 2018\", video_link=\"https://www.youtube.com/watch?v=0ZN6DdsBUZo\")],\n    GMCarSpecs(mass=1975, wheelbase=2.86, steerRatio=14.4, centerToFrontRatio=0.4),\n  )\n  BUICK_LACROSSE = GMASCMPlatformConfig(\n    [GMCarDocs(\"Buick LaCrosse 2017-19\", \"Driver Confidence Package 2\")],\n    GMCarSpecs(mass=1712, wheelbase=2.91, steerRatio=15.8, centerToFrontRatio=0.4),\n  )\n  BUICK_REGAL = GMASCMPlatformConfig(\n    [GMCarDocs(\"Buick Regal Essence 2018\")],\n    GMCarSpecs(mass=1714, wheelbase=2.83, steerRatio=14.4, centerToFrontRatio=0.4),\n  )\n  CADILLAC_ESCALADE = GMASCMPlatformConfig(\n    [GMCarDocs(\"Cadillac Escalade 2017\", \"Driver Assist Package\")],\n    GMCarSpecs(mass=2564, wheelbase=2.95, steerRatio=17.3),\n  )\n  CADILLAC_ESCALADE_ESV = GMASCMPlatformConfig(\n    [GMCarDocs(\"Cadillac Escalade ESV 2016\", \"Adaptive Cruise Control (ACC) & LKAS\")],\n    GMCarSpecs(mass=2739, wheelbase=3.302, steerRatio=17.3, tireStiffnessFactor=1.0),\n  )\n  CADILLAC_ESCALADE_ESV_2019 = GMASCMPlatformConfig(\n    [GMCarDocs(\"Cadillac Escalade ESV 2019\", \"Adaptive Cruise Control (ACC) & LKAS\")],\n    CADILLAC_ESCALADE_ESV.specs,\n  )\n  CHEVROLET_BOLT_EUV = GMPlatformConfig(\n    [\n      GMCarDocs(\"Chevrolet Bolt EUV 2022-23\", \"Premier or Premier Redline Trim without Super Cruise Package\", video_link=\"https://youtu.be/xvwzGMUA210\"),\n      GMCarDocs(\"Chevrolet Bolt EV 2022-23\", \"2LT Trim with Adaptive Cruise Control Package\"),\n    ],\n    GMCarSpecs(mass=1669, wheelbase=2.63779, steerRatio=16.8, centerToFrontRatio=0.4, tireStiffnessFactor=1.0),\n  )\n  CHEVROLET_SILVERADO = GMPlatformConfig(\n    [\n      GMCarDocs(\"Chevrolet Silverado 1500 2020-21\", \"Safety Package II\"),\n      GMCarDocs(\"GMC Sierra 1500 2020-21\", \"Driver Alert Package II\", video_link=\"https://youtu.be/5HbNoBLzRwE\"),\n    ],\n    GMCarSpecs(mass=2450, wheelbase=3.75, steerRatio=16.3, tireStiffnessFactor=1.0),\n  )\n  CHEVROLET_EQUINOX = GMPlatformConfig(\n    [GMCarDocs(\"Chevrolet Equinox 2019-22\")],\n    GMCarSpecs(mass=1588, wheelbase=2.72, steerRatio=14.4, centerToFrontRatio=0.4),\n  )\n  CHEVROLET_TRAILBLAZER = GMPlatformConfig(\n    [GMCarDocs(\"Chevrolet Trailblazer 2021-22\")],\n    GMCarSpecs(mass=1345, wheelbase=2.64, steerRatio=16.8, centerToFrontRatio=0.4, tireStiffnessFactor=1.0),\n  )\n\n\nclass CruiseButtons:\n  INIT = 0\n  UNPRESS = 1\n  RES_ACCEL = 2\n  DECEL_SET = 3\n  MAIN = 5\n  CANCEL = 6\n\nclass AccState:\n  OFF = 0\n  ACTIVE = 1\n  FAULTED = 3\n  STANDSTILL = 4\n\nclass CanBus:\n  POWERTRAIN = 0\n  OBSTACLE = 1\n  CAMERA = 2\n  CHASSIS = 2\n  LOOPBACK = 128\n  DROPPED = 192\n\n\n# In a Data Module, an identifier is a string used to recognize an object,\n# either by itself or together with the identifiers of parent objects.\n# Each returns a 4 byte hex representation of the decimal part number. `b\"\\x02\\x8c\\xf0'\"` -> 42790951\nGM_BOOT_SOFTWARE_PART_NUMER_REQUEST = b'\\x1a\\xc0'  # likely does not contain anything useful\nGM_SOFTWARE_MODULE_1_REQUEST = b'\\x1a\\xc1'\nGM_SOFTWARE_MODULE_2_REQUEST = b'\\x1a\\xc2'\nGM_SOFTWARE_MODULE_3_REQUEST = b'\\x1a\\xc3'\n\n# Part number of XML data file that is used to configure ECU\nGM_XML_DATA_FILE_PART_NUMBER = b'\\x1a\\x9c'\nGM_XML_CONFIG_COMPAT_ID = b'\\x1a\\x9b'  # used to know if XML file is compatible with the ECU software/hardware\n\n# This DID is for identifying the part number that reflects the mix of hardware,\n# software, and calibrations in the ECU when it first arrives at the vehicle assembly plant.\n# If there's an Alpha Code, it's associated with this part number and stored in the DID $DB.\nGM_END_MODEL_PART_NUMBER_REQUEST = b'\\x1a\\xcb'\nGM_END_MODEL_PART_NUMBER_ALPHA_CODE_REQUEST = b'\\x1a\\xdb'\nGM_BASE_MODEL_PART_NUMBER_REQUEST = b'\\x1a\\xcc'\nGM_BASE_MODEL_PART_NUMBER_ALPHA_CODE_REQUEST = b'\\x1a\\xdc'\nGM_FW_RESPONSE = b'\\x5a'\n\nGM_FW_REQUESTS = [\n  GM_BOOT_SOFTWARE_PART_NUMER_REQUEST,\n  GM_SOFTWARE_MODULE_1_REQUEST,\n  GM_SOFTWARE_MODULE_2_REQUEST,\n  GM_SOFTWARE_MODULE_3_REQUEST,\n  GM_XML_DATA_FILE_PART_NUMBER,\n  GM_XML_CONFIG_COMPAT_ID,\n  GM_END_MODEL_PART_NUMBER_REQUEST,\n  GM_END_MODEL_PART_NUMBER_ALPHA_CODE_REQUEST,\n  GM_BASE_MODEL_PART_NUMBER_REQUEST,\n  GM_BASE_MODEL_PART_NUMBER_ALPHA_CODE_REQUEST,\n]\n\nGM_RX_OFFSET = 0x400\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[request for req in GM_FW_REQUESTS for request in [\n    Request(\n      [StdQueries.SHORT_TESTER_PRESENT_REQUEST, req],\n      [StdQueries.SHORT_TESTER_PRESENT_RESPONSE, GM_FW_RESPONSE + bytes([req[-1]])],\n      rx_offset=GM_RX_OFFSET,\n      bus=0,\n      logging=True,\n    ),\n  ]],\n  extra_ecus=[(Ecu.fwdCamera, 0x24b, None)],\n)\n\nEV_CAR = {CAR.CHEVROLET_VOLT, CAR.CHEVROLET_BOLT_EUV}\n\n# We're integrated at the camera with VOACC on these cars (instead of ASCM w/ OBD-II harness)\nCAMERA_ACC_CAR = {CAR.CHEVROLET_BOLT_EUV, CAR.CHEVROLET_SILVERADO, CAR.CHEVROLET_EQUINOX, CAR.CHEVROLET_TRAILBLAZER}\n\nSTEER_THRESHOLD = 1.0\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/gm/carcontroller.py": "from cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import interp\nfrom openpilot.common.realtime import DT_CTRL\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car import apply_driver_steer_torque_limits\nfrom openpilot.selfdrive.car.gm import gmcan\nfrom openpilot.selfdrive.car.gm.values import DBC, CanBus, CarControllerParams, CruiseButtons\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\nNetworkLocation = car.CarParams.NetworkLocation\nLongCtrlState = car.CarControl.Actuators.LongControlState\n\n# Camera cancels up to 0.1s after brake is pressed, ECM allows 0.5s\nCAMERA_CANCEL_DELAY_FRAMES = 10\n# Enforce a minimum interval between steering messages to avoid a fault\nMIN_STEER_MSG_INTERVAL_MS = 15\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.start_time = 0.\n    self.apply_steer_last = 0\n    self.apply_gas = 0\n    self.apply_brake = 0\n    self.frame = 0\n    self.last_steer_frame = 0\n    self.last_button_frame = 0\n    self.cancel_counter = 0\n\n    self.lka_steering_cmd_counter = 0\n    self.lka_icon_status_last = (False, False)\n\n    self.params = CarControllerParams(self.CP)\n\n    self.packer_pt = CANPacker(DBC[self.CP.carFingerprint]['pt'])\n    self.packer_obj = CANPacker(DBC[self.CP.carFingerprint]['radar'])\n    self.packer_ch = CANPacker(DBC[self.CP.carFingerprint]['chassis'])\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n    hud_alert = hud_control.visualAlert\n    hud_v_cruise = hud_control.setSpeed\n    if hud_v_cruise > 70:\n      hud_v_cruise = 0\n\n    # Send CAN commands.\n    can_sends = []\n\n    # Steering (Active: 50Hz, inactive: 10Hz)\n    steer_step = self.params.STEER_STEP if CC.latActive else self.params.INACTIVE_STEER_STEP\n\n    if self.CP.networkLocation == NetworkLocation.fwdCamera:\n      # Also send at 50Hz:\n      # - on startup, first few msgs are blocked\n      # - until we're in sync with camera so counters align when relay closes, preventing a fault.\n      #   openpilot can subtly drift, so this is activated throughout a drive to stay synced\n      out_of_sync = self.lka_steering_cmd_counter % 4 != (CS.cam_lka_steering_cmd_counter + 1) % 4\n      if CS.loopback_lka_steering_cmd_ts_nanos == 0 or out_of_sync:\n        steer_step = self.params.STEER_STEP\n\n    self.lka_steering_cmd_counter += 1 if CS.loopback_lka_steering_cmd_updated else 0\n\n    # Avoid GM EPS faults when transmitting messages too close together: skip this transmit if we\n    # received the ASCMLKASteeringCmd loopback confirmation too recently\n    last_lka_steer_msg_ms = (now_nanos - CS.loopback_lka_steering_cmd_ts_nanos) * 1e-6\n    if (self.frame - self.last_steer_frame) >= steer_step and last_lka_steer_msg_ms > MIN_STEER_MSG_INTERVAL_MS:\n      # Initialize ASCMLKASteeringCmd counter using the camera until we get a msg on the bus\n      if CS.loopback_lka_steering_cmd_ts_nanos == 0:\n        self.lka_steering_cmd_counter = CS.pt_lka_steering_cmd_counter + 1\n\n      if CC.latActive:\n        new_steer = int(round(actuators.steer * self.params.STEER_MAX))\n        apply_steer = apply_driver_steer_torque_limits(new_steer, self.apply_steer_last, CS.out.steeringTorque, self.params)\n      else:\n        apply_steer = 0\n\n      self.last_steer_frame = self.frame\n      self.apply_steer_last = apply_steer\n      idx = self.lka_steering_cmd_counter % 4\n      can_sends.append(gmcan.create_steering_control(self.packer_pt, CanBus.POWERTRAIN, apply_steer, idx, CC.latActive))\n\n    if self.CP.openpilotLongitudinalControl:\n      # Gas/regen, brakes, and UI commands - all at 25Hz\n      if self.frame % 4 == 0:\n        stopping = actuators.longControlState == LongCtrlState.stopping\n        if not CC.longActive:\n          # ASCM sends max regen when not enabled\n          self.apply_gas = self.params.INACTIVE_REGEN\n          self.apply_brake = 0\n        else:\n          self.apply_gas = int(round(interp(actuators.accel, self.params.GAS_LOOKUP_BP, self.params.GAS_LOOKUP_V)))\n          self.apply_brake = int(round(interp(actuators.accel, self.params.BRAKE_LOOKUP_BP, self.params.BRAKE_LOOKUP_V)))\n          # Don't allow any gas above inactive regen while stopping\n          # FIXME: brakes aren't applied immediately when enabling at a stop\n          if stopping:\n            self.apply_gas = self.params.INACTIVE_REGEN\n\n        idx = (self.frame // 4) % 4\n\n        at_full_stop = CC.longActive and CS.out.standstill\n        near_stop = CC.longActive and (CS.out.vEgo < self.params.NEAR_STOP_BRAKE_PHASE)\n        friction_brake_bus = CanBus.CHASSIS\n        # GM Camera exceptions\n        # TODO: can we always check the longControlState?\n        if self.CP.networkLocation == NetworkLocation.fwdCamera:\n          at_full_stop = at_full_stop and stopping\n          friction_brake_bus = CanBus.POWERTRAIN\n\n        # GasRegenCmdActive needs to be 1 to avoid cruise faults. It describes the ACC state, not actuation\n        can_sends.append(gmcan.create_gas_regen_command(self.packer_pt, CanBus.POWERTRAIN, self.apply_gas, idx, CC.enabled, at_full_stop))\n        can_sends.append(gmcan.create_friction_brake_command(self.packer_ch, friction_brake_bus, self.apply_brake,\n                                                             idx, CC.enabled, near_stop, at_full_stop, self.CP))\n\n        # Send dashboard UI commands (ACC status)\n        send_fcw = hud_alert == VisualAlert.fcw\n        can_sends.append(gmcan.create_acc_dashboard_command(self.packer_pt, CanBus.POWERTRAIN, CC.enabled,\n                                                            hud_v_cruise * CV.MS_TO_KPH, hud_control, send_fcw))\n\n      # Radar needs to know current speed and yaw rate (50hz),\n      # and that ADAS is alive (10hz)\n      if not self.CP.radarUnavailable:\n        tt = self.frame * DT_CTRL\n        time_and_headlights_step = 10\n        if self.frame % time_and_headlights_step == 0:\n          idx = (self.frame // time_and_headlights_step) % 4\n          can_sends.append(gmcan.create_adas_time_status(CanBus.OBSTACLE, int((tt - self.start_time) * 60), idx))\n          can_sends.append(gmcan.create_adas_headlights_status(self.packer_obj, CanBus.OBSTACLE))\n\n        speed_and_accelerometer_step = 2\n        if self.frame % speed_and_accelerometer_step == 0:\n          idx = (self.frame // speed_and_accelerometer_step) % 4\n          can_sends.append(gmcan.create_adas_steering_status(CanBus.OBSTACLE, idx))\n          can_sends.append(gmcan.create_adas_accelerometer_speed_status(CanBus.OBSTACLE, CS.out.vEgo, idx))\n\n      if self.CP.networkLocation == NetworkLocation.gateway and self.frame % self.params.ADAS_KEEPALIVE_STEP == 0:\n        can_sends += gmcan.create_adas_keepalive(CanBus.POWERTRAIN)\n\n    else:\n      # While car is braking, cancel button causes ECM to enter a soft disable state with a fault status.\n      # A delayed cancellation allows camera to cancel and avoids a fault when user depresses brake quickly\n      self.cancel_counter = self.cancel_counter + 1 if CC.cruiseControl.cancel else 0\n\n      # Stock longitudinal, integrated at camera\n      if (self.frame - self.last_button_frame) * DT_CTRL > 0.04:\n        if self.cancel_counter > CAMERA_CANCEL_DELAY_FRAMES:\n          self.last_button_frame = self.frame\n          can_sends.append(gmcan.create_buttons(self.packer_pt, CanBus.CAMERA, CS.buttons_counter, CruiseButtons.CANCEL))\n\n    if self.CP.networkLocation == NetworkLocation.fwdCamera:\n      # Silence \"Take Steering\" alert sent by camera, forward PSCMStatus with HandsOffSWlDetectionStatus=1\n      if self.frame % 10 == 0:\n        can_sends.append(gmcan.create_pscm_status(self.packer_pt, CanBus.CAMERA, CS.pscm_status))\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steer = self.apply_steer_last / self.params.STEER_MAX\n    new_actuators.steerOutputCan = self.apply_steer_last\n    new_actuators.gas = self.apply_gas\n    new_actuators.brake = self.apply_brake\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/gm/radar_interface.py": "#!/usr/bin/env python3\nimport math\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.gm.values import DBC, CanBus\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nRADAR_HEADER_MSG = 1120\nSLOT_1_MSG = RADAR_HEADER_MSG + 1\nNUM_SLOTS = 20\n\n# Actually it's 0x47f, but can parser only reports\n# messages that are present in DBC\nLAST_RADAR_MSG = RADAR_HEADER_MSG + NUM_SLOTS\n\n\ndef create_radar_can_parser(car_fingerprint):\n  # C1A-ARS3-A by Continental\n  radar_targets = list(range(SLOT_1_MSG, SLOT_1_MSG + NUM_SLOTS))\n  signals = list(zip(['FLRRNumValidTargets',\n                      'FLRRSnsrBlckd', 'FLRRYawRtPlsblityFlt',\n                      'FLRRHWFltPrsntInt', 'FLRRAntTngFltPrsnt',\n                      'FLRRAlgnFltPrsnt', 'FLRRSnstvFltPrsntInt'] +\n                     ['TrkRange'] * NUM_SLOTS + ['TrkRangeRate'] * NUM_SLOTS +\n                     ['TrkRangeAccel'] * NUM_SLOTS + ['TrkAzimuth'] * NUM_SLOTS +\n                     ['TrkWidth'] * NUM_SLOTS + ['TrkObjectID'] * NUM_SLOTS,\n                     [RADAR_HEADER_MSG] * 7 + radar_targets * 6, strict=True))\n\n  messages = list({(s[1], 14) for s in signals})\n\n  return CANParser(DBC[car_fingerprint]['radar'], messages, CanBus.OBSTACLE)\n\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n\n    self.rcp = None if CP.radarUnavailable else create_radar_can_parser(CP.carFingerprint)\n\n    self.trigger_msg = LAST_RADAR_MSG\n    self.updated_messages = set()\n    self.radar_ts = CP.radarTimeStep\n\n  def update(self, can_strings):\n    if self.rcp is None:\n      return super().update(None)\n\n    vls = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(vls)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    ret = car.RadarData.new_message()\n    header = self.rcp.vl[RADAR_HEADER_MSG]\n    fault = header['FLRRSnsrBlckd'] or header['FLRRSnstvFltPrsntInt'] or \\\n      header['FLRRYawRtPlsblityFlt'] or header['FLRRHWFltPrsntInt'] or \\\n      header['FLRRAntTngFltPrsnt'] or header['FLRRAlgnFltPrsnt']\n    errors = []\n    if not self.rcp.can_valid:\n      errors.append(\"canError\")\n    if fault:\n      errors.append(\"fault\")\n    ret.errors = errors\n\n    currentTargets = set()\n    num_targets = header['FLRRNumValidTargets']\n\n    # Not all radar messages describe targets,\n    # no need to monitor all of the self.rcp.msgs_upd\n    for ii in self.updated_messages:\n      if ii == RADAR_HEADER_MSG:\n        continue\n\n      if num_targets == 0:\n        break\n\n      cpt = self.rcp.vl[ii]\n      # Zero distance means it's an empty target slot\n      if cpt['TrkRange'] > 0.0:\n        targetId = cpt['TrkObjectID']\n        currentTargets.add(targetId)\n        if targetId not in self.pts:\n          self.pts[targetId] = car.RadarData.RadarPoint.new_message()\n          self.pts[targetId].trackId = targetId\n        distance = cpt['TrkRange']\n        self.pts[targetId].dRel = distance  # from front of car\n        # From driver's pov, left is positive\n        self.pts[targetId].yRel = math.sin(cpt['TrkAzimuth'] * CV.DEG_TO_RAD) * distance\n        self.pts[targetId].vRel = cpt['TrkRangeRate']\n        self.pts[targetId].aRel = float('nan')\n        self.pts[targetId].yvRel = float('nan')\n\n    for oldTarget in list(self.pts.keys()):\n      if oldTarget not in currentTargets:\n        del self.pts[oldTarget]\n\n    ret.points = list(self.pts.values())\n    self.updated_messages.clear()\n    return ret\n", "selfdrive/car/gm/__init__.py": "", "selfdrive/car/gm/interface.py": "#!/usr/bin/env python3\nimport os\nfrom cereal import car\nfrom math import fabs, exp\nfrom panda import Panda\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.gm.radar_interface import RADAR_HEADER_MSG\nfrom openpilot.selfdrive.car.gm.values import CAR, CruiseButtons, CarControllerParams, EV_CAR, CAMERA_ACC_CAR, CanBus\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase, TorqueFromLateralAccelCallbackType, FRICTION_THRESHOLD, LatControlInputs, NanoFFModel\nfrom openpilot.selfdrive.controls.lib.drive_helpers import get_friction\n\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\nGearShifter = car.CarState.GearShifter\nTransmissionType = car.CarParams.TransmissionType\nNetworkLocation = car.CarParams.NetworkLocation\nBUTTONS_DICT = {CruiseButtons.RES_ACCEL: ButtonType.accelCruise, CruiseButtons.DECEL_SET: ButtonType.decelCruise,\n                CruiseButtons.MAIN: ButtonType.altButton3, CruiseButtons.CANCEL: ButtonType.cancel}\n\n\nNON_LINEAR_TORQUE_PARAMS = {\n  CAR.CHEVROLET_BOLT_EUV: [2.6531724862969748, 1.0, 0.1919764879840985, 0.009054123646805178],\n  CAR.GMC_ACADIA: [4.78003305, 1.0, 0.3122, 0.05591772],\n  CAR.CHEVROLET_SILVERADO: [3.29974374, 1.0, 0.25571356, 0.0465122]\n}\n\nNEURAL_PARAMS_PATH = os.path.join(BASEDIR, 'selfdrive/car/torque_data/neural_ff_weights.json')\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def get_pid_accel_limits(CP, current_speed, cruise_speed):\n    return CarControllerParams.ACCEL_MIN, CarControllerParams.ACCEL_MAX\n\n  # Determined by iteratively plotting and minimizing error for f(angle, speed) = steer.\n  @staticmethod\n  def get_steer_feedforward_volt(desired_angle, v_ego):\n    desired_angle *= 0.02904609\n    sigmoid = desired_angle / (1 + fabs(desired_angle))\n    return 0.10006696 * sigmoid * (v_ego + 3.12485927)\n\n  def get_steer_feedforward_function(self):\n    if self.CP.carFingerprint == CAR.CHEVROLET_VOLT:\n      return self.get_steer_feedforward_volt\n    else:\n      return CarInterfaceBase.get_steer_feedforward_default\n\n  def torque_from_lateral_accel_siglin(self, latcontrol_inputs: LatControlInputs, torque_params: car.CarParams.LateralTorqueTuning, lateral_accel_error: float,\n                                       lateral_accel_deadzone: float, friction_compensation: bool, gravity_adjusted: bool) -> float:\n    friction = get_friction(lateral_accel_error, lateral_accel_deadzone, FRICTION_THRESHOLD, torque_params, friction_compensation)\n\n    def sig(val):\n      return 1 / (1 + exp(-val)) - 0.5\n\n    # The \"lat_accel vs torque\" relationship is assumed to be the sum of \"sigmoid + linear\" curves\n    # An important thing to consider is that the slope at 0 should be > 0 (ideally >1)\n    # This has big effect on the stability about 0 (noise when going straight)\n    # ToDo: To generalize to other GMs, explore tanh function as the nonlinear\n    non_linear_torque_params = NON_LINEAR_TORQUE_PARAMS.get(self.CP.carFingerprint)\n    assert non_linear_torque_params, \"The params are not defined\"\n    a, b, c, _ = non_linear_torque_params\n    steer_torque = (sig(latcontrol_inputs.lateral_acceleration * a) * b) + (latcontrol_inputs.lateral_acceleration * c)\n    return float(steer_torque) + friction\n\n  def torque_from_lateral_accel_neural(self, latcontrol_inputs: LatControlInputs, torque_params: car.CarParams.LateralTorqueTuning, lateral_accel_error: float,\n                                       lateral_accel_deadzone: float, friction_compensation: bool, gravity_adjusted: bool) -> float:\n    friction = get_friction(lateral_accel_error, lateral_accel_deadzone, FRICTION_THRESHOLD, torque_params, friction_compensation)\n    inputs = list(latcontrol_inputs)\n    if gravity_adjusted:\n      inputs[0] += inputs[1]\n    return float(self.neural_ff_model.predict(inputs)) + friction\n\n  def torque_from_lateral_accel(self) -> TorqueFromLateralAccelCallbackType:\n    if self.CP.carFingerprint == CAR.CHEVROLET_BOLT_EUV:\n      self.neural_ff_model = NanoFFModel(NEURAL_PARAMS_PATH, self.CP.carFingerprint)\n      return self.torque_from_lateral_accel_neural\n    elif self.CP.carFingerprint in NON_LINEAR_TORQUE_PARAMS:\n      return self.torque_from_lateral_accel_siglin\n    else:\n      return self.torque_from_lateral_accel_linear\n\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"gm\"\n    ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.gm)]\n    ret.autoResumeSng = False\n    ret.enableBsm = 0x142 in fingerprint[CanBus.POWERTRAIN]\n\n    if candidate in EV_CAR:\n      ret.transmissionType = TransmissionType.direct\n    else:\n      ret.transmissionType = TransmissionType.automatic\n\n    ret.longitudinalTuning.kiBP = [5., 35.]\n\n    if candidate in CAMERA_ACC_CAR:\n      ret.experimentalLongitudinalAvailable = True\n      ret.networkLocation = NetworkLocation.fwdCamera\n      ret.radarUnavailable = True  # no radar\n      ret.pcmCruise = True\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_GM_HW_CAM\n      ret.minEnableSpeed = 5 * CV.KPH_TO_MS\n      ret.minSteerSpeed = 10 * CV.KPH_TO_MS\n\n      # Tuning for experimental long\n      ret.longitudinalTuning.kiV = [2.0, 1.5]\n      ret.stoppingDecelRate = 2.0  # reach brake quickly after enabling\n      ret.vEgoStopping = 0.25\n      ret.vEgoStarting = 0.25\n\n      if experimental_long:\n        ret.pcmCruise = False\n        ret.openpilotLongitudinalControl = True\n        ret.safetyConfigs[0].safetyParam |= Panda.FLAG_GM_HW_CAM_LONG\n\n    else:  # ASCM, OBD-II harness\n      ret.openpilotLongitudinalControl = True\n      ret.networkLocation = NetworkLocation.gateway\n      ret.radarUnavailable = RADAR_HEADER_MSG not in fingerprint[CanBus.OBSTACLE] and not docs\n      ret.pcmCruise = False  # stock non-adaptive cruise control is kept off\n      # supports stop and go, but initial engage must (conservatively) be above 18mph\n      ret.minEnableSpeed = 18 * CV.MPH_TO_MS\n      ret.minSteerSpeed = 7 * CV.MPH_TO_MS\n\n      # Tuning\n      ret.longitudinalTuning.kiV = [2.4, 1.5]\n\n    # These cars have been put into dashcam only due to both a lack of users and test coverage.\n    # These cars likely still work fine. Once a user confirms each car works and a test route is\n    # added to selfdrive/car/tests/routes.py, we can remove it from this list.\n    ret.dashcamOnly = candidate in {CAR.CADILLAC_ATS, CAR.HOLDEN_ASTRA, CAR.CHEVROLET_MALIBU, CAR.BUICK_REGAL} or \\\n                      (ret.networkLocation == NetworkLocation.gateway and ret.radarUnavailable)\n\n    # Start with a baseline tuning for all GM vehicles. Override tuning as needed in each model section below.\n    ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[0.], [0.]]\n    ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.2], [0.00]]\n    ret.lateralTuning.pid.kf = 0.00004   # full torque for 20 deg at 80mph means 0.00007818594\n    ret.steerActuatorDelay = 0.1  # Default delay, not measured yet\n\n    ret.steerLimitTimer = 0.4\n    ret.radarTimeStep = 0.0667  # GM radar runs at 15Hz instead of standard 20Hz\n    ret.longitudinalActuatorDelay = 0.5  # large delay to initially start braking\n\n    if candidate == CAR.CHEVROLET_VOLT:\n      ret.lateralTuning.pid.kpBP = [0., 40.]\n      ret.lateralTuning.pid.kpV = [0., 0.17]\n      ret.lateralTuning.pid.kiBP = [0.]\n      ret.lateralTuning.pid.kiV = [0.]\n      ret.lateralTuning.pid.kf = 1.  # get_steer_feedforward_volt()\n      ret.steerActuatorDelay = 0.2\n\n    elif candidate == CAR.GMC_ACADIA:\n      ret.minEnableSpeed = -1.  # engage speed is decided by pcm\n      ret.steerActuatorDelay = 0.2\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate == CAR.BUICK_LACROSSE:\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate == CAR.CADILLAC_ESCALADE:\n      ret.minEnableSpeed = -1.  # engage speed is decided by pcm\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate in (CAR.CADILLAC_ESCALADE_ESV, CAR.CADILLAC_ESCALADE_ESV_2019):\n      ret.minEnableSpeed = -1.  # engage speed is decided by pcm\n\n      if candidate == CAR.CADILLAC_ESCALADE_ESV:\n        ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[10., 41.0], [10., 41.0]]\n        ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.13, 0.24], [0.01, 0.02]]\n        ret.lateralTuning.pid.kf = 0.000045\n      else:\n        ret.steerActuatorDelay = 0.2\n        CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate == CAR.CHEVROLET_BOLT_EUV:\n      ret.steerActuatorDelay = 0.2\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate == CAR.CHEVROLET_SILVERADO:\n      # On the Bolt, the ECM and camera independently check that you are either above 5 kph or at a stop\n      # with foot on brake to allow engagement, but this platform only has that check in the camera.\n      # TODO: check if this is split by EV/ICE with more platforms in the future\n      if ret.openpilotLongitudinalControl:\n        ret.minEnableSpeed = -1.\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate == CAR.CHEVROLET_EQUINOX:\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    elif candidate == CAR.CHEVROLET_TRAILBLAZER:\n      ret.steerActuatorDelay = 0.2\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    return ret\n\n  # returns a car.CarState\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam, self.cp_loopback)\n\n    # Don't add event if transitioning from INIT, unless it's to an actual button\n    if self.CS.cruise_buttons != CruiseButtons.UNPRESS or self.CS.prev_cruise_buttons != CruiseButtons.INIT:\n      ret.buttonEvents = [\n        *create_button_events(self.CS.cruise_buttons, self.CS.prev_cruise_buttons, BUTTONS_DICT,\n                              unpressed_btn=CruiseButtons.UNPRESS),\n        *create_button_events(self.CS.distance_button, self.CS.prev_distance_button,\n                              {1: ButtonType.gapAdjustCruise})\n      ]\n\n    # The ECM allows enabling on falling edge of set, but only rising edge of resume\n    events = self.create_common_events(ret, extra_gears=[GearShifter.sport, GearShifter.low,\n                                                         GearShifter.eco, GearShifter.manumatic],\n                                       pcm_enable=self.CP.pcmCruise, enable_buttons=(ButtonType.decelCruise,))\n    if not self.CP.pcmCruise:\n      if any(b.type == ButtonType.accelCruise and b.pressed for b in ret.buttonEvents):\n        events.add(EventName.buttonEnable)\n\n    # Enabling at a standstill with brake is allowed\n    # TODO: verify 17 Volt can enable for the first time at a stop and allow for all GMs\n    below_min_enable_speed = ret.vEgo < self.CP.minEnableSpeed or self.CS.moving_backward\n    if below_min_enable_speed and not (ret.standstill and ret.brake >= 20 and\n                                       self.CP.networkLocation == NetworkLocation.fwdCamera):\n      events.add(EventName.belowEngageSpeed)\n    if ret.cruiseState.standstill:\n      events.add(EventName.resumeRequired)\n    if ret.vEgo < self.CP.minSteerSpeed:\n      events.add(EventName.belowSteerSpeed)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/hyundai/carstate.py": "from collections import deque\nimport copy\nimport math\n\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom opendbc.can.parser import CANParser\nfrom opendbc.can.can_define import CANDefine\nfrom openpilot.selfdrive.car.hyundai.hyundaicanfd import CanBus\nfrom openpilot.selfdrive.car.hyundai.values import HyundaiFlags, CAR, DBC, CAN_GEARS, CAMERA_SCC_CAR, \\\n                                                   CANFD_CAR, Buttons, CarControllerParams\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\n\nPREV_BUTTON_SAMPLES = 8\nCLUSTER_SAMPLE_RATE = 20  # frames\nSTANDSTILL_THRESHOLD = 12 * 0.03125 * CV.KPH_TO_MS\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n\n    self.cruise_buttons = deque([Buttons.NONE] * PREV_BUTTON_SAMPLES, maxlen=PREV_BUTTON_SAMPLES)\n    self.main_buttons = deque([Buttons.NONE] * PREV_BUTTON_SAMPLES, maxlen=PREV_BUTTON_SAMPLES)\n\n    self.gear_msg_canfd = \"GEAR_ALT\" if CP.flags & HyundaiFlags.CANFD_ALT_GEARS else \\\n                          \"GEAR_ALT_2\" if CP.flags & HyundaiFlags.CANFD_ALT_GEARS_2 else \\\n                          \"GEAR_SHIFTER\"\n    if CP.carFingerprint in CANFD_CAR:\n      self.shifter_values = can_define.dv[self.gear_msg_canfd][\"GEAR\"]\n    elif self.CP.carFingerprint in CAN_GEARS[\"use_cluster_gears\"]:\n      self.shifter_values = can_define.dv[\"CLU15\"][\"CF_Clu_Gear\"]\n    elif self.CP.carFingerprint in CAN_GEARS[\"use_tcu_gears\"]:\n      self.shifter_values = can_define.dv[\"TCU12\"][\"CUR_GR\"]\n    else:  # preferred and elect gear methods use same definition\n      self.shifter_values = can_define.dv[\"LVR12\"][\"CF_Lvr_Gear\"]\n\n    self.accelerator_msg_canfd = \"ACCELERATOR\" if CP.flags & HyundaiFlags.EV else \\\n                                 \"ACCELERATOR_ALT\" if CP.flags & HyundaiFlags.HYBRID else \\\n                                 \"ACCELERATOR_BRAKE_ALT\"\n    self.cruise_btns_msg_canfd = \"CRUISE_BUTTONS_ALT\" if CP.flags & HyundaiFlags.CANFD_ALT_BUTTONS else \\\n                                 \"CRUISE_BUTTONS\"\n    self.is_metric = False\n    self.buttons_counter = 0\n\n    self.cruise_info = {}\n\n    # On some cars, CLU15->CF_Clu_VehicleSpeed can oscillate faster than the dash updates. Sample at 5 Hz\n    self.cluster_speed = 0\n    self.cluster_speed_counter = CLUSTER_SAMPLE_RATE\n\n    self.params = CarControllerParams(CP)\n\n  def update(self, cp, cp_cam):\n    if self.CP.carFingerprint in CANFD_CAR:\n      return self.update_canfd(cp, cp_cam)\n\n    ret = car.CarState.new_message()\n    cp_cruise = cp_cam if self.CP.carFingerprint in CAMERA_SCC_CAR else cp\n    self.is_metric = cp.vl[\"CLU11\"][\"CF_Clu_SPEED_UNIT\"] == 0\n    speed_conv = CV.KPH_TO_MS if self.is_metric else CV.MPH_TO_MS\n\n    ret.doorOpen = any([cp.vl[\"CGW1\"][\"CF_Gway_DrvDrSw\"], cp.vl[\"CGW1\"][\"CF_Gway_AstDrSw\"],\n                        cp.vl[\"CGW2\"][\"CF_Gway_RLDrSw\"], cp.vl[\"CGW2\"][\"CF_Gway_RRDrSw\"]])\n\n    ret.seatbeltUnlatched = cp.vl[\"CGW1\"][\"CF_Gway_DrvSeatBeltSw\"] == 0\n\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"WHL_SPD11\"][\"WHL_SPD_FL\"],\n      cp.vl[\"WHL_SPD11\"][\"WHL_SPD_FR\"],\n      cp.vl[\"WHL_SPD11\"][\"WHL_SPD_RL\"],\n      cp.vl[\"WHL_SPD11\"][\"WHL_SPD_RR\"],\n    )\n    ret.vEgoRaw = (ret.wheelSpeeds.fl + ret.wheelSpeeds.fr + ret.wheelSpeeds.rl + ret.wheelSpeeds.rr) / 4.\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = ret.wheelSpeeds.fl <= STANDSTILL_THRESHOLD and ret.wheelSpeeds.rr <= STANDSTILL_THRESHOLD\n\n    self.cluster_speed_counter += 1\n    if self.cluster_speed_counter > CLUSTER_SAMPLE_RATE:\n      self.cluster_speed = cp.vl[\"CLU15\"][\"CF_Clu_VehicleSpeed\"]\n      self.cluster_speed_counter = 0\n\n      # Mimic how dash converts to imperial.\n      # Sorento is the only platform where CF_Clu_VehicleSpeed is already imperial when not is_metric\n      # TODO: CGW_USM1->CF_Gway_DrLockSoundRValue may describe this\n      if not self.is_metric and self.CP.carFingerprint not in (CAR.KIA_SORENTO,):\n        self.cluster_speed = math.floor(self.cluster_speed * CV.KPH_TO_MPH + CV.KPH_TO_MPH)\n\n    ret.vEgoCluster = self.cluster_speed * speed_conv\n\n    ret.steeringAngleDeg = cp.vl[\"SAS11\"][\"SAS_Angle\"]\n    ret.steeringRateDeg = cp.vl[\"SAS11\"][\"SAS_Speed\"]\n    ret.yawRate = cp.vl[\"ESP12\"][\"YAW_RATE\"]\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_lamp(\n      50, cp.vl[\"CGW1\"][\"CF_Gway_TurnSigLh\"], cp.vl[\"CGW1\"][\"CF_Gway_TurnSigRh\"])\n    ret.steeringTorque = cp.vl[\"MDPS12\"][\"CR_Mdps_StrColTq\"]\n    ret.steeringTorqueEps = cp.vl[\"MDPS12\"][\"CR_Mdps_OutTq\"]\n    ret.steeringPressed = self.update_steering_pressed(abs(ret.steeringTorque) > self.params.STEER_THRESHOLD, 5)\n    ret.steerFaultTemporary = cp.vl[\"MDPS12\"][\"CF_Mdps_ToiUnavail\"] != 0 or cp.vl[\"MDPS12\"][\"CF_Mdps_ToiFlt\"] != 0\n\n    # cruise state\n    if self.CP.openpilotLongitudinalControl:\n      # These are not used for engage/disengage since openpilot keeps track of state using the buttons\n      ret.cruiseState.available = cp.vl[\"TCS13\"][\"ACCEnable\"] == 0\n      ret.cruiseState.enabled = cp.vl[\"TCS13\"][\"ACC_REQ\"] == 1\n      ret.cruiseState.standstill = False\n      ret.cruiseState.nonAdaptive = False\n    else:\n      ret.cruiseState.available = cp_cruise.vl[\"SCC11\"][\"MainMode_ACC\"] == 1\n      ret.cruiseState.enabled = cp_cruise.vl[\"SCC12\"][\"ACCMode\"] != 0\n      ret.cruiseState.standstill = cp_cruise.vl[\"SCC11\"][\"SCCInfoDisplay\"] == 4.\n      ret.cruiseState.nonAdaptive = cp_cruise.vl[\"SCC11\"][\"SCCInfoDisplay\"] == 2.  # Shows 'Cruise Control' on dash\n      ret.cruiseState.speed = cp_cruise.vl[\"SCC11\"][\"VSetDis\"] * speed_conv\n\n    # TODO: Find brake pressure\n    ret.brake = 0\n    ret.brakePressed = cp.vl[\"TCS13\"][\"DriverOverride\"] == 2  # 2 includes regen braking by user on HEV/EV\n    ret.brakeHoldActive = cp.vl[\"TCS15\"][\"AVH_LAMP\"] == 2  # 0 OFF, 1 ERROR, 2 ACTIVE, 3 READY\n    ret.parkingBrake = cp.vl[\"TCS13\"][\"PBRAKE_ACT\"] == 1\n    ret.espDisabled = cp.vl[\"TCS11\"][\"TCS_PAS\"] == 1\n    ret.espActive = cp.vl[\"TCS11\"][\"ABS_ACT\"] == 1\n    ret.accFaulted = cp.vl[\"TCS13\"][\"ACCEnable\"] != 0  # 0 ACC CONTROL ENABLED, 1-3 ACC CONTROL DISABLED\n\n    if self.CP.flags & (HyundaiFlags.HYBRID | HyundaiFlags.EV):\n      if self.CP.flags & HyundaiFlags.HYBRID:\n        ret.gas = cp.vl[\"E_EMS11\"][\"CR_Vcu_AccPedDep_Pos\"] / 254.\n      else:\n        ret.gas = cp.vl[\"E_EMS11\"][\"Accel_Pedal_Pos\"] / 254.\n      ret.gasPressed = ret.gas > 0\n    else:\n      ret.gas = cp.vl[\"EMS12\"][\"PV_AV_CAN\"] / 100.\n      ret.gasPressed = bool(cp.vl[\"EMS16\"][\"CF_Ems_AclAct\"])\n\n    # Gear Selection via Cluster - For those Kia/Hyundai which are not fully discovered, we can use the Cluster Indicator for Gear Selection,\n    # as this seems to be standard over all cars, but is not the preferred method.\n    if self.CP.flags & (HyundaiFlags.HYBRID | HyundaiFlags.EV):\n      gear = cp.vl[\"ELECT_GEAR\"][\"Elect_Gear_Shifter\"]\n    elif self.CP.carFingerprint in CAN_GEARS[\"use_cluster_gears\"]:\n      gear = cp.vl[\"CLU15\"][\"CF_Clu_Gear\"]\n    elif self.CP.carFingerprint in CAN_GEARS[\"use_tcu_gears\"]:\n      gear = cp.vl[\"TCU12\"][\"CUR_GR\"]\n    else:\n      gear = cp.vl[\"LVR12\"][\"CF_Lvr_Gear\"]\n\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(gear))\n\n    if not self.CP.openpilotLongitudinalControl:\n      aeb_src = \"FCA11\" if self.CP.flags & HyundaiFlags.USE_FCA.value else \"SCC12\"\n      aeb_sig = \"FCA_CmdAct\" if self.CP.flags & HyundaiFlags.USE_FCA.value else \"AEB_CmdAct\"\n      aeb_warning = cp_cruise.vl[aeb_src][\"CF_VSM_Warn\"] != 0\n      scc_warning = cp_cruise.vl[\"SCC12\"][\"TakeOverReq\"] == 1  # sometimes only SCC system shows an FCW\n      aeb_braking = cp_cruise.vl[aeb_src][\"CF_VSM_DecCmdAct\"] != 0 or cp_cruise.vl[aeb_src][aeb_sig] != 0\n      ret.stockFcw = (aeb_warning or scc_warning) and not aeb_braking\n      ret.stockAeb = aeb_warning and aeb_braking\n\n    if self.CP.enableBsm:\n      ret.leftBlindspot = cp.vl[\"LCA11\"][\"CF_Lca_IndLeft\"] != 0\n      ret.rightBlindspot = cp.vl[\"LCA11\"][\"CF_Lca_IndRight\"] != 0\n\n    # save the entire LKAS11 and CLU11\n    self.lkas11 = copy.copy(cp_cam.vl[\"LKAS11\"])\n    self.clu11 = copy.copy(cp.vl[\"CLU11\"])\n    self.steer_state = cp.vl[\"MDPS12\"][\"CF_Mdps_ToiActive\"]  # 0 NOT ACTIVE, 1 ACTIVE\n    self.prev_cruise_buttons = self.cruise_buttons[-1]\n    self.cruise_buttons.extend(cp.vl_all[\"CLU11\"][\"CF_Clu_CruiseSwState\"])\n    self.main_buttons.extend(cp.vl_all[\"CLU11\"][\"CF_Clu_CruiseSwMain\"])\n\n    return ret\n\n  def update_canfd(self, cp, cp_cam):\n    ret = car.CarState.new_message()\n\n    self.is_metric = cp.vl[\"CRUISE_BUTTONS_ALT\"][\"DISTANCE_UNIT\"] != 1\n    speed_factor = CV.KPH_TO_MS if self.is_metric else CV.MPH_TO_MS\n\n    if self.CP.flags & (HyundaiFlags.EV | HyundaiFlags.HYBRID):\n      offset = 255. if self.CP.flags & HyundaiFlags.EV else 1023.\n      ret.gas = cp.vl[self.accelerator_msg_canfd][\"ACCELERATOR_PEDAL\"] / offset\n      ret.gasPressed = ret.gas > 1e-5\n    else:\n      ret.gasPressed = bool(cp.vl[self.accelerator_msg_canfd][\"ACCELERATOR_PEDAL_PRESSED\"])\n\n    ret.brakePressed = cp.vl[\"TCS\"][\"DriverBraking\"] == 1\n\n    ret.doorOpen = cp.vl[\"DOORS_SEATBELTS\"][\"DRIVER_DOOR\"] == 1\n    ret.seatbeltUnlatched = cp.vl[\"DOORS_SEATBELTS\"][\"DRIVER_SEATBELT\"] == 0\n\n    gear = cp.vl[self.gear_msg_canfd][\"GEAR\"]\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(gear))\n\n    # TODO: figure out positions\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_1\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_2\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_3\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_4\"],\n    )\n    ret.vEgoRaw = (ret.wheelSpeeds.fl + ret.wheelSpeeds.fr + ret.wheelSpeeds.rl + ret.wheelSpeeds.rr) / 4.\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = ret.wheelSpeeds.fl <= STANDSTILL_THRESHOLD and ret.wheelSpeeds.rr <= STANDSTILL_THRESHOLD\n\n    ret.steeringRateDeg = cp.vl[\"STEERING_SENSORS\"][\"STEERING_RATE\"]\n    ret.steeringAngleDeg = cp.vl[\"STEERING_SENSORS\"][\"STEERING_ANGLE\"] * -1\n    ret.steeringTorque = cp.vl[\"MDPS\"][\"STEERING_COL_TORQUE\"]\n    ret.steeringTorqueEps = cp.vl[\"MDPS\"][\"STEERING_OUT_TORQUE\"]\n    ret.steeringPressed = self.update_steering_pressed(abs(ret.steeringTorque) > self.params.STEER_THRESHOLD, 5)\n    ret.steerFaultTemporary = cp.vl[\"MDPS\"][\"LKA_FAULT\"] != 0\n\n    # TODO: alt signal usage may be described by cp.vl['BLINKERS']['USE_ALT_LAMP']\n    left_blinker_sig, right_blinker_sig = \"LEFT_LAMP\", \"RIGHT_LAMP\"\n    if self.CP.carFingerprint == CAR.HYUNDAI_KONA_EV_2ND_GEN:\n      left_blinker_sig, right_blinker_sig = \"LEFT_LAMP_ALT\", \"RIGHT_LAMP_ALT\"\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_lamp(50, cp.vl[\"BLINKERS\"][left_blinker_sig],\n                                                                      cp.vl[\"BLINKERS\"][right_blinker_sig])\n    if self.CP.enableBsm:\n      ret.leftBlindspot = cp.vl[\"BLINDSPOTS_REAR_CORNERS\"][\"FL_INDICATOR\"] != 0\n      ret.rightBlindspot = cp.vl[\"BLINDSPOTS_REAR_CORNERS\"][\"FR_INDICATOR\"] != 0\n\n    # cruise state\n    # CAN FD cars enable on main button press, set available if no TCS faults preventing engagement\n    ret.cruiseState.available = cp.vl[\"TCS\"][\"ACCEnable\"] == 0\n    if self.CP.openpilotLongitudinalControl:\n      # These are not used for engage/disengage since openpilot keeps track of state using the buttons\n      ret.cruiseState.enabled = cp.vl[\"TCS\"][\"ACC_REQ\"] == 1\n      ret.cruiseState.standstill = False\n    else:\n      cp_cruise_info = cp_cam if self.CP.flags & HyundaiFlags.CANFD_CAMERA_SCC else cp\n      ret.cruiseState.enabled = cp_cruise_info.vl[\"SCC_CONTROL\"][\"ACCMode\"] in (1, 2)\n      ret.cruiseState.standstill = cp_cruise_info.vl[\"SCC_CONTROL\"][\"CRUISE_STANDSTILL\"] == 1\n      ret.cruiseState.speed = cp_cruise_info.vl[\"SCC_CONTROL\"][\"VSetDis\"] * speed_factor\n      self.cruise_info = copy.copy(cp_cruise_info.vl[\"SCC_CONTROL\"])\n\n    # Manual Speed Limit Assist is a feature that replaces non-adaptive cruise control on EV CAN FD platforms.\n    # It limits the vehicle speed, overridable by pressing the accelerator past a certain point.\n    # The car will brake, but does not respect positive acceleration commands in this mode\n    # TODO: find this message on ICE & HYBRID cars + cruise control signals (if exists)\n    if self.CP.flags & HyundaiFlags.EV:\n      ret.cruiseState.nonAdaptive = cp.vl[\"MANUAL_SPEED_LIMIT_ASSIST\"][\"MSLA_ENABLED\"] == 1\n\n    self.prev_cruise_buttons = self.cruise_buttons[-1]\n    self.cruise_buttons.extend(cp.vl_all[self.cruise_btns_msg_canfd][\"CRUISE_BUTTONS\"])\n    self.main_buttons.extend(cp.vl_all[self.cruise_btns_msg_canfd][\"ADAPTIVE_CRUISE_MAIN_BTN\"])\n    self.buttons_counter = cp.vl[self.cruise_btns_msg_canfd][\"COUNTER\"]\n    ret.accFaulted = cp.vl[\"TCS\"][\"ACCEnable\"] != 0  # 0 ACC CONTROL ENABLED, 1-3 ACC CONTROL DISABLED\n\n    if self.CP.flags & HyundaiFlags.CANFD_HDA2:\n      self.hda2_lfa_block_msg = copy.copy(cp_cam.vl[\"CAM_0x362\"] if self.CP.flags & HyundaiFlags.CANFD_HDA2_ALT_STEERING\n                                          else cp_cam.vl[\"CAM_0x2a4\"])\n\n    return ret\n\n  def get_can_parser(self, CP):\n    if CP.carFingerprint in CANFD_CAR:\n      return self.get_can_parser_canfd(CP)\n\n    messages = [\n      # address, frequency\n      (\"MDPS12\", 50),\n      (\"TCS11\", 100),\n      (\"TCS13\", 50),\n      (\"TCS15\", 10),\n      (\"CLU11\", 50),\n      (\"CLU15\", 5),\n      (\"ESP12\", 100),\n      (\"CGW1\", 10),\n      (\"CGW2\", 5),\n      (\"CGW4\", 5),\n      (\"WHL_SPD11\", 50),\n      (\"SAS11\", 100),\n    ]\n\n    if not CP.openpilotLongitudinalControl and CP.carFingerprint not in CAMERA_SCC_CAR:\n      messages += [\n        (\"SCC11\", 50),\n        (\"SCC12\", 50),\n      ]\n      if CP.flags & HyundaiFlags.USE_FCA.value:\n        messages.append((\"FCA11\", 50))\n\n    if CP.enableBsm:\n      messages.append((\"LCA11\", 50))\n\n    if CP.flags & (HyundaiFlags.HYBRID | HyundaiFlags.EV):\n      messages.append((\"E_EMS11\", 50))\n    else:\n      messages += [\n        (\"EMS12\", 100),\n        (\"EMS16\", 100),\n      ]\n\n    if CP.flags & (HyundaiFlags.HYBRID | HyundaiFlags.EV):\n      messages.append((\"ELECT_GEAR\", 20))\n    elif CP.carFingerprint in CAN_GEARS[\"use_cluster_gears\"]:\n      pass\n    elif CP.carFingerprint in CAN_GEARS[\"use_tcu_gears\"]:\n      messages.append((\"TCU12\", 100))\n    else:\n      messages.append((\"LVR12\", 100))\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    if CP.carFingerprint in CANFD_CAR:\n      return CarState.get_cam_can_parser_canfd(CP)\n\n    messages = [\n      (\"LKAS11\", 100)\n    ]\n\n    if not CP.openpilotLongitudinalControl and CP.carFingerprint in CAMERA_SCC_CAR:\n      messages += [\n        (\"SCC11\", 50),\n        (\"SCC12\", 50),\n      ]\n\n      if CP.flags & HyundaiFlags.USE_FCA.value:\n        messages.append((\"FCA11\", 50))\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 2)\n\n  def get_can_parser_canfd(self, CP):\n    messages = [\n      (self.gear_msg_canfd, 100),\n      (self.accelerator_msg_canfd, 100),\n      (\"WHEEL_SPEEDS\", 100),\n      (\"STEERING_SENSORS\", 100),\n      (\"MDPS\", 100),\n      (\"TCS\", 50),\n      (\"CRUISE_BUTTONS_ALT\", 50),\n      (\"BLINKERS\", 4),\n      (\"DOORS_SEATBELTS\", 4),\n    ]\n\n    if CP.flags & HyundaiFlags.EV:\n      messages += [\n        (\"MANUAL_SPEED_LIMIT_ASSIST\", 10),\n      ]\n\n    if not (CP.flags & HyundaiFlags.CANFD_ALT_BUTTONS):\n      messages += [\n        (\"CRUISE_BUTTONS\", 50)\n      ]\n\n    if CP.enableBsm:\n      messages += [\n        (\"BLINDSPOTS_REAR_CORNERS\", 20),\n      ]\n\n    if not (CP.flags & HyundaiFlags.CANFD_CAMERA_SCC.value) and not CP.openpilotLongitudinalControl:\n      messages += [\n        (\"SCC_CONTROL\", 50),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus(CP).ECAN)\n\n  @staticmethod\n  def get_cam_can_parser_canfd(CP):\n    messages = []\n    if CP.flags & HyundaiFlags.CANFD_HDA2:\n      block_lfa_msg = \"CAM_0x362\" if CP.flags & HyundaiFlags.CANFD_HDA2_ALT_STEERING else \"CAM_0x2a4\"\n      messages += [(block_lfa_msg, 20)]\n    elif CP.flags & HyundaiFlags.CANFD_CAMERA_SCC:\n      messages += [\n        (\"SCC_CONTROL\", 50),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus(CP).CAM)\n", "selfdrive/car/hyundai/fingerprints.py": "# ruff: noqa: E501\nfrom cereal import car\nfrom openpilot.selfdrive.car.hyundai.values import CAR\n\nEcu = car.CarParams.Ecu\n\n# The existence of SCC or RDR in the fwdRadar FW usually determines the radar's function,\n# i.e. if it sends the SCC messages or if another ECU like the camera or ADAS Driving ECU does\n\n\nFINGERPRINTS = {\n  CAR.HYUNDAI_SANTA_FE: [{\n    67: 8, 127: 8, 304: 8, 320: 8, 339: 8, 356: 4, 544: 8, 593: 8, 608: 8, 688: 6, 809: 8, 832: 8, 854: 7, 870: 7, 871: 8, 872: 8, 897: 8, 902: 8, 903: 8, 905: 8, 909: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1078: 4, 1107: 5, 1136: 8, 1151: 6, 1155: 8, 1156: 8, 1162: 8, 1164: 8, 1168: 7, 1170: 8, 1173: 8, 1183: 8, 1186: 2, 1191: 2, 1227: 8, 1265: 4, 1280: 1, 1287: 4, 1290: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1342: 6, 1345: 8, 1348: 8, 1363: 8, 1369: 8, 1379: 8, 1384: 8, 1407: 8, 1414: 3, 1419: 8, 1427: 6, 1456: 4, 1470: 8\n  },\n  {\n    67: 8, 127: 8, 304: 8, 320: 8, 339: 8, 356: 4, 544: 8, 593: 8, 608: 8, 688: 6, 764: 8, 809: 8, 854: 7, 870: 7, 871: 8, 872: 8, 897: 8, 902: 8, 903: 8, 905: 8, 909: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1064: 8, 1078: 4, 1107: 5, 1136: 8, 1151: 6, 1155: 8, 1162: 8, 1164: 8, 1168: 7, 1170: 8, 1173: 8, 1180: 8, 1183: 8, 1186: 2, 1227: 8, 1265: 4, 1280: 1, 1287: 4, 1290: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1345: 8, 1348: 8, 1363: 8, 1369: 8, 1371: 8, 1378: 8, 1384: 8, 1407: 8, 1414: 3, 1419: 8, 1427: 6, 1456: 4, 1470: 8, 1988: 8, 2000: 8, 2004: 8, 2008: 8, 2012: 8\n  },\n  {\n    67: 8, 68: 8, 80: 4, 160: 8, 161: 8, 272: 8, 288: 4, 339: 8, 356: 8, 357: 8, 399: 8, 544: 8, 608: 8, 672: 8, 688: 5, 704: 1, 790: 8, 809: 8, 848: 8, 880: 8, 898: 8, 900: 8, 901: 8, 904: 8, 1056: 8, 1064: 8, 1065: 8, 1072: 8, 1075: 8, 1087: 8, 1088: 8, 1151: 8, 1200: 8, 1201: 8, 1232: 4, 1264: 8, 1265: 8, 1266: 8, 1296: 8, 1306: 8, 1312: 8, 1322: 8, 1331: 8, 1332: 8, 1333: 8, 1348: 8, 1349: 8, 1369: 8, 1370: 8, 1371: 8, 1407: 8, 1415: 8, 1419: 8, 1440: 8, 1442: 4, 1461: 8, 1470: 8\n  }],\n  CAR.HYUNDAI_SONATA: [{\n    67: 8, 68: 8, 127: 8, 304: 8, 320: 8, 339: 8, 356: 4, 544: 8, 546: 8, 549: 8, 550: 8, 576: 8, 593: 8, 608: 8, 688: 6, 809: 8, 832: 8, 854: 8, 865: 8, 870: 7, 871: 8, 872: 8, 897: 8, 902: 8, 903: 8, 905: 8, 908: 8, 909: 8, 912: 7, 913: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1078: 4, 1089: 5, 1096: 8, 1107: 5, 1108: 8, 1114: 8, 1136: 8, 1145: 8, 1151: 8, 1155: 8, 1156: 8, 1157: 4, 1162: 8, 1164: 8, 1168: 8, 1170: 8, 1173: 8, 1180: 8, 1183: 8, 1184: 8, 1186: 2, 1191: 2, 1193: 8, 1210: 8, 1225: 8, 1227: 8, 1265: 4, 1268: 8, 1280: 8, 1287: 4, 1290: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1330: 8, 1339: 8, 1342: 6, 1343: 8, 1345: 8, 1348: 8, 1363: 8, 1369: 8, 1371: 8, 1378: 8, 1379: 8, 1384: 8, 1394: 8, 1407: 8, 1419: 8, 1427: 6, 1446: 8, 1456: 4, 1460: 8, 1470: 8, 1485: 8, 1504: 3, 1988: 8, 1996: 8, 2000: 8, 2004: 8, 2008: 8, 2012: 8, 2015: 8\n  }],\n  CAR.KIA_STINGER: [{\n    67: 8, 127: 8, 304: 8, 320: 8, 339: 8, 356: 4, 358: 6, 359: 8, 544: 8, 576: 8, 593: 8, 608: 8, 688: 5, 809: 8, 832: 8, 854: 7, 870: 7, 871: 8, 872: 8, 897: 8, 902: 8, 909: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1064: 8, 1078: 4, 1107: 5, 1136: 8, 1151: 6, 1168: 7, 1170: 8, 1173: 8, 1184: 8, 1265: 4, 1280: 1, 1281: 4, 1287: 4, 1290: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1342: 6, 1345: 8, 1348: 8, 1363: 8, 1369: 8, 1371: 8, 1378: 4, 1379: 8, 1384: 8, 1407: 8, 1419: 8, 1425: 2, 1427: 6, 1456: 4, 1470: 8\n  }],\n  CAR.GENESIS_G90: [{\n    67: 8, 68: 8, 127: 8, 304: 8, 320: 8, 339: 8, 356: 4, 358: 6, 359: 8, 544: 8, 593: 8, 608: 8, 688: 5, 809: 8, 854: 7, 870: 7, 871: 8, 872: 8, 897: 8, 902: 8, 903: 8, 916: 8, 1040: 8, 1056: 8, 1057: 8, 1078: 4, 1107: 5, 1136: 8, 1151: 6, 1162: 4, 1168: 7, 1170: 8, 1173: 8, 1184: 8, 1265: 4, 1280: 1, 1281: 3, 1287: 4, 1290: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1345: 8, 1348: 8, 1363: 8, 1369: 8, 1370: 8, 1371: 8, 1378: 4, 1384: 8, 1407: 8, 1419: 8, 1425: 2, 1427: 6, 1434: 2, 1456: 4, 1470: 8, 1988: 8, 2000: 8, 2003: 8, 2004: 8, 2005: 8, 2008: 8, 2011: 8, 2012: 8, 2013: 8\n  }],\n  CAR.HYUNDAI_KONA_EV: [{\n    127: 8, 304: 8, 320: 8, 339: 8, 352: 8, 356: 4, 544: 8, 549: 8, 593: 8, 688: 5, 832: 8, 881: 8, 882: 8, 897: 8, 902: 8, 903: 8, 905: 8, 909: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1078: 4, 1136: 8, 1151: 6, 1168: 7, 1173: 8, 1183: 8, 1186: 2, 1191: 2, 1225: 8, 1265: 4, 1280: 1, 1287: 4, 1290: 8, 1291: 8, 1292: 8, 1294: 8, 1307: 8, 1312: 8, 1322: 8, 1342: 6, 1345: 8, 1348: 8, 1355: 8, 1363: 8, 1369: 8, 1378: 4, 1407: 8, 1419: 8, 1426: 8, 1427: 6, 1429: 8, 1430: 8, 1456: 4, 1470: 8, 1473: 8, 1507: 8, 1535: 8, 2000: 8, 2004: 8, 2008: 8, 2012: 8, 1157: 4, 1193: 8, 1379: 8, 1988: 8, 1996: 8\n  }],\n  CAR.HYUNDAI_KONA_EV_2022: [{\n    127: 8, 304: 8, 320: 8, 339: 8, 352: 8, 356: 4, 544: 8, 593: 8, 688: 5, 832: 8, 881: 8, 882: 8, 897: 8, 902: 8, 903: 8, 905: 8, 909: 8, 913: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1069: 8, 1078: 4, 1136: 8, 1145: 8, 1151: 8, 1155: 8, 1156: 8, 1157: 4, 1162: 8, 1164: 8, 1168: 8, 1173: 8, 1183: 8, 1188: 8, 1191: 2, 1193: 8, 1225: 8, 1227: 8, 1265: 4, 1280: 1, 1287: 4, 1290: 8, 1291: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1339: 8, 1342: 8, 1343: 8, 1345: 8, 1348: 8, 1355: 8, 1363: 8, 1369: 8, 1379: 8, 1407: 8, 1419: 8, 1426: 8, 1427: 6, 1429: 8, 1430: 8, 1446: 8, 1456: 4, 1470: 8, 1473: 8, 1485: 8, 1507: 8, 1535: 8, 1990: 8, 1998: 8\n  }],\n  CAR.KIA_NIRO_EV: [{\n    127: 8, 304: 8, 320: 8, 339: 8, 352: 8, 356: 4, 516: 8, 544: 8, 593: 8, 688: 5, 832: 8, 881: 8, 882: 8, 897: 8, 902: 8, 903: 8, 905: 8, 909: 8, 916: 8, 1040: 8, 1042: 8, 1056: 8, 1057: 8, 1078: 4, 1136: 8, 1151: 6, 1156: 8, 1157: 4, 1168: 7, 1173: 8, 1183: 8, 1186: 2, 1191: 2, 1193: 8, 1225: 8, 1260: 8, 1265: 4, 1280: 1, 1287: 4, 1290: 8, 1291: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1342: 6, 1345: 8, 1348: 8, 1355: 8, 1363: 8, 1369: 8, 1407: 8, 1419: 8, 1426: 8, 1427: 6, 1429: 8, 1430: 8, 1456: 4, 1470: 8, 1473: 8, 1507: 8, 1535: 8, 1990: 8, 1998: 8, 1996: 8, 2000: 8, 2004: 8, 2008: 8, 2012: 8, 2015: 8\n  }],\n  CAR.KIA_OPTIMA_H: [{\n    68: 8, 127: 8, 304: 8, 320: 8, 339: 8, 352: 8, 356: 4, 544: 8, 593: 8, 688: 5, 832: 8, 881: 8, 882: 8, 897: 8, 902: 8, 903: 6, 916: 8, 1040: 8, 1056: 8, 1057: 8, 1078: 4, 1136: 6, 1151: 6, 1168: 7, 1173: 8, 1236: 2, 1265: 4, 1280: 1, 1287: 4, 1290: 8, 1291: 8, 1292: 8, 1322: 8, 1331: 8, 1332: 8, 1333: 8, 1342: 6, 1345: 8, 1348: 8, 1355: 8, 1363: 8, 1369: 8, 1371: 8, 1407: 8, 1419: 8, 1427: 6, 1429: 8, 1430: 8, 1448: 8, 1456: 4, 1470: 8, 1476: 8, 1535: 8\n  },\n  {\n    68: 8, 127: 8, 304: 8, 320: 8, 339: 8, 352: 8, 356: 4, 544: 8, 576: 8, 593: 8, 688: 5, 881: 8, 882: 8, 897: 8, 902: 8, 903: 8, 909: 8, 912: 7, 916: 8, 1040: 8, 1056: 8, 1057: 8, 1078: 4, 1136: 6, 1151: 6, 1168: 7, 1173: 8, 1180: 8, 1186: 2, 1191: 2, 1265: 4, 1268: 8, 1280: 1, 1287: 4, 1290: 8, 1291: 8, 1292: 8, 1294: 8, 1312: 8, 1322: 8, 1342: 6, 1345: 8, 1348: 8, 1355: 8, 1363: 8, 1369: 8, 1371: 8, 1407: 8, 1419: 8, 1420: 8, 1425: 2, 1427: 6, 1429: 8, 1430: 8, 1448: 8, 1456: 4, 1470: 8, 1476: 8, 1535: 8\n  }],\n}\n\nFW_VERSIONS = {\n  CAR.HYUNDAI_AZERA_6TH_GEN: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00IG__ SCC F-CU-      1.00 1.00 99110-G8100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00IG  MDPS C 1.00 1.02 56310G8510\\x00 4IGSC103',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00IG  MFC  AT MES LHD 1.00 1.04 99211-G8100 200511',\n    ],\n  },\n  CAR.HYUNDAI_AZERA_HEV_6TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00IGH MFC  AT KOR LHD 1.00 1.00 99211-G8000 180903',\n      b'\\xf1\\x00IGH MFC  AT KOR LHD 1.00 1.01 99211-G8000 181109',\n      b'\\xf1\\x00IGH MFC  AT KOR LHD 1.00 1.02 99211-G8100 191029',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00IG  MDPS C 1.00 1.00 56310M9600\\x00 4IHSC100',\n      b'\\xf1\\x00IG  MDPS C 1.00 1.01 56310M9350\\x00 4IH8C101',\n      b'\\xf1\\x00IG  MDPS C 1.00 1.02 56310M9350\\x00 4IH8C102',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00IGhe SCC FHCUP      1.00 1.00 99110-M9100         ',\n      b'\\xf1\\x00IGhe SCC FHCUP      1.00 1.01 99110-M9000         ',\n      b'\\xf1\\x00IGhe SCC FHCUP      1.00 1.02 99110-M9000         ',\n    ],\n  },\n  CAR.HYUNDAI_GENESIS: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DH LKAS 1.1 -150210',\n      b'\\xf1\\x00DH LKAS 1.4 -140110',\n      b'\\xf1\\x00DH LKAS 1.5 -140425',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AEhe SCC H-CUP      1.01 1.01 96400-G2000         ',\n      b'\\xf1\\x00AEhe SCC H-CUP      1.01 1.01 96400-G2100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00AE  MDPS C 1.00 1.05 56310/G2501 4AEHC105',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.07 56310/G2301 4AEHC107',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.07 56310/G2501 4AEHC107',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AEH MFC  AT EUR LHD 1.00 1.00 95740-G2400 180222',\n      b'\\xf1\\x00AEH MFC  AT USA LHD 1.00 1.00 95740-G2400 180222',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_PHEV_2019: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AEhe SCC H-CUP      1.01 1.01 96400-G2000         ',\n      b'\\xf1\\x00AEhe SCC H-CUP      1.01 1.01 96400-G2100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00AE  MDPS C 1.00 1.07 56310/G2501 4AEHC107',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.07 56310/G2551 4AEHC107',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AEP MFC  AT AUS RHD 1.00 1.00 95740-G2400 180222',\n      b'\\xf1\\x00AEP MFC  AT USA LHD 1.00 1.00 95740-G2400 180222',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_PHEV: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AEhe SCC F-CUP      1.00 1.00 99110-G2200         ',\n      b'\\xf1\\x00AEhe SCC F-CUP      1.00 1.00 99110-G2600         ',\n      b'\\xf1\\x00AEhe SCC F-CUP      1.00 1.02 99110-G2100         ',\n      b'\\xf1\\x00AEhe SCC FHCUP      1.00 1.00 99110-G2600         ',\n      b'\\xf1\\x00AEhe SCC FHCUP      1.00 1.02 99110-G2100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G2210 4APHC101',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G2310 4APHC101',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G2510 4APHC101',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G2560 4APHC101',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310G2510\\x00 4APHC101',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AEP MFC  AT EUR LHD 1.00 1.01 95740-G2600 190819',\n      b'\\xf1\\x00AEP MFC  AT EUR RHD 1.00 1.01 95740-G2600 190819',\n      b'\\xf1\\x00AEP MFC  AT USA LHD 1.00 1.00 95740-G2700 201027',\n      b'\\xf1\\x00AEP MFC  AT USA LHD 1.00 1.01 95740-G2600 190819',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_EV_2020: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AEev SCC F-CUP      1.00 1.00 99110-G7200         ',\n      b'\\xf1\\x00AEev SCC F-CUP      1.00 1.00 99110-G7500         ',\n      b'\\xf1\\x00AEev SCC F-CUP      1.00 1.01 99110-G7000         ',\n      b'\\xf1\\x00AEev SCC F-CUP      1.00 1.01 99110-G7100         ',\n      b'\\xf1\\x00AEev SCC FHCUP      1.00 1.01 99110-G7100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G7310 4APEC101',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G7510 4APEC101',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310/G7560 4APEC101',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.00 95740-G2600 190730',\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.00 95740-G2700 201027',\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.01 95740-G2600 190819',\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.03 95740-G2500 190516',\n      b'\\xf1\\x00AEE MFC  AT EUR RHD 1.00 1.01 95740-G2600 190819',\n      b'\\xf1\\x00AEE MFC  AT USA LHD 1.00 1.01 95740-G2600 190819',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_EV_LTD: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AEev SCC F-CUP      1.00 1.00 96400-G7000         ',\n      b'\\xf1\\x00AEev SCC F-CUP      1.00 1.00 96400-G7100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00AE  MDPS C 1.00 1.02 56310G7300\\x00 4AEEC102',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.03 56310/G7300 4AEEC103',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.03 56310G7300\\x00 4AEEC103',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.04 56310/G7301 4AEEC104',\n      b'\\xf1\\x00AE  MDPS C 1.00 1.04 56310/G7501 4AEEC104',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.00 95740-G2300 170703',\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.00 95740-G2400 180222',\n      b'\\xf1\\x00AEE MFC  AT EUR LHD 1.00 1.00 95740-G7200 160418',\n      b'\\xf1\\x00AEE MFC  AT USA LHD 1.00 1.00 95740-G2400 180222',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_HEV_2022: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AEhe SCC F-CUP      1.00 1.00 99110-G2600         ',\n      b'\\xf1\\x00AEhe SCC FHCUP      1.00 1.00 99110-G2600         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00AE  MDPS C 1.00 1.01 56310G2510\\x00 4APHC101',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AEH MFC  AT USA LHD 1.00 1.00 95740-G2700 201027',\n    ],\n  },\n  CAR.HYUNDAI_SONATA: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DN8_ SCC F-CU-      1.00 1.00 99110-L0000         ',\n      b'\\xf1\\x00DN8_ SCC F-CUP      1.00 1.00 99110-L0000         ',\n      b'\\xf1\\x00DN8_ SCC F-CUP      1.00 1.02 99110-L1000         ',\n      b'\\xf1\\x00DN8_ SCC FHCUP      1.00 1.00 99110-L0000         ',\n      b'\\xf1\\x00DN8_ SCC FHCUP      1.00 1.01 99110-L1000         ',\n      b'\\xf1\\x00DN8_ SCC FHCUP      1.00 1.02 99110-L1000         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00DN ESC \\x01 102\\x19\\x04\\x13 58910-L1300',\n      b'\\xf1\\x00DN ESC \\x03 100 \\x08\\x01 58910-L0300',\n      b'\\xf1\\x00DN ESC \\x06 104\\x19\\x08\\x01 58910-L0100',\n      b'\\xf1\\x00DN ESC \\x06 106 \\x07\\x01 58910-L0100',\n      b'\\xf1\\x00DN ESC \\x06 107 \\x07\\x03 58910-L1300',\n      b'\\xf1\\x00DN ESC \\x06 107\"\\x08\\x07 58910-L0100',\n      b'\\xf1\\x00DN ESC \\x07 104\\x19\\x08\\x01 58910-L0100',\n      b'\\xf1\\x00DN ESC \\x07 106 \\x07\\x01 58910-L0100',\n      b'\\xf1\\x00DN ESC \\x07 107\"\\x08\\x07 58910-L0100',\n      b'\\xf1\\x00DN ESC \\x08 103\\x19\\x06\\x01 58910-L1300',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DN8 MDPS C 1,00 1,01 56310L0010\\x00 4DNAC101',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310-L0010 4DNAC101',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310-L0210 4DNAC101',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310-L0210 4DNAC102',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310L0010\\x00 4DNAC101',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310L0200\\x00 4DNAC102',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310L0210\\x00 4DNAC101',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310L0210\\x00 4DNAC102',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.03 56310-L1010 4DNDC103',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.03 56310-L1030 4DNDC103',\n      b'\\xf1\\x00DN8 MDPS R 1.00 1.00 57700-L0000 4DNAP100',\n      b'\\xf1\\x00DN8 MDPS R 1.00 1.00 57700-L0000 4DNAP101',\n      b'\\xf1\\x00DN8 MDPS R 1.00 1.02 57700-L1000 4DNDP105',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DN8 MFC  AT KOR LHD 1.00 1.02 99211-L1000 190422',\n      b'\\xf1\\x00DN8 MFC  AT KOR LHD 1.00 1.04 99211-L1000 191016',\n      b'\\xf1\\x00DN8 MFC  AT RUS LHD 1.00 1.03 99211-L1000 190705',\n      b'\\xf1\\x00DN8 MFC  AT USA LHD 1.00 1.00 99211-L0000 190716',\n      b'\\xf1\\x00DN8 MFC  AT USA LHD 1.00 1.01 99211-L0000 191016',\n      b'\\xf1\\x00DN8 MFC  AT USA LHD 1.00 1.03 99211-L0000 210603',\n      b'\\xf1\\x00DN8 MFC  AT USA LHD 1.00 1.05 99211-L1000 201109',\n      b'\\xf1\\x00DN8 MFC  AT USA LHD 1.00 1.06 99211-L1000 210325',\n      b'\\xf1\\x00DN8 MFC  AT USA LHD 1.00 1.07 99211-L1000 211223',\n    ],\n  },\n  CAR.HYUNDAI_SONATA_LF: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00LF__ SCC F-CUP      1.00 1.00 96401-C2200         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00LF ESC \\t 11 \\x17\\x01\\x13 58920-C2610',\n      b'\\xf1\\x00LF ESC \\x0c 11 \\x17\\x01\\x13 58920-C2610',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00LFF LKAS AT USA LHD 1.00 1.01 95740-C1000 E51',\n      b'\\xf1\\x00LFF LKAS AT USA LHD 1.01 1.02 95740-C1000 E52',\n    ],\n  },\n  CAR.HYUNDAI_TUCSON: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00TL__ FCA F-CUP      1.00 1.01 99110-D3500         ',\n      b'\\xf1\\x00TL__ FCA F-CUP      1.00 1.02 99110-D3510         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00TL  MFC  AT KOR LHD 1.00 1.02 95895-D3800 180719',\n      b'\\xf1\\x00TL  MFC  AT USA LHD 1.00 1.06 95895-D3800 190107',\n    ],\n  },\n  CAR.HYUNDAI_SANTA_FE: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00TM__ SCC F-CUP      1.00 1.00 99110-S1210         ',\n      b'\\xf1\\x00TM__ SCC F-CUP      1.00 1.01 99110-S2000         ',\n      b'\\xf1\\x00TM__ SCC F-CUP      1.00 1.02 99110-S2000         ',\n      b'\\xf1\\x00TM__ SCC F-CUP      1.00 1.03 99110-S2000         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00TM ESC \\x02 100\\x18\\x030 58910-S2600',\n      b'\\xf1\\x00TM ESC \\x02 102\\x18\\x07\\x01 58910-S2600',\n      b'\\xf1\\x00TM ESC \\x02 103\\x18\\x11\\x07 58910-S2600',\n      b'\\xf1\\x00TM ESC \\x02 104\\x19\\x07\\x07 58910-S2600',\n      b'\\xf1\\x00TM ESC \\x03 103\\x18\\x11\\x07 58910-S2600',\n      b'\\xf1\\x00TM ESC \\x0c 103\\x18\\x11\\x08 58910-S2650',\n      b'\\xf1\\x00TM ESC \\r 100\\x18\\x031 58910-S2650',\n      b'\\xf1\\x00TM ESC \\r 103\\x18\\x11\\x08 58910-S2650',\n      b'\\xf1\\x00TM ESC \\r 104\\x19\\x07\\x08 58910-S2650',\n      b'\\xf1\\x00TM ESC \\r 105\\x19\\x05# 58910-S1500',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00TM  MDPS C 1.00 1.00 56340-S2000 8409',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.00 56340-S2000 8A12',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.01 56340-S2000 9129',\n      b'\\xf1\\x00TM  MDPS R 1.00 1.02 57700-S1100 4TMDP102',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00TM  MFC  AT EUR LHD 1.00 1.01 99211-S1010 181207',\n      b'\\xf1\\x00TM  MFC  AT USA LHD 1.00 1.00 99211-S2000 180409',\n    ],\n  },\n  CAR.HYUNDAI_SANTA_FE_2022: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00TM__ SCC F-CUP      1.00 1.00 99110-S1500         ',\n      b'\\xf1\\x00TM__ SCC F-CUP      1.00 1.01 99110-S1500         ',\n      b'\\xf1\\x00TM__ SCC FHCUP      1.00 1.00 99110-S1500         ',\n      b'\\xf1\\x00TM__ SCC FHCUP      1.00 1.01 99110-S1500         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00TM ESC \\x01 102!\\x04\\x03 58910-S2DA0',\n      b'\\xf1\\x00TM ESC \\x01 104\"\\x10\\x07 58910-S2DA0',\n      b'\\xf1\\x00TM ESC \\x02 101 \\x08\\x04 58910-S2GA0',\n      b'\\xf1\\x00TM ESC \\x02 103\"\\x07\\x08 58910-S2GA0',\n      b'\\xf1\\x00TM ESC \\x03 101 \\x08\\x02 58910-S2DA0',\n      b'\\xf1\\x00TM ESC \\x03 102!\\x04\\x03 58910-S2DA0',\n      b'\\xf1\\x00TM ESC \\x04 101 \\x08\\x04 58910-S2GA0',\n      b'\\xf1\\x00TM ESC \\x04 102!\\x04\\x05 58910-S2GA0',\n      b'\\xf1\\x00TM ESC \\x04 103\"\\x07\\x08 58910-S2GA0',\n      b'\\xf1\\x00TM ESC \\x1e 102 \\x08\\x08 58910-S1DA0',\n      b'\\xf1\\x00TM ESC   103!\\x030 58910-S1MA0',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00TM  MDPS C 1.00 1.01 56310-S1AB0 4TSDC101',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.01 56310-S1EB0 4TSDC101',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56370-S2AA0 0B19',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00TM  MFC  AT EUR LHD 1.00 1.03 99211-S1500 210224',\n      b'\\xf1\\x00TM  MFC  AT MES LHD 1.00 1.05 99211-S1500 220126',\n      b'\\xf1\\x00TMA MFC  AT MEX LHD 1.00 1.01 99211-S2500 210205',\n      b'\\xf1\\x00TMA MFC  AT USA LHD 1.00 1.00 99211-S2500 200720',\n      b'\\xf1\\x00TMA MFC  AT USA LHD 1.00 1.01 99211-S2500 210205',\n      b'\\xf1\\x00TMA MFC  AT USA LHD 1.00 1.03 99211-S2500 220414',\n    ],\n  },\n  CAR.HYUNDAI_SANTA_FE_HEV_2022: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00TMhe SCC FHCUP      1.00 1.00 99110-CL500         ',\n      b'\\xf1\\x00TMhe SCC FHCUP      1.00 1.01 99110-CL500         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56310-CLAC0 4TSHC102',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56310-CLEC0 4TSHC102',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56310-GA000 4TSHA100',\n      b'\\xf1\\x00TM  MDPS R 1.00 1.05 57700-CL000 4TSHP105',\n      b'\\xf1\\x00TM  MDPS R 1.00 1.06 57700-CL000 4TSHP106',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00TMA MFC  AT USA LHD 1.00 1.03 99211-S2500 220414',\n      b'\\xf1\\x00TMH MFC  AT EUR LHD 1.00 1.06 99211-S1500 220727',\n      b'\\xf1\\x00TMH MFC  AT KOR LHD 1.00 1.06 99211-S1500 220727',\n      b'\\xf1\\x00TMH MFC  AT USA LHD 1.00 1.03 99211-S1500 210224',\n      b'\\xf1\\x00TMH MFC  AT USA LHD 1.00 1.05 99211-S1500 220126',\n      b'\\xf1\\x00TMH MFC  AT USA LHD 1.00 1.06 99211-S1500 220727',\n    ],\n  },\n  CAR.HYUNDAI_SANTA_FE_PHEV_2022: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00TMhe SCC F-CUP      1.00 1.00 99110-CL500         ',\n      b'\\xf1\\x00TMhe SCC FHCUP      1.00 1.00 99110-CL500         ',\n      b'\\xf1\\x00TMhe SCC FHCUP      1.00 1.01 99110-CL500         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56310-CLAC0 4TSHC102',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56310-CLEC0 4TSHC102',\n      b'\\xf1\\x00TM  MDPS C 1.00 1.02 56310CLEC0\\x00 4TSHC102',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00TMP MFC  AT USA LHD 1.00 1.03 99211-S1500 210224',\n      b'\\xf1\\x00TMP MFC  AT USA LHD 1.00 1.05 99211-S1500 220126',\n      b'\\xf1\\x00TMP MFC  AT USA LHD 1.00 1.06 99211-S1500 220727',\n    ],\n  },\n  CAR.HYUNDAI_CUSTIN_1ST_GEN: {\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00KU ESC \\x01 101!\\x02\\x03 58910-O3200',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00KU__ SCC F-CUP      1.00 1.01 99110-O3000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00KU  MDPS C 1.00 1.01 56310/O3100 4KUCC101',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00KU2 MFC  AT CHN LHD 1.00 1.02 99211-O3000 220923',\n    ],\n  },\n  CAR.KIA_STINGER: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CK__ SCC F_CUP      1.00 1.01 96400-J5000         ',\n      b'\\xf1\\x00CK__ SCC F_CUP      1.00 1.01 96400-J5100         ',\n      b'\\xf1\\x00CK__ SCC F_CUP      1.00 1.02 96400-J5100         ',\n      b'\\xf1\\x00CK__ SCC F_CUP      1.00 1.03 96400-J5100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00CK  MDPS R 1.00 1.04 57700-J5200 4C2CL104',\n      b'\\xf1\\x00CK  MDPS R 1.00 1.04 57700-J5220 4C2VL104',\n      b'\\xf1\\x00CK  MDPS R 1.00 1.04 57700-J5420 4C4VL104',\n      b'\\xf1\\x00CK  MDPS R 1.00 1.06 57700-J5220 4C2VL106',\n      b'\\xf1\\x00CK  MDPS R 1.00 1.06 57700-J5420 4C4VL106',\n      b'\\xf1\\x00CK  MDPS R 1.00 1.07 57700-J5220 4C2VL107',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CK  MFC  AT EUR LHD 1.00 1.03 95740-J5000 170822',\n      b'\\xf1\\x00CK  MFC  AT USA LHD 1.00 1.03 95740-J5000 170822',\n      b'\\xf1\\x00CK  MFC  AT USA LHD 1.00 1.04 95740-J5000 180504',\n    ],\n  },\n  CAR.KIA_STINGER_2022: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CK__ SCC F-CUP      1.00 1.00 99110-J5500         ',\n      b'\\xf1\\x00CK__ SCC FHCUP      1.00 1.00 99110-J5500         ',\n      b'\\xf1\\x00CK__ SCC FHCUP      1.00 1.00 99110-J5600         ',\n      b'\\xf1\\x00CK__ SCC FHCUP      1.00 1.01 99110-J5100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00CK  MDPS R 1.00 5.03 57700-J5300 4C2CL503',\n      b'\\xf1\\x00CK  MDPS R 1.00 5.03 57700-J5320 4C2VL503',\n      b'\\xf1\\x00CK  MDPS R 1.00 5.03 57700-J5380 4C2VR503',\n      b'\\xf1\\x00CK  MDPS R 1.00 5.03 57700-J5520 4C4VL503',\n      b'\\xf1\\x00CK  MDPS R 1.00 5.04 57700-J5520 4C4VL504',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CK  MFC  AT AUS RHD 1.00 1.00 99211-J5500 210622',\n      b'\\xf1\\x00CK  MFC  AT KOR LHD 1.00 1.00 99211-J5500 210622',\n      b'\\xf1\\x00CK  MFC  AT USA LHD 1.00 1.00 99211-J5500 210622',\n      b'\\xf1\\x00CK  MFC  AT USA LHD 1.00 1.03 99211-J5000 201209',\n    ],\n  },\n  CAR.HYUNDAI_PALISADE: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00LX2 SCC FHCUP      1.00 1.04 99110-S8100         ',\n      b'\\xf1\\x00LX2_ SCC F-CUP      1.00 1.04 99110-S8100         ',\n      b'\\xf1\\x00LX2_ SCC F-CUP      1.00 1.05 99110-S8100         ',\n      b'\\xf1\\x00LX2_ SCC FHCU-      1.00 1.05 99110-S8100         ',\n      b'\\xf1\\x00LX2_ SCC FHCUP      1.00 1.00 99110-S8110         ',\n      b'\\xf1\\x00LX2_ SCC FHCUP      1.00 1.03 99110-S8100         ',\n      b'\\xf1\\x00LX2_ SCC FHCUP      1.00 1.04 99110-S8100         ',\n      b'\\xf1\\x00LX2_ SCC FHCUP      1.00 1.05 99110-S8100         ',\n      b'\\xf1\\x00ON__ FCA FHCUP      1.00 1.00 99110-S9110         ',\n      b'\\xf1\\x00ON__ FCA FHCUP      1.00 1.01 99110-S9110         ',\n      b'\\xf1\\x00ON__ FCA FHCUP      1.00 1.02 99110-S9100         ',\n      b'\\xf1\\x00ON__ FCA FHCUP      1.00 1.03 99110-S9100         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00LX ESC \\x01 103\\x19\\t\\x10 58910-S8360',\n      b'\\xf1\\x00LX ESC \\x01 1031\\t\\x10 58910-S8360',\n      b'\\xf1\\x00LX ESC \\x01 104 \\x10\\x15 58910-S8350',\n      b'\\xf1\\x00LX ESC \\x01 104 \\x10\\x16 58910-S8360',\n      b'\\xf1\\x00LX ESC \\x0b 101\\x19\\x03\\x17 58910-S8330',\n      b'\\xf1\\x00LX ESC \\x0b 101\\x19\\x03  58910-S8360',\n      b'\\xf1\\x00LX ESC \\x0b 102\\x19\\x05\\x07 58910-S8330',\n      b'\\xf1\\x00LX ESC \\x0b 103\\x19\\t\\x07 58910-S8330',\n      b'\\xf1\\x00LX ESC \\x0b 103\\x19\\t\\t 58910-S8350',\n      b'\\xf1\\x00LX ESC \\x0b 103\\x19\\t\\x10 58910-S8360',\n      b'\\xf1\\x00LX ESC \\x0b 104 \\x10\\x16 58910-S8360',\n      b'\\xf1\\x00ON ESC \\x01 101\\x19\\t\\x08 58910-S9360',\n      b'\\xf1\\x00ON ESC \\x0b 100\\x18\\x12\\x18 58910-S9360',\n      b'\\xf1\\x00ON ESC \\x0b 101\\x19\\t\\x05 58910-S9320',\n      b'\\xf1\\x00ON ESC \\x0b 101\\x19\\t\\x08 58910-S9360',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00LX2 MDPS C 1,00 1,03 56310-S8020 4LXDC103',\n      b'\\xf1\\x00LX2 MDPS C 1.00 1.03 56310-S8000 4LXDC103',\n      b'\\xf1\\x00LX2 MDPS C 1.00 1.03 56310-S8020 4LXDC103',\n      b'\\xf1\\x00LX2 MDPS C 1.00 1.03 56310-XX000 4LXDC103',\n      b'\\xf1\\x00LX2 MDPS C 1.00 1.04 56310-S8020 4LXDC104',\n      b'\\xf1\\x00LX2 MDPS C 1.00 1.04 56310-S8420 4LXDC104',\n      b'\\xf1\\x00LX2 MDPS R 1.00 1.02 56370-S8300 9318',\n      b'\\xf1\\x00ON  MDPS C 1.00 1.00 56340-S9000 8B13',\n      b'\\xf1\\x00ON  MDPS C 1.00 1.01 56340-S9000 9201',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00LX2 MFC  AT KOR LHD 1.00 1.08 99211-S8100 200903',\n      b'\\xf1\\x00LX2 MFC  AT USA LHD 1.00 1.00 99211-S8110 210226',\n      b'\\xf1\\x00LX2 MFC  AT USA LHD 1.00 1.03 99211-S8100 190125',\n      b'\\xf1\\x00LX2 MFC  AT USA LHD 1.00 1.05 99211-S8100 190909',\n      b'\\xf1\\x00LX2 MFC  AT USA LHD 1.00 1.07 99211-S8100 200422',\n      b'\\xf1\\x00LX2 MFC  AT USA LHD 1.00 1.08 99211-S8100 200903',\n      b'\\xf1\\x00ON  MFC  AT USA LHD 1.00 1.01 99211-S9100 181105',\n      b'\\xf1\\x00ON  MFC  AT USA LHD 1.00 1.03 99211-S9100 200720',\n      b'\\xf1\\x00ON  MFC  AT USA LHD 1.00 1.04 99211-S9100 211227',\n    ],\n  },\n  CAR.HYUNDAI_VELOSTER: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JS__ SCC H-CUP      1.00 1.02 95650-J3200         ',\n      b'\\xf1\\x00JS__ SCC HNCUP      1.00 1.02 95650-J3100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00JSL MDPS C 1.00 1.03 56340-J3000 8308',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JS  LKAS AT KOR LHD 1.00 1.03 95740-J3000 K33',\n      b'\\xf1\\x00JS  LKAS AT USA LHD 1.00 1.02 95740-J3000 K32',\n    ],\n  },\n  CAR.GENESIS_G70: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00IK__ SCC F-CUP      1.00 1.01 96400-G9100         ',\n      b'\\xf1\\x00IK__ SCC F-CUP      1.00 1.02 96400-G9100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00IK  MDPS R 1.00 1.06 57700-G9420 4I4VL106',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00IK  MFC  AT USA LHD 1.00 1.01 95740-G9000 170920',\n    ],\n  },\n  CAR.GENESIS_G70_2020: {\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00IK  MDPS R 1.00 1.06 57700-G9220 4I2VL106',\n      b'\\xf1\\x00IK  MDPS R 1.00 1.07 57700-G9220 4I2VL107',\n      b'\\xf1\\x00IK  MDPS R 1.00 1.07 57700-G9420 4I4VL107',\n      b'\\xf1\\x00IK  MDPS R 1.00 1.08 57700-G9200 4I2CL108',\n      b'\\xf1\\x00IK  MDPS R 1.00 1.08 57700-G9420 4I4VL108',\n      b'\\xf1\\x00IK  MDPS R 1.00 5.09 57700-G9520 4I4VL509',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00IK__ SCC F-CUP      1.00 1.01 96400-G9100         ',\n      b'\\xf1\\x00IK__ SCC F-CUP      1.00 1.02 96400-G9100         ',\n      b'\\xf1\\x00IK__ SCC F-CUP      1.00 1.02 96400-G9100         \\xf1\\xa01.02',\n      b'\\xf1\\x00IK__ SCC FHCUP      1.00 1.00 99110-G9300         ',\n      b'\\xf1\\x00IK__ SCC FHCUP      1.00 1.02 96400-G9000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00IK  MFC  AT KOR LHD 1.00 1.01 95740-G9000 170920',\n      b'\\xf1\\x00IK  MFC  AT USA LHD 1.00 1.01 95740-G9000 170920',\n      b'\\xf1\\x00IK  MFC  AT USA LHD 1.00 1.04 99211-G9000 220401',\n    ],\n  },\n  CAR.GENESIS_G80: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DH__ SCC F-CUP      1.00 1.01 96400-B1120         ',\n      b'\\xf1\\x00DH__ SCC F-CUP      1.00 1.02 96400-B1120         ',\n      b'\\xf1\\x00DH__ SCC FHCUP      1.00 1.01 96400-B1110         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DH  LKAS AT KOR LHD 1.01 1.01 95895-B1500 161014',\n      b'\\xf1\\x00DH  LKAS AT KOR LHD 1.01 1.02 95895-B1500 170810',\n      b'\\xf1\\x00DH  LKAS AT USA LHD 1.01 1.01 95895-B1500 161014',\n      b'\\xf1\\x00DH  LKAS AT USA LHD 1.01 1.02 95895-B1500 170810',\n      b'\\xf1\\x00DH  LKAS AT USA LHD 1.01 1.03 95895-B1500 180713',\n      b'\\xf1\\x00DH  LKAS AT USA LHD 1.01 1.04 95895-B1500 181213',\n    ],\n  },\n  CAR.GENESIS_G90: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00HI__ SCC F-CUP      1.00 1.01 96400-D2100         ',\n      b'\\xf1\\x00HI__ SCC FHCUP      1.00 1.02 99110-D2100         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00HI  LKAS AT USA LHD 1.00 1.00 95895-D2020 160302',\n      b'\\xf1\\x00HI  LKAS AT USA LHD 1.00 1.00 95895-D2030 170208',\n      b'\\xf1\\x00HI  MFC  AT USA LHD 1.00 1.03 99211-D2000 190831',\n    ],\n  },\n  CAR.HYUNDAI_KONA: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00OS__ SCC F-CUP      1.00 1.00 95655-J9200         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00OS  MDPS C 1.00 1.05 56310J9030\\x00 4OSDC105',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00OS9 LKAS AT USA LHD 1.00 1.00 95740-J9300 g21',\n    ],\n  },\n  CAR.KIA_CEED: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CD__ SCC F-CUP      1.00 1.02 99110-J7000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00CD  MDPS C 1.00 1.06 56310-XX000 4CDEC106',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CD  LKAS AT EUR LHD 1.00 1.01 99211-J7000 B40',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00CD ESC \\x03 102\\x18\\x08\\x05 58920-J7350',\n    ],\n  },\n  CAR.KIA_FORTE: {\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00BD  MDPS C 1.00 1.02 56310-XX000 4BD2C102',\n      b'\\xf1\\x00BD  MDPS C 1.00 1.08 56310/M6300 4BDDC108',\n      b'\\xf1\\x00BD  MDPS C 1.00 1.08 56310M6300\\x00 4BDDC108',\n      b'\\xf1\\x00BDm MDPS C A.01 1.01 56310M7800\\x00 4BPMC101',\n      b'\\xf1\\x00BDm MDPS C A.01 1.03 56310M7800\\x00 4BPMC103',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00BD  LKAS AT USA LHD 1.00 1.04 95740-M6000 J33',\n      b'\\xf1\\x00BDP LKAS AT USA LHD 1.00 1.05 99211-M6500 744',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00BDPE_SCC FHCUPC     1.00 1.04 99110-M6500\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\xf1\\x00BD__ SCC H-CUP      1.00 1.02 99110-M6000         ',\n    ],\n  },\n  CAR.KIA_K5_2021: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DL3_ SCC F-CUP      1.00 1.03 99110-L2100         ',\n      b'\\xf1\\x00DL3_ SCC FHCUP      1.00 1.03 99110-L2000         ',\n      b'\\xf1\\x00DL3_ SCC FHCUP      1.00 1.03 99110-L2100         ',\n      b'\\xf1\\x00DL3_ SCC FHCUP      1.00 1.04 99110-L2100         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DL3 MDPS C 1.00 1.01 56310-L3110 4DLAC101',\n      b'\\xf1\\x00DL3 MDPS C 1.00 1.01 56310-L3220 4DLAC101',\n      b'\\xf1\\x00DL3 MDPS C 1.00 1.02 56310-L2220 4DLDC102',\n      b'\\xf1\\x00DL3 MDPS C 1.00 1.02 56310L3220\\x00 4DLAC102',\n      b'\\xf1\\x00DL3 MDPS R 1.00 1.02 57700-L3000 4DLAP102',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DL3 MFC  AT KOR LHD 1.00 1.04 99210-L2000 210527',\n      b'\\xf1\\x00DL3 MFC  AT USA LHD 1.00 1.03 99210-L3000 200915',\n      b'\\xf1\\x00DL3 MFC  AT USA LHD 1.00 1.04 99210-L3000 210208',\n      b'\\xf1\\x00DL3 MFC  AT USA LHD 1.00 1.05 99210-L3000 211222',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00DL ESC \\x01 104 \\x07\\x12 58910-L2200',\n      b'\\xf1\\x00DL ESC \\x03 100 \\x08\\x02 58910-L3600',\n      b'\\xf1\\x00DL ESC \\x06 101 \\x04\\x02 58910-L3200',\n      b'\\xf1\\x00DL ESC \\x06 103\"\\x08\\x06 58910-L3200',\n      b'\\xf1\\x00DL ESC \\t 100 \\x06\\x02 58910-L3800',\n      b'\\xf1\\x00DL ESC \\t 101 \\x07\\x02 58910-L3800',\n      b'\\xf1\\x00DL ESC \\t 102\"\\x08\\x10 58910-L3800',\n    ],\n  },\n  CAR.KIA_K5_HEV_2020: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DLhe SCC FHCUP      1.00 1.02 99110-L7000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DL3 MDPS C 1.00 1.02 56310-L7000 4DLHC102',\n      b'\\xf1\\x00DL3 MDPS C 1.00 1.02 56310-L7220 4DLHC102',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DL3HMFC  AT KOR LHD 1.00 1.02 99210-L2000 200309',\n      b'\\xf1\\x00DL3HMFC  AT KOR LHD 1.00 1.04 99210-L2000 210527',\n    ],\n  },\n  CAR.HYUNDAI_KONA_EV: {\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00OS IEB \\x01 212 \\x11\\x13 58520-K4000',\n      b'\\xf1\\x00OS IEB \\x02 210 \\x02\\x14 58520-K4000',\n      b'\\xf1\\x00OS IEB \\x02 212 \\x11\\x13 58520-K4000',\n      b'\\xf1\\x00OS IEB \\x03 210 \\x02\\x14 58520-K4000',\n      b'\\xf1\\x00OS IEB \\x03 212 \\x11\\x13 58520-K4000',\n      b'\\xf1\\x00OS IEB \\r 105\\x18\\t\\x18 58520-K4000',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00OE2 LKAS AT EUR LHD 1.00 1.00 95740-K4200 200',\n      b'\\xf1\\x00OSE LKAS AT EUR LHD 1.00 1.00 95740-K4100 W40',\n      b'\\xf1\\x00OSE LKAS AT EUR RHD 1.00 1.00 95740-K4100 W40',\n      b'\\xf1\\x00OSE LKAS AT KOR LHD 1.00 1.00 95740-K4100 W40',\n      b'\\xf1\\x00OSE LKAS AT USA LHD 1.00 1.00 95740-K4100 W40',\n      b'\\xf1\\x00OSE LKAS AT USA LHD 1.00 1.00 95740-K4300 W50',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00OS  MDPS C 1.00 1.03 56310/K4550 4OEDC103',\n      b'\\xf1\\x00OS  MDPS C 1.00 1.04 56310-XX000 4OEDC104',\n      b'\\xf1\\x00OS  MDPS C 1.00 1.04 56310K4000\\x00 4OEDC104',\n      b'\\xf1\\x00OS  MDPS C 1.00 1.04 56310K4050\\x00 4OEDC104',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00OSev SCC F-CUP      1.00 1.00 99110-K4000         ',\n      b'\\xf1\\x00OSev SCC F-CUP      1.00 1.00 99110-K4100         ',\n      b'\\xf1\\x00OSev SCC F-CUP      1.00 1.01 99110-K4000         ',\n      b'\\xf1\\x00OSev SCC FNCUP      1.00 1.01 99110-K4000         ',\n    ],\n  },\n  CAR.HYUNDAI_KONA_EV_2022: {\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00OS IEB \\x02 102\"\\x05\\x16 58520-K4010',\n      b'\\xf1\\x00OS IEB \\x03 101 \\x11\\x13 58520-K4010',\n      b'\\xf1\\x00OS IEB \\x03 102\"\\x05\\x16 58520-K4010',\n      b'\\xf1\\x00OS IEB \\r 102\"\\x05\\x16 58520-K4010',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00OSP LKA  AT AUS RHD 1.00 1.04 99211-J9200 904',\n      b'\\xf1\\x00OSP LKA  AT CND LHD 1.00 1.02 99211-J9110 802',\n      b'\\xf1\\x00OSP LKA  AT EUR LHD 1.00 1.04 99211-J9200 904',\n      b'\\xf1\\x00OSP LKA  AT EUR RHD 1.00 1.02 99211-J9110 802',\n      b'\\xf1\\x00OSP LKA  AT EUR RHD 1.00 1.04 99211-J9200 904',\n      b'\\xf1\\x00OSP LKA  AT USA LHD 1.00 1.04 99211-J9200 904',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00OSP MDPS C 1.00 1.02 56310-K4271 4OEPC102',\n      b'\\xf1\\x00OSP MDPS C 1.00 1.02 56310/K4271 4OEPC102',\n      b'\\xf1\\x00OSP MDPS C 1.00 1.02 56310/K4970 4OEPC102',\n      b'\\xf1\\x00OSP MDPS C 1.00 1.02 56310K4260\\x00 4OEPC102',\n      b'\\xf1\\x00OSP MDPS C 1.00 1.02 56310K4261\\x00 4OEPC102',\n      b'\\xf1\\x00OSP MDPS C 1.00 1.02 56310K4971\\x00 4OEPC102',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00YB__ FCA -----      1.00 1.01 99110-K4500      \\x00\\x00\\x00',\n    ],\n  },\n  CAR.HYUNDAI_KONA_EV_2ND_GEN: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00SXev RDR -----      1.00 1.00 99110-BF000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00SX2EMFC  AT KOR LHD 1.00 1.00 99211-BF000 230410',\n    ],\n  },\n  CAR.KIA_NIRO_EV: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.00 99110-Q4000         ',\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.00 99110-Q4100         ',\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.00 99110-Q4500         ',\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.00 99110-Q4600         ',\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.02 96400-Q4000         ',\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.02 96400-Q4100         ',\n      b'\\xf1\\x00DEev SCC F-CUP      1.00 1.03 96400-Q4100         ',\n      b'\\xf1\\x00DEev SCC FHCUP      1.00 1.00 99110-Q4600         ',\n      b'\\xf1\\x00DEev SCC FHCUP      1.00 1.03 96400-Q4000         ',\n      b'\\xf1\\x00DEev SCC FNCUP      1.00 1.00 99110-Q4600         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DE  MDPS C 1.00 1.04 56310Q4100\\x00 4DEEC104',\n      b'\\xf1\\x00DE  MDPS C 1.00 1.05 56310Q4000\\x00 4DEEC105',\n      b'\\xf1\\x00DE  MDPS C 1.00 1.05 56310Q4100\\x00 4DEEC105',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DEE MFC  AT EUR LHD 1.00 1.00 99211-Q4000 191211',\n      b'\\xf1\\x00DEE MFC  AT EUR LHD 1.00 1.00 99211-Q4100 200706',\n      b'\\xf1\\x00DEE MFC  AT EUR LHD 1.00 1.03 95740-Q4000 180821',\n      b'\\xf1\\x00DEE MFC  AT KOR LHD 1.00 1.03 95740-Q4000 180821',\n      b'\\xf1\\x00DEE MFC  AT USA LHD 1.00 1.00 99211-Q4000 191211',\n      b'\\xf1\\x00DEE MFC  AT USA LHD 1.00 1.01 99211-Q4500 210428',\n      b'\\xf1\\x00DEE MFC  AT USA LHD 1.00 1.03 95740-Q4000 180821',\n    ],\n  },\n  CAR.KIA_NIRO_EV_2ND_GEN: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00SG2_ RDR -----      1.00 1.01 99110-AT000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00SG2EMFC  AT EUR LHD 1.01 1.09 99211-AT000 220801',\n      b'\\xf1\\x00SG2EMFC  AT USA LHD 1.01 1.09 99211-AT000 220801',\n    ],\n  },\n  CAR.KIA_NIRO_PHEV: {\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DE  MDPS C 1.00 1.01 56310G5520\\x00 4DEPC101',\n      b'\\xf1\\x00DE  MDPS C 1.00 1.09 56310G5301\\x00 4DEHC109',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DEH MFC  AT USA LHD 1.00 1.00 95740-G5010 170117',\n      b'\\xf1\\x00DEP MFC  AT USA LHD 1.00 1.00 95740-G5010 170117',\n      b'\\xf1\\x00DEP MFC  AT USA LHD 1.00 1.01 95740-G5010 170424',\n      b'\\xf1\\x00DEP MFC  AT USA LHD 1.00 1.05 99211-G5000 190826',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DEhe SCC F-CUP      1.00 1.02 99110-G5100         ',\n      b'\\xf1\\x00DEhe SCC H-CUP      1.01 1.02 96400-G5100         ',\n    ],\n  },\n  CAR.KIA_NIRO_PHEV_2022: {\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DE  MDPS C 1.00 1.01 56310G5520\\x00 4DEPC101',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DEP MFC  AT USA LHD 1.00 1.00 99211-G5500 210428',\n      b'\\xf1\\x00DEP MFC  AT USA LHD 1.00 1.06 99211-G5000 201028',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DEhe SCC F-CUP      1.00 1.00 99110-G5600         ',\n      b'\\xf1\\x00DEhe SCC FHCUP      1.00 1.00 99110-G5600         ',\n    ],\n  },\n  CAR.KIA_NIRO_HEV_2021: {\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DE  MDPS C 1.00 1.01 56310G5520\\x00 4DEPC101',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DEH MFC  AT KOR LHD 1.00 1.04 99211-G5000 190516',\n      b'\\xf1\\x00DEH MFC  AT USA LHD 1.00 1.00 99211-G5500 210428',\n      b'\\xf1\\x00DEH MFC  AT USA LHD 1.00 1.07 99211-G5000 201221',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DEhe SCC FHCUP      1.00 1.00 99110-G5600         ',\n      b'\\xf1\\x00DEhe SCC FHCUP      1.00 1.01 99110-G5000         ',\n    ],\n  },\n  CAR.KIA_SELTOS: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00SP2_ SCC FHCUP      1.01 1.05 99110-Q5100         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00SP ESC \\x07 101\\x19\\t\\x05 58910-Q5450',\n      b'\\xf1\\x00SP ESC \\t 101\\x19\\t\\x05 58910-Q5450',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00SP2 MDPS C 1.00 1.04 56300Q5200          ',\n      b'\\xf1\\x00SP2 MDPS C 1.01 1.05 56300Q5200          ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00SP2 MFC  AT USA LHD 1.00 1.04 99210-Q5000 191114',\n      b'\\xf1\\x00SP2 MFC  AT USA LHD 1.00 1.05 99210-Q5000 201012',\n    ],\n  },\n  CAR.KIA_OPTIMA_G4: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JF__ SCC F-CUP      1.00 1.00 96400-D4100         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00JF ESC \\x0f 16 \\x16\\x06\\x17 58920-D5080',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JFWGN LDWS AT USA LHD 1.00 1.02 95895-D4100 G21',\n    ],\n  },\n  CAR.KIA_OPTIMA_G4_FL: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JF__ SCC F-CUP      1.00 1.00 96400-D4110         ',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b\"\\xf1\\x00JF ESC \\t 11 \\x18\\x03' 58920-D5260\",\n      b'\\xf1\\x00JF ESC \\x0b 11 \\x18\\x030 58920-D5180',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JFA LKAS AT USA LHD 1.00 1.00 95895-D5001 h32',\n      b'\\xf1\\x00JFA LKAS AT USA LHD 1.00 1.00 95895-D5100 h32',\n    ],\n  },\n  CAR.KIA_OPTIMA_H: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JFhe SCC FNCUP      1.00 1.00 96400-A8000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JFP LKAS AT EUR LHD 1.00 1.03 95895-A8100 160711',\n    ],\n  },\n  CAR.KIA_OPTIMA_H_G4_FL: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JFhe SCC FHCUP      1.00 1.01 99110-A8500         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JFH MFC  AT KOR LHD 1.00 1.01 95895-A8200 180323',\n    ],\n  },\n  CAR.HYUNDAI_ELANTRA: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00AD  LKAS AT USA LHD 1.01 1.01 95895-F2000 251',\n      b'\\xf1\\x00ADP LKAS AT USA LHD 1.00 1.03 99211-F2000 X31',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00AD ESC \\x11 11 \\x18\\x05\\x06 58910-F2840',\n      b'\\xf1\\x00AD ESC \\x11 12 \\x15\\t\\t 58920-F2810',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00AD__ SCC H-CUP      1.00 1.00 99110-F2100         ',\n      b'\\xf1\\x00AD__ SCC H-CUP      1.00 1.01 96400-F2100         ',\n    ],\n  },\n  CAR.HYUNDAI_ELANTRA_GT_I30: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00PD  LKAS AT KOR LHD 1.00 1.02 95740-G3000 A51',\n      b'\\xf1\\x00PD  LKAS AT USA LHD 1.00 1.02 95740-G3000 A51',\n      b'\\xf1\\x00PD  LKAS AT USA LHD 1.01 1.01 95740-G3100 A54',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00PD  MDPS C 1.00 1.00 56310G3300\\x00 4PDDC100',\n      b'\\xf1\\x00PD  MDPS C 1.00 1.03 56310/G3300 4PDDC103',\n      b'\\xf1\\x00PD  MDPS C 1.00 1.04 56310/G3300 4PDDC104',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00PD ESC \\t 104\\x18\\t\\x03 58920-G3350',\n      b'\\xf1\\x00PD ESC \\x0b 103\\x17\\x110 58920-G3350',\n      b'\\xf1\\x00PD ESC \\x0b 104\\x18\\t\\x03 58920-G3350',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00PD__ SCC F-CUP      1.00 1.00 96400-G3300         ',\n      b'\\xf1\\x00PD__ SCC F-CUP      1.01 1.00 96400-G3100         ',\n      b'\\xf1\\x00PD__ SCC FNCUP      1.01 1.00 96400-G3000         ',\n    ],\n  },\n  CAR.HYUNDAI_ELANTRA_2021: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CN7_ SCC F-CUP      1.00 1.01 99110-AA000         ',\n      b'\\xf1\\x00CN7_ SCC FHCUP      1.00 1.01 99110-AA000         ',\n      b'\\xf1\\x00CN7_ SCC FNCUP      1.00 1.01 99110-AA000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.06 56310/AA050 4CNDC106',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.06 56310/AA070 4CNDC106',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.06 56310AA050\\x00 4CNDC106',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.07 56310AA050\\x00 4CNDC107',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.00 99210-AB000 200819',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.01 99210-AB000 210205',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.02 99210-AB000 220111',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.03 99210-AA000 200819',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.03 99210-AB000 220426',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.06 99210-AA000 220111',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.07 99210-AA000 220426',\n      b'\\xf1\\x00CN7 MFC  AT USA LHD 1.00 1.08 99210-AA000 220728',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00CN ESC \\t 101 \\x10\\x03 58910-AB800',\n      b'\\xf1\\x00CN ESC \\t 104 \\x08\\x03 58910-AA800',\n      b'\\xf1\\x00CN ESC \\t 105 \\x10\\x03 58910-AA800',\n    ],\n  },\n  CAR.HYUNDAI_ELANTRA_HEV_2021: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CN7HMFC  AT USA LHD 1.00 1.03 99210-AA000 200819',\n      b'\\xf1\\x00CN7HMFC  AT USA LHD 1.00 1.05 99210-AA000 210930',\n      b'\\xf1\\x00CN7HMFC  AT USA LHD 1.00 1.07 99210-AA000 220426',\n      b'\\xf1\\x00CN7HMFC  AT USA LHD 1.00 1.08 99210-AA000 220728',\n      b'\\xf1\\x00CN7HMFC  AT USA LHD 1.00 1.09 99210-AA000 221108',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CNhe SCC FHCUP      1.00 1.01 99110-BY000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.02 56310/BY050 4CNHC102',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.03 56310/BY050 4CNHC103',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.03 56310BY050\\x00 4CNHC103',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.03 56310BY0500 4CNHC103',\n      b'\\xf1\\x00CN7 MDPS C 1.00 1.04 56310BY050\\x00 4CNHC104',\n    ],\n  },\n  CAR.HYUNDAI_KONA_HEV: {\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00OS IEB \\x01 104 \\x11  58520-CM000',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00OShe SCC FNCUP      1.00 1.01 99110-CM000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00OS  MDPS C 1.00 1.00 56310CM030\\x00 4OHDC100',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00OSH LKAS AT KOR LHD 1.00 1.01 95740-CM000 l31',\n    ],\n  },\n  CAR.HYUNDAI_SONATA_HYBRID: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00DNhe SCC F-CUP      1.00 1.02 99110-L5000         ',\n      b'\\xf1\\x00DNhe SCC FHCUP      1.00 1.00 99110-L5000         ',\n      b'\\xf1\\x00DNhe SCC FHCUP      1.00 1.02 99110-L5000         ',\n    ],\n    (Ecu.eps, 0x7d4, None): [\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.01 56310-L5000 4DNHC101',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.02 56310-L5450 4DNHC102',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.02 56310-L5500 4DNHC102',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.03 56310-L5450 4DNHC103',\n      b'\\xf1\\x00DN8 MDPS C 1.00 1.03 56310L5450\\x00 4DNHC104',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00DN8HMFC  AT KOR LHD 1.00 1.03 99211-L1000 190705',\n      b'\\xf1\\x00DN8HMFC  AT USA LHD 1.00 1.04 99211-L1000 191016',\n      b'\\xf1\\x00DN8HMFC  AT USA LHD 1.00 1.05 99211-L1000 201109',\n      b'\\xf1\\x00DN8HMFC  AT USA LHD 1.00 1.06 99211-L1000 210325',\n      b'\\xf1\\x00DN8HMFC  AT USA LHD 1.00 1.07 99211-L1000 211223',\n    ],\n  },\n  CAR.KIA_SORENTO: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00UMP LKAS AT KOR LHD 1.00 1.00 95740-C5550 S30',\n      b'\\xf1\\x00UMP LKAS AT USA LHD 1.00 1.00 95740-C6550 d00',\n      b'\\xf1\\x00UMP LKAS AT USA LHD 1.01 1.01 95740-C6550 d01',\n    ],\n    (Ecu.abs, 0x7d1, None): [\n      b'\\xf1\\x00UM ESC \\x02 12 \\x18\\x05\\x05 58910-C6300',\n      b'\\xf1\\x00UM ESC \\x0c 12 \\x18\\x05\\x06 58910-C6330',\n      b'\\xf1\\x00UM ESC \\x13 12 \\x17\\x07\\x05 58910-C5320',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00UM__ SCC F-CUP      1.00 1.00 96400-C5500         ',\n      b'\\xf1\\x00UM__ SCC F-CUP      1.00 1.00 96400-C6500         ',\n    ],\n  },\n  CAR.KIA_EV6: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CV1_ RDR -----      1.00 1.01 99110-CV000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CV1 MFC  AT EUR LHD 1.00 1.05 99210-CV000 211027',\n      b'\\xf1\\x00CV1 MFC  AT EUR LHD 1.00 1.06 99210-CV000 220328',\n      b'\\xf1\\x00CV1 MFC  AT EUR RHD 1.00 1.00 99210-CV100 220630',\n      b'\\xf1\\x00CV1 MFC  AT KOR LHD 1.00 1.04 99210-CV000 210823',\n      b'\\xf1\\x00CV1 MFC  AT KOR LHD 1.00 1.05 99210-CV000 211027',\n      b'\\xf1\\x00CV1 MFC  AT KOR LHD 1.00 1.06 99210-CV000 220328',\n      b'\\xf1\\x00CV1 MFC  AT USA LHD 1.00 1.00 99210-CV100 220630',\n      b'\\xf1\\x00CV1 MFC  AT USA LHD 1.00 1.00 99210-CV200 230510',\n      b'\\xf1\\x00CV1 MFC  AT USA LHD 1.00 1.05 99210-CV000 211027',\n      b'\\xf1\\x00CV1 MFC  AT USA LHD 1.00 1.06 99210-CV000 220328',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_5: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00NE1_ RDR -----      1.00 1.00 99110-GI000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00NE1 MFC  AT CAN LHD 1.00 1.01 99211-GI010 211007',\n      b'\\xf1\\x00NE1 MFC  AT CAN LHD 1.00 1.05 99211-GI010 220614',\n      b'\\xf1\\x00NE1 MFC  AT EUR LHD 1.00 1.00 99211-GI100 230915',\n      b'\\xf1\\x00NE1 MFC  AT EUR LHD 1.00 1.01 99211-GI010 211007',\n      b'\\xf1\\x00NE1 MFC  AT EUR LHD 1.00 1.06 99211-GI000 210813',\n      b'\\xf1\\x00NE1 MFC  AT EUR LHD 1.00 1.06 99211-GI010 230110',\n      b'\\xf1\\x00NE1 MFC  AT EUR RHD 1.00 1.01 99211-GI010 211007',\n      b'\\xf1\\x00NE1 MFC  AT EUR RHD 1.00 1.02 99211-GI010 211206',\n      b'\\xf1\\x00NE1 MFC  AT KOR LHD 1.00 1.00 99211-GI020 230719',\n      b'\\xf1\\x00NE1 MFC  AT KOR LHD 1.00 1.05 99211-GI010 220614',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.00 99211-GI020 230719',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.00 99211-GI100 230915',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.01 99211-GI010 211007',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.02 99211-GI010 211206',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.03 99211-GI010 220401',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.05 99211-GI010 220614',\n      b'\\xf1\\x00NE1 MFC  AT USA LHD 1.00 1.06 99211-GI010 230110',\n    ],\n  },\n  CAR.HYUNDAI_IONIQ_6: {\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00CE__ RDR -----      1.00 1.01 99110-KL000         ',\n    ],\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00CE  MFC  AT CAN LHD 1.00 1.04 99211-KL000 221213',\n      b'\\xf1\\x00CE  MFC  AT EUR LHD 1.00 1.03 99211-KL000 221011',\n      b'\\xf1\\x00CE  MFC  AT EUR LHD 1.00 1.04 99211-KL000 221213',\n      b'\\xf1\\x00CE  MFC  AT USA LHD 1.00 1.04 99211-KL000 221213',\n    ],\n  },\n  CAR.HYUNDAI_TUCSON_4TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00NX4 FR_CMR AT CAN LHD 1.00 1.00 99211-N9260 14Y',\n      b'\\xf1\\x00NX4 FR_CMR AT CAN LHD 1.00 1.01 99211-N9100 14A',\n      b'\\xf1\\x00NX4 FR_CMR AT EUR LHD 1.00 1.00 99211-N9220 14K',\n      b'\\xf1\\x00NX4 FR_CMR AT EUR LHD 1.00 2.02 99211-N9000 14E',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-N9210 14G',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-N9220 14K',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-N9240 14Q',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-N9250 14W',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-N9260 14Y',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.01 99211-N9100 14A',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.01 99211-N9240 14T',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00NX4__               1.00 1.00 99110-N9100         ',\n      b'\\xf1\\x00NX4__               1.00 1.01 99110-N9000         ',\n      b'\\xf1\\x00NX4__               1.00 1.02 99110-N9000         ',\n      b'\\xf1\\x00NX4__               1.01 1.00 99110-N9100         ',\n    ],\n  },\n  CAR.HYUNDAI_SANTA_CRUZ_1ST_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-CW000 14M',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-CW010 14X',\n      b'\\xf1\\x00NX4 FR_CMR AT USA LHD 1.00 1.00 99211-CW020 14Z',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00NX4__               1.00 1.00 99110-K5000         ',\n      b'\\xf1\\x00NX4__               1.01 1.00 99110-K5000         ',\n    ],\n  },\n  CAR.KIA_SPORTAGE_5TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00NQ5 FR_CMR AT AUS RHD 1.00 1.00 99211-P1040 663',\n      b'\\xf1\\x00NQ5 FR_CMR AT EUR LHD 1.00 1.00 99211-P1040 663',\n      b'\\xf1\\x00NQ5 FR_CMR AT GEN LHD 1.00 1.00 99211-P1060 665',\n      b'\\xf1\\x00NQ5 FR_CMR AT USA LHD 1.00 1.00 99211-P1030 662',\n      b'\\xf1\\x00NQ5 FR_CMR AT USA LHD 1.00 1.00 99211-P1040 663',\n      b'\\xf1\\x00NQ5 FR_CMR AT USA LHD 1.00 1.00 99211-P1060 665',\n      b'\\xf1\\x00NQ5 FR_CMR AT USA LHD 1.00 1.00 99211-P1070 690',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00NQ5__               1.00 1.02 99110-P1000         ',\n      b'\\xf1\\x00NQ5__               1.00 1.03 99110-CH000         ',\n      b'\\xf1\\x00NQ5__               1.00 1.03 99110-P1000         ',\n      b'\\xf1\\x00NQ5__               1.01 1.03 99110-CH000         ',\n      b'\\xf1\\x00NQ5__               1.01 1.03 99110-P1000         ',\n    ],\n  },\n  CAR.GENESIS_GV70_1ST_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JK1 MFC  AT USA LHD 1.00 1.01 99211-AR200 220125',\n      b'\\xf1\\x00JK1 MFC  AT USA LHD 1.00 1.01 99211-AR300 220125',\n      b'\\xf1\\x00JK1 MFC  AT USA LHD 1.00 1.04 99211-AR000 210204',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JK1_ SCC FHCUP      1.00 1.00 99110-AR200         ',\n      b'\\xf1\\x00JK1_ SCC FHCUP      1.00 1.00 99110-AR300         ',\n      b'\\xf1\\x00JK1_ SCC FHCUP      1.00 1.02 99110-AR000         ',\n    ],\n  },\n  CAR.GENESIS_GV60_EV_1ST_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JW1 MFC  AT USA LHD 1.00 1.02 99211-CU000 211215',\n      b'\\xf1\\x00JW1 MFC  AT USA LHD 1.00 1.02 99211-CU100 211215',\n      b'\\xf1\\x00JW1 MFC  AT USA LHD 1.00 1.03 99211-CU000 221118',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JW1_ RDR -----      1.00 1.00 99110-CU000         ',\n    ],\n  },\n  CAR.KIA_SORENTO_4TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00MQ4 MFC  AT USA LHD 1.00 1.00 99210-R5100 221019',\n      b'\\xf1\\x00MQ4 MFC  AT USA LHD 1.00 1.03 99210-R5000 200903',\n      b'\\xf1\\x00MQ4 MFC  AT USA LHD 1.00 1.05 99210-R5000 210623',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00MQ4_ SCC F-CUP      1.00 1.06 99110-P2000         ',\n      b'\\xf1\\x00MQ4_ SCC FHCUP      1.00 1.00 99110-R5000         ',\n      b'\\xf1\\x00MQ4_ SCC FHCUP      1.00 1.06 99110-P2000         ',\n      b'\\xf1\\x00MQ4_ SCC FHCUP      1.00 1.08 99110-P2000         ',\n    ],\n  },\n  CAR.KIA_SORENTO_HEV_4TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00MQ4HMFC  AT KOR LHD 1.00 1.04 99210-P2000 200330',\n      b'\\xf1\\x00MQ4HMFC  AT KOR LHD 1.00 1.12 99210-P2000 230331',\n      b'\\xf1\\x00MQ4HMFC  AT USA LHD 1.00 1.10 99210-P2000 210406',\n      b'\\xf1\\x00MQ4HMFC  AT USA LHD 1.00 1.11 99210-P2000 211217',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00MQhe SCC FHCUP      1.00 1.04 99110-P4000         ',\n      b'\\xf1\\x00MQhe SCC FHCUP      1.00 1.06 99110-P4000         ',\n      b'\\xf1\\x00MQhe SCC FHCUP      1.00 1.07 99110-P4000         ',\n    ],\n  },\n  CAR.KIA_NIRO_HEV_2ND_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00SG2HMFC  AT USA LHD 1.01 1.08 99211-AT000 220531',\n      b'\\xf1\\x00SG2HMFC  AT USA LHD 1.01 1.09 99211-AT000 220801',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00SG2_ RDR -----      1.00 1.01 99110-AT000         ',\n    ],\n  },\n  CAR.GENESIS_GV80: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00JX1 MFC  AT USA LHD 1.00 1.02 99211-T6110 220513',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00JX1_ SCC FHCUP      1.00 1.01 99110-T6100         ',\n    ],\n  },\n  CAR.KIA_CARNIVAL_4TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00KA4 MFC  AT EUR LHD 1.00 1.06 99210-R0000 220221',\n      b'\\xf1\\x00KA4 MFC  AT KOR LHD 1.00 1.06 99210-R0000 220221',\n      b'\\xf1\\x00KA4 MFC  AT USA LHD 1.00 1.00 99210-R0100 230105',\n      b'\\xf1\\x00KA4 MFC  AT USA LHD 1.00 1.01 99210-R0100 230710',\n      b'\\xf1\\x00KA4 MFC  AT USA LHD 1.00 1.05 99210-R0000 201221',\n      b'\\xf1\\x00KA4 MFC  AT USA LHD 1.00 1.06 99210-R0000 220221',\n      b'\\xf1\\x00KA4CMFC  AT CHN LHD 1.00 1.01 99211-I4000 210525',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00KA4_ SCC F-CUP      1.00 1.03 99110-R0000         ',\n      b'\\xf1\\x00KA4_ SCC FHCUP      1.00 1.00 99110-R0100         ',\n      b'\\xf1\\x00KA4_ SCC FHCUP      1.00 1.03 99110-R0000         ',\n      b'\\xf1\\x00KA4c SCC FHCUP      1.00 1.01 99110-I4000         ',\n    ],\n  },\n  CAR.KIA_K8_HEV_1ST_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00GL3HMFC  AT KOR LHD 1.00 1.03 99211-L8000 210907',\n      b'\\xf1\\x00GL3HMFC  AT KOR LHD 1.00 1.04 99211-L8000 230207',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00GL3_ RDR -----      1.00 1.02 99110-L8000         ',\n    ],\n  },\n  CAR.HYUNDAI_STARIA_4TH_GEN: {\n    (Ecu.fwdCamera, 0x7c4, None): [\n      b'\\xf1\\x00US4 MFC  AT KOR LHD 1.00 1.06 99211-CG000 230524',\n    ],\n    (Ecu.fwdRadar, 0x7d0, None): [\n      b'\\xf1\\x00US4_ RDR -----      1.00 1.00 99110-CG000         ',\n    ],\n  },\n}\n", "selfdrive/car/hyundai/values.py": "import re\nfrom dataclasses import dataclass, field\nfrom enum import Enum, IntFlag\n\nfrom cereal import car\nfrom panda.python import uds\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import CarSpecs, DbcDict, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarFootnote, CarHarness, CarDocs, CarParts, Column\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, p16\n\nEcu = car.CarParams.Ecu\n\n\nclass CarControllerParams:\n  ACCEL_MIN = -3.5 # m/s\n  ACCEL_MAX = 2.0 # m/s\n\n  def __init__(self, CP):\n    self.STEER_DELTA_UP = 3\n    self.STEER_DELTA_DOWN = 7\n    self.STEER_DRIVER_ALLOWANCE = 50\n    self.STEER_DRIVER_MULTIPLIER = 2\n    self.STEER_DRIVER_FACTOR = 1\n    self.STEER_THRESHOLD = 150\n    self.STEER_STEP = 1  # 100 Hz\n\n    if CP.carFingerprint in CANFD_CAR:\n      self.STEER_MAX = 270\n      self.STEER_DRIVER_ALLOWANCE = 250\n      self.STEER_DRIVER_MULTIPLIER = 2\n      self.STEER_THRESHOLD = 250\n      self.STEER_DELTA_UP = 2\n      self.STEER_DELTA_DOWN = 3\n\n    # To determine the limit for your car, find the maximum value that the stock LKAS will request.\n    # If the max stock LKAS request is <384, add your car to this list.\n    elif CP.carFingerprint in (CAR.GENESIS_G80, CAR.GENESIS_G90, CAR.HYUNDAI_ELANTRA, CAR.HYUNDAI_ELANTRA_GT_I30, CAR.HYUNDAI_IONIQ,\n                               CAR.HYUNDAI_IONIQ_EV_LTD, CAR.HYUNDAI_SANTA_FE_PHEV_2022, CAR.HYUNDAI_SONATA_LF, CAR.KIA_FORTE, CAR.KIA_NIRO_PHEV,\n                               CAR.KIA_OPTIMA_H, CAR.KIA_OPTIMA_H_G4_FL, CAR.KIA_SORENTO):\n      self.STEER_MAX = 255\n\n    # these cars have significantly more torque than most HKG; limit to 70% of max\n    elif CP.flags & HyundaiFlags.ALT_LIMITS:\n      self.STEER_MAX = 270\n      self.STEER_DELTA_UP = 2\n      self.STEER_DELTA_DOWN = 3\n\n    # Default for most HKG\n    else:\n      self.STEER_MAX = 384\n\n\nclass HyundaiFlags(IntFlag):\n  # Dynamic Flags\n  CANFD_HDA2 = 1\n  CANFD_ALT_BUTTONS = 2\n  CANFD_ALT_GEARS = 2 ** 2\n  CANFD_CAMERA_SCC = 2 ** 3\n\n  ALT_LIMITS = 2 ** 4\n  ENABLE_BLINKERS = 2 ** 5\n  CANFD_ALT_GEARS_2 = 2 ** 6\n  SEND_LFA = 2 ** 7\n  USE_FCA = 2 ** 8\n  CANFD_HDA2_ALT_STEERING = 2 ** 9\n\n  # these cars use a different gas signal\n  HYBRID = 2 ** 10\n  EV = 2 ** 11\n\n  # Static flags\n\n  # If 0x500 is present on bus 1 it probably has a Mando radar outputting radar points.\n  # If no points are outputted by default it might be possible to turn it on using  selfdrive/debug/hyundai_enable_radar_points.py\n  MANDO_RADAR = 2 ** 12\n  CANFD = 2 ** 13\n\n  # The radar does SCC on these cars when HDA I, rather than the camera\n  RADAR_SCC = 2 ** 14\n  CAMERA_SCC = 2 ** 15\n  CHECKSUM_CRC8 = 2 ** 16\n  CHECKSUM_6B = 2 ** 17\n\n  # these cars require a special panda safety mode due to missing counters and checksums in the messages\n  LEGACY = 2 ** 18\n\n  # these cars have not been verified to work with longitudinal yet - radar disable, sending correct messages, etc.\n  UNSUPPORTED_LONGITUDINAL = 2 ** 19\n\n  CANFD_NO_RADAR_DISABLE = 2 ** 20\n\n  CLUSTER_GEARS = 2 ** 21\n  TCU_GEARS = 2 ** 22\n\n  MIN_STEER_32_MPH = 2 ** 23\n\n\nclass Footnote(Enum):\n  CANFD = CarFootnote(\n    \"Requires a <a href=\\\"https://comma.ai/shop/can-fd-panda-kit\\\" target=\\\"_blank\\\">CAN FD panda kit</a> if not using \" +\n    \"comma 3X for this <a href=\\\"https://en.wikipedia.org/wiki/CAN_FD\\\" target=\\\"_blank\\\">CAN FD car</a>.\",\n    Column.MODEL, shop_footnote=False)\n\n\n@dataclass\nclass HyundaiCarDocs(CarDocs):\n  package: str = \"Smart Cruise Control (SCC)\"\n\n  def init_make(self, CP: car.CarParams):\n    if CP.flags & HyundaiFlags.CANFD:\n      self.footnotes.insert(0, Footnote.CANFD)\n\n\n@dataclass\nclass HyundaiPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict(\"hyundai_kia_generic\", None))\n\n  def init(self):\n    if self.flags & HyundaiFlags.MANDO_RADAR:\n      self.dbc_dict = dbc_dict('hyundai_kia_generic', 'hyundai_kia_mando_front_radar_generated')\n\n    if self.flags & HyundaiFlags.MIN_STEER_32_MPH:\n      self.specs = self.specs.override(minSteerSpeed=32 * CV.MPH_TO_MS)\n\n\n@dataclass\nclass HyundaiCanFDPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict(\"hyundai_canfd\", None))\n\n  def init(self):\n    self.flags |= HyundaiFlags.CANFD\n\n\nclass CAR(Platforms):\n  # Hyundai\n  HYUNDAI_AZERA_6TH_GEN = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Azera 2022\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    CarSpecs(mass=1600, wheelbase=2.885, steerRatio=14.5),\n  )\n  HYUNDAI_AZERA_HEV_6TH_GEN = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Hyundai Azera Hybrid 2019\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_c])),\n      HyundaiCarDocs(\"Hyundai Azera Hybrid 2020\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_k])),\n    ],\n    CarSpecs(mass=1675, wheelbase=2.885, steerRatio=14.5),\n    flags=HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_ELANTRA = HyundaiPlatformConfig(\n    [\n      # TODO: 2017-18 could be Hyundai G\n      HyundaiCarDocs(\"Hyundai Elantra 2017-18\", min_enable_speed=19 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_b])),\n      HyundaiCarDocs(\"Hyundai Elantra 2019\", min_enable_speed=19 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_g])),\n    ],\n    # steerRatio: 14 is Stock | Settled Params Learner values are steerRatio: 15.401566348670535, stiffnessFactor settled on 1.0081302973865127\n    CarSpecs(mass=1275, wheelbase=2.7, steerRatio=15.4, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.LEGACY | HyundaiFlags.CLUSTER_GEARS | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  HYUNDAI_ELANTRA_GT_I30 = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Hyundai Elantra GT 2017-19\", car_parts=CarParts.common([CarHarness.hyundai_e])),\n      HyundaiCarDocs(\"Hyundai i30 2017-19\", car_parts=CarParts.common([CarHarness.hyundai_e])),\n    ],\n    HYUNDAI_ELANTRA.specs,\n    flags=HyundaiFlags.LEGACY | HyundaiFlags.CLUSTER_GEARS | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  HYUNDAI_ELANTRA_2021 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Elantra 2021-23\", video_link=\"https://youtu.be/_EdYQtV52-c\", car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    CarSpecs(mass=2800 * CV.LB_TO_KG, wheelbase=2.72, steerRatio=12.9, tireStiffnessFactor=0.65),\n    flags=HyundaiFlags.CHECKSUM_CRC8,\n  )\n  HYUNDAI_ELANTRA_HEV_2021 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Elantra Hybrid 2021-23\", video_link=\"https://youtu.be/_EdYQtV52-c\",\n                    car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    CarSpecs(mass=3017 * CV.LB_TO_KG, wheelbase=2.72, steerRatio=12.9, tireStiffnessFactor=0.65),\n    flags=HyundaiFlags.CHECKSUM_CRC8 | HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_GENESIS = HyundaiPlatformConfig(\n    [\n      # TODO: check 2015 packages\n      HyundaiCarDocs(\"Hyundai Genesis 2015-16\", min_enable_speed=19 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_j])),\n      HyundaiCarDocs(\"Genesis G80 2017\", \"All\", min_enable_speed=19 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_j])),\n    ],\n    CarSpecs(mass=2060, wheelbase=3.01, steerRatio=16.5, minSteerSpeed=60 * CV.KPH_TO_MS),\n    flags=HyundaiFlags.CHECKSUM_6B | HyundaiFlags.LEGACY,\n  )\n  HYUNDAI_IONIQ = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq Hybrid 2017-19\", car_parts=CarParts.common([CarHarness.hyundai_c]))],\n    CarSpecs(mass=1490, wheelbase=2.7, steerRatio=13.73, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.HYBRID | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  HYUNDAI_IONIQ_HEV_2022 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq Hybrid 2020-22\", car_parts=CarParts.common([CarHarness.hyundai_h]))],  # TODO: confirm 2020-21 harness,\n    CarSpecs(mass=1490, wheelbase=2.7, steerRatio=13.73, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.HYBRID | HyundaiFlags.LEGACY,\n  )\n  HYUNDAI_IONIQ_EV_LTD = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq Electric 2019\", car_parts=CarParts.common([CarHarness.hyundai_c]))],\n    CarSpecs(mass=1490, wheelbase=2.7, steerRatio=13.73, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.EV | HyundaiFlags.LEGACY | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  HYUNDAI_IONIQ_EV_2020 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq Electric 2020\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_h]))],\n    CarSpecs(mass=1490, wheelbase=2.7, steerRatio=13.73, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.EV,\n  )\n  HYUNDAI_IONIQ_PHEV_2019 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq Plug-in Hybrid 2019\", car_parts=CarParts.common([CarHarness.hyundai_c]))],\n    CarSpecs(mass=1490, wheelbase=2.7, steerRatio=13.73, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.HYBRID | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  HYUNDAI_IONIQ_PHEV = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq Plug-in Hybrid 2020-22\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_h]))],\n    CarSpecs(mass=1490, wheelbase=2.7, steerRatio=13.73, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_KONA = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Kona 2020\", min_enable_speed=6 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_b]))],\n    CarSpecs(mass=1275, wheelbase=2.6, steerRatio=13.42, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.CLUSTER_GEARS,\n  )\n  HYUNDAI_KONA_EV = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Kona Electric 2018-21\", car_parts=CarParts.common([CarHarness.hyundai_g]))],\n    CarSpecs(mass=1685, wheelbase=2.6, steerRatio=13.42, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.EV,\n  )\n  HYUNDAI_KONA_EV_2022 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Kona Electric 2022-23\", car_parts=CarParts.common([CarHarness.hyundai_o]))],\n    CarSpecs(mass=1743, wheelbase=2.6, steerRatio=13.42, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.CAMERA_SCC | HyundaiFlags.EV,\n  )\n  HYUNDAI_KONA_EV_2ND_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Kona Electric (with HDA II, Korea only) 2023\", video_link=\"https://www.youtube.com/watch?v=U2fOCmcQ8hw\",\n                    car_parts=CarParts.common([CarHarness.hyundai_r]))],\n    CarSpecs(mass=1740, wheelbase=2.66, steerRatio=13.6, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.EV | HyundaiFlags.CANFD_NO_RADAR_DISABLE,\n  )\n  HYUNDAI_KONA_HEV = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Kona Hybrid 2020\", car_parts=CarParts.common([CarHarness.hyundai_i]))],  # TODO: check packages,\n    CarSpecs(mass=1425, wheelbase=2.6, steerRatio=13.42, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_SANTA_FE = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Santa Fe 2019-20\", \"All\", video_link=\"https://youtu.be/bjDR0YjM__s\",\n                    car_parts=CarParts.common([CarHarness.hyundai_d]))],\n    CarSpecs(mass=3982 * CV.LB_TO_KG, wheelbase=2.766, steerRatio=16.55, tireStiffnessFactor=0.82),\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.CHECKSUM_CRC8,\n  )\n  HYUNDAI_SANTA_FE_2022 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Santa Fe 2021-23\", \"All\", video_link=\"https://youtu.be/VnHzSTygTS4\",\n                    car_parts=CarParts.common([CarHarness.hyundai_l]))],\n    HYUNDAI_SANTA_FE.specs,\n    flags=HyundaiFlags.CHECKSUM_CRC8,\n  )\n  HYUNDAI_SANTA_FE_HEV_2022 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Santa Fe Hybrid 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_l]))],\n    HYUNDAI_SANTA_FE.specs,\n    flags=HyundaiFlags.CHECKSUM_CRC8 | HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_SANTA_FE_PHEV_2022 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Santa Fe Plug-in Hybrid 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_l]))],\n    HYUNDAI_SANTA_FE.specs,\n    flags=HyundaiFlags.CHECKSUM_CRC8 | HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_SONATA = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Sonata 2020-23\", \"All\", video_link=\"https://www.youtube.com/watch?v=ix63r9kE3Fw\",\n                   car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    CarSpecs(mass=1513, wheelbase=2.84, steerRatio=13.27 * 1.15, tireStiffnessFactor=0.65),  # 15% higher at the center seems reasonable\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.CHECKSUM_CRC8,\n  )\n  HYUNDAI_SONATA_LF = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Sonata 2018-19\", car_parts=CarParts.common([CarHarness.hyundai_e]))],\n    CarSpecs(mass=1536, wheelbase=2.804, steerRatio=13.27 * 1.15),  # 15% higher at the center seems reasonable\n\n    flags=HyundaiFlags.UNSUPPORTED_LONGITUDINAL | HyundaiFlags.TCU_GEARS,\n  )\n  HYUNDAI_STARIA_4TH_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Staria 2023\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    CarSpecs(mass=2205, wheelbase=3.273, steerRatio=11.94),  # https://www.hyundai.com/content/dam/hyundai/au/en/models/staria-load/premium-pip-update-2023/spec-sheet/STARIA_Load_Spec-Table_March_2023_v3.1.pdf\n  )\n  HYUNDAI_TUCSON = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Hyundai Tucson 2021\", min_enable_speed=19 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_l])),\n      HyundaiCarDocs(\"Hyundai Tucson Diesel 2019\", car_parts=CarParts.common([CarHarness.hyundai_l])),\n    ],\n    CarSpecs(mass=3520 * CV.LB_TO_KG, wheelbase=2.67, steerRatio=16.1, tireStiffnessFactor=0.385),\n    flags=HyundaiFlags.TCU_GEARS,\n  )\n  HYUNDAI_PALISADE = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Hyundai Palisade 2020-22\", \"All\", video_link=\"https://youtu.be/TAnDqjF4fDY?t=456\", car_parts=CarParts.common([CarHarness.hyundai_h])),\n      HyundaiCarDocs(\"Kia Telluride 2020-22\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_h])),\n    ],\n    CarSpecs(mass=1999, wheelbase=2.9, steerRatio=15.6 * 1.15, tireStiffnessFactor=0.63),\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.CHECKSUM_CRC8,\n  )\n  HYUNDAI_VELOSTER = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Veloster 2019-20\", min_enable_speed=5. * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_e]))],\n    CarSpecs(mass=2917 * CV.LB_TO_KG, wheelbase=2.8, steerRatio=13.75 * 1.15, tireStiffnessFactor=0.5),\n    flags=HyundaiFlags.LEGACY | HyundaiFlags.TCU_GEARS,\n  )\n  HYUNDAI_SONATA_HYBRID = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Sonata Hybrid 2020-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    HYUNDAI_SONATA.specs,\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.CHECKSUM_CRC8 | HyundaiFlags.HYBRID,\n  )\n  HYUNDAI_IONIQ_5 = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Hyundai Ioniq 5 (Non-US only) 2022-24\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_q])),\n      HyundaiCarDocs(\"Hyundai Ioniq 5 (without HDA II) 2022-24\", \"Highway Driving Assist\", car_parts=CarParts.common([CarHarness.hyundai_k])),\n      HyundaiCarDocs(\"Hyundai Ioniq 5 (with HDA II) 2022-24\", \"Highway Driving Assist II\", car_parts=CarParts.common([CarHarness.hyundai_q])),\n    ],\n    CarSpecs(mass=1948, wheelbase=2.97, steerRatio=14.26, tireStiffnessFactor=0.65),\n    flags=HyundaiFlags.EV,\n  )\n  HYUNDAI_IONIQ_6 = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Ioniq 6 (with HDA II) 2023-24\", \"Highway Driving Assist II\", car_parts=CarParts.common([CarHarness.hyundai_p]))],\n    HYUNDAI_IONIQ_5.specs,\n    flags=HyundaiFlags.EV | HyundaiFlags.CANFD_NO_RADAR_DISABLE,\n  )\n  HYUNDAI_TUCSON_4TH_GEN = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Hyundai Tucson 2022\", car_parts=CarParts.common([CarHarness.hyundai_n])),\n      HyundaiCarDocs(\"Hyundai Tucson 2023-24\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_n])),\n      HyundaiCarDocs(\"Hyundai Tucson Hybrid 2022-24\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_n])),\n      HyundaiCarDocs(\"Hyundai Tucson Plug-in Hybrid 2024\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_n])),\n    ],\n    CarSpecs(mass=1630, wheelbase=2.756, steerRatio=13.7, tireStiffnessFactor=0.385),\n  )\n  HYUNDAI_SANTA_CRUZ_1ST_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Santa Cruz 2022-24\", car_parts=CarParts.common([CarHarness.hyundai_n]))],\n    # weight from Limited trim - the only supported trim, steering ratio according to Hyundai News https://www.hyundainews.com/assets/documents/original/48035-2022SantaCruzProductGuideSpecsv2081521.pdf\n    CarSpecs(mass=1870, wheelbase=3, steerRatio=14.2),\n  )\n  HYUNDAI_CUSTIN_1ST_GEN = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Hyundai Custin 2023\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    CarSpecs(mass=1690, wheelbase=3.055, steerRatio=17),  # mass: from https://www.hyundai-motor.com.tw/clicktobuy/custin#spec_0, steerRatio: from learner\n    flags=HyundaiFlags.CHECKSUM_CRC8,\n  )\n\n  # Kia\n  KIA_FORTE = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Forte 2019-21\", min_enable_speed=6 * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_g])),\n      HyundaiCarDocs(\"Kia Forte 2022-23\", car_parts=CarParts.common([CarHarness.hyundai_e])),\n    ],\n    CarSpecs(mass=2878 * CV.LB_TO_KG, wheelbase=2.8, steerRatio=13.75, tireStiffnessFactor=0.5)\n  )\n  KIA_K5_2021 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia K5 2021-24\", car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    CarSpecs(mass=3381 * CV.LB_TO_KG, wheelbase=2.85, steerRatio=13.27, tireStiffnessFactor=0.5),  # 2021 Kia K5 Steering Ratio (all trims)\n    flags=HyundaiFlags.CHECKSUM_CRC8,\n  )\n  KIA_K5_HEV_2020 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia K5 Hybrid 2020-22\", car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    KIA_K5_2021.specs,\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.CHECKSUM_CRC8 | HyundaiFlags.HYBRID,\n  )\n  KIA_K8_HEV_1ST_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Kia K8 Hybrid (with HDA II) 2023\", \"Highway Driving Assist II\", car_parts=CarParts.common([CarHarness.hyundai_q]))],\n    # mass: https://carprices.ae/brands/kia/2023/k8/1.6-turbo-hybrid, steerRatio: guesstimate from K5 platform\n    CarSpecs(mass=1630, wheelbase=2.895, steerRatio=13.27)\n  )\n  KIA_NIRO_EV = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Niro EV 2019\", \"All\", video_link=\"https://www.youtube.com/watch?v=lT7zcG6ZpGo\", car_parts=CarParts.common([CarHarness.hyundai_h])),\n      HyundaiCarDocs(\"Kia Niro EV 2020\", \"All\", video_link=\"https://www.youtube.com/watch?v=lT7zcG6ZpGo\", car_parts=CarParts.common([CarHarness.hyundai_f])),\n      HyundaiCarDocs(\"Kia Niro EV 2021\", \"All\", video_link=\"https://www.youtube.com/watch?v=lT7zcG6ZpGo\", car_parts=CarParts.common([CarHarness.hyundai_c])),\n      HyundaiCarDocs(\"Kia Niro EV 2022\", \"All\", video_link=\"https://www.youtube.com/watch?v=lT7zcG6ZpGo\", car_parts=CarParts.common([CarHarness.hyundai_h])),\n    ],\n    CarSpecs(mass=3543 * CV.LB_TO_KG, wheelbase=2.7, steerRatio=13.6, tireStiffnessFactor=0.385),  # average of all the cars\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.EV,\n  )\n  KIA_NIRO_EV_2ND_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Kia Niro EV 2023\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    KIA_NIRO_EV.specs,\n    flags=HyundaiFlags.EV,\n  )\n  KIA_NIRO_PHEV = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Niro Hybrid 2018\", \"All\", min_enable_speed=10. * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_c])),\n      HyundaiCarDocs(\"Kia Niro Plug-in Hybrid 2018-19\", \"All\", min_enable_speed=10. * CV.MPH_TO_MS, car_parts=CarParts.common([CarHarness.hyundai_c])),\n      HyundaiCarDocs(\"Kia Niro Plug-in Hybrid 2020\", car_parts=CarParts.common([CarHarness.hyundai_d])),\n    ],\n    KIA_NIRO_EV.specs,\n    flags=HyundaiFlags.MANDO_RADAR | HyundaiFlags.HYBRID | HyundaiFlags.UNSUPPORTED_LONGITUDINAL | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  KIA_NIRO_PHEV_2022 = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Niro Plug-in Hybrid 2021\", car_parts=CarParts.common([CarHarness.hyundai_d])),\n      HyundaiCarDocs(\"Kia Niro Plug-in Hybrid 2022\", car_parts=CarParts.common([CarHarness.hyundai_f])),\n    ],\n    KIA_NIRO_EV.specs,\n    flags=HyundaiFlags.HYBRID | HyundaiFlags.MANDO_RADAR,\n  )\n  KIA_NIRO_HEV_2021 = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Niro Hybrid 2021\", car_parts=CarParts.common([CarHarness.hyundai_d])),\n      HyundaiCarDocs(\"Kia Niro Hybrid 2022\", car_parts=CarParts.common([CarHarness.hyundai_f])),\n    ],\n    KIA_NIRO_EV.specs,\n    flags=HyundaiFlags.HYBRID,\n  )\n  KIA_NIRO_HEV_2ND_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Kia Niro Hybrid 2023\", car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    KIA_NIRO_EV.specs,\n  )\n  KIA_OPTIMA_G4 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Optima 2017\", \"Advanced Smart Cruise Control\",\n                    car_parts=CarParts.common([CarHarness.hyundai_b]))],  # TODO: may support 2016, 2018\n    CarSpecs(mass=3558 * CV.LB_TO_KG, wheelbase=2.8, steerRatio=13.75, tireStiffnessFactor=0.5),\n    flags=HyundaiFlags.LEGACY | HyundaiFlags.TCU_GEARS | HyundaiFlags.MIN_STEER_32_MPH,\n  )\n  KIA_OPTIMA_G4_FL = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Optima 2019-20\", car_parts=CarParts.common([CarHarness.hyundai_g]))],\n    CarSpecs(mass=3558 * CV.LB_TO_KG, wheelbase=2.8, steerRatio=13.75, tireStiffnessFactor=0.5),\n    flags=HyundaiFlags.UNSUPPORTED_LONGITUDINAL | HyundaiFlags.TCU_GEARS,\n  )\n  # TODO: may support adjacent years. may have a non-zero minimum steering speed\n  KIA_OPTIMA_H = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Optima Hybrid 2017\", \"Advanced Smart Cruise Control\", car_parts=CarParts.common([CarHarness.hyundai_c]))],\n    CarSpecs(mass=3558 * CV.LB_TO_KG, wheelbase=2.8, steerRatio=13.75, tireStiffnessFactor=0.5),\n    flags=HyundaiFlags.HYBRID | HyundaiFlags.LEGACY,\n  )\n  KIA_OPTIMA_H_G4_FL = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Optima Hybrid 2019\", car_parts=CarParts.common([CarHarness.hyundai_h]))],\n    CarSpecs(mass=3558 * CV.LB_TO_KG, wheelbase=2.8, steerRatio=13.75, tireStiffnessFactor=0.5),\n    flags=HyundaiFlags.HYBRID | HyundaiFlags.UNSUPPORTED_LONGITUDINAL,\n  )\n  KIA_SELTOS = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Seltos 2021\", car_parts=CarParts.common([CarHarness.hyundai_a]))],\n    CarSpecs(mass=1337, wheelbase=2.63, steerRatio=14.56),\n    flags=HyundaiFlags.CHECKSUM_CRC8,\n  )\n  KIA_SPORTAGE_5TH_GEN = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Sportage 2023-24\", car_parts=CarParts.common([CarHarness.hyundai_n])),\n      HyundaiCarDocs(\"Kia Sportage Hybrid 2023\", car_parts=CarParts.common([CarHarness.hyundai_n])),\n    ],\n    # weight from SX and above trims, average of FWD and AWD version, steering ratio according to Kia News https://www.kiamedia.com/us/en/models/sportage/2023/specifications\n    CarSpecs(mass=1725, wheelbase=2.756, steerRatio=13.6),\n  )\n  KIA_SORENTO = HyundaiPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Sorento 2018\", \"Advanced Smart Cruise Control & LKAS\", video_link=\"https://www.youtube.com/watch?v=Fkh3s6WHJz8\",\n                     car_parts=CarParts.common([CarHarness.hyundai_e])),\n      HyundaiCarDocs(\"Kia Sorento 2019\", video_link=\"https://www.youtube.com/watch?v=Fkh3s6WHJz8\", car_parts=CarParts.common([CarHarness.hyundai_e])),\n    ],\n    CarSpecs(mass=1985, wheelbase=2.78, steerRatio=14.4 * 1.1),  # 10% higher at the center seems reasonable\n    flags=HyundaiFlags.CHECKSUM_6B | HyundaiFlags.UNSUPPORTED_LONGITUDINAL,\n  )\n  KIA_SORENTO_4TH_GEN = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Kia Sorento 2021-23\", car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    CarSpecs(mass=3957 * CV.LB_TO_KG, wheelbase=2.81, steerRatio=13.5),  # average of the platforms\n    flags=HyundaiFlags.RADAR_SCC,\n  )\n  KIA_SORENTO_HEV_4TH_GEN = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Sorento Hybrid 2021-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_a])),\n      HyundaiCarDocs(\"Kia Sorento Plug-in Hybrid 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_a])),\n    ],\n    CarSpecs(mass=4395 * CV.LB_TO_KG, wheelbase=2.81, steerRatio=13.5),  # average of the platforms\n    flags=HyundaiFlags.RADAR_SCC,\n  )\n  KIA_STINGER = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Stinger 2018-20\", video_link=\"https://www.youtube.com/watch?v=MJ94qoofYw0\",\n                    car_parts=CarParts.common([CarHarness.hyundai_c]))],\n    CarSpecs(mass=1825, wheelbase=2.78, steerRatio=14.4 * 1.15)  # 15% higher at the center seems reasonable\n  )\n  KIA_STINGER_2022 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Stinger 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_k]))],\n    KIA_STINGER.specs,\n  )\n  KIA_CEED = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Kia Ceed 2019\", car_parts=CarParts.common([CarHarness.hyundai_e]))],\n    CarSpecs(mass=1450, wheelbase=2.65, steerRatio=13.75, tireStiffnessFactor=0.5),\n    flags=HyundaiFlags.LEGACY,\n  )\n  KIA_EV6 = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia EV6 (Non-US only) 2022-24\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_p])),\n      HyundaiCarDocs(\"Kia EV6 (without HDA II) 2022-24\", \"Highway Driving Assist\", car_parts=CarParts.common([CarHarness.hyundai_l])),\n      HyundaiCarDocs(\"Kia EV6 (with HDA II) 2022-24\", \"Highway Driving Assist II\", car_parts=CarParts.common([CarHarness.hyundai_p]))\n    ],\n    CarSpecs(mass=2055, wheelbase=2.9, steerRatio=16, tireStiffnessFactor=0.65),\n    flags=HyundaiFlags.EV,\n  )\n  KIA_CARNIVAL_4TH_GEN = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Kia Carnival 2022-24\", car_parts=CarParts.common([CarHarness.hyundai_a])),\n      HyundaiCarDocs(\"Kia Carnival (China only) 2023\", car_parts=CarParts.common([CarHarness.hyundai_k]))\n    ],\n    CarSpecs(mass=2087, wheelbase=3.09, steerRatio=14.23),\n    flags=HyundaiFlags.RADAR_SCC,\n  )\n\n  # Genesis\n  GENESIS_GV60_EV_1ST_GEN = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Genesis GV60 (Advanced Trim) 2023\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_a])),\n      HyundaiCarDocs(\"Genesis GV60 (Performance Trim) 2023\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_k])),\n    ],\n    CarSpecs(mass=2205, wheelbase=2.9, steerRatio=12.6),  # steerRatio: https://www.motor1.com/reviews/586376/2023-genesis-gv60-first-drive/#:~:text=Relative%20to%20the%20related%20Ioniq,5%2FEV6%27s%2014.3%3A1.\n    flags=HyundaiFlags.EV,\n  )\n  GENESIS_G70 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Genesis G70 2018\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_f]))],\n    CarSpecs(mass=1640, wheelbase=2.84, steerRatio=13.56),\n    flags=HyundaiFlags.LEGACY,\n  )\n  GENESIS_G70_2020 = HyundaiPlatformConfig(\n    [\n      # TODO: 2021 MY harness is unknown\n      HyundaiCarDocs(\"Genesis G70 2019-21\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_f])),\n      # TODO: From 3.3T Sport Advanced 2022 & Prestige 2023 Trim, 2.0T is unknown\n      HyundaiCarDocs(\"Genesis G70 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_l])),\n    ],\n    GENESIS_G70.specs,\n    flags=HyundaiFlags.MANDO_RADAR,\n  )\n  GENESIS_GV70_1ST_GEN = HyundaiCanFDPlatformConfig(\n    [\n      HyundaiCarDocs(\"Genesis GV70 (2.5T Trim) 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_l])),\n      HyundaiCarDocs(\"Genesis GV70 (3.5T Trim) 2022-23\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_m])),\n    ],\n    CarSpecs(mass=1950, wheelbase=2.87, steerRatio=14.6),\n    flags=HyundaiFlags.RADAR_SCC,\n  )\n  GENESIS_G80 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Genesis G80 2018-19\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_h]))],\n    CarSpecs(mass=2060, wheelbase=3.01, steerRatio=16.5),\n    flags=HyundaiFlags.LEGACY,\n  )\n  GENESIS_G90 = HyundaiPlatformConfig(\n    [HyundaiCarDocs(\"Genesis G90 2017-20\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_c]))],\n    CarSpecs(mass=2200, wheelbase=3.15, steerRatio=12.069),\n  )\n  GENESIS_GV80 = HyundaiCanFDPlatformConfig(\n    [HyundaiCarDocs(\"Genesis GV80 2023\", \"All\", car_parts=CarParts.common([CarHarness.hyundai_m]))],\n    CarSpecs(mass=2258, wheelbase=2.95, steerRatio=14.14),\n    flags=HyundaiFlags.RADAR_SCC,\n  )\n\n\nclass Buttons:\n  NONE = 0\n  RES_ACCEL = 1\n  SET_DECEL = 2\n  GAP_DIST = 3\n  CANCEL = 4  # on newer models, this is a pause/resume button\n\n\ndef get_platform_codes(fw_versions: list[bytes]) -> set[tuple[bytes, bytes | None]]:\n  # Returns unique, platform-specific identification codes for a set of versions\n  codes = set()  # (code-Optional[part], date)\n  for fw in fw_versions:\n    code_match = PLATFORM_CODE_FW_PATTERN.search(fw)\n    part_match = PART_NUMBER_FW_PATTERN.search(fw)\n    date_match = DATE_FW_PATTERN.search(fw)\n    if code_match is not None:\n      code: bytes = code_match.group()\n      part = part_match.group() if part_match else None\n      date = date_match.group() if date_match else None\n      if part is not None:\n        # part number starts with generic ECU part type, add what is specific to platform\n        code += b\"-\" + part[-5:]\n\n      codes.add((code, date))\n  return codes\n\n\ndef match_fw_to_car_fuzzy(live_fw_versions, vin, offline_fw_versions) -> set[str]:\n  # Non-electric CAN FD platforms often do not have platform code specifiers needed\n  # to distinguish between hybrid and ICE. All EVs so far are either exclusively\n  # electric or specify electric in the platform code.\n  fuzzy_platform_blacklist = {str(c) for c in (CANFD_CAR - EV_CAR - CANFD_FUZZY_WHITELIST)}\n  candidates: set[str] = set()\n\n  for candidate, fws in offline_fw_versions.items():\n    # Keep track of ECUs which pass all checks (platform codes, within date range)\n    valid_found_ecus = set()\n    valid_expected_ecus = {ecu[1:] for ecu in fws if ecu[0] in PLATFORM_CODE_ECUS}\n    for ecu, expected_versions in fws.items():\n      addr = ecu[1:]\n      # Only check ECUs expected to have platform codes\n      if ecu[0] not in PLATFORM_CODE_ECUS:\n        continue\n\n      # Expected platform codes & dates\n      codes = get_platform_codes(expected_versions)\n      expected_platform_codes = {code for code, _ in codes}\n      expected_dates = {date for _, date in codes if date is not None}\n\n      # Found platform codes & dates\n      codes = get_platform_codes(live_fw_versions.get(addr, set()))\n      found_platform_codes = {code for code, _ in codes}\n      found_dates = {date for _, date in codes if date is not None}\n\n      # Check platform code + part number matches for any found versions\n      if not any(found_platform_code in expected_platform_codes for found_platform_code in found_platform_codes):\n        break\n\n      if ecu[0] in DATE_FW_ECUS:\n        # If ECU can have a FW date, require it to exist\n        # (this excludes candidates in the database without dates)\n        if not len(expected_dates) or not len(found_dates):\n          break\n\n        # Check any date within range in the database, format is %y%m%d\n        if not any(min(expected_dates) <= found_date <= max(expected_dates) for found_date in found_dates):\n          break\n\n      valid_found_ecus.add(addr)\n\n    # If all live ECUs pass all checks for candidate, add it as a match\n    if valid_expected_ecus.issubset(valid_found_ecus):\n      candidates.add(candidate)\n\n  return candidates - fuzzy_platform_blacklist\n\n\nHYUNDAI_VERSION_REQUEST_LONG = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(0xf100)  # Long description\n\nHYUNDAI_VERSION_REQUEST_ALT = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(0xf110)  # Alt long description\n\nHYUNDAI_ECU_MANUFACTURING_DATE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.ECU_MANUFACTURING_DATE)\n\nHYUNDAI_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40])\n\n# Regex patterns for parsing platform code, FW date, and part number from FW versions\nPLATFORM_CODE_FW_PATTERN = re.compile(b'((?<=' + HYUNDAI_VERSION_REQUEST_LONG[1:] +\n                                      b')[A-Z]{2}[A-Za-z0-9]{0,2})')\nDATE_FW_PATTERN = re.compile(b'(?<=[ -])([0-9]{6}$)')\nPART_NUMBER_FW_PATTERN = re.compile(b'(?<=[0-9][.,][0-9]{2} )([0-9]{5}[-/]?[A-Z][A-Z0-9]{3}[0-9])')\n\n# We've seen both ICE and hybrid for these platforms, and they have hybrid descriptors (e.g. MQ4 vs MQ4H)\nCANFD_FUZZY_WHITELIST = {CAR.KIA_SORENTO_4TH_GEN, CAR.KIA_SORENTO_HEV_4TH_GEN, CAR.KIA_K8_HEV_1ST_GEN,\n                         # TODO: the hybrid variant is not out yet\n                         CAR.KIA_CARNIVAL_4TH_GEN}\n\n# List of ECUs expected to have platform codes, camera and radar should exist on all cars\n# TODO: use abs, it has the platform code and part number on many platforms\nPLATFORM_CODE_ECUS = [Ecu.fwdRadar, Ecu.fwdCamera, Ecu.eps]\n# So far we've only seen dates in fwdCamera\n# TODO: there are date codes in the ABS firmware versions in hex\nDATE_FW_ECUS = [Ecu.fwdCamera]\n\n# Note: an ECU on CAN FD cars may sometimes send 0x30080aaaaaaaaaaa (flow control continue) while we\n# are attempting to query ECUs. This currently does not seem to affect fingerprinting from the camera\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    # TODO: add back whitelists\n    # CAN queries (OBD-II port)\n    Request(\n      [HYUNDAI_VERSION_REQUEST_LONG],\n      [HYUNDAI_VERSION_RESPONSE],\n    ),\n\n    # CAN & CAN-FD queries (from camera)\n    Request(\n      [HYUNDAI_VERSION_REQUEST_LONG],\n      [HYUNDAI_VERSION_RESPONSE],\n      bus=0,\n      auxiliary=True,\n    ),\n    Request(\n      [HYUNDAI_VERSION_REQUEST_LONG],\n      [HYUNDAI_VERSION_RESPONSE],\n      bus=1,\n      auxiliary=True,\n      obd_multiplexing=False,\n    ),\n\n    # CAN & CAN FD query to understand the three digit date code\n    # HDA2 cars usually use 6 digit date codes, so skip bus 1\n    Request(\n      [HYUNDAI_ECU_MANUFACTURING_DATE],\n      [HYUNDAI_VERSION_RESPONSE],\n      bus=0,\n      auxiliary=True,\n      logging=True,\n    ),\n\n    # CAN-FD alt request logging queries for hvac and parkingAdas\n    Request(\n      [HYUNDAI_VERSION_REQUEST_ALT],\n      [HYUNDAI_VERSION_RESPONSE],\n      bus=0,\n      auxiliary=True,\n      logging=True,\n    ),\n    Request(\n      [HYUNDAI_VERSION_REQUEST_ALT],\n      [HYUNDAI_VERSION_RESPONSE],\n      bus=1,\n      auxiliary=True,\n      logging=True,\n      obd_multiplexing=False,\n    ),\n  ],\n  # We lose these ECUs without the comma power on these cars.\n  # Note that we still attempt to match with them when they are present\n  non_essential_ecus={\n    Ecu.abs: [CAR.HYUNDAI_PALISADE, CAR.HYUNDAI_SONATA, CAR.HYUNDAI_SANTA_FE_2022, CAR.KIA_K5_2021, CAR.HYUNDAI_ELANTRA_2021,\n              CAR.HYUNDAI_SANTA_FE, CAR.HYUNDAI_KONA_EV_2022, CAR.HYUNDAI_KONA_EV, CAR.HYUNDAI_CUSTIN_1ST_GEN, CAR.KIA_SORENTO,\n              CAR.KIA_CEED, CAR.KIA_SELTOS],\n  },\n  extra_ecus=[\n    (Ecu.adas, 0x730, None),              # ADAS Driving ECU on HDA2 platforms\n    (Ecu.parkingAdas, 0x7b1, None),       # ADAS Parking ECU (may exist on all platforms)\n    (Ecu.hvac, 0x7b3, None),              # HVAC Control Assembly\n    (Ecu.cornerRadar, 0x7b7, None),\n    (Ecu.combinationMeter, 0x7c6, None),  # CAN FD Instrument cluster\n  ],\n  # Custom fuzzy fingerprinting function using platform codes, part numbers + FW dates:\n  match_fw_to_car_fuzzy=match_fw_to_car_fuzzy,\n)\n\nCHECKSUM = {\n  \"crc8\": CAR.with_flags(HyundaiFlags.CHECKSUM_CRC8),\n  \"6B\": CAR.with_flags(HyundaiFlags.CHECKSUM_6B),\n}\n\nCAN_GEARS = {\n  # which message has the gear. hybrid and EV use ELECT_GEAR\n  \"use_cluster_gears\": CAR.with_flags(HyundaiFlags.CLUSTER_GEARS),\n  \"use_tcu_gears\": CAR.with_flags(HyundaiFlags.TCU_GEARS),\n}\n\nCANFD_CAR = CAR.with_flags(HyundaiFlags.CANFD)\nCANFD_RADAR_SCC_CAR = CAR.with_flags(HyundaiFlags.RADAR_SCC)\n\n# These CAN FD cars do not accept communication control to disable the ADAS ECU,\n# responds with 0x7F2822 - 'conditions not correct'\nCANFD_UNSUPPORTED_LONGITUDINAL_CAR = CAR.with_flags(HyundaiFlags.CANFD_NO_RADAR_DISABLE)\n\n# The camera does SCC on these cars, rather than the radar\nCAMERA_SCC_CAR = CAR.with_flags(HyundaiFlags.CAMERA_SCC)\n\nHYBRID_CAR = CAR.with_flags(HyundaiFlags.HYBRID)\n\nEV_CAR = CAR.with_flags(HyundaiFlags.EV)\n\nLEGACY_SAFETY_MODE_CAR = CAR.with_flags(HyundaiFlags.LEGACY)\n\nUNSUPPORTED_LONGITUDINAL_CAR = CAR.with_flags(HyundaiFlags.LEGACY) | CAR.with_flags(HyundaiFlags.UNSUPPORTED_LONGITUDINAL)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/hyundai/hyundaicanfd.py": "from openpilot.common.numpy_fast import clip\nfrom openpilot.selfdrive.car import CanBusBase\nfrom openpilot.selfdrive.car.hyundai.values import HyundaiFlags\n\n\nclass CanBus(CanBusBase):\n  def __init__(self, CP, hda2=None, fingerprint=None) -> None:\n    super().__init__(CP, fingerprint)\n\n    if hda2 is None:\n      assert CP is not None\n      hda2 = CP.flags & HyundaiFlags.CANFD_HDA2.value\n\n    # On the CAN-FD platforms, the LKAS camera is on both A-CAN and E-CAN. HDA2 cars\n    # have a different harness than the HDA1 and non-HDA variants in order to split\n    # a different bus, since the steering is done by different ECUs.\n    self._a, self._e = 1, 0\n    if hda2:\n      self._a, self._e = 0, 1\n\n    self._a += self.offset\n    self._e += self.offset\n    self._cam = 2 + self.offset\n\n  @property\n  def ECAN(self):\n    return self._e\n\n  @property\n  def ACAN(self):\n    return self._a\n\n  @property\n  def CAM(self):\n    return self._cam\n\n\ndef create_steering_messages(packer, CP, CAN, enabled, lat_active, apply_steer):\n\n  ret = []\n\n  values = {\n    \"LKA_MODE\": 2,\n    \"LKA_ICON\": 2 if enabled else 1,\n    \"TORQUE_REQUEST\": apply_steer,\n    \"LKA_ASSIST\": 0,\n    \"STEER_REQ\": 1 if lat_active else 0,\n    \"STEER_MODE\": 0,\n    \"HAS_LANE_SAFETY\": 0,  # hide LKAS settings\n    \"NEW_SIGNAL_1\": 0,\n    \"NEW_SIGNAL_2\": 0,\n  }\n\n  if CP.flags & HyundaiFlags.CANFD_HDA2:\n    hda2_lkas_msg = \"LKAS_ALT\" if CP.flags & HyundaiFlags.CANFD_HDA2_ALT_STEERING else \"LKAS\"\n    if CP.openpilotLongitudinalControl:\n      ret.append(packer.make_can_msg(\"LFA\", CAN.ECAN, values))\n    ret.append(packer.make_can_msg(hda2_lkas_msg, CAN.ACAN, values))\n  else:\n    ret.append(packer.make_can_msg(\"LFA\", CAN.ECAN, values))\n\n  return ret\n\ndef create_suppress_lfa(packer, CAN, hda2_lfa_block_msg, hda2_alt_steering):\n  suppress_msg = \"CAM_0x362\" if hda2_alt_steering else \"CAM_0x2a4\"\n  msg_bytes = 32 if hda2_alt_steering else 24\n\n  values = {f\"BYTE{i}\": hda2_lfa_block_msg[f\"BYTE{i}\"] for i in range(3, msg_bytes) if i != 7}\n  values[\"COUNTER\"] = hda2_lfa_block_msg[\"COUNTER\"]\n  values[\"SET_ME_0\"] = 0\n  values[\"SET_ME_0_2\"] = 0\n  values[\"LEFT_LANE_LINE\"] = 0\n  values[\"RIGHT_LANE_LINE\"] = 0\n  return packer.make_can_msg(suppress_msg, CAN.ACAN, values)\n\ndef create_buttons(packer, CP, CAN, cnt, btn):\n  values = {\n    \"COUNTER\": cnt,\n    \"SET_ME_1\": 1,\n    \"CRUISE_BUTTONS\": btn,\n  }\n\n  bus = CAN.ECAN if CP.flags & HyundaiFlags.CANFD_HDA2 else CAN.CAM\n  return packer.make_can_msg(\"CRUISE_BUTTONS\", bus, values)\n\ndef create_acc_cancel(packer, CP, CAN, cruise_info_copy):\n  # TODO: why do we copy different values here?\n  if CP.flags & HyundaiFlags.CANFD_CAMERA_SCC.value:\n    values = {s: cruise_info_copy[s] for s in [\n      \"COUNTER\",\n      \"CHECKSUM\",\n      \"NEW_SIGNAL_1\",\n      \"MainMode_ACC\",\n      \"ACCMode\",\n      \"ZEROS_9\",\n      \"CRUISE_STANDSTILL\",\n      \"ZEROS_5\",\n      \"DISTANCE_SETTING\",\n      \"VSetDis\",\n    ]}\n  else:\n    values = {s: cruise_info_copy[s] for s in [\n      \"COUNTER\",\n      \"CHECKSUM\",\n      \"ACCMode\",\n      \"VSetDis\",\n      \"CRUISE_STANDSTILL\",\n    ]}\n  values.update({\n    \"ACCMode\": 4,\n    \"aReqRaw\": 0.0,\n    \"aReqValue\": 0.0,\n  })\n  return packer.make_can_msg(\"SCC_CONTROL\", CAN.ECAN, values)\n\ndef create_lfahda_cluster(packer, CAN, enabled):\n  values = {\n    \"HDA_ICON\": 1 if enabled else 0,\n    \"LFA_ICON\": 2 if enabled else 0,\n  }\n  return packer.make_can_msg(\"LFAHDA_CLUSTER\", CAN.ECAN, values)\n\n\ndef create_acc_control(packer, CAN, enabled, accel_last, accel, stopping, gas_override, set_speed, hud_control):\n  jerk = 5\n  jn = jerk / 50\n  if not enabled or gas_override:\n    a_val, a_raw = 0, 0\n  else:\n    a_raw = accel\n    a_val = clip(accel, accel_last - jn, accel_last + jn)\n\n  values = {\n    \"ACCMode\": 0 if not enabled else (2 if gas_override else 1),\n    \"MainMode_ACC\": 1,\n    \"StopReq\": 1 if stopping else 0,\n    \"aReqValue\": a_val,\n    \"aReqRaw\": a_raw,\n    \"VSetDis\": set_speed,\n    \"JerkLowerLimit\": jerk if enabled else 1,\n    \"JerkUpperLimit\": 3.0,\n\n    \"ACC_ObjDist\": 1,\n    \"ObjValid\": 0,\n    \"OBJ_STATUS\": 2,\n    \"SET_ME_2\": 0x4,\n    \"SET_ME_3\": 0x3,\n    \"SET_ME_TMP_64\": 0x64,\n    \"DISTANCE_SETTING\": hud_control.leadDistanceBars,\n  }\n\n  return packer.make_can_msg(\"SCC_CONTROL\", CAN.ECAN, values)\n\n\ndef create_spas_messages(packer, CAN, frame, left_blink, right_blink):\n  ret = []\n\n  values = {\n  }\n  ret.append(packer.make_can_msg(\"SPAS1\", CAN.ECAN, values))\n\n  blink = 0\n  if left_blink:\n    blink = 3\n  elif right_blink:\n    blink = 4\n  values = {\n    \"BLINKER_CONTROL\": blink,\n  }\n  ret.append(packer.make_can_msg(\"SPAS2\", CAN.ECAN, values))\n\n  return ret\n\n\ndef create_adrv_messages(packer, CAN, frame):\n  # messages needed to car happy after disabling\n  # the ADAS Driving ECU to do longitudinal control\n\n  ret = []\n\n  values = {\n  }\n  ret.append(packer.make_can_msg(\"ADRV_0x51\", CAN.ACAN, values))\n\n  if frame % 2 == 0:\n    values = {\n      'AEB_SETTING': 0x1,  # show AEB disabled icon\n      'SET_ME_2': 0x2,\n      'SET_ME_FF': 0xff,\n      'SET_ME_FC': 0xfc,\n      'SET_ME_9': 0x9,\n    }\n    ret.append(packer.make_can_msg(\"ADRV_0x160\", CAN.ECAN, values))\n\n  if frame % 5 == 0:\n    values = {\n      'SET_ME_1C': 0x1c,\n      'SET_ME_FF': 0xff,\n      'SET_ME_TMP_F': 0xf,\n      'SET_ME_TMP_F_2': 0xf,\n    }\n    ret.append(packer.make_can_msg(\"ADRV_0x1ea\", CAN.ECAN, values))\n\n    values = {\n      'SET_ME_E1': 0xe1,\n      'SET_ME_3A': 0x3a,\n    }\n    ret.append(packer.make_can_msg(\"ADRV_0x200\", CAN.ECAN, values))\n\n  if frame % 20 == 0:\n    values = {\n      'SET_ME_15': 0x15,\n    }\n    ret.append(packer.make_can_msg(\"ADRV_0x345\", CAN.ECAN, values))\n\n  if frame % 100 == 0:\n    values = {\n      'SET_ME_22': 0x22,\n      'SET_ME_41': 0x41,\n    }\n    ret.append(packer.make_can_msg(\"ADRV_0x1da\", CAN.ECAN, values))\n\n  return ret\n", "selfdrive/car/hyundai/hyundaican.py": "import crcmod\nfrom openpilot.selfdrive.car.hyundai.values import CAR, HyundaiFlags\n\nhyundai_checksum = crcmod.mkCrcFun(0x11D, initCrc=0xFD, rev=False, xorOut=0xdf)\n\ndef create_lkas11(packer, frame, CP, apply_steer, steer_req,\n                  torque_fault, lkas11, sys_warning, sys_state, enabled,\n                  left_lane, right_lane,\n                  left_lane_depart, right_lane_depart):\n  values = {s: lkas11[s] for s in [\n    \"CF_Lkas_LdwsActivemode\",\n    \"CF_Lkas_LdwsSysState\",\n    \"CF_Lkas_SysWarning\",\n    \"CF_Lkas_LdwsLHWarning\",\n    \"CF_Lkas_LdwsRHWarning\",\n    \"CF_Lkas_HbaLamp\",\n    \"CF_Lkas_FcwBasReq\",\n    \"CF_Lkas_HbaSysState\",\n    \"CF_Lkas_FcwOpt\",\n    \"CF_Lkas_HbaOpt\",\n    \"CF_Lkas_FcwSysState\",\n    \"CF_Lkas_FcwCollisionWarning\",\n    \"CF_Lkas_FusionState\",\n    \"CF_Lkas_FcwOpt_USM\",\n    \"CF_Lkas_LdwsOpt_USM\",\n  ]}\n  values[\"CF_Lkas_LdwsSysState\"] = sys_state\n  values[\"CF_Lkas_SysWarning\"] = 3 if sys_warning else 0\n  values[\"CF_Lkas_LdwsLHWarning\"] = left_lane_depart\n  values[\"CF_Lkas_LdwsRHWarning\"] = right_lane_depart\n  values[\"CR_Lkas_StrToqReq\"] = apply_steer\n  values[\"CF_Lkas_ActToi\"] = steer_req\n  values[\"CF_Lkas_ToiFlt\"] = torque_fault  # seems to allow actuation on CR_Lkas_StrToqReq\n  values[\"CF_Lkas_MsgCount\"] = frame % 0x10\n\n  if CP.carFingerprint in (CAR.HYUNDAI_SONATA, CAR.HYUNDAI_PALISADE, CAR.KIA_NIRO_EV, CAR.KIA_NIRO_HEV_2021, CAR.HYUNDAI_SANTA_FE,\n                           CAR.HYUNDAI_IONIQ_EV_2020, CAR.HYUNDAI_IONIQ_PHEV, CAR.KIA_SELTOS, CAR.HYUNDAI_ELANTRA_2021, CAR.GENESIS_G70_2020,\n                           CAR.HYUNDAI_ELANTRA_HEV_2021, CAR.HYUNDAI_SONATA_HYBRID, CAR.HYUNDAI_KONA_EV, CAR.HYUNDAI_KONA_HEV, CAR.HYUNDAI_KONA_EV_2022,\n                           CAR.HYUNDAI_SANTA_FE_2022, CAR.KIA_K5_2021, CAR.HYUNDAI_IONIQ_HEV_2022, CAR.HYUNDAI_SANTA_FE_HEV_2022,\n                           CAR.HYUNDAI_SANTA_FE_PHEV_2022, CAR.KIA_STINGER_2022, CAR.KIA_K5_HEV_2020, CAR.KIA_CEED,\n                           CAR.HYUNDAI_AZERA_6TH_GEN, CAR.HYUNDAI_AZERA_HEV_6TH_GEN, CAR.HYUNDAI_CUSTIN_1ST_GEN):\n    values[\"CF_Lkas_LdwsActivemode\"] = int(left_lane) + (int(right_lane) << 1)\n    values[\"CF_Lkas_LdwsOpt_USM\"] = 2\n\n    # FcwOpt_USM 5 = Orange blinking car + lanes\n    # FcwOpt_USM 4 = Orange car + lanes\n    # FcwOpt_USM 3 = Green blinking car + lanes\n    # FcwOpt_USM 2 = Green car + lanes\n    # FcwOpt_USM 1 = White car + lanes\n    # FcwOpt_USM 0 = No car + lanes\n    values[\"CF_Lkas_FcwOpt_USM\"] = 2 if enabled else 1\n\n    # SysWarning 4 = keep hands on wheel\n    # SysWarning 5 = keep hands on wheel (red)\n    # SysWarning 6 = keep hands on wheel (red) + beep\n    # Note: the warning is hidden while the blinkers are on\n    values[\"CF_Lkas_SysWarning\"] = 4 if sys_warning else 0\n\n  # Likely cars lacking the ability to show individual lane lines in the dash\n  elif CP.carFingerprint in (CAR.KIA_OPTIMA_G4, CAR.KIA_OPTIMA_G4_FL):\n    # SysWarning 4 = keep hands on wheel + beep\n    values[\"CF_Lkas_SysWarning\"] = 4 if sys_warning else 0\n\n    # SysState 0 = no icons\n    # SysState 1-2 = white car + lanes\n    # SysState 3 = green car + lanes, green steering wheel\n    # SysState 4 = green car + lanes\n    values[\"CF_Lkas_LdwsSysState\"] = 3 if enabled else 1\n    values[\"CF_Lkas_LdwsOpt_USM\"] = 2  # non-2 changes above SysState definition\n\n    # these have no effect\n    values[\"CF_Lkas_LdwsActivemode\"] = 0\n    values[\"CF_Lkas_FcwOpt_USM\"] = 0\n\n  elif CP.carFingerprint == CAR.HYUNDAI_GENESIS:\n    # This field is actually LdwsActivemode\n    # Genesis and Optima fault when forwarding while engaged\n    values[\"CF_Lkas_LdwsActivemode\"] = 2\n\n  dat = packer.make_can_msg(\"LKAS11\", 0, values)[2]\n\n  if CP.flags & HyundaiFlags.CHECKSUM_CRC8:\n    # CRC Checksum as seen on 2019 Hyundai Santa Fe\n    dat = dat[:6] + dat[7:8]\n    checksum = hyundai_checksum(dat)\n  elif CP.flags & HyundaiFlags.CHECKSUM_6B:\n    # Checksum of first 6 Bytes, as seen on 2018 Kia Sorento\n    checksum = sum(dat[:6]) % 256\n  else:\n    # Checksum of first 6 Bytes and last Byte as seen on 2018 Kia Stinger\n    checksum = (sum(dat[:6]) + dat[7]) % 256\n\n  values[\"CF_Lkas_Chksum\"] = checksum\n\n  return packer.make_can_msg(\"LKAS11\", 0, values)\n\n\ndef create_clu11(packer, frame, clu11, button, CP):\n  values = {s: clu11[s] for s in [\n    \"CF_Clu_CruiseSwState\",\n    \"CF_Clu_CruiseSwMain\",\n    \"CF_Clu_SldMainSW\",\n    \"CF_Clu_ParityBit1\",\n    \"CF_Clu_VanzDecimal\",\n    \"CF_Clu_Vanz\",\n    \"CF_Clu_SPEED_UNIT\",\n    \"CF_Clu_DetentOut\",\n    \"CF_Clu_RheostatLevel\",\n    \"CF_Clu_CluInfo\",\n    \"CF_Clu_AmpInfo\",\n    \"CF_Clu_AliveCnt1\",\n  ]}\n  values[\"CF_Clu_CruiseSwState\"] = button\n  values[\"CF_Clu_AliveCnt1\"] = frame % 0x10\n  # send buttons to camera on camera-scc based cars\n  bus = 2 if CP.flags & HyundaiFlags.CAMERA_SCC else 0\n  return packer.make_can_msg(\"CLU11\", bus, values)\n\n\ndef create_lfahda_mfc(packer, enabled, hda_set_speed=0):\n  values = {\n    \"LFA_Icon_State\": 2 if enabled else 0,\n    \"HDA_Active\": 1 if hda_set_speed else 0,\n    \"HDA_Icon_State\": 2 if hda_set_speed else 0,\n    \"HDA_VSetReq\": hda_set_speed,\n  }\n  return packer.make_can_msg(\"LFAHDA_MFC\", 0, values)\n\ndef create_acc_commands(packer, enabled, accel, upper_jerk, idx, hud_control, set_speed, stopping, long_override, use_fca):\n  commands = []\n\n  scc11_values = {\n    \"MainMode_ACC\": 1,\n    \"TauGapSet\": hud_control.leadDistanceBars,\n    \"VSetDis\": set_speed if enabled else 0,\n    \"AliveCounterACC\": idx % 0x10,\n    \"ObjValid\": 1, # close lead makes controls tighter\n    \"ACC_ObjStatus\": 1, # close lead makes controls tighter\n    \"ACC_ObjLatPos\": 0,\n    \"ACC_ObjRelSpd\": 0,\n    \"ACC_ObjDist\": 1, # close lead makes controls tighter\n    }\n  commands.append(packer.make_can_msg(\"SCC11\", 0, scc11_values))\n\n  scc12_values = {\n    \"ACCMode\": 2 if enabled and long_override else 1 if enabled else 0,\n    \"StopReq\": 1 if stopping else 0,\n    \"aReqRaw\": accel,\n    \"aReqValue\": accel,  # stock ramps up and down respecting jerk limit until it reaches aReqRaw\n    \"CR_VSM_Alive\": idx % 0xF,\n  }\n\n  # show AEB disabled indicator on dash with SCC12 if not sending FCA messages.\n  # these signals also prevent a TCS fault on non-FCA cars with alpha longitudinal\n  if not use_fca:\n    scc12_values[\"CF_VSM_ConfMode\"] = 1\n    scc12_values[\"AEB_Status\"] = 1  # AEB disabled\n\n  scc12_dat = packer.make_can_msg(\"SCC12\", 0, scc12_values)[2]\n  scc12_values[\"CR_VSM_ChkSum\"] = 0x10 - sum(sum(divmod(i, 16)) for i in scc12_dat) % 0x10\n\n  commands.append(packer.make_can_msg(\"SCC12\", 0, scc12_values))\n\n  scc14_values = {\n    \"ComfortBandUpper\": 0.0, # stock usually is 0 but sometimes uses higher values\n    \"ComfortBandLower\": 0.0, # stock usually is 0 but sometimes uses higher values\n    \"JerkUpperLimit\": upper_jerk, # stock usually is 1.0 but sometimes uses higher values\n    \"JerkLowerLimit\": 5.0, # stock usually is 0.5 but sometimes uses higher values\n    \"ACCMode\": 2 if enabled and long_override else 1 if enabled else 4, # stock will always be 4 instead of 0 after first disengage\n    \"ObjGap\": 2 if hud_control.leadVisible else 0, # 5: >30, m, 4: 25-30 m, 3: 20-25 m, 2: < 20 m, 0: no lead\n  }\n  commands.append(packer.make_can_msg(\"SCC14\", 0, scc14_values))\n\n  # Only send FCA11 on cars where it exists on the bus\n  if use_fca:\n    # note that some vehicles most likely have an alternate checksum/counter definition\n    # https://github.com/commaai/opendbc/commit/9ddcdb22c4929baf310295e832668e6e7fcfa602\n    fca11_values = {\n      \"CR_FCA_Alive\": idx % 0xF,\n      \"PAINT1_Status\": 1,\n      \"FCA_DrvSetStatus\": 1,\n      \"FCA_Status\": 1,  # AEB disabled\n    }\n    fca11_dat = packer.make_can_msg(\"FCA11\", 0, fca11_values)[2]\n    fca11_values[\"CR_FCA_ChkSum\"] = hyundai_checksum(fca11_dat[:7])\n    commands.append(packer.make_can_msg(\"FCA11\", 0, fca11_values))\n\n  return commands\n\ndef create_acc_opt(packer):\n  commands = []\n\n  scc13_values = {\n    \"SCCDrvModeRValue\": 2,\n    \"SCC_Equip\": 1,\n    \"Lead_Veh_Dep_Alert_USM\": 2,\n  }\n  commands.append(packer.make_can_msg(\"SCC13\", 0, scc13_values))\n\n  # TODO: this needs to be detected and conditionally sent on unsupported long cars\n  fca12_values = {\n    \"FCA_DrvSetState\": 2,\n    \"FCA_USM\": 1, # AEB disabled\n  }\n  commands.append(packer.make_can_msg(\"FCA12\", 0, fca12_values))\n\n  return commands\n\ndef create_frt_radar_opt(packer):\n  frt_radar11_values = {\n    \"CF_FCA_Equip_Front_Radar\": 1,\n  }\n  return packer.make_can_msg(\"FRT_RADAR11\", 0, frt_radar11_values)\n", "selfdrive/car/hyundai/carcontroller.py": "from cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.common.realtime import DT_CTRL\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car import apply_driver_steer_torque_limits, common_fault_avoidance\nfrom openpilot.selfdrive.car.hyundai import hyundaicanfd, hyundaican\nfrom openpilot.selfdrive.car.hyundai.hyundaicanfd import CanBus\nfrom openpilot.selfdrive.car.hyundai.values import HyundaiFlags, Buttons, CarControllerParams, CANFD_CAR, CAR\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\nLongCtrlState = car.CarControl.Actuators.LongControlState\n\n# EPS faults if you apply torque while the steering angle is above 90 degrees for more than 1 second\n# All slightly below EPS thresholds to avoid fault\nMAX_ANGLE = 85\nMAX_ANGLE_FRAMES = 89\nMAX_ANGLE_CONSECUTIVE_FRAMES = 2\n\n\ndef process_hud_alert(enabled, fingerprint, hud_control):\n  sys_warning = (hud_control.visualAlert in (VisualAlert.steerRequired, VisualAlert.ldw))\n\n  # initialize to no line visible\n  # TODO: this is not accurate for all cars\n  sys_state = 1\n  if hud_control.leftLaneVisible and hud_control.rightLaneVisible or sys_warning:  # HUD alert only display when LKAS status is active\n    sys_state = 3 if enabled or sys_warning else 4\n  elif hud_control.leftLaneVisible:\n    sys_state = 5\n  elif hud_control.rightLaneVisible:\n    sys_state = 6\n\n  # initialize to no warnings\n  left_lane_warning = 0\n  right_lane_warning = 0\n  if hud_control.leftLaneDepart:\n    left_lane_warning = 1 if fingerprint in (CAR.GENESIS_G90, CAR.GENESIS_G80) else 2\n  if hud_control.rightLaneDepart:\n    right_lane_warning = 1 if fingerprint in (CAR.GENESIS_G90, CAR.GENESIS_G80) else 2\n\n  return sys_warning, sys_state, left_lane_warning, right_lane_warning\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.CAN = CanBus(CP)\n    self.params = CarControllerParams(CP)\n    self.packer = CANPacker(dbc_name)\n    self.angle_limit_counter = 0\n    self.frame = 0\n\n    self.accel_last = 0\n    self.apply_steer_last = 0\n    self.car_fingerprint = CP.carFingerprint\n    self.last_button_frame = 0\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n\n    # steering torque\n    new_steer = int(round(actuators.steer * self.params.STEER_MAX))\n    apply_steer = apply_driver_steer_torque_limits(new_steer, self.apply_steer_last, CS.out.steeringTorque, self.params)\n\n    # >90 degree steering fault prevention\n    self.angle_limit_counter, apply_steer_req = common_fault_avoidance(abs(CS.out.steeringAngleDeg) >= MAX_ANGLE, CC.latActive,\n                                                                       self.angle_limit_counter, MAX_ANGLE_FRAMES,\n                                                                       MAX_ANGLE_CONSECUTIVE_FRAMES)\n\n    if not CC.latActive:\n      apply_steer = 0\n\n    # Hold torque with induced temporary fault when cutting the actuation bit\n    torque_fault = CC.latActive and not apply_steer_req\n\n    self.apply_steer_last = apply_steer\n\n    # accel + longitudinal\n    accel = clip(actuators.accel, CarControllerParams.ACCEL_MIN, CarControllerParams.ACCEL_MAX)\n    stopping = actuators.longControlState == LongCtrlState.stopping\n    set_speed_in_units = hud_control.setSpeed * (CV.MS_TO_KPH if CS.is_metric else CV.MS_TO_MPH)\n\n    # HUD messages\n    sys_warning, sys_state, left_lane_warning, right_lane_warning = process_hud_alert(CC.enabled, self.car_fingerprint,\n                                                                                      hud_control)\n\n    can_sends = []\n\n    # *** common hyundai stuff ***\n\n    # tester present - w/ no response (keeps relevant ECU disabled)\n    if self.frame % 100 == 0 and not (self.CP.flags & HyundaiFlags.CANFD_CAMERA_SCC.value) and self.CP.openpilotLongitudinalControl:\n      # for longitudinal control, either radar or ADAS driving ECU\n      addr, bus = 0x7d0, 0\n      if self.CP.flags & HyundaiFlags.CANFD_HDA2.value:\n        addr, bus = 0x730, self.CAN.ECAN\n      can_sends.append([addr, 0, b\"\\x02\\x3E\\x80\\x00\\x00\\x00\\x00\\x00\", bus])\n\n      # for blinkers\n      if self.CP.flags & HyundaiFlags.ENABLE_BLINKERS:\n        can_sends.append([0x7b1, 0, b\"\\x02\\x3E\\x80\\x00\\x00\\x00\\x00\\x00\", self.CAN.ECAN])\n\n    # CAN-FD platforms\n    if self.CP.carFingerprint in CANFD_CAR:\n      hda2 = self.CP.flags & HyundaiFlags.CANFD_HDA2\n      hda2_long = hda2 and self.CP.openpilotLongitudinalControl\n\n      # steering control\n      can_sends.extend(hyundaicanfd.create_steering_messages(self.packer, self.CP, self.CAN, CC.enabled, apply_steer_req, apply_steer))\n\n      # prevent LFA from activating on HDA2 by sending \"no lane lines detected\" to ADAS ECU\n      if self.frame % 5 == 0 and hda2:\n        can_sends.append(hyundaicanfd.create_suppress_lfa(self.packer, self.CAN, CS.hda2_lfa_block_msg,\n                                                          self.CP.flags & HyundaiFlags.CANFD_HDA2_ALT_STEERING))\n\n      # LFA and HDA icons\n      if self.frame % 5 == 0 and (not hda2 or hda2_long):\n        can_sends.append(hyundaicanfd.create_lfahda_cluster(self.packer, self.CAN, CC.enabled))\n\n      # blinkers\n      if hda2 and self.CP.flags & HyundaiFlags.ENABLE_BLINKERS:\n        can_sends.extend(hyundaicanfd.create_spas_messages(self.packer, self.CAN, self.frame, CC.leftBlinker, CC.rightBlinker))\n\n      if self.CP.openpilotLongitudinalControl:\n        if hda2:\n          can_sends.extend(hyundaicanfd.create_adrv_messages(self.packer, self.CAN, self.frame))\n        if self.frame % 2 == 0:\n          can_sends.append(hyundaicanfd.create_acc_control(self.packer, self.CAN, CC.enabled, self.accel_last, accel, stopping, CC.cruiseControl.override,\n                                                           set_speed_in_units, hud_control))\n          self.accel_last = accel\n      else:\n        # button presses\n        can_sends.extend(self.create_button_messages(CC, CS, use_clu11=False))\n    else:\n      can_sends.append(hyundaican.create_lkas11(self.packer, self.frame, self.CP, apply_steer, apply_steer_req,\n                                                torque_fault, CS.lkas11, sys_warning, sys_state, CC.enabled,\n                                                hud_control.leftLaneVisible, hud_control.rightLaneVisible,\n                                                left_lane_warning, right_lane_warning))\n\n      if not self.CP.openpilotLongitudinalControl:\n        can_sends.extend(self.create_button_messages(CC, CS, use_clu11=True))\n\n      if self.frame % 2 == 0 and self.CP.openpilotLongitudinalControl:\n        # TODO: unclear if this is needed\n        jerk = 3.0 if actuators.longControlState == LongCtrlState.pid else 1.0\n        use_fca = self.CP.flags & HyundaiFlags.USE_FCA.value\n        can_sends.extend(hyundaican.create_acc_commands(self.packer, CC.enabled, accel, jerk, int(self.frame / 2),\n                                                        hud_control, set_speed_in_units, stopping,\n                                                        CC.cruiseControl.override, use_fca))\n\n      # 20 Hz LFA MFA message\n      if self.frame % 5 == 0 and self.CP.flags & HyundaiFlags.SEND_LFA.value:\n        can_sends.append(hyundaican.create_lfahda_mfc(self.packer, CC.enabled))\n\n      # 5 Hz ACC options\n      if self.frame % 20 == 0 and self.CP.openpilotLongitudinalControl:\n        can_sends.extend(hyundaican.create_acc_opt(self.packer))\n\n      # 2 Hz front radar options\n      if self.frame % 50 == 0 and self.CP.openpilotLongitudinalControl:\n        can_sends.append(hyundaican.create_frt_radar_opt(self.packer))\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steer = apply_steer / self.params.STEER_MAX\n    new_actuators.steerOutputCan = apply_steer\n    new_actuators.accel = accel\n\n    self.frame += 1\n    return new_actuators, can_sends\n\n  def create_button_messages(self, CC: car.CarControl, CS: car.CarState, use_clu11: bool):\n    can_sends = []\n    if use_clu11:\n      if CC.cruiseControl.cancel:\n        can_sends.append(hyundaican.create_clu11(self.packer, self.frame, CS.clu11, Buttons.CANCEL, self.CP))\n      elif CC.cruiseControl.resume:\n        # send resume at a max freq of 10Hz\n        if (self.frame - self.last_button_frame) * DT_CTRL > 0.1:\n          # send 25 messages at a time to increases the likelihood of resume being accepted\n          can_sends.extend([hyundaican.create_clu11(self.packer, self.frame, CS.clu11, Buttons.RES_ACCEL, self.CP)] * 25)\n          if (self.frame - self.last_button_frame) * DT_CTRL >= 0.15:\n            self.last_button_frame = self.frame\n    else:\n      if (self.frame - self.last_button_frame) * DT_CTRL > 0.25:\n        # cruise cancel\n        if CC.cruiseControl.cancel:\n          if self.CP.flags & HyundaiFlags.CANFD_ALT_BUTTONS:\n            can_sends.append(hyundaicanfd.create_acc_cancel(self.packer, self.CP, self.CAN, CS.cruise_info))\n            self.last_button_frame = self.frame\n          else:\n            for _ in range(20):\n              can_sends.append(hyundaicanfd.create_buttons(self.packer, self.CP, self.CAN, CS.buttons_counter+1, Buttons.CANCEL))\n            self.last_button_frame = self.frame\n\n        # cruise standstill resume\n        elif CC.cruiseControl.resume:\n          if self.CP.flags & HyundaiFlags.CANFD_ALT_BUTTONS:\n            # TODO: resume for alt button cars\n            pass\n          else:\n            for _ in range(20):\n              can_sends.append(hyundaicanfd.create_buttons(self.packer, self.CP, self.CAN, CS.buttons_counter+1, Buttons.RES_ACCEL))\n            self.last_button_frame = self.frame\n\n    return can_sends\n", "selfdrive/car/hyundai/radar_interface.py": "import math\n\nfrom cereal import car\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\nfrom openpilot.selfdrive.car.hyundai.values import DBC\n\nRADAR_START_ADDR = 0x500\nRADAR_MSG_COUNT = 32\n\n# POC for parsing corner radars: https://github.com/commaai/openpilot/pull/24221/\n\ndef get_radar_can_parser(CP):\n  if DBC[CP.carFingerprint]['radar'] is None:\n    return None\n\n  messages = [(f\"RADAR_TRACK_{addr:x}\", 50) for addr in range(RADAR_START_ADDR, RADAR_START_ADDR + RADAR_MSG_COUNT)]\n  return CANParser(DBC[CP.carFingerprint]['radar'], messages, 1)\n\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.updated_messages = set()\n    self.trigger_msg = RADAR_START_ADDR + RADAR_MSG_COUNT - 1\n    self.track_id = 0\n\n    self.radar_off_can = CP.radarUnavailable\n    self.rcp = get_radar_can_parser(CP)\n\n  def update(self, can_strings):\n    if self.radar_off_can or (self.rcp is None):\n      return super().update(None)\n\n    vls = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(vls)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    rr = self._update(self.updated_messages)\n    self.updated_messages.clear()\n\n    return rr\n\n  def _update(self, updated_messages):\n    ret = car.RadarData.new_message()\n    if self.rcp is None:\n      return ret\n\n    errors = []\n\n    if not self.rcp.can_valid:\n      errors.append(\"canError\")\n    ret.errors = errors\n\n    for addr in range(RADAR_START_ADDR, RADAR_START_ADDR + RADAR_MSG_COUNT):\n      msg = self.rcp.vl[f\"RADAR_TRACK_{addr:x}\"]\n\n      if addr not in self.pts:\n        self.pts[addr] = car.RadarData.RadarPoint.new_message()\n        self.pts[addr].trackId = self.track_id\n        self.track_id += 1\n\n      valid = msg['STATE'] in (3, 4)\n      if valid:\n        azimuth = math.radians(msg['AZIMUTH'])\n        self.pts[addr].measured = True\n        self.pts[addr].dRel = math.cos(azimuth) * msg['LONG_DIST']\n        self.pts[addr].yRel = 0.5 * -math.sin(azimuth) * msg['LONG_DIST']\n        self.pts[addr].vRel = msg['REL_SPEED']\n        self.pts[addr].aRel = msg['REL_ACCEL']\n        self.pts[addr].yvRel = float('nan')\n\n      else:\n        del self.pts[addr]\n\n    ret.points = list(self.pts.values())\n    return ret\n", "selfdrive/car/hyundai/__init__.py": "", "selfdrive/car/hyundai/interface.py": "from cereal import car\nfrom panda import Panda\nfrom openpilot.selfdrive.car.hyundai.hyundaicanfd import CanBus\nfrom openpilot.selfdrive.car.hyundai.values import HyundaiFlags, CAR, DBC, CANFD_CAR, CAMERA_SCC_CAR, CANFD_RADAR_SCC_CAR, \\\n                                         CANFD_UNSUPPORTED_LONGITUDINAL_CAR, EV_CAR, HYBRID_CAR, LEGACY_SAFETY_MODE_CAR, \\\n                                         UNSUPPORTED_LONGITUDINAL_CAR, Buttons\nfrom openpilot.selfdrive.car.hyundai.radar_interface import RADAR_START_ADDR\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.car.disable_ecu import disable_ecu\n\nEcu = car.CarParams.Ecu\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\nENABLE_BUTTONS = (Buttons.RES_ACCEL, Buttons.SET_DECEL, Buttons.CANCEL)\nBUTTONS_DICT = {Buttons.RES_ACCEL: ButtonType.accelCruise, Buttons.SET_DECEL: ButtonType.decelCruise,\n                Buttons.GAP_DIST: ButtonType.gapAdjustCruise, Buttons.CANCEL: ButtonType.cancel}\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"hyundai\"\n    ret.radarUnavailable = RADAR_START_ADDR not in fingerprint[1] or DBC[ret.carFingerprint][\"radar\"] is None\n\n    # These cars have been put into dashcam only due to both a lack of users and test coverage.\n    # These cars likely still work fine. Once a user confirms each car works and a test route is\n    # added to selfdrive/car/tests/routes.py, we can remove it from this list.\n    # FIXME: the Optima Hybrid 2017 uses a different SCC12 checksum\n    ret.dashcamOnly = candidate in {CAR.KIA_OPTIMA_H, }\n\n    hda2 = Ecu.adas in [fw.ecu for fw in car_fw]\n    CAN = CanBus(None, hda2, fingerprint)\n\n    if candidate in CANFD_CAR:\n      # detect if car is hybrid\n      if 0x105 in fingerprint[CAN.ECAN]:\n        ret.flags |= HyundaiFlags.HYBRID.value\n      elif candidate in EV_CAR:\n        ret.flags |= HyundaiFlags.EV.value\n\n      # detect HDA2 with ADAS Driving ECU\n      if hda2:\n        ret.flags |= HyundaiFlags.CANFD_HDA2.value\n        if 0x110 in fingerprint[CAN.CAM]:\n          ret.flags |= HyundaiFlags.CANFD_HDA2_ALT_STEERING.value\n      else:\n        # non-HDA2\n        if 0x1cf not in fingerprint[CAN.ECAN]:\n          ret.flags |= HyundaiFlags.CANFD_ALT_BUTTONS.value\n        # ICE cars do not have 0x130; GEARS message on 0x40 or 0x70 instead\n        if 0x130 not in fingerprint[CAN.ECAN]:\n          if 0x40 not in fingerprint[CAN.ECAN]:\n            ret.flags |= HyundaiFlags.CANFD_ALT_GEARS_2.value\n          else:\n            ret.flags |= HyundaiFlags.CANFD_ALT_GEARS.value\n        if candidate not in CANFD_RADAR_SCC_CAR:\n          ret.flags |= HyundaiFlags.CANFD_CAMERA_SCC.value\n    else:\n      # TODO: detect EV and hybrid\n      if candidate in HYBRID_CAR:\n        ret.flags |= HyundaiFlags.HYBRID.value\n      elif candidate in EV_CAR:\n        ret.flags |= HyundaiFlags.EV.value\n\n      # Send LFA message on cars with HDA\n      if 0x485 in fingerprint[2]:\n        ret.flags |= HyundaiFlags.SEND_LFA.value\n\n      # These cars use the FCA11 message for the AEB and FCW signals, all others use SCC12\n      if 0x38d in fingerprint[0] or 0x38d in fingerprint[2]:\n        ret.flags |= HyundaiFlags.USE_FCA.value\n\n    ret.steerActuatorDelay = 0.1  # Default delay\n    ret.steerLimitTimer = 0.4\n    CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    if candidate == CAR.KIA_OPTIMA_G4_FL:\n      ret.steerActuatorDelay = 0.2\n\n    # *** longitudinal control ***\n    if candidate in CANFD_CAR:\n      ret.experimentalLongitudinalAvailable = candidate not in (CANFD_UNSUPPORTED_LONGITUDINAL_CAR | CANFD_RADAR_SCC_CAR)\n    else:\n      ret.experimentalLongitudinalAvailable = candidate not in (UNSUPPORTED_LONGITUDINAL_CAR | CAMERA_SCC_CAR)\n    ret.openpilotLongitudinalControl = experimental_long and ret.experimentalLongitudinalAvailable\n    ret.pcmCruise = not ret.openpilotLongitudinalControl\n\n    ret.stoppingControl = True\n    ret.startingState = True\n    ret.vEgoStarting = 0.1\n    ret.startAccel = 1.0\n    ret.longitudinalActuatorDelay = 0.5\n\n    # *** feature detection ***\n    if candidate in CANFD_CAR:\n      ret.enableBsm = 0x1e5 in fingerprint[CAN.ECAN]\n    else:\n      ret.enableBsm = 0x58b in fingerprint[0]\n\n    # *** panda safety config ***\n    if candidate in CANFD_CAR:\n      cfgs = [get_safety_config(car.CarParams.SafetyModel.hyundaiCanfd), ]\n      if CAN.ECAN >= 4:\n        cfgs.insert(0, get_safety_config(car.CarParams.SafetyModel.noOutput))\n      ret.safetyConfigs = cfgs\n\n      if ret.flags & HyundaiFlags.CANFD_HDA2:\n        ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_CANFD_HDA2\n        if ret.flags & HyundaiFlags.CANFD_HDA2_ALT_STEERING:\n          ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_CANFD_HDA2_ALT_STEERING\n      if ret.flags & HyundaiFlags.CANFD_ALT_BUTTONS:\n        ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_CANFD_ALT_BUTTONS\n      if ret.flags & HyundaiFlags.CANFD_CAMERA_SCC:\n        ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_CAMERA_SCC\n    else:\n      if candidate in LEGACY_SAFETY_MODE_CAR:\n        # these cars require a special panda safety mode due to missing counters and checksums in the messages\n        ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.hyundaiLegacy)]\n      else:\n        ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.hyundai, 0)]\n\n      if candidate in CAMERA_SCC_CAR:\n        ret.safetyConfigs[0].safetyParam |= Panda.FLAG_HYUNDAI_CAMERA_SCC\n\n    if ret.openpilotLongitudinalControl:\n      ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_LONG\n    if ret.flags & HyundaiFlags.HYBRID:\n      ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_HYBRID_GAS\n    elif ret.flags & HyundaiFlags.EV:\n      ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_EV_GAS\n\n    if candidate in (CAR.HYUNDAI_KONA, CAR.HYUNDAI_KONA_EV, CAR.HYUNDAI_KONA_HEV, CAR.HYUNDAI_KONA_EV_2022):\n      ret.flags |= HyundaiFlags.ALT_LIMITS.value\n      ret.safetyConfigs[-1].safetyParam |= Panda.FLAG_HYUNDAI_ALT_LIMITS\n\n    ret.centerToFront = ret.wheelbase * 0.4\n\n    return ret\n\n  @staticmethod\n  def init(CP, logcan, sendcan):\n    if CP.openpilotLongitudinalControl and not (CP.flags & HyundaiFlags.CANFD_CAMERA_SCC.value):\n      addr, bus = 0x7d0, 0\n      if CP.flags & HyundaiFlags.CANFD_HDA2.value:\n        addr, bus = 0x730, CanBus(CP).ECAN\n      disable_ecu(logcan, sendcan, bus=bus, addr=addr, com_cont_req=b'\\x28\\x83\\x01')\n\n    # for blinkers\n    if CP.flags & HyundaiFlags.ENABLE_BLINKERS:\n      disable_ecu(logcan, sendcan, bus=CanBus(CP).ECAN, addr=0x7B1, com_cont_req=b'\\x28\\x83\\x01')\n\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam)\n\n    if self.CS.CP.openpilotLongitudinalControl:\n      ret.buttonEvents = create_button_events(self.CS.cruise_buttons[-1], self.CS.prev_cruise_buttons, BUTTONS_DICT)\n\n    # On some newer model years, the CANCEL button acts as a pause/resume button based on the PCM state\n    # To avoid re-engaging when openpilot cancels, check user engagement intention via buttons\n    # Main button also can trigger an engagement on these cars\n    allow_enable = any(btn in ENABLE_BUTTONS for btn in self.CS.cruise_buttons) or any(self.CS.main_buttons)\n    events = self.create_common_events(ret, pcm_enable=self.CS.CP.pcmCruise, allow_enable=allow_enable)\n\n    # low speed steer alert hysteresis logic (only for cars with steer cut off above 10 m/s)\n    if ret.vEgo < (self.CP.minSteerSpeed + 2.) and self.CP.minSteerSpeed > 10.:\n      self.low_speed_alert = True\n    if ret.vEgo > (self.CP.minSteerSpeed + 4.):\n      self.low_speed_alert = False\n    if self.low_speed_alert:\n      events.add(car.CarEvent.EventName.belowSteerSpeed)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/subaru/carstate.py": "import copy\nfrom cereal import car\nfrom opendbc.can.can_define import CANDefine\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.subaru.values import DBC, CanBus, SubaruFlags\nfrom openpilot.selfdrive.car import CanSignalRateCalculator\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n    self.shifter_values = can_define.dv[\"Transmission\"][\"Gear\"]\n\n    self.angle_rate_calulator = CanSignalRateCalculator(50)\n\n  def update(self, cp, cp_cam, cp_body):\n    ret = car.CarState.new_message()\n\n    throttle_msg = cp.vl[\"Throttle\"] if not (self.CP.flags & SubaruFlags.HYBRID) else cp_body.vl[\"Throttle_Hybrid\"]\n    ret.gas = throttle_msg[\"Throttle_Pedal\"] / 255.\n\n    ret.gasPressed = ret.gas > 1e-5\n    if self.CP.flags & SubaruFlags.PREGLOBAL:\n      ret.brakePressed = cp.vl[\"Brake_Pedal\"][\"Brake_Pedal\"] > 0\n    else:\n      cp_brakes = cp_body if self.CP.flags & SubaruFlags.GLOBAL_GEN2 else cp\n      ret.brakePressed = cp_brakes.vl[\"Brake_Status\"][\"Brake\"] == 1\n\n    cp_es_distance = cp_body if self.CP.flags & (SubaruFlags.GLOBAL_GEN2 | SubaruFlags.HYBRID) else cp_cam\n    if not (self.CP.flags & SubaruFlags.HYBRID):\n      eyesight_fault = bool(cp_es_distance.vl[\"ES_Distance\"][\"Cruise_Fault\"])\n\n      # if openpilot is controlling long, an eyesight fault is a non-critical fault. otherwise it's an ACC fault\n      if self.CP.openpilotLongitudinalControl:\n        ret.carFaultedNonCritical = eyesight_fault\n      else:\n        ret.accFaulted = eyesight_fault\n\n    cp_wheels = cp_body if self.CP.flags & SubaruFlags.GLOBAL_GEN2 else cp\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp_wheels.vl[\"Wheel_Speeds\"][\"FL\"],\n      cp_wheels.vl[\"Wheel_Speeds\"][\"FR\"],\n      cp_wheels.vl[\"Wheel_Speeds\"][\"RL\"],\n      cp_wheels.vl[\"Wheel_Speeds\"][\"RR\"],\n    )\n    ret.vEgoRaw = (ret.wheelSpeeds.fl + ret.wheelSpeeds.fr + ret.wheelSpeeds.rl + ret.wheelSpeeds.rr) / 4.\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = ret.vEgoRaw == 0\n\n    # continuous blinker signals for assisted lane change\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_lamp(50, cp.vl[\"Dashlights\"][\"LEFT_BLINKER\"],\n                                                                          cp.vl[\"Dashlights\"][\"RIGHT_BLINKER\"])\n\n    if self.CP.enableBsm:\n      ret.leftBlindspot = (cp.vl[\"BSD_RCTA\"][\"L_ADJACENT\"] == 1) or (cp.vl[\"BSD_RCTA\"][\"L_APPROACHING\"] == 1)\n      ret.rightBlindspot = (cp.vl[\"BSD_RCTA\"][\"R_ADJACENT\"] == 1) or (cp.vl[\"BSD_RCTA\"][\"R_APPROACHING\"] == 1)\n\n    cp_transmission = cp_body if self.CP.flags & SubaruFlags.HYBRID else cp\n    can_gear = int(cp_transmission.vl[\"Transmission\"][\"Gear\"])\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(can_gear, None))\n\n    ret.steeringAngleDeg = cp.vl[\"Steering_Torque\"][\"Steering_Angle\"]\n\n    if not (self.CP.flags & SubaruFlags.PREGLOBAL):\n      # ideally we get this from the car, but unclear if it exists. diagnostic software doesn't even have it\n      ret.steeringRateDeg = self.angle_rate_calulator.update(ret.steeringAngleDeg, cp.vl[\"Steering_Torque\"][\"COUNTER\"])\n\n    ret.steeringTorque = cp.vl[\"Steering_Torque\"][\"Steer_Torque_Sensor\"]\n    ret.steeringTorqueEps = cp.vl[\"Steering_Torque\"][\"Steer_Torque_Output\"]\n\n    steer_threshold = 75 if self.CP.flags & SubaruFlags.PREGLOBAL else 80\n    ret.steeringPressed = abs(ret.steeringTorque) > steer_threshold\n\n    cp_cruise = cp_body if self.CP.flags & SubaruFlags.GLOBAL_GEN2 else cp\n    if self.CP.flags & SubaruFlags.HYBRID:\n      ret.cruiseState.enabled = cp_cam.vl[\"ES_DashStatus\"]['Cruise_Activated'] != 0\n      ret.cruiseState.available = cp_cam.vl[\"ES_DashStatus\"]['Cruise_On'] != 0\n    else:\n      ret.cruiseState.enabled = cp_cruise.vl[\"CruiseControl\"][\"Cruise_Activated\"] != 0\n      ret.cruiseState.available = cp_cruise.vl[\"CruiseControl\"][\"Cruise_On\"] != 0\n    ret.cruiseState.speed = cp_cam.vl[\"ES_DashStatus\"][\"Cruise_Set_Speed\"] * CV.KPH_TO_MS\n\n    if (self.CP.flags & SubaruFlags.PREGLOBAL and cp.vl[\"Dash_State2\"][\"UNITS\"] == 1) or \\\n       (not (self.CP.flags & SubaruFlags.PREGLOBAL) and cp.vl[\"Dashlights\"][\"UNITS\"] == 1):\n      ret.cruiseState.speed *= CV.MPH_TO_KPH\n\n    ret.seatbeltUnlatched = cp.vl[\"Dashlights\"][\"SEATBELT_FL\"] == 1\n    ret.doorOpen = any([cp.vl[\"BodyInfo\"][\"DOOR_OPEN_RR\"],\n                        cp.vl[\"BodyInfo\"][\"DOOR_OPEN_RL\"],\n                        cp.vl[\"BodyInfo\"][\"DOOR_OPEN_FR\"],\n                        cp.vl[\"BodyInfo\"][\"DOOR_OPEN_FL\"]])\n    ret.steerFaultPermanent = cp.vl[\"Steering_Torque\"][\"Steer_Error_1\"] == 1\n\n    if self.CP.flags & SubaruFlags.PREGLOBAL:\n      self.cruise_button = cp_cam.vl[\"ES_Distance\"][\"Cruise_Button\"]\n      self.ready = not cp_cam.vl[\"ES_DashStatus\"][\"Not_Ready_Startup\"]\n    else:\n      ret.steerFaultTemporary = cp.vl[\"Steering_Torque\"][\"Steer_Warning\"] == 1\n      ret.cruiseState.nonAdaptive = cp_cam.vl[\"ES_DashStatus\"][\"Conventional_Cruise\"] == 1\n      ret.cruiseState.standstill = cp_cam.vl[\"ES_DashStatus\"][\"Cruise_State\"] == 3\n      ret.stockFcw = (cp_cam.vl[\"ES_LKAS_State\"][\"LKAS_Alert\"] == 1) or \\\n                     (cp_cam.vl[\"ES_LKAS_State\"][\"LKAS_Alert\"] == 2)\n\n      self.es_lkas_state_msg = copy.copy(cp_cam.vl[\"ES_LKAS_State\"])\n      cp_es_brake = cp_body if self.CP.flags & SubaruFlags.GLOBAL_GEN2 else cp_cam\n      self.es_brake_msg = copy.copy(cp_es_brake.vl[\"ES_Brake\"])\n      cp_es_status = cp_body if self.CP.flags & SubaruFlags.GLOBAL_GEN2 else cp_cam\n\n      # TODO: Hybrid cars don't have ES_Distance, need a replacement\n      if not (self.CP.flags & SubaruFlags.HYBRID):\n        # 8 is known AEB, there are a few other values related to AEB we ignore\n        ret.stockAeb = (cp_es_distance.vl[\"ES_Brake\"][\"AEB_Status\"] == 8) and \\\n                       (cp_es_distance.vl[\"ES_Brake\"][\"Brake_Pressure\"] != 0)\n\n        self.es_status_msg = copy.copy(cp_es_status.vl[\"ES_Status\"])\n        self.cruise_control_msg = copy.copy(cp_cruise.vl[\"CruiseControl\"])\n\n    if not (self.CP.flags & SubaruFlags.HYBRID):\n      self.es_distance_msg = copy.copy(cp_es_distance.vl[\"ES_Distance\"])\n\n    self.es_dashstatus_msg = copy.copy(cp_cam.vl[\"ES_DashStatus\"])\n    if self.CP.flags & SubaruFlags.SEND_INFOTAINMENT:\n      self.es_infotainment_msg = copy.copy(cp_cam.vl[\"ES_Infotainment\"])\n\n    return ret\n\n  @staticmethod\n  def get_common_global_body_messages(CP):\n    messages = [\n      (\"Wheel_Speeds\", 50),\n      (\"Brake_Status\", 50),\n    ]\n\n    if not (CP.flags & SubaruFlags.HYBRID):\n      messages.append((\"CruiseControl\", 20))\n\n    return messages\n\n  @staticmethod\n  def get_common_global_es_messages(CP):\n    messages = [\n      (\"ES_Brake\", 20),\n    ]\n\n    if not (CP.flags & SubaruFlags.HYBRID):\n      messages += [\n        (\"ES_Distance\", 20),\n        (\"ES_Status\", 20)\n      ]\n\n    return messages\n\n  @staticmethod\n  def get_common_preglobal_body_messages():\n    messages = [\n      (\"CruiseControl\", 50),\n      (\"Wheel_Speeds\", 50),\n      (\"Dash_State2\", 1),\n    ]\n\n    return messages\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"Dashlights\", 10),\n      (\"Steering_Torque\", 50),\n      (\"BodyInfo\", 1),\n      (\"Brake_Pedal\", 50),\n    ]\n\n    if not (CP.flags & SubaruFlags.HYBRID):\n      messages += [\n        (\"Throttle\", 100),\n        (\"Transmission\", 100)\n      ]\n\n    if CP.enableBsm:\n      messages.append((\"BSD_RCTA\", 17))\n\n    if not (CP.flags & SubaruFlags.PREGLOBAL):\n      if not (CP.flags & SubaruFlags.GLOBAL_GEN2):\n        messages += CarState.get_common_global_body_messages(CP)\n    else:\n      messages += CarState.get_common_preglobal_body_messages()\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus.main)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    if CP.flags & SubaruFlags.PREGLOBAL:\n      messages = [\n        (\"ES_DashStatus\", 20),\n        (\"ES_Distance\", 20),\n      ]\n    else:\n      messages = [\n        (\"ES_DashStatus\", 10),\n        (\"ES_LKAS_State\", 10),\n      ]\n\n      if not (CP.flags & SubaruFlags.GLOBAL_GEN2):\n        messages += CarState.get_common_global_es_messages(CP)\n\n      if CP.flags & SubaruFlags.SEND_INFOTAINMENT:\n        messages.append((\"ES_Infotainment\", 10))\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus.camera)\n\n  @staticmethod\n  def get_body_can_parser(CP):\n    messages = []\n\n    if CP.flags & SubaruFlags.GLOBAL_GEN2:\n      messages += CarState.get_common_global_body_messages(CP)\n      messages += CarState.get_common_global_es_messages(CP)\n\n    if CP.flags & SubaruFlags.HYBRID:\n      messages += [\n        (\"Throttle_Hybrid\", 40),\n        (\"Transmission\", 100)\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, CanBus.alt)\n\n", "selfdrive/car/subaru/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.subaru.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFW_VERSIONS = {\n  CAR.SUBARU_ASCENT: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa5 \\x19\\x02\\x00',\n      b'\\xa5 !\\x02\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\x05\\xc0\\xd0\\x00',\n      b'\\x85\\xc0\\xd0\\x00',\n      b'\\x95\\xc0\\xd0\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00d\\xb9\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00d\\xb9\\x1f@ \\x10',\n      b'\\x00\\x00e@\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e@\\x1f@ $',\n      b\"\\x00\\x00e~\\x1f@ '\",\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xbb,\\xa0t\\x07',\n      b'\\xd1,\\xa0q\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\x00>\\xf0\\x00\\x00',\n      b'\\x00\\xfe\\xf7\\x00\\x00',\n      b'\\x01\\xfe\\xf7\\x00\\x00',\n      b'\\x01\\xfe\\xf9\\x00\\x00',\n      b'\\x01\\xfe\\xfa\\x00\\x00',\n    ],\n  },\n  CAR.SUBARU_ASCENT_2023: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa5 #\\x03\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'%\\xc0\\xd0\\x11',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x05!\\x08\\x1dK\\x05!\\x08\\x01/',\n    ],\n    (Ecu.engine, 0x7a2, None): [\n      b'\\xe5,\\xa0P\\x07',\n    ],\n    (Ecu.transmission, 0x7a3, None): [\n      b'\\x04\\xfe\\xf3\\x00\\x00',\n    ],\n  },\n  CAR.SUBARU_LEGACY: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa1  \\x02\\x01',\n      b'\\xa1  \\x02\\x02',\n      b'\\xa1  \\x03\\x03',\n      b'\\xa1  \\x04\\x01',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\x9b\\xc0\\x11\\x00',\n      b'\\x9b\\xc0\\x11\\x02',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00e\\x80\\x00\\x1f@ \\x19\\x00',\n      b'\\x00\\x00e\\x9a\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xde\"a0\\x07',\n      b'\\xde,\\xa0@\\x07',\n      b'\\xe2\"aq\\x07',\n      b'\\xe2,\\xa0@\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xa5\\xf6\\x05@\\x00',\n      b'\\xa5\\xfe\\xc7@\\x00',\n      b'\\xa7\\xf6\\x04@\\x00',\n      b'\\xa7\\xfe\\xc4@\\x00',\n    ],\n  },\n  CAR.SUBARU_IMPREZA: {\n    (Ecu.abs, 0x7b0, None): [\n      b'z\\x84\\x19\\x90\\x00',\n      b'z\\x94\\x08\\x90\\x00',\n      b'z\\x94\\x08\\x90\\x01',\n      b'z\\x94\\x0c\\x90\\x00',\n      b'z\\x94\\x0c\\x90\\x01',\n      b'z\\x94.\\x90\\x00',\n      b'z\\x94?\\x90\\x00',\n      b'z\\x9c\\x19\\x80\\x01',\n      b'\\xa2 \\x185\\x00',\n      b'\\xa2 \\x193\\x00',\n      b'\\xa2 \\x194\\x00',\n      b'\\xa2 \\x19`\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'z\\xc0\\x00\\x00',\n      b'z\\xc0\\x04\\x00',\n      b'z\\xc0\\x08\\x00',\n      b'z\\xc0\\n\\x00',\n      b'z\\xc0\\x0c\\x00',\n      b'\\x8a\\xc0\\x00\\x00',\n      b'\\x8a\\xc0\\x10\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00c\\xf4\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00c\\xf4\\x1f@ \\x07',\n      b'\\x00\\x00d)\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00d)\\x1f@ \\x07',\n      b'\\x00\\x00dd\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00dd\\x1f@ \\x0e',\n      b'\\x00\\x00d\\xb5\\x1f@ \\x0e',\n      b'\\x00\\x00d\\xdc\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00d\\xdc\\x1f@ \\x0e',\n      b'\\x00\\x00e\\x02\\x1f@ \\x14',\n      b'\\x00\\x00e\\x1c\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e\\x1c\\x1f@ \\x14',\n      b'\\x00\\x00e+\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e+\\x1f@ \\x14',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xaa\\x00Bu\\x07',\n      b'\\xaa\\x01bt\\x07',\n      b'\\xaa!`u\\x07',\n      b'\\xaa!au\\x07',\n      b'\\xaa!av\\x07',\n      b'\\xaa!aw\\x07',\n      b'\\xaa!dq\\x07',\n      b'\\xaa!ds\\x07',\n      b'\\xaa!dt\\x07',\n      b'\\xaaafs\\x07',\n      b'\\xbe!as\\x07',\n      b'\\xbe!at\\x07',\n      b'\\xbeacr\\x07',\n      b'\\xc5!`r\\x07',\n      b'\\xc5!`s\\x07',\n      b'\\xc5!ap\\x07',\n      b'\\xc5!ar\\x07',\n      b'\\xc5!as\\x07',\n      b'\\xc5!dr\\x07',\n      b'\\xc5!ds\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xe3\\xd0\\x081\\x00',\n      b'\\xe3\\xd5\\x161\\x00',\n      b'\\xe3\\xe5F1\\x00',\n      b'\\xe3\\xf5\\x06\\x00\\x00',\n      b'\\xe3\\xf5\\x07\\x00\\x00',\n      b'\\xe3\\xf5C\\x00\\x00',\n      b'\\xe3\\xf5F\\x00\\x00',\n      b'\\xe3\\xf5G\\x00\\x00',\n      b'\\xe4\\xe5\\x021\\x00',\n      b'\\xe4\\xe5\\x061\\x00',\n      b'\\xe4\\xf5\\x02\\x00\\x00',\n      b'\\xe4\\xf5\\x07\\x00\\x00',\n      b'\\xe5\\xf5\\x04\\x00\\x00',\n      b'\\xe5\\xf5$\\x00\\x00',\n      b'\\xe5\\xf5B\\x00\\x00',\n    ],\n  },\n  CAR.SUBARU_IMPREZA_2020: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa2 \\x193\\x00',\n      b'\\xa2 \\x194\\x00',\n      b'\\xa2  `\\x00',\n      b'\\xa2 !3\\x00',\n      b'\\xa2 !6\\x00',\n      b'\\xa2 !`\\x00',\n      b'\\xa2 !i\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\n\\xc0\\x04\\x00',\n      b'\\n\\xc0\\x04\\x01',\n      b'\\x9a\\xc0\\x00\\x00',\n      b'\\x9a\\xc0\\x04\\x00',\n      b'\\x9a\\xc0\\n\\x01',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00eb\\x1f@ \"',\n      b'\\x00\\x00eq\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00eq\\x1f@ \"',\n      b'\\x00\\x00e\\x8f\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e\\x8f\\x1f@ )',\n      b'\\x00\\x00e\\x92\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e\\xa4\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e\\xa4\\x1f@ (',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xca!`0\\x07',\n      b'\\xca!`p\\x07',\n      b'\\xca!ap\\x07',\n      b'\\xca!f@\\x07',\n      b'\\xca!fp\\x07',\n      b'\\xcaacp\\x07',\n      b'\\xcc!`p\\x07',\n      b'\\xcc!fp\\x07',\n      b'\\xcc\"f0\\x07',\n      b'\\xe6!`@\\x07',\n      b'\\xe6!fp\\x07',\n      b'\\xe6\"f0\\x07',\n      b'\\xe6\"fp\\x07',\n      b'\\xf3\"f@\\x07',\n      b'\\xf3\"fp\\x07',\n      b'\\xf3\"fr\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xe6\\x15\\x042\\x00',\n      b'\\xe6\\xf5\\x04\\x00\\x00',\n      b'\\xe6\\xf5$\\x00\\x00',\n      b'\\xe6\\xf5D0\\x00',\n      b'\\xe7\\xf5\\x04\\x00\\x00',\n      b'\\xe7\\xf5D0\\x00',\n      b'\\xe7\\xf6B0\\x00',\n      b'\\xe9\\xf5\"\\x00\\x00',\n      b'\\xe9\\xf5B0\\x00',\n      b'\\xe9\\xf6B0\\x00',\n      b'\\xe9\\xf6F0\\x00',\n    ],\n  },\n  CAR.SUBARU_CROSSTREK_HYBRID: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa2 \\x19e\\x01',\n      b'\\xa2 !e\\x01',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\n\\xc2\\x01\\x00',\n      b'\\x9a\\xc2\\x01\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00el\\x1f@ #',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xd7!`@\\x07',\n      b'\\xd7!`p\\x07',\n      b'\\xf4!`0\\x07',\n    ],\n  },\n  CAR.SUBARU_FORESTER: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa3 \\x18\\x14\\x00',\n      b'\\xa3 \\x18&\\x00',\n      b'\\xa3 \\x19\\x14\\x00',\n      b'\\xa3 \\x19&\\x00',\n      b'\\xa3 \\x19h\\x00',\n      b'\\xa3  \\x14\\x00',\n      b'\\xa3  \\x14\\x01',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\x8d\\xc0\\x00\\x00',\n      b'\\x8d\\xc0\\x04\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00e!\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e!\\x1f@ \\x11',\n      b'\\x00\\x00e^\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e^\\x1f@ !',\n      b'\\x00\\x00e`\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e`\\x1f@  ',\n      b'\\x00\\x00e\\x97\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e\\x97\\x1f@ 0',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xb6\"`A\\x07',\n      b'\\xb6\\xa2`A\\x07',\n      b'\\xcb\"`@\\x07',\n      b'\\xcb\"`p\\x07',\n      b'\\xcf\"`0\\x07',\n      b'\\xcf\"`p\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\x1a\\xe6B1\\x00',\n      b'\\x1a\\xe6F1\\x00',\n      b'\\x1a\\xf6B0\\x00',\n      b'\\x1a\\xf6B`\\x00',\n      b'\\x1a\\xf6F`\\x00',\n      b'\\x1a\\xf6b0\\x00',\n      b'\\x1a\\xf6b`\\x00',\n      b'\\x1a\\xf6f`\\x00',\n    ],\n  },\n  CAR.SUBARU_FORESTER_HYBRID: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa3 \\x19T\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\x8d\\xc2\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00eY\\x1f@ !',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xd2\\xa1`r\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\x1b\\xa7@a\\x00',\n    ],\n  },\n  CAR.SUBARU_FORESTER_PREGLOBAL: {\n    (Ecu.abs, 0x7b0, None): [\n      b'm\\x97\\x14@',\n      b'}\\x97\\x14@',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'm\\xc0\\x10\\x00',\n      b'}\\xc0\\x10\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00c\\xe9\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00c\\xe9\\x1f@ \\x03',\n      b'\\x00\\x00d5\\x1f@ \\t',\n      b'\\x00\\x00d\\xd3\\x1f@ \\t',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xa7\"@0\\x07',\n      b'\\xa7\"@p\\x07',\n      b'\\xa7)\\xa0q\\x07',\n      b'\\xba\"@@\\x07',\n      b'\\xba\"@p\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\x1a\\xf6F`\\x00',\n      b'\\xda\\xf2`p\\x00',\n      b'\\xda\\xf2`\\x80\\x00',\n      b'\\xda\\xfd\\xe0\\x80\\x00',\n      b'\\xdc\\xf2@`\\x00',\n      b'\\xdc\\xf2``\\x00',\n      b'\\xdc\\xf2`\\x80\\x00',\n      b'\\xdc\\xf2`\\x81\\x00',\n    ],\n  },\n  CAR.SUBARU_LEGACY_PREGLOBAL: {\n    (Ecu.abs, 0x7b0, None): [\n      b'[\\x97D\\x00',\n      b'[\\xba\\xc4\\x03',\n      b'k\\x97D\\x00',\n      b'k\\x9aD\\x00',\n      b'{\\x97D\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'K\\xb0\\x00\\x01',\n      b'[\\xb0\\x00\\x01',\n      b'k\\xb0\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00c\\x94\\x1f@\\x10\\x08',\n      b'\\x00\\x00c\\xb7\\x1f@\\x10\\x16',\n      b'\\x00\\x00c\\xec\\x1f@ \\x04',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xa0\"@q\\x07',\n      b'\\xa0+@p\\x07',\n      b'\\xab*@r\\x07',\n      b'\\xab+@p\\x07',\n      b'\\xb4\"@0\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xbd\\xf2\\x00`\\x00',\n      b'\\xbe\\xf2\\x00p\\x00',\n      b'\\xbe\\xfb\\xc0p\\x00',\n      b'\\xbf\\xf2\\x00\\x80\\x00',\n      b'\\xbf\\xfb\\xc0\\x80\\x00',\n    ],\n  },\n  CAR.SUBARU_OUTBACK_PREGLOBAL: {\n    (Ecu.abs, 0x7b0, None): [\n      b'[\\xba\\xac\\x03',\n      b'[\\xf7\\xac\\x00',\n      b'[\\xf7\\xac\\x03',\n      b'[\\xf7\\xbc\\x03',\n      b'k\\x97\\xac\\x00',\n      b'k\\x9a\\xac\\x00',\n      b'{\\x97\\xac\\x00',\n      b'{\\x9a\\xac\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'K\\xb0\\x00\\x00',\n      b'K\\xb0\\x00\\x02',\n      b'[\\xb0\\x00\\x00',\n      b'k\\xb0\\x00\\x00',\n      b'{\\xb0\\x00\\x01',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00c\\x90\\x1f@\\x10\\x0e',\n      b'\\x00\\x00c\\x94\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00c\\x94\\x1f@\\x10\\x08',\n      b'\\x00\\x00c\\xb7\\x1f@\\x10\\x16',\n      b'\\x00\\x00c\\xd1\\x1f@\\x10\\x17',\n      b'\\x00\\x00c\\xec\\x1f@ \\x04',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xa0\"@\\x80\\x07',\n      b'\\xa0*@q\\x07',\n      b'\\xa0*@u\\x07',\n      b'\\xa0+@@\\x07',\n      b'\\xa0bAq\\x07',\n      b'\\xab\"@@\\x07',\n      b'\\xab\"@s\\x07',\n      b'\\xab*@@\\x07',\n      b'\\xab+@@\\x07',\n      b'\\xb4\"@0\\x07',\n      b'\\xb4\"@p\\x07',\n      b'\\xb4\"@r\\x07',\n      b'\\xb4+@p\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xbd\\xf2@`\\x00',\n      b'\\xbd\\xf2@\\x81\\x00',\n      b'\\xbd\\xfb\\xe0\\x80\\x00',\n      b'\\xbe\\xf2@p\\x00',\n      b'\\xbe\\xf2@\\x80\\x00',\n      b'\\xbe\\xfb\\xe0p\\x00',\n      b'\\xbf\\xe2@\\x80\\x00',\n      b'\\xbf\\xf2@\\x80\\x00',\n      b'\\xbf\\xfb\\xe0b\\x00',\n    ],\n  },\n  CAR.SUBARU_OUTBACK_PREGLOBAL_2018: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x8b\\x97\\xac\\x00',\n      b'\\x8b\\x97\\xbc\\x00',\n      b'\\x8b\\x99\\xac\\x00',\n      b'\\x8b\\x9a\\xac\\x00',\n      b'\\x9b\\x97\\xac\\x00',\n      b'\\x9b\\x97\\xbe\\x10',\n      b'\\x9b\\x9a\\xac\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'{\\xb0\\x00\\x00',\n      b'{\\xb0\\x00\\x01',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00df\\x1f@ \\n',\n      b'\\x00\\x00d\\x95\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00d\\x95\\x1f@ \\x0f',\n      b'\\x00\\x00d\\xfe\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00d\\xfe\\x1f@ \\x15',\n      b'\\x00\\x00e\\x19\\x1f@ \\x15',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xb5\"@P\\x07',\n      b'\\xb5\"@p\\x07',\n      b'\\xb5+@@\\x07',\n      b'\\xb5b@1\\x07',\n      b'\\xb5q\\xe0@\\x07',\n      b'\\xc4\"@0\\x07',\n      b'\\xc4+@0\\x07',\n      b'\\xc4b@p\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xbb\\xf2@`\\x00',\n      b'\\xbb\\xfb\\xe0`\\x00',\n      b'\\xbc\\xaf\\xe0`\\x00',\n      b'\\xbc\\xe2@\\x80\\x00',\n      b'\\xbc\\xf2@\\x80\\x00',\n      b'\\xbc\\xf2@\\x81\\x00',\n      b'\\xbc\\xfb\\xe0`\\x00',\n      b'\\xbc\\xfb\\xe0\\x80\\x00',\n    ],\n  },\n  CAR.SUBARU_OUTBACK: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa1  \\x06\\x00',\n      b'\\xa1  \\x06\\x01',\n      b'\\xa1  \\x06\\x02',\n      b'\\xa1  \\x07\\x00',\n      b'\\xa1  \\x07\\x02',\n      b'\\xa1  \\x07\\x03',\n      b'\\xa1  \\x08\\x00',\n      b'\\xa1  \\x08\\x01',\n      b'\\xa1  \\x08\\x02',\n      b'\\xa1 \"\\t\\x00',\n      b'\\xa1 \"\\t\\x01',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'\\x1b\\xc0\\x10\\x00',\n      b'\\x9b\\xc0\\x10\\x00',\n      b'\\x9b\\xc0\\x10\\x02',\n      b'\\x9b\\xc0 \\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x00\\x00eJ\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00eJ\\x00\\x1f@ \\x19\\x00',\n      b'\\x00\\x00e\\x80\\x00\\x1f@ \\x19\\x00',\n      b'\\x00\\x00e\\x9a\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x00\\x00e\\x9a\\x00\\x1f@ 1\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xbc\"`@\\x07',\n      b'\\xbc\"`q\\x07',\n      b'\\xbc,\\xa0q\\x07',\n      b'\\xbc,\\xa0u\\x07',\n      b'\\xde\"`0\\x07',\n      b'\\xde,\\xa0@\\x07',\n      b'\\xe2\"`0\\x07',\n      b'\\xe2\"`p\\x07',\n      b'\\xe2\"`q\\x07',\n      b'\\xe3,\\xa0@\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\xa5\\xf6D@\\x00',\n      b'\\xa5\\xfe\\xf6@\\x00',\n      b'\\xa5\\xfe\\xf7@\\x00',\n      b'\\xa5\\xfe\\xf8@\\x00',\n      b'\\xa7\\x8e\\xf40\\x00',\n      b'\\xa7\\xf6D@\\x00',\n      b'\\xa7\\xfe\\xf4@\\x00',\n    ],\n  },\n  CAR.SUBARU_FORESTER_2022: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa3 !v\\x00',\n      b'\\xa3 !x\\x00',\n      b'\\xa3 \"v\\x00',\n      b'\\xa3 \"x\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'-\\xc0\\x040',\n      b'-\\xc0%0',\n      b'=\\xc0%\\x02',\n      b'=\\xc04\\x02',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\x04!\\x01\\x1eD\\x07!\\x00\\x04,',\n      b'\\x04!\\x08\\x01.\\x07!\\x08\\x022',\n      b'\\r!\\x08\\x017\\n!\\x08\\x003',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\xd5\"`0\\x07',\n      b'\\xd5\"a0\\x07',\n      b'\\xf1\"`q\\x07',\n      b'\\xf1\"aq\\x07',\n      b'\\xfa\"ap\\x07',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'\\x1d\\x86B0\\x00',\n      b'\\x1d\\xf6B0\\x00',\n      b'\\x1e\\x86B0\\x00',\n      b'\\x1e\\x86F0\\x00',\n      b'\\x1e\\xf6D0\\x00',\n    ],\n  },\n  CAR.SUBARU_OUTBACK_2023: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\xa1 #\\x14\\x00',\n      b'\\xa1 #\\x17\\x00',\n    ],\n    (Ecu.eps, 0x746, None): [\n      b'+\\xc0\\x10\\x11\\x00',\n      b'+\\xc0\\x12\\x11\\x00',\n    ],\n    (Ecu.fwdCamera, 0x787, None): [\n      b'\\t!\\x08\\x046\\x05!\\x08\\x01/',\n    ],\n    (Ecu.engine, 0x7a2, None): [\n      b'\\xed,\\xa0q\\x07',\n      b'\\xed,\\xa2q\\x07',\n    ],\n    (Ecu.transmission, 0x7a3, None): [\n      b'\\xa8\\x8e\\xf41\\x00',\n      b'\\xa8\\xfe\\xf41\\x00',\n    ],\n  },\n}\n", "selfdrive/car/subaru/subarucan.py": "from cereal import car\nfrom openpilot.selfdrive.car.subaru.values import CanBus\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\n\ndef create_steering_control(packer, apply_steer, steer_req):\n  values = {\n    \"LKAS_Output\": apply_steer,\n    \"LKAS_Request\": steer_req,\n    \"SET_1\": 1\n  }\n  return packer.make_can_msg(\"ES_LKAS\", 0, values)\n\n\ndef create_steering_control_angle(packer, apply_steer, steer_req):\n  values = {\n    \"LKAS_Output\": apply_steer,\n    \"LKAS_Request\": steer_req,\n    \"SET_3\": 3\n  }\n  return packer.make_can_msg(\"ES_LKAS_ANGLE\", 0, values)\n\n\ndef create_steering_status(packer):\n  return packer.make_can_msg(\"ES_LKAS_State\", 0, {})\n\ndef create_es_distance(packer, frame, es_distance_msg, bus, pcm_cancel_cmd, long_enabled = False, brake_cmd = False, cruise_throttle = 0):\n  values = {s: es_distance_msg[s] for s in [\n    \"CHECKSUM\",\n    \"Signal1\",\n    \"Cruise_Fault\",\n    \"Cruise_Throttle\",\n    \"Signal2\",\n    \"Car_Follow\",\n    \"Low_Speed_Follow\",\n    \"Cruise_Soft_Disable\",\n    \"Signal7\",\n    \"Cruise_Brake_Active\",\n    \"Distance_Swap\",\n    \"Cruise_EPB\",\n    \"Signal4\",\n    \"Close_Distance\",\n    \"Signal5\",\n    \"Cruise_Cancel\",\n    \"Cruise_Set\",\n    \"Cruise_Resume\",\n    \"Signal6\",\n  ]}\n\n  values[\"COUNTER\"] = frame % 0x10\n\n  if long_enabled:\n    values[\"Cruise_Throttle\"] = cruise_throttle\n\n    # Do not disable openpilot on Eyesight Soft Disable, if openpilot is controlling long\n    values[\"Cruise_Soft_Disable\"] = 0\n    values[\"Cruise_Fault\"] = 0\n\n    values[\"Cruise_Brake_Active\"] = brake_cmd\n\n  if pcm_cancel_cmd:\n    values[\"Cruise_Cancel\"] = 1\n    values[\"Cruise_Throttle\"] = 1818 # inactive throttle\n\n  return packer.make_can_msg(\"ES_Distance\", bus, values)\n\n\ndef create_es_lkas_state(packer, frame, es_lkas_state_msg, enabled, visual_alert, left_line, right_line, left_lane_depart, right_lane_depart):\n  values = {s: es_lkas_state_msg[s] for s in [\n    \"CHECKSUM\",\n    \"LKAS_Alert_Msg\",\n    \"Signal1\",\n    \"LKAS_ACTIVE\",\n    \"LKAS_Dash_State\",\n    \"Signal2\",\n    \"Backward_Speed_Limit_Menu\",\n    \"LKAS_Left_Line_Enable\",\n    \"LKAS_Left_Line_Light_Blink\",\n    \"LKAS_Right_Line_Enable\",\n    \"LKAS_Right_Line_Light_Blink\",\n    \"LKAS_Left_Line_Visible\",\n    \"LKAS_Right_Line_Visible\",\n    \"LKAS_Alert\",\n    \"Signal3\",\n  ]}\n\n  values[\"COUNTER\"] = frame % 0x10\n\n  # Filter the stock LKAS \"Keep hands on wheel\" alert\n  if values[\"LKAS_Alert_Msg\"] == 1:\n    values[\"LKAS_Alert_Msg\"] = 0\n\n  # Filter the stock LKAS sending an audible alert when it turns off LKAS\n  if values[\"LKAS_Alert\"] == 27:\n    values[\"LKAS_Alert\"] = 0\n\n  # Filter the stock LKAS sending an audible alert when \"Keep hands on wheel\" alert is active (2020+ models)\n  if values[\"LKAS_Alert\"] == 28 and values[\"LKAS_Alert_Msg\"] == 7:\n    values[\"LKAS_Alert\"] = 0\n\n  # Filter the stock LKAS sending an audible alert when \"Keep hands on wheel OFF\" alert is active (2020+ models)\n  if values[\"LKAS_Alert\"] == 30:\n    values[\"LKAS_Alert\"] = 0\n\n  # Filter the stock LKAS sending \"Keep hands on wheel OFF\" alert (2020+ models)\n  if values[\"LKAS_Alert_Msg\"] == 7:\n    values[\"LKAS_Alert_Msg\"] = 0\n\n  # Show Keep hands on wheel alert for openpilot steerRequired alert\n  if visual_alert == VisualAlert.steerRequired:\n    values[\"LKAS_Alert_Msg\"] = 1\n\n  # Ensure we don't overwrite potentially more important alerts from stock (e.g. FCW)\n  if visual_alert == VisualAlert.ldw and values[\"LKAS_Alert\"] == 0:\n    if left_lane_depart:\n      values[\"LKAS_Alert\"] = 12  # Left lane departure dash alert\n    elif right_lane_depart:\n      values[\"LKAS_Alert\"] = 11  # Right lane departure dash alert\n\n  if enabled:\n    values[\"LKAS_ACTIVE\"] = 1  # Show LKAS lane lines\n    values[\"LKAS_Dash_State\"] = 2  # Green enabled indicator\n  else:\n    values[\"LKAS_Dash_State\"] = 0  # LKAS Not enabled\n\n  values[\"LKAS_Left_Line_Visible\"] = int(left_line)\n  values[\"LKAS_Right_Line_Visible\"] = int(right_line)\n\n  return packer.make_can_msg(\"ES_LKAS_State\", CanBus.main, values)\n\ndef create_es_dashstatus(packer, frame, dashstatus_msg, enabled, long_enabled, long_active, lead_visible):\n  values = {s: dashstatus_msg[s] for s in [\n    \"CHECKSUM\",\n    \"PCB_Off\",\n    \"LDW_Off\",\n    \"Signal1\",\n    \"Cruise_State_Msg\",\n    \"LKAS_State_Msg\",\n    \"Signal2\",\n    \"Cruise_Soft_Disable\",\n    \"Cruise_Status_Msg\",\n    \"Signal3\",\n    \"Cruise_Distance\",\n    \"Signal4\",\n    \"Conventional_Cruise\",\n    \"Signal5\",\n    \"Cruise_Disengaged\",\n    \"Cruise_Activated\",\n    \"Signal6\",\n    \"Cruise_Set_Speed\",\n    \"Cruise_Fault\",\n    \"Cruise_On\",\n    \"Display_Own_Car\",\n    \"Brake_Lights\",\n    \"Car_Follow\",\n    \"Signal7\",\n    \"Far_Distance\",\n    \"Cruise_State\",\n  ]}\n\n  values[\"COUNTER\"] = frame % 0x10\n\n  if long_enabled:\n    values[\"Cruise_State\"] = 0\n    values[\"Cruise_Activated\"] = enabled\n    values[\"Cruise_Disengaged\"] = 0\n    values[\"Car_Follow\"] = int(lead_visible)\n\n    values[\"PCB_Off\"] = 1 # AEB is not presevered, so show the PCB_Off on dash\n    values[\"LDW_Off\"] = 0\n    values[\"Cruise_Fault\"] = 0\n\n  # Filter stock LKAS disabled and Keep hands on steering wheel OFF alerts\n  if values[\"LKAS_State_Msg\"] in (2, 3):\n    values[\"LKAS_State_Msg\"] = 0\n\n  return packer.make_can_msg(\"ES_DashStatus\", CanBus.main, values)\n\ndef create_es_brake(packer, frame, es_brake_msg, long_enabled, long_active, brake_value):\n  values = {s: es_brake_msg[s] for s in [\n    \"CHECKSUM\",\n    \"Signal1\",\n    \"Brake_Pressure\",\n    \"AEB_Status\",\n    \"Cruise_Brake_Lights\",\n    \"Cruise_Brake_Fault\",\n    \"Cruise_Brake_Active\",\n    \"Cruise_Activated\",\n    \"Signal3\",\n  ]}\n\n  values[\"COUNTER\"] = frame % 0x10\n\n  if long_enabled:\n    values[\"Cruise_Brake_Fault\"] = 0\n    values[\"Cruise_Activated\"] = long_active\n\n    values[\"Brake_Pressure\"] = brake_value\n\n    values[\"Cruise_Brake_Active\"] = brake_value > 0\n    values[\"Cruise_Brake_Lights\"] = brake_value >= 70\n\n  return packer.make_can_msg(\"ES_Brake\", CanBus.main, values)\n\ndef create_es_status(packer, frame, es_status_msg, long_enabled, long_active, cruise_rpm):\n  values = {s: es_status_msg[s] for s in [\n    \"CHECKSUM\",\n    \"Signal1\",\n    \"Cruise_Fault\",\n    \"Cruise_RPM\",\n    \"Cruise_Activated\",\n    \"Brake_Lights\",\n    \"Cruise_Hold\",\n    \"Signal3\",\n  ]}\n\n  values[\"COUNTER\"] = frame % 0x10\n\n  if long_enabled:\n    values[\"Cruise_RPM\"] = cruise_rpm\n    values[\"Cruise_Fault\"] = 0\n\n    values[\"Cruise_Activated\"] = long_active\n\n  return packer.make_can_msg(\"ES_Status\", CanBus.main, values)\n\n\ndef create_es_infotainment(packer, frame, es_infotainment_msg, visual_alert):\n  # Filter stock LKAS disabled and Keep hands on steering wheel OFF alerts\n  values = {s: es_infotainment_msg[s] for s in [\n    \"CHECKSUM\",\n    \"LKAS_State_Infotainment\",\n    \"LKAS_Blue_Lines\",\n    \"Signal1\",\n    \"Signal2\",\n  ]}\n\n  values[\"COUNTER\"] = frame % 0x10\n\n  if values[\"LKAS_State_Infotainment\"] in (3, 4):\n    values[\"LKAS_State_Infotainment\"] = 0\n\n  # Show Keep hands on wheel alert for openpilot steerRequired alert\n  if visual_alert == VisualAlert.steerRequired:\n    values[\"LKAS_State_Infotainment\"] = 3\n\n  # Show Obstacle Detected for fcw\n  if visual_alert == VisualAlert.fcw:\n    values[\"LKAS_State_Infotainment\"] = 2\n\n  return packer.make_can_msg(\"ES_Infotainment\", CanBus.main, values)\n\n\ndef create_es_highbeamassist(packer):\n  values = {\n    \"HBA_Available\": False,\n  }\n\n  return packer.make_can_msg(\"ES_HighBeamAssist\", CanBus.main, values)\n\n\ndef create_es_static_1(packer):\n  values = {\n    \"SET_3\": 3,\n  }\n\n  return packer.make_can_msg(\"ES_STATIC_1\", CanBus.main, values)\n\n\ndef create_es_static_2(packer):\n  values = {\n    \"SET_3\": 3,\n  }\n\n  return packer.make_can_msg(\"ES_STATIC_2\", CanBus.main, values)\n\n\n# *** Subaru Pre-global ***\n\ndef subaru_preglobal_checksum(packer, values, addr, checksum_byte=7):\n  dat = packer.make_can_msg(addr, 0, values)[2]\n  return (sum(dat[:checksum_byte]) + sum(dat[checksum_byte+1:])) % 256\n\n\ndef create_preglobal_steering_control(packer, frame, apply_steer, steer_req):\n  values = {\n    \"COUNTER\": frame % 0x08,\n    \"LKAS_Command\": apply_steer,\n    \"LKAS_Active\": steer_req,\n  }\n  values[\"Checksum\"] = subaru_preglobal_checksum(packer, values, \"ES_LKAS\")\n\n  return packer.make_can_msg(\"ES_LKAS\", CanBus.main, values)\n\n\ndef create_preglobal_es_distance(packer, cruise_button, es_distance_msg):\n  values = {s: es_distance_msg[s] for s in [\n    \"Cruise_Throttle\",\n    \"Signal1\",\n    \"Car_Follow\",\n    \"Signal2\",\n    \"Cruise_Brake_Active\",\n    \"Distance_Swap\",\n    \"Standstill\",\n    \"Signal3\",\n    \"Close_Distance\",\n    \"Signal4\",\n    \"Standstill_2\",\n    \"Cruise_Fault\",\n    \"Signal5\",\n    \"COUNTER\",\n    \"Signal6\",\n    \"Cruise_Button\",\n    \"Signal7\",\n  ]}\n\n  values[\"Cruise_Button\"] = cruise_button\n  values[\"Checksum\"] = subaru_preglobal_checksum(packer, values, \"ES_Distance\")\n\n  return packer.make_can_msg(\"ES_Distance\", CanBus.main, values)\n", "selfdrive/car/subaru/values.py": "from dataclasses import dataclass, field\nfrom enum import Enum, IntFlag\n\nfrom cereal import car\nfrom panda.python import uds\nfrom openpilot.selfdrive.car import CarSpecs, DbcDict, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarFootnote, CarHarness, CarDocs, CarParts, Tool, Column\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries, p16\n\nEcu = car.CarParams.Ecu\n\n\nclass CarControllerParams:\n  def __init__(self, CP):\n    self.STEER_STEP = 2                # how often we update the steer cmd\n    self.STEER_DELTA_UP = 50           # torque increase per refresh, 0.8s to max\n    self.STEER_DELTA_DOWN = 70         # torque decrease per refresh\n    self.STEER_DRIVER_ALLOWANCE = 60   # allowed driver torque before start limiting\n    self.STEER_DRIVER_MULTIPLIER = 50  # weight driver torque heavily\n    self.STEER_DRIVER_FACTOR = 1       # from dbc\n\n    if CP.flags & SubaruFlags.GLOBAL_GEN2:\n      self.STEER_MAX = 1000\n      self.STEER_DELTA_UP = 40\n      self.STEER_DELTA_DOWN = 40\n    elif CP.carFingerprint == CAR.SUBARU_IMPREZA_2020:\n      self.STEER_MAX = 1439\n    else:\n      self.STEER_MAX = 2047\n\n  THROTTLE_MIN = 808\n  THROTTLE_MAX = 3400\n\n  THROTTLE_INACTIVE     = 1818   # corresponds to zero acceleration\n  THROTTLE_ENGINE_BRAKE = 808    # while braking, eyesight sets throttle to this, probably for engine braking\n\n  BRAKE_MIN = 0\n  BRAKE_MAX = 600                # about -3.5m/s2 from testing\n\n  RPM_MIN = 0\n  RPM_MAX = 3600\n\n  RPM_INACTIVE = 600             # a good base rpm for zero acceleration\n\n  THROTTLE_LOOKUP_BP = [0, 2]\n  THROTTLE_LOOKUP_V = [THROTTLE_INACTIVE, THROTTLE_MAX]\n\n  RPM_LOOKUP_BP = [0, 2]\n  RPM_LOOKUP_V = [RPM_INACTIVE, RPM_MAX]\n\n  BRAKE_LOOKUP_BP = [-3.5, 0]\n  BRAKE_LOOKUP_V = [BRAKE_MAX, BRAKE_MIN]\n\n\nclass SubaruFlags(IntFlag):\n  # Detected flags\n  SEND_INFOTAINMENT = 1\n  DISABLE_EYESIGHT = 2\n\n  # Static flags\n  GLOBAL_GEN2 = 4\n\n  # Cars that temporarily fault when steering angle rate is greater than some threshold.\n  # Appears to be all torque-based cars produced around 2019 - present\n  STEER_RATE_LIMITED = 8\n  PREGLOBAL = 16\n  HYBRID = 32\n  LKAS_ANGLE = 64\n\n\nGLOBAL_ES_ADDR = 0x787\nGEN2_ES_BUTTONS_DID = b'\\x11\\x30'\n\n\nclass CanBus:\n  main = 0\n  alt = 1\n  camera = 2\n\n\nclass Footnote(Enum):\n  GLOBAL = CarFootnote(\n    \"In the non-US market, openpilot requires the car to come equipped with EyeSight with Lane Keep Assistance.\",\n    Column.PACKAGE)\n  EXP_LONG = CarFootnote(\n    \"Enabling longitudinal control (alpha) will disable all EyeSight functionality, including AEB, LDW, and RAB.\",\n    Column.LONGITUDINAL)\n\n\n@dataclass\nclass SubaruCarDocs(CarDocs):\n  package: str = \"EyeSight Driver Assistance\"\n  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.subaru_a]))\n  footnotes: list[Enum] = field(default_factory=lambda: [Footnote.GLOBAL])\n\n  def init_make(self, CP: car.CarParams):\n    self.car_parts.parts.extend([Tool.socket_8mm_deep, Tool.pry_tool])\n\n    if CP.experimentalLongitudinalAvailable:\n      self.footnotes.append(Footnote.EXP_LONG)\n\n\n@dataclass\nclass SubaruPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('subaru_global_2017_generated', None))\n\n  def init(self):\n    if self.flags & SubaruFlags.HYBRID:\n      self.dbc_dict = dbc_dict('subaru_global_2020_hybrid_generated', None)\n\n\n@dataclass\nclass SubaruGen2PlatformConfig(SubaruPlatformConfig):\n  def init(self):\n    super().init()\n    self.flags |= SubaruFlags.GLOBAL_GEN2\n    if not (self.flags & SubaruFlags.LKAS_ANGLE):\n      self.flags |= SubaruFlags.STEER_RATE_LIMITED\n\n\nclass CAR(Platforms):\n  # Global platform\n  SUBARU_ASCENT = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Ascent 2019-21\", \"All\")],\n    CarSpecs(mass=2031, wheelbase=2.89, steerRatio=13.5),\n  )\n  SUBARU_OUTBACK = SubaruGen2PlatformConfig(\n    [SubaruCarDocs(\"Subaru Outback 2020-22\", \"All\", car_parts=CarParts.common([CarHarness.subaru_b]))],\n    CarSpecs(mass=1568, wheelbase=2.67, steerRatio=17),\n  )\n  SUBARU_LEGACY = SubaruGen2PlatformConfig(\n    [SubaruCarDocs(\"Subaru Legacy 2020-22\", \"All\", car_parts=CarParts.common([CarHarness.subaru_b]))],\n    SUBARU_OUTBACK.specs,\n  )\n  SUBARU_IMPREZA = SubaruPlatformConfig(\n    [\n      SubaruCarDocs(\"Subaru Impreza 2017-19\"),\n      SubaruCarDocs(\"Subaru Crosstrek 2018-19\", video_link=\"https://youtu.be/Agww7oE1k-s?t=26\"),\n      SubaruCarDocs(\"Subaru XV 2018-19\", video_link=\"https://youtu.be/Agww7oE1k-s?t=26\"),\n    ],\n    CarSpecs(mass=1568, wheelbase=2.67, steerRatio=15),\n  )\n  SUBARU_IMPREZA_2020 = SubaruPlatformConfig(\n    [\n      SubaruCarDocs(\"Subaru Impreza 2020-22\"),\n      SubaruCarDocs(\"Subaru Crosstrek 2020-23\"),\n      SubaruCarDocs(\"Subaru XV 2020-21\"),\n    ],\n    CarSpecs(mass=1480, wheelbase=2.67, steerRatio=17),\n    flags=SubaruFlags.STEER_RATE_LIMITED,\n  )\n  # TODO: is there an XV and Impreza too?\n  SUBARU_CROSSTREK_HYBRID = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Crosstrek Hybrid 2020\", car_parts=CarParts.common([CarHarness.subaru_b]))],\n    CarSpecs(mass=1668, wheelbase=2.67, steerRatio=17),\n    flags=SubaruFlags.HYBRID,\n  )\n  SUBARU_FORESTER = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Forester 2019-21\", \"All\")],\n    CarSpecs(mass=1568, wheelbase=2.67, steerRatio=17),\n    flags=SubaruFlags.STEER_RATE_LIMITED,\n  )\n  SUBARU_FORESTER_HYBRID = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Forester Hybrid 2020\")],\n    SUBARU_FORESTER.specs,\n    flags=SubaruFlags.HYBRID,\n  )\n  # Pre-global\n  SUBARU_FORESTER_PREGLOBAL = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Forester 2017-18\")],\n    CarSpecs(mass=1568, wheelbase=2.67, steerRatio=20),\n    dbc_dict('subaru_forester_2017_generated', None),\n    flags=SubaruFlags.PREGLOBAL,\n  )\n  SUBARU_LEGACY_PREGLOBAL = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Legacy 2015-18\")],\n    CarSpecs(mass=1568, wheelbase=2.67, steerRatio=12.5),\n    dbc_dict('subaru_outback_2015_generated', None),\n    flags=SubaruFlags.PREGLOBAL,\n  )\n  SUBARU_OUTBACK_PREGLOBAL = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Outback 2015-17\")],\n    SUBARU_FORESTER_PREGLOBAL.specs,\n    dbc_dict('subaru_outback_2015_generated', None),\n    flags=SubaruFlags.PREGLOBAL,\n  )\n  SUBARU_OUTBACK_PREGLOBAL_2018 = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Outback 2018-19\")],\n    SUBARU_FORESTER_PREGLOBAL.specs,\n    dbc_dict('subaru_outback_2019_generated', None),\n    flags=SubaruFlags.PREGLOBAL,\n  )\n  # Angle LKAS\n  SUBARU_FORESTER_2022 = SubaruPlatformConfig(\n    [SubaruCarDocs(\"Subaru Forester 2022-24\", \"All\", car_parts=CarParts.common([CarHarness.subaru_c]))],\n    SUBARU_FORESTER.specs,\n    flags=SubaruFlags.LKAS_ANGLE,\n  )\n  SUBARU_OUTBACK_2023 = SubaruGen2PlatformConfig(\n    [SubaruCarDocs(\"Subaru Outback 2023\", \"All\", car_parts=CarParts.common([CarHarness.subaru_d]))],\n    SUBARU_OUTBACK.specs,\n    flags=SubaruFlags.LKAS_ANGLE,\n  )\n  SUBARU_ASCENT_2023 = SubaruGen2PlatformConfig(\n    [SubaruCarDocs(\"Subaru Ascent 2023\", \"All\", car_parts=CarParts.common([CarHarness.subaru_d]))],\n    SUBARU_ASCENT.specs,\n    flags=SubaruFlags.LKAS_ANGLE,\n  )\n\n\nSUBARU_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.APPLICATION_DATA_IDENTIFICATION)\nSUBARU_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.APPLICATION_DATA_IDENTIFICATION)\n\n# The EyeSight ECU takes 10s to respond to SUBARU_VERSION_REQUEST properly,\n# log this alternate manufacturer-specific query\nSUBARU_ALT_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(0xf100)\nSUBARU_ALT_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n  p16(0xf100)\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, SUBARU_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, SUBARU_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.eps, Ecu.fwdCamera, Ecu.engine, Ecu.transmission],\n      logging=True,\n    ),\n    # Non-OBD requests\n    # Some Eyesight modules fail on TESTER_PRESENT_REQUEST\n    # TODO: check if this resolves the fingerprinting issue for the 2023 Ascent and other new Subaru cars\n    Request(\n      [SUBARU_VERSION_REQUEST],\n      [SUBARU_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.fwdCamera],\n      bus=0,\n    ),\n    Request(\n      [SUBARU_ALT_VERSION_REQUEST],\n      [SUBARU_ALT_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.fwdCamera],\n      bus=0,\n      logging=True,\n    ),\n    Request(\n      [StdQueries.DEFAULT_DIAGNOSTIC_REQUEST, StdQueries.TESTER_PRESENT_REQUEST, SUBARU_VERSION_REQUEST],\n      [StdQueries.DEFAULT_DIAGNOSTIC_RESPONSE, StdQueries.TESTER_PRESENT_RESPONSE, SUBARU_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.fwdCamera],\n      bus=0,\n      logging=True,\n    ),\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, SUBARU_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, SUBARU_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.eps, Ecu.fwdCamera, Ecu.engine, Ecu.transmission],\n      bus=0,\n    ),\n    # GEN2 powertrain bus query\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, SUBARU_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, SUBARU_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.eps, Ecu.fwdCamera, Ecu.engine, Ecu.transmission],\n      bus=1,\n      obd_multiplexing=False,\n    ),\n  ],\n  # We don't get the EPS from non-OBD queries on GEN2 cars. Note that we still attempt to match when it exists\n  non_essential_ecus={\n    Ecu.eps: list(CAR.with_flags(SubaruFlags.GLOBAL_GEN2)),\n  }\n)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/subaru/carcontroller.py": "from openpilot.common.numpy_fast import clip, interp\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car import apply_driver_steer_torque_limits, common_fault_avoidance\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.car.subaru import subarucan\nfrom openpilot.selfdrive.car.subaru.values import DBC, GLOBAL_ES_ADDR, CanBus, CarControllerParams, SubaruFlags\n\n# FIXME: These limits aren't exact. The real limit is more than likely over a larger time period and\n# involves the total steering angle change rather than rate, but these limits work well for now\nMAX_STEER_RATE = 25  # deg/s\nMAX_STEER_RATE_FRAMES = 7  # tx control frames needed before torque can be cut\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.apply_steer_last = 0\n    self.frame = 0\n\n    self.cruise_button_prev = 0\n    self.steer_rate_counter = 0\n\n    self.p = CarControllerParams(CP)\n    self.packer = CANPacker(DBC[CP.carFingerprint]['pt'])\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n    pcm_cancel_cmd = CC.cruiseControl.cancel\n\n    can_sends = []\n\n    # *** steering ***\n    if (self.frame % self.p.STEER_STEP) == 0:\n      apply_steer = int(round(actuators.steer * self.p.STEER_MAX))\n\n      # limits due to driver torque\n\n      new_steer = int(round(apply_steer))\n      apply_steer = apply_driver_steer_torque_limits(new_steer, self.apply_steer_last, CS.out.steeringTorque, self.p)\n\n      if not CC.latActive:\n        apply_steer = 0\n\n      if self.CP.flags & SubaruFlags.PREGLOBAL:\n        can_sends.append(subarucan.create_preglobal_steering_control(self.packer, self.frame // self.p.STEER_STEP, apply_steer, CC.latActive))\n      else:\n        apply_steer_req = CC.latActive\n\n        if self.CP.flags & SubaruFlags.STEER_RATE_LIMITED:\n          # Steering rate fault prevention\n          self.steer_rate_counter, apply_steer_req = \\\n            common_fault_avoidance(abs(CS.out.steeringRateDeg) > MAX_STEER_RATE, apply_steer_req,\n                                  self.steer_rate_counter, MAX_STEER_RATE_FRAMES)\n\n        can_sends.append(subarucan.create_steering_control(self.packer, apply_steer, apply_steer_req))\n\n      self.apply_steer_last = apply_steer\n\n    # *** longitudinal ***\n\n    if CC.longActive:\n      apply_throttle = int(round(interp(actuators.accel, CarControllerParams.THROTTLE_LOOKUP_BP, CarControllerParams.THROTTLE_LOOKUP_V)))\n      apply_rpm = int(round(interp(actuators.accel, CarControllerParams.RPM_LOOKUP_BP, CarControllerParams.RPM_LOOKUP_V)))\n      apply_brake = int(round(interp(actuators.accel, CarControllerParams.BRAKE_LOOKUP_BP, CarControllerParams.BRAKE_LOOKUP_V)))\n\n      # limit min and max values\n      cruise_throttle = clip(apply_throttle, CarControllerParams.THROTTLE_MIN, CarControllerParams.THROTTLE_MAX)\n      cruise_rpm = clip(apply_rpm, CarControllerParams.RPM_MIN, CarControllerParams.RPM_MAX)\n      cruise_brake = clip(apply_brake, CarControllerParams.BRAKE_MIN, CarControllerParams.BRAKE_MAX)\n    else:\n      cruise_throttle = CarControllerParams.THROTTLE_INACTIVE\n      cruise_rpm = CarControllerParams.RPM_MIN\n      cruise_brake = CarControllerParams.BRAKE_MIN\n\n    # *** alerts and pcm cancel ***\n    if self.CP.flags & SubaruFlags.PREGLOBAL:\n      if self.frame % 5 == 0:\n        # 1 = main, 2 = set shallow, 3 = set deep, 4 = resume shallow, 5 = resume deep\n        # disengage ACC when OP is disengaged\n        if pcm_cancel_cmd:\n          cruise_button = 1\n        # turn main on if off and past start-up state\n        elif not CS.out.cruiseState.available and CS.ready:\n          cruise_button = 1\n        else:\n          cruise_button = CS.cruise_button\n\n        # unstick previous mocked button press\n        if cruise_button == 1 and self.cruise_button_prev == 1:\n          cruise_button = 0\n        self.cruise_button_prev = cruise_button\n\n        can_sends.append(subarucan.create_preglobal_es_distance(self.packer, cruise_button, CS.es_distance_msg))\n\n    else:\n      if self.frame % 10 == 0:\n        can_sends.append(subarucan.create_es_dashstatus(self.packer, self.frame // 10, CS.es_dashstatus_msg, CC.enabled,\n                                                        self.CP.openpilotLongitudinalControl, CC.longActive, hud_control.leadVisible))\n\n        can_sends.append(subarucan.create_es_lkas_state(self.packer, self.frame // 10, CS.es_lkas_state_msg, CC.enabled, hud_control.visualAlert,\n                                                        hud_control.leftLaneVisible, hud_control.rightLaneVisible,\n                                                        hud_control.leftLaneDepart, hud_control.rightLaneDepart))\n\n        if self.CP.flags & SubaruFlags.SEND_INFOTAINMENT:\n          can_sends.append(subarucan.create_es_infotainment(self.packer, self.frame // 10, CS.es_infotainment_msg, hud_control.visualAlert))\n\n      if self.CP.openpilotLongitudinalControl:\n        if self.frame % 5 == 0:\n          can_sends.append(subarucan.create_es_status(self.packer, self.frame // 5, CS.es_status_msg,\n                                                      self.CP.openpilotLongitudinalControl, CC.longActive, cruise_rpm))\n\n          can_sends.append(subarucan.create_es_brake(self.packer, self.frame // 5, CS.es_brake_msg,\n                                                     self.CP.openpilotLongitudinalControl, CC.longActive, cruise_brake))\n\n          can_sends.append(subarucan.create_es_distance(self.packer, self.frame // 5, CS.es_distance_msg, 0, pcm_cancel_cmd,\n                                                        self.CP.openpilotLongitudinalControl, cruise_brake > 0, cruise_throttle))\n      else:\n        if pcm_cancel_cmd:\n          if not (self.CP.flags & SubaruFlags.HYBRID):\n            bus = CanBus.alt if self.CP.flags & SubaruFlags.GLOBAL_GEN2 else CanBus.main\n            can_sends.append(subarucan.create_es_distance(self.packer, CS.es_distance_msg[\"COUNTER\"] + 1, CS.es_distance_msg, bus, pcm_cancel_cmd))\n\n      if self.CP.flags & SubaruFlags.DISABLE_EYESIGHT:\n        # Tester present (keeps eyesight disabled)\n        if self.frame % 100 == 0:\n          can_sends.append([GLOBAL_ES_ADDR, 0, b\"\\x02\\x3E\\x80\\x00\\x00\\x00\\x00\\x00\", CanBus.camera])\n\n        # Create all of the other eyesight messages to keep the rest of the car happy when eyesight is disabled\n        if self.frame % 5 == 0:\n          can_sends.append(subarucan.create_es_highbeamassist(self.packer))\n\n        if self.frame % 10 == 0:\n          can_sends.append(subarucan.create_es_static_1(self.packer))\n\n        if self.frame % 2 == 0:\n          can_sends.append(subarucan.create_es_static_2(self.packer))\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steer = self.apply_steer_last / self.p.STEER_MAX\n    new_actuators.steerOutputCan = self.apply_steer_last\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/subaru/radar_interface.py": "from openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nclass RadarInterface(RadarInterfaceBase):\n  pass\n", "selfdrive/car/subaru/__init__.py": "", "selfdrive/car/subaru/interface.py": "from cereal import car\nfrom panda import Panda\nfrom openpilot.selfdrive.car import get_safety_config\nfrom openpilot.selfdrive.car.disable_ecu import disable_ecu\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.car.subaru.values import CAR, GLOBAL_ES_ADDR, SubaruFlags\n\n\nclass CarInterface(CarInterfaceBase):\n\n  @staticmethod\n  def _get_params(ret, candidate: CAR, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"subaru\"\n    ret.radarUnavailable = True\n    # for HYBRID CARS to be upstreamed, we need:\n    # - replacement for ES_Distance so we can cancel the cruise control\n    # - to find the Cruise_Activated bit from the car\n    # - proper panda safety setup (use the correct cruise_activated bit, throttle from Throttle_Hybrid, etc)\n    ret.dashcamOnly = bool(ret.flags & (SubaruFlags.PREGLOBAL | SubaruFlags.LKAS_ANGLE | SubaruFlags.HYBRID))\n    ret.autoResumeSng = False\n\n    # Detect infotainment message sent from the camera\n    if not (ret.flags & SubaruFlags.PREGLOBAL) and 0x323 in fingerprint[2]:\n      ret.flags |= SubaruFlags.SEND_INFOTAINMENT.value\n\n    if ret.flags & SubaruFlags.PREGLOBAL:\n      ret.enableBsm = 0x25c in fingerprint[0]\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.subaruPreglobal)]\n    else:\n      ret.enableBsm = 0x228 in fingerprint[0]\n      ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.subaru)]\n      if ret.flags & SubaruFlags.GLOBAL_GEN2:\n        ret.safetyConfigs[0].safetyParam |= Panda.FLAG_SUBARU_GEN2\n\n    ret.steerLimitTimer = 0.4\n    ret.steerActuatorDelay = 0.1\n\n    if ret.flags & SubaruFlags.LKAS_ANGLE:\n      ret.steerControlType = car.CarParams.SteerControlType.angle\n    else:\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n    if candidate in (CAR.SUBARU_ASCENT, CAR.SUBARU_ASCENT_2023):\n      ret.steerActuatorDelay = 0.3  # end-to-end angle controller\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kf = 0.00003\n      ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[0., 20.], [0., 20.]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.0025, 0.1], [0.00025, 0.01]]\n\n    elif candidate == CAR.SUBARU_IMPREZA:\n      ret.steerActuatorDelay = 0.4  # end-to-end angle controller\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kf = 0.00005\n      ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[0., 20.], [0., 20.]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.2, 0.3], [0.02, 0.03]]\n\n    elif candidate == CAR.SUBARU_IMPREZA_2020:\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kf = 0.00005\n      ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[0., 14., 23.], [0., 14., 23.]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.045, 0.042, 0.20], [0.04, 0.035, 0.045]]\n\n    elif candidate == CAR.SUBARU_CROSSTREK_HYBRID:\n      ret.steerActuatorDelay = 0.1\n\n    elif candidate in (CAR.SUBARU_FORESTER, CAR.SUBARU_FORESTER_2022, CAR.SUBARU_FORESTER_HYBRID):\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kf = 0.000038\n      ret.lateralTuning.pid.kiBP, ret.lateralTuning.pid.kpBP = [[0., 14., 23.], [0., 14., 23.]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.01, 0.065, 0.2], [0.001, 0.015, 0.025]]\n\n    elif candidate in (CAR.SUBARU_OUTBACK, CAR.SUBARU_LEGACY, CAR.SUBARU_OUTBACK_2023):\n      ret.steerActuatorDelay = 0.1\n\n    elif candidate in (CAR.SUBARU_FORESTER_PREGLOBAL, CAR.SUBARU_OUTBACK_PREGLOBAL_2018):\n      ret.safetyConfigs[0].safetyParam = Panda.FLAG_SUBARU_PREGLOBAL_REVERSED_DRIVER_TORQUE  # Outback 2018-2019 and Forester have reversed driver torque signal\n\n    elif candidate == CAR.SUBARU_LEGACY_PREGLOBAL:\n      ret.steerActuatorDelay = 0.15\n\n    elif candidate == CAR.SUBARU_OUTBACK_PREGLOBAL:\n      pass\n    else:\n      raise ValueError(f\"unknown car: {candidate}\")\n\n    ret.experimentalLongitudinalAvailable = not (ret.flags & (SubaruFlags.GLOBAL_GEN2 | SubaruFlags.PREGLOBAL |\n                                                              SubaruFlags.LKAS_ANGLE | SubaruFlags.HYBRID))\n    ret.openpilotLongitudinalControl = experimental_long and ret.experimentalLongitudinalAvailable\n\n    if ret.flags & SubaruFlags.GLOBAL_GEN2 and ret.openpilotLongitudinalControl:\n      ret.flags |= SubaruFlags.DISABLE_EYESIGHT.value\n\n    if ret.openpilotLongitudinalControl:\n      ret.stoppingControl = True\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_SUBARU_LONG\n\n    return ret\n\n  # returns a car.CarState\n  def _update(self, c):\n\n    ret = self.CS.update(self.cp, self.cp_cam, self.cp_body)\n\n    ret.events = self.create_common_events(ret).to_msg()\n\n    return ret\n\n  @staticmethod\n  def init(CP, logcan, sendcan):\n    if CP.flags & SubaruFlags.DISABLE_EYESIGHT:\n      disable_ecu(logcan, sendcan, bus=2, addr=GLOBAL_ES_ADDR, com_cont_req=b'\\x28\\x03\\x01')\n", "selfdrive/car/nissan/carstate.py": "import copy\nfrom collections import deque\nfrom cereal import car\nfrom opendbc.can.can_define import CANDefine\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom openpilot.common.conversions import Conversions as CV\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.nissan.values import CAR, DBC, CarControllerParams\n\nTORQUE_SAMPLES = 12\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n\n    self.lkas_hud_msg = {}\n    self.lkas_hud_info_msg = {}\n\n    self.steeringTorqueSamples = deque(TORQUE_SAMPLES*[0], TORQUE_SAMPLES)\n    self.shifter_values = can_define.dv[\"GEARBOX\"][\"GEAR_SHIFTER\"]\n\n    self.prev_distance_button = 0\n    self.distance_button = 0\n\n  def update(self, cp, cp_adas, cp_cam):\n    ret = car.CarState.new_message()\n\n    self.prev_distance_button = self.distance_button\n    self.distance_button = cp.vl[\"CRUISE_THROTTLE\"][\"FOLLOW_DISTANCE_BUTTON\"]\n\n    if self.CP.carFingerprint in (CAR.NISSAN_ROGUE, CAR.NISSAN_XTRAIL, CAR.NISSAN_ALTIMA):\n      ret.gas = cp.vl[\"GAS_PEDAL\"][\"GAS_PEDAL\"]\n    elif self.CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC):\n      ret.gas = cp.vl[\"CRUISE_THROTTLE\"][\"GAS_PEDAL\"]\n\n    ret.gasPressed = bool(ret.gas > 3)\n\n    if self.CP.carFingerprint in (CAR.NISSAN_ROGUE, CAR.NISSAN_XTRAIL, CAR.NISSAN_ALTIMA):\n      ret.brakePressed = bool(cp.vl[\"DOORS_LIGHTS\"][\"USER_BRAKE_PRESSED\"])\n    elif self.CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC):\n      ret.brakePressed = bool(cp.vl[\"CRUISE_THROTTLE\"][\"USER_BRAKE_PRESSED\"])\n\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"WHEEL_SPEEDS_FRONT\"][\"WHEEL_SPEED_FL\"],\n      cp.vl[\"WHEEL_SPEEDS_FRONT\"][\"WHEEL_SPEED_FR\"],\n      cp.vl[\"WHEEL_SPEEDS_REAR\"][\"WHEEL_SPEED_RL\"],\n      cp.vl[\"WHEEL_SPEEDS_REAR\"][\"WHEEL_SPEED_RR\"],\n    )\n    ret.vEgoRaw = (ret.wheelSpeeds.fl + ret.wheelSpeeds.fr + ret.wheelSpeeds.rl + ret.wheelSpeeds.rr) / 4.\n\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = cp.vl[\"WHEEL_SPEEDS_REAR\"][\"WHEEL_SPEED_RL\"] == 0.0 and cp.vl[\"WHEEL_SPEEDS_REAR\"][\"WHEEL_SPEED_RR\"] == 0.0\n\n    if self.CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      ret.cruiseState.enabled = bool(cp.vl[\"CRUISE_STATE\"][\"CRUISE_ENABLED\"])\n    else:\n      ret.cruiseState.enabled = bool(cp_adas.vl[\"CRUISE_STATE\"][\"CRUISE_ENABLED\"])\n\n    if self.CP.carFingerprint in (CAR.NISSAN_ROGUE, CAR.NISSAN_XTRAIL):\n      ret.seatbeltUnlatched = cp.vl[\"HUD\"][\"SEATBELT_DRIVER_LATCHED\"] == 0\n      ret.cruiseState.available = bool(cp_cam.vl[\"PRO_PILOT\"][\"CRUISE_ON\"])\n    elif self.CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC):\n      if self.CP.carFingerprint == CAR.NISSAN_LEAF:\n        ret.seatbeltUnlatched = cp.vl[\"SEATBELT\"][\"SEATBELT_DRIVER_LATCHED\"] == 0\n      elif self.CP.carFingerprint == CAR.NISSAN_LEAF_IC:\n        ret.seatbeltUnlatched = cp.vl[\"CANCEL_MSG\"][\"CANCEL_SEATBELT\"] == 1\n      ret.cruiseState.available = bool(cp.vl[\"CRUISE_THROTTLE\"][\"CRUISE_AVAILABLE\"])\n    elif self.CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      ret.seatbeltUnlatched = cp.vl[\"HUD\"][\"SEATBELT_DRIVER_LATCHED\"] == 0\n      ret.cruiseState.available = bool(cp_adas.vl[\"PRO_PILOT\"][\"CRUISE_ON\"])\n\n    if self.CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      speed = cp.vl[\"PROPILOT_HUD\"][\"SET_SPEED\"]\n    else:\n      speed = cp_adas.vl[\"PROPILOT_HUD\"][\"SET_SPEED\"]\n\n    if speed != 255:\n      if self.CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC):\n        conversion = CV.MPH_TO_MS if cp.vl[\"HUD_SETTINGS\"][\"SPEED_MPH\"] else CV.KPH_TO_MS\n      else:\n        conversion = CV.MPH_TO_MS if cp.vl[\"HUD\"][\"SPEED_MPH\"] else CV.KPH_TO_MS\n      ret.cruiseState.speed = speed * conversion\n      ret.cruiseState.speedCluster = (speed - 1) * conversion  # Speed on HUD is always 1 lower than actually sent on can bus\n\n    if self.CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      ret.steeringTorque = cp_cam.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_TORQUE_DRIVER\"]\n    else:\n      ret.steeringTorque = cp.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_TORQUE_DRIVER\"]\n\n    self.steeringTorqueSamples.append(ret.steeringTorque)\n    # Filtering driver torque to prevent steeringPressed false positives\n    ret.steeringPressed = bool(abs(sum(self.steeringTorqueSamples) / TORQUE_SAMPLES) > CarControllerParams.STEER_THRESHOLD)\n\n    ret.steeringAngleDeg = cp.vl[\"STEER_ANGLE_SENSOR\"][\"STEER_ANGLE\"]\n\n    ret.leftBlinker = bool(cp.vl[\"LIGHTS\"][\"LEFT_BLINKER\"])\n    ret.rightBlinker = bool(cp.vl[\"LIGHTS\"][\"RIGHT_BLINKER\"])\n\n    ret.doorOpen = any([cp.vl[\"DOORS_LIGHTS\"][\"DOOR_OPEN_RR\"],\n                        cp.vl[\"DOORS_LIGHTS\"][\"DOOR_OPEN_RL\"],\n                        cp.vl[\"DOORS_LIGHTS\"][\"DOOR_OPEN_FR\"],\n                        cp.vl[\"DOORS_LIGHTS\"][\"DOOR_OPEN_FL\"]])\n\n    ret.espDisabled = bool(cp.vl[\"ESP\"][\"ESP_DISABLED\"])\n\n    can_gear = int(cp.vl[\"GEARBOX\"][\"GEAR_SHIFTER\"])\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(can_gear, None))\n\n    if self.CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      self.lkas_enabled = bool(cp.vl[\"LKAS_SETTINGS\"][\"LKAS_ENABLED\"])\n    else:\n      self.lkas_enabled = bool(cp_adas.vl[\"LKAS_SETTINGS\"][\"LKAS_ENABLED\"])\n\n    self.cruise_throttle_msg = copy.copy(cp.vl[\"CRUISE_THROTTLE\"])\n\n    if self.CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC):\n      self.cancel_msg = copy.copy(cp.vl[\"CANCEL_MSG\"])\n\n    if self.CP.carFingerprint != CAR.NISSAN_ALTIMA:\n      self.lkas_hud_msg = copy.copy(cp_adas.vl[\"PROPILOT_HUD\"])\n      self.lkas_hud_info_msg = copy.copy(cp_adas.vl[\"PROPILOT_HUD_INFO_MSG\"])\n\n    return ret\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"STEER_ANGLE_SENSOR\", 100),\n      (\"WHEEL_SPEEDS_REAR\", 50),\n      (\"WHEEL_SPEEDS_FRONT\", 50),\n      (\"ESP\", 25),\n      (\"GEARBOX\", 25),\n      (\"DOORS_LIGHTS\", 10),\n      (\"LIGHTS\", 10),\n    ]\n\n    if CP.carFingerprint in (CAR.NISSAN_ROGUE, CAR.NISSAN_XTRAIL, CAR.NISSAN_ALTIMA):\n      messages += [\n        (\"GAS_PEDAL\", 100),\n        (\"CRUISE_THROTTLE\", 50),\n        (\"HUD\", 25),\n      ]\n\n    elif CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC):\n      messages += [\n        (\"BRAKE_PEDAL\", 100),\n        (\"CRUISE_THROTTLE\", 50),\n        (\"CANCEL_MSG\", 50),\n        (\"HUD_SETTINGS\", 25),\n        (\"SEATBELT\", 10),\n      ]\n\n    if CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      messages += [\n        (\"CRUISE_STATE\", 10),\n        (\"LKAS_SETTINGS\", 10),\n        (\"PROPILOT_HUD\", 50),\n      ]\n      return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 1)\n\n    messages.append((\"STEER_TORQUE_SENSOR\", 100))\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n\n  @staticmethod\n  def get_adas_can_parser(CP):\n    # this function generates lists for signal, messages and initial values\n\n    if CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      messages = [\n        (\"LKAS\", 100),\n        (\"PRO_PILOT\", 100),\n      ]\n    else:\n      messages = [\n        (\"PROPILOT_HUD_INFO_MSG\", 2),\n        (\"LKAS_SETTINGS\", 10),\n        (\"CRUISE_STATE\", 50),\n        (\"PROPILOT_HUD\", 50),\n        (\"LKAS\", 100),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 2)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = []\n\n    if CP.carFingerprint in (CAR.NISSAN_ROGUE, CAR.NISSAN_XTRAIL):\n      messages.append((\"PRO_PILOT\", 100))\n    elif CP.carFingerprint == CAR.NISSAN_ALTIMA:\n      messages.append((\"STEER_TORQUE_SENSOR\", 100))\n      return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 1)\n", "selfdrive/car/nissan/fingerprints.py": "# ruff: noqa: E501\nfrom cereal import car\nfrom openpilot.selfdrive.car.nissan.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFINGERPRINTS = {\n  CAR.NISSAN_XTRAIL: [{\n    2: 5, 42: 6, 346: 6, 347: 5, 348: 8, 349: 7, 361: 8, 386: 8, 389: 8, 397: 8, 398: 8, 403: 8, 520: 2, 523: 6, 548: 8, 645: 8, 658: 8, 665: 8, 666: 8, 674: 2, 682: 8, 683: 8, 689: 8, 723: 8, 758: 3, 768: 2, 783: 3, 851: 8, 855: 8, 1041: 8, 1055: 2, 1104: 4, 1105: 6, 1107: 4, 1108: 8, 1111: 4, 1227: 8, 1228: 8, 1247: 4, 1266: 8, 1273: 7, 1342: 1, 1376: 6, 1401: 8, 1474: 2, 1497: 3, 1821: 8, 1823: 8, 1837: 8, 2015: 8, 2016: 8, 2024: 8\n  },\n  {\n    2: 5, 42: 6, 346: 6, 347: 5, 348: 8, 349: 7, 361: 8, 386: 8, 389: 8, 397: 8, 398: 8, 403: 8, 520: 2, 523: 6, 527: 1, 548: 8, 637: 4, 645: 8, 658: 8, 665: 8, 666: 8, 674: 2, 682: 8, 683: 8, 689: 8, 723: 8, 758: 3, 768: 6, 783: 3, 851: 8, 855: 8, 1041: 8, 1055: 2, 1104: 4, 1105: 6, 1107: 4, 1108: 8, 1111: 4, 1227: 8, 1228: 8, 1247: 4, 1266: 8, 1273: 7, 1342: 1, 1376: 6, 1401: 8, 1474: 8, 1497: 3, 1534: 6, 1792: 8, 1821: 8, 1823: 8, 1837: 8, 1872: 8, 1937: 8, 1953: 8, 1968: 8, 2015: 8, 2016: 8, 2024: 8\n  }],\n  CAR.NISSAN_LEAF: [{\n    2: 5, 42: 6, 264: 3, 361: 8, 372: 8, 384: 8, 389: 8, 403: 8, 459: 7, 460: 4, 470: 8, 520: 1, 569: 8, 581: 8, 634: 7, 640: 8, 644: 8, 645: 8, 646: 5, 658: 8, 682: 8, 683: 8, 689: 8, 724: 6, 758: 3, 761: 2, 783: 3, 852: 8, 853: 8, 856: 8, 861: 8, 944: 1, 976: 6, 1008: 7, 1011: 7, 1057: 3, 1227: 8, 1228: 8, 1261: 5, 1342: 1, 1354: 8, 1361: 8, 1459: 8, 1477: 8, 1497: 3, 1549: 8, 1573: 6, 1821: 8, 1837: 8, 1856: 8, 1859: 8, 1861: 8, 1864: 8, 1874: 8, 1888: 8, 1891: 8, 1893: 8, 1906: 8, 1947: 8, 1949: 8, 1979: 8, 1981: 8, 2016: 8, 2017: 8, 2021: 8, 643: 5, 1792: 8, 1872: 8, 1937: 8, 1953: 8, 1968: 8, 1988: 8, 2000: 8, 2001: 8, 2004: 8, 2005: 8, 2015: 8\n  },\n  {\n    2: 5, 42: 8, 264: 3, 361: 8, 372: 8, 384: 8, 389: 8, 403: 8, 459: 7, 460: 4, 470: 8, 520: 1, 569: 8, 581: 8, 634: 7, 640: 8, 643: 5, 644: 8, 645: 8, 646: 5, 658: 8, 682: 8, 683: 8, 689: 8, 724: 6, 758: 3, 761: 2, 772: 8, 773: 6, 774: 7, 775: 8, 776: 6, 777: 7, 778: 6, 783: 3, 852: 8, 853: 8, 856: 8, 861: 8, 943: 8, 944: 1, 976: 6, 1008: 7, 1009: 8, 1010: 8, 1011: 7, 1012: 8, 1013: 8, 1019: 8, 1020: 8, 1021: 8, 1022: 8, 1057: 3, 1227: 8, 1228: 8, 1261: 5, 1342: 1, 1354: 8, 1361: 8, 1402: 8, 1459: 8, 1477: 8, 1497: 3, 1549: 8, 1573: 6, 1821: 8, 1837: 8\n  }],\n  CAR.NISSAN_LEAF_IC: [{\n    2: 5, 42: 6, 264: 3, 282: 8, 361: 8, 372: 8, 384: 8, 389: 8, 403: 8, 459: 7, 460: 4, 470: 8, 520: 1, 569: 8, 581: 8, 634: 7, 640: 8, 643: 5, 644: 8, 645: 8, 646: 5, 658: 8, 682: 8, 683: 8, 689: 8, 756: 5, 758: 3, 761: 2, 783: 3, 830: 2, 852: 8, 853: 8, 856: 8, 861: 8, 943: 8, 944: 1, 1001: 6, 1057: 3, 1227: 8, 1228: 8, 1229: 8, 1342: 1, 1354: 8, 1361: 8, 1459: 8, 1477: 8, 1497: 3, 1514: 6, 1549: 8, 1573: 6, 1792: 8, 1821: 8, 1822: 8, 1837: 8, 1838: 8, 1872: 8, 1937: 8, 1953: 8, 1968: 8, 1988: 8, 2000: 8, 2001: 8, 2004: 8, 2005: 8, 2015: 8, 2016: 8, 2017: 8\n  }],\n  CAR.NISSAN_ROGUE: [{\n    2: 5, 42: 6, 346: 6, 347: 5, 348: 8, 349: 7, 361: 8, 386: 8, 389: 8, 397: 8, 398: 8, 403: 8, 520: 2, 523: 6, 548: 8, 634: 7, 643: 5, 645: 8, 658: 8, 665: 8, 666: 8, 674: 2, 682: 8, 683: 8, 689: 8, 723: 8, 758: 3, 772: 8, 773: 6, 774: 7, 775: 8, 776: 6, 777: 7, 778: 6, 783: 3, 851: 8, 855: 8, 1041: 8, 1042: 8, 1055: 2, 1104: 4, 1105: 6, 1107: 4, 1108: 8, 1110: 7, 1111: 7, 1227: 8, 1228: 8, 1247: 4, 1266: 8, 1273: 7, 1342: 1, 1376: 6, 1401: 8, 1474: 2, 1497: 3, 1534: 7, 1792: 8, 1821: 8, 1823: 8, 1837: 8, 1839: 8, 1872: 8, 1937: 8, 1953: 8, 1968: 8, 1988: 8, 2000: 8, 2001: 8, 2004: 8, 2005: 8, 2015: 8, 2016: 8, 2017: 8, 2024: 8, 2025: 8\n  }],\n  CAR.NISSAN_ALTIMA: [{\n    2: 5, 42: 6, 346: 6, 347: 5, 348: 8, 349: 7, 361: 8, 386: 8, 389: 8, 397: 8, 398: 8, 403: 8, 438: 8, 451: 8, 517: 8, 520: 2, 522: 8, 523: 6, 539: 8, 541: 7, 542: 8, 543: 8, 544: 8, 545: 8, 546: 8, 547: 8, 548: 8, 570: 8, 576: 8, 577: 8, 582: 8, 583: 8, 584: 8, 586: 8, 587: 8, 588: 8, 589: 8, 590: 8, 591: 8, 592: 8, 600: 8, 601: 8, 610: 8, 611: 8, 612: 8, 614: 8, 615: 8, 616: 8, 617: 8, 622: 8, 623: 8, 634: 7, 638: 8, 645: 8, 648: 5, 654: 6, 658: 8, 659: 8, 660: 8, 661: 8, 665: 8, 666: 8, 674: 2, 675: 8, 676: 8, 682: 8, 683: 8, 684: 8, 685: 8, 686: 8, 687: 8, 689: 8, 690: 8, 703: 8, 708: 7, 709: 7, 711: 7, 712: 7, 713: 7, 714: 8, 715: 8, 716: 8, 717: 7, 718: 7, 719: 7, 720: 7, 723: 8, 726: 7, 727: 7, 728: 7, 735: 8, 746: 8, 748: 6, 749: 6, 750: 8, 758: 3, 772: 8, 773: 6, 774: 7, 775: 8, 776: 6, 777: 7, 778: 6, 779: 7, 781: 7, 782: 7, 783: 3, 851: 8, 855: 5, 1001: 6, 1041: 8, 1042: 8, 1055: 3, 1100: 7, 1104: 4, 1105: 6, 1107: 4, 1108: 8, 1110: 7, 1111: 7, 1144: 7, 1145: 7, 1227: 8, 1228: 8, 1229: 8, 1232: 8, 1247: 4, 1258: 8, 1259: 8, 1266: 8, 1273: 7, 1306: 1, 1314: 8, 1323: 8, 1324: 8, 1342: 1, 1376: 8, 1401: 8, 1454: 8, 1497: 3, 1514: 6, 1526: 8, 1527: 5, 1792: 8, 1821: 8, 1823: 8, 1837: 8, 1872: 8, 1937: 8, 1953: 8, 1968: 8, 1988: 8, 2000: 8, 2001: 8, 2004: 8, 2005: 8, 2015: 8, 2016: 8, 2017: 8, 2024: 8, 2025: 8\n  }],\n}\n\nFW_VERSIONS = {\n  CAR.NISSAN_ALTIMA: {\n    (Ecu.fwdCamera, 0x707, None): [\n      b'284N86CA1D',\n    ],\n    (Ecu.eps, 0x742, None): [\n      b'6CA2B\\xa9A\\x02\\x02G8A89P90D6A\\x00\\x00\\x01\\x80',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'237109HE2B',\n    ],\n    (Ecu.gateway, 0x18dad0f1, None): [\n      b'284U29HE0A',\n    ],\n  },\n  CAR.NISSAN_LEAF: {\n    (Ecu.abs, 0x740, None): [\n      b'476605SA1C',\n      b'476605SA7D',\n      b'476605SC2D',\n      b'476606WK7B',\n      b'476606WK9B',\n    ],\n    (Ecu.eps, 0x742, None): [\n      b'5SA2A\\x99A\\x05\\x02N123F\\x15b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'5SA2A\\xb7A\\x05\\x02N123F\\x15\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'5SN2A\\xb7A\\x05\\x02N123F\\x15\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'5SN2A\\xb7A\\x05\\x02N126F\\x15\\xb2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.fwdCamera, 0x707, None): [\n      b'5SA0ADB\\x04\\x18\\x00\\x00\\x00\\x00\\x00_*6\\x04\\x94a\\x00\\x00\\x00\\x80',\n      b'5SA2ADB\\x04\\x18\\x00\\x00\\x00\\x00\\x00_*6\\x04\\x94a\\x00\\x00\\x00\\x80',\n      b'6WK2ADB\\x04\\x18\\x00\\x00\\x00\\x00\\x00R;1\\x18\\x99\\x10\\x00\\x00\\x00\\x80',\n      b'6WK2BDB\\x04\\x18\\x00\\x00\\x00\\x00\\x00R;1\\x18\\x99\\x10\\x00\\x00\\x00\\x80',\n      b'6WK2CDB\\x04\\x18\\x00\\x00\\x00\\x00\\x00R=1\\x18\\x99\\x10\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.gateway, 0x18dad0f1, None): [\n      b'284U25SA3C',\n      b'284U25SP0C',\n      b'284U25SP1C',\n      b'284U26WK0A',\n      b'284U26WK0C',\n    ],\n  },\n  CAR.NISSAN_LEAF_IC: {\n    (Ecu.fwdCamera, 0x707, None): [\n      b'5SH1BDB\\x04\\x18\\x00\\x00\\x00\\x00\\x00_-?\\x04\\x91\\xf2\\x00\\x00\\x00\\x80',\n      b'5SH4BDB\\x04\\x18\\x00\\x00\\x00\\x00\\x00_-?\\x04\\x91\\xf2\\x00\\x00\\x00\\x80',\n      b'5SK0ADB\\x04\\x18\\x00\\x00\\x00\\x00\\x00_(5\\x07\\x9aQ\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.abs, 0x740, None): [\n      b'476605SD2E',\n      b'476605SH1D',\n      b'476605SK2A',\n    ],\n    (Ecu.eps, 0x742, None): [\n      b'5SH2A\\x99A\\x05\\x02N123F\\x15\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'5SH2C\\xb7A\\x05\\x02N123F\\x15\\xa3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'5SK3A\\x99A\\x05\\x02N123F\\x15u\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.gateway, 0x18dad0f1, None): [\n      b'284U25SF0C',\n      b'284U25SH3A',\n      b'284U25SK2D',\n    ],\n  },\n  CAR.NISSAN_XTRAIL: {\n    (Ecu.fwdCamera, 0x707, None): [\n      b'284N86FR2A',\n    ],\n    (Ecu.abs, 0x740, None): [\n      b'6FU0AD\\x11\\x02\\x00\\x02e\\x95e\\x80iQ#\\x01\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'6FU1BD\\x11\\x02\\x00\\x02e\\x95e\\x80iX#\\x01\\x00\\x00\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.eps, 0x742, None): [\n      b'6FP2A\\x99A\\x05\\x02N123F\\x18\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.combinationMeter, 0x743, None): [\n      b'6FR2A\\x18B\\x05\\x17\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'6FR9A\\xa0A\\x06\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n      b'6FU9B\\xa0A\\x06\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80',\n    ],\n    (Ecu.gateway, 0x18dad0f1, None): [\n      b'284U26FR0E',\n    ],\n  },\n}\n", "selfdrive/car/nissan/values.py": "from dataclasses import dataclass, field\n\nfrom cereal import car\nfrom panda.python import uds\nfrom openpilot.selfdrive.car import AngleRateLimit, CarSpecs, DbcDict, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarDocs, CarHarness, CarParts\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries\n\nEcu = car.CarParams.Ecu\n\n\nclass CarControllerParams:\n  ANGLE_RATE_LIMIT_UP = AngleRateLimit(speed_bp=[0., 5., 15.], angle_v=[5., .8, .15])\n  ANGLE_RATE_LIMIT_DOWN = AngleRateLimit(speed_bp=[0., 5., 15.], angle_v=[5., 3.5, 0.4])\n  LKAS_MAX_TORQUE = 1               # A value of 1 is easy to overpower\n  STEER_THRESHOLD = 1.0\n\n  def __init__(self, CP):\n    pass\n\n\n@dataclass\nclass NissanCarDocs(CarDocs):\n  package: str = \"ProPILOT Assist\"\n  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.nissan_a]))\n\n\n@dataclass(frozen=True)\nclass NissanCarSpecs(CarSpecs):\n  centerToFrontRatio: float = 0.44\n  steerRatio: float = 17.\n\n\n@dataclass\nclass NissanPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('nissan_x_trail_2017_generated', None))\n\n\nclass CAR(Platforms):\n  NISSAN_XTRAIL = NissanPlatformConfig(\n    [NissanCarDocs(\"Nissan X-Trail 2017\")],\n    NissanCarSpecs(mass=1610, wheelbase=2.705)\n  )\n  NISSAN_LEAF = NissanPlatformConfig(\n    [NissanCarDocs(\"Nissan Leaf 2018-23\", video_link=\"https://youtu.be/vaMbtAh_0cY\")],\n    NissanCarSpecs(mass=1610, wheelbase=2.705),\n    dbc_dict('nissan_leaf_2018_generated', None),\n  )\n  # Leaf with ADAS ECU found behind instrument cluster instead of glovebox\n  # Currently the only known difference between them is the inverted seatbelt signal.\n  NISSAN_LEAF_IC = NISSAN_LEAF.override(car_docs=[])\n  NISSAN_ROGUE = NissanPlatformConfig(\n    [NissanCarDocs(\"Nissan Rogue 2018-20\")],\n    NissanCarSpecs(mass=1610, wheelbase=2.705)\n  )\n  NISSAN_ALTIMA = NissanPlatformConfig(\n    [NissanCarDocs(\"Nissan Altima 2019-20\", car_parts=CarParts.common([CarHarness.nissan_b]))],\n    NissanCarSpecs(mass=1492, wheelbase=2.824)\n  )\n\n\nDBC = CAR.create_dbc_map()\n\n# Default diagnostic session\nNISSAN_DIAGNOSTIC_REQUEST_KWP = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL, 0x81])\nNISSAN_DIAGNOSTIC_RESPONSE_KWP = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL + 0x40, 0x81])\n\n# Manufacturer specific\nNISSAN_DIAGNOSTIC_REQUEST_KWP_2 = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL, 0xda])\nNISSAN_DIAGNOSTIC_RESPONSE_KWP_2 = bytes([uds.SERVICE_TYPE.DIAGNOSTIC_SESSION_CONTROL + 0x40, 0xda])\n\nNISSAN_VERSION_REQUEST_KWP = b'\\x21\\x83'\nNISSAN_VERSION_RESPONSE_KWP = b'\\x61\\x83'\n\nNISSAN_RX_OFFSET = 0x20\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[request for bus, logging in ((0, False), (1, True)) for request in [\n    Request(\n      [NISSAN_DIAGNOSTIC_REQUEST_KWP, NISSAN_VERSION_REQUEST_KWP],\n      [NISSAN_DIAGNOSTIC_RESPONSE_KWP, NISSAN_VERSION_RESPONSE_KWP],\n      bus=bus,\n      logging=logging,\n    ),\n    Request(\n      [NISSAN_DIAGNOSTIC_REQUEST_KWP, NISSAN_VERSION_REQUEST_KWP],\n      [NISSAN_DIAGNOSTIC_RESPONSE_KWP, NISSAN_VERSION_RESPONSE_KWP],\n      rx_offset=NISSAN_RX_OFFSET,\n      bus=bus,\n      logging=logging,\n    ),\n    # Rogue's engine solely responds to this\n    Request(\n      [NISSAN_DIAGNOSTIC_REQUEST_KWP_2, NISSAN_VERSION_REQUEST_KWP],\n      [NISSAN_DIAGNOSTIC_RESPONSE_KWP_2, NISSAN_VERSION_RESPONSE_KWP],\n      bus=bus,\n      logging=logging,\n    ),\n    Request(\n      [StdQueries.MANUFACTURER_SOFTWARE_VERSION_REQUEST],\n      [StdQueries.MANUFACTURER_SOFTWARE_VERSION_RESPONSE],\n      rx_offset=NISSAN_RX_OFFSET,\n      bus=bus,\n      logging=logging,\n    ),\n  ]],\n)\n", "selfdrive/car/nissan/carcontroller.py": "from cereal import car\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car import apply_std_steer_angle_limits\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.car.nissan import nissancan\nfrom openpilot.selfdrive.car.nissan.values import CAR, CarControllerParams\n\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.car_fingerprint = CP.carFingerprint\n    self.frame = 0\n\n    self.lkas_max_torque = 0\n    self.apply_angle_last = 0\n\n    self.packer = CANPacker(dbc_name)\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n    pcm_cancel_cmd = CC.cruiseControl.cancel\n\n    can_sends = []\n\n    ### STEER ###\n    steer_hud_alert = 1 if hud_control.visualAlert in (VisualAlert.steerRequired, VisualAlert.ldw) else 0\n\n    if CC.latActive:\n      # windup slower\n      apply_angle = apply_std_steer_angle_limits(actuators.steeringAngleDeg, self.apply_angle_last, CS.out.vEgoRaw, CarControllerParams)\n\n      # Max torque from driver before EPS will give up and not apply torque\n      if not bool(CS.out.steeringPressed):\n        self.lkas_max_torque = CarControllerParams.LKAS_MAX_TORQUE\n      else:\n        # Scale max torque based on how much torque the driver is applying to the wheel\n        self.lkas_max_torque = max(\n          # Scale max torque down to half LKAX_MAX_TORQUE as a minimum\n          CarControllerParams.LKAS_MAX_TORQUE * 0.5,\n          # Start scaling torque at STEER_THRESHOLD\n          CarControllerParams.LKAS_MAX_TORQUE - 0.6 * max(0, abs(CS.out.steeringTorque) - CarControllerParams.STEER_THRESHOLD)\n        )\n\n    else:\n      apply_angle = CS.out.steeringAngleDeg\n      self.lkas_max_torque = 0\n\n    self.apply_angle_last = apply_angle\n\n    if self.CP.carFingerprint in (CAR.NISSAN_ROGUE, CAR.NISSAN_XTRAIL, CAR.NISSAN_ALTIMA) and pcm_cancel_cmd:\n      can_sends.append(nissancan.create_acc_cancel_cmd(self.packer, self.car_fingerprint, CS.cruise_throttle_msg))\n\n    # TODO: Find better way to cancel!\n    # For some reason spamming the cancel button is unreliable on the Leaf\n    # We now cancel by making propilot think the seatbelt is unlatched,\n    # this generates a beep and a warning message every time you disengage\n    if self.CP.carFingerprint in (CAR.NISSAN_LEAF, CAR.NISSAN_LEAF_IC) and self.frame % 2 == 0:\n      can_sends.append(nissancan.create_cancel_msg(self.packer, CS.cancel_msg, pcm_cancel_cmd))\n\n    can_sends.append(nissancan.create_steering_control(\n      self.packer, apply_angle, self.frame, CC.latActive, self.lkas_max_torque))\n\n    # Below are the HUD messages. We copy the stock message and modify\n    if self.CP.carFingerprint != CAR.NISSAN_ALTIMA:\n      if self.frame % 2 == 0:\n        can_sends.append(nissancan.create_lkas_hud_msg(self.packer, CS.lkas_hud_msg, CC.enabled, hud_control.leftLaneVisible, hud_control.rightLaneVisible,\n                                                       hud_control.leftLaneDepart, hud_control.rightLaneDepart))\n\n      if self.frame % 50 == 0:\n        can_sends.append(nissancan.create_lkas_hud_info_msg(\n          self.packer, CS.lkas_hud_info_msg, steer_hud_alert\n        ))\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steeringAngleDeg = apply_angle\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/nissan/nissancan.py": "import crcmod\nfrom openpilot.selfdrive.car.nissan.values import CAR\n\n# TODO: add this checksum to the CANPacker\nnissan_checksum = crcmod.mkCrcFun(0x11d, initCrc=0x00, rev=False, xorOut=0xff)\n\n\ndef create_steering_control(packer, apply_steer, frame, steer_on, lkas_max_torque):\n  values = {\n    \"COUNTER\": frame % 0x10,\n    \"DESIRED_ANGLE\": apply_steer,\n    \"SET_0x80_2\": 0x80,\n    \"SET_0x80\": 0x80,\n    \"MAX_TORQUE\": lkas_max_torque if steer_on else 0,\n    \"LKA_ACTIVE\": steer_on,\n  }\n\n  dat = packer.make_can_msg(\"LKAS\", 0, values)[2]\n\n  values[\"CHECKSUM\"] = nissan_checksum(dat[:7])\n  return packer.make_can_msg(\"LKAS\", 0, values)\n\n\ndef create_acc_cancel_cmd(packer, car_fingerprint, cruise_throttle_msg):\n  values = {s: cruise_throttle_msg[s] for s in [\n    \"COUNTER\",\n    \"PROPILOT_BUTTON\",\n    \"CANCEL_BUTTON\",\n    \"GAS_PEDAL_INVERTED\",\n    \"SET_BUTTON\",\n    \"RES_BUTTON\",\n    \"FOLLOW_DISTANCE_BUTTON\",\n    \"NO_BUTTON_PRESSED\",\n    \"GAS_PEDAL\",\n    \"USER_BRAKE_PRESSED\",\n    \"NEW_SIGNAL_2\",\n    \"GAS_PRESSED_INVERTED\",\n    \"unsure1\",\n    \"unsure2\",\n    \"unsure3\",\n  ]}\n  can_bus = 1 if car_fingerprint == CAR.NISSAN_ALTIMA else 2\n\n  values[\"CANCEL_BUTTON\"] = 1\n  values[\"NO_BUTTON_PRESSED\"] = 0\n  values[\"PROPILOT_BUTTON\"] = 0\n  values[\"SET_BUTTON\"] = 0\n  values[\"RES_BUTTON\"] = 0\n  values[\"FOLLOW_DISTANCE_BUTTON\"] = 0\n\n  return packer.make_can_msg(\"CRUISE_THROTTLE\", can_bus, values)\n\n\ndef create_cancel_msg(packer, cancel_msg, cruise_cancel):\n  values = {s: cancel_msg[s] for s in [\n    \"CANCEL_SEATBELT\",\n    \"NEW_SIGNAL_1\",\n    \"NEW_SIGNAL_2\",\n    \"NEW_SIGNAL_3\",\n  ]}\n\n  if cruise_cancel:\n    values[\"CANCEL_SEATBELT\"] = 1\n\n  return packer.make_can_msg(\"CANCEL_MSG\", 2, values)\n\n\ndef create_lkas_hud_msg(packer, lkas_hud_msg, enabled, left_line, right_line, left_lane_depart, right_lane_depart):\n  values = {s: lkas_hud_msg[s] for s in [\n    \"LARGE_WARNING_FLASHING\",\n    \"SIDE_RADAR_ERROR_FLASHING1\",\n    \"SIDE_RADAR_ERROR_FLASHING2\",\n    \"LEAD_CAR\",\n    \"LEAD_CAR_ERROR\",\n    \"FRONT_RADAR_ERROR\",\n    \"FRONT_RADAR_ERROR_FLASHING\",\n    \"SIDE_RADAR_ERROR_FLASHING3\",\n    \"LKAS_ERROR_FLASHING\",\n    \"SAFETY_SHIELD_ACTIVE\",\n    \"RIGHT_LANE_GREEN_FLASH\",\n    \"LEFT_LANE_GREEN_FLASH\",\n    \"FOLLOW_DISTANCE\",\n    \"AUDIBLE_TONE\",\n    \"SPEED_SET_ICON\",\n    \"SMALL_STEERING_WHEEL_ICON\",\n    \"unknown59\",\n    \"unknown55\",\n    \"unknown26\",\n    \"unknown28\",\n    \"unknown31\",\n    \"SET_SPEED\",\n    \"unknown43\",\n    \"unknown08\",\n    \"unknown05\",\n    \"unknown02\",\n  ]}\n\n  values[\"RIGHT_LANE_YELLOW_FLASH\"] = 1 if right_lane_depart else 0\n  values[\"LEFT_LANE_YELLOW_FLASH\"] = 1 if left_lane_depart else 0\n\n  values[\"LARGE_STEERING_WHEEL_ICON\"] = 2 if enabled else 0\n  values[\"RIGHT_LANE_GREEN\"] = 1 if right_line and enabled else 0\n  values[\"LEFT_LANE_GREEN\"] = 1 if left_line and enabled else 0\n\n  return packer.make_can_msg(\"PROPILOT_HUD\", 0, values)\n\n\ndef create_lkas_hud_info_msg(packer, lkas_hud_info_msg, steer_hud_alert):\n  values = {s: lkas_hud_info_msg[s] for s in [\n    \"NA_HIGH_ACCEL_TEMP\",\n    \"SIDE_RADAR_NA_HIGH_CABIN_TEMP\",\n    \"SIDE_RADAR_MALFUNCTION\",\n    \"LKAS_MALFUNCTION\",\n    \"FRONT_RADAR_MALFUNCTION\",\n    \"SIDE_RADAR_NA_CLEAN_REAR_CAMERA\",\n    \"NA_POOR_ROAD_CONDITIONS\",\n    \"CURRENTLY_UNAVAILABLE\",\n    \"SAFETY_SHIELD_OFF\",\n    \"FRONT_COLLISION_NA_FRONT_RADAR_OBSTRUCTION\",\n    \"PEDAL_MISSAPPLICATION_SYSTEM_ACTIVATED\",\n    \"SIDE_IMPACT_NA_RADAR_OBSTRUCTION\",\n    \"WARNING_DO_NOT_ENTER\",\n    \"SIDE_IMPACT_SYSTEM_OFF\",\n    \"SIDE_IMPACT_MALFUNCTION\",\n    \"FRONT_COLLISION_MALFUNCTION\",\n    \"SIDE_RADAR_MALFUNCTION2\",\n    \"LKAS_MALFUNCTION2\",\n    \"FRONT_RADAR_MALFUNCTION2\",\n    \"PROPILOT_NA_MSGS\",\n    \"BOTTOM_MSG\",\n    \"HANDS_ON_WHEEL_WARNING\",\n    \"WARNING_STEP_ON_BRAKE_NOW\",\n    \"PROPILOT_NA_FRONT_CAMERA_OBSTRUCTED\",\n    \"PROPILOT_NA_HIGH_CABIN_TEMP\",\n    \"WARNING_PROPILOT_MALFUNCTION\",\n    \"ACC_UNAVAILABLE_HIGH_CABIN_TEMP\",\n    \"ACC_NA_FRONT_CAMERA_IMPARED\",\n    \"unknown07\",\n    \"unknown10\",\n    \"unknown15\",\n    \"unknown23\",\n    \"unknown19\",\n    \"unknown31\",\n    \"unknown32\",\n    \"unknown46\",\n    \"unknown61\",\n    \"unknown55\",\n    \"unknown50\",\n  ]}\n\n  if steer_hud_alert:\n    values[\"HANDS_ON_WHEEL_WARNING\"] = 1\n\n  return packer.make_can_msg(\"PROPILOT_HUD_INFO_MSG\", 0, values)\n", "selfdrive/car/nissan/radar_interface.py": "from openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nclass RadarInterface(RadarInterfaceBase):\n  pass\n", "selfdrive/car/nissan/__init__.py": "", "selfdrive/car/nissan/interface.py": "from cereal import car\nfrom panda import Panda\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.car.nissan.values import CAR\n\nButtonType = car.CarState.ButtonEvent.Type\n\n\nclass CarInterface(CarInterfaceBase):\n\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"nissan\"\n    ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.nissan)]\n    ret.autoResumeSng = False\n\n    ret.steerLimitTimer = 1.0\n\n    ret.steerActuatorDelay = 0.1\n\n    ret.steerControlType = car.CarParams.SteerControlType.angle\n    ret.radarUnavailable = True\n\n    if candidate == CAR.NISSAN_ALTIMA:\n      # Altima has EPS on C-CAN unlike the others that have it on V-CAN\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_NISSAN_ALT_EPS_BUS\n\n    return ret\n\n  # returns a car.CarState\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_adas, self.cp_cam)\n\n    ret.buttonEvents = create_button_events(self.CS.distance_button, self.CS.prev_distance_button, {1: ButtonType.gapAdjustCruise})\n\n    events = self.create_common_events(ret, extra_gears=[car.CarState.GearShifter.brake])\n\n    if self.CS.lkas_enabled:\n      events.add(car.CarEvent.EventName.invalidLkasSetting)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/toyota/carstate.py": "import copy\n\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.common.numpy_fast import mean\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.realtime import DT_CTRL\nfrom opendbc.can.can_define import CANDefine\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom openpilot.selfdrive.car.toyota.values import ToyotaFlags, CAR, DBC, STEER_THRESHOLD, NO_STOP_TIMER_CAR, \\\n                                                  TSS2_CAR, RADAR_ACC_CAR, EPS_SCALE, UNSUPPORTED_DSU_CAR\n\nSteerControlType = car.CarParams.SteerControlType\n\n# These steering fault definitions seem to be common across LKA (torque) and LTA (angle):\n# - high steer rate fault: goes to 21 or 25 for 1 frame, then 9 for 2 seconds\n# - lka/lta msg drop out: goes to 9 then 11 for a combined total of 2 seconds, then 3.\n#     if using the other control command, goes directly to 3 after 1.5 seconds\n# - initializing: LTA can report 0 as long as STEER_TORQUE_SENSOR->STEER_ANGLE_INITIALIZING is 1,\n#     and is a catch-all for LKA\nTEMP_STEER_FAULTS = (0, 9, 11, 21, 25)\n# - lka/lta msg drop out: 3 (recoverable)\n# - prolonged high driver torque: 17 (permanent)\nPERM_STEER_FAULTS = (3, 17)\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n    self.shifter_values = can_define.dv[\"GEAR_PACKET\"][\"GEAR\"]\n    self.eps_torque_scale = EPS_SCALE[CP.carFingerprint] / 100.\n    self.cluster_speed_hyst_gap = CV.KPH_TO_MS / 2.\n    self.cluster_min_speed = CV.KPH_TO_MS / 2.\n\n    # On cars with cp.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_ANGLE\"]\n    # the signal is zeroed to where the steering angle is at start.\n    # Need to apply an offset as soon as the steering angle measurements are both received\n    self.accurate_steer_angle_seen = False\n    self.angle_offset = FirstOrderFilter(None, 60.0, DT_CTRL, initialized=False)\n\n    self.prev_distance_button = 0\n    self.distance_button = 0\n\n    self.pcm_follow_distance = 0\n\n    self.low_speed_lockout = False\n    self.acc_type = 1\n    self.lkas_hud = {}\n\n  def update(self, cp, cp_cam):\n    ret = car.CarState.new_message()\n\n    ret.doorOpen = any([cp.vl[\"BODY_CONTROL_STATE\"][\"DOOR_OPEN_FL\"], cp.vl[\"BODY_CONTROL_STATE\"][\"DOOR_OPEN_FR\"],\n                        cp.vl[\"BODY_CONTROL_STATE\"][\"DOOR_OPEN_RL\"], cp.vl[\"BODY_CONTROL_STATE\"][\"DOOR_OPEN_RR\"]])\n    ret.seatbeltUnlatched = cp.vl[\"BODY_CONTROL_STATE\"][\"SEATBELT_DRIVER_UNLATCHED\"] != 0\n    ret.parkingBrake = cp.vl[\"BODY_CONTROL_STATE\"][\"PARKING_BRAKE\"] == 1\n\n    ret.brakePressed = cp.vl[\"BRAKE_MODULE\"][\"BRAKE_PRESSED\"] != 0\n    ret.brakeHoldActive = cp.vl[\"ESP_CONTROL\"][\"BRAKE_HOLD_ACTIVE\"] == 1\n\n    ret.gasPressed = cp.vl[\"PCM_CRUISE\"][\"GAS_RELEASED\"] == 0\n\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_FL\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_FR\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_RL\"],\n      cp.vl[\"WHEEL_SPEEDS\"][\"WHEEL_SPEED_RR\"],\n    )\n    ret.vEgoRaw = mean([ret.wheelSpeeds.fl, ret.wheelSpeeds.fr, ret.wheelSpeeds.rl, ret.wheelSpeeds.rr])\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.vEgoCluster = ret.vEgo * 1.015  # minimum of all the cars\n\n    ret.standstill = abs(ret.vEgoRaw) < 1e-3\n\n    ret.steeringAngleDeg = cp.vl[\"STEER_ANGLE_SENSOR\"][\"STEER_ANGLE\"] + cp.vl[\"STEER_ANGLE_SENSOR\"][\"STEER_FRACTION\"]\n    ret.steeringRateDeg = cp.vl[\"STEER_ANGLE_SENSOR\"][\"STEER_RATE\"]\n    torque_sensor_angle_deg = cp.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_ANGLE\"]\n\n    # On some cars, the angle measurement is non-zero while initializing\n    if abs(torque_sensor_angle_deg) > 1e-3 and not bool(cp.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_ANGLE_INITIALIZING\"]):\n      self.accurate_steer_angle_seen = True\n\n    if self.accurate_steer_angle_seen:\n      # Offset seems to be invalid for large steering angles and high angle rates\n      if abs(ret.steeringAngleDeg) < 90 and abs(ret.steeringRateDeg) < 100 and cp.can_valid:\n        self.angle_offset.update(torque_sensor_angle_deg - ret.steeringAngleDeg)\n\n      if self.angle_offset.initialized:\n        ret.steeringAngleOffsetDeg = self.angle_offset.x\n        ret.steeringAngleDeg = torque_sensor_angle_deg - self.angle_offset.x\n\n    can_gear = int(cp.vl[\"GEAR_PACKET\"][\"GEAR\"])\n    ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(can_gear, None))\n    ret.leftBlinker = cp.vl[\"BLINKERS_STATE\"][\"TURN_SIGNALS\"] == 1\n    ret.rightBlinker = cp.vl[\"BLINKERS_STATE\"][\"TURN_SIGNALS\"] == 2\n\n    if self.CP.carFingerprint != CAR.TOYOTA_MIRAI:\n      ret.engineRpm = cp.vl[\"ENGINE_RPM\"][\"RPM\"]\n\n    ret.steeringTorque = cp.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_TORQUE_DRIVER\"]\n    ret.steeringTorqueEps = cp.vl[\"STEER_TORQUE_SENSOR\"][\"STEER_TORQUE_EPS\"] * self.eps_torque_scale\n    # we could use the override bit from dbc, but it's triggered at too high torque values\n    ret.steeringPressed = abs(ret.steeringTorque) > STEER_THRESHOLD\n\n    # Check EPS LKA/LTA fault status\n    ret.steerFaultTemporary = cp.vl[\"EPS_STATUS\"][\"LKA_STATE\"] in TEMP_STEER_FAULTS\n    ret.steerFaultPermanent = cp.vl[\"EPS_STATUS\"][\"LKA_STATE\"] in PERM_STEER_FAULTS\n\n    if self.CP.steerControlType == SteerControlType.angle:\n      ret.steerFaultTemporary = ret.steerFaultTemporary or cp.vl[\"EPS_STATUS\"][\"LTA_STATE\"] in TEMP_STEER_FAULTS\n      ret.steerFaultPermanent = ret.steerFaultPermanent or cp.vl[\"EPS_STATUS\"][\"LTA_STATE\"] in PERM_STEER_FAULTS\n\n    if self.CP.carFingerprint in UNSUPPORTED_DSU_CAR:\n      # TODO: find the bit likely in DSU_CRUISE that describes an ACC fault. one may also exist in CLUTCH\n      ret.cruiseState.available = cp.vl[\"DSU_CRUISE\"][\"MAIN_ON\"] != 0\n      ret.cruiseState.speed = cp.vl[\"DSU_CRUISE\"][\"SET_SPEED\"] * CV.KPH_TO_MS\n      cluster_set_speed = cp.vl[\"PCM_CRUISE_ALT\"][\"UI_SET_SPEED\"]\n    else:\n      ret.accFaulted = cp.vl[\"PCM_CRUISE_2\"][\"ACC_FAULTED\"] != 0\n      ret.cruiseState.available = cp.vl[\"PCM_CRUISE_2\"][\"MAIN_ON\"] != 0\n      ret.cruiseState.speed = cp.vl[\"PCM_CRUISE_2\"][\"SET_SPEED\"] * CV.KPH_TO_MS\n      cluster_set_speed = cp.vl[\"PCM_CRUISE_SM\"][\"UI_SET_SPEED\"]\n\n    # UI_SET_SPEED is always non-zero when main is on, hide until first enable\n    if ret.cruiseState.speed != 0:\n      is_metric = cp.vl[\"BODY_CONTROL_STATE_2\"][\"UNITS\"] in (1, 2)\n      conversion_factor = CV.KPH_TO_MS if is_metric else CV.MPH_TO_MS\n      ret.cruiseState.speedCluster = cluster_set_speed * conversion_factor\n\n    cp_acc = cp_cam if self.CP.carFingerprint in (TSS2_CAR - RADAR_ACC_CAR) else cp\n\n    if self.CP.carFingerprint in TSS2_CAR and not self.CP.flags & ToyotaFlags.DISABLE_RADAR.value:\n      self.acc_type = cp_acc.vl[\"ACC_CONTROL\"][\"ACC_TYPE\"]\n      ret.stockFcw = bool(cp_acc.vl[\"PCS_HUD\"][\"FCW\"])\n\n    # some TSS2 cars have low speed lockout permanently set, so ignore on those cars\n    # these cars are identified by an ACC_TYPE value of 2.\n    # TODO: it is possible to avoid the lockout and gain stop and go if you\n    # send your own ACC_CONTROL msg on startup with ACC_TYPE set to 1\n    if (self.CP.carFingerprint not in TSS2_CAR and self.CP.carFingerprint not in UNSUPPORTED_DSU_CAR) or \\\n       (self.CP.carFingerprint in TSS2_CAR and self.acc_type == 1):\n      self.low_speed_lockout = cp.vl[\"PCM_CRUISE_2\"][\"LOW_SPEED_LOCKOUT\"] == 2\n\n    self.pcm_acc_status = cp.vl[\"PCM_CRUISE\"][\"CRUISE_STATE\"]\n    if self.CP.carFingerprint not in (NO_STOP_TIMER_CAR - TSS2_CAR):\n      # ignore standstill state in certain vehicles, since pcm allows to restart with just an acceleration request\n      ret.cruiseState.standstill = self.pcm_acc_status == 7\n    ret.cruiseState.enabled = bool(cp.vl[\"PCM_CRUISE\"][\"CRUISE_ACTIVE\"])\n    ret.cruiseState.nonAdaptive = self.pcm_acc_status in (1, 2, 3, 4, 5, 6)\n\n    ret.genericToggle = bool(cp.vl[\"LIGHT_STALK\"][\"AUTO_HIGH_BEAM\"])\n    ret.espDisabled = cp.vl[\"ESP_CONTROL\"][\"TC_DISABLED\"] != 0\n\n    if not self.CP.enableDsu and not self.CP.flags & ToyotaFlags.DISABLE_RADAR.value:\n      ret.stockAeb = bool(cp_acc.vl[\"PRE_COLLISION\"][\"PRECOLLISION_ACTIVE\"] and cp_acc.vl[\"PRE_COLLISION\"][\"FORCE\"] < -1e-5)\n\n    if self.CP.enableBsm:\n      ret.leftBlindspot = (cp.vl[\"BSM\"][\"L_ADJACENT\"] == 1) or (cp.vl[\"BSM\"][\"L_APPROACHING\"] == 1)\n      ret.rightBlindspot = (cp.vl[\"BSM\"][\"R_ADJACENT\"] == 1) or (cp.vl[\"BSM\"][\"R_APPROACHING\"] == 1)\n\n    if self.CP.carFingerprint != CAR.TOYOTA_PRIUS_V:\n      self.lkas_hud = copy.copy(cp_cam.vl[\"LKAS_HUD\"])\n\n    if self.CP.carFingerprint not in UNSUPPORTED_DSU_CAR:\n      self.pcm_follow_distance = cp.vl[\"PCM_CRUISE_2\"][\"PCM_FOLLOW_DISTANCE\"]\n\n    if self.CP.carFingerprint in (TSS2_CAR - RADAR_ACC_CAR):\n      # distance button is wired to the ACC module (camera or radar)\n      self.prev_distance_button = self.distance_button\n      if self.CP.carFingerprint in (TSS2_CAR - RADAR_ACC_CAR):\n        self.distance_button = cp_acc.vl[\"ACC_CONTROL\"][\"DISTANCE\"]\n\n    return ret\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      (\"GEAR_PACKET\", 1),\n      (\"LIGHT_STALK\", 1),\n      (\"BLINKERS_STATE\", 0.15),\n      (\"BODY_CONTROL_STATE\", 3),\n      (\"BODY_CONTROL_STATE_2\", 2),\n      (\"ESP_CONTROL\", 3),\n      (\"EPS_STATUS\", 25),\n      (\"BRAKE_MODULE\", 40),\n      (\"WHEEL_SPEEDS\", 80),\n      (\"STEER_ANGLE_SENSOR\", 80),\n      (\"PCM_CRUISE\", 33),\n      (\"PCM_CRUISE_SM\", 1),\n      (\"STEER_TORQUE_SENSOR\", 50),\n    ]\n\n    if CP.carFingerprint != CAR.TOYOTA_MIRAI:\n      messages.append((\"ENGINE_RPM\", 42))\n\n    if CP.carFingerprint in UNSUPPORTED_DSU_CAR:\n      messages.append((\"DSU_CRUISE\", 5))\n      messages.append((\"PCM_CRUISE_ALT\", 1))\n    else:\n      messages.append((\"PCM_CRUISE_2\", 33))\n\n    if CP.enableBsm:\n      messages.append((\"BSM\", 1))\n\n    if CP.carFingerprint in RADAR_ACC_CAR and not CP.flags & ToyotaFlags.DISABLE_RADAR.value:\n      messages += [\n        (\"PCS_HUD\", 1),\n        (\"ACC_CONTROL\", 33),\n      ]\n\n    if CP.carFingerprint not in (TSS2_CAR - RADAR_ACC_CAR) and not CP.enableDsu and not CP.flags & ToyotaFlags.DISABLE_RADAR.value:\n      messages += [\n        (\"PRE_COLLISION\", 33),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = []\n\n    if CP.carFingerprint != CAR.TOYOTA_PRIUS_V:\n      messages += [\n        (\"LKAS_HUD\", 1),\n      ]\n\n    if CP.carFingerprint in (TSS2_CAR - RADAR_ACC_CAR):\n      messages += [\n        (\"PRE_COLLISION\", 33),\n        (\"ACC_CONTROL\", 33),\n        (\"PCS_HUD\", 1),\n      ]\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 2)\n", "selfdrive/car/toyota/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.toyota.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFW_VERSIONS = {\n  CAR.TOYOTA_AVALON: {\n    (Ecu.abs, 0x7b0, None): [\n      b'F152607060\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881510701300\\x00\\x00\\x00\\x00',\n      b'881510705100\\x00\\x00\\x00\\x00',\n      b'881510705200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B41051\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0230721100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0C01000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230721200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0C01000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702000\\x00\\x00\\x00\\x00',\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F0701100\\x00\\x00\\x00\\x00',\n      b'8646F0703000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_AVALON_2019: {\n    (Ecu.abs, 0x7b0, None): [\n      b'F152607110\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152607140\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152607171\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152607180\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152641040\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152641050\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152641060\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152641061\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881510703200\\x00\\x00\\x00\\x00',\n      b'881510704200\\x00\\x00\\x00\\x00',\n      b'881514107100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B07010\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B41070\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B41080\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B41090\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630725100\\x00\\x00\\x00\\x00',\n      b'\\x01896630725200\\x00\\x00\\x00\\x00',\n      b'\\x01896630725300\\x00\\x00\\x00\\x00',\n      b'\\x01896630725400\\x00\\x00\\x00\\x00',\n      b'\\x01896630735100\\x00\\x00\\x00\\x00',\n      b'\\x01896630738000\\x00\\x00\\x00\\x00',\n      b'\\x02896630724000\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x02896630728000\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x02896630734000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x02896630737000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F0702100\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_AVALON_TSS2: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F152607240\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152607250\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152607280\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152641080\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B41110\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966306Q6000\\x00\\x00\\x00\\x00',\n      b'\\x01896630742000\\x00\\x00\\x00\\x00',\n      b'\\x01896630743000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F6201200\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F4104100\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F4104100\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_CAMRY: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966306L3100\\x00\\x00\\x00\\x00',\n      b'\\x018966306L4200\\x00\\x00\\x00\\x00',\n      b'\\x018966306L5200\\x00\\x00\\x00\\x00',\n      b'\\x018966306L9000\\x00\\x00\\x00\\x00',\n      b'\\x018966306P8000\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q3100\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q4000\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q4100\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q4200\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q6000\\x00\\x00\\x00\\x00',\n      b'\\x018966333N1100\\x00\\x00\\x00\\x00',\n      b'\\x018966333N4300\\x00\\x00\\x00\\x00',\n      b'\\x018966333P3100\\x00\\x00\\x00\\x00',\n      b'\\x018966333P3200\\x00\\x00\\x00\\x00',\n      b'\\x018966333P4200\\x00\\x00\\x00\\x00',\n      b'\\x018966333P4300\\x00\\x00\\x00\\x00',\n      b'\\x018966333P4400\\x00\\x00\\x00\\x00',\n      b'\\x018966333P4500\\x00\\x00\\x00\\x00',\n      b'\\x018966333P4700\\x00\\x00\\x00\\x00',\n      b'\\x018966333P4900\\x00\\x00\\x00\\x00',\n      b'\\x018966333Q6000\\x00\\x00\\x00\\x00',\n      b'\\x018966333Q6200\\x00\\x00\\x00\\x00',\n      b'\\x018966333Q6300\\x00\\x00\\x00\\x00',\n      b'\\x018966333Q6500\\x00\\x00\\x00\\x00',\n      b'\\x018966333Q9200\\x00\\x00\\x00\\x00',\n      b'\\x018966333W6000\\x00\\x00\\x00\\x00',\n      b'\\x018966333X0000\\x00\\x00\\x00\\x00',\n      b'\\x018966333X4000\\x00\\x00\\x00\\x00',\n      b'\\x01896633T16000\\x00\\x00\\x00\\x00',\n      b'\\x028966306B2100\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306B2300\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306B2500\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306N8100\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306N8200\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306N8300\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306N8400\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306R5000\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306R5000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966306R6000\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966306R6000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966306S0000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966306S0100\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966306S1100\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02333P1100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'8821F0601200    ',\n      b'8821F0601300    ',\n      b'8821F0601400    ',\n      b'8821F0601500    ',\n      b'8821F0602000    ',\n      b'8821F0603300    ',\n      b'8821F0603400    ',\n      b'8821F0604000    ',\n      b'8821F0604100    ',\n      b'8821F0604200    ',\n      b'8821F0605200    ',\n      b'8821F0606200    ',\n      b'8821F0607200    ',\n      b'8821F0608000    ',\n      b'8821F0608200    ',\n      b'8821F0609000    ',\n      b'8821F0609100    ',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152606210\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152606230\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152606270\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152606290\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152606410\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633214\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633540\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633660\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633712\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633713\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633A10\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633A20\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633B51\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633B60\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B33540\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33542\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33550\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33551\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33580\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33581\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33611\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33621\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F0601200    ',\n      b'8821F0601300    ',\n      b'8821F0601400    ',\n      b'8821F0601500    ',\n      b'8821F0602000    ',\n      b'8821F0603300    ',\n      b'8821F0603400    ',\n      b'8821F0604000    ',\n      b'8821F0604100    ',\n      b'8821F0604200    ',\n      b'8821F0605200    ',\n      b'8821F0606200    ',\n      b'8821F0607200    ',\n      b'8821F0608000    ',\n      b'8821F0608200    ',\n      b'8821F0609000    ',\n      b'8821F0609100    ',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F0601200    ',\n      b'8646F0601300    ',\n      b'8646F0601400    ',\n      b'8646F0603400    ',\n      b'8646F0603500    ',\n      b'8646F0604000    ',\n      b'8646F0604100    ',\n      b'8646F0605000    ',\n      b'8646F0606000    ',\n      b'8646F0606100    ',\n      b'8646F0607000    ',\n      b'8646F0607100    ',\n    ],\n  },\n  CAR.TOYOTA_CAMRY_TSS2: {\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B33630\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33640\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33650\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F152606370\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152606390\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152606400\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152606431\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152633E11\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633310\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633D00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633D60\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966306Q5000\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q6000\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q7000\\x00\\x00\\x00\\x00',\n      b'\\x018966306Q9000\\x00\\x00\\x00\\x00',\n      b'\\x018966306R3000\\x00\\x00\\x00\\x00',\n      b'\\x018966306R8000\\x00\\x00\\x00\\x00',\n      b'\\x018966306T0000\\x00\\x00\\x00\\x00',\n      b'\\x018966306T3100\\x00\\x00\\x00\\x00',\n      b'\\x018966306T3200\\x00\\x00\\x00\\x00',\n      b'\\x018966306T4000\\x00\\x00\\x00\\x00',\n      b'\\x018966306T4100\\x00\\x00\\x00\\x00',\n      b'\\x018966306V1000\\x00\\x00\\x00\\x00',\n      b'\\x018966333Z1000\\x00\\x00\\x00\\x00',\n      b'\\x01896633T20000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F6201200\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201300\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F0602100\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n      b'\\x028646F0602200\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n      b'\\x028646F0602300\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F3305200\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F3305200\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n      b'\\x028646F3305300\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F3305300\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n      b'\\x028646F3305400\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F3305500\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_CHR: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896631017100\\x00\\x00\\x00\\x00',\n      b'\\x01896631017200\\x00\\x00\\x00\\x00',\n      b'\\x01896631021100\\x00\\x00\\x00\\x00',\n      b'\\x0189663F413100\\x00\\x00\\x00\\x00',\n      b'\\x0189663F414100\\x00\\x00\\x00\\x00',\n      b'\\x0189663F438000\\x00\\x00\\x00\\x00',\n      b'\\x02896631013200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x0289663F405000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x0289663F405100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x0289663F418000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x0289663F423000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x0289663F431000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'8821F0W01000    ',\n      b'8821F0W01100    ',\n      b'8821FF401600    ',\n      b'8821FF402300    ',\n      b'8821FF402400    ',\n      b'8821FF404000    ',\n      b'8821FF404100    ',\n      b'8821FF405000    ',\n      b'8821FF405100    ',\n      b'8821FF406000    ',\n      b'8821FF407100    ',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152610012\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610013\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610014\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610020\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610040\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610153\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610190\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610200\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610210\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610220\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610230\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F1526F4034\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F1526F4044\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F1526F4073\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F1526F4121\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F1526F4122\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B10011\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10020\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10040\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10050\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10070\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0331024000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203202\\x00\\x00\\x00\\x00',\n      b'\\x0331024000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203302\\x00\\x00\\x00\\x00',\n      b'\\x0331036000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203302\\x00\\x00\\x00\\x00',\n      b'\\x033F401100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203102\\x00\\x00\\x00\\x00',\n      b'\\x033F401200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203202\\x00\\x00\\x00\\x00',\n      b'\\x033F424000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203202\\x00\\x00\\x00\\x00',\n      b'\\x033F424000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203302\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F0W01000    ',\n      b'8821F0W01100    ',\n      b'8821FF401600    ',\n      b'8821FF402300    ',\n      b'8821FF402400    ',\n      b'8821FF404000    ',\n      b'8821FF404100    ',\n      b'8821FF405000    ',\n      b'8821FF405100    ',\n      b'8821FF406000    ',\n      b'8821FF407100    ',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646FF401700    ',\n      b'8646FF401800    ',\n      b'8646FF402100    ',\n      b'8646FF404000    ',\n      b'8646FF406000    ',\n      b'8646FF407000    ',\n      b'8646FF407100    ',\n    ],\n  },\n  CAR.TOYOTA_CHR_TSS2: {\n    (Ecu.abs, 0x7b0, None): [\n      b'F152610041\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152610260\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F1526F4270\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B10091\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10092\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10110\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B10111\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x0189663F438000\\x00\\x00\\x00\\x00',\n      b'\\x0189663F459000\\x00\\x00\\x00\\x00',\n      b'\\x02896631025000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x0289663F453000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0331014000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203402\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821FF410200\\x00\\x00\\x00\\x00',\n      b'\\x018821FF410300\\x00\\x00\\x00\\x00',\n      b'\\x018821FF410400\\x00\\x00\\x00\\x00',\n      b'\\x018821FF410500\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646FF410200\\x00\\x00\\x00\\x008646GF408200\\x00\\x00\\x00\\x00',\n      b'\\x028646FF411100\\x00\\x00\\x00\\x008646GF409000\\x00\\x00\\x00\\x00',\n      b'\\x028646FF413100\\x00\\x00\\x00\\x008646GF411100\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_COROLLA: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0230ZC2000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC2100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC2200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC2300\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC3000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC3100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC3200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZC3300\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0330ZC1200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203202\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881510201100\\x00\\x00\\x00\\x00',\n      b'881510201200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152602190\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152602191\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B02181\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B02191\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48150\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F0201101\\x00\\x00\\x00\\x00',\n      b'8646F0201200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_COROLLA_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630A22000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZG2000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZG5000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZG5100\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZG5200\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZG5300\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZJ1000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZP1000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZP2000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZQ5000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZU8000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZU9000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ZX4000\\x00\\x00\\x00\\x00',\n      b'\\x018966312L8000\\x00\\x00\\x00\\x00',\n      b'\\x018966312M0000\\x00\\x00\\x00\\x00',\n      b'\\x018966312M9000\\x00\\x00\\x00\\x00',\n      b'\\x018966312P9000\\x00\\x00\\x00\\x00',\n      b'\\x018966312P9100\\x00\\x00\\x00\\x00',\n      b'\\x018966312P9200\\x00\\x00\\x00\\x00',\n      b'\\x018966312P9300\\x00\\x00\\x00\\x00',\n      b'\\x018966312Q2300\\x00\\x00\\x00\\x00',\n      b'\\x018966312Q8000\\x00\\x00\\x00\\x00',\n      b'\\x018966312R0000\\x00\\x00\\x00\\x00',\n      b'\\x018966312R0100\\x00\\x00\\x00\\x00',\n      b'\\x018966312R0200\\x00\\x00\\x00\\x00',\n      b'\\x018966312R1000\\x00\\x00\\x00\\x00',\n      b'\\x018966312R1100\\x00\\x00\\x00\\x00',\n      b'\\x018966312R3100\\x00\\x00\\x00\\x00',\n      b'\\x018966312S5000\\x00\\x00\\x00\\x00',\n      b'\\x018966312S7000\\x00\\x00\\x00\\x00',\n      b'\\x018966312W3000\\x00\\x00\\x00\\x00',\n      b'\\x018966312W9000\\x00\\x00\\x00\\x00',\n      b'\\x01896637621000\\x00\\x00\\x00\\x00',\n      b'\\x01896637623000\\x00\\x00\\x00\\x00',\n      b'\\x01896637624000\\x00\\x00\\x00\\x00',\n      b'\\x01896637626000\\x00\\x00\\x00\\x00',\n      b'\\x01896637639000\\x00\\x00\\x00\\x00',\n      b'\\x01896637643000\\x00\\x00\\x00\\x00',\n      b'\\x01896637644000\\x00\\x00\\x00\\x00',\n      b'\\x01896637648000\\x00\\x00\\x00\\x00',\n      b'\\x02896630A07000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630A21000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZJ5000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZK8000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZN8000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZQ3000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZR2000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZT8000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZT9000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896630ZZ0000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966312K6000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966312L0000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966312Q3000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966312Q3100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966312Q4000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x038966312L7000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF1205001\\x00\\x00\\x00\\x00',\n      b'\\x038966312N1000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF1203001\\x00\\x00\\x00\\x00',\n      b'\\x038966312T3000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF1205001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0230A10000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230A11000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZN4000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230ZN5000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02312K4000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02312U5000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x03312K7000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203402\\x00\\x00\\x00\\x00',\n      b'\\x03312M3000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203402\\x00\\x00\\x00\\x00',\n      b'\\x03312N6000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203202\\x00\\x00\\x00\\x00',\n      b'\\x03312N6000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203302\\x00\\x00\\x00\\x00',\n      b'\\x03312N6000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203402\\x00\\x00\\x00\\x00',\n      b'\\x03312N6100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203302\\x00\\x00\\x00\\x00',\n      b'\\x03312N6100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203402\\x00\\x00\\x00\\x00',\n      b'\\x03312N6200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203202\\x00\\x00\\x00\\x00',\n      b'\\x03312N6200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203302\\x00\\x00\\x00\\x00',\n      b'\\x03312N6200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00895231203402\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'\\x018965B12350\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B12470\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B12490\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B12500\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B12510\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B12520\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B12530\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x018965B1254000\\x00\\x00\\x00\\x00',\n      b'\\x018965B1255000\\x00\\x00\\x00\\x00',\n      b'\\x018965B1256000\\x00\\x00\\x00\\x00',\n      b'8965B12361\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B12451\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B16011\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B16101\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B16170\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B76012\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B76050\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B76091\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F152602280\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152602281\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152602470\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152602560\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152602590\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152602650\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260A010\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260A050\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260A070\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612641\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612651\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612862\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B10\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B51\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B60\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B61\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B62\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B70\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B71\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B81\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B90\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612B91\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152612C00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152676250\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612590\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612691\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612692\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612700\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612710\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612790\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612800\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612820\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612840\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612842\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612890\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612A00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612A10\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152612D00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152616011\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152616030\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152616060\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642540\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152676293\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152676303\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152676304\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152676371\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301100\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301200\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301300\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F12010C0\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F12010D0\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F1201100\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F1201200\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F1201300\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F1201400\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n      b'\\x028646F1202000\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F1202100\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F1202200\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n      b'\\x028646F1206000\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n      b'\\x028646F1601100\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F1601200\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F1601300\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F4203400\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F76020C0\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F7603100\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F7603200\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F7603300\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F7605100\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_HIGHLANDER: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630E09000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E43000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E43100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E43200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E44200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E44400\\x00\\x00\\x00\\x00',\n      b'\\x01896630E45000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E45100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E45200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E46000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E46200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E74000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E75000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E76000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E77000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E83000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E84000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E85000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E86000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E88000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA0000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0230E40000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230E40100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230E51000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0050E17000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230EA2000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0230EA2100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B48140\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48150\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48160\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48210\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F15260E011\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648541\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648542\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881510E01100\\x00\\x00\\x00\\x00',\n      b'881510E01200\\x00\\x00\\x00\\x00',\n      b'881510E02200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F0E01200\\x00\\x00\\x00\\x00',\n      b'8646F0E01300\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_HIGHLANDER_TSS2: {\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B48241\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48310\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48320\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48400\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15260E051\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260E05300\\x00\\x00\\x00\\x00',\n      b'\\x01F15260E061\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260E110\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260E170\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15264872300\\x00\\x00\\x00\\x00',\n      b'\\x01F15264872400\\x00\\x00\\x00\\x00',\n      b'\\x01F15264872500\\x00\\x00\\x00\\x00',\n      b'\\x01F15264872600\\x00\\x00\\x00\\x00',\n      b'\\x01F15264872700\\x00\\x00\\x00\\x00',\n      b'\\x01F15264873500\\x00\\x00\\x00\\x00',\n      b'\\x01F152648C6300\\x00\\x00\\x00\\x00',\n      b'\\x01F152648J4000\\x00\\x00\\x00\\x00',\n      b'\\x01F152648J5000\\x00\\x00\\x00\\x00',\n      b'\\x01F152648J6000\\x00\\x00\\x00\\x00',\n      b'\\x01F152648J7000\\x00\\x00\\x00\\x00',\n      b'\\x01F152648L5000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630E62100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E62200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E64100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E64200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E64400\\x00\\x00\\x00\\x00',\n      b'\\x01896630E67000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA1000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB1000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB1100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB1200\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB1300\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB2000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB2100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB2200\\x00\\x00\\x00\\x00',\n      b'\\x01896630EC4000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ED9000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ED9100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE1000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE1100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE4000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE4100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE5000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE6000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EE7000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EF8000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EG3000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EG5000\\x00\\x00\\x00\\x00',\n      b'\\x02896630E66000\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896630E66100\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896630EB3000\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896630EB3100\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201200\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201300\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F0E02100\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F4803000\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F4803000\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n      b'\\x028646F4803200\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_IS: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966353M7000\\x00\\x00\\x00\\x00',\n      b'\\x018966353M7100\\x00\\x00\\x00\\x00',\n      b'\\x018966353Q2000\\x00\\x00\\x00\\x00',\n      b'\\x018966353Q2100\\x00\\x00\\x00\\x00',\n      b'\\x018966353Q2300\\x00\\x00\\x00\\x00',\n      b'\\x018966353Q4000\\x00\\x00\\x00\\x00',\n      b'\\x018966353R1100\\x00\\x00\\x00\\x00',\n      b'\\x018966353R7100\\x00\\x00\\x00\\x00',\n      b'\\x018966353R8000\\x00\\x00\\x00\\x00',\n      b'\\x018966353R8100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0232480000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02353P7000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00530J5000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02353P9000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00553C1000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152653300\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152653301\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152653310\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152653330\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881515306200\\x00\\x00\\x00\\x00',\n      b'881515306400\\x00\\x00\\x00\\x00',\n      b'881515306500\\x00\\x00\\x00\\x00',\n      b'881515307400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B53270\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B53271\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B53280\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B53281\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B53311\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F5301101\\x00\\x00\\x00\\x00',\n      b'8646F5301200\\x00\\x00\\x00\\x00',\n      b'8646F5301300\\x00\\x00\\x00\\x00',\n      b'8646F5301400\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_IS_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966353S1000\\x00\\x00\\x00\\x00',\n      b'\\x018966353S2000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02353U0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0052422000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15265337200\\x00\\x00\\x00\\x00',\n      b'\\x01F15265342000\\x00\\x00\\x00\\x00',\n      b'\\x01F15265343000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B53450\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B53800\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F6201200\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201300\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F5303300\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n      b'\\x028646F5303400\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_PRIUS: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x02896634761000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634761100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634761200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634762000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634762100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634763000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634763100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634765000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634765100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634769000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634769100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634769200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634770000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634770100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634774000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634774100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634774200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634782000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x02896634784000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347A0000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347A5000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347A8000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347B0000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x03896634759100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x03896634759200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x03896634759200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701004\\x00\\x00\\x00\\x00',\n      b'\\x03896634759300\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x03896634759300\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701004\\x00\\x00\\x00\\x00',\n      b'\\x03896634760000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701002\\x00\\x00\\x00\\x00',\n      b'\\x03896634760000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x03896634760000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701004\\x00\\x00\\x00\\x00',\n      b'\\x03896634760100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x03896634760200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x03896634760200\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701004\\x00\\x00\\x00\\x00',\n      b'\\x03896634760300\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701004\\x00\\x00\\x00\\x00',\n      b'\\x03896634768000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4703001\\x00\\x00\\x00\\x00',\n      b'\\x03896634768000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4703002\\x00\\x00\\x00\\x00',\n      b'\\x03896634768100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4703002\\x00\\x00\\x00\\x00',\n      b'\\x03896634785000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4705001\\x00\\x00\\x00\\x00',\n      b'\\x03896634785000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4710001\\x00\\x00\\x00\\x00',\n      b'\\x03896634786000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4705001\\x00\\x00\\x00\\x00',\n      b'\\x03896634786000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4710001\\x00\\x00\\x00\\x00',\n      b'\\x03896634789000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4703002\\x00\\x00\\x00\\x00',\n      b'\\x038966347A3000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4701003\\x00\\x00\\x00\\x00',\n      b'\\x038966347A3000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4707001\\x00\\x00\\x00\\x00',\n      b'\\x038966347B6000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4710001\\x00\\x00\\x00\\x00',\n      b'\\x038966347B7000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF1203001\\x00\\x00\\x00\\x00',\n      b'\\x038966347B7000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4710001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B47021\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B47022\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B47023\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B47050\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B47060\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B47070\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152647290\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647300\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647310\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647414\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647415\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647416\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647417\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647470\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647490\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647682\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647683\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647684\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647862\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647863\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647864\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647865\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881514702300\\x00\\x00\\x00\\x00',\n      b'881514702400\\x00\\x00\\x00\\x00',\n      b'881514703100\\x00\\x00\\x00\\x00',\n      b'881514704100\\x00\\x00\\x00\\x00',\n      b'881514706000\\x00\\x00\\x00\\x00',\n      b'881514706100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702000\\x00\\x00\\x00\\x00',\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F4701300\\x00\\x00\\x00\\x00',\n      b'8646F4702001\\x00\\x00\\x00\\x00',\n      b'8646F4702100\\x00\\x00\\x00\\x00',\n      b'8646F4702200\\x00\\x00\\x00\\x00',\n      b'8646F4705000\\x00\\x00\\x00\\x00',\n      b'8646F4705200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_PRIUS_V: {\n    (Ecu.abs, 0x7b0, None): [\n      b'F152647280\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0234781000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881514705100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F4703300\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_RAV4: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02342Q1000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q1100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q1200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q1300\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054212000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q2000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054213000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q2100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054213000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q2200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054213000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342Q4000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0054215000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B42063\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42073\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42082\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42083\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F15260R102\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F15260R103\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642492\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642493\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881514201200\\x00\\x00\\x00\\x00',\n      b'881514201300\\x00\\x00\\x00\\x00',\n      b'881514201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702000\\x00\\x00\\x00\\x00',\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F4201100\\x00\\x00\\x00\\x00',\n      b'8646F4201200\\x00\\x00\\x00\\x00',\n      b'8646F4202001\\x00\\x00\\x00\\x00',\n      b'8646F4202100\\x00\\x00\\x00\\x00',\n      b'8646F4204000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_RAV4H: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02342N9000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342N9100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02342P0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B42102\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42103\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42112\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42162\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42163\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152642090\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642110\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642120\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642400\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881514202200\\x00\\x00\\x00\\x00',\n      b'881514202300\\x00\\x00\\x00\\x00',\n      b'881514202400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702000\\x00\\x00\\x00\\x00',\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F4201100\\x00\\x00\\x00\\x00',\n      b'8646F4201200\\x00\\x00\\x00\\x00',\n      b'8646F4202001\\x00\\x00\\x00\\x00',\n      b'8646F4202100\\x00\\x00\\x00\\x00',\n      b'8646F4204000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_RAV4_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630R58000\\x00\\x00\\x00\\x00',\n      b'\\x01896630R58100\\x00\\x00\\x00\\x00',\n      b'\\x018966342E2000\\x00\\x00\\x00\\x00',\n      b'\\x018966342M5000\\x00\\x00\\x00\\x00',\n      b'\\x018966342M8000\\x00\\x00\\x00\\x00',\n      b'\\x018966342S9000\\x00\\x00\\x00\\x00',\n      b'\\x018966342T1000\\x00\\x00\\x00\\x00',\n      b'\\x018966342T6000\\x00\\x00\\x00\\x00',\n      b'\\x018966342T9000\\x00\\x00\\x00\\x00',\n      b'\\x018966342U4000\\x00\\x00\\x00\\x00',\n      b'\\x018966342U4100\\x00\\x00\\x00\\x00',\n      b'\\x018966342U5100\\x00\\x00\\x00\\x00',\n      b'\\x018966342V0000\\x00\\x00\\x00\\x00',\n      b'\\x018966342V3000\\x00\\x00\\x00\\x00',\n      b'\\x018966342V3100\\x00\\x00\\x00\\x00',\n      b'\\x018966342V3200\\x00\\x00\\x00\\x00',\n      b'\\x018966342W5000\\x00\\x00\\x00\\x00',\n      b'\\x018966342W7000\\x00\\x00\\x00\\x00',\n      b'\\x018966342W8000\\x00\\x00\\x00\\x00',\n      b'\\x018966342X5000\\x00\\x00\\x00\\x00',\n      b'\\x018966342X6000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A05000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A15000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A19000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A19100\\x00\\x00\\x00\\x00',\n      b'\\x01896634A20000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A20100\\x00\\x00\\x00\\x00',\n      b'\\x01896634A22000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A22100\\x00\\x00\\x00\\x00',\n      b'\\x01896634A25000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A30000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A44000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A45000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A46000\\x00\\x00\\x00\\x00',\n      b'\\x028966342M7000\\x00\\x00\\x00\\x00897CF1201001\\x00\\x00\\x00\\x00',\n      b'\\x028966342T0000\\x00\\x00\\x00\\x00897CF1201001\\x00\\x00\\x00\\x00',\n      b'\\x028966342V1000\\x00\\x00\\x00\\x00897CF1202001\\x00\\x00\\x00\\x00',\n      b'\\x028966342W4001\\x00\\x00\\x00\\x00897CF1203001\\x00\\x00\\x00\\x00',\n      b'\\x028966342Y8000\\x00\\x00\\x00\\x00897CF1201001\\x00\\x00\\x00\\x00',\n      b'\\x028966342Z8000\\x00\\x00\\x00\\x00897CF1201001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A13000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02896634A13001\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A13101\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A13201\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A14001\\x00\\x00\\x00\\x00897CF0R01000\\x00\\x00\\x00\\x00',\n      b'\\x02896634A14001\\x00\\x00\\x00\\x00897CF1203001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A14001\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A14101\\x00\\x00\\x00\\x00897CF4801001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A18000\\x00\\x00\\x00\\x00897CF1201001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A18100\\x00\\x00\\x00\\x00897CF1201001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A23000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02896634A23001\\x00\\x00\\x00\\x00897CF1203001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A23101\\x00\\x00\\x00\\x00897CF1203001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A43000\\x00\\x00\\x00\\x00897CF4201001\\x00\\x00\\x00\\x00',\n      b'\\x02896634A47000\\x00\\x00\\x00\\x00897CF4201001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15260R210\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R220\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R290\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R292\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R300\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R302\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642551\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642561\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642601\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642700\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642701\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642710\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642711\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642750\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152642751\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642290\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642291\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642322\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642330\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642331\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642520\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642521\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642531\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642532\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642540\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642541\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152642542\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'\\x028965B0R01200\\x00\\x00\\x00\\x008965B0R02200\\x00\\x00\\x00\\x00',\n      b'\\x028965B0R01300\\x00\\x00\\x00\\x008965B0R02300\\x00\\x00\\x00\\x00',\n      b'\\x028965B0R01400\\x00\\x00\\x00\\x008965B0R02400\\x00\\x00\\x00\\x00',\n      b'8965B42170\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42171\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42180\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42181\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301100\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301200\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301300\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F4203200\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F4203300\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F4203400\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F4203500\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F4203700\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F4203800\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_RAV4_TSS2_2022: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15260R350\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R361\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15264283100\\x00\\x00\\x00\\x00',\n      b'\\x01F15264283200\\x00\\x00\\x00\\x00',\n      b'\\x01F15264286100\\x00\\x00\\x00\\x00',\n      b'\\x01F15264286200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'\\x028965B0R01500\\x00\\x00\\x00\\x008965B0R02500\\x00\\x00\\x00\\x00',\n      b'8965B42172\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B42182\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896634A02001\\x00\\x00\\x00\\x00',\n      b'\\x01896634A03000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A08000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A61000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A62000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A62100\\x00\\x00\\x00\\x00',\n      b'\\x01896634A63000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A88000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A89000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A89100\\x00\\x00\\x00\\x00',\n      b'\\x01896634AA0000\\x00\\x00\\x00\\x00',\n      b'\\x01896634AA0100\\x00\\x00\\x00\\x00',\n      b'\\x01896634AA1000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F0R01100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F0R02100\\x00\\x00\\x00\\x008646G0R01100\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_RAV4_TSS2_2023: {\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15260R450\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R50000\\x00\\x00\\x00\\x00',\n      b'\\x01F15260R51000\\x00\\x00\\x00\\x00',\n      b'\\x01F15264283200\\x00\\x00\\x00\\x00',\n      b'\\x01F15264283300\\x00\\x00\\x00\\x00',\n      b'\\x01F152642F1000\\x00\\x00\\x00\\x00',\n      b'\\x01F152642F8000\\x00\\x00\\x00\\x00',\n      b'\\x01F152642F8100\\x00\\x00\\x00\\x00',\n      b'\\x01F152642F9000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'\\x028965B0R11000\\x00\\x00\\x00\\x008965B0R12000\\x00\\x00\\x00\\x00',\n      b'8965B42371\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896634A61000\\x00\\x00\\x00\\x00',\n      b'\\x01896634A88100\\x00\\x00\\x00\\x00',\n      b'\\x01896634A89100\\x00\\x00\\x00\\x00',\n      b'\\x01896634AE1001\\x00\\x00\\x00\\x00',\n      b'\\x01896634AF0000\\x00\\x00\\x00\\x00',\n      b'\\x01896634AJ2000\\x00\\x00\\x00\\x00',\n      b'\\x01896634AL5000\\x00\\x00\\x00\\x00',\n      b'\\x01896634AL6000\\x00\\x00\\x00\\x00',\n      b'\\x01896634AL8000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F0R03100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F0R05100\\x00\\x00\\x00\\x008646G0R02100\\x00\\x00\\x00\\x00',\n      b'\\x028646F0R05200\\x00\\x00\\x00\\x008646G0R02200\\x00\\x00\\x00\\x00',\n      b'\\x028646F0R11000\\x00\\x00\\x00\\x008646G0R04000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_SIENNA: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630832100\\x00\\x00\\x00\\x00',\n      b'\\x01896630832200\\x00\\x00\\x00\\x00',\n      b'\\x01896630838000\\x00\\x00\\x00\\x00',\n      b'\\x01896630838100\\x00\\x00\\x00\\x00',\n      b'\\x01896630842000\\x00\\x00\\x00\\x00',\n      b'\\x01896630843000\\x00\\x00\\x00\\x00',\n      b'\\x01896630851000\\x00\\x00\\x00\\x00',\n      b'\\x01896630851100\\x00\\x00\\x00\\x00',\n      b'\\x01896630851200\\x00\\x00\\x00\\x00',\n      b'\\x01896630852000\\x00\\x00\\x00\\x00',\n      b'\\x01896630852100\\x00\\x00\\x00\\x00',\n      b'\\x01896630859000\\x00\\x00\\x00\\x00',\n      b'\\x01896630860000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B45070\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B45080\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B45082\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152608130\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881510801100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702200\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F0801100\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_CTH: {\n    (Ecu.dsu, 0x791, None): [\n      b'881517601100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152676144\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0237635000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F7601100\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_ES_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966306U6000\\x00\\x00\\x00\\x00',\n      b'\\x018966333T5000\\x00\\x00\\x00\\x00',\n      b'\\x018966333T5100\\x00\\x00\\x00\\x00',\n      b'\\x018966333X6000\\x00\\x00\\x00\\x00',\n      b'\\x01896633T07000\\x00\\x00\\x00\\x00',\n      b'\\x01896633T38000\\x00\\x00\\x00\\x00',\n      b'\\x01896633T58000\\x00\\x00\\x00\\x00',\n      b'\\x028966333S8000\\x00\\x00\\x00\\x00897CF3302002\\x00\\x00\\x00\\x00',\n      b'\\x028966333S8000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966333T0100\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966333V4000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x028966333W1000\\x00\\x00\\x00\\x00897CF3305001\\x00\\x00\\x00\\x00',\n      b'\\x02896633T09000\\x00\\x00\\x00\\x00897CF3307001\\x00\\x00\\x00\\x00',\n      b'\\x02896633T10000\\x00\\x00\\x00\\x00897CF3307001\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F152606281\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152606340\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152606461\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260646200\\x00\\x00\\x00\\x00',\n      b'F152633423\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633680\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633681\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633F50\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633F51\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B33252\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33590\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33690\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33721\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301100\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301200\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301300\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201200\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201300\\x00\\x00\\x00\\x00',\n      b'\\x018821F6201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F0610000\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F33030D0\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F3303100\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F3303200\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F3304100\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F3304200\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F3304300\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n      b'\\x028646F3309100\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F3309100\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_ES: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02333M4100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02333M4200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02333R0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0C01000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152606202\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152633171\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881513309400\\x00\\x00\\x00\\x00',\n      b'881513309500\\x00\\x00\\x00\\x00',\n      b'881513310400\\x00\\x00\\x00\\x00',\n      b'881513310500\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B33502\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B33512\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4701100\\x00\\x00\\x00\\x00',\n      b'8821F4701200\\x00\\x00\\x00\\x00',\n      b'8821F4701300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F3302001\\x00\\x00\\x00\\x00',\n      b'8646F3302100\\x00\\x00\\x00\\x00',\n      b'8646F3302200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_GS_F: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0233075200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00530B9000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152630700\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881513016200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B30551\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F3002100\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_NX: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896637850000\\x00\\x00\\x00\\x00',\n      b'\\x01896637851000\\x00\\x00\\x00\\x00',\n      b'\\x01896637852000\\x00\\x00\\x00\\x00',\n      b'\\x01896637854000\\x00\\x00\\x00\\x00',\n      b'\\x01896637873000\\x00\\x00\\x00\\x00',\n      b'\\x01896637878000\\x00\\x00\\x00\\x00',\n      b'\\x01896637878100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0237841000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0237842000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0237880000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0237882000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0237886000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152678130\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678140\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678160\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678170\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678171\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881517803100\\x00\\x00\\x00\\x00',\n      b'881517803300\\x00\\x00\\x00\\x00',\n      b'881517804100\\x00\\x00\\x00\\x00',\n      b'881517804300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B78060\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B78080\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B78100\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702100\\x00\\x00\\x00\\x00',\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F7801100\\x00\\x00\\x00\\x00',\n      b'8646F7801300\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_NX_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x018966378B2000\\x00\\x00\\x00\\x00',\n      b'\\x018966378B2100\\x00\\x00\\x00\\x00',\n      b'\\x018966378B3000\\x00\\x00\\x00\\x00',\n      b'\\x018966378B3100\\x00\\x00\\x00\\x00',\n      b'\\x018966378B4100\\x00\\x00\\x00\\x00',\n      b'\\x018966378G2000\\x00\\x00\\x00\\x00',\n      b'\\x018966378G3000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0237881000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0237887000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02378A0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02378F4000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F152678221\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678200\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678210\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152678211\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B78110\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B78120\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301200\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301300\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F78030A0\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F7803100\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_LC_TSS2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0131130000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152611390\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B11091\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F6201400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F1104200\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n      b'\\x028646F1105200\\x00\\x00\\x00\\x008646G3304000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_RC: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896632461100\\x00\\x00\\x00\\x00',\n      b'\\x01896632478100\\x00\\x00\\x00\\x00',\n      b'\\x01896632478200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0232484000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0052422000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152624150\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152624221\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881512404100\\x00\\x00\\x00\\x00',\n      b'881512407000\\x00\\x00\\x00\\x00',\n      b'881512409100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B24081\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B24240\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B24320\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4702300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F2401100\\x00\\x00\\x00\\x00',\n      b'8646F2401200\\x00\\x00\\x00\\x00',\n      b'8646F2402200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_RX: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630E36100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E36200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E36300\\x00\\x00\\x00\\x00',\n      b'\\x01896630E37100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E37200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E37300\\x00\\x00\\x00\\x00',\n      b'\\x01896630E41000\\x00\\x00\\x00\\x00',\n      b'\\x01896630E41100\\x00\\x00\\x00\\x00',\n      b'\\x01896630E41200\\x00\\x00\\x00\\x00',\n      b'\\x01896630E41500\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA3100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA3300\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA3400\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA4100\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA4300\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA4400\\x00\\x00\\x00\\x00',\n      b'\\x01896630EA6300\\x00\\x00\\x00\\x00',\n      b'\\x018966348R1300\\x00\\x00\\x00\\x00',\n      b'\\x018966348R8500\\x00\\x00\\x00\\x00',\n      b'\\x018966348W1300\\x00\\x00\\x00\\x00',\n      b'\\x018966348W2300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02348J7000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348N0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348Q4000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348Q4100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348T1000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348T1100\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348T1200\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348T3000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348V6000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348Z3000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152648361\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648472\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648473\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648474\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648492\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648493\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648494\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648501\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648502\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648504\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648630\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648740\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648A30\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.dsu, 0x791, None): [\n      b'881514810300\\x00\\x00\\x00\\x00',\n      b'881514810500\\x00\\x00\\x00\\x00',\n      b'881514810700\\x00\\x00\\x00\\x00',\n      b'881514811300\\x00\\x00\\x00\\x00',\n      b'881514811500\\x00\\x00\\x00\\x00',\n      b'881514811700\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B0E011\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B0E012\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48102\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48111\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48112\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'8821F4701000\\x00\\x00\\x00\\x00',\n      b'8821F4701100\\x00\\x00\\x00\\x00',\n      b'8821F4701200\\x00\\x00\\x00\\x00',\n      b'8821F4701300\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'8646F4801100\\x00\\x00\\x00\\x00',\n      b'8646F4801200\\x00\\x00\\x00\\x00',\n      b'8646F4802001\\x00\\x00\\x00\\x00',\n      b'8646F4802100\\x00\\x00\\x00\\x00',\n      b'8646F4802200\\x00\\x00\\x00\\x00',\n      b'8646F4809000\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.LEXUS_RX_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x01896630EA9000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EB0000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EC9000\\x00\\x00\\x00\\x00',\n      b'\\x01896630EC9100\\x00\\x00\\x00\\x00',\n      b'\\x01896630ED0000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ED0100\\x00\\x00\\x00\\x00',\n      b'\\x01896630ED5000\\x00\\x00\\x00\\x00',\n      b'\\x01896630ED6000\\x00\\x00\\x00\\x00',\n      b'\\x018966348R9200\\x00\\x00\\x00\\x00',\n      b'\\x018966348T8000\\x00\\x00\\x00\\x00',\n      b'\\x018966348W5100\\x00\\x00\\x00\\x00',\n      b'\\x018966348W9000\\x00\\x00\\x00\\x00',\n      b'\\x018966348X0000\\x00\\x00\\x00\\x00',\n      b'\\x01896634D11000\\x00\\x00\\x00\\x00',\n      b'\\x01896634D12000\\x00\\x00\\x00\\x00',\n      b'\\x01896634D12100\\x00\\x00\\x00\\x00',\n      b'\\x01896634D43000\\x00\\x00\\x00\\x00',\n      b'\\x01896634D44000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x02348U2000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348X4000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348X5000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348X8000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x02348Y3000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0234D14000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0234D16000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4802000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15260E031\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F15260E041\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152648781\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x01F152648801\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648493\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648811\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648831\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648891\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648C80\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648D00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152648D60\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B48261\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B48271\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301100\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301300\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F4810100\\x00\\x00\\x00\\x008646G2601200\\x00\\x00\\x00\\x00',\n      b'\\x028646F4810200\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F4810300\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F4810400\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_PRIUS_TSS2: {\n    (Ecu.engine, 0x700, None): [\n      b'\\x028966347B1000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347C4000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347C6000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347C7000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x028966347C8000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00',\n      b'\\x038966347C0000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4710101\\x00\\x00\\x00\\x00',\n      b'\\x038966347C1000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4710101\\x00\\x00\\x00\\x00',\n      b'\\x038966347C5000\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4707101\\x00\\x00\\x00\\x00',\n      b'\\x038966347C5100\\x00\\x00\\x00\\x008966A4703000\\x00\\x00\\x00\\x00897CF4707101\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152647500\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647510\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647520\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647521\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152647531\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B47070\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F4707000\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646F4710000\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n      b'\\x028646F4712000\\x00\\x00\\x00\\x008646G2601500\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_MIRAI: {\n    (Ecu.abs, 0x7d1, None): [\n      b'\\x01898A36203000\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'\\x01F15266203200\\x00\\x00\\x00\\x00',\n      b'\\x01F15266203500\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'\\x028965B6204100\\x00\\x00\\x00\\x008965B6203100\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F6201200\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F6201400\\x00\\x00\\x00\\x008646G5301200\\x00\\x00\\x00\\x00',\n    ],\n  },\n  CAR.TOYOTA_ALPHARD_TSS2: {\n    (Ecu.engine, 0x7e0, None): [\n      b'\\x0235870000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0235879000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A4701000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'\\x0235883000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00A0202000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.eps, 0x7a1, None): [\n      b'8965B58040\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'8965B58052\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.abs, 0x7b0, None): [\n      b'F152658320\\x00\\x00\\x00\\x00\\x00\\x00',\n      b'F152658341\\x00\\x00\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdRadar, 0x750, 0xf): [\n      b'\\x018821F3301200\\x00\\x00\\x00\\x00',\n      b'\\x018821F3301400\\x00\\x00\\x00\\x00',\n    ],\n    (Ecu.fwdCamera, 0x750, 0x6d): [\n      b'\\x028646F58010C0\\x00\\x00\\x00\\x008646G26011A0\\x00\\x00\\x00\\x00',\n      b'\\x028646F5803200\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n      b'\\x028646FV201000\\x00\\x00\\x00\\x008646G2601400\\x00\\x00\\x00\\x00',\n    ],\n  },\n}\n", "selfdrive/car/toyota/values.py": "import re\nfrom collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom enum import Enum, IntFlag\n\nfrom cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom openpilot.selfdrive.car import CarSpecs, PlatformConfig, Platforms\nfrom openpilot.selfdrive.car import AngleRateLimit, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarFootnote, CarDocs, Column, CarParts, CarHarness\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries\n\nEcu = car.CarParams.Ecu\nMIN_ACC_SPEED = 19. * CV.MPH_TO_MS\nPEDAL_TRANSITION = 10. * CV.MPH_TO_MS\n\n\nclass CarControllerParams:\n  ACCEL_MAX = 1.5  # m/s2, lower than allowed 2.0 m/s2 for tuning reasons\n  ACCEL_MIN = -3.5  # m/s2\n\n  STEER_STEP = 1\n  STEER_MAX = 1500\n  STEER_ERROR_MAX = 350     # max delta between torque cmd and torque motor\n\n  # Lane Tracing Assist (LTA) control limits\n  # Assuming a steering ratio of 13.7:\n  # Limit to ~2.0 m/s^3 up (7.5 deg/s), ~3.5 m/s^3 down (13 deg/s) at 75 mph\n  # Worst case, the low speed limits will allow ~4.0 m/s^3 up (15 deg/s) and ~4.9 m/s^3 down (18 deg/s) at 75 mph,\n  # however the EPS has its own internal limits at all speeds which are less than that:\n  # Observed internal torque rate limit on TSS 2.5 Camry and RAV4 is ~1500 units/sec up and down when using LTA\n  ANGLE_RATE_LIMIT_UP = AngleRateLimit(speed_bp=[5, 25], angle_v=[0.3, 0.15])\n  ANGLE_RATE_LIMIT_DOWN = AngleRateLimit(speed_bp=[5, 25], angle_v=[0.36, 0.26])\n\n  def __init__(self, CP):\n    if CP.lateralTuning.which == 'torque':\n      self.STEER_DELTA_UP = 15       # 1.0s time to peak torque\n      self.STEER_DELTA_DOWN = 25     # always lower than 45 otherwise the Rav4 faults (Prius seems ok with 50)\n    else:\n      self.STEER_DELTA_UP = 10       # 1.5s time to peak torque\n      self.STEER_DELTA_DOWN = 25     # always lower than 45 otherwise the Rav4 faults (Prius seems ok with 50)\n\n\nclass ToyotaFlags(IntFlag):\n  # Detected flags\n  HYBRID = 1\n  DISABLE_RADAR = 4\n\n  # Static flags\n  TSS2 = 8\n  NO_DSU = 16\n  UNSUPPORTED_DSU = 32\n  RADAR_ACC = 64\n  # these cars use the Lane Tracing Assist (LTA) message for lateral control\n  ANGLE_CONTROL = 128\n  NO_STOP_TIMER = 256\n  # these cars are speculated to allow stop and go when the DSU is unplugged\n  SNG_WITHOUT_DSU = 512\n\n\nclass Footnote(Enum):\n  CAMRY = CarFootnote(\n    \"openpilot operates above 28mph for Camry 4CYL L, 4CYL LE and 4CYL SE which don't have Full-Speed Range Dynamic Radar Cruise Control.\",\n    Column.FSR_LONGITUDINAL)\n\n\n@dataclass\nclass ToyotaCarDocs(CarDocs):\n  package: str = \"All\"\n  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.toyota_a]))\n\n\n@dataclass\nclass ToyotaTSS2PlatformConfig(PlatformConfig):\n  dbc_dict: dict = field(default_factory=lambda: dbc_dict('toyota_nodsu_pt_generated', 'toyota_tss2_adas'))\n\n  def init(self):\n    self.flags |= ToyotaFlags.TSS2 | ToyotaFlags.NO_STOP_TIMER | ToyotaFlags.NO_DSU\n\n    if self.flags & ToyotaFlags.RADAR_ACC:\n      self.dbc_dict = dbc_dict('toyota_nodsu_pt_generated', None)\n\n\nclass CAR(Platforms):\n  # Toyota\n  TOYOTA_ALPHARD_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Alphard 2019-20\"),\n      ToyotaCarDocs(\"Toyota Alphard Hybrid 2021\"),\n    ],\n    CarSpecs(mass=4305. * CV.LB_TO_KG, wheelbase=3.0, steerRatio=14.2, tireStiffnessFactor=0.444),\n  )\n  TOYOTA_AVALON = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Avalon 2016\", \"Toyota Safety Sense P\"),\n      ToyotaCarDocs(\"Toyota Avalon 2017-18\"),\n    ],\n    CarSpecs(mass=3505. * CV.LB_TO_KG, wheelbase=2.82, steerRatio=14.8, tireStiffnessFactor=0.7983),\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n  )\n  TOYOTA_AVALON_2019 = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Avalon 2019-21\"),\n      ToyotaCarDocs(\"Toyota Avalon Hybrid 2019-21\"),\n    ],\n    TOYOTA_AVALON.specs,\n    dbc_dict('toyota_nodsu_pt_generated', 'toyota_adas'),\n  )\n  TOYOTA_AVALON_TSS2 = ToyotaTSS2PlatformConfig( # TSS 2.5\n    [\n      ToyotaCarDocs(\"Toyota Avalon 2022\"),\n      ToyotaCarDocs(\"Toyota Avalon Hybrid 2022\"),\n    ],\n    TOYOTA_AVALON.specs,\n  )\n  TOYOTA_CAMRY = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Camry 2018-20\", video_link=\"https://www.youtube.com/watch?v=fkcjviZY9CM\", footnotes=[Footnote.CAMRY]),\n      ToyotaCarDocs(\"Toyota Camry Hybrid 2018-20\", video_link=\"https://www.youtube.com/watch?v=Q2DYY0AWKgk\"),\n    ],\n    CarSpecs(mass=3400. * CV.LB_TO_KG, wheelbase=2.82448, steerRatio=13.7, tireStiffnessFactor=0.7933),\n    dbc_dict('toyota_nodsu_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.NO_DSU,\n  )\n  TOYOTA_CAMRY_TSS2 = ToyotaTSS2PlatformConfig( # TSS 2.5\n    [\n      ToyotaCarDocs(\"Toyota Camry 2021-24\", footnotes=[Footnote.CAMRY]),\n      ToyotaCarDocs(\"Toyota Camry Hybrid 2021-24\"),\n    ],\n    TOYOTA_CAMRY.specs,\n  )\n  TOYOTA_CHR = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota C-HR 2017-20\"),\n      ToyotaCarDocs(\"Toyota C-HR Hybrid 2017-20\"),\n    ],\n    CarSpecs(mass=3300. * CV.LB_TO_KG, wheelbase=2.63906, steerRatio=13.6, tireStiffnessFactor=0.7933),\n    dbc_dict('toyota_nodsu_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.NO_DSU,\n  )\n  TOYOTA_CHR_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota C-HR 2021\"),\n      ToyotaCarDocs(\"Toyota C-HR Hybrid 2021-22\"),\n    ],\n    TOYOTA_CHR.specs,\n    flags=ToyotaFlags.RADAR_ACC,\n  )\n  TOYOTA_COROLLA = PlatformConfig(\n    [ToyotaCarDocs(\"Toyota Corolla 2017-19\")],\n    CarSpecs(mass=2860. * CV.LB_TO_KG, wheelbase=2.7, steerRatio=18.27, tireStiffnessFactor=0.444),\n    dbc_dict('toyota_new_mc_pt_generated', 'toyota_adas'),\n  )\n  # LSS2 Lexus UX Hybrid is same as a TSS2 Corolla Hybrid\n  TOYOTA_COROLLA_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Corolla 2020-22\", video_link=\"https://www.youtube.com/watch?v=_66pXk0CBYA\"),\n      ToyotaCarDocs(\"Toyota Corolla Cross (Non-US only) 2020-23\", min_enable_speed=7.5),\n      ToyotaCarDocs(\"Toyota Corolla Hatchback 2019-22\", video_link=\"https://www.youtube.com/watch?v=_66pXk0CBYA\"),\n      # Hybrid platforms\n      ToyotaCarDocs(\"Toyota Corolla Hybrid 2020-22\"),\n      ToyotaCarDocs(\"Toyota Corolla Hybrid (South America only) 2020-23\", min_enable_speed=7.5),\n      ToyotaCarDocs(\"Toyota Corolla Cross Hybrid (Non-US only) 2020-22\", min_enable_speed=7.5),\n      ToyotaCarDocs(\"Lexus UX Hybrid 2019-23\"),\n    ],\n    CarSpecs(mass=3060. * CV.LB_TO_KG, wheelbase=2.67, steerRatio=13.9, tireStiffnessFactor=0.444),\n  )\n  TOYOTA_HIGHLANDER = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Highlander 2017-19\", video_link=\"https://www.youtube.com/watch?v=0wS0wXSLzoo\"),\n      ToyotaCarDocs(\"Toyota Highlander Hybrid 2017-19\"),\n    ],\n    CarSpecs(mass=4516. * CV.LB_TO_KG, wheelbase=2.8194, steerRatio=16.0, tireStiffnessFactor=0.8),\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.NO_STOP_TIMER | ToyotaFlags.SNG_WITHOUT_DSU,\n  )\n  TOYOTA_HIGHLANDER_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Highlander 2020-23\"),\n      ToyotaCarDocs(\"Toyota Highlander Hybrid 2020-23\"),\n    ],\n    TOYOTA_HIGHLANDER.specs,\n  )\n  TOYOTA_PRIUS = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Prius 2016\", \"Toyota Safety Sense P\", video_link=\"https://www.youtube.com/watch?v=8zopPJI8XQ0\"),\n      ToyotaCarDocs(\"Toyota Prius 2017-20\", video_link=\"https://www.youtube.com/watch?v=8zopPJI8XQ0\"),\n      ToyotaCarDocs(\"Toyota Prius Prime 2017-20\", video_link=\"https://www.youtube.com/watch?v=8zopPJI8XQ0\"),\n    ],\n    CarSpecs(mass=3045. * CV.LB_TO_KG, wheelbase=2.7, steerRatio=15.74, tireStiffnessFactor=0.6371),\n    dbc_dict('toyota_nodsu_pt_generated', 'toyota_adas'),\n  )\n  TOYOTA_PRIUS_V = PlatformConfig(\n    [ToyotaCarDocs(\"Toyota Prius v 2017\", \"Toyota Safety Sense P\", min_enable_speed=MIN_ACC_SPEED)],\n    CarSpecs(mass=3340. * CV.LB_TO_KG, wheelbase=2.78, steerRatio=17.4, tireStiffnessFactor=0.5533),\n    dbc_dict('toyota_new_mc_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.NO_STOP_TIMER | ToyotaFlags.SNG_WITHOUT_DSU,\n  )\n  TOYOTA_PRIUS_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota Prius 2021-22\", video_link=\"https://www.youtube.com/watch?v=J58TvCpUd4U\"),\n      ToyotaCarDocs(\"Toyota Prius Prime 2021-22\", video_link=\"https://www.youtube.com/watch?v=J58TvCpUd4U\"),\n    ],\n    CarSpecs(mass=3115. * CV.LB_TO_KG, wheelbase=2.70002, steerRatio=13.4, tireStiffnessFactor=0.6371),\n  )\n  TOYOTA_RAV4 = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota RAV4 2016\", \"Toyota Safety Sense P\"),\n      ToyotaCarDocs(\"Toyota RAV4 2017-18\")\n    ],\n    CarSpecs(mass=3650. * CV.LB_TO_KG, wheelbase=2.65, steerRatio=16.88, tireStiffnessFactor=0.5533),\n    dbc_dict('toyota_new_mc_pt_generated', 'toyota_adas'),\n  )\n  TOYOTA_RAV4H = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota RAV4 Hybrid 2016\", \"Toyota Safety Sense P\", video_link=\"https://youtu.be/LhT5VzJVfNI?t=26\"),\n      ToyotaCarDocs(\"Toyota RAV4 Hybrid 2017-18\", video_link=\"https://youtu.be/LhT5VzJVfNI?t=26\")\n    ],\n    TOYOTA_RAV4.specs,\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n    # Note that the ICE RAV4 does not respect positive acceleration commands under 19 mph\n    flags=ToyotaFlags.NO_STOP_TIMER | ToyotaFlags.SNG_WITHOUT_DSU,\n  )\n  TOYOTA_RAV4_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota RAV4 2019-21\", video_link=\"https://www.youtube.com/watch?v=wJxjDd42gGA\"),\n      ToyotaCarDocs(\"Toyota RAV4 Hybrid 2019-21\"),\n    ],\n    CarSpecs(mass=3585. * CV.LB_TO_KG, wheelbase=2.68986, steerRatio=14.3, tireStiffnessFactor=0.7933),\n  )\n  TOYOTA_RAV4_TSS2_2022 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota RAV4 2022\"),\n      ToyotaCarDocs(\"Toyota RAV4 Hybrid 2022\", video_link=\"https://youtu.be/U0nH9cnrFB0\"),\n    ],\n    TOYOTA_RAV4_TSS2.specs,\n    flags=ToyotaFlags.RADAR_ACC,\n  )\n  TOYOTA_RAV4_TSS2_2023 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Toyota RAV4 2023-24\"),\n      ToyotaCarDocs(\"Toyota RAV4 Hybrid 2023-24\"),\n    ],\n    TOYOTA_RAV4_TSS2.specs,\n    flags=ToyotaFlags.RADAR_ACC | ToyotaFlags.ANGLE_CONTROL,\n  )\n  TOYOTA_MIRAI = ToyotaTSS2PlatformConfig( # TSS 2.5\n    [ToyotaCarDocs(\"Toyota Mirai 2021\")],\n    CarSpecs(mass=4300. * CV.LB_TO_KG, wheelbase=2.91, steerRatio=14.8, tireStiffnessFactor=0.8),\n  )\n  TOYOTA_SIENNA = PlatformConfig(\n    [ToyotaCarDocs(\"Toyota Sienna 2018-20\", video_link=\"https://www.youtube.com/watch?v=q1UPOo4Sh68\", min_enable_speed=MIN_ACC_SPEED)],\n    CarSpecs(mass=4590. * CV.LB_TO_KG, wheelbase=3.03, steerRatio=15.5, tireStiffnessFactor=0.444),\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.NO_STOP_TIMER,\n  )\n\n  # Lexus\n  LEXUS_CTH = PlatformConfig(\n    [ToyotaCarDocs(\"Lexus CT Hybrid 2017-18\", \"Lexus Safety System+\")],\n    CarSpecs(mass=3108. * CV.LB_TO_KG, wheelbase=2.6, steerRatio=18.6, tireStiffnessFactor=0.517),\n    dbc_dict('toyota_new_mc_pt_generated', 'toyota_adas'),\n  )\n  LEXUS_ES = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Lexus ES 2017-18\"),\n      ToyotaCarDocs(\"Lexus ES Hybrid 2017-18\"),\n    ],\n    CarSpecs(mass=3677. * CV.LB_TO_KG, wheelbase=2.8702, steerRatio=16.0, tireStiffnessFactor=0.444),\n    dbc_dict('toyota_new_mc_pt_generated', 'toyota_adas'),\n  )\n  LEXUS_ES_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Lexus ES 2019-24\"),\n      ToyotaCarDocs(\"Lexus ES Hybrid 2019-24\", video_link=\"https://youtu.be/BZ29osRVJeg?t=12\"),\n    ],\n    LEXUS_ES.specs,\n  )\n  LEXUS_IS = PlatformConfig(\n    [ToyotaCarDocs(\"Lexus IS 2017-19\")],\n    CarSpecs(mass=3736.8 * CV.LB_TO_KG, wheelbase=2.79908, steerRatio=13.3, tireStiffnessFactor=0.444),\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.UNSUPPORTED_DSU,\n  )\n  LEXUS_IS_TSS2 = ToyotaTSS2PlatformConfig(\n    [ToyotaCarDocs(\"Lexus IS 2022-23\")],\n    LEXUS_IS.specs,\n  )\n  LEXUS_NX = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Lexus NX 2018-19\"),\n      ToyotaCarDocs(\"Lexus NX Hybrid 2018-19\"),\n    ],\n    CarSpecs(mass=4070. * CV.LB_TO_KG, wheelbase=2.66, steerRatio=14.7, tireStiffnessFactor=0.444),\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n  )\n  LEXUS_NX_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Lexus NX 2020-21\"),\n      ToyotaCarDocs(\"Lexus NX Hybrid 2020-21\"),\n    ],\n    LEXUS_NX.specs,\n  )\n  LEXUS_LC_TSS2 = ToyotaTSS2PlatformConfig(\n    [ToyotaCarDocs(\"Lexus LC 2024\")],\n    CarSpecs(mass=4500. * CV.LB_TO_KG, wheelbase=2.87, steerRatio=13.0, tireStiffnessFactor=0.444),\n  )\n  LEXUS_RC = PlatformConfig(\n    [ToyotaCarDocs(\"Lexus RC 2018-20\")],\n    LEXUS_IS.specs,\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.UNSUPPORTED_DSU,\n  )\n  LEXUS_RX = PlatformConfig(\n    [\n      ToyotaCarDocs(\"Lexus RX 2016\", \"Lexus Safety System+\"),\n      ToyotaCarDocs(\"Lexus RX 2017-19\"),\n      # Hybrid platforms\n      ToyotaCarDocs(\"Lexus RX Hybrid 2016\", \"Lexus Safety System+\"),\n      ToyotaCarDocs(\"Lexus RX Hybrid 2017-19\"),\n    ],\n    CarSpecs(mass=4481. * CV.LB_TO_KG, wheelbase=2.79, steerRatio=16., tireStiffnessFactor=0.5533),\n    dbc_dict('toyota_tnga_k_pt_generated', 'toyota_adas'),\n  )\n  LEXUS_RX_TSS2 = ToyotaTSS2PlatformConfig(\n    [\n      ToyotaCarDocs(\"Lexus RX 2020-22\"),\n      ToyotaCarDocs(\"Lexus RX Hybrid 2020-22\"),\n    ],\n    LEXUS_RX.specs,\n  )\n  LEXUS_GS_F = PlatformConfig(\n    [ToyotaCarDocs(\"Lexus GS F 2016\")],\n    CarSpecs(mass=4034. * CV.LB_TO_KG, wheelbase=2.84988, steerRatio=13.3, tireStiffnessFactor=0.444),\n    dbc_dict('toyota_new_mc_pt_generated', 'toyota_adas'),\n    flags=ToyotaFlags.UNSUPPORTED_DSU,\n  )\n\n\n# (addr, cars, bus, 1/freq*100, vl)\nSTATIC_DSU_MSGS = [\n  (0x128, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_AVALON), \\\n                                                                                                                      1, 3, b'\\xf4\\x01\\x90\\x83\\x00\\x37'),\n  (0x128, (CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES), 1,   3, b'\\x03\\x00\\x20\\x00\\x00\\x52'),\n  (0x141, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_AVALON,\n           CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V), 1,   2, b'\\x00\\x00\\x00\\x46'),\n  (0x160, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_AVALON,\n           CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V), 1,   7, b'\\x00\\x00\\x08\\x12\\x01\\x31\\x9c\\x51'),\n  (0x161, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_AVALON, CAR.TOYOTA_PRIUS_V),\n                                                                                               1,   7, b'\\x00\\x1e\\x00\\x00\\x00\\x80\\x07'),\n  (0X161, (CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES), 1,  7, b'\\x00\\x1e\\x00\\xd4\\x00\\x00\\x5b'),\n  (0x283, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_AVALON,\n           CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V), 0,   3, b'\\x00\\x00\\x00\\x00\\x00\\x00\\x8c'),\n  (0x2E6, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX), 0,   3, b'\\xff\\xf8\\x00\\x08\\x7f\\xe0\\x00\\x4e'),\n  (0x2E7, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX), 0,   3, b'\\xa8\\x9c\\x31\\x9c\\x00\\x00\\x00\\x02'),\n  (0x33E, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX), 0,  20, b'\\x0f\\xff\\x26\\x40\\x00\\x1f\\x00'),\n  (0x344, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_AVALON,\n           CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V), 0,   5, b'\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x50'),\n  (0x365, (CAR.TOYOTA_PRIUS, CAR.LEXUS_NX, CAR.TOYOTA_HIGHLANDER), 0,  20, b'\\x00\\x00\\x00\\x80\\x03\\x00\\x08'),\n  (0x365, (CAR.TOYOTA_RAV4, CAR.TOYOTA_RAV4H, CAR.TOYOTA_COROLLA, CAR.TOYOTA_AVALON, CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.LEXUS_RX,\n           CAR.TOYOTA_PRIUS_V), 0,  20, b'\\x00\\x00\\x00\\x80\\xfc\\x00\\x08'),\n  (0x366, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_HIGHLANDER), 0,  20, b'\\x00\\x00\\x4d\\x82\\x40\\x02\\x00'),\n  (0x366, (CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_AVALON, CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V),\n          0,  20, b'\\x00\\x72\\x07\\xff\\x09\\xfe\\x00'),\n  (0x470, (CAR.TOYOTA_PRIUS, CAR.LEXUS_RX), 1, 100, b'\\x00\\x00\\x02\\x7a'),\n  (0x470, (CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_RAV4H, CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V), 1,  100, b'\\x00\\x00\\x01\\x79'),\n  (0x4CB, (CAR.TOYOTA_PRIUS, CAR.TOYOTA_RAV4H, CAR.LEXUS_RX, CAR.LEXUS_NX, CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_AVALON,\n           CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_ES, CAR.TOYOTA_PRIUS_V), 0, 100, b'\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00'),\n]\n\n\ndef get_platform_codes(fw_versions: list[bytes]) -> dict[bytes, set[bytes]]:\n  # Returns sub versions in a dict so comparisons can be made within part-platform-major_version combos\n  codes = defaultdict(set)  # Optional[part]-platform-major_version: set of sub_version\n  for fw in fw_versions:\n    # FW versions returned from UDS queries can return multiple fields/chunks of data (different ECU calibrations, different data?)\n    #  and are prefixed with a byte that describes how many chunks of data there are.\n    # But FW returned from KWP requires querying of each sub-data id and does not have a length prefix.\n\n    length_code = 1\n    length_code_match = FW_LEN_CODE.search(fw)\n    if length_code_match is not None:\n      length_code = length_code_match.group()[0]\n      fw = fw[1:]\n\n    # fw length should be multiple of 16 bytes (per chunk, even if no length code), skip parsing if unexpected length\n    if length_code * FW_CHUNK_LEN != len(fw):\n      continue\n\n    chunks = [fw[FW_CHUNK_LEN * i:FW_CHUNK_LEN * i + FW_CHUNK_LEN].strip(b'\\x00 ') for i in range(length_code)]\n\n    # only first is considered for now since second is commonly shared (TODO: understand that)\n    first_chunk = chunks[0]\n    if len(first_chunk) == 8:\n      # TODO: no part number, but some short chunks have it in subsequent chunks\n      fw_match = SHORT_FW_PATTERN.search(first_chunk)\n      if fw_match is not None:\n        platform, major_version, sub_version = fw_match.groups()\n        codes[b'-'.join((platform, major_version))].add(sub_version)\n\n    elif len(first_chunk) == 10:\n      fw_match = MEDIUM_FW_PATTERN.search(first_chunk)\n      if fw_match is not None:\n        part, platform, major_version, sub_version = fw_match.groups()\n        codes[b'-'.join((part, platform, major_version))].add(sub_version)\n\n    elif len(first_chunk) == 12:\n      fw_match = LONG_FW_PATTERN.search(first_chunk)\n      if fw_match is not None:\n        part, platform, major_version, sub_version = fw_match.groups()\n        codes[b'-'.join((part, platform, major_version))].add(sub_version)\n\n  return dict(codes)\n\n\ndef match_fw_to_car_fuzzy(live_fw_versions, vin, offline_fw_versions) -> set[str]:\n  candidates = set()\n\n  for candidate, fws in offline_fw_versions.items():\n    # Keep track of ECUs which pass all checks (platform codes, within sub-version range)\n    valid_found_ecus = set()\n    valid_expected_ecus = {ecu[1:] for ecu in fws if ecu[0] in PLATFORM_CODE_ECUS}\n    for ecu, expected_versions in fws.items():\n      addr = ecu[1:]\n      # Only check ECUs expected to have platform codes\n      if ecu[0] not in PLATFORM_CODE_ECUS:\n        continue\n\n      # Expected platform codes & versions\n      expected_platform_codes = get_platform_codes(expected_versions)\n\n      # Found platform codes & versions\n      found_platform_codes = get_platform_codes(live_fw_versions.get(addr, set()))\n\n      # Check part number + platform code + major version matches for any found versions\n      # Platform codes and major versions change for different physical parts, generation, API, etc.\n      # Sub-versions are incremented for minor recalls, do not need to be checked.\n      if not any(found_platform_code in expected_platform_codes for found_platform_code in found_platform_codes):\n        break\n\n      valid_found_ecus.add(addr)\n\n    # If all live ECUs pass all checks for candidate, add it as a match\n    if valid_expected_ecus.issubset(valid_found_ecus):\n      candidates.add(candidate)\n\n  return {str(c) for c in (candidates - FUZZY_EXCLUDED_PLATFORMS)}\n\n\n# Regex patterns for parsing more general platform-specific identifiers from FW versions.\n# - Part number: Toyota part number (usually last character needs to be ignored to find a match).\n#    Each ECU address has just one part number.\n# - Platform: usually multiple codes per an openpilot platform, however this is the least variable and\n#    is usually shared across ECUs and model years signifying this describes something about the specific platform.\n#    This describes more generational changes (TSS-P vs TSS2), or manufacture region.\n# - Major version: second least variable part of the FW version. Seen splitting cars by model year/API such as\n#    RAV4 2022/2023 and Avalon. Used to differentiate cars where API has changed slightly, but is not a generational change.\n#    It is important to note that these aren't always consecutive, for example:\n#    Avalon 2016-18's fwdCamera has these major versions: 01, 03 while 2019 has: 02\n# - Sub version: exclusive to major version, but shared with other cars. Should only be used for further filtering.\n#    Seen bumped in TSB FW updates, and describes other minor differences.\nSHORT_FW_PATTERN = re.compile(b'[A-Z0-9](?P<platform>[A-Z0-9]{2})(?P<major_version>[A-Z0-9]{2})(?P<sub_version>[A-Z0-9]{3})')\nMEDIUM_FW_PATTERN = re.compile(b'(?P<part>[A-Z0-9]{5})(?P<platform>[A-Z0-9]{2})(?P<major_version>[A-Z0-9]{1})(?P<sub_version>[A-Z0-9]{2})')\nLONG_FW_PATTERN = re.compile(b'(?P<part>[A-Z0-9]{5})(?P<platform>[A-Z0-9]{2})(?P<major_version>[A-Z0-9]{2})(?P<sub_version>[A-Z0-9]{3})')\nFW_LEN_CODE = re.compile(b'^[\\x01-\\x03]')  # highest seen is 3 chunks, 16 bytes each\nFW_CHUNK_LEN = 16\n\n# List of ECUs that are most unique across openpilot platforms\n# - fwdCamera: describes actual features related to ADAS. For example, on the Avalon it describes\n#    when TSS-P became standard, whether the car supports stop and go, and whether it's TSS2.\n#    On the RAV4, it describes the move to the radar doing ACC, and the use of LTA for lane keeping.\n#    Note that the platform codes & major versions do not describe features in plain text, only with\n#    matching against other seen FW versions in the database they can describe features.\n# - fwdRadar: sanity check against fwdCamera, commonly shares a platform code.\n#    For example the RAV4 2022's new radar architecture is shown for both with platform code.\n# - abs: differentiates hybrid/ICE on most cars (Corolla TSS2 is an exception, not used due to hybrid platform combination)\n# - eps: describes lateral API changes for the EPS, such as using LTA for lane keeping and rejecting LKA messages\nPLATFORM_CODE_ECUS = (Ecu.fwdCamera, Ecu.fwdRadar, Ecu.eps)\n\n# These platforms have at least one platform code for all ECUs shared with another platform.\nFUZZY_EXCLUDED_PLATFORMS: set[CAR] = set()\n\n# Some ECUs that use KWP2000 have their FW versions on non-standard data identifiers.\n# Toyota diagnostic software first gets the supported data ids, then queries them one by one.\n# For example, sends: 0x1a8800, receives: 0x1a8800010203, queries: 0x1a8801, 0x1a8802, 0x1a8803\nTOYOTA_VERSION_REQUEST_KWP = b'\\x1a\\x88\\x01'\nTOYOTA_VERSION_RESPONSE_KWP = b'\\x5a\\x88\\x01'\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  # TODO: look at data to whitelist new ECUs effectively\n  requests=[\n    Request(\n      [StdQueries.SHORT_TESTER_PRESENT_REQUEST, TOYOTA_VERSION_REQUEST_KWP],\n      [StdQueries.SHORT_TESTER_PRESENT_RESPONSE, TOYOTA_VERSION_RESPONSE_KWP],\n      whitelist_ecus=[Ecu.fwdCamera, Ecu.fwdRadar, Ecu.dsu, Ecu.abs, Ecu.eps, Ecu.srs, Ecu.transmission, Ecu.hvac],\n      bus=0,\n    ),\n    Request(\n      [StdQueries.SHORT_TESTER_PRESENT_REQUEST, StdQueries.OBD_VERSION_REQUEST],\n      [StdQueries.SHORT_TESTER_PRESENT_RESPONSE, StdQueries.OBD_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.engine, Ecu.hybrid, Ecu.srs, Ecu.transmission, Ecu.hvac],\n      bus=0,\n    ),\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.DEFAULT_DIAGNOSTIC_REQUEST, StdQueries.EXTENDED_DIAGNOSTIC_REQUEST, StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.DEFAULT_DIAGNOSTIC_RESPONSE, StdQueries.EXTENDED_DIAGNOSTIC_RESPONSE, StdQueries.UDS_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.engine, Ecu.fwdRadar, Ecu.fwdCamera, Ecu.abs, Ecu.eps,\n                      Ecu.hybrid, Ecu.srs, Ecu.transmission, Ecu.hvac],\n      bus=0,\n    ),\n  ],\n  non_essential_ecus={\n    # FIXME: On some models, abs can sometimes be missing\n    Ecu.abs: [CAR.TOYOTA_RAV4, CAR.TOYOTA_COROLLA, CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_SIENNA, CAR.LEXUS_IS, CAR.TOYOTA_ALPHARD_TSS2],\n    # On some models, the engine can show on two different addresses\n    Ecu.engine: [CAR.TOYOTA_HIGHLANDER, CAR.TOYOTA_CAMRY, CAR.TOYOTA_COROLLA_TSS2, CAR.TOYOTA_CHR, CAR.TOYOTA_CHR_TSS2, CAR.LEXUS_IS,\n                 CAR.LEXUS_IS_TSS2, CAR.LEXUS_RC, CAR.LEXUS_NX, CAR.LEXUS_NX_TSS2, CAR.LEXUS_RX, CAR.LEXUS_RX_TSS2],\n  },\n  extra_ecus=[\n    # All known ECUs on a late-model Toyota vehicle not queried here:\n    # Responds to UDS:\n    # - Combination Meter (0x7c0)\n    # - HV Battery (0x713, 0x747)\n    # - Motor Generator (0x716, 0x724)\n    # - 2nd ABS \"Brake/EPB\" (0x730)\n    # - Electronic Parking Brake ((0x750, 0x2c))\n    # - Telematics ((0x750, 0xc7))\n    # Responds to KWP (0x1a8801):\n    # - Steering Angle Sensor (0x7b3)\n    # - EPS/EMPS (0x7a0, 0x7a1)\n    # - 2nd SRS Airbag (0x784)\n    # - Central Gateway ((0x750, 0x5f))\n    # - Telematics ((0x750, 0xc7))\n    # Responds to KWP (0x1a8881):\n    # - Body Control Module ((0x750, 0x40))\n    # - Telematics ((0x750, 0xc7))\n\n    # Hybrid control computer can be on 0x7e2 (KWP) or 0x7d2 (UDS) depending on platform\n    (Ecu.hybrid, 0x7e2, None),  # Hybrid Control Assembly & Computer\n    (Ecu.srs, 0x780, None),     # SRS Airbag\n    # Transmission is combined with engine on some platforms, such as TSS-P RAV4\n    (Ecu.transmission, 0x701, None),\n    # A few platforms have a tester present response on this address, add to log\n    (Ecu.transmission, 0x7e1, None),\n    (Ecu.hvac, 0x7c4, None),\n  ],\n  match_fw_to_car_fuzzy=match_fw_to_car_fuzzy,\n)\n\n\nSTEER_THRESHOLD = 100\n\n# These cars have non-standard EPS torque scale factors. All others are 73\nEPS_SCALE = defaultdict(lambda: 73,\n                        {CAR.TOYOTA_PRIUS: 66, CAR.TOYOTA_COROLLA: 88, CAR.LEXUS_IS: 77, CAR.LEXUS_RC: 77, CAR.LEXUS_CTH: 100, CAR.TOYOTA_PRIUS_V: 100})\n\n# Toyota/Lexus Safety Sense 2.0 and 2.5\nTSS2_CAR = CAR.with_flags(ToyotaFlags.TSS2)\n\nNO_DSU_CAR = CAR.with_flags(ToyotaFlags.NO_DSU)\n\n# the DSU uses the AEB message for longitudinal on these cars\nUNSUPPORTED_DSU_CAR = CAR.with_flags(ToyotaFlags.UNSUPPORTED_DSU)\n\n# these cars have a radar which sends ACC messages instead of the camera\nRADAR_ACC_CAR = CAR.with_flags(ToyotaFlags.RADAR_ACC)\n\nANGLE_CONTROL_CAR = CAR.with_flags(ToyotaFlags.ANGLE_CONTROL)\n\n# no resume button press required\nNO_STOP_TIMER_CAR = CAR.with_flags(ToyotaFlags.NO_STOP_TIMER)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/toyota/carcontroller.py": "from cereal import car\nfrom openpilot.common.numpy_fast import clip\nfrom openpilot.selfdrive.car import apply_meas_steer_torque_limits, apply_std_steer_angle_limits, common_fault_avoidance, make_can_msg\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.car.toyota import toyotacan\nfrom openpilot.selfdrive.car.toyota.values import CAR, STATIC_DSU_MSGS, NO_STOP_TIMER_CAR, TSS2_CAR, \\\n                                        CarControllerParams, ToyotaFlags, \\\n                                        UNSUPPORTED_DSU_CAR\nfrom opendbc.can.packer import CANPacker\n\nSteerControlType = car.CarParams.SteerControlType\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\n# LKA limits\n# EPS faults if you apply torque while the steering rate is above 100 deg/s for too long\nMAX_STEER_RATE = 100  # deg/s\nMAX_STEER_RATE_FRAMES = 18  # tx control frames needed before torque can be cut\n\n# EPS allows user torque above threshold for 50 frames before permanently faulting\nMAX_USER_TORQUE = 500\n\n# LTA limits\n# EPS ignores commands above this angle and causes PCS to fault\nMAX_LTA_ANGLE = 94.9461  # deg\nMAX_LTA_DRIVER_TORQUE_ALLOWANCE = 150  # slightly above steering pressed allows some resistance when changing lanes\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.params = CarControllerParams(self.CP)\n    self.frame = 0\n    self.last_steer = 0\n    self.last_angle = 0\n    self.alert_active = False\n    self.last_standstill = False\n    self.standstill_req = False\n    self.steer_rate_counter = 0\n    self.distance_button = 0\n\n    self.packer = CANPacker(dbc_name)\n    self.gas = 0\n    self.accel = 0\n\n  def update(self, CC, CS, now_nanos):\n    actuators = CC.actuators\n    hud_control = CC.hudControl\n    pcm_cancel_cmd = CC.cruiseControl.cancel\n    lat_active = CC.latActive and abs(CS.out.steeringTorque) < MAX_USER_TORQUE\n\n    # *** control msgs ***\n    can_sends = []\n\n    # *** steer torque ***\n    new_steer = int(round(actuators.steer * self.params.STEER_MAX))\n    apply_steer = apply_meas_steer_torque_limits(new_steer, self.last_steer, CS.out.steeringTorqueEps, self.params)\n\n    # >100 degree/sec steering fault prevention\n    self.steer_rate_counter, apply_steer_req = common_fault_avoidance(abs(CS.out.steeringRateDeg) >= MAX_STEER_RATE, lat_active,\n                                                                      self.steer_rate_counter, MAX_STEER_RATE_FRAMES)\n\n    if not lat_active:\n      apply_steer = 0\n\n    # *** steer angle ***\n    if self.CP.steerControlType == SteerControlType.angle:\n      # If using LTA control, disable LKA and set steering angle command\n      apply_steer = 0\n      apply_steer_req = False\n      if self.frame % 2 == 0:\n        # EPS uses the torque sensor angle to control with, offset to compensate\n        apply_angle = actuators.steeringAngleDeg + CS.out.steeringAngleOffsetDeg\n\n        # Angular rate limit based on speed\n        apply_angle = apply_std_steer_angle_limits(apply_angle, self.last_angle, CS.out.vEgoRaw, self.params)\n\n        if not lat_active:\n          apply_angle = CS.out.steeringAngleDeg + CS.out.steeringAngleOffsetDeg\n\n        self.last_angle = clip(apply_angle, -MAX_LTA_ANGLE, MAX_LTA_ANGLE)\n\n    self.last_steer = apply_steer\n\n    # toyota can trace shows STEERING_LKA at 42Hz, with counter adding alternatively 1 and 2;\n    # sending it at 100Hz seem to allow a higher rate limit, as the rate limit seems imposed\n    # on consecutive messages\n    can_sends.append(toyotacan.create_steer_command(self.packer, apply_steer, apply_steer_req))\n\n    # STEERING_LTA does not seem to allow more rate by sending faster, and may wind up easier\n    if self.frame % 2 == 0 and self.CP.carFingerprint in TSS2_CAR:\n      lta_active = lat_active and self.CP.steerControlType == SteerControlType.angle\n      # cut steering torque with TORQUE_WIND_DOWN when either EPS torque or driver torque is above\n      # the threshold, to limit max lateral acceleration and for driver torque blending respectively.\n      full_torque_condition = (abs(CS.out.steeringTorqueEps) < self.params.STEER_MAX and\n                               abs(CS.out.steeringTorque) < MAX_LTA_DRIVER_TORQUE_ALLOWANCE)\n\n      # TORQUE_WIND_DOWN at 0 ramps down torque at roughly the max down rate of 1500 units/sec\n      torque_wind_down = 100 if lta_active and full_torque_condition else 0\n      can_sends.append(toyotacan.create_lta_steer_command(self.packer, self.CP.steerControlType, self.last_angle,\n                                                          lta_active, self.frame // 2, torque_wind_down))\n\n    # *** gas and brake ***\n    pcm_accel_cmd = clip(actuators.accel, self.params.ACCEL_MIN, self.params.ACCEL_MAX)\n\n    # on entering standstill, send standstill request\n    if CS.out.standstill and not self.last_standstill and (self.CP.carFingerprint not in NO_STOP_TIMER_CAR):\n      self.standstill_req = True\n    if CS.pcm_acc_status != 8:\n      # pcm entered standstill or it's disabled\n      self.standstill_req = False\n\n    self.last_standstill = CS.out.standstill\n\n    # handle UI messages\n    fcw_alert = hud_control.visualAlert == VisualAlert.fcw\n    steer_alert = hud_control.visualAlert in (VisualAlert.steerRequired, VisualAlert.ldw)\n\n    # we can spam can to cancel the system even if we are using lat only control\n    if (self.frame % 3 == 0 and self.CP.openpilotLongitudinalControl) or pcm_cancel_cmd:\n      lead = hud_control.leadVisible or CS.out.vEgo < 12.  # at low speed we always assume the lead is present so ACC can be engaged\n\n      # Press distance button until we are at the correct bar length. Only change while enabled to avoid skipping startup popup\n      if self.frame % 6 == 0 and self.CP.openpilotLongitudinalControl:\n        desired_distance = 4 - hud_control.leadDistanceBars\n        if CS.out.cruiseState.enabled and CS.pcm_follow_distance != desired_distance:\n          self.distance_button = not self.distance_button\n        else:\n          self.distance_button = 0\n\n      # Lexus IS uses a different cancellation message\n      if pcm_cancel_cmd and self.CP.carFingerprint in UNSUPPORTED_DSU_CAR:\n        can_sends.append(toyotacan.create_acc_cancel_command(self.packer))\n      elif self.CP.openpilotLongitudinalControl:\n        can_sends.append(toyotacan.create_accel_command(self.packer, pcm_accel_cmd, pcm_cancel_cmd, self.standstill_req, lead, CS.acc_type, fcw_alert,\n                                                        self.distance_button))\n        self.accel = pcm_accel_cmd\n      else:\n        can_sends.append(toyotacan.create_accel_command(self.packer, 0, pcm_cancel_cmd, False, lead, CS.acc_type, False, self.distance_button))\n\n    # *** hud ui ***\n    if self.CP.carFingerprint != CAR.TOYOTA_PRIUS_V:\n      # ui mesg is at 1Hz but we send asap if:\n      # - there is something to display\n      # - there is something to stop displaying\n      send_ui = False\n      if ((fcw_alert or steer_alert) and not self.alert_active) or \\\n         (not (fcw_alert or steer_alert) and self.alert_active):\n        send_ui = True\n        self.alert_active = not self.alert_active\n      elif pcm_cancel_cmd:\n        # forcing the pcm to disengage causes a bad fault sound so play a good sound instead\n        send_ui = True\n\n      if self.frame % 20 == 0 or send_ui:\n        can_sends.append(toyotacan.create_ui_command(self.packer, steer_alert, pcm_cancel_cmd, hud_control.leftLaneVisible,\n                                                     hud_control.rightLaneVisible, hud_control.leftLaneDepart,\n                                                     hud_control.rightLaneDepart, CC.enabled, CS.lkas_hud))\n\n      if (self.frame % 100 == 0 or send_ui) and (self.CP.enableDsu or self.CP.flags & ToyotaFlags.DISABLE_RADAR.value):\n        can_sends.append(toyotacan.create_fcw_command(self.packer, fcw_alert))\n\n    # *** static msgs ***\n    for addr, cars, bus, fr_step, vl in STATIC_DSU_MSGS:\n      if self.frame % fr_step == 0 and self.CP.enableDsu and self.CP.carFingerprint in cars:\n        can_sends.append(make_can_msg(addr, vl, bus))\n\n    # keep radar disabled\n    if self.frame % 20 == 0 and self.CP.flags & ToyotaFlags.DISABLE_RADAR.value:\n      can_sends.append([0x750, 0, b\"\\x0F\\x02\\x3E\\x00\\x00\\x00\\x00\\x00\", 0])\n\n    new_actuators = actuators.as_builder()\n    new_actuators.steer = apply_steer / self.params.STEER_MAX\n    new_actuators.steerOutputCan = apply_steer\n    new_actuators.steeringAngleDeg = self.last_angle\n    new_actuators.accel = self.accel\n    new_actuators.gas = self.gas\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/toyota/toyotacan.py": "from cereal import car\n\nSteerControlType = car.CarParams.SteerControlType\n\n\ndef create_steer_command(packer, steer, steer_req):\n  \"\"\"Creates a CAN message for the Toyota Steer Command.\"\"\"\n\n  values = {\n    \"STEER_REQUEST\": steer_req,\n    \"STEER_TORQUE_CMD\": steer,\n    \"SET_ME_1\": 1,\n  }\n  return packer.make_can_msg(\"STEERING_LKA\", 0, values)\n\n\ndef create_lta_steer_command(packer, steer_control_type, steer_angle, steer_req, frame, torque_wind_down):\n  \"\"\"Creates a CAN message for the Toyota LTA Steer Command.\"\"\"\n\n  values = {\n    \"COUNTER\": frame + 128,\n    \"SETME_X1\": 1,  # suspected LTA feature availability\n    # 1 for TSS 2.5 cars, 3 for TSS 2.0. Send based on whether we're using LTA for lateral control\n    \"SETME_X3\": 1 if steer_control_type == SteerControlType.angle else 3,\n    \"PERCENTAGE\": 100,\n    \"TORQUE_WIND_DOWN\": torque_wind_down,\n    \"ANGLE\": 0,\n    \"STEER_ANGLE_CMD\": steer_angle,\n    \"STEER_REQUEST\": steer_req,\n    \"STEER_REQUEST_2\": steer_req,\n    \"CLEAR_HOLD_STEERING_ALERT\": 0,\n  }\n  return packer.make_can_msg(\"STEERING_LTA\", 0, values)\n\n\ndef create_accel_command(packer, accel, pcm_cancel, standstill_req, lead, acc_type, fcw_alert, distance):\n  # TODO: find the exact canceling bit that does not create a chime\n  values = {\n    \"ACCEL_CMD\": accel,\n    \"ACC_TYPE\": acc_type,\n    \"DISTANCE\": distance,\n    \"MINI_CAR\": lead,\n    \"PERMIT_BRAKING\": 1,\n    \"RELEASE_STANDSTILL\": not standstill_req,\n    \"CANCEL_REQ\": pcm_cancel,\n    \"ALLOW_LONG_PRESS\": 1,\n    \"ACC_CUT_IN\": fcw_alert,  # only shown when ACC enabled\n  }\n  return packer.make_can_msg(\"ACC_CONTROL\", 0, values)\n\n\ndef create_acc_cancel_command(packer):\n  values = {\n    \"GAS_RELEASED\": 0,\n    \"CRUISE_ACTIVE\": 0,\n    \"ACC_BRAKING\": 0,\n    \"ACCEL_NET\": 0,\n    \"CRUISE_STATE\": 0,\n    \"CANCEL_REQ\": 1,\n  }\n  return packer.make_can_msg(\"PCM_CRUISE\", 0, values)\n\n\ndef create_fcw_command(packer, fcw):\n  values = {\n    \"PCS_INDICATOR\": 1,  # PCS turned off\n    \"FCW\": fcw,\n    \"SET_ME_X20\": 0x20,\n    \"SET_ME_X10\": 0x10,\n    \"PCS_OFF\": 1,\n    \"PCS_SENSITIVITY\": 0,\n  }\n  return packer.make_can_msg(\"PCS_HUD\", 0, values)\n\n\ndef create_ui_command(packer, steer, chime, left_line, right_line, left_lane_depart, right_lane_depart, enabled, stock_lkas_hud):\n  values = {\n    \"TWO_BEEPS\": chime,\n    \"LDA_ALERT\": steer,\n    \"RIGHT_LINE\": 3 if right_lane_depart else 1 if right_line else 2,\n    \"LEFT_LINE\": 3 if left_lane_depart else 1 if left_line else 2,\n    \"BARRIERS\": 1 if enabled else 0,\n\n    # static signals\n    \"SET_ME_X02\": 2,\n    \"SET_ME_X01\": 1,\n    \"LKAS_STATUS\": 1,\n    \"REPEATED_BEEPS\": 0,\n    \"LANE_SWAY_FLD\": 7,\n    \"LANE_SWAY_BUZZER\": 0,\n    \"LANE_SWAY_WARNING\": 0,\n    \"LDA_FRONT_CAMERA_BLOCKED\": 0,\n    \"TAKE_CONTROL\": 0,\n    \"LANE_SWAY_SENSITIVITY\": 2,\n    \"LANE_SWAY_TOGGLE\": 1,\n    \"LDA_ON_MESSAGE\": 0,\n    \"LDA_MESSAGES\": 0,\n    \"LDA_SA_TOGGLE\": 1,\n    \"LDA_SENSITIVITY\": 2,\n    \"LDA_UNAVAILABLE\": 0,\n    \"LDA_MALFUNCTION\": 0,\n    \"LDA_UNAVAILABLE_QUIET\": 0,\n    \"ADJUSTING_CAMERA\": 0,\n    \"LDW_EXIST\": 1,\n  }\n\n  # lane sway functionality\n  # not all cars have LKAS_HUD \u2014 update with camera values if available\n  if len(stock_lkas_hud):\n    values.update({s: stock_lkas_hud[s] for s in [\n      \"LANE_SWAY_FLD\",\n      \"LANE_SWAY_BUZZER\",\n      \"LANE_SWAY_WARNING\",\n      \"LANE_SWAY_SENSITIVITY\",\n      \"LANE_SWAY_TOGGLE\",\n    ]})\n\n  return packer.make_can_msg(\"LKAS_HUD\", 0, values)\n", "selfdrive/car/toyota/radar_interface.py": "#!/usr/bin/env python3\nfrom opendbc.can.parser import CANParser\nfrom cereal import car\nfrom openpilot.selfdrive.car.toyota.values import DBC, TSS2_CAR\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\n\ndef _create_radar_can_parser(car_fingerprint):\n  if car_fingerprint in TSS2_CAR:\n    RADAR_A_MSGS = list(range(0x180, 0x190))\n    RADAR_B_MSGS = list(range(0x190, 0x1a0))\n  else:\n    RADAR_A_MSGS = list(range(0x210, 0x220))\n    RADAR_B_MSGS = list(range(0x220, 0x230))\n\n  msg_a_n = len(RADAR_A_MSGS)\n  msg_b_n = len(RADAR_B_MSGS)\n  messages = list(zip(RADAR_A_MSGS + RADAR_B_MSGS, [20] * (msg_a_n + msg_b_n), strict=True))\n\n  return CANParser(DBC[car_fingerprint]['radar'], messages, 1)\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.track_id = 0\n    self.radar_ts = CP.radarTimeStep\n\n    if CP.carFingerprint in TSS2_CAR:\n      self.RADAR_A_MSGS = list(range(0x180, 0x190))\n      self.RADAR_B_MSGS = list(range(0x190, 0x1a0))\n    else:\n      self.RADAR_A_MSGS = list(range(0x210, 0x220))\n      self.RADAR_B_MSGS = list(range(0x220, 0x230))\n\n    self.valid_cnt = {key: 0 for key in self.RADAR_A_MSGS}\n\n    self.rcp = None if CP.radarUnavailable else _create_radar_can_parser(CP.carFingerprint)\n    self.trigger_msg = self.RADAR_B_MSGS[-1]\n    self.updated_messages = set()\n\n  def update(self, can_strings):\n    if self.rcp is None:\n      return super().update(None)\n\n    vls = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(vls)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    rr = self._update(self.updated_messages)\n    self.updated_messages.clear()\n\n    return rr\n\n  def _update(self, updated_messages):\n    ret = car.RadarData.new_message()\n    errors = []\n    if not self.rcp.can_valid:\n      errors.append(\"canError\")\n    ret.errors = errors\n\n    for ii in sorted(updated_messages):\n      if ii in self.RADAR_A_MSGS:\n        cpt = self.rcp.vl[ii]\n\n        if cpt['LONG_DIST'] >= 255 or cpt['NEW_TRACK']:\n          self.valid_cnt[ii] = 0    # reset counter\n        if cpt['VALID'] and cpt['LONG_DIST'] < 255:\n          self.valid_cnt[ii] += 1\n        else:\n          self.valid_cnt[ii] = max(self.valid_cnt[ii] - 1, 0)\n\n        score = self.rcp.vl[ii+16]['SCORE']\n        # print ii, self.valid_cnt[ii], score, cpt['VALID'], cpt['LONG_DIST'], cpt['LAT_DIST']\n\n        # radar point only valid if it's a valid measurement and score is above 50\n        if cpt['VALID'] or (score > 50 and cpt['LONG_DIST'] < 255 and self.valid_cnt[ii] > 0):\n          if ii not in self.pts or cpt['NEW_TRACK']:\n            self.pts[ii] = car.RadarData.RadarPoint.new_message()\n            self.pts[ii].trackId = self.track_id\n            self.track_id += 1\n          self.pts[ii].dRel = cpt['LONG_DIST']  # from front of car\n          self.pts[ii].yRel = -cpt['LAT_DIST']  # in car frame's y axis, left is positive\n          self.pts[ii].vRel = cpt['REL_SPEED']\n          self.pts[ii].aRel = float('nan')\n          self.pts[ii].yvRel = float('nan')\n          self.pts[ii].measured = bool(cpt['VALID'])\n        else:\n          if ii in self.pts:\n            del self.pts[ii]\n\n    ret.points = list(self.pts.values())\n    return ret\n", "selfdrive/car/toyota/__init__.py": "", "selfdrive/car/toyota/interface.py": "from cereal import car\nfrom panda import Panda\nfrom panda.python import uds\nfrom openpilot.selfdrive.car.toyota.values import Ecu, CAR, DBC, ToyotaFlags, CarControllerParams, TSS2_CAR, RADAR_ACC_CAR, NO_DSU_CAR, \\\n                                        MIN_ACC_SPEED, EPS_SCALE, UNSUPPORTED_DSU_CAR, NO_STOP_TIMER_CAR, ANGLE_CONTROL_CAR\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.disable_ecu import disable_ecu\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\n\nButtonType = car.CarState.ButtonEvent.Type\nEventName = car.CarEvent.EventName\nSteerControlType = car.CarParams.SteerControlType\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def get_pid_accel_limits(CP, current_speed, cruise_speed):\n    return CarControllerParams.ACCEL_MIN, CarControllerParams.ACCEL_MAX\n\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"toyota\"\n    ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.toyota)]\n    ret.safetyConfigs[0].safetyParam = EPS_SCALE[candidate]\n\n    # BRAKE_MODULE is on a different address for these cars\n    if DBC[candidate][\"pt\"] == \"toyota_new_mc_pt_generated\":\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_TOYOTA_ALT_BRAKE\n\n    if candidate in ANGLE_CONTROL_CAR:\n      ret.steerControlType = SteerControlType.angle\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_TOYOTA_LTA\n\n      # LTA control can be more delayed and winds up more often\n      ret.steerActuatorDelay = 0.18\n      ret.steerLimitTimer = 0.8\n    else:\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n\n      ret.steerActuatorDelay = 0.12  # Default delay, Prius has larger delay\n      ret.steerLimitTimer = 0.4\n\n    ret.stoppingControl = False  # Toyota starts braking more when it thinks you want to stop\n\n    stop_and_go = candidate in TSS2_CAR\n\n    # In TSS2 cars, the camera does long control\n    found_ecus = [fw.ecu for fw in car_fw]\n    ret.enableDsu = len(found_ecus) > 0 and Ecu.dsu not in found_ecus and candidate not in (NO_DSU_CAR | UNSUPPORTED_DSU_CAR)\n\n    if candidate == CAR.TOYOTA_PRIUS:\n      stop_and_go = True\n      # Only give steer angle deadzone to for bad angle sensor prius\n      for fw in car_fw:\n        if fw.ecu == \"eps\" and not fw.fwVersion == b'8965B47060\\x00\\x00\\x00\\x00\\x00\\x00':\n          ret.steerActuatorDelay = 0.25\n          CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning, steering_angle_deadzone_deg=0.2)\n\n    elif candidate in (CAR.LEXUS_RX, CAR.LEXUS_RX_TSS2):\n      stop_and_go = True\n      ret.wheelSpeedFactor = 1.035\n\n    elif candidate in (CAR.TOYOTA_AVALON, CAR.TOYOTA_AVALON_2019, CAR.TOYOTA_AVALON_TSS2):\n      # starting from 2019, all Avalon variants have stop and go\n      # https://engage.toyota.com/static/images/toyota_safety_sense/TSS_Applicability_Chart.pdf\n      stop_and_go = candidate != CAR.TOYOTA_AVALON\n\n    elif candidate in (CAR.TOYOTA_RAV4_TSS2, CAR.TOYOTA_RAV4_TSS2_2022, CAR.TOYOTA_RAV4_TSS2_2023):\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kiBP = [0.0]\n      ret.lateralTuning.pid.kpBP = [0.0]\n      ret.lateralTuning.pid.kpV = [0.6]\n      ret.lateralTuning.pid.kiV = [0.1]\n      ret.lateralTuning.pid.kf = 0.00007818594\n\n      # 2019+ RAV4 TSS2 uses two different steering racks and specific tuning seems to be necessary.\n      # See https://github.com/commaai/openpilot/pull/21429#issuecomment-873652891\n      for fw in car_fw:\n        if fw.ecu == \"eps\" and (fw.fwVersion.startswith(b'\\x02') or fw.fwVersion in [b'8965B42181\\x00\\x00\\x00\\x00\\x00\\x00']):\n          ret.lateralTuning.pid.kpV = [0.15]\n          ret.lateralTuning.pid.kiV = [0.05]\n          ret.lateralTuning.pid.kf = 0.00004\n          break\n\n    elif candidate in (CAR.TOYOTA_CHR, CAR.TOYOTA_CAMRY, CAR.TOYOTA_SIENNA, CAR.LEXUS_CTH, CAR.LEXUS_NX):\n      # TODO: Some of these platforms are not advertised to have full range ACC, are they similar to SNG_WITHOUT_DSU cars?\n      stop_and_go = True\n\n    # TODO: these models can do stop and go, but unclear if it requires sDSU or unplugging DSU.\n    #  For now, don't list stop and go functionality in the docs\n    if ret.flags & ToyotaFlags.SNG_WITHOUT_DSU:\n      stop_and_go = stop_and_go or (ret.enableDsu and not docs)\n\n    ret.centerToFront = ret.wheelbase * 0.44\n\n    # TODO: Some TSS-P platforms have BSM, but are flipped based on region or driving direction.\n    # Detect flipped signals and enable for C-HR and others\n    ret.enableBsm = 0x3F6 in fingerprint[0] and candidate in TSS2_CAR\n\n    # No radar dbc for cars without DSU which are not TSS 2.0\n    # TODO: make an adas dbc file for dsu-less models\n    ret.radarUnavailable = DBC[candidate]['radar'] is None or candidate in (NO_DSU_CAR - TSS2_CAR)\n\n    # since we don't yet parse radar on TSS2/TSS-P radar-based ACC cars, gate longitudinal behind experimental toggle\n    if candidate in (RADAR_ACC_CAR | NO_DSU_CAR):\n      ret.experimentalLongitudinalAvailable = candidate in RADAR_ACC_CAR\n\n      # Disabling radar is only supported on TSS2 radar-ACC cars\n      if experimental_long and candidate in RADAR_ACC_CAR:\n        ret.flags |= ToyotaFlags.DISABLE_RADAR.value\n\n    # openpilot longitudinal enabled by default:\n    #  - cars w/ DSU disconnected\n    #  - TSS2 cars with camera sending ACC_CONTROL where we can block it\n    # openpilot longitudinal behind experimental long toggle:\n    #  - TSS2 radar ACC cars (disables radar)\n    ret.openpilotLongitudinalControl = ret.enableDsu or candidate in (TSS2_CAR - RADAR_ACC_CAR) or bool(ret.flags & ToyotaFlags.DISABLE_RADAR.value)\n    ret.autoResumeSng = ret.openpilotLongitudinalControl and candidate in NO_STOP_TIMER_CAR\n\n    if not ret.openpilotLongitudinalControl:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_TOYOTA_STOCK_LONGITUDINAL\n\n    # min speed to enable ACC. if car can do stop and go, then set enabling speed\n    # to a negative value, so it won't matter.\n    ret.minEnableSpeed = -1. if stop_and_go else MIN_ACC_SPEED\n\n    tune = ret.longitudinalTuning\n    if candidate in TSS2_CAR:\n      tune.kpV = [0.0]\n      tune.kiV = [0.5]\n      ret.vEgoStopping = 0.25\n      ret.vEgoStarting = 0.25\n      ret.stoppingDecelRate = 0.3  # reach stopping target smoothly\n    else:\n      tune.kiBP = [0., 5., 35.]\n      tune.kiV = [3.6, 2.4, 1.5]\n\n    return ret\n\n  @staticmethod\n  def init(CP, logcan, sendcan):\n    # disable radar if alpha longitudinal toggled on radar-ACC car\n    if CP.flags & ToyotaFlags.DISABLE_RADAR.value:\n      communication_control = bytes([uds.SERVICE_TYPE.COMMUNICATION_CONTROL, uds.CONTROL_TYPE.ENABLE_RX_DISABLE_TX, uds.MESSAGE_TYPE.NORMAL])\n      disable_ecu(logcan, sendcan, bus=0, addr=0x750, sub_addr=0xf, com_cont_req=communication_control)\n\n  # returns a car.CarState\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam)\n\n    if self.CP.carFingerprint in (TSS2_CAR - RADAR_ACC_CAR):\n      ret.buttonEvents = create_button_events(self.CS.distance_button, self.CS.prev_distance_button, {1: ButtonType.gapAdjustCruise})\n\n    # events\n    events = self.create_common_events(ret)\n\n    # Lane Tracing Assist control is unavailable (EPS_STATUS->LTA_STATE=0) until\n    # the more accurate angle sensor signal is initialized\n    if self.CP.steerControlType == SteerControlType.angle and not self.CS.accurate_steer_angle_seen:\n      events.add(EventName.vehicleSensorsInvalid)\n\n    if self.CP.openpilotLongitudinalControl:\n      if ret.cruiseState.standstill and not ret.brakePressed:\n        events.add(EventName.resumeRequired)\n      if self.CS.low_speed_lockout:\n        events.add(EventName.lowSpeedLockout)\n      if ret.vEgo < self.CP.minEnableSpeed:\n        events.add(EventName.belowEngageSpeed)\n        if c.actuators.accel > 0.3:\n          # some margin on the actuator to not false trigger cancellation while stopping\n          events.add(EventName.speedTooLow)\n        if ret.vEgo < 0.001:\n          # while in standstill, send a user alert\n          events.add(EventName.manualRestart)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/chrysler/chryslercan.py": "from cereal import car\nfrom openpilot.selfdrive.car.chrysler.values import RAM_CARS\n\nGearShifter = car.CarState.GearShifter\nVisualAlert = car.CarControl.HUDControl.VisualAlert\n\ndef create_lkas_hud(packer, CP, lkas_active, hud_alert, hud_count, car_model, auto_high_beam):\n  # LKAS_HUD - Controls what lane-keeping icon is displayed\n\n  # == Color ==\n  # 0 hidden?\n  # 1 white\n  # 2 green\n  # 3 ldw\n\n  # == Lines ==\n  # 03 white Lines\n  # 04 grey lines\n  # 09 left lane close\n  # 0A right lane close\n  # 0B left Lane very close\n  # 0C right Lane very close\n  # 0D left cross cross\n  # 0E right lane cross\n\n  # == Alerts ==\n  # 7 Normal\n  # 6 lane departure place hands on wheel\n\n  color = 2 if lkas_active else 1\n  lines = 3 if lkas_active else 0\n  alerts = 7 if lkas_active else 0\n\n  if hud_count < (1 * 4):  # first 3 seconds, 4Hz\n    alerts = 1\n\n  if hud_alert in (VisualAlert.ldw, VisualAlert.steerRequired):\n    color = 4\n    lines = 0\n    alerts = 6\n\n  values = {\n    \"LKAS_ICON_COLOR\": color,\n    \"CAR_MODEL\": car_model,\n    \"LKAS_LANE_LINES\": lines,\n    \"LKAS_ALERTS\": alerts,\n  }\n\n  if CP.carFingerprint in RAM_CARS:\n    values['AUTO_HIGH_BEAM_ON'] = auto_high_beam\n\n  return packer.make_can_msg(\"DAS_6\", 0, values)\n\n\ndef create_lkas_command(packer, CP, apply_steer, lkas_control_bit):\n  # LKAS_COMMAND Lane-keeping signal to turn the wheel\n  enabled_val = 2 if CP.carFingerprint in RAM_CARS else 1\n  values = {\n    \"STEERING_TORQUE\": apply_steer,\n    \"LKAS_CONTROL_BIT\": enabled_val if lkas_control_bit else 0,\n  }\n  return packer.make_can_msg(\"LKAS_COMMAND\", 0, values)\n\n\ndef create_cruise_buttons(packer, frame, bus, cancel=False, resume=False):\n  values = {\n    \"ACC_Cancel\": cancel,\n    \"ACC_Resume\": resume,\n    \"COUNTER\": frame % 0x10,\n  }\n  return packer.make_can_msg(\"CRUISE_BUTTONS\", bus, values)\n", "selfdrive/car/chrysler/carstate.py": "from cereal import car\nfrom openpilot.common.conversions import Conversions as CV\nfrom opendbc.can.parser import CANParser\nfrom opendbc.can.can_define import CANDefine\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom openpilot.selfdrive.car.chrysler.values import DBC, STEER_THRESHOLD, RAM_CARS\n\n\nclass CarState(CarStateBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.CP = CP\n    can_define = CANDefine(DBC[CP.carFingerprint][\"pt\"])\n\n    self.auto_high_beam = 0\n    self.button_counter = 0\n    self.lkas_car_model = -1\n\n    if CP.carFingerprint in RAM_CARS:\n      self.shifter_values = can_define.dv[\"Transmission_Status\"][\"Gear_State\"]\n    else:\n      self.shifter_values = can_define.dv[\"GEAR\"][\"PRNDL\"]\n\n    self.prev_distance_button = 0\n    self.distance_button = 0\n\n  def update(self, cp, cp_cam):\n\n    ret = car.CarState.new_message()\n\n    self.prev_distance_button = self.distance_button\n    self.distance_button = cp.vl[\"CRUISE_BUTTONS\"][\"ACC_Distance_Dec\"]\n\n    # lock info\n    ret.doorOpen = any([cp.vl[\"BCM_1\"][\"DOOR_OPEN_FL\"],\n                        cp.vl[\"BCM_1\"][\"DOOR_OPEN_FR\"],\n                        cp.vl[\"BCM_1\"][\"DOOR_OPEN_RL\"],\n                        cp.vl[\"BCM_1\"][\"DOOR_OPEN_RR\"]])\n    ret.seatbeltUnlatched = cp.vl[\"ORC_1\"][\"SEATBELT_DRIVER_UNLATCHED\"] == 1\n\n    # brake pedal\n    ret.brake = 0\n    ret.brakePressed = cp.vl[\"ESP_1\"]['Brake_Pedal_State'] == 1  # Physical brake pedal switch\n\n    # gas pedal\n    ret.gas = cp.vl[\"ECM_5\"][\"Accelerator_Position\"]\n    ret.gasPressed = ret.gas > 1e-5\n\n    # car speed\n    if self.CP.carFingerprint in RAM_CARS:\n      ret.vEgoRaw = cp.vl[\"ESP_8\"][\"Vehicle_Speed\"] * CV.KPH_TO_MS\n      ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(cp.vl[\"Transmission_Status\"][\"Gear_State\"], None))\n    else:\n      ret.vEgoRaw = (cp.vl[\"SPEED_1\"][\"SPEED_LEFT\"] + cp.vl[\"SPEED_1\"][\"SPEED_RIGHT\"]) / 2.\n      ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(cp.vl[\"GEAR\"][\"PRNDL\"], None))\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = not ret.vEgoRaw > 0.001\n    ret.wheelSpeeds = self.get_wheel_speeds(\n      cp.vl[\"ESP_6\"][\"WHEEL_SPEED_FL\"],\n      cp.vl[\"ESP_6\"][\"WHEEL_SPEED_FR\"],\n      cp.vl[\"ESP_6\"][\"WHEEL_SPEED_RL\"],\n      cp.vl[\"ESP_6\"][\"WHEEL_SPEED_RR\"],\n      unit=1,\n    )\n\n    # button presses\n    ret.leftBlinker, ret.rightBlinker = self.update_blinker_from_stalk(200, cp.vl[\"STEERING_LEVERS\"][\"TURN_SIGNALS\"] == 1,\n                                                                       cp.vl[\"STEERING_LEVERS\"][\"TURN_SIGNALS\"] == 2)\n    ret.genericToggle = cp.vl[\"STEERING_LEVERS\"][\"HIGH_BEAM_PRESSED\"] == 1\n\n    # steering wheel\n    ret.steeringAngleDeg = cp.vl[\"STEERING\"][\"STEERING_ANGLE\"] + cp.vl[\"STEERING\"][\"STEERING_ANGLE_HP\"]\n    ret.steeringRateDeg = cp.vl[\"STEERING\"][\"STEERING_RATE\"]\n    ret.steeringTorque = cp.vl[\"EPS_2\"][\"COLUMN_TORQUE\"]\n    ret.steeringTorqueEps = cp.vl[\"EPS_2\"][\"EPS_TORQUE_MOTOR\"]\n    ret.steeringPressed = abs(ret.steeringTorque) > STEER_THRESHOLD\n\n    # cruise state\n    cp_cruise = cp_cam if self.CP.carFingerprint in RAM_CARS else cp\n\n    ret.cruiseState.available = cp_cruise.vl[\"DAS_3\"][\"ACC_AVAILABLE\"] == 1\n    ret.cruiseState.enabled = cp_cruise.vl[\"DAS_3\"][\"ACC_ACTIVE\"] == 1\n    ret.cruiseState.speed = cp_cruise.vl[\"DAS_4\"][\"ACC_SET_SPEED_KPH\"] * CV.KPH_TO_MS\n    ret.cruiseState.nonAdaptive = cp_cruise.vl[\"DAS_4\"][\"ACC_STATE\"] in (1, 2)  # 1 NormalCCOn and 2 NormalCCSet\n    ret.cruiseState.standstill = cp_cruise.vl[\"DAS_3\"][\"ACC_STANDSTILL\"] == 1\n    ret.accFaulted = cp_cruise.vl[\"DAS_3\"][\"ACC_FAULTED\"] != 0\n\n    if self.CP.carFingerprint in RAM_CARS:\n      # Auto High Beam isn't Located in this message on chrysler or jeep currently located in 729 message\n      self.auto_high_beam = cp_cam.vl[\"DAS_6\"]['AUTO_HIGH_BEAM_ON']\n      ret.steerFaultTemporary = cp.vl[\"EPS_3\"][\"DASM_FAULT\"] == 1\n    else:\n      ret.steerFaultTemporary = cp.vl[\"EPS_2\"][\"LKAS_TEMPORARY_FAULT\"] == 1\n      ret.steerFaultPermanent = cp.vl[\"EPS_2\"][\"LKAS_STATE\"] == 4\n\n    # blindspot sensors\n    if self.CP.enableBsm:\n      ret.leftBlindspot = cp.vl[\"BSM_1\"][\"LEFT_STATUS\"] == 1\n      ret.rightBlindspot = cp.vl[\"BSM_1\"][\"RIGHT_STATUS\"] == 1\n\n    self.lkas_car_model = cp_cam.vl[\"DAS_6\"][\"CAR_MODEL\"]\n    self.button_counter = cp.vl[\"CRUISE_BUTTONS\"][\"COUNTER\"]\n\n    return ret\n\n  @staticmethod\n  def get_cruise_messages():\n    messages = [\n      (\"DAS_3\", 50),\n      (\"DAS_4\", 50),\n    ]\n    return messages\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      # sig_address, frequency\n      (\"ESP_1\", 50),\n      (\"EPS_2\", 100),\n      (\"ESP_6\", 50),\n      (\"STEERING\", 100),\n      (\"ECM_5\", 50),\n      (\"CRUISE_BUTTONS\", 50),\n      (\"STEERING_LEVERS\", 10),\n      (\"ORC_1\", 2),\n      (\"BCM_1\", 1),\n    ]\n\n    if CP.enableBsm:\n      messages.append((\"BSM_1\", 2))\n\n    if CP.carFingerprint in RAM_CARS:\n      messages += [\n        (\"ESP_8\", 50),\n        (\"EPS_3\", 50),\n        (\"Transmission_Status\", 50),\n      ]\n    else:\n      messages += [\n        (\"GEAR\", 50),\n        (\"SPEED_1\", 100),\n      ]\n      messages += CarState.get_cruise_messages()\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n\n  @staticmethod\n  def get_cam_can_parser(CP):\n    messages = [\n      (\"DAS_6\", 4),\n    ]\n\n    if CP.carFingerprint in RAM_CARS:\n      messages += CarState.get_cruise_messages()\n\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 2)\n", "selfdrive/car/chrysler/fingerprints.py": "from cereal import car\nfrom openpilot.selfdrive.car.chrysler.values import CAR\n\nEcu = car.CarParams.Ecu\n\nFW_VERSIONS = {\n  CAR.CHRYSLER_PACIFICA_2017_HYBRID: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68239262AH',\n      b'68239262AI',\n      b'68239262AJ',\n      b'68239263AH',\n      b'68239263AJ',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68238840AH',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'68226356AI',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68288309AC',\n      b'68288309AD',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'68277480AV ',\n      b'68277480AX ',\n      b'68277480AZ ',\n    ],\n    (Ecu.hybrid, 0x7e2, None): [\n      b'05190175BF',\n      b'05190175BH',\n      b'05190226AK',\n    ],\n  },\n  CAR.CHRYSLER_PACIFICA_2018: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68227902AF',\n      b'68227902AG',\n      b'68227902AH',\n      b'68227905AG',\n      b'68360252AC',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68211617AF',\n      b'68211617AG',\n      b'68358974AC',\n      b'68405937AA',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68222747AG',\n      b'68330876AA',\n      b'68330876AB',\n      b'68352227AA',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672758AA',\n      b'68226356AF',\n      b'68226356AH',\n      b'68226356AI',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68288891AE',\n      b'68378884AA',\n      b'68525338AA',\n      b'68525338AB',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'68267018AO ',\n      b'68267020AJ ',\n      b'68303534AG ',\n      b'68303534AJ ',\n      b'68340762AD ',\n      b'68340764AD ',\n      b'68352652AE ',\n      b'68352654AE ',\n      b'68366851AH ',\n      b'68366853AE ',\n      b'68372861AF ',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'68277370AJ',\n      b'68277370AM',\n      b'68277372AD',\n      b'68277372AE',\n      b'68277372AN',\n      b'68277374AA',\n      b'68277374AB',\n      b'68277374AD',\n      b'68277374AN',\n      b'68367471AC',\n      b'68380571AB',\n    ],\n  },\n  CAR.CHRYSLER_PACIFICA_2020: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68405327AC',\n      b'68436233AB',\n      b'68436233AC',\n      b'68436234AB',\n      b'68436250AE',\n      b'68529067AA',\n      b'68594993AB',\n      b'68594994AB',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68405565AB',\n      b'68405565AC',\n      b'68444299AC',\n      b'68480707AC',\n      b'68480708AC',\n      b'68526663AB',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68397394AA',\n      b'68433480AB',\n      b'68453575AF',\n      b'68577676AA',\n      b'68593395AA',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672758AA',\n      b'04672758AB',\n      b'68417813AF',\n      b'68540436AA',\n      b'68540436AC',\n      b'68540436AD',\n      b'68598670AB',\n      b'68598670AC',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68416742AA',\n      b'68460393AA',\n      b'68460393AB',\n      b'68494461AB',\n      b'68494461AC',\n      b'68524936AA',\n      b'68524936AB',\n      b'68525338AB',\n      b'68594337AB',\n      b'68594340AB',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'68413871AD ',\n      b'68413871AE ',\n      b'68413871AH ',\n      b'68413871AI ',\n      b'68413873AH ',\n      b'68413873AI ',\n      b'68443120AE ',\n      b'68443123AC ',\n      b'68443125AC ',\n      b'68496647AI ',\n      b'68496647AJ ',\n      b'68496650AH ',\n      b'68496650AI ',\n      b'68496652AH ',\n      b'68526752AD ',\n      b'68526752AE ',\n      b'68526754AE ',\n      b'68536264AE ',\n      b'68700304AB ',\n      b'68700306AB ',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'68414271AC',\n      b'68414271AD',\n      b'68414275AC',\n      b'68414275AD',\n      b'68443154AB',\n      b'68443155AC',\n      b'68443158AB',\n      b'68501050AD',\n      b'68501051AD',\n      b'68501055AD',\n      b'68527221AB',\n      b'68527223AB',\n      b'68586231AD',\n      b'68586233AD',\n    ],\n  },\n  CAR.CHRYSLER_PACIFICA_2018_HYBRID: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68358439AE',\n      b'68358439AG',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68358990AC',\n      b'68405939AA',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672758AA',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68288309AD',\n      b'68525339AA',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'68366580AI ',\n      b'68366580AK ',\n      b'68366580AM ',\n    ],\n    (Ecu.hybrid, 0x7e2, None): [\n      b'05190226AI',\n      b'05190226AK',\n      b'05190226AM',\n    ],\n  },\n  CAR.CHRYSLER_PACIFICA_2019_HYBRID: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68405292AC',\n      b'68434956AC',\n      b'68434956AD',\n      b'68434960AE',\n      b'68434960AF',\n      b'68529064AB',\n      b'68594990AB',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68405567AB',\n      b'68405567AC',\n      b'68453076AD',\n      b'68480710AC',\n      b'68526665AB',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672758AB',\n      b'68417813AF',\n      b'68540436AA',\n      b'68540436AB',\n      b'68540436AC',\n      b'68540436AD',\n      b'68598670AB',\n      b'68598670AC',\n      b'68645752AA',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68416741AA',\n      b'68460392AA',\n      b'68525339AA',\n      b'68525339AB',\n      b'68594341AB',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'68416680AE ',\n      b'68416680AF ',\n      b'68416680AG ',\n      b'68444228AD ',\n      b'68444228AE ',\n      b'68444228AF ',\n      b'68499122AD ',\n      b'68499122AE ',\n      b'68499122AF ',\n      b'68526772AD ',\n      b'68526772AH ',\n      b'68599493AC ',\n      b'68657433AA ',\n    ],\n    (Ecu.hybrid, 0x7e2, None): [\n      b'05185116AF',\n      b'05185116AJ',\n      b'05185116AK',\n      b'05190240AP',\n      b'05190240AQ',\n      b'05190240AR',\n      b'05190265AG',\n      b'05190265AH',\n      b'05190289AE',\n      b'68540977AH',\n      b'68540977AK',\n      b'68597647AE',\n      b'68632416AB',\n    ],\n  },\n  CAR.JEEP_GRAND_CHEROKEE: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68243549AG',\n      b'68302211AC',\n      b'68302212AD',\n      b'68302223AC',\n      b'68302246AC',\n      b'68331511AC',\n      b'68331574AC',\n      b'68331687AC',\n      b'68331690AC',\n      b'68340272AD',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68309533AA',\n      b'68316742AB',\n      b'68355363AB',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68252642AG',\n      b'68306178AD',\n      b'68336275AB',\n      b'68336276AB',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672627AB',\n      b'68251506AF',\n      b'68332015AB',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68276201AG',\n      b'68321644AB',\n      b'68321644AC',\n      b'68321646AC',\n      b'68321648AC',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'05035920AE ',\n      b'68252272AG ',\n      b'68284455AI ',\n      b'68284456AI ',\n      b'68284477AF ',\n      b'68325564AH ',\n      b'68325565AH ',\n      b'68325565AI ',\n      b'68325618AD ',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'05035517AH',\n      b'68253222AF',\n      b'68311218AC',\n      b'68311223AF',\n      b'68311223AG',\n      b'68361911AE',\n      b'68361911AF',\n      b'68361911AH',\n      b'68361916AD',\n    ],\n  },\n  CAR.JEEP_GRAND_CHEROKEE_2019: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68402703AB',\n      b'68402704AB',\n      b'68402708AB',\n      b'68402971AD',\n      b'68454144AD',\n      b'68454145AB',\n      b'68454152AB',\n      b'68454156AB',\n      b'68516650AB',\n      b'68516651AB',\n      b'68516669AB',\n      b'68516671AB',\n      b'68516683AB',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68355363AB',\n      b'68355364AB',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68408639AC',\n      b'68408639AD',\n      b'68499978AB',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672788AA',\n      b'68456722AC',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68417279AA',\n      b'68417280AA',\n      b'68417281AA',\n      b'68453431AA',\n      b'68453433AA',\n      b'68453435AA',\n      b'68499171AA',\n      b'68499171AB',\n      b'68501183AA',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'05035674AB ',\n      b'68412635AG ',\n      b'68412660AD ',\n      b'68422860AB',\n      b'68449435AE ',\n      b'68496223AA ',\n      b'68504959AD ',\n      b'68504959AE ',\n      b'68504960AD ',\n      b'68504993AC ',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'05035707AA',\n      b'68419672AC',\n      b'68419678AB',\n      b'68423905AB',\n      b'68449258AC',\n      b'68495807AA',\n      b'68495807AB',\n      b'68503641AC',\n      b'68503664AC',\n    ],\n  },\n  CAR.RAM_1500_5TH_GEN: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68294051AG',\n      b'68294051AI',\n      b'68294052AG',\n      b'68294052AH',\n      b'68294063AG',\n      b'68294063AH',\n      b'68294063AI',\n      b'68434846AC',\n      b'68434847AC',\n      b'68434849AC',\n      b'68434856AC',\n      b'68434858AC',\n      b'68434859AC',\n      b'68434860AC',\n      b'68453483AC',\n      b'68453483AD',\n      b'68453487AD',\n      b'68453491AC',\n      b'68453491AD',\n      b'68453499AD',\n      b'68453503AC',\n      b'68453503AD',\n      b'68453505AC',\n      b'68453505AD',\n      b'68453511AC',\n      b'68453513AC',\n      b'68453513AD',\n      b'68453514AD',\n      b'68505633AB',\n      b'68510277AG',\n      b'68510277AH',\n      b'68510280AG',\n      b'68510282AG',\n      b'68510282AH',\n      b'68510283AG',\n      b'68527346AE',\n      b'68527361AD',\n      b'68527375AD',\n      b'68527381AE',\n      b'68527382AE',\n      b'68527383AD',\n      b'68527383AE',\n      b'68527387AE',\n      b'68527403AC',\n      b'68527403AD',\n      b'68546047AF',\n      b'68631938AA',\n      b'68631939AA',\n      b'68631940AA',\n      b'68631940AB',\n      b'68631942AA',\n      b'68631943AB',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68428609AB',\n      b'68441329AB',\n      b'68473844AB',\n      b'68490898AA',\n      b'68500728AA',\n      b'68615033AA',\n      b'68615034AA',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68292406AG',\n      b'68292406AH',\n      b'68432418AB',\n      b'68432418AC',\n      b'68432418AD',\n      b'68436004AD',\n      b'68436004AE',\n      b'68438454AC',\n      b'68438454AD',\n      b'68438456AE',\n      b'68438456AF',\n      b'68535469AB',\n      b'68535470AC',\n      b'68548900AB',\n      b'68586307AB',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672892AB',\n      b'04672932AB',\n      b'04672932AC',\n      b'22DTRHD_AA',\n      b'68320950AH',\n      b'68320950AI',\n      b'68320950AJ',\n      b'68320950AL',\n      b'68320950AM',\n      b'68454268AB',\n      b'68475160AE',\n      b'68475160AF',\n      b'68475160AG',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'21590101AA',\n      b'21590101AB',\n      b'68273275AF',\n      b'68273275AG',\n      b'68273275AH',\n      b'68312176AE',\n      b'68312176AG',\n      b'68440789AC',\n      b'68466110AA',\n      b'68466110AB',\n      b'68466113AA',\n      b'68469901AA',\n      b'68469907AA',\n      b'68522583AA',\n      b'68522583AB',\n      b'68522584AA',\n      b'68522585AB',\n      b'68552788AA',\n      b'68552789AA',\n      b'68552790AA',\n      b'68552791AB',\n      b'68552794AA',\n      b'68552794AD',\n      b'68585106AB',\n      b'68585107AB',\n      b'68585108AB',\n      b'68585109AB',\n      b'68585112AB',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'05035699AG ',\n      b'05035841AC ',\n      b'05035841AD ',\n      b'05036026AB ',\n      b'05036065AE ',\n      b'05036066AE ',\n      b'05036193AA ',\n      b'05149368AA ',\n      b'05149591AD ',\n      b'05149591AE ',\n      b'05149592AE ',\n      b'05149599AE ',\n      b'05149600AD ',\n      b'05149605AE ',\n      b'05149846AA ',\n      b'05149848AA ',\n      b'05149848AC ',\n      b'05190341AD',\n      b'68378695AJ ',\n      b'68378696AJ ',\n      b'68378696AK ',\n      b'68378701AI ',\n      b'68378702AI ',\n      b'68378710AL ',\n      b'68378742AI ',\n      b'68378742AK ',\n      b'68378748AL ',\n      b'68378758AM ',\n      b'68448163AJ',\n      b'68448163AK',\n      b'68448163AL',\n      b'68448165AG',\n      b'68448165AK',\n      b'68455111AC ',\n      b'68455119AC ',\n      b'68455145AC ',\n      b'68455145AE ',\n      b'68455146AC ',\n      b'68467915AC ',\n      b'68467916AC ',\n      b'68467936AC ',\n      b'68500630AD',\n      b'68500630AE',\n      b'68500631AE',\n      b'68502719AC ',\n      b'68502722AC ',\n      b'68502733AC ',\n      b'68502734AF ',\n      b'68502740AF ',\n      b'68502741AF ',\n      b'68502742AC ',\n      b'68502742AF ',\n      b'68539650AD',\n      b'68539650AF',\n      b'68539651AD',\n      b'68586101AA ',\n      b'68586105AB ',\n      b'68629919AC ',\n      b'68629922AC ',\n      b'68629925AC ',\n      b'68629926AC ',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'05035706AD',\n      b'05035842AB',\n      b'05036069AA',\n      b'05036181AA',\n      b'05149536AC',\n      b'05149537AC',\n      b'05149543AC',\n      b'68360078AL',\n      b'68360080AL',\n      b'68360080AM',\n      b'68360081AM',\n      b'68360085AJ',\n      b'68360085AL',\n      b'68360086AH',\n      b'68360086AK',\n      b'68384328AD',\n      b'68384332AD',\n      b'68445531AC',\n      b'68445533AB',\n      b'68445536AB',\n      b'68445537AB',\n      b'68466081AB',\n      b'68466087AB',\n      b'68484466AC',\n      b'68484467AC',\n      b'68484471AC',\n      b'68502994AD',\n      b'68502996AD',\n      b'68520867AE',\n      b'68520867AF',\n      b'68520870AC',\n      b'68540431AB',\n      b'68540433AB',\n      b'68551676AA',\n      b'68629935AB',\n      b'68629936AC',\n    ],\n  },\n  CAR.RAM_HD_5TH_GEN: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68361606AH',\n      b'68437735AC',\n      b'68492693AD',\n      b'68525485AB',\n      b'68525487AB',\n      b'68525498AB',\n      b'68528791AF',\n      b'68628474AB',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68399794AC',\n      b'68428503AA',\n      b'68428505AA',\n      b'68428507AA',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68334977AH',\n      b'68455481AC',\n      b'68504022AA',\n      b'68504022AB',\n      b'68504022AC',\n      b'68530686AB',\n      b'68530686AC',\n      b'68544596AC',\n      b'68641704AA',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'04672895AB',\n      b'04672934AB',\n      b'56029827AG',\n      b'56029827AH',\n      b'68462657AE',\n      b'68484694AD',\n      b'68484694AE',\n      b'68615489AB',\n    ],\n    (Ecu.eps, 0x761, None): [\n      b'68421036AC',\n      b'68507906AB',\n      b'68534023AC',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'52370131AF',\n      b'52370231AF',\n      b'52370231AG',\n      b'52370491AA',\n      b'52370931CT',\n      b'52401032AE',\n      b'52421132AF',\n      b'52421332AF',\n      b'68527616AD ',\n      b'M2370131MB',\n      b'M2421132MB',\n    ],\n  },\n  CAR.DODGE_DURANGO: {\n    (Ecu.combinationMeter, 0x742, None): [\n      b'68454261AD',\n      b'68471535AE',\n    ],\n    (Ecu.srs, 0x744, None): [\n      b'68355362AB',\n      b'68492238AD',\n    ],\n    (Ecu.abs, 0x747, None): [\n      b'68408639AD',\n      b'68499978AB',\n    ],\n    (Ecu.fwdRadar, 0x753, None): [\n      b'68440581AE',\n      b'68456722AC',\n    ],\n    (Ecu.eps, 0x75a, None): [\n      b'68453435AA',\n      b'68498477AA',\n    ],\n    (Ecu.engine, 0x7e0, None): [\n      b'05035786AE ',\n      b'68449476AE ',\n    ],\n    (Ecu.transmission, 0x7e1, None): [\n      b'05035826AC',\n      b'68449265AC',\n    ],\n  },\n}\n", "selfdrive/car/chrysler/values.py": "from enum import IntFlag\nfrom dataclasses import dataclass, field\n\nfrom cereal import car\nfrom panda.python import uds\nfrom openpilot.selfdrive.car import CarSpecs, DbcDict, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarHarness, CarDocs, CarParts\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, p16\n\nEcu = car.CarParams.Ecu\n\n\nclass ChryslerFlags(IntFlag):\n  # Detected flags\n  HIGHER_MIN_STEERING_SPEED = 1\n\n@dataclass\nclass ChryslerCarDocs(CarDocs):\n  package: str = \"Adaptive Cruise Control (ACC)\"\n  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.fca]))\n\n\n@dataclass\nclass ChryslerPlatformConfig(PlatformConfig):\n  dbc_dict: DbcDict = field(default_factory=lambda: dbc_dict('chrysler_pacifica_2017_hybrid_generated', 'chrysler_pacifica_2017_hybrid_private_fusion'))\n\n\n@dataclass(frozen=True)\nclass ChryslerCarSpecs(CarSpecs):\n  minSteerSpeed: float = 3.8  # m/s\n\n\nclass CAR(Platforms):\n  # Chrysler\n  CHRYSLER_PACIFICA_2017_HYBRID = ChryslerPlatformConfig(\n    [ChryslerCarDocs(\"Chrysler Pacifica Hybrid 2017\")],\n    ChryslerCarSpecs(mass=2242., wheelbase=3.089, steerRatio=16.2),\n  )\n  CHRYSLER_PACIFICA_2018_HYBRID = ChryslerPlatformConfig(\n    [ChryslerCarDocs(\"Chrysler Pacifica Hybrid 2018\")],\n    CHRYSLER_PACIFICA_2017_HYBRID.specs,\n  )\n  CHRYSLER_PACIFICA_2019_HYBRID = ChryslerPlatformConfig(\n    [ChryslerCarDocs(\"Chrysler Pacifica Hybrid 2019-24\")],\n    CHRYSLER_PACIFICA_2017_HYBRID.specs,\n  )\n  CHRYSLER_PACIFICA_2018 = ChryslerPlatformConfig(\n    [ChryslerCarDocs(\"Chrysler Pacifica 2017-18\")],\n    CHRYSLER_PACIFICA_2017_HYBRID.specs,\n  )\n  CHRYSLER_PACIFICA_2020 = ChryslerPlatformConfig(\n    [\n      ChryslerCarDocs(\"Chrysler Pacifica 2019-20\"),\n      ChryslerCarDocs(\"Chrysler Pacifica 2021-23\", package=\"All\"),\n    ],\n    CHRYSLER_PACIFICA_2017_HYBRID.specs,\n  )\n\n  # Dodge\n  DODGE_DURANGO = ChryslerPlatformConfig(\n    [ChryslerCarDocs(\"Dodge Durango 2020-21\")],\n    CHRYSLER_PACIFICA_2017_HYBRID.specs,\n  )\n\n  # Jeep\n  JEEP_GRAND_CHEROKEE = ChryslerPlatformConfig(  # includes 2017 Trailhawk\n    [ChryslerCarDocs(\"Jeep Grand Cherokee 2016-18\", video_link=\"https://www.youtube.com/watch?v=eLR9o2JkuRk\")],\n    ChryslerCarSpecs(mass=1778., wheelbase=2.71, steerRatio=16.7),\n  )\n\n  JEEP_GRAND_CHEROKEE_2019 = ChryslerPlatformConfig(  # includes 2020 Trailhawk\n    [ChryslerCarDocs(\"Jeep Grand Cherokee 2019-21\", video_link=\"https://www.youtube.com/watch?v=jBe4lWnRSu4\")],\n    JEEP_GRAND_CHEROKEE.specs,\n  )\n\n  # Ram\n  RAM_1500_5TH_GEN = ChryslerPlatformConfig(\n    [ChryslerCarDocs(\"Ram 1500 2019-24\", car_parts=CarParts.common([CarHarness.ram]))],\n    ChryslerCarSpecs(mass=2493., wheelbase=3.88, steerRatio=16.3, minSteerSpeed=14.5),\n    dbc_dict('chrysler_ram_dt_generated', None),\n  )\n  RAM_HD_5TH_GEN = ChryslerPlatformConfig(\n    [\n      ChryslerCarDocs(\"Ram 2500 2020-24\", car_parts=CarParts.common([CarHarness.ram])),\n      ChryslerCarDocs(\"Ram 3500 2019-22\", car_parts=CarParts.common([CarHarness.ram])),\n    ],\n    ChryslerCarSpecs(mass=3405., wheelbase=3.785, steerRatio=15.61, minSteerSpeed=16.),\n    dbc_dict('chrysler_ram_hd_generated', None),\n  )\n\n\nclass CarControllerParams:\n  def __init__(self, CP):\n    self.STEER_STEP = 2  # 50 Hz\n    self.STEER_ERROR_MAX = 80\n    if CP.carFingerprint in RAM_HD:\n      self.STEER_DELTA_UP = 14\n      self.STEER_DELTA_DOWN = 14\n      self.STEER_MAX = 361  # higher than this faults the EPS\n    elif CP.carFingerprint in RAM_DT:\n      self.STEER_DELTA_UP = 6\n      self.STEER_DELTA_DOWN = 6\n      self.STEER_MAX = 261  # EPS allows more, up to 350?\n    else:\n      self.STEER_DELTA_UP = 3\n      self.STEER_DELTA_DOWN = 3\n      self.STEER_MAX = 261  # higher than this faults the EPS\n\n\nSTEER_THRESHOLD = 120\n\nRAM_DT = {CAR.RAM_1500_5TH_GEN, }\nRAM_HD = {CAR.RAM_HD_5TH_GEN, }\nRAM_CARS = RAM_DT | RAM_HD\n\n\nCHRYSLER_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(0xf132)\nCHRYSLER_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n  p16(0xf132)\n\nCHRYSLER_SOFTWARE_VERSION_REQUEST = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER]) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.SYSTEM_SUPPLIER_ECU_SOFTWARE_NUMBER)\nCHRYSLER_SOFTWARE_VERSION_RESPONSE = bytes([uds.SERVICE_TYPE.READ_DATA_BY_IDENTIFIER + 0x40]) + \\\n  p16(uds.DATA_IDENTIFIER_TYPE.SYSTEM_SUPPLIER_ECU_SOFTWARE_NUMBER)\n\nCHRYSLER_RX_OFFSET = -0x280\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    Request(\n      [CHRYSLER_VERSION_REQUEST],\n      [CHRYSLER_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.eps, Ecu.srs, Ecu.fwdRadar, Ecu.fwdCamera, Ecu.combinationMeter],\n      rx_offset=CHRYSLER_RX_OFFSET,\n      bus=0,\n    ),\n    Request(\n      [CHRYSLER_VERSION_REQUEST],\n      [CHRYSLER_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.abs, Ecu.hybrid, Ecu.engine, Ecu.transmission],\n      bus=0,\n    ),\n    Request(\n      [CHRYSLER_SOFTWARE_VERSION_REQUEST],\n      [CHRYSLER_SOFTWARE_VERSION_RESPONSE],\n      whitelist_ecus=[Ecu.engine, Ecu.transmission],\n      bus=0,\n    ),\n  ],\n  extra_ecus=[\n    (Ecu.abs, 0x7e4, None),  # alt address for abs on hybrids, NOTE: not on all hybrid platforms\n  ],\n)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/chrysler/carcontroller.py": "from opendbc.can.packer import CANPacker\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.car import apply_meas_steer_torque_limits\nfrom openpilot.selfdrive.car.chrysler import chryslercan\nfrom openpilot.selfdrive.car.chrysler.values import RAM_CARS, CarControllerParams, ChryslerFlags\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.CP = CP\n    self.apply_steer_last = 0\n    self.frame = 0\n\n    self.hud_count = 0\n    self.last_lkas_falling_edge = 0\n    self.lkas_control_bit_prev = False\n    self.last_button_frame = 0\n\n    self.packer = CANPacker(dbc_name)\n    self.params = CarControllerParams(CP)\n\n  def update(self, CC, CS, now_nanos):\n    can_sends = []\n\n    lkas_active = CC.latActive and self.lkas_control_bit_prev\n\n    # cruise buttons\n    if (self.frame - self.last_button_frame)*DT_CTRL > 0.05:\n      das_bus = 2 if self.CP.carFingerprint in RAM_CARS else 0\n\n      # ACC cancellation\n      if CC.cruiseControl.cancel:\n        self.last_button_frame = self.frame\n        can_sends.append(chryslercan.create_cruise_buttons(self.packer, CS.button_counter + 1, das_bus, cancel=True))\n\n      # ACC resume from standstill\n      elif CC.cruiseControl.resume:\n        self.last_button_frame = self.frame\n        can_sends.append(chryslercan.create_cruise_buttons(self.packer, CS.button_counter + 1, das_bus, resume=True))\n\n    # HUD alerts\n    if self.frame % 25 == 0:\n      if CS.lkas_car_model != -1:\n        can_sends.append(chryslercan.create_lkas_hud(self.packer, self.CP, lkas_active, CC.hudControl.visualAlert,\n                                                     self.hud_count, CS.lkas_car_model, CS.auto_high_beam))\n        self.hud_count += 1\n\n    # steering\n    if self.frame % self.params.STEER_STEP == 0:\n\n      # TODO: can we make this more sane? why is it different for all the cars?\n      lkas_control_bit = self.lkas_control_bit_prev\n      if CS.out.vEgo > self.CP.minSteerSpeed:\n        lkas_control_bit = True\n      elif self.CP.flags & ChryslerFlags.HIGHER_MIN_STEERING_SPEED:\n        if CS.out.vEgo < (self.CP.minSteerSpeed - 3.0):\n          lkas_control_bit = False\n      elif self.CP.carFingerprint in RAM_CARS:\n        if CS.out.vEgo < (self.CP.minSteerSpeed - 0.5):\n          lkas_control_bit = False\n\n      # EPS faults if LKAS re-enables too quickly\n      lkas_control_bit = lkas_control_bit and (self.frame - self.last_lkas_falling_edge > 200)\n\n      if not lkas_control_bit and self.lkas_control_bit_prev:\n        self.last_lkas_falling_edge = self.frame\n      self.lkas_control_bit_prev = lkas_control_bit\n\n      # steer torque\n      new_steer = int(round(CC.actuators.steer * self.params.STEER_MAX))\n      apply_steer = apply_meas_steer_torque_limits(new_steer, self.apply_steer_last, CS.out.steeringTorqueEps, self.params)\n      if not lkas_active or not lkas_control_bit:\n        apply_steer = 0\n      self.apply_steer_last = apply_steer\n\n      can_sends.append(chryslercan.create_lkas_command(self.packer, self.CP, int(apply_steer), lkas_control_bit))\n\n    self.frame += 1\n\n    new_actuators = CC.actuators.as_builder()\n    new_actuators.steer = self.apply_steer_last / self.params.STEER_MAX\n    new_actuators.steerOutputCan = self.apply_steer_last\n\n    return new_actuators, can_sends\n", "selfdrive/car/chrysler/radar_interface.py": "#!/usr/bin/env python3\nfrom opendbc.can.parser import CANParser\nfrom cereal import car\nfrom openpilot.selfdrive.car.interfaces import RadarInterfaceBase\nfrom openpilot.selfdrive.car.chrysler.values import DBC\n\nRADAR_MSGS_C = list(range(0x2c2, 0x2d4+2, 2))  # c_ messages 706,...,724\nRADAR_MSGS_D = list(range(0x2a2, 0x2b4+2, 2))  # d_ messages\nLAST_MSG = max(RADAR_MSGS_C + RADAR_MSGS_D)\nNUMBER_MSGS = len(RADAR_MSGS_C) + len(RADAR_MSGS_D)\n\ndef _create_radar_can_parser(car_fingerprint):\n  dbc = DBC[car_fingerprint]['radar']\n  if dbc is None:\n    return None\n\n  msg_n = len(RADAR_MSGS_C)\n  # list of [(signal name, message name or number), (...)]\n  # [('RADAR_STATE', 1024),\n  #  ('LONG_DIST', 1072),\n  #  ('LONG_DIST', 1073),\n  #  ('LONG_DIST', 1074),\n  #  ('LONG_DIST', 1075),\n\n  messages = list(zip(RADAR_MSGS_C +\n                      RADAR_MSGS_D,\n                      [20] * msg_n +  # 20Hz (0.05s)\n                      [20] * msg_n, strict=True))  # 20Hz (0.05s)\n\n  return CANParser(DBC[car_fingerprint]['radar'], messages, 1)\n\ndef _address_to_track(address):\n  if address in RADAR_MSGS_C:\n    return (address - RADAR_MSGS_C[0]) // 2\n  if address in RADAR_MSGS_D:\n    return (address - RADAR_MSGS_D[0]) // 2\n  raise ValueError(\"radar received unexpected address %d\" % address)\n\nclass RadarInterface(RadarInterfaceBase):\n  def __init__(self, CP):\n    super().__init__(CP)\n    self.CP = CP\n    self.rcp = _create_radar_can_parser(CP.carFingerprint)\n    self.updated_messages = set()\n    self.trigger_msg = LAST_MSG\n\n  def update(self, can_strings):\n    if self.rcp is None or self.CP.radarUnavailable:\n      return super().update(None)\n\n    vls = self.rcp.update_strings(can_strings)\n    self.updated_messages.update(vls)\n\n    if self.trigger_msg not in self.updated_messages:\n      return None\n\n    ret = car.RadarData.new_message()\n    errors = []\n    if not self.rcp.can_valid:\n      errors.append(\"canError\")\n    ret.errors = errors\n\n    for ii in self.updated_messages:  # ii should be the message ID as a number\n      cpt = self.rcp.vl[ii]\n      trackId = _address_to_track(ii)\n\n      if trackId not in self.pts:\n        self.pts[trackId] = car.RadarData.RadarPoint.new_message()\n        self.pts[trackId].trackId = trackId\n        self.pts[trackId].aRel = float('nan')\n        self.pts[trackId].yvRel = float('nan')\n        self.pts[trackId].measured = True\n\n      if 'LONG_DIST' in cpt:  # c_* message\n        self.pts[trackId].dRel = cpt['LONG_DIST']  # from front of car\n        # our lat_dist is positive to the right in car's frame.\n        # TODO what does yRel want?\n        self.pts[trackId].yRel = cpt['LAT_DIST']  # in car frame's y axis, left is positive\n      else:  # d_* message\n        self.pts[trackId].vRel = cpt['REL_SPEED']\n\n    # We want a list, not a dictionary. Filter out LONG_DIST==0 because that means it's not valid.\n    ret.points = [x for x in self.pts.values() if x.dRel != 0]\n\n    self.updated_messages.clear()\n    return ret\n", "selfdrive/car/chrysler/__init__.py": "", "selfdrive/car/chrysler/interface.py": "#!/usr/bin/env python3\nfrom cereal import car\nfrom panda import Panda\nfrom openpilot.selfdrive.car import create_button_events, get_safety_config\nfrom openpilot.selfdrive.car.chrysler.values import CAR, RAM_HD, RAM_DT, RAM_CARS, ChryslerFlags\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\n\nButtonType = car.CarState.ButtonEvent.Type\n\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.carName = \"chrysler\"\n    ret.dashcamOnly = candidate in RAM_HD\n\n    # radar parsing needs some work, see https://github.com/commaai/openpilot/issues/26842\n    ret.radarUnavailable = True # DBC[candidate]['radar'] is None\n    ret.steerActuatorDelay = 0.1\n    ret.steerLimitTimer = 0.4\n\n    # safety config\n    ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.chrysler)]\n    if candidate in RAM_HD:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_CHRYSLER_RAM_HD\n    elif candidate in RAM_DT:\n      ret.safetyConfigs[0].safetyParam |= Panda.FLAG_CHRYSLER_RAM_DT\n\n    CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)\n    if candidate not in RAM_CARS:\n      # Newer FW versions standard on the following platforms, or flashed by a dealer onto older platforms have a higher minimum steering speed.\n      new_eps_platform = candidate in (CAR.CHRYSLER_PACIFICA_2019_HYBRID, CAR.CHRYSLER_PACIFICA_2020, CAR.JEEP_GRAND_CHEROKEE_2019, CAR.DODGE_DURANGO)\n      new_eps_firmware = any(fw.ecu == 'eps' and fw.fwVersion[:4] >= b\"6841\" for fw in car_fw)\n      if new_eps_platform or new_eps_firmware:\n        ret.flags |= ChryslerFlags.HIGHER_MIN_STEERING_SPEED.value\n\n    # Chrysler\n    if candidate in (CAR.CHRYSLER_PACIFICA_2017_HYBRID, CAR.CHRYSLER_PACIFICA_2018, CAR.CHRYSLER_PACIFICA_2018_HYBRID, \\\n                     CAR.CHRYSLER_PACIFICA_2019_HYBRID, CAR.CHRYSLER_PACIFICA_2020, CAR.DODGE_DURANGO):\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kpBP, ret.lateralTuning.pid.kiBP = [[9., 20.], [9., 20.]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.15, 0.30], [0.03, 0.05]]\n      ret.lateralTuning.pid.kf = 0.00006\n\n    # Jeep\n    elif candidate in (CAR.JEEP_GRAND_CHEROKEE, CAR.JEEP_GRAND_CHEROKEE_2019):\n      ret.steerActuatorDelay = 0.2\n\n      ret.lateralTuning.init('pid')\n      ret.lateralTuning.pid.kpBP, ret.lateralTuning.pid.kiBP = [[9., 20.], [9., 20.]]\n      ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.15, 0.30], [0.03, 0.05]]\n      ret.lateralTuning.pid.kf = 0.00006\n\n    # Ram\n    elif candidate == CAR.RAM_1500_5TH_GEN:\n      ret.steerActuatorDelay = 0.2\n      ret.wheelbase = 3.88\n      # Older EPS FW allow steer to zero\n      if any(fw.ecu == 'eps' and b\"68\" < fw.fwVersion[:4] <= b\"6831\" for fw in car_fw):\n        ret.minSteerSpeed = 0.\n\n    elif candidate == CAR.RAM_HD_5TH_GEN:\n      ret.steerActuatorDelay = 0.2\n      CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning, 1.0, False)\n\n    else:\n      raise ValueError(f\"Unsupported car: {candidate}\")\n\n    if ret.flags & ChryslerFlags.HIGHER_MIN_STEERING_SPEED:\n      # TODO: allow these cars to steer down to 13 m/s if already engaged.\n      # TODO: Durango 2020 may be able to steer to zero once above 38 kph\n      ret.minSteerSpeed = 17.5  # m/s 17 on the way up, 13 on the way down once engaged.\n\n    ret.centerToFront = ret.wheelbase * 0.44\n    ret.enableBsm = 720 in fingerprint[0]\n\n    return ret\n\n  def _update(self, c):\n    ret = self.CS.update(self.cp, self.cp_cam)\n\n    ret.buttonEvents = create_button_events(self.CS.distance_button, self.CS.prev_distance_button, {1: ButtonType.gapAdjustCruise})\n\n    # events\n    events = self.create_common_events(ret, extra_gears=[car.CarState.GearShifter.low])\n\n    # Low speed steer alert hysteresis logic\n    if self.CP.minSteerSpeed > 0. and ret.vEgo < (self.CP.minSteerSpeed + 0.5):\n      self.low_speed_alert = True\n    elif ret.vEgo > (self.CP.minSteerSpeed + 1.):\n      self.low_speed_alert = False\n    if self.low_speed_alert:\n      events.add(car.CarEvent.EventName.belowSteerSpeed)\n\n    ret.events = events.to_msg()\n\n    return ret\n", "selfdrive/car/body/bodycan.py": "def create_control(packer, torque_l, torque_r):\n  values = {\n    \"TORQUE_L\": torque_l,\n    \"TORQUE_R\": torque_r,\n  }\n\n  return packer.make_can_msg(\"TORQUE_CMD\", 0, values)\n", "selfdrive/car/body/carstate.py": "from cereal import car\nfrom opendbc.can.parser import CANParser\nfrom openpilot.selfdrive.car.interfaces import CarStateBase\nfrom openpilot.selfdrive.car.body.values import DBC\n\nSTARTUP_TICKS = 100\n\nclass CarState(CarStateBase):\n  def update(self, cp):\n    ret = car.CarState.new_message()\n\n    ret.wheelSpeeds.fl = cp.vl['MOTORS_DATA']['SPEED_L']\n    ret.wheelSpeeds.fr = cp.vl['MOTORS_DATA']['SPEED_R']\n\n    ret.vEgoRaw = ((ret.wheelSpeeds.fl + ret.wheelSpeeds.fr) / 2.) * self.CP.wheelSpeedFactor\n\n    ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)\n    ret.standstill = False\n\n    ret.steerFaultPermanent = any([cp.vl['VAR_VALUES']['MOTOR_ERR_L'], cp.vl['VAR_VALUES']['MOTOR_ERR_R'],\n                                   cp.vl['VAR_VALUES']['FAULT']])\n\n    ret.charging = cp.vl[\"BODY_DATA\"][\"CHARGER_CONNECTED\"] == 1\n    ret.fuelGauge = cp.vl[\"BODY_DATA\"][\"BATT_PERCENTAGE\"] / 100\n\n    # irrelevant for non-car\n    ret.gearShifter = car.CarState.GearShifter.drive\n    ret.cruiseState.enabled = True\n    ret.cruiseState.available = True\n\n    return ret\n\n  @staticmethod\n  def get_can_parser(CP):\n    messages = [\n      (\"MOTORS_DATA\", 100),\n      (\"VAR_VALUES\", 10),\n      (\"BODY_DATA\", 1),\n    ]\n    return CANParser(DBC[CP.carFingerprint][\"pt\"], messages, 0)\n", "selfdrive/car/body/fingerprints.py": "# ruff: noqa: E501\nfrom cereal import car\nfrom openpilot.selfdrive.car.body.values import CAR\n\nEcu = car.CarParams.Ecu\n\n# debug ecu fw version is the git hash of the firmware\n\n\nFINGERPRINTS = {\n  CAR.COMMA_BODY: [{\n    513: 8, 516: 8, 514: 3, 515: 4\n  }],\n}\n\nFW_VERSIONS = {\n  CAR.COMMA_BODY: {\n    (Ecu.engine, 0x720, None): [\n      b'0.0.01',\n      b'0.3.00a',\n      b'02/27/2022',\n    ],\n    (Ecu.debug, 0x721, None): [\n      b'166bd860',\n      b'dc780f85',\n    ],\n  },\n}\n", "selfdrive/car/body/values.py": "from cereal import car\nfrom openpilot.selfdrive.car import CarSpecs, PlatformConfig, Platforms, dbc_dict\nfrom openpilot.selfdrive.car.docs_definitions import CarDocs\nfrom openpilot.selfdrive.car.fw_query_definitions import FwQueryConfig, Request, StdQueries\n\nEcu = car.CarParams.Ecu\n\nSPEED_FROM_RPM = 0.008587\n\n\nclass CarControllerParams:\n  ANGLE_DELTA_BP = [0., 5., 15.]\n  ANGLE_DELTA_V = [5., .8, .15]     # windup limit\n  ANGLE_DELTA_VU = [5., 3.5, 0.4]   # unwind limit\n  LKAS_MAX_TORQUE = 1               # A value of 1 is easy to overpower\n  STEER_THRESHOLD = 1.0\n\n  def __init__(self, CP):\n    pass\n\n\nclass CAR(Platforms):\n  COMMA_BODY = PlatformConfig(\n    [CarDocs(\"comma body\", package=\"All\")],\n    CarSpecs(mass=9, wheelbase=0.406, steerRatio=0.5, centerToFrontRatio=0.44),\n    dbc_dict('comma_body', None),\n  )\n\n\nFW_QUERY_CONFIG = FwQueryConfig(\n  requests=[\n    Request(\n      [StdQueries.TESTER_PRESENT_REQUEST, StdQueries.UDS_VERSION_REQUEST],\n      [StdQueries.TESTER_PRESENT_RESPONSE, StdQueries.UDS_VERSION_RESPONSE],\n      bus=0,\n    ),\n  ],\n)\n\nDBC = CAR.create_dbc_map()\n", "selfdrive/car/body/carcontroller.py": "import numpy as np\n\nfrom openpilot.common.realtime import DT_CTRL\nfrom opendbc.can.packer import CANPacker\nfrom openpilot.selfdrive.car.body import bodycan\nfrom openpilot.selfdrive.car.body.values import SPEED_FROM_RPM\nfrom openpilot.selfdrive.car.interfaces import CarControllerBase\nfrom openpilot.selfdrive.controls.lib.pid import PIDController\n\n\nMAX_TORQUE = 500\nMAX_TORQUE_RATE = 50\nMAX_ANGLE_ERROR = np.radians(7)\nMAX_POS_INTEGRATOR = 0.2   # meters\nMAX_TURN_INTEGRATOR = 0.1  # meters\n\n\nclass CarController(CarControllerBase):\n  def __init__(self, dbc_name, CP, VM):\n    self.frame = 0\n    self.packer = CANPacker(dbc_name)\n\n    # PIDs\n    self.turn_pid = PIDController(110, k_i=11.5, rate=1/DT_CTRL)\n    self.wheeled_speed_pid = PIDController(110, k_i=11.5, rate=1/DT_CTRL)\n\n    self.torque_r_filtered = 0.\n    self.torque_l_filtered = 0.\n\n  @staticmethod\n  def deadband_filter(torque, deadband):\n    if torque > 0:\n      torque += deadband\n    else:\n      torque -= deadband\n    return torque\n\n  def update(self, CC, CS, now_nanos):\n\n    torque_l = 0\n    torque_r = 0\n\n    llk_valid = len(CC.orientationNED) > 1 and len(CC.angularVelocity) > 1\n    if CC.enabled and llk_valid:\n      # Read these from the joystick\n      # TODO: this isn't acceleration, okay?\n      speed_desired = CC.actuators.accel / 5.\n      speed_diff_desired = -CC.actuators.steer / 2.\n\n      speed_measured = SPEED_FROM_RPM * (CS.out.wheelSpeeds.fl + CS.out.wheelSpeeds.fr) / 2.\n      speed_error = speed_desired - speed_measured\n\n      torque = self.wheeled_speed_pid.update(speed_error, freeze_integrator=False)\n\n      speed_diff_measured = SPEED_FROM_RPM * (CS.out.wheelSpeeds.fl - CS.out.wheelSpeeds.fr)\n      turn_error = speed_diff_measured - speed_diff_desired\n      freeze_integrator = ((turn_error < 0 and self.turn_pid.error_integral <= -MAX_TURN_INTEGRATOR) or\n                           (turn_error > 0 and self.turn_pid.error_integral >= MAX_TURN_INTEGRATOR))\n      torque_diff = self.turn_pid.update(turn_error, freeze_integrator=freeze_integrator)\n\n      # Combine 2 PIDs outputs\n      torque_r = torque + torque_diff\n      torque_l = torque - torque_diff\n\n      # Torque rate limits\n      self.torque_r_filtered = np.clip(self.deadband_filter(torque_r, 10),\n                                       self.torque_r_filtered - MAX_TORQUE_RATE,\n                                       self.torque_r_filtered + MAX_TORQUE_RATE)\n      self.torque_l_filtered = np.clip(self.deadband_filter(torque_l, 10),\n                                       self.torque_l_filtered - MAX_TORQUE_RATE,\n                                       self.torque_l_filtered + MAX_TORQUE_RATE)\n      torque_r = int(np.clip(self.torque_r_filtered, -MAX_TORQUE, MAX_TORQUE))\n      torque_l = int(np.clip(self.torque_l_filtered, -MAX_TORQUE, MAX_TORQUE))\n\n    can_sends = []\n    can_sends.append(bodycan.create_control(self.packer, torque_l, torque_r))\n\n    new_actuators = CC.actuators.as_builder()\n    new_actuators.accel = torque_l\n    new_actuators.steer = torque_r\n    new_actuators.steerOutputCan = torque_r\n\n    self.frame += 1\n    return new_actuators, can_sends\n", "selfdrive/car/body/radar_interface.py": "from openpilot.selfdrive.car.interfaces import RadarInterfaceBase\n\nclass RadarInterface(RadarInterfaceBase):\n  pass\n", "selfdrive/car/body/__init__.py": "", "selfdrive/car/body/interface.py": "import math\nfrom cereal import car\nfrom openpilot.common.realtime import DT_CTRL\nfrom openpilot.selfdrive.car import get_safety_config\nfrom openpilot.selfdrive.car.interfaces import CarInterfaceBase\nfrom openpilot.selfdrive.car.body.values import SPEED_FROM_RPM\n\nclass CarInterface(CarInterfaceBase):\n  @staticmethod\n  def _get_params(ret, candidate, fingerprint, car_fw, experimental_long, docs):\n    ret.notCar = True\n    ret.carName = \"body\"\n    ret.safetyConfigs = [get_safety_config(car.CarParams.SafetyModel.body)]\n\n    ret.minSteerSpeed = -math.inf\n    ret.maxLateralAccel = math.inf  # TODO: set to a reasonable value\n    ret.steerLimitTimer = 1.0\n    ret.steerActuatorDelay = 0.\n\n    ret.wheelSpeedFactor = SPEED_FROM_RPM\n\n    ret.radarUnavailable = True\n    ret.openpilotLongitudinalControl = True\n    ret.steerControlType = car.CarParams.SteerControlType.angle\n\n    return ret\n\n  def _update(self, c):\n    ret = self.CS.update(self.cp)\n\n    # wait for everything to init first\n    if self.frame > int(5. / DT_CTRL):\n      # body always wants to enable\n      ret.init('events', 1)\n      ret.events[0].name = car.CarEvent.EventName.pcmEnable\n      ret.events[0].enable = True\n    self.frame += 1\n\n    return ret\n", "selfdrive/monitoring/helpers.py": "from math import atan2\n\nfrom cereal import car\nimport cereal.messaging as messaging\nfrom openpilot.selfdrive.controls.lib.events import Events\nfrom openpilot.common.numpy_fast import interp\nfrom openpilot.common.realtime import DT_DMON\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.stat_live import RunningStatFilter\nfrom openpilot.common.transformations.camera import DEVICE_CAMERAS\n\nEventName = car.CarEvent.EventName\n\n# ******************************************************************************************\n#  NOTE: To fork maintainers.\n#  Disabling or nerfing safety features will get you and your users banned from our servers.\n#  We recommend that you do not change these numbers from the defaults.\n# ******************************************************************************************\n\nclass DRIVER_MONITOR_SETTINGS:\n  def __init__(self):\n    self._DT_DMON = DT_DMON\n    # ref (page15-16): https://eur-lex.europa.eu/legal-content/EN/TXT/PDF/?uri=CELEX:42018X1947&rid=2\n    self._AWARENESS_TIME = 30. # passive wheeltouch total timeout\n    self._AWARENESS_PRE_TIME_TILL_TERMINAL = 15.\n    self._AWARENESS_PROMPT_TIME_TILL_TERMINAL = 6.\n    self._DISTRACTED_TIME = 11. # active monitoring total timeout\n    self._DISTRACTED_PRE_TIME_TILL_TERMINAL = 8.\n    self._DISTRACTED_PROMPT_TIME_TILL_TERMINAL = 6.\n\n    self._FACE_THRESHOLD = 0.7\n    self._EYE_THRESHOLD = 0.65\n    self._SG_THRESHOLD = 0.9\n    self._BLINK_THRESHOLD = 0.865\n\n    self._EE_THRESH11 = 0.25\n    self._EE_THRESH12 = 7.5\n    self._EE_MAX_OFFSET1 = 0.06\n    self._EE_MIN_OFFSET1 = 0.025\n    self._EE_THRESH21 = 0.01\n    self._EE_THRESH22 = 0.35\n\n    self._POSE_PITCH_THRESHOLD = 0.3133\n    self._POSE_PITCH_THRESHOLD_SLACK = 0.3237\n    self._POSE_PITCH_THRESHOLD_STRICT = self._POSE_PITCH_THRESHOLD\n    self._POSE_YAW_THRESHOLD = 0.4020\n    self._POSE_YAW_THRESHOLD_SLACK = 0.5042\n    self._POSE_YAW_THRESHOLD_STRICT = self._POSE_YAW_THRESHOLD\n    self._PITCH_NATURAL_OFFSET = 0.029 # initial value before offset is learned\n    self._PITCH_NATURAL_THRESHOLD = 0.449\n    self._YAW_NATURAL_OFFSET = 0.097 # initial value before offset is learned\n    self._PITCH_MAX_OFFSET = 0.124\n    self._PITCH_MIN_OFFSET = -0.0881\n    self._YAW_MAX_OFFSET = 0.289\n    self._YAW_MIN_OFFSET = -0.0246\n\n    self._POSESTD_THRESHOLD = 0.3\n    self._HI_STD_FALLBACK_TIME = int(10  / self._DT_DMON)  # fall back to wheel touch if model is uncertain for 10s\n    self._DISTRACTED_FILTER_TS = 0.25  # 0.6Hz\n    self._ALWAYS_ON_ALERT_MIN_SPEED = 7\n\n    self._POSE_CALIB_MIN_SPEED = 13  # 30 mph\n    self._POSE_OFFSET_MIN_COUNT = int(60 / self._DT_DMON)  # valid data counts before calibration completes, 1min cumulative\n    self._POSE_OFFSET_MAX_COUNT = int(360 / self._DT_DMON)  # stop deweighting new data after 6 min, aka \"short term memory\"\n\n    self._WHEELPOS_CALIB_MIN_SPEED = 11\n    self._WHEELPOS_THRESHOLD = 0.5\n    self._WHEELPOS_FILTER_MIN_COUNT = int(15 / self._DT_DMON) # allow 15 seconds to converge wheel side\n\n    self._RECOVERY_FACTOR_MAX = 5.  # relative to minus step change\n    self._RECOVERY_FACTOR_MIN = 1.25  # relative to minus step change\n\n    self._MAX_TERMINAL_ALERTS = 3  # not allowed to engage after 3 terminal alerts\n    self._MAX_TERMINAL_DURATION = int(30 / self._DT_DMON)  # not allowed to engage after 30s of terminal alerts\n\nclass DistractedType:\n  NOT_DISTRACTED = 0\n  DISTRACTED_POSE = 1 << 0\n  DISTRACTED_BLINK = 1 << 1\n  DISTRACTED_E2E = 1 << 2\n\nclass DriverPose:\n  def __init__(self, max_trackable):\n    self.yaw = 0.\n    self.pitch = 0.\n    self.roll = 0.\n    self.yaw_std = 0.\n    self.pitch_std = 0.\n    self.roll_std = 0.\n    self.pitch_offseter = RunningStatFilter(max_trackable=max_trackable)\n    self.yaw_offseter = RunningStatFilter(max_trackable=max_trackable)\n    self.calibrated = False\n    self.low_std = True\n    self.cfactor_pitch = 1.\n    self.cfactor_yaw = 1.\n\nclass DriverBlink:\n  def __init__(self):\n    self.left = 0.\n    self.right = 0.\n\n\n# model output refers to center of undistorted+leveled image\nEFL = 598.0 # focal length in K\ncam = DEVICE_CAMERAS[(\"tici\", \"ar0231\")] # corrected image has same size as raw\nW, H = (cam.dcam.width, cam.dcam.height)  # corrected image has same size as raw\n\ndef face_orientation_from_net(angles_desc, pos_desc, rpy_calib):\n  # the output of these angles are in device frame\n  # so from driver's perspective, pitch is up and yaw is right\n\n  pitch_net, yaw_net, roll_net = angles_desc\n\n  face_pixel_position = ((pos_desc[0]+0.5)*W, (pos_desc[1]+0.5)*H)\n  yaw_focal_angle = atan2(face_pixel_position[0] - W//2, EFL)\n  pitch_focal_angle = atan2(face_pixel_position[1] - H//2, EFL)\n\n  pitch = pitch_net + pitch_focal_angle\n  yaw = -yaw_net + yaw_focal_angle\n\n  # no calib for roll\n  pitch -= rpy_calib[1]\n  yaw -= rpy_calib[2]\n  return roll_net, pitch, yaw\n\n\nclass DriverMonitoring:\n  def __init__(self, rhd_saved=False, settings=None, always_on=False):\n    if settings is None:\n      settings = DRIVER_MONITOR_SETTINGS()\n    # init policy settings\n    self.settings = settings\n\n    # init driver status\n    self.wheelpos_learner = RunningStatFilter()\n    self.pose = DriverPose(self.settings._POSE_OFFSET_MAX_COUNT)\n    self.blink = DriverBlink()\n    self.eev1 = 0.\n    self.eev2 = 1.\n    self.ee1_offseter = RunningStatFilter(max_trackable=self.settings._POSE_OFFSET_MAX_COUNT)\n    self.ee2_offseter = RunningStatFilter(max_trackable=self.settings._POSE_OFFSET_MAX_COUNT)\n    self.ee1_calibrated = False\n    self.ee2_calibrated = False\n\n    self.always_on = always_on\n    self.distracted_types = []\n    self.driver_distracted = False\n    self.driver_distraction_filter = FirstOrderFilter(0., self.settings._DISTRACTED_FILTER_TS, self.settings._DT_DMON)\n    self.wheel_on_right = False\n    self.wheel_on_right_last = None\n    self.wheel_on_right_default = rhd_saved\n    self.face_detected = False\n    self.terminal_alert_cnt = 0\n    self.terminal_time = 0\n    self.step_change = 0.\n    self.active_monitoring_mode = True\n    self.is_model_uncertain = False\n    self.hi_stds = 0\n    self.threshold_pre = self.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n    self.threshold_prompt = self.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n\n    self._reset_awareness()\n    self._set_timers(active_monitoring=True)\n    self._reset_events()\n\n  def _reset_awareness(self):\n    self.awareness = 1.\n    self.awareness_active = 1.\n    self.awareness_passive = 1.\n\n  def _reset_events(self):\n    self.current_events = Events()\n\n  def _set_timers(self, active_monitoring):\n    if self.active_monitoring_mode and self.awareness <= self.threshold_prompt:\n      if active_monitoring:\n        self.step_change = self.settings._DT_DMON / self.settings._DISTRACTED_TIME\n      else:\n        self.step_change = 0.\n      return  # no exploit after orange alert\n    elif self.awareness <= 0.:\n      return\n\n    if active_monitoring:\n      # when falling back from passive mode to active mode, reset awareness to avoid false alert\n      if not self.active_monitoring_mode:\n        self.awareness_passive = self.awareness\n        self.awareness = self.awareness_active\n\n      self.threshold_pre = self.settings._DISTRACTED_PRE_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n      self.threshold_prompt = self.settings._DISTRACTED_PROMPT_TIME_TILL_TERMINAL / self.settings._DISTRACTED_TIME\n      self.step_change = self.settings._DT_DMON / self.settings._DISTRACTED_TIME\n      self.active_monitoring_mode = True\n    else:\n      if self.active_monitoring_mode:\n        self.awareness_active = self.awareness\n        self.awareness = self.awareness_passive\n\n      self.threshold_pre = self.settings._AWARENESS_PRE_TIME_TILL_TERMINAL / self.settings._AWARENESS_TIME\n      self.threshold_prompt = self.settings._AWARENESS_PROMPT_TIME_TILL_TERMINAL / self.settings._AWARENESS_TIME\n      self.step_change = self.settings._DT_DMON / self.settings._AWARENESS_TIME\n      self.active_monitoring_mode = False\n\n  def _set_policy(self, model_data, car_speed):\n    bp = model_data.meta.disengagePredictions.brakeDisengageProbs[0] # brake disengage prob in next 2s\n    k1 = max(-0.00156*((car_speed-16)**2)+0.6, 0.2)\n    bp_normal = max(min(bp / k1, 0.5),0)\n    self.pose.cfactor_pitch = interp(bp_normal, [0, 0.5],\n                                           [self.settings._POSE_PITCH_THRESHOLD_SLACK,\n                                            self.settings._POSE_PITCH_THRESHOLD_STRICT]) / self.settings._POSE_PITCH_THRESHOLD\n    self.pose.cfactor_yaw = interp(bp_normal, [0, 0.5],\n                                           [self.settings._POSE_YAW_THRESHOLD_SLACK,\n                                            self.settings._POSE_YAW_THRESHOLD_STRICT]) / self.settings._POSE_YAW_THRESHOLD\n\n  def _get_distracted_types(self):\n    distracted_types = []\n\n    if not self.pose.calibrated:\n      pitch_error = self.pose.pitch - self.settings._PITCH_NATURAL_OFFSET\n      yaw_error = self.pose.yaw - self.settings._YAW_NATURAL_OFFSET\n    else:\n      pitch_error = self.pose.pitch - min(max(self.pose.pitch_offseter.filtered_stat.mean(),\n                                                       self.settings._PITCH_MIN_OFFSET), self.settings._PITCH_MAX_OFFSET)\n      yaw_error = self.pose.yaw - min(max(self.pose.yaw_offseter.filtered_stat.mean(),\n                                                    self.settings._YAW_MIN_OFFSET), self.settings._YAW_MAX_OFFSET)\n    pitch_error = 0 if pitch_error > 0 else abs(pitch_error) # no positive pitch limit\n    yaw_error = abs(yaw_error)\n    if pitch_error > (self.settings._POSE_PITCH_THRESHOLD*self.pose.cfactor_pitch if self.pose.calibrated else self.settings._PITCH_NATURAL_THRESHOLD) or \\\n       yaw_error > self.settings._POSE_YAW_THRESHOLD*self.pose.cfactor_yaw:\n      distracted_types.append(DistractedType.DISTRACTED_POSE)\n\n    if (self.blink.left + self.blink.right)*0.5 > self.settings._BLINK_THRESHOLD:\n      distracted_types.append(DistractedType.DISTRACTED_BLINK)\n\n    if self.ee1_calibrated:\n      ee1_dist = self.eev1 > max(min(self.ee1_offseter.filtered_stat.M, self.settings._EE_MAX_OFFSET1), self.settings._EE_MIN_OFFSET1) \\\n                              * self.settings._EE_THRESH12\n    else:\n      ee1_dist = self.eev1 > self.settings._EE_THRESH11\n    if ee1_dist:\n      distracted_types.append(DistractedType.DISTRACTED_E2E)\n\n    return distracted_types\n\n  def _update_states(self, driver_state, cal_rpy, car_speed, op_engaged):\n    rhd_pred = driver_state.wheelOnRightProb\n    # calibrates only when there's movement and either face detected\n    if car_speed > self.settings._WHEELPOS_CALIB_MIN_SPEED and (driver_state.leftDriverData.faceProb > self.settings._FACE_THRESHOLD or\n                                          driver_state.rightDriverData.faceProb > self.settings._FACE_THRESHOLD):\n      self.wheelpos_learner.push_and_update(rhd_pred)\n    if self.wheelpos_learner.filtered_stat.n > self.settings._WHEELPOS_FILTER_MIN_COUNT:\n      self.wheel_on_right = self.wheelpos_learner.filtered_stat.M > self.settings._WHEELPOS_THRESHOLD\n    else:\n      self.wheel_on_right = self.wheel_on_right_default # use default/saved if calibration is unfinished\n    # make sure no switching when engaged\n    if op_engaged and self.wheel_on_right_last is not None and self.wheel_on_right_last != self.wheel_on_right:\n      self.wheel_on_right = self.wheel_on_right_last\n    driver_data = driver_state.rightDriverData if self.wheel_on_right else driver_state.leftDriverData\n    if not all(len(x) > 0 for x in (driver_data.faceOrientation, driver_data.facePosition,\n                                    driver_data.faceOrientationStd, driver_data.facePositionStd,\n                                    driver_data.readyProb, driver_data.notReadyProb)):\n      return\n\n    self.face_detected = driver_data.faceProb > self.settings._FACE_THRESHOLD\n    self.pose.roll, self.pose.pitch, self.pose.yaw = face_orientation_from_net(driver_data.faceOrientation, driver_data.facePosition, cal_rpy)\n    if self.wheel_on_right:\n      self.pose.yaw *= -1\n    self.wheel_on_right_last = self.wheel_on_right\n    self.pose.pitch_std = driver_data.faceOrientationStd[0]\n    self.pose.yaw_std = driver_data.faceOrientationStd[1]\n    model_std_max = max(self.pose.pitch_std, self.pose.yaw_std)\n    self.pose.low_std = model_std_max < self.settings._POSESTD_THRESHOLD\n    self.blink.left = driver_data.leftBlinkProb * (driver_data.leftEyeProb > self.settings._EYE_THRESHOLD) \\\n                                                                  * (driver_data.sunglassesProb < self.settings._SG_THRESHOLD)\n    self.blink.right = driver_data.rightBlinkProb * (driver_data.rightEyeProb > self.settings._EYE_THRESHOLD) \\\n                                                                  * (driver_data.sunglassesProb < self.settings._SG_THRESHOLD)\n    self.eev1 = driver_data.notReadyProb[0]\n    self.eev2 = driver_data.readyProb[0]\n\n    self.distracted_types = self._get_distracted_types()\n    self.driver_distracted = (DistractedType.DISTRACTED_E2E in self.distracted_types or DistractedType.DISTRACTED_POSE in self.distracted_types\n                                or DistractedType.DISTRACTED_BLINK in self.distracted_types) \\\n                              and driver_data.faceProb > self.settings._FACE_THRESHOLD and self.pose.low_std\n    self.driver_distraction_filter.update(self.driver_distracted)\n\n    # update offseter\n    # only update when driver is actively driving the car above a certain speed\n    if self.face_detected and car_speed > self.settings._POSE_CALIB_MIN_SPEED and self.pose.low_std and (not op_engaged or not self.driver_distracted):\n      self.pose.pitch_offseter.push_and_update(self.pose.pitch)\n      self.pose.yaw_offseter.push_and_update(self.pose.yaw)\n      self.ee1_offseter.push_and_update(self.eev1)\n      self.ee2_offseter.push_and_update(self.eev2)\n\n    self.pose.calibrated = self.pose.pitch_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT and \\\n                                       self.pose.yaw_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT\n    self.ee1_calibrated = self.ee1_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT\n    self.ee2_calibrated = self.ee2_offseter.filtered_stat.n > self.settings._POSE_OFFSET_MIN_COUNT\n\n    self.is_model_uncertain = self.hi_stds > self.settings._HI_STD_FALLBACK_TIME\n    self._set_timers(self.face_detected and not self.is_model_uncertain)\n    if self.face_detected and not self.pose.low_std and not self.driver_distracted:\n      self.hi_stds += 1\n    elif self.face_detected and self.pose.low_std:\n      self.hi_stds = 0\n\n  def _update_events(self, driver_engaged, op_engaged, standstill, wrong_gear, car_speed):\n    self._reset_events()\n    # Block engaging after max number of distrations or when alert active\n    if self.terminal_alert_cnt >= self.settings._MAX_TERMINAL_ALERTS or \\\n       self.terminal_time >= self.settings._MAX_TERMINAL_DURATION or \\\n       self.always_on and self.awareness <= self.threshold_prompt:\n      self.current_events.add(EventName.tooDistracted)\n\n    always_on_valid = self.always_on and not wrong_gear\n    if (driver_engaged and self.awareness > 0 and not self.active_monitoring_mode) or \\\n       (not always_on_valid and not op_engaged) or \\\n       (always_on_valid and not op_engaged and self.awareness <= 0):\n      # always reset on disengage with normal mode; disengage resets only on red if always on\n      self._reset_awareness()\n      return\n\n    driver_attentive = self.driver_distraction_filter.x < 0.37\n    awareness_prev = self.awareness\n\n    if (driver_attentive and self.face_detected and self.pose.low_std and self.awareness > 0):\n      if driver_engaged:\n        self._reset_awareness()\n        return\n      # only restore awareness when paying attention and alert is not red\n      self.awareness = min(self.awareness + ((self.settings._RECOVERY_FACTOR_MAX-self.settings._RECOVERY_FACTOR_MIN)*\n                                             (1.-self.awareness)+self.settings._RECOVERY_FACTOR_MIN)*self.step_change, 1.)\n      if self.awareness == 1.:\n        self.awareness_passive = min(self.awareness_passive + self.step_change, 1.)\n      # don't display alert banner when awareness is recovering and has cleared orange\n      if self.awareness > self.threshold_prompt:\n        return\n\n    _reaching_audible = self.awareness - self.step_change <= self.threshold_prompt\n    _reaching_terminal = self.awareness - self.step_change <= 0\n    standstill_exemption = standstill and _reaching_audible\n    always_on_red_exemption = always_on_valid and not op_engaged and _reaching_terminal\n    always_on_lowspeed_exemption = always_on_valid and not op_engaged and car_speed < self.settings._ALWAYS_ON_ALERT_MIN_SPEED and _reaching_audible\n\n    certainly_distracted = self.driver_distraction_filter.x > 0.63 and self.driver_distracted and self.face_detected\n    maybe_distracted = self.hi_stds > self.settings._HI_STD_FALLBACK_TIME or not self.face_detected\n\n    if certainly_distracted or maybe_distracted:\n      # should always be counting if distracted unless at standstill (lowspeed for always-on) and reaching orange\n      # also will not be reaching 0 if DM is active when not engaged\n      if not (standstill_exemption or always_on_red_exemption or always_on_lowspeed_exemption):\n        self.awareness = max(self.awareness - self.step_change, -0.1)\n\n    alert = None\n    if self.awareness <= 0.:\n      # terminal red alert: disengagement required\n      alert = EventName.driverDistracted if self.active_monitoring_mode else EventName.driverUnresponsive\n      self.terminal_time += 1\n      if awareness_prev > 0.:\n        self.terminal_alert_cnt += 1\n    elif self.awareness <= self.threshold_prompt:\n      # prompt orange alert\n      alert = EventName.promptDriverDistracted if self.active_monitoring_mode else EventName.promptDriverUnresponsive\n    elif self.awareness <= self.threshold_pre:\n      # pre green alert\n      alert = EventName.preDriverDistracted if self.active_monitoring_mode else EventName.preDriverUnresponsive\n\n    if alert is not None:\n      self.current_events.add(alert)\n\n\n  def get_state_packet(self, valid=True):\n    # build driverMonitoringState packet\n    dat = messaging.new_message('driverMonitoringState', valid=valid)\n    dat.driverMonitoringState = {\n      \"events\": self.current_events.to_msg(),\n      \"faceDetected\": self.face_detected,\n      \"isDistracted\": self.driver_distracted,\n      \"distractedType\": sum(self.distracted_types),\n      \"awarenessStatus\": self.awareness,\n      \"posePitchOffset\": self.pose.pitch_offseter.filtered_stat.mean(),\n      \"posePitchValidCount\": self.pose.pitch_offseter.filtered_stat.n,\n      \"poseYawOffset\": self.pose.yaw_offseter.filtered_stat.mean(),\n      \"poseYawValidCount\": self.pose.yaw_offseter.filtered_stat.n,\n      \"stepChange\": self.step_change,\n      \"awarenessActive\": self.awareness_active,\n      \"awarenessPassive\": self.awareness_passive,\n      \"isLowStd\": self.pose.low_std,\n      \"hiStdCount\": self.hi_stds,\n      \"isActiveMode\": self.active_monitoring_mode,\n      \"isRHD\": self.wheel_on_right,\n    }\n    return dat\n\n  def run_step(self, sm):\n    # Set strictness\n    self._set_policy(\n      model_data=sm['modelV2'],\n      car_speed=sm['carState'].vEgo\n    )\n\n    # Parse data from dmonitoringmodeld\n    self._update_states(\n      driver_state=sm['driverStateV2'],\n      cal_rpy=sm['liveCalibration'].rpyCalib,\n      car_speed=sm['carState'].vEgo,\n      op_engaged=sm['controlsState'].enabled\n    )\n\n    # Update distraction events\n    self._update_events(\n      driver_engaged=sm['carState'].steeringPressed or sm['carState'].gasPressed,\n      op_engaged=sm['controlsState'].enabled,\n      standstill=sm['carState'].standstill,\n      wrong_gear=sm['carState'].gearShifter in [car.CarState.GearShifter.reverse, car.CarState.GearShifter.park],\n      car_speed=sm['carState'].vEgo\n    )\n", "selfdrive/monitoring/dmonitoringd.py": "#!/usr/bin/env python3\nimport gc\n\nimport cereal.messaging as messaging\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import set_realtime_priority\nfrom openpilot.selfdrive.monitoring.helpers import DriverMonitoring\n\n\ndef dmonitoringd_thread():\n  gc.disable()\n  set_realtime_priority(2)\n\n  params = Params()\n  pm = messaging.PubMaster(['driverMonitoringState'])\n  sm = messaging.SubMaster(['driverStateV2', 'liveCalibration', 'carState', 'controlsState', 'modelV2'], poll='driverStateV2')\n\n  DM = DriverMonitoring(rhd_saved=params.get_bool(\"IsRhdDetected\"), always_on=params.get_bool(\"AlwaysOnDM\"))\n\n  # 20Hz <- dmonitoringmodeld\n  while True:\n    sm.update()\n    if not sm.updated['driverStateV2']:\n      # iterate when model has new output\n      continue\n\n    valid = sm.all_checks()\n    if valid:\n      DM.run_step(sm)\n\n    # publish\n    dat = DM.get_state_packet(valid=valid)\n    pm.send('driverMonitoringState', dat)\n\n    # load live always-on toggle\n    if sm['driverStateV2'].frameId % 40 == 1:\n      DM.always_on = params.get_bool(\"AlwaysOnDM\")\n\n    # save rhd virtual toggle every 5 mins\n    if (sm['driverStateV2'].frameId % 6000 == 0 and\n     DM.wheelpos_learner.filtered_stat.n > DM.settings._WHEELPOS_FILTER_MIN_COUNT and\n     DM.wheel_on_right == (DM.wheelpos_learner.filtered_stat.M > DM.settings._WHEELPOS_THRESHOLD)):\n      params.put_bool_nonblocking(\"IsRhdDetected\", DM.wheel_on_right)\n\ndef main():\n  dmonitoringd_thread()\n\n\nif __name__ == '__main__':\n  main()\n", "selfdrive/pandad/pandad.py": "#!/usr/bin/env python3\n# simple pandad wrapper that updates the panda first\nimport os\nimport usb1\nimport time\nimport subprocess\nfrom typing import NoReturn\n\nfrom panda import Panda, PandaDFU, PandaProtocolMismatch, FW_PATH\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.params import Params\nfrom openpilot.system.hardware import HARDWARE\nfrom openpilot.common.swaglog import cloudlog\n\n\ndef get_expected_signature(panda: Panda) -> bytes:\n  try:\n    fn = os.path.join(FW_PATH, panda.get_mcu_type().config.app_fn)\n    return Panda.get_signature_from_firmware(fn)\n  except Exception:\n    cloudlog.exception(\"Error computing expected signature\")\n    return b\"\"\n\ndef flash_panda(panda_serial: str) -> Panda:\n  try:\n    panda = Panda(panda_serial)\n  except PandaProtocolMismatch:\n    cloudlog.warning(\"detected protocol mismatch, reflashing panda\")\n    HARDWARE.recover_internal_panda()\n    raise\n\n  fw_signature = get_expected_signature(panda)\n  internal_panda = panda.is_internal()\n\n  panda_version = \"bootstub\" if panda.bootstub else panda.get_version()\n  panda_signature = b\"\" if panda.bootstub else panda.get_signature()\n  cloudlog.warning(f\"Panda {panda_serial} connected, version: {panda_version}, signature {panda_signature.hex()[:16]}, expected {fw_signature.hex()[:16]}\")\n\n  if panda.bootstub or panda_signature != fw_signature:\n    cloudlog.info(\"Panda firmware out of date, update required\")\n    panda.flash()\n    cloudlog.info(\"Done flashing\")\n\n  if panda.bootstub:\n    bootstub_version = panda.get_version()\n    cloudlog.info(f\"Flashed firmware not booting, flashing development bootloader. {bootstub_version=}, {internal_panda=}\")\n    if internal_panda:\n      HARDWARE.recover_internal_panda()\n    panda.recover(reset=(not internal_panda))\n    cloudlog.info(\"Done flashing bootstub\")\n\n  if panda.bootstub:\n    cloudlog.info(\"Panda still not booting, exiting\")\n    raise AssertionError\n\n  panda_signature = panda.get_signature()\n  if panda_signature != fw_signature:\n    cloudlog.info(\"Version mismatch after flashing, exiting\")\n    raise AssertionError\n\n  return panda\n\n\ndef main() -> NoReturn:\n  count = 0\n  first_run = True\n  params = Params()\n  no_internal_panda_count = 0\n\n  while True:\n    try:\n      count += 1\n      cloudlog.event(\"pandad.flash_and_connect\", count=count)\n      params.remove(\"PandaSignatures\")\n\n      # TODO: remove this in the next AGNOS\n      # wait until USB is up before counting\n      if time.monotonic() < 25.:\n        no_internal_panda_count = 0\n\n      # Handle missing internal panda\n      if no_internal_panda_count > 0:\n        if no_internal_panda_count == 3:\n          cloudlog.info(\"No pandas found, putting internal panda into DFU\")\n          HARDWARE.recover_internal_panda()\n        else:\n          cloudlog.info(\"No pandas found, resetting internal panda\")\n          HARDWARE.reset_internal_panda()\n        time.sleep(3)  # wait to come back up\n\n      # Flash all Pandas in DFU mode\n      dfu_serials = PandaDFU.list()\n      if len(dfu_serials) > 0:\n        for serial in dfu_serials:\n          cloudlog.info(f\"Panda in DFU mode found, flashing recovery {serial}\")\n          PandaDFU(serial).recover()\n        time.sleep(1)\n\n      panda_serials = Panda.list()\n      if len(panda_serials) == 0:\n        no_internal_panda_count += 1\n        continue\n\n      cloudlog.info(f\"{len(panda_serials)} panda(s) found, connecting - {panda_serials}\")\n\n      # Flash pandas\n      pandas: list[Panda] = []\n      for serial in panda_serials:\n        pandas.append(flash_panda(serial))\n\n      # Ensure internal panda is present if expected\n      internal_pandas = [panda for panda in pandas if panda.is_internal()]\n      if HARDWARE.has_internal_panda() and len(internal_pandas) == 0:\n        cloudlog.error(\"Internal panda is missing, trying again\")\n        no_internal_panda_count += 1\n        continue\n      no_internal_panda_count = 0\n\n      # sort pandas to have deterministic order\n      # * the internal one is always first\n      # * then sort by hardware type\n      # * as a last resort, sort by serial number\n      pandas.sort(key=lambda x: (not x.is_internal(), x.get_type(), x.get_usb_serial()))\n      panda_serials = [p.get_usb_serial() for p in pandas]\n\n      # log panda fw versions\n      params.put(\"PandaSignatures\", b','.join(p.get_signature() for p in pandas))\n\n      for panda in pandas:\n        # check health for lost heartbeat\n        health = panda.health()\n        if health[\"heartbeat_lost\"]:\n          params.put_bool(\"PandaHeartbeatLost\", True)\n          cloudlog.event(\"heartbeat lost\", deviceState=health, serial=panda.get_usb_serial())\n        if health[\"som_reset_triggered\"]:\n          params.put_bool(\"PandaSomResetTriggered\", True)\n          cloudlog.event(\"panda.som_reset_triggered\", health=health, serial=panda.get_usb_serial())\n\n        if first_run:\n          # reset panda to ensure we're in a good state\n          cloudlog.info(f\"Resetting panda {panda.get_usb_serial()}\")\n          panda.reset(reconnect=True)\n\n      for p in pandas:\n        p.close()\n    # TODO: wrap all panda exceptions in a base panda exception\n    except (usb1.USBErrorNoDevice, usb1.USBErrorPipe):\n      # a panda was disconnected while setting everything up. let's try again\n      cloudlog.exception(\"Panda USB exception while setting up\")\n      continue\n    except PandaProtocolMismatch:\n      cloudlog.exception(\"pandad.protocol_mismatch\")\n      continue\n    except Exception:\n      cloudlog.exception(\"pandad.uncaught_exception\")\n      continue\n\n    first_run = False\n\n    # run pandad with all connected serials as arguments\n    os.environ['MANAGER_DAEMON'] = 'pandad'\n    os.chdir(os.path.join(BASEDIR, \"selfdrive/pandad\"))\n    subprocess.run([\"./pandad\", *panda_serials], check=True)\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/pandad/__init__.py": "# Cython, now uses scons to build\nfrom openpilot.selfdrive.pandad.pandad_api_impl import can_list_to_can_capnp\nassert can_list_to_can_capnp\n\ndef can_capnp_to_can_list(can, src_filter=None):\n  ret = []\n  for msg in can:\n    if src_filter is None or msg.src in src_filter:\n      ret.append((msg.address, msg.busTime, msg.dat, msg.src))\n  return ret\n", "selfdrive/modeld/fill_model_msg.py": "import os\nimport capnp\nimport numpy as np\nfrom cereal import log\nfrom openpilot.selfdrive.modeld.constants import ModelConstants, Plan, Meta\n\nSEND_RAW_PRED = os.getenv('SEND_RAW_PRED')\n\nConfidenceClass = log.ModelDataV2.ConfidenceClass\n\nclass PublishState:\n  def __init__(self):\n    self.disengage_buffer = np.zeros(ModelConstants.CONFIDENCE_BUFFER_LEN*ModelConstants.DISENGAGE_WIDTH, dtype=np.float32)\n    self.prev_brake_5ms2_probs = np.zeros(ModelConstants.FCW_5MS2_PROBS_WIDTH, dtype=np.float32)\n    self.prev_brake_3ms2_probs = np.zeros(ModelConstants.FCW_3MS2_PROBS_WIDTH, dtype=np.float32)\n\ndef fill_xyzt(builder, t, x, y, z, x_std=None, y_std=None, z_std=None):\n  builder.t = t\n  builder.x = x.tolist()\n  builder.y = y.tolist()\n  builder.z = z.tolist()\n  if x_std is not None:\n    builder.xStd = x_std.tolist()\n  if y_std is not None:\n    builder.yStd = y_std.tolist()\n  if z_std is not None:\n    builder.zStd = z_std.tolist()\n\ndef fill_xyvat(builder, t, x, y, v, a, x_std=None, y_std=None, v_std=None, a_std=None):\n  builder.t = t\n  builder.x = x.tolist()\n  builder.y = y.tolist()\n  builder.v = v.tolist()\n  builder.a = a.tolist()\n  if x_std is not None:\n    builder.xStd = x_std.tolist()\n  if y_std is not None:\n    builder.yStd = y_std.tolist()\n  if v_std is not None:\n    builder.vStd = v_std.tolist()\n  if a_std is not None:\n    builder.aStd = a_std.tolist()\n\ndef fill_model_msg(msg: capnp._DynamicStructBuilder, net_output_data: dict[str, np.ndarray], publish_state: PublishState,\n                   vipc_frame_id: int, vipc_frame_id_extra: int, frame_id: int, frame_drop: float,\n                   timestamp_eof: int, model_execution_time: float, valid: bool) -> None:\n  frame_age = frame_id - vipc_frame_id if frame_id > vipc_frame_id else 0\n  msg.valid = valid\n\n  modelV2 = msg.modelV2\n  modelV2.frameId = vipc_frame_id\n  modelV2.frameIdExtra = vipc_frame_id_extra\n  modelV2.frameAge = frame_age\n  modelV2.frameDropPerc = frame_drop * 100\n  modelV2.timestampEof = timestamp_eof\n  modelV2.modelExecutionTime = model_execution_time\n\n  # plan\n  position = modelV2.position\n  fill_xyzt(position, ModelConstants.T_IDXS, *net_output_data['plan'][0,:,Plan.POSITION].T, *net_output_data['plan_stds'][0,:,Plan.POSITION].T)\n  velocity = modelV2.velocity\n  fill_xyzt(velocity, ModelConstants.T_IDXS, *net_output_data['plan'][0,:,Plan.VELOCITY].T)\n  acceleration = modelV2.acceleration\n  fill_xyzt(acceleration, ModelConstants.T_IDXS, *net_output_data['plan'][0,:,Plan.ACCELERATION].T)\n  orientation = modelV2.orientation\n  fill_xyzt(orientation, ModelConstants.T_IDXS, *net_output_data['plan'][0,:,Plan.T_FROM_CURRENT_EULER].T)\n  orientation_rate = modelV2.orientationRate\n  fill_xyzt(orientation_rate, ModelConstants.T_IDXS, *net_output_data['plan'][0,:,Plan.ORIENTATION_RATE].T)\n\n  # lateral planning\n  action = modelV2.action\n  action.desiredCurvature = float(net_output_data['desired_curvature'][0,0])\n\n  # times at X_IDXS according to model plan\n  PLAN_T_IDXS = [np.nan] * ModelConstants.IDX_N\n  PLAN_T_IDXS[0] = 0.0\n  plan_x = net_output_data['plan'][0,:,Plan.POSITION][:,0].tolist()\n  for xidx in range(1, ModelConstants.IDX_N):\n    tidx = 0\n    # increment tidx until we find an element that's further away than the current xidx\n    while tidx < ModelConstants.IDX_N - 1 and plan_x[tidx+1] < ModelConstants.X_IDXS[xidx]:\n      tidx += 1\n    if tidx == ModelConstants.IDX_N - 1:\n      # if the Plan doesn't extend far enough, set plan_t to the max value (10s), then break\n      PLAN_T_IDXS[xidx] = ModelConstants.T_IDXS[ModelConstants.IDX_N - 1]\n      break\n    # interpolate to find `t` for the current xidx\n    current_x_val = plan_x[tidx]\n    next_x_val = plan_x[tidx+1]\n    p = (ModelConstants.X_IDXS[xidx] - current_x_val) / (next_x_val - current_x_val) if abs(next_x_val - current_x_val) > 1e-9 else float('nan')\n    PLAN_T_IDXS[xidx] = p * ModelConstants.T_IDXS[tidx+1] + (1 - p) * ModelConstants.T_IDXS[tidx]\n\n  # lane lines\n  modelV2.init('laneLines', 4)\n  for i in range(4):\n    lane_line = modelV2.laneLines[i]\n    fill_xyzt(lane_line, PLAN_T_IDXS, np.array(ModelConstants.X_IDXS), net_output_data['lane_lines'][0,i,:,0], net_output_data['lane_lines'][0,i,:,1])\n  modelV2.laneLineStds = net_output_data['lane_lines_stds'][0,:,0,0].tolist()\n  modelV2.laneLineProbs = net_output_data['lane_lines_prob'][0,1::2].tolist()\n\n  # road edges\n  modelV2.init('roadEdges', 2)\n  for i in range(2):\n    road_edge = modelV2.roadEdges[i]\n    fill_xyzt(road_edge, PLAN_T_IDXS, np.array(ModelConstants.X_IDXS), net_output_data['road_edges'][0,i,:,0], net_output_data['road_edges'][0,i,:,1])\n  modelV2.roadEdgeStds = net_output_data['road_edges_stds'][0,:,0,0].tolist()\n\n  # leads\n  modelV2.init('leadsV3', 3)\n  for i in range(3):\n    lead = modelV2.leadsV3[i]\n    fill_xyvat(lead, ModelConstants.LEAD_T_IDXS, *net_output_data['lead'][0,i].T, *net_output_data['lead_stds'][0,i].T)\n    lead.prob = net_output_data['lead_prob'][0,i].tolist()\n    lead.probTime = ModelConstants.LEAD_T_OFFSETS[i]\n\n  # meta\n  meta = modelV2.meta\n  meta.desireState = net_output_data['desire_state'][0].reshape(-1).tolist()\n  meta.desirePrediction = net_output_data['desire_pred'][0].reshape(-1).tolist()\n  meta.engagedProb = net_output_data['meta'][0,Meta.ENGAGED].item()\n  meta.init('disengagePredictions')\n  disengage_predictions = meta.disengagePredictions\n  disengage_predictions.t = ModelConstants.META_T_IDXS\n  disengage_predictions.brakeDisengageProbs = net_output_data['meta'][0,Meta.BRAKE_DISENGAGE].tolist()\n  disengage_predictions.gasDisengageProbs = net_output_data['meta'][0,Meta.GAS_DISENGAGE].tolist()\n  disengage_predictions.steerOverrideProbs = net_output_data['meta'][0,Meta.STEER_OVERRIDE].tolist()\n  disengage_predictions.brake3MetersPerSecondSquaredProbs = net_output_data['meta'][0,Meta.HARD_BRAKE_3].tolist()\n  disengage_predictions.brake4MetersPerSecondSquaredProbs = net_output_data['meta'][0,Meta.HARD_BRAKE_4].tolist()\n  disengage_predictions.brake5MetersPerSecondSquaredProbs = net_output_data['meta'][0,Meta.HARD_BRAKE_5].tolist()\n\n  publish_state.prev_brake_5ms2_probs[:-1] = publish_state.prev_brake_5ms2_probs[1:]\n  publish_state.prev_brake_5ms2_probs[-1] = net_output_data['meta'][0,Meta.HARD_BRAKE_5][0]\n  publish_state.prev_brake_3ms2_probs[:-1] = publish_state.prev_brake_3ms2_probs[1:]\n  publish_state.prev_brake_3ms2_probs[-1] = net_output_data['meta'][0,Meta.HARD_BRAKE_3][0]\n  hard_brake_predicted = (publish_state.prev_brake_5ms2_probs > ModelConstants.FCW_THRESHOLDS_5MS2).all() and \\\n    (publish_state.prev_brake_3ms2_probs > ModelConstants.FCW_THRESHOLDS_3MS2).all()\n  meta.hardBrakePredicted = hard_brake_predicted.item()\n\n  # temporal pose\n  temporal_pose = modelV2.temporalPose\n  temporal_pose.trans = net_output_data['sim_pose'][0,:3].tolist()\n  temporal_pose.transStd = net_output_data['sim_pose_stds'][0,:3].tolist()\n  temporal_pose.rot = net_output_data['sim_pose'][0,3:].tolist()\n  temporal_pose.rotStd = net_output_data['sim_pose_stds'][0,3:].tolist()\n\n  # confidence\n  if vipc_frame_id % (2*ModelConstants.MODEL_FREQ) == 0:\n    # any disengage prob\n    brake_disengage_probs = net_output_data['meta'][0,Meta.BRAKE_DISENGAGE]\n    gas_disengage_probs = net_output_data['meta'][0,Meta.GAS_DISENGAGE]\n    steer_override_probs = net_output_data['meta'][0,Meta.STEER_OVERRIDE]\n    any_disengage_probs = 1-((1-brake_disengage_probs)*(1-gas_disengage_probs)*(1-steer_override_probs))\n    # independent disengage prob for each 2s slice\n    ind_disengage_probs = np.r_[any_disengage_probs[0], np.diff(any_disengage_probs) / (1 - any_disengage_probs[:-1])]\n    # rolling buf for 2, 4, 6, 8, 10s\n    publish_state.disengage_buffer[:-ModelConstants.DISENGAGE_WIDTH] = publish_state.disengage_buffer[ModelConstants.DISENGAGE_WIDTH:]\n    publish_state.disengage_buffer[-ModelConstants.DISENGAGE_WIDTH:] = ind_disengage_probs\n\n  score = 0.\n  for i in range(ModelConstants.DISENGAGE_WIDTH):\n    score += publish_state.disengage_buffer[i*ModelConstants.DISENGAGE_WIDTH+ModelConstants.DISENGAGE_WIDTH-1-i].item() / ModelConstants.DISENGAGE_WIDTH\n  if score < ModelConstants.RYG_GREEN:\n    modelV2.confidence = ConfidenceClass.green\n  elif score < ModelConstants.RYG_YELLOW:\n    modelV2.confidence = ConfidenceClass.yellow\n  else:\n    modelV2.confidence = ConfidenceClass.red\n\n  # raw prediction if enabled\n  if SEND_RAW_PRED:\n    modelV2.rawPredictions = net_output_data['raw_pred'].tobytes()\n\ndef fill_pose_msg(msg: capnp._DynamicStructBuilder, net_output_data: dict[str, np.ndarray],\n                  vipc_frame_id: int, vipc_dropped_frames: int, timestamp_eof: int, live_calib_seen: bool) -> None:\n  msg.valid = live_calib_seen & (vipc_dropped_frames < 1)\n  cameraOdometry = msg.cameraOdometry\n\n  cameraOdometry.frameId = vipc_frame_id\n  cameraOdometry.timestampEof = timestamp_eof\n\n  cameraOdometry.trans = net_output_data['pose'][0,:3].tolist()\n  cameraOdometry.rot = net_output_data['pose'][0,3:].tolist()\n  cameraOdometry.wideFromDeviceEuler = net_output_data['wide_from_device_euler'][0,:].tolist()\n  cameraOdometry.roadTransformTrans = net_output_data['road_transform'][0,:3].tolist()\n  cameraOdometry.transStd = net_output_data['pose_stds'][0,:3].tolist()\n  cameraOdometry.rotStd = net_output_data['pose_stds'][0,3:].tolist()\n  cameraOdometry.wideFromDeviceEulerStd = net_output_data['wide_from_device_euler_stds'][0,:].tolist()\n  cameraOdometry.roadTransformTransStd = net_output_data['road_transform_stds'][0,:3].tolist()\n", "selfdrive/modeld/constants.py": "import numpy as np\n\ndef index_function(idx, max_val=192, max_idx=32):\n  return (max_val) * ((idx/max_idx)**2)\n\nclass ModelConstants:\n  # time and distance indices\n  IDX_N = 33\n  T_IDXS = [index_function(idx, max_val=10.0) for idx in range(IDX_N)]\n  X_IDXS = [index_function(idx, max_val=192.0) for idx in range(IDX_N)]\n  LEAD_T_IDXS = [0., 2., 4., 6., 8., 10.]\n  LEAD_T_OFFSETS = [0., 2., 4.]\n  META_T_IDXS = [2., 4., 6., 8., 10.]\n\n  # model inputs constants\n  MODEL_FREQ = 20\n  FEATURE_LEN = 512\n  HISTORY_BUFFER_LEN = 99\n  DESIRE_LEN = 8\n  TRAFFIC_CONVENTION_LEN = 2\n  LAT_PLANNER_STATE_LEN = 4\n  LATERAL_CONTROL_PARAMS_LEN = 2\n  PREV_DESIRED_CURV_LEN = 1\n\n  # model outputs constants\n  FCW_THRESHOLDS_5MS2 = np.array([.05, .05, .15, .15, .15], dtype=np.float32)\n  FCW_THRESHOLDS_3MS2 = np.array([.7, .7], dtype=np.float32)\n  FCW_5MS2_PROBS_WIDTH = 5\n  FCW_3MS2_PROBS_WIDTH = 2\n\n  DISENGAGE_WIDTH = 5\n  POSE_WIDTH = 6\n  WIDE_FROM_DEVICE_WIDTH = 3\n  SIM_POSE_WIDTH = 6\n  LEAD_WIDTH = 4\n  LANE_LINES_WIDTH = 2\n  ROAD_EDGES_WIDTH = 2\n  PLAN_WIDTH = 15\n  DESIRE_PRED_WIDTH = 8\n  LAT_PLANNER_SOLUTION_WIDTH = 4\n  DESIRED_CURV_WIDTH = 1\n\n  NUM_LANE_LINES = 4\n  NUM_ROAD_EDGES = 2\n\n  LEAD_TRAJ_LEN = 6\n  DESIRE_PRED_LEN = 4\n\n  PLAN_MHP_N = 5\n  LEAD_MHP_N = 2\n  PLAN_MHP_SELECTION = 1\n  LEAD_MHP_SELECTION = 3\n\n  FCW_THRESHOLD_5MS2_HIGH = 0.15\n  FCW_THRESHOLD_5MS2_LOW = 0.05\n  FCW_THRESHOLD_3MS2 = 0.7\n\n  CONFIDENCE_BUFFER_LEN = 5\n  RYG_GREEN = 0.01165\n  RYG_YELLOW = 0.06157\n\n# model outputs slices\nclass Plan:\n  POSITION = slice(0, 3)\n  VELOCITY = slice(3, 6)\n  ACCELERATION = slice(6, 9)\n  T_FROM_CURRENT_EULER = slice(9, 12)\n  ORIENTATION_RATE = slice(12, 15)\n\nclass Meta:\n  ENGAGED = slice(0, 1)\n  # next 2, 4, 6, 8, 10 seconds\n  GAS_DISENGAGE = slice(1, 36, 7)\n  BRAKE_DISENGAGE = slice(2, 36, 7)\n  STEER_OVERRIDE = slice(3, 36, 7)\n  HARD_BRAKE_3 = slice(4, 36, 7)\n  HARD_BRAKE_4 = slice(5, 36, 7)\n  HARD_BRAKE_5 = slice(6, 36, 7)\n  GAS_PRESS = slice(7, 36, 7)\n  # next 0, 2, 4, 6, 8, 10 seconds\n  LEFT_BLINKER = slice(36, 48, 2)\n  RIGHT_BLINKER = slice(37, 48, 2)\n", "selfdrive/modeld/parse_model_outputs.py": "import numpy as np\nfrom openpilot.selfdrive.modeld.constants import ModelConstants\n\ndef sigmoid(x):\n  return 1. / (1. + np.exp(-x))\n\ndef softmax(x, axis=-1):\n  x -= np.max(x, axis=axis, keepdims=True)\n  if x.dtype == np.float32 or x.dtype == np.float64:\n    np.exp(x, out=x)\n  else:\n    x = np.exp(x)\n  x /= np.sum(x, axis=axis, keepdims=True)\n  return x\n\nclass Parser:\n  def __init__(self, ignore_missing=False):\n    self.ignore_missing = ignore_missing\n\n  def check_missing(self, outs, name):\n    if name not in outs and not self.ignore_missing:\n      raise ValueError(f\"Missing output {name}\")\n    return name not in outs\n\n  def parse_categorical_crossentropy(self, name, outs, out_shape=None):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    if out_shape is not None:\n      raw = raw.reshape((raw.shape[0],) + out_shape)\n    outs[name] = softmax(raw, axis=-1)\n\n  def parse_binary_crossentropy(self, name, outs):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    outs[name] = sigmoid(raw)\n\n  def parse_mdn(self, name, outs, in_N=0, out_N=1, out_shape=None):\n    if self.check_missing(outs, name):\n      return\n    raw = outs[name]\n    raw = raw.reshape((raw.shape[0], max(in_N, 1), -1))\n\n    pred_mu = raw[:,:,:(raw.shape[2] - out_N)//2]\n    n_values = (raw.shape[2] - out_N)//2\n    pred_mu = raw[:,:,:n_values]\n    pred_std = np.exp(raw[:,:,n_values: 2*n_values])\n\n    if in_N > 1:\n      weights = np.zeros((raw.shape[0], in_N, out_N), dtype=raw.dtype)\n      for i in range(out_N):\n        weights[:,:,i - out_N] = softmax(raw[:,:,i - out_N], axis=-1)\n\n      if out_N == 1:\n        for fidx in range(weights.shape[0]):\n          idxs = np.argsort(weights[fidx][:,0])[::-1]\n          weights[fidx] = weights[fidx][idxs]\n          pred_mu[fidx] = pred_mu[fidx][idxs]\n          pred_std[fidx] = pred_std[fidx][idxs]\n      full_shape = tuple([raw.shape[0], in_N] + list(out_shape))\n      outs[name + '_weights'] = weights\n      outs[name + '_hypotheses'] = pred_mu.reshape(full_shape)\n      outs[name + '_stds_hypotheses'] = pred_std.reshape(full_shape)\n\n      pred_mu_final = np.zeros((raw.shape[0], out_N, n_values), dtype=raw.dtype)\n      pred_std_final = np.zeros((raw.shape[0], out_N, n_values), dtype=raw.dtype)\n      for fidx in range(weights.shape[0]):\n        for hidx in range(out_N):\n          idxs = np.argsort(weights[fidx,:,hidx])[::-1]\n          pred_mu_final[fidx, hidx] = pred_mu[fidx, idxs[0]]\n          pred_std_final[fidx, hidx] = pred_std[fidx, idxs[0]]\n    else:\n      pred_mu_final = pred_mu\n      pred_std_final = pred_std\n\n    if out_N > 1:\n      final_shape = tuple([raw.shape[0], out_N] + list(out_shape))\n    else:\n      final_shape = tuple([raw.shape[0],] + list(out_shape))\n    outs[name] = pred_mu_final.reshape(final_shape)\n    outs[name + '_stds'] = pred_std_final.reshape(final_shape)\n\n  def parse_outputs(self, outs: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    self.parse_mdn('plan', outs, in_N=ModelConstants.PLAN_MHP_N, out_N=ModelConstants.PLAN_MHP_SELECTION,\n                   out_shape=(ModelConstants.IDX_N,ModelConstants.PLAN_WIDTH))\n    self.parse_mdn('lane_lines', outs, in_N=0, out_N=0, out_shape=(ModelConstants.NUM_LANE_LINES,ModelConstants.IDX_N,ModelConstants.LANE_LINES_WIDTH))\n    self.parse_mdn('road_edges', outs, in_N=0, out_N=0, out_shape=(ModelConstants.NUM_ROAD_EDGES,ModelConstants.IDX_N,ModelConstants.LANE_LINES_WIDTH))\n    self.parse_mdn('pose', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('road_transform', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('sim_pose', outs, in_N=0, out_N=0, out_shape=(ModelConstants.POSE_WIDTH,))\n    self.parse_mdn('wide_from_device_euler', outs, in_N=0, out_N=0, out_shape=(ModelConstants.WIDE_FROM_DEVICE_WIDTH,))\n    self.parse_mdn('lead', outs, in_N=ModelConstants.LEAD_MHP_N, out_N=ModelConstants.LEAD_MHP_SELECTION,\n                   out_shape=(ModelConstants.LEAD_TRAJ_LEN,ModelConstants.LEAD_WIDTH))\n    if 'lat_planner_solution' in outs:\n      self.parse_mdn('lat_planner_solution', outs, in_N=0, out_N=0, out_shape=(ModelConstants.IDX_N,ModelConstants.LAT_PLANNER_SOLUTION_WIDTH))\n    if 'desired_curvature' in outs:\n      self.parse_mdn('desired_curvature', outs, in_N=0, out_N=0, out_shape=(ModelConstants.DESIRED_CURV_WIDTH,))\n    for k in ['lead_prob', 'lane_lines_prob', 'meta']:\n      self.parse_binary_crossentropy(k, outs)\n    self.parse_categorical_crossentropy('desire_state', outs, out_shape=(ModelConstants.DESIRE_PRED_WIDTH,))\n    self.parse_categorical_crossentropy('desire_pred', outs, out_shape=(ModelConstants.DESIRE_PRED_LEN,ModelConstants.DESIRE_PRED_WIDTH))\n    return outs\n", "selfdrive/modeld/dmonitoringmodeld.py": "#!/usr/bin/env python3\nimport os\nimport gc\nimport math\nimport time\nimport ctypes\nimport numpy as np\nfrom pathlib import Path\n\nfrom cereal import messaging\nfrom cereal.messaging import PubMaster, SubMaster\nfrom msgq.visionipc import VisionIpcClient, VisionStreamType, VisionBuf\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import set_realtime_priority\nfrom openpilot.selfdrive.modeld.runners import ModelRunner, Runtime\nfrom openpilot.selfdrive.modeld.models.commonmodel_pyx import sigmoid\n\nCALIB_LEN = 3\nREG_SCALE = 0.25\nMODEL_WIDTH = 1440\nMODEL_HEIGHT = 960\nOUTPUT_SIZE = 84\nSEND_RAW_PRED = os.getenv('SEND_RAW_PRED')\nMODEL_PATHS = {\n  ModelRunner.SNPE: Path(__file__).parent / 'models/dmonitoring_model_q.dlc',\n  ModelRunner.ONNX: Path(__file__).parent / 'models/dmonitoring_model.onnx'}\n\nclass DriverStateResult(ctypes.Structure):\n  _fields_ = [\n    (\"face_orientation\", ctypes.c_float*3),\n    (\"face_position\", ctypes.c_float*3),\n    (\"face_orientation_std\", ctypes.c_float*3),\n    (\"face_position_std\", ctypes.c_float*3),\n    (\"face_prob\", ctypes.c_float),\n    (\"_unused_a\", ctypes.c_float*8),\n    (\"left_eye_prob\", ctypes.c_float),\n    (\"_unused_b\", ctypes.c_float*8),\n    (\"right_eye_prob\", ctypes.c_float),\n    (\"left_blink_prob\", ctypes.c_float),\n    (\"right_blink_prob\", ctypes.c_float),\n    (\"sunglasses_prob\", ctypes.c_float),\n    (\"occluded_prob\", ctypes.c_float),\n    (\"ready_prob\", ctypes.c_float*4),\n    (\"not_ready_prob\", ctypes.c_float*2)]\n\nclass DMonitoringModelResult(ctypes.Structure):\n  _fields_ = [\n    (\"driver_state_lhd\", DriverStateResult),\n    (\"driver_state_rhd\", DriverStateResult),\n    (\"poor_vision_prob\", ctypes.c_float),\n    (\"wheel_on_right_prob\", ctypes.c_float)]\n\nclass ModelState:\n  inputs: dict[str, np.ndarray]\n  output: np.ndarray\n  model: ModelRunner\n\n  def __init__(self):\n    assert ctypes.sizeof(DMonitoringModelResult) == OUTPUT_SIZE * ctypes.sizeof(ctypes.c_float)\n    self.output = np.zeros(OUTPUT_SIZE, dtype=np.float32)\n    self.inputs = {\n      'input_img': np.zeros(MODEL_HEIGHT * MODEL_WIDTH, dtype=np.uint8),\n      'calib': np.zeros(CALIB_LEN, dtype=np.float32)}\n\n    self.model = ModelRunner(MODEL_PATHS, self.output, Runtime.DSP, True, None)\n    self.model.addInput(\"input_img\", None)\n    self.model.addInput(\"calib\", self.inputs['calib'])\n\n  def run(self, buf:VisionBuf, calib:np.ndarray) -> tuple[np.ndarray, float]:\n    self.inputs['calib'][:] = calib\n\n    v_offset = buf.height - MODEL_HEIGHT\n    h_offset = (buf.width - MODEL_WIDTH) // 2\n    buf_data = buf.data.reshape(-1, buf.stride)\n    input_data = self.inputs['input_img'].reshape(MODEL_HEIGHT, MODEL_WIDTH)\n    input_data[:] = buf_data[v_offset:v_offset+MODEL_HEIGHT, h_offset:h_offset+MODEL_WIDTH]\n\n    t1 = time.perf_counter()\n    self.model.setInputBuffer(\"input_img\", self.inputs['input_img'].view(np.float32))\n    self.model.execute()\n    t2 = time.perf_counter()\n    return self.output, t2 - t1\n\n\ndef fill_driver_state(msg, ds_result: DriverStateResult):\n  msg.faceOrientation = [x * REG_SCALE for x in ds_result.face_orientation]\n  msg.faceOrientationStd = [math.exp(x) for x in ds_result.face_orientation_std]\n  msg.facePosition = [x * REG_SCALE for x in ds_result.face_position[:2]]\n  msg.facePositionStd = [math.exp(x) for x in ds_result.face_position_std[:2]]\n  msg.faceProb = sigmoid(ds_result.face_prob)\n  msg.leftEyeProb = sigmoid(ds_result.left_eye_prob)\n  msg.rightEyeProb = sigmoid(ds_result.right_eye_prob)\n  msg.leftBlinkProb = sigmoid(ds_result.left_blink_prob)\n  msg.rightBlinkProb = sigmoid(ds_result.right_blink_prob)\n  msg.sunglassesProb = sigmoid(ds_result.sunglasses_prob)\n  msg.occludedProb = sigmoid(ds_result.occluded_prob)\n  msg.readyProb = [sigmoid(x) for x in ds_result.ready_prob]\n  msg.notReadyProb = [sigmoid(x) for x in ds_result.not_ready_prob]\n\ndef get_driverstate_packet(model_output: np.ndarray, frame_id: int, location_ts: int, execution_time: float, dsp_execution_time: float):\n  model_result = ctypes.cast(model_output.ctypes.data, ctypes.POINTER(DMonitoringModelResult)).contents\n  msg = messaging.new_message('driverStateV2', valid=True)\n  ds = msg.driverStateV2\n  ds.frameId = frame_id\n  ds.modelExecutionTime = execution_time\n  ds.dspExecutionTime = dsp_execution_time\n  ds.poorVisionProb = sigmoid(model_result.poor_vision_prob)\n  ds.wheelOnRightProb = sigmoid(model_result.wheel_on_right_prob)\n  ds.rawPredictions = model_output.tobytes() if SEND_RAW_PRED else b''\n  fill_driver_state(ds.leftDriverData, model_result.driver_state_lhd)\n  fill_driver_state(ds.rightDriverData, model_result.driver_state_rhd)\n  return msg\n\n\ndef main():\n  gc.disable()\n  set_realtime_priority(1)\n\n  model = ModelState()\n  cloudlog.warning(\"models loaded, dmonitoringmodeld starting\")\n  Params().put_bool(\"DmModelInitialized\", True)\n\n  cloudlog.warning(\"connecting to driver stream\")\n  vipc_client = VisionIpcClient(\"camerad\", VisionStreamType.VISION_STREAM_DRIVER, True)\n  while not vipc_client.connect(False):\n    time.sleep(0.1)\n  assert vipc_client.is_connected()\n  cloudlog.warning(f\"connected with buffer size: {vipc_client.buffer_len}\")\n\n  sm = SubMaster([\"liveCalibration\"])\n  pm = PubMaster([\"driverStateV2\"])\n\n  calib = np.zeros(CALIB_LEN, dtype=np.float32)\n  # last = 0\n\n  while True:\n    buf = vipc_client.recv()\n    if buf is None:\n      continue\n\n    sm.update(0)\n    if sm.updated[\"liveCalibration\"]:\n      calib[:] = np.array(sm[\"liveCalibration\"].rpyCalib)\n\n    t1 = time.perf_counter()\n    model_output, dsp_execution_time = model.run(buf, calib)\n    t2 = time.perf_counter()\n\n    pm.send(\"driverStateV2\", get_driverstate_packet(model_output, vipc_client.frame_id, vipc_client.timestamp_sof, t2 - t1, dsp_execution_time))\n    # print(\"dmonitoring process: %.2fms, from last %.2fms\\n\" % (t2 - t1, t1 - last))\n    # last = t1\n\n\nif __name__ == \"__main__\":\n  main()\n", "selfdrive/modeld/__init__.py": "", "selfdrive/modeld/modeld.py": "#!/usr/bin/env python3\nimport os\nimport time\nimport pickle\nimport numpy as np\nimport cereal.messaging as messaging\nfrom cereal import car, log\nfrom pathlib import Path\nfrom openpilot.common.threadname import setthreadname\nfrom cereal.messaging import PubMaster, SubMaster\nfrom msgq.visionipc import VisionIpcClient, VisionStreamType, VisionBuf\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.common.params import Params\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.realtime import config_realtime_process\nfrom openpilot.common.transformations.camera import DEVICE_CAMERAS\nfrom openpilot.common.transformations.model import get_warp_matrix\nfrom openpilot.system import sentry\nfrom openpilot.selfdrive.car.car_helpers import get_demo_car_params\nfrom openpilot.selfdrive.controls.lib.desire_helper import DesireHelper\nfrom openpilot.selfdrive.modeld.runners import ModelRunner, Runtime\nfrom openpilot.selfdrive.modeld.parse_model_outputs import Parser\nfrom openpilot.selfdrive.modeld.fill_model_msg import fill_model_msg, fill_pose_msg, PublishState\nfrom openpilot.selfdrive.modeld.constants import ModelConstants\nfrom openpilot.selfdrive.modeld.models.commonmodel_pyx import ModelFrame, CLContext\n\nTHREAD_NAME = \"selfdrive.modeld.modeld\"\nSEND_RAW_PRED = os.getenv('SEND_RAW_PRED')\n\nMODEL_PATHS = {\n  ModelRunner.THNEED: Path(__file__).parent / 'models/supercombo.thneed',\n  ModelRunner.ONNX: Path(__file__).parent / 'models/supercombo.onnx'}\n\nMETADATA_PATH = Path(__file__).parent / 'models/supercombo_metadata.pkl'\n\nclass FrameMeta:\n  frame_id: int = 0\n  timestamp_sof: int = 0\n  timestamp_eof: int = 0\n\n  def __init__(self, vipc=None):\n    if vipc is not None:\n      self.frame_id, self.timestamp_sof, self.timestamp_eof = vipc.frame_id, vipc.timestamp_sof, vipc.timestamp_eof\n\nclass ModelState:\n  frame: ModelFrame\n  wide_frame: ModelFrame\n  inputs: dict[str, np.ndarray]\n  output: np.ndarray\n  prev_desire: np.ndarray  # for tracking the rising edge of the pulse\n  model: ModelRunner\n\n  def __init__(self, context: CLContext):\n    self.frame = ModelFrame(context)\n    self.wide_frame = ModelFrame(context)\n    self.prev_desire = np.zeros(ModelConstants.DESIRE_LEN, dtype=np.float32)\n    self.inputs = {\n      'desire': np.zeros(ModelConstants.DESIRE_LEN * (ModelConstants.HISTORY_BUFFER_LEN+1), dtype=np.float32),\n      'traffic_convention': np.zeros(ModelConstants.TRAFFIC_CONVENTION_LEN, dtype=np.float32),\n      'lateral_control_params': np.zeros(ModelConstants.LATERAL_CONTROL_PARAMS_LEN, dtype=np.float32),\n      'prev_desired_curv': np.zeros(ModelConstants.PREV_DESIRED_CURV_LEN * (ModelConstants.HISTORY_BUFFER_LEN+1), dtype=np.float32),\n      'features_buffer': np.zeros(ModelConstants.HISTORY_BUFFER_LEN * ModelConstants.FEATURE_LEN, dtype=np.float32),\n    }\n\n    with open(METADATA_PATH, 'rb') as f:\n      model_metadata = pickle.load(f)\n\n    self.output_slices = model_metadata['output_slices']\n    net_output_size = model_metadata['output_shapes']['outputs'][1]\n    self.output = np.zeros(net_output_size, dtype=np.float32)\n    self.parser = Parser()\n\n    self.model = ModelRunner(MODEL_PATHS, self.output, Runtime.GPU, False, context)\n    self.model.addInput(\"input_imgs\", None)\n    self.model.addInput(\"big_input_imgs\", None)\n    for k,v in self.inputs.items():\n      self.model.addInput(k, v)\n\n  def slice_outputs(self, model_outputs: np.ndarray) -> dict[str, np.ndarray]:\n    parsed_model_outputs = {k: model_outputs[np.newaxis, v] for k,v in self.output_slices.items()}\n    if SEND_RAW_PRED:\n      parsed_model_outputs['raw_pred'] = model_outputs.copy()\n    return parsed_model_outputs\n\n  def run(self, buf: VisionBuf, wbuf: VisionBuf, transform: np.ndarray, transform_wide: np.ndarray,\n                inputs: dict[str, np.ndarray], prepare_only: bool) -> dict[str, np.ndarray] | None:\n    # Model decides when action is completed, so desire input is just a pulse triggered on rising edge\n    inputs['desire'][0] = 0\n    self.inputs['desire'][:-ModelConstants.DESIRE_LEN] = self.inputs['desire'][ModelConstants.DESIRE_LEN:]\n    self.inputs['desire'][-ModelConstants.DESIRE_LEN:] = np.where(inputs['desire'] - self.prev_desire > .99, inputs['desire'], 0)\n    self.prev_desire[:] = inputs['desire']\n\n    self.inputs['traffic_convention'][:] = inputs['traffic_convention']\n    self.inputs['lateral_control_params'][:] = inputs['lateral_control_params']\n\n    # if getCLBuffer is not None, frame will be None\n    self.model.setInputBuffer(\"input_imgs\", self.frame.prepare(buf, transform.flatten(), self.model.getCLBuffer(\"input_imgs\")))\n    if wbuf is not None:\n      self.model.setInputBuffer(\"big_input_imgs\", self.wide_frame.prepare(wbuf, transform_wide.flatten(), self.model.getCLBuffer(\"big_input_imgs\")))\n\n    if prepare_only:\n      return None\n\n    self.model.execute()\n    outputs = self.parser.parse_outputs(self.slice_outputs(self.output))\n\n    self.inputs['features_buffer'][:-ModelConstants.FEATURE_LEN] = self.inputs['features_buffer'][ModelConstants.FEATURE_LEN:]\n    self.inputs['features_buffer'][-ModelConstants.FEATURE_LEN:] = outputs['hidden_state'][0, :]\n    self.inputs['prev_desired_curv'][:-ModelConstants.PREV_DESIRED_CURV_LEN] = self.inputs['prev_desired_curv'][ModelConstants.PREV_DESIRED_CURV_LEN:]\n    self.inputs['prev_desired_curv'][-ModelConstants.PREV_DESIRED_CURV_LEN:] = outputs['desired_curvature'][0, :]\n    return outputs\n\n\ndef main(demo=False):\n  cloudlog.warning(\"modeld init\")\n\n  sentry.set_tag(\"daemon\", THREAD_NAME)\n  cloudlog.bind(daemon=THREAD_NAME)\n  setthreadname(\"modeld\")\n  config_realtime_process(7, 54)\n\n  cloudlog.warning(\"setting up CL context\")\n  cl_context = CLContext()\n  cloudlog.warning(\"CL context ready; loading model\")\n  model = ModelState(cl_context)\n  cloudlog.warning(\"models loaded, modeld starting\")\n\n  # visionipc clients\n  while True:\n    available_streams = VisionIpcClient.available_streams(\"camerad\", block=False)\n    if available_streams:\n      use_extra_client = VisionStreamType.VISION_STREAM_WIDE_ROAD in available_streams and VisionStreamType.VISION_STREAM_ROAD in available_streams\n      main_wide_camera = VisionStreamType.VISION_STREAM_ROAD not in available_streams\n      break\n    time.sleep(.1)\n\n  vipc_client_main_stream = VisionStreamType.VISION_STREAM_WIDE_ROAD if main_wide_camera else VisionStreamType.VISION_STREAM_ROAD\n  vipc_client_main = VisionIpcClient(\"camerad\", vipc_client_main_stream, True, cl_context)\n  vipc_client_extra = VisionIpcClient(\"camerad\", VisionStreamType.VISION_STREAM_WIDE_ROAD, False, cl_context)\n  cloudlog.warning(f\"vision stream set up, main_wide_camera: {main_wide_camera}, use_extra_client: {use_extra_client}\")\n\n  while not vipc_client_main.connect(False):\n    time.sleep(0.1)\n  while use_extra_client and not vipc_client_extra.connect(False):\n    time.sleep(0.1)\n\n  cloudlog.warning(f\"connected main cam with buffer size: {vipc_client_main.buffer_len} ({vipc_client_main.width} x {vipc_client_main.height})\")\n  if use_extra_client:\n    cloudlog.warning(f\"connected extra cam with buffer size: {vipc_client_extra.buffer_len} ({vipc_client_extra.width} x {vipc_client_extra.height})\")\n\n  # messaging\n  pm = PubMaster([\"modelV2\", \"cameraOdometry\"])\n  sm = SubMaster([\"deviceState\", \"carState\", \"roadCameraState\", \"liveCalibration\", \"driverMonitoringState\", \"carControl\"])\n\n  publish_state = PublishState()\n  params = Params()\n\n  # setup filter to track dropped frames\n  frame_dropped_filter = FirstOrderFilter(0., 10., 1. / ModelConstants.MODEL_FREQ)\n  frame_id = 0\n  last_vipc_frame_id = 0\n  run_count = 0\n\n  model_transform_main = np.zeros((3, 3), dtype=np.float32)\n  model_transform_extra = np.zeros((3, 3), dtype=np.float32)\n  live_calib_seen = False\n  buf_main, buf_extra = None, None\n  meta_main = FrameMeta()\n  meta_extra = FrameMeta()\n\n\n  if demo:\n    CP = get_demo_car_params()\n  else:\n    with car.CarParams.from_bytes(params.get(\"CarParams\", block=True)) as msg:\n      CP = msg\n  cloudlog.info(\"modeld got CarParams: %s\", CP.carName)\n\n  # TODO this needs more thought, use .2s extra for now to estimate other delays\n  steer_delay = CP.steerActuatorDelay + .2\n\n  DH = DesireHelper()\n\n  while True:\n    # Keep receiving frames until we are at least 1 frame ahead of previous extra frame\n    while meta_main.timestamp_sof < meta_extra.timestamp_sof + 25000000:\n      buf_main = vipc_client_main.recv()\n      meta_main = FrameMeta(vipc_client_main)\n      if buf_main is None:\n        break\n\n    if buf_main is None:\n      cloudlog.debug(\"vipc_client_main no frame\")\n      continue\n\n    if use_extra_client:\n      # Keep receiving extra frames until frame id matches main camera\n      while True:\n        buf_extra = vipc_client_extra.recv()\n        meta_extra = FrameMeta(vipc_client_extra)\n        if buf_extra is None or meta_main.timestamp_sof < meta_extra.timestamp_sof + 25000000:\n          break\n\n      if buf_extra is None:\n        cloudlog.debug(\"vipc_client_extra no frame\")\n        continue\n\n      if abs(meta_main.timestamp_sof - meta_extra.timestamp_sof) > 10000000:\n        cloudlog.error(f\"frames out of sync! main: {meta_main.frame_id} ({meta_main.timestamp_sof / 1e9:.5f}),\\\n                         extra: {meta_extra.frame_id} ({meta_extra.timestamp_sof / 1e9:.5f})\")\n\n    else:\n      # Use single camera\n      buf_extra = buf_main\n      meta_extra = meta_main\n\n    sm.update(0)\n    desire = DH.desire\n    is_rhd = sm[\"driverMonitoringState\"].isRHD\n    frame_id = sm[\"roadCameraState\"].frameId\n    lateral_control_params = np.array([sm[\"carState\"].vEgo, steer_delay], dtype=np.float32)\n    if sm.updated[\"liveCalibration\"] and sm.seen['roadCameraState'] and sm.seen['deviceState']:\n      device_from_calib_euler = np.array(sm[\"liveCalibration\"].rpyCalib, dtype=np.float32)\n      dc = DEVICE_CAMERAS[(str(sm['deviceState'].deviceType), str(sm['roadCameraState'].sensor))]\n      model_transform_main = get_warp_matrix(device_from_calib_euler, dc.ecam.intrinsics if main_wide_camera else dc.fcam.intrinsics, False).astype(np.float32)\n      model_transform_extra = get_warp_matrix(device_from_calib_euler, dc.ecam.intrinsics, True).astype(np.float32)\n      live_calib_seen = True\n\n    traffic_convention = np.zeros(2)\n    traffic_convention[int(is_rhd)] = 1\n\n    vec_desire = np.zeros(ModelConstants.DESIRE_LEN, dtype=np.float32)\n    if desire >= 0 and desire < ModelConstants.DESIRE_LEN:\n      vec_desire[desire] = 1\n\n    # tracked dropped frames\n    vipc_dropped_frames = max(0, meta_main.frame_id - last_vipc_frame_id - 1)\n    frames_dropped = frame_dropped_filter.update(min(vipc_dropped_frames, 10))\n    if run_count < 10: # let frame drops warm up\n      frame_dropped_filter.x = 0.\n      frames_dropped = 0.\n    run_count = run_count + 1\n\n    frame_drop_ratio = frames_dropped / (1 + frames_dropped)\n    prepare_only = vipc_dropped_frames > 0\n    if prepare_only:\n      cloudlog.error(f\"skipping model eval. Dropped {vipc_dropped_frames} frames\")\n\n    inputs:dict[str, np.ndarray] = {\n      'desire': vec_desire,\n      'traffic_convention': traffic_convention,\n      'lateral_control_params': lateral_control_params,\n      }\n\n    mt1 = time.perf_counter()\n    model_output = model.run(buf_main, buf_extra, model_transform_main, model_transform_extra, inputs, prepare_only)\n    mt2 = time.perf_counter()\n    model_execution_time = mt2 - mt1\n\n    if model_output is not None:\n      modelv2_send = messaging.new_message('modelV2')\n      posenet_send = messaging.new_message('cameraOdometry')\n      fill_model_msg(modelv2_send, model_output, publish_state, meta_main.frame_id, meta_extra.frame_id, frame_id, frame_drop_ratio,\n                      meta_main.timestamp_eof, model_execution_time, live_calib_seen)\n\n      desire_state = modelv2_send.modelV2.meta.desireState\n      l_lane_change_prob = desire_state[log.Desire.laneChangeLeft]\n      r_lane_change_prob = desire_state[log.Desire.laneChangeRight]\n      lane_change_prob = l_lane_change_prob + r_lane_change_prob\n      DH.update(sm['carState'], sm['carControl'].latActive, lane_change_prob)\n      modelv2_send.modelV2.meta.laneChangeState = DH.lane_change_state\n      modelv2_send.modelV2.meta.laneChangeDirection = DH.lane_change_direction\n\n      fill_pose_msg(posenet_send, model_output, meta_main.frame_id, vipc_dropped_frames, meta_main.timestamp_eof, live_calib_seen)\n      pm.send('modelV2', modelv2_send)\n      pm.send('cameraOdometry', posenet_send)\n\n    last_vipc_frame_id = meta_main.frame_id\n\n\nif __name__ == \"__main__\":\n  try:\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--demo', action='store_true', help='A boolean for demo mode.')\n    args = parser.parse_args()\n    main(demo=args.demo)\n  except KeyboardInterrupt:\n    cloudlog.warning(f\"child {THREAD_NAME} got SIGINT\")\n  except Exception:\n    sentry.capture_exception()\n    raise\n", "selfdrive/modeld/models/__init__.py": "", "selfdrive/modeld/thneed/__init__.py": "", "selfdrive/modeld/runners/onnxmodel.py": "import onnx\nimport itertools\nimport os\nimport sys\nimport numpy as np\nfrom typing import Any\n\nfrom openpilot.selfdrive.modeld.runners.runmodel_pyx import RunModel\n\nORT_TYPES_TO_NP_TYPES = {'tensor(float16)': np.float16, 'tensor(float)': np.float32, 'tensor(uint8)': np.uint8}\n\ndef attributeproto_fp16_to_fp32(attr):\n  float32_list = np.frombuffer(attr.raw_data, dtype=np.float16)\n  attr.data_type = 1\n  attr.raw_data = float32_list.astype(np.float32).tobytes()\n\ndef convert_fp16_to_fp32(path):\n  model = onnx.load(path)\n  for i in model.graph.initializer:\n    if i.data_type == 10:\n      attributeproto_fp16_to_fp32(i)\n  for i in itertools.chain(model.graph.input, model.graph.output):\n    if i.type.tensor_type.elem_type == 10:\n      i.type.tensor_type.elem_type = 1\n  for i in model.graph.node:\n    for a in i.attribute:\n      if hasattr(a, 't'):\n        if a.t.data_type == 10:\n          attributeproto_fp16_to_fp32(a.t)\n  return model.SerializeToString()\n\ndef create_ort_session(path, fp16_to_fp32):\n  os.environ[\"OMP_NUM_THREADS\"] = \"4\"\n  os.environ[\"OMP_WAIT_POLICY\"] = \"PASSIVE\"\n\n  import onnxruntime as ort\n  print(\"Onnx available providers: \", ort.get_available_providers(), file=sys.stderr)\n  options = ort.SessionOptions()\n  options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_DISABLE_ALL\n\n  provider: str | tuple[str, dict[Any, Any]]\n  if 'OpenVINOExecutionProvider' in ort.get_available_providers() and 'ONNXCPU' not in os.environ:\n    provider = 'OpenVINOExecutionProvider'\n  elif 'CUDAExecutionProvider' in ort.get_available_providers() and 'ONNXCPU' not in os.environ:\n    options.intra_op_num_threads = 2\n    provider = ('CUDAExecutionProvider', {'cudnn_conv_algo_search': 'DEFAULT'})\n  else:\n    options.intra_op_num_threads = 2\n    options.execution_mode = ort.ExecutionMode.ORT_SEQUENTIAL\n    options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL\n    provider = 'CPUExecutionProvider'\n\n  model_data = convert_fp16_to_fp32(path) if fp16_to_fp32 else path\n  print(\"Onnx selected provider: \", [provider], file=sys.stderr)\n  ort_session = ort.InferenceSession(model_data, options, providers=[provider])\n  print(\"Onnx using \", ort_session.get_providers(), file=sys.stderr)\n  return ort_session\n\n\nclass ONNXModel(RunModel):\n  def __init__(self, path, output, runtime, use_tf8, cl_context):\n    self.inputs = {}\n    self.output = output\n    self.use_tf8 = use_tf8\n\n    self.session = create_ort_session(path, fp16_to_fp32=True)\n    self.input_names = [x.name for x in self.session.get_inputs()]\n    self.input_shapes = {x.name: [1, *x.shape[1:]] for x in self.session.get_inputs()}\n    self.input_dtypes = {x.name: ORT_TYPES_TO_NP_TYPES[x.type] for x in self.session.get_inputs()}\n\n    # run once to initialize CUDA provider\n    if \"CUDAExecutionProvider\" in self.session.get_providers():\n      self.session.run(None, {k: np.zeros(self.input_shapes[k], dtype=self.input_dtypes[k]) for k in self.input_names})\n    print(\"ready to run onnx model\", self.input_shapes, file=sys.stderr)\n\n  def addInput(self, name, buffer):\n    assert name in self.input_names\n    self.inputs[name] = buffer\n\n  def setInputBuffer(self, name, buffer):\n    assert name in self.inputs\n    self.inputs[name] = buffer\n\n  def getCLBuffer(self, name):\n    return None\n\n  def execute(self):\n    inputs = {k: (v.view(np.uint8) / 255. if self.use_tf8 and k == 'input_img' else v) for k,v in self.inputs.items()}\n    inputs = {k: v.reshape(self.input_shapes[k]).astype(self.input_dtypes[k]) for k,v in inputs.items()}\n    outputs = self.session.run(None, inputs)\n    assert len(outputs) == 1, \"Only single model outputs are supported\"\n    self.output[:] = outputs[0]\n    return self.output\n", "selfdrive/modeld/runners/__init__.py": "import os\nfrom openpilot.system.hardware import TICI\nfrom openpilot.selfdrive.modeld.runners.runmodel_pyx import RunModel, Runtime\nassert Runtime\n\nUSE_THNEED = int(os.getenv('USE_THNEED', str(int(TICI))))\nUSE_SNPE = int(os.getenv('USE_SNPE', str(int(TICI))))\n\nclass ModelRunner(RunModel):\n  THNEED = 'THNEED'\n  SNPE = 'SNPE'\n  ONNX = 'ONNX'\n\n  def __new__(cls, paths, *args, **kwargs):\n    if ModelRunner.THNEED in paths and USE_THNEED:\n      from openpilot.selfdrive.modeld.runners.thneedmodel_pyx import ThneedModel as Runner\n      runner_type = ModelRunner.THNEED\n    elif ModelRunner.SNPE in paths and USE_SNPE:\n      from openpilot.selfdrive.modeld.runners.snpemodel_pyx import SNPEModel as Runner\n      runner_type = ModelRunner.SNPE\n    elif ModelRunner.ONNX in paths:\n      from openpilot.selfdrive.modeld.runners.onnxmodel import ONNXModel as Runner\n      runner_type = ModelRunner.ONNX\n    else:\n      raise Exception(\"Couldn't select a model runner, make sure to pass at least one valid model path\")\n\n    return Runner(str(paths[runner_type]), *args, **kwargs)\n", "system/ugpsd.py": "#!/usr/bin/env python3\nimport os\nimport time\nimport traceback\nimport serial\nimport datetime\nimport numpy as np\nfrom collections import defaultdict\n\nfrom cereal import log\nimport cereal.messaging as messaging\nfrom openpilot.common.retry import retry\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.qcomgpsd.qcomgpsd import at_cmd, wait_for_modem\n\n\ndef sfloat(n: str):\n  return float(n) if len(n) > 0 else 0\n\ndef checksum(s: str):\n  ret = 0\n  for c in s[1:-3]:\n    ret ^= ord(c)\n  return format(ret, '02X')\n\nclass Unicore:\n  def __init__(self):\n    self.s = serial.Serial('/dev/ttyHS0', 115200)\n    self.s.timeout = 1\n    self.s.writeTimeout = 1\n    self.s.newline = b'\\r\\n'\n\n    self.s.flush()\n    self.s.reset_input_buffer()\n    self.s.reset_output_buffer()\n    self.s.read(2048)\n\n  def send(self, cmd):\n    self.s.write(cmd.encode('utf8') + b'\\r')\n    resp = self.s.read(2048)\n    print(len(resp), cmd, \"\\n\", resp)\n    assert b\"OK\" in resp\n\n  def recv(self):\n    return self.s.readline()\n\ndef build_msg(state):\n  \"\"\"\n    NMEA sentences:\n      https://campar.in.tum.de/twiki/pub/Chair/NaviGpsDemon/nmea.html#RMC\n    NAV messages:\n      https://www.unicorecomm.com/assets/upload/file/UFirebird_Standard_Positioning_Products_Protocol_Specification_CH.pdf\n  \"\"\"\n\n  msg = messaging.new_message('gpsLocation', valid=True)\n  gps = msg.gpsLocation\n\n  gnrmc = state['$GNRMC']\n  gps.hasFix = gnrmc[1] == 'A'\n  gps.source = log.GpsLocationData.SensorSource.unicore\n  gps.latitude = (sfloat(gnrmc[3][:2]) + (sfloat(gnrmc[3][2:]) / 60)) * (1 if gnrmc[4] == \"N\" else -1)\n  gps.longitude = (sfloat(gnrmc[5][:3]) + (sfloat(gnrmc[5][3:]) / 60)) * (1 if gnrmc[6] == \"E\" else -1)\n\n  try:\n    date = gnrmc[9][:6]\n    dt = datetime.datetime.strptime(f\"{date} {gnrmc[1]}\", '%d%m%y %H%M%S.%f')\n    gps.unixTimestampMillis = dt.timestamp()*1e3\n  except Exception:\n    pass\n\n  gps.bearingDeg = sfloat(gnrmc[8])\n\n  if len(state['$GNGGA']):\n    gngga = state['$GNGGA']\n    if gngga[10] == 'M':\n      gps.altitude = sfloat(gngga[9])\n\n  if len(state['$GNGSA']):\n    gngsa = state['$GNGSA']\n    gps.horizontalAccuracy = sfloat(gngsa[4])\n    gps.verticalAccuracy = sfloat(gngsa[5])\n\n  #if len(state['$NAVACC']):\n  #  # $NAVVEL,264415000,5,3,0.375,0.141,-0.735,-65.450*2A\n  #  navacc = state['$NAVACC']\n  #  gps.horizontalAccuracy = sfloat(navacc[3])\n  #  gps.speedAccuracy = sfloat(navacc[4])\n  #  gps.bearingAccuracyDeg = sfloat(navacc[5])\n\n  if len(state['$NAVVEL']):\n    # $NAVVEL,264415000,5,3,0.375,0.141,-0.735,-65.450*2A\n    navvel = state['$NAVVEL']\n    vECEF = [\n      sfloat(navvel[4]),\n      sfloat(navvel[5]),\n      sfloat(navvel[6]),\n    ]\n\n    lat = np.radians(gps.latitude)\n    lon = np.radians(gps.longitude)\n    R = np.array([\n      [-np.sin(lat) * np.cos(lon), -np.sin(lon), -np.cos(lat) * np.cos(lon)],\n      [-np.sin(lat) * np.sin(lon), np.cos(lon), -np.cos(lat) * np.sin(lon)],\n      [np.cos(lat), 0, -np.sin(lat)]\n    ])\n\n    vNED = [float(x) for x in R.dot(vECEF)]\n    gps.vNED = vNED\n    gps.speed = np.linalg.norm(vNED)\n\n  # TODO: set these from the module\n  gps.bearingAccuracyDeg = 5.\n  gps.speedAccuracy = 3.\n\n  return msg\n\n\n@retry(attempts=10, delay=0.1)\ndef setup(u):\n  at_cmd('AT+CGPS=0')\n  at_cmd('AT+CGPS=1')\n  time.sleep(1.0)\n\n  # setup NAVXXX outputs\n  for i in range(4):\n    u.send(f\"$CFGMSG,1,{i},1\")\n  for i in (1, 3):\n    u.send(f\"$CFGMSG,3,{i},1\")\n\n  # 10Hz NAV outputs\n  u.send(\"$CFGNAV,100,100,1000\")\n\n\ndef main():\n  wait_for_modem(\"AT+CGPS?\")\n\n  u = Unicore()\n  setup(u)\n\n  state = defaultdict(list)\n  pm = messaging.PubMaster(['gpsLocation'])\n  while True:\n    try:\n      msg = u.recv().decode('utf8').strip()\n      if \"DEBUG\" in os.environ:\n        print(repr(msg))\n\n      if len(msg) > 0:\n        if checksum(msg) != msg.split('*')[1]:\n          cloudlog.error(f\"invalid checksum: {repr(msg)}\")\n          continue\n\n        k = msg.split(',')[0]\n        state[k] = msg.split(',')\n        if '$GNRMC' not in msg:\n          continue\n\n        pm.send('gpsLocation', build_msg(state))\n    except Exception:\n      traceback.print_exc()\n      cloudlog.exception(\"gps.issue\")\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/statsd.py": "#!/usr/bin/env python3\nimport os\nimport zmq\nimport time\nfrom pathlib import Path\nfrom collections import defaultdict\nfrom datetime import datetime, UTC\nfrom typing import NoReturn\n\nfrom openpilot.common.params import Params\nfrom cereal.messaging import SubMaster\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.hardware import HARDWARE\nfrom openpilot.common.file_helpers import atomic_write_in_dir\nfrom openpilot.system.version import get_build_metadata\nfrom openpilot.system.loggerd.config import STATS_DIR_FILE_LIMIT, STATS_SOCKET, STATS_FLUSH_TIME_S\n\n\nclass METRIC_TYPE:\n  GAUGE = 'g'\n  SAMPLE = 'sa'\n\nclass StatLog:\n  def __init__(self):\n    self.pid = None\n    self.zctx = None\n    self.sock = None\n\n  def connect(self) -> None:\n    self.zctx = zmq.Context()\n    self.sock = self.zctx.socket(zmq.PUSH)\n    self.sock.setsockopt(zmq.LINGER, 10)\n    self.sock.connect(STATS_SOCKET)\n    self.pid = os.getpid()\n\n  def __del__(self):\n    if self.sock is not None:\n      self.sock.close()\n    if self.zctx is not None:\n      self.zctx.term()\n\n  def _send(self, metric: str) -> None:\n    if os.getpid() != self.pid:\n      self.connect()\n\n    try:\n      self.sock.send_string(metric, zmq.NOBLOCK)\n    except zmq.error.Again:\n      # drop :/\n      pass\n\n  def gauge(self, name: str, value: float) -> None:\n    self._send(f\"{name}:{value}|{METRIC_TYPE.GAUGE}\")\n\n  # Samples will be recorded in a buffer and at aggregation time,\n  # statistical properties will be logged (mean, count, percentiles, ...)\n  def sample(self, name: str, value: float):\n    self._send(f\"{name}:{value}|{METRIC_TYPE.SAMPLE}\")\n\n\ndef main() -> NoReturn:\n  dongle_id = Params().get(\"DongleId\", encoding='utf-8')\n  def get_influxdb_line(measurement: str, value: float | dict[str, float],  timestamp: datetime, tags: dict) -> str:\n    res = f\"{measurement}\"\n    for k, v in tags.items():\n      res += f\",{k}={str(v)}\"\n    res += \" \"\n\n    if isinstance(value, float):\n      value = {'value': value}\n\n    for k, v in value.items():\n      res += f\"{k}={v},\"\n\n    res += f\"dongle_id=\\\"{dongle_id}\\\" {int(timestamp.timestamp() * 1e9)}\\n\"\n    return res\n\n  # open statistics socket\n  ctx = zmq.Context.instance()\n  sock = ctx.socket(zmq.PULL)\n  sock.bind(STATS_SOCKET)\n\n  STATS_DIR = Paths.stats_root()\n\n  # initialize stats directory\n  Path(STATS_DIR).mkdir(parents=True, exist_ok=True)\n\n  build_metadata = get_build_metadata()\n\n  # initialize tags\n  tags = {\n    'started': False,\n    'version': build_metadata.openpilot.version,\n    'branch': build_metadata.channel,\n    'dirty': build_metadata.openpilot.is_dirty,\n    'origin': build_metadata.openpilot.git_normalized_origin,\n    'deviceType': HARDWARE.get_device_type(),\n  }\n\n  # subscribe to deviceState for started state\n  sm = SubMaster(['deviceState'])\n\n  idx = 0\n  last_flush_time = time.monotonic()\n  gauges = {}\n  samples: dict[str, list[float]] = defaultdict(list)\n  try:\n    while True:\n      started_prev = sm['deviceState'].started\n      sm.update()\n\n      # Update metrics\n      while True:\n        try:\n          metric = sock.recv_string(zmq.NOBLOCK)\n          try:\n            metric_type = metric.split('|')[1]\n            metric_name = metric.split(':')[0]\n            metric_value = float(metric.split('|')[0].split(':')[1])\n\n            if metric_type == METRIC_TYPE.GAUGE:\n              gauges[metric_name] = metric_value\n            elif metric_type == METRIC_TYPE.SAMPLE:\n              samples[metric_name].append(metric_value)\n            else:\n              cloudlog.event(\"unknown metric type\", metric_type=metric_type)\n          except Exception:\n            cloudlog.event(\"malformed metric\", metric=metric)\n        except zmq.error.Again:\n          break\n\n      # flush when started state changes or after FLUSH_TIME_S\n      if (time.monotonic() > last_flush_time + STATS_FLUSH_TIME_S) or (sm['deviceState'].started != started_prev):\n        result = \"\"\n        current_time = datetime.now(UTC)\n        tags['started'] = sm['deviceState'].started\n\n        for key, value in gauges.items():\n          result += get_influxdb_line(f\"gauge.{key}\", value, current_time, tags)\n\n        for key, values in samples.items():\n          values.sort()\n          sample_count = len(values)\n          sample_sum = sum(values)\n\n          stats = {\n            'count': sample_count,\n            'min': values[0],\n            'max': values[-1],\n            'mean': sample_sum / sample_count,\n          }\n          for percentile in [0.05, 0.5, 0.95]:\n            value = values[int(round(percentile * (sample_count - 1)))]\n            stats[f\"p{int(percentile * 100)}\"] = value\n\n          result += get_influxdb_line(f\"sample.{key}\", stats, current_time, tags)\n\n        # clear intermediate data\n        gauges.clear()\n        samples.clear()\n        last_flush_time = time.monotonic()\n\n        # check that we aren't filling up the drive\n        if len(os.listdir(STATS_DIR)) < STATS_DIR_FILE_LIMIT:\n          if len(result) > 0:\n            stats_path = os.path.join(STATS_DIR, f\"{current_time.timestamp():.0f}_{idx}\")\n            with atomic_write_in_dir(stats_path) as f:\n              f.write(result)\n            idx += 1\n        else:\n          cloudlog.error(\"stats dir full\")\n  finally:\n    sock.close()\n    ctx.term()\n\n\nif __name__ == \"__main__\":\n  main()\nelse:\n  statlog = StatLog()\n", "system/timed.py": "#!/usr/bin/env python3\nimport datetime\nimport subprocess\nimport time\nfrom typing import NoReturn\n\nimport cereal.messaging as messaging\nfrom openpilot.common.time import system_time_valid\nfrom openpilot.common.swaglog import cloudlog\n\n\ndef set_time(new_time):\n  diff = datetime.datetime.now() - new_time\n  if diff < datetime.timedelta(seconds=10):\n    cloudlog.debug(f\"Time diff too small: {diff}\")\n    return\n\n  cloudlog.debug(f\"Setting time to {new_time}\")\n  try:\n    subprocess.run(f\"TZ=UTC date -s '{new_time}'\", shell=True, check=True)\n  except subprocess.CalledProcessError:\n    cloudlog.exception(\"timed.failed_setting_time\")\n\n\ndef main() -> NoReturn:\n  \"\"\"\n    timed has one responsibility:\n    - getting the current time\n\n    GPS directly gives time.\n    AGNOS will also use NTP to update the time.\n  \"\"\"\n\n  pm = messaging.PubMaster(['clocks'])\n  sm = messaging.SubMaster(['liveLocationKalman'])\n  while True:\n    sm.update(1000)\n\n    msg = messaging.new_message('clocks')\n    msg.valid = system_time_valid()\n    msg.clocks.wallTimeNanos = time.time_ns()\n    pm.send('clocks', msg)\n\n    llk = sm['liveLocationKalman']\n    if not llk.gpsOK or (time.monotonic() - sm.logMonoTime['liveLocationKalman']/1e9) > 0.2:\n      continue\n\n    # set time\n    # TODO: account for unixTimesatmpMillis being a (usually short) time in the past\n    gps_time = datetime.datetime.fromtimestamp(llk.unixTimestampMillis / 1000.)\n    set_time(gps_time)\n\n    time.sleep(10)\n\nif __name__ == \"__main__\":\n  main()\n", "system/tombstoned.py": "#!/usr/bin/env python3\nimport datetime\nimport os\nimport re\nimport shutil\nimport signal\nimport subprocess\nimport time\nimport glob\nfrom typing import NoReturn\n\nimport openpilot.system.sentry as sentry\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.version import get_build_metadata\n\nMAX_SIZE = 1_000_000 * 100  # allow up to 100M\nMAX_TOMBSTONE_FN_LEN = 62  # 85 - 23 (\"<dongle id>/crash/\")\n\nTOMBSTONE_DIR = \"/data/tombstones/\"\nAPPORT_DIR = \"/var/crash/\"\n\n\ndef safe_fn(s):\n  extra = ['_']\n  return \"\".join(c for c in s if c.isalnum() or c in extra).rstrip()\n\n\ndef clear_apport_folder():\n  for f in glob.glob(APPORT_DIR + '*'):\n    try:\n      os.remove(f)\n    except Exception:\n      pass\n\n\ndef get_apport_stacktrace(fn):\n  try:\n    cmd = f'apport-retrace -s <(cat <(echo \"Package: openpilot\") \"{fn}\")'\n    return subprocess.check_output(cmd, shell=True, encoding='utf8', timeout=30, executable='/bin/bash')\n  except subprocess.CalledProcessError:\n    return \"Error getting stacktrace\"\n  except subprocess.TimeoutExpired:\n    return \"Timeout getting stacktrace\"\n\n\ndef get_tombstones():\n  \"\"\"Returns list of (filename, ctime) for all crashlogs\"\"\"\n  files = []\n  if os.path.exists(APPORT_DIR):\n    with os.scandir(APPORT_DIR) as d:\n      # Loop over first 1000 directory entries\n      for _, f in zip(range(1000), d, strict=False):\n        if f.name.startswith(\"tombstone\"):\n          files.append((f.path, int(f.stat().st_ctime)))\n        elif f.name.endswith(\".crash\") and f.stat().st_mode == 0o100640:\n          files.append((f.path, int(f.stat().st_ctime)))\n  return files\n\n\ndef report_tombstone_apport(fn):\n  f_size = os.path.getsize(fn)\n  if f_size > MAX_SIZE:\n    cloudlog.error(f\"Tombstone {fn} too big, {f_size}. Skipping...\")\n    return\n\n  message = \"\"  # One line description of the crash\n  contents = \"\"  # Full file contents without coredump\n  path = \"\"  # File path relative to openpilot directory\n\n  proc_maps = False\n\n  with open(fn) as f:\n    for line in f:\n      if \"CoreDump\" in line:\n        break\n      elif \"ProcMaps\" in line:\n        proc_maps = True\n      elif \"ProcStatus\" in line:\n        proc_maps = False\n\n      if not proc_maps:\n        contents += line\n\n      if \"ExecutablePath\" in line:\n        path = line.strip().split(': ')[-1]\n        path = path.replace('/data/openpilot/', '')\n        message += path\n      elif \"Signal\" in line:\n        message += \" - \" + line.strip()\n\n        try:\n          sig_num = int(line.strip().split(': ')[-1])\n          message += \" (\" + signal.Signals(sig_num).name + \")\"\n        except ValueError:\n          pass\n\n  stacktrace = get_apport_stacktrace(fn)\n  stacktrace_s = stacktrace.split('\\n')\n  crash_function = \"No stacktrace\"\n\n  if len(stacktrace_s) > 2:\n    found = False\n\n    # Try to find first entry in openpilot, fall back to first line\n    for line in stacktrace_s:\n      if \"at selfdrive/\" in line:\n        crash_function = line\n        found = True\n        break\n\n    if not found:\n      crash_function = stacktrace_s[1]\n\n    # Remove arguments that can contain pointers to make sentry one-liner unique\n    crash_function = \" \".join(x for x in crash_function.split(' ')[1:] if not x.startswith('0x'))\n    crash_function = re.sub(r'\\(.*?\\)', '', crash_function)\n\n  contents = stacktrace + \"\\n\\n\" + contents\n  message = message + \" - \" + crash_function\n  sentry.report_tombstone(fn, message, contents)\n\n  # Copy crashlog to upload folder\n  clean_path = path.replace('/', '_')\n  date = datetime.datetime.now().strftime(\"%Y-%m-%d--%H-%M-%S\")\n\n  build_metadata = get_build_metadata()\n\n  new_fn = f\"{date}_{(build_metadata.openpilot.git_commit or 'nocommit')[:8]}_{safe_fn(clean_path)}\"[:MAX_TOMBSTONE_FN_LEN]\n\n  crashlog_dir = os.path.join(Paths.log_root(), \"crash\")\n  os.makedirs(crashlog_dir, exist_ok=True)\n\n  # Files could be on different filesystems, copy, then delete\n  shutil.copy(fn, os.path.join(crashlog_dir, new_fn))\n\n  try:\n    os.remove(fn)\n  except PermissionError:\n    pass\n\n\ndef main() -> NoReturn:\n  should_report = sentry.init(sentry.SentryProject.SELFDRIVE_NATIVE)\n\n  # Clear apport folder on start, otherwise duplicate crashes won't register\n  clear_apport_folder()\n  initial_tombstones = set(get_tombstones())\n\n  while True:\n    now_tombstones = set(get_tombstones())\n\n    for fn, _ in (now_tombstones - initial_tombstones):\n      # clear logs if we're not interested in them\n      if not should_report:\n        try:\n          os.remove(fn)\n        except Exception:\n          pass\n        continue\n\n      try:\n        cloudlog.info(f\"reporting new tombstone {fn}\")\n        if fn.endswith(\".crash\"):\n          report_tombstone_apport(fn)\n        else:\n          cloudlog.error(f\"unknown crash type: {fn}\")\n      except Exception:\n        cloudlog.exception(f\"Error reporting tombstone {fn}\")\n\n    initial_tombstones = now_tombstones\n    time.sleep(5)\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/logmessaged.py": "#!/usr/bin/env python3\nimport zmq\nfrom typing import NoReturn\n\nimport cereal.messaging as messaging\nfrom openpilot.common.logging_extra import SwagLogFileFormatter\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.common.swaglog import get_file_handler\n\n\ndef main() -> NoReturn:\n  log_handler = get_file_handler()\n  log_handler.setFormatter(SwagLogFileFormatter(None))\n  log_level = 20  # logging.INFO\n\n  ctx = zmq.Context.instance()\n  sock = ctx.socket(zmq.PULL)\n  sock.bind(Paths.swaglog_ipc())\n\n  # and we publish them\n  log_message_sock = messaging.pub_sock('logMessage')\n  error_log_message_sock = messaging.pub_sock('errorLogMessage')\n\n  try:\n    while True:\n      dat = b''.join(sock.recv_multipart())\n      level = dat[0]\n      record = dat[1:].decode(\"utf-8\")\n      if level >= log_level:\n        log_handler.emit(record)\n\n      if len(record) > 2*1024*1024:\n        print(\"WARNING: log too big to publish\", len(record))\n        print(print(record[:100]))\n        continue\n\n      # then we publish them\n      msg = messaging.new_message(None, valid=True, logMessage=record)\n      log_message_sock.send(msg.to_bytes())\n\n      if level >= 40:  # logging.ERROR\n        msg = messaging.new_message(None, valid=True, errorLogMessage=record)\n        error_log_message_sock.send(msg.to_bytes())\n  finally:\n    sock.close()\n    ctx.term()\n\n    # can hit this if interrupted during a rollover\n    try:\n      log_handler.close()\n    except ValueError:\n      pass\n\nif __name__ == \"__main__\":\n  main()\n", "system/version.py": "#!/usr/bin/env python3\nfrom dataclasses import dataclass\nfrom functools import cache\nimport json\nimport os\nimport pathlib\nimport subprocess\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.common.git import get_commit, get_origin, get_branch, get_short_branch, get_commit_date\n\nRELEASE_BRANCHES = ['release3-staging', 'release3', 'nightly']\nTESTED_BRANCHES = RELEASE_BRANCHES + ['devel', 'devel-staging']\n\nBUILD_METADATA_FILENAME = \"build.json\"\n\ntraining_version: bytes = b\"0.2.0\"\nterms_version: bytes = b\"2\"\n\n\ndef get_version(path: str = BASEDIR) -> str:\n  with open(os.path.join(path, \"common\", \"version.h\")) as _versionf:\n    version = _versionf.read().split('\"')[1]\n  return version\n\n\ndef get_release_notes(path: str = BASEDIR) -> str:\n  with open(os.path.join(path, \"RELEASES.md\")) as f:\n    return f.read().split('\\n\\n', 1)[0]\n\n\n@cache\ndef is_prebuilt(path: str = BASEDIR) -> bool:\n  return os.path.exists(os.path.join(path, 'prebuilt'))\n\n\n@cache\ndef is_dirty(cwd: str = BASEDIR) -> bool:\n  origin = get_origin()\n  branch = get_branch()\n  if not origin or not branch:\n    return True\n\n  dirty = False\n  try:\n    # Actually check dirty files\n    if not is_prebuilt(cwd):\n      # This is needed otherwise touched files might show up as modified\n      try:\n        subprocess.check_call([\"git\", \"update-index\", \"--refresh\"], cwd=cwd)\n      except subprocess.CalledProcessError:\n        pass\n\n      dirty = (subprocess.call([\"git\", \"diff-index\", \"--quiet\", branch, \"--\"], cwd=cwd)) != 0\n  except subprocess.CalledProcessError:\n    cloudlog.exception(\"git subprocess failed while checking dirty\")\n    dirty = True\n\n  return dirty\n\n\n@dataclass\nclass OpenpilotMetadata:\n  version: str\n  release_notes: str\n  git_commit: str\n  git_origin: str\n  git_commit_date: str\n  build_style: str\n  is_dirty: bool  # whether there are local changes\n\n  @property\n  def short_version(self) -> str:\n    return self.version.split('-')[0]\n\n  @property\n  def comma_remote(self) -> bool:\n    # note to fork maintainers, this is used for release metrics. please do not\n    # touch this to get rid of the orange startup alert. there's better ways to do that\n    return self.git_normalized_origin == \"github.com/commaai/openpilot\"\n\n  @property\n  def git_normalized_origin(self) -> str:\n    return self.git_origin \\\n      .replace(\"git@\", \"\", 1) \\\n      .replace(\".git\", \"\", 1) \\\n      .replace(\"https://\", \"\", 1) \\\n      .replace(\":\", \"/\", 1)\n\n\n@dataclass\nclass BuildMetadata:\n  channel: str\n  openpilot: OpenpilotMetadata\n\n  @property\n  def tested_channel(self) -> bool:\n    return self.channel in TESTED_BRANCHES\n\n  @property\n  def release_channel(self) -> bool:\n    return self.channel in RELEASE_BRANCHES\n\n  @property\n  def canonical(self) -> str:\n    return f\"{self.openpilot.version}-{self.openpilot.git_commit}-{self.openpilot.build_style}\"\n\n  @property\n  def ui_description(self) -> str:\n    return f\"{self.openpilot.version} / {self.openpilot.git_commit[:6]} / {self.channel}\"\n\n\ndef build_metadata_from_dict(build_metadata: dict) -> BuildMetadata:\n  channel = build_metadata.get(\"channel\", \"unknown\")\n  openpilot_metadata = build_metadata.get(\"openpilot\", {})\n  version = openpilot_metadata.get(\"version\", \"unknown\")\n  release_notes = openpilot_metadata.get(\"release_notes\", \"unknown\")\n  git_commit = openpilot_metadata.get(\"git_commit\", \"unknown\")\n  git_origin = openpilot_metadata.get(\"git_origin\", \"unknown\")\n  git_commit_date = openpilot_metadata.get(\"git_commit_date\", \"unknown\")\n  build_style = openpilot_metadata.get(\"build_style\", \"unknown\")\n  return BuildMetadata(channel,\n            OpenpilotMetadata(\n              version=version,\n              release_notes=release_notes,\n              git_commit=git_commit,\n              git_origin=git_origin,\n              git_commit_date=git_commit_date,\n              build_style=build_style,\n              is_dirty=False))\n\n\ndef get_build_metadata(path: str = BASEDIR) -> BuildMetadata:\n  build_metadata_path = pathlib.Path(path) / BUILD_METADATA_FILENAME\n\n  if build_metadata_path.exists():\n    build_metadata = json.loads(build_metadata_path.read_text())\n    return build_metadata_from_dict(build_metadata)\n\n  git_folder = pathlib.Path(path) / \".git\"\n\n  if git_folder.exists():\n    return BuildMetadata(get_short_branch(path),\n                    OpenpilotMetadata(\n                      version=get_version(path),\n                      release_notes=get_release_notes(path),\n                      git_commit=get_commit(path),\n                      git_origin=get_origin(path),\n                      git_commit_date=get_commit_date(path),\n                      build_style=\"unknown\",\n                      is_dirty=is_dirty(path)))\n\n  cloudlog.exception(\"unable to get build metadata\")\n  raise Exception(\"invalid build metadata\")\n\n\nif __name__ == \"__main__\":\n  from openpilot.common.params import Params\n\n  params = Params()\n  params.put(\"TermsVersion\", terms_version)\n  params.put(\"TrainingVersion\", training_version)\n\n  print(get_build_metadata())\n", "system/sentry.py": "\"\"\"Install exception handler for process crash.\"\"\"\nimport sentry_sdk\nfrom enum import Enum\nfrom sentry_sdk.integrations.threading import ThreadingIntegration\n\nfrom openpilot.common.params import Params\nfrom openpilot.system.athena.registration import is_registered_device\nfrom openpilot.system.hardware import HARDWARE, PC\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.version import get_build_metadata, get_version\n\n\nclass SentryProject(Enum):\n  # python project\n  SELFDRIVE = \"https://6f3c7076c1e14b2aa10f5dde6dda0cc4@o33823.ingest.sentry.io/77924\"\n  # native project\n  SELFDRIVE_NATIVE = \"https://3e4b586ed21a4479ad5d85083b639bc6@o33823.ingest.sentry.io/157615\"\n\n\ndef report_tombstone(fn: str, message: str, contents: str) -> None:\n  cloudlog.error({'tombstone': message})\n\n  with sentry_sdk.configure_scope() as scope:\n    scope.set_extra(\"tombstone_fn\", fn)\n    scope.set_extra(\"tombstone\", contents)\n    sentry_sdk.capture_message(message=message)\n    sentry_sdk.flush()\n\n\ndef capture_exception(*args, **kwargs) -> None:\n  cloudlog.error(\"crash\", exc_info=kwargs.get('exc_info', 1))\n\n  try:\n    sentry_sdk.capture_exception(*args, **kwargs)\n    sentry_sdk.flush()  # https://github.com/getsentry/sentry-python/issues/291\n  except Exception:\n    cloudlog.exception(\"sentry exception\")\n\n\ndef set_tag(key: str, value: str) -> None:\n  sentry_sdk.set_tag(key, value)\n\n\ndef init(project: SentryProject) -> bool:\n  build_metadata = get_build_metadata()\n  # forks like to mess with this, so double check\n  comma_remote = build_metadata.openpilot.comma_remote and \"commaai\" in build_metadata.openpilot.git_origin\n  if not comma_remote or not is_registered_device() or PC:\n    return False\n\n  env = \"release\" if build_metadata.tested_channel else \"master\"\n  dongle_id = Params().get(\"DongleId\", encoding='utf-8')\n\n  integrations = []\n  if project == SentryProject.SELFDRIVE:\n    integrations.append(ThreadingIntegration(propagate_hub=True))\n\n  sentry_sdk.init(project.value,\n                  default_integrations=False,\n                  release=get_version(),\n                  integrations=integrations,\n                  traces_sample_rate=1.0,\n                  max_value_length=8192,\n                  environment=env)\n\n  build_metadata = get_build_metadata()\n\n  sentry_sdk.set_user({\"id\": dongle_id})\n  sentry_sdk.set_tag(\"dirty\", build_metadata.openpilot.is_dirty)\n  sentry_sdk.set_tag(\"origin\", build_metadata.openpilot.git_origin)\n  sentry_sdk.set_tag(\"branch\", build_metadata.channel)\n  sentry_sdk.set_tag(\"commit\", build_metadata.openpilot.git_commit)\n  sentry_sdk.set_tag(\"device\", HARDWARE.get_device_type())\n\n  if project == SentryProject.SELFDRIVE:\n    sentry_sdk.Hub.current.start_session()\n\n  return True\n", "system/micd.py": "#!/usr/bin/env python3\nimport numpy as np\n\nfrom cereal import messaging\nfrom openpilot.common.realtime import Ratekeeper\nfrom openpilot.common.retry import retry\nfrom openpilot.common.swaglog import cloudlog\n\nRATE = 10\nFFT_SAMPLES = 4096\nREFERENCE_SPL = 2e-5  # newtons/m^2\nSAMPLE_RATE = 44100\nSAMPLE_BUFFER = 4096 # (approx 100ms)\n\n\ndef calculate_spl(measurements):\n  # https://www.engineeringtoolbox.com/sound-pressure-d_711.html\n  sound_pressure = np.sqrt(np.mean(measurements ** 2))  # RMS of amplitudes\n  if sound_pressure > 0:\n    sound_pressure_level = 20 * np.log10(sound_pressure / REFERENCE_SPL)  # dB\n  else:\n    sound_pressure_level = 0\n  return sound_pressure, sound_pressure_level\n\n\ndef apply_a_weighting(measurements: np.ndarray) -> np.ndarray:\n  # Generate a Hanning window of the same length as the audio measurements\n  measurements_windowed = measurements * np.hanning(len(measurements))\n\n  # Calculate the frequency axis for the signal\n  freqs = np.fft.fftfreq(measurements_windowed.size, d=1 / SAMPLE_RATE)\n\n  # Calculate the A-weighting filter\n  # https://en.wikipedia.org/wiki/A-weighting\n  A = 12194 ** 2 * freqs ** 4 / ((freqs ** 2 + 20.6 ** 2) * (freqs ** 2 + 12194 ** 2) * np.sqrt((freqs ** 2 + 107.7 ** 2) * (freqs ** 2 + 737.9 ** 2)))\n  A /= np.max(A)  # Normalize the filter\n\n  # Apply the A-weighting filter to the signal\n  return np.abs(np.fft.ifft(np.fft.fft(measurements_windowed) * A))\n\n\nclass Mic:\n  def __init__(self):\n    self.rk = Ratekeeper(RATE)\n    self.pm = messaging.PubMaster(['microphone'])\n\n    self.measurements = np.empty(0)\n\n    self.sound_pressure = 0\n    self.sound_pressure_weighted = 0\n    self.sound_pressure_level_weighted = 0\n\n  def update(self):\n    msg = messaging.new_message('microphone', valid=True)\n    msg.microphone.soundPressure = float(self.sound_pressure)\n    msg.microphone.soundPressureWeighted = float(self.sound_pressure_weighted)\n\n    msg.microphone.soundPressureWeightedDb = float(self.sound_pressure_level_weighted)\n\n    self.pm.send('microphone', msg)\n    self.rk.keep_time()\n\n  def callback(self, indata, frames, time, status):\n    \"\"\"\n    Using amplitude measurements, calculate an uncalibrated sound pressure and sound pressure level.\n    Then apply A-weighting to the raw amplitudes and run the same calculations again.\n\n    Logged A-weighted equivalents are rough approximations of the human-perceived loudness.\n    \"\"\"\n\n    self.measurements = np.concatenate((self.measurements, indata[:, 0]))\n\n    while self.measurements.size >= FFT_SAMPLES:\n      measurements = self.measurements[:FFT_SAMPLES]\n\n      self.sound_pressure, _ = calculate_spl(measurements)\n      measurements_weighted = apply_a_weighting(measurements)\n      self.sound_pressure_weighted, self.sound_pressure_level_weighted = calculate_spl(measurements_weighted)\n\n      self.measurements = self.measurements[FFT_SAMPLES:]\n\n  @retry(attempts=7, delay=3)\n  def get_stream(self, sd):\n    # reload sounddevice to reinitialize portaudio\n    sd._terminate()\n    sd._initialize()\n    return sd.InputStream(channels=1, samplerate=SAMPLE_RATE, callback=self.callback, blocksize=SAMPLE_BUFFER)\n\n  def micd_thread(self):\n    # sounddevice must be imported after forking processes\n    import sounddevice as sd\n\n    with self.get_stream(sd) as stream:\n      cloudlog.info(f\"micd stream started: {stream.samplerate=} {stream.channels=} {stream.dtype=} {stream.device=}, {stream.blocksize=}\")\n      while True:\n        self.update()\n\n\ndef main():\n  mic = Mic()\n  mic.micd_thread()\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/__init__.py": "", "system/hardware/fan_controller.py": "#!/usr/bin/env python3\nfrom abc import ABC, abstractmethod\n\nfrom openpilot.common.realtime import DT_HW\nfrom openpilot.common.numpy_fast import interp\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.selfdrive.controls.lib.pid import PIDController\n\nclass BaseFanController(ABC):\n  @abstractmethod\n  def update(self, cur_temp: float, ignition: bool) -> int:\n    pass\n\n\nclass TiciFanController(BaseFanController):\n  def __init__(self) -> None:\n    super().__init__()\n    cloudlog.info(\"Setting up TICI fan handler\")\n\n    self.last_ignition = False\n    self.controller = PIDController(k_p=0, k_i=4e-3, k_f=1, rate=(1 / DT_HW))\n\n  def update(self, cur_temp: float, ignition: bool) -> int:\n    self.controller.neg_limit = -(100 if ignition else 30)\n    self.controller.pos_limit = -(30 if ignition else 0)\n\n    if ignition != self.last_ignition:\n      self.controller.reset()\n\n    error = 70 - cur_temp\n    fan_pwr_out = -int(self.controller.update(\n                      error=error,\n                      feedforward=interp(cur_temp, [60.0, 100.0], [0, -100])\n                    ))\n\n    self.last_ignition = ignition\n    return fan_pwr_out\n\n", "system/hardware/power_monitoring.py": "import time\nimport threading\n\nfrom openpilot.common.params import Params\nfrom openpilot.system.hardware import HARDWARE\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.statsd import statlog\n\nCAR_VOLTAGE_LOW_PASS_K = 0.011 # LPF gain for 45s tau (dt/tau / (dt/tau + 1))\n\n# While driving, a battery charges completely in about 30-60 minutes\nCAR_BATTERY_CAPACITY_uWh = 30e6\nCAR_CHARGING_RATE_W = 45\n\nVBATT_PAUSE_CHARGING = 11.8           # Lower limit on the LPF car battery voltage\nMAX_TIME_OFFROAD_S = 30*3600\nMIN_ON_TIME_S = 3600\nDELAY_SHUTDOWN_TIME_S = 300 # Wait at least DELAY_SHUTDOWN_TIME_S seconds after offroad_time to shutdown.\nVOLTAGE_SHUTDOWN_MIN_OFFROAD_TIME_S = 60\n\nclass PowerMonitoring:\n  def __init__(self):\n    self.params = Params()\n    self.last_measurement_time = None           # Used for integration delta\n    self.last_save_time = 0                     # Used for saving current value in a param\n    self.power_used_uWh = 0                     # Integrated power usage in uWh since going into offroad\n    self.next_pulsed_measurement_time = None\n    self.car_voltage_mV = 12e3                  # Low-passed version of peripheralState voltage\n    self.car_voltage_instant_mV = 12e3          # Last value of peripheralState voltage\n    self.integration_lock = threading.Lock()\n\n    car_battery_capacity_uWh = self.params.get(\"CarBatteryCapacity\")\n    if car_battery_capacity_uWh is None:\n      car_battery_capacity_uWh = 0\n\n    # Reset capacity if it's low\n    self.car_battery_capacity_uWh = max((CAR_BATTERY_CAPACITY_uWh / 10), int(car_battery_capacity_uWh))\n\n  # Calculation tick\n  def calculate(self, voltage: int | None, ignition: bool):\n    try:\n      now = time.monotonic()\n\n      # If peripheralState is None, we're probably not in a car, so we don't care\n      if voltage is None:\n        with self.integration_lock:\n          self.last_measurement_time = None\n          self.next_pulsed_measurement_time = None\n          self.power_used_uWh = 0\n        return\n\n      # Low-pass battery voltage\n      self.car_voltage_instant_mV = voltage\n      self.car_voltage_mV = ((voltage * CAR_VOLTAGE_LOW_PASS_K) + (self.car_voltage_mV * (1 - CAR_VOLTAGE_LOW_PASS_K)))\n      statlog.gauge(\"car_voltage\", self.car_voltage_mV / 1e3)\n\n      # Cap the car battery power and save it in a param every 10-ish seconds\n      self.car_battery_capacity_uWh = max(self.car_battery_capacity_uWh, 0)\n      self.car_battery_capacity_uWh = min(self.car_battery_capacity_uWh, CAR_BATTERY_CAPACITY_uWh)\n      if now - self.last_save_time >= 10:\n        self.params.put_nonblocking(\"CarBatteryCapacity\", str(int(self.car_battery_capacity_uWh)))\n        self.last_save_time = now\n\n      # First measurement, set integration time\n      with self.integration_lock:\n        if self.last_measurement_time is None:\n          self.last_measurement_time = now\n          return\n\n      if ignition:\n        # If there is ignition, we integrate the charging rate of the car\n        with self.integration_lock:\n          self.power_used_uWh = 0\n          integration_time_h = (now - self.last_measurement_time) / 3600\n          if integration_time_h < 0:\n            raise ValueError(f\"Negative integration time: {integration_time_h}h\")\n          self.car_battery_capacity_uWh += (CAR_CHARGING_RATE_W * 1e6 * integration_time_h)\n          self.last_measurement_time = now\n      else:\n        # Get current power draw somehow\n        current_power = HARDWARE.get_current_power_draw()\n\n        # Do the integration\n        self._perform_integration(now, current_power)\n    except Exception:\n      cloudlog.exception(\"Power monitoring calculation failed\")\n\n  def _perform_integration(self, t: float, current_power: float) -> None:\n    with self.integration_lock:\n      try:\n        if self.last_measurement_time:\n          integration_time_h = (t - self.last_measurement_time) / 3600\n          power_used = (current_power * 1000000) * integration_time_h\n          if power_used < 0:\n            raise ValueError(f\"Negative power used! Integration time: {integration_time_h} h Current Power: {power_used} uWh\")\n          self.power_used_uWh += power_used\n          self.car_battery_capacity_uWh -= power_used\n          self.last_measurement_time = t\n      except Exception:\n        cloudlog.exception(\"Integration failed\")\n\n  # Get the power usage\n  def get_power_used(self) -> int:\n    return int(self.power_used_uWh)\n\n  def get_car_battery_capacity(self) -> int:\n    return int(self.car_battery_capacity_uWh)\n\n  # See if we need to shutdown\n  def should_shutdown(self, ignition: bool, in_car: bool, offroad_timestamp: float | None, started_seen: bool):\n    if offroad_timestamp is None:\n      return False\n\n    now = time.monotonic()\n    should_shutdown = False\n    offroad_time = (now - offroad_timestamp)\n    low_voltage_shutdown = (self.car_voltage_mV < (VBATT_PAUSE_CHARGING * 1e3) and\n                            offroad_time > VOLTAGE_SHUTDOWN_MIN_OFFROAD_TIME_S)\n    should_shutdown |= offroad_time > MAX_TIME_OFFROAD_S\n    should_shutdown |= low_voltage_shutdown\n    should_shutdown |= (self.car_battery_capacity_uWh <= 0)\n    should_shutdown &= not ignition\n    should_shutdown &= (not self.params.get_bool(\"DisablePowerDown\"))\n    should_shutdown &= in_car\n    should_shutdown &= offroad_time > DELAY_SHUTDOWN_TIME_S\n    should_shutdown |= self.params.get_bool(\"ForcePowerDown\")\n    should_shutdown &= started_seen or (now > MIN_ON_TIME_S)\n    return should_shutdown\n", "system/hardware/base.py": "from abc import abstractmethod, ABC\nfrom collections import namedtuple\n\nfrom cereal import log\n\nThermalConfig = namedtuple('ThermalConfig', ['cpu', 'gpu', 'mem', 'bat', 'pmic'])\nNetworkType = log.DeviceState.NetworkType\n\n\nclass HardwareBase(ABC):\n  @staticmethod\n  def get_cmdline() -> dict[str, str]:\n    with open('/proc/cmdline') as f:\n      cmdline = f.read()\n    return {kv[0]: kv[1] for kv in [s.split('=') for s in cmdline.split(' ')] if len(kv) == 2}\n\n  @staticmethod\n  def read_param_file(path, parser, default=0):\n    try:\n      with open(path) as f:\n        return parser(f.read())\n    except Exception:\n      return default\n\n  def booted(self) -> bool:\n    return True\n\n  @abstractmethod\n  def reboot(self, reason=None):\n    pass\n\n  @abstractmethod\n  def uninstall(self):\n    pass\n\n  @abstractmethod\n  def get_os_version(self):\n    pass\n\n  @abstractmethod\n  def get_device_type(self):\n    pass\n\n  @abstractmethod\n  def get_sound_card_online(self):\n    pass\n\n  @abstractmethod\n  def get_imei(self, slot) -> str:\n    pass\n\n  @abstractmethod\n  def get_serial(self):\n    pass\n\n  @abstractmethod\n  def get_network_info(self):\n    pass\n\n  @abstractmethod\n  def get_network_type(self):\n    pass\n\n  @abstractmethod\n  def get_sim_info(self):\n    pass\n\n  @abstractmethod\n  def get_network_strength(self, network_type):\n    pass\n\n  def get_network_metered(self, network_type) -> bool:\n    return network_type not in (NetworkType.none, NetworkType.wifi, NetworkType.ethernet)\n\n  @staticmethod\n  def set_bandwidth_limit(upload_speed_kbps: int, download_speed_kbps: int) -> None:\n    pass\n\n  @abstractmethod\n  def get_current_power_draw(self):\n    pass\n\n  @abstractmethod\n  def get_som_power_draw(self):\n    pass\n\n  @abstractmethod\n  def shutdown(self):\n    pass\n\n  @abstractmethod\n  def get_thermal_config(self):\n    pass\n\n  @abstractmethod\n  def set_screen_brightness(self, percentage):\n    pass\n\n  @abstractmethod\n  def get_screen_brightness(self):\n    pass\n\n  @abstractmethod\n  def set_power_save(self, powersave_enabled):\n    pass\n\n  @abstractmethod\n  def get_gpu_usage_percent(self):\n    pass\n\n  def get_modem_version(self):\n    return None\n\n  def get_modem_nv(self):\n    return None\n\n  @abstractmethod\n  def get_modem_temperatures(self):\n    pass\n\n  @abstractmethod\n  def get_nvme_temperatures(self):\n    pass\n\n  @abstractmethod\n  def initialize_hardware(self):\n    pass\n\n  def configure_modem(self):\n    pass\n\n  @abstractmethod\n  def get_networks(self):\n    pass\n\n  def has_internal_panda(self) -> bool:\n    return False\n\n  def reset_internal_panda(self):\n    pass\n\n  def recover_internal_panda(self):\n    pass\n\n  def get_modem_data_usage(self):\n    return -1, -1\n", "system/hardware/hardwared.py": "#!/usr/bin/env python3\nimport os\nimport json\nimport queue\nimport threading\nimport time\nfrom collections import OrderedDict, namedtuple\nfrom pathlib import Path\n\nimport psutil\n\nimport cereal.messaging as messaging\nfrom cereal import log\nfrom cereal.services import SERVICE_LIST\nfrom openpilot.common.dict_helpers import strip_deprecated_keys\nfrom openpilot.common.filter_simple import FirstOrderFilter\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import DT_HW\nfrom openpilot.selfdrive.controls.lib.alertmanager import set_offroad_alert\nfrom openpilot.system.hardware import HARDWARE, TICI, AGNOS\nfrom openpilot.system.loggerd.config import get_available_percent\nfrom openpilot.system.statsd import statlog\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.hardware.power_monitoring import PowerMonitoring\nfrom openpilot.system.hardware.fan_controller import TiciFanController\nfrom openpilot.system.version import terms_version, training_version\n\nThermalStatus = log.DeviceState.ThermalStatus\nNetworkType = log.DeviceState.NetworkType\nNetworkStrength = log.DeviceState.NetworkStrength\nCURRENT_TAU = 15.   # 15s time constant\nTEMP_TAU = 5.   # 5s time constant\nDISCONNECT_TIMEOUT = 5.  # wait 5 seconds before going offroad after disconnect so you get an alert\nPANDA_STATES_TIMEOUT = round(1000 / SERVICE_LIST['pandaStates'].frequency * 1.5)  # 1.5x the expected pandaState frequency\n\nThermalBand = namedtuple(\"ThermalBand\", ['min_temp', 'max_temp'])\nHardwareState = namedtuple(\"HardwareState\", ['network_type', 'network_info', 'network_strength', 'network_stats',\n                                             'network_metered', 'nvme_temps', 'modem_temps'])\n\n# List of thermal bands. We will stay within this region as long as we are within the bounds.\n# When exiting the bounds, we'll jump to the lower or higher band. Bands are ordered in the dict.\nTHERMAL_BANDS = OrderedDict({\n  ThermalStatus.green: ThermalBand(None, 80.0),\n  ThermalStatus.yellow: ThermalBand(75.0, 96.0),\n  ThermalStatus.red: ThermalBand(88.0, 107.),\n  ThermalStatus.danger: ThermalBand(94.0, None),\n})\n\n# Override to highest thermal band when offroad and above this temp\nOFFROAD_DANGER_TEMP = 75\n\nprev_offroad_states: dict[str, tuple[bool, str | None]] = {}\n\ntz_by_type: dict[str, int] | None = None\ndef populate_tz_by_type():\n  global tz_by_type\n  tz_by_type = {}\n  for n in os.listdir(\"/sys/devices/virtual/thermal\"):\n    if not n.startswith(\"thermal_zone\"):\n      continue\n    with open(os.path.join(\"/sys/devices/virtual/thermal\", n, \"type\")) as f:\n      tz_by_type[f.read().strip()] = int(n.removeprefix(\"thermal_zone\"))\n\ndef read_tz(x):\n  if x is None:\n    return 0\n\n  if isinstance(x, str):\n    if tz_by_type is None:\n      populate_tz_by_type()\n    x = tz_by_type[x]\n\n  try:\n    with open(f\"/sys/devices/virtual/thermal/thermal_zone{x}/temp\") as f:\n      return int(f.read())\n  except FileNotFoundError:\n    return 0\n\n\ndef read_thermal(thermal_config):\n  dat = messaging.new_message('deviceState', valid=True)\n  dat.deviceState.cpuTempC = [read_tz(z) / thermal_config.cpu[1] for z in thermal_config.cpu[0]]\n  dat.deviceState.gpuTempC = [read_tz(z) / thermal_config.gpu[1] for z in thermal_config.gpu[0]]\n  dat.deviceState.memoryTempC = read_tz(thermal_config.mem[0]) / thermal_config.mem[1]\n  dat.deviceState.pmicTempC = [read_tz(z) / thermal_config.pmic[1] for z in thermal_config.pmic[0]]\n  return dat\n\n\ndef set_offroad_alert_if_changed(offroad_alert: str, show_alert: bool, extra_text: str | None=None):\n  if prev_offroad_states.get(offroad_alert, None) == (show_alert, extra_text):\n    return\n  prev_offroad_states[offroad_alert] = (show_alert, extra_text)\n  set_offroad_alert(offroad_alert, show_alert, extra_text)\n\n\ndef hw_state_thread(end_event, hw_queue):\n  \"\"\"Handles non critical hardware state, and sends over queue\"\"\"\n  count = 0\n  prev_hw_state = None\n\n  modem_version = None\n  modem_nv = None\n  modem_configured = False\n  modem_restarted = False\n  modem_missing_count = 0\n\n  while not end_event.is_set():\n    # these are expensive calls. update every 10s\n    if (count % int(10. / DT_HW)) == 0:\n      try:\n        network_type = HARDWARE.get_network_type()\n        modem_temps = HARDWARE.get_modem_temperatures()\n        if len(modem_temps) == 0 and prev_hw_state is not None:\n          modem_temps = prev_hw_state.modem_temps\n\n        # Log modem version once\n        if AGNOS and ((modem_version is None) or (modem_nv is None)):\n          modem_version = HARDWARE.get_modem_version()\n          modem_nv = HARDWARE.get_modem_nv()\n\n          if (modem_version is not None) and (modem_nv is not None):\n            cloudlog.event(\"modem version\", version=modem_version, nv=modem_nv)\n          else:\n            if not modem_restarted:\n              # TODO: we may be able to remove this with a MM update\n              # ModemManager's probing on startup can fail\n              # rarely, restart the service to probe again.\n              modem_missing_count += 1\n              if modem_missing_count > 3:\n                modem_restarted = True\n                cloudlog.event(\"restarting ModemManager\")\n                os.system(\"sudo systemctl restart --no-block ModemManager\")\n\n        tx, rx = HARDWARE.get_modem_data_usage()\n\n        hw_state = HardwareState(\n          network_type=network_type,\n          network_info=HARDWARE.get_network_info(),\n          network_strength=HARDWARE.get_network_strength(network_type),\n          network_stats={'wwanTx': tx, 'wwanRx': rx},\n          network_metered=HARDWARE.get_network_metered(network_type),\n          nvme_temps=HARDWARE.get_nvme_temperatures(),\n          modem_temps=modem_temps,\n        )\n\n        try:\n          hw_queue.put_nowait(hw_state)\n        except queue.Full:\n          pass\n\n        # TODO: remove this once the config is in AGNOS\n        if not modem_configured and len(HARDWARE.get_sim_info().get('sim_id', '')) > 0:\n          cloudlog.warning(\"configuring modem\")\n          HARDWARE.configure_modem()\n          modem_configured = True\n\n        prev_hw_state = hw_state\n      except Exception:\n        cloudlog.exception(\"Error getting hardware state\")\n\n    count += 1\n    time.sleep(DT_HW)\n\n\ndef hardware_thread(end_event, hw_queue) -> None:\n  pm = messaging.PubMaster(['deviceState'])\n  sm = messaging.SubMaster([\"peripheralState\", \"gpsLocationExternal\", \"controlsState\", \"pandaStates\"], poll=\"pandaStates\")\n\n  count = 0\n\n  onroad_conditions: dict[str, bool] = {\n    \"ignition\": False,\n  }\n  startup_conditions: dict[str, bool] = {}\n  startup_conditions_prev: dict[str, bool] = {}\n\n  off_ts: float | None = None\n  started_ts: float | None = None\n  started_seen = False\n  startup_blocked_ts: float | None = None\n  thermal_status = ThermalStatus.yellow\n\n  last_hw_state = HardwareState(\n    network_type=NetworkType.none,\n    network_info=None,\n    network_metered=False,\n    network_strength=NetworkStrength.unknown,\n    network_stats={'wwanTx': -1, 'wwanRx': -1},\n    nvme_temps=[],\n    modem_temps=[],\n  )\n\n  all_temp_filter = FirstOrderFilter(0., TEMP_TAU, DT_HW, initialized=False)\n  offroad_temp_filter = FirstOrderFilter(0., TEMP_TAU, DT_HW, initialized=False)\n  should_start_prev = False\n  in_car = False\n  engaged_prev = False\n\n  params = Params()\n  power_monitor = PowerMonitoring()\n\n  HARDWARE.initialize_hardware()\n  thermal_config = HARDWARE.get_thermal_config()\n\n  fan_controller = None\n\n  while not end_event.is_set():\n    sm.update(PANDA_STATES_TIMEOUT)\n\n    pandaStates = sm['pandaStates']\n    peripheralState = sm['peripheralState']\n    peripheral_panda_present = peripheralState.pandaType != log.PandaState.PandaType.unknown\n\n    if sm.updated['pandaStates'] and len(pandaStates) > 0:\n\n      # Set ignition based on any panda connected\n      onroad_conditions[\"ignition\"] = any(ps.ignitionLine or ps.ignitionCan for ps in pandaStates if ps.pandaType != log.PandaState.PandaType.unknown)\n\n      pandaState = pandaStates[0]\n\n      in_car = pandaState.harnessStatus != log.PandaState.HarnessStatus.notConnected\n\n      # Setup fan handler on first connect to panda\n      if fan_controller is None and peripheral_panda_present:\n        if TICI:\n          fan_controller = TiciFanController()\n\n    elif (time.monotonic() - sm.recv_time['pandaStates']) > DISCONNECT_TIMEOUT:\n      if onroad_conditions[\"ignition\"]:\n        onroad_conditions[\"ignition\"] = False\n        cloudlog.error(\"panda timed out onroad\")\n\n    # Run at 2Hz, plus rising edge of ignition\n    ign_edge = started_ts is None and onroad_conditions[\"ignition\"]\n    if (sm.frame % round(SERVICE_LIST['pandaStates'].frequency * DT_HW) != 0) and not ign_edge:\n      continue\n\n    msg = read_thermal(thermal_config)\n    msg.deviceState.deviceType = HARDWARE.get_device_type()\n\n    try:\n      last_hw_state = hw_queue.get_nowait()\n    except queue.Empty:\n      pass\n\n    msg.deviceState.freeSpacePercent = get_available_percent(default=100.0)\n    msg.deviceState.memoryUsagePercent = int(round(psutil.virtual_memory().percent))\n    msg.deviceState.gpuUsagePercent = int(round(HARDWARE.get_gpu_usage_percent()))\n    online_cpu_usage = [int(round(n)) for n in psutil.cpu_percent(percpu=True)]\n    offline_cpu_usage = [0., ] * (len(msg.deviceState.cpuTempC) - len(online_cpu_usage))\n    msg.deviceState.cpuUsagePercent = online_cpu_usage + offline_cpu_usage\n\n    msg.deviceState.networkType = last_hw_state.network_type\n    msg.deviceState.networkMetered = last_hw_state.network_metered\n    msg.deviceState.networkStrength = last_hw_state.network_strength\n    msg.deviceState.networkStats = last_hw_state.network_stats\n    if last_hw_state.network_info is not None:\n      msg.deviceState.networkInfo = last_hw_state.network_info\n\n    msg.deviceState.nvmeTempC = last_hw_state.nvme_temps\n    msg.deviceState.modemTempC = last_hw_state.modem_temps\n\n    msg.deviceState.screenBrightnessPercent = HARDWARE.get_screen_brightness()\n\n    # this subset is only used for offroad\n    temp_sources = [\n      msg.deviceState.memoryTempC,\n      max(msg.deviceState.cpuTempC),\n      max(msg.deviceState.gpuTempC),\n    ]\n    offroad_comp_temp = offroad_temp_filter.update(max(temp_sources))\n\n    # this drives the thermal status while onroad\n    temp_sources.append(max(msg.deviceState.pmicTempC))\n    all_comp_temp = all_temp_filter.update(max(temp_sources))\n    msg.deviceState.maxTempC = all_comp_temp\n\n    if fan_controller is not None:\n      msg.deviceState.fanSpeedPercentDesired = fan_controller.update(all_comp_temp, onroad_conditions[\"ignition\"])\n\n    is_offroad_for_5_min = (started_ts is None) and ((not started_seen) or (off_ts is None) or (time.monotonic() - off_ts > 60 * 5))\n    if is_offroad_for_5_min and offroad_comp_temp > OFFROAD_DANGER_TEMP:\n      # if device is offroad and already hot without the extra onroad load,\n      # we want to cool down first before increasing load\n      thermal_status = ThermalStatus.danger\n    else:\n      current_band = THERMAL_BANDS[thermal_status]\n      band_idx = list(THERMAL_BANDS.keys()).index(thermal_status)\n      if current_band.min_temp is not None and all_comp_temp < current_band.min_temp:\n        thermal_status = list(THERMAL_BANDS.keys())[band_idx - 1]\n      elif current_band.max_temp is not None and all_comp_temp > current_band.max_temp:\n        thermal_status = list(THERMAL_BANDS.keys())[band_idx + 1]\n\n    # **** starting logic ****\n\n    startup_conditions[\"up_to_date\"] = params.get(\"Offroad_ConnectivityNeeded\") is None or params.get_bool(\"DisableUpdates\") or params.get_bool(\"SnoozeUpdate\")\n    startup_conditions[\"not_uninstalling\"] = not params.get_bool(\"DoUninstall\")\n    startup_conditions[\"accepted_terms\"] = params.get(\"HasAcceptedTerms\") == terms_version\n\n    # with 2% left, we killall, otherwise the phone will take a long time to boot\n    startup_conditions[\"free_space\"] = msg.deviceState.freeSpacePercent > 2\n    startup_conditions[\"completed_training\"] = params.get(\"CompletedTrainingVersion\") == training_version\n    startup_conditions[\"not_driver_view\"] = not params.get_bool(\"IsDriverViewEnabled\")\n    startup_conditions[\"not_taking_snapshot\"] = not params.get_bool(\"IsTakingSnapshot\")\n\n    # must be at an engageable thermal band to go onroad\n    startup_conditions[\"device_temp_engageable\"] = thermal_status < ThermalStatus.red\n\n    # ensure device is fully booted\n    startup_conditions[\"device_booted\"] = startup_conditions.get(\"device_booted\", False) or HARDWARE.booted()\n\n    # if the temperature enters the danger zone, go offroad to cool down\n    onroad_conditions[\"device_temp_good\"] = thermal_status < ThermalStatus.danger\n    extra_text = f\"{offroad_comp_temp:.1f}C\"\n    show_alert = (not onroad_conditions[\"device_temp_good\"] or not startup_conditions[\"device_temp_engageable\"]) and onroad_conditions[\"ignition\"]\n    set_offroad_alert_if_changed(\"Offroad_TemperatureTooHigh\", show_alert, extra_text=extra_text)\n\n    # TODO: this should move to TICI.initialize_hardware, but we currently can't import params there\n    if TICI:\n      if not os.path.isfile(\"/persist/comma/living-in-the-moment\"):\n        if not Path(\"/data/media\").is_mount():\n          set_offroad_alert_if_changed(\"Offroad_StorageMissing\", True)\n        else:\n          # check for bad NVMe\n          try:\n            with open(\"/sys/block/nvme0n1/device/model\") as f:\n              model = f.read().strip()\n            if not model.startswith(\"Samsung SSD 980\") and params.get(\"Offroad_BadNvme\") is None:\n              set_offroad_alert_if_changed(\"Offroad_BadNvme\", True)\n              cloudlog.event(\"Unsupported NVMe\", model=model, error=True)\n          except Exception:\n            pass\n\n    # Handle offroad/onroad transition\n    should_start = all(onroad_conditions.values())\n    if started_ts is None:\n      should_start = should_start and all(startup_conditions.values())\n\n    if should_start != should_start_prev or (count == 0):\n      params.put_bool(\"IsEngaged\", False)\n      engaged_prev = False\n      HARDWARE.set_power_save(not should_start)\n\n    if sm.updated['controlsState']:\n      engaged = sm['controlsState'].enabled\n      if engaged != engaged_prev:\n        params.put_bool(\"IsEngaged\", engaged)\n        engaged_prev = engaged\n\n      try:\n        with open('/dev/kmsg', 'w') as kmsg:\n          kmsg.write(f\"<3>[hardware] engaged: {engaged}\\n\")\n      except Exception:\n        pass\n\n    if should_start:\n      off_ts = None\n      if started_ts is None:\n        started_ts = time.monotonic()\n        started_seen = True\n        if startup_blocked_ts is not None:\n          cloudlog.event(\"Startup after block\", block_duration=(time.monotonic() - startup_blocked_ts),\n                         startup_conditions=startup_conditions, onroad_conditions=onroad_conditions,\n                         startup_conditions_prev=startup_conditions_prev, error=True)\n      startup_blocked_ts = None\n    else:\n      if onroad_conditions[\"ignition\"] and (startup_conditions != startup_conditions_prev):\n        cloudlog.event(\"Startup blocked\", startup_conditions=startup_conditions, onroad_conditions=onroad_conditions, error=True)\n        startup_conditions_prev = startup_conditions.copy()\n        startup_blocked_ts = time.monotonic()\n\n      started_ts = None\n      if off_ts is None:\n        off_ts = time.monotonic()\n\n    # Offroad power monitoring\n    voltage = None if peripheralState.pandaType == log.PandaState.PandaType.unknown else peripheralState.voltage\n    power_monitor.calculate(voltage, onroad_conditions[\"ignition\"])\n    msg.deviceState.offroadPowerUsageUwh = power_monitor.get_power_used()\n    msg.deviceState.carBatteryCapacityUwh = max(0, power_monitor.get_car_battery_capacity())\n    current_power_draw = HARDWARE.get_current_power_draw()\n    statlog.sample(\"power_draw\", current_power_draw)\n    msg.deviceState.powerDrawW = current_power_draw\n\n    som_power_draw = HARDWARE.get_som_power_draw()\n    statlog.sample(\"som_power_draw\", som_power_draw)\n    msg.deviceState.somPowerDrawW = som_power_draw\n\n    # Check if we need to shut down\n    if power_monitor.should_shutdown(onroad_conditions[\"ignition\"], in_car, off_ts, started_seen):\n      cloudlog.warning(f\"shutting device down, offroad since {off_ts}\")\n      params.put_bool(\"DoShutdown\", True)\n\n    msg.deviceState.started = started_ts is not None\n    msg.deviceState.startedMonoTime = int(1e9*(started_ts or 0))\n\n    last_ping = params.get(\"LastAthenaPingTime\")\n    if last_ping is not None:\n      msg.deviceState.lastAthenaPingTime = int(last_ping)\n\n    msg.deviceState.thermalStatus = thermal_status\n    pm.send(\"deviceState\", msg)\n\n    # Log to statsd\n    statlog.gauge(\"free_space_percent\", msg.deviceState.freeSpacePercent)\n    statlog.gauge(\"gpu_usage_percent\", msg.deviceState.gpuUsagePercent)\n    statlog.gauge(\"memory_usage_percent\", msg.deviceState.memoryUsagePercent)\n    for i, usage in enumerate(msg.deviceState.cpuUsagePercent):\n      statlog.gauge(f\"cpu{i}_usage_percent\", usage)\n    for i, temp in enumerate(msg.deviceState.cpuTempC):\n      statlog.gauge(f\"cpu{i}_temperature\", temp)\n    for i, temp in enumerate(msg.deviceState.gpuTempC):\n      statlog.gauge(f\"gpu{i}_temperature\", temp)\n    statlog.gauge(\"memory_temperature\", msg.deviceState.memoryTempC)\n    for i, temp in enumerate(msg.deviceState.pmicTempC):\n      statlog.gauge(f\"pmic{i}_temperature\", temp)\n    for i, temp in enumerate(last_hw_state.nvme_temps):\n      statlog.gauge(f\"nvme_temperature{i}\", temp)\n    for i, temp in enumerate(last_hw_state.modem_temps):\n      statlog.gauge(f\"modem_temperature{i}\", temp)\n    statlog.gauge(\"fan_speed_percent_desired\", msg.deviceState.fanSpeedPercentDesired)\n    statlog.gauge(\"screen_brightness_percent\", msg.deviceState.screenBrightnessPercent)\n\n    # report to server once every 10 minutes\n    rising_edge_started = should_start and not should_start_prev\n    if rising_edge_started or (count % int(600. / DT_HW)) == 0:\n      dat = {\n        'count': count,\n        'pandaStates': [strip_deprecated_keys(p.to_dict()) for p in pandaStates],\n        'peripheralState': strip_deprecated_keys(peripheralState.to_dict()),\n        'location': (strip_deprecated_keys(sm[\"gpsLocationExternal\"].to_dict()) if sm.alive[\"gpsLocationExternal\"] else None),\n        'deviceState': strip_deprecated_keys(msg.to_dict())\n      }\n      cloudlog.event(\"STATUS_PACKET\", **dat)\n\n      # save last one before going onroad\n      if rising_edge_started:\n        try:\n          params.put(\"LastOffroadStatusPacket\", json.dumps(dat))\n        except Exception:\n          cloudlog.exception(\"failed to save offroad status\")\n\n    params.put_bool_nonblocking(\"NetworkMetered\", msg.deviceState.networkMetered)\n\n    count += 1\n    should_start_prev = should_start\n\n\ndef main():\n  hw_queue = queue.Queue(maxsize=1)\n  end_event = threading.Event()\n\n  threads = [\n    threading.Thread(target=hw_state_thread, args=(end_event, hw_queue)),\n    threading.Thread(target=hardware_thread, args=(end_event, hw_queue)),\n  ]\n\n  for t in threads:\n    t.start()\n\n  try:\n    while True:\n      time.sleep(1)\n      if not all(t.is_alive() for t in threads):\n        break\n  finally:\n    end_event.set()\n\n  for t in threads:\n    t.join()\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/hardware/__init__.py": "import os\nfrom typing import cast\n\nfrom openpilot.system.hardware.base import HardwareBase\nfrom openpilot.system.hardware.tici.hardware import Tici\nfrom openpilot.system.hardware.pc.hardware import Pc\n\nTICI = os.path.isfile('/TICI')\nAGNOS = os.path.isfile('/AGNOS')\nPC = not TICI\n\n\nif TICI:\n  HARDWARE = cast(HardwareBase, Tici())\nelse:\n  HARDWARE = cast(HardwareBase, Pc())\n", "system/hardware/hw.py": "import os\nfrom pathlib import Path\n\nfrom openpilot.system.hardware import PC\n\nDEFAULT_DOWNLOAD_CACHE_ROOT = \"/tmp/comma_download_cache\"\n\nclass Paths:\n  @staticmethod\n  def comma_home() -> str:\n    return os.path.join(str(Path.home()), \".comma\" + os.environ.get(\"OPENPILOT_PREFIX\", \"\"))\n\n  @staticmethod\n  def log_root() -> str:\n    if os.environ.get('LOG_ROOT', False):\n      return os.environ['LOG_ROOT']\n    elif PC:\n      return str(Path(Paths.comma_home()) / \"media\" / \"0\" / \"realdata\")\n    else:\n      return '/data/media/0/realdata/'\n\n  @staticmethod\n  def swaglog_root() -> str:\n    if PC:\n      return os.path.join(Paths.comma_home(), \"log\")\n    else:\n      return \"/data/log/\"\n\n  @staticmethod\n  def swaglog_ipc() -> str:\n    return \"ipc:///tmp/logmessage\" + os.environ.get(\"OPENPILOT_PREFIX\", \"\")\n\n  @staticmethod\n  def download_cache_root() -> str:\n    if os.environ.get('COMMA_CACHE', False):\n      return os.environ['COMMA_CACHE'] + \"/\"\n    return DEFAULT_DOWNLOAD_CACHE_ROOT + os.environ.get(\"OPENPILOT_PREFIX\", \"\") + \"/\"\n\n  @staticmethod\n  def persist_root() -> str:\n    if PC:\n      return os.path.join(Paths.comma_home(), \"persist\")\n    else:\n      return \"/persist/\"\n\n  @staticmethod\n  def stats_root() -> str:\n    if PC:\n      return str(Path(Paths.comma_home()) / \"stats\")\n    else:\n      return \"/data/stats/\"\n\n  @staticmethod\n  def config_root() -> str:\n    if PC:\n      return Paths.comma_home()\n    else:\n      return \"/tmp/.comma\"\n", "system/hardware/pc/hardware.py": "import random\n\nfrom cereal import log\nfrom openpilot.system.hardware.base import HardwareBase, ThermalConfig\n\nNetworkType = log.DeviceState.NetworkType\nNetworkStrength = log.DeviceState.NetworkStrength\n\n\nclass Pc(HardwareBase):\n  def get_os_version(self):\n    return None\n\n  def get_device_type(self):\n    return \"pc\"\n\n  def get_sound_card_online(self):\n    return True\n\n  def reboot(self, reason=None):\n    print(\"REBOOT!\")\n\n  def uninstall(self):\n    print(\"uninstall\")\n\n  def get_imei(self, slot):\n    return \"%015d\" % random.randint(0, 1 << 32)\n\n  def get_serial(self):\n    return \"cccccccc\"\n\n  def get_network_info(self):\n    return None\n\n  def get_network_type(self):\n    return NetworkType.wifi\n\n  def get_sim_info(self):\n    return {\n      'sim_id': '',\n      'mcc_mnc': None,\n      'network_type': [\"Unknown\"],\n      'sim_state': [\"ABSENT\"],\n      'data_connected': False\n    }\n\n  def get_network_strength(self, network_type):\n    return NetworkStrength.unknown\n\n  def get_current_power_draw(self):\n    return 0\n\n  def get_som_power_draw(self):\n    return 0\n\n  def shutdown(self):\n    print(\"SHUTDOWN!\")\n\n  def get_thermal_config(self):\n    return ThermalConfig(cpu=((None,), 1), gpu=((None,), 1), mem=(None, 1), bat=(None, 1), pmic=((None,), 1))\n\n  def set_screen_brightness(self, percentage):\n    pass\n\n  def get_screen_brightness(self):\n    return 0\n\n  def set_power_save(self, powersave_enabled):\n    pass\n\n  def get_gpu_usage_percent(self):\n    return 0\n\n  def get_modem_temperatures(self):\n    return []\n\n  def get_nvme_temperatures(self):\n    return []\n\n  def initialize_hardware(self):\n    pass\n\n  def get_networks(self):\n    return None\n", "system/hardware/pc/__init__.py": "", "system/hardware/tici/hardware.py": "import json\nimport math\nimport os\nimport subprocess\nimport time\nimport tempfile\nfrom enum import IntEnum\nfrom functools import cached_property, lru_cache\nfrom pathlib import Path\n\nfrom cereal import log\nfrom openpilot.common.gpio import gpio_set, gpio_init, get_irqs_for_action\nfrom openpilot.system.hardware.base import HardwareBase, ThermalConfig\nfrom openpilot.system.hardware.tici import iwlist\nfrom openpilot.system.hardware.tici.pins import GPIO\nfrom openpilot.system.hardware.tici.amplifier import Amplifier\n\nNM = 'org.freedesktop.NetworkManager'\nNM_CON_ACT = NM + '.Connection.Active'\nNM_DEV = NM + '.Device'\nNM_DEV_WL = NM + '.Device.Wireless'\nNM_DEV_STATS = NM + '.Device.Statistics'\nNM_AP = NM + '.AccessPoint'\nDBUS_PROPS = 'org.freedesktop.DBus.Properties'\n\nMM = 'org.freedesktop.ModemManager1'\nMM_MODEM = MM + \".Modem\"\nMM_MODEM_SIMPLE = MM + \".Modem.Simple\"\nMM_SIM = MM + \".Sim\"\n\nclass MM_MODEM_STATE(IntEnum):\n  FAILED        = -1\n  UNKNOWN       = 0\n  INITIALIZING  = 1\n  LOCKED        = 2\n  DISABLED      = 3\n  DISABLING     = 4\n  ENABLING      = 5\n  ENABLED       = 6\n  SEARCHING     = 7\n  REGISTERED    = 8\n  DISCONNECTING = 9\n  CONNECTING    = 10\n  CONNECTED     = 11\n\nclass NMMetered(IntEnum):\n  NM_METERED_UNKNOWN = 0\n  NM_METERED_YES = 1\n  NM_METERED_NO = 2\n  NM_METERED_GUESS_YES = 3\n  NM_METERED_GUESS_NO = 4\n\nTIMEOUT = 0.1\nREFRESH_RATE_MS = 1000\n\nNetworkType = log.DeviceState.NetworkType\nNetworkStrength = log.DeviceState.NetworkStrength\n\n# https://developer.gnome.org/ModemManager/unstable/ModemManager-Flags-and-Enumerations.html#MMModemAccessTechnology\nMM_MODEM_ACCESS_TECHNOLOGY_UMTS = 1 << 5\nMM_MODEM_ACCESS_TECHNOLOGY_LTE = 1 << 14\n\n\ndef sudo_write(val, path):\n  try:\n    with open(path, 'w') as f:\n      f.write(str(val))\n  except PermissionError:\n    os.system(f\"sudo chmod a+w {path}\")\n    try:\n      with open(path, 'w') as f:\n        f.write(str(val))\n    except PermissionError:\n      # fallback for debugfs files\n      os.system(f\"sudo su -c 'echo {val} > {path}'\")\n\ndef sudo_read(path: str) -> str:\n  try:\n    return subprocess.check_output(f\"sudo cat {path}\", shell=True, encoding='utf8')\n  except Exception:\n    return \"\"\n\ndef affine_irq(val, action):\n  irqs = get_irqs_for_action(action)\n  if len(irqs) == 0:\n    print(f\"No IRQs found for '{action}'\")\n    return\n\n  for i in irqs:\n    sudo_write(str(val), f\"/proc/irq/{i}/smp_affinity_list\")\n\n@lru_cache\ndef get_device_type():\n  # lru_cache and cache can cause memory leaks when used in classes\n  with open(\"/sys/firmware/devicetree/base/model\") as f:\n    model = f.read().strip('\\x00')\n  return model.split('comma ')[-1]\n\nclass Tici(HardwareBase):\n  @cached_property\n  def bus(self):\n    import dbus\n    return dbus.SystemBus()\n\n  @cached_property\n  def nm(self):\n    return self.bus.get_object(NM, '/org/freedesktop/NetworkManager')\n\n  @property # this should not be cached, in case the modemmanager restarts\n  def mm(self):\n    return self.bus.get_object(MM, '/org/freedesktop/ModemManager1')\n\n  @cached_property\n  def amplifier(self):\n    if self.get_device_type() == \"mici\":\n      return None\n    return Amplifier()\n\n  def get_os_version(self):\n    with open(\"/VERSION\") as f:\n      return f.read().strip()\n\n  def get_device_type(self):\n    return get_device_type()\n\n  def get_sound_card_online(self):\n    if os.path.isfile('/proc/asound/card0/state'):\n      with open('/proc/asound/card0/state') as f:\n        return f.read().strip() == 'ONLINE'\n    return False\n\n  def reboot(self, reason=None):\n    subprocess.check_output([\"sudo\", \"reboot\"])\n\n  def uninstall(self):\n    Path(\"/data/__system_reset__\").touch()\n    os.sync()\n    self.reboot()\n\n  def get_serial(self):\n    return self.get_cmdline()['androidboot.serialno']\n\n  def get_network_type(self):\n    try:\n      primary_connection = self.nm.Get(NM, 'PrimaryConnection', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n      primary_connection = self.bus.get_object(NM, primary_connection)\n      primary_type = primary_connection.Get(NM_CON_ACT, 'Type', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n\n      if primary_type == '802-3-ethernet':\n        return NetworkType.ethernet\n      elif primary_type == '802-11-wireless':\n        return NetworkType.wifi\n      else:\n        active_connections = self.nm.Get(NM, 'ActiveConnections', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n        for conn in active_connections:\n          c = self.bus.get_object(NM, conn)\n          tp = c.Get(NM_CON_ACT, 'Type', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n          if tp == 'gsm':\n            modem = self.get_modem()\n            access_t = modem.Get(MM_MODEM, 'AccessTechnologies', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n            if access_t >= MM_MODEM_ACCESS_TECHNOLOGY_LTE:\n              return NetworkType.cell4G\n            elif access_t >= MM_MODEM_ACCESS_TECHNOLOGY_UMTS:\n              return NetworkType.cell3G\n            else:\n              return NetworkType.cell2G\n    except Exception:\n      pass\n\n    return NetworkType.none\n\n  def get_modem(self):\n    objects = self.mm.GetManagedObjects(dbus_interface=\"org.freedesktop.DBus.ObjectManager\", timeout=TIMEOUT)\n    modem_path = list(objects.keys())[0]\n    return self.bus.get_object(MM, modem_path)\n\n  def get_wlan(self):\n    wlan_path = self.nm.GetDeviceByIpIface('wlan0', dbus_interface=NM, timeout=TIMEOUT)\n    return self.bus.get_object(NM, wlan_path)\n\n  def get_wwan(self):\n    wwan_path = self.nm.GetDeviceByIpIface('wwan0', dbus_interface=NM, timeout=TIMEOUT)\n    return self.bus.get_object(NM, wwan_path)\n\n  def get_sim_info(self):\n    modem = self.get_modem()\n    sim_path = modem.Get(MM_MODEM, 'Sim', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n\n    if sim_path == \"/\":\n      return {\n        'sim_id': '',\n        'mcc_mnc': None,\n        'network_type': [\"Unknown\"],\n        'sim_state': [\"ABSENT\"],\n        'data_connected': False\n      }\n    else:\n      sim = self.bus.get_object(MM, sim_path)\n      return {\n        'sim_id': str(sim.Get(MM_SIM, 'SimIdentifier', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)),\n        'mcc_mnc': str(sim.Get(MM_SIM, 'OperatorIdentifier', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)),\n        'network_type': [\"Unknown\"],\n        'sim_state': [\"READY\"],\n        'data_connected': modem.Get(MM_MODEM, 'State', dbus_interface=DBUS_PROPS, timeout=TIMEOUT) == MM_MODEM_STATE.CONNECTED,\n      }\n\n  def get_imei(self, slot):\n    if slot != 0:\n      return \"\"\n\n    return str(self.get_modem().Get(MM_MODEM, 'EquipmentIdentifier', dbus_interface=DBUS_PROPS, timeout=TIMEOUT))\n\n  def get_network_info(self):\n    try:\n      modem = self.get_modem()\n      info = modem.Command(\"AT+QNWINFO\", math.ceil(TIMEOUT), dbus_interface=MM_MODEM, timeout=TIMEOUT)\n      extra = modem.Command('AT+QENG=\"servingcell\"', math.ceil(TIMEOUT), dbus_interface=MM_MODEM, timeout=TIMEOUT)\n      state = modem.Get(MM_MODEM, 'State', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n    except Exception:\n      return None\n\n    if info and info.startswith('+QNWINFO: '):\n      info = info.replace('+QNWINFO: ', '').replace('\"', '').split(',')\n      extra = \"\" if extra is None else extra.replace('+QENG: \"servingcell\",', '').replace('\"', '')\n      state = \"\" if state is None else MM_MODEM_STATE(state).name\n\n      if len(info) != 4:\n        return None\n\n      technology, operator, band, channel = info\n\n      return({\n        'technology': technology,\n        'operator': operator,\n        'band': band,\n        'channel': int(channel),\n        'extra': extra,\n        'state': state,\n      })\n    else:\n      return None\n\n  def parse_strength(self, percentage):\n    if percentage < 25:\n      return NetworkStrength.poor\n    elif percentage < 50:\n      return NetworkStrength.moderate\n    elif percentage < 75:\n      return NetworkStrength.good\n    else:\n      return NetworkStrength.great\n\n  def get_network_strength(self, network_type):\n    network_strength = NetworkStrength.unknown\n\n    try:\n      if network_type == NetworkType.none:\n        pass\n      elif network_type == NetworkType.wifi:\n        wlan = self.get_wlan()\n        active_ap_path = wlan.Get(NM_DEV_WL, 'ActiveAccessPoint', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n        if active_ap_path != \"/\":\n          active_ap = self.bus.get_object(NM, active_ap_path)\n          strength = int(active_ap.Get(NM_AP, 'Strength', dbus_interface=DBUS_PROPS, timeout=TIMEOUT))\n          network_strength = self.parse_strength(strength)\n      else:  # Cellular\n        modem = self.get_modem()\n        strength = int(modem.Get(MM_MODEM, 'SignalQuality', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)[0])\n        network_strength = self.parse_strength(strength)\n    except Exception:\n      pass\n\n    return network_strength\n\n  def get_network_metered(self, network_type) -> bool:\n    try:\n      primary_connection = self.nm.Get(NM, 'PrimaryConnection', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n      primary_connection = self.bus.get_object(NM, primary_connection)\n      primary_devices = primary_connection.Get(NM_CON_ACT, 'Devices', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n\n      for dev in primary_devices:\n        dev_obj = self.bus.get_object(NM, str(dev))\n        metered_prop = dev_obj.Get(NM_DEV, 'Metered', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n\n        if network_type == NetworkType.wifi:\n          if metered_prop in [NMMetered.NM_METERED_YES, NMMetered.NM_METERED_GUESS_YES]:\n            return True\n        elif network_type in [NetworkType.cell2G, NetworkType.cell3G, NetworkType.cell4G, NetworkType.cell5G]:\n          if metered_prop == NMMetered.NM_METERED_NO:\n            return False\n    except Exception:\n      pass\n\n    return super().get_network_metered(network_type)\n\n  def get_modem_version(self):\n    try:\n      modem = self.get_modem()\n      return modem.Get(MM_MODEM, 'Revision', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n    except Exception:\n      return None\n\n  def get_modem_nv(self):\n    timeout = 0.2  # Default timeout is too short\n    files = (\n      '/nv/item_files/modem/mmode/ue_usage_setting',\n      '/nv/item_files/ims/IMS_enable',\n      '/nv/item_files/modem/mmode/sms_only',\n    )\n    try:\n      modem = self.get_modem()\n      return { fn: str(modem.Command(f'AT+QNVFR=\"{fn}\"', math.ceil(timeout), dbus_interface=MM_MODEM, timeout=timeout)) for fn in files}\n    except Exception:\n      return None\n\n  def get_modem_temperatures(self):\n    timeout = 0.2  # Default timeout is too short\n    try:\n      modem = self.get_modem()\n      temps = modem.Command(\"AT+QTEMP\", math.ceil(timeout), dbus_interface=MM_MODEM, timeout=timeout)\n      return list(map(int, temps.split(' ')[1].split(',')))\n    except Exception:\n      return []\n\n  def get_nvme_temperatures(self):\n    ret = []\n    try:\n      out = subprocess.check_output(\"sudo smartctl -aj /dev/nvme0\", shell=True)\n      dat = json.loads(out)\n      ret = list(map(int, dat[\"nvme_smart_health_information_log\"][\"temperature_sensors\"]))\n    except Exception:\n      pass\n    return ret\n\n  def get_current_power_draw(self):\n    return (self.read_param_file(\"/sys/class/hwmon/hwmon1/power1_input\", int) / 1e6)\n\n  def get_som_power_draw(self):\n    return (self.read_param_file(\"/sys/class/power_supply/bms/voltage_now\", int) * self.read_param_file(\"/sys/class/power_supply/bms/current_now\", int) / 1e12)\n\n  def shutdown(self):\n    os.system(\"sudo poweroff\")\n\n  def get_thermal_config(self):\n    return ThermalConfig(cpu=([\"cpu%d-silver-usr\" % i for i in range(4)] +\n                              [\"cpu%d-gold-usr\" % i for i in range(4)], 1000),\n                         gpu=((\"gpu0-usr\", \"gpu1-usr\"), 1000),\n                         mem=(\"ddr-usr\", 1000),\n                         bat=(None, 1),\n                         pmic=((\"pm8998_tz\", \"pm8005_tz\"), 1000))\n\n  def set_screen_brightness(self, percentage):\n    try:\n      with open(\"/sys/class/backlight/panel0-backlight/max_brightness\") as f:\n        max_brightness = float(f.read().strip())\n\n      val = int(percentage * (max_brightness / 100.))\n      with open(\"/sys/class/backlight/panel0-backlight/brightness\", \"w\") as f:\n        f.write(str(val))\n    except Exception:\n      pass\n\n  def get_screen_brightness(self):\n    try:\n      with open(\"/sys/class/backlight/panel0-backlight/max_brightness\") as f:\n        max_brightness = float(f.read().strip())\n\n      with open(\"/sys/class/backlight/panel0-backlight/brightness\") as f:\n        return int(float(f.read()) / (max_brightness / 100.))\n    except Exception:\n      return 0\n\n  def set_power_save(self, powersave_enabled):\n    # amplifier, 100mW at idle\n    if self.amplifier is not None:\n      self.amplifier.set_global_shutdown(amp_disabled=powersave_enabled)\n      if not powersave_enabled:\n        self.amplifier.initialize_configuration(self.get_device_type())\n\n    # *** CPU config ***\n\n    # offline big cluster, leave core 4 online for pandad\n    for i in range(4, 8):\n      val = '0' if powersave_enabled else '1'\n      sudo_write(val, f'/sys/devices/system/cpu/cpu{i}/online')\n\n    for n in ('0', '4'):\n      if powersave_enabled and n == '4':\n        continue\n      gov = 'ondemand' if powersave_enabled else 'performance'\n      sudo_write(gov, f'/sys/devices/system/cpu/cpufreq/policy{n}/scaling_governor')\n\n    # *** IRQ config ***\n\n    # GPU\n    affine_irq(5, \"kgsl-3d0\")\n\n    # camerad core\n    camera_irqs = (\"cci\", \"cpas_camnoc\", \"cpas-cdm\", \"csid\", \"ife\", \"csid-lite\", \"ife-lite\")\n    for n in camera_irqs:\n      affine_irq(5, n)\n\n  def get_gpu_usage_percent(self):\n    try:\n      with open('/sys/class/kgsl/kgsl-3d0/gpubusy') as f:\n        used, total = f.read().strip().split()\n      return 100.0 * int(used) / int(total)\n    except Exception:\n      return 0\n\n  def initialize_hardware(self):\n    if self.amplifier is not None:\n      self.amplifier.initialize_configuration(self.get_device_type())\n\n    # Allow hardwared to write engagement status to kmsg\n    os.system(\"sudo chmod a+w /dev/kmsg\")\n\n    # Ensure fan gpio is enabled so fan runs until shutdown, also turned on at boot by the ABL\n    gpio_init(GPIO.SOM_ST_IO, True)\n    gpio_set(GPIO.SOM_ST_IO, 1)\n\n    # *** IRQ config ***\n\n    # mask off big cluster from default affinity\n    sudo_write(\"f\", \"/proc/irq/default_smp_affinity\")\n\n    # move these off the default core\n    affine_irq(1, \"msm_drm\")   # display\n    affine_irq(1, \"msm_vidc\")  # encoders\n    affine_irq(1, \"i2c_geni\")  # sensors\n\n    # *** GPU config ***\n    # https://github.com/commaai/agnos-kernel-sdm845/blob/master/arch/arm64/boot/dts/qcom/sdm845-gpu.dtsi#L216\n    sudo_write(\"1\", \"/sys/class/kgsl/kgsl-3d0/min_pwrlevel\")\n    sudo_write(\"1\", \"/sys/class/kgsl/kgsl-3d0/max_pwrlevel\")\n    sudo_write(\"1\", \"/sys/class/kgsl/kgsl-3d0/force_bus_on\")\n    sudo_write(\"1\", \"/sys/class/kgsl/kgsl-3d0/force_clk_on\")\n    sudo_write(\"1\", \"/sys/class/kgsl/kgsl-3d0/force_rail_on\")\n    sudo_write(\"1000\", \"/sys/class/kgsl/kgsl-3d0/idle_timer\")\n    sudo_write(\"performance\", \"/sys/class/kgsl/kgsl-3d0/devfreq/governor\")\n    sudo_write(\"710\", \"/sys/class/kgsl/kgsl-3d0/max_clock_mhz\")\n\n    # setup governors\n    sudo_write(\"performance\", \"/sys/class/devfreq/soc:qcom,cpubw/governor\")\n    sudo_write(\"performance\", \"/sys/class/devfreq/soc:qcom,memlat-cpu0/governor\")\n    sudo_write(\"performance\", \"/sys/class/devfreq/soc:qcom,memlat-cpu4/governor\")\n\n    # *** VIDC (encoder) config ***\n    sudo_write(\"N\", \"/sys/kernel/debug/msm_vidc/clock_scaling\")\n    sudo_write(\"Y\", \"/sys/kernel/debug/msm_vidc/disable_thermal_mitigation\")\n\n    # pandad core\n    affine_irq(3, \"spi_geni\")         # SPI\n    if \"tici\" in self.get_device_type():\n      affine_irq(3, \"xhci-hcd:usb3\")  # aux panda USB (or potentially anything else on USB)\n      affine_irq(3, \"xhci-hcd:usb1\")  # internal panda USB (also modem)\n    try:\n      pid = subprocess.check_output([\"pgrep\", \"-f\", \"spi0\"], encoding='utf8').strip()\n      subprocess.call([\"sudo\", \"chrt\", \"-f\", \"-p\", \"1\", pid])\n      subprocess.call([\"sudo\", \"taskset\", \"-pc\", \"3\", pid])\n    except subprocess.CalledProcessException as e:\n      print(str(e))\n\n  def configure_modem(self):\n    sim_id = self.get_sim_info().get('sim_id', '')\n\n    modem = self.get_modem()\n    try:\n      manufacturer = str(modem.Get(MM_MODEM, 'Manufacturer', dbus_interface=DBUS_PROPS, timeout=TIMEOUT))\n    except Exception:\n      manufacturer = None\n\n    cmds = []\n    if manufacturer == 'Cavli Inc.':\n      cmds += [\n        # use sim slot\n        'AT^SIMSWAP=1',\n\n        # ethernet config\n        'AT$QCPCFG=usbNet,0',\n        'AT$QCNETDEVCTL=3,1',\n      ]\n    else:\n      cmds += [\n        # configure modem as data-centric\n        'AT+QNVW=5280,0,\"0102000000000000\"',\n        'AT+QNVFW=\"/nv/item_files/ims/IMS_enable\",00',\n        'AT+QNVFW=\"/nv/item_files/modem/mmode/ue_usage_setting\",01',\n      ]\n      if self.get_device_type() == \"tizi\":\n        cmds += [\n          # SIM hot swap\n          'AT+QSIMDET=1,0',\n          'AT+QSIMSTAT=1',\n        ]\n\n      # clear out old blue prime initial APN\n      os.system('mmcli -m any --3gpp-set-initial-eps-bearer-settings=\"apn=\"')\n    for cmd in cmds:\n      try:\n        modem.Command(cmd, math.ceil(TIMEOUT), dbus_interface=MM_MODEM, timeout=TIMEOUT)\n      except Exception:\n        pass\n\n    # eSIM prime\n    if sim_id.startswith('8985235'):\n      dest = \"/etc/NetworkManager/system-connections/esim.nmconnection\"\n      with open(Path(__file__).parent/'esim.nmconnection') as f, tempfile.NamedTemporaryFile(mode='w') as tf:\n        dat = f.read()\n        dat = dat.replace(\"sim-id=\", f\"sim-id={sim_id}\")\n        tf.write(dat)\n        tf.flush()\n\n        # needs to be root\n        os.system(f\"sudo cp {tf.name} {dest}\")\n      os.system(f\"sudo nmcli con load {dest}\")\n\n  def get_networks(self):\n    r = {}\n\n    wlan = iwlist.scan()\n    if wlan is not None:\n      r['wlan'] = wlan\n\n    lte_info = self.get_network_info()\n    if lte_info is not None:\n      extra = lte_info['extra']\n\n      # <state>,\"LTE\",<is_tdd>,<mcc>,<mnc>,<cellid>,<pcid>,<earfcn>,<freq_band_ind>,\n      # <ul_bandwidth>,<dl_bandwidth>,<tac>,<rsrp>,<rsrq>,<rssi>,<sinr>,<srxlev>\n      if 'LTE' in extra:\n        extra = extra.split(',')\n        try:\n          r['lte'] = [{\n            \"mcc\": int(extra[3]),\n            \"mnc\": int(extra[4]),\n            \"cid\": int(extra[5], 16),\n            \"nmr\": [{\"pci\": int(extra[6]), \"earfcn\": int(extra[7])}],\n          }]\n        except (ValueError, IndexError):\n          pass\n\n    return r\n\n  def get_modem_data_usage(self):\n    try:\n      wwan = self.get_wwan()\n\n      # Ensure refresh rate is set so values don't go stale\n      refresh_rate = wwan.Get(NM_DEV_STATS, 'RefreshRateMs', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n      if refresh_rate != REFRESH_RATE_MS:\n        u = type(refresh_rate)\n        wwan.Set(NM_DEV_STATS, 'RefreshRateMs', u(REFRESH_RATE_MS), dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n\n      tx = wwan.Get(NM_DEV_STATS, 'TxBytes', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n      rx = wwan.Get(NM_DEV_STATS, 'RxBytes', dbus_interface=DBUS_PROPS, timeout=TIMEOUT)\n      return int(tx), int(rx)\n    except Exception:\n      return -1, -1\n\n  def has_internal_panda(self):\n    return True\n\n  def reset_internal_panda(self):\n    gpio_init(GPIO.STM_RST_N, True)\n\n    gpio_set(GPIO.STM_RST_N, 1)\n    time.sleep(1)\n    gpio_set(GPIO.STM_RST_N, 0)\n\n  def recover_internal_panda(self):\n    gpio_init(GPIO.STM_RST_N, True)\n    gpio_init(GPIO.STM_BOOT0, True)\n\n    gpio_set(GPIO.STM_RST_N, 1)\n    gpio_set(GPIO.STM_BOOT0, 1)\n    time.sleep(0.5)\n    gpio_set(GPIO.STM_RST_N, 0)\n    time.sleep(0.5)\n    gpio_set(GPIO.STM_BOOT0, 0)\n\n  def booted(self):\n    # this normally boots within 8s, but on rare occasions takes 30+s\n    encoder_state = sudo_read(\"/sys/kernel/debug/msm_vidc/core0/info\")\n    if \"Core state: 0\" in encoder_state and (time.monotonic() < 60*2):\n      return False\n    return True\n\nif __name__ == \"__main__\":\n  t = Tici()\n  t.configure_modem()\n  t.initialize_hardware()\n  t.set_power_save(False)\n", "system/hardware/tici/power_monitor.py": "#!/usr/bin/env python3\nimport sys\nimport time\nimport datetime\nimport numpy as np\nfrom collections import deque\n\nfrom openpilot.common.realtime import Ratekeeper\nfrom openpilot.common.filter_simple import FirstOrderFilter\n\n\ndef read_power():\n  with open(\"/sys/bus/i2c/devices/0-0040/hwmon/hwmon1/power1_input\") as f:\n    return int(f.read()) / 1e6\n\ndef sample_power(seconds=5) -> list[float]:\n  rate = 123\n  rk = Ratekeeper(rate, print_delay_threshold=None)\n\n  pwrs = []\n  for _ in range(rate*seconds):\n    pwrs.append(read_power())\n    rk.keep_time()\n  return pwrs\n\ndef get_power(seconds=5):\n  pwrs = sample_power(seconds)\n  return np.mean(pwrs)\n\ndef wait_for_power(min_pwr, max_pwr, min_secs_in_range, timeout):\n  start_time = time.monotonic()\n  pwrs = deque([min_pwr - 1.]*min_secs_in_range, maxlen=min_secs_in_range)\n  while (time.monotonic() - start_time < timeout):\n    pwrs.append(get_power(1))\n    if all(min_pwr <= p <= max_pwr for p in pwrs):\n      break\n  return np.mean(pwrs)\n\n\nif __name__ == \"__main__\":\n  duration = None\n  if len(sys.argv) > 1:\n    duration = int(sys.argv[1])\n\n  rate = 23\n  rk = Ratekeeper(rate, print_delay_threshold=None)\n  fltr = FirstOrderFilter(0, 5, 1. / rate, initialized=False)\n\n  measurements = []\n  start_time = time.monotonic()\n\n  try:\n    while duration is None or time.monotonic() - start_time < duration:\n      fltr.update(read_power())\n      if rk.frame % rate == 0:\n        measurements.append(fltr.x)\n        t = datetime.timedelta(seconds=time.monotonic() - start_time)\n        avg = sum(measurements) / len(measurements)\n        print(f\"Now: {fltr.x:.2f} W, Avg: {avg:.2f} W over {t}\")\n      rk.keep_time()\n  except KeyboardInterrupt:\n    pass\n\n  t = datetime.timedelta(seconds=time.monotonic() - start_time)\n  avg = sum(measurements) / len(measurements)\n  print(f\"\\nAverage power: {avg:.2f}W over {t}\")\n", "system/hardware/tici/pins.py": "# TODO: these are also defined in a header\n\n# GPIO pin definitions\nclass GPIO:\n  # both GPIO_STM_RST_N and GPIO_LTE_RST_N are misnamed, they are high to reset\n  HUB_RST_N = 30\n  UBLOX_RST_N = 32\n  UBLOX_SAFEBOOT_N = 33\n  GNSS_PWR_EN = 34 # SCHEMATIC LABEL: GPIO_UBLOX_PWR_EN\n  STM_RST_N = 124\n  STM_BOOT0 = 134\n\n  SIREN = 42\n  SOM_ST_IO = 49\n\n  LTE_RST_N = 50\n  LTE_PWRKEY = 116\n  LTE_BOOT = 52\n\n  # GPIO_CAM0_DVDD_EN = /sys/kernel/debug/regulator/camera_rear_ldo\n  CAM0_AVDD_EN = 8\n  CAM0_RSTN = 9\n  CAM1_RSTN = 7\n  CAM2_RSTN = 12\n\n  # Sensor interrupts\n  BMX055_ACCEL_INT = 21\n  BMX055_GYRO_INT = 23\n  BMX055_MAGN_INT = 87\n  LSM_INT = 84\n", "system/hardware/tici/iwlist.py": "import subprocess\n\n\ndef scan(interface=\"wlan0\"):\n  result = []\n  try:\n    r = subprocess.check_output([\"iwlist\", interface, \"scan\"], encoding='utf8')\n\n    mac = None\n    for line in r.split('\\n'):\n      if \"Address\" in line:\n        # Based on the adapter eithere a percentage or dBm is returned\n        # Add previous network in case no dBm signal level was seen\n        if mac is not None:\n          result.append({\"mac\": mac})\n          mac = None\n\n        mac = line.split(' ')[-1]\n      elif \"dBm\" in line:\n        try:\n          level = line.split('Signal level=')[1]\n          rss = int(level.split(' ')[0])\n          result.append({\"mac\": mac, \"rss\": rss})\n          mac = None\n        except ValueError:\n          continue\n\n    # Add last network if no dBm was found\n    if mac is not None:\n      result.append({\"mac\": mac})\n\n    return result\n\n  except Exception:\n    return None\n", "system/hardware/tici/agnos.py": "#!/usr/bin/env python3\nimport hashlib\nimport json\nimport lzma\nimport os\nimport struct\nimport subprocess\nimport time\nfrom collections.abc import Generator\n\nimport requests\n\nimport openpilot.system.updated.casync.casync as casync\n\nSPARSE_CHUNK_FMT = struct.Struct('H2xI4x')\nCAIBX_URL = \"https://commadist.azureedge.net/agnosupdate/\"\n\nAGNOS_MANIFEST_FILE = \"system/hardware/tici/agnos.json\"\n\n\nclass StreamingDecompressor:\n  def __init__(self, url: str) -> None:\n    self.buf = b\"\"\n\n    self.req = requests.get(url, stream=True, headers={'Accept-Encoding': None}, timeout=60)\n    self.it = self.req.iter_content(chunk_size=1024 * 1024)\n    self.decompressor = lzma.LZMADecompressor(format=lzma.FORMAT_AUTO)\n    self.eof = False\n    self.sha256 = hashlib.sha256()\n\n  def read(self, length: int) -> bytes:\n    while len(self.buf) < length:\n      self.req.raise_for_status()\n\n      try:\n        compressed = next(self.it)\n      except StopIteration:\n        self.eof = True\n        break\n      out = self.decompressor.decompress(compressed)\n      self.buf += out\n\n    result = self.buf[:length]\n    self.buf = self.buf[length:]\n\n    self.sha256.update(result)\n    return result\n\n\ndef unsparsify(f: StreamingDecompressor) -> Generator[bytes, None, None]:\n  # https://source.android.com/devices/bootloader/images#sparse-format\n  magic = struct.unpack(\"I\", f.read(4))[0]\n  assert(magic == 0xed26ff3a)\n\n  # Version\n  major = struct.unpack(\"H\", f.read(2))[0]\n  minor = struct.unpack(\"H\", f.read(2))[0]\n  assert(major == 1 and minor == 0)\n\n  f.read(2)  # file header size\n  f.read(2)  # chunk header size\n\n  block_sz = struct.unpack(\"I\", f.read(4))[0]\n  f.read(4)  # total blocks\n  num_chunks = struct.unpack(\"I\", f.read(4))[0]\n  f.read(4)  # crc checksum\n\n  for _ in range(num_chunks):\n    chunk_type, out_blocks = SPARSE_CHUNK_FMT.unpack(f.read(12))\n\n    if chunk_type == 0xcac1:  # Raw\n      # TODO: yield in smaller chunks. Yielding only block_sz is too slow. Largest observed data chunk is 252 MB.\n      yield f.read(out_blocks * block_sz)\n    elif chunk_type == 0xcac2:  # Fill\n      filler = f.read(4) * (block_sz // 4)\n      for _ in range(out_blocks):\n        yield filler\n    elif chunk_type == 0xcac3:  # Don't care\n      yield b\"\"\n    else:\n      raise Exception(\"Unhandled sparse chunk type\")\n\n\n# noop wrapper with same API as unsparsify() for non sparse images\ndef noop(f: StreamingDecompressor) -> Generator[bytes, None, None]:\n  while not f.eof:\n    yield f.read(1024 * 1024)\n\n\ndef get_target_slot_number() -> int:\n  current_slot = subprocess.check_output([\"abctl\", \"--boot_slot\"], encoding='utf-8').strip()\n  return 1 if current_slot == \"_a\" else 0\n\n\ndef slot_number_to_suffix(slot_number: int) -> str:\n  assert slot_number in (0, 1)\n  return '_a' if slot_number == 0 else '_b'\n\n\ndef get_partition_path(target_slot_number: int, partition: dict) -> str:\n  path = f\"/dev/disk/by-partlabel/{partition['name']}\"\n\n  if partition.get('has_ab', True):\n    path += slot_number_to_suffix(target_slot_number)\n\n  return path\n\n\ndef get_raw_hash(path: str, partition_size: int) -> str:\n  raw_hash = hashlib.sha256()\n  pos, chunk_size = 0, 1024 * 1024\n\n  with open(path, 'rb+') as out:\n    while pos < partition_size:\n      n = min(chunk_size, partition_size - pos)\n      raw_hash.update(out.read(n))\n      pos += n\n\n  return raw_hash.hexdigest().lower()\n\n\ndef verify_partition(target_slot_number: int, partition: dict[str, str | int], force_full_check: bool = False) -> bool:\n  full_check = partition['full_check'] or force_full_check\n  path = get_partition_path(target_slot_number, partition)\n\n  if not isinstance(partition['size'], int):\n    return False\n\n  partition_size: int = partition['size']\n\n  if not isinstance(partition['hash_raw'], str):\n    return False\n\n  partition_hash: str = partition['hash_raw']\n\n  if full_check:\n    return get_raw_hash(path, partition_size) == partition_hash.lower()\n  else:\n    with open(path, 'rb+') as out:\n      out.seek(partition_size)\n      return out.read(64) == partition_hash.lower().encode()\n\n\ndef clear_partition_hash(target_slot_number: int, partition: dict) -> None:\n  path = get_partition_path(target_slot_number, partition)\n  with open(path, 'wb+') as out:\n    partition_size = partition['size']\n\n    out.seek(partition_size)\n    out.write(b\"\\x00\" * 64)\n    os.sync()\n\n\ndef extract_compressed_image(target_slot_number: int, partition: dict, cloudlog):\n  path = get_partition_path(target_slot_number, partition)\n  downloader = StreamingDecompressor(partition['url'])\n\n  with open(path, 'wb+') as out:\n    # Flash partition\n    last_p = 0\n    raw_hash = hashlib.sha256()\n    f = unsparsify if partition['sparse'] else noop\n    for chunk in f(downloader):\n      raw_hash.update(chunk)\n      out.write(chunk)\n      p = int(out.tell() / partition['size'] * 100)\n      if p != last_p:\n        last_p = p\n        print(f\"Installing {partition['name']}: {p}\", flush=True)\n\n    if raw_hash.hexdigest().lower() != partition['hash_raw'].lower():\n      raise Exception(f\"Raw hash mismatch '{raw_hash.hexdigest().lower()}'\")\n\n    if downloader.sha256.hexdigest().lower() != partition['hash'].lower():\n      raise Exception(\"Uncompressed hash mismatch\")\n\n    if out.tell() != partition['size']:\n      raise Exception(\"Uncompressed size mismatch\")\n\n    os.sync()\n\n\ndef extract_casync_image(target_slot_number: int, partition: dict, cloudlog):\n  path = get_partition_path(target_slot_number, partition)\n  seed_path = path[:-1] + ('b' if path[-1] == 'a' else 'a')\n\n  target = casync.parse_caibx(partition['casync_caibx'])\n\n  sources: list[tuple[str, casync.ChunkReader, casync.ChunkDict]] = []\n\n  # First source is the current partition.\n  try:\n    raw_hash = get_raw_hash(seed_path, partition['size'])\n    caibx_url = f\"{CAIBX_URL}{partition['name']}-{raw_hash}.caibx\"\n\n    try:\n      cloudlog.info(f\"casync fetching {caibx_url}\")\n      sources += [('seed', casync.FileChunkReader(seed_path), casync.build_chunk_dict(casync.parse_caibx(caibx_url)))]\n    except requests.RequestException:\n      cloudlog.error(f\"casync failed to load {caibx_url}\")\n  except Exception:\n    cloudlog.exception(\"casync failed to hash seed partition\")\n\n  # Second source is the target partition, this allows for resuming\n  sources += [('target', casync.FileChunkReader(path), casync.build_chunk_dict(target))]\n\n  # Finally we add the remote source to download any missing chunks\n  sources += [('remote', casync.RemoteChunkReader(partition['casync_store']), casync.build_chunk_dict(target))]\n\n  last_p = 0\n\n  def progress(cur):\n    nonlocal last_p\n    p = int(cur / partition['size'] * 100)\n    if p != last_p:\n      last_p = p\n      print(f\"Installing {partition['name']}: {p}\", flush=True)\n\n  stats = casync.extract(target, sources, path, progress)\n  cloudlog.error(f'casync done {json.dumps(stats)}')\n\n  os.sync()\n  if not verify_partition(target_slot_number, partition, force_full_check=True):\n    raise Exception(f\"Raw hash mismatch '{partition['hash_raw'].lower()}'\")\n\n\ndef flash_partition(target_slot_number: int, partition: dict, cloudlog, standalone=False):\n  cloudlog.info(f\"Downloading and writing {partition['name']}\")\n\n  if verify_partition(target_slot_number, partition):\n    cloudlog.info(f\"Already flashed {partition['name']}\")\n    return\n\n  # Clear hash before flashing in case we get interrupted\n  full_check = partition['full_check']\n  if not full_check:\n    clear_partition_hash(target_slot_number, partition)\n\n  path = get_partition_path(target_slot_number, partition)\n\n  if ('casync_caibx' in partition) and not standalone:\n    extract_casync_image(target_slot_number, partition, cloudlog)\n  else:\n    extract_compressed_image(target_slot_number, partition, cloudlog)\n\n  # Write hash after successful flash\n  if not full_check:\n    with open(path, 'wb+') as out:\n      out.seek(partition['size'])\n      out.write(partition['hash_raw'].lower().encode())\n\n\ndef swap(manifest_path: str, target_slot_number: int, cloudlog) -> None:\n  update = json.load(open(manifest_path))\n  for partition in update:\n    if not partition.get('full_check', False):\n      clear_partition_hash(target_slot_number, partition)\n\n  while True:\n    out = subprocess.check_output(f\"abctl --set_active {target_slot_number}\", shell=True, stderr=subprocess.STDOUT, encoding='utf8')\n    if (\"No such file or directory\" not in out) and (\"lun as boot lun\" in out):\n      cloudlog.info(f\"Swap successful {out}\")\n      break\n    else:\n      cloudlog.error(f\"Swap failed {out}\")\n\n\ndef flash_agnos_update(manifest_path: str, target_slot_number: int, cloudlog, standalone=False) -> None:\n  update = json.load(open(manifest_path))\n\n  cloudlog.info(f\"Target slot {target_slot_number}\")\n\n  # set target slot as unbootable\n  os.system(f\"abctl --set_unbootable {target_slot_number}\")\n\n  for partition in update:\n    success = False\n\n    for retries in range(10):\n      try:\n        flash_partition(target_slot_number, partition, cloudlog, standalone)\n        success = True\n        break\n\n      except requests.exceptions.RequestException:\n        cloudlog.exception(\"Failed\")\n        cloudlog.info(f\"Failed to download {partition['name']}, retrying ({retries})\")\n        time.sleep(10)\n\n    if not success:\n      cloudlog.info(f\"Failed to flash {partition['name']}, aborting\")\n      raise Exception(\"Maximum retries exceeded\")\n\n  cloudlog.info(f\"AGNOS ready on slot {target_slot_number}\")\n\n\ndef verify_agnos_update(manifest_path: str, target_slot_number: int) -> bool:\n  update = json.load(open(manifest_path))\n  return all(verify_partition(target_slot_number, partition) for partition in update)\n\n\nif __name__ == \"__main__\":\n  import argparse\n  import logging\n\n  parser = argparse.ArgumentParser(description=\"Flash and verify AGNOS update\",\n                                   formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  parser.add_argument(\"--verify\", action=\"store_true\", help=\"Verify and perform swap if update ready\")\n  parser.add_argument(\"--swap\", action=\"store_true\", help=\"Verify and perform swap, downloads if necessary\")\n  parser.add_argument(\"manifest\", help=\"Manifest json\")\n  args = parser.parse_args()\n\n  logging.basicConfig(level=logging.INFO)\n\n  target_slot_number = get_target_slot_number()\n  if args.verify:\n    if verify_agnos_update(args.manifest, target_slot_number):\n      swap(args.manifest, target_slot_number, logging)\n      exit(0)\n    exit(1)\n  elif args.swap:\n    while not verify_agnos_update(args.manifest, target_slot_number):\n      logging.error(\"Verification failed. Flashing AGNOS\")\n      flash_agnos_update(args.manifest, target_slot_number, logging, standalone=True)\n\n    logging.warning(f\"Verification succeeded. Swapping to slot {target_slot_number}\")\n    swap(args.manifest, target_slot_number, logging)\n  else:\n    flash_agnos_update(args.manifest, target_slot_number, logging, standalone=True)\n", "system/hardware/tici/amplifier.py": "#!/usr/bin/env python3\nimport time\nfrom smbus2 import SMBus\nfrom collections import namedtuple\n\n# https://datasheets.maximintegrated.com/en/ds/MAX98089.pdf\n\nAmpConfig = namedtuple('AmpConfig', ['name', 'value', 'register', 'offset', 'mask'])\nEQParams = namedtuple('EQParams', ['K', 'k1', 'k2', 'c1', 'c2'])\n\ndef configs_from_eq_params(base, eq_params):\n  return [\n    AmpConfig(\"K (high)\", (eq_params.K >> 8), base, 0, 0xFF),\n    AmpConfig(\"K (low)\", (eq_params.K & 0xFF), base + 1, 0, 0xFF),\n    AmpConfig(\"k1 (high)\", (eq_params.k1 >> 8), base + 2, 0, 0xFF),\n    AmpConfig(\"k1 (low)\", (eq_params.k1 & 0xFF), base + 3, 0, 0xFF),\n    AmpConfig(\"k2 (high)\", (eq_params.k2 >> 8), base + 4, 0, 0xFF),\n    AmpConfig(\"k2 (low)\", (eq_params.k2 & 0xFF), base + 5, 0, 0xFF),\n    AmpConfig(\"c1 (high)\", (eq_params.c1 >> 8), base + 6, 0, 0xFF),\n    AmpConfig(\"c1 (low)\", (eq_params.c1 & 0xFF), base + 7, 0, 0xFF),\n    AmpConfig(\"c2 (high)\", (eq_params.c2 >> 8), base + 8, 0, 0xFF),\n    AmpConfig(\"c2 (low)\", (eq_params.c2 & 0xFF), base + 9, 0, 0xFF),\n  ]\n\nBASE_CONFIG = [\n  AmpConfig(\"MCLK prescaler\", 0b01, 0x10, 4, 0b00110000),\n  AmpConfig(\"PM: enable speakers\", 0b11, 0x4D, 4, 0b00110000),\n  AmpConfig(\"PM: enable DACs\", 0b11, 0x4D, 0, 0b00000011),\n  AmpConfig(\"Enable PLL1\", 0b1, 0x12, 7, 0b10000000),\n  AmpConfig(\"Enable PLL2\", 0b1, 0x1A, 7, 0b10000000),\n  AmpConfig(\"DAI1: I2S mode\", 0b00100, 0x14, 2, 0b01111100),\n  AmpConfig(\"DAI2: I2S mode\", 0b00100, 0x1C, 2, 0b01111100),\n  AmpConfig(\"DAI1 Passband filtering: music mode\", 0b1, 0x18, 7, 0b10000000),\n  AmpConfig(\"DAI1 voice mode gain (DV1G)\", 0b00, 0x2F, 4, 0b00110000),\n  AmpConfig(\"DAI1 attenuation (DV1)\", 0x0, 0x2F, 0, 0b00001111),\n  AmpConfig(\"DAI2 attenuation (DV2)\", 0x0, 0x31, 0, 0b00001111),\n  AmpConfig(\"DAI2: DC blocking\", 0b1, 0x20, 0, 0b00000001),\n  AmpConfig(\"DAI2: High sample rate\", 0b0, 0x20, 3, 0b00001000),\n  AmpConfig(\"ALC enable\", 0b1, 0x43, 7, 0b10000000),\n  AmpConfig(\"ALC/excursion limiter release time\", 0b101, 0x43, 4, 0b01110000),\n  AmpConfig(\"ALC multiband enable\", 0b1, 0x43, 3, 0b00001000),\n  AmpConfig(\"DAI1 EQ enable\", 0b0, 0x49, 0, 0b00000001),\n  AmpConfig(\"DAI2 EQ clip detection disabled\", 0b1, 0x32, 4, 0b00010000),\n  AmpConfig(\"DAI2 EQ attenuation\", 0x5, 0x32, 0, 0b00001111),\n  AmpConfig(\"Excursion limiter upper corner freq\", 0b100, 0x41, 4, 0b01110000),\n  AmpConfig(\"Excursion limiter lower corner freq\", 0b00, 0x41, 0, 0b00000011),\n  AmpConfig(\"Excursion limiter threshold\", 0b000, 0x42, 0, 0b00001111),\n  AmpConfig(\"Distortion limit (THDCLP)\", 0x6, 0x46, 4, 0b11110000),\n  AmpConfig(\"Distortion limiter release time constant\", 0b0, 0x46, 0, 0b00000001),\n  AmpConfig(\"Right DAC input mixer: DAI1 left\", 0b0, 0x22, 3, 0b00001000),\n  AmpConfig(\"Right DAC input mixer: DAI1 right\", 0b0, 0x22, 2, 0b00000100),\n  AmpConfig(\"Right DAC input mixer: DAI2 left\", 0b1, 0x22, 1, 0b00000010),\n  AmpConfig(\"Right DAC input mixer: DAI2 right\", 0b0, 0x22, 0, 0b00000001),\n  AmpConfig(\"DAI1 audio port selector\", 0b10, 0x16, 6, 0b11000000),\n  AmpConfig(\"DAI2 audio port selector\", 0b01, 0x1E, 6, 0b11000000),\n  AmpConfig(\"Enable left digital microphone\", 0b1, 0x48, 5, 0b00100000),\n  AmpConfig(\"Enable right digital microphone\", 0b1, 0x48, 4, 0b00010000),\n  AmpConfig(\"Enhanced volume smoothing disabled\", 0b0, 0x49, 7, 0b10000000),\n  AmpConfig(\"Volume adjustment smoothing disabled\", 0b0, 0x49, 6, 0b01000000),\n  AmpConfig(\"Zero-crossing detection disabled\", 0b0, 0x49, 5, 0b00100000),\n]\n\nCONFIGS = {\n  \"tici\": [\n    AmpConfig(\"Right speaker output from right DAC\", 0b1, 0x2C, 0, 0b11111111),\n    AmpConfig(\"Right Speaker Mixer Gain\", 0b00, 0x2D, 2, 0b00001100),\n    AmpConfig(\"Right speaker output volume\", 0x1c, 0x3E, 0, 0b00011111),\n    AmpConfig(\"DAI2 EQ enable\", 0b1, 0x49, 1, 0b00000010),\n\n    *configs_from_eq_params(0x84, EQParams(0x274F, 0xC0FF, 0x3BF9, 0x0B3C, 0x1656)),\n    *configs_from_eq_params(0x8E, EQParams(0x1009, 0xC6BF, 0x2952, 0x1C97, 0x30DF)),\n    *configs_from_eq_params(0x98, EQParams(0x0F75, 0xCBE5, 0x0ED2, 0x2528, 0x3E42)),\n    *configs_from_eq_params(0xA2, EQParams(0x091F, 0x3D4C, 0xCE11, 0x1266, 0x2807)),\n    *configs_from_eq_params(0xAC, EQParams(0x0A9E, 0x3F20, 0xE573, 0x0A8B, 0x3A3B)),\n  ],\n  \"tizi\": [\n    AmpConfig(\"Left speaker output from left DAC\", 0b1, 0x2B, 0, 0b11111111),\n    AmpConfig(\"Right speaker output from right DAC\", 0b1, 0x2C, 0, 0b11111111),\n    AmpConfig(\"Left Speaker Mixer Gain\", 0b00, 0x2D, 0, 0b00000011),\n    AmpConfig(\"Right Speaker Mixer Gain\", 0b00, 0x2D, 2, 0b00001100),\n    AmpConfig(\"Left speaker output volume\", 0x17, 0x3D, 0, 0b00011111),\n    AmpConfig(\"Right speaker output volume\", 0x17, 0x3E, 0, 0b00011111),\n\n    AmpConfig(\"DAI2 EQ enable\", 0b0, 0x49, 1, 0b00000010),\n    AmpConfig(\"DAI2: DC blocking\", 0b0, 0x20, 0, 0b00000001),\n    AmpConfig(\"ALC enable\", 0b0, 0x43, 7, 0b10000000),\n    AmpConfig(\"DAI2 EQ attenuation\", 0x2, 0x32, 0, 0b00001111),\n    AmpConfig(\"Excursion limiter upper corner freq\", 0b001, 0x41, 4, 0b01110000),\n    AmpConfig(\"Excursion limiter threshold\", 0b100, 0x42, 0, 0b00001111),\n    AmpConfig(\"Distortion limit (THDCLP)\", 0x0, 0x46, 4, 0b11110000),\n    AmpConfig(\"Distortion limiter release time constant\", 0b1, 0x46, 0, 0b00000001),\n    AmpConfig(\"Left DAC input mixer: DAI1 left\", 0b0, 0x22, 7, 0b10000000),\n    AmpConfig(\"Left DAC input mixer: DAI1 right\", 0b0, 0x22, 6, 0b01000000),\n    AmpConfig(\"Left DAC input mixer: DAI2 left\", 0b1, 0x22, 5, 0b00100000),\n    AmpConfig(\"Left DAC input mixer: DAI2 right\", 0b0, 0x22, 4, 0b00010000),\n    AmpConfig(\"Right DAC input mixer: DAI2 left\", 0b0, 0x22, 1, 0b00000010),\n    AmpConfig(\"Right DAC input mixer: DAI2 right\", 0b1, 0x22, 0, 0b00000001),\n    AmpConfig(\"Volume adjustment smoothing disabled\", 0b1, 0x49, 6, 0b01000000),\n  ],\n}\n\nclass Amplifier:\n  AMP_I2C_BUS = 0\n  AMP_ADDRESS = 0x10\n\n  def __init__(self, debug=False):\n    self.debug = debug\n\n  def _get_shutdown_config(self, amp_disabled: bool) -> AmpConfig:\n    return AmpConfig(\"Global shutdown\", 0b0 if amp_disabled else 0b1, 0x51, 7, 0b10000000)\n\n  def _set_configs(self, configs: list[AmpConfig]) -> None:\n    with SMBus(self.AMP_I2C_BUS) as bus:\n      for config in configs:\n        if self.debug:\n          print(f\"Setting \\\"{config.name}\\\" to {config.value}:\")\n\n        old_value = bus.read_byte_data(self.AMP_ADDRESS, config.register, force=True)\n        new_value = (old_value & (~config.mask)) | ((config.value << config.offset) & config.mask)\n        bus.write_byte_data(self.AMP_ADDRESS, config.register, new_value, force=True)\n\n        if self.debug:\n          print(f\"  Changed {hex(config.register)}: {hex(old_value)} -> {hex(new_value)}\")\n\n  def set_configs(self, configs: list[AmpConfig]) -> bool:\n    # retry in case panda is using the amp\n    tries = 15\n    for i in range(15):\n      try:\n        self._set_configs(configs)\n        return True\n      except OSError:\n        print(f\"Failed to set amp config, {tries - i - 1} retries left\")\n        time.sleep(0.02)\n    return False\n\n  def set_global_shutdown(self, amp_disabled: bool) -> bool:\n    return self.set_configs([self._get_shutdown_config(amp_disabled), ])\n\n  def initialize_configuration(self, model: str) -> bool:\n    cfgs = [\n      self._get_shutdown_config(True),\n      *BASE_CONFIG,\n      *CONFIGS[model],\n      self._get_shutdown_config(False),\n    ]\n    return self.set_configs(cfgs)\n\n\nif __name__ == \"__main__\":\n  with open(\"/sys/firmware/devicetree/base/model\") as f:\n    model = f.read().strip('\\x00')\n  model = model.split('comma ')[-1]\n\n  amp = Amplifier()\n  amp.initialize_configuration(model)\n", "system/hardware/tici/esim.py": "#!/usr/bin/env python3\nimport os\nimport math\nimport time\nimport binascii\nimport requests\nimport serial\nimport subprocess\n\n\ndef post(url, payload):\n  print()\n  print(\"POST to\", url)\n  r = requests.post(\n    url,\n    data=payload,\n    verify=False,\n    headers={\n      \"Content-Type\": \"application/json\",\n      \"X-Admin-Protocol\": \"gsma/rsp/v2.2.0\",\n      \"charset\": \"utf-8\",\n      \"User-Agent\": \"gsma-rsp-lpad\",\n    },\n  )\n  print(\"resp\", r)\n  print(\"resp text\", repr(r.text))\n  print()\n  r.raise_for_status()\n\n  ret = f\"HTTP/1.1 {r.status_code}\"\n  ret += ''.join(f\"{k}: {v}\" for k, v in r.headers.items() if k != 'Connection')\n  return ret.encode() + r.content\n\n\nclass LPA:\n  def __init__(self):\n    self.dev = serial.Serial('/dev/ttyUSB2', baudrate=57600, timeout=1, bytesize=8)\n    self.dev.reset_input_buffer()\n    self.dev.reset_output_buffer()\n    assert \"OK\" in self.at(\"AT\")\n\n  def at(self, cmd):\n    print(f\"==> {cmd}\")\n    self.dev.write(cmd.encode() + b'\\r\\n')\n\n    r = b\"\"\n    cnt = 0\n    while b\"OK\" not in r and b\"ERROR\" not in r and cnt < 20:\n      r += self.dev.read(8192).strip()\n      cnt += 1\n    r = r.decode()\n    print(f\"<== {repr(r)}\")\n    return r\n\n  def download_ota(self, qr):\n    return self.at(f'AT+QESIM=\"ota\",\"{qr}\"')\n\n  def download(self, qr):\n    smdp = qr.split('$')[1]\n    out = self.at(f'AT+QESIM=\"download\",\"{qr}\"')\n    for _ in range(5):\n      line = out.split(\"+QESIM: \")[1].split(\"\\r\\n\\r\\nOK\")[0]\n\n      parts = [x.strip().strip('\"') for x in line.split(',', maxsplit=4)]\n      print(repr(parts))\n      trans, ret, url, payloadlen, payload = parts\n      assert trans == \"trans\" and ret == \"0\"\n      assert len(payload) == int(payloadlen)\n\n      r = post(f\"https://{smdp}/{url}\", payload)\n      to_send = binascii.hexlify(r).decode()\n\n      chunk_len = 1400\n      for i in range(math.ceil(len(to_send) / chunk_len)):\n        state = 1 if (i+1)*chunk_len < len(to_send) else 0\n        data = to_send[i * chunk_len : (i+1)*chunk_len]\n        out = self.at(f'AT+QESIM=\"trans\",{len(to_send)},{state},{i},{len(data)},\"{data}\"')\n        assert \"OK\" in out\n\n      if '+QESIM:\"download\",1' in out:\n        raise Exception(\"profile install failed\")\n      elif '+QESIM:\"download\",0' in out:\n        print(\"done, successfully loaded\")\n        break\n\n  def enable(self, iccid):\n    self.at(f'AT+QESIM=\"enable\",\"{iccid}\"')\n\n  def disable(self, iccid):\n    self.at(f'AT+QESIM=\"disable\",\"{iccid}\"')\n\n  def delete(self, iccid):\n    self.at(f'AT+QESIM=\"delete\",\"{iccid}\"')\n\n  def list_profiles(self):\n    out = self.at('AT+QESIM=\"list\"')\n    return out.strip().splitlines()[1:]\n\n\nif __name__ == \"__main__\":\n  import sys\n\n  if \"RESTART\" in os.environ:\n    subprocess.check_call(\"sudo systemctl stop ModemManager\", shell=True)\n    subprocess.check_call(\"/usr/comma/lte/lte.sh stop_blocking\", shell=True)\n    subprocess.check_call(\"/usr/comma/lte/lte.sh start\", shell=True)\n    while not os.path.exists('/dev/ttyUSB2'):\n      time.sleep(1)\n    time.sleep(3)\n\n  lpa = LPA()\n  print(lpa.list_profiles())\n  if len(sys.argv) > 1:\n    lpa.download(sys.argv[1])\n    print(lpa.list_profiles())\n", "system/hardware/tici/__init__.py": "", "system/hardware/tici/precise_power_measure.py": "#!/usr/bin/env python3\nimport numpy as np\nfrom openpilot.system.hardware.tici.power_monitor import sample_power\n\nif __name__ == '__main__':\n  print(\"measuring for 5 seconds\")\n  for _ in range(3):\n    pwrs = sample_power()\n    print(f\"mean {np.mean(pwrs):.2f} std {np.std(pwrs):.2f}\")\n", "system/webrtc/schema.py": "import capnp\nfrom typing import Any\n\n\ndef generate_type(type_walker, schema_walker) -> str | list[Any] | dict[str, Any]:\n  data_type = next(type_walker)\n  if data_type.which() == 'struct':\n    return generate_struct(next(schema_walker))\n  elif data_type.which() == 'list':\n    _ = next(schema_walker)\n    return [generate_type(type_walker, schema_walker)]\n  elif data_type.which() == 'enum':\n    return \"text\"\n  else:\n    return str(data_type.which())\n\n\ndef generate_struct(schema: capnp.lib.capnp._StructSchema) -> dict[str, Any]:\n  return {field: generate_field(schema.fields[field]) for field in schema.fields if not field.endswith(\"DEPRECATED\")}\n\n\ndef generate_field(field: capnp.lib.capnp._StructSchemaField) -> str | list[Any] | dict[str, Any]:\n  def schema_walker(field):\n    yield field.schema\n\n    s = field.schema\n    while hasattr(s, 'elementType'):\n      s = s.elementType\n      yield s\n\n  def type_walker(field):\n    yield field.proto.slot.type\n\n    t = field.proto.slot.type\n    while hasattr(getattr(t, t.which()), 'elementType'):\n      t = getattr(t, t.which()).elementType\n      yield t\n\n  if field.proto.which() == \"slot\":\n    schema_gen, type_gen = schema_walker(field), type_walker(field)\n    return generate_type(type_gen, schema_gen)\n  else:\n    return generate_struct(field.schema)\n", "system/webrtc/__init__.py": "", "system/webrtc/webrtcd.py": "#!/usr/bin/env python3\n\nimport argparse\nimport asyncio\nimport json\nimport uuid\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Any, TYPE_CHECKING\n\n# aiortc and its dependencies have lots of internal warnings :(\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=RuntimeWarning) # TODO: remove this when google-crc32c publish a python3.12 wheel\n\nimport capnp\nfrom aiohttp import web\nif TYPE_CHECKING:\n  from aiortc.rtcdatachannel import RTCDataChannel\n\nfrom openpilot.system.webrtc.schema import generate_field\nfrom cereal import messaging, log\n\n\nclass CerealOutgoingMessageProxy:\n  def __init__(self, sm: messaging.SubMaster):\n    self.sm = sm\n    self.channels: list[RTCDataChannel] = []\n\n  def add_channel(self, channel: 'RTCDataChannel'):\n    self.channels.append(channel)\n\n  def to_json(self, msg_content: Any):\n    if isinstance(msg_content, capnp._DynamicStructReader):\n      msg_dict = msg_content.to_dict()\n    elif isinstance(msg_content, capnp._DynamicListReader):\n      msg_dict = [self.to_json(msg) for msg in msg_content]\n    elif isinstance(msg_content, bytes):\n      msg_dict = msg_content.decode()\n    else:\n      msg_dict = msg_content\n\n    return msg_dict\n\n  def update(self):\n    # this is blocking in async context...\n    self.sm.update(0)\n    for service, updated in self.sm.updated.items():\n      if not updated:\n        continue\n      msg_dict = self.to_json(self.sm[service])\n      mono_time, valid = self.sm.logMonoTime[service], self.sm.valid[service]\n      outgoing_msg = {\"type\": service, \"logMonoTime\": mono_time, \"valid\": valid, \"data\": msg_dict}\n      encoded_msg = json.dumps(outgoing_msg).encode()\n      for channel in self.channels:\n        channel.send(encoded_msg)\n\n\nclass CerealIncomingMessageProxy:\n  def __init__(self, pm: messaging.PubMaster):\n    self.pm = pm\n\n  def send(self, message: bytes):\n    msg_json = json.loads(message)\n    msg_type, msg_data = msg_json[\"type\"], msg_json[\"data\"]\n    size = None\n    if not isinstance(msg_data, dict):\n      size = len(msg_data)\n\n    msg = messaging.new_message(msg_type, size=size)\n    setattr(msg, msg_type, msg_data)\n    self.pm.send(msg_type, msg)\n\n\nclass CerealProxyRunner:\n  def __init__(self, proxy: CerealOutgoingMessageProxy):\n    self.proxy = proxy\n    self.is_running = False\n    self.task = None\n    self.logger = logging.getLogger(\"webrtcd\")\n\n  def start(self):\n    assert self.task is None\n    self.task = asyncio.create_task(self.run())\n\n  def stop(self):\n    if self.task is None or self.task.done():\n      return\n    self.task.cancel()\n    self.task = None\n\n  async def run(self):\n    from aiortc.exceptions import InvalidStateError\n\n    while True:\n      try:\n        self.proxy.update()\n      except InvalidStateError:\n        self.logger.warning(\"Cereal outgoing proxy invalid state (connection closed)\")\n        break\n      except Exception:\n        self.logger.exception(\"Cereal outgoing proxy failure\")\n      await asyncio.sleep(0.01)\n\n\nclass DynamicPubMaster(messaging.PubMaster):\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.lock = asyncio.Lock()\n\n  async def add_services_if_needed(self, services):\n    async with self.lock:\n      for service in services:\n        if service not in self.sock:\n          self.sock[service] = messaging.pub_sock(service)\n\n\nclass StreamSession:\n  shared_pub_master = DynamicPubMaster([])\n\n  def __init__(self, sdp: str, cameras: list[str], incoming_services: list[str], outgoing_services: list[str], debug_mode: bool = False):\n    from aiortc.mediastreams import VideoStreamTrack, AudioStreamTrack\n    from aiortc.contrib.media import MediaBlackhole\n    from openpilot.system.webrtc.device.video import LiveStreamVideoStreamTrack\n    from openpilot.system.webrtc.device.audio import AudioInputStreamTrack, AudioOutputSpeaker\n    from teleoprtc import WebRTCAnswerBuilder\n    from teleoprtc.info import parse_info_from_offer\n\n    config = parse_info_from_offer(sdp)\n    builder = WebRTCAnswerBuilder(sdp)\n\n    assert len(cameras) == config.n_expected_camera_tracks, \"Incoming stream has misconfigured number of video tracks\"\n    for cam in cameras:\n      track = LiveStreamVideoStreamTrack(cam) if not debug_mode else VideoStreamTrack()\n      builder.add_video_stream(cam, track)\n    if config.expected_audio_track:\n      track = AudioInputStreamTrack() if not debug_mode else AudioStreamTrack()\n      builder.add_audio_stream(track)\n    if config.incoming_audio_track:\n      self.audio_output_cls = AudioOutputSpeaker if not debug_mode else MediaBlackhole\n      builder.offer_to_receive_audio_stream()\n\n    self.stream = builder.stream()\n    self.identifier = str(uuid.uuid4())\n\n    self.incoming_bridge: CerealIncomingMessageProxy | None = None\n    self.incoming_bridge_services = incoming_services\n    self.outgoing_bridge: CerealOutgoingMessageProxy | None = None\n    self.outgoing_bridge_runner: CerealProxyRunner | None = None\n    if len(incoming_services) > 0:\n      self.incoming_bridge = CerealIncomingMessageProxy(self.shared_pub_master)\n    if len(outgoing_services) > 0:\n      self.outgoing_bridge = CerealOutgoingMessageProxy(messaging.SubMaster(outgoing_services))\n      self.outgoing_bridge_runner = CerealProxyRunner(self.outgoing_bridge)\n\n    self.audio_output: AudioOutputSpeaker | MediaBlackhole | None = None\n    self.run_task: asyncio.Task | None = None\n    self.logger = logging.getLogger(\"webrtcd\")\n    self.logger.info(\"New stream session (%s), cameras %s, audio in %s out %s, incoming services %s, outgoing services %s\",\n                      self.identifier, cameras, config.incoming_audio_track, config.expected_audio_track, incoming_services, outgoing_services)\n\n  def start(self):\n    self.run_task = asyncio.create_task(self.run())\n\n  def stop(self):\n    if self.run_task.done():\n      return\n    self.run_task.cancel()\n    self.run_task = None\n    asyncio.run(self.post_run_cleanup())\n\n  async def get_answer(self):\n    return await self.stream.start()\n\n  async def message_handler(self, message: bytes):\n    assert self.incoming_bridge is not None\n    try:\n      self.incoming_bridge.send(message)\n    except Exception:\n      self.logger.exception(\"Cereal incoming proxy failure\")\n\n  async def run(self):\n    try:\n      await self.stream.wait_for_connection()\n      if self.stream.has_messaging_channel():\n        if self.incoming_bridge is not None:\n          await self.shared_pub_master.add_services_if_needed(self.incoming_bridge_services)\n          self.stream.set_message_handler(self.message_handler)\n        if self.outgoing_bridge_runner is not None:\n          channel = self.stream.get_messaging_channel()\n          self.outgoing_bridge_runner.proxy.add_channel(channel)\n          self.outgoing_bridge_runner.start()\n      if self.stream.has_incoming_audio_track():\n        track = self.stream.get_incoming_audio_track(buffered=False)\n        self.audio_output = self.audio_output_cls()\n        self.audio_output.addTrack(track)\n        self.audio_output.start()\n      self.logger.info(\"Stream session (%s) connected\", self.identifier)\n\n      await self.stream.wait_for_disconnection()\n      await self.post_run_cleanup()\n\n      self.logger.info(\"Stream session (%s) ended\", self.identifier)\n    except Exception:\n      self.logger.exception(\"Stream session failure\")\n\n  async def post_run_cleanup(self):\n    await self.stream.stop()\n    if self.outgoing_bridge is not None:\n      self.outgoing_bridge_runner.stop()\n    if self.audio_output:\n      self.audio_output.stop()\n\n\n@dataclass\nclass StreamRequestBody:\n  sdp: str\n  cameras: list[str]\n  bridge_services_in: list[str] = field(default_factory=list)\n  bridge_services_out: list[str] = field(default_factory=list)\n\n\nasync def get_stream(request: 'web.Request'):\n  stream_dict, debug_mode = request.app['streams'], request.app['debug']\n  raw_body = await request.json()\n  body = StreamRequestBody(**raw_body)\n\n  session = StreamSession(body.sdp, body.cameras, body.bridge_services_in, body.bridge_services_out, debug_mode)\n  answer = await session.get_answer()\n  session.start()\n\n  stream_dict[session.identifier] = session\n\n  return web.json_response({\"sdp\": answer.sdp, \"type\": answer.type})\n\n\nasync def get_schema(request: 'web.Request'):\n  services = request.query[\"services\"].split(\",\")\n  services = [s for s in services if s]\n  assert all(s in log.Event.schema.fields and not s.endswith(\"DEPRECATED\") for s in services), \"Invalid service name\"\n  schema_dict = {s: generate_field(log.Event.schema.fields[s]) for s in services}\n  return web.json_response(schema_dict)\n\n\nasync def on_shutdown(app: 'web.Application'):\n  for session in app['streams'].values():\n    session.stop()\n  del app['streams']\n\n\ndef webrtcd_thread(host: str, port: int, debug: bool):\n  logging.basicConfig(level=logging.CRITICAL, handlers=[logging.StreamHandler()])\n  logging_level = logging.DEBUG if debug else logging.INFO\n  logging.getLogger(\"WebRTCStream\").setLevel(logging_level)\n  logging.getLogger(\"webrtcd\").setLevel(logging_level)\n\n  app = web.Application()\n\n  app['streams'] = dict()\n  app['debug'] = debug\n  app.on_shutdown.append(on_shutdown)\n  app.router.add_post(\"/stream\", get_stream)\n  app.router.add_get(\"/schema\", get_schema)\n\n  web.run_app(app, host=host, port=port)\n\n\ndef main():\n  parser = argparse.ArgumentParser(description=\"WebRTC daemon\")\n  parser.add_argument(\"--host\", type=str, default=\"0.0.0.0\", help=\"Host to listen on\")\n  parser.add_argument(\"--port\", type=int, default=5001, help=\"Port to listen on\")\n  parser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable debug mode\")\n  args = parser.parse_args()\n\n  webrtcd_thread(args.host, args.port, args.debug)\n\n\nif __name__==\"__main__\":\n  main()\n", "system/webrtc/device/video.py": "import asyncio\n\nimport av\nfrom teleoprtc.tracks import TiciVideoStreamTrack\n\nfrom cereal import messaging\nfrom openpilot.common.realtime import DT_MDL, DT_DMON\n\n\nclass LiveStreamVideoStreamTrack(TiciVideoStreamTrack):\n  camera_to_sock_mapping = {\n    \"driver\": \"livestreamDriverEncodeData\",\n    \"wideRoad\": \"livestreamWideRoadEncodeData\",\n    \"road\": \"livestreamRoadEncodeData\",\n  }\n\n  def __init__(self, camera_type: str):\n    dt = DT_DMON if camera_type == \"driver\" else DT_MDL\n    super().__init__(camera_type, dt)\n\n    self._sock = messaging.sub_sock(self.camera_to_sock_mapping[camera_type], conflate=True)\n    self._pts = 0\n\n  async def recv(self):\n    while True:\n      msg = messaging.recv_one_or_none(self._sock)\n      if msg is not None:\n        break\n      await asyncio.sleep(0.005)\n\n    evta = getattr(msg, msg.which())\n\n    packet = av.Packet(evta.header + evta.data)\n    packet.time_base = self._time_base\n    packet.pts = self._pts\n\n    self.log_debug(\"track sending frame %s\", self._pts)\n    self._pts += self._dt * self._clock_rate\n\n    return packet\n\n  def codec_preference(self) -> str | None:\n    return \"H264\"\n", "system/webrtc/device/audio.py": "import asyncio\nimport io\n\nimport aiortc\nimport av\nimport numpy as np\nimport pyaudio\n\n\nclass AudioInputStreamTrack(aiortc.mediastreams.AudioStreamTrack):\n  PYAUDIO_TO_AV_FORMAT_MAP = {\n      pyaudio.paUInt8: 'u8',\n      pyaudio.paInt16: 's16',\n      pyaudio.paInt24: 's24',\n      pyaudio.paInt32: 's32',\n      pyaudio.paFloat32: 'flt',\n  }\n\n  def __init__(self, audio_format: int = pyaudio.paInt16, rate: int = 16000, channels: int = 1, packet_time: float = 0.020, device_index: int = None):\n    super().__init__()\n\n    self.p = pyaudio.PyAudio()\n    chunk_size = int(packet_time * rate)\n    self.stream = self.p.open(format=audio_format,\n                              channels=channels,\n                              rate=rate,\n                              frames_per_buffer=chunk_size,\n                              input=True,\n                              input_device_index=device_index)\n    self.format = audio_format\n    self.rate = rate\n    self.channels = channels\n    self.packet_time = packet_time\n    self.chunk_size = chunk_size\n    self.pts = 0\n\n  async def recv(self):\n    mic_data = self.stream.read(self.chunk_size)\n    mic_array = np.frombuffer(mic_data, dtype=np.int16)\n    mic_array = np.expand_dims(mic_array, axis=0)\n    layout = 'stereo' if self.channels > 1 else 'mono'\n    frame = av.AudioFrame.from_ndarray(mic_array, format=self.PYAUDIO_TO_AV_FORMAT_MAP[self.format], layout=layout)\n    frame.rate = self.rate\n    frame.pts = self.pts\n    self.pts += frame.samples\n\n    return frame\n\n\nclass AudioOutputSpeaker:\n  def __init__(self, audio_format: int = pyaudio.paInt16, rate: int = 48000, channels: int = 2, packet_time: float = 0.2, device_index: int = None):\n\n    chunk_size = int(packet_time * rate)\n    self.p = pyaudio.PyAudio()\n    self.buffer = io.BytesIO()\n    self.channels = channels\n    self.stream = self.p.open(format=audio_format,\n                              channels=channels,\n                              rate=rate,\n                              frames_per_buffer=chunk_size,\n                              output=True,\n                              output_device_index=device_index,\n                              stream_callback=self.__pyaudio_callback)\n    self.tracks_and_tasks: list[tuple[aiortc.MediaStreamTrack, asyncio.Task | None]] = []\n\n  def __pyaudio_callback(self, in_data, frame_count, time_info, status):\n    if self.buffer.getbuffer().nbytes < frame_count * self.channels * 2:\n      buff = b'\\x00\\x00' * frame_count * self.channels\n    elif self.buffer.getbuffer().nbytes > 115200:  # 3x the usual read size\n      self.buffer.seek(0)\n      buff = self.buffer.read(frame_count * self.channels * 4)\n      buff = buff[:frame_count * self.channels * 2]\n      self.buffer.seek(2)\n    else:\n      self.buffer.seek(0)\n      buff = self.buffer.read(frame_count * self.channels * 2)\n      self.buffer.seek(2)\n    return (buff, pyaudio.paContinue)\n\n  async def __consume(self, track):\n    while True:\n      try:\n        frame = await track.recv()\n      except aiortc.MediaStreamError:\n        return\n\n      self.buffer.write(bytes(frame.planes[0]))\n\n  def hasTrack(self, track: aiortc.MediaStreamTrack) -> bool:\n    return any(t == track for t, _ in self.tracks_and_tasks)\n\n  def addTrack(self, track: aiortc.MediaStreamTrack):\n    if not self.hasTrack(track):\n      self.tracks_and_tasks.append((track, None))\n\n  def start(self):\n    for index, (track, task) in enumerate(self.tracks_and_tasks):\n      if task is None:\n        self.tracks_and_tasks[index] = (track, asyncio.create_task(self.__consume(track)))\n\n  def stop(self):\n    for _, task in self.tracks_and_tasks:\n      if task is not None:\n        task.cancel()\n\n    self.tracks_and_tasks = []\n    self.stream.stop_stream()\n    self.stream.close()\n    self.p.terminate()\n", "system/loggerd/config.py": "import os\nfrom openpilot.system.hardware.hw import Paths\n\n\nCAMERA_FPS = 20\nSEGMENT_LENGTH = 60\n\nSTATS_DIR_FILE_LIMIT = 10000\nSTATS_SOCKET = \"ipc:///tmp/stats\"\nSTATS_FLUSH_TIME_S = 60\n\ndef get_available_percent(default=None):\n  try:\n    statvfs = os.statvfs(Paths.log_root())\n    available_percent = 100.0 * statvfs.f_bavail / statvfs.f_blocks\n  except OSError:\n    available_percent = default\n\n  return available_percent\n\n\ndef get_available_bytes(default=None):\n  try:\n    statvfs = os.statvfs(Paths.log_root())\n    available_bytes = statvfs.f_bavail * statvfs.f_frsize\n  except OSError:\n    available_bytes = default\n\n  return available_bytes\n", "system/loggerd/deleter.py": "#!/usr/bin/env python3\nimport os\nimport shutil\nimport threading\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.loggerd.config import get_available_bytes, get_available_percent\nfrom openpilot.system.loggerd.uploader import listdir_by_creation\nfrom openpilot.system.loggerd.xattr_cache import getxattr\n\nMIN_BYTES = 5 * 1024 * 1024 * 1024\nMIN_PERCENT = 10\n\nDELETE_LAST = ['boot', 'crash']\n\nPRESERVE_ATTR_NAME = 'user.preserve'\nPRESERVE_ATTR_VALUE = b'1'\nPRESERVE_COUNT = 5\n\n\ndef has_preserve_xattr(d: str) -> bool:\n  return getxattr(os.path.join(Paths.log_root(), d), PRESERVE_ATTR_NAME) == PRESERVE_ATTR_VALUE\n\n\ndef get_preserved_segments(dirs_by_creation: list[str]) -> list[str]:\n  preserved = []\n  for n, d in enumerate(filter(has_preserve_xattr, reversed(dirs_by_creation))):\n    if n == PRESERVE_COUNT:\n      break\n    date_str, _, seg_str = d.rpartition(\"--\")\n\n    # ignore non-segment directories\n    if not date_str:\n      continue\n    try:\n      seg_num = int(seg_str)\n    except ValueError:\n      continue\n\n    # preserve segment and two prior\n    for _seg_num in range(max(0, seg_num - 2), seg_num + 1):\n      preserved.append(f\"{date_str}--{_seg_num}\")\n\n  return preserved\n\n\ndef deleter_thread(exit_event):\n  while not exit_event.is_set():\n    out_of_bytes = get_available_bytes(default=MIN_BYTES + 1) < MIN_BYTES\n    out_of_percent = get_available_percent(default=MIN_PERCENT + 1) < MIN_PERCENT\n\n    if out_of_percent or out_of_bytes:\n      dirs = listdir_by_creation(Paths.log_root())\n\n      # skip deleting most recent N preserved segments (and their prior segment)\n      preserved_dirs = get_preserved_segments(dirs)\n\n      # remove the earliest directory we can\n      for delete_dir in sorted(dirs, key=lambda d: (d in DELETE_LAST, d in preserved_dirs)):\n        delete_path = os.path.join(Paths.log_root(), delete_dir)\n\n        if any(name.endswith(\".lock\") for name in os.listdir(delete_path)):\n          continue\n\n        try:\n          cloudlog.info(f\"deleting {delete_path}\")\n          if os.path.isfile(delete_path):\n            os.remove(delete_path)\n          else:\n            shutil.rmtree(delete_path)\n          break\n        except OSError:\n          cloudlog.exception(f\"issue deleting {delete_path}\")\n      exit_event.wait(.1)\n    else:\n      exit_event.wait(30)\n\n\ndef main():\n  deleter_thread(threading.Event())\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/loggerd/uploader.py": "#!/usr/bin/env python3\nimport bz2\nimport io\nimport json\nimport os\nimport random\nimport requests\nimport threading\nimport time\nimport traceback\nimport datetime\nfrom typing import BinaryIO\nfrom collections.abc import Iterator\n\nfrom cereal import log\nimport cereal.messaging as messaging\nfrom openpilot.common.api import Api\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import set_core_affinity\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.system.loggerd.xattr_cache import getxattr, setxattr\nfrom openpilot.common.swaglog import cloudlog\n\nNetworkType = log.DeviceState.NetworkType\nUPLOAD_ATTR_NAME = 'user.upload'\nUPLOAD_ATTR_VALUE = b'1'\n\nUPLOAD_QLOG_QCAM_MAX_SIZE = 5 * 1e6  # MB\n\nallow_sleep = bool(os.getenv(\"UPLOADER_SLEEP\", \"1\"))\nforce_wifi = os.getenv(\"FORCEWIFI\") is not None\nfake_upload = os.getenv(\"FAKEUPLOAD\") is not None\n\n\nclass FakeRequest:\n  def __init__(self):\n    self.headers = {\"Content-Length\": \"0\"}\n\n\nclass FakeResponse:\n  def __init__(self):\n    self.status_code = 200\n    self.request = FakeRequest()\n\n\ndef get_directory_sort(d: str) -> list[str]:\n  # ensure old format is sorted sooner\n  o = [\"0\", ] if d.startswith(\"2024-\") else [\"1\", ]\n  return o + [s.rjust(10, '0') for s in d.rsplit('--', 1)]\n\ndef listdir_by_creation(d: str) -> list[str]:\n  if not os.path.isdir(d):\n    return []\n\n  try:\n    paths = [f for f in os.listdir(d) if os.path.isdir(os.path.join(d, f))]\n    paths = sorted(paths, key=get_directory_sort)\n    return paths\n  except OSError:\n    cloudlog.exception(\"listdir_by_creation failed\")\n    return []\n\ndef clear_locks(root: str) -> None:\n  for logdir in os.listdir(root):\n    path = os.path.join(root, logdir)\n    try:\n      for fname in os.listdir(path):\n        if fname.endswith(\".lock\"):\n          os.unlink(os.path.join(path, fname))\n    except OSError:\n      cloudlog.exception(\"clear_locks failed\")\n\n\nclass Uploader:\n  def __init__(self, dongle_id: str, root: str):\n    self.dongle_id = dongle_id\n    self.api = Api(dongle_id)\n    self.root = root\n\n    self.params = Params()\n\n    # stats for last successfully uploaded file\n    self.last_filename = \"\"\n\n    self.immediate_folders = [\"crash/\", \"boot/\"]\n    self.immediate_priority = {\"qlog\": 0, \"qlog.bz2\": 0, \"qcamera.ts\": 1}\n\n  def list_upload_files(self, metered: bool) -> Iterator[tuple[str, str, str]]:\n    r = self.params.get(\"AthenadRecentlyViewedRoutes\", encoding=\"utf8\")\n    requested_routes = [] if r is None else r.split(\",\")\n\n    for logdir in listdir_by_creation(self.root):\n      path = os.path.join(self.root, logdir)\n      try:\n        names = os.listdir(path)\n      except OSError:\n        continue\n\n      if any(name.endswith(\".lock\") for name in names):\n        continue\n\n      for name in sorted(names, key=lambda n: self.immediate_priority.get(n, 1000)):\n        key = os.path.join(logdir, name)\n        fn = os.path.join(path, name)\n        # skip files already uploaded\n        try:\n          ctime = os.path.getctime(fn)\n          is_uploaded = getxattr(fn, UPLOAD_ATTR_NAME) == UPLOAD_ATTR_VALUE\n        except OSError:\n          cloudlog.event(\"uploader_getxattr_failed\", key=key, fn=fn)\n          # deleter could have deleted, so skip\n          continue\n        if is_uploaded:\n          continue\n\n        # limit uploading on metered connections\n        if metered:\n          dt = datetime.timedelta(hours=12)\n          if logdir in self.immediate_folders and (datetime.datetime.now() - datetime.datetime.fromtimestamp(ctime)) < dt:\n            continue\n\n          if name == \"qcamera.ts\" and not any(logdir.startswith(r.split('|')[-1]) for r in requested_routes):\n            continue\n\n        yield name, key, fn\n\n  def next_file_to_upload(self, metered: bool) -> tuple[str, str, str] | None:\n    upload_files = list(self.list_upload_files(metered))\n\n    for name, key, fn in upload_files:\n      if any(f in fn for f in self.immediate_folders):\n        return name, key, fn\n\n    for name, key, fn in upload_files:\n      if name in self.immediate_priority:\n        return name, key, fn\n\n    return None\n\n  def do_upload(self, key: str, fn: str):\n    url_resp = self.api.get(\"v1.4/\" + self.dongle_id + \"/upload_url/\", timeout=10, path=key, access_token=self.api.get_token())\n    if url_resp.status_code == 412:\n      return url_resp\n\n    url_resp_json = json.loads(url_resp.text)\n    url = url_resp_json['url']\n    headers = url_resp_json['headers']\n    cloudlog.debug(\"upload_url v1.4 %s %s\", url, str(headers))\n\n    if fake_upload:\n      return FakeResponse()\n\n    with open(fn, \"rb\") as f:\n      data: BinaryIO\n      if key.endswith('.bz2') and not fn.endswith('.bz2'):\n        compressed = bz2.compress(f.read())\n        data = io.BytesIO(compressed)\n      else:\n        data = f\n\n      return requests.put(url, data=data, headers=headers, timeout=10)\n\n  def upload(self, name: str, key: str, fn: str, network_type: int, metered: bool) -> bool:\n    try:\n      sz = os.path.getsize(fn)\n    except OSError:\n      cloudlog.exception(\"upload: getsize failed\")\n      return False\n\n    cloudlog.event(\"upload_start\", key=key, fn=fn, sz=sz, network_type=network_type, metered=metered)\n\n    if sz == 0:\n      # tag files of 0 size as uploaded\n      success = True\n    elif name in self.immediate_priority and sz > UPLOAD_QLOG_QCAM_MAX_SIZE:\n      cloudlog.event(\"uploader_too_large\", key=key, fn=fn, sz=sz)\n      success = True\n    else:\n      start_time = time.monotonic()\n\n      stat = None\n      last_exc = None\n      try:\n        stat = self.do_upload(key, fn)\n      except Exception as e:\n        last_exc = (e, traceback.format_exc())\n\n      if stat is not None and stat.status_code in (200, 201, 401, 403, 412):\n        self.last_filename = fn\n        dt = time.monotonic() - start_time\n        if stat.status_code == 412:\n          cloudlog.event(\"upload_ignored\", key=key, fn=fn, sz=sz, network_type=network_type, metered=metered)\n        else:\n          content_length = int(stat.request.headers.get(\"Content-Length\", 0))\n          speed = (content_length / 1e6) / dt\n          cloudlog.event(\"upload_success\", key=key, fn=fn, sz=sz, content_length=content_length,\n                         network_type=network_type, metered=metered, speed=speed)\n        success = True\n      else:\n        success = False\n        cloudlog.event(\"upload_failed\", stat=stat, exc=last_exc, key=key, fn=fn, sz=sz, network_type=network_type, metered=metered)\n\n    if success:\n      # tag file as uploaded\n      try:\n        setxattr(fn, UPLOAD_ATTR_NAME, UPLOAD_ATTR_VALUE)\n      except OSError:\n        cloudlog.event(\"uploader_setxattr_failed\", exc=last_exc, key=key, fn=fn, sz=sz)\n\n    return success\n\n\n  def step(self, network_type: int, metered: bool) -> bool | None:\n    d = self.next_file_to_upload(metered)\n    if d is None:\n      return None\n\n    name, key, fn = d\n\n    # qlogs and bootlogs need to be compressed before uploading\n    if key.endswith(('qlog', 'rlog')) or (key.startswith('boot/') and not key.endswith('.bz2')):\n      key += \".bz2\"\n\n    return self.upload(name, key, fn, network_type, metered)\n\n\ndef main(exit_event: threading.Event = None) -> None:\n  if exit_event is None:\n    exit_event = threading.Event()\n\n  try:\n    set_core_affinity([0, 1, 2, 3])\n  except Exception:\n    cloudlog.exception(\"failed to set core affinity\")\n\n  clear_locks(Paths.log_root())\n\n  params = Params()\n  dongle_id = params.get(\"DongleId\", encoding='utf8')\n\n  if dongle_id is None:\n    cloudlog.info(\"uploader missing dongle_id\")\n    raise Exception(\"uploader can't start without dongle id\")\n\n  sm = messaging.SubMaster(['deviceState'])\n  uploader = Uploader(dongle_id, Paths.log_root())\n\n  backoff = 0.1\n  while not exit_event.is_set():\n    sm.update(0)\n    offroad = params.get_bool(\"IsOffroad\")\n    network_type = sm['deviceState'].networkType if not force_wifi else NetworkType.wifi\n    if network_type == NetworkType.none:\n      if allow_sleep:\n        time.sleep(60 if offroad else 5)\n      continue\n\n    success = uploader.step(sm['deviceState'].networkType.raw, sm['deviceState'].networkMetered)\n    if success is None:\n      backoff = 60 if offroad else 5\n    elif success:\n      backoff = 0.1\n    else:\n      cloudlog.info(\"upload backoff %r\", backoff)\n      backoff = min(backoff*2, 120)\n    if allow_sleep:\n      time.sleep(backoff + random.uniform(0, backoff))\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/loggerd/xattr_cache.py": "import os\nimport errno\n\n_cached_attributes: dict[tuple, bytes | None] = {}\n\ndef getxattr(path: str, attr_name: str) -> bytes | None:\n  key = (path, attr_name)\n  if key not in _cached_attributes:\n    try:\n      response = os.getxattr(path, attr_name)\n    except OSError as e:\n      # ENODATA means attribute hasn't been set\n      if e.errno == errno.ENODATA:\n        response = None\n      else:\n        raise\n    _cached_attributes[key] = response\n  return _cached_attributes[key]\n\ndef setxattr(path: str, attr_name: str, attr_value: bytes) -> None:\n  _cached_attributes.pop((path, attr_name), None)\n  return os.setxattr(path, attr_name, attr_value)\n", "system/loggerd/__init__.py": "", "system/ubloxd/pigeond.py": "#!/usr/bin/env python3\nimport sys\nimport time\nimport signal\nimport serial\nimport struct\nimport requests\nimport urllib.parse\nfrom datetime import datetime, UTC\n\nfrom cereal import messaging\nfrom openpilot.common.params import Params\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.hardware import TICI\nfrom openpilot.common.gpio import gpio_init, gpio_set\nfrom openpilot.system.hardware.tici.pins import GPIO\n\nUBLOX_TTY = \"/dev/ttyHS0\"\n\nUBLOX_ACK = b\"\\xb5\\x62\\x05\\x01\\x02\\x00\"\nUBLOX_NACK = b\"\\xb5\\x62\\x05\\x00\\x02\\x00\"\nUBLOX_SOS_ACK = b\"\\xb5\\x62\\x09\\x14\\x08\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\"\nUBLOX_SOS_NACK = b\"\\xb5\\x62\\x09\\x14\\x08\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\nUBLOX_BACKUP_RESTORE_MSG = b\"\\xb5\\x62\\x09\\x14\\x08\\x00\\x03\"\nUBLOX_ASSIST_ACK = b\"\\xb5\\x62\\x13\\x60\\x08\\x00\"\n\ndef set_power(enabled: bool) -> None:\n  gpio_init(GPIO.UBLOX_SAFEBOOT_N, True)\n  gpio_init(GPIO.GNSS_PWR_EN, True)\n  gpio_init(GPIO.UBLOX_RST_N, True)\n\n  gpio_set(GPIO.UBLOX_SAFEBOOT_N, True)\n  gpio_set(GPIO.GNSS_PWR_EN, enabled)\n  gpio_set(GPIO.UBLOX_RST_N, enabled)\n\ndef add_ubx_checksum(msg: bytes) -> bytes:\n  A = B = 0\n  for b in msg[2:]:\n    A = (A + b) % 256\n    B = (B + A) % 256\n  return msg + bytes([A, B])\n\ndef get_assistnow_messages(token: bytes) -> list[bytes]:\n  # make request\n  # TODO: implement adding the last known location\n  r = requests.get(\"https://online-live2.services.u-blox.com/GetOnlineData.ashx\", params=urllib.parse.urlencode({\n    'token': token,\n    'gnss': 'gps,glo',\n    'datatype': 'eph,alm,aux',\n  }, safe=':,'), timeout=5)\n  assert r.status_code == 200, \"Got invalid status code\"\n  dat = r.content\n\n  # split up messages\n  msgs = []\n  while len(dat) > 0:\n    assert dat[:2] == b\"\\xB5\\x62\"\n    msg_len = 6 + (dat[5] << 8 | dat[4]) + 2\n    msgs.append(dat[:msg_len])\n    dat = dat[msg_len:]\n  return msgs\n\n\nclass TTYPigeon:\n  def __init__(self):\n    self.tty = serial.VTIMESerial(UBLOX_TTY, baudrate=9600, timeout=0)\n\n  def send(self, dat: bytes) -> None:\n    self.tty.write(dat)\n\n  def receive(self) -> bytes:\n    dat = b''\n    while len(dat) < 0x1000:\n      d = self.tty.read(0x40)\n      dat += d\n      if len(d) == 0:\n        break\n    return dat\n\n  def set_baud(self, baud: int) -> None:\n    self.tty.baudrate = baud\n\n  def wait_for_ack(self, ack: bytes = UBLOX_ACK, nack: bytes = UBLOX_NACK, timeout: float = 0.5) -> bool:\n    dat = b''\n    st = time.monotonic()\n    while True:\n      dat += self.receive()\n      if ack in dat:\n        cloudlog.debug(\"Received ACK from ublox\")\n        return True\n      elif nack in dat:\n        cloudlog.error(\"Received NACK from ublox\")\n        return False\n      elif time.monotonic() - st > timeout:\n        cloudlog.error(\"No response from ublox\")\n        raise TimeoutError('No response from ublox')\n      time.sleep(0.001)\n\n  def send_with_ack(self, dat: bytes, ack: bytes = UBLOX_ACK, nack: bytes = UBLOX_NACK) -> None:\n    self.send(dat)\n    self.wait_for_ack(ack, nack)\n\n  def wait_for_backup_restore_status(self, timeout: float = 1.) -> int:\n    dat = b''\n    st = time.monotonic()\n    while True:\n      dat += self.receive()\n      position = dat.find(UBLOX_BACKUP_RESTORE_MSG)\n      if position >= 0 and len(dat) >= position + 11:\n        return dat[position + 10]\n      elif time.monotonic() - st > timeout:\n        cloudlog.error(\"No backup restore response from ublox\")\n        raise TimeoutError('No response from ublox')\n      time.sleep(0.001)\n\n  def reset_device(self) -> bool:\n    # deleting the backup does not always work on first try (mostly on second try)\n    for _ in range(5):\n      # device cold start\n      self.send(b\"\\xb5\\x62\\x06\\x04\\x04\\x00\\xff\\xff\\x00\\x00\\x0c\\x5d\")\n      time.sleep(1) # wait for cold start\n      init_baudrate(self)\n\n      # clear configuration\n      self.send_with_ack(b\"\\xb5\\x62\\x06\\x09\\x0d\\x00\\x1f\\x1f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x17\\x71\\xd7\")\n\n      # clear flash memory (almanac backup)\n      self.send_with_ack(b\"\\xB5\\x62\\x09\\x14\\x04\\x00\\x01\\x00\\x00\\x00\\x22\\xf0\")\n\n      # try restoring backup to verify it got deleted\n      self.send(b\"\\xB5\\x62\\x09\\x14\\x00\\x00\\x1D\\x60\")\n      # 1: failed to restore, 2: could restore, 3: no backup\n      status = self.wait_for_backup_restore_status()\n      if status == 1 or status == 3:\n        return True\n    return False\n\ndef init_baudrate(pigeon: TTYPigeon):\n  # ublox default setting on startup is 9600 baudrate\n  pigeon.set_baud(9600)\n\n  # $PUBX,41,1,0007,0003,460800,0*15\\r\\n\n  pigeon.send(b\"\\x24\\x50\\x55\\x42\\x58\\x2C\\x34\\x31\\x2C\\x31\\x2C\\x30\\x30\\x30\\x37\\x2C\\x30\\x30\\x30\\x33\\x2C\\x34\\x36\\x30\\x38\\x30\\x30\\x2C\\x30\\x2A\\x31\\x35\\x0D\\x0A\")\n  time.sleep(0.1)\n  pigeon.set_baud(460800)\n\n\ndef initialize_pigeon(pigeon: TTYPigeon) -> bool:\n  # try initializing a few times\n  for _ in range(10):\n    try:\n\n      # setup port config\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x14\\x00\\x03\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x1E\\x7F\")\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x14\\x00\\x00\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x19\\x35\")\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x14\\x00\\x01\\x00\\x00\\x00\\xC0\\x08\\x00\\x00\\x00\\x08\\x07\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\xF4\\x80\")\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x14\\x00\\x04\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1D\\x85\")\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x00\\x00\\x06\\x18\")\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x01\\x00\\x01\\x08\\x22\")\n      pigeon.send_with_ack(b\"\\xb5\\x62\\x06\\x00\\x01\\x00\\x03\\x0A\\x24\")\n\n      # UBX-CFG-RATE (0x06 0x08)\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x08\\x06\\x00\\x64\\x00\\x01\\x00\\x00\\x00\\x79\\x10\")\n\n      # UBX-CFG-NAV5 (0x06 0x24)\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x24\\x24\\x00\\x05\\x00\\x04\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x5A\\x63\")\n\n      # UBX-CFG-ODO (0x06 0x1E)\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x1E\\x14\\x00\\x00\\x00\\x00\\x00\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3C\\x37\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x39\\x08\\x00\\xFF\\xAD\\x62\\xAD\\x1E\\x63\\x00\\x00\\x83\\x0C\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x23\\x28\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x56\\x24\")\n\n      # UBX-CFG-NAV5 (0x06 0x24)\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x24\\x00\\x00\\x2A\\x84\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x23\\x00\\x00\\x29\\x81\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x1E\\x00\\x00\\x24\\x72\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x39\\x00\\x00\\x3F\\xC3\")\n\n      # UBX-CFG-MSG (set message rate)\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x01\\x03\\x00\\x01\\x07\\x01\\x13\\x51\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x01\\x03\\x00\\x02\\x15\\x01\\x22\\x70\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x01\\x03\\x00\\x02\\x13\\x01\\x20\\x6C\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x01\\x03\\x00\\x0A\\x09\\x01\\x1E\\x70\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x01\\x03\\x00\\x0A\\x0B\\x01\\x20\\x74\")\n      pigeon.send_with_ack(b\"\\xB5\\x62\\x06\\x01\\x03\\x00\\x01\\x35\\x01\\x41\\xAD\")\n      cloudlog.debug(\"pigeon configured\")\n\n      # try restoring almanac backup\n      pigeon.send(b\"\\xB5\\x62\\x09\\x14\\x00\\x00\\x1D\\x60\")\n      restore_status = pigeon.wait_for_backup_restore_status()\n      if restore_status == 2:\n        cloudlog.warning(\"almanac backup restored\")\n      elif restore_status == 3:\n        cloudlog.warning(\"no almanac backup found\")\n      else:\n        cloudlog.error(f\"failed to restore almanac backup, status: {restore_status}\")\n\n      # sending time to ublox\n      t_now = datetime.now(UTC).replace(tzinfo=None)\n      if t_now >= datetime(2021, 6, 1):\n        cloudlog.warning(\"Sending current time to ublox\")\n\n        # UBX-MGA-INI-TIME_UTC\n        msg = add_ubx_checksum(b\"\\xB5\\x62\\x13\\x40\\x18\\x00\" + struct.pack(\"<BBBBHBBBBBxIHxxI\",\n          0x10,\n          0x00,\n          0x00,\n          0x80,\n          t_now.year,\n          t_now.month,\n          t_now.day,\n          t_now.hour,\n          t_now.minute,\n          t_now.second,\n          0,\n          30,\n          0\n        ))\n        pigeon.send_with_ack(msg, ack=UBLOX_ASSIST_ACK)\n\n      # try getting AssistNow if we have a token\n      token = Params().get('AssistNowToken')\n      if token is not None:\n        try:\n          for msg in get_assistnow_messages(token):\n            pigeon.send_with_ack(msg, ack=UBLOX_ASSIST_ACK)\n          cloudlog.warning(\"AssistNow messages sent\")\n        except Exception:\n          cloudlog.warning(\"failed to get AssistNow messages\")\n\n      cloudlog.warning(\"Pigeon GPS on!\")\n      break\n    except TimeoutError:\n      cloudlog.warning(\"Initialization failed, trying again!\")\n  else:\n    cloudlog.warning(\"Failed to initialize pigeon\")\n    return False\n  return True\n\ndef deinitialize_and_exit(pigeon: TTYPigeon | None):\n  cloudlog.warning(\"Storing almanac in ublox flash\")\n\n  if pigeon is not None:\n    # controlled GNSS stop\n    pigeon.send(b\"\\xB5\\x62\\x06\\x04\\x04\\x00\\x00\\x00\\x08\\x00\\x16\\x74\")\n\n    # store almanac in flash\n    pigeon.send(b\"\\xB5\\x62\\x09\\x14\\x04\\x00\\x00\\x00\\x00\\x00\\x21\\xEC\")\n    try:\n      if pigeon.wait_for_ack(ack=UBLOX_SOS_ACK, nack=UBLOX_SOS_NACK):\n        cloudlog.warning(\"Done storing almanac\")\n      else:\n        cloudlog.error(\"Error storing almanac\")\n    except TimeoutError:\n      pass\n\n  # turn off power and exit cleanly\n  set_power(False)\n  sys.exit(0)\n\ndef create_pigeon() -> tuple[TTYPigeon, messaging.PubMaster]:\n  pigeon = None\n\n  # register exit handler\n  signal.signal(signal.SIGINT, lambda sig, frame: deinitialize_and_exit(pigeon))\n  pm = messaging.PubMaster(['ubloxRaw'])\n\n  # power cycle ublox\n  set_power(False)\n  time.sleep(0.1)\n  set_power(True)\n  time.sleep(0.5)\n\n  pigeon = TTYPigeon()\n  return pigeon, pm\n\ndef run_receiving(pigeon: TTYPigeon, pm: messaging.PubMaster, duration: int = 0):\n\n  start_time = time.monotonic()\n  def end_condition():\n    return True if duration == 0 else time.monotonic() - start_time < duration\n\n  while end_condition():\n    dat = pigeon.receive()\n    if len(dat) > 0:\n      if dat[0] == 0x00:\n        cloudlog.warning(\"received invalid data from ublox, re-initing!\")\n        init_baudrate(pigeon)\n        initialize_pigeon(pigeon)\n        continue\n\n      # send out to socket\n      msg = messaging.new_message('ubloxRaw', len(dat), valid=True)\n      msg.ubloxRaw = dat[:]\n      pm.send('ubloxRaw', msg)\n    else:\n      # prevent locking up a CPU core if ublox disconnects\n      time.sleep(0.001)\n\n\ndef main():\n  assert TICI, \"unsupported hardware for pigeond\"\n\n  pigeon, pm = create_pigeon()\n  init_baudrate(pigeon)\n  initialize_pigeon(pigeon)\n\n  # start receiving data\n  run_receiving(pigeon, pm)\n\nif __name__ == \"__main__\":\n  main()\n", "system/camerad/__init__.py": "", "system/camerad/snapshot/snapshot.py": "#!/usr/bin/env python3\nimport subprocess\nimport time\n\nimport numpy as np\nfrom PIL import Image\n\nimport cereal.messaging as messaging\nfrom msgq.visionipc import VisionIpcClient, VisionStreamType\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import DT_MDL\nfrom openpilot.system.hardware import PC\nfrom openpilot.selfdrive.controls.lib.alertmanager import set_offroad_alert\nfrom openpilot.system.manager.process_config import managed_processes\n\n\nVISION_STREAMS = {\n  \"roadCameraState\": VisionStreamType.VISION_STREAM_ROAD,\n  \"driverCameraState\": VisionStreamType.VISION_STREAM_DRIVER,\n  \"wideRoadCameraState\": VisionStreamType.VISION_STREAM_WIDE_ROAD,\n}\n\n\ndef jpeg_write(fn, dat):\n  img = Image.fromarray(dat)\n  img.save(fn, \"JPEG\")\n\n\ndef yuv_to_rgb(y, u, v):\n  ul = np.repeat(np.repeat(u, 2).reshape(u.shape[0], y.shape[1]), 2, axis=0).reshape(y.shape)\n  vl = np.repeat(np.repeat(v, 2).reshape(v.shape[0], y.shape[1]), 2, axis=0).reshape(y.shape)\n\n  yuv = np.dstack((y, ul, vl)).astype(np.int16)\n  yuv[:, :, 1:] -= 128\n\n  m = np.array([\n    [1.00000,  1.00000, 1.00000],\n    [0.00000, -0.39465, 2.03211],\n    [1.13983, -0.58060, 0.00000],\n  ])\n  rgb = np.dot(yuv, m).clip(0, 255)\n  return rgb.astype(np.uint8)\n\n\ndef extract_image(buf):\n  y = np.array(buf.data[:buf.uv_offset], dtype=np.uint8).reshape((-1, buf.stride))[:buf.height, :buf.width]\n  u = np.array(buf.data[buf.uv_offset::2], dtype=np.uint8).reshape((-1, buf.stride//2))[:buf.height//2, :buf.width//2]\n  v = np.array(buf.data[buf.uv_offset+1::2], dtype=np.uint8).reshape((-1, buf.stride//2))[:buf.height//2, :buf.width//2]\n\n  return yuv_to_rgb(y, u, v)\n\n\ndef get_snapshots(frame=\"roadCameraState\", front_frame=\"driverCameraState\"):\n  sockets = [s for s in (frame, front_frame) if s is not None]\n  sm = messaging.SubMaster(sockets)\n  vipc_clients = {s: VisionIpcClient(\"camerad\", VISION_STREAMS[s], True) for s in sockets}\n\n  # wait 4 sec from camerad startup for focus and exposure\n  while sm[sockets[0]].frameId < int(4. / DT_MDL):\n    sm.update()\n\n  for client in vipc_clients.values():\n    client.connect(True)\n\n  # grab images\n  rear, front = None, None\n  if frame is not None:\n    c = vipc_clients[frame]\n    rear = extract_image(c.recv())\n  if front_frame is not None:\n    c = vipc_clients[front_frame]\n    front = extract_image(c.recv())\n  return rear, front\n\n\ndef snapshot():\n  params = Params()\n\n  if (not params.get_bool(\"IsOffroad\")) or params.get_bool(\"IsTakingSnapshot\"):\n    print(\"Already taking snapshot\")\n    return None, None\n\n  front_camera_allowed = params.get_bool(\"RecordFront\")\n  params.put_bool(\"IsTakingSnapshot\", True)\n  set_offroad_alert(\"Offroad_IsTakingSnapshot\", True)\n  time.sleep(2.0)  # Give hardwared time to read the param, or if just started give camerad time to start\n\n  # Check if camerad is already started\n  try:\n    subprocess.check_call([\"pgrep\", \"camerad\"])\n    print(\"Camerad already running\")\n    params.put_bool(\"IsTakingSnapshot\", False)\n    params.remove(\"Offroad_IsTakingSnapshot\")\n    return None, None\n  except subprocess.CalledProcessError:\n    pass\n\n  try:\n    # Allow testing on replay on PC\n    if not PC:\n      managed_processes['camerad'].start()\n\n    frame = \"wideRoadCameraState\"\n    front_frame = \"driverCameraState\" if front_camera_allowed else None\n    rear, front = get_snapshots(frame, front_frame)\n  finally:\n    managed_processes['camerad'].stop()\n    params.put_bool(\"IsTakingSnapshot\", False)\n    set_offroad_alert(\"Offroad_IsTakingSnapshot\", False)\n\n  if not front_camera_allowed:\n    front = None\n\n  return rear, front\n\n\nif __name__ == \"__main__\":\n  pic, fpic = snapshot()\n  if pic is not None:\n    print(pic.shape)\n    jpeg_write(\"/tmp/back.jpg\", pic)\n    if fpic is not None:\n      jpeg_write(\"/tmp/front.jpg\", fpic)\n  else:\n    print(\"Error taking snapshot\")\n", "system/camerad/snapshot/__init__.py": "", "system/sensord/__init__.py": "", "system/qcomgpsd/qcomgpsd.py": "#!/usr/bin/env python3\nimport os\nimport sys\nimport signal\nimport itertools\nimport math\nimport time\nimport requests\nimport shutil\nimport subprocess\nimport datetime\nfrom multiprocessing import Process, Event\nfrom typing import NoReturn\nfrom struct import unpack_from, calcsize, pack\n\nfrom cereal import log\nimport cereal.messaging as messaging\nfrom openpilot.common.gpio import gpio_init, gpio_set\nfrom openpilot.common.retry import retry\nfrom openpilot.common.time import system_time_valid\nfrom openpilot.system.hardware.tici.pins import GPIO\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.qcomgpsd.modemdiag import ModemDiag, DIAG_LOG_F, setup_logs, send_recv\nfrom openpilot.system.qcomgpsd.structs import (dict_unpacker, position_report, relist,\n                                              gps_measurement_report, gps_measurement_report_sv,\n                                              glonass_measurement_report, glonass_measurement_report_sv,\n                                              oemdre_measurement_report, oemdre_measurement_report_sv, oemdre_svpoly_report,\n                                              LOG_GNSS_GPS_MEASUREMENT_REPORT, LOG_GNSS_GLONASS_MEASUREMENT_REPORT,\n                                              LOG_GNSS_POSITION_REPORT, LOG_GNSS_OEMDRE_MEASUREMENT_REPORT,\n                                              LOG_GNSS_OEMDRE_SVPOLY_REPORT)\n\nDEBUG = int(os.getenv(\"DEBUG\", \"0\"))==1\nASSIST_DATA_FILE = '/tmp/xtra3grc.bin'\nASSIST_DATA_FILE_DOWNLOAD = ASSIST_DATA_FILE + '.download'\nASSISTANCE_URL = 'http://xtrapath3.izatcloud.net/xtra3grc.bin'\n\nLOG_TYPES = [\n  LOG_GNSS_GPS_MEASUREMENT_REPORT,\n  LOG_GNSS_GLONASS_MEASUREMENT_REPORT,\n  LOG_GNSS_OEMDRE_MEASUREMENT_REPORT,\n  LOG_GNSS_POSITION_REPORT,\n  LOG_GNSS_OEMDRE_SVPOLY_REPORT,\n]\n\n\nmiscStatusFields = {\n  \"multipathEstimateIsValid\": 0,\n  \"directionIsValid\": 1,\n}\n\nmeasurementStatusFields = {\n  \"subMillisecondIsValid\": 0,\n  \"subBitTimeIsKnown\": 1,\n  \"satelliteTimeIsKnown\": 2,\n  \"bitEdgeConfirmedFromSignal\": 3,\n  \"measuredVelocity\": 4,\n  \"fineOrCoarseVelocity\": 5,\n  \"lockPointValid\": 6,\n  \"lockPointPositive\": 7,\n\n  \"lastUpdateFromDifference\": 9,\n  \"lastUpdateFromVelocityDifference\": 10,\n  \"strongIndicationOfCrossCorelation\": 11,\n  \"tentativeMeasurement\": 12,\n  \"measurementNotUsable\": 13,\n  \"sirCheckIsNeeded\": 14,\n  \"probationMode\": 15,\n\n  \"multipathIndicator\": 24,\n  \"imdJammingIndicator\": 25,\n  \"lteB13TxJammingIndicator\": 26,\n  \"freshMeasurementIndicator\": 27,\n}\n\nmeasurementStatusGPSFields = {\n  \"gpsRoundRobinRxDiversity\": 18,\n  \"gpsRxDiversity\": 19,\n  \"gpsLowBandwidthRxDiversityCombined\": 20,\n  \"gpsHighBandwidthNu4\": 21,\n  \"gpsHighBandwidthNu8\": 22,\n  \"gpsHighBandwidthUniform\": 23,\n}\n\nmeasurementStatusGlonassFields = {\n  \"glonassMeanderBitEdgeValid\": 16,\n  \"glonassTimeMarkValid\": 17\n}\n\n@retry(attempts=10, delay=1.0)\ndef try_setup_logs(diag, logs):\n  return setup_logs(diag, logs)\n\n@retry(attempts=3, delay=1.0)\ndef at_cmd(cmd: str) -> str | None:\n  return subprocess.check_output(f\"mmcli -m any --timeout 30 --command='{cmd}'\", shell=True, encoding='utf8')\n\ndef gps_enabled() -> bool:\n  return \"QGPS: 1\" in at_cmd(\"AT+QGPS?\")\n\ndef download_assistance():\n  try:\n    response = requests.get(ASSISTANCE_URL, timeout=5, stream=True)\n\n    with open(ASSIST_DATA_FILE_DOWNLOAD, 'wb') as fp:\n      for chunk in response.iter_content(chunk_size=8192):\n        fp.write(chunk)\n        if fp.tell() > 1e5:\n          cloudlog.error(\"Qcom assistance data larger than expected\")\n          return\n\n    os.rename(ASSIST_DATA_FILE_DOWNLOAD, ASSIST_DATA_FILE)\n\n  except requests.exceptions.RequestException:\n    cloudlog.exception(\"Failed to download assistance file\")\n    return\n\ndef downloader_loop(event):\n  if os.path.exists(ASSIST_DATA_FILE):\n    os.remove(ASSIST_DATA_FILE)\n\n  alt_path = os.getenv(\"QCOM_ALT_ASSISTANCE_PATH\", None)\n  if alt_path is not None and os.path.exists(alt_path):\n    shutil.copyfile(alt_path, ASSIST_DATA_FILE)\n\n  try:\n    while not os.path.exists(ASSIST_DATA_FILE) and not event.is_set():\n      download_assistance()\n      event.wait(timeout=10)\n  except KeyboardInterrupt:\n    pass\n\n@retry(attempts=5, delay=0.2, ignore_failure=True)\ndef inject_assistance():\n  cmd = f\"mmcli -m any --timeout 30 --location-inject-assistance-data={ASSIST_DATA_FILE}\"\n  subprocess.check_output(cmd, stderr=subprocess.PIPE, shell=True)\n  cloudlog.info(\"successfully loaded assistance data\")\n\n@retry(attempts=5, delay=1.0)\ndef setup_quectel(diag: ModemDiag) -> bool:\n  ret = False\n\n  # enable OEMDRE in the NV\n  # TODO: it has to reboot for this to take effect\n  DIAG_NV_READ_F = 38\n  DIAG_NV_WRITE_F = 39\n  NV_GNSS_OEM_FEATURE_MASK = 7165\n  send_recv(diag, DIAG_NV_WRITE_F, pack('<HI', NV_GNSS_OEM_FEATURE_MASK, 1))\n  send_recv(diag, DIAG_NV_READ_F, pack('<H', NV_GNSS_OEM_FEATURE_MASK))\n\n  try_setup_logs(diag, LOG_TYPES)\n\n  if gps_enabled():\n    at_cmd(\"AT+QGPSEND\")\n\n  if \"GPS_COLD_START\" in os.environ:\n    # deletes all assistance\n    at_cmd(\"AT+QGPSDEL=0\")\n  else:\n    # allow module to perform hot start\n    at_cmd(\"AT+QGPSDEL=1\")\n\n  # disable DPO power savings for more accuracy\n  at_cmd(\"AT+QGPSCFG=\\\"dpoenable\\\",0\")\n  # don't automatically turn on GNSS on powerup\n  at_cmd(\"AT+QGPSCFG=\\\"autogps\\\",0\")\n\n  # Do internet assistance\n  at_cmd(\"AT+QGPSXTRA=1\")\n  at_cmd(\"AT+QGPSSUPLURL=\\\"NULL\\\"\")\n  if os.path.exists(ASSIST_DATA_FILE):\n    ret = True\n    inject_assistance()\n    os.remove(ASSIST_DATA_FILE)\n  #at_cmd(\"AT+QGPSXTRADATA?\")\n  if system_time_valid():\n    time_str = datetime.datetime.now(datetime.UTC).replace(tzinfo=None).strftime(\"%Y/%m/%d,%H:%M:%S\")\n    at_cmd(f\"AT+QGPSXTRATIME=0,\\\"{time_str}\\\",1,1,1000\")\n\n  at_cmd(\"AT+QGPSCFG=\\\"outport\\\",\\\"usbnmea\\\"\")\n  at_cmd(\"AT+QGPS=1\")\n\n  # enable OEMDRE mode\n  DIAG_SUBSYS_CMD_F = 75\n  DIAG_SUBSYS_GPS = 13\n  CGPS_DIAG_PDAPI_CMD = 0x64\n  CGPS_OEM_CONTROL = 202\n  GPSDIAG_OEMFEATURE_DRE = 1\n  GPSDIAG_OEM_DRE_ON = 1\n\n  # gpsdiag_OemControlReqType\n  send_recv(diag, DIAG_SUBSYS_CMD_F, pack('<BHBBIIII',\n    DIAG_SUBSYS_GPS,           # Subsystem Id\n    CGPS_DIAG_PDAPI_CMD,       # Subsystem Command Code\n    CGPS_OEM_CONTROL,          # CGPS Command Code\n    0,                         # Version\n    GPSDIAG_OEMFEATURE_DRE,\n    GPSDIAG_OEM_DRE_ON,\n    0,0\n  ))\n\n  return ret\n\ndef teardown_quectel(diag):\n  at_cmd(\"AT+QGPSCFG=\\\"outport\\\",\\\"none\\\"\")\n  if gps_enabled():\n    at_cmd(\"AT+QGPSEND\")\n  try_setup_logs(diag, [])\n\n\ndef wait_for_modem(cmd=\"AT+QGPS?\"):\n  cloudlog.warning(\"waiting for modem to come up\")\n  while True:\n    ret = subprocess.call(f\"mmcli -m any --timeout 10 --command=\\\"{cmd}\\\"\", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n    if ret == 0:\n      return\n    time.sleep(0.1)\n\n\ndef main() -> NoReturn:\n  unpack_gps_meas, size_gps_meas = dict_unpacker(gps_measurement_report, True)\n  unpack_gps_meas_sv, size_gps_meas_sv = dict_unpacker(gps_measurement_report_sv, True)\n\n  unpack_glonass_meas, size_glonass_meas = dict_unpacker(glonass_measurement_report, True)\n  unpack_glonass_meas_sv, size_glonass_meas_sv = dict_unpacker(glonass_measurement_report_sv, True)\n\n  unpack_oemdre_meas, size_oemdre_meas = dict_unpacker(oemdre_measurement_report, True)\n  unpack_oemdre_meas_sv, size_oemdre_meas_sv = dict_unpacker(oemdre_measurement_report_sv, True)\n\n  unpack_svpoly, _ = dict_unpacker(oemdre_svpoly_report, True)\n  unpack_position, _ = dict_unpacker(position_report)\n\n  unpack_position, _ = dict_unpacker(position_report)\n\n  wait_for_modem()\n\n  stop_download_event = Event()\n  assist_fetch_proc = Process(target=downloader_loop, args=(stop_download_event,))\n  assist_fetch_proc.start()\n  def cleanup(sig, frame):\n    cloudlog.warning(\"caught sig disabling quectel gps\")\n\n    gpio_set(GPIO.GNSS_PWR_EN, False)\n    teardown_quectel(diag)\n    cloudlog.warning(\"quectel cleanup done\")\n\n    stop_download_event.set()\n    assist_fetch_proc.kill()\n    assist_fetch_proc.join()\n\n    sys.exit(0)\n  signal.signal(signal.SIGINT, cleanup)\n  signal.signal(signal.SIGTERM, cleanup)\n\n  # connect to modem\n  diag = ModemDiag()\n  r = setup_quectel(diag)\n  want_assistance = not r\n  cloudlog.warning(\"quectel setup done\")\n  gpio_init(GPIO.GNSS_PWR_EN, True)\n  gpio_set(GPIO.GNSS_PWR_EN, True)\n\n  pm = messaging.PubMaster(['qcomGnss', 'gpsLocation'])\n\n  while 1:\n    if os.path.exists(ASSIST_DATA_FILE) and want_assistance:\n      setup_quectel(diag)\n      want_assistance = False\n\n    opcode, payload = diag.recv()\n    if opcode != DIAG_LOG_F:\n      cloudlog.error(f\"Unhandled opcode: {opcode}\")\n      continue\n\n    (pending_msgs, log_outer_length), inner_log_packet = unpack_from('<BH', payload), payload[calcsize('<BH'):]\n    if pending_msgs > 0:\n      cloudlog.debug(\"have %d pending messages\" % pending_msgs)\n    assert log_outer_length == len(inner_log_packet)\n\n    (log_inner_length, log_type, log_time), log_payload = unpack_from('<HHQ', inner_log_packet), inner_log_packet[calcsize('<HHQ'):]\n    assert log_inner_length == len(inner_log_packet)\n\n    if log_type not in LOG_TYPES:\n      continue\n\n    if DEBUG:\n      print(\"%.4f: got log: %x len %d\" % (time.time(), log_type, len(log_payload)))\n\n    if log_type == LOG_GNSS_OEMDRE_MEASUREMENT_REPORT:\n      msg = messaging.new_message('qcomGnss', valid=True)\n\n      gnss = msg.qcomGnss\n      gnss.logTs = log_time\n      gnss.init('drMeasurementReport')\n      report = gnss.drMeasurementReport\n\n      dat = unpack_oemdre_meas(log_payload)\n      for k,v in dat.items():\n        if k in [\"gpsTimeBias\", \"gpsClockTimeUncertainty\"]:\n          k += \"Ms\"\n        if k == \"version\":\n          assert v == 2\n        elif k == \"svCount\" or k.startswith(\"cdmaClockInfo[\"):\n          # TODO: should we save cdmaClockInfo?\n          pass\n        elif k == \"systemRtcValid\":\n          setattr(report, k, bool(v))\n        else:\n          setattr(report, k, v)\n\n      report.init('sv', dat['svCount'])\n      sats = log_payload[size_oemdre_meas:]\n      for i in range(dat['svCount']):\n        sat = unpack_oemdre_meas_sv(sats[size_oemdre_meas_sv*i:size_oemdre_meas_sv*(i+1)])\n        sv = report.sv[i]\n        sv.init('measurementStatus')\n        for k,v in sat.items():\n          if k in [\"unkn\", \"measurementStatus2\"]:\n            pass\n          elif k == \"multipathEstimateValid\":\n            sv.measurementStatus.multipathEstimateIsValid = bool(v)\n          elif k == \"directionValid\":\n            sv.measurementStatus.directionIsValid = bool(v)\n          elif k == \"goodParity\":\n            setattr(sv, k, bool(v))\n          elif k == \"measurementStatus\":\n            for kk,vv in measurementStatusFields.items():\n              setattr(sv.measurementStatus, kk, bool(v & (1<<vv)))\n          else:\n            setattr(sv, k, v)\n      pm.send('qcomGnss', msg)\n    elif log_type == LOG_GNSS_POSITION_REPORT:\n      report = unpack_position(log_payload)\n      if report[\"u_PosSource\"] != 2:\n        continue\n      vNED = [report[\"q_FltVelEnuMps[1]\"], report[\"q_FltVelEnuMps[0]\"], -report[\"q_FltVelEnuMps[2]\"]]\n      vNEDsigma = [report[\"q_FltVelSigmaMps[1]\"], report[\"q_FltVelSigmaMps[0]\"], -report[\"q_FltVelSigmaMps[2]\"]]\n\n      msg = messaging.new_message('gpsLocation', valid=True)\n      gps = msg.gpsLocation\n      gps.latitude = report[\"t_DblFinalPosLatLon[0]\"] * 180/math.pi\n      gps.longitude = report[\"t_DblFinalPosLatLon[1]\"] * 180/math.pi\n      gps.altitude = report[\"q_FltFinalPosAlt\"]\n      gps.speed = math.sqrt(sum([x**2 for x in vNED]))\n      gps.bearingDeg = report[\"q_FltHeadingRad\"] * 180/math.pi\n\n      # TODO needs update if there is another leap second, after june 2024?\n      dt_timestamp = (datetime.datetime(1980, 1, 6, 0, 0, 0, 0, datetime.UTC) +\n                      datetime.timedelta(weeks=report['w_GpsWeekNumber']) +\n                      datetime.timedelta(seconds=(1e-3*report['q_GpsFixTimeMs'] - 18)))\n      gps.unixTimestampMillis = dt_timestamp.timestamp()*1e3\n      gps.source = log.GpsLocationData.SensorSource.qcomdiag\n      gps.vNED = vNED\n      gps.verticalAccuracy = report[\"q_FltVdop\"]\n      gps.bearingAccuracyDeg = report[\"q_FltHeadingUncRad\"] * 180/math.pi if (report[\"q_FltHeadingUncRad\"] != 0) else 180\n      gps.speedAccuracy = math.sqrt(sum([x**2 for x in vNEDsigma]))\n      # quectel gps verticalAccuracy is clipped to 500, set invalid if so\n      gps.hasFix = gps.verticalAccuracy != 500\n      if gps.hasFix:\n        want_assistance = False\n        stop_download_event.set()\n      pm.send('gpsLocation', msg)\n\n    elif log_type == LOG_GNSS_OEMDRE_SVPOLY_REPORT:\n      msg = messaging.new_message('qcomGnss', valid=True)\n      dat = unpack_svpoly(log_payload)\n      dat = relist(dat)\n      gnss = msg.qcomGnss\n      gnss.logTs = log_time\n      gnss.init('drSvPoly')\n      poly = gnss.drSvPoly\n      for k,v in dat.items():\n        if k == \"version\":\n          assert v == 2\n        elif k == \"flags\":\n          pass\n        else:\n          setattr(poly, k, v)\n\n      '''\n      # Timestamp glonass polys with GPSTime\n      from laika.gps_time import GPSTime, utc_to_gpst, get_leap_seconds\n      from laika.helpers import get_prn_from_nmea_id\n      prn = get_prn_from_nmea_id(poly.svId)\n      if prn[0] == 'R':\n        epoch = GPSTime(current_gps_time.week, (poly.t0 - 3*SECS_IN_HR + SECS_IN_DAY) % (SECS_IN_WEEK) + get_leap_seconds(current_gps_time))\n      else:\n        epoch = GPSTime(current_gps_time.week, poly.t0)\n\n      # handle week rollover\n      if epoch.tow < SECS_IN_DAY and current_gps_time.tow > 6*SECS_IN_DAY:\n        epoch.week += 1\n      elif epoch.tow > 6*SECS_IN_DAY and current_gps_time.tow < SECS_IN_DAY:\n        epoch.week -= 1\n\n      poly.gpsWeek = epoch.week\n      poly.gpsTow = epoch.tow\n      '''\n      pm.send('qcomGnss', msg)\n\n    elif log_type in [LOG_GNSS_GPS_MEASUREMENT_REPORT, LOG_GNSS_GLONASS_MEASUREMENT_REPORT]:\n      msg = messaging.new_message('qcomGnss', valid=True)\n\n      gnss = msg.qcomGnss\n      gnss.logTs = log_time\n      gnss.init('measurementReport')\n      report = gnss.measurementReport\n\n      if log_type == LOG_GNSS_GPS_MEASUREMENT_REPORT:\n        dat = unpack_gps_meas(log_payload)\n        sats = log_payload[size_gps_meas:]\n        unpack_meas_sv, size_meas_sv = unpack_gps_meas_sv, size_gps_meas_sv\n        report.source = 0  # gps\n        measurement_status_fields = (measurementStatusFields.items(), measurementStatusGPSFields.items())\n      elif log_type == LOG_GNSS_GLONASS_MEASUREMENT_REPORT:\n        dat = unpack_glonass_meas(log_payload)\n        sats = log_payload[size_glonass_meas:]\n        unpack_meas_sv, size_meas_sv = unpack_glonass_meas_sv, size_glonass_meas_sv\n        report.source = 1  # glonass\n        measurement_status_fields = (measurementStatusFields.items(), measurementStatusGlonassFields.items())\n      else:\n        raise RuntimeError(f\"invalid log_type: {log_type}\")\n\n      for k,v in dat.items():\n        if k == \"version\":\n          assert v == 0\n        elif k == \"week\":\n          report.gpsWeek = v\n        elif k == \"svCount\":\n          pass\n        else:\n          setattr(report, k, v)\n      report.init('sv', dat['svCount'])\n      if dat['svCount'] > 0:\n        assert len(sats)//dat['svCount'] == size_meas_sv\n        for i in range(dat['svCount']):\n          sv = report.sv[i]\n          sv.init('measurementStatus')\n          sat = unpack_meas_sv(sats[size_meas_sv*i:size_meas_sv*(i+1)])\n          for k,v in sat.items():\n            if k == \"parityErrorCount\":\n              sv.gpsParityErrorCount = v\n            elif k == \"frequencyIndex\":\n              sv.glonassFrequencyIndex = v\n            elif k == \"hemmingErrorCount\":\n              sv.glonassHemmingErrorCount = v\n            elif k == \"measurementStatus\":\n              for kk,vv in itertools.chain(*measurement_status_fields):\n                setattr(sv.measurementStatus, kk, bool(v & (1<<vv)))\n            elif k == \"miscStatus\":\n              for kk,vv in miscStatusFields.items():\n                setattr(sv.measurementStatus, kk, bool(v & (1<<vv)))\n            elif k == \"pad\":\n              pass\n            else:\n              setattr(sv, k, v)\n\n      pm.send('qcomGnss', msg)\n\nif __name__ == \"__main__\":\n  main()\n", "system/qcomgpsd/nmeaport.py": "import os\nimport sys\nfrom dataclasses import dataclass, fields\nfrom subprocess import check_output, CalledProcessError\nfrom time import sleep\nfrom typing import NoReturn\n\nDEBUG = int(os.environ.get(\"DEBUG\", \"0\"))\n\n@dataclass\nclass GnssClockNmeaPort:\n  # flags bit mask:\n  # 0x01 = leap_seconds valid\n  # 0x02 = time_uncertainty_ns valid\n  # 0x04 = full_bias_ns valid\n  # 0x08 = bias_ns valid\n  # 0x10 = bias_uncertainty_ns valid\n  # 0x20 = drift_nsps valid\n  # 0x40 = drift_uncertainty_nsps valid\n  flags: int\n  leap_seconds: int\n  time_ns: int\n  time_uncertainty_ns: int # 1-sigma\n  full_bias_ns: int\n  bias_ns: float\n  bias_uncertainty_ns: float # 1-sigma\n  drift_nsps: float\n  drift_uncertainty_nsps: float # 1-sigma\n\n  def __post_init__(self):\n    for field in fields(self):\n      val = getattr(self, field.name)\n      setattr(self, field.name, field.type(val) if val else None)\n\n@dataclass\nclass GnssMeasNmeaPort:\n  messageCount: int\n  messageNum: int\n  svCount: int\n  # constellation enum:\n  # 1 = GPS\n  # 2 = SBAS\n  # 3 = GLONASS\n  # 4 = QZSS\n  # 5 = BEIDOU\n  # 6 = GALILEO\n  constellation: int\n  svId: int\n  flags: int # always zero\n  time_offset_ns: int\n  # state bit mask:\n  # 0x0001 = CODE LOCK\n  # 0x0002 = BIT SYNC\n  # 0x0004 = SUBFRAME SYNC\n  # 0x0008 = TIME OF WEEK DECODED\n  # 0x0010 = MSEC AMBIGUOUS\n  # 0x0020 = SYMBOL SYNC\n  # 0x0040 = GLONASS STRING SYNC\n  # 0x0080 = GLONASS TIME OF DAY DECODED\n  # 0x0100 = BEIDOU D2 BIT SYNC\n  # 0x0200 = BEIDOU D2 SUBFRAME SYNC\n  # 0x0400 = GALILEO E1BC CODE LOCK\n  # 0x0800 = GALILEO E1C 2ND CODE LOCK\n  # 0x1000 = GALILEO E1B PAGE SYNC\n  # 0x2000 = GALILEO E1B PAGE SYNC\n  state: int\n  time_of_week_ns: int\n  time_of_week_uncertainty_ns: int # 1-sigma\n  carrier_to_noise_ratio: float\n  pseudorange_rate: float\n  pseudorange_rate_uncertainty: float # 1-sigma\n\n  def __post_init__(self):\n    for field in fields(self):\n      val = getattr(self, field.name)\n      setattr(self, field.name, field.type(val) if val else None)\n\ndef nmea_checksum_ok(s):\n  checksum = 0\n  for i, c in enumerate(s[1:]):\n    if c == \"*\":\n      if i != len(s) - 4: # should be 3rd to last character\n        print(\"ERROR: NMEA string does not have checksum delimiter in correct location:\", s)\n        return False\n      break\n    checksum ^= ord(c)\n  else:\n    print(\"ERROR: NMEA string does not have checksum delimiter:\", s)\n    return False\n\n  return True\n\ndef process_nmea_port_messages(device:str=\"/dev/ttyUSB1\") -> NoReturn:\n  while True:\n    try:\n      with open(device) as nmeaport:\n        for line in nmeaport:\n          line = line.strip()\n          if DEBUG:\n            print(line)\n          if not line.startswith(\"$\"): # all NMEA messages start with $\n            continue\n          if not nmea_checksum_ok(line):\n            continue\n\n          fields = line.split(\",\")\n          match fields[0]:\n            case \"$GNCLK\":\n              # fields at end are reserved (not used)\n              gnss_clock = GnssClockNmeaPort(*fields[1:10]) # type: ignore[arg-type]\n              print(gnss_clock)\n            case \"$GNMEAS\":\n              # fields at end are reserved (not used)\n              gnss_meas = GnssMeasNmeaPort(*fields[1:14]) # type: ignore[arg-type]\n              print(gnss_meas)\n    except Exception as e:\n      print(e)\n      sleep(1)\n\ndef main() -> NoReturn:\n  from openpilot.common.gpio import gpio_init, gpio_set\n  from openpilot.system.hardware.tici.pins import GPIO\n  from openpilot.system.qcomgpsd.qcomgpsd import at_cmd\n\n  try:\n    check_output([\"pidof\", \"qcomgpsd\"])\n    print(\"qcomgpsd is running, please kill openpilot before running this script! (aborted)\")\n    sys.exit(1)\n  except CalledProcessError as e:\n    if e.returncode != 1: # 1 == no process found (pandad not running)\n      raise e\n\n  print(\"power up antenna ...\")\n  gpio_init(GPIO.GNSS_PWR_EN, True)\n  gpio_set(GPIO.GNSS_PWR_EN, True)\n\n  if b\"+QGPS: 0\" not in (at_cmd(\"AT+QGPS?\") or b\"\"):\n    print(\"stop location tracking ...\")\n    at_cmd(\"AT+QGPSEND\")\n\n  if b'+QGPSCFG: \"outport\",usbnmea' not in (at_cmd('AT+QGPSCFG=\"outport\"') or b\"\"):\n    print(\"configure outport ...\")\n    at_cmd('AT+QGPSCFG=\"outport\",\"usbnmea\"') # usbnmea = /dev/ttyUSB1\n\n  if b'+QGPSCFG: \"gnssrawdata\",3,0' not in (at_cmd('AT+QGPSCFG=\"gnssrawdata\"') or b\"\"):\n    print(\"configure gnssrawdata ...\")\n    # AT+QGPSCFG=\"gnssrawdata\",<constellation-mask>,<port>'\n    # <constellation-mask> values:\n    # 0x01 = GPS\n    # 0x02 = GLONASS\n    # 0x04 = BEIDOU\n    # 0x08 = GALILEO\n    # 0x10 = QZSS\n    # <port> values:\n    # 0 = NMEA port\n    # 1 = AT port\n    at_cmd('AT+QGPSCFG=\"gnssrawdata\",3,0') # enable all constellations, output data to NMEA port\n    print(\"rebooting ...\")\n    at_cmd('AT+CFUN=1,1')\n    print(\"re-run this script when it is back up\")\n    sys.exit(2)\n\n  print(\"starting location tracking ...\")\n  at_cmd(\"AT+QGPS=1\")\n\n  process_nmea_port_messages()\n\nif __name__ == \"__main__\":\n  main()\n", "system/qcomgpsd/structs.py": "from struct import unpack_from, calcsize\n\nLOG_GNSS_POSITION_REPORT = 0x1476\nLOG_GNSS_GPS_MEASUREMENT_REPORT = 0x1477\nLOG_GNSS_CLOCK_REPORT = 0x1478\nLOG_GNSS_GLONASS_MEASUREMENT_REPORT = 0x1480\nLOG_GNSS_BDS_MEASUREMENT_REPORT = 0x1756\nLOG_GNSS_GAL_MEASUREMENT_REPORT = 0x1886\n\nLOG_GNSS_OEMDRE_MEASUREMENT_REPORT = 0x14DE\nLOG_GNSS_OEMDRE_SVPOLY_REPORT = 0x14E1\n\nLOG_GNSS_ME_DPO_STATUS = 0x1838\nLOG_GNSS_CD_DB_REPORT = 0x147B\nLOG_GNSS_PRX_RF_HW_STATUS_REPORT = 0x147E\nLOG_CGPS_SLOW_CLOCK_CLIB_REPORT = 0x1488\nLOG_GNSS_CONFIGURATION_STATE = 0x1516\n\noemdre_measurement_report = \"\"\"\n  uint8_t version;\n  uint8_t reason;\n  uint8_t sv_count;\n  uint8_t seq_num;\n  uint8_t seq_max;\n  uint16_t rf_loss;\n\n  uint8_t system_rtc_valid;\n  uint32_t f_count;\n  uint32_t clock_resets;\n  uint64_t system_rtc_time;\n\n  uint8_t gps_leap_seconds;\n  uint8_t gps_leap_seconds_uncertainty;\n  float gps_to_glonass_time_bias_milliseconds;\n  float gps_to_glonass_time_bias_milliseconds_uncertainty;\n\n  uint16_t gps_week;\n  uint32_t gps_milliseconds;\n  uint32_t gps_time_bias;\n  uint32_t gps_clock_time_uncertainty;\n  uint8_t gps_clock_source;\n\n  uint8_t glonass_clock_source;\n  uint8_t glonass_year;\n  uint16_t glonass_day;\n  uint32_t glonass_milliseconds;\n  float glonass_time_bias;\n  float glonass_clock_time_uncertainty;\n\n  float clock_frequency_bias;\n  float clock_frequency_uncertainty;\n  uint8_t frequency_source;\n\n  uint32_t cdma_clock_info[5];\n\n  uint8_t source;\n\"\"\"\n\noemdre_svpoly_report = \"\"\"\n  uint8_t version;\n  uint16_t sv_id;\n  int8_t frequency_index;\n  uint8_t flags;\n  uint16_t iode;\n  double t0;\n  double xyz0[3];\n  double xyzN[9];\n  float other[4];\n  float position_uncertainty;\n  float iono_delay;\n  float iono_dot;\n  float sbas_iono_delay;\n  float sbas_iono_dot;\n  float tropo_delay;\n  float elevation;\n  float elevation_dot;\n  float elevation_uncertainty;\n  double velocity_coeff[12];\n\"\"\"\n\n\noemdre_measurement_report_sv = \"\"\"\n  uint8_t sv_id;\n  uint8_t unkn;\n  int8_t glonass_frequency_index;\n  uint32_t observation_state;\n  uint8_t observations;\n  uint8_t good_observations;\n  uint8_t filter_stages;\n  uint8_t predetect_interval;\n  uint8_t cycle_slip_count;\n  uint16_t postdetections;\n\n  uint32_t measurement_status;\n  uint32_t measurement_status2;\n\n  uint16_t carrier_noise;\n  uint16_t rf_loss;\n  int16_t latency;\n\n  float filtered_measurement_fraction;\n  uint32_t filtered_measurement_integral;\n  float filtered_time_uncertainty;\n  float filtered_speed;\n  float filtered_speed_uncertainty;\n\n  float unfiltered_measurement_fraction;\n  uint32_t unfiltered_measurement_integral;\n  float unfiltered_time_uncertainty;\n  float unfiltered_speed;\n  float unfiltered_speed_uncertainty;\n\n  uint8_t multipath_estimate_valid;\n  uint32_t multipath_estimate;\n  uint8_t direction_valid;\n  float azimuth;\n  float elevation;\n  float doppler_acceleration;\n  float fine_speed;\n  float fine_speed_uncertainty;\n\n  uint64_t carrier_phase;\n  uint32_t f_count;\n\n  uint16_t parity_error_count;\n  uint8_t good_parity;\n\"\"\"\n\nglonass_measurement_report = \"\"\"\n  uint8_t version;\n  uint32_t f_count;\n  uint8_t glonass_cycle_number;\n  uint16_t glonass_number_of_days;\n  uint32_t milliseconds;\n  float time_bias;\n  float clock_time_uncertainty;\n  float clock_frequency_bias;\n  float clock_frequency_uncertainty;\n  uint8_t sv_count;\n\"\"\"\n\nglonass_measurement_report_sv = \"\"\"\n  uint8_t sv_id;\n  int8_t frequency_index;\n  uint8_t observation_state; // SVObservationStates\n  uint8_t observations;\n  uint8_t good_observations;\n  uint8_t hemming_error_count;\n  uint8_t filter_stages;\n  uint16_t carrier_noise;\n  int16_t latency;\n  uint8_t predetect_interval;\n  uint16_t postdetections;\n  uint32_t unfiltered_measurement_integral;\n  float unfiltered_measurement_fraction;\n  float unfiltered_time_uncertainty;\n  float unfiltered_speed;\n  float unfiltered_speed_uncertainty;\n  uint32_t measurement_status;\n  uint8_t misc_status;\n  uint32_t multipath_estimate;\n  float azimuth;\n  float elevation;\n  int32_t carrier_phase_cycles_integral;\n  uint16_t carrier_phase_cycles_fraction;\n  float fine_speed;\n  float fine_speed_uncertainty;\n  uint8_t cycle_slip_count;\n  uint32_t pad;\n\"\"\"\n\ngps_measurement_report = \"\"\"\n  uint8_t version;\n  uint32_t f_count;\n  uint16_t week;\n  uint32_t milliseconds;\n  float time_bias;\n  float clock_time_uncertainty;\n  float clock_frequency_bias;\n  float clock_frequency_uncertainty;\n  uint8_t sv_count;\n\"\"\"\n\ngps_measurement_report_sv = \"\"\"\n  uint8_t sv_id;                              // SV PRN\n  uint8_t observation_state;                  // SV Observation state\n  uint8_t observations;                       // Count of all observation (both success and failure)\n  uint8_t good_observations;                  // Count of Good observations\n  uint16_t parity_error_count;                // Carrier to Code filtering N count\n  uint8_t filter_stages;                      // Pre-Detection (Coherent) Interval (msecs)\n  uint16_t carrier_noise;                     // CNo. Units of 0.1 dB\n  int16_t latency;                            // Age of the measurement in msecs (+ve meas Meas precedes ref time)\n  uint8_t predetect_interval;                 // Pre-Detection (Coherent) Interval (msecs)\n  uint16_t postdetections;                    // Num Post-Detections (uints of PreInts\n  uint32_t unfiltered_measurement_integral;   // Range of 0 thru (WEEK_MSECS-1) [msecs]\n  float unfiltered_measurement_fraction;      // Range of 0 thru 0.99999 [msecs]\n  float unfiltered_time_uncertainty;          // Time uncertainty (msec)\n  float unfiltered_speed;                     // Speed estimate (meters/sec)\n  float unfiltered_speed_uncertainty;         // Speed uncertainty estimate (meters/sec)\n  uint32_t measurement_status;\n  uint8_t misc_status;\n  uint32_t multipath_estimate;\n  float azimuth;                              // Azimuth (radians)\n  float elevation;                            // Elevation (radians)\n  int32_t carrier_phase_cycles_integral;\n  uint16_t carrier_phase_cycles_fraction;\n  float fine_speed;                           // Carrier phase derived speed\n  float fine_speed_uncertainty;               // Carrier phase derived speed UNC\n  uint8_t cycle_slip_count;                   // Increments when a CSlip is detected\n  uint32_t pad;\n\"\"\"\n\nposition_report = \"\"\"\n  uint8       u_Version;                /* Version number of DM log */\n  uint32      q_Fcount;                 /* Local millisecond counter */\n  uint8       u_PosSource;              /* Source of position information */ /*  0: None 1: Weighted least-squares 2: Kalman filter 3: Externally injected 4: Internal database    */\n  uint32      q_Reserved1;              /* Reserved memory field */\n  uint16      w_PosVelFlag;             /* Position velocity bit field: (see DM log 0x1476 documentation) */\n  uint32      q_PosVelFlag2;            /* Position velocity 2 bit field: (see DM log 0x1476 documentation) */\n  uint8       u_FailureCode;            /* Failure code: (see DM log 0x1476 documentation) */\n  uint16      w_FixEvents;              /* Fix events bit field: (see DM log 0x1476 documentation) */\n  uint32 _fake_align_week_number;\n  uint16      w_GpsWeekNumber;          /* GPS week number of position */\n  uint32      q_GpsFixTimeMs;           /* GPS fix time of week of in milliseconds */\n  uint8       u_GloNumFourYear;         /* Number of Glonass four year cycles */\n  uint16      w_GloNumDaysInFourYear;   /* Glonass calendar day in four year cycle */\n  uint32      q_GloFixTimeMs;           /* Glonass fix time of day in milliseconds */\n  uint32      q_PosCount;               /* Integer count of the number of unique positions reported */\n  uint64      t_DblFinalPosLatLon[2];   /* Final latitude and longitude of position in radians */\n  uint32      q_FltFinalPosAlt;         /* Final height-above-ellipsoid altitude of position */\n  uint32      q_FltHeadingRad;          /* User heading in radians */\n  uint32      q_FltHeadingUncRad;       /* User heading uncertainty in radians */\n  uint32      q_FltVelEnuMps[3];        /* User velocity in east, north, up coordinate frame. In meters per second. */\n  uint32      q_FltVelSigmaMps[3];      /* Gaussian 1-sigma value for east, north, up components of user velocity */\n  uint32      q_FltClockBiasMeters;     /* Receiver clock bias in meters */\n  uint32      q_FltClockBiasSigmaMeters;  /* Gaussian 1-sigma value for receiver clock bias in meters */\n  uint32      q_FltGGTBMeters;          /* GPS to Glonass time bias in meters */\n  uint32      q_FltGGTBSigmaMeters;     /* Gaussian 1-sigma value for GPS to Glonass time bias uncertainty in meters */\n  uint32      q_FltGBTBMeters;          /* GPS to BeiDou time bias in meters */\n  uint32      q_FltGBTBSigmaMeters;     /* Gaussian 1-sigma value for GPS to BeiDou time bias uncertainty in meters */\n  uint32      q_FltBGTBMeters;          /* BeiDou to Glonass time bias in meters */\n  uint32      q_FltBGTBSigmaMeters;     /* Gaussian 1-sigma value for BeiDou to Glonass time bias uncertainty in meters */\n  uint32      q_FltFiltGGTBMeters;      /* Filtered GPS to Glonass time bias in meters */\n  uint32      q_FltFiltGGTBSigmaMeters; /* Filtered Gaussian 1-sigma value for GPS to Glonass time bias uncertainty in meters */\n  uint32      q_FltFiltGBTBMeters;      /* Filtered GPS to BeiDou time bias in meters */\n  uint32      q_FltFiltGBTBSigmaMeters; /* Filtered Gaussian 1-sigma value for GPS to BeiDou time bias uncertainty in meters */\n  uint32      q_FltFiltBGTBMeters;      /* Filtered BeiDou to Glonass time bias in meters */\n  uint32      q_FltFiltBGTBSigmaMeters; /* Filtered Gaussian 1-sigma value for BeiDou to Glonass time bias uncertainty in meters */\n  uint32      q_FltSftOffsetSec;        /* SFT offset as computed by WLS in seconds */\n  uint32      q_FltSftOffsetSigmaSec;   /* Gaussian 1-sigma value for SFT offset in seconds */\n  uint32      q_FltClockDriftMps;       /* Clock drift (clock frequency bias) in meters per second */\n  uint32      q_FltClockDriftSigmaMps;  /* Gaussian 1-sigma value for clock drift in meters per second */\n  uint32      q_FltFilteredAlt;         /* Filtered height-above-ellipsoid altitude in meters as computed by WLS */\n  uint32      q_FltFilteredAltSigma;    /* Gaussian 1-sigma value for filtered height-above-ellipsoid altitude in meters */\n  uint32      q_FltRawAlt;              /* Raw height-above-ellipsoid altitude in meters as computed by WLS */\n  uint32      q_FltRawAltSigma;         /* Gaussian 1-sigma value for raw height-above-ellipsoid altitude in meters */\n  uint32   align_Flt[14];\n  uint32      q_FltPdop;                /* 3D position dilution of precision as computed from the unweighted\n  uint32      q_FltHdop;                /* Horizontal position dilution of precision as computed from the unweighted least-squares covariance matrix */\n  uint32      q_FltVdop;                /* Vertical position dilution of precision as computed from the unweighted least-squares covariance matrix */\n  uint8       u_EllipseConfidence;      /* Statistical measure of the confidence (percentage) associated with the uncertainty ellipse values */\n  uint32      q_FltEllipseAngle;        /* Angle of semimajor axis with respect to true North, with increasing angles moving clockwise from North. In units of degrees. */\n  uint32      q_FltEllipseSemimajorAxis;  /* Semimajor axis of final horizontal position uncertainty error ellipse.  In units of meters. */\n  uint32      q_FltEllipseSemiminorAxis;  /* Semiminor axis of final horizontal position uncertainty error ellipse.  In units of meters. */\n  uint32      q_FltPosSigmaVertical;    /* Gaussian 1-sigma value for final position height-above-ellipsoid altitude in meters */\n  uint8       u_HorizontalReliability;  /* Horizontal position reliability 0: Not set 1: Very Low 2: Low 3: Medium 4: High    */\n  uint8       u_VerticalReliability;    /* Vertical position reliability */\n  uint16      w_Reserved2;              /* Reserved memory field */\n  uint32      q_FltGnssHeadingRad;      /* User heading in radians derived from GNSS only solution  */\n  uint32      q_FltGnssHeadingUncRad;   /* User heading uncertainty in radians derived from GNSS only solution  */\n  uint32      q_SensorDataUsageMask;    /* Denotes which additional sensor data were used to compute this position fix.  BIT[0] 0x00000001 <96> Accelerometer BIT[1] 0x00000002 <96> Gyro 0x0000FFFC - Reserved A bit set to 1 indicates that certain fields as defined by the SENSOR_AIDING_MASK were aided with sensor data*/\n  uint32      q_SensorAidMask;         /* Denotes which component of the position report was assisted with additional sensors defined in SENSOR_DATA_USAGE_MASK BIT[0] 0x00000001 <96> Heading aided with sensor data BIT[1] 0x00000002 <96> Speed aided with sensor data BIT[2] 0x00000004 <96> Position aided with sensor data BIT[3] 0x00000008 <96> Velocity aided with sensor data 0xFFFFFFF0 <96> Reserved */\n  uint8       u_NumGpsSvsUsed;          /* The number of GPS SVs used in the fix */\n  uint8       u_TotalGpsSvs;            /* Total number of GPS SVs detected by searcher, including ones not used in position calculation */\n  uint8       u_NumGloSvsUsed;          /* The number of Glonass SVs used in the fix */\n  uint8       u_TotalGloSvs;            /* Total number of Glonass SVs detected by searcher, including ones not used in position calculation */\n  uint8       u_NumBdsSvsUsed;          /* The number of BeiDou SVs used in the fix */\n  uint8       u_TotalBdsSvs;            /* Total number of BeiDou SVs detected by searcher, including ones not used in position calculation */\n\"\"\" # noqa: E501\n\ndef name_to_camelcase(nam):\n  ret = []\n  i = 0\n  while i < len(nam):\n    if nam[i] == \"_\":\n      ret.append(nam[i+1].upper())\n      i += 2\n    else:\n      ret.append(nam[i])\n      i += 1\n  return ''.join(ret)\n\ndef parse_struct(ss):\n  st = \"<\"\n  nams = []\n  for l in ss.strip().split(\"\\n\"):\n    if len(l.strip()) == 0:\n      continue\n    typ, nam = l.split(\";\")[0].split()\n    #print(typ, nam)\n    if typ == \"float\" or '_Flt' in nam:\n      st += \"f\"\n    elif typ == \"double\" or '_Dbl' in nam:\n      st += \"d\"\n    elif typ in [\"uint8\", \"uint8_t\"]:\n      st += \"B\"\n    elif typ in [\"int8\", \"int8_t\"]:\n      st += \"b\"\n    elif typ in [\"uint32\", \"uint32_t\"]:\n      st += \"I\"\n    elif typ in [\"int32\", \"int32_t\"]:\n      st += \"i\"\n    elif typ in [\"uint16\", \"uint16_t\"]:\n      st += \"H\"\n    elif typ in [\"int16\", \"int16_t\"]:\n      st += \"h\"\n    elif typ in [\"uint64\", \"uint64_t\"]:\n      st += \"Q\"\n    else:\n      raise RuntimeError(f\"unknown type {typ}\")\n    if '[' in nam:\n      cnt = int(nam.split(\"[\")[1].split(\"]\")[0])\n      st += st[-1]*(cnt-1)\n      for i in range(cnt):\n        nams.append(\"%s[%d]\" % (nam.split(\"[\")[0], i))\n    else:\n      nams.append(nam)\n  return st, nams\n\ndef dict_unpacker(ss, camelcase = False):\n  st, nams = parse_struct(ss)\n  if camelcase:\n    nams = [name_to_camelcase(x) for x in nams]\n  sz = calcsize(st)\n  return lambda x: dict(zip(nams, unpack_from(st, x), strict=True)), sz\n\ndef relist(dat):\n  list_keys = set()\n  for key in dat.keys():\n    if '[' in key:\n      list_keys.add(key.split('[')[0])\n  list_dict = {}\n  for list_key in list_keys:\n    list_dict[list_key] = []\n    i = 0\n    while True:\n      key = list_key + f'[{i}]'\n      if key not in dat:\n        break\n      list_dict[list_key].append(dat[key])\n      del dat[key]\n      i += 1\n  return {**dat, **list_dict}\n", "system/qcomgpsd/modemdiag.py": "import select\nfrom serial import Serial\nfrom crcmod import mkCrcFun\nfrom struct import pack, unpack_from, calcsize\n\nclass ModemDiag:\n  def __init__(self):\n    self.serial = self.open_serial()\n    self.pend = b''\n\n  def open_serial(self):\n    serial = Serial(\"/dev/ttyUSB0\", baudrate=115200, rtscts=True, dsrdtr=True, timeout=0, exclusive=True)\n    serial.flush()\n    serial.reset_input_buffer()\n    serial.reset_output_buffer()\n    return serial\n\n  ccitt_crc16 = mkCrcFun(0x11021, initCrc=0, xorOut=0xffff)\n  ESCAPE_CHAR = b'\\x7d'\n  TRAILER_CHAR = b'\\x7e'\n\n  def hdlc_encapsulate(self, payload):\n    payload += pack('<H', ModemDiag.ccitt_crc16(payload))\n    payload = payload.replace(self.ESCAPE_CHAR, bytes([self.ESCAPE_CHAR[0], self.ESCAPE_CHAR[0] ^ 0x20]))\n    payload = payload.replace(self.TRAILER_CHAR, bytes([self.ESCAPE_CHAR[0], self.TRAILER_CHAR[0] ^ 0x20]))\n    payload += self.TRAILER_CHAR\n    return payload\n\n  def hdlc_decapsulate(self, payload):\n    assert len(payload) >= 3\n    assert payload[-1:] == self.TRAILER_CHAR\n    payload = payload[:-1]\n    payload = payload.replace(bytes([self.ESCAPE_CHAR[0], self.TRAILER_CHAR[0] ^ 0x20]), self.TRAILER_CHAR)\n    payload = payload.replace(bytes([self.ESCAPE_CHAR[0], self.ESCAPE_CHAR[0] ^ 0x20]), self.ESCAPE_CHAR)\n    assert payload[-2:] == pack('<H', ModemDiag.ccitt_crc16(payload[:-2]))\n    return payload[:-2]\n\n  def recv(self):\n    # self.serial.read_until makes tons of syscalls!\n    raw_payload = [self.pend]\n    while self.TRAILER_CHAR not in raw_payload[-1]:\n      select.select([self.serial.fd], [], [])\n      raw = self.serial.read(0x10000)\n      raw_payload.append(raw)\n    raw_payload = b''.join(raw_payload)\n    raw_payload, self.pend = raw_payload.split(self.TRAILER_CHAR, 1)\n    raw_payload += self.TRAILER_CHAR\n    unframed_message = self.hdlc_decapsulate(raw_payload)\n    return unframed_message[0], unframed_message[1:]\n\n  def send(self, packet_type, packet_payload):\n    self.serial.write(self.hdlc_encapsulate(bytes([packet_type]) + packet_payload))\n\n# *** end class ***\n\nDIAG_LOG_F = 16\nDIAG_LOG_CONFIG_F = 115\nLOG_CONFIG_RETRIEVE_ID_RANGES_OP = 1\nLOG_CONFIG_SET_MASK_OP = 3\nLOG_CONFIG_SUCCESS_S = 0\n\ndef send_recv(diag, packet_type, packet_payload):\n  diag.send(packet_type, packet_payload)\n  while 1:\n    opcode, payload = diag.recv()\n    if opcode != DIAG_LOG_F:\n      break\n  return opcode, payload\n\ndef setup_logs(diag, types_to_log):\n  opcode, payload = send_recv(diag, DIAG_LOG_CONFIG_F, pack('<3xI', LOG_CONFIG_RETRIEVE_ID_RANGES_OP))\n\n  header_spec = '<3xII'\n  operation, status = unpack_from(header_spec, payload)\n  assert operation == LOG_CONFIG_RETRIEVE_ID_RANGES_OP\n  assert status == LOG_CONFIG_SUCCESS_S\n\n  log_masks = unpack_from('<16I', payload, calcsize(header_spec))\n\n  for log_type, log_mask_bitsize in enumerate(log_masks):\n    if log_mask_bitsize:\n      log_mask = [0] * ((log_mask_bitsize+7)//8)\n      for i in range(log_mask_bitsize):\n        if ((log_type<<12)|i) in types_to_log:\n          log_mask[i//8] |= 1 << (i%8)\n      opcode, payload = send_recv(diag, DIAG_LOG_CONFIG_F, pack('<3xIII',\n          LOG_CONFIG_SET_MASK_OP,\n          log_type,\n          log_mask_bitsize\n      ) + bytes(log_mask))\n      assert opcode == DIAG_LOG_CONFIG_F\n      operation, status = unpack_from(header_spec, payload)\n      assert operation == LOG_CONFIG_SET_MASK_OP\n      assert status == LOG_CONFIG_SUCCESS_S\n", "system/manager/process.py": "import importlib\nimport os\nimport signal\nimport struct\nimport time\nimport subprocess\nfrom collections.abc import Callable, ValuesView\nfrom abc import ABC, abstractmethod\nfrom multiprocessing import Process\n\nfrom openpilot.common.threadname import setthreadname\n\nfrom cereal import car, log\nimport cereal.messaging as messaging\nimport openpilot.system.sentry as sentry\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.params import Params\nfrom openpilot.common.swaglog import cloudlog\n\nWATCHDOG_FN = \"/dev/shm/wd_\"\nENABLE_WATCHDOG = os.getenv(\"NO_WATCHDOG\") is None\n\n\ndef launcher(proc: str, name: str) -> None:\n  try:\n    # import the process\n    mod = importlib.import_module(proc)\n\n    # rename the process\n    setthreadname(proc)\n\n    # create new context since we forked\n    messaging.context = messaging.Context()\n\n    # add daemon name tag to logs\n    cloudlog.bind(daemon=name)\n    sentry.set_tag(\"daemon\", name)\n\n    # exec the process\n    mod.main()\n  except KeyboardInterrupt:\n    cloudlog.warning(f\"child {proc} got SIGINT\")\n  except Exception:\n    # can't install the crash handler because sys.excepthook doesn't play nice\n    # with threads, so catch it here.\n    sentry.capture_exception()\n    raise\n\n\ndef nativelauncher(pargs: list[str], cwd: str, name: str) -> None:\n  os.environ['MANAGER_DAEMON'] = name\n\n  # exec the process\n  os.chdir(cwd)\n  os.execvp(pargs[0], pargs)\n\n\ndef join_process(process: Process, timeout: float) -> None:\n  # Process().join(timeout) will hang due to a python 3 bug: https://bugs.python.org/issue28382\n  # We have to poll the exitcode instead\n  t = time.monotonic()\n  while time.monotonic() - t < timeout and process.exitcode is None:\n    time.sleep(0.001)\n\n\nclass ManagerProcess(ABC):\n  daemon = False\n  sigkill = False\n  should_run: Callable[[bool, Params, car.CarParams], bool]\n  proc: Process | None = None\n  enabled = True\n  name = \"\"\n\n  last_watchdog_time = 0\n  watchdog_max_dt: int | None = None\n  watchdog_seen = False\n  shutting_down = False\n\n  @abstractmethod\n  def prepare(self) -> None:\n    pass\n\n  @abstractmethod\n  def start(self) -> None:\n    pass\n\n  def restart(self) -> None:\n    self.stop(sig=signal.SIGKILL)\n    self.start()\n\n  def check_watchdog(self, started: bool) -> None:\n    if self.watchdog_max_dt is None or self.proc is None:\n      return\n\n    try:\n      fn = WATCHDOG_FN + str(self.proc.pid)\n      with open(fn, \"rb\") as f:\n        # TODO: why can't pylint find struct.unpack?\n        self.last_watchdog_time = struct.unpack('Q', f.read())[0]\n    except Exception:\n      pass\n\n    dt = time.monotonic() - self.last_watchdog_time / 1e9\n\n    if dt > self.watchdog_max_dt:\n      if self.watchdog_seen and ENABLE_WATCHDOG:\n        cloudlog.error(f\"Watchdog timeout for {self.name} (exitcode {self.proc.exitcode}) restarting ({started=})\")\n        self.restart()\n    else:\n      self.watchdog_seen = True\n\n  def stop(self, retry: bool = True, block: bool = True, sig: signal.Signals = None) -> int | None:\n    if self.proc is None:\n      return None\n\n    if self.proc.exitcode is None:\n      if not self.shutting_down:\n        cloudlog.info(f\"killing {self.name}\")\n        if sig is None:\n          sig = signal.SIGKILL if self.sigkill else signal.SIGINT\n        self.signal(sig)\n        self.shutting_down = True\n\n        if not block:\n          return None\n\n      join_process(self.proc, 5)\n\n      # If process failed to die send SIGKILL\n      if self.proc.exitcode is None and retry:\n        cloudlog.info(f\"killing {self.name} with SIGKILL\")\n        self.signal(signal.SIGKILL)\n        self.proc.join()\n\n    ret = self.proc.exitcode\n    cloudlog.info(f\"{self.name} is dead with {ret}\")\n\n    if self.proc.exitcode is not None:\n      self.shutting_down = False\n      self.proc = None\n\n    return ret\n\n  def signal(self, sig: int) -> None:\n    if self.proc is None:\n      return\n\n    # Don't signal if already exited\n    if self.proc.exitcode is not None and self.proc.pid is not None:\n      return\n\n    # Can't signal if we don't have a pid\n    if self.proc.pid is None:\n      return\n\n    cloudlog.info(f\"sending signal {sig} to {self.name}\")\n    os.kill(self.proc.pid, sig)\n\n  def get_process_state_msg(self):\n    state = log.ManagerState.ProcessState.new_message()\n    state.name = self.name\n    if self.proc:\n      state.running = self.proc.is_alive()\n      state.shouldBeRunning = self.proc is not None and not self.shutting_down\n      state.pid = self.proc.pid or 0\n      state.exitCode = self.proc.exitcode or 0\n    return state\n\n\nclass NativeProcess(ManagerProcess):\n  def __init__(self, name, cwd, cmdline, should_run, enabled=True, sigkill=False, watchdog_max_dt=None):\n    self.name = name\n    self.cwd = cwd\n    self.cmdline = cmdline\n    self.should_run = should_run\n    self.enabled = enabled\n    self.sigkill = sigkill\n    self.watchdog_max_dt = watchdog_max_dt\n    self.launcher = nativelauncher\n\n  def prepare(self) -> None:\n    pass\n\n  def start(self) -> None:\n    # In case we only tried a non blocking stop we need to stop it before restarting\n    if self.shutting_down:\n      self.stop()\n\n    if self.proc is not None:\n      return\n\n    cwd = os.path.join(BASEDIR, self.cwd)\n    cloudlog.info(f\"starting process {self.name}\")\n    self.proc = Process(name=self.name, target=self.launcher, args=(self.cmdline, cwd, self.name))\n    self.proc.start()\n    self.watchdog_seen = False\n    self.shutting_down = False\n\n\nclass PythonProcess(ManagerProcess):\n  def __init__(self, name, module, should_run, enabled=True, sigkill=False, watchdog_max_dt=None):\n    self.name = name\n    self.module = module\n    self.should_run = should_run\n    self.enabled = enabled\n    self.sigkill = sigkill\n    self.watchdog_max_dt = watchdog_max_dt\n    self.launcher = launcher\n\n  def prepare(self) -> None:\n    if self.enabled:\n      cloudlog.info(f\"preimporting {self.module}\")\n      importlib.import_module(self.module)\n\n  def start(self) -> None:\n    # In case we only tried a non blocking stop we need to stop it before restarting\n    if self.shutting_down:\n      self.stop()\n\n    if self.proc is not None:\n      return\n\n    cloudlog.info(f\"starting python {self.module}\")\n    self.proc = Process(name=self.name, target=self.launcher, args=(self.module, self.name))\n    self.proc.start()\n    self.watchdog_seen = False\n    self.shutting_down = False\n\n\nclass DaemonProcess(ManagerProcess):\n  \"\"\"Python process that has to stay running across manager restart.\n  This is used for athena so you don't lose SSH access when restarting manager.\"\"\"\n  def __init__(self, name, module, param_name, enabled=True):\n    self.name = name\n    self.module = module\n    self.param_name = param_name\n    self.enabled = enabled\n    self.params = None\n\n  @staticmethod\n  def should_run(started, params, CP):\n    return True\n\n  def prepare(self) -> None:\n    pass\n\n  def start(self) -> None:\n    if self.params is None:\n      self.params = Params()\n\n    pid = self.params.get(self.param_name, encoding='utf-8')\n    if pid is not None:\n      try:\n        os.kill(int(pid), 0)\n        with open(f'/proc/{pid}/cmdline') as f:\n          if self.module in f.read():\n            # daemon is running\n            return\n      except (OSError, FileNotFoundError):\n        # process is dead\n        pass\n\n    cloudlog.info(f\"starting daemon {self.name}\")\n    proc = subprocess.Popen(['python', '-m', self.module],\n                               stdin=open('/dev/null'),\n                               stdout=open('/dev/null', 'w'),\n                               stderr=open('/dev/null', 'w'),\n                               preexec_fn=os.setpgrp)\n\n    self.params.put(self.param_name, str(proc.pid))\n\n  def stop(self, retry=True, block=True, sig=None) -> None:\n    pass\n\n\ndef ensure_running(procs: ValuesView[ManagerProcess], started: bool, params=None, CP: car.CarParams=None,\n                   not_run: list[str] | None=None) -> list[ManagerProcess]:\n  if not_run is None:\n    not_run = []\n\n  running = []\n  for p in procs:\n    if p.enabled and p.name not in not_run and p.should_run(started, params, CP):\n      running.append(p)\n    else:\n      p.stop(block=False)\n\n    p.check_watchdog(started)\n\n  for p in running:\n    p.start()\n\n  return running\n", "system/manager/process_config.py": "import os\n\nfrom cereal import car\nfrom openpilot.common.params import Params\nfrom openpilot.system.hardware import PC, TICI\nfrom openpilot.system.manager.process import PythonProcess, NativeProcess, DaemonProcess\n\nWEBCAM = os.getenv(\"USE_WEBCAM\") is not None\n\ndef driverview(started: bool, params: Params, CP: car.CarParams) -> bool:\n  return started or params.get_bool(\"IsDriverViewEnabled\")\n\ndef notcar(started: bool, params: Params, CP: car.CarParams) -> bool:\n  return started and CP.notCar\n\ndef iscar(started: bool, params: Params, CP: car.CarParams) -> bool:\n  return started and not CP.notCar\n\ndef logging(started, params, CP: car.CarParams) -> bool:\n  run = (not CP.notCar) or not params.get_bool(\"DisableLogging\")\n  return started and run\n\ndef ublox_available() -> bool:\n  return os.path.exists('/dev/ttyHS0') and not os.path.exists('/persist/comma/use-quectel-gps')\n\ndef ublox(started, params, CP: car.CarParams) -> bool:\n  use_ublox = ublox_available()\n  if use_ublox != params.get_bool(\"UbloxAvailable\"):\n    params.put_bool(\"UbloxAvailable\", use_ublox)\n  return started and use_ublox\n\ndef qcomgps(started, params, CP: car.CarParams) -> bool:\n  return started and not ublox_available()\n\ndef always_run(started, params, CP: car.CarParams) -> bool:\n  return True\n\ndef only_onroad(started: bool, params, CP: car.CarParams) -> bool:\n  return started\n\ndef only_offroad(started, params, CP: car.CarParams) -> bool:\n  return not started\n\nprocs = [\n  DaemonProcess(\"manage_athenad\", \"system.athena.manage_athenad\", \"AthenadPid\"),\n\n  NativeProcess(\"camerad\", \"system/camerad\", [\"./camerad\"], driverview),\n  NativeProcess(\"logcatd\", \"system/logcatd\", [\"./logcatd\"], only_onroad),\n  NativeProcess(\"proclogd\", \"system/proclogd\", [\"./proclogd\"], only_onroad),\n  PythonProcess(\"logmessaged\", \"system.logmessaged\", always_run),\n  PythonProcess(\"micd\", \"system.micd\", iscar),\n  PythonProcess(\"timed\", \"system.timed\", always_run, enabled=not PC),\n\n  PythonProcess(\"dmonitoringmodeld\", \"selfdrive.modeld.dmonitoringmodeld\", driverview, enabled=(not PC or WEBCAM)),\n  NativeProcess(\"encoderd\", \"system/loggerd\", [\"./encoderd\"], only_onroad),\n  NativeProcess(\"stream_encoderd\", \"system/loggerd\", [\"./encoderd\", \"--stream\"], notcar),\n  NativeProcess(\"loggerd\", \"system/loggerd\", [\"./loggerd\"], logging),\n  NativeProcess(\"modeld\", \"selfdrive/modeld\", [\"./modeld\"], only_onroad),\n  NativeProcess(\"sensord\", \"system/sensord\", [\"./sensord\"], only_onroad, enabled=not PC),\n  NativeProcess(\"ui\", \"selfdrive/ui\", [\"./ui\"], always_run, watchdog_max_dt=(5 if not PC else None)),\n  PythonProcess(\"soundd\", \"selfdrive.ui.soundd\", only_onroad),\n  NativeProcess(\"locationd\", \"selfdrive/locationd\", [\"./locationd\"], only_onroad),\n  NativeProcess(\"pandad\", \"selfdrive/pandad\", [\"./pandad\"], always_run, enabled=False),\n  PythonProcess(\"calibrationd\", \"selfdrive.locationd.calibrationd\", only_onroad),\n  PythonProcess(\"torqued\", \"selfdrive.locationd.torqued\", only_onroad),\n  PythonProcess(\"controlsd\", \"selfdrive.controls.controlsd\", only_onroad),\n  PythonProcess(\"card\", \"selfdrive.car.card\", only_onroad),\n  PythonProcess(\"deleter\", \"system.loggerd.deleter\", always_run),\n  PythonProcess(\"dmonitoringd\", \"selfdrive.monitoring.dmonitoringd\", driverview, enabled=(not PC or WEBCAM)),\n  PythonProcess(\"qcomgpsd\", \"system.qcomgpsd.qcomgpsd\", qcomgps, enabled=TICI),\n  #PythonProcess(\"ugpsd\", \"system.ugpsd\", only_onroad, enabled=TICI),\n  PythonProcess(\"pandad\", \"selfdrive.pandad.pandad\", always_run),\n  PythonProcess(\"paramsd\", \"selfdrive.locationd.paramsd\", only_onroad),\n  NativeProcess(\"ubloxd\", \"system/ubloxd\", [\"./ubloxd\"], ublox, enabled=TICI),\n  PythonProcess(\"pigeond\", \"system.ubloxd.pigeond\", ublox, enabled=TICI),\n  PythonProcess(\"plannerd\", \"selfdrive.controls.plannerd\", only_onroad),\n  PythonProcess(\"radard\", \"selfdrive.controls.radard\", only_onroad),\n  PythonProcess(\"hardwared\", \"system.hardware.hardwared\", always_run),\n  PythonProcess(\"tombstoned\", \"system.tombstoned\", always_run, enabled=not PC),\n  PythonProcess(\"updated\", \"system.updated.updated\", only_offroad, enabled=not PC),\n  PythonProcess(\"uploader\", \"system.loggerd.uploader\", always_run),\n  PythonProcess(\"statsd\", \"system.statsd\", always_run),\n\n  # debug procs\n  NativeProcess(\"bridge\", \"cereal/messaging\", [\"./bridge\"], notcar),\n  PythonProcess(\"webrtcd\", \"system.webrtc.webrtcd\", notcar),\n  PythonProcess(\"webjoystick\", \"tools.bodyteleop.web\", notcar),\n]\n\nmanaged_processes = {p.name: p for p in procs}\n", "system/manager/manager.py": "#!/usr/bin/env python3\nimport datetime\nimport os\nimport signal\nimport sys\nimport traceback\n\nfrom cereal import log\nimport cereal.messaging as messaging\nimport openpilot.system.sentry as sentry\nfrom openpilot.common.params import Params, ParamKeyType\nfrom openpilot.common.text_window import TextWindow\nfrom openpilot.system.hardware import HARDWARE, PC\nfrom openpilot.system.manager.helpers import unblock_stdout, write_onroad_params, save_bootlog\nfrom openpilot.system.manager.process import ensure_running\nfrom openpilot.system.manager.process_config import managed_processes\nfrom openpilot.system.athena.registration import register, UNREGISTERED_DONGLE_ID\nfrom openpilot.common.swaglog import cloudlog, add_file_handler\nfrom openpilot.system.version import get_build_metadata, terms_version, training_version\n\n\n\ndef manager_init() -> None:\n  save_bootlog()\n\n  build_metadata = get_build_metadata()\n\n  params = Params()\n  params.clear_all(ParamKeyType.CLEAR_ON_MANAGER_START)\n  params.clear_all(ParamKeyType.CLEAR_ON_ONROAD_TRANSITION)\n  params.clear_all(ParamKeyType.CLEAR_ON_OFFROAD_TRANSITION)\n  if build_metadata.release_channel:\n    params.clear_all(ParamKeyType.DEVELOPMENT_ONLY)\n\n  default_params: list[tuple[str, str | bytes]] = [\n    (\"CompletedTrainingVersion\", \"0\"),\n    (\"DisengageOnAccelerator\", \"0\"),\n    (\"GsmMetered\", \"1\"),\n    (\"HasAcceptedTerms\", \"0\"),\n    (\"LanguageSetting\", \"main_en\"),\n    (\"OpenpilotEnabledToggle\", \"1\"),\n    (\"LongitudinalPersonality\", str(log.LongitudinalPersonality.standard)),\n  ]\n  if not PC:\n    default_params.append((\"LastUpdateTime\", datetime.datetime.now(datetime.UTC).replace(tzinfo=None).isoformat().encode('utf8')))\n\n  if params.get_bool(\"RecordFrontLock\"):\n    params.put_bool(\"RecordFront\", True)\n\n  # set unset params\n  for k, v in default_params:\n    if params.get(k) is None:\n      params.put(k, v)\n\n  # Create folders needed for msgq\n  try:\n    os.mkdir(\"/dev/shm\")\n  except FileExistsError:\n    pass\n  except PermissionError:\n    print(\"WARNING: failed to make /dev/shm\")\n\n  # set version params\n  params.put(\"Version\", build_metadata.openpilot.version)\n  params.put(\"TermsVersion\", terms_version)\n  params.put(\"TrainingVersion\", training_version)\n  params.put(\"GitCommit\", build_metadata.openpilot.git_commit)\n  params.put(\"GitCommitDate\", build_metadata.openpilot.git_commit_date)\n  params.put(\"GitBranch\", build_metadata.channel)\n  params.put(\"GitRemote\", build_metadata.openpilot.git_origin)\n  params.put_bool(\"IsTestedBranch\", build_metadata.tested_channel)\n  params.put_bool(\"IsReleaseBranch\", build_metadata.release_channel)\n\n  # set dongle id\n  reg_res = register(show_spinner=True)\n  if reg_res:\n    dongle_id = reg_res\n  else:\n    serial = params.get(\"HardwareSerial\")\n    raise Exception(f\"Registration failed for device {serial}\")\n  os.environ['DONGLE_ID'] = dongle_id  # Needed for swaglog\n  os.environ['GIT_ORIGIN'] = build_metadata.openpilot.git_normalized_origin # Needed for swaglog\n  os.environ['GIT_BRANCH'] = build_metadata.channel # Needed for swaglog\n  os.environ['GIT_COMMIT'] = build_metadata.openpilot.git_commit # Needed for swaglog\n\n  if not build_metadata.openpilot.is_dirty:\n    os.environ['CLEAN'] = '1'\n\n  # init logging\n  sentry.init(sentry.SentryProject.SELFDRIVE)\n  cloudlog.bind_global(dongle_id=dongle_id,\n                       version=build_metadata.openpilot.version,\n                       origin=build_metadata.openpilot.git_normalized_origin,\n                       branch=build_metadata.channel,\n                       commit=build_metadata.openpilot.git_commit,\n                       dirty=build_metadata.openpilot.is_dirty,\n                       device=HARDWARE.get_device_type())\n\n  # preimport all processes\n  for p in managed_processes.values():\n    p.prepare()\n\n\ndef manager_cleanup() -> None:\n  # send signals to kill all procs\n  for p in managed_processes.values():\n    p.stop(block=False)\n\n  # ensure all are killed\n  for p in managed_processes.values():\n    p.stop(block=True)\n\n  cloudlog.info(\"everything is dead\")\n\n\ndef manager_thread() -> None:\n  cloudlog.bind(daemon=\"manager\")\n  cloudlog.info(\"manager start\")\n  cloudlog.info({\"environ\": os.environ})\n\n  params = Params()\n\n  ignore: list[str] = []\n  if params.get(\"DongleId\", encoding='utf8') in (None, UNREGISTERED_DONGLE_ID):\n    ignore += [\"manage_athenad\", \"uploader\"]\n  if os.getenv(\"NOBOARD\") is not None:\n    ignore.append(\"pandad\")\n  ignore += [x for x in os.getenv(\"BLOCK\", \"\").split(\",\") if len(x) > 0]\n\n  sm = messaging.SubMaster(['deviceState', 'carParams'], poll='deviceState')\n  pm = messaging.PubMaster(['managerState'])\n\n  write_onroad_params(False, params)\n  ensure_running(managed_processes.values(), False, params=params, CP=sm['carParams'], not_run=ignore)\n\n  started_prev = False\n\n  while True:\n    sm.update(1000)\n\n    started = sm['deviceState'].started\n\n    if started and not started_prev:\n      params.clear_all(ParamKeyType.CLEAR_ON_ONROAD_TRANSITION)\n    elif not started and started_prev:\n      params.clear_all(ParamKeyType.CLEAR_ON_OFFROAD_TRANSITION)\n\n    # update onroad params, which drives pandad's safety setter thread\n    if started != started_prev:\n      write_onroad_params(started, params)\n\n    started_prev = started\n\n    ensure_running(managed_processes.values(), started, params=params, CP=sm['carParams'], not_run=ignore)\n\n    running = ' '.join(\"{}{}\\u001b[0m\".format(\"\\u001b[32m\" if p.proc.is_alive() else \"\\u001b[31m\", p.name)\n                       for p in managed_processes.values() if p.proc)\n    print(running)\n    cloudlog.debug(running)\n\n    # send managerState\n    msg = messaging.new_message('managerState', valid=True)\n    msg.managerState.processes = [p.get_process_state_msg() for p in managed_processes.values()]\n    pm.send('managerState', msg)\n\n    # Exit main loop when uninstall/shutdown/reboot is needed\n    shutdown = False\n    for param in (\"DoUninstall\", \"DoShutdown\", \"DoReboot\"):\n      if params.get_bool(param):\n        shutdown = True\n        params.put(\"LastManagerExitReason\", f\"{param} {datetime.datetime.now()}\")\n        cloudlog.warning(f\"Shutting down manager - {param} set\")\n\n    if shutdown:\n      break\n\n\ndef main() -> None:\n  manager_init()\n  if os.getenv(\"PREPAREONLY\") is not None:\n    return\n\n  # SystemExit on sigterm\n  signal.signal(signal.SIGTERM, lambda signum, frame: sys.exit(1))\n\n  try:\n    manager_thread()\n  except Exception:\n    traceback.print_exc()\n    sentry.capture_exception()\n  finally:\n    manager_cleanup()\n\n  params = Params()\n  if params.get_bool(\"DoUninstall\"):\n    cloudlog.warning(\"uninstalling\")\n    HARDWARE.uninstall()\n  elif params.get_bool(\"DoReboot\"):\n    cloudlog.warning(\"reboot\")\n    HARDWARE.reboot()\n  elif params.get_bool(\"DoShutdown\"):\n    cloudlog.warning(\"shutdown\")\n    HARDWARE.shutdown()\n\n\nif __name__ == \"__main__\":\n  unblock_stdout()\n\n  try:\n    main()\n  except KeyboardInterrupt:\n    print(\"got CTRL-C, exiting\")\n  except Exception:\n    add_file_handler(cloudlog)\n    cloudlog.exception(\"Manager failed to start\")\n\n    try:\n      managed_processes['ui'].stop()\n    except Exception:\n      pass\n\n    # Show last 3 lines of traceback\n    error = traceback.format_exc(-3)\n    error = \"Manager failed to start\\n\\n\" + error\n    with TextWindow(error) as t:\n      t.wait_for_exit()\n\n    raise\n\n  # manual exit because we are forked\n  sys.exit(0)\n", "system/manager/helpers.py": "import errno\nimport fcntl\nimport os\nimport sys\nimport pathlib\nimport shutil\nimport signal\nimport subprocess\nimport tempfile\nimport threading\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.params import Params\n\ndef unblock_stdout() -> None:\n  # get a non-blocking stdout\n  child_pid, child_pty = os.forkpty()\n  if child_pid != 0:  # parent\n\n    # child is in its own process group, manually pass kill signals\n    signal.signal(signal.SIGINT, lambda signum, frame: os.kill(child_pid, signal.SIGINT))\n    signal.signal(signal.SIGTERM, lambda signum, frame: os.kill(child_pid, signal.SIGTERM))\n\n    fcntl.fcntl(sys.stdout, fcntl.F_SETFL, fcntl.fcntl(sys.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)\n\n    while True:\n      try:\n        dat = os.read(child_pty, 4096)\n      except OSError as e:\n        if e.errno == errno.EIO:\n          break\n        continue\n\n      if not dat:\n        break\n\n      try:\n        sys.stdout.write(dat.decode('utf8'))\n      except (OSError, UnicodeDecodeError):\n        pass\n\n    # os.wait() returns a tuple with the pid and a 16 bit value\n    # whose low byte is the signal number and whose high byte is the exit status\n    exit_status = os.wait()[1] >> 8\n    os._exit(exit_status)\n\n\ndef write_onroad_params(started, params):\n  params.put_bool(\"IsOnroad\", started)\n  params.put_bool(\"IsOffroad\", not started)\n\n\ndef save_bootlog():\n  # copy current params\n  tmp = tempfile.mkdtemp()\n  params_dirname = pathlib.Path(Params().get_param_path()).name\n  params_dir = os.path.join(tmp, params_dirname)\n  shutil.copytree(Params().get_param_path(), params_dir, dirs_exist_ok=True)\n\n  def fn(tmpdir):\n    env = os.environ.copy()\n    env['PARAMS_COPY_PATH'] = tmpdir\n    subprocess.call(\"./bootlog\", cwd=os.path.join(BASEDIR, \"system/loggerd\"), env=env)\n    shutil.rmtree(tmpdir)\n  t = threading.Thread(target=fn, args=(tmp, ))\n  t.daemon = True\n  t.start()\n", "system/manager/build.py": "#!/usr/bin/env python3\nimport os\nimport subprocess\nfrom pathlib import Path\n\n# NOTE: Do NOT import anything here that needs be built (e.g. params)\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.spinner import Spinner\nfrom openpilot.common.text_window import TextWindow\nfrom openpilot.system.hardware import AGNOS\nfrom openpilot.common.swaglog import cloudlog, add_file_handler\nfrom openpilot.system.version import get_build_metadata\n\nMAX_CACHE_SIZE = 4e9 if \"CI\" in os.environ else 2e9\nCACHE_DIR = Path(\"/data/scons_cache\" if AGNOS else \"/tmp/scons_cache\")\n\nTOTAL_SCONS_NODES = 2820\nMAX_BUILD_PROGRESS = 100\n\ndef build(spinner: Spinner, dirty: bool = False, minimal: bool = False) -> None:\n  env = os.environ.copy()\n  env['SCONS_PROGRESS'] = \"1\"\n  nproc = os.cpu_count()\n  if nproc is None:\n    nproc = 2\n\n  extra_args = [\"--minimal\"] if minimal else []\n\n  # building with all cores can result in using too\n  # much memory, so retry with less parallelism\n  compile_output: list[bytes] = []\n  for n in (nproc, nproc/2, 1):\n    compile_output.clear()\n    scons: subprocess.Popen = subprocess.Popen([\"scons\", f\"-j{int(n)}\", \"--cache-populate\", *extra_args], cwd=BASEDIR, env=env, stderr=subprocess.PIPE)\n    assert scons.stderr is not None\n\n    # Read progress from stderr and update spinner\n    while scons.poll() is None:\n      try:\n        line = scons.stderr.readline()\n        if line is None:\n          continue\n        line = line.rstrip()\n\n        prefix = b'progress: '\n        if line.startswith(prefix):\n          i = int(line[len(prefix):])\n          spinner.update_progress(MAX_BUILD_PROGRESS * min(1., i / TOTAL_SCONS_NODES), 100.)\n        elif len(line):\n          compile_output.append(line)\n          print(line.decode('utf8', 'replace'))\n      except Exception:\n        pass\n\n    if scons.returncode == 0:\n      break\n\n  if scons.returncode != 0:\n    # Read remaining output\n    if scons.stderr is not None:\n      compile_output += scons.stderr.read().split(b'\\n')\n\n    # Build failed log errors\n    error_s = b\"\\n\".join(compile_output).decode('utf8', 'replace')\n    add_file_handler(cloudlog)\n    cloudlog.error(\"scons build failed\\n\" + error_s)\n\n    # Show TextWindow\n    spinner.close()\n    if not os.getenv(\"CI\"):\n      with TextWindow(\"openpilot failed to build\\n \\n\" + error_s) as t:\n        t.wait_for_exit()\n    exit(1)\n\n  # enforce max cache size\n  cache_files = [f for f in CACHE_DIR.rglob('*') if f.is_file()]\n  cache_files.sort(key=lambda f: f.stat().st_mtime)\n  cache_size = sum(f.stat().st_size for f in cache_files)\n  for f in cache_files:\n    if cache_size < MAX_CACHE_SIZE:\n      break\n    cache_size -= f.stat().st_size\n    f.unlink()\n\n\nif __name__ == \"__main__\":\n  spinner = Spinner()\n  spinner.update_progress(0, 100)\n  build_metadata = get_build_metadata()\n  build(spinner, build_metadata.openpilot.is_dirty, minimal = AGNOS)\n", "system/manager/__init__.py": "", "system/athena/manage_athenad.py": "#!/usr/bin/env python3\n\nimport time\nfrom multiprocessing import Process\n\nfrom openpilot.common.params import Params\nfrom openpilot.system.manager.process import launcher\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.hardware import HARDWARE\nfrom openpilot.system.version import get_build_metadata\n\nATHENA_MGR_PID_PARAM = \"AthenadPid\"\n\n\ndef main():\n  params = Params()\n  dongle_id = params.get(\"DongleId\").decode('utf-8')\n  build_metadata = get_build_metadata()\n\n  cloudlog.bind_global(dongle_id=dongle_id,\n                       version=build_metadata.openpilot.version,\n                       origin=build_metadata.openpilot.git_normalized_origin,\n                       branch=build_metadata.channel,\n                       commit=build_metadata.openpilot.git_commit,\n                       dirty=build_metadata.openpilot.is_dirty,\n                       device=HARDWARE.get_device_type())\n\n  try:\n    while 1:\n      cloudlog.info(\"starting athena daemon\")\n      proc = Process(name='athenad', target=launcher, args=('system.athena.athenad', 'athenad'))\n      proc.start()\n      proc.join()\n      cloudlog.event(\"athenad exited\", exitcode=proc.exitcode)\n      time.sleep(5)\n  except Exception:\n    cloudlog.exception(\"manage_athenad.exception\")\n  finally:\n    params.remove(ATHENA_MGR_PID_PARAM)\n\n\nif __name__ == '__main__':\n  main()\n", "system/athena/athenad.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport base64\nimport bz2\nimport hashlib\nimport io\nimport json\nimport os\nimport queue\nimport random\nimport select\nimport socket\nimport sys\nimport tempfile\nimport threading\nimport time\nfrom dataclasses import asdict, dataclass, replace\nfrom datetime import datetime\nfrom functools import partial\nfrom queue import Queue\nfrom typing import cast\nfrom collections.abc import Callable\n\nimport requests\nfrom jsonrpc import JSONRPCResponseManager, dispatcher\nfrom websocket import (ABNF, WebSocket, WebSocketException, WebSocketTimeoutException,\n                       create_connection)\n\nimport cereal.messaging as messaging\nfrom cereal import log\nfrom cereal.services import SERVICE_LIST\nfrom openpilot.common.api import Api\nfrom openpilot.common.file_helpers import CallbackReader\nfrom openpilot.common.params import Params\nfrom openpilot.common.realtime import set_core_affinity\nfrom openpilot.system.hardware import HARDWARE, PC\nfrom openpilot.system.loggerd.xattr_cache import getxattr, setxattr\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.system.version import get_build_metadata\nfrom openpilot.system.hardware.hw import Paths\n\n\nATHENA_HOST = os.getenv('ATHENA_HOST', 'wss://athena.comma.ai')\nHANDLER_THREADS = int(os.getenv('HANDLER_THREADS', \"4\"))\nLOCAL_PORT_WHITELIST = {8022}\n\nLOG_ATTR_NAME = 'user.upload'\nLOG_ATTR_VALUE_MAX_UNIX_TIME = int.to_bytes(2147483647, 4, sys.byteorder)\nRECONNECT_TIMEOUT_S = 70\n\nRETRY_DELAY = 10  # seconds\nMAX_RETRY_COUNT = 30  # Try for at most 5 minutes if upload fails immediately\nMAX_AGE = 31 * 24 * 3600  # seconds\nWS_FRAME_SIZE = 4096\n\nNetworkType = log.DeviceState.NetworkType\n\nUploadFileDict = dict[str, str | int | float | bool]\nUploadItemDict = dict[str, str | bool | int | float | dict[str, str]]\n\nUploadFilesToUrlResponse = dict[str, int | list[UploadItemDict] | list[str]]\n\n\n@dataclass\nclass UploadFile:\n  fn: str\n  url: str\n  headers: dict[str, str]\n  allow_cellular: bool\n\n  @classmethod\n  def from_dict(cls, d: dict) -> UploadFile:\n    return cls(d.get(\"fn\", \"\"), d.get(\"url\", \"\"), d.get(\"headers\", {}), d.get(\"allow_cellular\", False))\n\n\n@dataclass\nclass UploadItem:\n  path: str\n  url: str\n  headers: dict[str, str]\n  created_at: int\n  id: str | None\n  retry_count: int = 0\n  current: bool = False\n  progress: float = 0\n  allow_cellular: bool = False\n\n  @classmethod\n  def from_dict(cls, d: dict) -> UploadItem:\n    return cls(d[\"path\"], d[\"url\"], d[\"headers\"], d[\"created_at\"], d[\"id\"], d[\"retry_count\"], d[\"current\"],\n               d[\"progress\"], d[\"allow_cellular\"])\n\n\ndispatcher[\"echo\"] = lambda s: s\nrecv_queue: Queue[str] = queue.Queue()\nsend_queue: Queue[str] = queue.Queue()\nupload_queue: Queue[UploadItem] = queue.Queue()\nlow_priority_send_queue: Queue[str] = queue.Queue()\nlog_recv_queue: Queue[str] = queue.Queue()\ncancelled_uploads: set[str] = set()\n\ncur_upload_items: dict[int, UploadItem | None] = {}\n\n\ndef strip_bz2_extension(fn: str) -> str:\n  if fn.endswith('.bz2'):\n    return fn[:-4]\n  return fn\n\n\nclass AbortTransferException(Exception):\n  pass\n\n\nclass UploadQueueCache:\n\n  @staticmethod\n  def initialize(upload_queue: Queue[UploadItem]) -> None:\n    try:\n      upload_queue_json = Params().get(\"AthenadUploadQueue\")\n      if upload_queue_json is not None:\n        for item in json.loads(upload_queue_json):\n          upload_queue.put(UploadItem.from_dict(item))\n    except Exception:\n      cloudlog.exception(\"athena.UploadQueueCache.initialize.exception\")\n\n  @staticmethod\n  def cache(upload_queue: Queue[UploadItem]) -> None:\n    try:\n      queue: list[UploadItem | None] = list(upload_queue.queue)\n      items = [asdict(i) for i in queue if i is not None and (i.id not in cancelled_uploads)]\n      Params().put(\"AthenadUploadQueue\", json.dumps(items))\n    except Exception:\n      cloudlog.exception(\"athena.UploadQueueCache.cache.exception\")\n\n\ndef handle_long_poll(ws: WebSocket, exit_event: threading.Event | None) -> None:\n  end_event = threading.Event()\n\n  threads = [\n    threading.Thread(target=ws_manage, args=(ws, end_event), name='ws_manage'),\n    threading.Thread(target=ws_recv, args=(ws, end_event), name='ws_recv'),\n    threading.Thread(target=ws_send, args=(ws, end_event), name='ws_send'),\n    threading.Thread(target=upload_handler, args=(end_event,), name='upload_handler'),\n    threading.Thread(target=log_handler, args=(end_event,), name='log_handler'),\n    threading.Thread(target=stat_handler, args=(end_event,), name='stat_handler'),\n  ] + [\n    threading.Thread(target=jsonrpc_handler, args=(end_event,), name=f'worker_{x}')\n    for x in range(HANDLER_THREADS)\n  ]\n\n  for thread in threads:\n    thread.start()\n  try:\n    while not end_event.wait(0.1):\n      if exit_event is not None and exit_event.is_set():\n        end_event.set()\n  except (KeyboardInterrupt, SystemExit):\n    end_event.set()\n    raise\n  finally:\n    for thread in threads:\n      cloudlog.debug(f\"athena.joining {thread.name}\")\n      thread.join()\n\n\ndef jsonrpc_handler(end_event: threading.Event) -> None:\n  dispatcher[\"startLocalProxy\"] = partial(startLocalProxy, end_event)\n  while not end_event.is_set():\n    try:\n      data = recv_queue.get(timeout=1)\n      if \"method\" in data:\n        cloudlog.event(\"athena.jsonrpc_handler.call_method\", data=data)\n        response = JSONRPCResponseManager.handle(data, dispatcher)\n        send_queue.put_nowait(response.json)\n      elif \"id\" in data and (\"result\" in data or \"error\" in data):\n        log_recv_queue.put_nowait(data)\n      else:\n        raise Exception(\"not a valid request or response\")\n    except queue.Empty:\n      pass\n    except Exception as e:\n      cloudlog.exception(\"athena jsonrpc handler failed\")\n      send_queue.put_nowait(json.dumps({\"error\": str(e)}))\n\n\ndef retry_upload(tid: int, end_event: threading.Event, increase_count: bool = True) -> None:\n  item = cur_upload_items[tid]\n  if item is not None and item.retry_count < MAX_RETRY_COUNT:\n    new_retry_count = item.retry_count + 1 if increase_count else item.retry_count\n\n    item = replace(\n      item,\n      retry_count=new_retry_count,\n      progress=0,\n      current=False\n    )\n    upload_queue.put_nowait(item)\n    UploadQueueCache.cache(upload_queue)\n\n    cur_upload_items[tid] = None\n\n    for _ in range(RETRY_DELAY):\n      time.sleep(1)\n      if end_event.is_set():\n        break\n\n\ndef cb(sm, item, tid, end_event: threading.Event, sz: int, cur: int) -> None:\n  # Abort transfer if connection changed to metered after starting upload\n  # or if athenad is shutting down to re-connect the websocket\n  sm.update(0)\n  metered = sm['deviceState'].networkMetered\n  if metered and (not item.allow_cellular):\n    raise AbortTransferException\n\n  if end_event.is_set():\n    raise AbortTransferException\n\n  cur_upload_items[tid] = replace(item, progress=cur / sz if sz else 1)\n\n\ndef upload_handler(end_event: threading.Event) -> None:\n  sm = messaging.SubMaster(['deviceState'])\n  tid = threading.get_ident()\n\n  while not end_event.is_set():\n    cur_upload_items[tid] = None\n\n    try:\n      cur_upload_items[tid] = item = replace(upload_queue.get(timeout=1), current=True)\n\n      if item.id in cancelled_uploads:\n        cancelled_uploads.remove(item.id)\n        continue\n\n      # Remove item if too old\n      age = datetime.now() - datetime.fromtimestamp(item.created_at / 1000)\n      if age.total_seconds() > MAX_AGE:\n        cloudlog.event(\"athena.upload_handler.expired\", item=item, error=True)\n        continue\n\n      # Check if uploading over metered connection is allowed\n      sm.update(0)\n      metered = sm['deviceState'].networkMetered\n      network_type = sm['deviceState'].networkType.raw\n      if metered and (not item.allow_cellular):\n        retry_upload(tid, end_event, False)\n        continue\n\n      try:\n        fn = item.path\n        try:\n          sz = os.path.getsize(fn)\n        except OSError:\n          sz = -1\n\n        cloudlog.event(\"athena.upload_handler.upload_start\", fn=fn, sz=sz, network_type=network_type, metered=metered, retry_count=item.retry_count)\n        response = _do_upload(item, partial(cb, sm, item, tid, end_event))\n\n        if response.status_code not in (200, 201, 401, 403, 412):\n          cloudlog.event(\"athena.upload_handler.retry\", status_code=response.status_code, fn=fn, sz=sz, network_type=network_type, metered=metered)\n          retry_upload(tid, end_event)\n        else:\n          cloudlog.event(\"athena.upload_handler.success\", fn=fn, sz=sz, network_type=network_type, metered=metered)\n\n        UploadQueueCache.cache(upload_queue)\n      except (requests.exceptions.Timeout, requests.exceptions.ConnectionError, requests.exceptions.SSLError):\n        cloudlog.event(\"athena.upload_handler.timeout\", fn=fn, sz=sz, network_type=network_type, metered=metered)\n        retry_upload(tid, end_event)\n      except AbortTransferException:\n        cloudlog.event(\"athena.upload_handler.abort\", fn=fn, sz=sz, network_type=network_type, metered=metered)\n        retry_upload(tid, end_event, False)\n\n    except queue.Empty:\n      pass\n    except Exception:\n      cloudlog.exception(\"athena.upload_handler.exception\")\n\n\ndef _do_upload(upload_item: UploadItem, callback: Callable = None) -> requests.Response:\n  path = upload_item.path\n  compress = False\n\n  # If file does not exist, but does exist without the .bz2 extension we will compress on the fly\n  if not os.path.exists(path) and os.path.exists(strip_bz2_extension(path)):\n    path = strip_bz2_extension(path)\n    compress = True\n\n  with open(path, \"rb\") as f:\n    content = f.read()\n    if compress:\n      cloudlog.event(\"athena.upload_handler.compress\", fn=path, fn_orig=upload_item.path)\n      content = bz2.compress(content)\n\n  with io.BytesIO(content) as data:\n    return requests.put(upload_item.url,\n                        data=CallbackReader(data, callback, len(content)) if callback else data,\n                        headers={**upload_item.headers, 'Content-Length': str(len(content))},\n                        timeout=30)\n\n\n# security: user should be able to request any message from their car\n@dispatcher.add_method\ndef getMessage(service: str, timeout: int = 1000) -> dict:\n  if service is None or service not in SERVICE_LIST:\n    raise Exception(\"invalid service\")\n\n  socket = messaging.sub_sock(service, timeout=timeout)\n  ret = messaging.recv_one(socket)\n\n  if ret is None:\n    raise TimeoutError\n\n  # this is because capnp._DynamicStructReader doesn't have typing information\n  return cast(dict, ret.to_dict())\n\n\n@dispatcher.add_method\ndef getVersion() -> dict[str, str]:\n  build_metadata = get_build_metadata()\n  return {\n    \"version\": build_metadata.openpilot.version,\n    \"remote\": build_metadata.openpilot.git_normalized_origin,\n    \"branch\": build_metadata.channel,\n    \"commit\": build_metadata.openpilot.git_commit,\n  }\n\n\ndef scan_dir(path: str, prefix: str) -> list[str]:\n  files = []\n  # only walk directories that match the prefix\n  # (glob and friends traverse entire dir tree)\n  with os.scandir(path) as i:\n    for e in i:\n      rel_path = os.path.relpath(e.path, Paths.log_root())\n      if e.is_dir(follow_symlinks=False):\n        # add trailing slash\n        rel_path = os.path.join(rel_path, '')\n        # if prefix is a partial dir name, current dir will start with prefix\n        # if prefix is a partial file name, prefix with start with dir name\n        if rel_path.startswith(prefix) or prefix.startswith(rel_path):\n          files.extend(scan_dir(e.path, prefix))\n      else:\n        if rel_path.startswith(prefix):\n          files.append(rel_path)\n  return files\n\n@dispatcher.add_method\ndef listDataDirectory(prefix='') -> list[str]:\n  return scan_dir(Paths.log_root(), prefix)\n\n\n@dispatcher.add_method\ndef uploadFileToUrl(fn: str, url: str, headers: dict[str, str]) -> UploadFilesToUrlResponse:\n  # this is because mypy doesn't understand that the decorator doesn't change the return type\n  response: UploadFilesToUrlResponse = uploadFilesToUrls([{\n    \"fn\": fn,\n    \"url\": url,\n    \"headers\": headers,\n  }])\n  return response\n\n\n@dispatcher.add_method\ndef uploadFilesToUrls(files_data: list[UploadFileDict]) -> UploadFilesToUrlResponse:\n  files = map(UploadFile.from_dict, files_data)\n\n  items: list[UploadItemDict] = []\n  failed: list[str] = []\n  for file in files:\n    if len(file.fn) == 0 or file.fn[0] == '/' or '..' in file.fn or len(file.url) == 0:\n      failed.append(file.fn)\n      continue\n\n    path = os.path.join(Paths.log_root(), file.fn)\n    if not os.path.exists(path) and not os.path.exists(strip_bz2_extension(path)):\n      failed.append(file.fn)\n      continue\n\n    # Skip item if already in queue\n    url = file.url.split('?')[0]\n    if any(url == item['url'].split('?')[0] for item in listUploadQueue()):\n      continue\n\n    item = UploadItem(\n      path=path,\n      url=file.url,\n      headers=file.headers,\n      created_at=int(time.time() * 1000),\n      id=None,\n      allow_cellular=file.allow_cellular,\n    )\n    upload_id = hashlib.sha1(str(item).encode()).hexdigest()\n    item = replace(item, id=upload_id)\n    upload_queue.put_nowait(item)\n    items.append(asdict(item))\n\n  UploadQueueCache.cache(upload_queue)\n\n  resp: UploadFilesToUrlResponse = {\"enqueued\": len(items), \"items\": items}\n  if failed:\n    resp[\"failed\"] = failed\n\n  return resp\n\n\n@dispatcher.add_method\ndef listUploadQueue() -> list[UploadItemDict]:\n  items = list(upload_queue.queue) + list(cur_upload_items.values())\n  return [asdict(i) for i in items if (i is not None) and (i.id not in cancelled_uploads)]\n\n\n@dispatcher.add_method\ndef cancelUpload(upload_id: str | list[str]) -> dict[str, int | str]:\n  if not isinstance(upload_id, list):\n    upload_id = [upload_id]\n\n  uploading_ids = {item.id for item in list(upload_queue.queue)}\n  cancelled_ids = uploading_ids.intersection(upload_id)\n  if len(cancelled_ids) == 0:\n    return {\"success\": 0, \"error\": \"not found\"}\n\n  cancelled_uploads.update(cancelled_ids)\n  return {\"success\": 1}\n\n@dispatcher.add_method\ndef setRouteViewed(route: str) -> dict[str, int | str]:\n  # maintain a list of the last 10 routes viewed in connect\n  params = Params()\n\n  r = params.get(\"AthenadRecentlyViewedRoutes\", encoding=\"utf8\")\n  routes = [] if r is None else r.split(\",\")\n  routes.append(route)\n\n  # remove duplicates\n  routes = list(dict.fromkeys(routes))\n\n  params.put(\"AthenadRecentlyViewedRoutes\", \",\".join(routes[-10:]))\n  return {\"success\": 1}\n\n\ndef startLocalProxy(global_end_event: threading.Event, remote_ws_uri: str, local_port: int) -> dict[str, int]:\n  try:\n    if local_port not in LOCAL_PORT_WHITELIST:\n      raise Exception(\"Requested local port not whitelisted\")\n\n    cloudlog.debug(\"athena.startLocalProxy.starting\")\n\n    dongle_id = Params().get(\"DongleId\").decode('utf8')\n    identity_token = Api(dongle_id).get_token()\n    ws = create_connection(remote_ws_uri,\n                           cookie=\"jwt=\" + identity_token,\n                           enable_multithread=True)\n\n    # Set TOS to keep connection responsive while under load.\n    # DSCP of 36/HDD_LINUX_AC_VI with the minimum delay flag\n    ws.sock.setsockopt(socket.IPPROTO_IP, socket.IP_TOS, 0x90)\n\n    ssock, csock = socket.socketpair()\n    local_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    local_sock.connect(('127.0.0.1', local_port))\n    local_sock.setblocking(False)\n\n    proxy_end_event = threading.Event()\n    threads = [\n      threading.Thread(target=ws_proxy_recv, args=(ws, local_sock, ssock, proxy_end_event, global_end_event)),\n      threading.Thread(target=ws_proxy_send, args=(ws, local_sock, csock, proxy_end_event))\n    ]\n    for thread in threads:\n      thread.start()\n\n    cloudlog.debug(\"athena.startLocalProxy.started\")\n    return {\"success\": 1}\n  except Exception as e:\n    cloudlog.exception(\"athenad.startLocalProxy.exception\")\n    raise e\n\n\n@dispatcher.add_method\ndef getPublicKey() -> str | None:\n  if not os.path.isfile(Paths.persist_root() + '/comma/id_rsa.pub'):\n    return None\n\n  with open(Paths.persist_root() + '/comma/id_rsa.pub') as f:\n    return f.read()\n\n\n@dispatcher.add_method\ndef getSshAuthorizedKeys() -> str:\n  return Params().get(\"GithubSshKeys\", encoding='utf8') or ''\n\n\n@dispatcher.add_method\ndef getGithubUsername() -> str:\n  return Params().get(\"GithubUsername\", encoding='utf8') or ''\n\n\n@dispatcher.add_method\ndef getSimInfo():\n  return HARDWARE.get_sim_info()\n\n\n@dispatcher.add_method\ndef getNetworkType():\n  return HARDWARE.get_network_type()\n\n\n@dispatcher.add_method\ndef getNetworkMetered() -> bool:\n  network_type = HARDWARE.get_network_type()\n  return HARDWARE.get_network_metered(network_type)\n\n\n@dispatcher.add_method\ndef getNetworks():\n  return HARDWARE.get_networks()\n\n\n@dispatcher.add_method\ndef takeSnapshot() -> str | dict[str, str] | None:\n  from openpilot.system.camerad.snapshot.snapshot import jpeg_write, snapshot\n  ret = snapshot()\n  if ret is not None:\n    def b64jpeg(x):\n      if x is not None:\n        f = io.BytesIO()\n        jpeg_write(f, x)\n        return base64.b64encode(f.getvalue()).decode(\"utf-8\")\n      else:\n        return None\n    return {'jpegBack': b64jpeg(ret[0]),\n            'jpegFront': b64jpeg(ret[1])}\n  else:\n    raise Exception(\"not available while camerad is started\")\n\n\ndef get_logs_to_send_sorted() -> list[str]:\n  # TODO: scan once then use inotify to detect file creation/deletion\n  curr_time = int(time.time())\n  logs = []\n  for log_entry in os.listdir(Paths.swaglog_root()):\n    log_path = os.path.join(Paths.swaglog_root(), log_entry)\n    time_sent = 0\n    try:\n      value = getxattr(log_path, LOG_ATTR_NAME)\n      if value is not None:\n        time_sent = int.from_bytes(value, sys.byteorder)\n    except (ValueError, TypeError):\n      pass\n    # assume send failed and we lost the response if sent more than one hour ago\n    if not time_sent or curr_time - time_sent > 3600:\n      logs.append(log_entry)\n  # excluding most recent (active) log file\n  return sorted(logs)[:-1]\n\n\ndef log_handler(end_event: threading.Event) -> None:\n  if PC:\n    return\n\n  log_files = []\n  last_scan = 0.\n  while not end_event.is_set():\n    try:\n      curr_scan = time.monotonic()\n      if curr_scan - last_scan > 10:\n        log_files = get_logs_to_send_sorted()\n        last_scan = curr_scan\n\n      # send one log\n      curr_log = None\n      if len(log_files) > 0:\n        log_entry = log_files.pop() # newest log file\n        cloudlog.debug(f\"athena.log_handler.forward_request {log_entry}\")\n        try:\n          curr_time = int(time.time())\n          log_path = os.path.join(Paths.swaglog_root(), log_entry)\n          setxattr(log_path, LOG_ATTR_NAME, int.to_bytes(curr_time, 4, sys.byteorder))\n          with open(log_path) as f:\n            jsonrpc = {\n              \"method\": \"forwardLogs\",\n              \"params\": {\n                \"logs\": f.read()\n              },\n              \"jsonrpc\": \"2.0\",\n              \"id\": log_entry\n            }\n            low_priority_send_queue.put_nowait(json.dumps(jsonrpc))\n            curr_log = log_entry\n        except OSError:\n          pass  # file could be deleted by log rotation\n\n      # wait for response up to ~100 seconds\n      # always read queue at least once to process any old responses that arrive\n      for _ in range(100):\n        if end_event.is_set():\n          break\n        try:\n          log_resp = json.loads(log_recv_queue.get(timeout=1))\n          log_entry = log_resp.get(\"id\")\n          log_success = \"result\" in log_resp and log_resp[\"result\"].get(\"success\")\n          cloudlog.debug(f\"athena.log_handler.forward_response {log_entry} {log_success}\")\n          if log_entry and log_success:\n            log_path = os.path.join(Paths.swaglog_root(), log_entry)\n            try:\n              setxattr(log_path, LOG_ATTR_NAME, LOG_ATTR_VALUE_MAX_UNIX_TIME)\n            except OSError:\n              pass  # file could be deleted by log rotation\n          if curr_log == log_entry:\n            break\n        except queue.Empty:\n          if curr_log is None:\n            break\n\n    except Exception:\n      cloudlog.exception(\"athena.log_handler.exception\")\n\n\ndef stat_handler(end_event: threading.Event) -> None:\n  STATS_DIR = Paths.stats_root()\n  while not end_event.is_set():\n    last_scan = 0.\n    curr_scan = time.monotonic()\n    try:\n      if curr_scan - last_scan > 10:\n        stat_filenames = list(filter(lambda name: not name.startswith(tempfile.gettempprefix()), os.listdir(STATS_DIR)))\n        if len(stat_filenames) > 0:\n          stat_path = os.path.join(STATS_DIR, stat_filenames[0])\n          with open(stat_path) as f:\n            jsonrpc = {\n              \"method\": \"storeStats\",\n              \"params\": {\n                \"stats\": f.read()\n              },\n              \"jsonrpc\": \"2.0\",\n              \"id\": stat_filenames[0]\n            }\n            low_priority_send_queue.put_nowait(json.dumps(jsonrpc))\n          os.remove(stat_path)\n        last_scan = curr_scan\n    except Exception:\n      cloudlog.exception(\"athena.stat_handler.exception\")\n    time.sleep(0.1)\n\n\ndef ws_proxy_recv(ws: WebSocket, local_sock: socket.socket, ssock: socket.socket, end_event: threading.Event, global_end_event: threading.Event) -> None:\n  while not (end_event.is_set() or global_end_event.is_set()):\n    try:\n      r = select.select((ws.sock,), (), (), 30)\n      if r[0]:\n        data = ws.recv()\n        if isinstance(data, str):\n          data = data.encode(\"utf-8\")\n        local_sock.sendall(data)\n    except WebSocketTimeoutException:\n      pass\n    except Exception:\n      cloudlog.exception(\"athenad.ws_proxy_recv.exception\")\n      break\n\n  cloudlog.debug(\"athena.ws_proxy_recv closing sockets\")\n  ssock.close()\n  local_sock.close()\n  ws.close()\n  cloudlog.debug(\"athena.ws_proxy_recv done closing sockets\")\n\n  end_event.set()\n\n\ndef ws_proxy_send(ws: WebSocket, local_sock: socket.socket, signal_sock: socket.socket, end_event: threading.Event) -> None:\n  while not end_event.is_set():\n    try:\n      r, _, _ = select.select((local_sock, signal_sock), (), ())\n      if r:\n        if r[0].fileno() == signal_sock.fileno():\n          # got end signal from ws_proxy_recv\n          end_event.set()\n          break\n        data = local_sock.recv(4096)\n        if not data:\n          # local_sock is dead\n          end_event.set()\n          break\n\n        ws.send(data, ABNF.OPCODE_BINARY)\n    except Exception:\n      cloudlog.exception(\"athenad.ws_proxy_send.exception\")\n      end_event.set()\n\n  cloudlog.debug(\"athena.ws_proxy_send closing sockets\")\n  signal_sock.close()\n  cloudlog.debug(\"athena.ws_proxy_send done closing sockets\")\n\n\ndef ws_recv(ws: WebSocket, end_event: threading.Event) -> None:\n  last_ping = int(time.monotonic() * 1e9)\n  while not end_event.is_set():\n    try:\n      opcode, data = ws.recv_data(control_frame=True)\n      if opcode in (ABNF.OPCODE_TEXT, ABNF.OPCODE_BINARY):\n        if opcode == ABNF.OPCODE_TEXT:\n          data = data.decode(\"utf-8\")\n        recv_queue.put_nowait(data)\n      elif opcode == ABNF.OPCODE_PING:\n        last_ping = int(time.monotonic() * 1e9)\n        Params().put(\"LastAthenaPingTime\", str(last_ping))\n    except WebSocketTimeoutException:\n      ns_since_last_ping = int(time.monotonic() * 1e9) - last_ping\n      if ns_since_last_ping > RECONNECT_TIMEOUT_S * 1e9:\n        cloudlog.exception(\"athenad.ws_recv.timeout\")\n        end_event.set()\n    except Exception:\n      cloudlog.exception(\"athenad.ws_recv.exception\")\n      end_event.set()\n\n\ndef ws_send(ws: WebSocket, end_event: threading.Event) -> None:\n  while not end_event.is_set():\n    try:\n      try:\n        data = send_queue.get_nowait()\n      except queue.Empty:\n        data = low_priority_send_queue.get(timeout=1)\n      for i in range(0, len(data), WS_FRAME_SIZE):\n        frame = data[i:i+WS_FRAME_SIZE]\n        last = i + WS_FRAME_SIZE >= len(data)\n        opcode = ABNF.OPCODE_TEXT if i == 0 else ABNF.OPCODE_CONT\n        ws.send_frame(ABNF.create_frame(frame, opcode, last))\n    except queue.Empty:\n      pass\n    except Exception:\n      cloudlog.exception(\"athenad.ws_send.exception\")\n      end_event.set()\n\n\ndef ws_manage(ws: WebSocket, end_event: threading.Event) -> None:\n  params = Params()\n  onroad_prev = None\n  sock = ws.sock\n\n  while True:\n    onroad = params.get_bool(\"IsOnroad\")\n    if onroad != onroad_prev:\n      onroad_prev = onroad\n\n      if sock is not None:\n        # While not sending data, onroad, we can expect to time out in 7 + (7 * 2) = 21s\n        #                         offroad, we can expect to time out in 30 + (10 * 3) = 60s\n        # FIXME: TCP_USER_TIMEOUT is effectively 2x for some reason (32s), so it's mostly unused\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_USER_TIMEOUT, 16000 if onroad else 0)\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 7 if onroad else 30)\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 7 if onroad else 10)\n        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 2 if onroad else 3)\n\n    if end_event.wait(5):\n      break\n\n\ndef backoff(retries: int) -> int:\n  return random.randrange(0, min(128, int(2 ** retries)))\n\n\ndef main(exit_event: threading.Event = None):\n  try:\n    set_core_affinity([0, 1, 2, 3])\n  except Exception:\n    cloudlog.exception(\"failed to set core affinity\")\n\n  params = Params()\n  dongle_id = params.get(\"DongleId\", encoding='utf-8')\n  UploadQueueCache.initialize(upload_queue)\n\n  ws_uri = ATHENA_HOST + \"/ws/v2/\" + dongle_id\n  api = Api(dongle_id)\n\n  conn_start = None\n  conn_retries = 0\n  while exit_event is None or not exit_event.is_set():\n    try:\n      if conn_start is None:\n        conn_start = time.monotonic()\n\n      cloudlog.event(\"athenad.main.connecting_ws\", ws_uri=ws_uri, retries=conn_retries)\n      ws = create_connection(ws_uri,\n                             cookie=\"jwt=\" + api.get_token(),\n                             enable_multithread=True,\n                             timeout=30.0)\n      cloudlog.event(\"athenad.main.connected_ws\", ws_uri=ws_uri, retries=conn_retries,\n                     duration=time.monotonic() - conn_start)\n      conn_start = None\n\n      conn_retries = 0\n      cur_upload_items.clear()\n\n      handle_long_poll(ws, exit_event)\n    except (KeyboardInterrupt, SystemExit):\n      break\n    except (ConnectionError, TimeoutError, WebSocketException):\n      conn_retries += 1\n      params.remove(\"LastAthenaPingTime\")\n    except Exception:\n      cloudlog.exception(\"athenad.main.exception\")\n\n      conn_retries += 1\n      params.remove(\"LastAthenaPingTime\")\n\n    time.sleep(backoff(conn_retries))\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/athena/__init__.py": "", "system/athena/registration.py": "#!/usr/bin/env python3\nimport time\nimport json\nimport jwt\nfrom pathlib import Path\n\nfrom datetime import datetime, timedelta, UTC\nfrom openpilot.common.api import api_get\nfrom openpilot.common.params import Params\nfrom openpilot.common.spinner import Spinner\nfrom openpilot.selfdrive.controls.lib.alertmanager import set_offroad_alert\nfrom openpilot.system.hardware import HARDWARE, PC\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.common.swaglog import cloudlog\n\n\nUNREGISTERED_DONGLE_ID = \"UnregisteredDevice\"\n\n\ndef is_registered_device() -> bool:\n  dongle = Params().get(\"DongleId\", encoding='utf-8')\n  return dongle not in (None, UNREGISTERED_DONGLE_ID)\n\n\ndef register(show_spinner=False) -> str | None:\n  params = Params()\n\n  IMEI = params.get(\"IMEI\", encoding='utf8')\n  HardwareSerial = params.get(\"HardwareSerial\", encoding='utf8')\n  dongle_id: str | None = params.get(\"DongleId\", encoding='utf8')\n  needs_registration = None in (IMEI, HardwareSerial, dongle_id)\n\n  pubkey = Path(Paths.persist_root()+\"/comma/id_rsa.pub\")\n  if not pubkey.is_file():\n    dongle_id = UNREGISTERED_DONGLE_ID\n    cloudlog.warning(f\"missing public key: {pubkey}\")\n  elif needs_registration:\n    if show_spinner:\n      spinner = Spinner()\n      spinner.update(\"registering device\")\n\n    # Create registration token, in the future, this key will make JWTs directly\n    with open(Paths.persist_root()+\"/comma/id_rsa.pub\") as f1, open(Paths.persist_root()+\"/comma/id_rsa\") as f2:\n      public_key = f1.read()\n      private_key = f2.read()\n\n    # Block until we get the imei\n    serial = HARDWARE.get_serial()\n    start_time = time.monotonic()\n    imei1: str | None = None\n    imei2: str | None = None\n    while imei1 is None and imei2 is None:\n      try:\n        imei1, imei2 = HARDWARE.get_imei(0), HARDWARE.get_imei(1)\n      except Exception:\n        cloudlog.exception(\"Error getting imei, trying again...\")\n        time.sleep(1)\n\n      if time.monotonic() - start_time > 60 and show_spinner:\n        spinner.update(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n\n    params.put(\"IMEI\", imei1)\n    params.put(\"HardwareSerial\", serial)\n\n    backoff = 0\n    start_time = time.monotonic()\n    while True:\n      try:\n        register_token = jwt.encode({'register': True, 'exp': datetime.now(UTC).replace(tzinfo=None) + timedelta(hours=1)}, private_key, algorithm='RS256')\n        cloudlog.info(\"getting pilotauth\")\n        resp = api_get(\"v2/pilotauth/\", method='POST', timeout=15,\n                       imei=imei1, imei2=imei2, serial=serial, public_key=public_key, register_token=register_token)\n\n        if resp.status_code in (402, 403):\n          cloudlog.info(f\"Unable to register device, got {resp.status_code}\")\n          dongle_id = UNREGISTERED_DONGLE_ID\n        else:\n          dongleauth = json.loads(resp.text)\n          dongle_id = dongleauth[\"dongle_id\"]\n        break\n      except Exception:\n        cloudlog.exception(\"failed to authenticate\")\n        backoff = min(backoff + 1, 15)\n        time.sleep(backoff)\n\n      if time.monotonic() - start_time > 60 and show_spinner:\n        spinner.update(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n\n    if show_spinner:\n      spinner.close()\n\n  if dongle_id:\n    params.put(\"DongleId\", dongle_id)\n    set_offroad_alert(\"Offroad_UnofficialHardware\", (dongle_id == UNREGISTERED_DONGLE_ID) and not PC)\n  return dongle_id\n\n\nif __name__ == \"__main__\":\n  print(register())\n", "system/updated/common.py": "import os\nimport pathlib\n\n\ndef get_consistent_flag(path: str) -> bool:\n  consistent_file = pathlib.Path(os.path.join(path, \".overlay_consistent\"))\n  return consistent_file.is_file()\n\ndef set_consistent_flag(path: str, consistent: bool) -> None:\n  os.sync()\n  consistent_file = pathlib.Path(os.path.join(path, \".overlay_consistent\"))\n  if consistent:\n    consistent_file.touch()\n  elif not consistent:\n    consistent_file.unlink(missing_ok=True)\n  os.sync()\n", "system/updated/updated.py": "#!/usr/bin/env python3\nimport os\nimport re\nimport datetime\nimport subprocess\nimport psutil\nimport shutil\nimport signal\nimport fcntl\nimport time\nimport threading\nfrom collections import defaultdict\nfrom pathlib import Path\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.params import Params\nfrom openpilot.common.time import system_time_valid\nfrom openpilot.common.markdown import parse_markdown\nfrom openpilot.common.swaglog import cloudlog\nfrom openpilot.selfdrive.controls.lib.alertmanager import set_offroad_alert\nfrom openpilot.system.hardware import AGNOS, HARDWARE\nfrom openpilot.system.version import get_build_metadata\n\nLOCK_FILE = os.getenv(\"UPDATER_LOCK_FILE\", \"/tmp/safe_staging_overlay.lock\")\nSTAGING_ROOT = os.getenv(\"UPDATER_STAGING_ROOT\", \"/data/safe_staging\")\n\nOVERLAY_UPPER = os.path.join(STAGING_ROOT, \"upper\")\nOVERLAY_METADATA = os.path.join(STAGING_ROOT, \"metadata\")\nOVERLAY_MERGED = os.path.join(STAGING_ROOT, \"merged\")\nFINALIZED = os.path.join(STAGING_ROOT, \"finalized\")\n\nOVERLAY_INIT = Path(os.path.join(BASEDIR, \".overlay_init\"))\n\nDAYS_NO_CONNECTIVITY_MAX = 14     # do not allow to engage after this many days\nDAYS_NO_CONNECTIVITY_PROMPT = 10  # send an offroad prompt after this many days\n\nclass UserRequest:\n  NONE = 0\n  CHECK = 1\n  FETCH = 2\n\nclass WaitTimeHelper:\n  def __init__(self):\n    self.ready_event = threading.Event()\n    self.user_request = UserRequest.NONE\n    signal.signal(signal.SIGHUP, self.update_now)\n    signal.signal(signal.SIGUSR1, self.check_now)\n\n  def update_now(self, signum: int, frame) -> None:\n    cloudlog.info(\"caught SIGHUP, attempting to downloading update\")\n    self.user_request = UserRequest.FETCH\n    self.ready_event.set()\n\n  def check_now(self, signum: int, frame) -> None:\n    cloudlog.info(\"caught SIGUSR1, checking for updates\")\n    self.user_request = UserRequest.CHECK\n    self.ready_event.set()\n\n  def sleep(self, t: float) -> None:\n    self.ready_event.wait(timeout=t)\n\ndef write_time_to_param(params, param) -> None:\n  t = datetime.datetime.now(datetime.UTC).replace(tzinfo=None)\n  params.put(param, t.isoformat().encode('utf8'))\n\ndef read_time_from_param(params, param) -> datetime.datetime | None:\n  t = params.get(param, encoding='utf8')\n  try:\n    return datetime.datetime.fromisoformat(t)\n  except (TypeError, ValueError):\n    pass\n  return None\n\ndef run(cmd: list[str], cwd: str = None) -> str:\n  return subprocess.check_output(cmd, cwd=cwd, stderr=subprocess.STDOUT, encoding='utf8')\n\n\ndef set_consistent_flag(consistent: bool) -> None:\n  os.sync()\n  consistent_file = Path(os.path.join(FINALIZED, \".overlay_consistent\"))\n  if consistent:\n    consistent_file.touch()\n  elif not consistent:\n    consistent_file.unlink(missing_ok=True)\n  os.sync()\n\ndef parse_release_notes(basedir: str) -> bytes:\n  try:\n    with open(os.path.join(basedir, \"RELEASES.md\"), \"rb\") as f:\n      r = f.read().split(b'\\n\\n', 1)[0]  # Slice latest release notes\n    try:\n      return bytes(parse_markdown(r.decode(\"utf-8\")), encoding=\"utf-8\")\n    except Exception:\n      return r + b\"\\n\"\n  except FileNotFoundError:\n    pass\n  except Exception:\n    cloudlog.exception(\"failed to parse release notes\")\n  return b\"\"\n\ndef setup_git_options(cwd: str) -> None:\n  # We sync FS object atimes (which NEOS doesn't use) and mtimes, but ctimes\n  # are outside user control. Make sure Git is set up to ignore system ctimes,\n  # because they change when we make hard links during finalize. Otherwise,\n  # there is a lot of unnecessary churn. This appears to be a common need on\n  # OSX as well: https://www.git-tower.com/blog/make-git-rebase-safe-on-osx/\n\n  # We are using copytree to copy the directory, which also changes\n  # inode numbers. Ignore those changes too.\n\n  # Set protocol to the new version (default after git 2.26) to reduce data\n  # usage on git fetch --dry-run from about 400KB to 18KB.\n  git_cfg = [\n    (\"core.trustctime\", \"false\"),\n    (\"core.checkStat\", \"minimal\"),\n    (\"protocol.version\", \"2\"),\n    (\"gc.auto\", \"0\"),\n    (\"gc.autoDetach\", \"false\"),\n  ]\n  for option, value in git_cfg:\n    run([\"git\", \"config\", option, value], cwd)\n\n\ndef dismount_overlay() -> None:\n  if os.path.ismount(OVERLAY_MERGED):\n    cloudlog.info(\"unmounting existing overlay\")\n    run([\"sudo\", \"umount\", \"-l\", OVERLAY_MERGED])\n\n\ndef init_overlay() -> None:\n\n  # Re-create the overlay if BASEDIR/.git has changed since we created the overlay\n  if OVERLAY_INIT.is_file() and os.path.ismount(OVERLAY_MERGED):\n    git_dir_path = os.path.join(BASEDIR, \".git\")\n    new_files = run([\"find\", git_dir_path, \"-newer\", str(OVERLAY_INIT)])\n    if not len(new_files.splitlines()):\n      # A valid overlay already exists\n      return\n    else:\n      cloudlog.info(\".git directory changed, recreating overlay\")\n\n  cloudlog.info(\"preparing new safe staging area\")\n\n  params = Params()\n  params.put_bool(\"UpdateAvailable\", False)\n  set_consistent_flag(False)\n  dismount_overlay()\n  run([\"sudo\", \"rm\", \"-rf\", STAGING_ROOT])\n  if os.path.isdir(STAGING_ROOT):\n    shutil.rmtree(STAGING_ROOT)\n\n  for dirname in [STAGING_ROOT, OVERLAY_UPPER, OVERLAY_METADATA, OVERLAY_MERGED]:\n    os.mkdir(dirname, 0o755)\n\n  if os.lstat(BASEDIR).st_dev != os.lstat(OVERLAY_MERGED).st_dev:\n    raise RuntimeError(\"base and overlay merge directories are on different filesystems; not valid for overlay FS!\")\n\n  # Leave a timestamped canary in BASEDIR to check at startup. The device clock\n  # should be correct by the time we get here. If the init file disappears, or\n  # critical mtimes in BASEDIR are newer than .overlay_init, continue.sh can\n  # assume that BASEDIR has used for local development or otherwise modified,\n  # and skips the update activation attempt.\n  consistent_file = Path(os.path.join(BASEDIR, \".overlay_consistent\"))\n  if consistent_file.is_file():\n    consistent_file.unlink()\n  OVERLAY_INIT.touch()\n\n  os.sync()\n  overlay_opts = f\"lowerdir={BASEDIR},upperdir={OVERLAY_UPPER},workdir={OVERLAY_METADATA}\"\n\n  mount_cmd = [\"mount\", \"-t\", \"overlay\", \"-o\", overlay_opts, \"none\", OVERLAY_MERGED]\n  run([\"sudo\"] + mount_cmd)\n  run([\"sudo\", \"chmod\", \"755\", os.path.join(OVERLAY_METADATA, \"work\")])\n\n  git_diff = run([\"git\", \"diff\"], OVERLAY_MERGED)\n  params.put(\"GitDiff\", git_diff)\n  cloudlog.info(f\"git diff output:\\n{git_diff}\")\n\n\ndef finalize_update() -> None:\n  \"\"\"Take the current OverlayFS merged view and finalize a copy outside of\n  OverlayFS, ready to be swapped-in at BASEDIR. Copy using shutil.copytree\"\"\"\n\n  # Remove the update ready flag and any old updates\n  cloudlog.info(\"creating finalized version of the overlay\")\n  set_consistent_flag(False)\n\n  # Copy the merged overlay view and set the update ready flag\n  if os.path.exists(FINALIZED):\n    shutil.rmtree(FINALIZED)\n  shutil.copytree(OVERLAY_MERGED, FINALIZED, symlinks=True)\n\n  run([\"git\", \"reset\", \"--hard\"], FINALIZED)\n  run([\"git\", \"submodule\", \"foreach\", \"--recursive\", \"git\", \"reset\", \"--hard\"], FINALIZED)\n\n  cloudlog.info(\"Starting git cleanup in finalized update\")\n  t = time.monotonic()\n  try:\n    run([\"git\", \"gc\"], FINALIZED)\n    run([\"git\", \"lfs\", \"prune\"], FINALIZED)\n    cloudlog.event(\"Done git cleanup\", duration=time.monotonic() - t)\n  except subprocess.CalledProcessError:\n    cloudlog.exception(f\"Failed git cleanup, took {time.monotonic() - t:.3f} s\")\n\n  set_consistent_flag(True)\n  cloudlog.info(\"done finalizing overlay\")\n\n\ndef handle_agnos_update() -> None:\n  from openpilot.system.hardware.tici.agnos import flash_agnos_update, get_target_slot_number\n\n  cur_version = HARDWARE.get_os_version()\n  updated_version = run([\"bash\", \"-c\", r\"unset AGNOS_VERSION && source launch_env.sh && \\\n                          echo -n $AGNOS_VERSION\"], OVERLAY_MERGED).strip()\n\n  cloudlog.info(f\"AGNOS version check: {cur_version} vs {updated_version}\")\n  if cur_version == updated_version:\n    return\n\n  # prevent an openpilot getting swapped in with a mismatched or partially downloaded agnos\n  set_consistent_flag(False)\n\n  cloudlog.info(f\"Beginning background installation for AGNOS {updated_version}\")\n  set_offroad_alert(\"Offroad_NeosUpdate\", True)\n\n  manifest_path = os.path.join(OVERLAY_MERGED, \"system/hardware/tici/agnos.json\")\n  target_slot_number = get_target_slot_number()\n  flash_agnos_update(manifest_path, target_slot_number, cloudlog)\n  set_offroad_alert(\"Offroad_NeosUpdate\", False)\n\n\n\nclass Updater:\n  def __init__(self):\n    self.params = Params()\n    self.branches = defaultdict(str)\n    self._has_internet: bool = False\n\n  @property\n  def has_internet(self) -> bool:\n    return self._has_internet\n\n  @property\n  def target_branch(self) -> str:\n    b: str | None = self.params.get(\"UpdaterTargetBranch\", encoding='utf-8')\n    if b is None:\n      b = self.get_branch(BASEDIR)\n    return b\n\n  @property\n  def update_ready(self) -> bool:\n    consistent_file = Path(os.path.join(FINALIZED, \".overlay_consistent\"))\n    if consistent_file.is_file():\n      hash_mismatch = self.get_commit_hash(BASEDIR) != self.branches[self.target_branch]\n      branch_mismatch = self.get_branch(BASEDIR) != self.target_branch\n      on_target_branch = self.get_branch(FINALIZED) == self.target_branch\n      return ((hash_mismatch or branch_mismatch) and on_target_branch)\n    return False\n\n  @property\n  def update_available(self) -> bool:\n    if os.path.isdir(OVERLAY_MERGED) and len(self.branches) > 0:\n      hash_mismatch = self.get_commit_hash(OVERLAY_MERGED) != self.branches[self.target_branch]\n      branch_mismatch = self.get_branch(OVERLAY_MERGED) != self.target_branch\n      return hash_mismatch or branch_mismatch\n    return False\n\n  def get_branch(self, path: str) -> str:\n    return run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"], path).rstrip()\n\n  def get_commit_hash(self, path: str = OVERLAY_MERGED) -> str:\n    return run([\"git\", \"rev-parse\", \"HEAD\"], path).rstrip()\n\n  def set_params(self, update_success: bool, failed_count: int, exception: str | None) -> None:\n    self.params.put(\"UpdateFailedCount\", str(failed_count))\n    self.params.put(\"UpdaterTargetBranch\", self.target_branch)\n\n    self.params.put_bool(\"UpdaterFetchAvailable\", self.update_available)\n    if len(self.branches):\n      self.params.put(\"UpdaterAvailableBranches\", ','.join(self.branches.keys()))\n\n    last_update = datetime.datetime.now(datetime.UTC).replace(tzinfo=None)\n    if update_success:\n      write_time_to_param(self.params, \"LastUpdateTime\")\n    else:\n      t = read_time_from_param(self.params, \"LastUpdateTime\")\n      if t is not None:\n        last_update = t\n\n    if exception is None:\n      self.params.remove(\"LastUpdateException\")\n    else:\n      self.params.put(\"LastUpdateException\", exception)\n\n    # Write out current and new version info\n    def get_description(basedir: str) -> str:\n      if not os.path.exists(basedir):\n        return \"\"\n\n      version = \"\"\n      branch = \"\"\n      commit = \"\"\n      commit_date = \"\"\n      try:\n        branch = self.get_branch(basedir)\n        commit = self.get_commit_hash(basedir)[:7]\n        with open(os.path.join(basedir, \"common\", \"version.h\")) as f:\n          version = f.read().split('\"')[1]\n\n        commit_unix_ts = run([\"git\", \"show\", \"-s\", \"--format=%ct\", \"HEAD\"], basedir).rstrip()\n        dt = datetime.datetime.fromtimestamp(int(commit_unix_ts))\n        commit_date = dt.strftime(\"%b %d\")\n      except Exception:\n        cloudlog.exception(\"updater.get_description\")\n      return f\"{version} / {branch} / {commit} / {commit_date}\"\n    self.params.put(\"UpdaterCurrentDescription\", get_description(BASEDIR))\n    self.params.put(\"UpdaterCurrentReleaseNotes\", parse_release_notes(BASEDIR))\n    self.params.put(\"UpdaterNewDescription\", get_description(FINALIZED))\n    self.params.put(\"UpdaterNewReleaseNotes\", parse_release_notes(FINALIZED))\n    self.params.put_bool(\"UpdateAvailable\", self.update_ready)\n\n    # Handle user prompt\n    for alert in (\"Offroad_UpdateFailed\", \"Offroad_ConnectivityNeeded\", \"Offroad_ConnectivityNeededPrompt\"):\n      set_offroad_alert(alert, False)\n\n    now = datetime.datetime.now(datetime.UTC).replace(tzinfo=None)\n    dt = now - last_update\n    build_metadata = get_build_metadata()\n    if failed_count > 15 and exception is not None and self.has_internet:\n      if build_metadata.tested_channel:\n        extra_text = \"Ensure the software is correctly installed. Uninstall and re-install if this error persists.\"\n      else:\n        extra_text = exception\n      set_offroad_alert(\"Offroad_UpdateFailed\", True, extra_text=extra_text)\n    elif failed_count > 0:\n      if dt.days > DAYS_NO_CONNECTIVITY_MAX:\n        set_offroad_alert(\"Offroad_ConnectivityNeeded\", True)\n      elif dt.days > DAYS_NO_CONNECTIVITY_PROMPT:\n        remaining = max(DAYS_NO_CONNECTIVITY_MAX - dt.days, 1)\n        set_offroad_alert(\"Offroad_ConnectivityNeededPrompt\", True, extra_text=f\"{remaining} day{'' if remaining == 1 else 's'}.\")\n\n  def check_for_update(self) -> None:\n    cloudlog.info(\"checking for updates\")\n\n    excluded_branches = ('release2', 'release2-staging')\n\n    try:\n      run([\"git\", \"ls-remote\", \"origin\", \"HEAD\"], OVERLAY_MERGED)\n      self._has_internet = True\n    except subprocess.CalledProcessError:\n      self._has_internet = False\n\n    setup_git_options(OVERLAY_MERGED)\n    output = run([\"git\", \"ls-remote\", \"--heads\"], OVERLAY_MERGED)\n\n    self.branches = defaultdict(lambda: None)\n    for line in output.split('\\n'):\n      ls_remotes_re = r'(?P<commit_sha>\\b[0-9a-f]{5,40}\\b)(\\s+)(refs\\/heads\\/)(?P<branch_name>.*$)'\n      x = re.fullmatch(ls_remotes_re, line.strip())\n      if x is not None and x.group('branch_name') not in excluded_branches:\n        self.branches[x.group('branch_name')] = x.group('commit_sha')\n\n    cur_branch = self.get_branch(OVERLAY_MERGED)\n    cur_commit = self.get_commit_hash(OVERLAY_MERGED)\n    new_branch = self.target_branch\n    new_commit = self.branches[new_branch]\n    if (cur_branch, cur_commit) != (new_branch, new_commit):\n      cloudlog.info(f\"update available, {cur_branch} ({str(cur_commit)[:7]}) -> {new_branch} ({str(new_commit)[:7]})\")\n    else:\n      cloudlog.info(f\"up to date on {cur_branch} ({str(cur_commit)[:7]})\")\n\n  def fetch_update(self) -> None:\n    cloudlog.info(\"attempting git fetch inside staging overlay\")\n\n    self.params.put(\"UpdaterState\", \"downloading...\")\n\n    # TODO: cleanly interrupt this and invalidate old update\n    set_consistent_flag(False)\n    self.params.put_bool(\"UpdateAvailable\", False)\n\n    setup_git_options(OVERLAY_MERGED)\n\n    branch = self.target_branch\n    git_fetch_output = run([\"git\", \"fetch\", \"origin\", branch], OVERLAY_MERGED)\n    cloudlog.info(\"git fetch success: %s\", git_fetch_output)\n\n    cloudlog.info(\"git reset in progress\")\n    cmds = [\n      [\"git\", \"checkout\", \"--force\", \"--no-recurse-submodules\", \"-B\", branch, \"FETCH_HEAD\"],\n      [\"git\", \"reset\", \"--hard\"],\n      [\"git\", \"clean\", \"-xdff\"],\n      [\"git\", \"submodule\", \"sync\"],\n      [\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"],\n      [\"git\", \"submodule\", \"foreach\", \"--recursive\", \"git\", \"reset\", \"--hard\"],\n    ]\n    r = [run(cmd, OVERLAY_MERGED) for cmd in cmds]\n    cloudlog.info(\"git reset success: %s\", '\\n'.join(r))\n\n    # TODO: show agnos download progress\n    if AGNOS:\n      handle_agnos_update()\n\n    # Create the finalized, ready-to-swap update\n    self.params.put(\"UpdaterState\", \"finalizing update...\")\n    finalize_update()\n    cloudlog.info(\"finalize success!\")\n\n\ndef main() -> None:\n  params = Params()\n\n  if params.get_bool(\"DisableUpdates\"):\n    cloudlog.warning(\"updates are disabled by the DisableUpdates param\")\n    exit(0)\n\n  with open(LOCK_FILE, 'w') as ov_lock_fd:\n    try:\n      fcntl.flock(ov_lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n    except OSError as e:\n      raise RuntimeError(\"couldn't get overlay lock; is another instance running?\") from e\n\n    # Set low io priority\n    proc = psutil.Process()\n    if psutil.LINUX:\n      proc.ionice(psutil.IOPRIO_CLASS_BE, value=7)\n\n    # Check if we just performed an update\n    if Path(os.path.join(STAGING_ROOT, \"old_openpilot\")).is_dir():\n      cloudlog.event(\"update installed\")\n\n    if not params.get(\"InstallDate\"):\n      t = datetime.datetime.now(datetime.UTC).replace(tzinfo=None).isoformat()\n      params.put(\"InstallDate\", t.encode('utf8'))\n\n    updater = Updater()\n    update_failed_count = 0 # TODO: Load from param?\n    wait_helper = WaitTimeHelper()\n\n    # invalidate old finalized update\n    set_consistent_flag(False)\n\n    # set initial state\n    params.put(\"UpdaterState\", \"idle\")\n\n    # Run the update loop\n    first_run = True\n    while True:\n      wait_helper.ready_event.clear()\n\n      # Attempt an update\n      exception = None\n      try:\n        # TODO: reuse overlay from previous updated instance if it looks clean\n        init_overlay()\n\n        # ensure we have some params written soon after startup\n        updater.set_params(False, update_failed_count, exception)\n\n        if not system_time_valid() or first_run:\n          first_run = False\n          wait_helper.sleep(60)\n          continue\n\n        update_failed_count += 1\n\n        # check for update\n        params.put(\"UpdaterState\", \"checking...\")\n        updater.check_for_update()\n\n        # download update\n        last_fetch = read_time_from_param(params, \"UpdaterLastFetchTime\")\n        timed_out = last_fetch is None or (datetime.datetime.now(datetime.UTC).replace(tzinfo=None) - last_fetch > datetime.timedelta(days=3))\n        user_requested_fetch = wait_helper.user_request == UserRequest.FETCH\n        if params.get_bool(\"NetworkMetered\") and not timed_out and not user_requested_fetch:\n          cloudlog.info(\"skipping fetch, connection metered\")\n        elif wait_helper.user_request == UserRequest.CHECK:\n          cloudlog.info(\"skipping fetch, only checking\")\n        else:\n          updater.fetch_update()\n          write_time_to_param(params, \"UpdaterLastFetchTime\")\n        update_failed_count = 0\n      except subprocess.CalledProcessError as e:\n        cloudlog.event(\n          \"update process failed\",\n          cmd=e.cmd,\n          output=e.output,\n          returncode=e.returncode\n        )\n        exception = f\"command failed: {e.cmd}\\n{e.output}\"\n        OVERLAY_INIT.unlink(missing_ok=True)\n      except Exception as e:\n        cloudlog.exception(\"uncaught updated exception, shouldn't happen\")\n        exception = str(e)\n        OVERLAY_INIT.unlink(missing_ok=True)\n\n      try:\n        params.put(\"UpdaterState\", \"idle\")\n        update_successful = (update_failed_count == 0)\n        updater.set_params(update_successful, update_failed_count, exception)\n      except Exception:\n        cloudlog.exception(\"uncaught updated exception while setting params, shouldn't happen\")\n\n      # infrequent attempts if we successfully updated recently\n      wait_helper.user_request = UserRequest.NONE\n      wait_helper.sleep(5*60 if update_failed_count > 0 else 1.5*60*60)\n\n\nif __name__ == \"__main__\":\n  main()\n", "system/updated/casync/common.py": "import dataclasses\nimport json\nimport pathlib\nimport subprocess\n\nfrom openpilot.system.version import BUILD_METADATA_FILENAME, BuildMetadata\nfrom openpilot.system.updated.casync import tar\n\n\nCASYNC_ARGS = [\"--with=symlinks\", \"--with=permissions\", \"--compression=xz\", \"--chunk-size=16M\"]\nCASYNC_FILES = [BUILD_METADATA_FILENAME]\n\n\ndef run(cmd):\n  return subprocess.check_output(cmd)\n\n\ndef get_exclude_set(path) -> set[str]:\n  exclude_set = set(CASYNC_FILES)\n\n  for file in path.rglob(\"*\"):\n    if file.is_file() or file.is_symlink():\n\n      while file.resolve() != path.resolve():\n        exclude_set.add(str(file.relative_to(path)))\n\n        file = file.parent\n\n  return exclude_set\n\n\ndef create_build_metadata_file(path: pathlib.Path, build_metadata: BuildMetadata):\n  with open(path / BUILD_METADATA_FILENAME, \"w\") as f:\n    build_metadata_dict = dataclasses.asdict(build_metadata)\n    build_metadata_dict[\"openpilot\"].pop(\"is_dirty\")  # this is determined at runtime\n    build_metadata_dict.pop(\"channel\")                # channel is unrelated to the build itself\n    f.write(json.dumps(build_metadata_dict))\n\n\ndef is_not_git(path: pathlib.Path) -> bool:\n  return \".git\" not in path.parts\n\n\ndef create_casync_tar_package(target_dir: pathlib.Path, output_path: pathlib.Path):\n  tar.create_tar_archive(output_path, target_dir, is_not_git)\n\n\ndef create_casync_from_file(file: pathlib.Path, output_dir: pathlib.Path, caibx_name: str):\n  caibx_file = output_dir / f\"{caibx_name}.caibx\"\n  run([\"casync\", \"make\", *CASYNC_ARGS, caibx_file, str(file)])\n\n  return caibx_file\n\n\ndef create_casync_release(target_dir: pathlib.Path, output_dir: pathlib.Path, caibx_name: str):\n  tar_file = output_dir / f\"{caibx_name}.tar\"\n  create_casync_tar_package(target_dir, tar_file)\n  caibx_file = create_casync_from_file(tar_file, output_dir, caibx_name)\n  tar_file.unlink()\n  digest = run([\"casync\", \"digest\", *CASYNC_ARGS, target_dir]).decode(\"utf-8\").strip()\n  return digest, caibx_file\n", "system/updated/casync/casync.py": "#!/usr/bin/env python3\nimport io\nimport lzma\nimport os\nimport pathlib\nimport struct\nimport sys\nimport time\nfrom abc import ABC, abstractmethod\nfrom collections import defaultdict, namedtuple\nfrom collections.abc import Callable\nfrom typing import IO\n\nimport requests\nfrom Crypto.Hash import SHA512\nfrom openpilot.system.updated.casync import tar\nfrom openpilot.system.updated.casync.common import create_casync_tar_package\n\nCA_FORMAT_INDEX = 0x96824d9c7b129ff9\nCA_FORMAT_TABLE = 0xe75b9e112f17417d\nCA_FORMAT_TABLE_TAIL_MARKER = 0xe75b9e112f17417\nFLAGS = 0xb000000000000000\n\nCA_HEADER_LEN = 48\nCA_TABLE_HEADER_LEN = 16\nCA_TABLE_ENTRY_LEN = 40\nCA_TABLE_MIN_LEN = CA_TABLE_HEADER_LEN + CA_TABLE_ENTRY_LEN\n\nCHUNK_DOWNLOAD_TIMEOUT = 60\nCHUNK_DOWNLOAD_RETRIES = 3\n\nCAIBX_DOWNLOAD_TIMEOUT = 120\n\nChunk = namedtuple('Chunk', ['sha', 'offset', 'length'])\nChunkDict = dict[bytes, Chunk]\n\n\nclass ChunkReader(ABC):\n  @abstractmethod\n  def read(self, chunk: Chunk) -> bytes:\n    ...\n\n\nclass BinaryChunkReader(ChunkReader):\n  \"\"\"Reads chunks from a local file\"\"\"\n  def __init__(self, file_like: IO[bytes]) -> None:\n    super().__init__()\n    self.f = file_like\n\n  def read(self, chunk: Chunk) -> bytes:\n    self.f.seek(chunk.offset)\n    return self.f.read(chunk.length)\n\n\nclass FileChunkReader(BinaryChunkReader):\n  def __init__(self, path: str) -> None:\n    super().__init__(open(path, 'rb'))\n\n  def __del__(self):\n    self.f.close()\n\n\nclass RemoteChunkReader(ChunkReader):\n  \"\"\"Reads lzma compressed chunks from a remote store\"\"\"\n\n  def __init__(self, url: str) -> None:\n    super().__init__()\n    self.url = url\n    self.session = requests.Session()\n\n  def read(self, chunk: Chunk) -> bytes:\n    sha_hex = chunk.sha.hex()\n    url = os.path.join(self.url, sha_hex[:4], sha_hex + \".cacnk\")\n\n    if os.path.isfile(url):\n      with open(url, 'rb') as f:\n        contents = f.read()\n    else:\n      for i in range(CHUNK_DOWNLOAD_RETRIES):\n        try:\n          resp = self.session.get(url, timeout=CHUNK_DOWNLOAD_TIMEOUT)\n          break\n        except Exception:\n          if i == CHUNK_DOWNLOAD_RETRIES - 1:\n            raise\n          time.sleep(CHUNK_DOWNLOAD_TIMEOUT)\n\n      resp.raise_for_status()\n      contents = resp.content\n\n    decompressor = lzma.LZMADecompressor(format=lzma.FORMAT_AUTO)\n    return decompressor.decompress(contents)\n\n\nclass DirectoryTarChunkReader(BinaryChunkReader):\n  \"\"\"creates a tar archive of a directory and reads chunks from it\"\"\"\n\n  def __init__(self, path: str, cache_file: str) -> None:\n    create_casync_tar_package(pathlib.Path(path), pathlib.Path(cache_file))\n\n    self.f = open(cache_file, \"rb\")\n    return super().__init__(self.f)\n\n  def __del__(self):\n    self.f.close()\n    os.unlink(self.f.name)\n\n\ndef parse_caibx(caibx_path: str) -> list[Chunk]:\n  \"\"\"Parses the chunks from a caibx file. Can handle both local and remote files.\n  Returns a list of chunks with hash, offset and length\"\"\"\n  caibx: io.BufferedIOBase\n  if os.path.isfile(caibx_path):\n    caibx = open(caibx_path, 'rb')\n  else:\n    resp = requests.get(caibx_path, timeout=CAIBX_DOWNLOAD_TIMEOUT)\n    resp.raise_for_status()\n    caibx = io.BytesIO(resp.content)\n\n  caibx.seek(0, os.SEEK_END)\n  caibx_len = caibx.tell()\n  caibx.seek(0, os.SEEK_SET)\n\n  # Parse header\n  length, magic, flags, min_size, _, max_size = struct.unpack(\"<QQQQQQ\", caibx.read(CA_HEADER_LEN))\n  assert flags == flags\n  assert length == CA_HEADER_LEN\n  assert magic == CA_FORMAT_INDEX\n\n  # Parse table header\n  length, magic = struct.unpack(\"<QQ\", caibx.read(CA_TABLE_HEADER_LEN))\n  assert magic == CA_FORMAT_TABLE\n\n  # Parse chunks\n  num_chunks = (caibx_len - CA_HEADER_LEN - CA_TABLE_MIN_LEN) // CA_TABLE_ENTRY_LEN\n  chunks = []\n\n  offset = 0\n  for i in range(num_chunks):\n    new_offset = struct.unpack(\"<Q\", caibx.read(8))[0]\n\n    sha = caibx.read(32)\n    length = new_offset - offset\n\n    assert length <= max_size\n\n    # Last chunk can be smaller\n    if i < num_chunks - 1:\n      assert length >= min_size\n\n    chunks.append(Chunk(sha, offset, length))\n    offset = new_offset\n\n  caibx.close()\n  return chunks\n\n\ndef build_chunk_dict(chunks: list[Chunk]) -> ChunkDict:\n  \"\"\"Turn a list of chunks into a dict for faster lookups based on hash.\n  Keep first chunk since it's more likely to be already downloaded.\"\"\"\n  r = {}\n  for c in chunks:\n    if c.sha not in r:\n      r[c.sha] = c\n  return r\n\n\ndef extract(target: list[Chunk],\n            sources: list[tuple[str, ChunkReader, ChunkDict]],\n            out_path: str,\n            progress: Callable[[int], None] = None):\n  stats: dict[str, int] = defaultdict(int)\n\n  mode = 'rb+' if os.path.exists(out_path) else 'wb'\n  with open(out_path, mode) as out:\n    for cur_chunk in target:\n\n      # Find source for desired chunk\n      for name, chunk_reader, store_chunks in sources:\n        if cur_chunk.sha in store_chunks:\n          bts = chunk_reader.read(store_chunks[cur_chunk.sha])\n\n          # Check length\n          if len(bts) != cur_chunk.length:\n            continue\n\n          # Check hash\n          if SHA512.new(bts, truncate=\"256\").digest() != cur_chunk.sha:\n            continue\n\n          # Write to output\n          out.seek(cur_chunk.offset)\n          out.write(bts)\n\n          stats[name] += cur_chunk.length\n\n          if progress is not None:\n            progress(sum(stats.values()))\n\n          break\n      else:\n        raise RuntimeError(\"Desired chunk not found in provided stores\")\n\n  return stats\n\n\ndef extract_directory(target: list[Chunk],\n            sources: list[tuple[str, ChunkReader, ChunkDict]],\n            out_path: str,\n            tmp_file: str,\n            progress: Callable[[int], None] = None):\n  \"\"\"extract a directory stored as a casync tar archive\"\"\"\n\n  stats = extract(target, sources, tmp_file, progress)\n\n  with open(tmp_file, \"rb\") as f:\n    tar.extract_tar_archive(f, pathlib.Path(out_path))\n\n  return stats\n\n\ndef print_stats(stats: dict[str, int]):\n  total_bytes = sum(stats.values())\n  print(f\"Total size: {total_bytes / 1024 / 1024:.2f} MB\")\n  for name, total in stats.items():\n    print(f\"  {name}: {total / 1024 / 1024:.2f} MB ({total / total_bytes * 100:.1f}%)\")\n\n\ndef extract_simple(caibx_path, out_path, store_path):\n  # (name, callback, chunks)\n  target = parse_caibx(caibx_path)\n  sources = [\n    # (store_path, RemoteChunkReader(store_path), build_chunk_dict(target)),\n    (store_path, FileChunkReader(store_path), build_chunk_dict(target)),\n  ]\n\n  return extract(target, sources, out_path)\n\n\nif __name__ == \"__main__\":\n  caibx = sys.argv[1]\n  out = sys.argv[2]\n  store = sys.argv[3]\n\n  stats = extract_simple(caibx, out, store)\n  print_stats(stats)\n", "system/updated/casync/tar.py": "import pathlib\nimport tarfile\nfrom typing import IO\nfrom collections.abc import Callable\n\n\ndef include_default(_) -> bool:\n  return True\n\n\ndef create_tar_archive(filename: pathlib.Path, directory: pathlib.Path, include: Callable[[pathlib.Path], bool] = include_default):\n  \"\"\"Creates a tar archive of a directory\"\"\"\n\n  with tarfile.open(filename, 'w') as tar:\n    for file in sorted(directory.rglob(\"*\"), key=lambda f: f.stat().st_size if f.is_file() else 0, reverse=True):\n      if not include(file):\n        continue\n      relative_path = str(file.relative_to(directory))\n      if file.is_symlink():\n        info = tarfile.TarInfo(relative_path)\n        info.type = tarfile.SYMTYPE\n        info.linkpath = str(file.readlink())\n        tar.addfile(info)\n\n      elif file.is_file():\n        info = tarfile.TarInfo(relative_path)\n        info.size = file.stat().st_size\n        info.type = tarfile.REGTYPE\n        info.mode = file.stat().st_mode\n        with file.open('rb') as f:\n          tar.addfile(info, f)\n\n\ndef extract_tar_archive(fh: IO[bytes], directory: pathlib.Path):\n  \"\"\"Extracts a tar archive to a directory\"\"\"\n\n  tar = tarfile.open(fileobj=fh, mode='r')\n  tar.extractall(str(directory), filter=lambda info, path: info)\n  tar.close()\n", "openpilot/__init__.py": "", "third_party/acados/acados_template/casadi_function_generation.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport os\nimport casadi as ca\nfrom .utils import is_empty, casadi_length\n\n\ndef get_casadi_symbol(x):\n    if isinstance(x, ca.MX):\n        return ca.MX.sym\n    elif isinstance(x, ca.SX):\n        return ca.SX.sym\n    else:\n        raise TypeError(\"Expected casadi SX or MX.\")\n\n################\n# Dynamics\n################\n\n\ndef generate_c_code_discrete_dynamics( model, opts ):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    # load model\n    x = model.x\n    u = model.u\n    p = model.p\n    phi = model.disc_dyn_expr\n    model_name = model.name\n    nx = casadi_length(x)\n\n    symbol = get_casadi_symbol(x)\n    # assume nx1 = nx !!!\n    lam = symbol('lam', nx, 1)\n\n    # generate jacobians\n    ux = ca.vertcat(u,x)\n    jac_ux = ca.jacobian(phi, ux)\n    # generate adjoint\n    adj_ux = ca.jtimes(phi, ux, lam, True)\n    # generate hessian\n    hess_ux = ca.jacobian(adj_ux, ux)\n\n    # change directory\n    cwd = os.getcwd()\n    model_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model_name}_model'))\n    if not os.path.exists(model_dir):\n        os.makedirs(model_dir)\n    os.chdir(model_dir)\n\n    # set up & generate ca.Functions\n    fun_name = model_name + '_dyn_disc_phi_fun'\n    phi_fun = ca.Function(fun_name, [x, u, p], [phi])\n    phi_fun.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_dyn_disc_phi_fun_jac'\n    phi_fun_jac_ut_xt = ca.Function(fun_name, [x, u, p], [phi, jac_ux.T])\n    phi_fun_jac_ut_xt.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_dyn_disc_phi_fun_jac_hess'\n    phi_fun_jac_ut_xt_hess = ca.Function(fun_name, [x, u, lam, p], [phi, jac_ux.T, hess_ux])\n    phi_fun_jac_ut_xt_hess.generate(fun_name, casadi_codegen_opts)\n\n    os.chdir(cwd)\n    return\n\n\n\ndef generate_c_code_explicit_ode( model, opts ):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    generate_hess = opts[\"generate_hess\"]\n\n    # load model\n    x = model.x\n    u = model.u\n    p = model.p\n    f_expl = model.f_expl_expr\n    model_name = model.name\n\n    ## get model dimensions\n    nx = x.size()[0]\n    nu = u.size()[0]\n\n    symbol = get_casadi_symbol(x)\n\n    ## set up functions to be exported\n    Sx = symbol('Sx', nx, nx)\n    Sp = symbol('Sp', nx, nu)\n    lambdaX = symbol('lambdaX', nx, 1)\n\n    fun_name = model_name + '_expl_ode_fun'\n\n    ## Set up functions\n    expl_ode_fun = ca.Function(fun_name, [x, u, p], [f_expl])\n\n    vdeX = ca.jtimes(f_expl,x,Sx)\n    vdeP = ca.jacobian(f_expl,u) + ca.jtimes(f_expl,x,Sp)\n\n    fun_name = model_name + '_expl_vde_forw'\n\n    expl_vde_forw = ca.Function(fun_name, [x, Sx, Sp, u, p], [f_expl, vdeX, vdeP])\n\n    adj = ca.jtimes(f_expl, ca.vertcat(x, u), lambdaX, True)\n\n    fun_name = model_name + '_expl_vde_adj'\n    expl_vde_adj = ca.Function(fun_name, [x, lambdaX, u, p], [adj])\n\n    if generate_hess:\n        S_forw = ca.vertcat(ca.horzcat(Sx, Sp), ca.horzcat(ca.DM.zeros(nu,nx), ca.DM.eye(nu)))\n        hess = ca.mtimes(ca.transpose(S_forw),ca.jtimes(adj, ca.vertcat(x,u), S_forw))\n        hess2 = []\n        for j in range(nx+nu):\n            for i in range(j,nx+nu):\n                hess2 = ca.vertcat(hess2, hess[i,j])\n\n        fun_name = model_name + '_expl_ode_hess'\n        expl_ode_hess = ca.Function(fun_name, [x, Sx, Sp, lambdaX, u, p], [adj, hess2])\n\n    # change directory\n    cwd = os.getcwd()\n    model_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model_name}_model'))\n    if not os.path.exists(model_dir):\n        os.makedirs(model_dir)\n    os.chdir(model_dir)\n\n    # generate C code\n    fun_name = model_name + '_expl_ode_fun'\n    expl_ode_fun.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_expl_vde_forw'\n    expl_vde_forw.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_expl_vde_adj'\n    expl_vde_adj.generate(fun_name, casadi_codegen_opts)\n\n    if generate_hess:\n        fun_name = model_name + '_expl_ode_hess'\n        expl_ode_hess.generate(fun_name, casadi_codegen_opts)\n    os.chdir(cwd)\n\n    return\n\n\ndef generate_c_code_implicit_ode( model, opts ):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    # load model\n    x = model.x\n    xdot = model.xdot\n    u = model.u\n    z = model.z\n    p = model.p\n    f_impl = model.f_impl_expr\n    model_name = model.name\n\n    # get model dimensions\n    nx = casadi_length(x)\n    nz = casadi_length(z)\n\n    # generate jacobians\n    jac_x       = ca.jacobian(f_impl, x)\n    jac_xdot    = ca.jacobian(f_impl, xdot)\n    jac_u       = ca.jacobian(f_impl, u)\n    jac_z       = ca.jacobian(f_impl, z)\n\n    # Set up functions\n    p = model.p\n    fun_name = model_name + '_impl_dae_fun'\n    impl_dae_fun = ca.Function(fun_name, [x, xdot, u, z, p], [f_impl])\n\n    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_z'\n    impl_dae_fun_jac_x_xdot_z = ca.Function(fun_name, [x, xdot, u, z, p], [f_impl, jac_x, jac_xdot, jac_z])\n\n    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u_z'\n    impl_dae_fun_jac_x_xdot_u_z = ca.Function(fun_name, [x, xdot, u, z, p], [f_impl, jac_x, jac_xdot, jac_u, jac_z])\n\n    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u'\n    impl_dae_fun_jac_x_xdot_u = ca.Function(fun_name, [x, xdot, u, z, p], [f_impl, jac_x, jac_xdot, jac_u])\n\n    fun_name = model_name + '_impl_dae_jac_x_xdot_u_z'\n    impl_dae_jac_x_xdot_u_z = ca.Function(fun_name, [x, xdot, u, z, p], [jac_x, jac_xdot, jac_u, jac_z])\n\n    if opts[\"generate_hess\"]:\n        x_xdot_z_u = ca.vertcat(x, xdot, z, u)\n        symbol = get_casadi_symbol(x)\n        multiplier = symbol('multiplier', nx + nz)\n        ADJ = ca.jtimes(f_impl, x_xdot_z_u, multiplier, True)\n        HESS = ca.jacobian(ADJ, x_xdot_z_u)\n        fun_name = model_name + '_impl_dae_hess'\n        impl_dae_hess = ca.Function(fun_name, [x, xdot, u, z, multiplier, p], [HESS])\n\n    # change directory\n    cwd = os.getcwd()\n    model_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model_name}_model'))\n    if not os.path.exists(model_dir):\n        os.makedirs(model_dir)\n    os.chdir(model_dir)\n\n    # generate C code\n    fun_name = model_name + '_impl_dae_fun'\n    impl_dae_fun.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_z'\n    impl_dae_fun_jac_x_xdot_z.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_impl_dae_jac_x_xdot_u_z'\n    impl_dae_jac_x_xdot_u_z.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u_z'\n    impl_dae_fun_jac_x_xdot_u_z.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u'\n    impl_dae_fun_jac_x_xdot_u.generate(fun_name, casadi_codegen_opts)\n\n    if opts[\"generate_hess\"]:\n        fun_name = model_name + '_impl_dae_hess'\n        impl_dae_hess.generate(fun_name, casadi_codegen_opts)\n\n    os.chdir(cwd)\n    return\n\n\ndef generate_c_code_gnsf( model, opts ):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    model_name = model.name\n\n    # set up directory\n    cwd = os.getcwd()\n    model_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model_name}_model'))\n    if not os.path.exists(model_dir):\n        os.makedirs(model_dir)\n    os.chdir(model_dir)\n\n    # obtain gnsf dimensions\n    get_matrices_fun = model.get_matrices_fun\n    phi_fun = model.phi_fun\n\n    size_gnsf_A = get_matrices_fun.size_out(0)\n    gnsf_nx1 = size_gnsf_A[1]\n    gnsf_nz1 = size_gnsf_A[0] - size_gnsf_A[1]\n    gnsf_nuhat = max(phi_fun.size_in(1))\n    gnsf_ny = max(phi_fun.size_in(0))\n    gnsf_nout = max(phi_fun.size_out(0))\n\n    # set up expressions\n    # if the model uses ca.MX because of cost/constraints\n    # the DAE can be exported as ca.SX -> detect GNSF in Matlab\n    # -> evaluated ca.SX GNSF functions with ca.MX.\n    u = model.u\n    symbol = get_casadi_symbol(u)\n\n    y = symbol(\"y\", gnsf_ny, 1)\n    uhat = symbol(\"uhat\", gnsf_nuhat, 1)\n    p = model.p\n    x1 = symbol(\"gnsf_x1\", gnsf_nx1, 1)\n    x1dot = symbol(\"gnsf_x1dot\", gnsf_nx1, 1)\n    z1 = symbol(\"gnsf_z1\", gnsf_nz1, 1)\n    dummy = symbol(\"gnsf_dummy\", 1, 1)\n    empty_var = symbol(\"gnsf_empty_var\", 0, 0)\n\n    ## generate C code\n    fun_name = model_name + '_gnsf_phi_fun'\n    phi_fun_ = ca.Function(fun_name, [y, uhat, p], [phi_fun(y, uhat, p)])\n    phi_fun_.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_gnsf_phi_fun_jac_y'\n    phi_fun_jac_y = model.phi_fun_jac_y\n    phi_fun_jac_y_ = ca.Function(fun_name, [y, uhat, p], phi_fun_jac_y(y, uhat, p))\n    phi_fun_jac_y_.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_gnsf_phi_jac_y_uhat'\n    phi_jac_y_uhat = model.phi_jac_y_uhat\n    phi_jac_y_uhat_ = ca.Function(fun_name, [y, uhat, p], phi_jac_y_uhat(y, uhat, p))\n    phi_jac_y_uhat_.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_gnsf_f_lo_fun_jac_x1k1uz'\n    f_lo_fun_jac_x1k1uz = model.f_lo_fun_jac_x1k1uz\n    f_lo_fun_jac_x1k1uz_eval = f_lo_fun_jac_x1k1uz(x1, x1dot, z1, u, p)\n\n    # avoid codegeneration issue\n    if not isinstance(f_lo_fun_jac_x1k1uz_eval, tuple) and is_empty(f_lo_fun_jac_x1k1uz_eval):\n        f_lo_fun_jac_x1k1uz_eval = [empty_var]\n\n    f_lo_fun_jac_x1k1uz_ = ca.Function(fun_name, [x1, x1dot, z1, u, p],\n                 f_lo_fun_jac_x1k1uz_eval)\n    f_lo_fun_jac_x1k1uz_.generate(fun_name, casadi_codegen_opts)\n\n    fun_name = model_name + '_gnsf_get_matrices_fun'\n    get_matrices_fun_ = ca.Function(fun_name, [dummy], get_matrices_fun(1))\n    get_matrices_fun_.generate(fun_name, casadi_codegen_opts)\n\n    # remove fields for json dump\n    del model.phi_fun\n    del model.phi_fun_jac_y\n    del model.phi_jac_y_uhat\n    del model.f_lo_fun_jac_x1k1uz\n    del model.get_matrices_fun\n\n    os.chdir(cwd)\n\n    return\n\n\n################\n# Cost\n################\n\ndef generate_c_code_external_cost(model, stage_type, opts):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    x = model.x\n    p = model.p\n    u = model.u\n    z = model.z\n    symbol = get_casadi_symbol(x)\n\n    if stage_type == 'terminal':\n        suffix_name = \"_cost_ext_cost_e_fun\"\n        suffix_name_hess = \"_cost_ext_cost_e_fun_jac_hess\"\n        suffix_name_jac = \"_cost_ext_cost_e_fun_jac\"\n        ext_cost = model.cost_expr_ext_cost_e\n        custom_hess = model.cost_expr_ext_cost_custom_hess_e\n        # Last stage cannot depend on u and z\n        u = symbol(\"u\", 0, 0)\n        z = symbol(\"z\", 0, 0)\n\n    elif stage_type == 'path':\n        suffix_name = \"_cost_ext_cost_fun\"\n        suffix_name_hess = \"_cost_ext_cost_fun_jac_hess\"\n        suffix_name_jac = \"_cost_ext_cost_fun_jac\"\n        ext_cost = model.cost_expr_ext_cost\n        custom_hess = model.cost_expr_ext_cost_custom_hess\n\n    elif stage_type == 'initial':\n        suffix_name = \"_cost_ext_cost_0_fun\"\n        suffix_name_hess = \"_cost_ext_cost_0_fun_jac_hess\"\n        suffix_name_jac = \"_cost_ext_cost_0_fun_jac\"\n        ext_cost = model.cost_expr_ext_cost_0\n        custom_hess = model.cost_expr_ext_cost_custom_hess_0\n\n    nunx = x.shape[0] + u.shape[0]\n\n    # set up functions to be exported\n    fun_name = model.name + suffix_name\n    fun_name_hess = model.name + suffix_name_hess\n    fun_name_jac = model.name + suffix_name_jac\n\n    # generate expression for full gradient and Hessian\n    hess_uxz, grad_uxz = ca.hessian(ext_cost, ca.vertcat(u, x, z))\n\n    hess_ux = hess_uxz[:nunx, :nunx]\n    hess_z = hess_uxz[nunx:, nunx:]\n    hess_z_ux = hess_uxz[nunx:, :nunx]\n\n    if custom_hess is not None:\n        hess_ux = custom_hess\n\n    ext_cost_fun = ca.Function(fun_name, [x, u, z, p], [ext_cost])\n\n    ext_cost_fun_jac_hess = ca.Function(\n        fun_name_hess, [x, u, z, p], [ext_cost, grad_uxz, hess_ux, hess_z, hess_z_ux]\n    )\n    ext_cost_fun_jac = ca.Function(\n        fun_name_jac, [x, u, z, p], [ext_cost, grad_uxz]\n    )\n\n    # change directory\n    cwd = os.getcwd()\n    cost_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model.name}_cost'))\n    if not os.path.exists(cost_dir):\n        os.makedirs(cost_dir)\n    os.chdir(cost_dir)\n\n    ext_cost_fun.generate(fun_name, casadi_codegen_opts)\n    ext_cost_fun_jac_hess.generate(fun_name_hess, casadi_codegen_opts)\n    ext_cost_fun_jac.generate(fun_name_jac, casadi_codegen_opts)\n\n    os.chdir(cwd)\n    return\n\n\ndef generate_c_code_nls_cost( model, cost_name, stage_type, opts ):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    x = model.x\n    z = model.z\n    p = model.p\n    u = model.u\n\n    symbol = get_casadi_symbol(x)\n\n    if stage_type == 'terminal':\n        middle_name = '_cost_y_e'\n        u = symbol('u', 0, 0)\n        y_expr = model.cost_y_expr_e\n\n    elif stage_type == 'initial':\n        middle_name = '_cost_y_0'\n        y_expr = model.cost_y_expr_0\n\n    elif stage_type == 'path':\n        middle_name = '_cost_y'\n        y_expr = model.cost_y_expr\n\n    # change directory\n    cwd = os.getcwd()\n    cost_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model.name}_cost'))\n    if not os.path.exists(cost_dir):\n        os.makedirs(cost_dir)\n    os.chdir(cost_dir)\n\n    # set up expressions\n    cost_jac_expr = ca.transpose(ca.jacobian(y_expr, ca.vertcat(u, x)))\n    dy_dz = ca.jacobian(y_expr, z)\n    ny = casadi_length(y_expr)\n\n    y = symbol('y', ny, 1)\n\n    y_adj = ca.jtimes(y_expr, ca.vertcat(u, x), y, True)\n    y_hess = ca.jacobian(y_adj, ca.vertcat(u, x))\n\n    ## generate C code\n    suffix_name = '_fun'\n    fun_name = cost_name + middle_name + suffix_name\n    y_fun = ca.Function( fun_name, [x, u, z, p], [ y_expr ])\n    y_fun.generate( fun_name, casadi_codegen_opts )\n\n    suffix_name = '_fun_jac_ut_xt'\n    fun_name = cost_name + middle_name + suffix_name\n    y_fun_jac_ut_xt = ca.Function(fun_name, [x, u, z, p], [ y_expr, cost_jac_expr, dy_dz ])\n    y_fun_jac_ut_xt.generate( fun_name, casadi_codegen_opts )\n\n    suffix_name = '_hess'\n    fun_name = cost_name + middle_name + suffix_name\n    y_hess = ca.Function(fun_name, [x, u, z, y, p], [ y_hess ])\n    y_hess.generate( fun_name, casadi_codegen_opts )\n\n    os.chdir(cwd)\n\n    return\n\n\n\ndef generate_c_code_conl_cost(model, cost_name, stage_type, opts):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    x = model.x\n    z = model.z\n    p = model.p\n\n    symbol = get_casadi_symbol(x)\n\n    if stage_type == 'terminal':\n        u = symbol('u', 0, 0)\n\n        yref = model.cost_r_in_psi_expr_e\n        inner_expr = model.cost_y_expr_e - yref\n        outer_expr = model.cost_psi_expr_e\n        res_expr = model.cost_r_in_psi_expr_e\n\n        suffix_name_fun = '_conl_cost_e_fun'\n        suffix_name_fun_jac_hess = '_conl_cost_e_fun_jac_hess'\n\n        custom_hess = model.cost_conl_custom_outer_hess_e\n\n    elif stage_type == 'initial':\n        u = model.u\n\n        yref = model.cost_r_in_psi_expr_0\n        inner_expr = model.cost_y_expr_0 - yref\n        outer_expr = model.cost_psi_expr_0\n        res_expr = model.cost_r_in_psi_expr_0\n\n        suffix_name_fun = '_conl_cost_0_fun'\n        suffix_name_fun_jac_hess = '_conl_cost_0_fun_jac_hess'\n\n        custom_hess = model.cost_conl_custom_outer_hess_0\n\n    elif stage_type == 'path':\n        u = model.u\n\n        yref = model.cost_r_in_psi_expr\n        inner_expr = model.cost_y_expr - yref\n        outer_expr = model.cost_psi_expr\n        res_expr = model.cost_r_in_psi_expr\n\n        suffix_name_fun = '_conl_cost_fun'\n        suffix_name_fun_jac_hess = '_conl_cost_fun_jac_hess'\n\n        custom_hess = model.cost_conl_custom_outer_hess\n\n    # set up function names\n    fun_name_cost_fun = model.name + suffix_name_fun\n    fun_name_cost_fun_jac_hess = model.name + suffix_name_fun_jac_hess\n\n    # set up functions to be exported\n    outer_loss_fun = ca.Function('psi', [res_expr, p], [outer_expr])\n    cost_expr = outer_loss_fun(inner_expr, p)\n\n    outer_loss_grad_fun = ca.Function('outer_loss_grad', [res_expr, p], [ca.jacobian(outer_expr, res_expr).T])\n\n    if custom_hess is None:\n        outer_hess_fun = ca.Function('inner_hess', [res_expr, p], [ca.hessian(outer_loss_fun(res_expr, p), res_expr)[0]])\n    else:\n        outer_hess_fun = ca.Function('inner_hess', [res_expr, p], [custom_hess])\n\n    Jt_ux_expr = ca.jacobian(inner_expr, ca.vertcat(u, x)).T\n    Jt_z_expr = ca.jacobian(inner_expr, z).T\n\n    cost_fun = ca.Function(\n        fun_name_cost_fun,\n        [x, u, z, yref, p],\n        [cost_expr])\n\n    cost_fun_jac_hess = ca.Function(\n        fun_name_cost_fun_jac_hess,\n        [x, u, z, yref, p],\n        [cost_expr, outer_loss_grad_fun(inner_expr, p), Jt_ux_expr, Jt_z_expr, outer_hess_fun(inner_expr, p)]\n    )\n    # change directory\n    cwd = os.getcwd()\n    cost_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model.name}_cost'))\n    if not os.path.exists(cost_dir):\n        os.makedirs(cost_dir)\n    os.chdir(cost_dir)\n\n    # generate C code\n    cost_fun.generate(fun_name_cost_fun, casadi_codegen_opts)\n    cost_fun_jac_hess.generate(fun_name_cost_fun_jac_hess, casadi_codegen_opts)\n\n    os.chdir(cwd)\n\n    return\n\n\n################\n# Constraints\n################\ndef generate_c_code_constraint( model, con_name, is_terminal, opts ):\n\n    casadi_codegen_opts = dict(mex=False, casadi_int='int', casadi_real='double')\n\n    # load constraint variables and expression\n    x = model.x\n    p = model.p\n\n    symbol = get_casadi_symbol(x)\n\n    if is_terminal:\n        con_h_expr = model.con_h_expr_e\n        con_phi_expr = model.con_phi_expr_e\n        # create dummy u, z\n        u = symbol('u', 0, 0)\n        z = symbol('z', 0, 0)\n    else:\n        con_h_expr = model.con_h_expr\n        con_phi_expr = model.con_phi_expr\n        u = model.u\n        z = model.z\n\n    if (not is_empty(con_h_expr)) and (not is_empty(con_phi_expr)):\n        raise Exception(\"acados: you can either have constraint_h, or constraint_phi, not both.\")\n\n    if (is_empty(con_h_expr) and is_empty(con_phi_expr)):\n        # both empty -> nothing to generate\n        return\n\n    if is_empty(con_h_expr):\n        constr_type = 'BGP'\n    else:\n        constr_type = 'BGH'\n\n    if is_empty(p):\n        p = symbol('p', 0, 0)\n\n    if is_empty(z):\n        z = symbol('z', 0, 0)\n\n    if not (is_empty(con_h_expr)) and opts['generate_hess']:\n        # multipliers for hessian\n        nh = casadi_length(con_h_expr)\n        lam_h = symbol('lam_h', nh, 1)\n\n    # set up & change directory\n    cwd = os.getcwd()\n    constraints_dir = os.path.abspath(os.path.join(opts[\"code_export_directory\"], f'{model.name}_constraints'))\n    if not os.path.exists(constraints_dir):\n        os.makedirs(constraints_dir)\n    os.chdir(constraints_dir)\n\n    # export casadi functions\n    if constr_type == 'BGH':\n        if is_terminal:\n            fun_name = con_name + '_constr_h_e_fun_jac_uxt_zt'\n        else:\n            fun_name = con_name + '_constr_h_fun_jac_uxt_zt'\n\n        jac_ux_t = ca.transpose(ca.jacobian(con_h_expr, ca.vertcat(u,x)))\n        jac_z_t = ca.jacobian(con_h_expr, z)\n        constraint_fun_jac_tran = ca.Function(fun_name, [x, u, z, p], \\\n                [con_h_expr, jac_ux_t, jac_z_t])\n\n        constraint_fun_jac_tran.generate(fun_name, casadi_codegen_opts)\n        if opts['generate_hess']:\n\n            if is_terminal:\n                fun_name = con_name + '_constr_h_e_fun_jac_uxt_zt_hess'\n            else:\n                fun_name = con_name + '_constr_h_fun_jac_uxt_zt_hess'\n\n            # adjoint\n            adj_ux = ca.jtimes(con_h_expr, ca.vertcat(u, x), lam_h, True)\n            # hessian\n            hess_ux = ca.jacobian(adj_ux, ca.vertcat(u, x))\n\n            adj_z = ca.jtimes(con_h_expr, z, lam_h, True)\n            hess_z = ca.jacobian(adj_z, z)\n\n            # set up functions\n            constraint_fun_jac_tran_hess = \\\n                ca.Function(fun_name, [x, u, lam_h, z, p], \\\n                    [con_h_expr, jac_ux_t, hess_ux, jac_z_t, hess_z])\n\n            # generate C code\n            constraint_fun_jac_tran_hess.generate(fun_name, casadi_codegen_opts)\n\n        if is_terminal:\n            fun_name = con_name + '_constr_h_e_fun'\n        else:\n            fun_name = con_name + '_constr_h_fun'\n        h_fun = ca.Function(fun_name, [x, u, z, p], [con_h_expr])\n        h_fun.generate(fun_name, casadi_codegen_opts)\n\n    else: # BGP constraint\n        if is_terminal:\n            fun_name = con_name + '_phi_e_constraint'\n            r = model.con_r_in_phi_e\n            con_r_expr = model.con_r_expr_e\n        else:\n            fun_name = con_name + '_phi_constraint'\n            r = model.con_r_in_phi\n            con_r_expr = model.con_r_expr\n\n        nphi = casadi_length(con_phi_expr)\n        con_phi_expr_x_u_z = ca.substitute(con_phi_expr, r, con_r_expr)\n        phi_jac_u = ca.jacobian(con_phi_expr_x_u_z, u)\n        phi_jac_x = ca.jacobian(con_phi_expr_x_u_z, x)\n        phi_jac_z = ca.jacobian(con_phi_expr_x_u_z, z)\n\n        hess = ca.hessian(con_phi_expr[0], r)[0]\n        for i in range(1, nphi):\n            hess = ca.vertcat(hess, ca.hessian(con_phi_expr[i], r)[0])\n\n        r_jac_u = ca.jacobian(con_r_expr, u)\n        r_jac_x = ca.jacobian(con_r_expr, x)\n\n        constraint_phi = \\\n            ca.Function(fun_name, [x, u, z, p], \\\n                [con_phi_expr_x_u_z, \\\n                ca.vertcat(ca.transpose(phi_jac_u), ca.transpose(phi_jac_x)), \\\n                ca.transpose(phi_jac_z), \\\n                hess,\n                ca.vertcat(ca.transpose(r_jac_u), ca.transpose(r_jac_x))])\n\n        constraint_phi.generate(fun_name, casadi_codegen_opts)\n\n    # change directory back\n    os.chdir(cwd)\n\n    return\n\n", "third_party/acados/acados_template/acados_ocp_solver.py": "# -*- coding: future_fstrings -*-\n#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport sys\nimport os\nimport json\nimport numpy as np\nfrom datetime import datetime\nimport importlib\nimport shutil\n\nfrom subprocess import DEVNULL, call, STDOUT\n\nfrom ctypes import POINTER, cast, CDLL, c_void_p, c_char_p, c_double, c_int, c_int64, byref\n\nfrom copy import deepcopy\nfrom pathlib import Path\n\nfrom .casadi_function_generation import generate_c_code_explicit_ode, \\\n    generate_c_code_implicit_ode, generate_c_code_gnsf, generate_c_code_discrete_dynamics, \\\n    generate_c_code_constraint, generate_c_code_nls_cost, generate_c_code_conl_cost, \\\n    generate_c_code_external_cost\nfrom .gnsf.detect_gnsf_structure import detect_gnsf_structure\nfrom .acados_ocp import AcadosOcp\nfrom .acados_model import AcadosModel\nfrom .utils import is_column, is_empty, casadi_length, render_template,\\\n     format_class_dict, make_object_json_dumpable, make_model_consistent,\\\n     set_up_imported_gnsf_model, get_ocp_nlp_layout, get_python_interface_path, get_lib_ext, check_casadi_version\nfrom .builders import CMakeBuilder\n\n\ndef make_ocp_dims_consistent(acados_ocp: AcadosOcp):\n    dims = acados_ocp.dims\n    cost = acados_ocp.cost\n    constraints = acados_ocp.constraints\n    model = acados_ocp.model\n    opts = acados_ocp.solver_options\n\n    # nx\n    if is_column(model.x):\n        dims.nx = casadi_length(model.x)\n    else:\n        raise Exception('model.x should be column vector!')\n\n    # nu\n    if is_empty(model.u):\n        dims.nu = 0\n    else:\n        dims.nu = casadi_length(model.u)\n\n    # nz\n    if is_empty(model.z):\n        dims.nz = 0\n    else:\n        dims.nz = casadi_length(model.z)\n\n    # np\n    if is_empty(model.p):\n        dims.np = 0\n    else:\n        dims.np = casadi_length(model.p)\n    if acados_ocp.parameter_values.shape[0] != dims.np:\n        raise Exception('inconsistent dimension np, regarding model.p and parameter_values.' + \\\n            f'\\nGot np = {dims.np}, acados_ocp.parameter_values.shape = {acados_ocp.parameter_values.shape[0]}\\n')\n\n    ## cost\n    # initial stage - if not set, copy fields from path constraints\n    if cost.cost_type_0 is None:\n        cost.cost_type_0 = cost.cost_type\n        cost.W_0 = cost.W\n        cost.Vx_0 = cost.Vx\n        cost.Vu_0 = cost.Vu\n        cost.Vz_0 = cost.Vz\n        cost.yref_0 = cost.yref\n        cost.cost_ext_fun_type_0 = cost.cost_ext_fun_type\n        model.cost_y_expr_0 = model.cost_y_expr\n        model.cost_expr_ext_cost_0 = model.cost_expr_ext_cost\n        model.cost_expr_ext_cost_custom_hess_0 = model.cost_expr_ext_cost_custom_hess\n\n        model.cost_psi_expr_0 = model.cost_psi_expr\n        model.cost_r_in_psi_expr_0 = model.cost_r_in_psi_expr\n\n    if cost.cost_type_0 == 'LINEAR_LS':\n        ny_0 = cost.W_0.shape[0]\n        if cost.Vx_0.shape[0] != ny_0 or cost.Vu_0.shape[0] != ny_0:\n            raise Exception('inconsistent dimension ny_0, regarding W_0, Vx_0, Vu_0.' + \\\n                            f'\\nGot W_0[{cost.W_0.shape}], Vx_0[{cost.Vx_0.shape}], Vu_0[{cost.Vu_0.shape}]\\n')\n        if dims.nz != 0 and cost.Vz_0.shape[0] != ny_0:\n            raise Exception('inconsistent dimension ny_0, regarding W_0, Vx_0, Vu_0, Vz_0.' + \\\n                            f'\\nGot W_0[{cost.W_0.shape}], Vx_0[{cost.Vx_0.shape}], Vu_0[{cost.Vu_0.shape}], Vz_0[{cost.Vz_0.shape}]\\n')\n        if cost.Vx_0.shape[1] != dims.nx and ny_0 != 0:\n            raise Exception('inconsistent dimension: Vx_0 should have nx columns.')\n        if cost.Vu_0.shape[1] != dims.nu and ny_0 != 0:\n            raise Exception('inconsistent dimension: Vu_0 should have nu columns.')\n        if cost.yref_0.shape[0] != ny_0:\n            raise Exception('inconsistent dimension: regarding W_0, yref_0.' + \\\n                            f'\\nGot W_0[{cost.W_0.shape}], yref_0[{cost.yref_0.shape}]\\n')\n        dims.ny_0 = ny_0\n\n    elif cost.cost_type_0 == 'NONLINEAR_LS':\n        ny_0 = cost.W_0.shape[0]\n        if is_empty(model.cost_y_expr_0) and ny_0 != 0:\n            raise Exception('inconsistent dimension ny_0: regarding W_0, cost_y_expr.')\n        elif casadi_length(model.cost_y_expr_0) != ny_0:\n            raise Exception('inconsistent dimension ny_0: regarding W_0, cost_y_expr.')\n        if cost.yref_0.shape[0] != ny_0:\n            raise Exception('inconsistent dimension: regarding W_0, yref_0.' + \\\n                            f'\\nGot W_0[{cost.W.shape}], yref_0[{cost.yref_0.shape}]\\n')\n        dims.ny_0 = ny_0\n\n    elif cost.cost_type_0 == 'CONVEX_OVER_NONLINEAR':\n        if is_empty(model.cost_y_expr_0):\n            raise Exception('cost_y_expr_0 and/or cost_y_expr not provided.')\n        ny_0 = casadi_length(model.cost_y_expr_0)\n        if is_empty(model.cost_r_in_psi_expr_0) or casadi_length(model.cost_r_in_psi_expr_0) != ny_0:\n            raise Exception('inconsistent dimension ny_0: regarding cost_y_expr_0 and cost_r_in_psi_0.')\n        if is_empty(model.cost_psi_expr_0) or casadi_length(model.cost_psi_expr_0) != 1:\n            raise Exception('cost_psi_expr_0 not provided or not scalar-valued.')\n        if cost.yref_0.shape[0] != ny_0:\n            raise Exception('inconsistent dimension: regarding yref_0 and cost_y_expr_0, cost_r_in_psi_0.')\n        dims.ny_0 = ny_0\n\n        if not (opts.hessian_approx=='EXACT' and opts.exact_hess_cost==False) and opts.hessian_approx != 'GAUSS_NEWTON':\n            raise Exception(\"\\nWith CONVEX_OVER_NONLINEAR cost type, possible Hessian approximations are:\\n\"\n            \"GAUSS_NEWTON or EXACT with 'exact_hess_cost' == False.\\n\")\n\n    elif cost.cost_type_0 == 'EXTERNAL':\n        if opts.hessian_approx == 'GAUSS_NEWTON' and opts.ext_cost_num_hess == 0 and model.cost_expr_ext_cost_custom_hess_0 is None:\n            print(\"\\nWARNING: Gauss-Newton Hessian approximation with EXTERNAL cost type not possible!\\n\"\n            \"got cost_type_0: EXTERNAL, hessian_approx: 'GAUSS_NEWTON.'\\n\"\n            \"GAUSS_NEWTON hessian is only supported for cost_types [NON]LINEAR_LS.\\n\"\n            \"If you continue, acados will proceed computing the exact hessian for the cost term.\\n\"\n            \"Note: There is also the option to use the external cost module with a numerical hessian approximation (see `ext_cost_num_hess`).\\n\"\n            \"OR the option to provide a symbolic custom hessian approximation (see `cost_expr_ext_cost_custom_hess`).\\n\")\n\n    # path\n    if cost.cost_type == 'LINEAR_LS':\n        ny = cost.W.shape[0]\n        if cost.Vx.shape[0] != ny or cost.Vu.shape[0] != ny:\n            raise Exception('inconsistent dimension ny, regarding W, Vx, Vu.' + \\\n                            f'\\nGot W[{cost.W.shape}], Vx[{cost.Vx.shape}], Vu[{cost.Vu.shape}]\\n')\n        if dims.nz != 0 and cost.Vz.shape[0] != ny:\n            raise Exception('inconsistent dimension ny, regarding W, Vx, Vu, Vz.' + \\\n                            f'\\nGot W[{cost.W.shape}], Vx[{cost.Vx.shape}], Vu[{cost.Vu.shape}], Vz[{cost.Vz.shape}]\\n')\n        if cost.Vx.shape[1] != dims.nx and ny != 0:\n            raise Exception('inconsistent dimension: Vx should have nx columns.')\n        if cost.Vu.shape[1] != dims.nu and ny != 0:\n            raise Exception('inconsistent dimension: Vu should have nu columns.')\n        if cost.yref.shape[0] != ny:\n            raise Exception('inconsistent dimension: regarding W, yref.' + \\\n                            f'\\nGot W[{cost.W.shape}], yref[{cost.yref.shape}]\\n')\n        dims.ny = ny\n\n    elif cost.cost_type == 'NONLINEAR_LS':\n        ny = cost.W.shape[0]\n        if is_empty(model.cost_y_expr) and ny != 0:\n            raise Exception('inconsistent dimension ny: regarding W, cost_y_expr.')\n        elif casadi_length(model.cost_y_expr) != ny:\n            raise Exception('inconsistent dimension ny: regarding W, cost_y_expr.')\n        if cost.yref.shape[0] != ny:\n            raise Exception('inconsistent dimension: regarding W, yref.' + \\\n                            f'\\nGot W[{cost.W.shape}], yref[{cost.yref.shape}]\\n')\n        dims.ny = ny\n\n    elif cost.cost_type == 'CONVEX_OVER_NONLINEAR':\n        if is_empty(model.cost_y_expr):\n            raise Exception('cost_y_expr and/or cost_y_expr not provided.')\n        ny = casadi_length(model.cost_y_expr)\n        if is_empty(model.cost_r_in_psi_expr) or casadi_length(model.cost_r_in_psi_expr) != ny:\n            raise Exception('inconsistent dimension ny: regarding cost_y_expr and cost_r_in_psi.')\n        if is_empty(model.cost_psi_expr) or casadi_length(model.cost_psi_expr) != 1:\n            raise Exception('cost_psi_expr not provided or not scalar-valued.')\n        if cost.yref.shape[0] != ny:\n            raise Exception('inconsistent dimension: regarding yref and cost_y_expr, cost_r_in_psi.')\n        dims.ny = ny\n\n        if not (opts.hessian_approx=='EXACT' and opts.exact_hess_cost==False) and opts.hessian_approx != 'GAUSS_NEWTON':\n            raise Exception(\"\\nWith CONVEX_OVER_NONLINEAR cost type, possible Hessian approximations are:\\n\"\n            \"GAUSS_NEWTON or EXACT with 'exact_hess_cost' == False.\\n\")\n\n\n    elif cost.cost_type == 'EXTERNAL':\n        if opts.hessian_approx == 'GAUSS_NEWTON' and opts.ext_cost_num_hess == 0 and model.cost_expr_ext_cost_custom_hess is None:\n            print(\"\\nWARNING: Gauss-Newton Hessian approximation with EXTERNAL cost type not possible!\\n\"\n            \"got cost_type: EXTERNAL, hessian_approx: 'GAUSS_NEWTON.'\\n\"\n            \"GAUSS_NEWTON hessian is only supported for cost_types [NON]LINEAR_LS.\\n\"\n            \"If you continue, acados will proceed computing the exact hessian for the cost term.\\n\"\n            \"Note: There is also the option to use the external cost module with a numerical hessian approximation (see `ext_cost_num_hess`).\\n\"\n            \"OR the option to provide a symbolic custom hessian approximation (see `cost_expr_ext_cost_custom_hess`).\\n\")\n\n    # terminal\n    if cost.cost_type_e == 'LINEAR_LS':\n        ny_e = cost.W_e.shape[0]\n        if cost.Vx_e.shape[0] != ny_e:\n            raise Exception('inconsistent dimension ny_e: regarding W_e, cost_y_expr_e.' + \\\n                f'\\nGot W_e[{cost.W_e.shape}], Vx_e[{cost.Vx_e.shape}]')\n        if cost.Vx_e.shape[1] != dims.nx and ny_e != 0:\n            raise Exception('inconsistent dimension: Vx_e should have nx columns.')\n        if cost.yref_e.shape[0] != ny_e:\n            raise Exception('inconsistent dimension: regarding W_e, yref_e.')\n        dims.ny_e = ny_e\n\n    elif cost.cost_type_e == 'NONLINEAR_LS':\n        ny_e = cost.W_e.shape[0]\n        if is_empty(model.cost_y_expr_e) and ny_e != 0:\n            raise Exception('inconsistent dimension ny_e: regarding W_e, cost_y_expr_e.')\n        elif casadi_length(model.cost_y_expr_e) != ny_e:\n            raise Exception('inconsistent dimension ny_e: regarding W_e, cost_y_expr_e.')\n        if cost.yref_e.shape[0] != ny_e:\n            raise Exception('inconsistent dimension: regarding W_e, yref_e.')\n        dims.ny_e = ny_e\n\n    elif cost.cost_type_e == 'CONVEX_OVER_NONLINEAR':\n        if is_empty(model.cost_y_expr_e):\n            raise Exception('cost_y_expr_e not provided.')\n        ny_e = casadi_length(model.cost_y_expr_e)\n        if is_empty(model.cost_r_in_psi_expr_e) or casadi_length(model.cost_r_in_psi_expr_e) != ny_e:\n            raise Exception('inconsistent dimension ny_e: regarding cost_y_expr_e and cost_r_in_psi_e.')\n        if is_empty(model.cost_psi_expr_e) or casadi_length(model.cost_psi_expr_e) != 1:\n            raise Exception('cost_psi_expr_e not provided or not scalar-valued.')\n        if cost.yref_e.shape[0] != ny_e:\n            raise Exception('inconsistent dimension: regarding yref_e and cost_y_expr_e, cost_r_in_psi_e.')\n        dims.ny_e = ny_e\n\n        if not (opts.hessian_approx=='EXACT' and opts.exact_hess_cost==False) and opts.hessian_approx != 'GAUSS_NEWTON':\n            raise Exception(\"\\nWith CONVEX_OVER_NONLINEAR cost type, possible Hessian approximations are:\\n\"\n            \"GAUSS_NEWTON or EXACT with 'exact_hess_cost' == False.\\n\")\n\n\n\n    elif cost.cost_type_e == 'EXTERNAL':\n        if opts.hessian_approx == 'GAUSS_NEWTON' and opts.ext_cost_num_hess == 0 and model.cost_expr_ext_cost_custom_hess_e is None:\n            print(\"\\nWARNING: Gauss-Newton Hessian approximation with EXTERNAL cost type not possible!\\n\"\n            \"got cost_type_e: EXTERNAL, hessian_approx: 'GAUSS_NEWTON.'\\n\"\n            \"GAUSS_NEWTON hessian is only supported for cost_types [NON]LINEAR_LS.\\n\"\n            \"If you continue, acados will proceed computing the exact hessian for the cost term.\\n\"\n            \"Note: There is also the option to use the external cost module with a numerical hessian approximation (see `ext_cost_num_hess`).\\n\"\n            \"OR the option to provide a symbolic custom hessian approximation (see `cost_expr_ext_cost_custom_hess`).\\n\")\n\n    ## constraints\n    # initial\n    this_shape = constraints.lbx_0.shape\n    other_shape = constraints.ubx_0.shape\n    if not this_shape == other_shape:\n        raise Exception('lbx_0, ubx_0 have different shapes!')\n    if not is_column(constraints.lbx_0):\n        raise Exception('lbx_0, ubx_0 must be column vectors!')\n    dims.nbx_0 = constraints.lbx_0.size\n\n    if all(constraints.lbx_0 == constraints.ubx_0) and dims.nbx_0 == dims.nx \\\n        and dims.nbxe_0 is None \\\n        and (constraints.idxbxe_0.shape == constraints.idxbx_0.shape)\\\n            and all(constraints.idxbxe_0 == constraints.idxbx_0):\n        # case: x0 was set: nbx0 are all equlities.\n        dims.nbxe_0 = dims.nbx_0\n    elif constraints.idxbxe_0 is not None:\n        dims.nbxe_0 = constraints.idxbxe_0.shape[0]\n    elif dims.nbxe_0 is None:\n        # case: x0 and idxbxe_0 were not set -> dont assume nbx0 to be equality constraints.\n        dims.nbxe_0 = 0\n\n    # path\n    nbx = constraints.idxbx.shape[0]\n    if constraints.ubx.shape[0] != nbx or constraints.lbx.shape[0] != nbx:\n        raise Exception('inconsistent dimension nbx, regarding idxbx, ubx, lbx.')\n    else:\n        dims.nbx = nbx\n\n    nbu = constraints.idxbu.shape[0]\n    if constraints.ubu.shape[0] != nbu or constraints.lbu.shape[0] != nbu:\n        raise Exception('inconsistent dimension nbu, regarding idxbu, ubu, lbu.')\n    else:\n        dims.nbu = nbu\n\n    ng = constraints.lg.shape[0]\n    if constraints.ug.shape[0] != ng or constraints.C.shape[0] != ng \\\n       or constraints.D.shape[0] != ng:\n        raise Exception('inconsistent dimension ng, regarding lg, ug, C, D.')\n    else:\n        dims.ng = ng\n\n    if not is_empty(model.con_h_expr):\n        nh = casadi_length(model.con_h_expr)\n    else:\n        nh = 0\n\n    if constraints.uh.shape[0] != nh or constraints.lh.shape[0] != nh:\n        raise Exception('inconsistent dimension nh, regarding lh, uh, con_h_expr.')\n    else:\n        dims.nh = nh\n\n    if is_empty(model.con_phi_expr):\n        dims.nphi = 0\n        dims.nr = 0\n    else:\n        dims.nphi = casadi_length(model.con_phi_expr)\n        if is_empty(model.con_r_expr):\n            raise Exception('convex over nonlinear constraints: con_r_expr but con_phi_expr is nonempty')\n        else:\n            dims.nr = casadi_length(model.con_r_expr)\n\n    # terminal\n    nbx_e = constraints.idxbx_e.shape[0]\n    if constraints.ubx_e.shape[0] != nbx_e or constraints.lbx_e.shape[0] != nbx_e:\n        raise Exception('inconsistent dimension nbx_e, regarding idxbx_e, ubx_e, lbx_e.')\n    else:\n        dims.nbx_e = nbx_e\n\n    ng_e = constraints.lg_e.shape[0]\n    if constraints.ug_e.shape[0] != ng_e or constraints.C_e.shape[0] != ng_e:\n        raise Exception('inconsistent dimension ng_e, regarding_e lg_e, ug_e, C_e.')\n    else:\n        dims.ng_e = ng_e\n\n    if not is_empty(model.con_h_expr_e):\n        nh_e = casadi_length(model.con_h_expr_e)\n    else:\n        nh_e = 0\n\n    if constraints.uh_e.shape[0] != nh_e or constraints.lh_e.shape[0] != nh_e:\n        raise Exception('inconsistent dimension nh_e, regarding lh_e, uh_e, con_h_expr_e.')\n    else:\n        dims.nh_e = nh_e\n\n    if is_empty(model.con_phi_expr_e):\n        dims.nphi_e = 0\n        dims.nr_e = 0\n    else:\n        dims.nphi_e = casadi_length(model.con_phi_expr_e)\n        if is_empty(model.con_r_expr_e):\n            raise Exception('convex over nonlinear constraints: con_r_expr_e but con_phi_expr_e is nonempty')\n        else:\n            dims.nr_e = casadi_length(model.con_r_expr_e)\n\n    # Slack dimensions\n    nsbx = constraints.idxsbx.shape[0]\n    if nsbx > nbx:\n        raise Exception(f'inconsistent dimension nsbx = {nsbx}. Is greater than nbx = {nbx}.')\n    if is_empty(constraints.lsbx):\n        constraints.lsbx = np.zeros((nsbx,))\n    elif constraints.lsbx.shape[0] != nsbx:\n        raise Exception('inconsistent dimension nsbx, regarding idxsbx, lsbx.')\n    if is_empty(constraints.usbx):\n        constraints.usbx = np.zeros((nsbx,))\n    elif constraints.usbx.shape[0] != nsbx:\n        raise Exception('inconsistent dimension nsbx, regarding idxsbx, usbx.')\n    dims.nsbx = nsbx\n\n    nsbu = constraints.idxsbu.shape[0]\n    if nsbu > nbu:\n        raise Exception(f'inconsistent dimension nsbu = {nsbu}. Is greater than nbu = {nbu}.')\n    if is_empty(constraints.lsbu):\n        constraints.lsbu = np.zeros((nsbu,))\n    elif constraints.lsbu.shape[0] != nsbu:\n        raise Exception('inconsistent dimension nsbu, regarding idxsbu, lsbu.')\n    if is_empty(constraints.usbu):\n        constraints.usbu = np.zeros((nsbu,))\n    elif constraints.usbu.shape[0] != nsbu:\n        raise Exception('inconsistent dimension nsbu, regarding idxsbu, usbu.')\n    dims.nsbu = nsbu\n\n    nsh = constraints.idxsh.shape[0]\n    if nsh > nh:\n        raise Exception(f'inconsistent dimension nsh = {nsh}. Is greater than nh = {nh}.')\n    if is_empty(constraints.lsh):\n        constraints.lsh = np.zeros((nsh,))\n    elif constraints.lsh.shape[0] != nsh:\n        raise Exception('inconsistent dimension nsh, regarding idxsh, lsh.')\n    if is_empty(constraints.ush):\n        constraints.ush = np.zeros((nsh,))\n    elif constraints.ush.shape[0] != nsh:\n        raise Exception('inconsistent dimension nsh, regarding idxsh, ush.')\n    dims.nsh = nsh\n\n    nsphi = constraints.idxsphi.shape[0]\n    if nsphi > dims.nphi:\n        raise Exception(f'inconsistent dimension nsphi = {nsphi}. Is greater than nphi = {dims.nphi}.')\n    if is_empty(constraints.lsphi):\n        constraints.lsphi = np.zeros((nsphi,))\n    elif constraints.lsphi.shape[0] != nsphi:\n        raise Exception('inconsistent dimension nsphi, regarding idxsphi, lsphi.')\n    if is_empty(constraints.usphi):\n        constraints.usphi = np.zeros((nsphi,))\n    elif constraints.usphi.shape[0] != nsphi:\n        raise Exception('inconsistent dimension nsphi, regarding idxsphi, usphi.')\n    dims.nsphi = nsphi\n\n    nsg = constraints.idxsg.shape[0]\n    if nsg > ng:\n        raise Exception(f'inconsistent dimension nsg = {nsg}. Is greater than ng = {ng}.')\n    if is_empty(constraints.lsg):\n        constraints.lsg = np.zeros((nsg,))\n    elif constraints.lsg.shape[0] != nsg:\n        raise Exception('inconsistent dimension nsg, regarding idxsg, lsg.')\n    if is_empty(constraints.usg):\n        constraints.usg = np.zeros((nsg,))\n    elif constraints.usg.shape[0] != nsg:\n        raise Exception('inconsistent dimension nsg, regarding idxsg, usg.')\n    dims.nsg = nsg\n\n    ns = nsbx + nsbu + nsh + nsg + nsphi\n    wrong_field = \"\"\n    if cost.Zl.shape[0] != ns:\n        wrong_field = \"Zl\"\n        dim = cost.Zl.shape[0]\n    elif cost.Zu.shape[0] != ns:\n        wrong_field = \"Zu\"\n        dim = cost.Zu.shape[0]\n    elif cost.zl.shape[0] != ns:\n        wrong_field = \"zl\"\n        dim = cost.zl.shape[0]\n    elif cost.zu.shape[0] != ns:\n        wrong_field = \"zu\"\n        dim = cost.zu.shape[0]\n\n    if wrong_field != \"\":\n        raise Exception(f'Inconsistent size for field {wrong_field}, with dimension {dim}, \\n\\t'\\\n            + f'Detected ns = {ns} = nsbx + nsbu + nsg + nsh + nsphi.\\n\\t'\\\n            + f'With nsbx = {nsbx}, nsbu = {nsbu}, nsg = {nsg}, nsh = {nsh}, nsphi = {nsphi}')\n\n    dims.ns = ns\n\n    nsbx_e = constraints.idxsbx_e.shape[0]\n    if nsbx_e > nbx_e:\n        raise Exception(f'inconsistent dimension nsbx_e = {nsbx_e}. Is greater than nbx_e = {nbx_e}.')\n    if is_empty(constraints.lsbx_e):\n        constraints.lsbx_e = np.zeros((nsbx_e,))\n    elif constraints.lsbx_e.shape[0] != nsbx_e:\n        raise Exception('inconsistent dimension nsbx_e, regarding idxsbx_e, lsbx_e.')\n    if is_empty(constraints.usbx_e):\n        constraints.usbx_e = np.zeros((nsbx_e,))\n    elif constraints.usbx_e.shape[0] != nsbx_e:\n        raise Exception('inconsistent dimension nsbx_e, regarding idxsbx_e, usbx_e.')\n    dims.nsbx_e = nsbx_e\n\n    nsh_e = constraints.idxsh_e.shape[0]\n    if nsh_e > nh_e:\n        raise Exception(f'inconsistent dimension nsh_e = {nsh_e}. Is greater than nh_e = {nh_e}.')\n    if is_empty(constraints.lsh_e):\n        constraints.lsh_e = np.zeros((nsh_e,))\n    elif constraints.lsh_e.shape[0] != nsh_e:\n        raise Exception('inconsistent dimension nsh_e, regarding idxsh_e, lsh_e.')\n    if is_empty(constraints.ush_e):\n        constraints.ush_e = np.zeros((nsh_e,))\n    elif constraints.ush_e.shape[0] != nsh_e:\n        raise Exception('inconsistent dimension nsh_e, regarding idxsh_e, ush_e.')\n    dims.nsh_e = nsh_e\n\n    nsg_e = constraints.idxsg_e.shape[0]\n    if nsg_e > ng_e:\n        raise Exception(f'inconsistent dimension nsg_e = {nsg_e}. Is greater than ng_e = {ng_e}.')\n    if is_empty(constraints.lsg_e):\n        constraints.lsg_e = np.zeros((nsg_e,))\n    elif constraints.lsg_e.shape[0] != nsg_e:\n        raise Exception('inconsistent dimension nsg_e, regarding idxsg_e, lsg_e.')\n    if is_empty(constraints.usg_e):\n        constraints.usg_e = np.zeros((nsg_e,))\n    elif constraints.usg_e.shape[0] != nsg_e:\n        raise Exception('inconsistent dimension nsg_e, regarding idxsg_e, usg_e.')\n    dims.nsg_e = nsg_e\n\n    nsphi_e = constraints.idxsphi_e.shape[0]\n    if nsphi_e > dims.nphi_e:\n        raise Exception(f'inconsistent dimension nsphi_e = {nsphi_e}. Is greater than nphi_e = {dims.nphi_e}.')\n    if is_empty(constraints.lsphi_e):\n        constraints.lsphi_e = np.zeros((nsphi_e,))\n    elif constraints.lsphi_e.shape[0] != nsphi_e:\n        raise Exception('inconsistent dimension nsphi_e, regarding idxsphi_e, lsphi_e.')\n    if is_empty(constraints.usphi_e):\n        constraints.usphi_e = np.zeros((nsphi_e,))\n    elif constraints.usphi_e.shape[0] != nsphi_e:\n        raise Exception('inconsistent dimension nsphi_e, regarding idxsphi_e, usphi_e.')\n    dims.nsphi_e = nsphi_e\n\n    # terminal\n    ns_e = nsbx_e + nsh_e + nsg_e + nsphi_e\n    wrong_field = \"\"\n    if cost.Zl_e.shape[0] != ns_e:\n        wrong_field = \"Zl_e\"\n        dim = cost.Zl_e.shape[0]\n    elif cost.Zu_e.shape[0] != ns_e:\n        wrong_field = \"Zu_e\"\n        dim = cost.Zu_e.shape[0]\n    elif cost.zl_e.shape[0] != ns_e:\n        wrong_field = \"zl_e\"\n        dim = cost.zl_e.shape[0]\n    elif cost.zu_e.shape[0] != ns_e:\n        wrong_field = \"zu_e\"\n        dim = cost.zu_e.shape[0]\n\n    if wrong_field != \"\":\n        raise Exception(f'Inconsistent size for field {wrong_field}, with dimension {dim}, \\n\\t'\\\n            + f'Detected ns_e = {ns_e} = nsbx_e + nsg_e + nsh_e + nsphi_e.\\n\\t'\\\n            + f'With nsbx_e = {nsbx_e}, nsg_e = {nsg_e}, nsh_e = {nsh_e}, nsphi_e = {nsphi_e}')\n\n    dims.ns_e = ns_e\n\n    # discretization\n    if is_empty(opts.time_steps) and is_empty(opts.shooting_nodes):\n        # uniform discretization\n        opts.time_steps = opts.tf / dims.N * np.ones((dims.N,))\n\n    elif not is_empty(opts.shooting_nodes):\n        if np.shape(opts.shooting_nodes)[0] != dims.N+1:\n            raise Exception('inconsistent dimension N, regarding shooting_nodes.')\n\n        time_steps = opts.shooting_nodes[1:] - opts.shooting_nodes[0:-1]\n        # identify constant time_steps: due to numerical reasons the content of time_steps might vary a bit\n        avg_time_steps = np.average(time_steps)\n        # criterion for constant time step detection: the min/max difference in values normalized by the average\n        check_const_time_step = (np.max(time_steps)-np.min(time_steps)) / avg_time_steps\n        # if the criterion is small, we have a constant time_step\n        if check_const_time_step < 1e-9:\n            time_steps[:] = avg_time_steps  # if we have a constant time_step: apply the average time_step\n\n        opts.time_steps = time_steps\n\n    elif (not is_empty(opts.time_steps)) and (not is_empty(opts.shooting_nodes)):\n        Exception('Please provide either time_steps or shooting_nodes for nonuniform discretization')\n\n    tf = np.sum(opts.time_steps)\n    if (tf - opts.tf) / tf > 1e-15:\n        raise Exception(f'Inconsistent discretization: {opts.tf}'\\\n            f' = tf != sum(opts.time_steps) = {tf}.')\n\n    # num_steps\n    if isinstance(opts.sim_method_num_steps, np.ndarray) and opts.sim_method_num_steps.size == 1:\n        opts.sim_method_num_steps = opts.sim_method_num_steps.item()\n\n    if isinstance(opts.sim_method_num_steps, (int, float)) and opts.sim_method_num_steps % 1 == 0:\n        opts.sim_method_num_steps = opts.sim_method_num_steps * np.ones((dims.N,), dtype=np.int64)\n    elif isinstance(opts.sim_method_num_steps, np.ndarray) and opts.sim_method_num_steps.size == dims.N \\\n           and np.all(np.equal(np.mod(opts.sim_method_num_steps, 1), 0)):\n        opts.sim_method_num_steps = np.reshape(opts.sim_method_num_steps, (dims.N,)).astype(np.int64)\n    else:\n        raise Exception(\"Wrong value for sim_method_num_steps. Should be either int or array of ints of shape (N,).\")\n\n    # num_stages\n    if isinstance(opts.sim_method_num_stages, np.ndarray) and opts.sim_method_num_stages.size == 1:\n        opts.sim_method_num_stages = opts.sim_method_num_stages.item()\n\n    if isinstance(opts.sim_method_num_stages, (int, float)) and opts.sim_method_num_stages % 1 == 0:\n        opts.sim_method_num_stages = opts.sim_method_num_stages * np.ones((dims.N,), dtype=np.int64)\n    elif isinstance(opts.sim_method_num_stages, np.ndarray) and opts.sim_method_num_stages.size == dims.N \\\n           and np.all(np.equal(np.mod(opts.sim_method_num_stages, 1), 0)):\n        opts.sim_method_num_stages = np.reshape(opts.sim_method_num_stages, (dims.N,)).astype(np.int64)\n    else:\n        raise Exception(\"Wrong value for sim_method_num_stages. Should be either int or array of ints of shape (N,).\")\n\n    # jac_reuse\n    if isinstance(opts.sim_method_jac_reuse, np.ndarray) and opts.sim_method_jac_reuse.size == 1:\n        opts.sim_method_jac_reuse = opts.sim_method_jac_reuse.item()\n\n    if isinstance(opts.sim_method_jac_reuse, (int, float)) and opts.sim_method_jac_reuse % 1 == 0:\n        opts.sim_method_jac_reuse = opts.sim_method_jac_reuse * np.ones((dims.N,), dtype=np.int64)\n    elif isinstance(opts.sim_method_jac_reuse, np.ndarray) and opts.sim_method_jac_reuse.size == dims.N \\\n           and np.all(np.equal(np.mod(opts.sim_method_jac_reuse, 1), 0)):\n        opts.sim_method_jac_reuse = np.reshape(opts.sim_method_jac_reuse, (dims.N,)).astype(np.int64)\n    else:\n        raise Exception(\"Wrong value for sim_method_jac_reuse. Should be either int or array of ints of shape (N,).\")\n\n\ndef get_simulink_default_opts():\n    python_interface_path = get_python_interface_path()\n    abs_path = os.path.join(python_interface_path, 'simulink_default_opts.json')\n    with open(abs_path , 'r') as f:\n        simulink_default_opts = json.load(f)\n    return simulink_default_opts\n\n\ndef ocp_formulation_json_dump(acados_ocp, simulink_opts=None, json_file='acados_ocp_nlp.json'):\n    # Load acados_ocp_nlp structure description\n    ocp_layout = get_ocp_nlp_layout()\n\n    # Copy input ocp object dictionary\n    ocp_nlp_dict = dict(deepcopy(acados_ocp).__dict__)\n    # TODO: maybe make one function with formatting\n\n    for acados_struct, v in ocp_layout.items():\n        # skip non dict attributes\n        if not isinstance(v, dict):\n            continue\n        #  setattr(ocp_nlp, acados_struct, dict(getattr(acados_ocp, acados_struct).__dict__))\n        # Copy ocp object attributes dictionaries\n        ocp_nlp_dict[acados_struct]=dict(getattr(acados_ocp, acados_struct).__dict__)\n\n    ocp_nlp_dict = format_class_dict(ocp_nlp_dict)\n\n    if simulink_opts is not None:\n        ocp_nlp_dict['simulink_opts'] = simulink_opts\n\n    with open(json_file, 'w') as f:\n        json.dump(ocp_nlp_dict, f, default=make_object_json_dumpable, indent=4, sort_keys=True)\n\n\n\ndef ocp_formulation_json_load(json_file='acados_ocp_nlp.json'):\n    # Load acados_ocp_nlp structure description\n    ocp_layout = get_ocp_nlp_layout()\n\n    with open(json_file, 'r') as f:\n        ocp_nlp_json = json.load(f)\n\n    ocp_nlp_dict = json2dict(ocp_nlp_json, ocp_nlp_json['dims'])\n\n    # Instantiate AcadosOcp object\n    acados_ocp = AcadosOcp()\n\n    # load class dict\n    acados_ocp.__dict__ = ocp_nlp_dict\n\n    # load class attributes dict, dims, constraints, etc\n    for acados_struct, v in ocp_layout.items():\n        # skip non dict attributes\n        if not isinstance(v, dict):\n            continue\n        acados_attribute = getattr(acados_ocp, acados_struct)\n        acados_attribute.__dict__ = ocp_nlp_dict[acados_struct]\n        setattr(acados_ocp, acados_struct, acados_attribute)\n\n    return acados_ocp\n\n\ndef ocp_generate_external_functions(acados_ocp: AcadosOcp, model: AcadosModel):\n\n    model = make_model_consistent(model)\n\n    if acados_ocp.solver_options.hessian_approx == 'EXACT':\n        opts = dict(generate_hess=1)\n    else:\n        opts = dict(generate_hess=0)\n\n    # create code_export_dir, model_dir\n    code_export_dir = acados_ocp.code_export_directory\n    opts['code_export_directory'] = code_export_dir\n    model_dir = os.path.join(code_export_dir, model.name + '_model')\n    if not os.path.exists(model_dir):\n        os.makedirs(model_dir)\n\n    check_casadi_version()\n    # TODO: remove dir gen from all the generate_c_* functions\n    if acados_ocp.model.dyn_ext_fun_type == 'casadi':\n        if acados_ocp.solver_options.integrator_type == 'ERK':\n            generate_c_code_explicit_ode(model, opts)\n        elif acados_ocp.solver_options.integrator_type == 'IRK':\n            generate_c_code_implicit_ode(model, opts)\n        elif acados_ocp.solver_options.integrator_type == 'LIFTED_IRK':\n            generate_c_code_implicit_ode(model, opts)\n        elif acados_ocp.solver_options.integrator_type == 'GNSF':\n            generate_c_code_gnsf(model, opts)\n        elif acados_ocp.solver_options.integrator_type == 'DISCRETE':\n            generate_c_code_discrete_dynamics(model, opts)\n        else:\n            raise Exception(\"ocp_generate_external_functions: unknown integrator type.\")\n    else:\n        target_location = os.path.join(code_export_dir, model_dir, model.dyn_generic_source)\n        shutil.copyfile(model.dyn_generic_source, target_location)\n\n    if acados_ocp.dims.nphi > 0 or acados_ocp.dims.nh > 0:\n        generate_c_code_constraint(model, model.name, False, opts)\n\n    if acados_ocp.dims.nphi_e > 0 or acados_ocp.dims.nh_e > 0:\n        generate_c_code_constraint(model, model.name, True, opts)\n\n    if acados_ocp.cost.cost_type_0 == 'NONLINEAR_LS':\n        generate_c_code_nls_cost(model, model.name, 'initial', opts)\n    elif acados_ocp.cost.cost_type_0 == 'CONVEX_OVER_NONLINEAR':\n        generate_c_code_conl_cost(model, model.name, 'initial', opts)\n    elif acados_ocp.cost.cost_type_0 == 'EXTERNAL':\n        generate_c_code_external_cost(model, 'initial', opts)\n\n    if acados_ocp.cost.cost_type == 'NONLINEAR_LS':\n        generate_c_code_nls_cost(model, model.name, 'path', opts)\n    elif acados_ocp.cost.cost_type == 'CONVEX_OVER_NONLINEAR':\n        generate_c_code_conl_cost(model, model.name, 'path', opts)\n    elif acados_ocp.cost.cost_type == 'EXTERNAL':\n        generate_c_code_external_cost(model, 'path', opts)\n\n    if acados_ocp.cost.cost_type_e == 'NONLINEAR_LS':\n        generate_c_code_nls_cost(model, model.name, 'terminal', opts)\n    elif acados_ocp.cost.cost_type_e == 'CONVEX_OVER_NONLINEAR':\n        generate_c_code_conl_cost(model, model.name, 'terminal', opts)\n    elif acados_ocp.cost.cost_type_e == 'EXTERNAL':\n        generate_c_code_external_cost(model, 'terminal', opts)\n\n\ndef ocp_get_default_cmake_builder() -> CMakeBuilder:\n    \"\"\"\n    If :py:class:`~acados_template.acados_ocp_solver.AcadosOcpSolver` is used with `CMake` this function returns a good first setting.\n    :return: default :py:class:`~acados_template.builders.CMakeBuilder`\n    \"\"\"\n    cmake_builder = CMakeBuilder()\n    cmake_builder.options_on = ['BUILD_ACADOS_OCP_SOLVER_LIB']\n    return cmake_builder\n\n\n\ndef ocp_render_templates(acados_ocp: AcadosOcp, json_file, cmake_builder=None, simulink_opts=None):\n\n    # setting up loader and environment\n    json_path = os.path.abspath(json_file)\n\n    if not os.path.exists(json_path):\n        raise Exception(f'Path \"{json_path}\" not found!')\n\n    # Render templates\n    template_list = __ocp_get_template_list(acados_ocp, cmake_builder=cmake_builder, simulink_opts=simulink_opts)\n    for tup in template_list:\n        if len(tup) > 2:\n            output_dir = tup[2]\n        else:\n            output_dir = acados_ocp.code_export_directory\n        render_template(tup[0], tup[1], output_dir, json_path)\n\n    # Custom templates\n    acados_template_path = os.path.dirname(os.path.abspath(__file__))\n    custom_template_glob = os.path.join(acados_template_path, 'custom_update_templates', '*')\n    for tup in acados_ocp.solver_options.custom_templates:\n        render_template(tup[0], tup[1], acados_ocp.code_export_directory, json_path, template_glob=custom_template_glob)\n\n    return\n\n\n\ndef __ocp_get_template_list(acados_ocp: AcadosOcp, cmake_builder=None, simulink_opts=None) -> list:\n    \"\"\"\n    returns a list of tuples in the form:\n    (input_filename, output_filname)\n    or\n    (input_filename, output_filname, output_directory)\n    \"\"\"\n    name = acados_ocp.model.name\n    code_export_directory = acados_ocp.code_export_directory\n    template_list = []\n\n    template_list.append(('main.in.c', f'main_{name}.c'))\n    template_list.append(('acados_solver.in.c', f'acados_solver_{name}.c'))\n    template_list.append(('acados_solver.in.h', f'acados_solver_{name}.h'))\n    template_list.append(('acados_solver.in.pxd', f'acados_solver.pxd'))\n    if cmake_builder is not None:\n        template_list.append(('CMakeLists.in.txt', 'CMakeLists.txt'))\n    else:\n        template_list.append(('Makefile.in', 'Makefile'))\n\n\n    # sim\n    template_list.append(('acados_sim_solver.in.c', f'acados_sim_solver_{name}.c'))\n    template_list.append(('acados_sim_solver.in.h', f'acados_sim_solver_{name}.h'))\n    template_list.append(('main_sim.in.c', f'main_sim_{name}.c'))\n\n    # model\n    model_dir = os.path.join(code_export_directory, f'{name}_model')\n    template_list.append(('model.in.h', f'{name}_model.h', model_dir))\n    # constraints\n    constraints_dir = os.path.join(code_export_directory, f'{name}_constraints')\n    template_list.append(('constraints.in.h', f'{name}_constraints.h', constraints_dir))\n    # cost\n    cost_dir = os.path.join(code_export_directory, f'{name}_cost')\n    template_list.append(('cost.in.h', f'{name}_cost.h', cost_dir))\n\n    # Simulink\n    if simulink_opts is not None:\n        template_file = os.path.join('matlab_templates', 'acados_solver_sfun.in.c')\n        template_list.append((template_file, f'acados_solver_sfunction_{name}.c'))\n        template_file = os.path.join('matlab_templates', 'acados_solver_sfun.in.c')\n        template_list.append((template_file, f'make_sfun_{name}.m'))\n\n    return template_list\n\n\ndef remove_x0_elimination(acados_ocp):\n    acados_ocp.constraints.idxbxe_0 = np.zeros((0,))\n    acados_ocp.dims.nbxe_0 = 0\n\n\nclass AcadosOcpSolver:\n    \"\"\"\n    Class to interact with the acados ocp solver C object.\n\n        :param acados_ocp: type :py:class:`~acados_template.acados_ocp.AcadosOcp` - description of the OCP for acados\n        :param json_file: name for the json file used to render the templated code - default: acados_ocp_nlp.json\n        :param simulink_opts: Options to configure Simulink S-function blocks, mainly to activate possible Inputs and Outputs\n    \"\"\"\n    if sys.platform==\"win32\":\n        from ctypes import wintypes\n        from ctypes import WinDLL\n        dlclose = WinDLL('kernel32', use_last_error=True).FreeLibrary\n        dlclose.argtypes = [wintypes.HMODULE]\n    else:\n        dlclose = CDLL(None).dlclose\n        dlclose.argtypes = [c_void_p]\n\n    @classmethod\n    def generate(cls, acados_ocp: AcadosOcp, json_file='acados_ocp_nlp.json', simulink_opts=None, cmake_builder: CMakeBuilder = None):\n        \"\"\"\n        Generates the code for an acados OCP solver, given the description in acados_ocp.\n            :param acados_ocp: type AcadosOcp - description of the OCP for acados\n            :param json_file: name for the json file used to render the templated code - default: `acados_ocp_nlp.json`\n            :param simulink_opts: Options to configure Simulink S-function blocks, mainly to activate possible inputs and\n                   outputs; default: `None`\n            :param cmake_builder: type :py:class:`~acados_template.builders.CMakeBuilder` generate a `CMakeLists.txt` and use\n                   the `CMake` pipeline instead of a `Makefile` (`CMake` seems to be the better option in conjunction with\n                   `MS Visual Studio`); default: `None`\n        \"\"\"\n        model = acados_ocp.model\n        acados_ocp.code_export_directory = os.path.abspath(acados_ocp.code_export_directory)\n\n        # make dims consistent\n        make_ocp_dims_consistent(acados_ocp)\n\n        # module dependent post processing\n        if acados_ocp.solver_options.integrator_type == 'GNSF':\n            if 'gnsf_model' in acados_ocp.__dict__:\n                set_up_imported_gnsf_model(acados_ocp)\n            else:\n                detect_gnsf_structure(acados_ocp)\n\n        if acados_ocp.solver_options.qp_solver == 'PARTIAL_CONDENSING_QPDUNES':\n            remove_x0_elimination(acados_ocp)\n\n        # set integrator time automatically\n        acados_ocp.solver_options.Tsim = acados_ocp.solver_options.time_steps[0]\n\n        # generate external functions\n        ocp_generate_external_functions(acados_ocp, model)\n\n        # dump to json\n        acados_ocp.json_file = json_file\n        ocp_formulation_json_dump(acados_ocp, simulink_opts=simulink_opts, json_file=json_file)\n\n        # render templates\n        ocp_render_templates(acados_ocp, json_file, cmake_builder=cmake_builder, simulink_opts=simulink_opts)\n\n        # copy custom update function\n        if acados_ocp.solver_options.custom_update_filename != \"\" and acados_ocp.solver_options.custom_update_copy:\n            target_location = os.path.join(acados_ocp.code_export_directory, acados_ocp.solver_options.custom_update_filename)\n            shutil.copyfile(acados_ocp.solver_options.custom_update_filename, target_location)\n        if acados_ocp.solver_options.custom_update_header_filename != \"\" and acados_ocp.solver_options.custom_update_copy:\n            target_location = os.path.join(acados_ocp.code_export_directory, acados_ocp.solver_options.custom_update_header_filename)\n            shutil.copyfile(acados_ocp.solver_options.custom_update_header_filename, target_location)\n\n\n    @classmethod\n    def build(cls, code_export_dir, with_cython=False, cmake_builder: CMakeBuilder = None, verbose: bool = True):\n        \"\"\"\n        Builds the code for an acados OCP solver, that has been generated in code_export_dir\n            :param code_export_dir: directory in which acados OCP solver has been generated, see generate()\n            :param with_cython: option indicating if the cython interface is build, default: False.\n            :param cmake_builder: type :py:class:`~acados_template.builders.CMakeBuilder` generate a `CMakeLists.txt` and use\n                   the `CMake` pipeline instead of a `Makefile` (`CMake` seems to be the better option in conjunction with\n                   `MS Visual Studio`); default: `None`\n            :param verbose: indicating if build command is printed\n        \"\"\"\n        code_export_dir = os.path.abspath(code_export_dir)\n        cwd = os.getcwd()\n        os.chdir(code_export_dir)\n        if with_cython:\n            call(\n                ['make', 'clean_all'],\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n            call(\n                ['make', 'ocp_cython'],\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n        else:\n            if cmake_builder is not None:\n                cmake_builder.exec(code_export_dir)\n            else:\n                call(\n                    ['make', 'clean_ocp_shared_lib'],\n                    stdout=None if verbose else DEVNULL,\n                    stderr=None if verbose else STDOUT\n                )\n                call(\n                    ['make', 'ocp_shared_lib'],\n                    stdout=None if verbose else DEVNULL,\n                    stderr=None if verbose else STDOUT\n                )\n        os.chdir(cwd)\n\n\n    @classmethod\n    def create_cython_solver(cls, json_file):\n        \"\"\"\n        Returns an `AcadosOcpSolverCython` object.\n\n        This is an alternative Cython based Python wrapper to the acados OCP solver in C.\n        This offers faster interaction with the solver, because getter and setter calls, which include shape checking are done in compiled C code.\n\n        The default wrapper `AcadosOcpSolver` is based on ctypes.\n        \"\"\"\n        with open(json_file, 'r') as f:\n            acados_ocp_json = json.load(f)\n        code_export_directory = acados_ocp_json['code_export_directory']\n\n        importlib.invalidate_caches()\n        rel_code_export_directory = os.path.relpath(code_export_directory)\n        acados_ocp_solver_pyx = importlib.import_module(f'{rel_code_export_directory}.acados_ocp_solver_pyx')\n\n        AcadosOcpSolverCython = getattr(acados_ocp_solver_pyx, 'AcadosOcpSolverCython')\n        return AcadosOcpSolverCython(acados_ocp_json['model']['name'],\n                    acados_ocp_json['solver_options']['nlp_solver_type'],\n                    acados_ocp_json['dims']['N'])\n\n\n    def __init__(self, acados_ocp: AcadosOcp, json_file='acados_ocp_nlp.json', simulink_opts=None, build=True, generate=True, cmake_builder: CMakeBuilder = None, verbose=True):\n\n        self.solver_created = False\n        if generate:\n            self.generate(acados_ocp, json_file=json_file, simulink_opts=simulink_opts, cmake_builder=cmake_builder)\n\n        # load json, store options in object\n        with open(json_file, 'r') as f:\n            acados_ocp_json = json.load(f)\n        self.N = acados_ocp_json['dims']['N']\n        self.model_name = acados_ocp_json['model']['name']\n        self.solver_options = acados_ocp_json['solver_options']\n\n        acados_lib_path = acados_ocp_json['acados_lib_path']\n        code_export_directory = acados_ocp_json['code_export_directory']\n\n        if build:\n            self.build(code_export_directory, with_cython=False, cmake_builder=cmake_builder, verbose=verbose)\n\n        # prepare library loading\n        lib_prefix = 'lib'\n        lib_ext = get_lib_ext()\n        if os.name == 'nt':\n            lib_prefix = ''\n\n        # Load acados library to avoid unloading the library.\n        # This is necessary if acados was compiled with OpenMP, since the OpenMP threads can't be destroyed.\n        # Unloading a library which uses OpenMP results in a segfault (on any platform?).\n        # see [https://stackoverflow.com/questions/34439956/vc-crash-when-freeing-a-dll-built-with-openmp]\n        # or [https://python.hotexamples.com/examples/_ctypes/-/dlclose/python-dlclose-function-examples.html]\n        libacados_name = f'{lib_prefix}acados{lib_ext}'\n        libacados_filepath = os.path.join(acados_lib_path, libacados_name)\n        self.__acados_lib = CDLL(libacados_filepath)\n        # find out if acados was compiled with OpenMP\n        try:\n            self.__acados_lib_uses_omp = getattr(self.__acados_lib, 'omp_get_thread_num') is not None\n        except AttributeError as e:\n            self.__acados_lib_uses_omp = False\n        if self.__acados_lib_uses_omp:\n            print('acados was compiled with OpenMP.')\n        else:\n            print('acados was compiled without OpenMP.')\n        libacados_ocp_solver_name = f'{lib_prefix}acados_ocp_solver_{self.model_name}{lib_ext}'\n        self.shared_lib_name = os.path.join(code_export_directory, libacados_ocp_solver_name)\n\n        # get shared_lib\n        self.shared_lib = CDLL(self.shared_lib_name)\n\n        # create capsule\n        getattr(self.shared_lib, f\"{self.model_name}_acados_create_capsule\").restype = c_void_p\n        self.capsule = getattr(self.shared_lib, f\"{self.model_name}_acados_create_capsule\")()\n\n        # create solver\n        getattr(self.shared_lib, f\"{self.model_name}_acados_create\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_create\").restype = c_int\n        assert getattr(self.shared_lib, f\"{self.model_name}_acados_create\")(self.capsule)==0\n        self.solver_created = True\n\n        self.acados_ocp = acados_ocp\n\n        # get pointers solver\n        self.__get_pointers_solver()\n\n        self.status = 0\n\n        # gettable fields\n        self.__qp_dynamics_fields = ['A', 'B', 'b']\n        self.__qp_cost_fields = ['Q', 'R', 'S', 'q', 'r']\n        self.__qp_constraint_fields = ['C', 'D', 'lg', 'ug', 'lbx', 'ubx', 'lbu', 'ubu']\n\n\n    def __get_pointers_solver(self):\n        # \"\"\"\n        # Private function to get the pointers for solver\n        # \"\"\"\n        # get pointers solver\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_opts\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_opts\").restype = c_void_p\n        self.nlp_opts = getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_opts\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_dims\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_dims\").restype = c_void_p\n        self.nlp_dims = getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_dims\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_config\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_config\").restype = c_void_p\n        self.nlp_config = getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_config\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_out\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_out\").restype = c_void_p\n        self.nlp_out = getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_out\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_sens_out\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_sens_out\").restype = c_void_p\n        self.sens_out = getattr(self.shared_lib, f\"{self.model_name}_acados_get_sens_out\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_in\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_in\").restype = c_void_p\n        self.nlp_in = getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_in\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_solver\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_solver\").restype = c_void_p\n        self.nlp_solver = getattr(self.shared_lib, f\"{self.model_name}_acados_get_nlp_solver\")(self.capsule)\n\n\n\n    def solve_for_x0(self, x0_bar):\n        \"\"\"\n        Wrapper around `solve()` which sets initial state constraint, solves the OCP, and returns u0.\n        \"\"\"\n        self.set(0, \"lbx\", x0_bar)\n        self.set(0, \"ubx\", x0_bar)\n\n        status = self.solve()\n\n        if status == 2:\n            print(\"Warning: acados_ocp_solver reached maximum iterations.\")\n        elif status != 0:\n            raise Exception(f'acados acados_ocp_solver returned status {status}')\n\n        u0 = self.get(0, \"u\")\n        return u0\n\n\n    def solve(self):\n        \"\"\"\n        Solve the ocp with current input.\n        \"\"\"\n        getattr(self.shared_lib, f\"{self.model_name}_acados_solve\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_solve\").restype = c_int\n        self.status = getattr(self.shared_lib, f\"{self.model_name}_acados_solve\")(self.capsule)\n\n        return self.status\n\n\n    def custom_update(self, data_: np.ndarray):\n        \"\"\"\n        A custom function that can be implemented by a user to be called between solver calls.\n        By default this does nothing.\n        The idea is to have a convenient wrapper to do complex updates of parameters and numerical data efficiently in C,\n        in a function that is compiled into the solver library and can be conveniently used in the Python environment.\n        \"\"\"\n        data = np.ascontiguousarray(data_, dtype=np.float64)\n        c_data = cast(data.ctypes.data, POINTER(c_double))\n        data_len = len(data)\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_custom_update\").argtypes = [c_void_p, POINTER(c_double), c_int]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_custom_update\").restype = c_int\n        status = getattr(self.shared_lib, f\"{self.model_name}_acados_custom_update\")(self.capsule, c_data, data_len)\n\n        return status\n\n\n    def reset(self, reset_qp_solver_mem=1):\n        \"\"\"\n        Sets current iterate to all zeros.\n        \"\"\"\n        getattr(self.shared_lib, f\"{self.model_name}_acados_reset\").argtypes = [c_void_p, c_int]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_reset\").restype = c_int\n        getattr(self.shared_lib, f\"{self.model_name}_acados_reset\")(self.capsule, reset_qp_solver_mem)\n\n        return\n\n\n    def set_new_time_steps(self, new_time_steps):\n        \"\"\"\n        Set new time steps.\n        Recreates the solver if N changes.\n\n            :param new_time_steps: 1 dimensional np array of new time steps for the solver\n\n            .. note:: This allows for different use-cases: either set a new size of time_steps or a new distribution of\n                      the shooting nodes without changing the number, e.g., to reach a different final time. Both cases\n                      do not require a new code export and compilation.\n        \"\"\"\n\n        # unlikely but still possible\n        if not self.solver_created:\n            raise Exception('Solver was not yet created!')\n\n        # check if time steps really changed in value\n        if np.array_equal(self.solver_options['time_steps'], new_time_steps):\n            return\n\n        N = new_time_steps.size\n        new_time_steps_data = cast(new_time_steps.ctypes.data, POINTER(c_double))\n\n        # check if recreation of acados is necessary (no need to recreate acados if sizes are identical)\n        if len(self.solver_options['time_steps']) == N:\n            getattr(self.shared_lib, f\"{self.model_name}_acados_update_time_steps\").argtypes = [c_void_p, c_int, c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_update_time_steps\").restype = c_int\n            assert getattr(self.shared_lib, f\"{self.model_name}_acados_update_time_steps\")(self.capsule, N, new_time_steps_data) == 0\n        else:  # recreate the solver with the new time steps\n            self.solver_created = False\n\n            # delete old memory (analog to __del__)\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free\").argtypes = [c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free\").restype = c_int\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free\")(self.capsule)\n\n            # create solver with new time steps\n            getattr(self.shared_lib, f\"{self.model_name}_acados_create_with_discretization\").argtypes = [c_void_p, c_int, c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_create_with_discretization\").restype = c_int\n            assert getattr(self.shared_lib, f\"{self.model_name}_acados_create_with_discretization\")(self.capsule, N, new_time_steps_data) == 0\n\n            self.solver_created = True\n\n            # get pointers solver\n            self.__get_pointers_solver()\n\n        # store time_steps, N\n        self.solver_options['time_steps'] = new_time_steps\n        self.N = N\n        self.solver_options['Tsim'] = self.solver_options['time_steps'][0]\n\n\n    def update_qp_solver_cond_N(self, qp_solver_cond_N: int):\n        \"\"\"\n        Recreate solver with new value `qp_solver_cond_N` with a partial condensing QP solver.\n        This function is relevant for code reuse, i.e., if either `set_new_time_steps(...)` is used or\n        the influence of a different `qp_solver_cond_N` is studied without code export and compilation.\n            :param qp_solver_cond_N: new number of condensing stages for the solver\n\n            .. note:: This function can only be used in combination with a partial condensing QP solver.\n\n            .. note:: After `set_new_time_steps(...)` is used and depending on the new number of time steps it might be\n                      necessary to change `qp_solver_cond_N` as well (using this function), i.e., typically\n                      `qp_solver_cond_N < N`.\n        \"\"\"\n        # unlikely but still possible\n        if not self.solver_created:\n            raise Exception('Solver was not yet created!')\n        if self.N < qp_solver_cond_N:\n            raise Exception('Setting qp_solver_cond_N to be larger than N does not work!')\n        if self.solver_options['qp_solver_cond_N'] != qp_solver_cond_N:\n            self.solver_created = False\n\n            # recreate the solver\n            fun_name = f'{self.model_name}_acados_update_qp_solver_cond_N'\n            getattr(self.shared_lib, fun_name).argtypes = [c_void_p, c_int]\n            getattr(self.shared_lib, fun_name).restype = c_int\n            assert getattr(self.shared_lib, fun_name)(self.capsule, qp_solver_cond_N) == 0\n\n            # store the new value\n            self.solver_options['qp_solver_cond_N'] = qp_solver_cond_N\n            self.solver_created = True\n\n            # get pointers solver\n            self.__get_pointers_solver()\n\n\n    def eval_param_sens(self, index, stage=0, field=\"ex\"):\n        \"\"\"\n        Calculate the sensitivity of the curent solution with respect to the initial state component of index\n\n            :param index: integer corresponding to initial state index in range(nx)\n        \"\"\"\n\n        field_ = field\n        field = field_.encode('utf-8')\n\n        # checks\n        if not isinstance(index, int):\n            raise Exception('AcadosOcpSolver.eval_param_sens(): index must be Integer.')\n\n        self.shared_lib.ocp_nlp_dims_get_from_attr.argtypes = [c_void_p, c_void_p, c_void_p, c_int, c_char_p]\n        self.shared_lib.ocp_nlp_dims_get_from_attr.restype = c_int\n        nx = self.shared_lib.ocp_nlp_dims_get_from_attr(self.nlp_config, self.nlp_dims, self.nlp_out, 0, \"x\".encode('utf-8'))\n\n        if index < 0 or index > nx:\n            raise Exception(f'AcadosOcpSolver.eval_param_sens(): index must be in [0, nx-1], got: {index}.')\n\n        # actual eval_param\n        self.shared_lib.ocp_nlp_eval_param_sens.argtypes = [c_void_p, c_char_p, c_int, c_int, c_void_p]\n        self.shared_lib.ocp_nlp_eval_param_sens.restype = None\n        self.shared_lib.ocp_nlp_eval_param_sens(self.nlp_solver, field, stage, index, self.sens_out)\n\n        return\n\n\n    def get(self, stage_, field_):\n        \"\"\"\n        Get the last solution of the solver:\n\n            :param stage: integer corresponding to shooting node\n            :param field: string in ['x', 'u', 'z', 'pi', 'lam', 't', 'sl', 'su',]\n\n            .. note:: regarding lam, t: \\n\n                    the inequalities are internally organized in the following order: \\n\n                    [ lbu lbx lg lh lphi ubu ubx ug uh uphi; \\n\n                      lsbu lsbx lsg lsh lsphi usbu usbx usg ush usphi]\n\n            .. note:: pi: multipliers for dynamics equality constraints \\n\n                      lam: multipliers for inequalities \\n\n                      t: slack variables corresponding to evaluation of all inequalities (at the solution) \\n\n                      sl: slack variables of soft lower inequality constraints \\n\n                      su: slack variables of soft upper inequality constraints \\n\n        \"\"\"\n\n        out_fields = ['x', 'u', 'z', 'pi', 'lam', 't', 'sl', 'su']\n        # mem_fields = ['sl', 'su']\n        sens_fields = ['sens_u', \"sens_x\"]\n        all_fields = out_fields + sens_fields\n\n        field = field_\n\n        if (field_ not in all_fields):\n            raise Exception(f'AcadosOcpSolver.get(stage={stage_}, field={field_}): \\'{field_}\\' is an invalid argument.\\\n                    \\n Possible values are {all_fields}.')\n\n        if not isinstance(stage_, int):\n            raise Exception(f'AcadosOcpSolver.get(stage={stage_}, field={field_}): stage index must be an integer, got type {type(stage_)}.')\n\n        if stage_ < 0 or stage_ > self.N:\n            raise Exception(f'AcadosOcpSolver.get(stage={stage_}, field={field_}): stage index must be in [0, {self.N}], got: {stage_}.')\n\n        if stage_ == self.N and field_ == 'pi':\n            raise Exception(f'AcadosOcpSolver.get(stage={stage_}, field={field_}): field \\'{field_}\\' does not exist at final stage {stage_}.')\n\n        if field_ in sens_fields:\n            field = field_.replace('sens_', '')\n\n        field = field.encode('utf-8')\n\n        self.shared_lib.ocp_nlp_dims_get_from_attr.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p]\n        self.shared_lib.ocp_nlp_dims_get_from_attr.restype = c_int\n\n        dims = self.shared_lib.ocp_nlp_dims_get_from_attr(self.nlp_config, \\\n            self.nlp_dims, self.nlp_out, stage_, field)\n\n        out = np.ascontiguousarray(np.zeros((dims,)), dtype=np.float64)\n        out_data = cast(out.ctypes.data, POINTER(c_double))\n\n        if (field_ in out_fields):\n            self.shared_lib.ocp_nlp_out_get.argtypes = \\\n                [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n            self.shared_lib.ocp_nlp_out_get(self.nlp_config, \\\n                self.nlp_dims, self.nlp_out, stage_, field, out_data)\n        # elif field_ in mem_fields:\n        #     self.shared_lib.ocp_nlp_get_at_stage.argtypes = \\\n        #         [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n        #     self.shared_lib.ocp_nlp_get_at_stage(self.nlp_config, \\\n        #         self.nlp_dims, self.nlp_solver, stage_, field, out_data)\n        elif field_ in sens_fields:\n            self.shared_lib.ocp_nlp_out_get.argtypes = \\\n                [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n            self.shared_lib.ocp_nlp_out_get(self.nlp_config, \\\n                self.nlp_dims, self.sens_out, stage_, field, out_data)\n\n        return out\n\n\n    def print_statistics(self):\n        \"\"\"\n        prints statistics of previous solver run as a table:\n            - iter: iteration number\n            - res_stat: stationarity residual\n            - res_eq: residual wrt equality constraints (dynamics)\n            - res_ineq: residual wrt inequality constraints (constraints)\n            - res_comp: residual wrt complementarity conditions\n            - qp_stat: status of QP solver\n            - qp_iter: number of QP iterations\n            - alpha: SQP step size\n            - qp_res_stat: stationarity residual of the last QP solution\n            - qp_res_eq: residual wrt equality constraints (dynamics) of the last QP solution\n            - qp_res_ineq: residual wrt inequality constraints (constraints)  of the last QP solution\n            - qp_res_comp: residual wrt complementarity conditions of the last QP solution\n        \"\"\"\n        stat = self.get_stats(\"statistics\")\n\n        if self.solver_options['nlp_solver_type'] == 'SQP':\n            print('\\niter\\tres_stat\\tres_eq\\t\\tres_ineq\\tres_comp\\tqp_stat\\tqp_iter\\talpha')\n            if stat.shape[0]>8:\n                print('\\tqp_res_stat\\tqp_res_eq\\tqp_res_ineq\\tqp_res_comp')\n            for jj in range(stat.shape[1]):\n                print(f'{int(stat[0][jj]):d}\\t{stat[1][jj]:e}\\t{stat[2][jj]:e}\\t{stat[3][jj]:e}\\t' +\n                      f'{stat[4][jj]:e}\\t{int(stat[5][jj]):d}\\t{int(stat[6][jj]):d}\\t{stat[7][jj]:e}\\t')\n                if stat.shape[0]>8:\n                    print('\\t{:e}\\t{:e}\\t{:e}\\t{:e}'.format( \\\n                        stat[8][jj], stat[9][jj], stat[10][jj], stat[11][jj]))\n            print('\\n')\n        elif self.solver_options['nlp_solver_type'] == 'SQP_RTI':\n            print('\\niter\\tqp_stat\\tqp_iter')\n            if stat.shape[0]>3:\n                print('\\tqp_res_stat\\tqp_res_eq\\tqp_res_ineq\\tqp_res_comp')\n            for jj in range(stat.shape[1]):\n                print('{:d}\\t{:d}\\t{:d}'.format( int(stat[0][jj]), int(stat[1][jj]), int(stat[2][jj])))\n                if stat.shape[0]>3:\n                    print('\\t{:e}\\t{:e}\\t{:e}\\t{:e}'.format( \\\n                         stat[3][jj], stat[4][jj], stat[5][jj], stat[6][jj]))\n            print('\\n')\n\n        return\n\n\n    def store_iterate(self, filename: str = '', overwrite=False):\n        \"\"\"\n        Stores the current iterate of the ocp solver in a json file.\n\n            :param filename: if not set, use f'{self.model_name}_iterate.json'\n            :param overwrite: if false and filename exists add timestamp to filename\n        \"\"\"\n        if filename == '':\n            filename = f'{self.model_name}_iterate.json'\n\n        if not overwrite:\n            # append timestamp\n            if os.path.isfile(filename):\n                filename = filename[:-5]\n                filename += datetime.utcnow().strftime('%Y-%m-%d-%H:%M:%S.%f') + '.json'\n\n        # get iterate:\n        solution = dict()\n\n        lN = len(str(self.N+1))\n        for i in range(self.N+1):\n            i_string = f'{i:0{lN}d}'\n            solution['x_'+i_string] = self.get(i,'x')\n            solution['u_'+i_string] = self.get(i,'u')\n            solution['z_'+i_string] = self.get(i,'z')\n            solution['lam_'+i_string] = self.get(i,'lam')\n            solution['t_'+i_string] = self.get(i, 't')\n            solution['sl_'+i_string] = self.get(i, 'sl')\n            solution['su_'+i_string] = self.get(i, 'su')\n            if i < self.N:\n                solution['pi_'+i_string] = self.get(i,'pi')\n\n        for k in list(solution.keys()):\n            if len(solution[k]) == 0:\n                del solution[k]\n\n        # save\n        with open(filename, 'w') as f:\n            json.dump(solution, f, default=make_object_json_dumpable, indent=4, sort_keys=True)\n        print(\"stored current iterate in \", os.path.join(os.getcwd(), filename))\n\n\n\n    def dump_last_qp_to_json(self, filename: str = '', overwrite=False):\n        \"\"\"\n        Dumps the latest QP data into a json file\n\n            :param filename: if not set, use model_name + timestamp + '.json'\n            :param overwrite: if false and filename exists add timestamp to filename\n        \"\"\"\n        if filename == '':\n            filename = f'{self.model_name}_QP.json'\n\n        if not overwrite:\n            # append timestamp\n            if os.path.isfile(filename):\n                filename = filename[:-5]\n                filename += datetime.utcnow().strftime('%Y-%m-%d-%H:%M:%S.%f') + '.json'\n\n        # get QP data:\n        qp_data = dict()\n\n        lN = len(str(self.N+1))\n        for field in self.__qp_dynamics_fields:\n            for i in range(self.N):\n                qp_data[f'{field}_{i:0{lN}d}'] = self.get_from_qp_in(i,field)\n\n        for field in self.__qp_constraint_fields + self.__qp_cost_fields:\n            for i in range(self.N+1):\n                qp_data[f'{field}_{i:0{lN}d}'] = self.get_from_qp_in(i,field)\n\n        # remove empty fields\n        for k in list(qp_data.keys()):\n            if len(qp_data[k]) == 0:\n                del qp_data[k]\n\n        # save\n        with open(filename, 'w') as f:\n            json.dump(qp_data, f, default=make_object_json_dumpable, indent=4, sort_keys=True)\n        print(\"stored qp from solver memory in \", os.path.join(os.getcwd(), filename))\n\n\n\n    def load_iterate(self, filename):\n        \"\"\"\n        Loads the iterate stored in json file with filename into the ocp solver.\n        \"\"\"\n        if not os.path.isfile(filename):\n            raise Exception('load_iterate: failed, file does not exist: ' + os.path.join(os.getcwd(), filename))\n\n        with open(filename, 'r') as f:\n            solution = json.load(f)\n\n        print(f\"loading iterate {filename}\")\n        for key in solution.keys():\n            (field, stage) = key.split('_')\n            self.set(int(stage), field, np.array(solution[key]))\n\n\n    def get_stats(self, field_):\n        \"\"\"\n        Get the information of the last solver call.\n\n            :param field: string in ['statistics', 'time_tot', 'time_lin', 'time_sim', 'time_sim_ad', 'time_sim_la', 'time_qp', 'time_qp_solver_call', 'time_reg', 'sqp_iter', 'residuals', 'qp_iter', 'alpha']\n\n        Available fileds:\n            - time_tot: total CPU time previous call\n            - time_lin: CPU time for linearization\n            - time_sim: CPU time for integrator\n            - time_sim_ad: CPU time for integrator contribution of external function calls\n            - time_sim_la: CPU time for integrator contribution of linear algebra\n            - time_qp: CPU time qp solution\n            - time_qp_solver_call: CPU time inside qp solver (without converting the QP)\n            - time_qp_xcond: time_glob: CPU time globalization\n            - time_solution_sensitivities: CPU time for previous call to eval_param_sens\n            - time_reg: CPU time regularization\n            - sqp_iter: number of SQP iterations\n            - qp_iter: vector of QP iterations for last SQP call\n            - statistics: table with info about last iteration\n            - stat_m: number of rows in statistics matrix\n            - stat_n: number of columns in statistics matrix\n            - residuals: residuals of last iterate\n            - alpha: step sizes of SQP iterations\n        \"\"\"\n\n        double_fields = ['time_tot',\n                  'time_lin',\n                  'time_sim',\n                  'time_sim_ad',\n                  'time_sim_la',\n                  'time_qp',\n                  'time_qp_solver_call',\n                  'time_qp_xcond',\n                  'time_glob',\n                  'time_solution_sensitivities',\n                  'time_reg'\n        ]\n        fields = double_fields + [\n                  'sqp_iter',\n                  'qp_iter',\n                  'statistics',\n                  'stat_m',\n                  'stat_n',\n                  'residuals',\n                  'alpha',\n                ]\n        field = field_.encode('utf-8')\n\n\n        if field_ in ['sqp_iter', 'stat_m', 'stat_n']:\n            out = np.ascontiguousarray(np.zeros((1,)), dtype=np.int64)\n            out_data = cast(out.ctypes.data, POINTER(c_int64))\n            self.shared_lib.ocp_nlp_get.argtypes = [c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n            return out\n\n        # TODO: just return double instead of np.\n        elif field_ in double_fields:\n            out = np.zeros((1,))\n            out_data = cast(out.ctypes.data, POINTER(c_double))\n            self.shared_lib.ocp_nlp_get.argtypes = [c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n            return out\n\n        elif field_ == 'statistics':\n            sqp_iter = self.get_stats(\"sqp_iter\")\n            stat_m = self.get_stats(\"stat_m\")\n            stat_n = self.get_stats(\"stat_n\")\n            min_size = min([stat_m, sqp_iter+1])\n            out = np.ascontiguousarray(\n                        np.zeros((stat_n[0]+1, min_size[0])), dtype=np.float64)\n            out_data = cast(out.ctypes.data, POINTER(c_double))\n            self.shared_lib.ocp_nlp_get.argtypes = [c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n            return out\n\n        elif field_ == 'qp_iter':\n            full_stats = self.get_stats('statistics')\n            if self.solver_options['nlp_solver_type'] == 'SQP':\n                return full_stats[6, :]\n            elif self.solver_options['nlp_solver_type'] == 'SQP_RTI':\n                return full_stats[2, :]\n\n        elif field_ == 'alpha':\n            full_stats = self.get_stats('statistics')\n            if self.solver_options['nlp_solver_type'] == 'SQP':\n                return full_stats[7, :]\n            else: # self.solver_options['nlp_solver_type'] == 'SQP_RTI':\n                raise Exception(\"alpha values are not available for SQP_RTI\")\n\n        elif field_ == 'residuals':\n            return self.get_residuals()\n\n        else:\n            raise Exception(f'AcadosOcpSolver.get_stats(): \\'{field}\\' is not a valid argument.'\n                    + f'\\n Possible values are {fields}.')\n\n\n    def get_cost(self):\n        \"\"\"\n        Returns the cost value of the current solution.\n        \"\"\"\n        # compute cost internally\n        self.shared_lib.ocp_nlp_eval_cost.argtypes = [c_void_p, c_void_p, c_void_p]\n        self.shared_lib.ocp_nlp_eval_cost(self.nlp_solver, self.nlp_in, self.nlp_out)\n\n        # create output array\n        out = np.ascontiguousarray(np.zeros((1,)), dtype=np.float64)\n        out_data = cast(out.ctypes.data, POINTER(c_double))\n\n        # call getter\n        self.shared_lib.ocp_nlp_get.argtypes = [c_void_p, c_void_p, c_char_p, c_void_p]\n\n        field = \"cost_value\".encode('utf-8')\n        self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n\n        return out[0]\n\n\n    def get_residuals(self, recompute=False):\n        \"\"\"\n        Returns an array of the form [res_stat, res_eq, res_ineq, res_comp].\n        This residual has to be computed for SQP_RTI solver, since it is not available by default.\n\n        - res_stat: stationarity residual\n        - res_eq: residual wrt equality constraints (dynamics)\n        - res_ineq: residual wrt inequality constraints (constraints)\n        - res_comp: residual wrt complementarity conditions\n        \"\"\"\n        # compute residuals if RTI\n        if self.solver_options['nlp_solver_type'] == 'SQP_RTI' or recompute:\n            self.shared_lib.ocp_nlp_eval_residuals.argtypes = [c_void_p, c_void_p, c_void_p]\n            self.shared_lib.ocp_nlp_eval_residuals(self.nlp_solver, self.nlp_in, self.nlp_out)\n\n        # create output array\n        out = np.ascontiguousarray(np.zeros((4, 1)), dtype=np.float64)\n        out_data = cast(out.ctypes.data, POINTER(c_double))\n\n        # call getters\n        self.shared_lib.ocp_nlp_get.argtypes = [c_void_p, c_void_p, c_char_p, c_void_p]\n\n        field = \"res_stat\".encode('utf-8')\n        self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n\n        out_data = cast(out[1].ctypes.data, POINTER(c_double))\n        field = \"res_eq\".encode('utf-8')\n        self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n\n        out_data = cast(out[2].ctypes.data, POINTER(c_double))\n        field = \"res_ineq\".encode('utf-8')\n        self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n\n        out_data = cast(out[3].ctypes.data, POINTER(c_double))\n        field = \"res_comp\".encode('utf-8')\n        self.shared_lib.ocp_nlp_get(self.nlp_config, self.nlp_solver, field, out_data)\n        return out.flatten()\n\n\n    # Note: this function should not be used anymore, better use cost_set, constraints_set\n    def set(self, stage_, field_, value_):\n        \"\"\"\n        Set numerical data inside the solver.\n\n            :param stage: integer corresponding to shooting node\n            :param field: string in ['x', 'u', 'pi', 'lam', 't', 'p', 'xdot_guess', 'z_guess']\n\n            .. note:: regarding lam, t: \\n\n                    the inequalities are internally organized in the following order: \\n\n                    [ lbu lbx lg lh lphi ubu ubx ug uh uphi; \\n\n                      lsbu lsbx lsg lsh lsphi usbu usbx usg ush usphi]\n\n            .. note:: pi: multipliers for dynamics equality constraints \\n\n                      lam: multipliers for inequalities \\n\n                      t: slack variables corresponding to evaluation of all inequalities (at the solution) \\n\n                      sl: slack variables of soft lower inequality constraints \\n\n                      su: slack variables of soft upper inequality constraints \\n\n        \"\"\"\n        cost_fields = ['y_ref', 'yref']\n        constraints_fields = ['lbx', 'ubx', 'lbu', 'ubu']\n        out_fields = ['x', 'u', 'pi', 'lam', 't', 'z', 'sl', 'su']\n        mem_fields = ['xdot_guess', 'z_guess']\n\n        # cast value_ to avoid conversion issues\n        if isinstance(value_, (float, int)):\n            value_ = np.array([value_])\n        value_ = value_.astype(float)\n\n        field = field_.encode('utf-8')\n\n        stage = c_int(stage_)\n\n        # treat parameters separately\n        if field_ == 'p':\n            getattr(self.shared_lib, f\"{self.model_name}_acados_update_params\").argtypes = [c_void_p, c_int, POINTER(c_double), c_int]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_update_params\").restype = c_int\n\n            value_data = cast(value_.ctypes.data, POINTER(c_double))\n\n            assert getattr(self.shared_lib, f\"{self.model_name}_acados_update_params\")(self.capsule, stage, value_data, value_.shape[0])==0\n        else:\n            if field_ not in constraints_fields + cost_fields + out_fields + mem_fields:\n                raise Exception(f\"AcadosOcpSolver.set(): '{field}' is not a valid argument.\\n\"\n                    f\" Possible values are {constraints_fields + cost_fields + out_fields + mem_fields + ['p']}.\")\n\n            self.shared_lib.ocp_nlp_dims_get_from_attr.argtypes = \\\n                [c_void_p, c_void_p, c_void_p, c_int, c_char_p]\n            self.shared_lib.ocp_nlp_dims_get_from_attr.restype = c_int\n\n            dims = self.shared_lib.ocp_nlp_dims_get_from_attr(self.nlp_config, \\\n                self.nlp_dims, self.nlp_out, stage_, field)\n\n            if value_.shape[0] != dims:\n                msg = f'AcadosOcpSolver.set(): mismatching dimension for field \"{field_}\" '\n                msg += f'with dimension {dims} (you have {value_.shape[0]})'\n                raise Exception(msg)\n\n            value_data = cast(value_.ctypes.data, POINTER(c_double))\n            value_data_p = cast((value_data), c_void_p)\n\n            if field_ in constraints_fields:\n                self.shared_lib.ocp_nlp_constraints_model_set.argtypes = \\\n                    [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n                self.shared_lib.ocp_nlp_constraints_model_set(self.nlp_config, \\\n                    self.nlp_dims, self.nlp_in, stage, field, value_data_p)\n            elif field_ in cost_fields:\n                self.shared_lib.ocp_nlp_cost_model_set.argtypes = \\\n                    [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n                self.shared_lib.ocp_nlp_cost_model_set(self.nlp_config, \\\n                    self.nlp_dims, self.nlp_in, stage, field, value_data_p)\n            elif field_ in out_fields:\n                self.shared_lib.ocp_nlp_out_set.argtypes = \\\n                    [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n                self.shared_lib.ocp_nlp_out_set(self.nlp_config, \\\n                    self.nlp_dims, self.nlp_out, stage, field, value_data_p)\n            elif field_ in mem_fields:\n                self.shared_lib.ocp_nlp_set.argtypes = \\\n                    [c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n                self.shared_lib.ocp_nlp_set(self.nlp_config, \\\n                    self.nlp_solver, stage, field, value_data_p)\n            # also set z_guess, when setting z.\n            if field_ == 'z':\n                field = 'z_guess'.encode('utf-8')\n                self.shared_lib.ocp_nlp_set.argtypes = \\\n                    [c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n                self.shared_lib.ocp_nlp_set(self.nlp_config, \\\n                    self.nlp_solver, stage, field, value_data_p)\n        return\n\n\n    def cost_set(self, stage_, field_, value_, api='warn'):\n        \"\"\"\n        Set numerical data in the cost module of the solver.\n\n            :param stage: integer corresponding to shooting node\n            :param field: string, e.g. 'yref', 'W', 'ext_cost_num_hess', 'zl', 'zu', 'Zl', 'Zu'\n            :param value: of appropriate size\n        \"\"\"\n        # cast value_ to avoid conversion issues\n        if isinstance(value_, (float, int)):\n            value_ = np.array([value_])\n        value_ = value_.astype(float)\n\n        field = field_\n        field = field.encode('utf-8')\n\n        stage = c_int(stage_)\n        self.shared_lib.ocp_nlp_cost_dims_get_from_attr.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p, POINTER(c_int)]\n        self.shared_lib.ocp_nlp_cost_dims_get_from_attr.restype = c_int\n\n        dims = np.ascontiguousarray(np.zeros((2,)), dtype=np.intc)\n        dims_data = cast(dims.ctypes.data, POINTER(c_int))\n\n        self.shared_lib.ocp_nlp_cost_dims_get_from_attr(self.nlp_config, \\\n            self.nlp_dims, self.nlp_out, stage_, field, dims_data)\n\n        value_shape = value_.shape\n        if len(value_shape) == 1:\n            value_shape = (value_shape[0], 0)\n\n        elif len(value_shape) == 2:\n            if api=='old':\n                pass\n            elif api=='warn':\n                if not np.all(np.ravel(value_, order='F')==np.ravel(value_, order='K')):\n                    raise Exception(\"Ambiguity in API detected.\\n\"\n                                    \"Are you making an acados model from scrach? Add api='new' to cost_set and carry on.\\n\"\n                                    \"Are you seeing this error suddenly in previously running code? Read on.\\n\"\n                                    f\"  You are relying on a now-fixed bug in cost_set for field '{field_}'.\\n\" +\n                                    \"  acados_template now correctly passes on any matrices to acados in column major format.\\n\" +\n                                    \"  Two options to fix this error: \\n\" +\n                                    \"   * Add api='old' to cost_set to restore old incorrect behaviour\\n\" +\n                                    \"   * Add api='new' to cost_set and remove any unnatural manipulation of the value argument \" +\n                                    \"such as non-mathematical transposes, reshaping, casting to fortran order, etc... \" +\n                                    \"If there is no such manipulation, then you have probably been getting an incorrect solution before.\")\n                # Get elements in column major order\n                value_ = np.ravel(value_, order='F')\n            elif api=='new':\n                # Get elements in column major order\n                value_ = np.ravel(value_, order='F')\n            else:\n                raise Exception(\"Unknown api: '{}'\".format(api))\n\n        if value_shape != tuple(dims):\n            raise Exception('AcadosOcpSolver.cost_set(): mismatching dimension' +\n                f' for field \"{field_}\" at stage {stage} with dimension {tuple(dims)} (you have {value_shape})')\n\n        value_data = cast(value_.ctypes.data, POINTER(c_double))\n        value_data_p = cast((value_data), c_void_p)\n\n        self.shared_lib.ocp_nlp_cost_model_set.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n        self.shared_lib.ocp_nlp_cost_model_set(self.nlp_config, \\\n            self.nlp_dims, self.nlp_in, stage, field, value_data_p)\n\n        return\n\n\n    def constraints_set(self, stage_, field_, value_, api='warn'):\n        \"\"\"\n        Set numerical data in the constraint module of the solver.\n\n            :param stage: integer corresponding to shooting node\n            :param field: string in ['lbx', 'ubx', 'lbu', 'ubu', 'lg', 'ug', 'lh', 'uh', 'uphi', 'C', 'D']\n            :param value: of appropriate size\n        \"\"\"\n        # cast value_ to avoid conversion issues\n        if isinstance(value_, (float, int)):\n            value_ = np.array([value_])\n        value_ = value_.astype(float)\n\n        field = field_\n        field = field.encode('utf-8')\n\n        stage = c_int(stage_)\n        self.shared_lib.ocp_nlp_constraint_dims_get_from_attr.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p, POINTER(c_int)]\n        self.shared_lib.ocp_nlp_constraint_dims_get_from_attr.restype = c_int\n\n        dims = np.ascontiguousarray(np.zeros((2,)), dtype=np.intc)\n        dims_data = cast(dims.ctypes.data, POINTER(c_int))\n\n        self.shared_lib.ocp_nlp_constraint_dims_get_from_attr(self.nlp_config, \\\n            self.nlp_dims, self.nlp_out, stage_, field, dims_data)\n\n        value_shape = value_.shape\n        if len(value_shape) == 1:\n            value_shape = (value_shape[0], 0)\n        elif len(value_shape) == 2:\n            if api=='old':\n                pass\n            elif api=='warn':\n                if not np.all(np.ravel(value_, order='F')==np.ravel(value_, order='K')):\n                    raise Exception(\"Ambiguity in API detected.\\n\"\n                                    \"Are you making an acados model from scrach? Add api='new' to constraints_set and carry on.\\n\"\n                                    \"Are you seeing this error suddenly in previously running code? Read on.\\n\"\n                                    f\"  You are relying on a now-fixed bug in constraints_set for field '{field}'.\\n\" +\n                                    \"  acados_template now correctly passes on any matrices to acados in column major format.\\n\" +\n                                    \"  Two options to fix this error: \\n\" +\n                                    \"   * Add api='old' to constraints_set to restore old incorrect behaviour\\n\" +\n                                    \"   * Add api='new' to constraints_set and remove any unnatural manipulation of the value argument \" +\n                                    \"such as non-mathematical transposes, reshaping, casting to fortran order, etc... \" +\n                                    \"If there is no such manipulation, then you have probably been getting an incorrect solution before.\")\n                # Get elements in column major order\n                value_ = np.ravel(value_, order='F')\n            elif api=='new':\n                # Get elements in column major order\n                value_ = np.ravel(value_, order='F')\n            else:\n                raise Exception(f\"Unknown api: '{api}'\")\n\n        if value_shape != tuple(dims):\n            raise Exception(f'AcadosOcpSolver.constraints_set(): mismatching dimension' +\n                f' for field \"{field_}\" at stage {stage} with dimension {tuple(dims)} (you have {value_shape})')\n\n        value_data = cast(value_.ctypes.data, POINTER(c_double))\n        value_data_p = cast((value_data), c_void_p)\n\n        self.shared_lib.ocp_nlp_constraints_model_set.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n        self.shared_lib.ocp_nlp_constraints_model_set(self.nlp_config, \\\n            self.nlp_dims, self.nlp_in, stage, field, value_data_p)\n\n        return\n\n\n    def get_from_qp_in(self, stage_: int, field_: str):\n        \"\"\"\n        Get numerical data from the current QP.\n\n            :param stage: integer corresponding to shooting node\n            :param field: string in ['A', 'B', 'b', 'Q', 'R', 'S', 'q', 'r', 'C', 'D', 'lg', 'ug', 'lbx', 'ubx', 'lbu', 'ubu']\n        \"\"\"\n        # idx* should be added too..\n        if not isinstance(stage_, int):\n            raise TypeError(\"stage should be int\")\n        if stage_ > self.N:\n            raise Exception(\"stage should be <= self.N\")\n        if field_ in self.__qp_dynamics_fields and stage_ >= self.N:\n            raise ValueError(f\"dynamics field {field_} not available at terminal stage\")\n        if field_ not in self.__qp_dynamics_fields + self.__qp_cost_fields + self.__qp_constraint_fields:\n            raise Exception(f\"field {field_} not supported.\")\n\n        field = field_.encode('utf-8')\n        stage = c_int(stage_)\n\n        # get dims\n        self.shared_lib.ocp_nlp_qp_dims_get_from_attr.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p, POINTER(c_int)]\n        self.shared_lib.ocp_nlp_qp_dims_get_from_attr.restype = c_int\n\n        dims = np.ascontiguousarray(np.zeros((2,)), dtype=np.intc)\n        dims_data = cast(dims.ctypes.data, POINTER(c_int))\n\n        self.shared_lib.ocp_nlp_qp_dims_get_from_attr(self.nlp_config, \\\n            self.nlp_dims, self.nlp_out, stage_, field, dims_data)\n\n        # create output data\n        out = np.ascontiguousarray(np.zeros((np.prod(dims),)), dtype=np.float64)\n        out = out.reshape(dims[0], dims[1], order='F')\n\n        out_data = cast(out.ctypes.data, POINTER(c_double))\n        out_data_p = cast((out_data), c_void_p)\n\n        # call getter\n        self.shared_lib.ocp_nlp_get_at_stage.argtypes = \\\n            [c_void_p, c_void_p, c_void_p, c_int, c_char_p, c_void_p]\n        self.shared_lib.ocp_nlp_get_at_stage(self.nlp_config, \\\n            self.nlp_dims, self.nlp_solver, stage, field, out_data_p)\n\n        return out\n\n\n    def options_set(self, field_, value_):\n        \"\"\"\n        Set options of the solver.\n\n            :param field: string, e.g. 'print_level', 'rti_phase', 'initialize_t_slacks', 'step_length', 'alpha_min', 'alpha_reduction', 'qp_warm_start', 'line_search_use_sufficient_descent', 'full_step_dual', 'globalization_use_SOC', 'qp_tol_stat', 'qp_tol_eq', 'qp_tol_ineq', 'qp_tol_comp', 'qp_tau_min', 'qp_mu0'\n\n            :param value: of type int, float, string\n\n            - qp_tol_stat: QP solver tolerance stationarity\n            - qp_tol_eq: QP solver tolerance equalities\n            - qp_tol_ineq: QP solver tolerance inequalities\n            - qp_tol_comp: QP solver tolerance complementarity\n            - qp_tau_min: for HPIPM QP solvers: minimum value of barrier parameter in HPIPM\n            - qp_mu0: for HPIPM QP solvers: initial value for complementarity slackness\n            - warm_start_first_qp: indicates if first QP in SQP is warm_started\n        \"\"\"\n        int_fields = ['print_level', 'rti_phase', 'initialize_t_slacks', 'qp_warm_start',\n                      'line_search_use_sufficient_descent', 'full_step_dual', 'globalization_use_SOC', 'warm_start_first_qp']\n        double_fields = ['step_length', 'tol_eq', 'tol_stat', 'tol_ineq', 'tol_comp', 'alpha_min', 'alpha_reduction',\n                         'eps_sufficient_descent', 'qp_tol_stat', 'qp_tol_eq', 'qp_tol_ineq', 'qp_tol_comp', 'qp_tau_min', 'qp_mu0']\n        string_fields = ['globalization']\n\n        # check field availability and type\n        if field_ in int_fields:\n            if not isinstance(value_, int):\n                raise Exception(f'solver option \\'{field_}\\' must be of type int. You have {type(value_)}.')\n            else:\n                value_ctypes = c_int(value_)\n\n        elif field_ in double_fields:\n            if not isinstance(value_, float):\n                raise Exception(f'solver option \\'{field_}\\' must be of type float. You have {type(value_)}.')\n            else:\n                value_ctypes = c_double(value_)\n\n        elif field_ in string_fields:\n            if not isinstance(value_, str):\n                raise Exception(f'solver option \\'{field_}\\' must be of type str. You have {type(value_)}.')\n            else:\n                value_ctypes = value_.encode('utf-8')\n        else:\n            fields = ', '.join(int_fields + double_fields + string_fields)\n            raise Exception(f'AcadosOcpSolver.options_set() does not support field \\'{field_}\\'.\\n'\\\n                f' Possible values are {fields}.')\n\n\n        if field_ == 'rti_phase':\n            if value_ < 0 or value_ > 2:\n                raise Exception('AcadosOcpSolver.options_set(): argument \\'rti_phase\\' can '\n                    'take only values 0, 1, 2 for SQP-RTI-type solvers')\n            if self.solver_options['nlp_solver_type'] != 'SQP_RTI' and value_ > 0:\n                raise Exception('AcadosOcpSolver.options_set(): argument \\'rti_phase\\' can '\n                    'take only value 0 for SQP-type solvers')\n\n        # encode\n        field = field_\n        field = field.encode('utf-8')\n\n        # call C interface\n        if field_ in string_fields:\n            self.shared_lib.ocp_nlp_solver_opts_set.argtypes = \\\n                [c_void_p, c_void_p, c_char_p, c_char_p]\n            self.shared_lib.ocp_nlp_solver_opts_set(self.nlp_config, \\\n                self.nlp_opts, field, value_ctypes)\n        else:\n            self.shared_lib.ocp_nlp_solver_opts_set.argtypes = \\\n                [c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.ocp_nlp_solver_opts_set(self.nlp_config, \\\n                self.nlp_opts, field, byref(value_ctypes))\n        return\n\n\n    def set_params_sparse(self, stage_, idx_values_, param_values_):\n        \"\"\"\n        set parameters of the solvers external function partially:\n        Pseudo: solver.param[idx_values_] = param_values_;\n        Parameters:\n            :param stage_: integer corresponding to shooting node\n            :param idx_values_: 0 based np array (or iterable) of integers: indices of parameter to be set\n            :param param_values_: new parameter values as numpy array\n        \"\"\"\n\n        # if not isinstance(idx_values_, np.ndarray) or not issubclass(type(idx_values_[0]), np.integer):\n        #     raise Exception('idx_values_ must be np.array of integers.')\n\n        if not isinstance(param_values_, np.ndarray):\n            raise Exception('param_values_ must be np.array.')\n        elif np.float64 != param_values_.dtype:\n            raise TypeError('param_values_ must be np.array of float64.')\n\n        if param_values_.shape[0] != len(idx_values_):\n            raise Exception(f'param_values_ and idx_values_ must be of the same size.' +\n                 f' Got sizes idx {param_values_.shape[0]}, param_values {len(idx_values_)}.')\n\n        if any(idx_values_ >= self.acados_ocp.dims.np):\n            raise Exception(f'idx_values_ contains value >= np = {self.acados_ocp.dims.np}')\n\n        stage = c_int(stage_)\n        n_update = c_int(len(param_values_))\n\n        param_data = cast(param_values_.ctypes.data, POINTER(c_double))\n        c_idx_values = np.ascontiguousarray(idx_values_, dtype=np.intc)\n        idx_data = cast(c_idx_values.ctypes.data, POINTER(c_int))\n\n        getattr(self.shared_lib, f\"{self.model_name}_acados_update_params_sparse\").argtypes = \\\n                        [c_void_p, c_int, POINTER(c_int), POINTER(c_double), c_int]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_update_params_sparse\").restype = c_int\n        getattr(self.shared_lib, f\"{self.model_name}_acados_update_params_sparse\") \\\n                                    (self.capsule, stage, idx_data, param_data, n_update)\n\n    def __del__(self):\n        if self.solver_created:\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free\").argtypes = [c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free\").restype = c_int\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free\")(self.capsule)\n\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free_capsule\").argtypes = [c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free_capsule\").restype = c_int\n            getattr(self.shared_lib, f\"{self.model_name}_acados_free_capsule\")(self.capsule)\n\n            try:\n                self.dlclose(self.shared_lib._handle)\n            except:\n                print(f\"WARNING: acados Python interface could not close shared_lib handle of AcadosOcpSolver {self.model_name}.\\n\",\n                     \"Attempting to create a new one with the same name will likely result in the old one being used!\")\n                pass\n", "third_party/acados/acados_template/utils.py": "# -*- coding: future_fstrings -*-\n#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport os, sys, json\nimport urllib.request\nimport shutil\nimport numpy as np\nfrom casadi import SX, MX, DM, Function, CasadiMeta\n\nALLOWED_CASADI_VERSIONS = ('3.5.6', '3.5.5', '3.5.4', '3.5.3', '3.5.2', '3.5.1', '3.4.5', '3.4.0')\n\nTERA_VERSION = \"0.0.34\"\n\nPLATFORM2TERA = {\n    \"linux\": \"linux\",\n    \"darwin\": \"osx\",\n    \"win32\": \"windows\"\n}\n\n\ndef get_acados_path():\n    ACADOS_PATH = os.environ.get('ACADOS_SOURCE_DIR')\n    if not ACADOS_PATH:\n        acados_template_path = os.path.dirname(os.path.abspath(__file__))\n        acados_path = os.path.join(acados_template_path, '..','..','..')\n        ACADOS_PATH = os.path.realpath(acados_path)\n        msg = 'Warning: Did not find environment variable ACADOS_SOURCE_DIR, '\n        msg += 'guessed ACADOS_PATH to be {}.\\n'.format(ACADOS_PATH)\n        msg += 'Please export ACADOS_SOURCE_DIR to avoid this warning.'\n        print(msg)\n    return ACADOS_PATH\n\n\ndef get_python_interface_path():\n    ACADOS_PYTHON_INTERFACE_PATH = os.environ.get('ACADOS_PYTHON_INTERFACE_PATH')\n    if not ACADOS_PYTHON_INTERFACE_PATH:\n        acados_path = get_acados_path()\n        ACADOS_PYTHON_INTERFACE_PATH = os.path.join(acados_path, 'interfaces', 'acados_template', 'acados_template')\n    return ACADOS_PYTHON_INTERFACE_PATH\n\n\ndef get_tera_exec_path():\n    TERA_PATH = os.environ.get('TERA_PATH')\n    if not TERA_PATH:\n        TERA_PATH = os.path.join(get_acados_path(), 'bin', 't_renderer')\n        if os.name == 'nt':\n            TERA_PATH += '.exe'\n    return TERA_PATH\n\n\ndef check_casadi_version():\n    casadi_version = CasadiMeta.version()\n    if casadi_version in ALLOWED_CASADI_VERSIONS:\n        return\n    else:\n        msg =  'Warning: Please note that the following versions of CasADi  are '\n        msg += 'officially supported: {}.\\n '.format(\" or \".join(ALLOWED_CASADI_VERSIONS))\n        msg += 'If there is an incompatibility with the CasADi generated code, '\n        msg += 'please consider changing your CasADi version.\\n'\n        msg += 'Version {} currently in use.'.format(casadi_version)\n        print(msg)\n\n\ndef is_column(x):\n    if isinstance(x, np.ndarray):\n        if x.ndim == 1:\n            return True\n        elif x.ndim == 2 and x.shape[1] == 1:\n            return True\n        else:\n            return False\n    elif isinstance(x, (MX, SX, DM)):\n        if x.shape[1] == 1:\n            return True\n        elif x.shape[0] == 0 and x.shape[1] == 0:\n            return True\n        else:\n            return False\n    elif x == None or x == []:\n        return False\n    else:\n        raise Exception(\"is_column expects one of the following types: np.ndarray, casadi.MX, casadi.SX.\"\n                        + \" Got: \" + str(type(x)))\n\n\ndef is_empty(x):\n    if isinstance(x, (MX, SX, DM)):\n        return x.is_empty()\n    elif isinstance(x, np.ndarray):\n        if np.prod(x.shape) == 0:\n            return True\n        else:\n            return False\n    elif x == None:\n        return True\n    elif isinstance(x, (set, list)):\n        if len(x)==0:\n            return True\n        else:\n            return False\n    else:\n        raise Exception(\"is_empty expects one of the following types: casadi.MX, casadi.SX, \"\n                        + \"None, numpy array empty list, set. Got: \" + str(type(x)))\n\n\ndef casadi_length(x):\n    if isinstance(x, (MX, SX, DM)):\n        return int(np.prod(x.shape))\n    else:\n        raise Exception(\"casadi_length expects one of the following types: casadi.MX, casadi.SX.\"\n                        + \" Got: \" + str(type(x)))\n\n\ndef make_model_consistent(model):\n    x = model.x\n    xdot = model.xdot\n    u = model.u\n    z = model.z\n    p = model.p\n\n    if isinstance(x, MX):\n        symbol = MX.sym\n    elif isinstance(x, SX):\n        symbol = SX.sym\n    else:\n        raise Exception(\"model.x must be casadi.SX or casadi.MX, got {}\".format(type(x)))\n\n    if is_empty(p):\n        model.p = symbol('p', 0, 0)\n\n    if is_empty(z):\n        model.z = symbol('z', 0, 0)\n\n    return model\n\ndef get_lib_ext():\n    lib_ext = '.so'\n    if sys.platform == 'darwin':\n        lib_ext = '.dylib'\n    elif os.name == 'nt':\n        lib_ext = ''\n\n    return lib_ext\n\ndef get_tera():\n    tera_path = get_tera_exec_path()\n    acados_path = get_acados_path()\n\n    if os.path.exists(tera_path) and os.access(tera_path, os.X_OK):\n        return tera_path\n\n    repo_url = \"https://github.com/acados/tera_renderer/releases\"\n    url = \"{}/download/v{}/t_renderer-v{}-{}\".format(\n        repo_url, TERA_VERSION, TERA_VERSION, PLATFORM2TERA[sys.platform])\n\n    manual_install = 'For manual installation follow these instructions:\\n'\n    manual_install += '1 Download binaries from {}\\n'.format(url)\n    manual_install += '2 Copy them in {}/bin\\n'.format(acados_path)\n    manual_install += '3 Strip the version and platform from the binaries: '\n    manual_install += 'as t_renderer-v0.0.34-X -> t_renderer)\\n'\n    manual_install += '4 Enable execution privilege on the file \"t_renderer\" with:\\n'\n    manual_install += '\"chmod +x {}\"\\n\\n'.format(tera_path)\n\n    msg = \"\\n\"\n    msg += 'Tera template render executable not found, '\n    msg += 'while looking in path:\\n{}\\n'.format(tera_path)\n    msg += 'In order to be able to render the templates, '\n    msg += 'you need to download the tera renderer binaries from:\\n'\n    msg += '{}\\n\\n'.format(repo_url)\n    msg += 'Do you wish to set up Tera renderer automatically?\\n'\n    msg += 'y/N? (press y to download tera or any key for manual installation)\\n'\n\n    if input(msg) == 'y':\n        print(\"Dowloading {}\".format(url))\n        with urllib.request.urlopen(url) as response, open(tera_path, 'wb') as out_file:\n            shutil.copyfileobj(response, out_file)\n        print(\"Successfully downloaded t_renderer.\")\n        os.chmod(tera_path, 0o755)\n        return tera_path\n\n    msg_cancel = \"\\nYou cancelled automatic download.\\n\\n\"\n    msg_cancel += manual_install\n    msg_cancel += \"Once installed re-run your script.\\n\\n\"\n    print(msg_cancel)\n\n    sys.exit(1)\n\n\ndef render_template(in_file, out_file, output_dir, json_path, template_glob=None):\n\n    acados_path = os.path.dirname(os.path.abspath(__file__))\n    if template_glob is None:\n        template_glob = os.path.join(acados_path, 'c_templates_tera', '**', '*')\n    cwd = os.getcwd()\n\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    os.chdir(output_dir)\n\n    tera_path = get_tera()\n\n    # call tera as system cmd\n    os_cmd = f\"{tera_path} '{template_glob}' '{in_file}' '{json_path}' '{out_file}'\"\n    # Windows cmd.exe can not cope with '...', so use \"...\" instead:\n    if os.name == 'nt':\n        os_cmd = os_cmd.replace('\\'', '\\\"')\n\n    status = os.system(os_cmd)\n    if (status != 0):\n        raise Exception(f'Rendering of {in_file} failed!\\n\\nAttempted to execute OS command:\\n{os_cmd}\\n\\n')\n\n    os.chdir(cwd)\n\n\n## Conversion functions\ndef make_object_json_dumpable(input):\n    if isinstance(input, (np.ndarray)):\n        return input.tolist()\n    elif isinstance(input, (SX)):\n        return input.serialize()\n    elif isinstance(input, (MX)):\n        # NOTE: MX expressions can not be serialized, only Functions.\n        return input.__str__()\n    elif isinstance(input, (DM)):\n        return input.full()\n    else:\n        raise TypeError(f\"Cannot make input of type {type(input)} dumpable.\")\n\n\ndef format_class_dict(d):\n    \"\"\"\n    removes the __ artifact from class to dict conversion\n    \"\"\"\n    out = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = format_class_dict(v)\n\n        out_key = k.split('__', 1)[-1]\n        out[k.replace(k, out_key)] = v\n    return out\n\n\ndef get_ocp_nlp_layout() -> dict:\n    python_interface_path = get_python_interface_path()\n    abs_path = os.path.join(python_interface_path, 'acados_layout.json')\n    with open(abs_path, 'r') as f:\n        ocp_nlp_layout = json.load(f)\n    return ocp_nlp_layout\n\n\ndef get_default_simulink_opts() -> dict:\n    python_interface_path = get_python_interface_path()\n    abs_path = os.path.join(python_interface_path, 'simulink_default_opts.json')\n    with open(abs_path, 'r') as f:\n        simulink_opts = json.load(f)\n    return simulink_opts\n\n\ndef J_to_idx(J):\n    nrows = J.shape[0]\n    idx = np.zeros((nrows, ))\n    for i in range(nrows):\n        this_idx = np.nonzero(J[i,:])[0]\n        if len(this_idx) != 1:\n            raise Exception('Invalid J matrix structure detected, ' \\\n                'must contain one nonzero element per row.')\n        if this_idx.size > 0 and J[i,this_idx[0]] != 1:\n            raise Exception('J matrices can only contain 1s.')\n        idx[i] = this_idx[0]\n    return idx\n\n\ndef J_to_idx_slack(J):\n    nrows = J.shape[0]\n    ncol = J.shape[1]\n    idx = np.zeros((ncol, ))\n    i_idx = 0\n    for i in range(nrows):\n        this_idx = np.nonzero(J[i,:])[0]\n        if len(this_idx) == 1:\n            idx[i_idx] = i\n            i_idx = i_idx + 1\n        elif len(this_idx) > 1:\n            raise Exception('J_to_idx_slack: Invalid J matrix. ' \\\n                'Found more than one nonzero in row ' + str(i))\n        if this_idx.size > 0 and J[i,this_idx[0]] != 1:\n            raise Exception('J_to_idx_slack: J matrices can only contain 1s, ' \\\n                 'got J(' + str(i) + ', ' + str(this_idx[0]) + ') = ' + str(J[i,this_idx[0]]) )\n    if not i_idx == ncol:\n            raise Exception('J_to_idx_slack: J must contain a 1 in every column!')\n    return idx\n\n\ndef acados_dae_model_json_dump(model):\n\n    # load model\n    x = model.x\n    xdot = model.xdot\n    u = model.u\n    z = model.z\n    p = model.p\n\n    f_impl = model.f_impl_expr\n    model_name = model.name\n\n    # create struct with impl_dae_fun, casadi_version\n    fun_name = model_name + '_impl_dae_fun'\n    impl_dae_fun = Function(fun_name, [x, xdot, u, z, p], [f_impl])\n\n    casadi_version = CasadiMeta.version()\n    str_impl_dae_fun = impl_dae_fun.serialize()\n\n    dae_dict = {\"str_impl_dae_fun\": str_impl_dae_fun, \"casadi_version\": casadi_version}\n\n    # dump\n    json_file = model_name + '_acados_dae.json'\n    with open(json_file, 'w') as f:\n        json.dump(dae_dict, f, default=make_object_json_dumpable, indent=4, sort_keys=True)\n    print(\"dumped \", model_name, \" dae to file:\", json_file, \"\\n\")\n\n\ndef set_up_imported_gnsf_model(acados_ocp):\n\n    gnsf = acados_ocp.gnsf_model\n\n    # check CasADi version\n    # dump_casadi_version = gnsf['casadi_version']\n    # casadi_version = CasadiMeta.version()\n\n    # if not casadi_version == dump_casadi_version:\n    #     print(\"WARNING: GNSF model was dumped with another CasADi version.\\n\"\n    #             + \"This might yield errors. Please use the same version for compatibility, serialize version: \"\n    #             + dump_casadi_version + \" current Python CasADi verison: \" + casadi_version)\n    #     input(\"Press any key to attempt to continue...\")\n\n    # load model\n    phi_fun = Function.deserialize(gnsf['phi_fun'])\n    phi_fun_jac_y = Function.deserialize(gnsf['phi_fun_jac_y'])\n    phi_jac_y_uhat = Function.deserialize(gnsf['phi_jac_y_uhat'])\n    get_matrices_fun = Function.deserialize(gnsf['get_matrices_fun'])\n\n    # obtain gnsf dimensions\n    size_gnsf_A = get_matrices_fun.size_out(0)\n    acados_ocp.dims.gnsf_nx1 = size_gnsf_A[1]\n    acados_ocp.dims.gnsf_nz1 = size_gnsf_A[0] - size_gnsf_A[1]\n    acados_ocp.dims.gnsf_nuhat = max(phi_fun.size_in(1))\n    acados_ocp.dims.gnsf_ny = max(phi_fun.size_in(0))\n    acados_ocp.dims.gnsf_nout = max(phi_fun.size_out(0))\n\n    # save gnsf functions in model\n    acados_ocp.model.phi_fun = phi_fun\n    acados_ocp.model.phi_fun_jac_y = phi_fun_jac_y\n    acados_ocp.model.phi_jac_y_uhat = phi_jac_y_uhat\n    acados_ocp.model.get_matrices_fun = get_matrices_fun\n\n    # get_matrices_fun = Function([model_name,'_gnsf_get_matrices_fun'], {dummy},...\n    #  {A, B, C, E, L_x, L_xdot, L_z, L_u, A_LO, c, E_LO, B_LO,...\n    #   nontrivial_f_LO, purely_linear, ipiv_x, ipiv_z, c_LO});\n    get_matrices_out = get_matrices_fun(0)\n    acados_ocp.model.gnsf['nontrivial_f_LO'] = int(get_matrices_out[12])\n    acados_ocp.model.gnsf['purely_linear'] = int(get_matrices_out[13])\n\n    if \"f_lo_fun_jac_x1k1uz\" in gnsf:\n        f_lo_fun_jac_x1k1uz = Function.deserialize(gnsf['f_lo_fun_jac_x1k1uz'])\n        acados_ocp.model.f_lo_fun_jac_x1k1uz = f_lo_fun_jac_x1k1uz\n    else:\n        dummy_var_x1 = SX.sym('dummy_var_x1', acados_ocp.dims.gnsf_nx1)\n        dummy_var_x1dot = SX.sym('dummy_var_x1dot', acados_ocp.dims.gnsf_nx1)\n        dummy_var_z1 = SX.sym('dummy_var_z1', acados_ocp.dims.gnsf_nz1)\n        dummy_var_u = SX.sym('dummy_var_z1', acados_ocp.dims.nu)\n        dummy_var_p = SX.sym('dummy_var_z1', acados_ocp.dims.np)\n        empty_var = SX.sym('empty_var', 0, 0)\n\n        empty_fun = Function('empty_fun', \\\n            [dummy_var_x1, dummy_var_x1dot, dummy_var_z1, dummy_var_u, dummy_var_p],\n                [empty_var])\n        acados_ocp.model.f_lo_fun_jac_x1k1uz = empty_fun\n\n    del acados_ocp.gnsf_model\n\n\ndef idx_perm_to_ipiv(idx_perm):\n    n = len(idx_perm)\n    vec = list(range(n))\n    ipiv = np.zeros(n)\n\n    print(n, idx_perm)\n    # import pdb; pdb.set_trace()\n    for ii in range(n):\n        idx0 = idx_perm[ii]\n        for jj in range(ii,n):\n            if vec[jj]==idx0:\n                idx1 = jj\n                break\n        tmp = vec[ii]\n        vec[ii] = vec[idx1]\n        vec[idx1] = tmp\n        ipiv[ii] = idx1\n\n    ipiv = ipiv-1 # C 0-based indexing\n    return ipiv\n\n\ndef print_casadi_expression(f):\n    for ii in range(casadi_length(f)):\n        print(f[ii,:])\n", "third_party/acados/acados_template/acados_model.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\n\nclass AcadosModel():\n    \"\"\"\n    Class containing all the information to code generate the external CasADi functions\n    that are needed when creating an acados ocp solver or acados integrator.\n    Thus, this class contains:\n\n    a) the :py:attr:`name` of the model,\n    b) all CasADi variables/expressions needed in the CasADi function generation process.\n    \"\"\"\n    def __init__(self):\n        ## common for OCP and Integrator\n        self.name = None\n        \"\"\"\n        The model name is used for code generation. Type: string. Default: :code:`None`\n        \"\"\"\n        self.x = None           #: CasADi variable describing the state of the system; Default: :code:`None`\n        self.xdot = None        #: CasADi variable describing the derivative of the state wrt time; Default: :code:`None`\n        self.u = None           #: CasADi variable describing the input of the system; Default: :code:`None`\n        self.z = []             #: CasADi variable describing the algebraic variables of the DAE; Default: :code:`empty`\n        self.p = []             #: CasADi variable describing parameters of the DAE; Default: :code:`empty`\n        # dynamics\n        self.f_impl_expr = None\n        \"\"\"\n        CasADi expression for the implicit dynamics :math:`f_\\\\text{impl}(\\dot{x}, x, u, z, p) = 0`.\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.integrator_type` == 'IRK'.\n        Default: :code:`None`\n        \"\"\"\n        self.f_expl_expr = None\n        \"\"\"\n        CasADi expression for the explicit dynamics :math:`\\dot{x} = f_\\\\text{expl}(x, u, p)`.\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.integrator_type` == 'ERK'.\n        Default: :code:`None`\n        \"\"\"\n        self.disc_dyn_expr = None\n        \"\"\"\n        CasADi expression for the discrete dynamics :math:`x_{+} = f_\\\\text{disc}(x, u, p)`.\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.integrator_type` == 'DISCRETE'.\n        Default: :code:`None`\n        \"\"\"\n\n        self.dyn_ext_fun_type = 'casadi'  #: type of external functions for dynamics module; 'casadi' or 'generic'; Default: 'casadi'\n        self.dyn_generic_source = None  #: name of source file for discrete dyanamics; Default: :code:`None`\n        self.dyn_disc_fun_jac_hess = None  #: name of function discrete dyanamics + jacobian and hessian; Default: :code:`None`\n        self.dyn_disc_fun_jac = None  #: name of function discrete dyanamics + jacobian; Default: :code:`None`\n        self.dyn_disc_fun = None  #: name of function discrete dyanamics; Default: :code:`None`\n\n        # for GNSF models\n        self.gnsf = {'nontrivial_f_LO': 1, 'purely_linear': 0}\n        \"\"\"\n        dictionary containing information on GNSF structure needed when rendering templates.\n        Contains integers `nontrivial_f_LO`, `purely_linear`.\n        \"\"\"\n\n        ## for OCP\n        # constraints\n        # BGH(default): lh <= h(x, u) <= uh\n        self.con_h_expr = None  #: CasADi expression for the constraint :math:`h`; Default: :code:`None`\n        # BGP(convex over nonlinear): lphi <= phi(r(x, u)) <= uphi\n        self.con_phi_expr = None  #: CasADi expression for the constraint phi; Default: :code:`None`\n        self.con_r_expr = None  #: CasADi expression for the constraint phi(r); Default: :code:`None`\n        self.con_r_in_phi = None\n        # terminal\n        self.con_h_expr_e = None  #: CasADi expression for the terminal constraint :math:`h^e`; Default: :code:`None`\n        self.con_r_expr_e = None  #: CasADi expression for the terminal constraint; Default: :code:`None`\n        self.con_phi_expr_e = None  #: CasADi expression for the terminal constraint; Default: :code:`None`\n        self.con_r_in_phi_e = None\n        # cost\n        self.cost_y_expr = None  #: CasADi expression for nonlinear least squares; Default: :code:`None`\n        self.cost_y_expr_e = None  #: CasADi expression for nonlinear least squares, terminal; Default: :code:`None`\n        self.cost_y_expr_0 = None  #: CasADi expression for nonlinear least squares, initial; Default: :code:`None`\n        self.cost_expr_ext_cost = None  #: CasADi expression for external cost; Default: :code:`None`\n        self.cost_expr_ext_cost_e = None  #: CasADi expression for external cost, terminal; Default: :code:`None`\n        self.cost_expr_ext_cost_0 = None  #: CasADi expression for external cost, initial; Default: :code:`None`\n        self.cost_expr_ext_cost_custom_hess = None  #: CasADi expression for custom hessian (only for external cost); Default: :code:`None`\n        self.cost_expr_ext_cost_custom_hess_e = None  #: CasADi expression for custom hessian (only for external cost), terminal; Default: :code:`None`\n        self.cost_expr_ext_cost_custom_hess_0 = None  #: CasADi expression for custom hessian (only for external cost), initial; Default: :code:`None`\n\n        ## CONVEX_OVER_NONLINEAR convex-over-nonlinear cost: psi(y(x, u, p) - y_ref; p)\n        self.cost_psi_expr_0 = None\n        \"\"\"\n        CasADi expression for the outer loss function :math:`\\psi(r, p)`, initial; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type_0` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_psi_expr = None\n        \"\"\"\n        CasADi expression for the outer loss function :math:`\\psi(r, p)`; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_psi_expr_e = None\n        \"\"\"\n        CasADi expression for the outer loss function :math:`\\psi(r, p)`, terminal; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type_e` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_r_in_psi_expr_0 = None\n        \"\"\"\n        CasADi expression for the argument :math:`r`; to the outer loss function :math:`\\psi(r, p)`, initial; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type_0` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_r_in_psi_expr = None\n        \"\"\"\n        CasADi expression for the argument :math:`r`; to the outer loss function :math:`\\psi(r, p)`; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_r_in_psi_expr_e = None\n        \"\"\"\n        CasADi expression for the argument :math:`r`; to the outer loss function :math:`\\psi(r, p)`, terminal; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type_e` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_conl_custom_outer_hess_0 = None\n        \"\"\"\n        CasADi expression for the custom hessian of the outer loss function (only for convex-over-nonlinear cost), initial; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type_0` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_conl_custom_outer_hess = None\n        \"\"\"\n        CasADi expression for the custom hessian of the outer loss function (only for convex-over-nonlinear cost); Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n        self.cost_conl_custom_outer_hess_e = None\n        \"\"\"\n        CasADi expression for the custom hessian of the outer loss function (only for convex-over-nonlinear cost), terminal; Default: :code:`None`\n        Used if :py:attr:`acados_template.acados_ocp.AcadosOcpOptions.cost_type_e` == 'CONVEX_OVER_NONLINEAR'.\n        \"\"\"\n", "third_party/acados/acados_template/acados_sim_solver.py": "# -*- coding: future_fstrings -*-\n#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport sys\nimport os\nimport json\nimport importlib\n\nimport numpy as np\n\nfrom subprocess import DEVNULL, call, STDOUT\n\nfrom ctypes import POINTER, cast, CDLL, c_void_p, c_char_p, c_double, c_int, c_bool, byref\nfrom copy import deepcopy\n\nfrom .casadi_function_generation import generate_c_code_implicit_ode, generate_c_code_gnsf, generate_c_code_explicit_ode\nfrom .acados_sim import AcadosSim\nfrom .acados_ocp import AcadosOcp\nfrom .utils import is_column, render_template, format_class_dict, make_object_json_dumpable,\\\n     make_model_consistent, set_up_imported_gnsf_model, get_python_interface_path, get_lib_ext,\\\n     casadi_length, is_empty, check_casadi_version\nfrom .builders import CMakeBuilder\nfrom .gnsf.detect_gnsf_structure import detect_gnsf_structure\n\n\n\ndef make_sim_dims_consistent(acados_sim: AcadosSim):\n    dims = acados_sim.dims\n    model = acados_sim.model\n    # nx\n    if is_column(model.x):\n        dims.nx = casadi_length(model.x)\n    else:\n        raise Exception('model.x should be column vector!')\n\n    # nu\n    if is_empty(model.u):\n        dims.nu = 0\n    else:\n        dims.nu = casadi_length(model.u)\n\n    # nz\n    if is_empty(model.z):\n        dims.nz = 0\n    else:\n        dims.nz = casadi_length(model.z)\n\n    # np\n    if is_empty(model.p):\n        dims.np = 0\n    else:\n        dims.np = casadi_length(model.p)\n    if acados_sim.parameter_values.shape[0] != dims.np:\n        raise Exception('inconsistent dimension np, regarding model.p and parameter_values.' + \\\n            f'\\nGot np = {dims.np}, acados_sim.parameter_values.shape = {acados_sim.parameter_values.shape[0]}\\n')\n\n\ndef get_sim_layout():\n    python_interface_path = get_python_interface_path()\n    abs_path = os.path.join(python_interface_path, 'acados_sim_layout.json')\n    with open(abs_path, 'r') as f:\n        sim_layout = json.load(f)\n    return sim_layout\n\n\ndef sim_formulation_json_dump(acados_sim: AcadosSim, json_file='acados_sim.json'):\n    # Load acados_sim structure description\n    sim_layout = get_sim_layout()\n\n    # Copy input sim object dictionary\n    sim_dict = dict(deepcopy(acados_sim).__dict__)\n\n    for key, v in sim_layout.items():\n        # skip non dict attributes\n        if not isinstance(v, dict): continue\n        # Copy sim object attributes dictionaries\n        sim_dict[key]=dict(getattr(acados_sim, key).__dict__)\n\n    sim_json = format_class_dict(sim_dict)\n\n    with open(json_file, 'w') as f:\n        json.dump(sim_json, f, default=make_object_json_dumpable, indent=4, sort_keys=True)\n\n\ndef sim_get_default_cmake_builder() -> CMakeBuilder:\n    \"\"\"\n    If :py:class:`~acados_template.acados_sim_solver.AcadosSimSolver` is used with `CMake` this function returns a good first setting.\n    :return: default :py:class:`~acados_template.builders.CMakeBuilder`\n    \"\"\"\n    cmake_builder = CMakeBuilder()\n    cmake_builder.options_on = ['BUILD_ACADOS_SIM_SOLVER_LIB']\n    return cmake_builder\n\n\ndef sim_render_templates(json_file, model_name: str, code_export_dir, cmake_options: CMakeBuilder = None):\n    # setting up loader and environment\n    json_path = os.path.join(os.getcwd(), json_file)\n\n    if not os.path.exists(json_path):\n        raise Exception(f\"{json_path} not found!\")\n\n    # Render templates\n    in_file = 'acados_sim_solver.in.c'\n    out_file = f'acados_sim_solver_{model_name}.c'\n    render_template(in_file, out_file, code_export_dir, json_path)\n\n    in_file = 'acados_sim_solver.in.h'\n    out_file = f'acados_sim_solver_{model_name}.h'\n    render_template(in_file, out_file, code_export_dir, json_path)\n\n    in_file = 'acados_sim_solver.in.pxd'\n    out_file = f'acados_sim_solver.pxd'\n    render_template(in_file, out_file, code_export_dir, json_path)\n\n    # Builder\n    if cmake_options is not None:\n        in_file = 'CMakeLists.in.txt'\n        out_file = 'CMakeLists.txt'\n        render_template(in_file, out_file, code_export_dir, json_path)\n    else:\n        in_file = 'Makefile.in'\n        out_file = 'Makefile'\n        render_template(in_file, out_file, code_export_dir, json_path)\n\n    in_file = 'main_sim.in.c'\n    out_file = f'main_sim_{model_name}.c'\n    render_template(in_file, out_file, code_export_dir, json_path)\n\n    # folder model\n    model_dir = os.path.join(code_export_dir, model_name + '_model')\n\n    in_file = 'model.in.h'\n    out_file = f'{model_name}_model.h'\n    render_template(in_file, out_file, model_dir, json_path)\n\n\ndef sim_generate_external_functions(acados_sim: AcadosSim):\n    model = acados_sim.model\n    model = make_model_consistent(model)\n\n    integrator_type = acados_sim.solver_options.integrator_type\n\n    opts = dict(generate_hess = acados_sim.solver_options.sens_hess,\n                code_export_directory = acados_sim.code_export_directory)\n\n    # create code_export_dir, model_dir\n    code_export_dir = acados_sim.code_export_directory\n    opts['code_export_directory'] = code_export_dir\n    model_dir = os.path.join(code_export_dir, model.name + '_model')\n    if not os.path.exists(model_dir):\n        os.makedirs(model_dir)\n\n    # generate external functions\n    check_casadi_version()\n    if integrator_type == 'ERK':\n        generate_c_code_explicit_ode(model, opts)\n    elif integrator_type == 'IRK':\n        generate_c_code_implicit_ode(model, opts)\n    elif integrator_type == 'GNSF':\n        generate_c_code_gnsf(model, opts)\n\n\nclass AcadosSimSolver:\n    \"\"\"\n    Class to interact with the acados integrator C object.\n\n        :param acados_sim: type :py:class:`~acados_template.acados_ocp.AcadosOcp` (takes values to generate an instance :py:class:`~acados_template.acados_sim.AcadosSim`) or :py:class:`~acados_template.acados_sim.AcadosSim`\n        :param json_file: Default: 'acados_sim.json'\n        :param build: Default: True\n        :param cmake_builder: type :py:class:`~acados_template.utils.CMakeBuilder` generate a `CMakeLists.txt` and use\n            the `CMake` pipeline instead of a `Makefile` (`CMake` seems to be the better option in conjunction with\n            `MS Visual Studio`); default: `None`\n    \"\"\"\n    if sys.platform==\"win32\":\n        from ctypes import wintypes\n        from ctypes import WinDLL\n        dlclose = WinDLL('kernel32', use_last_error=True).FreeLibrary\n        dlclose.argtypes = [wintypes.HMODULE]\n    else:\n        dlclose = CDLL(None).dlclose\n        dlclose.argtypes = [c_void_p]\n\n\n    @classmethod\n    def generate(cls, acados_sim: AcadosSim, json_file='acados_sim.json', cmake_builder: CMakeBuilder = None):\n        \"\"\"\n        Generates the code for an acados sim solver, given the description in acados_sim\n        \"\"\"\n\n        acados_sim.code_export_directory = os.path.abspath(acados_sim.code_export_directory)\n\n        # make dims consistent\n        make_sim_dims_consistent(acados_sim)\n\n        # module dependent post processing\n        if acados_sim.solver_options.integrator_type == 'GNSF':\n            if acados_sim.solver_options.sens_hess == True:\n                raise Exception(\"AcadosSimSolver: GNSF does not support sens_hess = True.\")\n            if 'gnsf_model' in acados_sim.__dict__:\n                set_up_imported_gnsf_model(acados_sim)\n            else:\n                detect_gnsf_structure(acados_sim)\n\n        # generate external functions\n        sim_generate_external_functions(acados_sim)\n\n        # dump to json\n        sim_formulation_json_dump(acados_sim, json_file)\n\n        # render templates\n        sim_render_templates(json_file, acados_sim.model.name, acados_sim.code_export_directory, cmake_builder)\n\n\n    @classmethod\n    def build(cls, code_export_dir, with_cython=False, cmake_builder: CMakeBuilder = None, verbose: bool = True):\n        # Compile solver\n        cwd = os.getcwd()\n        os.chdir(code_export_dir)\n        if with_cython:\n            call(\n                ['make', 'clean_sim_cython'],\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n            call(\n                ['make', 'sim_cython'],\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n        else:\n            if cmake_builder is not None:\n                cmake_builder.exec(code_export_dir, verbose=verbose)\n            else:\n                call(\n                    ['make', 'sim_shared_lib'],\n                    stdout=None if verbose else DEVNULL,\n                    stderr=None if verbose else STDOUT\n                )\n        os.chdir(cwd)\n\n\n    @classmethod\n    def create_cython_solver(cls, json_file):\n        \"\"\"\n        \"\"\"\n        with open(json_file, 'r') as f:\n            acados_sim_json = json.load(f)\n        code_export_directory = acados_sim_json['code_export_directory']\n\n        importlib.invalidate_caches()\n        rel_code_export_directory = os.path.relpath(code_export_directory)\n        acados_sim_solver_pyx = importlib.import_module(f'{rel_code_export_directory}.acados_sim_solver_pyx')\n\n        AcadosSimSolverCython = getattr(acados_sim_solver_pyx, 'AcadosSimSolverCython')\n        return AcadosSimSolverCython(acados_sim_json['model']['name'])\n\n    def __init__(self, acados_sim, json_file='acados_sim.json', generate=True, build=True, cmake_builder: CMakeBuilder = None, verbose: bool = True):\n\n        self.solver_created = False\n        self.acados_sim = acados_sim\n        model_name = acados_sim.model.name\n        self.model_name = model_name\n\n        code_export_dir = os.path.abspath(acados_sim.code_export_directory)\n\n        # reuse existing json and casadi functions, when creating integrator from ocp\n        if generate and not isinstance(acados_sim, AcadosOcp):\n            self.generate(acados_sim, json_file=json_file, cmake_builder=cmake_builder)\n\n        if build:\n            self.build(code_export_dir, cmake_builder=cmake_builder, verbose=True)\n\n        # prepare library loading\n        lib_prefix = 'lib'\n        lib_ext = get_lib_ext()\n        if os.name == 'nt':\n            lib_prefix = ''\n\n        # Load acados library to avoid unloading the library.\n        # This is necessary if acados was compiled with OpenMP, since the OpenMP threads can't be destroyed.\n        # Unloading a library which uses OpenMP results in a segfault (on any platform?).\n        # see [https://stackoverflow.com/questions/34439956/vc-crash-when-freeing-a-dll-built-with-openmp]\n        # or [https://python.hotexamples.com/examples/_ctypes/-/dlclose/python-dlclose-function-examples.html]\n        libacados_name = f'{lib_prefix}acados{lib_ext}'\n        libacados_filepath = os.path.join(acados_sim.acados_lib_path, libacados_name)\n        self.__acados_lib = CDLL(libacados_filepath)\n        # find out if acados was compiled with OpenMP\n        try:\n            self.__acados_lib_uses_omp = getattr(self.__acados_lib, 'omp_get_thread_num') is not None\n        except AttributeError as e:\n            self.__acados_lib_uses_omp = False\n        if self.__acados_lib_uses_omp:\n            print('acados was compiled with OpenMP.')\n        else:\n            print('acados was compiled without OpenMP.')\n        libacados_sim_solver_name = f'{lib_prefix}acados_sim_solver_{self.model_name}{lib_ext}'\n        self.shared_lib_name = os.path.join(code_export_dir, libacados_sim_solver_name)\n\n        # get shared_lib\n        self.shared_lib = CDLL(self.shared_lib_name)\n\n        # create capsule\n        getattr(self.shared_lib, f\"{model_name}_acados_sim_solver_create_capsule\").restype = c_void_p\n        self.capsule = getattr(self.shared_lib, f\"{model_name}_acados_sim_solver_create_capsule\")()\n\n        # create solver\n        getattr(self.shared_lib, f\"{model_name}_acados_sim_create\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_sim_create\").restype = c_int\n        assert getattr(self.shared_lib, f\"{model_name}_acados_sim_create\")(self.capsule)==0\n        self.solver_created = True\n\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_opts\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_opts\").restype = c_void_p\n        self.sim_opts = getattr(self.shared_lib, f\"{model_name}_acados_get_sim_opts\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_dims\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_dims\").restype = c_void_p\n        self.sim_dims = getattr(self.shared_lib, f\"{model_name}_acados_get_sim_dims\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_config\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_config\").restype = c_void_p\n        self.sim_config = getattr(self.shared_lib, f\"{model_name}_acados_get_sim_config\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_out\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_out\").restype = c_void_p\n        self.sim_out = getattr(self.shared_lib, f\"{model_name}_acados_get_sim_out\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_in\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_in\").restype = c_void_p\n        self.sim_in = getattr(self.shared_lib, f\"{model_name}_acados_get_sim_in\")(self.capsule)\n\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_solver\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{model_name}_acados_get_sim_solver\").restype = c_void_p\n        self.sim_solver = getattr(self.shared_lib, f\"{model_name}_acados_get_sim_solver\")(self.capsule)\n\n        self.gettable_vectors = ['x', 'u', 'z', 'S_adj']\n        self.gettable_matrices = ['S_forw', 'Sx', 'Su', 'S_hess', 'S_algebraic']\n        self.gettable_scalars = ['CPUtime', 'time_tot', 'ADtime', 'time_ad', 'LAtime', 'time_la']\n\n\n    def simulate(self, x=None, u=None, z=None, p=None):\n        \"\"\"\n        Simulate the system forward for the given x, u, z, p and return x_next.\n        Wrapper around `solve()` taking care of setting/getting inputs/outputs.\n        \"\"\"\n        if x is not None:\n            self.set('x', x)\n        if u is not None:\n            self.set('u', u)\n        if z is not None:\n            self.set('z', z)\n        if p is not None:\n            self.set('p', p)\n\n        status = self.solve()\n\n        if status == 2:\n            print(\"Warning: acados_sim_solver reached maximum iterations.\")\n        elif status != 0:\n            raise Exception(f'acados_sim_solver for model {self.model_name} returned status {status}.')\n\n        x_next = self.get('x')\n        return x_next\n\n\n    def solve(self):\n        \"\"\"\n        Solve the simulation problem with current input.\n        \"\"\"\n        getattr(self.shared_lib, f\"{self.model_name}_acados_sim_solve\").argtypes = [c_void_p]\n        getattr(self.shared_lib, f\"{self.model_name}_acados_sim_solve\").restype = c_int\n\n        status = getattr(self.shared_lib, f\"{self.model_name}_acados_sim_solve\")(self.capsule)\n        return status\n\n\n    def get(self, field_):\n        \"\"\"\n        Get the last solution of the solver.\n\n            :param str field: string in ['x', 'u', 'z', 'S_forw', 'Sx', 'Su', 'S_adj', 'S_hess', 'S_algebraic', 'CPUtime', 'time_tot', 'ADtime', 'time_ad', 'LAtime', 'time_la']\n        \"\"\"\n        field = field_.encode('utf-8')\n\n        if field_ in self.gettable_vectors:\n            # get dims\n            dims = np.ascontiguousarray(np.zeros((2,)), dtype=np.intc)\n            dims_data = cast(dims.ctypes.data, POINTER(c_int))\n\n            self.shared_lib.sim_dims_get_from_attr.argtypes = [c_void_p, c_void_p, c_char_p, POINTER(c_int)]\n            self.shared_lib.sim_dims_get_from_attr(self.sim_config, self.sim_dims, field, dims_data)\n\n            # allocate array\n            out = np.ascontiguousarray(np.zeros((dims[0],)), dtype=np.float64)\n            out_data = cast(out.ctypes.data, POINTER(c_double))\n\n            self.shared_lib.sim_out_get.argtypes = [c_void_p, c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.sim_out_get(self.sim_config, self.sim_dims, self.sim_out, field, out_data)\n\n        elif field_ in self.gettable_matrices:\n            # get dims\n            dims = np.ascontiguousarray(np.zeros((2,)), dtype=np.intc)\n            dims_data = cast(dims.ctypes.data, POINTER(c_int))\n\n            self.shared_lib.sim_dims_get_from_attr.argtypes = [c_void_p, c_void_p, c_char_p, POINTER(c_int)]\n            self.shared_lib.sim_dims_get_from_attr(self.sim_config, self.sim_dims, field, dims_data)\n\n            out = np.zeros((dims[0], dims[1]), order='F')\n            out_data = cast(out.ctypes.data, POINTER(c_double))\n\n            self.shared_lib.sim_out_get.argtypes = [c_void_p, c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.sim_out_get(self.sim_config, self.sim_dims, self.sim_out, field, out_data)\n\n        elif field_ in self.gettable_scalars:\n            scalar = c_double()\n            scalar_data = byref(scalar)\n            self.shared_lib.sim_out_get.argtypes = [c_void_p, c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.sim_out_get(self.sim_config, self.sim_dims, self.sim_out, field, scalar_data)\n\n            out = scalar.value\n        else:\n            raise Exception(f'AcadosSimSolver.get(): Unknown field {field_},' \\\n                f' available fields are {\", \".join(self.gettable_vectors+self.gettable_matrices)}, {\", \".join(self.gettable_scalars)}')\n\n        return out\n\n\n\n    def set(self, field_: str, value_):\n        \"\"\"\n        Set numerical data inside the solver.\n\n            :param field: string in ['x', 'u', 'p', 'xdot', 'z', 'seed_adj', 'T']\n            :param value: the value with appropriate size.\n        \"\"\"\n        settable = ['x', 'u', 'p', 'xdot', 'z', 'seed_adj', 'T'] # S_forw\n\n        # TODO: check and throw error here. then remove checks in Cython for speed\n        # cast value_ to avoid conversion issues\n        if isinstance(value_, (float, int)):\n            value_ = np.array([value_])\n\n        value_ = value_.astype(float)\n        value_data = cast(value_.ctypes.data, POINTER(c_double))\n        value_data_p = cast((value_data), c_void_p)\n\n        field = field_.encode('utf-8')\n\n        # treat parameters separately\n        if field_ == 'p':\n            model_name = self.acados_sim.model.name\n            getattr(self.shared_lib, f\"{model_name}_acados_sim_update_params\").argtypes = [c_void_p, POINTER(c_double), c_int]\n            value_data = cast(value_.ctypes.data, POINTER(c_double))\n            getattr(self.shared_lib, f\"{model_name}_acados_sim_update_params\")(self.capsule, value_data, value_.shape[0])\n            return\n        else:\n            # dimension check\n            dims = np.ascontiguousarray(np.zeros((2,)), dtype=np.intc)\n            dims_data = cast(dims.ctypes.data, POINTER(c_int))\n\n            self.shared_lib.sim_dims_get_from_attr.argtypes = [c_void_p, c_void_p, c_char_p, POINTER(c_int)]\n            self.shared_lib.sim_dims_get_from_attr(self.sim_config, self.sim_dims, field, dims_data)\n\n            value_ = np.ravel(value_, order='F')\n\n            value_shape = value_.shape\n            if len(value_shape) == 1:\n                value_shape = (value_shape[0], 0)\n\n            if value_shape != tuple(dims):\n                raise Exception(f'AcadosSimSolver.set(): mismatching dimension' \\\n                    f' for field \"{field_}\" with dimension {tuple(dims)} (you have {value_shape}).')\n\n        # set\n        if field_ in ['xdot', 'z']:\n            self.shared_lib.sim_solver_set.argtypes = [c_void_p, c_char_p, c_void_p]\n            self.shared_lib.sim_solver_set(self.sim_solver, field, value_data_p)\n        elif field_ in settable:\n            self.shared_lib.sim_in_set.argtypes = [c_void_p, c_void_p, c_void_p, c_char_p, c_void_p]\n            self.shared_lib.sim_in_set(self.sim_config, self.sim_dims, self.sim_in, field, value_data_p)\n        else:\n            raise Exception(f'AcadosSimSolver.set(): Unknown field {field_},' \\\n                f' available fields are {\", \".join(settable)}')\n\n        return\n\n\n    def options_set(self, field_: str, value_: bool):\n        \"\"\"\n        Set solver options\n\n            :param field: string in ['sens_forw', 'sens_adj', 'sens_hess']\n            :param value: Boolean\n        \"\"\"\n        fields = ['sens_forw', 'sens_adj', 'sens_hess']\n        if field_ not in fields:\n            raise Exception(f\"field {field_} not supported. Supported values are {', '.join(fields)}.\\n\")\n\n        field = field_.encode('utf-8')\n        value_ctypes = c_bool(value_)\n\n        if not isinstance(value_, bool):\n            raise TypeError(\"options_set: expected boolean for value\")\n\n        # only allow setting\n        if getattr(self.acados_sim.solver_options, field_) or value_ == False:\n            self.shared_lib.sim_opts_set.argtypes = [c_void_p, c_void_p, c_char_p, POINTER(c_bool)]\n            self.shared_lib.sim_opts_set(self.sim_config, self.sim_opts, field, value_ctypes)\n        else:\n            raise RuntimeError(f\"Cannot set option {field_} to True, because it was False in original solver options.\\n\")\n\n        return\n\n\n    def __del__(self):\n\n        if self.solver_created:\n            getattr(self.shared_lib, f\"{self.model_name}_acados_sim_free\").argtypes = [c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_sim_free\").restype = c_int\n            getattr(self.shared_lib, f\"{self.model_name}_acados_sim_free\")(self.capsule)\n\n            getattr(self.shared_lib, f\"{self.model_name}_acados_sim_solver_free_capsule\").argtypes = [c_void_p]\n            getattr(self.shared_lib, f\"{self.model_name}_acados_sim_solver_free_capsule\").restype = c_int\n            getattr(self.shared_lib, f\"{self.model_name}_acados_sim_solver_free_capsule\")(self.capsule)\n\n            try:\n                self.dlclose(self.shared_lib._handle)\n            except:\n                print(f\"WARNING: acados Python interface could not close shared_lib handle of AcadosSimSolver {self.model_name}.\\n\",\n                     \"Attempting to create a new one with the same name will likely result in the old one being used!\")\n                pass\n", "third_party/acados/acados_template/__init__.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nfrom .acados_model import AcadosModel\nfrom .acados_ocp import AcadosOcp, AcadosOcpConstraints, AcadosOcpCost, AcadosOcpDims, AcadosOcpOptions\nfrom .acados_sim import AcadosSim, AcadosSimDims, AcadosSimOpts\nfrom .acados_ocp_solver import AcadosOcpSolver, get_simulink_default_opts, ocp_get_default_cmake_builder\nfrom .acados_sim_solver import AcadosSimSolver, sim_get_default_cmake_builder\nfrom .utils import print_casadi_expression, get_acados_path, get_python_interface_path, \\\n    get_tera_exec_path, get_tera, check_casadi_version, acados_dae_model_json_dump, \\\n    casadi_length, make_object_json_dumpable, J_to_idx, get_default_simulink_opts\n\nfrom .zoro_description import ZoroDescription, process_zoro_description\n", "third_party/acados/acados_template/zoro_description.py": "# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n\nfrom dataclasses import dataclass, field\nimport numpy as np\n\n\n@dataclass\nclass ZoroDescription:\n    \"\"\"\n    Zero-Order Robust Optimization scheme.\n\n    For advanced users.\n    \"\"\"\n    backoff_scaling_gamma: float = 1.0\n    fdbk_K_mat: np.ndarray = None\n    unc_jac_G_mat: np.ndarray = None    # default: an identity matrix\n    P0_mat: np.ndarray = None\n    W_mat: np.ndarray = None\n    idx_lbx_t: list = field(default_factory=list)\n    idx_ubx_t: list = field(default_factory=list)\n    idx_lbx_e_t: list = field(default_factory=list)\n    idx_ubx_e_t: list = field(default_factory=list)\n    idx_lbu_t: list = field(default_factory=list)\n    idx_ubu_t: list = field(default_factory=list)\n    idx_lg_t: list = field(default_factory=list)\n    idx_ug_t: list = field(default_factory=list)\n    idx_lg_e_t: list = field(default_factory=list)\n    idx_ug_e_t: list = field(default_factory=list)\n    idx_lh_t: list = field(default_factory=list)\n    idx_uh_t: list = field(default_factory=list)\n    idx_lh_e_t: list = field(default_factory=list)\n    idx_uh_e_t: list = field(default_factory=list)\n\ndef process_zoro_description(zoro_description: ZoroDescription):\n    zoro_description.nw, _ = zoro_description.W_mat.shape\n    if zoro_description.unc_jac_G_mat is None:\n        zoro_description.unc_jac_G_mat = np.eye(zoro_description.nw)\n    zoro_description.nlbx_t = len(zoro_description.idx_lbx_t)\n    zoro_description.nubx_t = len(zoro_description.idx_ubx_t)\n    zoro_description.nlbx_e_t = len(zoro_description.idx_lbx_e_t)\n    zoro_description.nubx_e_t = len(zoro_description.idx_ubx_e_t)\n    zoro_description.nlbu_t = len(zoro_description.idx_lbu_t)\n    zoro_description.nubu_t = len(zoro_description.idx_ubu_t)\n    zoro_description.nlg_t = len(zoro_description.idx_lg_t)\n    zoro_description.nug_t = len(zoro_description.idx_ug_t)\n    zoro_description.nlg_e_t = len(zoro_description.idx_lg_e_t)\n    zoro_description.nug_e_t = len(zoro_description.idx_ug_e_t)\n    zoro_description.nlh_t = len(zoro_description.idx_lh_t)\n    zoro_description.nuh_t = len(zoro_description.idx_uh_t)\n    zoro_description.nlh_e_t = len(zoro_description.idx_lh_e_t)\n    zoro_description.nuh_e_t = len(zoro_description.idx_uh_e_t)\n    return zoro_description.__dict__\n", "third_party/acados/acados_template/acados_sim.py": "# -*- coding: future_fstrings -*-\n#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport numpy as np\nimport os\nfrom .acados_model import AcadosModel\nfrom .utils import get_acados_path, get_lib_ext\n\nclass AcadosSimDims:\n    \"\"\"\n    Class containing the dimensions of the model to be simulated.\n    \"\"\"\n    def __init__(self):\n        self.__nx = None\n        self.__nu = None\n        self.__nz = 0\n        self.__np = 0\n\n    @property\n    def nx(self):\n        \"\"\":math:`n_x` - number of states. Type: int > 0\"\"\"\n        return self.__nx\n\n    @property\n    def nz(self):\n        \"\"\":math:`n_z` - number of algebraic variables. Type: int >= 0\"\"\"\n        return self.__nz\n\n    @property\n    def nu(self):\n        \"\"\":math:`n_u` - number of inputs. Type: int >= 0\"\"\"\n        return self.__nu\n\n    @property\n    def np(self):\n        \"\"\":math:`n_p` - number of parameters. Type: int >= 0\"\"\"\n        return self.__np\n\n    @nx.setter\n    def nx(self, nx):\n        if isinstance(nx, int) and nx > 0:\n            self.__nx = nx\n        else:\n            raise Exception('Invalid nx value, expected positive integer.')\n\n    @nz.setter\n    def nz(self, nz):\n        if isinstance(nz, int) and nz > -1:\n            self.__nz = nz\n        else:\n            raise Exception('Invalid nz value, expected nonnegative integer.')\n\n    @nu.setter\n    def nu(self, nu):\n        if isinstance(nu, int) and nu > -1:\n            self.__nu = nu\n        else:\n            raise Exception('Invalid nu value, expected nonnegative integer.')\n\n    @np.setter\n    def np(self, np):\n        if isinstance(np, int) and np > -1:\n            self.__np = np\n        else:\n            raise Exception('Invalid np value, expected nonnegative integer.')\n\n    def set(self, attr, value):\n        setattr(self, attr, value)\n\n\nclass AcadosSimOpts:\n    \"\"\"\n    class containing the solver options\n    \"\"\"\n    def __init__(self):\n        self.__integrator_type = 'ERK'\n        self.__collocation_type = 'GAUSS_LEGENDRE'\n        self.__Tsim = None\n        # ints\n        self.__sim_method_num_stages = 1\n        self.__sim_method_num_steps = 1\n        self.__sim_method_newton_iter = 3\n        # doubles\n        self.__sim_method_newton_tol = 0.0\n        # bools\n        self.__sens_forw = True\n        self.__sens_adj = False\n        self.__sens_algebraic = False\n        self.__sens_hess = False\n        self.__output_z = True\n        self.__sim_method_jac_reuse = 0\n        self.__ext_fun_compile_flags = '-O2'\n\n    @property\n    def integrator_type(self):\n        \"\"\"Integrator type. Default: 'ERK'.\"\"\"\n        return self.__integrator_type\n\n    @property\n    def num_stages(self):\n        \"\"\"Number of stages in the integrator. Default: 1\"\"\"\n        return self.__sim_method_num_stages\n\n    @property\n    def num_steps(self):\n        \"\"\"Number of steps in the integrator. Default: 1\"\"\"\n        return self.__sim_method_num_steps\n\n    @property\n    def newton_iter(self):\n        \"\"\"Number of Newton iterations in simulation method. Default: 3\"\"\"\n        return self.__sim_method_newton_iter\n\n    @property\n    def newton_tol(self):\n        \"\"\"\n        Tolerance for Newton system solved in implicit integrator (IRK, GNSF).\n        0.0 means this is not used and exactly newton_iter iterations are carried out.\n        Default: 0.0\n        \"\"\"\n        return self.__sim_method_newton_tol\n\n    @property\n    def sens_forw(self):\n        \"\"\"Boolean determining if forward sensitivities are computed. Default: True\"\"\"\n        return self.__sens_forw\n\n    @property\n    def sens_adj(self):\n        \"\"\"Boolean determining if adjoint sensitivities are computed. Default: False\"\"\"\n        return self.__sens_adj\n\n    @property\n    def sens_algebraic(self):\n        \"\"\"Boolean determining if sensitivities wrt algebraic variables are computed. Default: False\"\"\"\n        return self.__sens_algebraic\n\n    @property\n    def sens_hess(self):\n        \"\"\"Boolean determining if hessians are computed. Default: False\"\"\"\n        return self.__sens_hess\n\n    @property\n    def output_z(self):\n        \"\"\"Boolean determining if values for algebraic variables (corresponding to start of simulation interval) are computed. Default: True\"\"\"\n        return self.__output_z\n\n    @property\n    def sim_method_jac_reuse(self):\n        \"\"\"Integer determining if jacobians are reused (0 or 1). Default: 0\"\"\"\n        return self.__sim_method_jac_reuse\n\n    @property\n    def T(self):\n        \"\"\"Time horizon\"\"\"\n        return self.__Tsim\n\n    @property\n    def collocation_type(self):\n        \"\"\"Collocation type: relevant for implicit integrators\n        -- string in {GAUSS_RADAU_IIA, GAUSS_LEGENDRE}\n\n        Default: GAUSS_LEGENDRE\n        \"\"\"\n        return self.__collocation_type\n\n    @property\n    def ext_fun_compile_flags(self):\n        \"\"\"\n        String with compiler flags for external function compilation.\n        Default: '-O2'.\n        \"\"\"\n        return self.__ext_fun_compile_flags\n\n    @ext_fun_compile_flags.setter\n    def ext_fun_compile_flags(self, ext_fun_compile_flags):\n        if isinstance(ext_fun_compile_flags, str):\n            self.__ext_fun_compile_flags = ext_fun_compile_flags\n        else:\n            raise Exception('Invalid ext_fun_compile_flags, expected a string.\\n')\n\n    @integrator_type.setter\n    def integrator_type(self, integrator_type):\n        integrator_types = ('ERK', 'IRK', 'GNSF')\n        if integrator_type in integrator_types:\n            self.__integrator_type = integrator_type\n        else:\n            raise Exception('Invalid integrator_type value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(integrator_types) + '.\\n\\nYou have: ' + integrator_type + '.\\n\\n')\n\n    @collocation_type.setter\n    def collocation_type(self, collocation_type):\n        collocation_types = ('GAUSS_RADAU_IIA', 'GAUSS_LEGENDRE')\n        if collocation_type in collocation_types:\n            self.__collocation_type = collocation_type\n        else:\n            raise Exception('Invalid collocation_type value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(collocation_types) + '.\\n\\nYou have: ' + collocation_type + '.\\n\\n')\n\n    @T.setter\n    def T(self, T):\n        self.__Tsim = T\n\n    @num_stages.setter\n    def num_stages(self, num_stages):\n        if isinstance(num_stages, int):\n            self.__sim_method_num_stages = num_stages\n        else:\n            raise Exception('Invalid num_stages value. num_stages must be an integer.')\n\n    @num_steps.setter\n    def num_steps(self, num_steps):\n        if isinstance(num_steps, int):\n            self.__sim_method_num_steps = num_steps\n        else:\n            raise Exception('Invalid num_steps value. num_steps must be an integer.')\n\n    @newton_iter.setter\n    def newton_iter(self, newton_iter):\n        if isinstance(newton_iter, int):\n            self.__sim_method_newton_iter = newton_iter\n        else:\n            raise Exception('Invalid newton_iter value. newton_iter must be an integer.')\n\n    @newton_tol.setter\n    def newton_tol(self, newton_tol):\n        if isinstance(newton_tol, float):\n            self.__sim_method_newton_tol = newton_tol\n        else:\n            raise Exception('Invalid newton_tol value. newton_tol must be an float.')\n\n    @sens_forw.setter\n    def sens_forw(self, sens_forw):\n        if sens_forw in (True, False):\n            self.__sens_forw = sens_forw\n        else:\n            raise Exception('Invalid sens_forw value. sens_forw must be a Boolean.')\n\n    @sens_adj.setter\n    def sens_adj(self, sens_adj):\n        if sens_adj in (True, False):\n            self.__sens_adj = sens_adj\n        else:\n            raise Exception('Invalid sens_adj value. sens_adj must be a Boolean.')\n\n    @sens_hess.setter\n    def sens_hess(self, sens_hess):\n        if sens_hess in (True, False):\n            self.__sens_hess = sens_hess\n        else:\n            raise Exception('Invalid sens_hess value. sens_hess must be a Boolean.')\n\n    @sens_algebraic.setter\n    def sens_algebraic(self, sens_algebraic):\n        if sens_algebraic in (True, False):\n            self.__sens_algebraic = sens_algebraic\n        else:\n            raise Exception('Invalid sens_algebraic value. sens_algebraic must be a Boolean.')\n\n    @output_z.setter\n    def output_z(self, output_z):\n        if output_z in (True, False):\n            self.__output_z = output_z\n        else:\n            raise Exception('Invalid output_z value. output_z must be a Boolean.')\n\n    @sim_method_jac_reuse.setter\n    def sim_method_jac_reuse(self, sim_method_jac_reuse):\n        if sim_method_jac_reuse in (0, 1):\n            self.__sim_method_jac_reuse = sim_method_jac_reuse\n        else:\n            raise Exception('Invalid sim_method_jac_reuse value. sim_method_jac_reuse must be 0 or 1.')\n\nclass AcadosSim:\n    \"\"\"\n    The class has the following properties that can be modified to formulate a specific simulation problem, see below:\n\n    :param acados_path: string with the path to acados. It is used to generate the include and lib paths.\n\n    - :py:attr:`dims` of type :py:class:`acados_template.acados_ocp.AcadosSimDims` - are automatically detected from model\n    - :py:attr:`model` of type :py:class:`acados_template.acados_model.AcadosModel`\n    - :py:attr:`solver_options` of type :py:class:`acados_template.acados_sim.AcadosSimOpts`\n\n    - :py:attr:`acados_include_path` (set automatically)\n    - :py:attr:`shared_lib_ext` (set automatically)\n    - :py:attr:`acados_lib_path` (set automatically)\n    - :py:attr:`parameter_values` - used to initialize the parameters (can be changed)\n\n    \"\"\"\n    def __init__(self, acados_path=''):\n        if acados_path == '':\n            acados_path = get_acados_path()\n        self.dims = AcadosSimDims()\n        \"\"\"Dimension definitions, automatically detected from :py:attr:`model`. Type :py:class:`acados_template.acados_sim.AcadosSimDims`\"\"\"\n        self.model = AcadosModel()\n        \"\"\"Model definitions, type :py:class:`acados_template.acados_model.AcadosModel`\"\"\"\n        self.solver_options = AcadosSimOpts()\n        \"\"\"Solver Options, type :py:class:`acados_template.acados_sim.AcadosSimOpts`\"\"\"\n\n        self.acados_include_path = os.path.join(acados_path, 'include').replace(os.sep, '/') # the replace part is important on Windows for CMake\n        \"\"\"Path to acados include directory (set automatically), type: `string`\"\"\"\n        self.acados_lib_path = os.path.join(acados_path, 'lib').replace(os.sep, '/') # the replace part is important on Windows for CMake\n        \"\"\"Path to where acados library is located (set automatically), type: `string`\"\"\"\n\n        self.code_export_directory = 'c_generated_code'\n        \"\"\"Path to where code will be exported. Default: `c_generated_code`.\"\"\"\n        self.shared_lib_ext = get_lib_ext()\n\n        # get cython paths\n        from sysconfig import get_paths\n        self.cython_include_dirs = [np.get_include(), get_paths()['include']]\n\n        self.__parameter_values = np.array([])\n        self.__problem_class = 'SIM'\n\n    @property\n    def parameter_values(self):\n        \"\"\":math:`p` - initial values for parameter - can be updated\"\"\"\n        return self.__parameter_values\n\n    @parameter_values.setter\n    def parameter_values(self, parameter_values):\n        if isinstance(parameter_values, np.ndarray):\n            self.__parameter_values = parameter_values\n        else:\n            raise Exception('Invalid parameter_values value. ' +\n                            f'Expected numpy array, got {type(parameter_values)}.')\n\n    def set(self, attr, value):\n        # tokenize string\n        tokens = attr.split('_', 1)\n        if len(tokens) > 1:\n            setter_to_call = getattr(getattr(self, tokens[0]), 'set')\n        else:\n            setter_to_call = getattr(self, 'set')\n\n        setter_to_call(tokens[1], value)\n\n        return\n", "third_party/acados/acados_template/acados_ocp.py": "# -*- coding: future_fstrings -*-\n#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport numpy as np\nimport os\nfrom .acados_model import AcadosModel\nfrom .utils import get_acados_path, J_to_idx, J_to_idx_slack, get_lib_ext\n\nclass AcadosOcpDims:\n    \"\"\"\n    Class containing the dimensions of the optimal control problem.\n    \"\"\"\n    def __init__(self):\n        self.__nx      = None\n        self.__nu      = None\n        self.__nz      = 0\n        self.__np      = 0\n        self.__ny      = 0\n        self.__ny_e    = 0\n        self.__ny_0    = 0\n        self.__nr      = 0\n        self.__nr_e    = 0\n        self.__nh      = 0\n        self.__nh_e    = 0\n        self.__nphi    = 0\n        self.__nphi_e  = 0\n        self.__nbx     = 0\n        self.__nbx_0   = 0\n        self.__nbx_e   = 0\n        self.__nbu     = 0\n        self.__nsbx    = 0\n        self.__nsbx_e  = 0\n        self.__nsbu    = 0\n        self.__nsh     = 0\n        self.__nsh_e   = 0\n        self.__nsphi   = 0\n        self.__nsphi_e = 0\n        self.__ns      = 0\n        self.__ns_e    = 0\n        self.__ng      = 0\n        self.__ng_e    = 0\n        self.__nsg     = 0\n        self.__nsg_e   = 0\n        self.__nbxe_0  = None\n        self.__N       = None\n\n\n    @property\n    def nx(self):\n        \"\"\":math:`n_x` - number of states.\n        Type: int; default: None\"\"\"\n        return self.__nx\n\n    @property\n    def nz(self):\n        \"\"\":math:`n_z` - number of algebraic variables.\n        Type: int; default: 0\"\"\"\n        return self.__nz\n\n    @property\n    def nu(self):\n        \"\"\":math:`n_u` - number of inputs.\n        Type: int; default: None\"\"\"\n        return self.__nu\n\n    @property\n    def np(self):\n        \"\"\":math:`n_p` - number of parameters.\n        Type: int; default: 0\"\"\"\n        return self.__np\n\n    @property\n    def ny(self):\n        \"\"\":math:`n_y` - number of residuals in Lagrange term.\n        Type: int; default: 0\"\"\"\n        return self.__ny\n\n    @property\n    def ny_0(self):\n        \"\"\":math:`n_{y}^0` - number of residuals in Mayer term.\n        Type: int; default: 0\"\"\"\n        return self.__ny_0\n\n    @property\n    def ny_e(self):\n        \"\"\":math:`n_{y}^e` - number of residuals in Mayer term.\n        Type: int; default: 0\"\"\"\n        return self.__ny_e\n\n    @property\n    def nr(self):\n        \"\"\":math:`n_{\\pi}` - dimension of the image of the inner nonlinear function in positive definite constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nr\n\n    @property\n    def nr_e(self):\n        \"\"\":math:`n_{\\pi}^e` - dimension of the image of the inner nonlinear function in positive definite constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nr_e\n\n    @property\n    def nh(self):\n        \"\"\":math:`n_h` - number of nonlinear constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nh\n\n    @property\n    def nh_e(self):\n        \"\"\":math:`n_{h}^e` - number of nonlinear constraints at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nh_e\n\n    @property\n    def nphi(self):\n        \"\"\":math:`n_{\\phi}` - number of convex-over-nonlinear constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nphi\n\n    @property\n    def nphi_e(self):\n        \"\"\":math:`n_{\\phi}^e` - number of convex-over-nonlinear constraints at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nphi_e\n\n    @property\n    def nbx(self):\n        \"\"\":math:`n_{b_x}` - number of state bounds.\n        Type: int; default: 0\"\"\"\n        return self.__nbx\n\n    @property\n    def nbxe_0(self):\n        \"\"\":math:`n_{be_{x0}}` - number of state bounds at initial shooting node that are equalities.\n        Type: int; default: None\"\"\"\n        return self.__nbxe_0\n\n    @property\n    def nbx_0(self):\n        \"\"\":math:`n_{b_{x0}}` - number of state bounds for initial state.\n        Type: int; default: 0\"\"\"\n        return self.__nbx_0\n\n    @property\n    def nbx_e(self):\n        \"\"\":math:`n_{b_x}` - number of state bounds at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nbx_e\n\n    @property\n    def nbu(self):\n        \"\"\":math:`n_{b_u}` - number of input bounds.\n        Type: int; default: 0\"\"\"\n        return self.__nbu\n\n    @property\n    def nsbx(self):\n        \"\"\":math:`n_{{sb}_x}` - number of soft state bounds.\n        Type: int; default: 0\"\"\"\n        return self.__nsbx\n\n    @property\n    def nsbx_e(self):\n        \"\"\":math:`n_{{sb}^e_{x}}` - number of soft state bounds at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nsbx_e\n\n    @property\n    def nsbu(self):\n        \"\"\":math:`n_{{sb}_u}` - number of soft input bounds.\n        Type: int; default: 0\"\"\"\n        return self.__nsbu\n\n    @property\n    def nsg(self):\n        \"\"\":math:`n_{{sg}}` - number of soft general linear constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nsg\n\n    @property\n    def nsg_e(self):\n        \"\"\":math:`n_{{sg}^e}` - number of soft general linear constraints at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nsg_e\n\n    @property\n    def nsh(self):\n        \"\"\":math:`n_{{sh}}` - number of soft nonlinear constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nsh\n\n    @property\n    def nsh_e(self):\n        \"\"\":math:`n_{{sh}}^e` - number of soft nonlinear constraints at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nsh_e\n\n    @property\n    def nsphi(self):\n        \"\"\":math:`n_{{s\\phi}}` - number of soft convex-over-nonlinear constraints.\n        Type: int; default: 0\"\"\"\n        return self.__nsphi\n\n    @property\n    def nsphi_e(self):\n        \"\"\":math:`n_{{s\\phi}^e}` - number of soft convex-over-nonlinear constraints at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__nsphi_e\n\n    @property\n    def ns(self):\n        \"\"\":math:`n_{s}` - total number of slacks.\n        Type: int; default: 0\"\"\"\n        return self.__ns\n\n    @property\n    def ns_e(self):\n        \"\"\":math:`n_{s}^e` - total number of slacks at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__ns_e\n\n    @property\n    def ng(self):\n        \"\"\":math:`n_{g}` - number of general polytopic constraints.\n        Type: int; default: 0\"\"\"\n        return self.__ng\n\n    @property\n    def ng_e(self):\n        \"\"\":math:`n_{g}^e` - number of general polytopic constraints at terminal shooting node N.\n        Type: int; default: 0\"\"\"\n        return self.__ng_e\n\n    @property\n    def N(self):\n        \"\"\":math:`N` - prediction horizon.\n        Type: int; default: None\"\"\"\n        return self.__N\n\n    @nx.setter\n    def nx(self, nx):\n        if isinstance(nx, int) and nx > 0:\n            self.__nx = nx\n        else:\n            raise Exception('Invalid nx value, expected positive integer.')\n\n    @nz.setter\n    def nz(self, nz):\n        if isinstance(nz, int) and nz > -1:\n            self.__nz = nz\n        else:\n            raise Exception('Invalid nz value, expected nonnegative integer.')\n\n    @nu.setter\n    def nu(self, nu):\n        if isinstance(nu, int) and nu > -1:\n            self.__nu = nu\n        else:\n            raise Exception('Invalid nu value, expected nonnegative integer.')\n\n    @np.setter\n    def np(self, np):\n        if isinstance(np, int) and np > -1:\n            self.__np = np\n        else:\n            raise Exception('Invalid np value, expected nonnegative integer.')\n\n    @ny_0.setter\n    def ny_0(self, ny_0):\n        if isinstance(ny_0, int) and ny_0 > -1:\n            self.__ny_0 = ny_0\n        else:\n            raise Exception('Invalid ny_0 value, expected nonnegative integer.')\n\n    @ny.setter\n    def ny(self, ny):\n        if isinstance(ny, int) and ny > -1:\n            self.__ny = ny\n        else:\n            raise Exception('Invalid ny value, expected nonnegative integer.')\n\n    @ny_e.setter\n    def ny_e(self, ny_e):\n        if isinstance(ny_e, int) and ny_e > -1:\n            self.__ny_e = ny_e\n        else:\n            raise Exception('Invalid ny_e value, expected nonnegative integer.')\n\n    @nr.setter\n    def nr(self, nr):\n        if isinstance(nr, int) and nr > -1:\n            self.__nr = nr\n        else:\n            raise Exception('Invalid nr value, expected nonnegative integer.')\n\n    @nr_e.setter\n    def nr_e(self, nr_e):\n        if isinstance(nr_e, int) and nr_e > -1:\n            self.__nr_e = nr_e\n        else:\n            raise Exception('Invalid nr_e value, expected nonnegative integer.')\n\n    @nh.setter\n    def nh(self, nh):\n        if isinstance(nh, int) and nh > -1:\n            self.__nh = nh\n        else:\n            raise Exception('Invalid nh value, expected nonnegative integer.')\n\n    @nh_e.setter\n    def nh_e(self, nh_e):\n        if isinstance(nh_e, int) and nh_e > -1:\n            self.__nh_e = nh_e\n        else:\n            raise Exception('Invalid nh_e value, expected nonnegative integer.')\n\n    @nphi.setter\n    def nphi(self, nphi):\n        if isinstance(nphi, int) and nphi > -1:\n            self.__nphi = nphi\n        else:\n            raise Exception('Invalid nphi value, expected nonnegative integer.')\n\n    @nphi_e.setter\n    def nphi_e(self, nphi_e):\n        if isinstance(nphi_e, int) and nphi_e > -1:\n            self.__nphi_e = nphi_e\n        else:\n            raise Exception('Invalid nphi_e value, expected nonnegative integer.')\n\n    @nbx.setter\n    def nbx(self, nbx):\n        if isinstance(nbx, int) and nbx > -1:\n            self.__nbx = nbx\n        else:\n            raise Exception('Invalid nbx value, expected nonnegative integer.')\n\n    @nbxe_0.setter\n    def nbxe_0(self, nbxe_0):\n        if isinstance(nbxe_0, int) and nbxe_0 > -1:\n            self.__nbxe_0 = nbxe_0\n        else:\n            raise Exception('Invalid nbxe_0 value, expected nonnegative integer.')\n\n    @nbx_0.setter\n    def nbx_0(self, nbx_0):\n        if isinstance(nbx_0, int) and nbx_0 > -1:\n            self.__nbx_0 = nbx_0\n        else:\n            raise Exception('Invalid nbx_0 value, expected nonnegative integer.')\n\n    @nbx_e.setter\n    def nbx_e(self, nbx_e):\n        if isinstance(nbx_e, int) and nbx_e > -1:\n            self.__nbx_e = nbx_e\n        else:\n            raise Exception('Invalid nbx_e value, expected nonnegative integer.')\n\n    @nbu.setter\n    def nbu(self, nbu):\n        if isinstance(nbu, int) and nbu > -1:\n            self.__nbu = nbu\n        else:\n            raise Exception('Invalid nbu value, expected nonnegative integer.')\n\n    @nsbx.setter\n    def nsbx(self, nsbx):\n        if isinstance(nsbx, int) and nsbx > -1:\n            self.__nsbx = nsbx\n        else:\n            raise Exception('Invalid nsbx value, expected nonnegative integer.')\n\n    @nsbx_e.setter\n    def nsbx_e(self, nsbx_e):\n        if isinstance(nsbx_e, int) and nsbx_e > -1:\n            self.__nsbx_e = nsbx_e\n        else:\n            raise Exception('Invalid nsbx_e value, expected nonnegative integer.')\n\n    @nsbu.setter\n    def nsbu(self, nsbu):\n        if isinstance(nsbu, int) and nsbu > -1:\n            self.__nsbu = nsbu\n        else:\n            raise Exception('Invalid nsbu value, expected nonnegative integer.')\n\n    @nsg.setter\n    def nsg(self, nsg):\n        if isinstance(nsg, int) and nsg > -1:\n            self.__nsg = nsg\n        else:\n            raise Exception('Invalid nsg value, expected nonnegative integer.')\n\n    @nsg_e.setter\n    def nsg_e(self, nsg_e):\n        if isinstance(nsg_e, int) and nsg_e > -1:\n            self.__nsg_e = nsg_e\n        else:\n            raise Exception('Invalid nsg_e value, expected nonnegative integer.')\n\n    @nsh.setter\n    def nsh(self, nsh):\n        if isinstance(nsh, int) and nsh > -1:\n            self.__nsh = nsh\n        else:\n            raise Exception('Invalid nsh value, expected nonnegative integer.')\n\n    @nsh_e.setter\n    def nsh_e(self, nsh_e):\n        if isinstance(nsh_e, int) and nsh_e > -1:\n            self.__nsh_e = nsh_e\n        else:\n            raise Exception('Invalid nsh_e value, expected nonnegative integer.')\n\n    @nsphi.setter\n    def nsphi(self, nsphi):\n        if isinstance(nsphi, int) and nsphi > -1:\n            self.__nsphi = nsphi\n        else:\n            raise Exception('Invalid nsphi value, expected nonnegative integer.')\n\n    @nsphi_e.setter\n    def nsphi_e(self, nsphi_e):\n        if isinstance(nsphi_e, int) and nsphi_e > -1:\n            self.__nsphi_e = nsphi_e\n        else:\n            raise Exception('Invalid nsphi_e value, expected nonnegative integer.')\n\n    @ns.setter\n    def ns(self, ns):\n        if isinstance(ns, int) and ns > -1:\n            self.__ns = ns\n        else:\n            raise Exception('Invalid ns value, expected nonnegative integer.')\n\n    @ns_e.setter\n    def ns_e(self, ns_e):\n        if isinstance(ns_e, int) and ns_e > -1:\n            self.__ns_e = ns_e\n        else:\n            raise Exception('Invalid ns_e value, expected nonnegative integer.')\n\n    @ng.setter\n    def ng(self, ng):\n        if isinstance(ng, int) and ng > -1:\n            self.__ng = ng\n        else:\n            raise Exception('Invalid ng value, expected nonnegative integer.')\n\n    @ng_e.setter\n    def ng_e(self, ng_e):\n        if isinstance(ng_e, int) and ng_e > -1:\n            self.__ng_e = ng_e\n        else:\n            raise Exception('Invalid ng_e value, expected nonnegative integer.')\n\n    @N.setter\n    def N(self, N):\n        if isinstance(N, int) and N > 0:\n            self.__N = N\n        else:\n            raise Exception('Invalid N value, expected positive integer.')\n\n    def set(self, attr, value):\n        setattr(self, attr, value)\n\n\nclass AcadosOcpCost:\n    \"\"\"\n    Class containing the numerical data of the cost:\n\n    NOTE: all cost terms, except for the terminal one are weighted with the corresponding time step.\n    This means given the time steps are :math:`\\Delta t_0,..., \\Delta t_N`, the total cost is given by:\n    :math:`c_\\\\text{total} = \\Delta t_0 \\cdot c_0(x_0, u_0, p_0, z_0) + ... + \\Delta t_{N-1} \\cdot c_{N-1}(x_0, u_0, p_0, z_0) + c_N(x_N, p_N)`.\n\n    This means the Lagrange cost term is given in continuous time, this makes up for a seeminglessly OCP discretization with a nonuniform time grid.\n\n    In case of LINEAR_LS:\n    stage cost is\n    :math:`l(x,u,z) = || V_x \\, x + V_u \\, u + V_z \\, z - y_\\\\text{ref}||^2_W`,\n    terminal cost is\n    :math:`m(x) = || V^e_x \\, x - y_\\\\text{ref}^e||^2_{W^e}`\n\n    In case of NONLINEAR_LS:\n    stage cost is\n    :math:`l(x,u,z,p) = || y(x,u,z,p) - y_\\\\text{ref}||^2_W`,\n    terminal cost is\n    :math:`m(x,p) = || y^e(x,p) - y_\\\\text{ref}^e||^2_{W^e}`\n\n    In case of CONVEX_OVER_NONLINEAR:\n    stage cost is\n    :math:`l(x,u,p) = \\psi(y(x,u,p) - y_\\\\text{ref}, p)`,\n    terminal cost is\n    :math:`m(x, p) = \\psi^e (y^e(x,p) - y_\\\\text{ref}^e, p)`\n    \"\"\"\n    def __init__(self):\n        # initial stage\n        self.__cost_type_0 = None\n        self.__W_0 = None\n        self.__Vx_0 = None\n        self.__Vu_0 = None\n        self.__Vz_0 = None\n        self.__yref_0 = None\n        self.__cost_ext_fun_type_0 = 'casadi'\n        # Lagrange term\n        self.__cost_type   = 'LINEAR_LS'  # cost type\n        self.__W           = np.zeros((0,0))\n        self.__Vx          = np.zeros((0,0))\n        self.__Vu          = np.zeros((0,0))\n        self.__Vz          = np.zeros((0,0))\n        self.__yref        = np.array([])\n        self.__Zl          = np.array([])\n        self.__Zu          = np.array([])\n        self.__zl          = np.array([])\n        self.__zu          = np.array([])\n        self.__cost_ext_fun_type = 'casadi'\n        # Mayer term\n        self.__cost_type_e = 'LINEAR_LS'\n        self.__W_e         = np.zeros((0,0))\n        self.__Vx_e        = np.zeros((0,0))\n        self.__yref_e      = np.array([])\n        self.__Zl_e        = np.array([])\n        self.__Zu_e        = np.array([])\n        self.__zl_e        = np.array([])\n        self.__zu_e        = np.array([])\n        self.__cost_ext_fun_type_e = 'casadi'\n\n    # initial stage\n    @property\n    def cost_type_0(self):\n        \"\"\"Cost type at initial shooting node (0)\n        -- string in {EXTERNAL, LINEAR_LS, NONLINEAR_LS, CONVEX_OVER_NONLINEAR} or :code:`None`.\n        Default: :code:`None`.\n\n            .. note:: Cost at initial stage is the same as for intermediate shooting nodes if not set differently explicitly.\n\n            .. note:: If :py:attr:`cost_type_0` is set to :code:`None` values in :py:attr:`W_0`, :py:attr:`Vx_0`, :py:attr:`Vu_0`, :py:attr:`Vz_0` and :py:attr:`yref_0` are ignored (set to :code:`None`).\n        \"\"\"\n        return self.__cost_type_0\n\n    @property\n    def W_0(self):\n        \"\"\":math:`W_0` - weight matrix at initial shooting node (0).\n        Default: :code:`None`.\n        \"\"\"\n        return self.__W_0\n\n    @property\n    def Vx_0(self):\n        \"\"\":math:`V_x^0` - x matrix coefficient at initial shooting node (0).\n        Default: :code:`None`.\n        \"\"\"\n        return self.__Vx_0\n\n    @property\n    def Vu_0(self):\n        \"\"\":math:`V_u^0` - u matrix coefficient at initial shooting node (0).\n        Default: :code:`None`.\n        \"\"\"\n        return self.__Vu_0\n\n    @property\n    def Vz_0(self):\n        \"\"\":math:`V_z^0` - z matrix coefficient at initial shooting node (0).\n        Default: :code:`None`.\n        \"\"\"\n        return self.__Vz_0\n\n    @property\n    def yref_0(self):\n        \"\"\":math:`y_\\\\text{ref}^0` - reference at initial shooting node (0).\n        Default: :code:`None`.\n        \"\"\"\n        return self.__yref_0\n\n    @property\n    def cost_ext_fun_type_0(self):\n        \"\"\"Type of external function for cost at initial shooting node (0)\n        -- string in {casadi, generic} or :code:`None`\n        Default: :code:'casadi'.\n\n            .. note:: Cost at initial stage is the same as for intermediate shooting nodes if not set differently explicitly.\n        \"\"\"\n        return self.__cost_ext_fun_type_0\n\n    @yref_0.setter\n    def yref_0(self, yref_0):\n        if isinstance(yref_0, np.ndarray) and len(yref_0.shape) == 1:\n            self.__yref_0 = yref_0\n        else:\n            raise Exception('Invalid yref_0 value, expected 1-dimensional numpy array.')\n\n    @W_0.setter\n    def W_0(self, W_0):\n        if isinstance(W_0, np.ndarray) and len(W_0.shape) == 2:\n            self.__W_0 = W_0\n        else:\n            raise Exception('Invalid cost W_0 value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @Vx_0.setter\n    def Vx_0(self, Vx_0):\n        if isinstance(Vx_0, np.ndarray) and len(Vx_0.shape) == 2:\n            self.__Vx_0 = Vx_0\n        else:\n            raise Exception('Invalid cost Vx_0 value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @Vu_0.setter\n    def Vu_0(self, Vu_0):\n        if isinstance(Vu_0, np.ndarray) and len(Vu_0.shape) == 2:\n            self.__Vu_0 = Vu_0\n        else:\n            raise Exception('Invalid cost Vu_0 value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @Vz_0.setter\n    def Vz_0(self, Vz_0):\n        if isinstance(Vz_0, np.ndarray) and len(Vz_0.shape) == 2:\n            self.__Vz_0 = Vz_0\n        else:\n            raise Exception('Invalid cost Vz_0 value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @cost_ext_fun_type_0.setter\n    def cost_ext_fun_type_0(self, cost_ext_fun_type_0):\n        if cost_ext_fun_type_0 in ['casadi', 'generic']:\n            self.__cost_ext_fun_type_0 = cost_ext_fun_type_0\n        else:\n            raise Exception('Invalid cost_ext_fun_type_0 value, expected numpy array.')\n\n    # Lagrange term\n    @property\n    def cost_type(self):\n        \"\"\"\n        Cost type at intermediate shooting nodes (1 to N-1)\n        -- string in {EXTERNAL, LINEAR_LS, NONLINEAR_LS, CONVEX_OVER_NONLINEAR}.\n        Default: 'LINEAR_LS'.\n        \"\"\"\n        return self.__cost_type\n\n    @property\n    def W(self):\n        \"\"\":math:`W` - weight matrix at intermediate shooting nodes (1 to N-1).\n        Default: :code:`np.zeros((0,0))`.\n        \"\"\"\n        return self.__W\n\n    @property\n    def Vx(self):\n        \"\"\":math:`V_x` - x matrix coefficient at intermediate shooting nodes (1 to N-1).\n        Default: :code:`np.zeros((0,0))`.\n        \"\"\"\n        return self.__Vx\n\n    @property\n    def Vu(self):\n        \"\"\":math:`V_u` - u matrix coefficient at intermediate shooting nodes (1 to N-1).\n        Default: :code:`np.zeros((0,0))`.\n        \"\"\"\n        return self.__Vu\n\n    @property\n    def Vz(self):\n        \"\"\":math:`V_z` - z matrix coefficient at intermediate shooting nodes (1 to N-1).\n        Default: :code:`np.zeros((0,0))`.\n        \"\"\"\n        return self.__Vz\n\n    @property\n    def yref(self):\n        \"\"\":math:`y_\\\\text{ref}` - reference at intermediate shooting nodes (1 to N-1).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__yref\n\n    @property\n    def Zl(self):\n        \"\"\":math:`Z_l` - diagonal of Hessian wrt lower slack at intermediate shooting nodes (0 to N-1).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__Zl\n\n    @property\n    def Zu(self):\n        \"\"\":math:`Z_u` - diagonal of Hessian wrt upper slack at intermediate shooting nodes (0 to N-1).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__Zu\n\n    @property\n    def zl(self):\n        \"\"\":math:`z_l` - gradient wrt lower slack at intermediate shooting nodes (0 to N-1).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__zl\n\n    @property\n    def zu(self):\n        \"\"\":math:`z_u` - gradient wrt upper slack at intermediate shooting nodes (0 to N-1).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__zu\n\n    @property\n    def cost_ext_fun_type(self):\n        \"\"\"Type of external function for cost at intermediate shooting nodes (1 to N-1).\n        -- string in {casadi, generic}\n        Default: :code:'casadi'.\n        \"\"\"\n        return self.__cost_ext_fun_type\n\n    @cost_type.setter\n    def cost_type(self, cost_type):\n        cost_types = ('LINEAR_LS', 'NONLINEAR_LS', 'EXTERNAL', 'CONVEX_OVER_NONLINEAR')\n        if cost_type in cost_types:\n            self.__cost_type = cost_type\n        else:\n            raise Exception('Invalid cost_type value.')\n\n    @cost_type_0.setter\n    def cost_type_0(self, cost_type_0):\n        cost_types = ('LINEAR_LS', 'NONLINEAR_LS', 'EXTERNAL', 'CONVEX_OVER_NONLINEAR')\n        if cost_type_0 in cost_types:\n            self.__cost_type_0 = cost_type_0\n        else:\n            raise Exception('Invalid cost_type_0 value.')\n\n    @W.setter\n    def W(self, W):\n        if isinstance(W, np.ndarray) and len(W.shape) == 2:\n            self.__W = W\n        else:\n            raise Exception('Invalid cost W value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n\n    @Vx.setter\n    def Vx(self, Vx):\n        if isinstance(Vx, np.ndarray) and len(Vx.shape) == 2:\n            self.__Vx = Vx\n        else:\n            raise Exception('Invalid cost Vx value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @Vu.setter\n    def Vu(self, Vu):\n        if isinstance(Vu, np.ndarray) and len(Vu.shape) == 2:\n            self.__Vu = Vu\n        else:\n            raise Exception('Invalid cost Vu value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @Vz.setter\n    def Vz(self, Vz):\n        if isinstance(Vz, np.ndarray) and len(Vz.shape) == 2:\n            self.__Vz = Vz\n        else:\n            raise Exception('Invalid cost Vz value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @yref.setter\n    def yref(self, yref):\n        if isinstance(yref, np.ndarray) and len(yref.shape) == 1:\n            self.__yref = yref\n        else:\n            raise Exception('Invalid yref value, expected 1-dimensional numpy array.')\n\n    @Zl.setter\n    def Zl(self, Zl):\n        if isinstance(Zl, np.ndarray):\n            self.__Zl = Zl\n        else:\n            raise Exception('Invalid Zl value, expected numpy array.')\n\n    @Zu.setter\n    def Zu(self, Zu):\n        if isinstance(Zu, np.ndarray):\n            self.__Zu = Zu\n        else:\n            raise Exception('Invalid Zu value, expected numpy array.')\n\n    @zl.setter\n    def zl(self, zl):\n        if isinstance(zl, np.ndarray):\n            self.__zl = zl\n        else:\n            raise Exception('Invalid zl value, expected numpy array.')\n\n    @zu.setter\n    def zu(self, zu):\n        if isinstance(zu, np.ndarray):\n            self.__zu = zu\n        else:\n            raise Exception('Invalid zu value, expected numpy array.')\n\n    @cost_ext_fun_type.setter\n    def cost_ext_fun_type(self, cost_ext_fun_type):\n        if cost_ext_fun_type in ['casadi', 'generic']:\n            self.__cost_ext_fun_type = cost_ext_fun_type\n        else:\n            raise Exception(\"Invalid cost_ext_fun_type value, expected one in ['casadi', 'generic'].\")\n\n    # Mayer term\n    @property\n    def cost_type_e(self):\n        \"\"\"\n        Cost type at terminal shooting node (N)\n        -- string in {EXTERNAL, LINEAR_LS, NONLINEAR_LS, CONVEX_OVER_NONLINEAR}.\n        Default: 'LINEAR_LS'.\n        \"\"\"\n        return self.__cost_type_e\n\n    @property\n    def W_e(self):\n        \"\"\":math:`W_e` - weight matrix at terminal shooting node (N).\n        Default: :code:`np.zeros((0,0))`.\n        \"\"\"\n        return self.__W_e\n\n    @property\n    def Vx_e(self):\n        \"\"\":math:`V_x^e` - x matrix coefficient for cost at terminal shooting node (N).\n        Default: :code:`np.zeros((0,0))`.\n        \"\"\"\n        return self.__Vx_e\n\n    @property\n    def yref_e(self):\n        \"\"\":math:`y_\\\\text{ref}^e` - cost reference at terminal shooting node (N).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__yref_e\n\n    @property\n    def Zl_e(self):\n        \"\"\":math:`Z_l^e` - diagonal of Hessian wrt lower slack at terminal shooting node (N).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__Zl_e\n\n    @property\n    def Zu_e(self):\n        \"\"\":math:`Z_u^e` - diagonal of Hessian wrt upper slack at terminal shooting node (N).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__Zu_e\n\n    @property\n    def zl_e(self):\n        \"\"\":math:`z_l^e` - gradient wrt lower slack at terminal shooting node (N).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__zl_e\n\n    @property\n    def zu_e(self):\n        \"\"\":math:`z_u^e` - gradient wrt upper slack at terminal shooting node (N).\n        Default: :code:`np.array([])`.\n        \"\"\"\n        return self.__zu_e\n\n    @property\n    def cost_ext_fun_type_e(self):\n        \"\"\"Type of external function for cost at terminal shooting node (N).\n        -- string in {casadi, generic}\n        Default: :code:'casadi'.\n        \"\"\"\n        return self.__cost_ext_fun_type_e\n\n    @cost_type_e.setter\n    def cost_type_e(self, cost_type_e):\n        cost_types = ('LINEAR_LS', 'NONLINEAR_LS', 'EXTERNAL', 'CONVEX_OVER_NONLINEAR')\n\n        if cost_type_e in cost_types:\n            self.__cost_type_e = cost_type_e\n        else:\n            raise Exception('Invalid cost_type_e value.')\n\n    @W_e.setter\n    def W_e(self, W_e):\n        if isinstance(W_e, np.ndarray) and len(W_e.shape) == 2:\n            self.__W_e = W_e\n        else:\n            raise Exception('Invalid cost W_e value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @Vx_e.setter\n    def Vx_e(self, Vx_e):\n        if isinstance(Vx_e, np.ndarray) and len(Vx_e.shape) == 2:\n            self.__Vx_e = Vx_e\n        else:\n            raise Exception('Invalid cost Vx_e value. ' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @yref_e.setter\n    def yref_e(self, yref_e):\n        if isinstance(yref_e, np.ndarray) and len(yref_e.shape) == 1:\n            self.__yref_e = yref_e\n        else:\n            raise Exception('Invalid yref_e value, expected 1-dimensional numpy array.')\n\n    @Zl_e.setter\n    def Zl_e(self, Zl_e):\n        if isinstance(Zl_e, np.ndarray):\n            self.__Zl_e = Zl_e\n        else:\n            raise Exception('Invalid Zl_e value, expected numpy array.')\n\n    @Zu_e.setter\n    def Zu_e(self, Zu_e):\n        if isinstance(Zu_e, np.ndarray):\n            self.__Zu_e = Zu_e\n        else:\n            raise Exception('Invalid Zu_e value, expected numpy array.')\n\n    @zl_e.setter\n    def zl_e(self, zl_e):\n        if isinstance(zl_e, np.ndarray):\n            self.__zl_e = zl_e\n        else:\n            raise Exception('Invalid zl_e value, expected numpy array.')\n\n    @zu_e.setter\n    def zu_e(self, zu_e):\n        if isinstance(zu_e, np.ndarray):\n            self.__zu_e = zu_e\n        else:\n            raise Exception('Invalid zu_e value, expected numpy array.')\n\n    @cost_ext_fun_type_e.setter\n    def cost_ext_fun_type_e(self, cost_ext_fun_type_e):\n        if cost_ext_fun_type_e in ['casadi', 'generic']:\n            self.__cost_ext_fun_type_e = cost_ext_fun_type_e\n        else:\n            raise Exception(\"Invalid cost_ext_fun_type_e value, expected one in ['casadi', 'generic'].\")\n\n    def set(self, attr, value):\n        setattr(self, attr, value)\n\n\ndef print_J_to_idx_note():\n    print(\"NOTE: J* matrix is converted to zero based vector idx* vector, which is returned here.\")\n\n\nclass AcadosOcpConstraints:\n    \"\"\"\n    class containing the description of the constraints\n    \"\"\"\n    def __init__(self):\n        self.__constr_type   = 'BGH'\n        self.__constr_type_e = 'BGH'\n        # initial x\n        self.__lbx_0   = np.array([])\n        self.__ubx_0   = np.array([])\n        self.__idxbx_0 = np.array([])\n        self.__idxbxe_0 = np.array([])\n        # state bounds\n        self.__lbx     = np.array([])\n        self.__ubx     = np.array([])\n        self.__idxbx   = np.array([])\n        # bounds on x at shooting node N\n        self.__lbx_e   = np.array([])\n        self.__ubx_e   = np.array([])\n        self.__idxbx_e = np.array([])\n        # bounds on u\n        self.__lbu     = np.array([])\n        self.__ubu     = np.array([])\n        self.__idxbu   = np.array([])\n        # polytopic constraints\n        self.__lg      = np.array([])\n        self.__ug      = np.array([])\n        self.__D       = np.zeros((0,0))\n        self.__C       = np.zeros((0,0))\n        # polytopic constraints at shooting node N\n        self.__C_e     = np.zeros((0,0))\n        self.__lg_e    = np.array([])\n        self.__ug_e    = np.array([])\n        # nonlinear constraints\n        self.__lh      = np.array([])\n        self.__uh      = np.array([])\n        # nonlinear constraints at shooting node N\n        self.__uh_e    = np.array([])\n        self.__lh_e    = np.array([])\n        # convex-over-nonlinear constraints\n        self.__lphi    = np.array([])\n        self.__uphi    = np.array([])\n        # nonlinear constraints at shooting node N\n        self.__uphi_e = np.array([])\n        self.__lphi_e = np.array([])\n        # SLACK BOUNDS\n        # soft bounds on x\n        self.__lsbx   = np.array([])\n        self.__usbx   = np.array([])\n        self.__idxsbx = np.array([])\n        # soft bounds on u\n        self.__lsbu   = np.array([])\n        self.__usbu   = np.array([])\n        self.__idxsbu = np.array([])\n        # soft bounds on x at shooting node N\n        self.__lsbx_e  = np.array([])\n        self.__usbx_e  = np.array([])\n        self.__idxsbx_e= np.array([])\n        # soft bounds on general linear constraints\n        self.__lsg    = np.array([])\n        self.__usg    = np.array([])\n        self.__idxsg  = np.array([])\n        # soft bounds on nonlinear constraints\n        self.__lsh    = np.array([])\n        self.__ush    = np.array([])\n        self.__idxsh  = np.array([])\n        # soft bounds on nonlinear constraints\n        self.__lsphi  = np.array([])\n        self.__usphi  = np.array([])\n        self.__idxsphi  = np.array([])\n        # soft bounds on general linear constraints at shooting node N\n        self.__lsg_e    = np.array([])\n        self.__usg_e    = np.array([])\n        self.__idxsg_e  = np.array([])\n        # soft bounds on nonlinear constraints at shooting node N\n        self.__lsh_e    = np.array([])\n        self.__ush_e    = np.array([])\n        self.__idxsh_e  = np.array([])\n        # soft bounds on nonlinear constraints at shooting node N\n        self.__lsphi_e    = np.array([])\n        self.__usphi_e    = np.array([])\n        self.__idxsphi_e  = np.array([])\n\n\n    # types\n    @property\n    def constr_type(self):\n        \"\"\"Constraints type for shooting nodes (0 to N-1). string in {BGH, BGP}.\n        Default: BGH; BGP is for convex over nonlinear.\"\"\"\n        return self.__constr_type\n\n    @property\n    def constr_type_e(self):\n        \"\"\"Constraints type for terminal shooting node N. string in {BGH, BGP}.\n        Default: BGH; BGP is for convex over nonlinear.\"\"\"\n        return self.__constr_type_e\n\n    # initial bounds on x\n    @property\n    def lbx_0(self):\n        \"\"\":math:`\\\\underline{x_0}` - lower bounds on x at initial stage 0.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\"\"\"\n        return self.__lbx_0\n\n    @property\n    def ubx_0(self):\n        \"\"\":math:`\\\\bar{x_0}` - upper bounds on x at initial stage 0.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__ubx_0\n\n    @property\n    def Jbx_0(self):\n        \"\"\":math:`J_{bx,0}` - matrix coefficient for bounds on x at initial stage 0.\n        Translated internally to :py:attr:`idxbx_0`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxbx_0\n\n    @property\n    def idxbx_0(self):\n        \"\"\"Indices of bounds on x at initial stage 0\n        -- can be set automatically via x0.\n        Can be set by using :py:attr:`Jbx_0`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxbx_0\n\n    @property\n    def idxbxe_0(self):\n        \"\"\"Indices of bounds on x0 that are equalities -- can be set automatically via :py:attr:`x0`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxbxe_0\n\n    # bounds on x\n    @property\n    def lbx(self):\n        \"\"\":math:`\\\\underline{x}` - lower bounds on x at intermediate shooting nodes (1 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__lbx\n\n    @property\n    def ubx(self):\n        \"\"\":math:`\\\\bar{x}` - upper bounds on x at intermediate shooting nodes (1 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__ubx\n\n    @property\n    def idxbx(self):\n        \"\"\"indices of bounds on x (defines :math:`J_{bx}`) at intermediate shooting nodes (1 to N-1).\n        Can be set by using :py:attr:`Jbx`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxbx\n\n    @property\n    def Jbx(self):\n        \"\"\":math:`J_{bx}` - matrix coefficient for bounds on x\n        at intermediate shooting nodes (1 to N-1).\n        Translated internally into :py:attr:`idxbx`.\"\"\"\n        print_J_to_idx_note()\n        return self.__idxbx\n\n    # bounds on x at shooting node N\n    @property\n    def lbx_e(self):\n        \"\"\":math:`\\\\underline{x}^e` - lower bounds on x at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__lbx_e\n\n    @property\n    def ubx_e(self):\n        \"\"\":math:`\\\\bar{x}^e` - upper bounds on x at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__ubx_e\n\n    @property\n    def idxbx_e(self):\n        \"\"\"Indices for bounds on x at terminal shooting node N (defines :math:`J_{bx}^e`).\n        Can be set by using :py:attr:`Jbx_e`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxbx_e\n\n    @property\n    def Jbx_e(self):\n        \"\"\":math:`J_{bx}^e` matrix coefficient for bounds on x at terminal shooting node N.\n        Translated internally into :py:attr:`idxbx_e`.\"\"\"\n        print_J_to_idx_note()\n        return self.__idxbx_e\n\n    # bounds on u\n    @property\n    def lbu(self):\n        \"\"\":math:`\\\\underline{u}` - lower bounds on u at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\n        \"\"\"\n        return self.__lbu\n\n    @property\n    def ubu(self):\n        \"\"\":math:`\\\\bar{u}` - upper bounds on u at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\n        \"\"\"\n        return self.__ubu\n\n    @property\n    def idxbu(self):\n        \"\"\"Indices of bounds on u (defines :math:`J_{bu}`) at shooting nodes (0 to N-1).\n        Can be set by using :py:attr:`Jbu`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\n        \"\"\"\n        return self.__idxbu\n\n    @property\n    def Jbu(self):\n        \"\"\":math:`J_{bu}` - matrix coefficient for bounds on u at shooting nodes (0 to N-1).\n        Translated internally to :py:attr:`idxbu`.\n        \"\"\"\n        print_J_to_idx_note()\n        return self.__idxbu\n\n    # polytopic constraints\n    @property\n    def C(self):\n        \"\"\":math:`C` - C matrix in :math:`\\\\underline{g} \\\\leq D \\, u + C \\, x \\\\leq \\\\bar{g}`\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array((0,0))`.\n        \"\"\"\n        return self.__C\n\n    @property\n    def D(self):\n        \"\"\":math:`D` - D matrix in :math:`\\\\underline{g} \\\\leq D \\, u + C \\, x \\\\leq \\\\bar{g}`\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array((0,0))`\n        \"\"\"\n        return self.__D\n\n    @property\n    def lg(self):\n        \"\"\":math:`\\\\underline{g}` - lower bound for general polytopic inequalities\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\n        \"\"\"\n        return self.__lg\n\n    @property\n    def ug(self):\n        \"\"\":math:`\\\\bar{g}` - upper bound for general polytopic inequalities\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__ug\n\n    # polytopic constraints at shooting node N\n    @property\n    def C_e(self):\n        \"\"\":math:`C^e` - C matrix at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array((0,0))`.\n        \"\"\"\n        return self.__C_e\n\n    @property\n    def lg_e(self):\n        \"\"\":math:`\\\\underline{g}^e` - lower bound on general polytopic inequalities\n        at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__lg_e\n\n    @property\n    def ug_e(self):\n        \"\"\":math:`\\\\bar{g}^e` - upper bound on general polytopic inequalities\n        at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__ug_e\n\n\n    # nonlinear constraints\n    @property\n    def lh(self):\n        \"\"\":math:`\\\\underline{h}` - lower bound for nonlinear inequalities\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__lh\n\n    @property\n    def uh(self):\n        \"\"\":math:`\\\\bar{h}` - upper bound for nonlinear inequalities\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__uh\n\n    # nonlinear constraints at shooting node N\n    @property\n    def lh_e(self):\n        \"\"\":math:`\\\\underline{h}^e` - lower bound on nonlinear inequalities\n        at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__lh_e\n\n    @property\n    def uh_e(self):\n        \"\"\":math:`\\\\bar{h}^e` - upper bound on nonlinear inequalities\n        at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__uh_e\n\n    # convex-over-nonlinear constraints\n    @property\n    def lphi(self):\n        \"\"\":math:`\\\\underline{\\phi}` - lower bound for convex-over-nonlinear inequalities\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__lphi\n\n    @property\n    def uphi(self):\n        \"\"\":math:`\\\\bar{\\phi}` - upper bound for convex-over-nonlinear inequalities\n        at shooting nodes (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__uphi\n\n    # convex-over-nonlinear constraints at shooting node N\n    @property\n    def lphi_e(self):\n        \"\"\":math:`\\\\underline{\\phi}^e` - lower bound on convex-over-nonlinear inequalities\n        at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__lphi_e\n\n    @property\n    def uphi_e(self):\n        \"\"\":math:`\\\\bar{\\phi}^e` - upper bound on convex-over-nonlinear inequalities\n        at terminal shooting node N.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`.\n        \"\"\"\n        return self.__uphi_e\n\n\n    # SLACK bounds\n    # soft bounds on x\n    @property\n    def lsbx(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds on x\n        at stages (1 to N-1);\n        not required - zeros by default\"\"\"\n        return self.__lsbx\n\n    @property\n    def usbx(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds on x\n        at stages (1 to N-1);\n        not required - zeros by default\"\"\"\n        return self.__usbx\n\n    @property\n    def idxsbx(self):\n        \"\"\"Indices of soft bounds on x within the indices of bounds on x\n        at stages (1 to N-1).\n        Can be set by using :py:attr:`Jsbx`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsbx\n\n    @property\n    def Jsbx(self):\n        \"\"\":math:`J_{sbx}` - matrix coefficient for soft bounds on x\n        at stages (1 to N-1);\n        Translated internally into :py:attr:`idxsbx`.\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsbx\n\n    # soft bounds on u\n    @property\n    def lsbu(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds on u\n        at stages (0 to N-1).\n        Not required - zeros by default.\"\"\"\n        return self.__lsbu\n\n    @property\n    def usbu(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds on u\n        at stages (0 to N-1);\n        not required - zeros by default\"\"\"\n        return self.__usbu\n\n    @property\n    def idxsbu(self):\n        \"\"\"Indices of soft bounds on u within the indices of bounds on u\n        at stages (0 to N-1).\n        Can be set by using :py:attr:`Jsbu`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsbu\n\n    @property\n    def Jsbu(self):\n        \"\"\":math:`J_{sbu}` - matrix coefficient for soft bounds on u\n        at stages (0 to N-1);\n        internally translated into :py:attr:`idxsbu`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsbu\n\n    # soft bounds on x at shooting node N\n    @property\n    def lsbx_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds on x at shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__lsbx_e\n\n    @property\n    def usbx_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds on x at shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__usbx_e\n\n    @property\n    def idxsbx_e(self):\n        \"\"\"Indices of soft bounds on x at shooting node N, within the indices of bounds on x at terminal shooting node N.\n        Can be set by using :py:attr:`Jsbx_e`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsbx_e\n\n    @property\n    def Jsbx_e(self):\n        \"\"\":math:`J_{sbx}^e` - matrix coefficient for soft bounds on x at terminal shooting node N.\n        Translated internally to :py:attr:`idxsbx_e`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsbx_e\n\n    # soft general linear constraints\n    @property\n    def lsg(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds for general linear constraints\n        at stages (0 to N-1).\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\n        \"\"\"\n        return self.__lsg\n\n    @property\n    def usg(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds for general linear constraints.\n        Not required - zeros by default\"\"\"\n        return self.__usg\n\n    @property\n    def idxsg(self):\n        \"\"\"Indices of soft general linear constraints within the indices of general linear constraints.\n        Can be set by using :py:attr:`Jsg`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsg\n\n    @property\n    def Jsg(self):\n        \"\"\":math:`J_{sg}` - matrix coefficient for soft bounds on general linear constraints.\n        Translated internally to :py:attr:`idxsg`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsg\n\n    # soft nonlinear constraints\n    @property\n    def lsh(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds for nonlinear constraints.\n        Not required - zeros by default\"\"\"\n        return self.__lsh\n\n    @property\n    def ush(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds for nonlinear constraints.\n        Not required - zeros by default\"\"\"\n        return self.__ush\n\n    @property\n    def idxsh(self):\n        \"\"\"Indices of soft nonlinear constraints within the indices of nonlinear constraints.\n        Can be set by using :py:attr:`Jbx`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsh\n\n    @property\n    def Jsh(self):\n        \"\"\":math:`J_{sh}` - matrix coefficient for soft bounds on nonlinear constraints.\n        Translated internally to :py:attr:`idxsh`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsh\n\n    # soft bounds on convex-over-nonlinear constraints\n    @property\n    def lsphi(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds for convex-over-nonlinear constraints.\n        Not required - zeros by default\"\"\"\n        return self.__lsphi\n\n    @property\n    def usphi(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds for convex-over-nonlinear constraints.\n        Not required - zeros by default\"\"\"\n        return self.__usphi\n\n    @property\n    def idxsphi(self):\n        \"\"\"Indices of soft convex-over-nonlinear constraints within the indices of nonlinear constraints.\n        Can be set by using :py:attr:`Jsphi`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsphi\n\n    @property\n    def Jsphi(self):\n        \"\"\":math:`J_{s, \\phi}` - matrix coefficient for soft bounds on convex-over-nonlinear constraints.\n        Translated internally into :py:attr:`idxsphi`.\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsphi\n\n\n    # soft bounds on general linear constraints at shooting node N\n    @property\n    def lsg_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds for general linear constraints at shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__lsg_e\n\n    @property\n    def usg_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds for general linear constraints at shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__usg_e\n\n    @property\n    def idxsg_e(self):\n        \"\"\"Indices of soft general linear constraints at shooting node N within the indices of general linear constraints at shooting node N.\n        Can be set by using :py:attr:`Jsg_e`.\"\"\"\n        return self.__idxsg_e\n\n    @property\n    def Jsg_e(self):\n        \"\"\":math:`J_{s,h}^e` - matrix coefficient for soft bounds on general linear constraints at terminal shooting node N.\n        Translated internally to :py:attr:`idxsg_e`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsg_e\n\n\n    # soft bounds on nonlinear constraints at shooting node N\n    @property\n    def lsh_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds for nonlinear constraints at terminal shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__lsh_e\n\n    @property\n    def ush_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds for nonlinear constraints at terminal shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__ush_e\n\n    @property\n    def idxsh_e(self):\n        \"\"\"Indices of soft nonlinear constraints at shooting node N within the indices of nonlinear constraints at terminal shooting node N.\n        Can be set by using :py:attr:`Jsh_e`.\"\"\"\n        return self.__idxsh_e\n\n    @property\n    def Jsh_e(self):\n        \"\"\":math:`J_{s,h}^e` - matrix coefficient for soft bounds on nonlinear constraints at terminal shooting node N; fills :py:attr:`idxsh_e`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsh_e\n\n    # soft bounds on convex-over-nonlinear constraints at shooting node N\n    @property\n    def lsphi_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft lower bounds for convex-over-nonlinear constraints at terminal shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__lsphi_e\n\n    @property\n    def usphi_e(self):\n        \"\"\"Lower bounds on slacks corresponding to soft upper bounds for convex-over-nonlinear constraints at terminal shooting node N.\n        Not required - zeros by default\"\"\"\n        return self.__usphi_e\n\n    @property\n    def idxsphi_e(self):\n        \"\"\"Indices of soft nonlinear constraints at shooting node N within the indices of nonlinear constraints at terminal shooting node N.\n        Can be set by using :py:attr:`Jsphi_e`.\n        Type: :code:`np.ndarray`; default: :code:`np.array([])`\"\"\"\n        return self.__idxsphi_e\n\n    @property\n    def Jsphi_e(self):\n        \"\"\":math:`J_{sh}^e` - matrix coefficient for soft bounds on convex-over-nonlinear constraints at shooting node N.\n        Translated internally to :py:attr:`idxsphi_e`\"\"\"\n        print_J_to_idx_note()\n        return self.__idxsphi_e\n\n    @property\n    def x0(self):\n        \"\"\":math:`x_0 \\\\in \\mathbb{R}^{n_x}` - initial state --\n        Translated internally to :py:attr:`idxbx_0`, :py:attr:`lbx_0`, :py:attr:`ubx_0`, :py:attr:`idxbxe_0` \"\"\"\n        print(\"x0 is converted to lbx_0, ubx_0, idxbx_0\")\n        print(\"idxbx_0: \", self.__idxbx_0)\n        print(\"lbx_0: \", self.__lbx_0)\n        print(\"ubx_0: \", self.__ubx_0)\n        print(\"idxbxe_0: \", self.__idxbxe_0)\n        return None\n\n    # SETTERS\n    @constr_type.setter\n    def constr_type(self, constr_type):\n        constr_types = ('BGH', 'BGP')\n        if constr_type in constr_types:\n            self.__constr_type = constr_type\n        else:\n            raise Exception('Invalid constr_type value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(constr_types) + '.\\n\\nYou have: ' + constr_type + '.\\n\\n')\n\n    @constr_type_e.setter\n    def constr_type_e(self, constr_type_e):\n        constr_types = ('BGH', 'BGP')\n        if constr_type_e in constr_types:\n            self.__constr_type_e = constr_type_e\n        else:\n            raise Exception('Invalid constr_type_e value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(constr_types) + '.\\n\\nYou have: ' + constr_type_e + '.\\n\\n')\n\n    # initial x\n    @lbx_0.setter\n    def lbx_0(self, lbx_0):\n        if isinstance(lbx_0, np.ndarray):\n            self.__lbx_0 = lbx_0\n        else:\n            raise Exception('Invalid lbx_0 value.')\n\n    @ubx_0.setter\n    def ubx_0(self, ubx_0):\n        if isinstance(ubx_0, np.ndarray):\n            self.__ubx_0 = ubx_0\n        else:\n            raise Exception('Invalid ubx_0 value.')\n\n    @idxbx_0.setter\n    def idxbx_0(self, idxbx_0):\n        if isinstance(idxbx_0, np.ndarray):\n            self.__idxbx_0 = idxbx_0\n        else:\n            raise Exception('Invalid idxbx_0 value.')\n\n    @Jbx_0.setter\n    def Jbx_0(self, Jbx_0):\n        if isinstance(Jbx_0, np.ndarray):\n            self.__idxbx_0 = J_to_idx(Jbx_0)\n        else:\n            raise Exception('Invalid Jbx_0 value.')\n\n    @idxbxe_0.setter\n    def idxbxe_0(self, idxbxe_0):\n        if isinstance(idxbxe_0, np.ndarray):\n            self.__idxbxe_0 = idxbxe_0\n        else:\n            raise Exception('Invalid idxbxe_0 value.')\n\n\n    @x0.setter\n    def x0(self, x0):\n        if isinstance(x0, np.ndarray):\n            self.__lbx_0 = x0\n            self.__ubx_0 = x0\n            self.__idxbx_0 = np.arange(x0.size)\n            self.__idxbxe_0 = np.arange(x0.size)\n        else:\n            raise Exception('Invalid x0 value.')\n\n    # bounds on x\n    @lbx.setter\n    def lbx(self, lbx):\n        if isinstance(lbx, np.ndarray):\n            self.__lbx = lbx\n        else:\n            raise Exception('Invalid lbx value.')\n\n    @ubx.setter\n    def ubx(self, ubx):\n        if isinstance(ubx, np.ndarray):\n            self.__ubx = ubx\n        else:\n            raise Exception('Invalid ubx value.')\n\n    @idxbx.setter\n    def idxbx(self, idxbx):\n        if isinstance(idxbx, np.ndarray):\n            self.__idxbx = idxbx\n        else:\n            raise Exception('Invalid idxbx value.')\n\n    @Jbx.setter\n    def Jbx(self, Jbx):\n        if isinstance(Jbx, np.ndarray):\n            self.__idxbx = J_to_idx(Jbx)\n        else:\n            raise Exception('Invalid Jbx value.')\n\n    # bounds on u\n    @lbu.setter\n    def lbu(self, lbu):\n        if isinstance(lbu, np.ndarray):\n            self.__lbu = lbu\n        else:\n            raise Exception('Invalid lbu value.')\n\n    @ubu.setter\n    def ubu(self, ubu):\n        if isinstance(ubu, np.ndarray):\n            self.__ubu = ubu\n        else:\n            raise Exception('Invalid ubu value.')\n\n    @idxbu.setter\n    def idxbu(self, idxbu):\n        if isinstance(idxbu, np.ndarray):\n            self.__idxbu = idxbu\n        else:\n            raise Exception('Invalid idxbu value.')\n\n    @Jbu.setter\n    def Jbu(self, Jbu):\n        if isinstance(Jbu, np.ndarray):\n            self.__idxbu = J_to_idx(Jbu)\n        else:\n            raise Exception('Invalid Jbu value.')\n\n    # bounds on x at shooting node N\n    @lbx_e.setter\n    def lbx_e(self, lbx_e):\n        if isinstance(lbx_e, np.ndarray):\n            self.__lbx_e = lbx_e\n        else:\n            raise Exception('Invalid lbx_e value.')\n\n    @ubx_e.setter\n    def ubx_e(self, ubx_e):\n        if isinstance(ubx_e, np.ndarray):\n            self.__ubx_e = ubx_e\n        else:\n            raise Exception('Invalid ubx_e value.')\n\n    @idxbx_e.setter\n    def idxbx_e(self, idxbx_e):\n        if isinstance(idxbx_e, np.ndarray):\n            self.__idxbx_e = idxbx_e\n        else:\n            raise Exception('Invalid idxbx_e value.')\n\n    @Jbx_e.setter\n    def Jbx_e(self, Jbx_e):\n        if isinstance(Jbx_e, np.ndarray):\n            self.__idxbx_e = J_to_idx(Jbx_e)\n        else:\n            raise Exception('Invalid Jbx_e value.')\n\n    # polytopic constraints\n    @D.setter\n    def D(self, D):\n        if isinstance(D, np.ndarray) and len(D.shape) == 2:\n            self.__D = D\n        else:\n            raise Exception('Invalid constraint D value.' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @C.setter\n    def C(self, C):\n        if isinstance(C, np.ndarray) and len(C.shape) == 2:\n            self.__C = C\n        else:\n            raise Exception('Invalid constraint C value.' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @lg.setter\n    def lg(self, lg):\n        if isinstance(lg, np.ndarray):\n            self.__lg = lg\n        else:\n            raise Exception('Invalid lg value.')\n\n    @ug.setter\n    def ug(self, ug):\n        if isinstance(ug, np.ndarray):\n            self.__ug = ug\n        else:\n            raise Exception('Invalid ug value.')\n\n    # polytopic constraints at shooting node N\n    @C_e.setter\n    def C_e(self, C_e):\n        if isinstance(C_e, np.ndarray) and len(C_e.shape) == 2:\n            self.__C_e = C_e\n        else:\n            raise Exception('Invalid constraint C_e value.' \\\n                + 'Should be 2 dimensional numpy array.')\n\n    @lg_e.setter\n    def lg_e(self, lg_e):\n        if isinstance(lg_e, np.ndarray):\n            self.__lg_e = lg_e\n        else:\n            raise Exception('Invalid lg_e value.')\n\n    @ug_e.setter\n    def ug_e(self, ug_e):\n        if isinstance(ug_e, np.ndarray):\n            self.__ug_e = ug_e\n        else:\n            raise Exception('Invalid ug_e value.')\n\n    # nonlinear constraints\n    @lh.setter\n    def lh(self, lh):\n        if isinstance(lh, np.ndarray):\n            self.__lh = lh\n        else:\n            raise Exception('Invalid lh value.')\n\n    @uh.setter\n    def uh(self, uh):\n        if isinstance(uh, np.ndarray):\n            self.__uh = uh\n        else:\n            raise Exception('Invalid uh value.')\n\n    # convex-over-nonlinear constraints\n    @lphi.setter\n    def lphi(self, lphi):\n        if isinstance(lphi, np.ndarray):\n            self.__lphi = lphi\n        else:\n            raise Exception('Invalid lphi value.')\n\n    @uphi.setter\n    def uphi(self, uphi):\n        if isinstance(uphi, np.ndarray):\n            self.__uphi = uphi\n        else:\n            raise Exception('Invalid uphi value.')\n\n    # nonlinear constraints at shooting node N\n    @lh_e.setter\n    def lh_e(self, lh_e):\n        if isinstance(lh_e, np.ndarray):\n            self.__lh_e = lh_e\n        else:\n            raise Exception('Invalid lh_e value.')\n\n    @uh_e.setter\n    def uh_e(self, uh_e):\n        if isinstance(uh_e, np.ndarray):\n            self.__uh_e = uh_e\n        else:\n            raise Exception('Invalid uh_e value.')\n\n    # convex-over-nonlinear constraints at shooting node N\n    @lphi_e.setter\n    def lphi_e(self, lphi_e):\n        if isinstance(lphi_e, np.ndarray):\n            self.__lphi_e = lphi_e\n        else:\n            raise Exception('Invalid lphi_e value.')\n\n    @uphi_e.setter\n    def uphi_e(self, uphi_e):\n        if isinstance(uphi_e, np.ndarray):\n            self.__uphi_e = uphi_e\n        else:\n            raise Exception('Invalid uphi_e value.')\n\n    # SLACK bounds\n    # soft bounds on x\n    @lsbx.setter\n    def lsbx(self, lsbx):\n        if isinstance(lsbx, np.ndarray):\n            self.__lsbx = lsbx\n        else:\n            raise Exception('Invalid lsbx value.')\n\n    @usbx.setter\n    def usbx(self, usbx):\n        if isinstance(usbx, np.ndarray):\n            self.__usbx = usbx\n        else:\n            raise Exception('Invalid usbx value.')\n\n    @idxsbx.setter\n    def idxsbx(self, idxsbx):\n        if isinstance(idxsbx, np.ndarray):\n            self.__idxsbx = idxsbx\n        else:\n            raise Exception('Invalid idxsbx value.')\n\n    @Jsbx.setter\n    def Jsbx(self, Jsbx):\n        if isinstance(Jsbx, np.ndarray):\n            self.__idxsbx = J_to_idx_slack(Jsbx)\n        else:\n            raise Exception('Invalid Jsbx value, expected numpy array.')\n\n    # soft bounds on u\n    @lsbu.setter\n    def lsbu(self, lsbu):\n        if isinstance(lsbu, np.ndarray):\n            self.__lsbu = lsbu\n        else:\n            raise Exception('Invalid lsbu value.')\n\n    @usbu.setter\n    def usbu(self, usbu):\n        if isinstance(usbu, np.ndarray):\n            self.__usbu = usbu\n        else:\n            raise Exception('Invalid usbu value.')\n\n    @idxsbu.setter\n    def idxsbu(self, idxsbu):\n        if isinstance(idxsbu, np.ndarray):\n            self.__idxsbu = idxsbu\n        else:\n            raise Exception('Invalid idxsbu value.')\n\n    @Jsbu.setter\n    def Jsbu(self, Jsbu):\n        if isinstance(Jsbu, np.ndarray):\n            self.__idxsbu = J_to_idx_slack(Jsbu)\n        else:\n            raise Exception('Invalid Jsbu value.')\n\n    # soft bounds on x at shooting node N\n    @lsbx_e.setter\n    def lsbx_e(self, lsbx_e):\n        if isinstance(lsbx_e, np.ndarray):\n            self.__lsbx_e = lsbx_e\n        else:\n            raise Exception('Invalid lsbx_e value.')\n\n    @usbx_e.setter\n    def usbx_e(self, usbx_e):\n        if isinstance(usbx_e, np.ndarray):\n            self.__usbx_e = usbx_e\n        else:\n            raise Exception('Invalid usbx_e value.')\n\n    @idxsbx_e.setter\n    def idxsbx_e(self, idxsbx_e):\n        if isinstance(idxsbx_e, np.ndarray):\n            self.__idxsbx_e = idxsbx_e\n        else:\n            raise Exception('Invalid idxsbx_e value.')\n\n    @Jsbx_e.setter\n    def Jsbx_e(self, Jsbx_e):\n        if isinstance(Jsbx_e, np.ndarray):\n            self.__idxsbx_e = J_to_idx_slack(Jsbx_e)\n        else:\n            raise Exception('Invalid Jsbx_e value.')\n\n\n    # soft bounds on general linear constraints\n    @lsg.setter\n    def lsg(self, lsg):\n        if isinstance(lsg, np.ndarray):\n            self.__lsg = lsg\n        else:\n            raise Exception('Invalid lsg value.')\n\n    @usg.setter\n    def usg(self, usg):\n        if isinstance(usg, np.ndarray):\n            self.__usg = usg\n        else:\n            raise Exception('Invalid usg value.')\n\n    @idxsg.setter\n    def idxsg(self, idxsg):\n        if isinstance(idxsg, np.ndarray):\n            self.__idxsg = idxsg\n        else:\n            raise Exception('Invalid idxsg value.')\n\n    @Jsg.setter\n    def Jsg(self, Jsg):\n        if isinstance(Jsg, np.ndarray):\n            self.__idxsg = J_to_idx_slack(Jsg)\n        else:\n            raise Exception('Invalid Jsg value, expected numpy array.')\n\n\n    # soft bounds on nonlinear constraints\n    @lsh.setter\n    def lsh(self, lsh):\n        if isinstance(lsh, np.ndarray):\n            self.__lsh = lsh\n        else:\n            raise Exception('Invalid lsh value.')\n\n    @ush.setter\n    def ush(self, ush):\n        if isinstance(ush, np.ndarray):\n            self.__ush = ush\n        else:\n            raise Exception('Invalid ush value.')\n\n    @idxsh.setter\n    def idxsh(self, idxsh):\n        if isinstance(idxsh, np.ndarray):\n            self.__idxsh = idxsh\n        else:\n            raise Exception('Invalid idxsh value.')\n\n\n    @Jsh.setter\n    def Jsh(self, Jsh):\n        if isinstance(Jsh, np.ndarray):\n            self.__idxsh = J_to_idx_slack(Jsh)\n        else:\n            raise Exception('Invalid Jsh value, expected numpy array.')\n\n    # soft bounds on convex-over-nonlinear constraints\n    @lsphi.setter\n    def lsphi(self, lsphi):\n        if isinstance(lsphi, np.ndarray):\n            self.__lsphi = lsphi\n        else:\n            raise Exception('Invalid lsphi value.')\n\n    @usphi.setter\n    def usphi(self, usphi):\n        if isinstance(usphi, np.ndarray):\n            self.__usphi = usphi\n        else:\n            raise Exception('Invalid usphi value.')\n\n    @idxsphi.setter\n    def idxsphi(self, idxsphi):\n        if isinstance(idxsphi, np.ndarray):\n            self.__idxsphi = idxsphi\n        else:\n            raise Exception('Invalid idxsphi value.')\n\n    @Jsphi.setter\n    def Jsphi(self, Jsphi):\n        if isinstance(Jsphi, np.ndarray):\n            self.__idxsphi = J_to_idx_slack(Jsphi)\n        else:\n            raise Exception('Invalid Jsphi value, expected numpy array.')\n\n    # soft bounds on general linear constraints at shooting node N\n    @lsg_e.setter\n    def lsg_e(self, lsg_e):\n        if isinstance(lsg_e, np.ndarray):\n            self.__lsg_e = lsg_e\n        else:\n            raise Exception('Invalid lsg_e value.')\n\n    @usg_e.setter\n    def usg_e(self, usg_e):\n        if isinstance(usg_e, np.ndarray):\n            self.__usg_e = usg_e\n        else:\n            raise Exception('Invalid usg_e value.')\n\n    @idxsg_e.setter\n    def idxsg_e(self, idxsg_e):\n        if isinstance(idxsg_e, np.ndarray):\n            self.__idxsg_e = idxsg_e\n        else:\n            raise Exception('Invalid idxsg_e value.')\n\n    @Jsg_e.setter\n    def Jsg_e(self, Jsg_e):\n        if isinstance(Jsg_e, np.ndarray):\n            self.__idxsg_e = J_to_idx_slack(Jsg_e)\n        else:\n            raise Exception('Invalid Jsg_e value, expected numpy array.')\n\n    # soft bounds on nonlinear constraints at shooting node N\n    @lsh_e.setter\n    def lsh_e(self, lsh_e):\n        if isinstance(lsh_e, np.ndarray):\n            self.__lsh_e = lsh_e\n        else:\n            raise Exception('Invalid lsh_e value.')\n\n    @ush_e.setter\n    def ush_e(self, ush_e):\n        if isinstance(ush_e, np.ndarray):\n            self.__ush_e = ush_e\n        else:\n            raise Exception('Invalid ush_e value.')\n\n    @idxsh_e.setter\n    def idxsh_e(self, idxsh_e):\n        if isinstance(idxsh_e, np.ndarray):\n            self.__idxsh_e = idxsh_e\n        else:\n            raise Exception('Invalid idxsh_e value.')\n\n    @Jsh_e.setter\n    def Jsh_e(self, Jsh_e):\n        if isinstance(Jsh_e, np.ndarray):\n            self.__idxsh_e = J_to_idx_slack(Jsh_e)\n        else:\n            raise Exception('Invalid Jsh_e value, expected numpy array.')\n\n\n    # soft bounds on convex-over-nonlinear constraints at shooting node N\n    @lsphi_e.setter\n    def lsphi_e(self, lsphi_e):\n        if isinstance(lsphi_e, np.ndarray):\n            self.__lsphi_e = lsphi_e\n        else:\n            raise Exception('Invalid lsphi_e value.')\n\n    @usphi_e.setter\n    def usphi_e(self, usphi_e):\n        if isinstance(usphi_e, np.ndarray):\n            self.__usphi_e = usphi_e\n        else:\n            raise Exception('Invalid usphi_e value.')\n\n    @idxsphi_e.setter\n    def idxsphi_e(self, idxsphi_e):\n        if isinstance(idxsphi_e, np.ndarray):\n            self.__idxsphi_e = idxsphi_e\n        else:\n            raise Exception('Invalid idxsphi_e value.')\n\n    @Jsphi_e.setter\n    def Jsphi_e(self, Jsphi_e):\n        if isinstance(Jsphi_e, np.ndarray):\n            self.__idxsphi_e = J_to_idx_slack(Jsphi_e)\n        else:\n            raise Exception('Invalid Jsphi_e value.')\n\n    def set(self, attr, value):\n        setattr(self, attr, value)\n\n\nclass AcadosOcpOptions:\n    \"\"\"\n    class containing the description of the solver options\n    \"\"\"\n    def __init__(self):\n        self.__qp_solver        = 'PARTIAL_CONDENSING_HPIPM'  # qp solver to be used in the NLP solver\n        self.__hessian_approx   = 'GAUSS_NEWTON'              # hessian approximation\n        self.__integrator_type  = 'ERK'                       # integrator type\n        self.__tf               = None                        # prediction horizon\n        self.__nlp_solver_type  = 'SQP_RTI'                   # NLP solver\n        self.__globalization = 'FIXED_STEP'\n        self.__nlp_solver_step_length = 1.0                   # fixed Newton step length\n        self.__levenberg_marquardt = 0.0\n        self.__collocation_type = 'GAUSS_LEGENDRE'\n        self.__sim_method_num_stages  = 4                     # number of stages in the integrator\n        self.__sim_method_num_steps   = 1                     # number of steps in the integrator\n        self.__sim_method_newton_iter = 3                     # number of Newton iterations in simulation method\n        self.__sim_method_newton_tol = 0.0\n        self.__sim_method_jac_reuse = 0\n        self.__qp_solver_tol_stat = None                      # QP solver stationarity tolerance\n        self.__qp_solver_tol_eq   = None                      # QP solver equality tolerance\n        self.__qp_solver_tol_ineq = None                      # QP solver inequality\n        self.__qp_solver_tol_comp = None                      # QP solver complementarity\n        self.__qp_solver_iter_max = 50                        # QP solver max iter\n        self.__qp_solver_cond_N = None                        # QP solver: new horizon after partial condensing\n        self.__qp_solver_warm_start = 0\n        self.__qp_solver_cond_ric_alg = 1\n        self.__qp_solver_ric_alg = 1\n        self.__nlp_solver_tol_stat = 1e-6                     # NLP solver stationarity tolerance\n        self.__nlp_solver_tol_eq   = 1e-6                     # NLP solver equality tolerance\n        self.__nlp_solver_tol_ineq = 1e-6                     # NLP solver inequality\n        self.__nlp_solver_tol_comp = 1e-6                     # NLP solver complementarity\n        self.__nlp_solver_max_iter = 100                      # NLP solver maximum number of iterations\n        self.__nlp_solver_ext_qp_res = 0\n        self.__Tsim = None                                    # automatically calculated as tf/N\n        self.__print_level = 0                                # print level\n        self.__initialize_t_slacks = 0                        # possible values: 0, 1\n        self.__regularize_method = None\n        self.__time_steps = None\n        self.__shooting_nodes = None\n        self.__exact_hess_cost = 1\n        self.__exact_hess_dyn = 1\n        self.__exact_hess_constr = 1\n        self.__ext_cost_num_hess = 0\n        self.__alpha_min = 0.05\n        self.__alpha_reduction = 0.7\n        self.__line_search_use_sufficient_descent = 0\n        self.__globalization_use_SOC = 0\n        self.__full_step_dual = 0\n        self.__eps_sufficient_descent = 1e-4\n        self.__hpipm_mode = 'BALANCE'\n        # TODO: move those out? they are more about generation than about the acados OCP solver.\n        self.__ext_fun_compile_flags = '-O2'\n        self.__model_external_shared_lib_dir   = None         # path to the the .so lib\n        self.__model_external_shared_lib_name  = None         # name of the the .so lib\n        self.__custom_update_filename = ''\n        self.__custom_update_header_filename = ''\n        self.__custom_templates = []\n        self.__custom_update_copy = True\n\n    @property\n    def qp_solver(self):\n        \"\"\"QP solver to be used in the NLP solver.\n        String in ('PARTIAL_CONDENSING_HPIPM', 'FULL_CONDENSING_QPOASES', 'FULL_CONDENSING_HPIPM', 'PARTIAL_CONDENSING_QPDUNES', 'PARTIAL_CONDENSING_OSQP', 'FULL_CONDENSING_DAQP').\n        Default: 'PARTIAL_CONDENSING_HPIPM'.\n        \"\"\"\n        return self.__qp_solver\n\n    @property\n    def ext_fun_compile_flags(self):\n        \"\"\"\n        String with compiler flags for external function compilation.\n        Default: '-O2'.\n        \"\"\"\n        return self.__ext_fun_compile_flags\n\n\n    @property\n    def custom_update_filename(self):\n        \"\"\"\n        Filename of the custom C function to update solver data and parameters in between solver calls\n\n        This file has to implement the functions\n        int custom_update_init_function([model.name]_solver_capsule* capsule);\n        int custom_update_function([model.name]_solver_capsule* capsule);\n        int custom_update_terminate_function([model.name]_solver_capsule* capsule);\n\n\n        Default: ''.\n        \"\"\"\n        return self.__custom_update_filename\n\n\n    @property\n    def custom_templates(self):\n        \"\"\"\n        List of tuples of the form:\n        (input_filename, output_filename)\n\n        Custom templates are render in OCP solver generation.\n\n        Default: [].\n        \"\"\"\n        return self.__custom_templates\n\n\n    @property\n    def custom_update_header_filename(self):\n        \"\"\"\n        Header filename of the custom C function to update solver data and parameters in between solver calls\n\n        This file has to declare the custom_update functions and look as follows:\n\n        ```\n        // Called at the end of solver creation.\n        // This is allowed to allocate memory and store the pointer to it into capsule->custom_update_memory.\n        int custom_update_init_function([model.name]_solver_capsule* capsule);\n\n        // Custom update function that can be called between solver calls\n        int custom_update_function([model.name]_solver_capsule* capsule, double* data, int data_len);\n\n        // Called just before destroying the solver.\n        // Responsible to free allocated memory, stored at capsule->custom_update_memory.\n        int custom_update_terminate_function([model.name]_solver_capsule* capsule);\n\n        Default: ''.\n        \"\"\"\n        return self.__custom_update_header_filename\n\n    @property\n    def custom_update_copy(self):\n        \"\"\"\n        Boolean;\n        If True, the custom update function files are copied into the `code_export_directory`.\n        \"\"\"\n        return self.__custom_update_copy\n\n\n    @property\n    def hpipm_mode(self):\n        \"\"\"\n        Mode of HPIPM to be used,\n\n        String in ('BALANCE', 'SPEED_ABS', 'SPEED', 'ROBUST').\n\n        Default: 'BALANCE'.\n\n        see https://cdn.syscop.de/publications/Frison2020a.pdf\n        and the HPIPM code:\n        https://github.com/giaf/hpipm/blob/master/ocp_qp/x_ocp_qp_ipm.c#L69\n        \"\"\"\n        return self.__hpipm_mode\n\n    @property\n    def hessian_approx(self):\n        \"\"\"Hessian approximation.\n        String in ('GAUSS_NEWTON', 'EXACT').\n        Default: 'GAUSS_NEWTON'.\n        \"\"\"\n        return self.__hessian_approx\n\n    @property\n    def integrator_type(self):\n        \"\"\"\n        Integrator type.\n        String in ('ERK', 'IRK', 'GNSF', 'DISCRETE', 'LIFTED_IRK').\n        Default: 'ERK'.\n        \"\"\"\n        return self.__integrator_type\n\n    @property\n    def nlp_solver_type(self):\n        \"\"\"NLP solver.\n        String in ('SQP', 'SQP_RTI').\n        Default: 'SQP_RTI'.\n        \"\"\"\n        return self.__nlp_solver_type\n\n    @property\n    def globalization(self):\n        \"\"\"Globalization type.\n        String in ('FIXED_STEP', 'MERIT_BACKTRACKING').\n        Default: 'FIXED_STEP'.\n\n        .. note:: preliminary implementation.\n        \"\"\"\n        return self.__globalization\n\n    @property\n    def collocation_type(self):\n        \"\"\"Collocation type: relevant for implicit integrators\n        -- string in {GAUSS_RADAU_IIA, GAUSS_LEGENDRE}.\n\n        Default: GAUSS_LEGENDRE\n        \"\"\"\n        return self.__collocation_type\n\n    @property\n    def regularize_method(self):\n        \"\"\"Regularization method for the Hessian.\n        String in ('NO_REGULARIZE', 'MIRROR', 'PROJECT', 'PROJECT_REDUC_HESS', 'CONVEXIFY') or :code:`None`.\n\n        - MIRROR: performs eigenvalue decomposition H = V^T D V and sets D_ii = max(eps, abs(D_ii))\n        - PROJECT: performs eigenvalue decomposition H = V^T D V and sets D_ii = max(eps, D_ii)\n        - CONVEXIFY: Algorithm 6 from Verschueren2017, https://cdn.syscop.de/publications/Verschueren2017.pdf\n        - PROJECT_REDUC_HESS: experimental\n\n        Note: default eps = 1e-4\n\n        Default: :code:`None`.\n        \"\"\"\n        return self.__regularize_method\n\n    @property\n    def nlp_solver_step_length(self):\n        \"\"\"\n        Fixed Newton step length.\n        Type: float > 0.\n        Default: 1.0.\n        \"\"\"\n        return self.__nlp_solver_step_length\n\n    @property\n    def levenberg_marquardt(self):\n        \"\"\"\n        Factor for LM regularization.\n        Type: float >= 0\n        Default: 0.0.\n        \"\"\"\n        return self.__levenberg_marquardt\n\n    @property\n    def sim_method_num_stages(self):\n        \"\"\"\n        Number of stages in the integrator.\n        Type: int > 0 or ndarray of ints > 0 of shape (N,).\n        Default: 4\n        \"\"\"\n        return self.__sim_method_num_stages\n\n    @property\n    def sim_method_num_steps(self):\n        \"\"\"\n        Number of steps in the integrator.\n        Type: int > 0 or ndarray of ints > 0 of shape (N,).\n        Default: 1\n        \"\"\"\n        return self.__sim_method_num_steps\n\n    @property\n    def sim_method_newton_iter(self):\n        \"\"\"\n        Number of Newton iterations in simulation method.\n        Type: int > 0\n        Default: 3\n        \"\"\"\n        return self.__sim_method_newton_iter\n\n    @property\n    def sim_method_newton_tol(self):\n        \"\"\"\n        Tolerance of Newton system in simulation method.\n        Type: float: 0.0 means not used\n        Default: 0.0\n        \"\"\"\n        return self.__sim_method_newton_tol\n\n    @property\n    def sim_method_jac_reuse(self):\n        \"\"\"\n        Integer determining if jacobians are reused within integrator or ndarray of ints > 0 of shape (N,).\n        0: False (no reuse); 1: True (reuse)\n        Default: 0\n        \"\"\"\n        return self.__sim_method_jac_reuse\n\n    @property\n    def qp_solver_tol_stat(self):\n        \"\"\"\n        QP solver stationarity tolerance.\n        Default: :code:`None`\n        \"\"\"\n        return self.__qp_solver_tol_stat\n\n    @property\n    def qp_solver_tol_eq(self):\n        \"\"\"\n        QP solver equality tolerance.\n        Default: :code:`None`\n        \"\"\"\n        return self.__qp_solver_tol_eq\n\n    @property\n    def qp_solver_tol_ineq(self):\n        \"\"\"\n        QP solver inequality.\n        Default: :code:`None`\n        \"\"\"\n        return self.__qp_solver_tol_ineq\n\n    @property\n    def qp_solver_tol_comp(self):\n        \"\"\"\n        QP solver complementarity.\n        Default: :code:`None`\n        \"\"\"\n        return self.__qp_solver_tol_comp\n\n    @property\n    def qp_solver_cond_N(self):\n        \"\"\"QP solver: New horizon after partial condensing.\n        Set to N by default -> no condensing.\"\"\"\n        return self.__qp_solver_cond_N\n\n    @property\n    def qp_solver_warm_start(self):\n        \"\"\"\n        QP solver: Warm starting.\n        0: no warm start; 1: warm start; 2: hot start.\n        Default: 0\n        \"\"\"\n        return self.__qp_solver_warm_start\n\n    @property\n    def qp_solver_cond_ric_alg(self):\n        \"\"\"\n        QP solver: Determines which algorithm is used in HPIPM condensing.\n        0: dont factorize hessian in the condensing; 1: factorize.\n        Default: 1\n        \"\"\"\n        return self.__qp_solver_cond_ric_alg\n\n    @property\n    def qp_solver_ric_alg(self):\n        \"\"\"\n        QP solver: Determines which algorithm is used in HPIPM OCP QP solver.\n        0 classical Riccati, 1 square-root Riccati.\n\n        Note: taken from [HPIPM paper]:\n\n        (a) the classical implementation requires the reduced Hessian with respect to the dynamics\n            equality constraints to be positive definite, but allows the full-space Hessian to be indefinite)\n        (b) the square-root implementation, which in order to reduce the flop count employs the Cholesky\n            factorization of the Riccati recursion matrix, and therefore requires the full-space Hessian to be positive definite\n\n        [HPIPM paper]: HPIPM: a high-performance quadratic programming framework for model predictive control, Frison and Diehl, 2020\n        https://cdn.syscop.de/publications/Frison2020a.pdf\n\n        Default: 1\n        \"\"\"\n        return self.__qp_solver_ric_alg\n\n    @property\n    def qp_solver_iter_max(self):\n        \"\"\"\n        QP solver: maximum number of iterations.\n        Type: int > 0\n        Default: 50\n        \"\"\"\n        return self.__qp_solver_iter_max\n\n    @property\n    def tol(self):\n        \"\"\"\n        NLP solver tolerance. Sets or gets the max of :py:attr:`nlp_solver_tol_eq`,\n        :py:attr:`nlp_solver_tol_ineq`, :py:attr:`nlp_solver_tol_comp`\n        and :py:attr:`nlp_solver_tol_stat`.\n        \"\"\"\n        return max([self.__nlp_solver_tol_eq, self.__nlp_solver_tol_ineq,\\\n                    self.__nlp_solver_tol_comp, self.__nlp_solver_tol_stat])\n\n    @property\n    def qp_tol(self):\n        \"\"\"\n        QP solver tolerance.\n        Sets all of the following at once or gets the max of\n        :py:attr:`qp_solver_tol_eq`, :py:attr:`qp_solver_tol_ineq`,\n        :py:attr:`qp_solver_tol_comp` and\n        :py:attr:`qp_solver_tol_stat`.\n        \"\"\"\n        return max([self.__qp_solver_tol_eq, self.__qp_solver_tol_ineq,\\\n                    self.__qp_solver_tol_comp, self.__qp_solver_tol_stat])\n\n    @property\n    def nlp_solver_tol_stat(self):\n        \"\"\"\n        NLP solver stationarity tolerance.\n        Type: float > 0\n        Default: 1e-6\n        \"\"\"\n        return self.__nlp_solver_tol_stat\n\n    @property\n    def nlp_solver_tol_eq(self):\n        \"\"\"NLP solver equality tolerance\"\"\"\n        return self.__nlp_solver_tol_eq\n\n    @property\n    def alpha_min(self):\n        \"\"\"Minimal step size for globalization MERIT_BACKTRACKING, default: 0.05.\"\"\"\n        return self.__alpha_min\n\n    @property\n    def alpha_reduction(self):\n        \"\"\"Step size reduction factor for globalization MERIT_BACKTRACKING, default: 0.7.\"\"\"\n        return self.__alpha_reduction\n\n    @property\n    def line_search_use_sufficient_descent(self):\n        \"\"\"\n        Determines if sufficient descent (Armijo) condition is used in line search.\n        Type: int; 0 or 1;\n        default: 0.\n        \"\"\"\n        return self.__line_search_use_sufficient_descent\n\n    @property\n    def eps_sufficient_descent(self):\n        \"\"\"\n        Factor for sufficient descent (Armijo) conditon, see line_search_use_sufficient_descent.\n        Type: float,\n        default: 1e-4.\n        \"\"\"\n        return self.__eps_sufficient_descent\n\n    @property\n    def globalization_use_SOC(self):\n        \"\"\"\n        Determines if second order correction (SOC) is done when using MERIT_BACKTRACKING.\n        SOC is done if preliminary line search does not return full step.\n        Type: int; 0 or 1;\n        default: 0.\n        \"\"\"\n        return self.__globalization_use_SOC\n\n    @property\n    def full_step_dual(self):\n        \"\"\"\n        Determines if dual variables are updated with full steps (alpha=1.0) when primal variables are updated with smaller step.\n        Type: int; 0 or 1;\n        default: 0.\n        \"\"\"\n        return self.__full_step_dual\n\n    @property\n    def nlp_solver_tol_ineq(self):\n        \"\"\"NLP solver inequality tolerance\"\"\"\n        return self.__nlp_solver_tol_ineq\n\n    @property\n    def nlp_solver_ext_qp_res(self):\n        \"\"\"Determines if residuals of QP are computed externally within NLP solver (for debugging)\n\n        Type: int; 0 or 1;\n        Default: 0.\n        \"\"\"\n        return self.__nlp_solver_ext_qp_res\n\n    @property\n    def nlp_solver_tol_comp(self):\n        \"\"\"NLP solver complementarity tolerance\"\"\"\n        return self.__nlp_solver_tol_comp\n\n    @property\n    def nlp_solver_max_iter(self):\n        \"\"\"\n        NLP solver maximum number of iterations.\n        Type: int > 0\n        Default: 100\n        \"\"\"\n        return self.__nlp_solver_max_iter\n\n    @property\n    def time_steps(self):\n        \"\"\"\n        Vector with time steps between the shooting nodes. Set automatically to uniform discretization if :py:attr:`N` and :py:attr:`tf` are provided.\n        Default: :code:`None`\n        \"\"\"\n        return self.__time_steps\n\n    @property\n    def shooting_nodes(self):\n        \"\"\"\n        Vector with the shooting nodes, time_steps will be computed from it automatically.\n        Default: :code:`None`\n        \"\"\"\n        return self.__shooting_nodes\n\n    @property\n    def tf(self):\n        \"\"\"\n        Prediction horizon\n        Type: float > 0\n        Default: :code:`None`\n        \"\"\"\n        return self.__tf\n\n    @property\n    def Tsim(self):\n        \"\"\"\n        Time horizon for one integrator step. Automatically calculated as :py:attr:`tf`/:py:attr:`N`.\n        Default: :code:`None`\n        \"\"\"\n        return self.__Tsim\n\n    @property\n    def print_level(self):\n        \"\"\"\n        Verbosity of printing.\n        Type: int >= 0\n        Default: 0\n        \"\"\"\n        return self.__print_level\n\n    @property\n    def model_external_shared_lib_dir(self):\n        \"\"\"Path to the .so lib\"\"\"\n        return self.__model_external_shared_lib_dir\n\n    @property\n    def model_external_shared_lib_name(self):\n        \"\"\"Name of the .so lib\"\"\"\n        return self.__model_external_shared_lib_name\n\n    @property\n    def exact_hess_constr(self):\n        \"\"\"\n        Used in case of hessian_approx == 'EXACT'.\\n\n        Can be used to turn off exact hessian contributions from the constraints module.\n        \"\"\"\n        return self.__exact_hess_constr\n\n    @property\n    def exact_hess_cost(self):\n        \"\"\"\n        Used in case of hessian_approx == 'EXACT'.\\n\n        Can be used to turn off exact hessian contributions from the cost module.\n        \"\"\"\n        return self.__exact_hess_cost\n\n    @property\n    def exact_hess_dyn(self):\n        \"\"\"\n        Used in case of hessian_approx == 'EXACT'.\\n\n        Can be used to turn off exact hessian contributions from the dynamics module.\n        \"\"\"\n        return self.__exact_hess_dyn\n\n    @property\n    def ext_cost_num_hess(self):\n        \"\"\"\n        Determines if custom hessian approximation for cost contribution is used (> 0).\\n\n        Or if hessian contribution is evaluated exactly using CasADi external function (=0 - default).\n        \"\"\"\n        return self.__ext_cost_num_hess\n\n    @qp_solver.setter\n    def qp_solver(self, qp_solver):\n        qp_solvers = ('PARTIAL_CONDENSING_HPIPM', \\\n                'FULL_CONDENSING_QPOASES', 'FULL_CONDENSING_HPIPM', \\\n                'PARTIAL_CONDENSING_QPDUNES', 'PARTIAL_CONDENSING_OSQP', \\\n                'FULL_CONDENSING_DAQP')\n        if qp_solver in qp_solvers:\n            self.__qp_solver = qp_solver\n        else:\n            raise Exception('Invalid qp_solver value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(qp_solvers) + '.\\n\\nYou have: ' + qp_solver + '.\\n\\n')\n\n    @regularize_method.setter\n    def regularize_method(self, regularize_method):\n        regularize_methods = ('NO_REGULARIZE', 'MIRROR', 'PROJECT', \\\n                                'PROJECT_REDUC_HESS', 'CONVEXIFY')\n        if regularize_method in regularize_methods:\n            self.__regularize_method = regularize_method\n        else:\n            raise Exception('Invalid regularize_method value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(regularize_methods) + '.\\n\\nYou have: ' + regularize_method + '.\\n\\n')\n\n    @collocation_type.setter\n    def collocation_type(self, collocation_type):\n        collocation_types = ('GAUSS_RADAU_IIA', 'GAUSS_LEGENDRE')\n        if collocation_type in collocation_types:\n            self.__collocation_type = collocation_type\n        else:\n            raise Exception('Invalid collocation_type value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(collocation_types) + '.\\n\\nYou have: ' + collocation_type + '.\\n\\n')\n\n    @hpipm_mode.setter\n    def hpipm_mode(self, hpipm_mode):\n        hpipm_modes = ('BALANCE', 'SPEED_ABS', 'SPEED', 'ROBUST')\n        if hpipm_mode in hpipm_modes:\n            self.__hpipm_mode = hpipm_mode\n        else:\n            raise Exception('Invalid hpipm_mode value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(hpipm_modes) + '.\\n\\nYou have: ' + hpipm_mode + '.\\n\\n')\n\n    @ext_fun_compile_flags.setter\n    def ext_fun_compile_flags(self, ext_fun_compile_flags):\n        if isinstance(ext_fun_compile_flags, str):\n            self.__ext_fun_compile_flags = ext_fun_compile_flags\n        else:\n            raise Exception('Invalid ext_fun_compile_flags, expected a string.\\n')\n\n\n    @custom_update_filename.setter\n    def custom_update_filename(self, custom_update_filename):\n        if isinstance(custom_update_filename, str):\n            self.__custom_update_filename = custom_update_filename\n        else:\n            raise Exception('Invalid custom_update_filename, expected a string.\\n')\n\n    @custom_templates.setter\n    def custom_templates(self, custom_templates):\n        if not isinstance(custom_templates, list):\n            raise Exception('Invalid custom_templates, expected a list.\\n')\n        for tup in custom_templates:\n            if not isinstance(tup, tuple):\n                raise Exception('Invalid custom_templates, shoubld be list of tuples.\\n')\n            for s in tup:\n                if not isinstance(s, str):\n                    raise Exception('Invalid custom_templates, shoubld be list of tuples of strings.\\n')\n        self.__custom_templates = custom_templates\n\n    @custom_update_header_filename.setter\n    def custom_update_header_filename(self, custom_update_header_filename):\n        if isinstance(custom_update_header_filename, str):\n            self.__custom_update_header_filename = custom_update_header_filename\n        else:\n            raise Exception('Invalid custom_update_header_filename, expected a string.\\n')\n\n    @custom_update_copy.setter\n    def custom_update_copy(self, custom_update_copy):\n        if isinstance(custom_update_copy, bool):\n            self.__custom_update_copy = custom_update_copy\n        else:\n            raise Exception('Invalid custom_update_copy, expected a bool.\\n')\n\n    @hessian_approx.setter\n    def hessian_approx(self, hessian_approx):\n        hessian_approxs = ('GAUSS_NEWTON', 'EXACT')\n        if hessian_approx in hessian_approxs:\n            self.__hessian_approx = hessian_approx\n        else:\n            raise Exception('Invalid hessian_approx value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(hessian_approxs) + '.\\n\\nYou have: ' + hessian_approx + '.\\n\\n')\n\n    @integrator_type.setter\n    def integrator_type(self, integrator_type):\n        integrator_types = ('ERK', 'IRK', 'GNSF', 'DISCRETE', 'LIFTED_IRK')\n        if integrator_type in integrator_types:\n            self.__integrator_type = integrator_type\n        else:\n            raise Exception('Invalid integrator_type value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(integrator_types) + '.\\n\\nYou have: ' + integrator_type + '.\\n\\n')\n\n    @tf.setter\n    def tf(self, tf):\n        self.__tf = tf\n\n    @time_steps.setter\n    def time_steps(self, time_steps):\n        if isinstance(time_steps, np.ndarray):\n            if len(time_steps.shape) == 1:\n                    self.__time_steps = time_steps\n            else:\n                raise Exception('Invalid time_steps, expected np.ndarray of shape (N,).')\n        else:\n            raise Exception('Invalid time_steps, expected np.ndarray.')\n\n    @shooting_nodes.setter\n    def shooting_nodes(self, shooting_nodes):\n        if isinstance(shooting_nodes, np.ndarray):\n            if len(shooting_nodes.shape) == 1:\n                self.__shooting_nodes = shooting_nodes\n            else:\n                raise Exception('Invalid shooting_nodes, expected np.ndarray of shape (N+1,).')\n        else:\n            raise Exception('Invalid shooting_nodes, expected np.ndarray.')\n\n    @Tsim.setter\n    def Tsim(self, Tsim):\n        self.__Tsim = Tsim\n\n    @globalization.setter\n    def globalization(self, globalization):\n        globalization_types = ('MERIT_BACKTRACKING', 'FIXED_STEP')\n        if globalization in globalization_types:\n            self.__globalization = globalization\n        else:\n            raise Exception('Invalid globalization value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(globalization_types) + '.\\n\\nYou have: ' + globalization + '.\\n\\n')\n\n    @alpha_min.setter\n    def alpha_min(self, alpha_min):\n        self.__alpha_min = alpha_min\n\n    @alpha_reduction.setter\n    def alpha_reduction(self, alpha_reduction):\n        self.__alpha_reduction = alpha_reduction\n\n    @line_search_use_sufficient_descent.setter\n    def line_search_use_sufficient_descent(self, line_search_use_sufficient_descent):\n        if line_search_use_sufficient_descent in [0, 1]:\n            self.__line_search_use_sufficient_descent = line_search_use_sufficient_descent\n        else:\n            raise Exception(f'Invalid value for line_search_use_sufficient_descent. Possible values are 0, 1, got {line_search_use_sufficient_descent}')\n\n    @globalization_use_SOC.setter\n    def globalization_use_SOC(self, globalization_use_SOC):\n        if globalization_use_SOC in [0, 1]:\n            self.__globalization_use_SOC = globalization_use_SOC\n        else:\n            raise Exception(f'Invalid value for globalization_use_SOC. Possible values are 0, 1, got {globalization_use_SOC}')\n\n    @full_step_dual.setter\n    def full_step_dual(self, full_step_dual):\n        if full_step_dual in [0, 1]:\n            self.__full_step_dual = full_step_dual\n        else:\n            raise Exception(f'Invalid value for full_step_dual. Possible values are 0, 1, got {full_step_dual}')\n\n    @eps_sufficient_descent.setter\n    def eps_sufficient_descent(self, eps_sufficient_descent):\n        if isinstance(eps_sufficient_descent, float) and eps_sufficient_descent > 0:\n            self.__eps_sufficient_descent = eps_sufficient_descent\n        else:\n            raise Exception('Invalid eps_sufficient_descent value. eps_sufficient_descent must be a positive float.')\n\n    @sim_method_num_stages.setter\n    def sim_method_num_stages(self, sim_method_num_stages):\n\n        # if isinstance(sim_method_num_stages, int):\n        #     self.__sim_method_num_stages = sim_method_num_stages\n        # else:\n        #     raise Exception('Invalid sim_method_num_stages value. sim_method_num_stages must be an integer.')\n\n        self.__sim_method_num_stages = sim_method_num_stages\n\n    @sim_method_num_steps.setter\n    def sim_method_num_steps(self, sim_method_num_steps):\n\n        # if isinstance(sim_method_num_steps, int):\n        #     self.__sim_method_num_steps = sim_method_num_steps\n        # else:\n        #     raise Exception('Invalid sim_method_num_steps value. sim_method_num_steps must be an integer.')\n        self.__sim_method_num_steps = sim_method_num_steps\n\n\n    @sim_method_newton_iter.setter\n    def sim_method_newton_iter(self, sim_method_newton_iter):\n\n        if isinstance(sim_method_newton_iter, int):\n            self.__sim_method_newton_iter = sim_method_newton_iter\n        else:\n            raise Exception('Invalid sim_method_newton_iter value. sim_method_newton_iter must be an integer.')\n\n    @sim_method_jac_reuse.setter\n    def sim_method_jac_reuse(self, sim_method_jac_reuse):\n        # if sim_method_jac_reuse in (True, False):\n        self.__sim_method_jac_reuse = sim_method_jac_reuse\n        # else:\n            # raise Exception('Invalid sim_method_jac_reuse value. sim_method_jac_reuse must be a Boolean.')\n\n    @nlp_solver_type.setter\n    def nlp_solver_type(self, nlp_solver_type):\n        nlp_solver_types = ('SQP', 'SQP_RTI')\n        if nlp_solver_type in nlp_solver_types:\n            self.__nlp_solver_type = nlp_solver_type\n        else:\n            raise Exception('Invalid nlp_solver_type value. Possible values are:\\n\\n' \\\n                    + ',\\n'.join(nlp_solver_types) + '.\\n\\nYou have: ' + nlp_solver_type + '.\\n\\n')\n\n    @nlp_solver_step_length.setter\n    def nlp_solver_step_length(self, nlp_solver_step_length):\n        if isinstance(nlp_solver_step_length, float) and nlp_solver_step_length > 0:\n            self.__nlp_solver_step_length = nlp_solver_step_length\n        else:\n            raise Exception('Invalid nlp_solver_step_length value. nlp_solver_step_length must be a positive float.')\n\n    @levenberg_marquardt.setter\n    def levenberg_marquardt(self, levenberg_marquardt):\n        if isinstance(levenberg_marquardt, float) and levenberg_marquardt >= 0:\n            self.__levenberg_marquardt = levenberg_marquardt\n        else:\n            raise Exception('Invalid levenberg_marquardt value. levenberg_marquardt must be a positive float.')\n\n    @qp_solver_iter_max.setter\n    def qp_solver_iter_max(self, qp_solver_iter_max):\n        if isinstance(qp_solver_iter_max, int) and qp_solver_iter_max > 0:\n            self.__qp_solver_iter_max = qp_solver_iter_max\n        else:\n            raise Exception('Invalid qp_solver_iter_max value. qp_solver_iter_max must be a positive int.')\n\n    @qp_solver_ric_alg.setter\n    def qp_solver_ric_alg(self, qp_solver_ric_alg):\n        if qp_solver_ric_alg in [0, 1]:\n            self.__qp_solver_ric_alg = qp_solver_ric_alg\n        else:\n            raise Exception(f'Invalid qp_solver_ric_alg value. qp_solver_ric_alg must be in [0, 1], got {qp_solver_ric_alg}.')\n\n    @qp_solver_cond_ric_alg.setter\n    def qp_solver_cond_ric_alg(self, qp_solver_cond_ric_alg):\n        if qp_solver_cond_ric_alg in [0, 1]:\n            self.__qp_solver_cond_ric_alg = qp_solver_cond_ric_alg\n        else:\n            raise Exception(f'Invalid qp_solver_cond_ric_alg value. qp_solver_cond_ric_alg must be in [0, 1], got {qp_solver_cond_ric_alg}.')\n\n\n    @qp_solver_cond_N.setter\n    def qp_solver_cond_N(self, qp_solver_cond_N):\n        if isinstance(qp_solver_cond_N, int) and qp_solver_cond_N >= 0:\n            self.__qp_solver_cond_N = qp_solver_cond_N\n        else:\n            raise Exception('Invalid qp_solver_cond_N value. qp_solver_cond_N must be a positive int.')\n\n    @qp_solver_warm_start.setter\n    def qp_solver_warm_start(self, qp_solver_warm_start):\n        if qp_solver_warm_start in [0, 1, 2]:\n            self.__qp_solver_warm_start = qp_solver_warm_start\n        else:\n            raise Exception('Invalid qp_solver_warm_start value. qp_solver_warm_start must be 0 or 1 or 2.')\n\n    @qp_tol.setter\n    def qp_tol(self, qp_tol):\n        if isinstance(qp_tol, float) and qp_tol > 0:\n            self.__qp_solver_tol_eq = qp_tol\n            self.__qp_solver_tol_ineq = qp_tol\n            self.__qp_solver_tol_stat = qp_tol\n            self.__qp_solver_tol_comp = qp_tol\n        else:\n            raise Exception('Invalid qp_tol value. qp_tol must be a positive float.')\n\n    @qp_solver_tol_stat.setter\n    def qp_solver_tol_stat(self, qp_solver_tol_stat):\n        if isinstance(qp_solver_tol_stat, float) and qp_solver_tol_stat > 0:\n            self.__qp_solver_tol_stat = qp_solver_tol_stat\n        else:\n            raise Exception('Invalid qp_solver_tol_stat value. qp_solver_tol_stat must be a positive float.')\n\n    @qp_solver_tol_eq.setter\n    def qp_solver_tol_eq(self, qp_solver_tol_eq):\n        if isinstance(qp_solver_tol_eq, float) and qp_solver_tol_eq > 0:\n            self.__qp_solver_tol_eq = qp_solver_tol_eq\n        else:\n            raise Exception('Invalid qp_solver_tol_eq value. qp_solver_tol_eq must be a positive float.')\n\n    @qp_solver_tol_ineq.setter\n    def qp_solver_tol_ineq(self, qp_solver_tol_ineq):\n        if isinstance(qp_solver_tol_ineq, float) and qp_solver_tol_ineq > 0:\n            self.__qp_solver_tol_ineq = qp_solver_tol_ineq\n        else:\n            raise Exception('Invalid qp_solver_tol_ineq value. qp_solver_tol_ineq must be a positive float.')\n\n    @qp_solver_tol_comp.setter\n    def qp_solver_tol_comp(self, qp_solver_tol_comp):\n        if isinstance(qp_solver_tol_comp, float) and qp_solver_tol_comp > 0:\n            self.__qp_solver_tol_comp = qp_solver_tol_comp\n        else:\n            raise Exception('Invalid qp_solver_tol_comp value. qp_solver_tol_comp must be a positive float.')\n\n    @tol.setter\n    def tol(self, tol):\n        if isinstance(tol, float) and tol > 0:\n            self.__nlp_solver_tol_eq = tol\n            self.__nlp_solver_tol_ineq = tol\n            self.__nlp_solver_tol_stat = tol\n            self.__nlp_solver_tol_comp = tol\n        else:\n            raise Exception('Invalid tol value. tol must be a positive float.')\n\n    @nlp_solver_tol_stat.setter\n    def nlp_solver_tol_stat(self, nlp_solver_tol_stat):\n        if isinstance(nlp_solver_tol_stat, float) and nlp_solver_tol_stat > 0:\n            self.__nlp_solver_tol_stat = nlp_solver_tol_stat\n        else:\n            raise Exception('Invalid nlp_solver_tol_stat value. nlp_solver_tol_stat must be a positive float.')\n\n    @nlp_solver_tol_eq.setter\n    def nlp_solver_tol_eq(self, nlp_solver_tol_eq):\n        if isinstance(nlp_solver_tol_eq, float) and nlp_solver_tol_eq > 0:\n            self.__nlp_solver_tol_eq = nlp_solver_tol_eq\n        else:\n            raise Exception('Invalid nlp_solver_tol_eq value. nlp_solver_tol_eq must be a positive float.')\n\n    @nlp_solver_tol_ineq.setter\n    def nlp_solver_tol_ineq(self, nlp_solver_tol_ineq):\n        if isinstance(nlp_solver_tol_ineq, float) and nlp_solver_tol_ineq > 0:\n            self.__nlp_solver_tol_ineq = nlp_solver_tol_ineq\n        else:\n            raise Exception('Invalid nlp_solver_tol_ineq value. nlp_solver_tol_ineq must be a positive float.')\n\n    @nlp_solver_ext_qp_res.setter\n    def nlp_solver_ext_qp_res(self, nlp_solver_ext_qp_res):\n        if nlp_solver_ext_qp_res in [0, 1]:\n            self.__nlp_solver_ext_qp_res = nlp_solver_ext_qp_res\n        else:\n            raise Exception('Invalid nlp_solver_ext_qp_res value. nlp_solver_ext_qp_res must be in [0, 1].')\n\n    @nlp_solver_tol_comp.setter\n    def nlp_solver_tol_comp(self, nlp_solver_tol_comp):\n        if isinstance(nlp_solver_tol_comp, float) and nlp_solver_tol_comp > 0:\n            self.__nlp_solver_tol_comp = nlp_solver_tol_comp\n        else:\n            raise Exception('Invalid nlp_solver_tol_comp value. nlp_solver_tol_comp must be a positive float.')\n\n    @nlp_solver_max_iter.setter\n    def nlp_solver_max_iter(self, nlp_solver_max_iter):\n\n        if isinstance(nlp_solver_max_iter, int) and nlp_solver_max_iter > 0:\n            self.__nlp_solver_max_iter = nlp_solver_max_iter\n        else:\n            raise Exception('Invalid nlp_solver_max_iter value. nlp_solver_max_iter must be a positive int.')\n\n    @print_level.setter\n    def print_level(self, print_level):\n        if isinstance(print_level, int) and print_level >= 0:\n            self.__print_level = print_level\n        else:\n            raise Exception('Invalid print_level value. print_level takes one of the values >=0.')\n\n    @model_external_shared_lib_dir.setter\n    def model_external_shared_lib_dir(self, model_external_shared_lib_dir):\n        if isinstance(model_external_shared_lib_dir, str) :\n            self.__model_external_shared_lib_dir = model_external_shared_lib_dir\n        else:\n            raise Exception('Invalid model_external_shared_lib_dir value. Str expected.' \\\n            + '.\\n\\nYou have: ' + type(model_external_shared_lib_dir) + '.\\n\\n')\n\n    @model_external_shared_lib_name.setter\n    def model_external_shared_lib_name(self, model_external_shared_lib_name):\n        if isinstance(model_external_shared_lib_name, str) :\n            if model_external_shared_lib_name[-3:] == '.so' : \n                raise Exception('Invalid model_external_shared_lib_name value. Remove the .so extension.' \\\n            + '.\\n\\nYou have: ' + type(model_external_shared_lib_name) + '.\\n\\n')\n            else :\n                self.__model_external_shared_lib_name = model_external_shared_lib_name\n        else:\n            raise Exception('Invalid model_external_shared_lib_name value. Str expected.' \\\n            + '.\\n\\nYou have: ' + type(model_external_shared_lib_name) + '.\\n\\n')\n\n    @exact_hess_constr.setter\n    def exact_hess_constr(self, exact_hess_constr):\n        if exact_hess_constr in [0, 1]:\n            self.__exact_hess_constr = exact_hess_constr\n        else:\n            raise Exception('Invalid exact_hess_constr value. exact_hess_constr takes one of the values 0, 1.')\n\n    @exact_hess_cost.setter\n    def exact_hess_cost(self, exact_hess_cost):\n        if exact_hess_cost in [0, 1]:\n            self.__exact_hess_cost = exact_hess_cost\n        else:\n            raise Exception('Invalid exact_hess_cost value. exact_hess_cost takes one of the values 0, 1.')\n\n    @exact_hess_dyn.setter\n    def exact_hess_dyn(self, exact_hess_dyn):\n        if exact_hess_dyn in [0, 1]:\n            self.__exact_hess_dyn = exact_hess_dyn\n        else:\n            raise Exception('Invalid exact_hess_dyn value. exact_hess_dyn takes one of the values 0, 1.')\n\n    @ext_cost_num_hess.setter\n    def ext_cost_num_hess(self, ext_cost_num_hess):\n        if ext_cost_num_hess in [0, 1]:\n            self.__ext_cost_num_hess = ext_cost_num_hess\n        else:\n            raise Exception('Invalid ext_cost_num_hess value. ext_cost_num_hess takes one of the values 0, 1.')\n\n    def set(self, attr, value):\n        setattr(self, attr, value)\n\n\nclass AcadosOcp:\n    \"\"\"\n    Class containing the full description of the optimal control problem.\n    This object can be used to create an :py:class:`acados_template.acados_ocp_solver.AcadosOcpSolver`.\n\n    The class has the following properties that can be modified to formulate a specific OCP, see below:\n\n        - :py:attr:`dims` of type :py:class:`acados_template.acados_ocp.AcadosOcpDims`\n        - :py:attr:`model` of type :py:class:`acados_template.acados_model.AcadosModel`\n        - :py:attr:`cost` of type :py:class:`acados_template.acados_ocp.AcadosOcpCost`\n        - :py:attr:`constraints` of type :py:class:`acados_template.acados_ocp.AcadosOcpConstraints`\n        - :py:attr:`solver_options` of type :py:class:`acados_template.acados_ocp.AcadosOcpOptions`\n\n        - :py:attr:`acados_include_path` (set automatically)\n        - :py:attr:`shared_lib_ext` (set automatically)\n        - :py:attr:`acados_lib_path` (set automatically)\n        - :py:attr:`parameter_values` - used to initialize the parameters (can be changed)\n    \"\"\"\n    def __init__(self, acados_path=''):\n        \"\"\"\n        Keyword arguments:\n        acados_path -- path of your acados installation\n        \"\"\"\n        if acados_path == '':\n            acados_path = get_acados_path()\n\n        self.dims = AcadosOcpDims()\n        \"\"\"Dimension definitions, type :py:class:`acados_template.acados_ocp.AcadosOcpDims`\"\"\"\n        self.model = AcadosModel()\n        \"\"\"Model definitions, type :py:class:`acados_template.acados_model.AcadosModel`\"\"\"\n        self.cost = AcadosOcpCost()\n        \"\"\"Cost definitions, type :py:class:`acados_template.acados_ocp.AcadosOcpCost`\"\"\"\n        self.constraints = AcadosOcpConstraints()\n        \"\"\"Constraints definitions, type :py:class:`acados_template.acados_ocp.AcadosOcpConstraints`\"\"\"\n        self.solver_options = AcadosOcpOptions()\n        \"\"\"Solver Options, type :py:class:`acados_template.acados_ocp.AcadosOcpOptions`\"\"\"\n\n        self.acados_include_path = os.path.join(acados_path, 'include').replace(os.sep, '/') # the replace part is important on Windows for CMake\n        \"\"\"Path to acados include directory (set automatically), type: `string`\"\"\"\n        self.acados_lib_path = os.path.join(acados_path, 'lib').replace(os.sep, '/') # the replace part is important on Windows for CMake\n        \"\"\"Path to where acados library is located, type: `string`\"\"\"\n        self.shared_lib_ext = get_lib_ext()\n\n        # get cython paths\n        from sysconfig import get_paths\n        self.cython_include_dirs = [np.get_include(), get_paths()['include']]\n\n        self.__parameter_values = np.array([])\n        self.__problem_class = 'OCP'\n\n        self.code_export_directory = 'c_generated_code'\n        \"\"\"Path to where code will be exported. Default: `c_generated_code`.\"\"\"\n\n    @property\n    def parameter_values(self):\n        \"\"\":math:`p` - initial values for parameter - can be updated stagewise\"\"\"\n        return self.__parameter_values\n\n    @parameter_values.setter\n    def parameter_values(self, parameter_values):\n        if isinstance(parameter_values, np.ndarray):\n            self.__parameter_values = parameter_values\n        else:\n            raise Exception('Invalid parameter_values value. ' +\n                            f'Expected numpy array, got {type(parameter_values)}.')\n\n    def set(self, attr, value):\n        # tokenize string\n        tokens = attr.split('_', 1)\n        if len(tokens) > 1:\n            setter_to_call = getattr(getattr(self, tokens[0]), 'set')\n        else:\n            setter_to_call = getattr(self, 'set')\n\n        setter_to_call(tokens[1], value)\n\n        return\n", "third_party/acados/acados_template/builders.py": "# -*- coding: future_fstrings -*-\n#\n# Copyright 2019 Gianluca Frison, Dimitris Kouzoupis, Robin Verschueren,\n# Andrea Zanelli, Niels van Duijkeren, Jonathan Frey, Tommaso Sartor,\n# Branimir Novoselnik, Rien Quirynen, Rezart Qelibari, Dang Doan,\n# Jonas Koenemann, Yutao Chen, Tobias Sch\u00f6ls, Jonas Schlagenhauf, Moritz Diehl\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nimport os\nimport sys\nfrom subprocess import DEVNULL, call, STDOUT\n\n\nclass CMakeBuilder:\n    \"\"\"\n    Class to work with the `CMake` build system.\n    \"\"\"\n    def __init__(self):\n        self._source_dir = None  # private source directory, this is set to code_export_dir\n        self.build_dir = 'build'\n        self._build_dir = None  # private build directory, usually rendered to abspath(build_dir)\n        self.generator = None\n        \"\"\"Defines the generator, options can be found via `cmake --help` under 'Generator'. Type: string. Linux default 'Unix Makefiles', Windows 'Visual Studio 15 2017 Win64'; default value: `None`.\"\"\"\n        # set something for Windows\n        if os.name == 'nt':\n            self.generator = 'Visual Studio 15 2017 Win64'\n        self.build_targets = None\n        \"\"\"A comma-separated list of the build targets, if `None` then all targets will be build; type: List of strings; default: `None`.\"\"\"\n        self.options_on = None\n        \"\"\"List of strings as CMake options which are translated to '-D Opt[0]=ON -D Opt[1]=ON ...'; default: `None`.\"\"\"\n\n    # Generate the command string for handling the cmake command.\n    def get_cmd1_cmake(self):\n        defines_str = ''\n        if self.options_on is not None:\n            defines_arr = [f' -D{opt}=ON' for opt in self.options_on]\n            defines_str = ' '.join(defines_arr)\n        generator_str = ''\n        if self.generator is not None:\n            generator_str = f' -G\"{self.generator}\"'\n        return f'cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=\"{self._source_dir}\"{defines_str}{generator_str} -Wdev -S\"{self._source_dir}\" -B\"{self._build_dir}\"'\n\n    # Generate the command string for handling the build.\n    def get_cmd2_build(self):\n        import multiprocessing\n        cmd = f'cmake --build \"{self._build_dir}\" --config Release -j{multiprocessing.cpu_count()}'\n        if self.build_targets is not None:\n            cmd += f' -t {self.build_targets}'\n        return cmd\n\n    # Generate the command string for handling the install command.\n    def get_cmd3_install(self):\n        return f'cmake --install \"{self._build_dir}\"'\n\n    def exec(self, code_export_directory, verbose=True):\n        \"\"\"\n        Execute the compilation using `CMake` with the given settings.\n        :param code_export_directory: must be the absolute path to the directory where the code was exported to\n        \"\"\"\n        if(os.path.isabs(code_export_directory) is False):\n            print(f'(W) the code export directory \"{code_export_directory}\" is not an absolute path!')\n        self._source_dir = code_export_directory\n        self._build_dir = os.path.abspath(self.build_dir)\n        try:\n            os.mkdir(self._build_dir)\n        except FileExistsError as e:\n            pass\n\n        try:\n            os.chdir(self._build_dir)\n            cmd_str = self.get_cmd1_cmake()\n            print(f'call(\"{cmd_str})\"')\n            retcode = call(\n                cmd_str,\n                shell=True,\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n            if retcode != 0:\n                raise RuntimeError(f'CMake command \"{cmd_str}\" was terminated by signal {retcode}')\n            cmd_str = self.get_cmd2_build()\n            print(f'call(\"{cmd_str}\")')\n            retcode = call(\n                cmd_str,\n                shell=True,\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n            if retcode != 0:\n                raise RuntimeError(f'Build command \"{cmd_str}\" was terminated by signal {retcode}')\n            cmd_str = self.get_cmd3_install()\n            print(f'call(\"{cmd_str}\")')\n            retcode = call(\n                cmd_str,\n                shell=True,\n                stdout=None if verbose else DEVNULL,\n                stderr=None if verbose else STDOUT\n            )\n            if retcode != 0:\n                raise RuntimeError(f'Install command \"{cmd_str}\" was terminated by signal {retcode}')\n        except OSError as e:\n            print(\"Execution failed:\", e, file=sys.stderr)\n        except Exception as e:\n            print(\"Execution failed:\", e, file=sys.stderr)\n            exit(1)\n", "third_party/acados/acados_template/gnsf/detect_gnsf_structure.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n#   Author: Jonathan Frey: jonathanpaulfrey(at)gmail.com\n\nfrom casadi import Function, jacobian, SX, vertcat, horzcat\n\nfrom .determine_trivial_gnsf_transcription import determine_trivial_gnsf_transcription\nfrom .detect_affine_terms_reduce_nonlinearity import (\n    detect_affine_terms_reduce_nonlinearity,\n)\nfrom .reformulate_with_LOS import reformulate_with_LOS\nfrom .reformulate_with_invertible_E_mat import reformulate_with_invertible_E_mat\nfrom .structure_detection_print_summary import structure_detection_print_summary\nfrom .check_reformulation import check_reformulation\n\n\ndef detect_gnsf_structure(acados_ocp, transcribe_opts=None):\n\n    ## Description\n    # This function takes a CasADi implicit ODE or index-1 DAE model \"model\"\n    # consisting of a CasADi expression f_impl in the symbolic CasADi\n    # variables x, xdot, u, z, (and possibly parameters p), which are also part\n    # of the model, as well as a model name.\n    # It will create a struct \"gnsf\" containing all information needed to use\n    # it with the gnsf integrator in acados.\n    # Additionally it will create the struct \"reordered_model\" which contains\n    # the permuted state vector and permuted f_impl, in which additionally some\n    # functions, which were made part of the linear output system of the gnsf,\n    # have changed signs.\n\n    # Options: transcribe_opts is a Matlab struct consisting of booleans:\n    #   print_info: if extensive information on how the model is processed\n    #       is printed to the console.\n    #   generate_gnsf_model: if the neccessary C functions to simulate the gnsf\n    #       model with the acados implementation of the GNSF exploiting\n    #       integrator should be generated.\n    #   generate_gnsf_model: if the neccessary C functions to simulate the\n    #       reordered model with the acados implementation of the IRK\n    #       integrator should be generated.\n    #   check_E_invertibility: if the transcription method should check if the\n    #       assumption that the main blocks of the matrix gnsf.E are invertible\n    #       holds. If not, the method will try to reformulate the gnsf model\n    #       with a different model, such that the assumption holds.\n\n    # acados_root_dir = getenv('ACADOS_INSTALL_DIR')\n\n    ## load transcribe_opts\n    if transcribe_opts is None:\n        print(\"WARNING: GNSF structure detection called without transcribe_opts\")\n        print(\" using default settings\")\n        print(\"\")\n        transcribe_opts = dict()\n\n    if \"print_info\" in transcribe_opts:\n        print_info = transcribe_opts[\"print_info\"]\n    else:\n        print_info = 1\n        print(\"print_info option was not set - default is true\")\n\n    if \"detect_LOS\" in transcribe_opts:\n        detect_LOS = transcribe_opts[\"detect_LOS\"]\n    else:\n        detect_LOS = 1\n        if print_info:\n            print(\"detect_LOS option was not set - default is true\")\n\n    if \"check_E_invertibility\" in transcribe_opts:\n        check_E_invertibility = transcribe_opts[\"check_E_invertibility\"]\n    else:\n        check_E_invertibility = 1\n        if print_info:\n            print(\"check_E_invertibility option was not set - default is true\")\n\n    ## Reformulate implicit index-1 DAE into GNSF form\n    # (Generalized nonlinear static feedback)\n    gnsf = determine_trivial_gnsf_transcription(acados_ocp, print_info)\n    gnsf = detect_affine_terms_reduce_nonlinearity(gnsf, acados_ocp, print_info)\n\n    if detect_LOS:\n        gnsf = reformulate_with_LOS(acados_ocp, gnsf, print_info)\n\n    if check_E_invertibility:\n        gnsf = reformulate_with_invertible_E_mat(gnsf, acados_ocp, print_info)\n\n    # detect purely linear model\n    if gnsf[\"nx1\"] == 0 and gnsf[\"nz1\"] == 0 and gnsf[\"nontrivial_f_LO\"] == 0:\n        gnsf[\"purely_linear\"] = 1\n    else:\n        gnsf[\"purely_linear\"] = 0\n\n    structure_detection_print_summary(gnsf, acados_ocp)\n    check_reformulation(acados_ocp.model, gnsf, print_info)\n\n    ## copy relevant fields from gnsf to model\n    acados_ocp.model.get_matrices_fun = Function()\n    dummy = acados_ocp.model.x[0]\n    model_name = acados_ocp.model.name\n\n    get_matrices_fun = Function(\n        f\"{model_name}_gnsf_get_matrices_fun\",\n        [dummy],\n        [\n            gnsf[\"A\"],\n            gnsf[\"B\"],\n            gnsf[\"C\"],\n            gnsf[\"E\"],\n            gnsf[\"L_x\"],\n            gnsf[\"L_xdot\"],\n            gnsf[\"L_z\"],\n            gnsf[\"L_u\"],\n            gnsf[\"A_LO\"],\n            gnsf[\"c\"],\n            gnsf[\"E_LO\"],\n            gnsf[\"B_LO\"],\n            gnsf[\"nontrivial_f_LO\"],\n            gnsf[\"purely_linear\"],\n            gnsf[\"ipiv_x\"] + 1,\n            gnsf[\"ipiv_z\"] + 1,\n            gnsf[\"c_LO\"],\n        ],\n    )\n\n    phi = gnsf[\"phi_expr\"]\n    y = gnsf[\"y\"]\n    uhat = gnsf[\"uhat\"]\n    p = gnsf[\"p\"]\n\n    jac_phi_y = jacobian(phi, y)\n    jac_phi_uhat = jacobian(phi, uhat)\n\n    phi_fun = Function(f\"{model_name}_gnsf_phi_fun\", [y, uhat, p], [phi])\n    acados_ocp.model.phi_fun = phi_fun\n    acados_ocp.model.phi_fun_jac_y = Function(\n        f\"{model_name}_gnsf_phi_fun_jac_y\", [y, uhat, p], [phi, jac_phi_y]\n    )\n    acados_ocp.model.phi_jac_y_uhat = Function(\n        f\"{model_name}_gnsf_phi_jac_y_uhat\", [y, uhat, p], [jac_phi_y, jac_phi_uhat]\n    )\n\n    x1 = acados_ocp.model.x[gnsf[\"idx_perm_x\"][: gnsf[\"nx1\"]]]\n    x1dot = acados_ocp.model.xdot[gnsf[\"idx_perm_x\"][: gnsf[\"nx1\"]]]\n    if gnsf[\"nz1\"] > 0:\n        z1 = acados_ocp.model.z[gnsf[\"idx_perm_z\"][: gnsf[\"nz1\"]]]\n    else:\n        z1 = SX.sym(\"z1\", 0, 0)\n    f_lo = gnsf[\"f_lo_expr\"]\n    u = acados_ocp.model.u\n    acados_ocp.model.f_lo_fun_jac_x1k1uz = Function(\n        f\"{model_name}_gnsf_f_lo_fun_jac_x1k1uz\",\n        [x1, x1dot, z1, u, p],\n        [\n            f_lo,\n            horzcat(\n                jacobian(f_lo, x1),\n                jacobian(f_lo, x1dot),\n                jacobian(f_lo, u),\n                jacobian(f_lo, z1),\n            ),\n        ],\n    )\n\n    acados_ocp.model.get_matrices_fun = get_matrices_fun\n\n    size_gnsf_A = gnsf[\"A\"].shape\n    acados_ocp.dims.gnsf_nx1 = size_gnsf_A[1]\n    acados_ocp.dims.gnsf_nz1 = size_gnsf_A[0] - size_gnsf_A[1]\n    acados_ocp.dims.gnsf_nuhat = max(phi_fun.size_in(1))\n    acados_ocp.dims.gnsf_ny = max(phi_fun.size_in(0))\n    acados_ocp.dims.gnsf_nout = max(phi_fun.size_out(0))\n\n    # # dim\n    # model['dim_gnsf_nx1'] = gnsf['nx1']\n    # model['dim_gnsf_nx2'] = gnsf['nx2']\n    # model['dim_gnsf_nz1'] = gnsf['nz1']\n    # model['dim_gnsf_nz2'] = gnsf['nz2']\n    # model['dim_gnsf_nuhat'] = gnsf['nuhat']\n    # model['dim_gnsf_ny'] = gnsf['ny']\n    # model['dim_gnsf_nout'] = gnsf['n_out']\n\n    # # sym\n    # model['sym_gnsf_y'] = gnsf['y']\n    # model['sym_gnsf_uhat'] = gnsf['uhat']\n\n    # # data\n    # model['dyn_gnsf_A'] = gnsf['A']\n    # model['dyn_gnsf_A_LO'] = gnsf['A_LO']\n    # model['dyn_gnsf_B'] = gnsf['B']\n    # model['dyn_gnsf_B_LO'] = gnsf['B_LO']\n    # model['dyn_gnsf_E'] = gnsf['E']\n    # model['dyn_gnsf_E_LO'] = gnsf['E_LO']\n    # model['dyn_gnsf_C'] = gnsf['C']\n    # model['dyn_gnsf_c'] = gnsf['c']\n    # model['dyn_gnsf_c_LO'] = gnsf['c_LO']\n    # model['dyn_gnsf_L_x'] = gnsf['L_x']\n    # model['dyn_gnsf_L_xdot'] = gnsf['L_xdot']\n    # model['dyn_gnsf_L_z'] = gnsf['L_z']\n    # model['dyn_gnsf_L_u'] = gnsf['L_u']\n    # model['dyn_gnsf_idx_perm_x'] = gnsf['idx_perm_x']\n    # model['dyn_gnsf_ipiv_x'] = gnsf['ipiv_x']\n    # model['dyn_gnsf_idx_perm_z'] = gnsf['idx_perm_z']\n    # model['dyn_gnsf_ipiv_z'] = gnsf['ipiv_z']\n    # model['dyn_gnsf_idx_perm_f'] = gnsf['idx_perm_f']\n    # model['dyn_gnsf_ipiv_f'] = gnsf['ipiv_f']\n\n    # # flags\n    # model['dyn_gnsf_nontrivial_f_LO'] = gnsf['nontrivial_f_LO']\n    # model['dyn_gnsf_purely_linear'] = gnsf['purely_linear']\n\n    # # casadi expr\n    # model['dyn_gnsf_expr_phi'] = gnsf['phi_expr']\n    # model['dyn_gnsf_expr_f_lo'] = gnsf['f_lo_expr']\n\n    return acados_ocp\n", "third_party/acados/acados_template/gnsf/determine_input_nonlinearity_function.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n#   Author: Jonathan Frey: jonathanpaulfrey(at)gmail.com\n\nfrom casadi import *\nfrom ..utils import casadi_length, is_empty\n\n\ndef determine_input_nonlinearity_function(gnsf):\n\n    ## Description\n    # this function takes a structure gnsf and updates the matrices L_x,\n    # L_xdot, L_z, L_u and CasADi vectors y, uhat of this structure as follows:\n\n    # given a CasADi expression phi_expr, which may depend on the variables\n    # (x1, x1dot, z, u), this function determines a vector y (uhat) consisting\n    # of all components of (x1, x1dot, z) (respectively u) that enter phi_expr.\n    # Additionally matrices L_x, L_xdot, L_z, L_u are determined such that\n    #           y    = L_x * x + L_xdot * xdot + L_z * z\n    #           uhat = L_u * u\n    # Furthermore the dimensions ny, nuhat, n_out are updated\n\n    ## y\n    y = SX.sym('y', 0, 0)\n    # components of x1\n    for ii in range(gnsf[\"nx1\"]):\n        if which_depends(gnsf[\"phi_expr\"], gnsf[\"x\"][ii])[0]:\n            y = vertcat(y, gnsf[\"x\"][ii])\n        # else:\n        # x[ii] is not part of y\n    # components of x1dot\n    for ii in range(gnsf[\"nx1\"]):\n        if which_depends(gnsf[\"phi_expr\"], gnsf[\"xdot\"][ii])[0]:\n            print(gnsf[\"phi_expr\"], \"depends on\", gnsf[\"xdot\"][ii])\n            y = vertcat(y, gnsf[\"xdot\"][ii])\n        # else:\n        # xdot[ii] is not part of y\n    # components of z\n    for ii in range(gnsf[\"nz1\"]):\n        if which_depends(gnsf[\"phi_expr\"], gnsf[\"z\"][ii])[0]:\n            y = vertcat(y, gnsf[\"z\"][ii])\n        # else:\n        # z[ii] is not part of y\n    ## uhat\n    uhat = SX.sym('uhat', 0, 0)\n    # components of u\n    for ii in range(gnsf[\"nu\"]):\n        if which_depends(gnsf[\"phi_expr\"], gnsf[\"u\"][ii])[0]:\n            uhat = vertcat(uhat, gnsf[\"u\"][ii])\n        # else:\n        # u[ii] is not part of uhat\n    ## generate gnsf['phi_expr_fun']\n    # linear input matrices\n    if is_empty(y):\n        gnsf[\"L_x\"] = []\n        gnsf[\"L_xdot\"] = []\n        gnsf[\"L_u\"] = []\n        gnsf[\"L_z\"] = []\n    else:\n        dummy = SX.sym(\"dummy_input\", 0)\n        L_x_fun = Function(\n            \"L_x_fun\", [dummy], [jacobian(y, gnsf[\"x\"][range(gnsf[\"nx1\"])])]\n        )\n        L_xdot_fun = Function(\n            \"L_xdot_fun\", [dummy], [jacobian(y, gnsf[\"xdot\"][range(gnsf[\"nx1\"])])]\n        )\n        L_z_fun = Function(\n            \"L_z_fun\", [dummy], [jacobian(y, gnsf[\"z\"][range(gnsf[\"nz1\"])])]\n        )\n        L_u_fun = Function(\"L_u_fun\", [dummy], [jacobian(uhat, gnsf[\"u\"])])\n\n        gnsf[\"L_x\"] = L_x_fun(0).full()\n        gnsf[\"L_xdot\"] = L_xdot_fun(0).full()\n        gnsf[\"L_u\"] = L_u_fun(0).full()\n        gnsf[\"L_z\"] = L_z_fun(0).full()\n    gnsf[\"y\"] = y\n    gnsf[\"uhat\"] = uhat\n\n    gnsf[\"ny\"] = casadi_length(y)\n    gnsf[\"nuhat\"] = casadi_length(uhat)\n    gnsf[\"n_out\"] = casadi_length(gnsf[\"phi_expr\"])\n\n    return gnsf\n", "third_party/acados/acados_template/gnsf/structure_detection_print_summary.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n#   Author: Jonathan Frey: jonathanpaulfrey(at)gmail.com\n\nfrom casadi import n_nodes\nimport numpy as np\n\n\ndef structure_detection_print_summary(gnsf, acados_ocp):\n\n    ## Description\n    # this function prints the most important info after determining a GNSF\n    # reformulation of the implicit model \"initial_model\" into \"gnsf\", which is\n    # equivalent to the \"reordered_model\".\n    model = acados_ocp.model\n    # # GNSF\n    # get dimensions\n    nx = gnsf[\"nx\"]\n    nu = gnsf[\"nu\"]\n    nz = gnsf[\"nz\"]\n\n    nx1 = gnsf[\"nx1\"]\n    nx2 = gnsf[\"nx2\"]\n\n    nz1 = gnsf[\"nz1\"]\n    nz2 = gnsf[\"nz2\"]\n\n    # np = gnsf['np']\n    n_out = gnsf[\"n_out\"]\n    ny = gnsf[\"ny\"]\n    nuhat = gnsf[\"nuhat\"]\n\n    #\n    f_impl_expr = model.f_impl_expr\n    n_nodes_initial = n_nodes(model.f_impl_expr)\n    # x_old = model.x\n    # f_impl_old = model.f_impl_expr\n\n    x = gnsf[\"x\"]\n    z = gnsf[\"z\"]\n\n    phi_current = gnsf[\"phi_expr\"]\n\n    ## PRINT SUMMARY -- STRUCHTRE DETECTION\n    print(\" \")\n    print(\n        \"*********************************************************************************************\"\n    )\n    print(\" \")\n    print(\n        \"******************        SUCCESS: GNSF STRUCTURE DETECTION COMPLETE !!!      ***************\"\n    )\n    print(\" \")\n    print(\n        \"*********************************************************************************************\"\n    )\n    print(\" \")\n    print(\n        f\"========================= STRUCTURE DETECTION SUMMARY ====================================\"\n    )\n    print(\" \")\n    print(\"-------- Nonlinear Static Feedback type system --------\")\n    print(\" \")\n    print(\" successfully transcribed dynamic system model into GNSF structure \")\n    print(\" \")\n    print(\n        \"reduced dimension of nonlinearity phi from        \",\n        str(nx + nz),\n        \" to \",\n        str(gnsf[\"n_out\"]),\n    )\n    print(\" \")\n    print(\n        \"reduced input dimension of nonlinearity phi from  \",\n        2 * nx + nz + nu,\n        \" to \",\n        gnsf[\"ny\"] + gnsf[\"nuhat\"],\n    )\n    print(\" \")\n    print(f\"reduced number of nodes in CasADi expression of nonlinearity phi from  {n_nodes_initial}  to  {n_nodes(phi_current)}\\n\")\n    print(\"----------- Linear Output System (LOS) ---------------\")\n    if nx2 + nz2 > 0:\n        print(\" \")\n        print(f\"introduced Linear Output System of size           \", str(nx2 + nz2))\n        print(\" \")\n        if nx2 > 0:\n            print(\"consisting of the states:\")\n            print(\" \")\n            print(x[range(nx1, nx)])\n            print(\" \")\n        if nz2 > 0:\n            print(\"and algebraic variables:\")\n            print(\" \")\n            print(z[range(nz1, nz)])\n            print(\" \")\n        if gnsf[\"purely_linear\"] == 1:\n            print(\" \")\n            print(\"Model is fully linear!\")\n            print(\" \")\n    if not all(gnsf[\"idx_perm_x\"] == np.array(range(nx))):\n        print(\" \")\n        print(\n            \"--------------------------------------------------------------------------------------------------\"\n        )\n        print(\n            \"NOTE: permuted differential state vector x, such that x_gnsf = x(idx_perm_x) with idx_perm_x =\"\n        )\n        print(\" \")\n        print(gnsf[\"idx_perm_x\"])\n    if nz != 0 and not all(gnsf[\"idx_perm_z\"] == np.array(range(nz))):\n        print(\" \")\n        print(\n            \"--------------------------------------------------------------------------------------------------\"\n        )\n        print(\n            \"NOTE: permuted algebraic state vector z, such that z_gnsf = z(idx_perm_z) with idx_perm_z =\"\n        )\n        print(\" \")\n        print(gnsf[\"idx_perm_z\"])\n    if not all(gnsf[\"idx_perm_f\"] == np.array(range(nx + nz))):\n        print(\" \")\n        print(\n            \"--------------------------------------------------------------------------------------------------\"\n        )\n        print(\n            \"NOTE: permuted rhs expression vector f, such that f_gnsf = f(idx_perm_f) with idx_perm_f =\"\n        )\n        print(\" \")\n        print(gnsf[\"idx_perm_f\"])\n    ## print GNSF dimensions\n    print(\n        \"--------------------------------------------------------------------------------------------------------\"\n    )\n    print(\" \")\n    print(\"The dimensions of the GNSF reformulated model read as:\")\n    print(\" \")\n    # T_dim = table(nx, nu, nz, np, nx1, nz1, n_out, ny, nuhat)\n    # print( T_dim )\n    print(f\"nx    \", {nx})\n    print(f\"nu    \", {nu})\n    print(f\"nz    \", {nz})\n    # print(f\"np    \", {np})\n    print(f\"nx1   \", {nx1})\n    print(f\"nz1   \", {nz1})\n    print(f\"n_out \", {n_out})\n    print(f\"ny    \", {ny})\n    print(f\"nuhat \", {nuhat})\n", "third_party/acados/acados_template/gnsf/detect_affine_terms_reduce_nonlinearity.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nfrom casadi import *\nfrom .check_reformulation import check_reformulation\nfrom .determine_input_nonlinearity_function import determine_input_nonlinearity_function\nfrom ..utils import casadi_length, print_casadi_expression\n\n\ndef detect_affine_terms_reduce_nonlinearity(gnsf, acados_ocp, print_info):\n\n    ## Description\n    # this function takes a gnsf structure with trivial model matrices (A, B,\n    # E, c are zeros, and C is eye).\n    # It detects all affine linear terms and sets up an equivalent model in the\n    # GNSF structure, where all affine linear terms are modeled through the\n    # matrices A, B, E, c and the linear output system (LOS) is empty.\n    # NOTE: model is just taken as an argument to check equivalence of the\n    # models within the function.\n\n    model = acados_ocp.model\n    if print_info:\n        print(\" \")\n        print(\"====================================================================\")\n        print(\" \")\n        print(\"============  Detect affine-linear dependencies   ==================\")\n        print(\" \")\n        print(\"====================================================================\")\n        print(\" \")\n    # symbolics\n    x = gnsf[\"x\"]\n    xdot = gnsf[\"xdot\"]\n    u = gnsf[\"u\"]\n    z = gnsf[\"z\"]\n\n    # dimensions\n    nx = gnsf[\"nx\"]\n    nu = gnsf[\"nu\"]\n    nz = gnsf[\"nz\"]\n\n    ny_old = gnsf[\"ny\"]\n    nuhat_old = gnsf[\"nuhat\"]\n\n    ## Represent all affine dependencies through the model matrices A, B, E, c\n    ## determine A\n    n_nodes_current = n_nodes(gnsf[\"phi_expr\"])\n\n    for ii in range(casadi_length(gnsf[\"phi_expr\"])):\n        fii = gnsf[\"phi_expr\"][ii]\n        for ix in range(nx):\n            var = x[ix]\n            varname = var.name\n            # symbolic jacobian of fii w.r.t. xi\n            jac_fii_xi = jacobian(fii, var)\n            if jac_fii_xi.is_constant():\n                # jacobian value\n                jac_fii_xi_fun = Function(\"jac_fii_xi_fun\", [x[1]], [jac_fii_xi])\n                # x[1] as input just to have a scalar input and call the function as follows:\n                gnsf[\"A\"][ii, ix] = jac_fii_xi_fun(0).full()\n            else:\n                gnsf[\"A\"][ii, ix] = 0\n                if print_info:\n                    print(\n                        \"phi(\",\n                        str(ii),\n                        \") is nonlinear in x(\",\n                        str(ix),\n                        \") = \",\n                        varname,\n                    )\n                    print(fii)\n                    print(\"-----------------------------------------------------\")\n    f_next = gnsf[\"phi_expr\"] - gnsf[\"A\"] @ x\n    f_next = simplify(f_next)\n    n_nodes_next = n_nodes(f_next)\n\n    if print_info:\n        print(\"\\n\")\n        print(f\"determined matrix A:\")\n        print(gnsf[\"A\"])\n        print(f\"reduced nonlinearity from  {n_nodes_current} to {n_nodes_next} nodes\")\n    # assert(n_nodes_current >= n_nodes_next,'n_nodes_current >= n_nodes_next FAILED')\n    gnsf[\"phi_expr\"] = f_next\n\n    check_reformulation(model, gnsf, print_info)\n\n    ## determine B\n    n_nodes_current = n_nodes(gnsf[\"phi_expr\"])\n\n    for ii in range(casadi_length(gnsf[\"phi_expr\"])):\n        fii = gnsf[\"phi_expr\"][ii]\n        for iu in range(nu):\n            var = u[iu]\n            varname = var.name\n            # symbolic jacobian of fii w.r.t. ui\n            jac_fii_ui = jacobian(fii, var)\n            if jac_fii_ui.is_constant():  # i.e. hessian is structural zero:\n                # jacobian value\n                jac_fii_ui_fun = Function(\"jac_fii_ui_fun\", [x[1]], [jac_fii_ui])\n                gnsf[\"B\"][ii, iu] = jac_fii_ui_fun(0).full()\n            else:\n                gnsf[\"B\"][ii, iu] = 0\n                if print_info:\n                    print(f\"phi({ii}) is nonlinear in u(\", str(iu), \") = \", varname)\n                    print(fii)\n                    print(\"-----------------------------------------------------\")\n    f_next = gnsf[\"phi_expr\"] - gnsf[\"B\"] @ u\n    f_next = simplify(f_next)\n    n_nodes_next = n_nodes(f_next)\n\n    if print_info:\n        print(\"\\n\")\n        print(f\"determined matrix B:\")\n        print(gnsf[\"B\"])\n        print(f\"reduced nonlinearity from  {n_nodes_current} to {n_nodes_next} nodes\")\n\n    gnsf[\"phi_expr\"] = f_next\n\n    check_reformulation(model, gnsf, print_info)\n\n    ## determine E\n    n_nodes_current = n_nodes(gnsf[\"phi_expr\"])\n    k = vertcat(xdot, z)\n\n    for ii in range(casadi_length(gnsf[\"phi_expr\"])):\n        fii = gnsf[\"phi_expr\"][ii]\n        for ik in range(casadi_length(k)):\n            # symbolic jacobian of fii w.r.t. ui\n            var = k[ik]\n            varname = var.name\n            jac_fii_ki = jacobian(fii, var)\n            if jac_fii_ki.is_constant():\n                # jacobian value\n                jac_fii_ki_fun = Function(\"jac_fii_ki_fun\", [x[1]], [jac_fii_ki])\n                gnsf[\"E\"][ii, ik] = -jac_fii_ki_fun(0).full()\n            else:\n                gnsf[\"E\"][ii, ik] = 0\n                if print_info:\n                    print(f\"phi( {ii}) is nonlinear in xdot_z({ik}) = \", varname)\n                    print(fii)\n                    print(\"-----------------------------------------------------\")\n    f_next = gnsf[\"phi_expr\"] + gnsf[\"E\"] @ k\n    f_next = simplify(f_next)\n    n_nodes_next = n_nodes(f_next)\n\n    if print_info:\n        print(\"\\n\")\n        print(f\"determined matrix E:\")\n        print(gnsf[\"E\"])\n        print(f\"reduced nonlinearity from {n_nodes_current} to {n_nodes_next} nodes\")\n\n    gnsf[\"phi_expr\"] = f_next\n    check_reformulation(model, gnsf, print_info)\n\n    ## determine constant term c\n\n    n_nodes_current = n_nodes(gnsf[\"phi_expr\"])\n    for ii in range(casadi_length(gnsf[\"phi_expr\"])):\n        fii = gnsf[\"phi_expr\"][ii]\n        if fii.is_constant():\n            # function value goes into c\n            fii_fun = Function(\"fii_fun\", [x[1]], [fii])\n            gnsf[\"c\"][ii] = fii_fun(0).full()\n        else:\n            gnsf[\"c\"][ii] = 0\n            if print_info:\n                print(f\"phi(\", str(ii), \") is NOT constant\")\n                print(fii)\n                print(\"-----------------------------------------------------\")\n    gnsf[\"phi_expr\"] = gnsf[\"phi_expr\"] - gnsf[\"c\"]\n    gnsf[\"phi_expr\"] = simplify(gnsf[\"phi_expr\"])\n    n_nodes_next = n_nodes(gnsf[\"phi_expr\"])\n\n    if print_info:\n        print(\"\\n\")\n        print(f\"determined vector c:\")\n        print(gnsf[\"c\"])\n        print(f\"reduced nonlinearity from {n_nodes_current} to {n_nodes_next} nodes\")\n\n    check_reformulation(model, gnsf, print_info)\n\n    ## determine nonlinearity & corresponding matrix C\n    ## Reduce dimension of phi\n    n_nodes_current = n_nodes(gnsf[\"phi_expr\"])\n    ind_non_zero = []\n    for ii in range(casadi_length(gnsf[\"phi_expr\"])):\n        fii = gnsf[\"phi_expr\"][ii]\n        fii = simplify(fii)\n        if not fii.is_zero():\n            ind_non_zero = list(set.union(set(ind_non_zero), set([ii])))\n    gnsf[\"phi_expr\"] = gnsf[\"phi_expr\"][ind_non_zero]\n\n    # C\n    gnsf[\"C\"] = np.zeros((nx + nz, len(ind_non_zero)))\n    for ii in range(len(ind_non_zero)):\n        gnsf[\"C\"][ind_non_zero[ii], ii] = 1\n    gnsf = determine_input_nonlinearity_function(gnsf)\n    n_nodes_next = n_nodes(gnsf[\"phi_expr\"])\n\n    if print_info:\n        print(\" \")\n        print(\"determined matrix C:\")\n        print(gnsf[\"C\"])\n        print(\n            \"---------------------------------------------------------------------------------\"\n        )\n        print(\n            \"------------- Success: Affine linear terms detected -----------------------------\"\n        )\n        print(\n            \"---------------------------------------------------------------------------------\"\n        )\n        print(\n            f'reduced nonlinearity dimension n_out from  {nx+nz}  to  {gnsf[\"n_out\"]}'\n        )\n        print(f\"reduced nonlinearity from  {n_nodes_current} to {n_nodes_next} nodes\")\n        print(\" \")\n        print(\"phi now reads as:\")\n        print_casadi_expression(gnsf[\"phi_expr\"])\n\n    ## determine input of nonlinearity function\n    check_reformulation(model, gnsf, print_info)\n\n    gnsf[\"ny\"] = casadi_length(gnsf[\"y\"])\n    gnsf[\"nuhat\"] = casadi_length(gnsf[\"uhat\"])\n\n    if print_info:\n        print(\n            \"-----------------------------------------------------------------------------------\"\n        )\n        print(\" \")\n        print(\n            f\"reduced input ny    of phi from  \",\n            str(ny_old),\n            \"   to  \",\n            str(gnsf[\"ny\"]),\n        )\n        print(\n            f\"reduced input nuhat of phi from  \",\n            str(nuhat_old),\n            \"   to  \",\n            str(gnsf[\"nuhat\"]),\n        )\n        print(\n            \"-----------------------------------------------------------------------------------\"\n        )\n\n    # if print_info:\n    #     print(f\"gnsf: {gnsf}\")\n\n    return gnsf\n", "third_party/acados/acados_template/gnsf/check_reformulation.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nfrom acados_template.utils import casadi_length\nfrom casadi import *\nimport numpy as np\n\n\ndef check_reformulation(model, gnsf, print_info):\n\n    ## Description:\n    # this function takes the implicit ODE/ index-1 DAE and a gnsf structure\n    # to evaluate both models at num_eval random points x0, x0dot, z0, u0\n    # if for all points the relative error is <= TOL, the function will return::\n    # 1, otherwise it will give an error.\n\n    TOL = 1e-14\n    num_eval = 10\n\n    # get dimensions\n    nx = gnsf[\"nx\"]\n    nu = gnsf[\"nu\"]\n    nz = gnsf[\"nz\"]\n    nx1 = gnsf[\"nx1\"]\n    nx2 = gnsf[\"nx2\"]\n    nz1 = gnsf[\"nz1\"]\n    nz2 = gnsf[\"nz2\"]\n    n_out = gnsf[\"n_out\"]\n\n    # get model matrices\n    A = gnsf[\"A\"]\n    B = gnsf[\"B\"]\n    C = gnsf[\"C\"]\n    E = gnsf[\"E\"]\n    c = gnsf[\"c\"]\n\n    L_x = gnsf[\"L_x\"]\n    L_xdot = gnsf[\"L_xdot\"]\n    L_z = gnsf[\"L_z\"]\n    L_u = gnsf[\"L_u\"]\n\n    A_LO = gnsf[\"A_LO\"]\n    E_LO = gnsf[\"E_LO\"]\n    B_LO = gnsf[\"B_LO\"]\n    c_LO = gnsf[\"c_LO\"]\n\n    I_x1 = range(nx1)\n    I_x2 = range(nx1, nx)\n\n    I_z1 = range(nz1)\n    I_z2 = range(nz1, nz)\n\n    idx_perm_f = gnsf[\"idx_perm_f\"]\n\n    # get casadi variables\n    x = gnsf[\"x\"]\n    xdot = gnsf[\"xdot\"]\n    z = gnsf[\"z\"]\n    u = gnsf[\"u\"]\n    y = gnsf[\"y\"]\n    uhat = gnsf[\"uhat\"]\n    p = gnsf[\"p\"]\n\n    # create functions\n    impl_dae_fun = Function(\"impl_dae_fun\", [x, xdot, u, z, p], [model.f_impl_expr])\n    phi_fun = Function(\"phi_fun\", [y, uhat, p], [gnsf[\"phi_expr\"]])\n    f_lo_fun = Function(\n        \"f_lo_fun\", [x[range(nx1)], xdot[range(nx1)], z, u, p], [gnsf[\"f_lo_expr\"]]\n    )\n\n    # print(gnsf)\n    # print(gnsf[\"n_out\"])\n\n    for i_check in range(num_eval):\n        # generate random values\n        x0 = np.random.rand(nx, 1)\n        x0dot = np.random.rand(nx, 1)\n        z0 = np.random.rand(nz, 1)\n        u0 = np.random.rand(nu, 1)\n\n        if gnsf[\"ny\"] > 0:\n            y0 = L_x @ x0[I_x1] + L_xdot @ x0dot[I_x1] + L_z @ z0[I_z1]\n        else:\n            y0 = []\n        if gnsf[\"nuhat\"] > 0:\n            uhat0 = L_u @ u0\n        else:\n            uhat0 = []\n\n        # eval functions\n        p0 = np.random.rand(gnsf[\"np\"], 1)\n        f_impl_val = impl_dae_fun(x0, x0dot, u0, z0, p0).full()\n        phi_val = phi_fun(y0, uhat0, p0)\n        f_lo_val = f_lo_fun(x0[I_x1], x0dot[I_x1], z0[I_z1], u0, p0)\n\n        f_impl_val = f_impl_val[idx_perm_f]\n        # eval gnsf\n        if n_out > 0:\n            C_phi = C @ phi_val\n        else:\n            C_phi = np.zeros((nx1 + nz1, 1))\n        try:\n            gnsf_val1 = (\n                A @ x0[I_x1] + B @ u0 + C_phi + c - E @ vertcat(x0dot[I_x1], z0[I_z1])\n            )\n            # gnsf_1 = (A @ x[I_x1] + B @ u + C_phi + c - E @ vertcat(xdot[I_x1], z[I_z1]))\n        except:\n            import pdb\n\n            pdb.set_trace()\n\n        if nx2 > 0:  # eval LOS:\n            gnsf_val2 = (\n                A_LO @ x0[I_x2]\n                + B_LO @ u0\n                + c_LO\n                + f_lo_val\n                - E_LO @ vertcat(x0dot[I_x2], z0[I_z2])\n            )\n            gnsf_val = vertcat(gnsf_val1, gnsf_val2).full()\n        else:\n            gnsf_val = gnsf_val1.full()\n        # compute error and check\n        rel_error = np.linalg.norm(f_impl_val - gnsf_val) / np.linalg.norm(f_impl_val)\n\n        if rel_error > TOL:\n            print(\"transcription failed rel_error > TOL\")\n            print(\"you are in debug mode now: import pdb; pdb.set_trace()\")\n            abs_error = gnsf_val - f_impl_val\n            # T = table(f_impl_val, gnsf_val, abs_error)\n            # print(T)\n            print(\"abs_error:\", abs_error)\n            #         error('transcription failed rel_error > TOL')\n            #         check = 0\n            import pdb\n\n            pdb.set_trace()\n    if print_info:\n        print(\" \")\n        print(\"model reformulation checked: relative error <= TOL = \", str(TOL))\n        print(\" \")\n        check = 1\n    ## helpful for debugging:\n    # # use in calling function and compare\n    # # compare f_impl(i) with gnsf_val1(i)\n    #\n\n    #     nx  = gnsf['nx']\n    #     nu  = gnsf['nu']\n    #     nz  = gnsf['nz']\n    #     nx1 = gnsf['nx1']\n    #     nx2 = gnsf['nx2']\n    #\n    #         A  = gnsf['A']\n    #     B  = gnsf['B']\n    #     C  = gnsf['C']\n    #     E  = gnsf['E']\n    #     c  = gnsf['c']\n    #\n    #     L_x    = gnsf['L_x']\n    #     L_z    = gnsf['L_z']\n    #     L_xdot = gnsf['L_xdot']\n    #     L_u    = gnsf['L_u']\n    #\n    #     A_LO = gnsf['A_LO']\n    #\n    #     x0 = rand(nx, 1)\n    #     x0dot = rand(nx, 1)\n    #     z0 = rand(nz, 1)\n    #     u0 = rand(nu, 1)\n    #     I_x1 = range(nx1)\n    #     I_x2 = nx1+range(nx)\n    #\n    #     y0 = L_x @ x0[I_x1] + L_xdot @ x0dot[I_x1] + L_z @ z0\n    #     uhat0 = L_u @ u0\n    #\n    #     gnsf_val1 = (A @ x[I_x1] + B @ u + #         C @ phi_current + c) - E @ [xdot[I_x1] z]\n    #     gnsf_val1 = gnsf_val1.simplify()\n    #\n    # #     gnsf_val2 = A_LO @ x[I_x2] + gnsf['f_lo_fun'](x[I_x1], xdot[I_x1], z, u) - xdot[I_x2]\n    #     gnsf_val2 =  A_LO @ x[I_x2] + gnsf['f_lo_fun'](x[I_x1], xdot[I_x1], z, u) - xdot[I_x2]\n    #\n    #\n    #     gnsf_val = [gnsf_val1 gnsf_val2]\n    #     gnsf_val = gnsf_val.simplify()\n    #     dyn_expr_f = dyn_expr_f.simplify()\n    # import pdb; pdb.set_trace()\n\n    return check\n", "third_party/acados/acados_template/gnsf/reformulate_with_invertible_E_mat.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n#   Author: Jonathan Frey: jonathanpaulfrey(at)gmail.com\n\nfrom casadi import *\nfrom .determine_input_nonlinearity_function import determine_input_nonlinearity_function\nfrom .check_reformulation import check_reformulation\n\n\ndef reformulate_with_invertible_E_mat(gnsf, model, print_info):\n    ## Description\n    # this function checks that the necessary condition to apply the gnsf\n    # structure exploiting integrator to a model, namely that the matrices E11,\n    # E22 are invertible holds.\n    # if this is not the case, it will make these matrices invertible and add:\n    # corresponding terms, to the term C * phi, such that the obtained model is\n    # still equivalent\n\n    # check invertibility of E11, E22 and reformulate if needed:\n    ind_11 = range(gnsf[\"nx1\"])\n    ind_22 = range(gnsf[\"nx1\"], gnsf[\"nx1\"] + gnsf[\"nz1\"])\n\n    if print_info:\n        print(\" \")\n        print(\"----------------------------------------------------\")\n        print(\"checking rank of E11 and E22\")\n        print(\"----------------------------------------------------\")\n    ## check if E11, E22 are invertible:\n    z_check = False\n    if gnsf[\"nz1\"] > 0:\n        z_check = (\n            np.linalg.matrix_rank(gnsf[\"E\"][np.ix_(ind_22, ind_22)]) != gnsf[\"nz1\"]\n        )\n\n    if (\n        np.linalg.matrix_rank(gnsf[\"E\"][np.ix_(ind_11, ind_11)]) != gnsf[\"nx1\"]\n        or z_check\n    ):\n        # print warning (always)\n        print(f\"the rank of E11 or E22 is not full after the reformulation\")\n        print(\"\")\n        print(\n            f\"the script will try to reformulate the model with an invertible matrix instead\"\n        )\n        print(\n            f\"NOTE: this feature is based on a heuristic, it should be used with care!!!\"\n        )\n\n        ## load models\n        xdot = gnsf[\"xdot\"]\n        z = gnsf[\"z\"]\n\n        # # GNSF\n        # get dimensions\n        nx1 = gnsf[\"nx1\"]\n        x1dot = xdot[range(nx1)]\n\n        k = vertcat(x1dot, z)\n        for i in [1, 2]:\n            if i == 1:\n                ind = range(gnsf[\"nx1\"])\n            else:\n                ind = range(gnsf[\"nx1\"], gnsf[\"nx1\"] + gnsf[\"nz1\"])\n            mat = gnsf[\"E\"][np.ix_(ind, ind)]\n            import pdb\n\n            pdb.set_trace()\n            while np.linalg.matrix_rank(mat) < len(ind):\n                # import pdb; pdb.set_trace()\n                if print_info:\n                    print(\" \")\n                    print(f\"the rank of E\", str(i), str(i), \" is not full\")\n                    print(\n                        f\"the algorithm will try to reformulate the model with an invertible matrix instead\"\n                    )\n                    print(\n                        f\"NOTE: this feature is not super stable and might need more testing!!!!!!\"\n                    )\n                for sub_max in ind:\n                    sub_ind = range(min(ind), sub_max)\n                    # regard the submatrix mat(sub_ind, sub_ind)\n                    sub_mat = gnsf[\"E\"][sub_ind, sub_ind]\n                    if np.linalg.matrix_rank(sub_mat) < len(sub_ind):\n                        # reformulate the model by adding a 1 to last diagonal\n                        # element and changing rhs respectively.\n                        gnsf[\"E\"][sub_max, sub_max] = gnsf[\"E\"][sub_max, sub_max] + 1\n                        # this means adding the term 1 * k(sub_max) to the sub_max\n                        # row of the l.h.s\n                        if len(np.nonzero(gnsf[\"C\"][sub_max, :])[0]) == 0:\n                            # if isempty(find(gnsf['C'](sub_max,:), 1)):\n                            # add new nonlinearity entry\n                            gnsf[\"C\"][sub_max, gnsf[\"n_out\"] + 1] = 1\n                            gnsf[\"phi_expr\"] = vertcat(gnsf[\"phi_expr\"], k[sub_max])\n                        else:\n                            ind_f = np.nonzero(gnsf[\"C\"][sub_max, :])[0]\n                            if len(ind_f) != 1:\n                                raise Exception(\"C is assumed to be a selection matrix\")\n                            else:\n                                ind_f = ind_f[0]\n                            # add term to corresponding nonlinearity entry\n                            # note: herbey we assume that C is a selection matrix,\n                            # i.e. gnsf['phi_expr'](ind_f) is only entering one equation\n\n                            gnsf[\"phi_expr\"][ind_f] = (\n                                gnsf[\"phi_expr\"][ind_f]\n                                + k[sub_max] / gnsf[\"C\"][sub_max, ind_f]\n                            )\n                            gnsf = determine_input_nonlinearity_function(gnsf)\n                            check_reformulation(model, gnsf, print_info)\n        print(\"successfully reformulated the model with invertible matrices E11, E22\")\n    else:\n        if print_info:\n            print(\" \")\n            print(\n                \"the rank of both E11 and E22 is naturally full after the reformulation \"\n            )\n            print(\"==>  model reformulation finished\")\n            print(\" \")\n    if (gnsf['nx2'] > 0 or gnsf['nz2'] > 0) and det(gnsf[\"E_LO\"]) == 0:\n        print(\n            \"_______________________________________________________________________________________________________\"\n        )\n        print(\" \")\n        print(\"TAKE CARE \")\n        print(\"E_LO matrix is NOT regular after automatic transcription!\")\n        print(\"->> this means the model CANNOT be used with the gnsf integrator\")\n        print(\n            \"->> it probably means that one entry (of xdot or z) that was moved to the linear output type system\"\n        )\n        print(\"    does not appear in the model at all (zero column in E_LO)\")\n        print(\" OR: the columns of E_LO are linearly dependent \")\n        print(\" \")\n        print(\n            \" SOLUTIONs: a) go through your model & check equations the method wanted to move to LOS\"\n        )\n        print(\"            b) deactivate the detect_LOS option\")\n        print(\n            \"_______________________________________________________________________________________________________\"\n        )\n    return gnsf\n", "third_party/acados/acados_template/gnsf/__init__.py": "", "third_party/acados/acados_template/gnsf/reformulate_with_LOS.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n#   Author: Jonathan Frey: jonathanpaulfrey(at)gmail.com\n\nfrom .determine_input_nonlinearity_function import determine_input_nonlinearity_function\nfrom .check_reformulation import check_reformulation\nfrom casadi import *\nfrom ..utils import casadi_length, idx_perm_to_ipiv, is_empty\n\n\ndef reformulate_with_LOS(acados_ocp, gnsf, print_info):\n\n    ## Description:\n    # This function takes an intitial transcription of the implicit ODE model\n    # \"model\" into \"gnsf\" and reformulates \"gnsf\" with a linear output system\n    # (LOS), containing as many states of the model as possible.\n    # Therefore it might be that the state vector and the implicit function\n    # vector have to be reordered. This reordered model is part of the output,\n    # namely reordered_model.\n\n    ## import CasADi and load models\n    model = acados_ocp.model\n\n    # symbolics\n    x = gnsf[\"x\"]\n    xdot = gnsf[\"xdot\"]\n    u = gnsf[\"u\"]\n    z = gnsf[\"z\"]\n\n    # dimensions\n    nx = gnsf[\"nx\"]\n    nz = gnsf[\"nz\"]\n\n    # get model matrices\n    A = gnsf[\"A\"]\n    B = gnsf[\"B\"]\n    C = gnsf[\"C\"]\n    E = gnsf[\"E\"]\n    c = gnsf[\"c\"]\n\n    A_LO = gnsf[\"A_LO\"]\n\n    y = gnsf[\"y\"]\n\n    phi_old = gnsf[\"phi_expr\"]\n\n    if print_info:\n        print(\" \")\n        print(\"=================================================================\")\n        print(\" \")\n        print(\"================    Detect Linear Output System   ===============\")\n        print(\" \")\n        print(\"=================================================================\")\n        print(\" \")\n    ## build initial I_x1 and I_x2_candidates\n    # I_xrange( all components of x for which either xii or xdot_ii enters y):\n    # I_LOS_candidates: the remaining components\n\n    I_nsf_components = set()\n    I_LOS_candidates = set()\n\n    if gnsf[\"ny\"] > 0:\n        for ii in range(nx):\n            if which_depends(y, x[ii])[0] or which_depends(y, xdot[ii])[0]:\n                # i.e. xii or xiidot are part of y, and enter phi_expr\n                if print_info:\n                    print(f\"x_{ii} is part of x1\")\n                I_nsf_components = set.union(I_nsf_components, set([ii]))\n            else:\n                # i.e. neither xii nor xiidot are part of y, i.e. enter phi_expr\n                I_LOS_candidates = set.union(I_LOS_candidates, set([ii]))\n                if print_info:\n                    print(\" \")\n        for ii in range(nz):\n            if which_depends(y, z[ii])[0]:\n                # i.e. xii or xiidot are part of y, and enter phi_expr\n                if print_info:\n                    print(f\"z_{ii} is part of x1\")\n                I_nsf_components = set.union(I_nsf_components, set([ii + nx]))\n            else:\n                # i.e. neither xii nor xiidot are part of y, i.e. enter phi_expr\n                I_LOS_candidates = set.union(I_LOS_candidates, set([ii + nx]))\n    else:\n        I_LOS_candidates = set(range((nx + nz)))\n    if print_info:\n        print(\" \")\n        print(f\"I_LOS_candidates {I_LOS_candidates}\")\n    new_nsf_components = I_nsf_components\n    I_nsf_eq = set([])\n    unsorted_dyn = set(range(nx + nz))\n    xdot_z = vertcat(xdot, z)\n\n    ## determine components of Linear Output System\n    # determine maximal index set I_x2\n    # such that the components x(I_x2) can be written as a LOS\n    Eq_map = []\n    while True:\n        ## find equations corresponding to new_nsf_components\n        for ii in new_nsf_components:\n            current_var = xdot_z[ii]\n            var_name = current_var.name\n\n            # print( unsorted_dyn)\n            # print(\"np.nonzero(E[:,ii])[0]\",np.nonzero(E[:,ii])[0])\n            I_eq = set.intersection(set(np.nonzero(E[:, ii])[0]), unsorted_dyn)\n            if len(I_eq) == 1:\n                i_eq = I_eq.pop()\n                if print_info:\n                    print(f\"component {i_eq} is associated with state {ii}\")\n            elif len(I_eq) > 1:  # x_ii_dot occurs in more than 1 eq linearly\n                # find the equation with least linear dependencies on\n                # I_LOS_cancidates\n                number_of_eq = 0\n                candidate_dependencies = np.zeros(len(I_eq), 1)\n                I_x2_candidates = set.intersection(I_LOS_candidates, set(range(nx)))\n                for eq in I_eq:\n                    depending_candidates = set.union(\n                        np.nonzero(E[eq, I_LOS_candidates])[0],\n                        np.nonzero(A[eq, I_x2_candidates])[0],\n                    )\n                    candidate_dependencies[number_of_eq] = +len(depending_candidates)\n                    number_of_eq += 1\n                    number_of_eq = np.argmin(candidate_dependencies)\n                i_eq = I_eq[number_of_eq]\n            else:  ## x_ii_dot does not occur linearly in any of the unsorted dynamics\n                for j in unsorted_dyn:\n                    phi_eq_j = gnsf[\"phi_expr\"][np.nonzero(C[j, :])[0]]\n                    if which_depends(phi_eq_j, xdot_z(ii))[0]:\n                        I_eq = set.union(I_eq, j)\n                if is_empty(I_eq):\n                    I_eq = unsorted_dyn\n                # find the equation with least linear dependencies on I_LOS_cancidates\n                number_of_eq = 0\n                candidate_dependencies = np.zeros(len(I_eq), 1)\n                I_x2_candidates = set.intersection(I_LOS_candidates, set(range(nx)))\n                for eq in I_eq:\n                    depending_candidates = set.union(\n                        np.nonzero(E[eq, I_LOS_candidates])[0],\n                        np.nonzero(A[eq, I_x2_candidates])[0],\n                    )\n                    candidate_dependencies[number_of_eq] = +len(depending_candidates)\n                    number_of_eq += 1\n                    number_of_eq = np.argmin(candidate_dependencies)\n                i_eq = I_eq[number_of_eq]\n                ## add 1 * [xdot,z](ii) to both sides of i_eq\n                if print_info:\n                    print(\n                        \"adding 1 * \",\n                        var_name,\n                        \" to both sides of equation \",\n                        i_eq,\n                        \".\",\n                    )\n                gnsf[\"E\"][i_eq, ii] = 1\n                i_phi = np.nonzero(gnsf[\"C\"][i_eq, :])\n                if is_empty(i_phi):\n                    i_phi = len(gnsf[\"phi_expr\"]) + 1\n                    gnsf[\"C\"][i_eq, i_phi] = 1  # add column to C with 1 entry\n                    gnsf[\"phi_expr\"] = vertcat(gnsf[\"phi_expr\"], 0)\n                    gnsf[\"phi_expr\"][i_phi] = (\n                        gnsf[\"phi_expr\"](i_phi)\n                        + gnsf[\"E\"][i_eq, ii] / gnsf[\"C\"][i_eq, i_phi] * xdot_z[ii]\n                    )\n                if print_info:\n                    print(\n                        \"detected equation \",\n                        i_eq,\n                        \" to correspond to variable \",\n                        var_name,\n                    )\n            I_nsf_eq = set.union(I_nsf_eq, {i_eq})\n            # remove i_eq from unsorted_dyn\n            unsorted_dyn.remove(i_eq)\n            Eq_map.append([ii, i_eq])\n\n        ## add components to I_x1\n        for eq in I_nsf_eq:\n            I_linear_dependence = set.union(\n                set(np.nonzero(A[eq, :])[0]), set(np.nonzero(E[eq, :])[0])\n            )\n            I_nsf_components = set.union(I_linear_dependence, I_nsf_components)\n            # I_nsf_components = I_nsf_components[:]\n\n        new_nsf_components = set.intersection(I_LOS_candidates, I_nsf_components)\n        if is_empty(new_nsf_components):\n            if print_info:\n                print(\"new_nsf_components is empty\")\n            break\n        # remove new_nsf_components from candidates\n        I_LOS_candidates = set.difference(I_LOS_candidates, new_nsf_components)\n    if not is_empty(Eq_map):\n        # [~, new_eq_order] = sort(Eq_map(1,:))\n        # I_nsf_eq = Eq_map(2, new_eq_order )\n        for count, m in enumerate(Eq_map):\n            m.append(count)\n        sorted(Eq_map, key=lambda x: x[1])\n        new_eq_order = [m[2] for m in Eq_map]\n        Eq_map = [Eq_map[i] for i in new_eq_order]\n        I_nsf_eq = [m[1] for m in Eq_map]\n\n    else:\n        I_nsf_eq = []\n\n    I_LOS_components = I_LOS_candidates\n    I_LOS_eq = sorted(set.difference(set(range(nx + nz)), I_nsf_eq))\n    I_nsf_eq = sorted(I_nsf_eq)\n\n    I_x1 = set.intersection(I_nsf_components, set(range(nx)))\n    I_z1 = set.intersection(I_nsf_components, set(range(nx, nx + nz)))\n    I_z1 = set([i - nx for i in I_z1])\n\n    I_x2 = set.intersection(I_LOS_components, set(range(nx)))\n    I_z2 = set.intersection(I_LOS_components, set(range(nx, nx + nz)))\n    I_z2 = set([i - nx for i in I_z2])\n\n    if print_info:\n        print(f\"I_x1 {I_x1}, I_x2 {I_x2}\")\n\n    ## permute x, xdot\n    if is_empty(I_x1):\n        x1 = []\n        x1dot = []\n    else:\n        x1 = x[list(I_x1)]\n        x1dot = xdot[list(I_x1)]\n    if is_empty(I_x2):\n        x2 = []\n        x2dot = []\n    else:\n        x2 = x[list(I_x2)]\n        x2dot = xdot[list(I_x2)]\n    if is_empty(I_z1):\n        z1 = []\n    else:\n        z1 = z(I_z1)\n    if is_empty(I_z2):\n        z2 = []\n    else:\n        z2 = z[list(I_z2)]\n\n    I_x1 = sorted(I_x1)\n    I_x2 = sorted(I_x2)\n    I_z1 = sorted(I_z1)\n    I_z2 = sorted(I_z2)\n    gnsf[\"xdot\"] = vertcat(x1dot, x2dot)\n    gnsf[\"x\"] = vertcat(x1, x2)\n    gnsf[\"z\"] = vertcat(z1, z2)\n    gnsf[\"nx1\"] = len(I_x1)\n    gnsf[\"nx2\"] = len(I_x2)\n    gnsf[\"nz1\"] = len(I_z1)\n    gnsf[\"nz2\"] = len(I_z2)\n\n    # store permutations\n    gnsf[\"idx_perm_x\"] = I_x1 + I_x2\n    gnsf[\"ipiv_x\"] = idx_perm_to_ipiv(gnsf[\"idx_perm_x\"])\n    gnsf[\"idx_perm_z\"] = I_z1 + I_z2\n    gnsf[\"ipiv_z\"] = idx_perm_to_ipiv(gnsf[\"idx_perm_z\"])\n    gnsf[\"idx_perm_f\"] = I_nsf_eq + I_LOS_eq\n    gnsf[\"ipiv_f\"] = idx_perm_to_ipiv(gnsf[\"idx_perm_f\"])\n\n    f_LO = SX.sym(\"f_LO\", 0, 0)\n\n    ## rewrite I_LOS_eq as LOS\n    if gnsf[\"n_out\"] == 0:\n        C_phi = np.zeros(gnsf[\"nx\"] + gnsf[\"nz\"], 1)\n    else:\n        C_phi = C @ phi_old\n    if gnsf[\"nx1\"] == 0:\n        Ax1 = np.zeros(gnsf[\"nx\"] + gnsf[\"nz\"], 1)\n    else:\n        Ax1 = A[:, sorted(I_x1)] @ x1\n    if gnsf[\"nx1\"] + gnsf[\"nz1\"] == 0:\n        lhs_nsf = np.zeros(gnsf[\"nx\"] + gnsf[\"nz\"], 1)\n    else:\n        lhs_nsf = E[:, sorted(I_nsf_components)] @ vertcat(x1, z1)\n    n_LO = len(I_LOS_eq)\n    B_LO = np.zeros((n_LO, gnsf[\"nu\"]))\n    A_LO = np.zeros((gnsf[\"nx2\"] + gnsf[\"nz2\"], gnsf[\"nx2\"]))\n    E_LO = np.zeros((n_LO, n_LO))\n    c_LO = np.zeros((n_LO, 1))\n\n    I_LOS_eq = list(I_LOS_eq)\n    for eq in I_LOS_eq:\n        i_LO = I_LOS_eq.index(eq)\n        f_LO = vertcat(f_LO, Ax1[eq] + C_phi[eq] - lhs_nsf[eq])\n        print(f\"eq {eq} I_LOS_components {I_LOS_components}, i_LO {i_LO}, f_LO {f_LO}\")\n        E_LO[i_LO, :] = E[eq, sorted(I_LOS_components)]\n        A_LO[i_LO, :] = A[eq, I_x2]\n        c_LO[i_LO, :] = c[eq]\n        B_LO[i_LO, :] = B[eq, :]\n    if casadi_length(f_LO) == 0:\n        f_LO = SX.zeros((gnsf[\"nx2\"] + gnsf[\"nz2\"], 1))\n    f_LO = simplify(f_LO)\n    gnsf[\"A_LO\"] = A_LO\n    gnsf[\"E_LO\"] = E_LO\n    gnsf[\"B_LO\"] = B_LO\n    gnsf[\"c_LO\"] = c_LO\n    gnsf[\"f_lo_expr\"] = f_LO\n\n    ## remove I_LOS_eq from NSF type system\n    gnsf[\"A\"] = gnsf[\"A\"][np.ix_(sorted(I_nsf_eq), sorted(I_x1))]\n    gnsf[\"B\"] = gnsf[\"B\"][sorted(I_nsf_eq), :]\n    gnsf[\"C\"] = gnsf[\"C\"][sorted(I_nsf_eq), :]\n    gnsf[\"E\"] = gnsf[\"E\"][np.ix_(sorted(I_nsf_eq), sorted(I_nsf_components))]\n    gnsf[\"c\"] = gnsf[\"c\"][sorted(I_nsf_eq), :]\n\n    ## reduce phi, C\n    I_nonzero = []\n    for ii in range(gnsf[\"C\"].shape[1]):  # n_colums of C:\n        print(f\"ii {ii}\")\n        if not all(gnsf[\"C\"][:, ii] == 0):  # if column ~= 0\n            I_nonzero.append(ii)\n    gnsf[\"C\"] = gnsf[\"C\"][:, I_nonzero]\n    gnsf[\"phi_expr\"] = gnsf[\"phi_expr\"][I_nonzero]\n\n    gnsf = determine_input_nonlinearity_function(gnsf)\n\n    check_reformulation(model, gnsf, print_info)\n\n    gnsf[\"nontrivial_f_LO\"] = 0\n    if not is_empty(gnsf[\"f_lo_expr\"]):\n        for ii in range(casadi_length(gnsf[\"f_lo_expr\"])):\n            fii = gnsf[\"f_lo_expr\"][ii]\n            if not fii.is_zero():\n                gnsf[\"nontrivial_f_LO\"] = 1\n            if not gnsf[\"nontrivial_f_LO\"] and print_info:\n                print(\"f_LO is fully trivial (== 0)\")\n    check_reformulation(model, gnsf, print_info)\n\n    if print_info:\n        print(\"\")\n        print(\n            \"---------------------------------------------------------------------------------\"\n        )\n        print(\n            \"------------- Success: Linear Output System (LOS) detected ----------------------\"\n        )\n        print(\n            \"---------------------------------------------------------------------------------\"\n        )\n        print(\"\")\n        print(\n            \"==>>  moved  \",\n            gnsf[\"nx2\"],\n            \"differential states and \",\n            gnsf[\"nz2\"],\n            \" algebraic variables to the Linear Output System\",\n        )\n        print(\n            \"==>>  recuced output dimension of phi from  \",\n            casadi_length(phi_old),\n            \" to \",\n            casadi_length(gnsf[\"phi_expr\"]),\n        )\n        print(\" \")\n        print(\"Matrices defining the LOS read as\")\n        print(\" \")\n        print(\"E_LO =\")\n        print(gnsf[\"E_LO\"])\n        print(\"A_LO =\")\n        print(gnsf[\"A_LO\"])\n        print(\"B_LO =\")\n        print(gnsf[\"B_LO\"])\n        print(\"c_LO =\")\n        print(gnsf[\"c_LO\"])\n\n    return gnsf\n", "third_party/acados/acados_template/gnsf/determine_trivial_gnsf_transcription.py": "#\n# Copyright (c) The acados authors.\n#\n# This file is part of acados.\n#\n# The 2-Clause BSD License\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.;\n#\n\nfrom casadi import *\nimport numpy as np\nfrom ..utils import casadi_length, idx_perm_to_ipiv\nfrom .determine_input_nonlinearity_function import determine_input_nonlinearity_function\nfrom .check_reformulation import check_reformulation\n\n\ndef determine_trivial_gnsf_transcription(acados_ocp, print_info):\n    ## Description\n    # this function takes a model of an implicit ODE/ index-1 DAE and sets up\n    # an equivalent model in the GNSF structure, with empty linear output\n    # system and trivial model matrices, i.e. A, B, E, c are zeros, and C is\n    # eye. - no structure is exploited\n\n    model = acados_ocp.model\n    # initial print\n    print(\"*****************************************************************\")\n    print(\" \")\n    print(f\"******      Restructuring {model.name} model    ***********\")\n    print(\" \")\n    print(\"*****************************************************************\")\n\n    # load model\n    f_impl_expr = model.f_impl_expr\n\n    model_name_prefix = model.name\n\n    # x\n    x = model.x\n    nx = acados_ocp.dims.nx\n    # check type\n    if isinstance(x[0], SX):\n        isSX = True\n    else:\n        print(\"GNSF detection only works for SX CasADi type!!!\")\n        import pdb\n\n        pdb.set_trace()\n    # xdot\n    xdot = model.xdot\n    # u\n    nu = acados_ocp.dims.nu\n    if nu == 0:\n        u = SX.sym(\"u\", 0, 0)\n    else:\n        u = model.u\n\n    nz = acados_ocp.dims.nz\n    if nz == 0:\n        z = SX.sym(\"z\", 0, 0)\n    else:\n        z = model.z\n\n    p = model.p\n    nparam = acados_ocp.dims.np\n\n    # avoid SX of size 0x1\n    if casadi_length(u) == 0:\n        u = SX.sym(\"u\", 0, 0)\n        nu = 0\n    ## initialize gnsf struct\n    # dimensions\n    gnsf = {\"nx\": nx, \"nu\": nu, \"nz\": nz, \"np\": nparam}\n    gnsf[\"nx1\"] = nx\n    gnsf[\"nx2\"] = 0\n    gnsf[\"nz1\"] = nz\n    gnsf[\"nz2\"] = 0\n    gnsf[\"nuhat\"] = nu\n    gnsf[\"ny\"] = 2 * nx + nz\n\n    gnsf[\"phi_expr\"] = f_impl_expr\n    gnsf[\"A\"] = np.zeros((nx + nz, nx))\n    gnsf[\"B\"] = np.zeros((nx + nz, nu))\n    gnsf[\"E\"] = np.zeros((nx + nz, nx + nz))\n    gnsf[\"c\"] = np.zeros((nx + nz, 1))\n    gnsf[\"C\"] = np.eye(nx + nz)\n    gnsf[\"name\"] = model_name_prefix\n\n    gnsf[\"x\"] = x\n    gnsf[\"xdot\"] = xdot\n    gnsf[\"z\"] = z\n    gnsf[\"u\"] = u\n    gnsf[\"p\"] = p\n\n    gnsf = determine_input_nonlinearity_function(gnsf)\n\n    gnsf[\"A_LO\"] = []\n    gnsf[\"E_LO\"] = []\n    gnsf[\"B_LO\"] = []\n    gnsf[\"c_LO\"] = []\n    gnsf[\"f_lo_expr\"] = []\n\n    # permutation\n    gnsf[\"idx_perm_x\"] = range(nx)  # matlab-style)\n    gnsf[\"ipiv_x\"] = idx_perm_to_ipiv(gnsf[\"idx_perm_x\"])  # blasfeo-style\n    gnsf[\"idx_perm_z\"] = range(nz)\n    gnsf[\"ipiv_z\"] = idx_perm_to_ipiv(gnsf[\"idx_perm_z\"])\n    gnsf[\"idx_perm_f\"] = range((nx + nz))\n    gnsf[\"ipiv_f\"] = idx_perm_to_ipiv(gnsf[\"idx_perm_f\"])\n\n    gnsf[\"nontrivial_f_LO\"] = 0\n\n    check_reformulation(model, gnsf, print_info)\n    if print_info:\n        print(f\"Success: Set up equivalent GNSF model with trivial matrices\")\n        print(\" \")\n    if print_info:\n        print(\n            \"-----------------------------------------------------------------------------------\"\n        )\n        print(\" \")\n        print(\n            \"reduced input ny    of phi from  \",\n            str(2 * nx + nz),\n            \"   to  \",\n            str(gnsf[\"ny\"]),\n        )\n        print(\n            \"reduced input nuhat of phi from  \", str(nu), \"   to  \", str(gnsf[\"nuhat\"])\n        )\n        print(\" \")\n        print(\n            \"-----------------------------------------------------------------------------------\"\n        )\n    return gnsf\n", "cereal/services.py": "#!/usr/bin/env python3\nfrom typing import Optional\n\n\nclass Service:\n  def __init__(self, should_log: bool, frequency: float, decimation: Optional[int] = None):\n    self.should_log = should_log\n    self.frequency = frequency\n    self.decimation = decimation\n\n\n_services: dict[str, tuple] = {\n  # service: (should_log, frequency, qlog decimation (optional))\n  # note: the \"EncodeIdx\" packets will still be in the log\n  \"gyroscope\": (True, 104., 104),\n  \"gyroscope2\": (True, 100., 100),\n  \"accelerometer\": (True, 104., 104),\n  \"accelerometer2\": (True, 100., 100),\n  \"magnetometer\": (True, 25., 25),\n  \"lightSensor\": (True, 100., 100),\n  \"temperatureSensor\": (True, 2., 200),\n  \"temperatureSensor2\": (True, 2., 200),\n  \"gpsNMEA\": (True, 9.),\n  \"deviceState\": (True, 2., 1),\n  \"can\": (True, 100., 1223),  # decimation gives ~5 msgs in a full segment\n  \"controlsState\": (True, 100., 10),\n  \"pandaStates\": (True, 10., 1),\n  \"peripheralState\": (True, 2., 1),\n  \"radarState\": (True, 20., 5),\n  \"roadEncodeIdx\": (False, 20., 1),\n  \"liveTracks\": (True, 20.),\n  \"sendcan\": (True, 100., 139),\n  \"logMessage\": (True, 0.),\n  \"errorLogMessage\": (True, 0., 1),\n  \"liveCalibration\": (True, 4., 4),\n  \"liveTorqueParameters\": (True, 4., 1),\n  \"androidLog\": (True, 0.),\n  \"carState\": (True, 100., 10),\n  \"carControl\": (True, 100., 10),\n  \"carOutput\": (True, 100., 10),\n  \"longitudinalPlan\": (True, 20., 5),\n  \"procLog\": (True, 0.5, 15),\n  \"gpsLocationExternal\": (True, 10., 10),\n  \"gpsLocation\": (True, 1., 1),\n  \"ubloxGnss\": (True, 10.),\n  \"qcomGnss\": (True, 2.),\n  \"gnssMeasurements\": (True, 10., 10),\n  \"clocks\": (True, 0.1, 1),\n  \"ubloxRaw\": (True, 20.),\n  \"liveLocationKalman\": (True, 20., 5),\n  \"liveParameters\": (True, 20., 5),\n  \"cameraOdometry\": (True, 20., 5),\n  \"thumbnail\": (True, 0.2, 1),\n  \"onroadEvents\": (True, 1., 1),\n  \"carParams\": (True, 0.02, 1),\n  \"roadCameraState\": (True, 20., 20),\n  \"driverCameraState\": (True, 20., 20),\n  \"driverEncodeIdx\": (False, 20., 1),\n  \"driverStateV2\": (True, 20., 10),\n  \"driverMonitoringState\": (True, 20., 10),\n  \"wideRoadEncodeIdx\": (False, 20., 1),\n  \"wideRoadCameraState\": (True, 20., 20),\n  \"modelV2\": (True, 20., 40),\n  \"managerState\": (True, 2., 1),\n  \"uploaderState\": (True, 0., 1),\n  \"navInstruction\": (True, 1., 10),\n  \"navRoute\": (True, 0.),\n  \"navThumbnail\": (True, 0.),\n  \"qRoadEncodeIdx\": (False, 20.),\n  \"userFlag\": (True, 0., 1),\n  \"microphone\": (True, 10., 10),\n\n  # debug\n  \"uiDebug\": (True, 0., 1),\n  \"testJoystick\": (True, 0.),\n  \"roadEncodeData\": (False, 20.),\n  \"driverEncodeData\": (False, 20.),\n  \"wideRoadEncodeData\": (False, 20.),\n  \"qRoadEncodeData\": (False, 20.),\n  \"livestreamWideRoadEncodeIdx\": (False, 20.),\n  \"livestreamRoadEncodeIdx\": (False, 20.),\n  \"livestreamDriverEncodeIdx\": (False, 20.),\n  \"livestreamWideRoadEncodeData\": (False, 20.),\n  \"livestreamRoadEncodeData\": (False, 20.),\n  \"livestreamDriverEncodeData\": (False, 20.),\n  \"customReservedRawData0\": (True, 0.),\n  \"customReservedRawData1\": (True, 0.),\n  \"customReservedRawData2\": (True, 0.),\n}\nSERVICE_LIST = {name: Service(*vals) for\n                idx, (name, vals) in enumerate(_services.items())}\n\n\ndef build_header():\n  h = \"\"\n  h += \"/* THIS IS AN AUTOGENERATED FILE, PLEASE EDIT services.py */\\n\"\n  h += \"#ifndef __SERVICES_H\\n\"\n  h += \"#define __SERVICES_H\\n\"\n\n  h += \"#include <map>\\n\"\n  h += \"#include <string>\\n\"\n\n  h += \"struct service { std::string name; bool should_log; int frequency; int decimation; };\\n\"\n  h += \"static std::map<std::string, service> services = {\\n\"\n  for k, v in SERVICE_LIST.items():\n    should_log = \"true\" if v.should_log else \"false\"\n    decimation = -1 if v.decimation is None else v.decimation\n    h += '  { \"%s\", {\"%s\", %s, %d, %d}},\\n' % \\\n         (k, k, should_log, v.frequency, decimation)\n  h += \"};\\n\"\n\n  h += \"#endif\\n\"\n  return h\n\n\nif __name__ == \"__main__\":\n  print(build_header())\n", "cereal/__init__.py": "import os\nimport capnp\n\nCEREAL_PATH = os.path.dirname(os.path.abspath(__file__))\ncapnp.remove_import_hook()\n\nlog = capnp.load(os.path.join(CEREAL_PATH, \"log.capnp\"))\ncar = capnp.load(os.path.join(CEREAL_PATH, \"car.capnp\"))\ncustom = capnp.load(os.path.join(CEREAL_PATH, \"custom.capnp\"))\n", "cereal/messaging/__init__.py": "# must be built with scons\nfrom msgq.ipc_pyx import Context, Poller, SubSocket, PubSocket, SocketEventHandle, toggle_fake_events, \\\n                                set_fake_prefix, get_fake_prefix, delete_fake_prefix, wait_for_one_event\nfrom msgq.ipc_pyx import MultiplePublishersError, IpcError\nfrom msgq import fake_event_handle, pub_sock, sub_sock, drain_sock_raw, context\n\nimport os\nimport capnp\nimport time\n\nfrom typing import Optional, List, Union, Dict, Deque\nfrom collections import deque\n\nfrom cereal import log\nfrom cereal.services import SERVICE_LIST\n\nNO_TRAVERSAL_LIMIT = 2**64-1\n\n\ndef log_from_bytes(dat: bytes) -> capnp.lib.capnp._DynamicStructReader:\n  with log.Event.from_bytes(dat, traversal_limit_in_words=NO_TRAVERSAL_LIMIT) as msg:\n    return msg\n\n\ndef new_message(service: Optional[str], size: Optional[int] = None, **kwargs) -> capnp.lib.capnp._DynamicStructBuilder:\n  args = {\n    'valid': False,\n    'logMonoTime': int(time.monotonic() * 1e9),\n    **kwargs\n  }\n  dat = log.Event.new_message(**args)\n  if service is not None:\n    if size is None:\n      dat.init(service)\n    else:\n      dat.init(service, size)\n  return dat\n\n\ndef drain_sock(sock: SubSocket, wait_for_one: bool = False) -> List[capnp.lib.capnp._DynamicStructReader]:\n  \"\"\"Receive all message currently available on the queue\"\"\"\n  msgs = drain_sock_raw(sock, wait_for_one=wait_for_one)\n  return [log_from_bytes(m) for m in msgs]\n\n\n# TODO: print when we drop packets?\ndef recv_sock(sock: SubSocket, wait: bool = False) -> Optional[capnp.lib.capnp._DynamicStructReader]:\n  \"\"\"Same as drain sock, but only returns latest message. Consider using conflate instead.\"\"\"\n  dat = None\n\n  while 1:\n    if wait and dat is None:\n      recv = sock.receive()\n    else:\n      recv = sock.receive(non_blocking=True)\n\n    if recv is None:  # Timeout hit\n      break\n\n    dat = recv\n\n  if dat is not None:\n    dat = log_from_bytes(dat)\n\n  return dat\n\n\ndef recv_one(sock: SubSocket) -> Optional[capnp.lib.capnp._DynamicStructReader]:\n  dat = sock.receive()\n  if dat is not None:\n    dat = log_from_bytes(dat)\n  return dat\n\n\ndef recv_one_or_none(sock: SubSocket) -> Optional[capnp.lib.capnp._DynamicStructReader]:\n  dat = sock.receive(non_blocking=True)\n  if dat is not None:\n    dat = log_from_bytes(dat)\n  return dat\n\n\ndef recv_one_retry(sock: SubSocket) -> capnp.lib.capnp._DynamicStructReader:\n  \"\"\"Keep receiving until we get a message\"\"\"\n  while True:\n    dat = sock.receive()\n    if dat is not None:\n      return log_from_bytes(dat)\n\n\nclass SubMaster:\n  def __init__(self, services: List[str], poll: Optional[str] = None,\n               ignore_alive: Optional[List[str]] = None, ignore_avg_freq: Optional[List[str]] = None,\n               ignore_valid: Optional[List[str]] = None, addr: str = \"127.0.0.1\", frequency: Optional[float] = None):\n    self.frame = -1\n    self.seen = {s: False for s in services}\n    self.updated = {s: False for s in services}\n    self.recv_time = {s: 0. for s in services}\n    self.recv_frame = {s: 0 for s in services}\n    self.alive = {s: False for s in services}\n    self.freq_ok = {s: False for s in services}\n    self.recv_dts: Dict[str, Deque[float]] = {}\n    self.sock = {}\n    self.data = {}\n    self.valid = {}\n    self.logMonoTime = {}\n\n    self.max_freq = {}\n    self.min_freq = {}\n\n    self.poller = Poller()\n    polled_services = set([poll, ] if poll is not None else services)\n    self.non_polled_services = set(services) - polled_services\n\n    self.ignore_average_freq = [] if ignore_avg_freq is None else ignore_avg_freq\n    self.ignore_alive = [] if ignore_alive is None else ignore_alive\n    self.ignore_valid = [] if ignore_valid is None else ignore_valid\n\n    self.simulation = bool(int(os.getenv(\"SIMULATION\", \"0\")))\n\n    # if freq and poll aren't specified, assume the max to be conservative\n    assert frequency is None or poll is None, \"Do not specify 'frequency' - frequency of the polled service will be used.\"\n    self.update_freq = frequency or max([SERVICE_LIST[s].frequency for s in polled_services])\n\n    for s in services:\n      p = self.poller if s not in self.non_polled_services else None\n      self.sock[s] = sub_sock(s, poller=p, addr=addr, conflate=True)\n\n      try:\n        data = new_message(s)\n      except capnp.lib.capnp.KjException:\n        data = new_message(s, 0) # lists\n\n      self.data[s] = getattr(data.as_reader(), s)\n      self.logMonoTime[s] = 0\n      self.valid[s] = True  # FIXME: this should default to False\n\n      freq = max(min([SERVICE_LIST[s].frequency, self.update_freq]), 1.)\n      if s == poll:\n        max_freq = freq\n        min_freq = freq\n      else:\n        max_freq = min(freq, self.update_freq)\n        if SERVICE_LIST[s].frequency >= 2*self.update_freq:\n          min_freq = self.update_freq\n        elif self.update_freq >= 2*SERVICE_LIST[s].frequency:\n          min_freq = freq\n        else:\n          min_freq = min(freq, freq / 2.)\n      self.max_freq[s] = max_freq*1.2\n      self.min_freq[s] = min_freq*0.8\n      self.recv_dts[s] = deque(maxlen=int(10*freq))\n\n  def __getitem__(self, s: str) -> capnp.lib.capnp._DynamicStructReader:\n    return self.data[s]\n\n  def _check_avg_freq(self, s: str) -> bool:\n    return SERVICE_LIST[s].frequency > 0.99 and (s not in self.ignore_average_freq) and (s not in self.ignore_alive)\n\n  def update(self, timeout: int = 100) -> None:\n    msgs = []\n    for sock in self.poller.poll(timeout):\n      msgs.append(recv_one_or_none(sock))\n\n    # non-blocking receive for non-polled sockets\n    for s in self.non_polled_services:\n      msgs.append(recv_one_or_none(self.sock[s]))\n    self.update_msgs(time.monotonic(), msgs)\n\n  def update_msgs(self, cur_time: float, msgs: List[capnp.lib.capnp._DynamicStructReader]) -> None:\n    self.frame += 1\n    self.updated = dict.fromkeys(self.updated, False)\n    for msg in msgs:\n      if msg is None:\n        continue\n\n      s = msg.which()\n      self.seen[s] = True\n      self.updated[s] = True\n\n      if self.recv_time[s] > 1e-5:\n        self.recv_dts[s].append(cur_time - self.recv_time[s])\n      self.recv_time[s] = cur_time\n      self.recv_frame[s] = self.frame\n      self.data[s] = getattr(msg, s)\n      self.logMonoTime[s] = msg.logMonoTime\n      self.valid[s] = msg.valid\n\n    for s in self.data:\n      if SERVICE_LIST[s].frequency > 1e-5 and not self.simulation:\n        # alive if delay is within 10x the expected frequency\n        self.alive[s] = (cur_time - self.recv_time[s]) < (10. / SERVICE_LIST[s].frequency)\n\n        # check average frequency; slow to fall, quick to recover\n        dts = self.recv_dts[s]\n        assert dts.maxlen is not None\n        recent_dts = list(dts)[-int(dts.maxlen / 10):]\n        try:\n          avg_freq = 1 / (sum(dts) / len(dts))\n          avg_freq_recent = 1 / (sum(recent_dts) / len(recent_dts))\n        except ZeroDivisionError:\n          avg_freq = 0\n          avg_freq_recent = 0\n\n        avg_freq_ok = self.min_freq[s] <= avg_freq <= self.max_freq[s]\n        recent_freq_ok = self.min_freq[s] <= avg_freq_recent <= self.max_freq[s]\n        self.freq_ok[s] = avg_freq_ok or recent_freq_ok\n      else:\n        self.freq_ok[s] = True\n        if self.simulation:\n          self.alive[s] = self.seen[s] # alive is defined as seen when simulation flag set\n        else:\n          self.alive[s] = True\n\n  def all_alive(self, service_list: Optional[List[str]] = None) -> bool:\n    if service_list is None:\n      service_list = list(self.sock.keys())\n    return all(self.alive[s] for s in service_list if s not in self.ignore_alive)\n\n  def all_freq_ok(self, service_list: Optional[List[str]] = None) -> bool:\n    if service_list is None:\n      service_list = list(self.sock.keys())\n    return all(self.freq_ok[s] for s in service_list if self._check_avg_freq(s))\n\n  def all_valid(self, service_list: Optional[List[str]] = None) -> bool:\n    if service_list is None:\n      service_list = list(self.sock.keys())\n    return all(self.valid[s] for s in service_list if s not in self.ignore_valid)\n\n  def all_checks(self, service_list: Optional[List[str]] = None) -> bool:\n    return self.all_alive(service_list) and self.all_freq_ok(service_list) and self.all_valid(service_list)\n\n\nclass PubMaster:\n  def __init__(self, services: List[str]):\n    self.sock = {}\n    for s in services:\n      self.sock[s] = pub_sock(s)\n\n  def send(self, s: str, dat: Union[bytes, capnp.lib.capnp._DynamicStructBuilder]) -> None:\n    if not isinstance(dat, bytes):\n      dat = dat.to_bytes()\n    self.sock[s].send(dat)\n\n  def wait_for_readers_to_update(self, s: str, timeout: int, dt: float = 0.05) -> bool:\n    for _ in range(int(timeout*(1./dt))):\n      if self.sock[s].all_readers_updated():\n        return True\n      time.sleep(dt)\n    return False\n\n  def all_readers_updated(self, s: str) -> bool:\n    return self.sock[s].all_readers_updated()  # type: ignore\n", ".github/build.py": "import pathlib\n\nGITHUB_FOLDER = pathlib.Path(__file__).parent\n\nPULL_REQUEST_TEMPLATES = (GITHUB_FOLDER / \"PULL_REQUEST_TEMPLATE\")\n\norder = [\"fingerprint\", \"car_bugfix\", \"bugfix\", \"car_port\", \"refactor\"]\n\ndef create_pull_request_template():\n  with open(GITHUB_FOLDER / \"pull_request_template.md\", \"w\") as f:\n    f.write(\"<!-- Please copy and paste the relevant template -->\\n\\n\")\n\n    for t in order:\n      template = PULL_REQUEST_TEMPLATES / f\"{t}.md\"\n      text = template.read_text()\n\n      # Remove metadata for GitHub\n      start = text.find(\"---\")\n      end = text.find(\"---\", start+1)\n      text = text[end + 4:]\n\n      # Remove comments\n      text = text.replace(\"<!-- \", \"\").replace(\"-->\", \"\")\n\n      f.write(f\"<!--- ***** Template: {template.stem.replace('_', ' ').title()} *****\\n\")\n      f.write(text)\n      f.write(\"\\n\\n\")\n      f.write(\"-->\\n\\n\")\n\ncreate_pull_request_template()\n", "scripts/disable-powersave.py": "#!/usr/bin/env python3\nfrom openpilot.system.hardware import HARDWARE\n\nif __name__ == \"__main__\":\n  HARDWARE.set_power_save(False)\n", "scripts/pyqt_demo.py": "#!/usr/bin/env python3\n\nfrom PyQt5.QtWidgets import QApplication, QLabel\nfrom openpilot.selfdrive.ui.qt.python_helpers import set_main_window\n\n\nif __name__ == \"__main__\":\n  app = QApplication([])\n  label = QLabel('Hello World!')\n\n  # Set full screen and rotate\n  set_main_window(label)\n\n  app.exec_()\n", "scripts/count_cars.py": "#!/usr/bin/env python3\nfrom collections import Counter\nfrom pprint import pprint\n\nfrom openpilot.selfdrive.car.docs import get_all_car_docs\n\nif __name__ == \"__main__\":\n  cars = get_all_car_docs()\n  make_count = Counter(l.make for l in cars)\n  print(\"\\n\", \"*\" * 20, len(cars), \"total\", \"*\" * 20, \"\\n\")\n  pprint(make_count)\n", "scripts/__init__.py": "", "scripts/code_stats.py": "#!/usr/bin/env python3\nimport os\nimport ast\nimport stat\nimport subprocess\n\nfouts = {x.decode('utf-8') for x in subprocess.check_output(['git', 'ls-files']).strip().split()}\n\npyf = []\nfor d in [\"cereal\", \"common\", \"scripts\", \"selfdrive\", \"tools\"]:\n  for root, _, files in os.walk(d):\n    for f in files:\n      if f.endswith(\".py\"):\n        pyf.append(os.path.join(root, f))\n\nimps: set[str] = set()\n\nclass Analyzer(ast.NodeVisitor):\n  def visit_Import(self, node):\n    for alias in node.names:\n      imps.add(alias.name)\n    self.generic_visit(node)\n\n  def visit_ImportFrom(self, node):\n    imps.add(node.module)\n    self.generic_visit(node)\n\ntlns = 0\ncarlns = 0\nscriptlns = 0\ntestlns = 0\nfor f in sorted(pyf):\n  if f not in fouts:\n    continue\n  xbit = bool(os.stat(f)[stat.ST_MODE] & stat.S_IXUSR)\n  src = open(f).read()\n  lns = len(src.split(\"\\n\"))\n  tree = ast.parse(src)\n  Analyzer().visit(tree)\n  print(\"%5d %s %s\" % (lns, f, xbit))\n  if 'test' in f:\n    testlns += lns\n  elif f.startswith(('tools/', 'scripts/', 'selfdrive/debug')):\n    scriptlns += lns\n  elif f.startswith('selfdrive/car'):\n    carlns += lns\n  else:\n    tlns += lns\n\nprint(\"%d lines of openpilot python\" % tlns)\nprint(\"%d lines of car ports\" % carlns)\nprint(\"%d lines of tools/scripts/debug\" % scriptlns)\nprint(\"%d lines of tests\" % testlns)\n#print(sorted(list(imps)))\n", "scripts/waste.py": "#!/usr/bin/env python3\nimport os\nimport time\nimport numpy as np\nfrom multiprocessing import Process\nfrom openpilot.common.threadname import setthreadname\n\ndef waste(core):\n  os.sched_setaffinity(0, [core,])\n\n  m1 = np.zeros((200, 200)) + 0.8\n  m2 = np.zeros((200, 200)) + 1.2\n\n  i = 1\n  st = time.monotonic()\n  j = 0\n  while 1:\n    if (i % 100) == 0:\n      setthreadname(\"%3d: %8d\" % (core, i))\n      lt = time.monotonic()\n      print(\"%3d: %8d %f  %.2f\" % (core, i, lt-st, j))\n      st = lt\n    i += 1\n    j = np.sum(np.matmul(m1, m2))\n\ndef main(gctx=None):\n  print(\"1-2 seconds is baseline\")\n  for i in range(os.cpu_count()):\n    p = Process(target=waste, args=(i,))\n    p.start()\n\nif __name__ == \"__main__\":\n  main()\n", "release/release_files.py": "#!/usr/bin/env python3\nimport os\nimport re\nfrom pathlib import Path\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nROOT = HERE + \"/..\"\n\n# blacklisting is for two purposes:\n# - minimizing release download size\n# - keeping the diff readable\nblacklist = [\n  \"body/STL/\",\n\n  \"panda/drivers/\",\n  \"panda/examples/\",\n  \"panda/tests/safety/\",\n\n  \"opendbc/.*.dbc$\",\n  \"opendbc/generator/\",\n\n  \"cereal/.*test.*\",\n  \"^common/tests/\",\n\n  # particularly large text files\n  \"poetry.lock\",\n  \"third_party/catch2\",\n  \"selfdrive/car/tests/test_models.*\",\n\n  \"^tools/\",\n  \"^scripts/\",\n  \"^tinygrad_repo/\",\n\n  \"matlab.*.md\",\n\n  \".git/\",\n  \".github/\",\n  \".devcontainer/\",\n  \"Darwin/\",\n  \".vscode\",\n\n  # common things\n  \"LICENSE\",\n  \"Dockerfile\",\n  \".pre-commit\",\n\n  # no LFS or submodules in release\n  \".lfsconfig\",\n  \".gitattributes\",\n  \".git$\",\n  \".gitmodules\",\n]\n\n# gets you through the blacklist\nwhitelist = [\n  \"tools/lib/\",\n  \"tools/bodyteleop/\",\n\n  \"tinygrad_repo/openpilot/compile2.py\",\n  \"tinygrad_repo/extra/onnx.py\",\n  \"tinygrad_repo/extra/onnx_ops.py\",\n  \"tinygrad_repo/extra/thneed.py\",\n  \"tinygrad_repo/extra/utils.py\",\n  \"tinygrad_repo/tinygrad/codegen/kernel.py\",\n  \"tinygrad_repo/tinygrad/codegen/linearizer.py\",\n  \"tinygrad_repo/tinygrad/features/image.py\",\n  \"tinygrad_repo/tinygrad/features/search.py\",\n  \"tinygrad_repo/tinygrad/nn/*\",\n  \"tinygrad_repo/tinygrad/renderer/cstyle.py\",\n  \"tinygrad_repo/tinygrad/renderer/opencl.py\",\n  \"tinygrad_repo/tinygrad/runtime/lib.py\",\n  \"tinygrad_repo/tinygrad/runtime/ops_cpu.py\",\n  \"tinygrad_repo/tinygrad/runtime/ops_disk.py\",\n  \"tinygrad_repo/tinygrad/runtime/ops_gpu.py\",\n  \"tinygrad_repo/tinygrad/shape/*\",\n  \"tinygrad_repo/tinygrad/.*.py\",\n\n  # TODO: do this automatically\n  \"opendbc/comma_body.dbc\",\n  \"opendbc/chrysler_ram_hd_generated.dbc\",\n  \"opendbc/chrysler_ram_dt_generated.dbc\",\n  \"opendbc/chrysler_pacifica_2017_hybrid_generated.dbc\",\n  \"opendbc/chrysler_pacifica_2017_hybrid_private_fusion.dbc\",\n  \"opendbc/gm_global_a_powertrain_generated.dbc\",\n  \"opendbc/gm_global_a_object.dbc\",\n  \"opendbc/gm_global_a_chassis.dbc\",\n  \"opendbc/FORD_CADS.dbc\",\n  \"opendbc/ford_fusion_2018_adas.dbc\",\n  \"opendbc/ford_lincoln_base_pt.dbc\",\n  \"opendbc/honda_accord_2018_can_generated.dbc\",\n  \"opendbc/acura_ilx_2016_can_generated.dbc\",\n  \"opendbc/acura_rdx_2018_can_generated.dbc\",\n  \"opendbc/acura_rdx_2020_can_generated.dbc\",\n  \"opendbc/honda_civic_touring_2016_can_generated.dbc\",\n  \"opendbc/honda_civic_hatchback_ex_2017_can_generated.dbc\",\n  \"opendbc/honda_crv_touring_2016_can_generated.dbc\",\n  \"opendbc/honda_crv_ex_2017_can_generated.dbc\",\n  \"opendbc/honda_crv_ex_2017_body_generated.dbc\",\n  \"opendbc/honda_crv_executive_2016_can_generated.dbc\",\n  \"opendbc/honda_fit_ex_2018_can_generated.dbc\",\n  \"opendbc/honda_odyssey_exl_2018_generated.dbc\",\n  \"opendbc/honda_odyssey_extreme_edition_2018_china_can_generated.dbc\",\n  \"opendbc/honda_insight_ex_2019_can_generated.dbc\",\n  \"opendbc/acura_ilx_2016_nidec.dbc\",\n  \"opendbc/honda_civic_ex_2022_can_generated.dbc\",\n  \"opendbc/hyundai_canfd.dbc\",\n  \"opendbc/hyundai_kia_generic.dbc\",\n  \"opendbc/hyundai_kia_mando_front_radar_generated.dbc\",\n  \"opendbc/mazda_2017.dbc\",\n  \"opendbc/nissan_x_trail_2017_generated.dbc\",\n  \"opendbc/nissan_leaf_2018_generated.dbc\",\n  \"opendbc/subaru_global_2017_generated.dbc\",\n  \"opendbc/subaru_global_2020_hybrid_generated.dbc\",\n  \"opendbc/subaru_outback_2015_generated.dbc\",\n  \"opendbc/subaru_outback_2019_generated.dbc\",\n  \"opendbc/subaru_forester_2017_generated.dbc\",\n  \"opendbc/toyota_tnga_k_pt_generated.dbc\",\n  \"opendbc/toyota_new_mc_pt_generated.dbc\",\n  \"opendbc/toyota_nodsu_pt_generated.dbc\",\n  \"opendbc/toyota_adas.dbc\",\n  \"opendbc/toyota_tss2_adas.dbc\",\n  \"opendbc/vw_golf_mk4.dbc\",\n  \"opendbc/vw_mqb_2010.dbc\",\n  \"opendbc/tesla_can.dbc\",\n  \"opendbc/tesla_radar_bosch_generated.dbc\",\n  \"opendbc/tesla_radar_continental_generated.dbc\",\n  \"opendbc/tesla_powertrain.dbc\",\n]\n\n\nif __name__ == \"__main__\":\n  for f in Path(ROOT).rglob(\"**/*\"):\n    if not (f.is_file() or f.is_symlink()):\n      continue\n\n    rf = str(f.relative_to(ROOT))\n    blacklisted = any(re.search(p, rf) for p in blacklist)\n    whitelisted = any(re.search(p, rf) for p in whitelist)\n    if blacklisted and not whitelisted:\n      continue\n\n    print(rf)\n", "common/text_window.py": "#!/usr/bin/env python3\nimport os\nimport time\nimport subprocess\nfrom openpilot.common.basedir import BASEDIR\n\n\nclass TextWindow:\n  def __init__(self, text):\n    try:\n      self.text_proc = subprocess.Popen([\"./text\", text],\n                                        stdin=subprocess.PIPE,\n                                        cwd=os.path.join(BASEDIR, \"selfdrive\", \"ui\"),\n                                        close_fds=True)\n    except OSError:\n      self.text_proc = None\n\n  def get_status(self):\n    if self.text_proc is not None:\n      self.text_proc.poll()\n      return self.text_proc.returncode\n    return None\n\n  def __enter__(self):\n    return self\n\n  def close(self):\n    if self.text_proc is not None:\n      self.text_proc.terminate()\n      self.text_proc = None\n\n  def wait_for_exit(self):\n    if self.text_proc is not None:\n      while True:\n        if self.get_status() == 1:\n          return\n        time.sleep(0.1)\n\n  def __del__(self):\n    self.close()\n\n  def __exit__(self, exc_type, exc_value, traceback):\n    self.close()\n\n\nif __name__ == \"__main__\":\n  text = \"\"\"Traceback (most recent call last):\n  File \"./controlsd.py\", line 608, in <module>\n    main()\n  File \"./controlsd.py\", line 604, in main\n    controlsd_thread(sm, pm, logcan)\n  File \"./controlsd.py\", line 455, in controlsd_thread\n    1/0\nZeroDivisionError: division by zero\"\"\"\n  print(text)\n\n  with TextWindow(text) as s:\n    for _ in range(100):\n      if s.get_status() == 1:\n        print(\"Got exit button\")\n        break\n      time.sleep(0.1)\n  print(\"gone\")\n", "common/dict_helpers.py": "# remove all keys that end in DEPRECATED\ndef strip_deprecated_keys(d):\n  for k in list(d.keys()):\n    if isinstance(k, str):\n      if k.endswith('DEPRECATED'):\n        d.pop(k)\n      elif isinstance(d[k], dict):\n        strip_deprecated_keys(d[k])\n  return d\n", "common/run.py": "import subprocess\n\n\ndef run_cmd(cmd: list[str], cwd=None, env=None) -> str:\n  return subprocess.check_output(cmd, encoding='utf8', cwd=cwd, env=env).strip()\n\n\ndef run_cmd_default(cmd: list[str], default: str = \"\", cwd=None, env=None) -> str:\n  try:\n    return run_cmd(cmd, cwd=cwd, env=env)\n  except subprocess.CalledProcessError:\n    return default\n\n", "common/conversions.py": "import numpy as np\n\nclass Conversions:\n  # Speed\n  MPH_TO_KPH = 1.609344\n  KPH_TO_MPH = 1. / MPH_TO_KPH\n  MS_TO_KPH = 3.6\n  KPH_TO_MS = 1. / MS_TO_KPH\n  MS_TO_MPH = MS_TO_KPH * KPH_TO_MPH\n  MPH_TO_MS = MPH_TO_KPH * KPH_TO_MS\n  MS_TO_KNOTS = 1.9438\n  KNOTS_TO_MS = 1. / MS_TO_KNOTS\n\n  # Angle\n  DEG_TO_RAD = np.pi / 180.\n  RAD_TO_DEG = 1. / DEG_TO_RAD\n\n  # Mass\n  LB_TO_KG = 0.453592\n", "common/ffi_wrapper.py": "import platform\n\n\ndef suffix():\n  if platform.system() == \"Darwin\":\n    return \".dylib\"\n  else:\n    return \".so\"\n", "common/numpy_fast.py": "def clip(x, lo, hi):\n  return max(lo, min(hi, x))\n\ndef interp(x, xp, fp):\n  N = len(xp)\n\n  def get_interp(xv):\n    hi = 0\n    while hi < N and xv > xp[hi]:\n      hi += 1\n    low = hi - 1\n    return fp[-1] if hi == N and xv > xp[low] else (\n      fp[0] if hi == 0 else\n      (xv - xp[low]) * (fp[hi] - fp[low]) / (xp[hi] - xp[low]) + fp[low])\n\n  return [get_interp(v) for v in x] if hasattr(x, '__iter__') else get_interp(x)\n\ndef mean(x):\n  return sum(x) / len(x)\n", "common/threadname.py": "import ctypes\nimport os\n\nLINUX = os.name == 'posix' and os.uname().sysname == 'Linux'\n\nif LINUX:\n  libc = ctypes.CDLL('libc.so.6')\n\ndef setthreadname(name: str) -> None:\n  if LINUX:\n    name = name[-15:] + '\\0'\n    libc.prctl(15, str.encode(name), 0, 0, 0)\n\ndef getthreadname() -> str:\n  if LINUX:\n    name = ctypes.create_string_buffer(16)\n    libc.prctl(16, name)\n    return name.value.decode('utf-8')\n  return \"\"\n", "common/prefix.py": "import os\nimport shutil\nimport uuid\n\n\nfrom openpilot.common.params import Params\nfrom openpilot.system.hardware import PC\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.system.hardware.hw import DEFAULT_DOWNLOAD_CACHE_ROOT\n\nclass OpenpilotPrefix:\n  def __init__(self, prefix: str = None, clean_dirs_on_exit: bool = True, shared_download_cache: bool = False):\n    self.prefix = prefix if prefix else str(uuid.uuid4().hex[0:15])\n    self.msgq_path = os.path.join('/dev/shm', self.prefix)\n    self.clean_dirs_on_exit = clean_dirs_on_exit\n    self.shared_download_cache = shared_download_cache\n\n  def __enter__(self):\n    self.original_prefix = os.environ.get('OPENPILOT_PREFIX', None)\n    os.environ['OPENPILOT_PREFIX'] = self.prefix\n    try:\n      os.mkdir(self.msgq_path)\n    except FileExistsError:\n      pass\n    os.makedirs(Paths.log_root(), exist_ok=True)\n\n    if self.shared_download_cache:\n      os.environ[\"COMMA_CACHE\"] = DEFAULT_DOWNLOAD_CACHE_ROOT\n\n    return self\n\n  def __exit__(self, exc_type, exc_obj, exc_tb):\n    if self.clean_dirs_on_exit:\n      self.clean_dirs()\n    try:\n      del os.environ['OPENPILOT_PREFIX']\n      if self.original_prefix is not None:\n        os.environ['OPENPILOT_PREFIX'] = self.original_prefix\n    except KeyError:\n      pass\n    return False\n\n  def clean_dirs(self):\n    symlink_path = Params().get_param_path()\n    if os.path.exists(symlink_path):\n      shutil.rmtree(os.path.realpath(symlink_path), ignore_errors=True)\n      os.remove(symlink_path)\n    shutil.rmtree(self.msgq_path, ignore_errors=True)\n    if PC:\n      shutil.rmtree(Paths.log_root(), ignore_errors=True)\n    if not os.environ.get(\"COMMA_CACHE\", False):\n      shutil.rmtree(Paths.download_cache_root(), ignore_errors=True)\n    shutil.rmtree(Paths.comma_home(), ignore_errors=True)\n", "common/retry.py": "import time\nimport functools\n\nfrom openpilot.common.swaglog import cloudlog\n\n\ndef retry(attempts=3, delay=1.0, ignore_failure=False):\n  def decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n      for _ in range(attempts):\n        try:\n          return func(*args, **kwargs)\n        except Exception:\n          cloudlog.exception(f\"{func.__name__} failed, trying again\")\n          time.sleep(delay)\n\n      if ignore_failure:\n        cloudlog.error(f\"{func.__name__} failed after retry\")\n      else:\n        raise Exception(f\"{func.__name__} failed after retry\")\n    return wrapper\n  return decorator\n\n\nif __name__ == \"__main__\":\n  @retry(attempts=10)\n  def abc():\n    raise ValueError(\"abc failed :(\")\n  abc()\n", "common/simple_kalman.py": "import numpy as np\n\n\ndef get_kalman_gain(dt, A, C, Q, R, iterations=100):\n  P = np.zeros_like(Q)\n  for _ in range(iterations):\n    P = A.dot(P).dot(A.T) + dt * Q\n    S = C.dot(P).dot(C.T) + R\n    K = P.dot(C.T).dot(np.linalg.inv(S))\n    P = (np.eye(len(P)) - K.dot(C)).dot(P)\n  return K\n\n\nclass KF1D:\n  # this EKF assumes constant covariance matrix, so calculations are much simpler\n  # the Kalman gain also needs to be precomputed using the control module\n\n  def __init__(self, x0, A, C, K):\n    self.x0_0 = x0[0][0]\n    self.x1_0 = x0[1][0]\n    self.A0_0 = A[0][0]\n    self.A0_1 = A[0][1]\n    self.A1_0 = A[1][0]\n    self.A1_1 = A[1][1]\n    self.C0_0 = C[0]\n    self.C0_1 = C[1]\n    self.K0_0 = K[0][0]\n    self.K1_0 = K[1][0]\n\n    self.A_K_0 = self.A0_0 - self.K0_0 * self.C0_0\n    self.A_K_1 = self.A0_1 - self.K0_0 * self.C0_1\n    self.A_K_2 = self.A1_0 - self.K1_0 * self.C0_0\n    self.A_K_3 = self.A1_1 - self.K1_0 * self.C0_1\n\n    # K matrix needs to  be pre-computed as follow:\n    # import control\n    # (x, l, K) = control.dare(np.transpose(self.A), np.transpose(self.C), Q, R)\n    # self.K = np.transpose(K)\n\n  def update(self, meas):\n    #self.x = np.dot(self.A_K, self.x) + np.dot(self.K, meas)\n    x0_0 = self.A_K_0 * self.x0_0 + self.A_K_1 * self.x1_0 + self.K0_0 * meas\n    x1_0 = self.A_K_2 * self.x0_0 + self.A_K_3 * self.x1_0 + self.K1_0 * meas\n    self.x0_0 = x0_0\n    self.x1_0 = x1_0\n    return [self.x0_0, self.x1_0]\n\n  @property\n  def x(self):\n    return [[self.x0_0], [self.x1_0]]\n\n  def set_x(self, x):\n    self.x0_0 = x[0][0]\n    self.x1_0 = x[1][0]\n", "common/time.py": "import datetime\nfrom pathlib import Path\n\n_MIN_DATE = datetime.datetime(year=2024, month=3, day=30)\n\ndef min_date():\n  # on systemd systems, the default time is the systemd build time\n  systemd_path = Path(\"/lib/systemd/systemd\")\n  if systemd_path.exists():\n    d = datetime.datetime.fromtimestamp(systemd_path.stat().st_mtime)\n    return d + datetime.timedelta(days=1)\n  return _MIN_DATE\n\ndef system_time_valid():\n  return datetime.datetime.now() > min_date()\n", "common/spinner.py": "import os\nimport subprocess\nfrom openpilot.common.basedir import BASEDIR\n\n\nclass Spinner:\n  def __init__(self):\n    try:\n      self.spinner_proc = subprocess.Popen([\"./spinner\"],\n                                           stdin=subprocess.PIPE,\n                                           cwd=os.path.join(BASEDIR, \"selfdrive\", \"ui\"),\n                                           close_fds=True)\n    except OSError:\n      self.spinner_proc = None\n\n  def __enter__(self):\n    return self\n\n  def update(self, spinner_text: str):\n    if self.spinner_proc is not None:\n      self.spinner_proc.stdin.write(spinner_text.encode('utf8') + b\"\\n\")\n      try:\n        self.spinner_proc.stdin.flush()\n      except BrokenPipeError:\n        pass\n\n  def update_progress(self, cur: float, total: float):\n    self.update(str(round(100 * cur / total)))\n\n  def close(self):\n    if self.spinner_proc is not None:\n      self.spinner_proc.kill()\n      try:\n        self.spinner_proc.communicate(timeout=2.)\n      except subprocess.TimeoutExpired:\n        print(\"WARNING: failed to kill spinner\")\n      self.spinner_proc = None\n\n  def __del__(self):\n    self.close()\n\n  def __exit__(self, exc_type, exc_value, traceback):\n    self.close()\n\n\nif __name__ == \"__main__\":\n  import time\n  with Spinner() as s:\n    s.update(\"Spinner text\")\n    time.sleep(5.0)\n  print(\"gone\")\n  time.sleep(5.0)\n", "common/utils.py": "class Freezable:\n  _frozen: bool = False\n\n  def freeze(self):\n    if not self._frozen:\n      self._frozen = True\n\n  def __setattr__(self, *args, **kwargs):\n    if self._frozen:\n      raise Exception(\"cannot modify frozen object\")\n    super().__setattr__(*args, **kwargs)\n", "common/basedir.py": "import os\n\n\nBASEDIR = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)), \"../\"))\n", "common/git.py": "from functools import cache\nimport subprocess\nfrom openpilot.common.run import run_cmd, run_cmd_default\n\n\n@cache\ndef get_commit(cwd: str = None, branch: str = \"HEAD\") -> str:\n  return run_cmd_default([\"git\", \"rev-parse\", branch], cwd=cwd)\n\n\n@cache\ndef get_commit_date(cwd: str = None, commit: str = \"HEAD\") -> str:\n  return run_cmd_default([\"git\", \"show\", \"--no-patch\", \"--format='%ct %ci'\", commit], cwd=cwd)\n\n\n@cache\ndef get_short_branch(cwd: str = None) -> str:\n  return run_cmd_default([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"], cwd=cwd)\n\n\n@cache\ndef get_branch(cwd: str = None) -> str:\n  return run_cmd_default([\"git\", \"rev-parse\", \"--abbrev-ref\", \"--symbolic-full-name\", \"@{u}\"], cwd=cwd)\n\n\n@cache\ndef get_origin(cwd: str = None) -> str:\n  try:\n    local_branch = run_cmd([\"git\", \"name-rev\", \"--name-only\", \"HEAD\"], cwd=cwd)\n    tracking_remote = run_cmd([\"git\", \"config\", \"branch.\" + local_branch + \".remote\"], cwd=cwd)\n    return run_cmd([\"git\", \"config\", \"remote.\" + tracking_remote + \".url\"], cwd=cwd)\n  except subprocess.CalledProcessError:  # Not on a branch, fallback\n    return run_cmd_default([\"git\", \"config\", \"--get\", \"remote.origin.url\"], cwd=cwd)\n\n\n@cache\ndef get_normalized_origin(cwd: str = None) -> str:\n  return get_origin(cwd) \\\n    .replace(\"git@\", \"\", 1) \\\n    .replace(\".git\", \"\", 1) \\\n    .replace(\"https://\", \"\", 1) \\\n    .replace(\":\", \"/\", 1)\n", "common/params.py": "from openpilot.common.params_pyx import Params, ParamKeyType, UnknownKeyName\nassert Params\nassert ParamKeyType\nassert UnknownKeyName\n\nif __name__ == \"__main__\":\n  import sys\n\n  params = Params()\n  key = sys.argv[1]\n  assert params.check_key(key), f\"unknown param: {key}\"\n\n  if len(sys.argv) == 3:\n    val = sys.argv[2]\n    print(f\"SET: {key} = {val}\")\n    params.put(key, val)\n  elif len(sys.argv) == 2:\n    print(f\"GET: {key} = {params.get(key)}\")\n", "common/file_helpers.py": "import os\nimport tempfile\nimport contextlib\n\n\nclass CallbackReader:\n  \"\"\"Wraps a file, but overrides the read method to also\n  call a callback function with the number of bytes read so far.\"\"\"\n  def __init__(self, f, callback, *args):\n    self.f = f\n    self.callback = callback\n    self.cb_args = args\n    self.total_read = 0\n\n  def __getattr__(self, attr):\n    return getattr(self.f, attr)\n\n  def read(self, *args, **kwargs):\n    chunk = self.f.read(*args, **kwargs)\n    self.total_read += len(chunk)\n    self.callback(*self.cb_args, self.total_read)\n    return chunk\n\n\n@contextlib.contextmanager\ndef atomic_write_in_dir(path: str, mode: str = 'w', buffering: int = -1, encoding: str = None, newline: str = None,\n                        overwrite: bool = False):\n  \"\"\"Write to a file atomically using a temporary file in the same directory as the destination file.\"\"\"\n  dir_name = os.path.dirname(path)\n\n  if not overwrite and os.path.exists(path):\n    raise FileExistsError(f\"File '{path}' already exists. To overwrite it, set 'overwrite' to True.\")\n\n  with tempfile.NamedTemporaryFile(mode=mode, buffering=buffering, encoding=encoding, newline=newline, dir=dir_name, delete=False) as tmp_file:\n    yield tmp_file\n    tmp_file_name = tmp_file.name\n  os.replace(tmp_file_name, path)\n", "common/gpio.py": "import os\nfrom functools import cache\n\ndef gpio_init(pin: int, output: bool) -> None:\n  try:\n    with open(f\"/sys/class/gpio/gpio{pin}/direction\", 'wb') as f:\n      f.write(b\"out\" if output else b\"in\")\n  except Exception as e:\n    print(f\"Failed to set gpio {pin} direction: {e}\")\n\ndef gpio_set(pin: int, high: bool) -> None:\n  try:\n    with open(f\"/sys/class/gpio/gpio{pin}/value\", 'wb') as f:\n      f.write(b\"1\" if high else b\"0\")\n  except Exception as e:\n    print(f\"Failed to set gpio {pin} value: {e}\")\n\ndef gpio_read(pin: int) -> bool | None:\n  val = None\n  try:\n    with open(f\"/sys/class/gpio/gpio{pin}/value\", 'rb') as f:\n      val = bool(int(f.read().strip()))\n  except Exception as e:\n    print(f\"Failed to set gpio {pin} value: {e}\")\n\n  return val\n\ndef gpio_export(pin: int) -> None:\n  if os.path.isdir(f\"/sys/class/gpio/gpio{pin}\"):\n    return\n\n  try:\n    with open(\"/sys/class/gpio/export\", 'w') as f:\n      f.write(str(pin))\n  except Exception:\n    print(f\"Failed to export gpio {pin}\")\n\n@cache\ndef get_irq_action(irq: int) -> list[str]:\n  try:\n    with open(f\"/sys/kernel/irq/{irq}/actions\") as f:\n      actions = f.read().strip().split(',')\n      return actions\n  except FileNotFoundError:\n    return []\n\ndef get_irqs_for_action(action: str) -> list[str]:\n  ret = []\n  with open(\"/proc/interrupts\") as f:\n    for l in f.readlines():\n      irq = l.split(':')[0].strip()\n      if irq.isdigit() and action in get_irq_action(irq):\n        ret.append(irq)\n  return ret\n", "common/timeout.py": "import signal\n\nclass TimeoutException(Exception):\n  pass\n\nclass Timeout:\n  \"\"\"\n  Timeout context manager.\n  For example this code will raise a TimeoutException:\n  with Timeout(seconds=5, error_msg=\"Sleep was too long\"):\n    time.sleep(10)\n  \"\"\"\n  def __init__(self, seconds, error_msg=None):\n    if error_msg is None:\n      error_msg = f'Timed out after {seconds} seconds'\n    self.seconds = seconds\n    self.error_msg = error_msg\n\n  def handle_timeout(self, signume, frame):\n    raise TimeoutException(self.error_msg)\n\n  def __enter__(self):\n    signal.signal(signal.SIGALRM, self.handle_timeout)\n    signal.alarm(self.seconds)\n\n  def __exit__(self, exc_type, exc_val, exc_tb):\n    signal.alarm(0)\n", "common/stat_live.py": "import numpy as np\n\nclass RunningStat:\n  # tracks realtime mean and standard deviation without storing any data\n  def __init__(self, priors=None, max_trackable=-1):\n    self.max_trackable = max_trackable\n    if priors is not None:\n      # initialize from history\n      self.M = priors[0]\n      self.S = priors[1]\n      self.n = priors[2]\n      self.M_last = self.M\n      self.S_last = self.S\n\n    else:\n      self.reset()\n\n  def reset(self):\n    self.M = 0.\n    self.S = 0.\n    self.M_last = 0.\n    self.S_last = 0.\n    self.n = 0\n\n  def push_data(self, new_data):\n    # short term memory hack\n    if self.max_trackable < 0 or self.n < self.max_trackable:\n      self.n += 1\n    if self.n == 0:\n      self.M_last = new_data\n      self.M = self.M_last\n      self.S_last = 0.\n    else:\n      self.M = self.M_last + (new_data - self.M_last) / self.n\n      self.S = self.S_last + (new_data - self.M_last) * (new_data - self.M)\n      self.M_last = self.M\n      self.S_last = self.S\n\n  def mean(self):\n    return self.M\n\n  def variance(self):\n    if self.n >= 2:\n      return self.S / (self.n - 1.)\n    else:\n      return 0\n\n  def std(self):\n    return np.sqrt(self.variance())\n\n  def params_to_save(self):\n    return [self.M, self.S, self.n]\n\nclass RunningStatFilter:\n  def __init__(self, raw_priors=None, filtered_priors=None, max_trackable=-1):\n    self.raw_stat = RunningStat(raw_priors, -1)\n    self.filtered_stat = RunningStat(filtered_priors, max_trackable)\n\n  def reset(self):\n    self.raw_stat.reset()\n    self.filtered_stat.reset()\n\n  def push_and_update(self, new_data):\n    _std_last = self.raw_stat.std()\n    self.raw_stat.push_data(new_data)\n    _delta_std = self.raw_stat.std() - _std_last\n    if _delta_std <= 0:\n      self.filtered_stat.push_data(new_data)\n    else:\n      pass\n      # self.filtered_stat.push_data(self.filtered_stat.mean())\n\n# class SequentialBayesian():\n", "common/__init__.py": "", "common/logging_extra.py": "import io\nimport os\nimport sys\nimport copy\nimport json\nimport time\nimport uuid\nimport socket\nimport logging\nimport traceback\nfrom threading import local\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\n\nLOG_TIMESTAMPS = \"LOG_TIMESTAMPS\" in os.environ\n\ndef json_handler(obj):\n  # if isinstance(obj, (datetime.date, datetime.time)):\n  #   return obj.isoformat()\n  return repr(obj)\n\ndef json_robust_dumps(obj):\n  return json.dumps(obj, default=json_handler)\n\nclass NiceOrderedDict(OrderedDict):\n  def __str__(self):\n    return json_robust_dumps(self)\n\nclass SwagFormatter(logging.Formatter):\n  def __init__(self, swaglogger):\n    logging.Formatter.__init__(self, None, '%a %b %d %H:%M:%S %Z %Y')\n\n    self.swaglogger = swaglogger\n    self.host = socket.gethostname()\n\n  def format_dict(self, record):\n    record_dict = NiceOrderedDict()\n\n    if isinstance(record.msg, dict):\n      record_dict['msg'] = record.msg\n    else:\n      try:\n        record_dict['msg'] = record.getMessage()\n      except (ValueError, TypeError):\n        record_dict['msg'] = [record.msg]+record.args\n\n    record_dict['ctx'] = self.swaglogger.get_ctx()\n\n    if record.exc_info:\n      record_dict['exc_info'] = self.formatException(record.exc_info)\n\n    record_dict['level'] = record.levelname\n    record_dict['levelnum'] = record.levelno\n    record_dict['name'] = record.name\n    record_dict['filename'] = record.filename\n    record_dict['lineno'] = record.lineno\n    record_dict['pathname'] = record.pathname\n    record_dict['module'] = record.module\n    record_dict['funcName'] = record.funcName\n    record_dict['host'] = self.host\n    record_dict['process'] = record.process\n    record_dict['thread'] = record.thread\n    record_dict['threadName'] = record.threadName\n    record_dict['created'] = record.created\n\n    return record_dict\n\n  def format(self, record):\n    if self.swaglogger is None:\n      raise Exception(\"must set swaglogger before calling format()\")\n    return json_robust_dumps(self.format_dict(record))\n\nclass SwagLogFileFormatter(SwagFormatter):\n  def fix_kv(self, k, v):\n    # append type to names to preserve legacy naming in logs\n    # avoids overlapping key namespaces with different types\n    # e.g. log.info() creates 'msg' -> 'msg$s'\n    #      log.event() creates 'msg.health.logMonoTime' -> 'msg.health.logMonoTime$i'\n    #      because overlapping namespace 'msg' caused problems\n    if isinstance(v, (str, bytes)):\n      k += \"$s\"\n    elif isinstance(v, float):\n      k += \"$f\"\n    elif isinstance(v, bool):\n      k += \"$b\"\n    elif isinstance(v, int):\n      k += \"$i\"\n    elif isinstance(v, dict):\n      nv = {}\n      for ik, iv in v.items():\n        ik, iv = self.fix_kv(ik, iv)\n        nv[ik] = iv\n      v = nv\n    elif isinstance(v, list):\n      k += \"$a\"\n    return k, v\n\n  def format(self, record):\n    if isinstance(record, str):\n      v = json.loads(record)\n    else:\n      v = self.format_dict(record)\n\n    mk, mv = self.fix_kv('msg', v['msg'])\n    del v['msg']\n    v[mk] = mv\n    v['id'] = uuid.uuid4().hex\n\n    return json_robust_dumps(v)\n\nclass SwagErrorFilter(logging.Filter):\n  def filter(self, record):\n    return record.levelno < logging.ERROR\n\ndef _tmpfunc():\n  return 0\n\ndef _srcfile():\n  return os.path.normcase(_tmpfunc.__code__.co_filename)\n\nclass SwagLogger(logging.Logger):\n  def __init__(self):\n    logging.Logger.__init__(self, \"swaglog\")\n\n    self.global_ctx = {}\n\n    self.log_local = local()\n    self.log_local.ctx = {}\n\n  def local_ctx(self):\n    try:\n      return self.log_local.ctx\n    except AttributeError:\n      self.log_local.ctx = {}\n      return self.log_local.ctx\n\n  def get_ctx(self):\n    return dict(self.local_ctx(), **self.global_ctx)\n\n  @contextmanager\n  def ctx(self, **kwargs):\n    old_ctx = self.local_ctx()\n    self.log_local.ctx = copy.copy(old_ctx) or {}\n    self.log_local.ctx.update(kwargs)\n    try:\n      yield\n    finally:\n      self.log_local.ctx = old_ctx\n\n  def bind(self, **kwargs):\n    self.local_ctx().update(kwargs)\n\n  def bind_global(self, **kwargs):\n    self.global_ctx.update(kwargs)\n\n  def event(self, event, *args, **kwargs):\n    evt = NiceOrderedDict()\n    evt['event'] = event\n    if args:\n      evt['args'] = args\n    evt.update(kwargs)\n    if 'error' in kwargs:\n      self.error(evt)\n    elif 'debug' in kwargs:\n      self.debug(evt)\n    else:\n      self.info(evt)\n\n  def timestamp(self, event_name):\n    if LOG_TIMESTAMPS:\n      t = time.monotonic()\n      tstp = NiceOrderedDict()\n      tstp['timestamp'] = NiceOrderedDict()\n      tstp['timestamp'][\"event\"] = event_name\n      tstp['timestamp'][\"time\"] = t*1e9\n      self.debug(tstp)\n\n  def findCaller(self, stack_info=False, stacklevel=1):\n    \"\"\"\n    Find the stack frame of the caller so that we can note the source\n    file name, line number and function name.\n    \"\"\"\n    f = sys._getframe(3)\n    #On some versions of IronPython, currentframe() returns None if\n    #IronPython isn't run with -X:Frames.\n    if f is not None:\n      f = f.f_back\n    orig_f = f\n    while f and stacklevel > 1:\n      f = f.f_back\n      stacklevel -= 1\n    if not f:\n      f = orig_f\n    rv = \"(unknown file)\", 0, \"(unknown function)\", None\n    while hasattr(f, \"f_code\"):\n      co = f.f_code\n      filename = os.path.normcase(co.co_filename)\n\n      # TODO: is this pylint exception correct?\n      if filename == _srcfile:\n        f = f.f_back\n        continue\n      sinfo = None\n      if stack_info:\n        sio = io.StringIO()\n        sio.write('Stack (most recent call last):\\n')\n        traceback.print_stack(f, file=sio)\n        sinfo = sio.getvalue()\n        if sinfo[-1] == '\\n':\n          sinfo = sinfo[:-1]\n        sio.close()\n      rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)\n      break\n    return rv\n\nif __name__ == \"__main__\":\n  log = SwagLogger()\n\n  stdout_handler = logging.StreamHandler(sys.stdout)\n  stdout_handler.setLevel(logging.INFO)\n  stdout_handler.addFilter(SwagErrorFilter())\n  log.addHandler(stdout_handler)\n\n  stderr_handler = logging.StreamHandler(sys.stderr)\n  stderr_handler.setLevel(logging.ERROR)\n  log.addHandler(stderr_handler)\n\n  log.info(\"asdasd %s\", \"a\")\n  log.info({'wut': 1})\n  log.warning(\"warning\")\n  log.error(\"error\")\n  log.critical(\"critical\")\n  log.event(\"test\", x=\"y\")\n\n  with log.ctx():\n    stdout_handler.setFormatter(SwagFormatter(log))\n    stderr_handler.setFormatter(SwagFormatter(log))\n    log.bind(user=\"some user\")\n    log.info(\"in req\")\n    print(\"\")\n    log.warning(\"warning\")\n    print(\"\")\n    log.error(\"error\")\n    print(\"\")\n    log.critical(\"critical\")\n    print(\"\")\n    log.event(\"do_req\", a=1, b=\"c\")\n", "common/swaglog.py": "import logging\nimport os\nimport time\nimport warnings\nfrom pathlib import Path\nfrom logging.handlers import BaseRotatingHandler\n\nimport zmq\n\nfrom openpilot.common.logging_extra import SwagLogger, SwagFormatter, SwagLogFileFormatter\nfrom openpilot.system.hardware.hw import Paths\n\n\ndef get_file_handler():\n  Path(Paths.swaglog_root()).mkdir(parents=True, exist_ok=True)\n  base_filename = os.path.join(Paths.swaglog_root(), \"swaglog\")\n  handler = SwaglogRotatingFileHandler(base_filename)\n  return handler\n\nclass SwaglogRotatingFileHandler(BaseRotatingHandler):\n  def __init__(self, base_filename, interval=60, max_bytes=1024*256, backup_count=2500, encoding=None):\n    super().__init__(base_filename, mode=\"a\", encoding=encoding, delay=True)\n    self.base_filename = base_filename\n    self.interval = interval # seconds\n    self.max_bytes = max_bytes\n    self.backup_count = backup_count\n    self.log_files = self.get_existing_logfiles()\n    log_indexes = [f.split(\".\")[-1] for f in self.log_files]\n    self.last_file_idx = max([int(i) for i in log_indexes if i.isdigit()] or [-1])\n    self.last_rollover = None\n    self.doRollover()\n\n  def _open(self):\n    self.last_rollover = time.monotonic()\n    self.last_file_idx += 1\n    next_filename = f\"{self.base_filename}.{self.last_file_idx:010}\"\n    stream = open(next_filename, self.mode, encoding=self.encoding)\n    self.log_files.insert(0, next_filename)\n    return stream\n\n  def get_existing_logfiles(self):\n    log_files = list()\n    base_dir = os.path.dirname(self.base_filename)\n    for fn in os.listdir(base_dir):\n      fp = os.path.join(base_dir, fn)\n      if fp.startswith(self.base_filename) and os.path.isfile(fp):\n        log_files.append(fp)\n    return sorted(log_files)\n\n  def shouldRollover(self, record):\n    size_exceeded = self.max_bytes > 0 and self.stream.tell() >= self.max_bytes\n    time_exceeded = self.interval > 0 and self.last_rollover + self.interval <= time.monotonic()\n    return size_exceeded or time_exceeded\n\n  def doRollover(self):\n    if self.stream:\n      self.stream.close()\n    self.stream = self._open()\n\n    if self.backup_count > 0:\n      while len(self.log_files) > self.backup_count:\n        to_delete = self.log_files.pop()\n        if os.path.exists(to_delete): # just being safe, should always exist\n          os.remove(to_delete)\n\nclass UnixDomainSocketHandler(logging.Handler):\n  def __init__(self, formatter):\n    logging.Handler.__init__(self)\n    self.setFormatter(formatter)\n    self.pid = None\n\n    self.zctx = None\n    self.sock = None\n\n  def __del__(self):\n    self.close()\n\n  def close(self):\n    if self.sock is not None:\n      self.sock.close()\n    if self.zctx is not None:\n      self.zctx.term()\n\n  def connect(self):\n    self.zctx = zmq.Context()\n    self.sock = self.zctx.socket(zmq.PUSH)\n    self.sock.setsockopt(zmq.LINGER, 10)\n    self.sock.connect(Paths.swaglog_ipc())\n    self.pid = os.getpid()\n\n  def emit(self, record):\n    if os.getpid() != self.pid:\n      # TODO suppresses warning about forking proc with zmq socket, fix root cause\n      warnings.filterwarnings(\"ignore\", category=ResourceWarning, message=\"unclosed.*<zmq.*>\")\n      self.connect()\n\n    msg = self.format(record).rstrip('\\n')\n    # print(\"SEND\".format(repr(msg)))\n    try:\n      s = chr(record.levelno)+msg\n      self.sock.send(s.encode('utf8'), zmq.NOBLOCK)\n    except zmq.error.Again:\n      # drop :/\n      pass\n\n\ndef add_file_handler(log):\n  \"\"\"\n  Function to add the file log handler to swaglog.\n  This can be used to store logs when logmessaged is not running.\n  \"\"\"\n  handler = get_file_handler()\n  handler.setFormatter(SwagLogFileFormatter(log))\n  log.addHandler(handler)\n\n\ncloudlog = log = SwagLogger()\nlog.setLevel(logging.DEBUG)\n\n\nouthandler = logging.StreamHandler()\n\nprint_level = os.environ.get('LOGPRINT', 'warning')\nif print_level == 'debug':\n  outhandler.setLevel(logging.DEBUG)\nelif print_level == 'info':\n  outhandler.setLevel(logging.INFO)\nelif print_level == 'warning':\n  outhandler.setLevel(logging.WARNING)\n\nipchandler = UnixDomainSocketHandler(SwagFormatter(log))\n\nlog.addHandler(outhandler)\n# logs are sent through IPC before writing to disk to prevent disk I/O blocking\nlog.addHandler(ipchandler)\n", "common/markdown.py": "HTML_REPLACEMENTS = [\n  (r'&', r'&amp;'),\n  (r'\"', r'&quot;'),\n]\n\ndef parse_markdown(text: str, tab_length: int = 2) -> str:\n  lines = text.split(\"\\n\")\n  output: list[str] = []\n  list_level = 0\n\n  def end_outstanding_lists(level: int, end_level: int) -> int:\n    while level > end_level:\n      level -= 1\n      output.append(\"</ul>\")\n      if level > 0:\n        output.append(\"</li>\")\n    return end_level\n\n  for i, line in enumerate(lines):\n    if i + 1 < len(lines) and lines[i + 1].startswith(\"===\"):  # heading\n      output.append(f\"<h1>{line}</h1>\")\n    elif line.startswith(\"===\"):\n      pass\n    elif line.lstrip().startswith(\"* \"):  # list\n      line_level = 1 + line.count(\" \" * tab_length, 0, line.index(\"*\"))\n      if list_level >= line_level:\n        list_level = end_outstanding_lists(list_level, line_level)\n      else:\n        list_level += 1\n        if list_level > 1:\n          output[-1] = output[-1].replace(\"</li>\", \"\")\n        output.append(\"<ul>\")\n      output.append(f\"<li>{line.replace('*', '', 1).lstrip()}</li>\")\n    else:\n      list_level = end_outstanding_lists(list_level, 0)\n      if len(line) > 0:\n        output.append(line)\n\n  end_outstanding_lists(list_level, 0)\n  output_str = \"\\n\".join(output) + \"\\n\"\n\n  for (fr, to) in HTML_REPLACEMENTS:\n    output_str = output_str.replace(fr, to)\n\n  return output_str\n", "common/filter_simple.py": "class FirstOrderFilter:\n  # first order filter\n  def __init__(self, x0, rc, dt, initialized=True):\n    self.x = x0\n    self.dt = dt\n    self.update_alpha(rc)\n    self.initialized = initialized\n\n  def update_alpha(self, rc):\n    self.alpha = self.dt / (rc + self.dt)\n\n  def update(self, x):\n    if self.initialized:\n      self.x = (1. - self.alpha) * self.x + self.alpha * x\n    else:\n      self.initialized = True\n      self.x = x\n    return self.x\n", "common/realtime.py": "\"\"\"Utilities for reading real time clocks and keeping soft real time constraints.\"\"\"\nimport gc\nimport os\nimport time\nfrom collections import deque\n\nfrom openpilot.common.threadname import getthreadname\n\nfrom openpilot.system.hardware import PC\n\n\n# time step for each process\nDT_CTRL = 0.01  # controlsd\nDT_MDL = 0.05  # model\nDT_HW = 0.5  # hardwared and manager\nDT_DMON = 0.05  # driver monitoring\n\n\nclass Priority:\n  # CORE 2\n  # - modeld = 55\n  # - camerad = 54\n  CTRL_LOW = 51 # plannerd & radard\n\n  # CORE 3\n  # - pandad = 55\n  CTRL_HIGH = 53\n\n\ndef set_realtime_priority(level: int) -> None:\n  if not PC:\n    os.sched_setscheduler(0, os.SCHED_FIFO, os.sched_param(level))\n\n\ndef set_core_affinity(cores: list[int]) -> None:\n  if not PC:\n    os.sched_setaffinity(0, cores)\n\n\ndef config_realtime_process(cores: int | list[int], priority: int) -> None:\n  gc.disable()\n  set_realtime_priority(priority)\n  c = cores if isinstance(cores, list) else [cores, ]\n  set_core_affinity(c)\n\n\nclass Ratekeeper:\n  def __init__(self, rate: float, print_delay_threshold: float | None = 0.0) -> None:\n    \"\"\"Rate in Hz for ratekeeping. print_delay_threshold must be nonnegative.\"\"\"\n    self._interval = 1. / rate\n    self._next_frame_time = time.monotonic() + self._interval\n    self._print_delay_threshold = print_delay_threshold\n    self._frame = 0\n    self._remaining = 0.0\n    self._thread_name = getthreadname()\n    self._dts = deque([self._interval], maxlen=100)\n    self._last_monitor_time = time.monotonic()\n\n  @property\n  def frame(self) -> int:\n    return self._frame\n\n  @property\n  def remaining(self) -> float:\n    return self._remaining\n\n  @property\n  def lagging(self) -> bool:\n    avg_dt = sum(self._dts) / len(self._dts)\n    expected_dt = self._interval * (1 / 0.9)\n    return avg_dt > expected_dt\n\n  # Maintain loop rate by calling this at the end of each loop\n  def keep_time(self) -> bool:\n    lagged = self.monitor_time()\n    if self._remaining > 0:\n      time.sleep(self._remaining)\n    return lagged\n\n  # Monitors the cumulative lag, but does not enforce a rate\n  def monitor_time(self) -> bool:\n    prev = self._last_monitor_time\n    self._last_monitor_time = time.monotonic()\n    self._dts.append(self._last_monitor_time - prev)\n\n    lagged = False\n    remaining = self._next_frame_time - time.monotonic()\n    self._next_frame_time += self._interval\n    if self._print_delay_threshold is not None and remaining < -self._print_delay_threshold:\n      print(f\"{self._thread_name} lagging by {-remaining * 1000:.2f} ms\")\n      lagged = True\n    self._frame += 1\n    self._remaining = remaining\n    return lagged\n", "common/mock/generators.py": "from cereal import messaging\n\n\nLOCATION1 = (32.7174, -117.16277)\nLOCATION2 = (32.7558, -117.2037)\n\nLLK_DECIMATION = 10\nRENDER_FRAMES = 15\nDEFAULT_ITERATIONS = RENDER_FRAMES * LLK_DECIMATION\n\n\ndef generate_liveLocationKalman(location=LOCATION1):\n  msg = messaging.new_message('liveLocationKalman')\n  msg.liveLocationKalman.positionGeodetic = {'value': [*location, 0], 'std': [0., 0., 0.], 'valid': True}\n  msg.liveLocationKalman.positionECEF = {'value': [0., 0., 0.], 'std': [0., 0., 0.], 'valid': True}\n  msg.liveLocationKalman.calibratedOrientationNED = {'value': [0., 0., 0.], 'std': [0., 0., 0.], 'valid': True}\n  msg.liveLocationKalman.velocityCalibrated = {'value': [0., 0., 0.], 'std': [0., 0., 0.], 'valid': True}\n  msg.liveLocationKalman.status = 'valid'\n  msg.liveLocationKalman.gpsOK = True\n  return msg\n", "common/mock/__init__.py": "\"\"\"\nUtilities for generating mock messages for testing.\nexample in common/tests/test_mock.py\n\"\"\"\n\n\nimport functools\nimport threading\nfrom cereal.messaging import PubMaster\nfrom cereal.services import SERVICE_LIST\nfrom openpilot.common.mock.generators import generate_liveLocationKalman\nfrom openpilot.common.realtime import Ratekeeper\n\n\nMOCK_GENERATOR = {\n  \"liveLocationKalman\": generate_liveLocationKalman\n}\n\n\ndef generate_messages_loop(services: list[str], done: threading.Event):\n  pm = PubMaster(services)\n  rk = Ratekeeper(100)\n  i = 0\n  while not done.is_set():\n    for s in services:\n      should_send = i % (100/SERVICE_LIST[s].frequency) == 0\n      if should_send:\n        message = MOCK_GENERATOR[s]()\n        pm.send(s, message)\n    i += 1\n    rk.keep_time()\n\n\ndef mock_messages(services: list[str] | str):\n  if isinstance(services, str):\n    services = [services]\n\n  def decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n      done = threading.Event()\n      t = threading.Thread(target=generate_messages_loop, args=(services, done))\n      t.start()\n      try:\n        return func(*args, **kwargs)\n      finally:\n        done.set()\n        t.join()\n    return wrapper\n  return decorator\n", "common/api/__init__.py": "import jwt\nimport os\nimport requests\nfrom datetime import datetime, timedelta, UTC\nfrom openpilot.system.hardware.hw import Paths\nfrom openpilot.system.version import get_version\n\nAPI_HOST = os.getenv('API_HOST', 'https://api.commadotai.com')\n\nclass Api:\n  def __init__(self, dongle_id):\n    self.dongle_id = dongle_id\n    with open(Paths.persist_root()+'/comma/id_rsa') as f:\n      self.private_key = f.read()\n\n  def get(self, *args, **kwargs):\n    return self.request('GET', *args, **kwargs)\n\n  def post(self, *args, **kwargs):\n    return self.request('POST', *args, **kwargs)\n\n  def request(self, method, endpoint, timeout=None, access_token=None, **params):\n    return api_get(endpoint, method=method, timeout=timeout, access_token=access_token, **params)\n\n  def get_token(self, expiry_hours=1):\n    now = datetime.now(UTC).replace(tzinfo=None)\n    payload = {\n      'identity': self.dongle_id,\n      'nbf': now,\n      'iat': now,\n      'exp': now + timedelta(hours=expiry_hours)\n    }\n    token = jwt.encode(payload, self.private_key, algorithm='RS256')\n    if isinstance(token, bytes):\n      token = token.decode('utf8')\n    return token\n\n\ndef api_get(endpoint, method='GET', timeout=None, access_token=None, **params):\n  headers = {}\n  if access_token is not None:\n    headers['Authorization'] = \"JWT \" + access_token\n\n  headers['User-Agent'] = \"openpilot-\" + get_version()\n\n  return requests.request(method, API_HOST + \"/\" + endpoint, timeout=timeout, headers=headers, params=params)\n", "common/transformations/model.py": "import numpy as np\n\nfrom openpilot.common.transformations.orientation import rot_from_euler\nfrom openpilot.common.transformations.camera import get_view_frame_from_calib_frame, view_frame_from_device_frame\n\n# segnet\nSEGNET_SIZE = (512, 384)\n\n# MED model\nMEDMODEL_INPUT_SIZE = (512, 256)\nMEDMODEL_YUV_SIZE = (MEDMODEL_INPUT_SIZE[0], MEDMODEL_INPUT_SIZE[1] * 3 // 2)\nMEDMODEL_CY = 47.6\n\nmedmodel_fl = 910.0\nmedmodel_intrinsics = np.array([\n  [medmodel_fl,  0.0,  0.5 * MEDMODEL_INPUT_SIZE[0]],\n  [0.0,  medmodel_fl,                   MEDMODEL_CY],\n  [0.0,  0.0,                                   1.0]])\n\n\n# BIG model\nBIGMODEL_INPUT_SIZE = (1024, 512)\nBIGMODEL_YUV_SIZE = (BIGMODEL_INPUT_SIZE[0], BIGMODEL_INPUT_SIZE[1] * 3 // 2)\n\nbigmodel_fl = 910.0\nbigmodel_intrinsics = np.array([\n  [bigmodel_fl,  0.0,  0.5 * BIGMODEL_INPUT_SIZE[0]],\n  [0.0,  bigmodel_fl,             256 + MEDMODEL_CY],\n  [0.0,  0.0,                                   1.0]])\n\n\n# SBIG model (big model with the size of small model)\nSBIGMODEL_INPUT_SIZE = (512, 256)\nSBIGMODEL_YUV_SIZE = (SBIGMODEL_INPUT_SIZE[0], SBIGMODEL_INPUT_SIZE[1] * 3 // 2)\n\nsbigmodel_fl = 455.0\nsbigmodel_intrinsics = np.array([\n  [sbigmodel_fl,  0.0,  0.5 * SBIGMODEL_INPUT_SIZE[0]],\n  [0.0,  sbigmodel_fl,      0.5 * (256 + MEDMODEL_CY)],\n  [0.0,  0.0,                                     1.0]])\n\nbigmodel_frame_from_calib_frame = np.dot(bigmodel_intrinsics,\n  get_view_frame_from_calib_frame(0, 0, 0, 0))\n\n\nsbigmodel_frame_from_calib_frame = np.dot(sbigmodel_intrinsics,\n  get_view_frame_from_calib_frame(0, 0, 0, 0))\n\nmedmodel_frame_from_calib_frame = np.dot(medmodel_intrinsics,\n  get_view_frame_from_calib_frame(0, 0, 0, 0))\n\nmedmodel_frame_from_bigmodel_frame = np.dot(medmodel_intrinsics, np.linalg.inv(bigmodel_intrinsics))\n\ncalib_from_medmodel = np.linalg.inv(medmodel_frame_from_calib_frame[:, :3])\ncalib_from_sbigmodel = np.linalg.inv(sbigmodel_frame_from_calib_frame[:, :3])\n\n# This function is verified to give similar results to xx.uncommon.utils.transform_img\ndef get_warp_matrix(device_from_calib_euler: np.ndarray, intrinsics: np.ndarray, bigmodel_frame: bool = False) -> np.ndarray:\n  calib_from_model = calib_from_sbigmodel if bigmodel_frame else calib_from_medmodel\n  device_from_calib = rot_from_euler(device_from_calib_euler)\n  camera_from_calib = intrinsics @ view_frame_from_device_frame @ device_from_calib\n  warp_matrix: np.ndarray = camera_from_calib @ calib_from_model\n  return warp_matrix\n", "common/transformations/camera.py": "import itertools\nimport numpy as np\nfrom dataclasses import dataclass\n\nimport openpilot.common.transformations.orientation as orient\n\n## -- hardcoded hardware params --\n@dataclass(frozen=True)\nclass CameraConfig:\n  width: int\n  height: int\n  focal_length: float\n\n  @property\n  def size(self):\n    return (self.width, self.height)\n\n  @property\n  def intrinsics(self):\n    # aka 'K' aka camera_frame_from_view_frame\n    return np.array([\n      [self.focal_length,  0.0, float(self.width)/2],\n      [0.0, self.focal_length, float(self.height)/2],\n      [0.0,  0.0, 1.0]\n    ])\n\n  @property\n  def intrinsics_inv(self):\n    # aka 'K_inv' aka view_frame_from_camera_frame\n    return np.linalg.inv(self.intrinsics)\n\n@dataclass(frozen=True)\nclass _NoneCameraConfig(CameraConfig):\n  width: int = 0\n  height: int = 0\n  focal_length: float = 0\n\n@dataclass(frozen=True)\nclass DeviceCameraConfig:\n  fcam: CameraConfig\n  dcam: CameraConfig\n  ecam: CameraConfig\n\n  def all_cams(self):\n    for cam in ['fcam', 'dcam', 'ecam']:\n      if not isinstance(getattr(self, cam), _NoneCameraConfig):\n        yield cam, getattr(self, cam)\n\n_ar_ox_fisheye = CameraConfig(1928, 1208, 567.0)  # focal length probably wrong? magnification is not consistent across frame\n_os_fisheye = CameraConfig(2688, 1520, 567.0 / 2 * 3)\n_ar_ox_config = DeviceCameraConfig(CameraConfig(1928, 1208, 2648.0), _ar_ox_fisheye, _ar_ox_fisheye)\n_os_config = DeviceCameraConfig(CameraConfig(2688, 1520, 2648.0 * 2 / 3), _os_fisheye, _os_fisheye)\n_neo_config = DeviceCameraConfig(CameraConfig(1164, 874, 910.0), CameraConfig(816, 612, 650.0), _NoneCameraConfig())\n\nDEVICE_CAMERAS = {\n  # A \"device camera\" is defined by a device type and sensor\n\n  # sensor type was never set on eon/neo/two\n  (\"neo\", \"unknown\"): _neo_config,\n  # unknown here is AR0231, field was added with OX03C10 support\n  (\"tici\", \"unknown\"): _ar_ox_config,\n\n  # before deviceState.deviceType was set, assume tici AR config\n  (\"unknown\", \"ar0231\"): _ar_ox_config,\n  (\"unknown\", \"ox03c10\"): _ar_ox_config,\n\n  # simulator (emulates a tici)\n  (\"pc\", \"unknown\"): _ar_ox_config,\n}\nprods = itertools.product(('tici', 'tizi', 'mici'), (('ar0231', _ar_ox_config), ('ox03c10', _ar_ox_config), ('os04c10', _os_config)))\nDEVICE_CAMERAS.update({(d, c[0]): c[1] for d, c in prods})\n\n# device/mesh : x->forward, y-> right, z->down\n# view : x->right, y->down, z->forward\ndevice_frame_from_view_frame = np.array([\n  [ 0.,  0.,  1.],\n  [ 1.,  0.,  0.],\n  [ 0.,  1.,  0.]\n])\nview_frame_from_device_frame = device_frame_from_view_frame.T\n\n\n# aka 'extrinsic_matrix'\n# road : x->forward, y -> left, z->up\ndef get_view_frame_from_road_frame(roll, pitch, yaw, height):\n  device_from_road = orient.rot_from_euler([roll, pitch, yaw]).dot(np.diag([1, -1, -1]))\n  view_from_road = view_frame_from_device_frame.dot(device_from_road)\n  return np.hstack((view_from_road, [[0], [height], [0]]))\n\n\n\n# aka 'extrinsic_matrix'\ndef get_view_frame_from_calib_frame(roll, pitch, yaw, height):\n  device_from_calib= orient.rot_from_euler([roll, pitch, yaw])\n  view_from_calib = view_frame_from_device_frame.dot(device_from_calib)\n  return np.hstack((view_from_calib, [[0], [height], [0]]))\n\n\ndef vp_from_ke(m):\n  \"\"\"\n  Computes the vanishing point from the product of the intrinsic and extrinsic\n  matrices C = KE.\n\n  The vanishing point is defined as lim x->infinity C (x, 0, 0, 1).T\n  \"\"\"\n  return (m[0, 0]/m[2, 0], m[1, 0]/m[2, 0])\n\n\ndef roll_from_ke(m):\n  # note: different from calibration.h/RollAnglefromKE: i think that one's just wrong\n  return np.arctan2(-(m[1, 0] - m[1, 1] * m[2, 0] / m[2, 1]),\n                    -(m[0, 0] - m[0, 1] * m[2, 0] / m[2, 1]))\n\n\ndef normalize(img_pts, intrinsics):\n  # normalizes image coordinates\n  # accepts single pt or array of pts\n  intrinsics_inv = np.linalg.inv(intrinsics)\n  img_pts = np.array(img_pts)\n  input_shape = img_pts.shape\n  img_pts = np.atleast_2d(img_pts)\n  img_pts = np.hstack((img_pts, np.ones((img_pts.shape[0], 1))))\n  img_pts_normalized = img_pts.dot(intrinsics_inv.T)\n  img_pts_normalized[(img_pts < 0).any(axis=1)] = np.nan\n  return img_pts_normalized[:, :2].reshape(input_shape)\n\n\ndef denormalize(img_pts, intrinsics, width=np.inf, height=np.inf):\n  # denormalizes image coordinates\n  # accepts single pt or array of pts\n  img_pts = np.array(img_pts)\n  input_shape = img_pts.shape\n  img_pts = np.atleast_2d(img_pts)\n  img_pts = np.hstack((img_pts, np.ones((img_pts.shape[0], 1), dtype=img_pts.dtype)))\n  img_pts_denormalized = img_pts.dot(intrinsics.T)\n  if np.isfinite(width):\n    img_pts_denormalized[img_pts_denormalized[:, 0] > width] = np.nan\n    img_pts_denormalized[img_pts_denormalized[:, 0] < 0] = np.nan\n  if np.isfinite(height):\n    img_pts_denormalized[img_pts_denormalized[:, 1] > height] = np.nan\n    img_pts_denormalized[img_pts_denormalized[:, 1] < 0] = np.nan\n  return img_pts_denormalized[:, :2].reshape(input_shape)\n\n\ndef get_calib_from_vp(vp, intrinsics):\n  vp_norm = normalize(vp, intrinsics)\n  yaw_calib = np.arctan(vp_norm[0])\n  pitch_calib = -np.arctan(vp_norm[1]*np.cos(yaw_calib))\n  roll_calib = 0\n  return roll_calib, pitch_calib, yaw_calib\n\n\ndef device_from_ecef(pos_ecef, orientation_ecef, pt_ecef):\n  # device from ecef frame\n  # device frame is x -> forward, y-> right, z -> down\n  # accepts single pt or array of pts\n  input_shape = pt_ecef.shape\n  pt_ecef = np.atleast_2d(pt_ecef)\n  ecef_from_device_rot = orient.rotations_from_quats(orientation_ecef)\n  device_from_ecef_rot = ecef_from_device_rot.T\n  pt_ecef_rel = pt_ecef - pos_ecef\n  pt_device = np.einsum('jk,ik->ij', device_from_ecef_rot, pt_ecef_rel)\n  return pt_device.reshape(input_shape)\n\n\ndef img_from_device(pt_device):\n  # img coordinates from pts in device frame\n  # first transforms to view frame, then to img coords\n  # accepts single pt or array of pts\n  input_shape = pt_device.shape\n  pt_device = np.atleast_2d(pt_device)\n  pt_view = np.einsum('jk,ik->ij', view_frame_from_device_frame, pt_device)\n\n  # This function should never return negative depths\n  pt_view[pt_view[:, 2] < 0] = np.nan\n\n  pt_img = pt_view/pt_view[:, 2:3]\n  return pt_img.reshape(input_shape)[:, :2]\n\n", "common/transformations/coordinates.py": "from openpilot.common.transformations.orientation import numpy_wrap\nfrom openpilot.common.transformations.transformations import (ecef2geodetic_single,\n                                                    geodetic2ecef_single)\nfrom openpilot.common.transformations.transformations import LocalCoord as LocalCoord_single\n\n\nclass LocalCoord(LocalCoord_single):\n  ecef2ned = numpy_wrap(LocalCoord_single.ecef2ned_single, (3,), (3,))\n  ned2ecef = numpy_wrap(LocalCoord_single.ned2ecef_single, (3,), (3,))\n  geodetic2ned = numpy_wrap(LocalCoord_single.geodetic2ned_single, (3,), (3,))\n  ned2geodetic = numpy_wrap(LocalCoord_single.ned2geodetic_single, (3,), (3,))\n\n\ngeodetic2ecef = numpy_wrap(geodetic2ecef_single, (3,), (3,))\necef2geodetic = numpy_wrap(ecef2geodetic_single, (3,), (3,))\n\ngeodetic_from_ecef = ecef2geodetic\necef_from_geodetic = geodetic2ecef\n", "common/transformations/orientation.py": "import numpy as np\nfrom collections.abc import Callable\n\nfrom openpilot.common.transformations.transformations import (ecef_euler_from_ned_single,\n                                                    euler2quat_single,\n                                                    euler2rot_single,\n                                                    ned_euler_from_ecef_single,\n                                                    quat2euler_single,\n                                                    quat2rot_single,\n                                                    rot2euler_single,\n                                                    rot2quat_single)\n\n\ndef numpy_wrap(function, input_shape, output_shape) -> Callable[..., np.ndarray]:\n  \"\"\"Wrap a function to take either an input or list of inputs and return the correct shape\"\"\"\n  def f(*inps):\n    *args, inp = inps\n    inp = np.array(inp)\n    shape = inp.shape\n\n    if len(shape) == len(input_shape):\n      out_shape = output_shape\n    else:\n      out_shape = (shape[0],) + output_shape\n\n    # Add empty dimension if inputs is not a list\n    if len(shape) == len(input_shape):\n      inp.shape = (1, ) + inp.shape\n\n    result = np.asarray([function(*args, i) for i in inp])\n    result.shape = out_shape\n    return result\n  return f\n\n\neuler2quat = numpy_wrap(euler2quat_single, (3,), (4,))\nquat2euler = numpy_wrap(quat2euler_single, (4,), (3,))\nquat2rot = numpy_wrap(quat2rot_single, (4,), (3, 3))\nrot2quat = numpy_wrap(rot2quat_single, (3, 3), (4,))\neuler2rot = numpy_wrap(euler2rot_single, (3,), (3, 3))\nrot2euler = numpy_wrap(rot2euler_single, (3, 3), (3,))\necef_euler_from_ned = numpy_wrap(ecef_euler_from_ned_single, (3,), (3,))\nned_euler_from_ecef = numpy_wrap(ned_euler_from_ecef_single, (3,), (3,))\n\nquats_from_rotations = rot2quat\nquat_from_rot = rot2quat\nrotations_from_quats = quat2rot\nrot_from_quat = quat2rot\neuler_from_rot = rot2euler\neuler_from_quat = quat2euler\nrot_from_euler = euler2rot\nquat_from_euler = euler2quat\n", "common/transformations/__init__.py": "", "site_scons/site_tools/cython.py": "import re\nimport SCons\nfrom SCons.Action import Action\nfrom SCons.Scanner import Scanner\n\npyx_from_import_re = re.compile(r'^from\\s+(\\S+)\\s+cimport', re.M)\npyx_import_re = re.compile(r'^cimport\\s+(\\S+)', re.M)\ncdef_import_re = re.compile(r'^cdef extern from\\s+.(\\S+).:', re.M)\n\n\ndef pyx_scan(node, env, path, arg=None):\n  contents = node.get_text_contents()\n\n  # from <module> cimport ...\n  matches = pyx_from_import_re.findall(contents)\n  # cimport <module>\n  matches += pyx_import_re.findall(contents)\n\n  # Modules can be either .pxd or .pyx files\n  files = [m.replace('.', '/') + '.pxd' for m in matches]\n  files += [m.replace('.', '/') + '.pyx' for m in matches]\n\n  # cdef extern from <file>\n  files += cdef_import_re.findall(contents)\n\n  # Handle relative imports\n  cur_dir = str(node.get_dir())\n  files = [cur_dir + f if f.startswith('/') else f for f in files]\n\n  # Filter out non-existing files (probably system imports)\n  files = [f for f in files if env.File(f).exists()]\n  return env.File(files)\n\n\npyxscanner = Scanner(function=pyx_scan, skeys=['.pyx', '.pxd'], recursive=True)\ncythonAction = Action(\"$CYTHONCOM\")\n\n\ndef create_builder(env):\n  try:\n    cython = env['BUILDERS']['Cython']\n  except KeyError:\n    cython = SCons.Builder.Builder(\n      action=cythonAction,\n      emitter={},\n      suffix=cython_suffix_emitter,\n      single_source=1\n    )\n    env.Append(SCANNERS=pyxscanner)\n    env['BUILDERS']['Cython'] = cython\n  return cython\n\ndef cython_suffix_emitter(env, source):\n  return \"$CYTHONCFILESUFFIX\"\n\ndef generate(env):\n  env[\"CYTHON\"] = \"cythonize\"\n  env[\"CYTHONCOM\"] = \"$CYTHON $CYTHONFLAGS $SOURCE\"\n  env[\"CYTHONCFILESUFFIX\"] = \".cpp\"\n\n  c_file, _ = SCons.Tool.createCFileBuilders(env)\n\n  c_file.suffix['.pyx'] = cython_suffix_emitter\n  c_file.add_action('.pyx', cythonAction)\n\n  c_file.suffix['.py'] = cython_suffix_emitter\n  c_file.add_action('.py', cythonAction)\n\n  create_builder(env)\n\ndef exists(env):\n  return True\n"}