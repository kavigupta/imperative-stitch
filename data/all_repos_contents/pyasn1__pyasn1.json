{"setup.py": "#!/usr/bin/env python\n#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom setuptools import setup\n\nsetup()\n", "docs/source/conf.py": "# -*- coding: utf-8 -*-\n#\n# PyASN1 documentation build configuration file, created by\n# sphinx-quickstart on Sat Jun 27 23:15:54 2015.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('.'))\n\nimport os, sys\n# add ../.. to module lookup path\nsys.path.insert(\n    0,\n    os.path.abspath(\n        os.path.join(os.path.dirname(__file__), \"..\", \"..\")\n    )\n)\nimport pyasn1\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.napoleon',\n    'sphinx.ext.intersphinx',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['.templates']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'contents'\n\n# General information about the project.\nproject = u'ASN.1 types and codecs'\ncopyright = u'2005-2020, Ilya Etingof <etingof@gmail.com>'\nauthor = u'Ilya Etingof <etingof@gmail.com>'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \".\".join(pyasn1.__version__.split(\".\")[:2])\n# The full version, including alpha/beta/rc tags.\nrelease = pyasn1.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = \"en\"\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'alabaster'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    'logo': 'logo.svg',\n    'description': '<p align=left><i><b>Brewing free software for the greater good</i></b></p>',\n    'show_powered_by': False,\n    'github_user': 'etingof',\n    'github_repo': 'pyasn1',\n    'fixed_sidebar': True,\n}\n\nhtml_sidebars = {\n    '**': [\n        'about.html',\n        'navigation.html',\n        'relations.html',\n        'searchbox.html',\n        'donate.html',\n    ]\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = \"\"\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = '.static/favicon.ico'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['.static']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n# html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = False\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\nhtml_show_sphinx = False\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'\n# html_search_language = 'en'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n# html_search_options = {'type': 'default'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n# html_search_scorer = 'scorer.js'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'pyasn1doc'\n\n# html_context = {\n#     'include_analytics': 'PYASN1DEV' in os.environ\n# }\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    # 'papersize': 'letterpaper',\n\n    # The font size ('10pt', '11pt' or '12pt').\n    # 'pointsize': '10pt',\n\n    # Additional stuff for the LaTeX preamble.\n    # 'preamble': '',\n\n    # Latex figure (float) alignment\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, 'PyASN1.tex', u'PyASN1 Documentation',\n     u'Ilya Etingof \\\\textless{}etingof@gmail.com\\\\textgreater{}', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'pyasn1', u'PyASN1 Documentation',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'PyASN1', u'PyASN1 Documentation',\n     author, 'PyASN1', 'One line description of project.',\n     'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n# texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {'python': ('https://docs.python.org/3.10/', None)}\n\n# this merges constructor docstring with class docstring\nautoclass_content = 'both'\n# Sort members by type\nautodoc_member_order = 'bysource'\n# autodoc_member_order = 'groupwise'\n\n# Napoleon settings\nnapoleon_google_docstring = False\nnapoleon_numpy_docstring = True\nnapoleon_include_private_with_doc = False\nnapoleon_include_special_with_doc = True\nnapoleon_use_admonition_for_examples = False\nnapoleon_use_admonition_for_notes = False\nnapoleon_use_admonition_for_references = False\nnapoleon_use_ivar = False\nnapoleon_use_param = False\nnapoleon_use_rtype = False\n", "tests/base.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nfrom pyasn1 import debug\n\n\nclass BaseTestCase(unittest.TestCase):\n\n    def setUp(self):\n        debug.setLogger(debug.Debug('all', printer=lambda *x: None))\n\n    def tearDown(self):\n        debug.setLogger(None)\n", "tests/test_debug.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\n\nclass DebugCaseBase(BaseTestCase):\n    def testKnownFlags(self):\n        debug.setLogger(0)\n        debug.setLogger(debug.Debug('all', 'encoder', 'decoder'))\n        debug.setLogger(0)\n\n    def testUnknownFlags(self):\n        try:\n            debug.setLogger(debug.Debug('all', 'unknown', loggerName='xxx'))\n\n        except error.PyAsn1Error:\n            debug.setLogger(0)\n            return\n\n        else:\n            debug.setLogger(0)\n            assert 0, 'unknown debug flag tolerated'\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.test_debug.suite',\n     'tests.type.__main__.suite',\n     'tests.codec.__main__.suite',\n     'tests.compat.__main__.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/type/test_namedval.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import namedval\n\n\nclass NamedValuesCaseBase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.e = namedval.NamedValues(('off', 0), ('on', 1))\n\n    def testDict(self):\n        assert set(self.e.items()) == {('off', 0), ('on', 1)}\n        assert set(self.e.keys()) == {'off', 'on'}\n        assert set(self.e) == {'off', 'on'}\n        assert set(self.e.values()) == {0, 1}\n        assert 'on' in self.e and 'off' in self.e and 'xxx' not in self.e\n        assert 0 in self.e and 1 in self.e and 2 not in self.e\n\n    def testInit(self):\n        assert namedval.NamedValues(off=0, on=1) == {'off': 0, 'on': 1}\n        assert namedval.NamedValues('off', 'on') == {'off': 0, 'on': 1}\n        assert namedval.NamedValues(('c', 0)) == {'c': 0}\n        assert namedval.NamedValues('a', 'b', ('c', 0), d=1) == {'c': 0, 'd': 1, 'a': 2, 'b': 3}\n\n    def testLen(self):\n        assert len(self.e) == 2\n        assert len(namedval.NamedValues()) == 0\n\n    def testAdd(self):\n        assert namedval.NamedValues(off=0) + namedval.NamedValues(on=1) == {'off': 0, 'on': 1}\n\n    def testClone(self):\n        assert namedval.NamedValues(off=0).clone(('on', 1)) == {'off': 0, 'on': 1}\n        assert namedval.NamedValues(off=0).clone(on=1) == {'off': 0, 'on': 1}\n\n    def testStrRepr(self):\n        assert str(self.e)\n        assert repr(self.e)\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/test_constraint.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import constraint\nfrom pyasn1.type import error\n\n\nclass SingleValueConstraintTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.v1 = 1, 2\n        self.v2 = 3, 4\n        self.c1 = constraint.SingleValueConstraint(*self.v1)\n        self.c2 = constraint.SingleValueConstraint(*self.v2)\n\n    def testCmp(self):\n        assert self.c1 == self.c1, 'comparison fails'\n\n    def testHash(self):\n        assert hash(self.c1) != hash(self.c2), 'hash() fails'\n\n    def testGoodVal(self):\n        try:\n            self.c1(1)\n\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(4)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n    def testContains(self):\n        for v in self.v1:\n            assert v in self.c1\n            assert v not in self.c2\n\n        for v in self.v2:\n            assert v in self.c2\n            assert v not in self.c1\n\n    def testIter(self):\n        assert set(self.v1) == set(self.c1)\n        assert set(self.v2) == set(self.c2)\n\n    def testSub(self):\n        subconst = self.c1 - constraint.SingleValueConstraint(self.v1[0])\n        assert list(subconst) == [self.v1[1]]\n\n    def testAdd(self):\n        superconst = self.c1 + self.c2\n        assert set(superconst) == set(self.v1 + self.v2)\n\n\nclass ContainedSubtypeConstraintTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ContainedSubtypeConstraint(\n            constraint.SingleValueConstraint(12)\n        )\n\n    def testGoodVal(self):\n        try:\n            self.c1(12)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(4)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass ValueRangeConstraintTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ValueRangeConstraint(1, 4)\n\n    def testGoodVal(self):\n        try:\n            self.c1(1)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(-5)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass ValueSizeConstraintTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ValueSizeConstraint(1, 2)\n\n    def testGoodVal(self):\n        try:\n            self.c1('a')\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1('abc')\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass PermittedAlphabetConstraintTestCase(SingleValueConstraintTestCase):\n    def setUp(self):\n        self.v1 = 'A', 'B'\n        self.v2 = 'C', 'D'\n        self.c1 = constraint.PermittedAlphabetConstraint(*self.v1)\n        self.c2 = constraint.PermittedAlphabetConstraint(*self.v2)\n\n    def testGoodVal(self):\n        try:\n            self.c1('A')\n\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1('E')\n\n        except error.ValueConstraintError:\n            pass\n\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass WithComponentsConstraintTestCase(BaseTestCase):\n\n    def testGoodVal(self):\n        c = constraint.WithComponentsConstraint(\n            ('A', constraint.ComponentPresentConstraint()),\n            ('B', constraint.ComponentAbsentConstraint()))\n\n        try:\n            c({'A': 1})\n\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testGoodValWithExtraFields(self):\n        c = constraint.WithComponentsConstraint(\n            ('A', constraint.ComponentPresentConstraint()),\n            ('B', constraint.ComponentAbsentConstraint())\n        )\n\n        try:\n            c({'A': 1, 'C': 2})\n\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testEmptyConstraint(self):\n        c = constraint.WithComponentsConstraint()\n\n        try:\n            c({'A': 1})\n\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        c = constraint.WithComponentsConstraint(\n            ('A', constraint.ComponentPresentConstraint())\n        )\n\n        try:\n            c({'B': 2})\n\n        except error.ValueConstraintError:\n            pass\n\n        else:\n            assert 0, 'constraint check fails'\n\n    def testBadValExtraFields(self):\n        c = constraint.WithComponentsConstraint(\n            ('A', constraint.ComponentPresentConstraint())\n        )\n\n        try:\n            c({'B': 2, 'C': 3})\n\n        except error.ValueConstraintError:\n            pass\n\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass ConstraintsIntersectionTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ConstraintsIntersection(\n            constraint.SingleValueConstraint(4),\n            constraint.ValueRangeConstraint(2, 4)\n        )\n\n    def testCmp1(self):\n        assert constraint.SingleValueConstraint(4) in self.c1, '__cmp__() fails'\n\n    def testCmp2(self):\n        assert constraint.SingleValueConstraint(5) not in self.c1, \\\n            '__cmp__() fails'\n\n    def testCmp3(self):\n        c = constraint.ConstraintsUnion(constraint.ConstraintsIntersection(\n            constraint.SingleValueConstraint(4),\n            constraint.ValueRangeConstraint(2, 4))\n        )\n        assert self.c1 in c, '__cmp__() fails'\n\n    def testCmp4(self):\n        c = constraint.ConstraintsUnion(\n            constraint.ConstraintsIntersection(constraint.SingleValueConstraint(5))\n        )\n        assert self.c1 not in c, '__cmp__() fails'\n\n    def testGoodVal(self):\n        try:\n            self.c1(4)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(-5)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass InnerTypeConstraintTestCase(BaseTestCase):\n    def testConst1(self):\n        c = constraint.InnerTypeConstraint(\n            constraint.SingleValueConstraint(4)\n        )\n        try:\n            c(4, 32)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n        try:\n            c(5, 32)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n    def testConst2(self):\n        c = constraint.InnerTypeConstraint(\n            (0, constraint.SingleValueConstraint(4), 'PRESENT'),\n            (1, constraint.SingleValueConstraint(4), 'ABSENT')\n        )\n        try:\n            c(4, 0)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n        try:\n            c(4, 1)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n        try:\n            c(3, 0)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n        # Constraints compositions\n\n\nclass ConstraintsIntersectionRangeTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ConstraintsIntersection(\n            constraint.ValueRangeConstraint(1, 9),\n            constraint.ValueRangeConstraint(2, 5)\n        )\n\n    def testGoodVal(self):\n        try:\n            self.c1(3)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(0)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass ConstraintsUnionTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ConstraintsUnion(\n            constraint.SingleValueConstraint(5),\n            constraint.ValueRangeConstraint(1, 3)\n        )\n\n    def testGoodVal(self):\n        try:\n            self.c1(2)\n            self.c1(5)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(-5)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\nclass ConstraintsExclusionTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.c1 = constraint.ConstraintsExclusion(\n            constraint.ValueRangeConstraint(2, 4)\n        )\n\n    def testGoodVal(self):\n        try:\n            self.c1(6)\n        except error.ValueConstraintError:\n            assert 0, 'constraint check fails'\n\n    def testBadVal(self):\n        try:\n            self.c1(2)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint check fails'\n\n\n# Constraints derivations\n\nclass DirectDerivationTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.c1 = constraint.SingleValueConstraint(5)\n\n        self.c2 = constraint.ConstraintsUnion(\n            self.c1, constraint.ValueRangeConstraint(1, 3)\n        )\n\n    def testGoodVal(self):\n        assert self.c1.isSuperTypeOf(self.c2), 'isSuperTypeOf failed'\n        assert not self.c1.isSubTypeOf(self.c2), 'isSubTypeOf failed'\n\n    def testBadVal(self):\n        assert not self.c2.isSuperTypeOf(self.c1), 'isSuperTypeOf failed'\n        assert self.c2.isSubTypeOf(self.c1), 'isSubTypeOf failed'\n\n\nclass IndirectDerivationTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.c1 = constraint.ConstraintsIntersection(\n            constraint.ValueRangeConstraint(1, 30)\n        )\n\n        self.c2 = constraint.ConstraintsIntersection(\n            self.c1, constraint.ValueRangeConstraint(1, 20)\n        )\n\n        self.c2 = constraint.ConstraintsIntersection(\n            self.c2, constraint.ValueRangeConstraint(1, 10)\n        )\n\n    def testGoodVal(self):\n        assert self.c1.isSuperTypeOf(self.c2), 'isSuperTypeOf failed'\n        assert not self.c1.isSubTypeOf(self.c2), 'isSubTypeOf failed'\n\n    def testBadVal(self):\n        assert not self.c2.isSuperTypeOf(self.c1), 'isSuperTypeOf failed'\n        assert self.c2.isSubTypeOf(self.c1), 'isSubTypeOf failed'\n\n# TODO: how to apply size constraints to constructed types?\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/test_opentype.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import univ\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.compat.octets import str2octs\nfrom pyasn1.error import PyAsn1Error\n\n\nclass UntaggedAnyTestCase(BaseTestCase):\n\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any())\n            )\n\n        self.s = Sequence()\n\n    def testTypeCheckOnAssignment(self):\n\n        self.s.clear()\n\n        self.s['blob'] = univ.Any(str2octs('xxx'))\n\n        # this should succeed because Any is untagged and unconstrained\n        self.s['blob'] = univ.Integer(123)\n\n\nclass TaggedAnyTestCase(BaseTestCase):\n\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.taggedAny = univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 20))\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', self.taggedAny)\n            )\n\n        self.s = Sequence()\n\n    def testTypeCheckOnAssignment(self):\n\n        self.s.clear()\n\n        self.s['blob'] = self.taggedAny.clone('xxx')\n\n        try:\n            self.s.setComponentByName('blob', univ.Integer(123))\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'non-open type assignment tolerated'\n\n\nclass TaggedAnyOpenTypeTestCase(BaseTestCase):\n\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.taggedAny = univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 20))\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', self.taggedAny, openType=opentype.OpenType(name='id'))\n            )\n\n        self.s = Sequence()\n\n    def testTypeCheckOnAssignment(self):\n\n        self.s.clear()\n\n        self.s['blob'] = univ.Any(str2octs('xxx'))\n        self.s['blob'] = univ.Integer(123)\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/test_univ.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport math\nimport pickle\nimport platform\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import univ\nfrom pyasn1.type import tag\nfrom pyasn1.type import constraint\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import namedval\nfrom pyasn1.type import error\nfrom pyasn1.compat.octets import str2octs, ints2octs, octs2ints, octs2str\nfrom pyasn1.error import PyAsn1Error\nfrom pyasn1.error import PyAsn1UnicodeEncodeError, PyAsn1UnicodeDecodeError\n\n\nclass NoValueTestCase(BaseTestCase):\n    def testSingleton(self):\n        assert univ.NoValue() is univ.NoValue(), 'NoValue is not a singleton'\n\n    def testRepr(self):\n        try:\n            repr(univ.noValue)\n\n        except PyAsn1Error:\n            assert False, 'repr() on NoValue object fails'\n\n    def testIsInstance(self):\n        try:\n            assert isinstance(univ.noValue, univ.NoValue), 'isinstance() on NoValue() object fails'\n\n        except PyAsn1Error:\n            assert False, 'isinstance() on NoValue object fails'\n\n    def testStr(self):\n        try:\n            str(univ.noValue)\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'str() works for NoValue object'\n\n    def testLen(self):\n        try:\n            len(univ.noValue)\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'len() works for NoValue object'\n\n    def testCmp(self):\n        try:\n            univ.noValue == 1\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'comparison works for NoValue object'\n\n    def testSubs(self):\n        try:\n            univ.noValue[0]\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, '__getitem__() works for NoValue object'\n\n    def testKey(self):\n        try:\n            univ.noValue['key']\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, '__getitem__() works for NoValue object'\n\n    def testKeyAssignment(self):\n        try:\n            univ.noValue['key'] = 123\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, '__setitem__() works for NoValue object'\n\n    def testInt(self):\n        try:\n            int(univ.noValue)\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'integer conversion works for NoValue object'\n\n    def testAdd(self):\n        try:\n            univ.noValue + univ.noValue\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'addition works for NoValue object'\n\n    def testBitShift(self):\n        try:\n            univ.noValue << 1\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'bitshift works for NoValue object'\n\n    def testBooleanEvaluation(self):\n        try:\n            if univ.noValue:\n                pass\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'boolean evaluation works for NoValue object'\n    \n    @unittest.skipIf(\n        platform.python_implementation() == \"PyPy\",\n        \"getsizeof() raises TypeError on PyPy\"\n    )\n    def testSizeOf(self):\n        try:\n            sys.getsizeof(univ.noValue)\n\n        except PyAsn1Error:\n            assert False, 'sizeof failed for NoValue object'\n\n\nclass IntegerTestCase(BaseTestCase):\n    def testStr(self):\n        assert str(univ.Integer(1)) in ('1', '1L'), 'str() fails'\n\n    def testRepr(self):\n        assert '123' in repr(univ.Integer(123))\n\n    def testAnd(self):\n        assert univ.Integer(1) & 0 == 0, '__and__() fails'\n\n    def testOr(self):\n        assert univ.Integer(1) | 0 == 1, '__or__() fails'\n\n    def testXor(self):\n        assert univ.Integer(1) ^ 0 == 1, '__xor__() fails'\n\n    def testRand(self):\n        assert 0 & univ.Integer(1) == 0, '__rand__() fails'\n\n    def testRor(self):\n        assert 0 | univ.Integer(1) == 1, '__ror__() fails'\n\n    def testRxor(self):\n        assert 0 ^ univ.Integer(1) == 1, '__rxor__() fails'\n\n    def testAdd(self):\n        assert univ.Integer(-4) + 6 == 2, '__add__() fails'\n\n    def testRadd(self):\n        assert 4 + univ.Integer(5) == 9, '__radd__() fails'\n\n    def testSub(self):\n        assert univ.Integer(3) - 6 == -3, '__sub__() fails'\n\n    def testRsub(self):\n        assert 6 - univ.Integer(3) == 3, '__rsub__() fails'\n\n    def testMul(self):\n        assert univ.Integer(3) * -3 == -9, '__mul__() fails'\n\n    def testRmul(self):\n        assert 2 * univ.Integer(3) == 6, '__rmul__() fails'\n\n    def testDivInt(self):\n        assert univ.Integer(4) / 2 == 2, '__div__() fails'\n\n    if sys.version_info[0] > 2:\n        def testDivFloat(self):\n            assert univ.Integer(3) / 2 == 1.5, '__div__() fails'\n\n        def testRdivFloat(self):\n            assert 3 / univ.Integer(2) == 1.5, '__rdiv__() fails'\n    else:\n        def testDivFloat(self):\n            assert univ.Integer(3) / 2 == 1, '__div__() fails'\n\n        def testRdivFloat(self):\n            assert 3 / univ.Integer(2) == 1, '__rdiv__() fails'\n\n    def testRdivInt(self):\n        assert 6 / univ.Integer(3) == 2, '__rdiv__() fails'\n\n    if sys.version_info[0] > 2:\n        def testTrueDiv(self):\n            assert univ.Integer(3) / univ.Integer(2) == 1.5, '__truediv__() fails'\n\n    def testFloorDiv(self):\n        assert univ.Integer(3) // univ.Integer(2) == 1, '__floordiv__() fails'\n\n    def testMod(self):\n        assert univ.Integer(3) % 2 == 1, '__mod__() fails'\n\n    def testRmod(self):\n        assert 4 % univ.Integer(3) == 1, '__rmod__() fails'\n\n    def testPow(self):\n        assert univ.Integer(3) ** 2 == 9, '__pow__() fails'\n\n    def testRpow(self):\n        assert 2 ** univ.Integer(2) == 4, '__rpow__() fails'\n\n    def testLshift(self):\n        assert univ.Integer(1) << 1 == 2, '<< fails'\n\n    def testRshift(self):\n        assert univ.Integer(2) >> 1 == 1, '>> fails'\n\n    def testInt(self):\n        assert int(univ.Integer(3)) == 3, '__int__() fails'\n\n    def testLong(self):\n        assert int(univ.Integer(8)) == 8, '__long__() fails'\n\n    def testFloat(self):\n        assert float(univ.Integer(4)) == 4.0, '__float__() fails'\n\n    def testPos(self):\n        assert +univ.Integer(1) == 1, '__pos__() fails'\n\n    def testNeg(self):\n        assert -univ.Integer(1) == -1, '__neg__() fails'\n\n    def testInvert(self):\n        assert ~univ.Integer(1) == -2, '__invert__() fails'\n\n    def testRound(self):\n        assert round(univ.Integer(1), 3) == 1.0, '__round__() fails'\n\n    def testFloor(self):\n        assert math.floor(univ.Integer(1)) == 1, '__floor__() fails'\n\n    def testCeil(self):\n        assert math.ceil(univ.Integer(1)) == 1, '__ceil__() fails'\n\n    def testTrunc(self):\n        assert math.trunc(univ.Integer(1)) == 1, '__trunc__() fails'\n\n    def testPrettyIn(self):\n        assert univ.Integer('3') == 3, 'prettyIn() fails'\n\n    def testTag(self):\n        assert univ.Integer().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x02)\n        )\n\n    def testNamedVals(self):\n\n        class Integer(univ.Integer):\n            namedValues = univ.Integer.namedValues.clone(('asn1', 1))\n\n        assert Integer('asn1') == 1, 'named val fails'\n        assert int(Integer('asn1')) == 1, 'named val fails'\n        assert str(Integer('asn1')) == 'asn1', 'named val __str__() fails'\n\n    def testSubtype(self):\n        assert univ.Integer().subtype(\n            value=1,\n            implicitTag=tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 2),\n            subtypeSpec=constraint.SingleValueConstraint(1, 3)\n        ) == univ.Integer(\n            value=1,\n            tagSet=tag.TagSet(tag.Tag(tag.tagClassPrivate,\n                                      tag.tagFormatSimple, 2)),\n            subtypeSpec=constraint.ConstraintsIntersection(constraint.SingleValueConstraint(1, 3))\n        )\n\n\nclass IntegerPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Integer()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Integer\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Integer(-123)\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == -123\n\n\nclass BooleanTestCase(BaseTestCase):\n    def testTruth(self):\n        assert univ.Boolean(True) and univ.Boolean(1), 'Truth initializer fails'\n\n    def testFalse(self):\n        assert not univ.Boolean(False) and not univ.Boolean(0), 'False initializer fails'\n\n    def testStr(self):\n        assert str(univ.Boolean(1)) == 'True', 'str() fails'\n\n    def testInt(self):\n        assert int(univ.Boolean(1)) == 1, 'int() fails'\n\n    def testRepr(self):\n        assert 'Boolean' in repr(univ.Boolean(1))\n\n    def testTag(self):\n        assert univ.Boolean().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x01)\n        )\n\n    def testConstraints(self):\n\n        class Boolean(univ.Boolean):\n            pass\n\n        try:\n            Boolean(2)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint fail'\n\n\nclass BooleanPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Boolean()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Boolean\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Boolean(True)\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == True\n\n\nclass BitStringTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.b = univ.BitString(\n            namedValues=namedval.NamedValues(('Active', 0), ('Urgent', 1))\n        )\n\n    def testBinDefault(self):\n\n        class BinDefault(univ.BitString):\n            defaultBinValue = '1010100110001010'\n\n        assert BinDefault() == univ.BitString(binValue='1010100110001010')\n\n    def testHexDefault(self):\n\n        class HexDefault(univ.BitString):\n            defaultHexValue = 'A98A'\n\n        assert HexDefault() == univ.BitString(hexValue='A98A')\n\n    def testSet(self):\n        assert self.b.clone('Active') == (1,)\n        assert self.b.clone('Urgent') == (0, 1)\n        assert self.b.clone('Urgent, Active') == (1, 1)\n        assert self.b.clone(\"'1010100110001010'B\") == (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0)\n        assert self.b.clone(\"'A98A'H\") == (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0)\n        assert self.b.clone(binValue='1010100110001010') == (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0)\n        assert self.b.clone(hexValue='A98A') == (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0)\n        assert self.b.clone('1010100110001010') == (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0)\n        assert self.b.clone((1, 0, 1)) == (1, 0, 1)\n\n    def testStr(self):\n        assert str(self.b.clone('Urgent')) == '01'\n\n    def testRepr(self):\n        assert 'BitString' in repr(self.b.clone('Urgent,Active'))\n\n    def testTag(self):\n        assert univ.BitString().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x03)\n        )\n\n    def testLen(self):\n        assert len(self.b.clone(\"'A98A'H\")) == 16\n\n    def testGetItem(self):\n        assert self.b.clone(\"'A98A'H\")[0] == 1\n        assert self.b.clone(\"'A98A'H\")[1] == 0\n        assert self.b.clone(\"'A98A'H\")[2] == 1\n\n    def testReverse(self):\n        assert list(reversed(univ.BitString([0, 0, 1]))) == list(univ.BitString([1, 0, 0]))\n\n    def testAsOctets(self):\n        assert self.b.clone(hexValue='A98A').asOctets() == ints2octs((0xa9, 0x8a)), 'testAsOctets() fails'\n\n    def testAsInts(self):\n        assert self.b.clone(hexValue='A98A').asNumbers() == (0xa9, 0x8a), 'testAsNumbers() fails'\n\n    def testMultipleOfEightPadding(self):\n        assert self.b.clone((1, 0, 1)).asNumbers() == (5,)\n\n    def testAsInteger(self):\n        assert self.b.clone('11000000011001').asInteger() == 12313\n        assert self.b.clone('1100110011011111').asInteger() == 52447\n\n    def testStaticDef(self):\n\n        class BitString(univ.BitString):\n            pass\n\n        assert BitString('11000000011001').asInteger() == 12313\n\n\nclass BitStringPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.BitString()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.BitString\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.BitString((1, 0, 1, 0))\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == (1, 0, 1, 0)\n\n\nclass OctetStringWithUnicodeMixIn(object):\n\n    initializer = ()\n    encoding = 'us-ascii'\n\n    def setUp(self):\n        self.pythonString = ints2octs(self.initializer).decode(self.encoding)\n        self.encodedPythonString = self.pythonString.encode(self.encoding)\n        self.numbersString = tuple(octs2ints(self.encodedPythonString))\n\n    def testInit(self):\n        assert univ.OctetString(self.encodedPythonString) == self.encodedPythonString, '__init__() fails'\n\n    def testInitFromAsn1(self):\n            assert univ.OctetString(univ.OctetString(self.encodedPythonString)) == self.encodedPythonString\n            assert univ.OctetString(univ.Integer(123)) == univ.OctetString('123')\n\n    def testSerialised(self):\n        if sys.version_info[0] < 3:\n            assert str(univ.OctetString(self.encodedPythonString, encoding=self.encoding)) == self.encodedPythonString, '__str__() fails'\n        else:\n            assert bytes(univ.OctetString(self.encodedPythonString, encoding=self.encoding)) == self.encodedPythonString, '__str__() fails'\n\n    def testPrintable(self):\n        if sys.version_info[0] < 3:\n            assert str(univ.OctetString(self.encodedPythonString, encoding=self.encoding)) == self.encodedPythonString, '__str__() fails'\n            assert unicode(univ.OctetString(self.pythonString, encoding=self.encoding)) == self.pythonString, 'unicode init fails'\n        else:\n            assert str(univ.OctetString(self.pythonString, encoding=self.encoding)) == self.pythonString, 'unicode init fails'\n\n    def testSeq(self):\n        assert univ.OctetString(self.encodedPythonString)[0] == self.encodedPythonString[0], '__getitem__() fails'\n\n    def testRepr(self):\n        assert 'abc' in repr(univ.OctetString('abc'))\n\n    def testAsOctets(self):\n        assert univ.OctetString(self.encodedPythonString).asOctets() == self.encodedPythonString, 'testAsOctets() fails'\n\n    def testAsInts(self):\n        assert univ.OctetString(self.encodedPythonString).asNumbers() == self.numbersString, 'testAsNumbers() fails'\n\n    def testAdd(self):\n        assert univ.OctetString(self.encodedPythonString) + self.encodedPythonString == self.encodedPythonString + self.encodedPythonString, '__add__() fails'\n\n    def testRadd(self):\n        assert self.encodedPythonString + univ.OctetString(self.encodedPythonString) == self.encodedPythonString + self.encodedPythonString, '__radd__() fails'\n\n    def testMul(self):\n        assert univ.OctetString(self.encodedPythonString) * 2 == self.encodedPythonString * 2, '__mul__() fails'\n\n    def testRmul(self):\n        assert 2 * univ.OctetString(self.encodedPythonString) == 2 * self.encodedPythonString, '__rmul__() fails'\n\n    def testContains(self):\n        s = univ.OctetString(self.encodedPythonString)\n        assert self.encodedPythonString in s\n        assert self.encodedPythonString * 2 not in s\n\n    def testReverse(self):\n        assert list(reversed(univ.OctetString(self.encodedPythonString))) == list(reversed(self.encodedPythonString))\n\n\nclass OctetStringWithAsciiTestCase(OctetStringWithUnicodeMixIn, BaseTestCase):\n    initializer = (97, 102)\n    encoding = 'us-ascii'\n\n\nclass OctetStringUnicodeErrorTestCase(BaseTestCase):\n    def testEncodeError(self):\n        serialized = ints2octs((0xff, 0xfe))\n\n        if sys.version_info < (3, 0):\n            text = serialized.decode('iso-8859-1')\n\n        else:\n            text = octs2str(serialized)\n\n        try:\n            univ.OctetString(text, encoding='us-ascii')\n\n        except PyAsn1UnicodeEncodeError:\n            pass\n\n    def testDecodeError(self):\n        serialized = ints2octs((0xff, 0xfe))\n\n        octetString = univ.OctetString(serialized, encoding='us-ascii')\n\n        try:\n            if sys.version_info < (3, 0):\n                unicode(octetString)\n\n            else:\n                str(octetString)\n\n        except PyAsn1UnicodeDecodeError:\n            pass\n\n\nclass OctetStringWithUtf8TestCase(OctetStringWithUnicodeMixIn, BaseTestCase):\n    initializer = (208, 176, 208, 177, 208, 178)\n    encoding = 'utf-8'\n\n\nclass OctetStringWithUtf16TestCase(OctetStringWithUnicodeMixIn, BaseTestCase):\n    initializer = (4, 48, 4, 49, 4, 50)\n    encoding = 'utf-16-be'\n\n\nif sys.version_info[0] > 2:\n\n    # Somehow comparison of UTF-32 encoded strings does not work in Py2\n\n    class OctetStringWithUtf32TestCase(OctetStringWithUnicodeMixIn, BaseTestCase):\n        initializer = (0, 0, 4, 48, 0, 0, 4, 49, 0, 0, 4, 50)\n        encoding = 'utf-32-be'\n\n\nclass OctetStringTestCase(BaseTestCase):\n\n    def testBinDefault(self):\n\n        class BinDefault(univ.OctetString):\n            defaultBinValue = '1000010111101110101111000000111011'\n\n        assert BinDefault() == univ.OctetString(binValue='1000010111101110101111000000111011')\n\n    def testHexDefault(self):\n\n        class HexDefault(univ.OctetString):\n            defaultHexValue = 'FA9823C43E43510DE3422'\n\n        assert HexDefault() == univ.OctetString(hexValue='FA9823C43E43510DE3422')\n\n    def testBinStr(self):\n        assert univ.OctetString(binValue=\"1000010111101110101111000000111011\") == ints2octs((133, 238, 188, 14, 192)), 'bin init fails'\n\n    def testHexStr(self):\n        assert univ.OctetString(hexValue=\"FA9823C43E43510DE3422\") == ints2octs((250, 152, 35, 196, 62, 67, 81, 13, 227, 66, 32)), 'hex init fails'\n\n    def testTuple(self):\n        assert univ.OctetString((1, 2, 3, 4, 5)) == ints2octs((1, 2, 3, 4, 5)), 'tuple init failed'\n\n    def testRepr(self):\n        assert 'abc' in repr(univ.OctetString('abc'))\n\n    def testEmpty(self):\n        try:\n            str(univ.OctetString())\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'empty OctetString() not reported'\n\n    def testTag(self):\n        assert univ.OctetString().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x04)\n        )\n\n    def testStaticDef(self):\n\n        class OctetString(univ.OctetString):\n            pass\n\n        assert OctetString(hexValue=\"FA9823C43E43510DE3422\") == ints2octs((250, 152, 35, 196, 62, 67, 81, 13, 227, 66, 32))\n\n\nclass OctetStringPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.BitString()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.BitString\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.BitString((1, 0, 1, 0))\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == (1, 0, 1, 0)\n\n\nclass Null(BaseTestCase):\n\n    def testInit(self):\n        assert not univ.Null().isValue\n        assert univ.Null(0) == str2octs('')\n        assert univ.Null(False) == str2octs('')\n        assert univ.Null('') == str2octs('')\n        assert univ.Null(None) == str2octs('')\n\n        try:\n            assert univ.Null(True)\n\n        except PyAsn1Error:\n            pass\n\n        try:\n            assert univ.Null('xxx')\n\n        except PyAsn1Error:\n            pass\n\n    def testStr(self):\n        assert str(univ.Null('')) == '', 'str() fails'\n\n    def testRepr(self):\n        assert 'Null' in repr(univ.Null(''))\n\n    def testTag(self):\n        assert univ.Null().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x05)\n        )\n\n    def testConstraints(self):\n        try:\n            univ.Null(2)\n        except error.ValueConstraintError:\n            pass\n        else:\n            assert 0, 'constraint fail'\n\n    def testStaticDef(self):\n\n        class Null(univ.Null):\n            pass\n\n        assert not Null('')\n\n\nclass NullPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Null()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Null\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Null('')\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert not new_asn1\n\n\nclass RealTestCase(BaseTestCase):\n    def testFloat4BinEnc(self):\n        assert univ.Real((0.25, 2, 3)) == 2.0, 'float initializer for binary encoding fails'\n\n    def testStr(self):\n        assert str(univ.Real(1.0)) == '1.0', 'str() fails'\n\n    def testRepr(self):\n        assert 'Real' in repr(univ.Real(-4.1))\n        assert 'Real' in repr(univ.Real(-4.1))\n        assert 'inf' in repr(univ.Real('inf'))\n        assert '-inf' in repr(univ.Real('-inf'))\n\n    def testAdd(self):\n        assert univ.Real(-4.1) + 1.4 == -2.7, '__add__() fails'\n\n    def testRadd(self):\n        assert 4 + univ.Real(0.5) == 4.5, '__radd__() fails'\n\n    def testSub(self):\n        assert univ.Real(3.9) - 1.7 == 2.2, '__sub__() fails'\n\n    def testRsub(self):\n        assert 6.1 - univ.Real(0.1) == 6, '__rsub__() fails'\n\n    def testMul(self):\n        assert univ.Real(3.0) * -3 == -9, '__mul__() fails'\n\n    def testRmul(self):\n        assert 2 * univ.Real(3.0) == 6, '__rmul__() fails'\n\n    def testDiv(self):\n        assert univ.Real(3.0) / 2 == 1.5, '__div__() fails'\n\n    def testRdiv(self):\n        assert 6 / univ.Real(3.0) == 2, '__rdiv__() fails'\n\n    def testMod(self):\n        assert univ.Real(3.0) % 2 == 1, '__mod__() fails'\n\n    def testRmod(self):\n        assert 4 % univ.Real(3.0) == 1, '__rmod__() fails'\n\n    def testPow(self):\n        assert univ.Real(3.0) ** 2 == 9, '__pow__() fails'\n\n    def testRpow(self):\n        assert 2 ** univ.Real(2.0) == 4, '__rpow__() fails'\n\n    def testInt(self):\n        assert int(univ.Real(3.0)) == 3, '__int__() fails'\n\n    def testLong(self):\n        assert int(univ.Real(8.0)) == 8, '__long__() fails'\n\n    def testFloat(self):\n        assert float(univ.Real(4.0)) == 4.0, '__float__() fails'\n\n    def testPrettyIn(self):\n        assert univ.Real((3, 10, 0)) == 3, 'prettyIn() fails'\n\n    # infinite float values\n    def testStrInf(self):\n        assert str(univ.Real('inf')) == 'inf', 'str() fails'\n\n    def testAddInf(self):\n        assert univ.Real('inf') + 1 == float('inf'), '__add__() fails'\n\n    def testRaddInf(self):\n        assert 1 + univ.Real('inf') == float('inf'), '__radd__() fails'\n\n    def testIntInf(self):\n        try:\n            assert int(univ.Real('inf'))\n        except OverflowError:\n            pass\n        else:\n            assert 0, '__int__() fails'\n\n    def testLongInf(self):\n        try:\n            assert int(univ.Real('inf'))\n        except OverflowError:\n            pass\n        else:\n            assert 0, '__long__() fails'\n        assert int(univ.Real(8.0)) == 8, '__long__() fails'\n\n    def testFloatInf(self):\n        assert float(univ.Real('-inf')) == float('-inf'), '__float__() fails'\n\n    def testPrettyInInf(self):\n        assert univ.Real(float('inf')) == float('inf'), 'prettyIn() fails'\n\n    def testPlusInf(self):\n        assert univ.Real('inf').isPlusInf, 'isPlusInfinity failed'\n\n    def testMinusInf(self):\n        assert univ.Real('-inf').isMinusInf, 'isMinusInfinity failed'\n\n    def testPos(self):\n        assert +univ.Real(1.0) == 1.0, '__pos__() fails'\n\n    def testNeg(self):\n        assert -univ.Real(1.0) == -1.0, '__neg__() fails'\n\n    def testRound(self):\n        assert round(univ.Real(1.123), 2) == 1.12, '__round__() fails'\n\n    def testFloor(self):\n        assert math.floor(univ.Real(1.6)) == 1.0, '__floor__() fails'\n\n    def testCeil(self):\n        assert math.ceil(univ.Real(1.2)) == 2.0, '__ceil__() fails'\n\n    def testTrunc(self):\n        assert math.trunc(univ.Real(1.1)) == 1.0, '__trunc__() fails'\n\n    def testTag(self):\n        assert univ.Real().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x09)\n        )\n\n    def testStaticDef(self):\n\n        class Real(univ.Real):\n            pass\n\n        assert Real(1.0) == 1.0\n\n\nclass RealPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Real()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Real\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Real((1, 10, 3))\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == 1000\n\n\nclass ObjectIdentifier(BaseTestCase):\n    def testStr(self):\n        assert str(univ.ObjectIdentifier((1, 3, 6))) == '1.3.6', 'str() fails'\n\n    def testRepr(self):\n        assert '1.3.6' in repr(univ.ObjectIdentifier('1.3.6'))\n\n    def testEq(self):\n        assert univ.ObjectIdentifier((1, 3, 6)) == (1, 3, 6), '__cmp__() fails'\n\n    def testAdd(self):\n        assert univ.ObjectIdentifier((1, 3)) + (6,) == (1, 3, 6), '__add__() fails'\n\n    def testRadd(self):\n        assert (1,) + univ.ObjectIdentifier((3, 6)) == (1, 3, 6), '__radd__() fails'\n\n    def testLen(self):\n        assert len(univ.ObjectIdentifier((1, 3))) == 2, '__len__() fails'\n\n    def testPrefix(self):\n        o = univ.ObjectIdentifier('1.3.6')\n        assert o.isPrefixOf((1, 3, 6)), 'isPrefixOf() fails'\n        assert o.isPrefixOf((1, 3, 6, 1)), 'isPrefixOf() fails'\n        assert not o.isPrefixOf((1, 3)), 'isPrefixOf() fails'\n\n    def testInput1(self):\n        assert univ.ObjectIdentifier('1.3.6') == (1, 3, 6), 'prettyIn() fails'\n\n    def testInput2(self):\n        assert univ.ObjectIdentifier((1, 3, 6)) == (1, 3, 6), 'prettyIn() fails'\n\n    def testInput3(self):\n        assert univ.ObjectIdentifier(univ.ObjectIdentifier('1.3') + (6,)) == (1, 3, 6), 'prettyIn() fails'\n\n    def testUnicode(self):\n        s = '1.3.6'\n        if sys.version_info[0] < 3:\n            s = s.decode()\n        assert univ.ObjectIdentifier(s) == (1, 3, 6), 'unicode init fails'\n\n    def testTag(self):\n        assert univ.ObjectIdentifier().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x06)\n        )\n\n    def testContains(self):\n        s = univ.ObjectIdentifier('1.3.6.1234.99999')\n        assert 1234 in s\n        assert 4321 not in s\n\n    def testStaticDef(self):\n\n        class ObjectIdentifier(univ.ObjectIdentifier):\n            pass\n\n        assert str(ObjectIdentifier((1, 3, 6))) == '1.3.6'\n\n\nclass ObjectIdentifierPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.ObjectIdentifier()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.ObjectIdentifier\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.ObjectIdentifier('2.3.1.1.2')\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == (2, 3, 1, 1, 2)\n\n\nclass RelativeOID(BaseTestCase):\n    def testStr(self):\n        assert str(univ.RelativeOID((1, 3, 6))) == '1.3.6', 'str() fails'\n\n    def testRepr(self):\n        assert '1.3.6' in repr(univ.RelativeOID('1.3.6'))\n\n    def testEq(self):\n        assert univ.RelativeOID((1, 3, 6)) == (1, 3, 6), '__cmp__() fails'\n\n    def testAdd(self):\n        assert univ.RelativeOID((1, 3)) + (6,) == (1, 3, 6), '__add__() fails'\n\n    def testRadd(self):\n        assert (1,) + univ.RelativeOID((3, 6)) == (1, 3, 6), '__radd__() fails'\n\n    def testLen(self):\n        assert len(univ.RelativeOID((1, 3))) == 2, '__len__() fails'\n\n    def testPrefix(self):\n        o = univ.RelativeOID('1.3.6')\n        assert o.isPrefixOf((1, 3, 6)), 'isPrefixOf() fails'\n        assert o.isPrefixOf((1, 3, 6, 1)), 'isPrefixOf() fails'\n        assert not o.isPrefixOf((1, 3)), 'isPrefixOf() fails'\n\n    def testInput1(self):\n        assert univ.RelativeOID('1.3.6') == (1, 3, 6), 'prettyIn() fails'\n\n    def testInput2(self):\n        assert univ.RelativeOID((1, 3, 6)) == (1, 3, 6), 'prettyIn() fails'\n\n    def testInput3(self):\n        assert univ.RelativeOID(univ.RelativeOID('1.3') + (6,)) == (1, 3, 6), 'prettyIn() fails'\n\n    def testUnicode(self):\n        s = '1.3.6'\n        if sys.version_info[0] < 3:\n            s = s.decode()\n        assert univ.RelativeOID(s) == (1, 3, 6), 'unicode init fails'\n\n    def testTag(self):\n        assert univ.RelativeOID().tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0d)\n        )\n\n    def testContains(self):\n        s = univ.RelativeOID('1.3.6.1234.99999')\n        assert 1234 in s\n        assert 4321 not in s\n\n    def testStaticDef(self):\n\n        class RelOID(univ.ObjectIdentifier):\n            pass\n\n        assert str(RelOID((1, 3, 6))) == '1.3.6'\n\n\nclass RelativeOIDPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.RelativeOID()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.RelativeOID\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.RelativeOID('2.3.1.1.2')\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == (2, 3, 1, 1, 2)\n\n\nclass SequenceOf(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s1 = univ.SequenceOf(\n            componentType=univ.OctetString('')\n        )\n        self.s2 = self.s1.clone()\n\n    def testRepr(self):\n        assert 'a' in repr(self.s1.clone().setComponents('a', 'b'))\n\n    def testTag(self):\n        assert self.s1.tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)\n        ), 'wrong tagSet'\n\n    def testSeq(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        assert self.s1[0] == str2octs('abc'), 'set by idx fails'\n        self.s1[0] = 'cba'\n        assert self.s1[0] == str2octs('cba'), 'set by idx fails'\n\n    def testCmp(self):\n        self.s1.clear()\n        self.s1.setComponentByPosition(0, 'abc')\n        self.s2.clear()\n        self.s2.setComponentByPosition(0, univ.OctetString('abc'))\n        assert self.s1 == self.s2, '__cmp__() fails'\n\n    def testSubtypeSpec(self):\n        s = self.s1.clone(\n            componentType=univ.OctetString().subtype(\n                subtypeSpec=constraint.SingleValueConstraint(str2octs('abc'))))\n        try:\n            s.setComponentByPosition(\n                0, univ.OctetString().subtype(\n                    'abc', subtypeSpec=constraint.SingleValueConstraint(str2octs('abc'))))\n        except PyAsn1Error:\n            assert 0, 'constraint fails'\n        try:\n            s.setComponentByPosition(1, univ.OctetString('Abc'))\n        except PyAsn1Error:\n            try:\n                s.setComponentByPosition(1, univ.OctetString('Abc'),\n                                         verifyConstraints=False)\n            except PyAsn1Error:\n                assert 0, 'constraint fails with verifyConstraints=False'\n        else:\n            assert 0, 'constraint fails'\n\n    def testComponentTagsMatching(self):\n        s = self.s1.clone()\n        s.strictConstraints = True  # This requires types equality\n        o = univ.OctetString('abc').subtype(explicitTag=tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 12))\n        try:\n            s.setComponentByPosition(0, o)\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'inner supertype tag allowed'\n\n    def testComponentConstraintsMatching(self):\n        s = self.s1.clone()\n        o = univ.OctetString().subtype(\n            subtypeSpec=constraint.ConstraintsUnion(constraint.SingleValueConstraint(str2octs('cba'))))\n        s.strictConstraints = True  # This requires types equality\n        try:\n            s.setComponentByPosition(0, o.clone('cba'))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'inner supertype constraint allowed'\n        s.strictConstraints = False  # This requires subtype relationships\n        try:\n            s.setComponentByPosition(0, o.clone('cba'))\n        except PyAsn1Error:\n            assert 0, 'inner supertype constraint disallowed'\n        else:\n            pass\n\n    def testConsistency(self):\n        s = self.s1.clone(subtypeSpec=constraint.ConstraintsUnion(\n            constraint.ValueSizeConstraint(1, 1)\n        ))\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        assert not s.isInconsistent, 'size spec fails'\n        s.setComponentByPosition(1, univ.OctetString('abc'))\n        assert s.isInconsistent, 'size spec fails'\n\n    def testGetComponentTagMap(self):\n        assert self.s1.componentType.tagMap.presentTypes == {\n            univ.OctetString.tagSet: univ.OctetString('')\n        }\n\n    def testSubtype(self):\n        subtype = self.s1.subtype(\n            implicitTag=tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 2),\n            subtypeSpec=constraint.ValueSizeConstraint(0, 1)\n        )\n        subtype.clear()\n        clone = self.s1.clone(\n            tagSet=tag.TagSet(tag.Tag(tag.tagClassPrivate,\n                                      tag.tagFormatSimple, 2)),\n            subtypeSpec=constraint.ValueSizeConstraint(0, 1)\n        )\n        clone.clear()\n        assert clone == subtype\n\n    def testClone(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        s = self.s1.clone()\n        s.clear()\n        assert len(s) == 0\n        s = self.s1.clone(cloneValueFlag=1)\n        assert len(s) == 1\n        assert s.getComponentByPosition(0) == self.s1.getComponentByPosition(0)\n\n    def testSetComponents(self):\n        assert self.s1.clone().setComponents('abc', 'def') == \\\n               self.s1.setComponentByPosition(0, 'abc').setComponentByPosition(1, 'def')\n\n    def testGetItem(self):\n        s = self.s1.clone()\n        s.append('xxx')\n        assert s[0]\n\n        # this is a deviation from standard sequence protocol\n        assert not s[2]\n\n    def testGetItemSlice(self):\n        s = self.s1.clone()\n        s.extend(['xxx', 'yyy', 'zzz'])\n        assert s[:1] == [str2octs('xxx')]\n        assert s[-2:] == [str2octs('yyy'), str2octs('zzz')]\n        assert s[1:2] == [str2octs('yyy')]\n\n    def testSetItem(self):\n        s = self.s1.clone()\n        s.append('xxx')\n        s[2] = 'yyy'\n        assert len(s) == 3\n        assert s[1] == str2octs('')\n\n    def testSetItemSlice(self):\n        s = self.s1.clone()\n        s[:1] = ['xxx']\n        assert s == [str2octs('xxx')]\n        s[-2:] = ['yyy', 'zzz']\n        assert s == [str2octs('yyy'), str2octs('zzz')]\n        s[1:2] = ['yyy']\n        assert s == [str2octs('yyy'), str2octs('yyy')]\n        assert len(s) == 2\n\n    def testAppend(self):\n        self.s1.clear()\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        assert len(self.s1) == 1\n        self.s1.append('def')\n        assert len(self.s1) == 2\n        assert list(self.s1) == [str2octs(x) for x in ['abc', 'def']]\n\n    def testExtend(self):\n        self.s1.clear()\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        assert len(self.s1) == 1\n        self.s1.extend(['def', 'ghi'])\n        assert len(self.s1) == 3\n        assert list(self.s1) == [str2octs(x) for x in ['abc', 'def', 'ghi']]\n\n    def testCount(self):\n        self.s1.clear()\n        for x in ['abc', 'def', 'abc']:\n            self.s1.append(x)\n        assert self.s1.count(str2octs('abc')) == 2\n        assert self.s1.count(str2octs('def')) == 1\n        assert self.s1.count(str2octs('ghi')) == 0\n\n    def testIndex(self):\n        self.s1.clear()\n        for x in ['abc', 'def', 'abc']:\n            self.s1.append(x)\n        assert self.s1.index(str2octs('abc')) == 0\n        assert self.s1.index(str2octs('def')) == 1\n        assert self.s1.index(str2octs('abc'), 1) == 2\n\n    def testSort(self):\n        self.s1.clear()\n        self.s1[0] = 'b'\n        self.s1[1] = 'a'\n        assert list(self.s1) == [str2octs('b'), str2octs('a')]\n        self.s1.sort()\n        assert list(self.s1) == [str2octs('a'), str2octs('b')]\n\n    def testStaticDef(self):\n\n        class SequenceOf(univ.SequenceOf):\n            componentType = univ.OctetString('')\n\n        s = SequenceOf()\n        s[0] = 'abc'\n        assert len(s) == 1\n        assert s == [str2octs('abc')]\n\n    def testUntyped(self):\n        n = univ.SequenceOf()\n\n        assert not n.isValue\n\n        n[0] = univ.OctetString('fox')\n\n        assert n.isValue\n\n    def testLegacyInitializer(self):\n        n = univ.SequenceOf(\n            componentType=univ.OctetString()\n        )\n        o = univ.SequenceOf(\n            univ.OctetString()  # this is the old way\n        )\n\n        assert n.isSameTypeWith(o) and o.isSameTypeWith(n)\n\n        n[0] = 'fox'\n        o[0] = 'fox'\n\n        assert n == o\n\n    def testGetComponentWithDefault(self):\n\n        class SequenceOf(univ.SequenceOf):\n            componentType = univ.OctetString()\n\n        s = SequenceOf()\n        assert s.getComponentByPosition(0, default=None, instantiate=False) is None\n        assert s.getComponentByPosition(0, default=None) is None\n        s[0] = 'test'\n        assert s.getComponentByPosition(0, default=None) is not None\n        assert s.getComponentByPosition(0, default=None) == str2octs('test')\n        s.clear()\n        assert s.getComponentByPosition(0, default=None) is None\n\n    def testGetComponentNoInstantiation(self):\n\n        class SequenceOf(univ.SequenceOf):\n            componentType = univ.OctetString()\n\n        s = SequenceOf()\n        assert s.getComponentByPosition(0, instantiate=False) is univ.noValue\n        s[0] = 'test'\n        assert s.getComponentByPosition(0, instantiate=False) is not univ.noValue\n        assert s.getComponentByPosition(0, instantiate=False) == str2octs('test')\n        s.clear()\n        assert s.getComponentByPosition(0, instantiate=False) is univ.noValue\n\n    def testClear(self):\n\n        class SequenceOf(univ.SequenceOf):\n            componentType = univ.OctetString()\n\n        s = SequenceOf()\n        s.setComponentByPosition(0, 'test')\n\n        assert s.getComponentByPosition(0) == str2octs('test')\n        assert len(s) == 1\n        assert s.isValue\n\n        s.clear()\n\n        assert len(s) == 0\n        assert s == []\n        assert s.isValue\n\n    def testReset(self):\n\n        class SequenceOf(univ.SequenceOf):\n            componentType = univ.OctetString()\n\n        s = SequenceOf()\n        s.setComponentByPosition(0, 'test')\n\n        assert s.getComponentByPosition(0) == str2octs('test')\n        assert s.isValue\n\n        s.reset()\n\n        assert not s.isValue\n\n    def testIsInconsistentSizeConstraint(self):\n\n        class SequenceOf(univ.SequenceOf):\n            componentType = univ.OctetString()\n            subtypeSpec = constraint.ValueSizeConstraint(0, 1)\n\n        s = SequenceOf()\n\n        assert s.isInconsistent\n\n        s[0] = 'test'\n\n        assert not s.isInconsistent\n\n        s[0] = 'test'\n        s[1] = 'test'\n\n        assert s.isInconsistent\n\n        s.clear()\n\n        assert not s.isInconsistent\n\n        s.reset()\n\n        assert s.isInconsistent\n\n        s[1] = 'test'\n\n        assert not s.isInconsistent\n\n\nclass SequenceOfPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.SequenceOf(componentType=univ.OctetString())\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.SequenceOf\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.SequenceOf(componentType=univ.OctetString())\n        old_asn1[0] = 'test'\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1\n        assert new_asn1 == [str2octs('test')]\n\n\nclass Sequence(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString('')),\n                namedtype.OptionalNamedType('nick', univ.OctetString('')),\n                namedtype.DefaultedNamedType('age', univ.Integer(34))\n            )\n        )\n\n    def testRepr(self):\n        assert 'name' in repr(self.s1.clone().setComponents('a', 'b'))\n\n    def testTag(self):\n        assert self.s1.tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)\n        ), 'wrong tagSet'\n\n    def testById(self):\n        self.s1.setComponentByName('name', univ.OctetString('abc'))\n        assert self.s1.getComponentByName('name') == str2octs('abc'), 'set by name fails'\n\n    def testByKey(self):\n        self.s1['name'] = 'abc'\n        assert self.s1['name'] == str2octs('abc'), 'set by key fails'\n\n    def testContains(self):\n        assert 'name' in self.s1\n        assert '<missing>' not in self.s1\n\n    def testGetNearPosition(self):\n        assert self.s1.componentType.getTagMapNearPosition(1).presentTypes == {\n            univ.OctetString.tagSet: univ.OctetString(''),\n            univ.Integer.tagSet: univ.Integer(34)\n        }\n        assert self.s1.componentType.getPositionNearType(\n            univ.OctetString.tagSet, 1\n        ) == 1\n\n    def testSetDefaultComponents(self):\n        self.s1.clear()\n        self.s1.setComponentByPosition(0, univ.OctetString('Ping'))\n        self.s1.setComponentByPosition(1, univ.OctetString('Pong'))\n        assert self.s1.getComponentByPosition(2) == 34\n\n    def testClone(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        self.s1.setComponentByPosition(1, univ.OctetString('def'))\n        self.s1.setComponentByPosition(2, univ.Integer(123))\n        s = self.s1.clone()\n        assert s.getComponentByPosition(0) != self.s1.getComponentByPosition(0)\n        assert s.getComponentByPosition(1) != self.s1.getComponentByPosition(1)\n        assert s.getComponentByPosition(2) != self.s1.getComponentByPosition(2)\n        s = self.s1.clone(cloneValueFlag=1)\n        assert s.getComponentByPosition(0) == self.s1.getComponentByPosition(0)\n        assert s.getComponentByPosition(1) == self.s1.getComponentByPosition(1)\n        assert s.getComponentByPosition(2) == self.s1.getComponentByPosition(2)\n\n    def testComponentTagsMatching(self):\n        s = self.s1.clone()\n        s.strictConstraints = True  # This requires types equality\n        o = univ.OctetString('abc').subtype(explicitTag=tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 12))\n        try:\n            s.setComponentByName('name', o)\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'inner supertype tag allowed'\n\n    def testComponentConstraintsMatching(self):\n        s = self.s1.clone()\n        o = univ.OctetString().subtype(\n            subtypeSpec=constraint.ConstraintsUnion(constraint.SingleValueConstraint(str2octs('cba'))))\n        s.strictConstraints = True  # This requires types equality\n        try:\n            s.setComponentByName('name', o.clone('cba'))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'inner supertype constraint allowed'\n        s.strictConstraints = False  # This requires subtype relationships\n        try:\n            s.setComponentByName('name', o.clone('cba'))\n        except PyAsn1Error:\n            assert 0, 'inner supertype constraint disallowed'\n        else:\n            pass\n\n    def testSetComponents(self):\n        assert self.s1.clone().setComponents(name='a', nick='b', age=1) == \\\n               self.s1.setComponentByPosition(0, 'a').setComponentByPosition(1, 'b').setComponentByPosition(2, 1)\n\n    def testSetToDefault(self):\n        s = self.s1.clone()\n        s.setComponentByPosition(0, univ.noValue)\n        s[2] = univ.noValue\n        assert s[0] == univ.OctetString('')\n        assert s[2] == univ.Integer(34)\n\n    def testGetItem(self):\n        s = self.s1.clone()\n        s['name'] = 'xxx'\n        assert s['name']\n        assert s[0]\n\n        try:\n            s['xxx']\n\n        except KeyError:\n            pass\n\n        else:\n            assert False, 'KeyError not raised'\n\n        try:\n            s[100]\n\n        except IndexError:\n            pass\n\n        else:\n            assert False, 'IndexError not raised'\n\n    def testSetItem(self):\n        s = self.s1.clone()\n        s['name'] = 'xxx'\n\n        try:\n\n            s['xxx'] = 'xxx'\n\n        except KeyError:\n            pass\n\n        else:\n            assert False, 'KeyError not raised'\n\n        try:\n\n            s[100] = 'xxx'\n\n        except IndexError:\n            pass\n\n        else:\n            assert False, 'IndexError not raised'\n\n    def testIter(self):\n        assert list(self.s1) == ['name', 'nick', 'age']\n\n    def testKeys(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        self.s1.setComponentByPosition(1, univ.OctetString('def'))\n        self.s1.setComponentByPosition(2, univ.Integer(123))\n        assert list(self.s1.keys()) == ['name', 'nick', 'age']\n\n    def testValues(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        self.s1.setComponentByPosition(1, univ.OctetString('def'))\n        self.s1.setComponentByPosition(2, univ.Integer(123))\n        assert list(self.s1.values()) == [str2octs('abc'), str2octs('def'), 123]\n\n    def testItems(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        self.s1.setComponentByPosition(1, univ.OctetString('def'))\n        self.s1.setComponentByPosition(2, univ.Integer(123))\n        assert list(self.s1.items()) == [(x[0], str2octs(x[1])) for x in [('name', 'abc'), ('nick', 'def')]] + [('age', 123)]\n\n    def testUpdate(self):\n        self.s1.clear()\n        assert list(self.s1.values()) == [str2octs(''), str2octs(''), 34]\n        self.s1.update(**{'name': 'abc', 'nick': 'def', 'age': 123})\n        assert list(self.s1.items()) == [(x[0], str2octs(x[1])) for x in [('name', 'abc'), ('nick', 'def')]] + [('age', 123)]\n        self.s1.update(('name', 'ABC'))\n        assert list(self.s1.items()) == [(x[0], str2octs(x[1])) for x in [('name', 'ABC'), ('nick', 'def')]] + [('age', 123)]\n        self.s1.update(name='CBA')\n        assert list(self.s1.items()) == [(x[0], str2octs(x[1])) for x in [('name', 'CBA'), ('nick', 'def')]] + [('age', 123)]\n\n    def testStaticDef(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString('')),\n                namedtype.OptionalNamedType('nick', univ.OctetString('')),\n                namedtype.DefaultedNamedType('age', univ.Integer(34))\n            )\n\n        s = Sequence()\n        s['name'] = 'abc'\n        assert s['name'] == str2octs('abc')\n\n    def testGetComponentWithDefault(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString('')),\n                namedtype.OptionalNamedType('nick', univ.OctetString()),\n            )\n\n        s = Sequence()\n\n        assert s[0] == str2octs('')\n        assert s.getComponentByPosition(1, default=None, instantiate=False) is None\n        assert s.getComponentByName('nick', default=None) is None\n        s[1] = 'test'\n        assert s.getComponentByPosition(1, default=None) is not None\n        assert s.getComponentByPosition(1, default=None) == str2octs('test')\n        s.clear()\n        assert s.getComponentByPosition(1, default=None) is None\n\n    def testGetComponentWithConstructedDefault(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.DefaultedNamedType('nick', univ.SequenceOf(\n                    componentType=univ.Integer()\n                ).setComponentByPosition(0, 1)),\n            )\n\n        s = Sequence()\n\n        assert s.getComponentByPosition(1, default=None, instantiate=False) is None\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n        assert s.getComponentByPosition(1) == [1]\n\n    def testGetComponentNoInstantiation(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString('')),\n                namedtype.OptionalNamedType('nick', univ.OctetString()),\n            )\n\n        s = Sequence()\n        assert s[0] == str2octs('')\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n        assert s.getComponentByName('nick', instantiate=False) is univ.noValue\n        s[1] = 'test'\n        assert s.getComponentByPosition(1, instantiate=False) is not univ.noValue\n        assert s.getComponentByPosition(1, instantiate=False) == str2octs('test')\n        s.clear()\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n\n    def testSchemaWithComponents(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString())\n            )\n\n        s = Sequence()\n\n        assert not s.isValue\n\n        s[0] = 'test'\n\n        assert s.isValue\n\n        s.clear()\n\n        assert not s.isValue\n\n        s.reset()\n\n        assert not s.isValue\n\n    def testSchemaWithOptionalComponents(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.OptionalNamedType('name', univ.OctetString())\n            )\n\n        s = Sequence()\n\n        assert s.isValue\n\n        s[0] = 'test'\n\n        assert s.isValue\n\n        s.clear()\n\n        assert s.isValue\n\n        s.reset()\n\n        assert not s.isValue\n\n    def testSchemaWithOptionalComponents(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.DefaultedNamedType('name', univ.OctetString(''))\n            )\n\n        s = Sequence()\n\n        assert s.isValue\n\n        s[0] = 'test'\n\n        assert s.isValue\n\n        s.clear()\n\n        assert s.isValue\n\n        s.reset()\n\n        assert not s.isValue\n\n    def testIsInconsistentWithComponentsConstraint(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.OptionalNamedType('name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(65))\n            )\n            subtypeSpec = constraint.WithComponentsConstraint(\n                ('name', constraint.ComponentPresentConstraint()),\n                ('age', constraint.ComponentAbsentConstraint())\n            )\n\n        s = Sequence()\n\n        assert s.isInconsistent\n\n        s[0] = 'test'\n\n        assert not s.isInconsistent\n\n        s[0] = 'test'\n        s[1] = 23\n\n        assert s.isInconsistent\n\n        s.clear()\n\n        assert s.isInconsistent\n\n        s.reset()\n\n        assert s.isInconsistent\n\n        s[1] = 23\n\n        assert s.isInconsistent\n\n    def testIsInconsistentSizeConstraint(self):\n\n        class Sequence(univ.Sequence):\n            componentType = namedtype.NamedTypes(\n                namedtype.OptionalNamedType('name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(65))\n            )\n            subtypeSpec = constraint.ValueSizeConstraint(0, 1)\n\n        s = Sequence()\n\n        assert not s.isInconsistent\n\n        s[0] = 'test'\n\n        assert not s.isInconsistent\n\n        s[0] = 'test'\n        s[1] = 23\n\n        assert s.isInconsistent\n\n        s.clear()\n\n        assert not s.isInconsistent\n\n        s.reset()\n\n        assert s.isInconsistent\n\n        s[1] = 23\n\n        assert not s.isInconsistent\n\n\nclass SequenceWithoutSchema(BaseTestCase):\n\n    def testGetItem(self):\n        s = univ.Sequence()\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s[0] = 'abc'\n        assert s['field-0']\n        assert s[0]\n\n        try:\n            s['field-1']\n\n        except KeyError:\n            pass\n\n        else:\n            assert False, 'KeyError not raised'\n\n    def testSetItem(self):\n        s = univ.Sequence()\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s['field-0'] = 'xxx'\n\n        try:\n\n            s['field-1'] = 'xxx'\n\n        except KeyError:\n            pass\n\n        else:\n            assert False, 'KeyError not raised'\n\n    def testIter(self):\n        s = univ.Sequence()\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s.setComponentByPosition(1, univ.Integer(123))\n        assert list(s) == ['field-0', 'field-1']\n\n    def testKeys(self):\n        s = univ.Sequence()\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s.setComponentByPosition(1, univ.Integer(123))\n        assert list(s.keys()) == ['field-0', 'field-1']\n\n    def testValues(self):\n        s = univ.Sequence()\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s.setComponentByPosition(1, univ.Integer(123))\n        assert list(s.values()) == [str2octs('abc'), 123]\n\n    def testItems(self):\n        s = univ.Sequence()\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s.setComponentByPosition(1, univ.Integer(123))\n        assert list(s.items()) == [('field-0', str2octs('abc')), ('field-1', 123)]\n\n    def testUpdate(self):\n        s = univ.Sequence().clear()\n        assert not s\n        s.setComponentByPosition(0, univ.OctetString('abc'))\n        s.setComponentByPosition(1, univ.Integer(123))\n        assert s\n        assert list(s.keys()) == ['field-0', 'field-1']\n        assert list(s.values()) == [str2octs('abc'), 123]\n        assert list(s.items()) == [('field-0', str2octs('abc')), ('field-1', 123)]\n        s['field-0'] = univ.OctetString('def')\n        assert list(s.values()) == [str2octs('def'), 123]\n        s['field-1'] = univ.OctetString('ghi')\n        assert list(s.values()) == [str2octs('def'), str2octs('ghi')]\n        try:\n            s['field-2'] = univ.OctetString('xxx')\n        except KeyError:\n            pass\n        else:\n            assert False, 'unknown field at schema-less object tolerated'\n        assert 'field-0' in s\n        s.clear()\n        assert 'field-0' not in s\n\n    def testSchema(self):\n\n        class Sequence(univ.Sequence):\n            pass\n\n        s = Sequence()\n\n        assert not s.isValue\n\n        s[0] = univ.OctetString('test')\n\n        assert s.isValue\n\n        s.clear()\n\n        assert s.isValue\n\n        s.reset()\n\n        assert not s.isValue\n\n\nclass SequencePicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString())\n            )\n        )\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Sequence\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString())\n            )\n        )\n        old_asn1['name'] = 'test'\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1\n        assert new_asn1['name'] == str2octs('test')\n\n\nclass SetOf(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s1 = univ.SetOf(componentType=univ.OctetString(''))\n\n    def testTag(self):\n        assert self.s1.tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)\n        ), 'wrong tagSet'\n\n    def testSeq(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        assert self.s1[0] == str2octs('abc'), 'set by idx fails'\n        self.s1.setComponentByPosition(0, self.s1[0].clone('cba'))\n        assert self.s1[0] == str2octs('cba'), 'set by idx fails'\n\n    def testStaticDef(self):\n\n        class SetOf(univ.SequenceOf):\n            componentType = univ.OctetString('')\n\n        s = SetOf()\n        s[0] = 'abc'\n        assert len(s) == 1\n        assert s == [str2octs('abc')]\n\n\n\nclass SetOfPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.SetOf(componentType=univ.OctetString())\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.SetOf\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.SetOf(componentType=univ.OctetString())\n        old_asn1[0] = 'test'\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1\n        assert new_asn1 == [str2octs('test')]\n\n\nclass Set(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s1 = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString('')),\n                namedtype.OptionalNamedType('null', univ.Null('')),\n                namedtype.DefaultedNamedType('age', univ.Integer(34))\n            )\n        )\n        self.s2 = self.s1.clone()\n\n    def testTag(self):\n        assert self.s1.tagSet == tag.TagSet(\n            (),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)\n        ), 'wrong tagSet'\n\n    def testByTypeWithPythonValue(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert self.s1.getComponentByType(\n            univ.OctetString.tagSet\n        ) == str2octs('abc'), 'set by name fails'\n\n    def testByTypeWithInstance(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, univ.OctetString('abc'))\n        assert self.s1.getComponentByType(\n            univ.OctetString.tagSet\n        ) == str2octs('abc'), 'set by name fails'\n\n    def testGetTagMap(self):\n        assert self.s1.tagMap.presentTypes == {\n            univ.Set.tagSet: univ.Set().clear()\n        }\n\n    def testGetComponentTagMap(self):\n        assert self.s1.componentType.tagMapUnique.presentTypes == {\n            univ.OctetString.tagSet: univ.OctetString(''),\n            univ.Null.tagSet: univ.Null(''),\n            univ.Integer.tagSet: univ.Integer(34)\n        }\n\n    def testGetPositionByType(self):\n        assert self.s1.componentType.getPositionByType(univ.Null().tagSet) == 1\n\n    def testSetToDefault(self):\n        self.s1.setComponentByName('name', univ.noValue)\n        assert self.s1['name'] == univ.OctetString('')\n\n    def testIter(self):\n        assert list(self.s1) == ['name', 'null', 'age']\n\n    def testStaticDef(self):\n\n        class Set(univ.Set):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString('')),\n                namedtype.OptionalNamedType('nick', univ.OctetString('')),\n                namedtype.DefaultedNamedType('age', univ.Integer(34))\n            )\n\n        s = Set()\n        s['name'] = 'abc'\n        assert s['name'] == str2octs('abc')\n\n    def testGetComponentWithDefault(self):\n\n        class Set(univ.Set):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer(123)),\n                namedtype.OptionalNamedType('nick', univ.OctetString()),\n            )\n\n        s = Set()\n        assert s[0] == 123\n        assert s.getComponentByPosition(1, default=None, instantiate=False) is None\n        assert s.getComponentByName('nick', default=None) is None\n        s[1] = 'test'\n        assert s.getComponentByPosition(1, default=None) is not None\n        assert s.getComponentByPosition(1, default=None) == str2octs('test')\n        s.clear()\n        assert s.getComponentByPosition(1, default=None) is None\n\n    def testGetComponentNoInstantiation(self):\n\n        class Set(univ.Set):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer(123)),\n                namedtype.OptionalNamedType('nick', univ.OctetString()),\n            )\n\n        s = Set()\n        assert s[0] == 123\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n        assert s.getComponentByName('nick', instantiate=False) is univ.noValue\n        assert s.getComponentByType(univ.OctetString.tagSet, instantiate=False) is univ.noValue\n        s[1] = 'test'\n        assert s.getComponentByPosition(1, instantiate=False) is not univ.noValue\n        assert s.getComponentByPosition(1, instantiate=False) == str2octs('test')\n        s.clear()\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n\n\nclass SetPicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString())\n            )\n        )\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Set\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString())\n            )\n        )\n        old_asn1['name'] = 'test'\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1\n        assert new_asn1['name'] == str2octs('test')\n\n\nclass Choice(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        innerComp = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('count', univ.Integer()),\n                namedtype.NamedType('flag', univ.Boolean())\n            )\n        )\n        self.s1 = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('sex', innerComp)\n            )\n        )\n\n    def testTag(self):\n        assert self.s1.tagSet == tag.TagSet(), 'wrong tagSet'\n\n    def testRepr(self):\n        assert 'Choice' in repr(self.s1.clone().setComponents('a'))\n        s = self.s1.clone().setComponents(\n                sex=self.s1.setComponentByPosition(1).getComponentByPosition(1).clone().setComponents(count=univ.Integer(123))\n        )\n        assert 'Choice' in repr(s)\n\n    def testContains(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert 'name' in self.s1\n        assert 'sex' not in self.s1\n\n        self.s1.setComponentByType(univ.Integer.tagSet, 123, innerFlag=True)\n        assert 'name' not in self.s1\n        assert 'sex' in self.s1\n\n    def testIter(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert list(self.s1) == ['name']\n        self.s1.setComponentByType(univ.Integer.tagSet, 123, innerFlag=True)\n        assert list(self.s1) == ['sex']\n\n    def testOuterByTypeWithPythonValue(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert self.s1.getComponentByType(\n            univ.OctetString.tagSet\n        ) == str2octs('abc')\n\n    def testOuterByTypeWithInstanceValue(self):\n        self.s1.setComponentByType(\n            univ.OctetString.tagSet, univ.OctetString('abc')\n        )\n        assert self.s1.getComponentByType(\n            univ.OctetString.tagSet\n        ) == str2octs('abc')\n\n    def testInnerByTypeWithPythonValue(self):\n        self.s1.setComponentByType(univ.Integer.tagSet, 123, innerFlag=True)\n        assert self.s1.getComponentByType(\n            univ.Integer.tagSet, 1\n        ) == 123\n\n    def testInnerByTypeWithInstanceValue(self):\n        self.s1.setComponentByType(\n            univ.Integer.tagSet, univ.Integer(123), innerFlag=True\n        )\n        assert self.s1.getComponentByType(\n            univ.Integer.tagSet, 1\n        ) == 123\n\n    def testCmp(self):\n        self.s1.setComponentByName('name', univ.OctetString('abc'))\n        assert self.s1 == str2octs('abc'), '__cmp__() fails'\n\n    def testGetComponent(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert self.s1.getComponent() == str2octs('abc'), 'getComponent() fails'\n\n    def testGetName(self):\n        self.s1.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert self.s1.getName() == 'name', 'getName() fails'\n\n    def testSetComponentByPosition(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('Jim'))\n        assert self.s1 == str2octs('Jim')\n\n    def testClone(self):\n        self.s1.setComponentByPosition(0, univ.OctetString('abc'))\n        s = self.s1.clone()\n        assert len(s) == 0\n        s = self.s1.clone(cloneValueFlag=1)\n        assert len(s) == 1\n        assert s.getComponentByPosition(0) == self.s1.getComponentByPosition(0)\n\n    def testSetToDefault(self):\n        s = self.s1.clone()\n        s.setComponentByName('sex', univ.noValue)\n        assert s['sex'] is not univ.noValue\n\n    def testStaticDef(self):\n\n        class InnerChoice(univ.Choice):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('count', univ.Integer()),\n                namedtype.NamedType('flag', univ.Boolean())\n            )\n\n        class OuterChoice(univ.Choice):\n            componentType = namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('sex', InnerChoice())\n            )\n\n        c = OuterChoice()\n\n        c.setComponentByType(univ.OctetString.tagSet, 'abc')\n        assert c.getName() == 'name'\n\n    def testGetComponentWithDefault(self):\n\n        s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('id', univ.Integer())\n            )\n        )\n\n        assert s.getComponentByPosition(0, default=None, instantiate=False) is None\n        assert s.getComponentByPosition(1, default=None, instantiate=False) is None\n        assert s.getComponentByName('name', default=None, instantiate=False) is None\n        assert s.getComponentByName('id', default=None, instantiate=False) is None\n        assert s.getComponentByType(univ.OctetString.tagSet, default=None) is None\n        assert s.getComponentByType(univ.Integer.tagSet, default=None) is None\n        s[1] = 123\n        assert s.getComponentByPosition(1, default=None) is not None\n        assert s.getComponentByPosition(1, univ.noValue) == 123\n        s.clear()\n        assert s.getComponentByPosition(1, default=None, instantiate=False) is None\n\n    def testGetComponentNoInstantiation(self):\n\n        s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('id', univ.Integer())\n            )\n        )\n\n        assert s.getComponentByPosition(0, instantiate=False) is univ.noValue\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n        assert s.getComponentByName('name', instantiate=False) is univ.noValue\n        assert s.getComponentByName('id', instantiate=False) is univ.noValue\n        assert s.getComponentByType(univ.OctetString.tagSet, instantiate=False) is univ.noValue\n        assert s.getComponentByType(univ.Integer.tagSet, instantiate=False) is univ.noValue\n        s[1] = 123\n        assert s.getComponentByPosition(1, instantiate=False) is not univ.noValue\n        assert s.getComponentByPosition(1, instantiate=False) == 123\n        s.clear()\n        assert s.getComponentByPosition(1, instantiate=False) is univ.noValue\n\n\nclass ChoicePicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('id', univ.Integer())\n            )\n        )\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == univ.Choice\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('id', univ.Integer())\n            )\n        )\n        old_asn1['name'] = 'test'\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1\n        assert new_asn1['name'] == str2octs('test')\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/test_tag.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\n\n\nclass TagTestCaseBase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.t1 = tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 3)\n        self.t2 = tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 3)\n\n\nclass TagReprTestCase(TagTestCaseBase):\n    def testRepr(self):\n        assert 'Tag' in repr(self.t1)\n\n\nclass TagCmpTestCase(TagTestCaseBase):\n    def testCmp(self):\n        assert self.t1 == self.t2, 'tag comparison fails'\n\n    def testHash(self):\n        assert hash(self.t1) == hash(self.t2), 'tag hash comparison fails'\n\n    def testSequence(self):\n        assert self.t1[0] == self.t2[0] and \\\n               self.t1[1] == self.t2[1] and \\\n               self.t1[2] == self.t2[2], 'tag sequence protocol fails'\n\n\nclass TagSetTestCaseBase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.ts1 = tag.initTagSet(\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)\n        )\n\n        self.ts2 = tag.initTagSet(\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)\n        )\n\n\nclass TagSetReprTestCase(TagSetTestCaseBase):\n    def testRepr(self):\n        assert 'TagSet' in repr(self.ts1)\n\n\nclass TagSetCmpTestCase(TagSetTestCaseBase):\n    def testCmp(self):\n        assert self.ts1 == self.ts2, 'tag set comparison fails'\n\n    def testHash(self):\n        assert hash(self.ts1) == hash(self.ts2), 'tag set hash comp. fails'\n\n    def testLen(self):\n        assert len(self.ts1) == len(self.ts2), 'tag length comparison fails'\n\n\nclass TaggingTestSuite(TagSetTestCaseBase):\n    def testImplicitTag(self):\n        t = self.ts1.tagImplicitly(\n            tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 14)\n        )\n        assert t == tag.TagSet(\n            tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 12),\n            tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 14)\n        ), 'implicit tagging went wrong'\n\n    def testExplicitTag(self):\n        t = self.ts1.tagExplicitly(\n            tag.Tag(tag.tagClassPrivate, tag.tagFormatSimple, 32)\n        )\n        assert t == tag.TagSet(\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n            tag.Tag(tag.tagClassPrivate, tag.tagFormatConstructed, 32)\n        ), 'explicit tagging went wrong'\n\n\nclass TagSetAddTestSuite(TagSetTestCaseBase):\n    def testAdd(self):\n        t = self.ts1 + tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 2)\n        assert t == tag.TagSet(\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n            tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 2)\n        ), 'TagSet.__add__() fails'\n\n    def testRadd(self):\n        t = tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 2) + self.ts1\n        assert t == tag.TagSet(\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n            tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 2),\n            tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)\n        ), 'TagSet.__radd__() fails'\n\n\nclass SuperTagSetTestCase(TagSetTestCaseBase):\n    def testSuperTagCheck1(self):\n        assert self.ts1.isSuperTagSetOf(\n            tag.TagSet(\n                tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n                tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)\n            )), 'isSuperTagSetOf() fails'\n\n    def testSuperTagCheck2(self):\n        assert not self.ts1.isSuperTagSetOf(\n            tag.TagSet(\n                tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12),\n                tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 13)\n            )), 'isSuperTagSetOf() fails'\n\n    def testSuperTagCheck3(self):\n        assert self.ts1.isSuperTagSetOf(\n            tag.TagSet((), tag.Tag(tag.tagClassUniversal,\n                                   tag.tagFormatSimple, 12))\n        ), 'isSuperTagSetOf() fails'\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/test_char.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport pickle\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import char\nfrom pyasn1.type import univ\nfrom pyasn1.type import constraint\nfrom pyasn1.compat.octets import ints2octs\nfrom pyasn1.error import PyAsn1Error\n\n\nclass AbstractStringTestCase(object):\n\n    initializer = ()\n    encoding = 'us-ascii'\n    asn1Type = None\n\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.asn1String = self.asn1Type(ints2octs(self.initializer), encoding=self.encoding)\n        self.pythonString = ints2octs(self.initializer).decode(self.encoding)\n\n    def testUnicode(self):\n        assert self.asn1String == self.pythonString, 'unicode init fails'\n\n    def testLength(self):\n        assert len(self.asn1String) == len(self.pythonString), 'unicode len() fails'\n\n    def testSizeConstraint(self):\n        asn1Spec = self.asn1Type(subtypeSpec=constraint.ValueSizeConstraint(1, 1))\n\n        try:\n            asn1Spec.clone(self.pythonString)\n        except PyAsn1Error:\n            pass\n        else:\n            assert False, 'Size constraint tolerated'\n\n        try:\n            asn1Spec.clone(self.pythonString[0])\n        except PyAsn1Error:\n            assert False, 'Size constraint failed'\n\n    def testSerialised(self):\n        if sys.version_info[0] < 3:\n            assert str(self.asn1String) == self.pythonString.encode(self.encoding), '__str__() fails'\n        else:\n            assert bytes(self.asn1String) == self.pythonString.encode(self.encoding), '__str__() fails'\n\n    def testPrintable(self):\n        if sys.version_info[0] < 3:\n            assert unicode(self.asn1String) == self.pythonString, '__str__() fails'\n        else:\n            assert str(self.asn1String) == self.pythonString, '__str__() fails'\n\n    def testInit(self):\n        assert self.asn1Type(self.pythonString) == self.pythonString\n        assert self.asn1Type(self.pythonString.encode(self.encoding)) == self.pythonString\n        assert self.asn1Type(univ.OctetString(self.pythonString.encode(self.encoding))) == self.pythonString\n        assert self.asn1Type(self.asn1Type(self.pythonString)) == self.pythonString\n        assert self.asn1Type(self.initializer, encoding=self.encoding) == self.pythonString\n\n    def testInitFromAsn1(self):\n        assert self.asn1Type(self.asn1Type(self.pythonString)) == self.pythonString\n        assert self.asn1Type(univ.OctetString(self.pythonString.encode(self.encoding), encoding=self.encoding)) == self.pythonString\n\n    def testAsOctets(self):\n        assert self.asn1String.asOctets() == self.pythonString.encode(self.encoding), 'testAsOctets() fails'\n\n    def testAsNumbers(self):\n        assert self.asn1String.asNumbers() == self.initializer, 'testAsNumbers() fails'\n\n    def testSeq(self):\n        assert self.asn1String[0] == self.pythonString[0], '__getitem__() fails'\n\n    def testEmpty(self):\n        try:\n            str(self.asn1Type())\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Value operation on ASN1 type tolerated'\n\n    def testAdd(self):\n        assert self.asn1String + self.pythonString.encode(self.encoding) == self.pythonString + self.pythonString, '__add__() fails'\n\n    def testRadd(self):\n        assert self.pythonString.encode(self.encoding) + self.asn1String == self.pythonString + self.pythonString, '__radd__() fails'\n\n    def testMul(self):\n        assert self.asn1String * 2 == self.pythonString * 2, '__mul__() fails'\n\n    def testRmul(self):\n        assert 2 * self.asn1String == 2 * self.pythonString, '__rmul__() fails'\n\n    def testContains(self):\n        assert self.pythonString in self.asn1String\n        assert self.pythonString + self.pythonString not in self.asn1String\n\n    def testReverse(self):\n        assert list(reversed(self.asn1String)) == list(reversed(self.pythonString))\n\n    def testSchemaPickling(self):\n        old_asn1 = self.asn1Type()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == self.asn1Type\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = self.asn1String\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == self.asn1String\n\n\nclass VisibleStringTestCase(AbstractStringTestCase, BaseTestCase):\n\n    initializer = (97, 102)\n    encoding = 'us-ascii'\n    asn1Type = char.VisibleString\n\n\nclass GeneralStringTestCase(AbstractStringTestCase, BaseTestCase):\n\n    initializer = (169, 174)\n    encoding = 'iso-8859-1'\n    asn1Type = char.GeneralString\n\n\nclass UTF8StringTestCase(AbstractStringTestCase, BaseTestCase):\n\n    initializer = (209, 132, 208, 176)\n    encoding = 'utf-8'\n    asn1Type = char.UTF8String\n\n\nclass BMPStringTestCase(AbstractStringTestCase, BaseTestCase):\n\n    initializer = (4, 48, 4, 68)\n    encoding = 'utf-16-be'\n    asn1Type = char.BMPString\n\n\nif sys.version_info[0] > 2:\n\n    # Somehow comparison of UTF-32 encoded strings does not work in Py2\n\n    class UniversalStringTestCase(AbstractStringTestCase, BaseTestCase):\n        initializer = (0, 0, 4, 48, 0, 0, 4, 68)\n        encoding = 'utf-32-be'\n        asn1Type = char.UniversalString\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.type.test_constraint.suite',\n     'tests.type.test_opentype.suite',\n     'tests.type.test_namedtype.suite',\n     'tests.type.test_namedval.suite',\n     'tests.type.test_tag.suite',\n     'tests.type.test_univ.suite',\n     'tests.type.test_char.suite',\n     'tests.type.test_useful.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/test_namedtype.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import univ\nfrom pyasn1.error import PyAsn1Error\n\n\nclass NamedTypeCaseBase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.e = namedtype.NamedType('age', univ.Integer(0))\n\n    def testIter(self):\n        n, t = self.e\n        assert n == 'age' or t == univ.Integer(), 'unpack fails'\n\n    def testRepr(self):\n        assert 'age' in repr(self.e)\n\n\nclass NamedTypesCaseBase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.e = namedtype.NamedTypes(\n            namedtype.NamedType('first-name', univ.OctetString('')),\n            namedtype.OptionalNamedType('age', univ.Integer(0)),\n            namedtype.NamedType('family-name', univ.OctetString(''))\n        )\n\n    def testRepr(self):\n        assert 'first-name' in repr(self.e)\n\n    def testContains(self):\n        assert 'first-name' in self.e\n        assert '<missing>' not in self.e\n\n    # noinspection PyUnusedLocal\n    def testGetItem(self):\n        assert self.e[0] == namedtype.NamedType('first-name', univ.OctetString(''))\n\n    def testIter(self):\n        assert list(self.e) == ['first-name', 'age', 'family-name']\n\n    def testGetTypeByPosition(self):\n        assert self.e.getTypeByPosition(0) == univ.OctetString(''), \\\n            'getTypeByPosition() fails'\n\n    def testGetNameByPosition(self):\n        assert self.e.getNameByPosition(0) == 'first-name', \\\n            'getNameByPosition() fails'\n\n    def testGetPositionByName(self):\n        assert self.e.getPositionByName('first-name') == 0, \\\n            'getPositionByName() fails'\n\n    def testGetTypesNearPosition(self):\n        assert self.e.getTagMapNearPosition(0).presentTypes == {\n            univ.OctetString.tagSet: univ.OctetString('')\n        }\n        assert self.e.getTagMapNearPosition(1).presentTypes == {\n            univ.Integer.tagSet: univ.Integer(0),\n            univ.OctetString.tagSet: univ.OctetString('')\n        }\n        assert self.e.getTagMapNearPosition(2).presentTypes == {\n            univ.OctetString.tagSet: univ.OctetString('')\n        }\n\n    def testGetTagMap(self):\n        assert self.e.tagMap.presentTypes == {\n            univ.OctetString.tagSet: univ.OctetString(''),\n            univ.Integer.tagSet: univ.Integer(0)\n        }\n\n    def testStrTagMap(self):\n        assert 'TagMap' in str(self.e.tagMap)\n        assert 'OctetString' in str(self.e.tagMap)\n        assert 'Integer' in str(self.e.tagMap)\n\n    def testReprTagMap(self):\n        assert 'TagMap' in repr(self.e.tagMap)\n        assert 'OctetString' in repr(self.e.tagMap)\n        assert 'Integer' in repr(self.e.tagMap)\n\n    def testGetTagMapWithDups(self):\n        try:\n            self.e.tagMapUnique[0]\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Duped types not noticed'\n\n    def testGetPositionNearType(self):\n        assert self.e.getPositionNearType(univ.OctetString.tagSet, 0) == 0\n        assert self.e.getPositionNearType(univ.Integer.tagSet, 1) == 1\n        assert self.e.getPositionNearType(univ.OctetString.tagSet, 2) == 2\n\n\nclass OrderedNamedTypesCaseBase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.e = namedtype.NamedTypes(\n            namedtype.NamedType('first-name', univ.OctetString('')),\n            namedtype.NamedType('age', univ.Integer(0))\n        )\n\n    def testGetTypeByPosition(self):\n        assert self.e.getTypeByPosition(0) == univ.OctetString(''), \\\n            'getTypeByPosition() fails'\n\n\nclass DuplicateNamedTypesCaseBase(BaseTestCase):\n    def testDuplicateDefaultTags(self):\n        nt = namedtype.NamedTypes(\n            namedtype.NamedType('first-name', univ.Any()),\n            namedtype.NamedType('age', univ.Any())\n        )\n\n        assert isinstance(nt.tagMap, namedtype.NamedTypes.PostponedError)\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/type/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/type/test_useful.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport datetime\nimport pickle\nimport sys\nfrom copy import deepcopy\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import useful\n\n\nclass FixedOffset(datetime.tzinfo):\n    def __init__(self, offset, name):\n        self.__offset = datetime.timedelta(minutes=offset)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return datetime.timedelta(0)\n\n\nUTC = FixedOffset(0, 'UTC')\nUTC2 = FixedOffset(120, 'UTC')\n\n\nclass ObjectDescriptorTestCase(BaseTestCase):\n    pass\n\n\nclass GeneralizedTimeTestCase(BaseTestCase):\n\n    def testFromDateTime(self):\n        assert useful.GeneralizedTime.fromDateTime(datetime.datetime(2017, 7, 11, 0, 1, 2, 3000, tzinfo=UTC)) == '20170711000102.3Z'\n\n    def testToDateTime0(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2) == useful.GeneralizedTime('20170711000102').asDateTime\n\n    def testToDateTime1(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, tzinfo=UTC) == useful.GeneralizedTime('20170711000102Z').asDateTime\n\n    def testToDateTime2(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, 3000, tzinfo=UTC) == useful.GeneralizedTime('20170711000102.3Z').asDateTime\n\n    def testToDateTime3(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, 3000, tzinfo=UTC) == useful.GeneralizedTime('20170711000102,3Z').asDateTime\n\n    def testToDateTime4(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, 3000, tzinfo=UTC) == useful.GeneralizedTime('20170711000102.3+0000').asDateTime\n\n    def testToDateTime5(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, 3000, tzinfo=UTC2) == useful.GeneralizedTime('20170711000102.3+0200').asDateTime\n\n    def testToDateTime6(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, 3000, tzinfo=UTC2) == useful.GeneralizedTime('20170711000102.3+02').asDateTime\n\n    def testToDateTime7(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1) == useful.GeneralizedTime('201707110001').asDateTime\n\n    def testToDateTime8(self):\n        assert datetime.datetime(2017, 7, 11, 0) == useful.GeneralizedTime('2017071100').asDateTime\n\n    def testCopy(self):\n        dt = useful.GeneralizedTime(\"20170916234254+0130\").asDateTime\n        assert dt == deepcopy(dt)\n\n\nclass GeneralizedTimePicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = useful.GeneralizedTime()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == useful.GeneralizedTime\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = useful.GeneralizedTime(\"20170916234254+0130\")\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == old_asn1\n\n\nclass UTCTimeTestCase(BaseTestCase):\n\n    def testFromDateTime(self):\n        assert useful.UTCTime.fromDateTime(datetime.datetime(2017, 7, 11, 0, 1, 2, tzinfo=UTC)) == '170711000102Z'\n\n    def testToDateTime0(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2) == useful.UTCTime('170711000102').asDateTime\n\n    def testToDateTime1(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, tzinfo=UTC) == useful.UTCTime('170711000102Z').asDateTime\n\n    def testToDateTime2(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, tzinfo=UTC) == useful.UTCTime('170711000102+0000').asDateTime\n\n    def testToDateTime3(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1, 2, tzinfo=UTC2) == useful.UTCTime('170711000102+0200').asDateTime\n\n    def testToDateTime4(self):\n        assert datetime.datetime(2017, 7, 11, 0, 1) == useful.UTCTime('1707110001').asDateTime\n\n\nclass UTCTimePicklingTestCase(unittest.TestCase):\n\n    def testSchemaPickling(self):\n        old_asn1 = useful.UTCTime()\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert type(new_asn1) == useful.UTCTime\n        assert old_asn1.isSameTypeWith(new_asn1)\n\n    def testValuePickling(self):\n        old_asn1 = useful.UTCTime(\"170711000102\")\n        serialised = pickle.dumps(old_asn1)\n        assert serialised\n        new_asn1 = pickle.loads(serialised)\n        assert new_asn1 == old_asn1\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/compat/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.compat.test_integer.suite',\n     'tests.compat.test_octets.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/compat/test_octets.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.compat import octets\n\n\nclass OctetsTestCase(BaseTestCase):\n\n    if sys.version_info[0] > 2:\n\n        def test_ints2octs(self):\n            assert [1, 2, 3] == list(octets.ints2octs([1, 2, 3]))\n\n        def test_ints2octs_empty(self):\n            assert not octets.ints2octs([])\n\n        def test_int2oct(self):\n            assert [12] == list(octets.int2oct(12))\n\n        def test_octs2ints(self):\n            assert [1, 2, 3] == list(octets.octs2ints(bytes([1, 2, 3])))\n\n        def test_octs2ints_empty(self):\n            assert not octets.octs2ints(bytes([]))\n\n        def test_oct2int(self):\n            assert 12 == octets.oct2int(bytes([12]))[0]\n\n        def test_str2octs(self):\n            assert bytes([1, 2, 3]) == octets.str2octs('\\x01\\x02\\x03')\n\n        def test_str2octs_empty(self):\n            assert not octets.str2octs('')\n\n        def test_octs2str(self):\n            assert '\\x01\\x02\\x03' == octets.octs2str(bytes([1, 2, 3]))\n\n        def test_octs2str_empty(self):\n            assert not octets.octs2str(bytes([]))\n\n        def test_isOctetsType(self):\n            assert octets.isOctetsType('abc') == False\n            assert octets.isOctetsType(123) == False\n            assert octets.isOctetsType(bytes()) == True\n\n        def test_isStringType(self):\n            assert octets.isStringType('abc') == True\n            assert octets.isStringType(123) == False\n            assert octets.isStringType(bytes()) == False\n\n        def test_ensureString(self):\n            assert 'abc'.encode() == octets.ensureString('abc'.encode())\n            assert bytes([1, 2, 3]) == octets.ensureString([1, 2, 3])\n\n    else:\n\n        def test_ints2octs(self):\n            assert '\\x01\\x02\\x03' == octets.ints2octs([1, 2, 3])\n\n        def test_ints2octs_empty(self):\n            assert not octets.ints2octs([])\n\n        def test_int2oct(self):\n            assert '\\x0c' == octets.int2oct(12)\n\n        def test_octs2ints(self):\n            assert [1, 2, 3] == octets.octs2ints('\\x01\\x02\\x03')\n\n        def test_octs2ints_empty(self):\n            assert not octets.octs2ints('')\n\n        def test_oct2int(self):\n            assert 12 == octets.oct2int('\\x0c')\n\n        def test_str2octs(self):\n            assert '\\x01\\x02\\x03' == octets.str2octs('\\x01\\x02\\x03')\n\n        def test_str2octs_empty(self):\n            assert not octets.str2octs('')\n\n        def test_octs2str(self):\n            assert '\\x01\\x02\\x03' == octets.octs2str('\\x01\\x02\\x03')\n\n        def test_octs2str_empty(self):\n            assert not octets.octs2str('')\n\n        def test_isOctetsType(self):\n            assert octets.isOctetsType('abc') == True\n            assert octets.isOctetsType(123) == False\n            assert octets.isOctetsType(unicode('abc')) == False\n\n        def test_isStringType(self):\n            assert octets.isStringType('abc') == True\n            assert octets.isStringType(123) == False\n            assert octets.isStringType(unicode('abc')) == True\n\n        def test_ensureString(self):\n            assert 'abc' == octets.ensureString('abc')\n            assert '123' == octets.ensureString(123)\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/compat/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/compat/test_integer.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.compat import integer\n\n\nclass IntegerTestCase(BaseTestCase):\n\n    if sys.version_info[0] > 2:\n\n        def test_from_bytes_zero(self):\n            assert 0 == integer.from_bytes(bytes([0]), signed=False)\n\n        def test_from_bytes_unsigned(self):\n            assert -66051 == integer.from_bytes(bytes([254, 253, 253]), signed=True)\n\n        def test_from_bytes_signed(self):\n            assert 66051 == integer.from_bytes(bytes([0, 1, 2, 3]), signed=False)\n\n        def test_from_bytes_empty(self):\n            assert 0 == integer.from_bytes(bytes([]))\n\n    else:\n\n        def test_from_bytes_zero(self):\n            assert 0 == integer.from_bytes('\\x00', signed=False)\n\n        def test_from_bytes_unsigned(self):\n            assert -66051 == integer.from_bytes('\\xfe\\xfd\\xfd', signed=True)\n\n        def test_from_bytes_signed(self):\n            assert 66051 == integer.from_bytes('\\x01\\x02\\x03', signed=False)\n\n        def test_from_bytes_empty(self):\n            assert 0 == integer.from_bytes('')\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/test_streaming.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2019, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport io\nimport sys\n\ntry:\n    import unittest2 as unittest\n\nexcept ImportError:\n    import unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.codec import streaming\n\n\nclass CachingStreamWrapperTestCase(BaseTestCase):\n    def setUp(self):\n        self.shortText = b\"abcdefghij\"\n        self.longText = self.shortText * (io.DEFAULT_BUFFER_SIZE * 5)\n        self.shortStream = io.BytesIO(self.shortText)\n        self.longStream = io.BytesIO(self.longText)\n\n    def testReadJustFromCache(self):\n        wrapper = streaming.CachingStreamWrapper(self.shortStream)\n        wrapper.read(6)\n        wrapper.seek(3)\n        assert wrapper.read(1) == b\"d\"\n        assert wrapper.read(1) == b\"e\"\n        assert wrapper.tell() == 5\n\n    def testReadFromCacheAndStream(self):\n        wrapper = streaming.CachingStreamWrapper(self.shortStream)\n        wrapper.read(6)\n        wrapper.seek(3)\n        assert wrapper.read(4) == b\"defg\"\n        assert wrapper.tell() == 7\n\n    def testReadJustFromStream(self):\n        wrapper = streaming.CachingStreamWrapper(self.shortStream)\n        assert wrapper.read(6) == b\"abcdef\"\n        assert wrapper.tell() == 6\n\n    def testPeek(self):\n        wrapper = streaming.CachingStreamWrapper(self.longStream)\n        read_bytes = wrapper.peek(io.DEFAULT_BUFFER_SIZE + 73)\n        assert len(read_bytes) == io.DEFAULT_BUFFER_SIZE + 73\n        assert read_bytes.startswith(b\"abcdefg\")\n        assert wrapper.tell() == 0\n        assert wrapper.read(4) == b\"abcd\"\n\n    def testMarkedPositionResets(self):\n        wrapper = streaming.CachingStreamWrapper(self.longStream)\n        wrapper.read(10)\n        wrapper.markedPosition = wrapper.tell()\n        assert wrapper.markedPosition == 10\n\n        # Reach the maximum capacity of cache\n        wrapper.read(io.DEFAULT_BUFFER_SIZE)\n        assert wrapper.tell() == 10 + io.DEFAULT_BUFFER_SIZE\n\n        # The following should clear the cache\n        wrapper.markedPosition = wrapper.tell()\n        assert wrapper.markedPosition == 0\n        assert len(wrapper._cache.getvalue()) == 0\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.codec.test_streaming.suite',\n     'tests.codec.ber.__main__.suite',\n     'tests.codec.cer.__main__.suite',\n     'tests.codec.der.__main__.suite',\n     'tests.codec.native.__main__.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/codec/cer/test_encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\nfrom pyasn1.codec.cer import encoder\nfrom pyasn1.compat.octets import ints2octs\nfrom pyasn1.error import PyAsn1Error\n\n\nclass BooleanEncoderTestCase(BaseTestCase):\n    def testTrue(self):\n        assert encoder.encode(univ.Boolean(1)) == ints2octs((1, 1, 255))\n\n    def testFalse(self):\n        assert encoder.encode(univ.Boolean(0)) == ints2octs((1, 1, 0))\n\n\nclass BitStringEncoderTestCase(BaseTestCase):\n    def testShortMode(self):\n        assert encoder.encode(\n            univ.BitString((1, 0) * 5)\n        ) == ints2octs((3, 3, 6, 170, 128))\n\n    def testLongMode(self):\n        assert encoder.encode(univ.BitString((1, 0) * 501)) == ints2octs((3, 127, 6) + (170,) * 125 + (128,))\n\n\nclass OctetStringEncoderTestCase(BaseTestCase):\n    def testShortMode(self):\n        assert encoder.encode(\n            univ.OctetString('Quick brown fox')\n        ) == ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testLongMode(self):\n        assert encoder.encode(\n            univ.OctetString('Q' * 1001)\n        ) == ints2octs((36, 128, 4, 130, 3, 232) + (81,) * 1000 + (4, 1, 81, 0, 0))\n\n\nclass GeneralizedTimeEncoderTestCase(BaseTestCase):\n    #    def testExtraZeroInSeconds(self):\n    #        try:\n    #            assert encoder.encode(\n    #                useful.GeneralizedTime('20150501120112.10Z')\n    #            )\n    #        except PyAsn1Error:\n    #            pass\n    #        else:\n    #            assert 0, 'Meaningless trailing zero in fraction part tolerated'\n\n    def testLocalTimezone(self):\n        try:\n            assert encoder.encode(\n                useful.GeneralizedTime('20150501120112.1+0200')\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Local timezone tolerated'\n\n    def testMissingTimezone(self):\n        try:\n            assert encoder.encode(\n                useful.GeneralizedTime('20150501120112.1')\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Missing timezone tolerated'\n\n    def testDecimalCommaPoint(self):\n        try:\n            assert encoder.encode(\n                useful.GeneralizedTime('20150501120112,1Z')\n             )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Decimal comma tolerated'\n\n    def testWithSubseconds(self):\n        assert encoder.encode(\n                useful.GeneralizedTime('20170801120112.59Z')\n             ) == ints2octs((24, 18, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 46, 53, 57, 90))\n\n    def testWithSubsecondsWithZeros(self):\n        assert encoder.encode(\n                useful.GeneralizedTime('20170801120112.099Z')\n             ) == ints2octs((24, 18, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 46, 57, 57, 90))\n\n    def testWithSubsecondsMax(self):\n        assert encoder.encode(\n                useful.GeneralizedTime('20170801120112.999Z')\n             ) == ints2octs((24, 19, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 46, 57, 57, 57, 90))\n\n    def testWithSubsecondsMin(self):\n        assert encoder.encode(\n                useful.GeneralizedTime('20170801120112.000Z')\n             ) == ints2octs((24, 15, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 90))\n\n    def testWithSubsecondsDanglingDot(self):\n        assert encoder.encode(\n                useful.GeneralizedTime('20170801120112.Z')\n             ) == ints2octs((24, 15, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 90))\n\n    def testWithSeconds(self):\n        assert encoder.encode(\n                    useful.GeneralizedTime('20170801120112Z')\n             ) == ints2octs((24, 15, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 90))\n\n    def testWithMinutes(self):\n        assert encoder.encode(\n                    useful.GeneralizedTime('201708011201Z')\n             ) == ints2octs((24, 13, 50, 48, 49, 55, 48, 56, 48, 49, 49, 50, 48, 49, 90))\n\n\nclass UTCTimeEncoderTestCase(BaseTestCase):\n    def testFractionOfSecond(self):\n        try:\n            assert encoder.encode(\n                useful.UTCTime('150501120112.10Z')\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Decimal point tolerated'\n\n    def testMissingTimezone(self):\n        try:\n            assert encoder.encode(\n                useful.UTCTime('150501120112')\n            ) == ints2octs((23, 13, 49, 53, 48, 53, 48, 49, 49, 50, 48, 49, 49, 50, 90))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Missing timezone tolerated'\n\n    def testLocalTimezone(self):\n        try:\n            assert encoder.encode(\n                useful.UTCTime('150501120112+0200')\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Local timezone tolerated'\n\n    def testWithSeconds(self):\n        assert encoder.encode(\n                    useful.UTCTime('990801120112Z')\n             ) == ints2octs((23, 13, 57, 57, 48, 56, 48, 49, 49, 50, 48, 49, 49, 50, 90))\n\n    def testWithMinutes(self):\n        assert encoder.encode(\n                    useful.UTCTime('9908011201Z')\n             ) == ints2octs((23, 11, 57, 57, 48, 56, 48, 49, 49, 50, 48, 49, 90))\n\n\nclass SequenceOfEncoderTestCase(BaseTestCase):\n    def testEmpty(self):\n        s = univ.SequenceOf()\n        s.clear()\n        assert encoder.encode(s) == ints2octs((48, 128, 0, 0))\n\n    def testDefMode1(self):\n        s = univ.SequenceOf()\n        s.append(univ.OctetString('a'))\n        s.append(univ.OctetString('ab'))\n        assert encoder.encode(s) == ints2octs((48, 128, 4, 1, 97, 4, 2, 97, 98, 0, 0))\n\n    def testDefMode2(self):\n        s = univ.SequenceOf()\n        s.append(univ.OctetString('ab'))\n        s.append(univ.OctetString('a'))\n        assert encoder.encode(s) == ints2octs((48, 128, 4, 2, 97, 98, 4, 1, 97, 0, 0))\n\n    def testDefMode3(self):\n        s = univ.SequenceOf()\n        s.append(univ.OctetString('b'))\n        s.append(univ.OctetString('a'))\n        assert encoder.encode(s) == ints2octs((48, 128, 4, 1, 98, 4, 1, 97, 0, 0))\n\n    def testDefMode4(self):\n        s = univ.SequenceOf()\n        s.append(univ.OctetString('a'))\n        s.append(univ.OctetString('b'))\n        assert encoder.encode(s) == ints2octs((48, 128, 4, 1, 97, 4, 1, 98, 0, 0))\n\n\nclass SequenceOfEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SequenceOf(componentType=univ.OctetString())\n\n    def testEmpty(self):\n        self.s.clear()\n        assert encoder.encode(self.s) == ints2octs((48, 128, 0, 0))\n\n    def testIndefMode1(self):\n        self.s.clear()\n        self.s.append('a')\n        self.s.append('ab')\n        assert encoder.encode(self.s) == ints2octs((48, 128, 4, 1, 97, 4, 2, 97, 98, 0, 0))\n\n    def testIndefMode2(self):\n        self.s.clear()\n        self.s.append('ab')\n        self.s.append('a')\n        assert encoder.encode(self.s) == ints2octs((48, 128, 4, 2, 97, 98, 4, 1, 97, 0, 0))\n\n    def testIndefMode3(self):\n        self.s.clear()\n        self.s.append('b')\n        self.s.append('a')\n        assert encoder.encode(self.s) == ints2octs((48, 128, 4, 1, 98, 4, 1, 97, 0, 0))\n\n    def testIndefMode4(self):\n        self.s.clear()\n        self.s.append('a')\n        self.s.append('b')\n        assert encoder.encode(self.s) == ints2octs((48, 128, 4, 1, 97, 4, 1, 98, 0, 0))\n\n\nclass SetOfEncoderTestCase(BaseTestCase):\n    def testEmpty(self):\n        s = univ.SetOf()\n        s.clear()\n        assert encoder.encode(s) == ints2octs((49, 128, 0, 0))\n\n    def testDefMode1(self):\n        s = univ.SetOf()\n        s.append(univ.OctetString('a'))\n        s.append(univ.OctetString('ab'))\n        assert encoder.encode(s) == ints2octs((49, 128, 4, 1, 97, 4, 2, 97, 98, 0, 0))\n\n    def testDefMode2(self):\n        s = univ.SetOf()\n        s.append(univ.OctetString('ab'))\n        s.append(univ.OctetString('a'))\n        assert encoder.encode(s) == ints2octs((49, 128, 4, 1, 97, 4, 2, 97, 98, 0, 0))\n\n    def testDefMode3(self):\n        s = univ.SetOf()\n        s.append(univ.OctetString('b'))\n        s.append(univ.OctetString('a'))\n        assert encoder.encode(s) == ints2octs((49, 128, 4, 1, 97, 4, 1, 98, 0, 0))\n\n    def testDefMode4(self):\n        s = univ.SetOf()\n        s.append(univ.OctetString('a'))\n        s.append(univ.OctetString('b'))\n        assert encoder.encode(s) == ints2octs((49, 128, 4, 1, 97, 4, 1, 98, 0, 0))\n\n\nclass SetOfEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SetOf(componentType=univ.OctetString())\n\n    def testEmpty(self):\n        self.s.clear()\n        assert encoder.encode(self.s) == ints2octs((49, 128, 0, 0))\n\n    def testIndefMode1(self):\n        self.s.clear()\n        self.s.append('a')\n        self.s.append('ab')\n\n        assert encoder.encode(self.s) == ints2octs((49, 128, 4, 1, 97, 4, 2, 97, 98, 0, 0))\n\n    def testIndefMode2(self):\n        self.s.clear()\n        self.s.append('ab')\n        self.s.append('a')\n\n        assert encoder.encode(self.s) == ints2octs((49, 128, 4, 1, 97, 4, 2, 97, 98, 0, 0))\n\n    def testIndefMode3(self):\n        self.s.clear()\n        self.s.append('b')\n        self.s.append('a')\n\n        assert encoder.encode(self.s) == ints2octs((49, 128, 4, 1, 97, 4, 1, 98, 0, 0))\n\n    def testIndefMode4(self):\n        self.s.clear()\n        self.s.append('a')\n        self.s.append('b')\n\n        assert encoder.encode(self.s) == ints2octs((49, 128, 4, 1, 97, 4, 1, 98, 0, 0))\n\n\nclass SetEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testIndefMode(self):\n        assert encoder.encode(self.s) == ints2octs((49, 128, 2, 1, 1, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0, 0, 0))\n\n    def testWithOptionalIndefMode(self):\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((49, 128, 2, 1, 1, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0, 0, 0))\n\n    def testWithDefaultedIndefMode(self):\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((49, 128, 2, 1, 1, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0, 0, 0))\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((49, 128, 2, 1, 1, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0, 0, 0))\n\n\nclass SetEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('place-holder', univ.Null('')),\n            namedtype.OptionalNamedType('first-name', univ.OctetString()),\n            namedtype.DefaultedNamedType('age', univ.Integer(33))\n        ))\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0)\n\n    def __initWithOptional(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0)\n        self.s.setComponentByPosition(1, 'quick brown')\n\n    def __initWithDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0)\n        self.s.setComponentByPosition(2, 1)\n\n    def __initWithOptionalAndDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testIndefMode(self):\n        self.__init()\n        assert encoder.encode(self.s) == ints2octs((49, 128, 5, 0, 0, 0))\n\n    def testWithOptionalIndefMode(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((49, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0, 0, 0))\n\n    def testWithDefaultedIndefMode(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((49, 128, 2, 1, 1, 5, 0, 0, 0))\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((49, 128, 2, 1, 1, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0, 0, 0))\n\n\nclass SetEncoderWithChoiceWithSchemaEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        c = univ.Choice(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('actual', univ.Boolean(0))\n        ))\n        self.s = univ.Set(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('place-holder', univ.Null('')),\n            namedtype.NamedType('status', c)\n        ))\n\n    def testIndefMode(self):\n        self.s.setComponentByPosition(0)\n        self.s.setComponentByName('status')\n        self.s.getComponentByName('status').setComponentByPosition(0, 1)\n        assert encoder.encode(self.s) == ints2octs((49, 128, 1, 1, 255, 5, 0, 0, 0))\n\n\nclass SetEncoderWithTaggedChoiceEncoderTestCase(BaseTestCase):\n\n    def testWithUntaggedChoice(self):\n\n        c = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('premium', univ.Boolean())\n            )\n        )\n\n        s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('customer', c)\n            )\n        )\n\n        s.setComponentByName('name', 'A')\n        s.getComponentByName('customer').setComponentByName('premium', True)\n\n        assert encoder.encode(s) == ints2octs((49, 128, 1, 1, 255, 4, 1, 65, 0, 0))\n\n    def testWithTaggedChoice(self):\n\n        c = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('premium', univ.Boolean())\n            )\n        ).subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 7))\n\n        s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('customer', c)\n            )\n        )\n\n        s.setComponentByName('name', 'A')\n        s.getComponentByName('customer').setComponentByName('premium', True)\n\n        assert encoder.encode(s) == ints2octs((49, 128, 4, 1, 65, 167, 128, 1, 1, 255, 0, 0, 0, 0))\n\n\nclass SequenceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testIndefMode(self):\n        assert encoder.encode(self.s) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testWithOptionalIndefMode(self):\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testWithDefaultedIndefMode(self):\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n\nclass SequenceEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null('')),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33))\n            )\n        )\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0)\n\n    def __initWithOptional(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0)\n        self.s.setComponentByPosition(1, 'quick brown')\n\n    def __initWithDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0)\n        self.s.setComponentByPosition(2, 1)\n\n    def __initWithOptionalAndDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testIndefMode(self):\n        self.__init()\n        assert encoder.encode(self.s) == ints2octs((48, 128, 5, 0, 0, 0))\n\n    def testWithOptionalIndefMode(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testWithDefaultedIndefMode(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((48, 128, 5, 0, 2, 1, 1, 0, 0))\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n\nclass SequenceEncoderWithUntaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any(), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 1, 49, 50, 0, 0)\n        )\n\n    def testEncodeOpenTypeChoiceTwo(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.OctetString('quick brown')\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 2, 113, 117, 105, 99, 107, 32, 98, 114,\n             111, 119, 110, 0, 0)\n        )\n\n    def testEncodeOpenTypeUnknownId(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.ObjectIdentifier('1.3.6')\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n    def testEncodeOpenTypeIncompatibleType(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.ObjectIdentifier('1.3.6')\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n\nclass SequenceEncoderWithImplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 1, 163, 128, 163, 128, 49, 50, 0, 0, 0, 0, 0, 0)\n        )\n\n\nclass SequenceEncoderWithExplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 1, 163, 128, 163, 128, 49, 50, 0, 0, 0, 0, 0, 0)\n        )\n\n\nclass SequenceEncoderWithUntaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any()), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 1, 49, 128, 49, 50, 0, 0, 0, 0)\n        )\n\n    def testEncodeOpenTypeChoiceTwo(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.OctetString('quick brown'))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 2, 49, 128, 113, 117, 105, 99, 107, 32, 98, 114,\n             111, 119, 110, 0, 0, 0, 0)\n        )\n\n    def testEncodeOpenTypeUnknownId(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.ObjectIdentifier('1.3.6'))\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n    def testEncodeOpenTypeIncompatibleType(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.ObjectIdentifier('1.3.6'))\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n\nclass SequenceEncoderWithImplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any().subtype(\n                        implicitTag=tag.Tag(\n                            tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 1, 49, 128, 163, 128, 163, 128, 49, 50, 0, 0,\n             0, 0, 0, 0, 0, 0)\n        )\n\n\nclass SequenceEncoderWithExplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any().subtype(\n                        explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 128, 2, 1, 1, 49, 128, 163, 128, 163, 128, 49, 50, 0, 0,\n             0, 0, 0, 0, 0, 0)\n        )\n\n\nclass NestedOptionalSequenceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        inner = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n        outerWithOptional = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('inner', inner),\n            )\n        )\n\n        outerWithDefault = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.DefaultedNamedType('inner', inner),\n            )\n        )\n\n        self.s1 = outerWithOptional\n        self.s2 = outerWithDefault\n\n    def __initOptionalWithDefaultAndOptional(self):\n        self.s1.clear()\n        self.s1[0][0] = 'test'\n        self.s1[0][1] = 123\n        return self.s1\n\n    def __initOptionalWithDefault(self):\n        self.s1.clear()\n        self.s1[0][1] = 123\n        return self.s1\n\n    def __initOptionalWithOptional(self):\n        self.s1.clear()\n        self.s1[0][0] = 'test'\n        return self.s1\n\n    def __initOptional(self):\n        self.s1.clear()\n        return self.s1\n\n    def __initDefaultWithDefaultAndOptional(self):\n        self.s2.clear()\n        self.s2[0][0] = 'test'\n        self.s2[0][1] = 123\n        return self.s2\n\n    def __initDefaultWithDefault(self):\n        self.s2.clear()\n        self.s2[0][0] = 'test'\n        return self.s2\n\n    def __initDefaultWithOptional(self):\n        self.s2.clear()\n        self.s2[0][1] = 123\n        return self.s2\n\n    def testOptionalWithDefaultAndOptional(self):\n        s = self.__initOptionalWithDefaultAndOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 2, 1, 123, 0, 0, 0, 0))\n\n    def testOptionalWithDefault(self):\n        s = self.__initOptionalWithDefault()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 2, 1, 123, 0, 0, 0, 0))\n\n    def testOptionalWithOptional(self):\n        s = self.__initOptionalWithOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 0, 0, 0, 0))\n\n    def testOptional(self):\n        s = self.__initOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 0, 0))\n\n    def testDefaultWithDefaultAndOptional(self):\n        s = self.__initDefaultWithDefaultAndOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 2, 1, 123, 0, 0, 0, 0))\n\n    def testDefaultWithDefault(self):\n        s = self.__initDefaultWithDefault()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 0, 0, 0, 0))\n\n    def testDefaultWithOptional(self):\n        s = self.__initDefaultWithOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 2, 1, 123, 0, 0, 0, 0))\n\n\nclass NestedOptionalChoiceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        layer3 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n        layer2 = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('inner', layer3),\n                namedtype.NamedType('first-name', univ.OctetString())\n            )\n        )\n\n        layer1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('inner', layer2),\n            )\n        )\n\n        self.s = layer1\n\n    def __initOptionalWithDefaultAndOptional(self):\n        self.s.clear()\n        self.s[0][0][0] = 'test'\n        self.s[0][0][1] = 123\n        return self.s\n\n    def __initOptionalWithDefault(self):\n        self.s.clear()\n        self.s[0][0][1] = 123\n        return self.s\n\n    def __initOptionalWithOptional(self):\n        self.s.clear()\n        self.s[0][0][0] = 'test'\n        return self.s\n\n    def __initOptional(self):\n        self.s.clear()\n        return self.s\n\n    def testOptionalWithDefaultAndOptional(self):\n        s = self.__initOptionalWithDefaultAndOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 2, 1, 123, 0, 0, 0, 0))\n\n    def testOptionalWithDefault(self):\n        s = self.__initOptionalWithDefault()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 2, 1, 123, 0, 0, 0, 0))\n\n    def testOptionalWithOptional(self):\n        s = self.__initOptionalWithOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 0, 0, 0, 0))\n\n    def testOptional(self):\n        s = self.__initOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 0, 0))\n\n\nclass NestedOptionalSequenceOfEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        layer2 = univ.SequenceOf(\n            componentType=univ.OctetString()\n        )\n\n        layer1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('inner', layer2),\n            )\n        )\n\n        self.s = layer1\n\n    def __initOptionalWithValue(self):\n        self.s.clear()\n        self.s[0][0] = 'test'\n        return self.s\n\n    def __initOptional(self):\n        self.s.clear()\n        return self.s\n\n    def testOptionalWithValue(self):\n        s = self.__initOptionalWithValue()\n        assert encoder.encode(s) == ints2octs((48, 128, 48, 128, 4, 4, 116, 101, 115, 116, 0, 0, 0, 0))\n\n    def testOptional(self):\n        s = self.__initOptional()\n        assert encoder.encode(s) == ints2octs((48, 128, 0, 0))\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/cer/test_decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.type import univ\nfrom pyasn1.codec.cer import decoder\nfrom pyasn1.compat.octets import ints2octs, str2octs, null\nfrom pyasn1.error import PyAsn1Error\n\n\nclass BooleanDecoderTestCase(BaseTestCase):\n    def testTrue(self):\n        assert decoder.decode(ints2octs((1, 1, 255))) == (1, null)\n\n    def testFalse(self):\n        assert decoder.decode(ints2octs((1, 1, 0))) == (0, null)\n\n    def testEmpty(self):\n        try:\n            decoder.decode(ints2octs((1, 0)))\n        except PyAsn1Error:\n            pass\n\n    def testOverflow(self):\n        try:\n            decoder.decode(ints2octs((1, 2, 0, 0)))\n        except PyAsn1Error:\n            pass\n\n\nclass BitStringDecoderTestCase(BaseTestCase):\n    def testShortMode(self):\n        assert decoder.decode(\n            ints2octs((3, 3, 6, 170, 128))\n        ) == (((1, 0) * 5), null)\n\n    def testLongMode(self):\n        assert decoder.decode(\n            ints2octs((3, 127, 6) + (170,) * 125 + (128,))\n        ) == (((1, 0) * 501), null)\n\n    # TODO: test failures on short chunked and long unchunked substrate samples\n\n\nclass OctetStringDecoderTestCase(BaseTestCase):\n    def testShortMode(self):\n        assert decoder.decode(\n            ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120)),\n        ) == (str2octs('Quick brown fox'), null)\n\n    def testLongMode(self):\n        assert decoder.decode(\n            ints2octs((36, 128, 4, 130, 3, 232) + (81,) * 1000 + (4, 1, 81, 0, 0))\n        ) == (str2octs('Q' * 1001), null)\n\n    # TODO: test failures on short chunked and long unchunked substrate samples\n\n\nclass SequenceDecoderWithUntaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any(), openType=openType)\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 1, 2, 1, 12, 0, 0)),\n            asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 2, 4, 11, 113, 117, 105, 99, 107, 32, 98,\n                114, 111, 119, 110, 0, 0)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1] == univ.OctetString('quick brown')\n\n    def testDecodeOpenTypesUnknownType(self):\n        try:\n            s, r = decoder.decode(\n                ints2octs((48, 128, 6, 1, 1, 2, 1, 12, 0, 0)), asn1Spec=self.s,\n                decodeOpenTypes=True\n            )\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'unknown open type tolerated'\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 3, 6, 1, 12, 0, 0)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='06010c')\n\n    def testDontDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 1, 2, 1, 12, 0, 0)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == ints2octs((2, 1, 12))\n\n    def testDontDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 2, 4, 11, 113, 117, 105, 99, 107, 32, 98,\n                114, 111, 119, 110, 0, 0)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1] == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n\nclass SequenceDecoderWithImplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 1, 163, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 3, 163, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithExplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.Any().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 1, 163, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 3, 163, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithUntaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(componentType=univ.Any()),\n                                    openType=openType)\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 1, 49, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 2, 49, 128, 4, 11, 113, 117, 105, 99,\n                       107, 32, 98, 114, 111, 119, 110, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1][0] == univ.OctetString('quick brown')\n\n    def testDecodeOpenTypesUnknownType(self):\n        try:\n            s, r = decoder.decode(\n                ints2octs((48, 128, 6, 1, 1, 49, 128, 2, 1, 12, 0, 0, 0, 0)),\n                asn1Spec=self.s, decodeOpenTypes=True\n            )\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'unknown open type tolerated'\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 3, 49, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010c')\n\n    def testDontDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 1, 49, 128, 2, 1, 12, 0, 0, 0, 0)),\n            asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == ints2octs((2, 1, 12))\n\n    def testDontDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 128, 2, 1, 2, 49, 128, 4, 11, 113, 117, 105, 99, 107, 32,\n                98, 114, 111, 119, 110, 0, 0, 0, 0)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1][0] == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114,\n                                     111, 119, 110))\n\n\nclass SequenceDecoderWithImplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.SetOf(\n                        componentType=univ.Any().subtype(\n                            implicitTag=tag.Tag(\n                                tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 1, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 3, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithExplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.SetOf(\n                        componentType=univ.Any().subtype(\n                            explicitTag=tag.Tag(\n                                tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 1, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs( (48, 10, 2, 1, 3, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010C')\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/cer/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.codec.cer.test_encoder.suite',\n     'tests.codec.cer.test_decoder.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/cer/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/codec/ber/test_encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.type import univ\nfrom pyasn1.type import char\nfrom pyasn1.codec.ber import encoder\nfrom pyasn1.compat.octets import ints2octs\nfrom pyasn1.error import PyAsn1Error\n\n\nclass LargeTagEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.o = univ.Integer().subtype(\n            value=1, explicitTag=tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 0xdeadbeaf)\n        )\n\n    def testEncoder(self):\n        assert encoder.encode(self.o) == ints2octs((127, 141, 245, 182, 253, 47, 3, 2, 1, 1))\n\n\nclass IntegerEncoderTestCase(BaseTestCase):\n    def testPosInt(self):\n        assert encoder.encode(univ.Integer(12)) == ints2octs((2, 1, 12))\n\n    def testNegInt(self):\n        assert encoder.encode(univ.Integer(-12)) == ints2octs((2, 1, 244))\n\n    def testZero(self):\n        assert encoder.encode(univ.Integer(0)) == ints2octs((2, 1, 0))\n\n    def testCompactZero(self):\n        encoder.IntegerEncoder.supportCompactZero = True\n        substrate = encoder.encode(univ.Integer(0))\n        encoder.IntegerEncoder.supportCompactZero = False\n        assert substrate == ints2octs((2, 0))\n\n    def testMinusOne(self):\n        assert encoder.encode(univ.Integer(-1)) == ints2octs((2, 1, 255))\n\n    def testPosLong(self):\n        assert encoder.encode(\n            univ.Integer(0xffffffffffffffff)\n        ) == ints2octs((2, 9, 0, 255, 255, 255, 255, 255, 255, 255, 255))\n\n    def testNegLong(self):\n        assert encoder.encode(\n            univ.Integer(-0xffffffffffffffff)\n        ) == ints2octs((2, 9, 255, 0, 0, 0, 0, 0, 0, 0, 1))\n\n\nclass IntegerEncoderWithSchemaTestCase(BaseTestCase):\n    def testPosInt(self):\n        assert encoder.encode(12, asn1Spec=univ.Integer()) == ints2octs((2, 1, 12))\n\n    def testNegInt(self):\n        assert encoder.encode(-12, asn1Spec=univ.Integer()) == ints2octs((2, 1, 244))\n\n    def testZero(self):\n        assert encoder.encode(0, asn1Spec=univ.Integer()) == ints2octs((2, 1, 0))\n\n    def testPosLong(self):\n        assert encoder.encode(\n            0xffffffffffffffff, asn1Spec=univ.Integer()\n        ) == ints2octs((2, 9, 0, 255, 255, 255, 255, 255, 255, 255, 255))\n\n\nclass BooleanEncoderTestCase(BaseTestCase):\n    def testTrue(self):\n        assert encoder.encode(univ.Boolean(1)) == ints2octs((1, 1, 1))\n\n    def testFalse(self):\n        assert encoder.encode(univ.Boolean(0)) == ints2octs((1, 1, 0))\n\n\nclass BooleanEncoderWithSchemaTestCase(BaseTestCase):\n    def testTrue(self):\n        assert encoder.encode(True, asn1Spec=univ.Boolean()) == ints2octs((1, 1, 1))\n\n    def testFalse(self):\n        assert encoder.encode(False, asn1Spec=univ.Boolean()) == ints2octs((1, 1, 0))\n\n\nclass BitStringEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.b = univ.BitString((1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1))\n\n    def testDefMode(self):\n        assert encoder.encode(self.b) == ints2octs((3, 3, 1, 169, 138))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.b, defMode=False\n        ) == ints2octs((3, 3, 1, 169, 138))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.b, maxChunkSize=1\n        ) == ints2octs((35, 8, 3, 2, 0, 169, 3, 2, 1, 138))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.b, defMode=False, maxChunkSize=1\n        ) == ints2octs((35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0))\n\n    def testEmptyValue(self):\n        assert encoder.encode(univ.BitString([])) == ints2octs((3, 1, 0))\n\n\nclass BitStringEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.b = (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1)\n        self.s = univ.BitString()\n\n    def testDefMode(self):\n        assert encoder.encode(self.b, asn1Spec=self.s) == ints2octs((3, 3, 1, 169, 138))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.b, asn1Spec=self.s, defMode=False\n        ) == ints2octs((3, 3, 1, 169, 138))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.b, asn1Spec=self.s, maxChunkSize=1\n        ) == ints2octs((35, 8, 3, 2, 0, 169, 3, 2, 1, 138))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.b, asn1Spec=self.s, defMode=False, maxChunkSize=1\n        ) == ints2octs((35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0))\n\n    def testEmptyValue(self):\n        assert encoder.encode([],  asn1Spec=self.s) == ints2octs((3, 1, 0))\n\n\nclass OctetStringEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.o = univ.OctetString('Quick brown fox')\n\n    def testDefMode(self):\n        assert encoder.encode(self.o) == ints2octs(\n            (4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.o, defMode=False\n        ) == ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.o, maxChunkSize=4\n        ) == ints2octs((36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119,\n                        110, 32, 4, 3, 102, 111, 120))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.o, defMode=False, maxChunkSize=4\n        ) == ints2octs((36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110,\n                        32, 4, 3, 102,  111, 120, 0, 0))\n\n\nclass OctetStringEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.OctetString()\n        self.o = 'Quick brown fox'\n\n    def testDefMode(self):\n        assert encoder.encode(self.o, asn1Spec=self.s) == ints2octs(\n            (4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.o, asn1Spec=self.s, defMode=False\n        ) == ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.o, asn1Spec=self.s, maxChunkSize=4\n        ) == ints2octs((36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119,\n                        110, 32, 4, 3, 102, 111, 120))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.o, asn1Spec=self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110,\n                        32, 4, 3, 102,  111, 120, 0, 0))\n\n\nclass ExpTaggedOctetStringEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.o = univ.OctetString().subtype(\n            value='Quick brown fox',\n            explicitTag=tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 5)\n        )\n\n    def testDefMode(self):\n        assert encoder.encode(self.o) == ints2octs(\n            (101, 17, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.o, defMode=False\n        ) == ints2octs((101, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.o, defMode=True, maxChunkSize=4\n        ) == ints2octs((101, 25, 36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3,\n                        102, 111, 120))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.o, defMode=False, maxChunkSize=4\n        ) == ints2octs((101, 128, 36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120, 0, 0, 0, 0))\n\n\nclass NullEncoderTestCase(BaseTestCase):\n    def testNull(self):\n        assert encoder.encode(univ.Null('')) == ints2octs((5, 0))\n\n\nclass NullEncoderWithSchemaTestCase(BaseTestCase):\n    def testNull(self):\n        assert encoder.encode(None, univ.Null()) == ints2octs((5, 0))\n\n\nclass ObjectIdentifierEncoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert encoder.encode(\n            univ.ObjectIdentifier((1, 3, 6, 0, 0xffffe))\n        ) == ints2octs((6, 6, 43, 6, 0, 191, 255, 126))\n\n    def testEdge1(self):\n        assert encoder.encode(\n            univ.ObjectIdentifier((0, 39))\n        ) == ints2octs((6, 1, 39))\n\n    def testEdge2(self):\n        assert encoder.encode(\n            univ.ObjectIdentifier((1, 39))\n        ) == ints2octs((6, 1, 79))\n\n    def testEdge3(self):\n        # 01111111\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 40))\n        ) == ints2octs((6, 1, 120))\n\n    def testEdge4(self):\n        # 10010000|10000000|10000000|10000000|01001111\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 0xffffffff))\n        ) == ints2octs((6, 5, 0x90, 0x80, 0x80, 0x80, 0x4F))\n\n    def testEdge5(self):\n        # 01111111\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 47))\n        ) == ints2octs((6, 1, 0x7F))\n\n    def testEdge6(self):\n        # 10000001|00000000\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 48))\n        ) == ints2octs((6, 2, 0x81, 0x00))\n\n    def testEdge7(self):\n        # 10000001|00110100|00000003\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 100, 3))\n        ) == ints2octs((6, 3, 0x81, 0x34, 0x03))\n\n    def testEdge8(self):\n        # 10000101|00000000\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 560))\n        ) == ints2octs((6, 2, 133, 0))\n\n    def testEdge9(self):\n        # 10001000|10000100|10000111|0000010\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 16843570))\n        ) == ints2octs((6, 4, 0x88, 0x84, 0x87, 0x02))\n\n    def testEdgeA(self):\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 5))\n        ) == ints2octs((6, 1, 85))\n\n    def testImpossible1(self):\n        try:\n            encoder.encode(univ.ObjectIdentifier((3, 1, 2)))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'impossible leading arc tolerated'\n\n    def testImpossible2(self):\n        try:\n            encoder.encode(univ.ObjectIdentifier((0,)))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'single arc OID tolerated'\n\n    def testImpossible3(self):\n        try:\n            encoder.encode(univ.ObjectIdentifier((0, 40)))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'second arc overflow tolerated'\n\n    def testImpossible4(self):\n        try:\n            encoder.encode(univ.ObjectIdentifier((1, 40)))\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'second arc overflow tolerated'\n\n    def testLarge1(self):\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 18446744073709551535184467440737095))\n        ) == ints2octs((0x06, 0x11, 0x83, 0xC6, 0xDF, 0xD4, 0xCC, 0xB3, 0xFF, 0xFF, 0xFE, 0xF0, 0xB8, 0xD6, 0xB8, 0xCB,\n                        0xE2, 0xB7, 0x17))\n\n    def testLarge2(self):\n        assert encoder.encode(\n            univ.ObjectIdentifier((2, 999, 18446744073709551535184467440737095))\n        ) == ints2octs((0x06, 0x13, 0x88, 0x37, 0x83, 0xC6, 0xDF, 0xD4, 0xCC, 0xB3, 0xFF, 0xFF, 0xFE, 0xF0, 0xB8, 0xD6,\n                        0xB8, 0xCB, 0xE2, 0xB6, 0x47))\n\n\nclass ObjectIdentifierWithSchemaEncoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert encoder.encode(\n            (1, 3, 6, 0, 0xffffe), asn1Spec=univ.ObjectIdentifier()\n        ) == ints2octs((6, 6, 43, 6, 0, 191, 255, 126))\n\n\nclass RelativeOIDEncoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert encoder.encode(\n            univ.RelativeOID((39,))\n        ) == ints2octs((13, 1, 39))\n\n    def testTwo(self):\n        assert encoder.encode(\n            univ.RelativeOID((5, 6))\n        ) == ints2octs((13, 2, 5, 6))\n\n    def testThree(self):\n        assert encoder.encode(\n            univ.RelativeOID((5, 6, 7))\n        ) == ints2octs((13, 3, 5, 6, 7))\n\n    def testLarge(self):\n        assert encoder.encode(\n            univ.RelativeOID((1079, 18446744073709551535184467440737095))\n        ) == ints2octs((0x0D, 0x13, 0x88, 0x37, 0x83, 0xC6, 0xDF, 0xD4, 0xCC,\n                        0xB3, 0xFF, 0xFF, 0xFE, 0xF0, 0xB8, 0xD6, 0xB8, 0xCB,\n                        0xE2, 0xB6, 0x47))\n\n\nclass RelativeOIDWithSchemaEncoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert encoder.encode(\n            (5, 6, 7), asn1Spec=univ.RelativeOID()\n        ) == ints2octs((13, 3, 5, 6, 7))\n\n\nclass RealEncoderTestCase(BaseTestCase):\n    def testChar(self):\n        assert encoder.encode(\n            univ.Real((123, 10, 11))\n        ) == ints2octs((9, 7, 3, 49, 50, 51, 69, 49, 49))\n\n    def testBin1(self):\n        assert encoder.encode(  # default binEncBase = 2\n            univ.Real((0.5, 2, 0))  # check encbase = 2 and exponent = -1\n        ) == ints2octs((9, 3, 128, 255, 1))\n\n    def testBin2(self):\n        r = univ.Real((3.25, 2, 0))\n        r.binEncBase = 8  # change binEncBase only for this instance of Real\n        assert encoder.encode(\n            r  # check encbase = 8\n        ) == ints2octs((9, 3, 148, 255, 13))\n\n    def testBin3(self):\n        # change binEncBase in the RealEncoder instance => for all further Real\n        binEncBase, encoder.TYPE_MAP[univ.Real.typeId].binEncBase = encoder.TYPE_MAP[univ.Real.typeId].binEncBase, 16\n        assert encoder.encode(\n            univ.Real((0.00390625, 2, 0))  # check encbase = 16\n        ) == ints2octs((9, 3, 160, 254, 1))\n        encoder.TYPE_MAP[univ.Real.typeId].binEncBase = binEncBase\n\n    def testBin4(self):\n        # choose binEncBase automatically for all further Real (testBin[4-7])\n        binEncBase, encoder.TYPE_MAP[univ.Real.typeId].binEncBase = encoder.TYPE_MAP[univ.Real.typeId].binEncBase, None\n        assert encoder.encode(\n            univ.Real((1, 2, 0))  # check exponent = 0\n        ) == ints2octs((9, 3, 128, 0, 1))\n        encoder.TYPE_MAP[univ.Real.typeId].binEncBase = binEncBase\n\n    def testBin5(self):\n        assert encoder.encode(\n            univ.Real((3, 2, -1020))  # case of 2 octs for exponent and\n            # negative exponent and abs(exponent) is\n            # all 1's and fills the whole octet(s)\n        ) == ints2octs((9, 4, 129, 252, 4, 3))\n\n    def testBin6(self):\n        assert encoder.encode(\n            univ.Real((1, 2, 262140))  # case of 3 octs for exponent and\n            # check that first 9 bits for exponent\n            # are not all 1's\n        ) == ints2octs((9, 5, 130, 3, 255, 252, 1))\n\n    def testBin7(self):\n        assert encoder.encode(\n            univ.Real((-1, 2, 76354972))  # case of >3 octs for exponent and\n            # mantissa < 0\n        ) == ints2octs((9, 7, 195, 4, 4, 141, 21, 156, 1))\n\n    def testPlusInf(self):\n        assert encoder.encode(univ.Real('inf')) == ints2octs((9, 1, 64))\n\n    def testMinusInf(self):\n        assert encoder.encode(univ.Real('-inf')) == ints2octs((9, 1, 65))\n\n    def testZero(self):\n        assert encoder.encode(univ.Real(0)) == ints2octs((9, 0))\n\n\nclass RealEncoderWithSchemaTestCase(BaseTestCase):\n    def testChar(self):\n        assert encoder.encode(\n            (123, 10, 11), asn1Spec=univ.Real()\n        ) == ints2octs((9, 7, 3, 49, 50, 51, 69, 49, 49))\n\n\nclass UniversalStringEncoderTestCase(BaseTestCase):\n    def testEncoding(self):\n        assert encoder.encode(char.UniversalString(sys.version_info[0] >= 3 and 'abc' or unicode('abc'))) == ints2octs(\n            (28, 12, 0, 0, 0, 97, 0, 0, 0, 98, 0, 0, 0, 99)), 'Incorrect encoding'\n\n\nclass UniversalStringEncoderWithSchemaTestCase(BaseTestCase):\n    def testEncoding(self):\n        assert encoder.encode(\n            sys.version_info[0] >= 3 and 'abc' or unicode('abc'), asn1Spec=char.UniversalString()\n        ) == ints2octs((28, 12, 0, 0, 0, 97, 0, 0, 0, 98, 0, 0, 0, 99)), 'Incorrect encoding'\n\n\nclass BMPStringEncoderTestCase(BaseTestCase):\n    def testEncoding(self):\n        assert encoder.encode(char.BMPString(sys.version_info[0] >= 3 and 'abc' or unicode('abc'))) == ints2octs(\n            (30, 6, 0, 97, 0, 98, 0, 99)), 'Incorrect encoding'\n\n\nclass BMPStringEncoderWithSchemaTestCase(BaseTestCase):\n    def testEncoding(self):\n        assert encoder.encode(\n            sys.version_info[0] >= 3 and 'abc' or unicode('abc'), asn1Spec=char.BMPString()\n        ) == ints2octs((30, 6, 0, 97, 0, 98, 0, 99)), 'Incorrect encoding'\n\n\nclass UTF8StringEncoderTestCase(BaseTestCase):\n    def testEncoding(self):\n        assert encoder.encode(char.UTF8String(sys.version_info[0] >= 3 and 'abc' or unicode('abc'))) == ints2octs(\n            (12, 3, 97, 98, 99)), 'Incorrect encoding'\n\n\nclass UTF8StringEncoderWithSchemaTestCase(BaseTestCase):\n    def testEncoding(self):\n        assert encoder.encode(\n            sys.version_info[0] >= 3 and 'abc' or unicode('abc'), asn1Spec=char.UTF8String()\n        ) == ints2octs((12, 3, 97, 98, 99)), 'Incorrect encoding'\n\n\nclass SequenceOfEncoderTestCase(BaseTestCase):\n    def testEmpty(self):\n        s = univ.SequenceOf()\n        s.clear()\n        assert encoder.encode(s) == ints2octs((48, 0))\n\n    def testDefMode(self):\n        s = univ.SequenceOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(s) == ints2octs((48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        s = univ.SequenceOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=False\n        ) == ints2octs((48, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testDefModeChunked(self):\n        s = univ.SequenceOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        s = univ.SequenceOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n\nclass SequenceOfEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SequenceOf(componentType=univ.OctetString())\n        self.v = ['quick brown']\n\n    def testEmpty(self):\n        assert encoder.encode([], asn1Spec=self.s) == ints2octs((48, 0))\n\n    def testDefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s\n        ) == ints2octs((48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False\n        ) == ints2octs((48, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n\nclass SequenceOfEncoderWithComponentsSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SequenceOf(componentType=univ.OctetString())\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, 'quick brown')\n\n    def testDefMode(self):\n        self.__init()\n        assert encoder.encode(self.s) == ints2octs((48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testDefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n\nclass SetOfEncoderTestCase(BaseTestCase):\n    def testEmpty(self):\n        s = univ.SetOf()\n        s.clear()\n        assert encoder.encode(s) == ints2octs((49, 0))\n\n    def testDefMode(self):\n        s = univ.SetOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(s) == ints2octs((49, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        s = univ.SetOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=False\n        ) == ints2octs((49, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testDefModeChunked(self):\n        s = univ.SetOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        s = univ.SetOf()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n\nclass SetOfEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SetOf(componentType=univ.OctetString())\n        self.v = ['quick brown']\n\n    def testEmpty(self):\n        s = univ.SetOf()\n        assert encoder.encode([], asn1Spec=self.s) == ints2octs((49, 0))\n\n    def testDefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s\n        ) == ints2octs((49, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False\n        ) == ints2octs((49, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs(\n            (49, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n\nclass SetOfEncoderWithComponentsSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SetOf(componentType=univ.OctetString())\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, 'quick brown')\n\n    def testDefMode(self):\n        self.__init()\n        assert encoder.encode(self.s) == ints2octs((49, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((49, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testDefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n\nclass SequenceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testDefMode(self):\n        assert encoder.encode(self.s) == ints2octs((48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n\n\nclass SequenceEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null()),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n        self.v = {\n            'place-holder': None,\n            'first-name': 'quick brown',\n            'age': 1\n        }\n\n    def testEmpty(self):\n        try:\n            assert encoder.encode({}, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'empty bare sequence tolerated'\n\n    def testDefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s\n        ) == ints2octs((48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n\n\nclass SequenceEncoderWithUntaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any(), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 5, 2, 1, 1, 49, 50)\n        )\n\n    def testEncodeOpenTypeChoiceTwo(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.OctetString('quick brown')\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 14, 2, 1, 2, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)\n        )\n\n    def testEncodeOpenTypeUnknownId(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.ObjectIdentifier('1.3.6')\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n    def testEncodeOpenTypeIncompatibleType(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.ObjectIdentifier('1.3.6')\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n\nclass SequenceEncoderWithImplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 9, 2, 1, 1, 131, 4, 131, 2, 49, 50)\n        )\n\n\nclass SequenceEncoderWithExplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 9, 2, 1, 1, 163, 4, 163, 2, 49, 50)\n    )\n\n\nclass SequenceEncoderWithUntaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any()), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 7, 2, 1, 1, 49, 2, 49, 50)\n        )\n\n    def testEncodeOpenTypeChoiceTwo(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.OctetString('quick brown'))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 16, 2, 1, 2, 49, 11, 113, 117, 105, 99, 107, 32, 98, 114,\n             111, 119, 110)\n        )\n\n    def testEncodeOpenTypeUnknownId(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.ObjectIdentifier('1.3.6'))\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n    def testEncodeOpenTypeIncompatibleType(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.ObjectIdentifier('1.3.6'))\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n\nclass SequenceEncoderWithImplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any().subtype(\n                        implicitTag=tag.Tag(\n                            tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 11, 2, 1, 1, 49, 6, 131, 4, 131, 2, 49, 50)\n        )\n\n\nclass SequenceEncoderWithExplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any().subtype(\n                        explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 11, 2, 1, 1, 49, 6, 163, 4, 163, 2, 49, 50)\n        )\n\n\nclass SequenceEncoderWithComponentsSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null()),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, '')\n\n    def __initWithOptional(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, '')\n        self.s.setComponentByPosition(1, 'quick brown')\n\n    def __initWithDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, '')\n        self.s.setComponentByPosition(2, 1)\n\n    def __initWithOptionalAndDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testDefMode(self):\n        self.__init()\n        assert encoder.encode(self.s) == ints2octs((48, 2, 5, 0))\n\n    def testIndefMode(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 5, 0, 0, 0))\n\n    def testDefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 2, 5, 0))\n\n    def testIndefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 5, 0, 0, 0))\n\n    def testWithOptionalDefMode(self):\n        self.__initWithOptional()\n        assert encoder.encode(self.s) == ints2octs(\n            (48, 15, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testWithOptionalIndefMode(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testWithOptionalDefModeChunked(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 21, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testWithOptionalIndefModeChunked(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs(\n            (48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n    def testWithDefaultedDefMode(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(self.s) == ints2octs((48, 5, 5, 0, 2, 1, 1))\n\n    def testWithDefaultedIndefMode(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 5, 0, 2, 1, 1, 0, 0))\n\n    def testWithDefaultedDefModeChunked(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((48, 5, 5, 0, 2, 1, 1))\n\n    def testWithDefaultedIndefModeChunked(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 5, 0, 2, 1, 1, 0, 0))\n\n    def testWithOptionalAndDefaultedDefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(self.s) == ints2octs(\n            (48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testWithOptionalAndDefaultedDefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs(\n            (48, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n\n    def testWithOptionalAndDefaultedIndefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0,\n                        0, 2, 1, 1, 0, 0))\n\n\nclass ExpTaggedSequenceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('number', univ.Integer()),\n            )\n        )\n\n        s = s.subtype(\n            explicitTag=tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 5)\n        )\n\n        s[0] = 12\n\n        self.s = s\n\n    def testDefMode(self):\n        assert encoder.encode(self.s) == ints2octs((101, 5, 48, 3, 2, 1, 12))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((101, 128, 48, 128, 2, 1, 12, 0, 0, 0, 0))\n\n\nclass ExpTaggedSequenceComponentEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('number', univ.Boolean().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),\n            )\n        )\n\n        self.s[0] = True\n\n    def testDefMode(self):\n        assert encoder.encode(self.s) == ints2octs((48, 5, 160, 3, 1, 1, 1))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((48, 128, 160, 3, 1, 1, 1, 0, 0, 0, 0))\n\n\nclass SetEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testDefMode(self):\n        assert encoder.encode(self.s) == ints2octs((49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((49, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n\n\nclass SetEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null()),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n        self.v = {\n            'place-holder': None,\n            'first-name': 'quick brown',\n            'age': 1\n        }\n\n    def testEmpty(self):\n        try:\n            assert encoder.encode({}, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'empty bare SET tolerated'\n\n    def testDefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s\n        ) == ints2octs((49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n\n    def testIndefMode(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False\n        ) == ints2octs((49, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testDefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n\n    def testIndefModeChunked(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n\n\nclass SetEncoderWithComponentsSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null()),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, '')\n\n    def __initWithOptional(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, '')\n        self.s.setComponentByPosition(1, 'quick brown')\n\n    def __initWithDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, '')\n        self.s.setComponentByPosition(2, 1)\n\n    def __initWithOptionalAndDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(''))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testDefMode(self):\n        self.__init()\n        assert encoder.encode(self.s) == ints2octs((49, 2, 5, 0))\n\n    def testIndefMode(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((49, 128, 5, 0, 0, 0))\n\n    def testDefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 2, 5, 0))\n\n    def testIndefModeChunked(self):\n        self.__init()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 5, 0, 0, 0))\n\n    def testWithOptionalDefMode(self):\n        self.__initWithOptional()\n        assert encoder.encode(self.s) == ints2octs(\n            (49, 15, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testWithOptionalIndefMode(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((49, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n\n    def testWithOptionalDefModeChunked(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 21, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testWithOptionalIndefModeChunked(self):\n        self.__initWithOptional()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs(\n            (49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n\n    def testWithDefaultedDefMode(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(self.s) == ints2octs((49, 5, 5, 0, 2, 1, 1))\n\n    def testWithDefaultedIndefMode(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((49, 128, 5, 0, 2, 1, 1, 0, 0))\n\n    def testWithDefaultedDefModeChunked(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs((49, 5, 5, 0, 2, 1, 1))\n\n    def testWithDefaultedIndefModeChunked(self):\n        self.__initWithDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 5, 0, 2, 1, 1, 0, 0))\n\n    def testWithOptionalAndDefaultedDefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(self.s) == ints2octs(\n            (49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False\n        ) == ints2octs((49, 128, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1, 0, 0))\n\n    def testWithOptionalAndDefaultedDefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s, defMode=True, maxChunkSize=4\n        ) == ints2octs(\n            (49, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n\n    def testWithOptionalAndDefaultedIndefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert encoder.encode(\n            self.s, defMode=False, maxChunkSize=4\n        ) == ints2octs((49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n\n\nclass ChoiceEncoderTestCase(BaseTestCase):\n\n    def testEmpty(self):\n        s = univ.Choice()\n        try:\n            encoder.encode(s)\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'encoded unset choice'\n\n    def testDefModeOptionOne(self):\n        s = univ.Choice()\n        s.setComponentByPosition(0, univ.Null(''))\n        assert encoder.encode(s) == ints2octs((5, 0))\n\n    def testDefModeOptionTwo(self):\n        s = univ.Choice()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(s) == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testIndefMode(self):\n        s = univ.Choice()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=False\n        ) == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n    def testDefModeChunked(self):\n        s = univ.Choice()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=True, maxChunkSize=4\n        ) == ints2octs((36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n\n    def testIndefModeChunked(self):\n        s = univ.Choice()\n        s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        assert encoder.encode(\n            s, defMode=False, maxChunkSize=4\n        ) == ints2octs((36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0))\n\n\nclass ChoiceEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null('')),\n                namedtype.NamedType('number', univ.Integer(0)),\n                namedtype.NamedType('string', univ.OctetString())\n            )\n        )\n        self.v = {\n            'place-holder': None\n        }\n\n    def testFilled(self):\n        assert encoder.encode(\n            self.v, asn1Spec=self.s\n        ) == ints2octs((5, 0))\n\n\nclass ChoiceEncoderWithComponentsSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null('')),\n                namedtype.NamedType('number', univ.Integer(0)),\n                namedtype.NamedType('string', univ.OctetString())\n            )\n        )\n\n    def testEmpty(self):\n        try:\n            encoder.encode(self.s)\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'encoded unset choice'\n\n    def testFilled(self):\n        self.s.setComponentByPosition(0, univ.Null(''))\n        assert encoder.encode(self.s) == ints2octs((5, 0))\n\n    def testTagged(self):\n        s = self.s.subtype(\n            explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 4)\n        )\n        s.setComponentByPosition(0, univ.Null(''))\n        assert encoder.encode(s) == ints2octs((164, 2, 5, 0))\n\n    def testUndefLength(self):\n        self.s.setComponentByPosition(2, univ.OctetString('abcdefgh'))\n        assert encoder.encode(self.s, defMode=False, maxChunkSize=3) == ints2octs(\n            (36, 128, 4, 3, 97, 98, 99, 4, 3, 100, 101, 102, 4, 2, 103, 104, 0, 0))\n\n    def testTaggedUndefLength(self):\n        s = self.s.subtype(\n            explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 4)\n        )\n        s.setComponentByPosition(2, univ.OctetString('abcdefgh'))\n        assert encoder.encode(s, defMode=False, maxChunkSize=3) == ints2octs(\n            (164, 128, 36, 128, 4, 3, 97, 98, 99, 4, 3, 100, 101, 102, 4, 2, 103, 104, 0, 0, 0, 0))\n\n\nclass AnyEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Any(encoder.encode(univ.OctetString('fox')))\n\n    def testUntagged(self):\n        assert encoder.encode(self.s) == ints2octs((4, 3, 102, 111, 120))\n\n    def testTaggedEx(self):\n        s = self.s.subtype(\n            explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4)\n        )\n        assert encoder.encode(s) == ints2octs((164, 5, 4, 3, 102, 111, 120))\n\n    def testTaggedIm(self):\n        s = self.s.subtype(\n            implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4)\n        )\n        assert encoder.encode(s) == ints2octs((132, 5, 4, 3, 102, 111, 120))\n\n\nclass AnyEncoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Any()\n        self.v = encoder.encode(univ.OctetString('fox'))\n\n    def testUntagged(self):\n        assert encoder.encode(self.v, asn1Spec=self.s) == ints2octs((4, 3, 102, 111, 120))\n\n    def testTaggedEx(self):\n        s = self.s.subtype(\n            explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4)\n        )\n        assert encoder.encode(self.v, asn1Spec=s) == ints2octs((164, 5, 4, 3, 102, 111, 120))\n\n    def testTaggedIm(self):\n        s = self.s.subtype(\n            implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4)\n        )\n        assert encoder.encode(self.v, asn1Spec=s) == ints2octs((132, 5, 4, 3, 102, 111, 120))\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/ber/test_decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport gzip\nimport io\nimport os\nimport sys\nimport tempfile\nimport unittest\nimport zipfile\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.type import univ\nfrom pyasn1.type import char\nfrom pyasn1.codec import streaming\nfrom pyasn1.codec.ber import decoder\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.compat.octets import ints2octs, str2octs, null\nfrom pyasn1 import error\n\n\nclass LargeTagDecoderTestCase(BaseTestCase):\n    def testLargeTag(self):\n        assert decoder.decode(ints2octs((127, 141, 245, 182, 253, 47, 3, 2, 1, 1))) == (1, null)\n\n    def testLongTag(self):\n        assert decoder.decode(ints2octs((0x1f, 2, 1, 0)))[0].tagSet == univ.Integer.tagSet\n\n    def testTagsEquivalence(self):\n        integer = univ.Integer(2).subtype(implicitTag=tag.Tag(tag.tagClassContext, 0, 0))\n        assert decoder.decode(ints2octs((0x9f, 0x80, 0x00, 0x02, 0x01, 0x02)), asn1Spec=integer) == decoder.decode(\n            ints2octs((0x9f, 0x00, 0x02, 0x01, 0x02)), asn1Spec=integer)\n\n\nclass DecoderCacheTestCase(BaseTestCase):\n    def testCache(self):\n        assert decoder.decode(ints2octs((0x1f, 2, 1, 0))) == decoder.decode(ints2octs((0x1f, 2, 1, 0)))\n\n\nclass IntegerDecoderTestCase(BaseTestCase):\n    def testPosInt(self):\n        assert decoder.decode(ints2octs((2, 1, 12))) == (12, null)\n\n    def testNegInt(self):\n        assert decoder.decode(ints2octs((2, 1, 244))) == (-12, null)\n\n    def testZero(self):\n        assert decoder.decode(ints2octs((2, 0))) == (0, null)\n\n    def testZeroLong(self):\n        assert decoder.decode(ints2octs((2, 1, 0))) == (0, null)\n\n    def testMinusOne(self):\n        assert decoder.decode(ints2octs((2, 1, 255))) == (-1, null)\n\n    def testPosLong(self):\n        assert decoder.decode(\n            ints2octs((2, 9, 0, 255, 255, 255, 255, 255, 255, 255, 255))\n        ) == (0xffffffffffffffff, null)\n\n    def testNegLong(self):\n        assert decoder.decode(\n            ints2octs((2, 9, 255, 0, 0, 0, 0, 0, 0, 0, 1))\n        ) == (-0xffffffffffffffff, null)\n\n    def testSpec(self):\n        try:\n            decoder.decode(\n                ints2octs((2, 1, 12)), asn1Spec=univ.Null()\n            ) == (12, null)\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong asn1Spec worked out'\n        assert decoder.decode(\n            ints2octs((2, 1, 12)), asn1Spec=univ.Integer()\n        ) == (12, null)\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(ints2octs((34, 1, 12)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n\nclass BooleanDecoderTestCase(BaseTestCase):\n    def testTrue(self):\n        assert decoder.decode(ints2octs((1, 1, 1))) == (1, null)\n\n    def testTrueNeg(self):\n        assert decoder.decode(ints2octs((1, 1, 255))) == (1, null)\n\n    def testExtraTrue(self):\n        assert decoder.decode(ints2octs((1, 1, 1, 0, 120, 50, 50))) == (1, ints2octs((0, 120, 50, 50)))\n\n    def testFalse(self):\n        assert decoder.decode(ints2octs((1, 1, 0))) == (0, null)\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(ints2octs((33, 1, 1)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n\nclass BitStringDecoderTestCase(BaseTestCase):\n    def testDefMode(self):\n        assert decoder.decode(\n            ints2octs((3, 3, 1, 169, 138))\n        ) == ((1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1), null)\n\n    def testIndefMode(self):\n        assert decoder.decode(\n            ints2octs((3, 3, 1, 169, 138))\n        ) == ((1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1), null)\n\n    def testDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((35, 8, 3, 2, 0, 169, 3, 2, 1, 138))\n        ) == ((1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1), null)\n\n    def testIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0))\n        ) == ((1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1), null)\n\n    def testDefModeChunkedSubst(self):\n        assert decoder.decode(\n            ints2octs((35, 8, 3, 2, 0, 169, 3, 2, 1, 138)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((3, 2, 0, 169, 3, 2, 1, 138)), str2octs(''))\n\n    def testDefModeChunkedSubstV04(self):\n        assert decoder.decode(\n            ints2octs((35, 8, 3, 2, 0, 169, 3, 2, 1, 138)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((3, 2, 0, 169, 3, 2, 1, 138)), str2octs(''))\n\n    def testIndefModeChunkedSubst(self):\n        assert decoder.decode(\n            ints2octs((35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((3, 2, 0, 169, 3, 2, 1, 138, 0, 0)), str2octs(''))\n\n    def testIndefModeChunkedSubstV04(self):\n        assert decoder.decode(\n            ints2octs((35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((3, 2, 0, 169, 3, 2, 1, 138, 0, 0)), str2octs(''))\n\n    def testTypeChecking(self):\n        try:\n            decoder.decode(ints2octs((35, 4, 2, 2, 42, 42)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'accepted mis-encoded bit-string constructed out of an integer'\n\n\nclass OctetStringDecoderTestCase(BaseTestCase):\n    def testDefMode(self):\n        assert decoder.decode(\n            ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n        ) == (str2octs('Quick brown fox'), null)\n\n    def testIndefMode(self):\n        assert decoder.decode(\n            ints2octs((36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0, 0))\n        ) == (str2octs('Quick brown fox'), null)\n\n    def testDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs(\n                (36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120))\n        ) == (str2octs('Quick brown fox'), null)\n\n    def testIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120, 0, 0))\n        ) == (str2octs('Quick brown fox'), null)\n\n    def testDefModeChunkedSubst(self):\n        assert decoder.decode(\n            ints2octs(\n                (36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120)), str2octs(''))\n\n    def testDefModeChunkedSubstV04(self):\n        assert decoder.decode(\n            ints2octs(\n                (36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120)), str2octs(''))\n\n    def testIndefModeChunkedSubst(self):\n        assert decoder.decode(\n            ints2octs((36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111,\n                       120, 0, 0)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs(\n            (4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120, 0, 0)), str2octs(''))\n\n    def testIndefModeChunkedSubstV04(self):\n        assert decoder.decode(\n            ints2octs((36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111,\n                       120, 0, 0)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs(\n            (4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120, 0, 0)), str2octs(''))\n\n\nclass ExpTaggedOctetStringDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.o = univ.OctetString(\n            'Quick brown fox',\n            tagSet=univ.OctetString.tagSet.tagExplicitly(\n                tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 5)\n            ))\n\n    def testDefMode(self):\n        o, r = decoder.decode(\n            ints2octs((101, 17, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n        )\n        assert not r\n        assert self.o == o\n        assert self.o.tagSet == o.tagSet\n        assert self.o.isSameTypeWith(o)\n\n    def testIndefMode(self):\n        o, r = decoder.decode(\n            ints2octs((101, 128, 36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0, 0, 0, 0))\n        )\n        assert not r\n        assert self.o == o\n        assert self.o.tagSet == o.tagSet\n        assert self.o.isSameTypeWith(o)\n\n    def testDefModeChunked(self):\n        o, r = decoder.decode(\n            ints2octs((101, 25, 36, 23, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120))\n        )\n        assert not r\n        assert self.o == o\n        assert self.o.tagSet == o.tagSet\n        assert self.o.isSameTypeWith(o)\n\n    def testIndefModeChunked(self):\n        o, r = decoder.decode(\n            ints2octs((101, 128, 36, 128, 4, 4, 81, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 4, 111, 119, 110, 32, 4, 3, 102, 111, 120, 0, 0, 0, 0))\n        )\n        assert not r\n        assert self.o == o\n        assert self.o.tagSet == o.tagSet\n        assert self.o.isSameTypeWith(o)\n\n    def testDefModeSubst(self):\n        assert decoder.decode(\n            ints2octs((101, 17, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120)), str2octs(''))\n\n    def testDefModeSubstV04(self):\n        assert decoder.decode(\n            ints2octs((101, 17, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120)), str2octs(''))\n\n    def testIndefModeSubst(self):\n        assert decoder.decode(\n            ints2octs((\n                      101, 128, 36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0,\n                      0, 0, 0)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs(\n            (36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0, 0, 0, 0)), str2octs(''))\n\n    def testIndefModeSubstV04(self):\n        assert decoder.decode(\n            ints2octs((\n                      101, 128, 36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0,\n                      0, 0, 0)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs(\n            (36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0, 0, 0, 0)), str2octs(''))\n\n\nclass NullDecoderTestCase(BaseTestCase):\n    def testNull(self):\n        assert decoder.decode(ints2octs((5, 0))) == (null, null)\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(ints2octs((37, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n\n# Useful analysis of OID encoding issues could be found here:\n# https://misc.daniel-marschall.de/asn.1/oid_facts.html\nclass ObjectIdentifierDecoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert decoder.decode(\n            ints2octs((6, 6, 43, 6, 0, 191, 255, 126))\n        ) == ((1, 3, 6, 0, 0xffffe), null)\n\n    def testEdge1(self):\n        assert decoder.decode(\n            ints2octs((6, 1, 39))\n        ) == ((0, 39), null)\n\n    def testEdge2(self):\n        assert decoder.decode(\n            ints2octs((6, 1, 79))\n        ) == ((1, 39), null)\n\n    def testEdge3(self):\n        assert decoder.decode(\n            ints2octs((6, 1, 120))\n        ) == ((2, 40), null)\n\n    def testEdge4(self):\n        assert decoder.decode(\n            ints2octs((6, 5, 0x90, 0x80, 0x80, 0x80, 0x4F))\n        ) == ((2, 0xffffffff), null)\n\n    def testEdge5(self):\n        assert decoder.decode(\n            ints2octs((6, 1, 0x7F))\n        ) == ((2, 47), null)\n\n    def testEdge6(self):\n        assert decoder.decode(\n            ints2octs((6, 2, 0x81, 0x00))\n        ) == ((2, 48), null)\n\n    def testEdge7(self):\n        assert decoder.decode(\n            ints2octs((6, 3, 0x81, 0x34, 0x03))\n        ) == ((2, 100, 3), null)\n\n    def testEdge8(self):\n        assert decoder.decode(\n            ints2octs((6, 2, 133, 0))\n        ) == ((2, 560), null)\n\n    def testEdge9(self):\n        assert decoder.decode(\n            ints2octs((6, 4, 0x88, 0x84, 0x87, 0x02))\n        ) == ((2, 16843570), null)\n\n    def testNonLeading0x80(self):\n        assert decoder.decode(\n            ints2octs((6, 5, 85, 4, 129, 128, 0)),\n        ) == ((2, 5, 4, 16384), null)\n\n    def testLeading0x80Case1(self):\n        try:\n            decoder.decode(\n                ints2octs((6, 5, 85, 4, 128, 129, 0))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Leading 0x80 tolerated'\n\n    def testLeading0x80Case2(self):\n        try:\n            decoder.decode(\n                ints2octs((6, 7, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7F))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Leading 0x80 tolerated'\n\n    def testLeading0x80Case3(self):\n        try:\n            decoder.decode(\n                ints2octs((6, 2, 0x80, 1))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Leading 0x80 tolerated'\n\n    def testLeading0x80Case4(self):\n        try:\n            decoder.decode(\n                ints2octs((6, 2, 0x80, 0x7F))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Leading 0x80 tolerated'\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(ints2octs((38, 1, 239)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n    def testZeroLength(self):\n        try:\n            decoder.decode(ints2octs((6, 0, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'zero length tolerated'\n\n    def testIndefiniteLength(self):\n        try:\n            decoder.decode(ints2octs((6, 128, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'indefinite length tolerated'\n\n    def testReservedLength(self):\n        try:\n            decoder.decode(ints2octs((6, 255, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'reserved length tolerated'\n\n    def testLarge1(self):\n        assert decoder.decode(\n            ints2octs((0x06, 0x11, 0x83, 0xC6, 0xDF, 0xD4, 0xCC, 0xB3, 0xFF, 0xFF, 0xFE, 0xF0, 0xB8, 0xD6, 0xB8, 0xCB, 0xE2, 0xB7, 0x17))\n        ) == ((2, 18446744073709551535184467440737095), null)\n\n    def testLarge2(self):\n        assert decoder.decode(\n            ints2octs((0x06, 0x13, 0x88, 0x37, 0x83, 0xC6, 0xDF, 0xD4, 0xCC, 0xB3, 0xFF, 0xFF, 0xFE, 0xF0, 0xB8, 0xD6, 0xB8, 0xCB, 0xE2, 0xB6, 0x47))\n        ) == ((2, 999, 18446744073709551535184467440737095), null)\n\n\nclass RelativeOIDDecoderTestCase(BaseTestCase):\n    def testOne(self):\n        obj, rest = decoder.decode(ints2octs((13, 1, 39)))\n        assert str(obj) == '39'\n        assert rest == null\n\n    def testTwo(self):\n        assert decoder.decode(\n            ints2octs((13, 2, 5, 6))\n        ) == ((5, 6), null)\n\n    def testThree(self):\n        assert decoder.decode(\n            ints2octs((13, 3, 5, 6, 7))\n        ) == ((5, 6, 7), null)\n\n    def testNonLeading0x80(self):\n        assert decoder.decode(\n            ints2octs((13, 5, 85, 4, 129, 128, 0)),\n        ) == ((85, 4, 16384), null)\n\n    def testLeading0x80(self):\n        try:\n            decoder.decode(\n                ints2octs((13, 5, 85, 4, 128, 129, 0))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Leading 0x80 tolerated'\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(ints2octs((38, 1, 239)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n    def testZeroLength(self):\n        try:\n            decoder.decode(ints2octs((13, 0, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'zero length tolerated'\n\n    def testIndefiniteLength(self):\n        try:\n            decoder.decode(ints2octs((13, 128, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'indefinite length tolerated'\n\n    def testReservedLength(self):\n        try:\n            decoder.decode(ints2octs((13, 255, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'reserved length tolerated'\n\n    def testLarge(self):\n        assert decoder.decode(\n            ints2octs((0x0D, 0x13, 0x88, 0x37, 0x83, 0xC6, 0xDF, 0xD4, 0xCC, 0xB3, 0xFF, 0xFF, 0xFE, 0xF0, 0xB8, 0xD6, 0xB8, 0xCB, 0xE2, 0xB6, 0x47))\n        ) == ((1079, 18446744073709551535184467440737095), null)\n\n\nclass RealDecoderTestCase(BaseTestCase):\n    def testChar(self):\n        assert decoder.decode(\n            ints2octs((9, 7, 3, 49, 50, 51, 69, 49, 49))\n        ) == (univ.Real((123, 10, 11)), null)\n\n    def testBin1(self):  # check base = 2\n        assert decoder.decode(  # (0.5, 2, 0) encoded with base = 2\n            ints2octs((9, 3, 128, 255, 1))\n        ) == (univ.Real((1, 2, -1)), null)\n\n    def testBin2(self):  # check base = 2 and scale factor\n        assert decoder.decode(  # (3.25, 2, 0) encoded with base = 8\n            ints2octs((9, 3, 148, 255, 13))\n        ) == (univ.Real((26, 2, -3)), null)\n\n    def testBin3(self):  # check base = 16\n        assert decoder.decode(  # (0.00390625, 2, 0) encoded with base = 16\n            ints2octs((9, 3, 160, 254, 1))\n        ) == (univ.Real((1, 2, -8)), null)\n\n    def testBin4(self):  # check exponent = 0\n        assert decoder.decode(  # (1, 2, 0) encoded with base = 2\n            ints2octs((9, 3, 128, 0, 1))\n        ) == (univ.Real((1, 2, 0)), null)\n\n    def testBin5(self):  # case of 2 octs for exponent and negative exponent\n        assert decoder.decode(  # (3, 2, -1020) encoded with base = 16\n            ints2octs((9, 4, 161, 255, 1, 3))\n        ) == (univ.Real((3, 2, -1020)), null)\n\n# TODO: this requires Real type comparison fix\n\n#    def testBin6(self):\n#        assert decoder.decode(\n#            ints2octs((9, 5, 162, 0, 255, 255, 1))\n#        ) == (univ.Real((1, 2, 262140)), null)\n\n#    def testBin7(self):\n#        assert decoder.decode(\n#            ints2octs((9, 7, 227, 4, 1, 35, 69, 103, 1))\n#        ) == (univ.Real((-1, 2, 76354972)), null)\n\n    def testPlusInf(self):\n        assert decoder.decode(\n            ints2octs((9, 1, 64))\n        ) == (univ.Real('inf'), null)\n\n    def testMinusInf(self):\n        assert decoder.decode(\n            ints2octs((9, 1, 65))\n        ) == (univ.Real('-inf'), null)\n\n    def testEmpty(self):\n        assert decoder.decode(\n            ints2octs((9, 0))\n        ) == (univ.Real(0.0), null)\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(ints2octs((41, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n    def testShortEncoding(self):\n        try:\n            decoder.decode(ints2octs((9, 1, 131)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'accepted too-short real'\n\n\nclass UniversalStringDecoderTestCase(BaseTestCase):\n    def testDecoder(self):\n        assert decoder.decode(ints2octs((28, 12, 0, 0, 0, 97, 0, 0, 0, 98, 0, 0, 0, 99))) == (char.UniversalString(sys.version_info[0] >= 3 and 'abc' or unicode('abc')), null)\n\n\nclass BMPStringDecoderTestCase(BaseTestCase):\n    def testDecoder(self):\n        assert decoder.decode(ints2octs((30, 6, 0, 97, 0, 98, 0, 99))) == (char.BMPString(sys.version_info[0] >= 3 and 'abc' or unicode('abc')), null)\n\n\nclass UTF8StringDecoderTestCase(BaseTestCase):\n    def testDecoder(self):\n        assert decoder.decode(ints2octs((12, 3, 97, 98, 99))) == (char.UTF8String(sys.version_info[0] >= 3 and 'abc' or unicode('abc')), null)\n\n\nclass SequenceOfDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.SequenceOf(componentType=univ.OctetString())\n        self.s.setComponentByPosition(0, univ.OctetString('quick brown'))\n\n    def testDefMode(self):\n        assert decoder.decode(\n            ints2octs((48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n        ) == (self.s, null)\n\n    def testIndefMode(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n        ) == (self.s, null)\n\n    def testDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((48, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n        ) == (self.s, null)\n\n    def testIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n        ) == (self.s, null)\n\n    def testSchemalessDecoder(self):\n        assert decoder.decode(\n            ints2octs((48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=univ.SequenceOf()\n        ) == (self.s, null)\n\n\nclass ExpTaggedSequenceOfDecoderTestCase(BaseTestCase):\n\n    def testWithSchema(self):\n        s = univ.SequenceOf().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 3))\n        s2, r = decoder.decode(\n            ints2octs((163, 15, 48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=s\n        )\n        assert not r\n        assert s2 == [str2octs('quick brown')]\n        assert s.tagSet == s2.tagSet\n\n    def testWithoutSchema(self):\n        s = univ.SequenceOf().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 3))\n        s2, r = decoder.decode(\n            ints2octs((163, 15, 48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n        )\n        assert not r\n        assert s2 == [str2octs('quick brown')]\n        assert s.tagSet == s2.tagSet\n\n\nclass SequenceOfDecoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SequenceOf(componentType=univ.OctetString())\n        self.s.setComponentByPosition(0, univ.OctetString('quick brown'))\n\n    def testDefMode(self):\n        assert decoder.decode(\n            ints2octs((48, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefMode(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((48, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n\nclass SetOfDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SetOf(componentType=univ.OctetString())\n        self.s.setComponentByPosition(0, univ.OctetString('quick brown'))\n\n    def testDefMode(self):\n        assert decoder.decode(\n            ints2octs((49, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n        ) == (self.s, null)\n\n    def testIndefMode(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0))\n        ) == (self.s, null)\n\n    def testDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((49, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110))\n        ) == (self.s, null)\n\n    def testIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0))\n        ) == (self.s, null)\n\n    def testSchemalessDecoder(self):\n        assert decoder.decode(\n            ints2octs((49, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=univ.SetOf()\n        ) == (self.s, null)\n\n\nclass SetOfDecoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SetOf(componentType=univ.OctetString())\n        self.s.setComponentByPosition(0, univ.OctetString('quick brown'))\n\n    def testDefMode(self):\n        assert decoder.decode(\n            ints2octs((49, 13, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefMode(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((49, 19, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n\nclass SequenceDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null(null)),\n                namedtype.NamedType('first-name', univ.OctetString(null)),\n                namedtype.NamedType('age', univ.Integer(33))\n            )\n        )\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testWithOptionalAndDefaultedDefMode(self):\n        assert decoder.decode(\n            ints2octs((48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs(\n                (48, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeSubst(self):\n        assert decoder.decode(\n            ints2octs((48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)), str2octs(''))\n\n    def testWithOptionalAndDefaultedDefModeSubstV04(self):\n        assert decoder.decode(\n            ints2octs((48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)), str2octs(''))\n\n    def testWithOptionalAndDefaultedIndefModeSubst(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs(\n            (5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)), str2octs(''))\n\n    def testWithOptionalAndDefaultedIndefModeSubstV04(self):\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs(\n            (5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)), str2octs(''))\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(\n                ints2octs((16, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n\nclass SequenceDecoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null(null)),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n\n    def __initWithOptional(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n\n    def __initWithDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def __initWithOptionalAndDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testDefMode(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((48, 2, 5, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefMode(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testDefModeChunked(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((48, 2, 5, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefModeChunked(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalDefMode(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((48, 15, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionaIndefMode(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 0, 0)),\n            asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalDefModeChunked(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((48, 21, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110)),\n            asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalIndefModeChunked(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0,\n                       0, 0, 0)),\n            asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedDefMode(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 5, 5, 0, 2, 1, 1)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedIndefMode(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedDefModeChunked(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 5, 5, 0, 2, 1, 1)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedIndefModeChunked(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)),\n            asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1,\n                       0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs(\n                (48, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1)),\n            asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((48, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0,\n                       0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n\nclass SequenceDecoderWithUntaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any(), openType=openType)\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 6, 2, 1, 1, 2, 1, 12)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 16, 2, 1, 2, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1] == univ.OctetString('quick brown')\n\n    def testDecodeOpenTypesUnknownType(self):\n        try:\n            s, r = decoder.decode(\n                ints2octs((48, 6, 2, 1, 2, 6, 1, 39)), asn1Spec=self.s,\n                decodeOpenTypes=True\n            )\n\n        except error.PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'unknown open type tolerated'\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 6, 2, 1, 3, 6, 1, 39)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='060127')\n\n    def testDontDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 6, 2, 1, 1, 2, 1, 12)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == ints2octs((2, 1, 12))\n\n    def testDontDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 16, 2, 1, 2, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1] == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n\nclass SequenceDecoderWithImplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 131, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 3, 131, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithExplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.Any().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 163, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 3, 163, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithUnaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(componentType=univ.Any()),\n                                    openType=openType)\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 49, 3, 2, 1, 12)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 18, 2, 1, 2, 49, 13, 4, 11, 113, 117, 105, 99,\n                       107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1][0] == univ.OctetString('quick brown')\n\n    def testDecodeOpenTypesUnknownType(self):\n        try:\n            s, r = decoder.decode(\n                ints2octs((48, 6, 2, 1, 2, 6, 1, 39)), asn1Spec=self.s,\n                decodeOpenTypes=True\n            )\n\n        except error.PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'unknown open type tolerated'\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 3, 49, 3, 2, 1, 12)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010c')\n\n    def testDontDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 49, 3, 2, 1, 12)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == ints2octs((2, 1, 12))\n\n    def testDontDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 18, 2, 1, 2, 49, 13, 4, 11, 113, 117, 105, 99,\n                       107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1][0] == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114,\n                                     111, 119, 110))\n\n\nclass SequenceDecoderWithImplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.SetOf(\n                        componentType=univ.Any().subtype(\n                            implicitTag=tag.Tag(\n                                tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 1, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 3, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithExplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.SetOf(\n                        componentType=univ.Any().subtype(\n                            explicitTag=tag.Tag(\n                                tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 1, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs( (48, 10, 2, 1, 3, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010C')\n\n\nclass SetDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null(null)),\n                namedtype.NamedType('first-name', univ.OctetString(null)),\n                namedtype.NamedType('age', univ.Integer(33))\n            )\n        )\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testWithOptionalAndDefaultedDefMode(self):\n        assert decoder.decode(\n            ints2octs((49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeChunked(self):\n        assert decoder.decode(\n            ints2octs(\n                (49, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefModeChunked(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0))\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeSubst(self):\n        assert decoder.decode(\n            ints2octs((49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)), str2octs(''))\n\n    def testWithOptionalAndDefaultedDefModeSubstV04(self):\n        assert decoder.decode(\n            ints2octs((49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)), str2octs(''))\n\n    def testWithOptionalAndDefaultedIndefModeSubst(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)),\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs(\n            (5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)), str2octs(''))\n\n    def testWithOptionalAndDefaultedIndefModeSubstV04(self):\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)),\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs(\n            (5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)), str2octs(''))\n\n    def testTagFormat(self):\n        try:\n            decoder.decode(\n                ints2octs((16, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1))\n            )\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'wrong tagFormat worked out'\n\n\nclass SetDecoderWithSchemaTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null(null)),\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n    def __init(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n\n    def __initWithOptional(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n\n    def __initWithDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def __initWithOptionalAndDefaulted(self):\n        self.s.clear()\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n    def testDefMode(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefMode(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testDefModeChunked(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((49, 2, 5, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testIndefModeChunked(self):\n        self.__init()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalDefMode(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((49, 15, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalIndefMode(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalDefModeChunked(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((49, 21, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalIndefModeChunked(self):\n        self.__initWithOptional()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedDefMode(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 5, 5, 0, 2, 1, 1)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedIndefMode(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedDefModeChunked(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 5, 5, 0, 2, 1, 1)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithDefaultedIndefModeChunked(self):\n        self.__initWithDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeReordered(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 18, 2, 1, 1, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 5, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefMode(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefModeReordered(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 128, 2, 1, 1, 5, 0, 36, 128, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 0, 0,  0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedDefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 24, 5, 0, 36, 17, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 2, 1, 1)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithOptionalAndDefaultedIndefModeChunked(self):\n        self.__initWithOptionalAndDefaulted()\n        assert decoder.decode(\n            ints2octs((49, 128, 5, 0, 36, 128, 4, 4, 113, 117, 105, 99, 4, 4, 107, 32, 98, 114, 4, 3, 111, 119, 110, 0, 0, 2, 1, 1, 0, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n\nclass SequenceOfWithExpTaggedOctetStringDecoder(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.SequenceOf(\n            componentType=univ.OctetString().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))\n        )\n        self.s.setComponentByPosition(0, 'q')\n        self.s2 = univ.SequenceOf()\n\n    def testDefModeSchema(self):\n        s, r = decoder.decode(ints2octs((48, 5, 163, 3, 4, 1, 113)), asn1Spec=self.s)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testIndefModeSchema(self):\n        s, r = decoder.decode(ints2octs((48, 128, 163, 128, 4, 1, 113, 0, 0, 0, 0)), asn1Spec=self.s)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testDefModeNoComponent(self):\n        s, r = decoder.decode(ints2octs((48, 5, 163, 3, 4, 1, 113)), asn1Spec=self.s2)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testIndefModeNoComponent(self):\n        s, r = decoder.decode(ints2octs((48, 128, 163, 128, 4, 1, 113, 0, 0, 0, 0)), asn1Spec=self.s2)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testDefModeSchemaless(self):\n        s, r = decoder.decode(ints2octs((48, 5, 163, 3, 4, 1, 113)))\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testIndefModeSchemaless(self):\n        s, r = decoder.decode(ints2octs((48, 128, 163, 128, 4, 1, 113, 0, 0, 0, 0)))\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n\nclass SequenceWithExpTaggedOctetStringDecoder(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType(\n                    'x', univ.OctetString().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))\n                )\n            )\n        )\n        self.s.setComponentByPosition(0, 'q')\n        self.s2 = univ.Sequence()\n\n    def testDefModeSchema(self):\n        s, r = decoder.decode(ints2octs((48, 5, 163, 3, 4, 1, 113)), asn1Spec=self.s)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testIndefModeSchema(self):\n        s, r = decoder.decode(ints2octs((48, 128, 163, 128, 4, 1, 113, 0, 0, 0, 0)), asn1Spec=self.s)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testDefModeNoComponent(self):\n        s, r = decoder.decode(ints2octs((48, 5, 163, 3, 4, 1, 113)), asn1Spec=self.s2)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testIndefModeNoComponent(self):\n        s, r = decoder.decode(ints2octs((48, 128, 163, 128, 4, 1, 113, 0, 0, 0, 0)), asn1Spec=self.s2)\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testDefModeSchemaless(self):\n        s, r = decoder.decode(ints2octs((48, 5, 163, 3, 4, 1, 113)))\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n    def testIndefModeSchemaless(self):\n        s, r = decoder.decode(ints2octs((48, 128, 163, 128, 4, 1, 113, 0, 0, 0, 0)))\n        assert not r\n        assert s == self.s\n        assert s.tagSet == self.s.tagSet\n\n\nclass ChoiceDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null(null)),\n                namedtype.NamedType('number', univ.Integer(0)),\n                namedtype.NamedType('string', univ.OctetString())\n            )\n        )\n\n    def testBySpec(self):\n        self.s.setComponentByPosition(0, univ.Null(null))\n        assert decoder.decode(\n            ints2octs((5, 0)), asn1Spec=self.s\n        ) == (self.s, null)\n\n    def testWithoutSpec(self):\n        self.s.setComponentByPosition(0, univ.Null(null))\n        assert decoder.decode(ints2octs((5, 0))) == (self.s, null)\n        assert decoder.decode(ints2octs((5, 0))) == (univ.Null(null), null)\n\n    def testUndefLength(self):\n        self.s.setComponentByPosition(2, univ.OctetString('abcdefgh'))\n        assert decoder.decode(ints2octs((36, 128, 4, 3, 97, 98, 99, 4, 3, 100, 101, 102, 4, 2, 103, 104, 0, 0)),\n                              asn1Spec=self.s) == (self.s, null)\n\n    def testExplicitTag(self):\n        s = self.s.subtype(explicitTag=tag.Tag(tag.tagClassContext,\n                                               tag.tagFormatConstructed, 4))\n        s.setComponentByPosition(0, univ.Null(null))\n        assert decoder.decode(ints2octs((164, 2, 5, 0)), asn1Spec=s) == (s, null)\n\n    def testExplicitTagUndefLength(self):\n        s = self.s.subtype(explicitTag=tag.Tag(tag.tagClassContext,\n                                               tag.tagFormatConstructed, 4))\n        s.setComponentByPosition(0, univ.Null(null))\n        assert decoder.decode(ints2octs((164, 128, 5, 0, 0, 0)), asn1Spec=s) == (s, null)\n\n\nclass AnyDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Any()\n\n    def testByUntagged(self):\n        assert decoder.decode(\n            ints2octs((4, 3, 102, 111, 120)), asn1Spec=self.s\n        ) == (univ.Any('\\004\\003fox'), null)\n\n    def testTaggedEx(self):\n        s = univ.Any('\\004\\003fox').subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4))\n        assert decoder.decode(ints2octs((164, 5, 4, 3, 102, 111, 120)), asn1Spec=s) == (s, null)\n\n    def testTaggedIm(self):\n        s = univ.Any('\\004\\003fox').subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4))\n        assert decoder.decode(ints2octs((132, 5, 4, 3, 102, 111, 120)), asn1Spec=s) == (s, null)\n\n    def testByUntaggedIndefMode(self):\n        assert decoder.decode(\n            ints2octs((4, 3, 102, 111, 120)), asn1Spec=self.s\n        ) == (univ.Any('\\004\\003fox'), null)\n\n    def testTaggedExIndefMode(self):\n        s = univ.Any('\\004\\003fox').subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4))\n        assert decoder.decode(ints2octs((164, 128, 4, 3, 102, 111, 120, 0, 0)), asn1Spec=s) == (s, null)\n\n    def testTaggedImIndefMode(self):\n        s = univ.Any('\\004\\003fox').subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4))\n        assert decoder.decode(ints2octs((164, 128, 4, 3, 102, 111, 120, 0, 0)), asn1Spec=s) == (s, null)\n\n    def testByUntaggedSubst(self):\n        assert decoder.decode(\n            ints2octs((4, 3, 102, 111, 120)),\n            asn1Spec=self.s,\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((4, 3, 102, 111, 120)), str2octs(''))\n\n    def testByUntaggedSubstV04(self):\n        assert decoder.decode(\n            ints2octs((4, 3, 102, 111, 120)),\n            asn1Spec=self.s,\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((4, 3, 102, 111, 120)), str2octs(''))\n\n    def testTaggedExSubst(self):\n        assert decoder.decode(\n            ints2octs((164, 5, 4, 3, 102, 111, 120)),\n            asn1Spec=self.s,\n            substrateFun=lambda a, b, c, d: streaming.readFromStream(b, c)\n        ) == (ints2octs((164, 5, 4, 3, 102, 111, 120)), str2octs(''))\n\n    def testTaggedExSubstV04(self):\n        assert decoder.decode(\n            ints2octs((164, 5, 4, 3, 102, 111, 120)),\n            asn1Spec=self.s,\n            substrateFun=lambda a, b, c: (b, b[c:])\n        ) == (ints2octs((164, 5, 4, 3, 102, 111, 120)), str2octs(''))\n\n\nclass EndOfOctetsTestCase(BaseTestCase):\n    def testUnexpectedEoo(self):\n        try:\n            decoder.decode(ints2octs((0, 0)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'end-of-contents octets accepted at top level'\n\n    def testExpectedEoo(self):\n        result, remainder = decoder.decode(ints2octs((0, 0)), allowEoo=True)\n        assert eoo.endOfOctets.isSameTypeWith(result) and result == eoo.endOfOctets and result is eoo.endOfOctets\n        assert remainder == null\n\n    def testDefiniteNoEoo(self):\n        try:\n            decoder.decode(ints2octs((0x23, 0x02, 0x00, 0x00)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'end-of-contents octets accepted inside definite-length encoding'\n\n    def testIndefiniteEoo(self):\n        result, remainder = decoder.decode(ints2octs((0x23, 0x80, 0x00, 0x00)))\n        assert result == () and remainder == null, 'incorrect decoding of indefinite length end-of-octets'\n\n    def testNoLongFormEoo(self):\n        try:\n            decoder.decode(ints2octs((0x23, 0x80, 0x00, 0x81, 0x00)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'end-of-contents octets accepted with invalid long-form length'\n\n    def testNoConstructedEoo(self):\n        try:\n            decoder.decode(ints2octs((0x23, 0x80, 0x20, 0x00)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'end-of-contents octets accepted with invalid constructed encoding'\n\n    def testNoEooData(self):\n        try:\n            decoder.decode(ints2octs((0x23, 0x80, 0x00, 0x01, 0x00)))\n        except error.PyAsn1Error:\n            pass\n        else:\n            assert 0, 'end-of-contents octets accepted with unexpected data'\n\n\nclass NonStringDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null(null)),\n                namedtype.NamedType('first-name', univ.OctetString(null)),\n                namedtype.NamedType('age', univ.Integer(33))\n            )\n        )\n        self.s.setComponentByPosition(0, univ.Null(null))\n        self.s.setComponentByPosition(1, univ.OctetString('quick brown'))\n        self.s.setComponentByPosition(2, univ.Integer(1))\n\n        self.substrate = ints2octs([48, 18, 5, 0, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 2, 1, 1])\n\n    def testOctetString(self):\n        s = list(decoder.StreamingDecoder(\n            univ.OctetString(self.substrate), asn1Spec=self.s))\n        assert [self.s] == s\n\n    def testAny(self):\n        s = list(decoder.StreamingDecoder(\n            univ.Any(self.substrate), asn1Spec=self.s))\n        assert [self.s] == s\n\n\nclass ErrorOnDecodingTestCase(BaseTestCase):\n\n    def testErrorCondition(self):\n        decode = decoder.SingleItemDecoder(\n            tagMap=decoder.TAG_MAP, typeMap=decoder.TYPE_MAP)\n        substrate = ints2octs((00, 1, 2))\n        stream = streaming.asSeekableStream(substrate)\n\n        try:\n            asn1Object = next(decode(stream))\n\n        except error.PyAsn1Error:\n            exc = sys.exc_info()[1]\n            assert isinstance(exc, error.PyAsn1Error), (\n                'Unexpected exception raised %r' % (exc,))\n\n        else:\n            assert False, 'Unexpected decoder result %r' % (asn1Object,)\n\n    def testRawDump(self):\n        substrate = ints2octs((31, 8, 2, 1, 1, 131, 3, 2, 1, 12))\n        stream = streaming.asSeekableStream(substrate)\n\n        class SingleItemEncoder(decoder.SingleItemDecoder):\n            defaultErrorState = decoder.stDumpRawValue\n\n        class StreamingDecoder(decoder.StreamingDecoder):\n            SINGLE_ITEM_DECODER = SingleItemEncoder\n\n        class OneShotDecoder(decoder.Decoder):\n            STREAMING_DECODER = StreamingDecoder\n\n        d = OneShotDecoder()\n\n        asn1Object, rest = d(stream)\n\n        assert isinstance(asn1Object, univ.Any), (\n            'Unexpected raw dump type %r' % (asn1Object,))\n        assert asn1Object.asNumbers() == (31, 8, 2, 1, 1), (\n            'Unexpected raw dump value %r' % (asn1Object,))\n        assert rest == ints2octs((131, 3, 2, 1, 12)), (\n            'Unexpected rest of substrate after raw dump %r' % rest)\n\n\n@unittest.skipIf(sys.version_info < (3,), \"Unsupported on Python 2\")\nclass BinaryFileTestCase(BaseTestCase):\n    \"\"\"Assure that decode works on open binary files.\"\"\"\n    def testOneObject(self):\n        _, path = tempfile.mkstemp()\n        try:\n            with open(path, \"wb\") as out:\n                out.write(ints2octs((2, 1, 12)))\n\n            with open(path, \"rb\") as source:\n                values = list(decoder.StreamingDecoder(source))\n\n            assert values == [12]\n        finally:\n            os.remove(path)\n\n    def testMoreObjects(self):\n        _, path = tempfile.mkstemp()\n        try:\n            with open(path, \"wb\") as out:\n                out.write(ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)))\n\n            with open(path, \"rb\") as source:\n                values = list(decoder.StreamingDecoder(source))\n\n            assert values == [12, (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1)]\n\n        finally:\n            os.remove(path)\n\n    def testInvalidFileContent(self):\n        _, path = tempfile.mkstemp()\n        try:\n            with open(path, \"wb\") as out:\n                out.write(ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0, 7)))\n\n            with open(path, \"rb\") as source:\n                list(decoder.StreamingDecoder(source))\n\n        except error.EndOfStreamError:\n            pass\n\n        finally:\n            os.remove(path)\n\n\nclass BytesIOTestCase(BaseTestCase):\n    def testRead(self):\n        source = ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0))\n        stream = io.BytesIO(source)\n        values = list(decoder.StreamingDecoder(stream))\n        assert values == [12, (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1)]\n\n\nclass UnicodeTestCase(BaseTestCase):\n    def testFail(self):\n        # This ensures that str objects in Python 3.7 cannot be parsed.\n        source = ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)).decode(\"latin-1\")\n        try:\n            next(decoder.StreamingDecoder(source))\n\n        except error.UnsupportedSubstrateError:\n            pass\n\n        else:\n            assert False, 'Tolerated parsing broken unicode strings'\n\n\nclass RestartableDecoderTestCase(BaseTestCase):\n\n    class NonBlockingStream(io.BytesIO):\n        block = False\n\n        def read(self, size=-1):\n            self.block = not self.block\n            if self.block:\n                return  # this is what non-blocking streams sometimes do\n\n            return io.BytesIO.read(self, size)\n\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.SequenceOf(componentType=univ.OctetString())\n        self.s.setComponentByPosition(0, univ.OctetString('quick brown'))\n        source = ints2octs(\n            (48, 26,\n             4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110,\n             4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n        self.stream = self.NonBlockingStream(source)\n\n    def testPartialReadingFromNonBlockingStream(self):\n        iterator = iter(decoder.StreamingDecoder(self.stream, asn1Spec=self.s))\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' not in res.context\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' not in res.context\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' in res.context\n        assert isinstance(res.context['asn1Object'], univ.SequenceOf)\n        assert res.context['asn1Object'].isValue\n        assert len(res.context['asn1Object']) == 0\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' in res.context\n        assert isinstance(res.context['asn1Object'], univ.SequenceOf)\n        assert res.context['asn1Object'].isValue\n        assert len(res.context['asn1Object']) == 0\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' in res.context\n        assert isinstance(res.context['asn1Object'], univ.SequenceOf)\n        assert res.context['asn1Object'].isValue\n        assert len(res.context['asn1Object']) == 0\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' in res.context\n        assert isinstance(res.context['asn1Object'], univ.SequenceOf)\n        assert res.context['asn1Object'].isValue\n        assert len(res.context['asn1Object']) == 1\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' in res.context\n        assert isinstance(res.context['asn1Object'], univ.SequenceOf)\n        assert res.context['asn1Object'].isValue\n        assert len(res.context['asn1Object']) == 1\n\n        res = next(iterator)\n\n        assert isinstance(res, error.SubstrateUnderrunError)\n        assert 'asn1Object' in res.context\n        assert isinstance(res.context['asn1Object'], univ.SequenceOf)\n        assert res.context['asn1Object'].isValue\n        assert len(res.context['asn1Object']) == 1\n\n        res = next(iterator)\n\n        assert isinstance(res, univ.SequenceOf)\n        assert res.isValue\n        assert len(res) == 2\n\n        try:\n            next(iterator)\n\n        except StopIteration:\n            pass\n\n        else:\n            assert False, 'End of stream not raised'\n\n\nclass CompressedFilesTestCase(BaseTestCase):\n    def testGzip(self):\n        _, path = tempfile.mkstemp(suffix=\".gz\")\n        try:\n            with gzip.open(path, \"wb\") as out:\n                out.write(ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)))\n\n            with gzip.open(path, \"rb\") as source:\n                values = list(decoder.StreamingDecoder(source))\n\n            assert values == [12, (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1)]\n\n        finally:\n            os.remove(path)\n\n    def testZipfile(self):\n        # It is a seekable stream.\n        _, path = tempfile.mkstemp(suffix=\".zip\")\n        try:\n            with zipfile.ZipFile(path, \"w\") as myzip:\n                myzip.writestr(\"data\", ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)))\n\n            with zipfile.ZipFile(path, \"r\") as myzip:\n                with myzip.open(\"data\", \"r\") as source:\n                    values = list(decoder.StreamingDecoder(source))\n                    assert values == [12, (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1)]\n        finally:\n            os.remove(path)\n\n    def testZipfileMany(self):\n        _, path = tempfile.mkstemp(suffix=\".zip\")\n        try:\n            with zipfile.ZipFile(path, \"w\") as myzip:\n                #for i in range(100):\n                myzip.writestr(\"data\", ints2octs((2, 1, 12, 35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0)) * 1000)\n\n            with zipfile.ZipFile(path, \"r\") as myzip:\n                with myzip.open(\"data\", \"r\") as source:\n                    values = list(decoder.StreamingDecoder(source))\n                    assert values == [12, (1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1)] * 1000\n        finally:\n            os.remove(path)\n\n\nclass NonStreamingCompatibilityTestCase(BaseTestCase):\n    def setUp(self):\n        from pyasn1 import debug\n        BaseTestCase.setUp(self)\n        debug.setLogger(None)  # undo logger setup from BaseTestCase to work around unrelated issue\n\n    def testPartialDecodeWithCustomSubstrateFun(self):\n        snmp_req_substrate = ints2octs((\n            0x30, 0x22, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa0, 0x15, 0x02, 0x04, 0x69,\n            0x30, 0xdb, 0xeb, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x07, 0x30, 0x05, 0x06, 0x01, 0x01, 0x05, 0x00))\n        seq, next_substrate = decoder.decode(\n            snmp_req_substrate, asn1Spec=univ.Sequence(),\n            recursiveFlag=False, substrateFun=lambda a, b, c: (a, b[:c])\n        )\n        assert seq.isSameTypeWith(univ.Sequence)\n        assert next_substrate == snmp_req_substrate[2:]\n        version, next_substrate = decoder.decode(\n            next_substrate, asn1Spec=univ.Integer(), recursiveFlag=False,\n            substrateFun=lambda a, b, c: (a, b[:c])\n        )\n        assert version == 1\n\n    def testPartialDecodeWithDefaultSubstrateFun(self):\n        substrate = ints2octs((\n            0x04, 0x0e, 0x30, 0x0c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x3c, 0x03, 0x02\n        ))\n        result, rest = decoder.decode(substrate, recursiveFlag=False)\n        assert result.isSameTypeWith(univ.OctetString)\n        assert rest == substrate[2:]\n\n    def testPropagateUserException(self):\n        substrate = io.BytesIO(ints2octs((0x04, 0x00)))\n\n        def userSubstrateFun(_asn1Object, _substrate, _length, _options):\n            raise TypeError(\"error inside user function\")\n\n        try:\n            decoder.decode(substrate, asn1Spec=univ.OctetString, substrateFun=userSubstrateFun)\n        except TypeError as exc:\n            assert str(exc) == \"error inside user function\"\n        else:\n            raise AssertionError(\"decode() must not hide TypeError from inside user provided callback\")\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/ber/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.codec.ber.test_encoder.suite',\n     'tests.codec.ber.test_decoder.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/ber/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/codec/der/test_encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.type import univ\nfrom pyasn1.codec.der import encoder\nfrom pyasn1.compat.octets import ints2octs\n\n\nclass OctetStringEncoderTestCase(BaseTestCase):\n    def testDefModeShort(self):\n        assert encoder.encode(\n            univ.OctetString('Quick brown fox')\n        ) == ints2octs((4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120))\n\n    def testDefModeLong(self):\n        assert encoder.encode(\n            univ.OctetString('Q' * 10000)\n        ) == ints2octs((4, 130, 39, 16) + (81,) * 10000)\n\n\nclass BitStringEncoderTestCase(BaseTestCase):\n    def testDefModeShort(self):\n        assert encoder.encode(\n            univ.BitString((1,))\n        ) == ints2octs((3, 2, 7, 128))\n\n    def testDefModeLong(self):\n        assert encoder.encode(\n            univ.BitString((1,) * 80000)\n        ) == ints2octs((3, 130, 39, 17, 0) + (255,) * 10000)\n\n\nclass SetOfEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.SetOf(componentType=univ.OctetString())\n\n    def testDefMode1(self):\n        self.s.clear()\n        self.s.append('a')\n        self.s.append('ab')\n\n        assert encoder.encode(self.s) == ints2octs((49, 7, 4, 1, 97, 4, 2, 97, 98))\n\n    def testDefMode2(self):\n        self.s.clear()\n        self.s.append('ab')\n        self.s.append('a')\n\n        assert encoder.encode(self.s) == ints2octs((49, 7, 4, 1, 97, 4, 2, 97, 98))\n\n    def testDefMode3(self):\n        self.s.clear()\n        self.s.append('b')\n        self.s.append('a')\n\n        assert encoder.encode(self.s) == ints2octs((49, 6, 4, 1, 97, 4, 1, 98))\n\n    def testDefMode4(self):\n        self.s.clear()\n        self.s.append('a')\n        self.s.append('b')\n\n        assert encoder.encode(self.s) == ints2octs((49, 6, 4, 1, 97, 4, 1, 98))\n\n\nclass SetWithAlternatingChoiceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        c = univ.Choice(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('name', univ.OctetString()),\n            namedtype.NamedType('amount', univ.Boolean()))\n        )\n\n        self.s = univ.Set(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('value', univ.Integer(5)),\n            namedtype.NamedType('status', c))\n        )\n\n    def testComponentsOrdering1(self):\n        self.s.setComponentByName('status')\n        self.s.getComponentByName('status').setComponentByPosition(0, 'A')\n        assert encoder.encode(self.s) == ints2octs((49, 6, 2, 1, 5, 4, 1, 65))\n\n    def testComponentsOrdering2(self):\n        self.s.setComponentByName('status')\n        self.s.getComponentByName('status').setComponentByPosition(1, True)\n        assert encoder.encode(self.s) == ints2octs((49, 6, 1, 1, 255, 2, 1, 5))\n\n\nclass SetWithTaggedChoiceEncoderTestCase(BaseTestCase):\n\n    def testWithUntaggedChoice(self):\n\n        c = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('premium', univ.Boolean())\n            )\n        )\n\n        s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('customer', c)\n            )\n        )\n\n        s.setComponentByName('name', 'A')\n        s.getComponentByName('customer').setComponentByName('premium', True)\n\n        assert encoder.encode(s) == ints2octs((49, 6, 1, 1, 255, 4, 1, 65))\n\n    def testWithTaggedChoice(self):\n\n        c = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('premium', univ.Boolean())\n            )\n        ).subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 7))\n\n        s = univ.Set(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('name', univ.OctetString()),\n                namedtype.NamedType('customer', c)\n            )\n        )\n\n        s.setComponentByName('name', 'A')\n        s.getComponentByName('customer').setComponentByName('premium', True)\n\n        assert encoder.encode(s) == ints2octs((49, 8, 4, 1, 65, 167, 3, 1, 1, 255))\n\n\nclass SequenceEncoderWithUntaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any(), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 5, 2, 1, 1, 49, 50)\n        )\n\n    def testEncodeOpenTypeChoiceTwo(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.OctetString('quick brown')\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 14, 2, 1, 2, 113, 117, 105, 99, 107, 32,\n             98, 114, 111, 119, 110)\n        )\n\n    def testEncodeOpenTypeUnknownId(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.ObjectIdentifier('1.3.6')\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n    def testEncodeOpenTypeIncompatibleType(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1] = univ.ObjectIdentifier('1.3.6')\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n\nclass SequenceEncoderWithImplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 9, 2, 1, 1, 131, 4, 131, 2, 49, 50)\n        )\n\n\nclass SequenceEncoderWithExplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1] = univ.Integer(12)\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 9, 2, 1, 1, 163, 4, 163, 2, 49, 50)\n        )\n\n\nclass SequenceEncoderWithUntaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any()), openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 7, 2, 1, 1, 49, 2, 49, 50)\n        )\n\n    def testEncodeOpenTypeChoiceTwo(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.OctetString('quick brown'))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 16, 2, 1, 2, 49, 11, 113, 117, 105, 99, 107, 32, 98, 114,\n             111, 119, 110)\n        )\n\n    def testEncodeOpenTypeUnknownId(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.ObjectIdentifier('1.3.6'))\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n    def testEncodeOpenTypeIncompatibleType(self):\n        self.s.clear()\n\n        self.s[0] = 2\n        self.s[1].append(univ.ObjectIdentifier('1.3.6'))\n\n        try:\n            encoder.encode(self.s, asn1Spec=self.s)\n\n        except PyAsn1Error:\n            assert False, 'incompatible open type tolerated'\n\n\nclass SequenceEncoderWithImplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any().subtype(\n                        implicitTag=tag.Tag(\n                            tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 11, 2, 1, 1, 49, 6, 131, 4, 131, 2, 49, 50)\n        )\n\n\nclass SequenceEncoderWithExplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(\n                    componentType=univ.Any().subtype(\n                        explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType)\n            )\n        )\n\n    def testEncodeOpenTypeChoiceOne(self):\n        self.s.clear()\n\n        self.s[0] = 1\n        self.s[1].append(univ.Integer(12))\n\n        assert encoder.encode(self.s, asn1Spec=self.s) == ints2octs(\n            (48, 11, 2, 1, 1, 49, 6, 163, 4, 163, 2, 49, 50)\n        )\n\n\nclass NestedOptionalSequenceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        inner = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n        outerWithOptional = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('inner', inner),\n            )\n        )\n\n        outerWithDefault = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.DefaultedNamedType('inner', inner),\n            )\n        )\n\n        self.s1 = outerWithOptional\n        self.s2 = outerWithDefault\n\n    def __initOptionalWithDefaultAndOptional(self):\n        self.s1.clear()\n        self.s1[0][0] = 'test'\n        self.s1[0][1] = 123\n        return self.s1\n\n    def __initOptionalWithDefault(self):\n        self.s1.clear()\n        self.s1[0][1] = 123\n        return self.s1\n\n    def __initOptionalWithOptional(self):\n        self.s1.clear()\n        self.s1[0][0] = 'test'\n        return self.s1\n\n    def __initOptional(self):\n        self.s1.clear()\n        return self.s1\n\n    def __initDefaultWithDefaultAndOptional(self):\n        self.s2.clear()\n        self.s2[0][0] = 'test'\n        self.s2[0][1] = 123\n        return self.s2\n\n    def __initDefaultWithDefault(self):\n        self.s2.clear()\n        self.s2[0][0] = 'test'\n        return self.s2\n\n    def __initDefaultWithOptional(self):\n        self.s2.clear()\n        self.s2[0][1] = 123\n        return self.s2\n\n    def testDefModeOptionalWithDefaultAndOptional(self):\n        s = self.__initOptionalWithDefaultAndOptional()\n        assert encoder.encode(s) == ints2octs((48, 11, 48, 9, 4, 4, 116, 101, 115, 116, 2, 1, 123))\n\n    def testDefModeOptionalWithDefault(self):\n        s = self.__initOptionalWithDefault()\n        assert encoder.encode(s) == ints2octs((48, 5, 48, 3, 2, 1, 123))\n\n    def testDefModeOptionalWithOptional(self):\n        s = self.__initOptionalWithOptional()\n        assert encoder.encode(s) == ints2octs((48, 8, 48, 6, 4, 4, 116, 101, 115, 116))\n\n    def testDefModeOptional(self):\n        s = self.__initOptional()\n        assert encoder.encode(s) == ints2octs((48, 0))\n\n    def testDefModeDefaultWithDefaultAndOptional(self):\n        s = self.__initDefaultWithDefaultAndOptional()\n        assert encoder.encode(s) == ints2octs((48, 11, 48, 9, 4, 4, 116, 101, 115, 116, 2, 1, 123))\n\n    def testDefModeDefaultWithDefault(self):\n        s = self.__initDefaultWithDefault()\n        assert encoder.encode(s) == ints2octs((48, 8, 48, 6, 4, 4, 116, 101, 115, 116))\n\n    def testDefModeDefaultWithOptional(self):\n        s = self.__initDefaultWithOptional()\n        assert encoder.encode(s) == ints2octs((48, 5, 48, 3, 2, 1, 123))\n\n\nclass NestedOptionalChoiceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        layer3 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('first-name', univ.OctetString()),\n                namedtype.DefaultedNamedType('age', univ.Integer(33)),\n            )\n        )\n\n        layer2 = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('inner', layer3),\n                namedtype.NamedType('first-name', univ.OctetString())\n            )\n        )\n\n        layer1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('inner', layer2),\n            )\n        )\n\n        self.s = layer1\n\n    def __initOptionalWithDefaultAndOptional(self):\n        self.s.clear()\n        self.s[0][0][0] = 'test'\n        self.s[0][0][1] = 123\n        return self.s\n\n    def __initOptionalWithDefault(self):\n        self.s.clear()\n        self.s[0][0][1] = 123\n        return self.s\n\n    def __initOptionalWithOptional(self):\n        self.s.clear()\n        self.s[0][0][0] = 'test'\n        return self.s\n\n    def __initOptional(self):\n        self.s.clear()\n        return self.s\n\n    def testDefModeOptionalWithDefaultAndOptional(self):\n        s = self.__initOptionalWithDefaultAndOptional()\n        assert encoder.encode(s) == ints2octs((48, 11, 48, 9, 4, 4, 116, 101, 115, 116, 2, 1, 123))\n\n    def testDefModeOptionalWithDefault(self):\n        s = self.__initOptionalWithDefault()\n        assert encoder.encode(s) == ints2octs((48, 5, 48, 3, 2, 1, 123))\n\n    def testDefModeOptionalWithOptional(self):\n        s = self.__initOptionalWithOptional()\n        assert encoder.encode(s) == ints2octs((48, 8, 48, 6, 4, 4, 116, 101, 115, 116))\n\n    def testDefModeOptional(self):\n        s = self.__initOptional()\n        assert encoder.encode(s) == ints2octs((48, 0))\n\n\nclass NestedOptionalSequenceOfEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        layer2 = univ.SequenceOf(\n            componentType=univ.OctetString()\n        )\n\n        layer1 = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('inner', layer2),\n            )\n        )\n\n        self.s = layer1\n\n    def __initOptionalWithValue(self):\n        self.s.clear()\n        self.s[0][0] = 'test'\n        return self.s\n\n    def __initOptional(self):\n        self.s.clear()\n        return self.s\n\n    def testDefModeOptionalWithValue(self):\n        s = self.__initOptionalWithValue()\n        assert encoder.encode(s) == ints2octs((48, 8, 48, 6, 4, 4, 116, 101, 115, 116))\n\n    def testDefModeOptional(self):\n        s = self.__initOptional()\n        assert encoder.encode(s) == ints2octs((48, 0))\n\n\nclass EmptyInnerFieldOfSequenceEncoderTestCase(BaseTestCase):\n\n    def testInitializedOptionalNullIsEncoded(self):\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('null', univ.Null())\n            )\n        )\n\n        self.s.clear()\n        self.s[0] = ''\n        assert encoder.encode(self.s) == ints2octs((48, 2, 5, 0))\n\n    def testUninitializedOptionalNullIsNotEncoded(self):\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('null', univ.Null())\n            )\n        )\n\n        self.s.clear()\n        assert encoder.encode(self.s) == ints2octs((48, 0))\n\n    def testInitializedDefaultNullIsNotEncoded(self):\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.DefaultedNamedType('null', univ.Null(''))\n            )\n        )\n\n        self.s.clear()\n        self.s[0] = ''\n        assert encoder.encode(self.s) == ints2octs((48, 0))\n\n    def testInitializedOptionalOctetStringIsEncoded(self):\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('str', univ.OctetString())\n            )\n        )\n\n        self.s.clear()\n        self.s[0] = ''\n        assert encoder.encode(self.s) == ints2octs((48, 2, 4, 0))\n\n    def testUninitializedOptionalOctetStringIsNotEncoded(self):\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.OptionalNamedType('str', univ.OctetString())\n            )\n        )\n\n        self.s.clear()\n        assert encoder.encode(self.s) == ints2octs((48, 0))\n\n    def testInitializedDefaultOctetStringIsNotEncoded(self):\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.DefaultedNamedType('str', univ.OctetString(''))\n            )\n        )\n\n        self.s.clear()\n        self.s[0] = ''\n        assert encoder.encode(self.s) == ints2octs((48, 0))\n\n\nclass ClassConstructorTestCase(BaseTestCase):\n    def testKeywords(self):\n        tagmap = {\"tagmap\": True}\n        typemap = {\"typemap\": True}\n\n        sie = encoder.Encoder()._singleItemEncoder\n        self.assertIs(sie._tagMap, encoder.TAG_MAP)\n        self.assertIs(sie._typeMap, encoder.TYPE_MAP)\n\n        sie = encoder.Encoder(\n            tagMap=tagmap, typeMap=typemap\n        )._singleItemEncoder\n        self.assertIs(sie._tagMap, tagmap)\n        self.assertIs(sie._typeMap, typemap)\n\n        sie = encoder.Encoder(tagmap, typemap)._singleItemEncoder\n        self.assertIs(sie._tagMap, tagmap)\n        self.assertIs(sie._typeMap, typemap)\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/der/test_decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import tag\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import opentype\nfrom pyasn1.type import univ\nfrom pyasn1.codec.der import decoder\nfrom pyasn1.compat.octets import ints2octs, null\nfrom pyasn1.error import PyAsn1Error\n\n\nclass BitStringDecoderTestCase(BaseTestCase):\n    def testShortMode(self):\n        assert decoder.decode(\n            ints2octs((3, 127, 6) + (170,) * 125 + (128,))\n        ) == (((1, 0) * 501), null)\n\n    def testIndefMode(self):\n        try:\n            decoder.decode(\n                ints2octs((35, 128, 3, 2, 0, 169, 3, 2, 1, 138, 0, 0))\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'indefinite length encoding tolerated'\n\n    def testDefModeChunked(self):\n        try:\n            assert decoder.decode(\n                ints2octs((35, 8, 3, 2, 0, 169, 3, 2, 1, 138))\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'chunked encoding tolerated'\n\n\nclass OctetStringDecoderTestCase(BaseTestCase):\n    def testShortMode(self):\n        assert decoder.decode(\n            '\\004\\017Quick brown fox'.encode()\n        ) == ('Quick brown fox'.encode(), ''.encode())\n\n    def testIndefMode(self):\n        try:\n            decoder.decode(\n                ints2octs((36, 128, 4, 15, 81, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 0, 0))\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'indefinite length encoding tolerated'\n\n    def testChunkedMode(self):\n        try:\n            decoder.decode(\n                ints2octs((36, 23, 4, 2, 81, 117, 4, 2, 105, 99, 4, 2, 107, 32, 4, 2, 98, 114, 4, 2, 111, 119, 4, 1, 110))\n            )\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'chunked encoding tolerated'\n\n\nclass SequenceDecoderWithUntaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.Any(), openType=openType)\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 6, 2, 1, 1, 2, 1, 12)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 16, 2, 1, 2, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1] == univ.OctetString('quick brown')\n\n    def testDecodeOpenTypesUnknownType(self):\n        try:\n            s, r = decoder.decode(\n                ints2octs((48, 6, 2, 1, 2, 6, 1, 39)), asn1Spec=self.s,\n                decodeOpenTypes=True\n            )\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'unknown open type tolerated'\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 6, 2, 1, 3, 6, 1, 39)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='060127')\n\n    def testDontDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 6, 2, 1, 1, 2, 1, 12)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == ints2octs((2, 1, 12))\n\n    def testDontDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 16, 2, 1, 2, 4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1] == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110))\n\n\nclass SequenceDecoderWithImplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.Any().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 131, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 3, 131, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithExplicitlyTaggedOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.Any().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)), openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 163, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 3, 163, 3, 2, 1, 12)), asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithUnaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType('blob', univ.SetOf(componentType=univ.Any()),\n                                    openType=openType)\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 49, 3, 2, 1, 12)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 18, 2, 1, 2, 49, 13, 4, 11, 113, 117, 105, 99,\n                       107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1][0] == univ.OctetString('quick brown')\n\n    def testDecodeOpenTypesUnknownType(self):\n        try:\n            s, r = decoder.decode(\n                ints2octs((48, 6, 2, 1, 2, 6, 1, 39)), asn1Spec=self.s,\n                decodeOpenTypes=True\n            )\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert False, 'unknown open type tolerated'\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 3, 49, 3, 2, 1, 12)), asn1Spec=self.s,\n            decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010c')\n\n    def testDontDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 8, 2, 1, 1, 49, 3, 2, 1, 12)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == ints2octs((2, 1, 12))\n\n    def testDontDecodeOpenTypesChoiceTwo(self):\n        s, r = decoder.decode(\n            ints2octs((48, 18, 2, 1, 2, 49, 13, 4, 11, 113, 117, 105, 99,\n                       107, 32, 98, 114, 111, 119, 110)), asn1Spec=self.s\n        )\n        assert not r\n        assert s[0] == 2\n        assert s[1][0] == ints2octs((4, 11, 113, 117, 105, 99, 107, 32, 98, 114,\n                                     111, 119, 110))\n\n\nclass SequenceDecoderWithImplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.SetOf(\n                        componentType=univ.Any().subtype(\n                            implicitTag=tag.Tag(\n                                tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 1, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 3, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010C')\n\n\nclass SequenceDecoderWithExplicitlyTaggedSetOfOpenTypesTestCase(BaseTestCase):\n    def setUp(self):\n        openType = opentype.OpenType(\n            'id',\n            {1: univ.Integer(),\n             2: univ.OctetString()}\n        )\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('id', univ.Integer()),\n                namedtype.NamedType(\n                    'blob', univ.SetOf(\n                        componentType=univ.Any().subtype(\n                            explicitTag=tag.Tag(\n                                tag.tagClassContext, tag.tagFormatSimple, 3))),\n                    openType=openType\n                )\n            )\n        )\n\n    def testDecodeOpenTypesChoiceOne(self):\n        s, r = decoder.decode(\n            ints2octs((48, 10, 2, 1, 1, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 1\n        assert s[1][0] == 12\n\n    def testDecodeOpenTypesUnknownId(self):\n        s, r = decoder.decode(\n            ints2octs( (48, 10, 2, 1, 3, 49, 5, 131, 3, 2, 1, 12)),\n            asn1Spec=self.s, decodeOpenTypes=True\n        )\n        assert not r\n        assert s[0] == 3\n        assert s[1][0] == univ.OctetString(hexValue='02010C')\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/der/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.codec.der.test_encoder.suite',\n     'tests.codec.der.test_decoder.suite']\n)\n\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/der/__init__.py": "# This file is necessary to make this directory a package.\n", "tests/codec/native/test_encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import univ\nfrom pyasn1.codec.native import encoder\nfrom pyasn1.compat.octets import str2octs\nfrom pyasn1.error import PyAsn1Error\n\n\nclass BadAsn1SpecTestCase(BaseTestCase):\n    def testBadValueType(self):\n        try:\n            encoder.encode('not an Asn1Item')\n\n        except PyAsn1Error:\n            pass\n\n        else:\n            assert 0, 'Invalid value type accepted'\n\n\nclass IntegerEncoderTestCase(BaseTestCase):\n    def testPosInt(self):\n        assert encoder.encode(univ.Integer(12)) == 12\n\n    def testNegInt(self):\n        assert encoder.encode(univ.Integer(-12)) == -12\n\n\nclass BooleanEncoderTestCase(BaseTestCase):\n    def testTrue(self):\n        assert encoder.encode(univ.Boolean(1)) is True\n\n    def testFalse(self):\n        assert encoder.encode(univ.Boolean(0)) is False\n\n\nclass BitStringEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.b = univ.BitString((1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1))\n\n    def testValue(self):\n        assert encoder.encode(self.b) == '101010011000101'\n\n\nclass OctetStringEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.o = univ.OctetString('Quick brown fox')\n\n    def testValue(self):\n        assert encoder.encode(self.o) == str2octs('Quick brown fox')\n\n\nclass NullEncoderTestCase(BaseTestCase):\n    def testNull(self):\n        assert encoder.encode(univ.Null('')) is None\n\n\nclass ObjectIdentifierEncoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert encoder.encode(univ.ObjectIdentifier((1, 3, 6, 0, 12345))) == '1.3.6.0.12345'\n\n\nclass RealEncoderTestCase(BaseTestCase):\n    def testChar(self):\n        assert encoder.encode(univ.Real((123, 10, 11))) == 1.23e+13\n\n    def testPlusInf(self):\n        assert encoder.encode(univ.Real('inf')) == float('inf')\n\n    def testMinusInf(self):\n        assert encoder.encode(univ.Real('-inf')) == float('-inf')\n\n\nclass SequenceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.Sequence(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('place-holder', univ.Null('')),\n            namedtype.OptionalNamedType('first-name', univ.OctetString('')),\n            namedtype.DefaultedNamedType('age', univ.Integer(33)),\n        ))\n\n    def testSimple(self):\n        s = self.s.clone()\n        s[0] = univ.Null('')\n        s[1] = 'abc'\n        s[2] = 123\n        assert encoder.encode(s) == {'place-holder': None, 'first-name': str2octs('abc'), 'age': 123}\n\n\nclass ChoiceEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null('')),\n                namedtype.NamedType('number', univ.Integer(0)),\n                namedtype.NamedType('string', univ.OctetString())\n           )\n        )\n\n    def testEmpty(self):\n        try:\n            encoder.encode(self.s)\n        except PyAsn1Error:\n            pass\n        else:\n            assert False, 'encoded unset choice'\n\n    def testFilled(self):\n        self.s.setComponentByPosition(0, univ.Null(''))\n        assert encoder.encode(self.s) == {'place-holder': None}\n\n\nclass AnyEncoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self.s = univ.Any(encoder.encode(univ.OctetString('fox')))\n\n    def testSimple(self):\n        assert encoder.encode(self.s) == str2octs('fox')\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/native/test_decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport unittest\n\nfrom tests.base import BaseTestCase\n\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import univ\nfrom pyasn1.codec.native import decoder\nfrom pyasn1.error import PyAsn1Error\n\n\nclass BadAsn1SpecTestCase(BaseTestCase):\n    def testBadSpec(self):\n        try:\n            decoder.decode('', asn1Spec='not an Asn1Item')\n        except PyAsn1Error:\n            pass\n        else:\n            assert 0, 'Invalid asn1Spec accepted'\n\n\nclass IntegerDecoderTestCase(BaseTestCase):\n    def testPosInt(self):\n        assert decoder.decode(12, asn1Spec=univ.Integer()) == univ.Integer(12)\n\n    def testNegInt(self):\n        assert decoder.decode(-12, asn1Spec=univ.Integer()) == univ.Integer(-12)\n\n\nclass BooleanDecoderTestCase(BaseTestCase):\n    def testTrue(self):\n        assert decoder.decode(True, asn1Spec=univ.Boolean()) == univ.Boolean(True)\n\n    def testTrueNeg(self):\n        assert decoder.decode(False, asn1Spec=univ.Boolean()) == univ.Boolean(False)\n\n\nclass BitStringDecoderTestCase(BaseTestCase):\n    def testSimple(self):\n        assert decoder.decode('11111111', asn1Spec=univ.BitString()) == univ.BitString(hexValue='ff')\n\n\nclass OctetStringDecoderTestCase(BaseTestCase):\n    def testSimple(self):\n        assert decoder.decode('Quick brown fox', asn1Spec=univ.OctetString()) == univ.OctetString('Quick brown fox')\n\n\nclass NullDecoderTestCase(BaseTestCase):\n    def testNull(self):\n        assert decoder.decode(None, asn1Spec=univ.Null()) == univ.Null('')\n\n\nclass ObjectIdentifierDecoderTestCase(BaseTestCase):\n    def testOne(self):\n        assert decoder.decode('1.3.6.11', asn1Spec=univ.ObjectIdentifier()) == univ.ObjectIdentifier('1.3.6.11')\n\n\nclass RealDecoderTestCase(BaseTestCase):\n    def testSimple(self):\n        assert decoder.decode(1.33, asn1Spec=univ.Real()) == univ.Real(1.33)\n\n\nclass SequenceDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.Sequence(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null()),\n                namedtype.NamedType('first-name', univ.OctetString()),\n                namedtype.NamedType('age', univ.Integer(33))\n            )\n        )\n\n    def testSimple(self):\n        s = self.s.clone()\n        s[0] = univ.Null('')\n        s[1] = univ.OctetString('xx')\n        s[2] = univ.Integer(33)\n        assert decoder.decode({'place-holder': None, 'first-name': 'xx', 'age': 33}, asn1Spec=self.s) == s\n\n\nclass ChoiceDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.Choice(\n            componentType=namedtype.NamedTypes(\n                namedtype.NamedType('place-holder', univ.Null()),\n                namedtype.NamedType('first-name', univ.OctetString()),\n                namedtype.NamedType('age', univ.Integer(33))\n            )\n        )\n\n    def testSimple(self):\n        s = self.s.clone()\n        s[1] = univ.OctetString('xx')\n        assert decoder.decode({'first-name': 'xx'}, asn1Spec=self.s) == s\n\n\nclass AnyDecoderTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n\n        self.s = univ.Any()\n\n    def testSimple(self):\n        assert decoder.decode('fox', asn1Spec=univ.Any()) == univ.Any('fox')\n\n\nsuite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/native/__main__.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport unittest\n\nsuite = unittest.TestLoader().loadTestsFromNames(\n    ['tests.codec.native.test_encoder.suite',\n     'tests.codec.native.test_decoder.suite']\n)\n\nif __name__ == '__main__':\n    unittest.TextTestRunner(verbosity=2).run(suite)\n", "tests/codec/native/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/debug.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport logging\nimport sys\n\nfrom pyasn1 import __version__\nfrom pyasn1 import error\nfrom pyasn1.compat.octets import octs2ints\n\n__all__ = ['Debug', 'setLogger', 'hexdump']\n\nDEBUG_NONE = 0x0000\nDEBUG_ENCODER = 0x0001\nDEBUG_DECODER = 0x0002\nDEBUG_ALL = 0xffff\n\nFLAG_MAP = {\n    'none': DEBUG_NONE,\n    'encoder': DEBUG_ENCODER,\n    'decoder': DEBUG_DECODER,\n    'all': DEBUG_ALL\n}\n\nLOGGEE_MAP = {}\n\n\nclass Printer(object):\n    # noinspection PyShadowingNames\n    def __init__(self, logger=None, handler=None, formatter=None):\n        if logger is None:\n            logger = logging.getLogger('pyasn1')\n\n        logger.setLevel(logging.DEBUG)\n\n        if handler is None:\n            handler = logging.StreamHandler()\n\n        if formatter is None:\n            formatter = logging.Formatter('%(asctime)s %(name)s: %(message)s')\n\n        handler.setFormatter(formatter)\n        handler.setLevel(logging.DEBUG)\n        logger.addHandler(handler)\n\n        self.__logger = logger\n\n    def __call__(self, msg):\n        self.__logger.debug(msg)\n\n    def __str__(self):\n        return '<python logging>'\n\n\nclass Debug(object):\n    defaultPrinter = Printer()\n\n    def __init__(self, *flags, **options):\n        self._flags = DEBUG_NONE\n\n        if 'loggerName' in options:\n            # route our logs to parent logger\n            self._printer = Printer(\n                logger=logging.getLogger(options['loggerName']),\n                handler=logging.NullHandler()\n            )\n\n        elif 'printer' in options:\n            self._printer = options.get('printer')\n\n        else:\n            self._printer = self.defaultPrinter\n\n        self._printer('running pyasn1 %s, debug flags %s' % (__version__, ', '.join(flags)))\n\n        for flag in flags:\n            inverse = flag and flag[0] in ('!', '~')\n            if inverse:\n                flag = flag[1:]\n            try:\n                if inverse:\n                    self._flags &= ~FLAG_MAP[flag]\n                else:\n                    self._flags |= FLAG_MAP[flag]\n            except KeyError:\n                raise error.PyAsn1Error('bad debug flag %s' % flag)\n\n            self._printer(\"debug category '%s' %s\" % (flag, inverse and 'disabled' or 'enabled'))\n\n    def __str__(self):\n        return 'logger %s, flags %x' % (self._printer, self._flags)\n\n    def __call__(self, msg):\n        self._printer(msg)\n\n    def __and__(self, flag):\n        return self._flags & flag\n\n    def __rand__(self, flag):\n        return flag & self._flags\n\n_LOG = DEBUG_NONE\n\n\ndef setLogger(userLogger):\n    global _LOG\n\n    if userLogger:\n        _LOG = userLogger\n    else:\n        _LOG = DEBUG_NONE\n\n    # Update registered logging clients\n    for module, (name, flags) in LOGGEE_MAP.items():\n        setattr(module, name, _LOG & flags and _LOG or DEBUG_NONE)\n\n\ndef registerLoggee(module, name='LOG', flags=DEBUG_NONE):\n    LOGGEE_MAP[sys.modules[module]] = name, flags\n    setLogger(_LOG)\n    return _LOG\n\n\ndef hexdump(octets):\n    return ' '.join(\n        ['%s%.2X' % (n % 16 == 0 and ('\\n%.5d: ' % n) or '', x)\n         for n, x in zip(range(len(octets)), octs2ints(octets))]\n    )\n\n\nclass Scope(object):\n    def __init__(self):\n        self._list = []\n\n    def __str__(self): return '.'.join(self._list)\n\n    def push(self, token):\n        self._list.append(token)\n\n    def pop(self):\n        return self._list.pop()\n\n\nscope = Scope()\n", "pyasn1/error.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n\n\nclass PyAsn1Error(Exception):\n    \"\"\"Base pyasn1 exception\n\n    `PyAsn1Error` is the base exception class (based on\n    :class:`Exception`) that represents all possible ASN.1 related\n    errors.\n\n    Parameters\n    ----------\n    args:\n        Opaque positional parameters\n\n    Keyword Args\n    ------------\n    kwargs:\n        Opaque keyword parameters\n\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self._args = args\n        self._kwargs = kwargs\n\n    @property\n    def context(self):\n        \"\"\"Return exception context\n\n        When exception object is created, the caller can supply some opaque\n        context for the upper layers to better understand the cause of the\n        exception.\n\n        Returns\n        -------\n        : :py:class:`dict`\n            Dict holding context specific data\n        \"\"\"\n        return self._kwargs.get('context', {})\n\n\nclass ValueConstraintError(PyAsn1Error):\n    \"\"\"ASN.1 type constraints violation exception\n\n    The `ValueConstraintError` exception indicates an ASN.1 value\n    constraint violation.\n\n    It might happen on value object instantiation (for scalar types) or on\n    serialization (for constructed types).\n    \"\"\"\n\n\nclass SubstrateUnderrunError(PyAsn1Error):\n    \"\"\"ASN.1 data structure deserialization error\n\n    The `SubstrateUnderrunError` exception indicates insufficient serialised\n    data on input of a de-serialization codec.\n    \"\"\"\n\n\nclass EndOfStreamError(SubstrateUnderrunError):\n    \"\"\"ASN.1 data structure deserialization error\n\n    The `EndOfStreamError` exception indicates the condition of the input\n    stream has been closed.\n    \"\"\"\n\n\nclass UnsupportedSubstrateError(PyAsn1Error):\n    \"\"\"Unsupported substrate type to parse as ASN.1 data.\"\"\"\n\n\nclass PyAsn1UnicodeError(PyAsn1Error, UnicodeError):\n    \"\"\"Unicode text processing error\n\n    The `PyAsn1UnicodeError` exception is a base class for errors relating to\n    unicode text de/serialization.\n\n    Apart from inheriting from :class:`PyAsn1Error`, it also inherits from\n    :class:`UnicodeError` to help the caller catching unicode-related errors.\n    \"\"\"\n    def __init__(self, message, unicode_error=None):\n        if isinstance(unicode_error, UnicodeError):\n            UnicodeError.__init__(self, *unicode_error.args)\n        PyAsn1Error.__init__(self, message)\n\n\nclass PyAsn1UnicodeDecodeError(PyAsn1UnicodeError, UnicodeDecodeError):\n    \"\"\"Unicode text decoding error\n\n    The `PyAsn1UnicodeDecodeError` exception represents a failure to\n    deserialize unicode text.\n\n    Apart from inheriting from :class:`PyAsn1UnicodeError`, it also inherits\n    from :class:`UnicodeDecodeError` to help the caller catching unicode-related\n    errors.\n    \"\"\"\n\n\nclass PyAsn1UnicodeEncodeError(PyAsn1UnicodeError, UnicodeEncodeError):\n    \"\"\"Unicode text encoding error\n\n    The `PyAsn1UnicodeEncodeError` exception represents a failure to\n    serialize unicode text.\n\n    Apart from inheriting from :class:`PyAsn1UnicodeError`, it also inherits\n    from :class:`UnicodeEncodeError` to help the caller catching\n    unicode-related errors.\n    \"\"\"\n\n\n", "pyasn1/__init__.py": "# https://www.python.org/dev/peps/pep-0396/\n__version__ = '0.6.0'\n", "pyasn1/type/constraint.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n# Original concept and code by Mike C. Fletcher.\n#\nimport sys\n\nfrom pyasn1.type import error\n\n__all__ = ['SingleValueConstraint', 'ContainedSubtypeConstraint',\n           'ValueRangeConstraint', 'ValueSizeConstraint',\n           'PermittedAlphabetConstraint', 'InnerTypeConstraint',\n           'ConstraintsExclusion', 'ConstraintsIntersection',\n           'ConstraintsUnion']\n\n\nclass AbstractConstraint(object):\n\n    def __init__(self, *values):\n        self._valueMap = set()\n        self._setValues(values)\n        self.__hash = hash((self.__class__.__name__, self._values))\n\n    def __call__(self, value, idx=None):\n        if not self._values:\n            return\n\n        try:\n            self._testValue(value, idx)\n\n        except error.ValueConstraintError:\n            raise error.ValueConstraintError(\n                '%s failed at: %r' % (self, sys.exc_info()[1])\n            )\n\n    def __repr__(self):\n        representation = '%s object' % (self.__class__.__name__)\n\n        if self._values:\n            representation += ', consts %s' % ', '.join(\n                [repr(x) for x in self._values])\n\n        return '<%s>' % representation\n\n    def __eq__(self, other):\n        return self is other and True or self._values == other\n\n    def __ne__(self, other):\n        return self._values != other\n\n    def __lt__(self, other):\n        return self._values < other\n\n    def __le__(self, other):\n        return self._values <= other\n\n    def __gt__(self, other):\n        return self._values > other\n\n    def __ge__(self, other):\n        return self._values >= other\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self._values and True or False\n    else:\n        def __bool__(self):\n            return self._values and True or False\n\n    def __hash__(self):\n        return self.__hash\n\n    def _setValues(self, values):\n        self._values = values\n\n    def _testValue(self, value, idx):\n        raise error.ValueConstraintError(value)\n\n    # Constraints derivation logic\n    def getValueMap(self):\n        return self._valueMap\n\n    def isSuperTypeOf(self, otherConstraint):\n        # TODO: fix possible comparison of set vs scalars here\n        return (otherConstraint is self or\n                not self._values or\n                otherConstraint == self or\n                self in otherConstraint.getValueMap())\n\n    def isSubTypeOf(self, otherConstraint):\n        return (otherConstraint is self or\n                not self or\n                otherConstraint == self or\n                otherConstraint in self._valueMap)\n\n\nclass SingleValueConstraint(AbstractConstraint):\n    \"\"\"Create a SingleValueConstraint object.\n\n    The SingleValueConstraint satisfies any value that\n    is present in the set of permitted values.\n\n    Objects of this type are iterable (emitting constraint values) and\n    can act as operands for some arithmetic operations e.g. addition\n    and subtraction. The latter can be used for combining multiple\n    SingleValueConstraint objects into one.\n\n    The SingleValueConstraint object can be applied to\n    any ASN.1 type.\n\n    Parameters\n    ----------\n    *values: :class:`int`\n        Full set of values permitted by this constraint object.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class DivisorOfSix(Integer):\n            '''\n            ASN.1 specification:\n\n            Divisor-Of-6 ::= INTEGER (1 | 2 | 3 | 6)\n            '''\n            subtypeSpec = SingleValueConstraint(1, 2, 3, 6)\n\n        # this will succeed\n        divisor_of_six = DivisorOfSix(1)\n\n        # this will raise ValueConstraintError\n        divisor_of_six = DivisorOfSix(7)\n    \"\"\"\n    def _setValues(self, values):\n        self._values = values\n        self._set = set(values)\n\n    def _testValue(self, value, idx):\n        if value not in self._set:\n            raise error.ValueConstraintError(value)\n\n    # Constrains can be merged or reduced\n\n    def __contains__(self, item):\n        return item in self._set\n\n    def __iter__(self):\n        return iter(self._set)\n\n    def __sub__(self, constraint):\n        return self.__class__(*(self._set.difference(constraint)))\n\n    def __add__(self, constraint):\n        return self.__class__(*(self._set.union(constraint)))\n\n    def __sub__(self, constraint):\n        return self.__class__(*(self._set.difference(constraint)))\n\n\nclass ContainedSubtypeConstraint(AbstractConstraint):\n    \"\"\"Create a ContainedSubtypeConstraint object.\n\n    The ContainedSubtypeConstraint satisfies any value that\n    is present in the set of permitted values and also\n    satisfies included constraints.\n\n    The ContainedSubtypeConstraint object can be applied to\n    any ASN.1 type.\n\n    Parameters\n    ----------\n    *values:\n        Full set of values and constraint objects permitted\n        by this constraint object.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class DivisorOfEighteen(Integer):\n            '''\n            ASN.1 specification:\n\n            Divisors-of-18 ::= INTEGER (INCLUDES Divisors-of-6 | 9 | 18)\n            '''\n            subtypeSpec = ContainedSubtypeConstraint(\n                SingleValueConstraint(1, 2, 3, 6), 9, 18\n            )\n\n        # this will succeed\n        divisor_of_eighteen = DivisorOfEighteen(9)\n\n        # this will raise ValueConstraintError\n        divisor_of_eighteen = DivisorOfEighteen(10)\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            if isinstance(constraint, AbstractConstraint):\n                constraint(value, idx)\n            elif value not in self._set:\n                raise error.ValueConstraintError(value)\n\n\nclass ValueRangeConstraint(AbstractConstraint):\n    \"\"\"Create a ValueRangeConstraint object.\n\n    The ValueRangeConstraint satisfies any value that\n    falls in the range of permitted values.\n\n    The ValueRangeConstraint object can only be applied\n    to :class:`~pyasn1.type.univ.Integer` and\n    :class:`~pyasn1.type.univ.Real` types.\n\n    Parameters\n    ----------\n    start: :class:`int`\n        Minimum permitted value in the range (inclusive)\n\n    end: :class:`int`\n        Maximum permitted value in the range (inclusive)\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class TeenAgeYears(Integer):\n            '''\n            ASN.1 specification:\n\n            TeenAgeYears ::= INTEGER (13 .. 19)\n            '''\n            subtypeSpec = ValueRangeConstraint(13, 19)\n\n        # this will succeed\n        teen_year = TeenAgeYears(18)\n\n        # this will raise ValueConstraintError\n        teen_year = TeenAgeYears(20)\n    \"\"\"\n    def _testValue(self, value, idx):\n        if value < self.start or value > self.stop:\n            raise error.ValueConstraintError(value)\n\n    def _setValues(self, values):\n        if len(values) != 2:\n            raise error.PyAsn1Error(\n                '%s: bad constraint values' % (self.__class__.__name__,)\n            )\n        self.start, self.stop = values\n        if self.start > self.stop:\n            raise error.PyAsn1Error(\n                '%s: screwed constraint values (start > stop): %s > %s' % (\n                    self.__class__.__name__,\n                    self.start, self.stop\n                )\n            )\n        AbstractConstraint._setValues(self, values)\n\n\nclass ValueSizeConstraint(ValueRangeConstraint):\n    \"\"\"Create a ValueSizeConstraint object.\n\n    The ValueSizeConstraint satisfies any value for\n    as long as its size falls within the range of\n    permitted sizes.\n\n    The ValueSizeConstraint object can be applied\n    to :class:`~pyasn1.type.univ.BitString`,\n    :class:`~pyasn1.type.univ.OctetString` (including\n    all :ref:`character ASN.1 types <type.char>`),\n    :class:`~pyasn1.type.univ.SequenceOf`\n    and :class:`~pyasn1.type.univ.SetOf` types.\n\n    Parameters\n    ----------\n    minimum: :class:`int`\n        Minimum permitted size of the value (inclusive)\n\n    maximum: :class:`int`\n        Maximum permitted size of the value (inclusive)\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class BaseballTeamRoster(SetOf):\n            '''\n            ASN.1 specification:\n\n            BaseballTeamRoster ::= SET SIZE (1..25) OF PlayerNames\n            '''\n            componentType = PlayerNames()\n            subtypeSpec = ValueSizeConstraint(1, 25)\n\n        # this will succeed\n        team = BaseballTeamRoster()\n        team.extend(['Jan', 'Matej'])\n        encode(team)\n\n        # this will raise ValueConstraintError\n        team = BaseballTeamRoster()\n        team.extend(['Jan'] * 26)\n        encode(team)\n\n    Note\n    ----\n    Whenever ValueSizeConstraint is applied to mutable types\n    (e.g. :class:`~pyasn1.type.univ.SequenceOf`,\n    :class:`~pyasn1.type.univ.SetOf`), constraint\n    validation only happens at the serialisation phase rather\n    than schema instantiation phase (as it is with immutable\n    types).\n    \"\"\"\n    def _testValue(self, value, idx):\n        valueSize = len(value)\n        if valueSize < self.start or valueSize > self.stop:\n            raise error.ValueConstraintError(value)\n\n\nclass PermittedAlphabetConstraint(SingleValueConstraint):\n    \"\"\"Create a PermittedAlphabetConstraint object.\n\n    The PermittedAlphabetConstraint satisfies any character\n    string for as long as all its characters are present in\n    the set of permitted characters.\n\n    Objects of this type are iterable (emitting constraint values) and\n    can act as operands for some arithmetic operations e.g. addition\n    and subtraction.\n\n    The PermittedAlphabetConstraint object can only be applied\n    to the :ref:`character ASN.1 types <type.char>` such as\n    :class:`~pyasn1.type.char.IA5String`.\n\n    Parameters\n    ----------\n    *alphabet: :class:`str`\n        Full set of characters permitted by this constraint object.\n\n    Example\n    -------\n    .. code-block:: python\n\n        class BooleanValue(IA5String):\n            '''\n            ASN.1 specification:\n\n            BooleanValue ::= IA5String (FROM ('T' | 'F'))\n            '''\n            subtypeSpec = PermittedAlphabetConstraint('T', 'F')\n\n        # this will succeed\n        truth = BooleanValue('T')\n        truth = BooleanValue('TF')\n\n        # this will raise ValueConstraintError\n        garbage = BooleanValue('TAF')\n\n    ASN.1 `FROM ... EXCEPT ...` clause can be modelled by combining multiple\n    PermittedAlphabetConstraint objects into one:\n\n    Example\n    -------\n    .. code-block:: python\n\n        class Lipogramme(IA5String):\n            '''\n            ASN.1 specification:\n\n            Lipogramme ::=\n                IA5String (FROM (ALL EXCEPT (\"e\"|\"E\")))\n            '''\n            subtypeSpec = (\n                PermittedAlphabetConstraint(*string.printable) -\n                PermittedAlphabetConstraint('e', 'E')\n            )\n\n        # this will succeed\n        lipogramme = Lipogramme('A work of fiction?')\n\n        # this will raise ValueConstraintError\n        lipogramme = Lipogramme('Eel')\n\n    Note\n    ----\n    Although `ConstraintsExclusion` object could seemingly be used for this\n    purpose, practically, for it to work, it needs to represent its operand\n    constraints as sets and intersect one with the other. That would require\n    the insight into the constraint values (and their types) that are otherwise\n    hidden inside the constraint object.\n\n    Therefore it's more practical to model `EXCEPT` clause at\n    `PermittedAlphabetConstraint` level instead.\n    \"\"\"\n    def _setValues(self, values):\n        self._values = values\n        self._set = set(values)\n\n    def _testValue(self, value, idx):\n        if not self._set.issuperset(value):\n            raise error.ValueConstraintError(value)\n\n\nclass ComponentPresentConstraint(AbstractConstraint):\n    \"\"\"Create a ComponentPresentConstraint object.\n\n    The ComponentPresentConstraint is only satisfied when the value\n    is not `None`.\n\n    The ComponentPresentConstraint object is typically used with\n    `WithComponentsConstraint`.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        present = ComponentPresentConstraint()\n\n        # this will succeed\n        present('whatever')\n\n        # this will raise ValueConstraintError\n        present(None)\n    \"\"\"\n    def _setValues(self, values):\n        self._values = ('<must be present>',)\n\n        if values:\n            raise error.PyAsn1Error('No arguments expected')\n\n    def _testValue(self, value, idx):\n        if value is None:\n            raise error.ValueConstraintError(\n                'Component is not present:')\n\n\nclass ComponentAbsentConstraint(AbstractConstraint):\n    \"\"\"Create a ComponentAbsentConstraint object.\n\n    The ComponentAbsentConstraint is only satisfied when the value\n    is `None`.\n\n    The ComponentAbsentConstraint object is typically used with\n    `WithComponentsConstraint`.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        absent = ComponentAbsentConstraint()\n\n        # this will succeed\n        absent(None)\n\n        # this will raise ValueConstraintError\n        absent('whatever')\n    \"\"\"\n    def _setValues(self, values):\n        self._values = ('<must be absent>',)\n\n        if values:\n            raise error.PyAsn1Error('No arguments expected')\n\n    def _testValue(self, value, idx):\n        if value is not None:\n            raise error.ValueConstraintError(\n                'Component is not absent: %r' % value)\n\n\nclass WithComponentsConstraint(AbstractConstraint):\n    \"\"\"Create a WithComponentsConstraint object.\n\n    The `WithComponentsConstraint` satisfies any mapping object that has\n    constrained fields present or absent, what is indicated by\n    `ComponentPresentConstraint` and `ComponentAbsentConstraint`\n    objects respectively.\n\n    The `WithComponentsConstraint` object is typically applied\n    to  :class:`~pyasn1.type.univ.Set` or\n    :class:`~pyasn1.type.univ.Sequence` types.\n\n    Parameters\n    ----------\n    *fields: :class:`tuple`\n        Zero or more tuples of (`field`, `constraint`) indicating constrained\n        fields.\n\n    Notes\n    -----\n    On top of the primary use of `WithComponentsConstraint` (ensuring presence\n    or absence of particular components of a :class:`~pyasn1.type.univ.Set` or\n    :class:`~pyasn1.type.univ.Sequence`), it is also possible to pass any other\n    constraint objects or their combinations. In case of scalar fields, these\n    constraints will be verified in addition to the constraints belonging to\n    scalar components themselves. However, formally, these additional\n    constraints do not change the type of these ASN.1 objects.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Item(Sequence):  #  Set is similar\n            '''\n            ASN.1 specification:\n\n            Item ::= SEQUENCE {\n                id    INTEGER OPTIONAL,\n                name  OCTET STRING OPTIONAL\n            } WITH COMPONENTS id PRESENT, name ABSENT | id ABSENT, name PRESENT\n            '''\n            componentType = NamedTypes(\n                OptionalNamedType('id', Integer()),\n                OptionalNamedType('name', OctetString())\n            )\n            withComponents = ConstraintsUnion(\n                WithComponentsConstraint(\n                    ('id', ComponentPresentConstraint()),\n                    ('name', ComponentAbsentConstraint())\n                ),\n                WithComponentsConstraint(\n                    ('id', ComponentAbsentConstraint()),\n                    ('name', ComponentPresentConstraint())\n                )\n            )\n\n        item = Item()\n\n        # This will succeed\n        item['id'] = 1\n\n        # This will succeed\n        item.reset()\n        item['name'] = 'John'\n\n        # This will fail (on encoding)\n        item.reset()\n        descr['id'] = 1\n        descr['name'] = 'John'\n    \"\"\"\n    def _testValue(self, value, idx):\n        for field, constraint in self._values:\n            constraint(value.get(field))\n\n    def _setValues(self, values):\n        AbstractConstraint._setValues(self, values)\n\n\n# This is a bit kludgy, meaning two op modes within a single constraint\nclass InnerTypeConstraint(AbstractConstraint):\n    \"\"\"Value must satisfy the type and presence constraints\"\"\"\n\n    def _testValue(self, value, idx):\n        if self.__singleTypeConstraint:\n            self.__singleTypeConstraint(value)\n        elif self.__multipleTypeConstraint:\n            if idx not in self.__multipleTypeConstraint:\n                raise error.ValueConstraintError(value)\n            constraint, status = self.__multipleTypeConstraint[idx]\n            if status == 'ABSENT':  # XXX presence is not checked!\n                raise error.ValueConstraintError(value)\n            constraint(value)\n\n    def _setValues(self, values):\n        self.__multipleTypeConstraint = {}\n        self.__singleTypeConstraint = None\n        for v in values:\n            if isinstance(v, tuple):\n                self.__multipleTypeConstraint[v[0]] = v[1], v[2]\n            else:\n                self.__singleTypeConstraint = v\n        AbstractConstraint._setValues(self, values)\n\n\n# Logic operations on constraints\n\nclass ConstraintsExclusion(AbstractConstraint):\n    \"\"\"Create a ConstraintsExclusion logic operator object.\n\n    The ConstraintsExclusion logic operator succeeds when the\n    value does *not* satisfy the operand constraint.\n\n    The ConstraintsExclusion object can be applied to\n    any constraint and logic operator object.\n\n    Parameters\n    ----------\n    *constraints:\n        Constraint or logic operator objects.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class LuckyNumber(Integer):\n            subtypeSpec = ConstraintsExclusion(\n                SingleValueConstraint(13)\n            )\n\n        # this will succeed\n        luckyNumber = LuckyNumber(12)\n\n        # this will raise ValueConstraintError\n        luckyNumber = LuckyNumber(13)\n\n    Note\n    ----\n    The `FROM ... EXCEPT ...` ASN.1 clause should be modeled by combining\n    constraint objects into one. See `PermittedAlphabetConstraint` for more\n    information.\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            try:\n                constraint(value, idx)\n\n            except error.ValueConstraintError:\n                continue\n\n            raise error.ValueConstraintError(value)\n\n    def _setValues(self, values):\n        AbstractConstraint._setValues(self, values)\n\n\nclass AbstractConstraintSet(AbstractConstraint):\n\n    def __getitem__(self, idx):\n        return self._values[idx]\n\n    def __iter__(self):\n        return iter(self._values)\n\n    def __add__(self, value):\n        return self.__class__(*(self._values + (value,)))\n\n    def __radd__(self, value):\n        return self.__class__(*((value,) + self._values))\n\n    def __len__(self):\n        return len(self._values)\n\n    # Constraints inclusion in sets\n\n    def _setValues(self, values):\n        self._values = values\n        for constraint in values:\n            if constraint:\n                self._valueMap.add(constraint)\n                self._valueMap.update(constraint.getValueMap())\n\n\nclass ConstraintsIntersection(AbstractConstraintSet):\n    \"\"\"Create a ConstraintsIntersection logic operator object.\n\n    The ConstraintsIntersection logic operator only succeeds\n    if *all* its operands succeed.\n\n    The ConstraintsIntersection object can be applied to\n    any constraint and logic operator objects.\n\n    The ConstraintsIntersection object duck-types the immutable\n    container object like Python :py:class:`tuple`.\n\n    Parameters\n    ----------\n    *constraints:\n        Constraint or logic operator objects.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class CapitalAndSmall(IA5String):\n            '''\n            ASN.1 specification:\n\n            CapitalAndSmall ::=\n                IA5String (FROM (\"A\"..\"Z\"|\"a\"..\"z\"))\n            '''\n            subtypeSpec = ConstraintsIntersection(\n                PermittedAlphabetConstraint('A', 'Z'),\n                PermittedAlphabetConstraint('a', 'z')\n            )\n\n        # this will succeed\n        capital_and_small = CapitalAndSmall('Hello')\n\n        # this will raise ValueConstraintError\n        capital_and_small = CapitalAndSmall('hello')\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            constraint(value, idx)\n\n\nclass ConstraintsUnion(AbstractConstraintSet):\n    \"\"\"Create a ConstraintsUnion logic operator object.\n\n    The ConstraintsUnion logic operator succeeds if\n    *at least* a single operand succeeds.\n\n    The ConstraintsUnion object can be applied to\n    any constraint and logic operator objects.\n\n    The ConstraintsUnion object duck-types the immutable\n    container object like Python :py:class:`tuple`.\n\n    Parameters\n    ----------\n    *constraints:\n        Constraint or logic operator objects.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class CapitalOrSmall(IA5String):\n            '''\n            ASN.1 specification:\n\n            CapitalOrSmall ::=\n                IA5String (FROM (\"A\"..\"Z\") | FROM (\"a\"..\"z\"))\n            '''\n            subtypeSpec = ConstraintsUnion(\n                PermittedAlphabetConstraint('A', 'Z'),\n                PermittedAlphabetConstraint('a', 'z')\n            )\n\n        # this will succeed\n        capital_or_small = CapitalAndSmall('Hello')\n\n        # this will raise ValueConstraintError\n        capital_or_small = CapitalOrSmall('hello!')\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            try:\n                constraint(value, idx)\n            except error.ValueConstraintError:\n                pass\n            else:\n                return\n\n        raise error.ValueConstraintError(\n            'all of %s failed for \"%s\"' % (self._values, value)\n        )\n\n# TODO:\n# refactor InnerTypeConstraint\n# add tests for type check\n# implement other constraint types\n# make constraint validation easy to skip\n", "pyasn1/type/tagmap.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\n\n__all__ = ['TagMap']\n\n\nclass TagMap(object):\n    \"\"\"Map *TagSet* objects to ASN.1 types\n\n    Create an object mapping *TagSet* object to ASN.1 type.\n\n    *TagMap* objects are immutable and duck-type read-only Python\n    :class:`dict` objects holding *TagSet* objects as keys and ASN.1\n    type objects as values.\n\n    Parameters\n    ----------\n    presentTypes: :py:class:`dict`\n        Map of :class:`~pyasn1.type.tag.TagSet` to ASN.1 objects considered\n        as being unconditionally present in the *TagMap*.\n\n    skipTypes: :py:class:`dict`\n        A collection of :class:`~pyasn1.type.tag.TagSet` objects considered\n        as absent in the *TagMap* even when *defaultType* is present.\n\n    defaultType: ASN.1 type object\n        An ASN.1 type object callee *TagMap* returns for any *TagSet* key not present\n        in *presentTypes* (unless given key is present in *skipTypes*).\n    \"\"\"\n    def __init__(self, presentTypes=None, skipTypes=None, defaultType=None):\n        self.__presentTypes = presentTypes or {}\n        self.__skipTypes = skipTypes or {}\n        self.__defaultType = defaultType\n\n    def __contains__(self, tagSet):\n        return (tagSet in self.__presentTypes or\n                self.__defaultType is not None and tagSet not in self.__skipTypes)\n\n    def __getitem__(self, tagSet):\n        try:\n            return self.__presentTypes[tagSet]\n        except KeyError:\n            if self.__defaultType is None:\n                raise KeyError()\n            elif tagSet in self.__skipTypes:\n                raise error.PyAsn1Error('Key in negative map')\n            else:\n                return self.__defaultType\n\n    def __iter__(self):\n        return iter(self.__presentTypes)\n\n    def __repr__(self):\n        representation = '%s object' % self.__class__.__name__\n\n        if self.__presentTypes:\n            representation += ', present %s' % repr(self.__presentTypes)\n\n        if self.__skipTypes:\n            representation += ', skip %s' % repr(self.__skipTypes)\n\n        if self.__defaultType is not None:\n            representation += ', default %s' % repr(self.__defaultType)\n\n        return '<%s>' % representation\n\n    @property\n    def presentTypes(self):\n        \"\"\"Return *TagSet* to ASN.1 type map present in callee *TagMap*\"\"\"\n        return self.__presentTypes\n\n    @property\n    def skipTypes(self):\n        \"\"\"Return *TagSet* collection unconditionally absent in callee *TagMap*\"\"\"\n        return self.__skipTypes\n\n    @property\n    def defaultType(self):\n        \"\"\"Return default ASN.1 type being returned for any missing *TagSet*\"\"\"\n        return self.__defaultType\n\n    # Backward compatibility\n\n    def getPosMap(self):\n        return self.presentTypes\n\n    def getNegMap(self):\n        return self.skipTypes\n\n    def getDef(self):\n        return self.defaultType\n", "pyasn1/type/useful.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport datetime\n\nfrom pyasn1 import error\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\n\n__all__ = ['ObjectDescriptor', 'GeneralizedTime', 'UTCTime']\n\nNoValue = univ.NoValue\nnoValue = univ.noValue\n\n\nclass ObjectDescriptor(char.GraphicString):\n    __doc__ = char.GraphicString.__doc__\n\n    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects\n    tagSet = char.GraphicString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 7)\n    )\n\n    # Optimization for faster codec lookup\n    typeId = char.GraphicString.getTypeId()\n\n\nclass TimeMixIn(object):\n\n    _yearsDigits = 4\n    _hasSubsecond = False\n    _optionalMinutes = False\n    _shortTZ = False\n\n    class FixedOffset(datetime.tzinfo):\n        \"\"\"Fixed offset in minutes east from UTC.\"\"\"\n\n        # defaulted arguments required\n        # https: // docs.python.org / 2.3 / lib / datetime - tzinfo.html\n        def __init__(self, offset=0, name='UTC'):\n            self.__offset = datetime.timedelta(minutes=offset)\n            self.__name = name\n\n        def utcoffset(self, dt):\n            return self.__offset\n\n        def tzname(self, dt):\n            return self.__name\n\n        def dst(self, dt):\n            return datetime.timedelta(0)\n\n    UTC = FixedOffset()\n\n    @property\n    def asDateTime(self):\n        \"\"\"Create :py:class:`datetime.datetime` object from a |ASN.1| object.\n\n        Returns\n        -------\n        :\n            new instance of :py:class:`datetime.datetime` object\n        \"\"\"\n        text = str(self)\n        if text.endswith('Z'):\n            tzinfo = TimeMixIn.UTC\n            text = text[:-1]\n\n        elif '-' in text or '+' in text:\n            if '+' in text:\n                text, plusminus, tz = text.partition('+')\n            else:\n                text, plusminus, tz = text.partition('-')\n\n            if self._shortTZ and len(tz) == 2:\n                tz += '00'\n\n            if len(tz) != 4:\n                raise error.PyAsn1Error('malformed time zone offset %s' % tz)\n\n            try:\n                minutes = int(tz[:2]) * 60 + int(tz[2:])\n                if plusminus == '-':\n                    minutes *= -1\n\n            except ValueError:\n                raise error.PyAsn1Error('unknown time specification %s' % self)\n\n            tzinfo = TimeMixIn.FixedOffset(minutes, '?')\n\n        else:\n            tzinfo = None\n\n        if '.' in text or ',' in text:\n            if '.' in text:\n                text, _, ms = text.partition('.')\n            else:\n                text, _, ms = text.partition(',')\n\n            try:\n                ms = int(ms) * 1000\n\n            except ValueError:\n                raise error.PyAsn1Error('bad sub-second time specification %s' % self)\n\n        else:\n            ms = 0\n\n        if self._optionalMinutes and len(text) - self._yearsDigits == 6:\n            text += '0000'\n        elif len(text) - self._yearsDigits == 8:\n            text += '00'\n\n        try:\n            dt = datetime.datetime.strptime(text, self._yearsDigits == 4 and '%Y%m%d%H%M%S' or '%y%m%d%H%M%S')\n\n        except ValueError:\n            raise error.PyAsn1Error('malformed datetime format %s' % self)\n\n        return dt.replace(microsecond=ms, tzinfo=tzinfo)\n\n    @classmethod\n    def fromDateTime(cls, dt):\n        \"\"\"Create |ASN.1| object from a :py:class:`datetime.datetime` object.\n\n        Parameters\n        ----------\n        dt: :py:class:`datetime.datetime` object\n            The `datetime.datetime` object to initialize the |ASN.1| object\n            from\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| value\n        \"\"\"\n        text = dt.strftime(cls._yearsDigits == 4 and '%Y%m%d%H%M%S' or '%y%m%d%H%M%S')\n        if cls._hasSubsecond:\n            text += '.%d' % (dt.microsecond // 1000)\n\n        if dt.utcoffset():\n            seconds = dt.utcoffset().seconds\n            if seconds < 0:\n                text += '-'\n            else:\n                text += '+'\n            text += '%.2d%.2d' % (seconds // 3600, seconds % 3600)\n        else:\n            text += 'Z'\n\n        return cls(text)\n\n\nclass GeneralizedTime(char.VisibleString, TimeMixIn):\n    __doc__ = char.VisibleString.__doc__\n\n    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects\n    tagSet = char.VisibleString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 24)\n    )\n\n    # Optimization for faster codec lookup\n    typeId = char.VideotexString.getTypeId()\n\n    _yearsDigits = 4\n    _hasSubsecond = True\n    _optionalMinutes = True\n    _shortTZ = True\n\n\nclass UTCTime(char.VisibleString, TimeMixIn):\n    __doc__ = char.VisibleString.__doc__\n\n    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects\n    tagSet = char.VisibleString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 23)\n    )\n\n    # Optimization for faster codec lookup\n    typeId = char.VideotexString.getTypeId()\n\n    _yearsDigits = 2\n    _hasSubsecond = False\n    _optionalMinutes = False\n    _shortTZ = False\n", "pyasn1/type/tag.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\n\n__all__ = ['tagClassUniversal', 'tagClassApplication', 'tagClassContext',\n           'tagClassPrivate', 'tagFormatSimple', 'tagFormatConstructed',\n           'tagCategoryImplicit', 'tagCategoryExplicit',\n           'tagCategoryUntagged', 'Tag', 'TagSet']\n\n#: Identifier for ASN.1 class UNIVERSAL\ntagClassUniversal = 0x00\n\n#: Identifier for ASN.1 class APPLICATION\ntagClassApplication = 0x40\n\n#: Identifier for ASN.1 class context-specific\ntagClassContext = 0x80\n\n#: Identifier for ASN.1 class private\ntagClassPrivate = 0xC0\n\n#: Identifier for \"simple\" ASN.1 structure (e.g. scalar)\ntagFormatSimple = 0x00\n\n#: Identifier for \"constructed\" ASN.1 structure (e.g. may have inner components)\ntagFormatConstructed = 0x20\n\ntagCategoryImplicit = 0x01\ntagCategoryExplicit = 0x02\ntagCategoryUntagged = 0x04\n\n\nclass Tag(object):\n    \"\"\"Create ASN.1 tag\n\n    Represents ASN.1 tag that can be attached to a ASN.1 type to make\n    types distinguishable from each other.\n\n    *Tag* objects are immutable and duck-type Python :class:`tuple` objects\n    holding three integer components of a tag.\n\n    Parameters\n    ----------\n    tagClass: :py:class:`int`\n        Tag *class* value\n\n    tagFormat: :py:class:`int`\n        Tag *format* value\n\n    tagId: :py:class:`int`\n        Tag ID value\n    \"\"\"\n    def __init__(self, tagClass, tagFormat, tagId):\n        if tagId < 0:\n            raise error.PyAsn1Error('Negative tag ID (%s) not allowed' % tagId)\n        self.__tagClass = tagClass\n        self.__tagFormat = tagFormat\n        self.__tagId = tagId\n        self.__tagClassId = tagClass, tagId\n        self.__hash = hash(self.__tagClassId)\n\n    def __repr__(self):\n        representation = '[%s:%s:%s]' % (\n            self.__tagClass, self.__tagFormat, self.__tagId)\n        return '<%s object, tag %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return self.__tagClassId == other\n\n    def __ne__(self, other):\n        return self.__tagClassId != other\n\n    def __lt__(self, other):\n        return self.__tagClassId < other\n\n    def __le__(self, other):\n        return self.__tagClassId <= other\n\n    def __gt__(self, other):\n        return self.__tagClassId > other\n\n    def __ge__(self, other):\n        return self.__tagClassId >= other\n\n    def __hash__(self):\n        return self.__hash\n\n    def __getitem__(self, idx):\n        if idx == 0:\n            return self.__tagClass\n        elif idx == 1:\n            return self.__tagFormat\n        elif idx == 2:\n            return self.__tagId\n        else:\n            raise IndexError()\n\n    def __iter__(self):\n        yield self.__tagClass\n        yield self.__tagFormat\n        yield self.__tagId\n\n    def __and__(self, otherTag):\n        return self.__class__(self.__tagClass & otherTag.tagClass,\n                              self.__tagFormat & otherTag.tagFormat,\n                              self.__tagId & otherTag.tagId)\n\n    def __or__(self, otherTag):\n        return self.__class__(self.__tagClass | otherTag.tagClass,\n                              self.__tagFormat | otherTag.tagFormat,\n                              self.__tagId | otherTag.tagId)\n\n    @property\n    def tagClass(self):\n        \"\"\"ASN.1 tag class\n\n        Returns\n        -------\n        : :py:class:`int`\n            Tag class\n        \"\"\"\n        return self.__tagClass\n\n    @property\n    def tagFormat(self):\n        \"\"\"ASN.1 tag format\n\n        Returns\n        -------\n        : :py:class:`int`\n            Tag format\n        \"\"\"\n        return self.__tagFormat\n\n    @property\n    def tagId(self):\n        \"\"\"ASN.1 tag ID\n\n        Returns\n        -------\n        : :py:class:`int`\n            Tag ID\n        \"\"\"\n        return self.__tagId\n\n\nclass TagSet(object):\n    \"\"\"Create a collection of ASN.1 tags\n\n    Represents a combination of :class:`~pyasn1.type.tag.Tag` objects\n    that can be attached to a ASN.1 type to make types distinguishable\n    from each other.\n\n    *TagSet* objects are immutable and duck-type Python :class:`tuple` objects\n    holding arbitrary number of :class:`~pyasn1.type.tag.Tag` objects.\n\n    Parameters\n    ----------\n    baseTag: :class:`~pyasn1.type.tag.Tag`\n        Base *Tag* object. This tag survives IMPLICIT tagging.\n\n    *superTags: :class:`~pyasn1.type.tag.Tag`\n        Additional *Tag* objects taking part in subtyping.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class OrderNumber(NumericString):\n            '''\n            ASN.1 specification\n\n            Order-number ::=\n                [APPLICATION 5] IMPLICIT NumericString\n            '''\n            tagSet = NumericString.tagSet.tagImplicitly(\n                Tag(tagClassApplication, tagFormatSimple, 5)\n            )\n\n        orderNumber = OrderNumber('1234')\n    \"\"\"\n    def __init__(self, baseTag=(), *superTags):\n        self.__baseTag = baseTag\n        self.__superTags = superTags\n        self.__superTagsClassId = tuple(\n            [(superTag.tagClass, superTag.tagId) for superTag in superTags]\n        )\n        self.__lenOfSuperTags = len(superTags)\n        self.__hash = hash(self.__superTagsClassId)\n\n    def __repr__(self):\n        representation = '-'.join(['%s:%s:%s' % (x.tagClass, x.tagFormat, x.tagId)\n                                   for x in self.__superTags])\n        if representation:\n            representation = 'tags ' + representation\n        else:\n            representation = 'untagged'\n\n        return '<%s object, %s>' % (self.__class__.__name__, representation)\n\n    def __add__(self, superTag):\n        return self.__class__(self.__baseTag, *self.__superTags + (superTag,))\n\n    def __radd__(self, superTag):\n        return self.__class__(self.__baseTag, *(superTag,) + self.__superTags)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.__class__(self.__baseTag, *self.__superTags[i])\n        else:\n            return self.__superTags[i]\n\n    def __eq__(self, other):\n        return self.__superTagsClassId == other\n\n    def __ne__(self, other):\n        return self.__superTagsClassId != other\n\n    def __lt__(self, other):\n        return self.__superTagsClassId < other\n\n    def __le__(self, other):\n        return self.__superTagsClassId <= other\n\n    def __gt__(self, other):\n        return self.__superTagsClassId > other\n\n    def __ge__(self, other):\n        return self.__superTagsClassId >= other\n\n    def __hash__(self):\n        return self.__hash\n\n    def __len__(self):\n        return self.__lenOfSuperTags\n\n    @property\n    def baseTag(self):\n        \"\"\"Return base ASN.1 tag\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tag.Tag`\n            Base tag of this *TagSet*\n        \"\"\"\n        return self.__baseTag\n\n    @property\n    def superTags(self):\n        \"\"\"Return ASN.1 tags\n\n        Returns\n        -------\n        : :py:class:`tuple`\n            Tuple of :class:`~pyasn1.type.tag.Tag` objects that this *TagSet* contains\n        \"\"\"\n        return self.__superTags\n\n    def tagExplicitly(self, superTag):\n        \"\"\"Return explicitly tagged *TagSet*\n\n        Create a new *TagSet* representing callee *TagSet* explicitly tagged\n        with passed tag(s). With explicit tagging mode, new tags are appended\n        to existing tag(s).\n\n        Parameters\n        ----------\n        superTag: :class:`~pyasn1.type.tag.Tag`\n            *Tag* object to tag this *TagSet*\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tag.TagSet`\n            New *TagSet* object\n        \"\"\"\n        if superTag.tagClass == tagClassUniversal:\n            raise error.PyAsn1Error(\"Can't tag with UNIVERSAL class tag\")\n        if superTag.tagFormat != tagFormatConstructed:\n            superTag = Tag(superTag.tagClass, tagFormatConstructed, superTag.tagId)\n        return self + superTag\n\n    def tagImplicitly(self, superTag):\n        \"\"\"Return implicitly tagged *TagSet*\n\n        Create a new *TagSet* representing callee *TagSet* implicitly tagged\n        with passed tag(s). With implicit tagging mode, new tag(s) replace the\n        last existing tag.\n\n        Parameters\n        ----------\n        superTag: :class:`~pyasn1.type.tag.Tag`\n            *Tag* object to tag this *TagSet*\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tag.TagSet`\n            New *TagSet* object\n        \"\"\"\n        if self.__superTags:\n            superTag = Tag(superTag.tagClass, self.__superTags[-1].tagFormat, superTag.tagId)\n        return self[:-1] + superTag\n\n    def isSuperTagSetOf(self, tagSet):\n        \"\"\"Test type relationship against given *TagSet*\n\n        The callee is considered to be a supertype of given *TagSet*\n        tag-wise if all tags in *TagSet* are present in the callee and\n        they are in the same order.\n\n        Parameters\n        ----------\n        tagSet: :class:`~pyasn1.type.tag.TagSet`\n            *TagSet* object to evaluate against the callee\n\n        Returns\n        -------\n        : :py:class:`bool`\n            :obj:`True` if callee is a supertype of *tagSet*\n        \"\"\"\n        if len(tagSet) < self.__lenOfSuperTags:\n            return False\n        return self.__superTags == tagSet[:self.__lenOfSuperTags]\n\n    # Backward compatibility\n\n    def getBaseTag(self):\n        return self.__baseTag\n\ndef initTagSet(tag):\n    return TagSet(tag, tag)\n", "pyasn1/type/base.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import constraint\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\n\n__all__ = ['Asn1Item', 'Asn1Type', 'SimpleAsn1Type',\n           'ConstructedAsn1Type']\n\n\nclass Asn1Item(object):\n    @classmethod\n    def getTypeId(cls, increment=1):\n        try:\n            Asn1Item._typeCounter += increment\n        except AttributeError:\n            Asn1Item._typeCounter = increment\n        return Asn1Item._typeCounter\n\n\nclass Asn1Type(Asn1Item):\n    \"\"\"Base class for all classes representing ASN.1 types.\n\n    In the user code, |ASN.1| class is normally used only for telling\n    ASN.1 objects from others.\n\n    Note\n    ----\n    For as long as ASN.1 is concerned, a way to compare ASN.1 types\n    is to use :meth:`isSameTypeWith` and :meth:`isSuperTypeOf` methods.\n    \"\"\"\n    #: Set or return a :py:class:`~pyasn1.type.tag.TagSet` object representing\n    #: ASN.1 tag(s) associated with |ASN.1| type.\n    tagSet = tag.TagSet()\n\n    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n    #: object imposing constraints on initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = None\n\n    def __init__(self, **kwargs):\n        readOnly = {\n            'tagSet': self.tagSet,\n            'subtypeSpec': self.subtypeSpec\n        }\n\n        readOnly.update(kwargs)\n\n        self.__dict__.update(readOnly)\n\n        self._readOnly = readOnly\n\n    def __setattr__(self, name, value):\n        if name[0] != '_' and name in self._readOnly:\n            raise error.PyAsn1Error('read-only instance attribute \"%s\"' % name)\n\n        self.__dict__[name] = value\n\n    def __str__(self):\n        return self.prettyPrint()\n\n    @property\n    def readOnly(self):\n        return self._readOnly\n\n    @property\n    def effectiveTagSet(self):\n        \"\"\"For |ASN.1| type is equivalent to *tagSet*\n        \"\"\"\n        return self.tagSet  # used by untagged types\n\n    @property\n    def tagMap(self):\n        \"\"\"Return a :class:`~pyasn1.type.tagmap.TagMap` object mapping ASN.1 tags to ASN.1 objects within callee object.\n        \"\"\"\n        return tagmap.TagMap({self.tagSet: self})\n\n    def isSameTypeWith(self, other, matchTags=True, matchConstraints=True):\n        \"\"\"Examine |ASN.1| type for equality with other ASN.1 type.\n\n        ASN.1 tags (:py:mod:`~pyasn1.type.tag`) and constraints\n        (:py:mod:`~pyasn1.type.constraint`) are examined when carrying\n        out ASN.1 types comparison.\n\n        Python class inheritance relationship is NOT considered.\n\n        Parameters\n        ----------\n        other: a pyasn1 type object\n            Class instance representing ASN.1 type.\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if *other* is |ASN.1| type,\n            :obj:`False` otherwise.\n        \"\"\"\n        return (self is other or\n                (not matchTags or self.tagSet == other.tagSet) and\n                (not matchConstraints or self.subtypeSpec == other.subtypeSpec))\n\n    def isSuperTypeOf(self, other, matchTags=True, matchConstraints=True):\n        \"\"\"Examine |ASN.1| type for subtype relationship with other ASN.1 type.\n\n        ASN.1 tags (:py:mod:`~pyasn1.type.tag`) and constraints\n        (:py:mod:`~pyasn1.type.constraint`) are examined when carrying\n        out ASN.1 types comparison.\n\n        Python class inheritance relationship is NOT considered.\n\n        Parameters\n        ----------\n            other: a pyasn1 type object\n                Class instance representing ASN.1 type.\n\n        Returns\n        -------\n            : :class:`bool`\n                :obj:`True` if *other* is a subtype of |ASN.1| type,\n                :obj:`False` otherwise.\n        \"\"\"\n        return (not matchTags or\n                (self.tagSet.isSuperTagSetOf(other.tagSet)) and\n                 (not matchConstraints or self.subtypeSpec.isSuperTypeOf(other.subtypeSpec)))\n\n    @staticmethod\n    def isNoValue(*values):\n        for value in values:\n            if value is not noValue:\n                return False\n        return True\n\n    def prettyPrint(self, scope=0):\n        raise NotImplementedError()\n\n    # backward compatibility\n\n    def getTagSet(self):\n        return self.tagSet\n\n    def getEffectiveTagSet(self):\n        return self.effectiveTagSet\n\n    def getTagMap(self):\n        return self.tagMap\n\n    def getSubtypeSpec(self):\n        return self.subtypeSpec\n\n    # backward compatibility\n    def hasValue(self):\n        return self.isValue\n\n# Backward compatibility\nAsn1ItemBase = Asn1Type\n\n\nclass NoValue(object):\n    \"\"\"Create a singleton instance of NoValue class.\n\n    The *NoValue* sentinel object represents an instance of ASN.1 schema\n    object as opposed to ASN.1 value object.\n\n    Only ASN.1 schema-related operations can be performed on ASN.1\n    schema objects.\n\n    Warning\n    -------\n    Any operation attempted on the *noValue* object will raise the\n    *PyAsn1Error* exception.\n    \"\"\"\n    skipMethods = {\n        '__slots__',\n        # attributes\n        '__getattribute__',\n        '__getattr__',\n        '__setattr__',\n        '__delattr__',\n        # class instance\n        '__class__',\n        '__init__',\n        '__del__',\n        '__new__',\n        '__repr__',\n        '__qualname__',\n        '__objclass__',\n        'im_class',\n        '__sizeof__',\n        # pickle protocol\n        '__reduce__',\n        '__reduce_ex__',\n        '__getnewargs__',\n        '__getinitargs__',\n        '__getstate__',\n        '__setstate__',\n    }\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            def getPlug(name):\n                def plug(self, *args, **kw):\n                    raise error.PyAsn1Error('Attempted \"%s\" operation on ASN.1 schema object' % name)\n                return plug\n\n            op_names = [name\n                        for typ in (str, int, list, dict)\n                        for name in dir(typ)\n                        if (name not in cls.skipMethods and\n                            name.startswith('__') and\n                            name.endswith('__') and\n                            callable(getattr(typ, name)))]\n\n            for name in set(op_names):\n                setattr(cls, name, getPlug(name))\n\n            cls._instance = object.__new__(cls)\n\n        return cls._instance\n\n    def __getattr__(self, attr):\n        if attr in self.skipMethods:\n            raise AttributeError('Attribute %s not present' % attr)\n\n        raise error.PyAsn1Error('Attempted \"%s\" operation on ASN.1 schema object' % attr)\n\n    def __repr__(self):\n        return '<%s object>' % self.__class__.__name__\n\n\nnoValue = NoValue()\n\n\nclass SimpleAsn1Type(Asn1Type):\n    \"\"\"Base class for all simple classes representing ASN.1 types.\n\n    ASN.1 distinguishes types by their ability to hold other objects.\n    Scalar types are known as *simple* in ASN.1.\n\n    In the user code, |ASN.1| class is normally used only for telling\n    ASN.1 objects from others.\n\n    Note\n    ----\n    For as long as ASN.1 is concerned, a way to compare ASN.1 types\n    is to use :meth:`isSameTypeWith` and :meth:`isSuperTypeOf` methods.\n    \"\"\"\n    #: Default payload value\n    defaultValue = noValue\n\n    def __init__(self, value=noValue, **kwargs):\n        Asn1Type.__init__(self, **kwargs)\n        if value is noValue:\n            value = self.defaultValue\n        else:\n            value = self.prettyIn(value)\n            try:\n                self.subtypeSpec(value)\n\n            except error.PyAsn1Error:\n                exType, exValue, exTb = sys.exc_info()\n                raise exType('%s at %s' % (exValue, self.__class__.__name__))\n\n        self._value = value\n\n    def __repr__(self):\n        representation = '%s %s object' % (\n            self.__class__.__name__, self.isValue and 'value' or 'schema')\n\n        for attr, value in self.readOnly.items():\n            if value:\n                representation += ', %s %s' % (attr, value)\n\n        if self.isValue:\n            value = self.prettyPrint()\n            if len(value) > 32:\n                value = value[:16] + '...' + value[-16:]\n            representation += ', payload [%s]' % value\n\n        return '<%s>' % representation\n\n    def __eq__(self, other):\n        return self is other and True or self._value == other\n\n    def __ne__(self, other):\n        return self._value != other\n\n    def __lt__(self, other):\n        return self._value < other\n\n    def __le__(self, other):\n        return self._value <= other\n\n    def __gt__(self, other):\n        return self._value > other\n\n    def __ge__(self, other):\n        return self._value >= other\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self._value and True or False\n    else:\n        def __bool__(self):\n            return self._value and True or False\n\n    def __hash__(self):\n        return hash(self._value)\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just\n        ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema\n        features, this object can also be used like a Python built-in object\n        (e.g. :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a normal value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n        \"\"\"\n        return self._value is not noValue\n\n    def clone(self, value=noValue, **kwargs):\n        \"\"\"Create a modified version of |ASN.1| schema or value object.\n\n        The `clone()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all arguments\n        of the `clone()` method are optional.\n\n        Whatever arguments are supplied, they are used to create a copy\n        of `self` taking precedence over the ones used to instantiate `self`.\n\n        Note\n        ----\n        Due to the immutable nature of the |ASN.1| object, if no arguments\n        are supplied, no new |ASN.1| object will be created and `self` will\n        be returned instead.\n        \"\"\"\n        if value is noValue:\n            if not kwargs:\n                return self\n\n            value = self._value\n\n        initializers = self.readOnly.copy()\n        initializers.update(kwargs)\n\n        return self.__class__(value, **initializers)\n\n    def subtype(self, value=noValue, **kwargs):\n        \"\"\"Create a specialization of |ASN.1| schema or value object.\n\n        The subtype relationship between ASN.1 types has no correlation with\n        subtype relationship between Python types. ASN.1 type is mainly identified\n        by its tag(s) (:py:class:`~pyasn1.type.tag.TagSet`) and value range\n        constraints (:py:class:`~pyasn1.type.constraint.ConstraintsIntersection`).\n        These ASN.1 type properties are implemented as |ASN.1| attributes.  \n\n        The `subtype()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all parameters\n        of the `subtype()` method are optional.\n\n        With the exception of the arguments described below, the rest of\n        supplied arguments they are used to create a copy of `self` taking\n        precedence over the ones used to instantiate `self`.\n\n        The following arguments to `subtype()` create a ASN.1 subtype out of\n        |ASN.1| type:\n\n        Other Parameters\n        ----------------\n        implicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Implicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        explicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Explicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n            Add ASN.1 constraints object to one of the `self`'s, then\n            use the result as new object's ASN.1 constraints.\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| schema or value object\n\n        Note\n        ----\n        Due to the immutable nature of the |ASN.1| object, if no arguments\n        are supplied, no new |ASN.1| object will be created and `self` will\n        be returned instead.\n        \"\"\"\n        if value is noValue:\n            if not kwargs:\n                return self\n\n            value = self._value\n\n        initializers = self.readOnly.copy()\n\n        implicitTag = kwargs.pop('implicitTag', None)\n        if implicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagImplicitly(implicitTag)\n\n        explicitTag = kwargs.pop('explicitTag', None)\n        if explicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagExplicitly(explicitTag)\n\n        for arg, option in kwargs.items():\n            initializers[arg] += option\n\n        return self.__class__(value, **initializers)\n\n    def prettyIn(self, value):\n        return value\n\n    def prettyOut(self, value):\n        return str(value)\n\n    def prettyPrint(self, scope=0):\n        return self.prettyOut(self._value)\n\n    def prettyPrintType(self, scope=0):\n        return '%s -> %s' % (self.tagSet, self.__class__.__name__)\n\n# Backward compatibility\nAbstractSimpleAsn1Item = SimpleAsn1Type\n\n#\n# Constructed types:\n# * There are five of them: Sequence, SequenceOf/SetOf, Set and Choice\n# * ASN1 types and values are represened by Python class instances\n# * Value initialization is made for defaulted components only\n# * Primary method of component addressing is by-position. Data model for base\n#   type is Python sequence. Additional type-specific addressing methods\n#   may be implemented for particular types.\n# * SequenceOf and SetOf types do not implement any additional methods\n# * Sequence, Set and Choice types also implement by-identifier addressing\n# * Sequence, Set and Choice types also implement by-asn1-type (tag) addressing\n# * Sequence and Set types may include optional and defaulted\n#   components\n# * Constructed types hold a reference to component types used for value\n#   verification and ordering.\n# * Component type is a scalar type for SequenceOf/SetOf types and a list\n#   of types for Sequence/Set/Choice.\n#\n\n\nclass ConstructedAsn1Type(Asn1Type):\n    \"\"\"Base class for all constructed classes representing ASN.1 types.\n\n    ASN.1 distinguishes types by their ability to hold other objects.\n    Those \"nesting\" types are known as *constructed* in ASN.1.\n\n    In the user code, |ASN.1| class is normally used only for telling\n    ASN.1 objects from others.\n\n    Note\n    ----\n    For as long as ASN.1 is concerned, a way to compare ASN.1 types\n    is to use :meth:`isSameTypeWith` and :meth:`isSuperTypeOf` methods.\n    \"\"\"\n\n    #: If :obj:`True`, requires exact component type matching,\n    #: otherwise subtype relation is only enforced\n    strictConstraints = False\n\n    componentType = None\n\n    # backward compatibility, unused\n    sizeSpec = constraint.ConstraintsIntersection()\n\n    def __init__(self, **kwargs):\n        readOnly = {\n            'componentType': self.componentType,\n            # backward compatibility, unused\n            'sizeSpec': self.sizeSpec\n        }\n\n        # backward compatibility: preserve legacy sizeSpec support\n        kwargs = self._moveSizeSpec(**kwargs)\n\n        readOnly.update(kwargs)\n\n        Asn1Type.__init__(self, **readOnly)\n\n    def _moveSizeSpec(self, **kwargs):\n        # backward compatibility, unused\n        sizeSpec = kwargs.pop('sizeSpec', self.sizeSpec)\n        if sizeSpec:\n            subtypeSpec = kwargs.pop('subtypeSpec', self.subtypeSpec)\n            if subtypeSpec:\n                subtypeSpec = sizeSpec\n\n            else:\n                subtypeSpec += sizeSpec\n\n            kwargs['subtypeSpec'] = subtypeSpec\n\n        return kwargs\n\n    def __repr__(self):\n        representation = '%s %s object' % (\n            self.__class__.__name__, self.isValue and 'value' or 'schema'\n        )\n\n        for attr, value in self.readOnly.items():\n            if value is not noValue:\n                representation += ', %s=%r' % (attr, value)\n\n        if self.isValue and self.components:\n            representation += ', payload [%s]' % ', '.join(\n                [repr(x) for x in self.components])\n\n        return '<%s>' % representation\n\n    def __eq__(self, other):\n        return self is other or self.components == other\n\n    def __ne__(self, other):\n        return self.components != other\n\n    def __lt__(self, other):\n        return self.components < other\n\n    def __le__(self, other):\n        return self.components <= other\n\n    def __gt__(self, other):\n        return self.components > other\n\n    def __ge__(self, other):\n        return self.components >= other\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return bool(self.components)\n    else:\n        def __bool__(self):\n            return bool(self.components)\n\n    @property\n    def components(self):\n        raise error.PyAsn1Error('Method not implemented')\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        pass\n\n    def clone(self, **kwargs):\n        \"\"\"Create a modified version of |ASN.1| schema object.\n\n        The `clone()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all arguments\n        of the `clone()` method are optional.\n\n        Whatever arguments are supplied, they are used to create a copy\n        of `self` taking precedence over the ones used to instantiate `self`.\n\n        Possible values of `self` are never copied over thus `clone()` can\n        only create a new schema object.\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| type/value\n\n        Note\n        ----\n        Due to the mutable nature of the |ASN.1| object, even if no arguments\n        are supplied, a new |ASN.1| object will be created and returned.\n        \"\"\"\n        cloneValueFlag = kwargs.pop('cloneValueFlag', False)\n\n        initializers = self.readOnly.copy()\n        initializers.update(kwargs)\n\n        clone = self.__class__(**initializers)\n\n        if cloneValueFlag:\n            self._cloneComponentValues(clone, cloneValueFlag)\n\n        return clone\n\n    def subtype(self, **kwargs):\n        \"\"\"Create a specialization of |ASN.1| schema object.\n\n        The `subtype()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all parameters\n        of the `subtype()` method are optional.\n\n        With the exception of the arguments described below, the rest of\n        supplied arguments they are used to create a copy of `self` taking\n        precedence over the ones used to instantiate `self`.\n\n        The following arguments to `subtype()` create a ASN.1 subtype out of\n        |ASN.1| type.\n\n        Other Parameters\n        ----------------\n        implicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Implicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        explicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Explicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n            Add ASN.1 constraints object to one of the `self`'s, then\n            use the result as new object's ASN.1 constraints.\n\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| type/value\n\n        Note\n        ----\n        Due to the mutable nature of the |ASN.1| object, even if no arguments\n        are supplied, a new |ASN.1| object will be created and returned.\n        \"\"\"\n\n        initializers = self.readOnly.copy()\n\n        cloneValueFlag = kwargs.pop('cloneValueFlag', False)\n\n        implicitTag = kwargs.pop('implicitTag', None)\n        if implicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagImplicitly(implicitTag)\n\n        explicitTag = kwargs.pop('explicitTag', None)\n        if explicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagExplicitly(explicitTag)\n\n        for arg, option in kwargs.items():\n            initializers[arg] += option\n\n        clone = self.__class__(**initializers)\n\n        if cloneValueFlag:\n            self._cloneComponentValues(clone, cloneValueFlag)\n\n        return clone\n\n    def getComponentByPosition(self, idx):\n        raise error.PyAsn1Error('Method not implemented')\n\n    def setComponentByPosition(self, idx, value, verifyConstraints=True):\n        raise error.PyAsn1Error('Method not implemented')\n\n    def setComponents(self, *args, **kwargs):\n        for idx, value in enumerate(args):\n            self[idx] = value\n        for k in kwargs:\n            self[k] = kwargs[k]\n        return self\n\n    # backward compatibility\n\n    def setDefaultComponents(self):\n        pass\n\n    def getComponentType(self):\n        return self.componentType\n\n    # backward compatibility, unused\n    def verifySizeSpec(self):\n        self.subtypeSpec(self)\n\n\n        # Backward compatibility\nAbstractConstructedAsn1Item = ConstructedAsn1Type\n", "pyasn1/type/opentype.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n\n__all__ = ['OpenType']\n\n\nclass OpenType(object):\n    \"\"\"Create ASN.1 type map indexed by a value\n\n    The *OpenType* object models an untyped field of a constructed ASN.1\n    type. In ASN.1 syntax it is usually represented by the\n    `ANY DEFINED BY` for scalars or `SET OF ANY DEFINED BY`,\n    `SEQUENCE OF ANY DEFINED BY` for container types clauses. Typically\n    used together with :class:`~pyasn1.type.univ.Any` object.\n\n    OpenType objects duck-type a read-only Python :class:`dict` objects,\n    however the passed `typeMap` is not copied, but stored by reference.\n    That means the user can manipulate `typeMap` at run time having this\n    reflected on *OpenType* object behavior.\n\n    The |OpenType| class models an untyped field of a constructed ASN.1\n    type. In ASN.1 syntax it is usually represented by the\n    `ANY DEFINED BY` for scalars or `SET OF ANY DEFINED BY`,\n    `SEQUENCE OF ANY DEFINED BY` for container types clauses. Typically\n    used with :class:`~pyasn1.type.univ.Any` type.\n\n    Parameters\n    ----------\n    name: :py:class:`str`\n        Field name\n\n    typeMap: :py:class:`dict`\n        A map of value->ASN.1 type. It's stored by reference and can be\n        mutated later to register new mappings.\n\n    Examples\n    --------\n\n    For untyped scalars:\n\n    .. code-block:: python\n\n        openType = OpenType(\n            'id', {1: Integer(),\n                   2: OctetString()}\n        )\n        Sequence(\n            componentType=NamedTypes(\n                NamedType('id', Integer()),\n                NamedType('blob', Any(), openType=openType)\n            )\n        )\n\n    For untyped `SET OF` or `SEQUENCE OF` vectors:\n\n    .. code-block:: python\n\n        openType = OpenType(\n            'id', {1: Integer(),\n                   2: OctetString()}\n        )\n        Sequence(\n            componentType=NamedTypes(\n                NamedType('id', Integer()),\n                NamedType('blob', SetOf(componentType=Any()),\n                          openType=openType)\n            )\n        )\n    \"\"\"\n\n    def __init__(self, name, typeMap=None):\n        self.__name = name\n        if typeMap is None:\n            self.__typeMap = {}\n        else:\n            self.__typeMap = typeMap\n\n    @property\n    def name(self):\n        return self.__name\n\n    # Python dict protocol\n\n    def values(self):\n        return self.__typeMap.values()\n\n    def keys(self):\n        return self.__typeMap.keys()\n\n    def items(self):\n        return self.__typeMap.items()\n\n    def __contains__(self, key):\n        return key in self.__typeMap\n\n    def __getitem__(self, key):\n        return self.__typeMap[key]\n\n    def __iter__(self):\n        return iter(self.__typeMap)\n", "pyasn1/type/namedtype.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\n\n__all__ = ['NamedType', 'OptionalNamedType', 'DefaultedNamedType',\n           'NamedTypes']\n\ntry:\n    any\n\nexcept NameError:\n    any = lambda x: bool(filter(bool, x))\n\n\nclass NamedType(object):\n    \"\"\"Create named field object for a constructed ASN.1 type.\n\n    The |NamedType| object represents a single name and ASN.1 type of a constructed ASN.1 type.\n\n    |NamedType| objects are immutable and duck-type Python :class:`tuple` objects\n    holding *name* and *asn1Object* components.\n\n    Parameters\n    ----------\n    name: :py:class:`str`\n        Field name\n\n    asn1Object:\n        ASN.1 type object\n    \"\"\"\n    isOptional = False\n    isDefaulted = False\n\n    def __init__(self, name, asn1Object, openType=None):\n        self.__name = name\n        self.__type = asn1Object\n        self.__nameAndType = name, asn1Object\n        self.__openType = openType\n\n    def __repr__(self):\n        representation = '%s=%r' % (self.name, self.asn1Object)\n\n        if self.openType:\n            representation += ', open type %r' % self.openType\n\n        return '<%s object, type %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return self.__nameAndType == other\n\n    def __ne__(self, other):\n        return self.__nameAndType != other\n\n    def __lt__(self, other):\n        return self.__nameAndType < other\n\n    def __le__(self, other):\n        return self.__nameAndType <= other\n\n    def __gt__(self, other):\n        return self.__nameAndType > other\n\n    def __ge__(self, other):\n        return self.__nameAndType >= other\n\n    def __hash__(self):\n        return hash(self.__nameAndType)\n\n    def __getitem__(self, idx):\n        return self.__nameAndType[idx]\n\n    def __iter__(self):\n        return iter(self.__nameAndType)\n\n    @property\n    def name(self):\n        return self.__name\n\n    @property\n    def asn1Object(self):\n        return self.__type\n\n    @property\n    def openType(self):\n        return self.__openType\n\n    # Backward compatibility\n\n    def getName(self):\n        return self.name\n\n    def getType(self):\n        return self.asn1Object\n\n\nclass OptionalNamedType(NamedType):\n    __doc__ = NamedType.__doc__\n\n    isOptional = True\n\n\nclass DefaultedNamedType(NamedType):\n    __doc__ = NamedType.__doc__\n\n    isDefaulted = True\n\n\nclass NamedTypes(object):\n    \"\"\"Create a collection of named fields for a constructed ASN.1 type.\n\n    The NamedTypes object represents a collection of named fields of a constructed ASN.1 type.\n\n    *NamedTypes* objects are immutable and duck-type Python :class:`dict` objects\n    holding *name* as keys and ASN.1 type object as values.\n\n    Parameters\n    ----------\n    *namedTypes: :class:`~pyasn1.type.namedtype.NamedType`\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Description(Sequence):\n            '''\n            ASN.1 specification:\n\n            Description ::= SEQUENCE {\n                surname    IA5String,\n                first-name IA5String OPTIONAL,\n                age        INTEGER DEFAULT 40\n            }\n            '''\n            componentType = NamedTypes(\n                NamedType('surname', IA5String()),\n                OptionalNamedType('first-name', IA5String()),\n                DefaultedNamedType('age', Integer(40))\n            )\n\n        descr = Description()\n        descr['surname'] = 'Smith'\n        descr['first-name'] = 'John'\n    \"\"\"\n    def __init__(self, *namedTypes, **kwargs):\n        self.__namedTypes = namedTypes\n        self.__namedTypesLen = len(self.__namedTypes)\n        self.__minTagSet = self.__computeMinTagSet()\n        self.__nameToPosMap = self.__computeNameToPosMap()\n        self.__tagToPosMap = self.__computeTagToPosMap()\n        self.__ambiguousTypes = 'terminal' not in kwargs and self.__computeAmbiguousTypes() or {}\n        self.__uniqueTagMap = self.__computeTagMaps(unique=True)\n        self.__nonUniqueTagMap = self.__computeTagMaps(unique=False)\n        self.__hasOptionalOrDefault = any([True for namedType in self.__namedTypes\n                                           if namedType.isDefaulted or namedType.isOptional])\n        self.__hasOpenTypes = any([True for namedType in self.__namedTypes\n                                   if namedType.openType])\n\n        self.__requiredComponents = frozenset(\n                [idx for idx, nt in enumerate(self.__namedTypes) if not nt.isOptional and not nt.isDefaulted]\n            )\n        self.__keys = frozenset([namedType.name for namedType in self.__namedTypes])\n        self.__values = tuple([namedType.asn1Object for namedType in self.__namedTypes])\n        self.__items = tuple([(namedType.name, namedType.asn1Object) for namedType in self.__namedTypes])\n\n    def __repr__(self):\n        representation = ', '.join(['%r' % x for x in self.__namedTypes])\n        return '<%s object, types %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return self.__namedTypes == other\n\n    def __ne__(self, other):\n        return self.__namedTypes != other\n\n    def __lt__(self, other):\n        return self.__namedTypes < other\n\n    def __le__(self, other):\n        return self.__namedTypes <= other\n\n    def __gt__(self, other):\n        return self.__namedTypes > other\n\n    def __ge__(self, other):\n        return self.__namedTypes >= other\n\n    def __hash__(self):\n        return hash(self.__namedTypes)\n\n    def __getitem__(self, idx):\n        try:\n            return self.__namedTypes[idx]\n\n        except TypeError:\n            return self.__namedTypes[self.__nameToPosMap[idx]]\n\n    def __contains__(self, key):\n        return key in self.__nameToPosMap\n\n    def __iter__(self):\n        return (x[0] for x in self.__namedTypes)\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self.__namedTypesLen > 0\n    else:\n        def __bool__(self):\n            return self.__namedTypesLen > 0\n\n    def __len__(self):\n        return self.__namedTypesLen\n\n    # Python dict protocol\n\n    def values(self):\n        return self.__values\n\n    def keys(self):\n        return self.__keys\n\n    def items(self):\n        return self.__items\n\n    def clone(self):\n        return self.__class__(*self.__namedTypes)\n\n    class PostponedError(object):\n        def __init__(self, errorMsg):\n            self.__errorMsg = errorMsg\n\n        def __getitem__(self, item):\n            raise  error.PyAsn1Error(self.__errorMsg)\n\n    def __computeTagToPosMap(self):\n        tagToPosMap = {}\n        for idx, namedType in enumerate(self.__namedTypes):\n            tagMap = namedType.asn1Object.tagMap\n            if isinstance(tagMap, NamedTypes.PostponedError):\n                return tagMap\n            if not tagMap:\n                continue\n            for _tagSet in tagMap.presentTypes:\n                if _tagSet in tagToPosMap:\n                    return NamedTypes.PostponedError('Duplicate component tag %s at %s' % (_tagSet, namedType))\n                tagToPosMap[_tagSet] = idx\n\n        return tagToPosMap\n\n    def __computeNameToPosMap(self):\n        nameToPosMap = {}\n        for idx, namedType in enumerate(self.__namedTypes):\n            if namedType.name in nameToPosMap:\n                return NamedTypes.PostponedError('Duplicate component name %s at %s' % (namedType.name, namedType))\n            nameToPosMap[namedType.name] = idx\n\n        return nameToPosMap\n\n    def __computeAmbiguousTypes(self):\n        ambiguousTypes = {}\n        partialAmbiguousTypes = ()\n        for idx, namedType in reversed(tuple(enumerate(self.__namedTypes))):\n            if namedType.isOptional or namedType.isDefaulted:\n                partialAmbiguousTypes = (namedType,) + partialAmbiguousTypes\n            else:\n                partialAmbiguousTypes = (namedType,)\n            if len(partialAmbiguousTypes) == len(self.__namedTypes):\n                ambiguousTypes[idx] = self\n            else:\n                ambiguousTypes[idx] = NamedTypes(*partialAmbiguousTypes, **dict(terminal=True))\n        return ambiguousTypes\n\n    def getTypeByPosition(self, idx):\n        \"\"\"Return ASN.1 type object by its position in fields set.\n\n        Parameters\n        ----------\n        idx: :py:class:`int`\n            Field index\n\n        Returns\n        -------\n        :\n            ASN.1 type\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If given position is out of fields range\n        \"\"\"\n        try:\n            return self.__namedTypes[idx].asn1Object\n\n        except IndexError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def getPositionByType(self, tagSet):\n        \"\"\"Return field position by its ASN.1 type.\n\n        Parameters\n        ----------\n        tagSet: :class:`~pysnmp.type.tag.TagSet`\n            ASN.1 tag set distinguishing one ASN.1 type from others.\n\n        Returns\n        -------\n        : :py:class:`int`\n            ASN.1 type position in fields set\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If *tagSet* is not present or ASN.1 types are not unique within callee *NamedTypes*\n        \"\"\"\n        try:\n            return self.__tagToPosMap[tagSet]\n\n        except KeyError:\n            raise error.PyAsn1Error('Type %s not found' % (tagSet,))\n\n    def getNameByPosition(self, idx):\n        \"\"\"Return field name by its position in fields set.\n\n        Parameters\n        ----------\n        idx: :py:class:`idx`\n            Field index\n\n        Returns\n        -------\n        : :py:class:`str`\n            Field name\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If given field name is not present in callee *NamedTypes*\n        \"\"\"\n        try:\n            return self.__namedTypes[idx].name\n\n        except IndexError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def getPositionByName(self, name):\n        \"\"\"Return field position by filed name.\n\n        Parameters\n        ----------\n        name: :py:class:`str`\n            Field name\n\n        Returns\n        -------\n        : :py:class:`int`\n            Field position in fields set\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If *name* is not present or not unique within callee *NamedTypes*\n        \"\"\"\n        try:\n            return self.__nameToPosMap[name]\n\n        except KeyError:\n            raise error.PyAsn1Error('Name %s not found' % (name,))\n\n    def getTagMapNearPosition(self, idx):\n        \"\"\"Return ASN.1 types that are allowed at or past given field position.\n\n        Some ASN.1 serialisation allow for skipping optional and defaulted fields.\n        Some constructed ASN.1 types allow reordering of the fields. When recovering\n        such objects it may be important to know which types can possibly be\n        present at any given position in the field sets.\n\n        Parameters\n        ----------\n        idx: :py:class:`int`\n            Field index\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tagmap.TagMap`\n            Map if ASN.1 types allowed at given field position\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If given position is out of fields range\n        \"\"\"\n        try:\n            return self.__ambiguousTypes[idx].tagMap\n\n        except KeyError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def getPositionNearType(self, tagSet, idx):\n        \"\"\"Return the closest field position where given ASN.1 type is allowed.\n\n        Some ASN.1 serialisation allow for skipping optional and defaulted fields.\n        Some constructed ASN.1 types allow reordering of the fields. When recovering\n        such objects it may be important to know at which field position, in field set,\n        given *tagSet* is allowed at or past *idx* position.\n\n        Parameters\n        ----------\n        tagSet: :class:`~pyasn1.type.tag.TagSet`\n           ASN.1 type which field position to look up\n\n        idx: :py:class:`int`\n            Field position at or past which to perform ASN.1 type look up\n\n        Returns\n        -------\n        : :py:class:`int`\n            Field position in fields set\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If *tagSet* is not present or not unique within callee *NamedTypes*\n            or *idx* is out of fields range\n        \"\"\"\n        try:\n            return idx + self.__ambiguousTypes[idx].getPositionByType(tagSet)\n\n        except KeyError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def __computeMinTagSet(self):\n        minTagSet = None\n        for namedType in self.__namedTypes:\n            asn1Object = namedType.asn1Object\n\n            try:\n                tagSet = asn1Object.minTagSet\n\n            except AttributeError:\n                tagSet = asn1Object.tagSet\n\n            if minTagSet is None or tagSet < minTagSet:\n                minTagSet = tagSet\n\n        return minTagSet or tag.TagSet()\n\n    @property\n    def minTagSet(self):\n        \"\"\"Return the minimal TagSet among ASN.1 type in callee *NamedTypes*.\n\n        Some ASN.1 types/serialisation protocols require ASN.1 types to be\n        arranged based on their numerical tag value. The *minTagSet* property\n        returns that.\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tagset.TagSet`\n            Minimal TagSet among ASN.1 types in callee *NamedTypes*\n        \"\"\"\n        return self.__minTagSet\n\n    def __computeTagMaps(self, unique):\n        presentTypes = {}\n        skipTypes = {}\n        defaultType = None\n        for namedType in self.__namedTypes:\n            tagMap = namedType.asn1Object.tagMap\n            if isinstance(tagMap, NamedTypes.PostponedError):\n                return tagMap\n            for tagSet in tagMap:\n                if unique and tagSet in presentTypes:\n                    return NamedTypes.PostponedError('Non-unique tagSet %s of %s at %s' % (tagSet, namedType, self))\n                presentTypes[tagSet] = namedType.asn1Object\n            skipTypes.update(tagMap.skipTypes)\n\n            if defaultType is None:\n                defaultType = tagMap.defaultType\n            elif tagMap.defaultType is not None:\n                return NamedTypes.PostponedError('Duplicate default ASN.1 type at %s' % (self,))\n\n        return tagmap.TagMap(presentTypes, skipTypes, defaultType)\n\n    @property\n    def tagMap(self):\n        \"\"\"Return a *TagMap* object from tags and types recursively.\n\n        Return a :class:`~pyasn1.type.tagmap.TagMap` object by\n        combining tags from *TagMap* objects of children types and\n        associating them with their immediate child type.\n\n        Example\n        -------\n        .. code-block:: python\n\n           OuterType ::= CHOICE {\n               innerType INTEGER\n           }\n\n        Calling *.tagMap* on *OuterType* will yield a map like this:\n\n        .. code-block:: python\n\n           Integer.tagSet -> Choice\n        \"\"\"\n        return self.__nonUniqueTagMap\n\n    @property\n    def tagMapUnique(self):\n        \"\"\"Return a *TagMap* object from unique tags and types recursively.\n\n        Return a :class:`~pyasn1.type.tagmap.TagMap` object by\n        combining tags from *TagMap* objects of children types and\n        associating them with their immediate child type.\n\n        Example\n        -------\n        .. code-block:: python\n\n           OuterType ::= CHOICE {\n               innerType INTEGER\n           }\n\n        Calling *.tagMapUnique* on *OuterType* will yield a map like this:\n\n        .. code-block:: python\n\n           Integer.tagSet -> Choice\n\n        Note\n        ----\n\n        Duplicate *TagSet* objects found in the tree of children\n        types would cause error.\n        \"\"\"\n        return self.__uniqueTagMap\n\n    @property\n    def hasOptionalOrDefault(self):\n        return self.__hasOptionalOrDefault\n\n    @property\n    def hasOpenTypes(self):\n        return self.__hasOpenTypes\n\n    @property\n    def namedTypes(self):\n        return tuple(self.__namedTypes)\n\n    @property\n    def requiredComponents(self):\n        return self.__requiredComponents\n", "pyasn1/type/error.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1.error import PyAsn1Error\n\n\nclass ValueConstraintError(PyAsn1Error):\n    pass\n", "pyasn1/type/char.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\n\n__all__ = ['NumericString', 'PrintableString', 'TeletexString', 'T61String', 'VideotexString',\n           'IA5String', 'GraphicString', 'VisibleString', 'ISO646String',\n           'GeneralString', 'UniversalString', 'BMPString', 'UTF8String']\n\nNoValue = univ.NoValue\nnoValue = univ.noValue\n\n\nclass AbstractCharacterString(univ.OctetString):\n    \"\"\"Creates |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`,\n    its objects are immutable and duck-type Python 2 :class:`str` or Python 3\n    :class:`bytes`. When used in octet-stream context, |ASN.1| type assumes\n    \"|encoding|\" encoding.\n\n    Keyword Args\n    ------------\n    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object\n        :class:`unicode` object (Python 2) or :class:`str` (Python 3),\n        alternatively :class:`str` (Python 2) or :class:`bytes` (Python 3)\n        representing octet-stream of serialised unicode string\n        (note `encoding` parameter) or |ASN.1| class instance.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    encoding: :py:class:`str`\n        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or\n        :class:`str` (Python 3) the payload when |ASN.1| object is used\n        in octet-stream context.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n    \"\"\"\n\n    if sys.version_info[0] <= 2:\n        def __str__(self):\n            try:\n                # `str` is Py2 text representation\n                return self._value.encode(self.encoding)\n\n            except UnicodeEncodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeEncodeError(\n                    \"Can't encode string '%s' with codec \"\n                    \"%s\" % (self._value, self.encoding), exc\n                )\n\n        def __unicode__(self):\n            return unicode(self._value)\n\n        def prettyIn(self, value):\n            try:\n                if isinstance(value, unicode):\n                    return value\n                elif isinstance(value, str):\n                    return value.decode(self.encoding)\n                elif isinstance(value, (tuple, list)):\n                    return self.prettyIn(''.join([chr(x) for x in value]))\n                elif isinstance(value, univ.OctetString):\n                    return value.asOctets().decode(self.encoding)\n                else:\n                    return unicode(value)\n\n            except (UnicodeDecodeError, LookupError):\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with codec \"\n                    \"%s\" % (value, self.encoding), exc\n                )\n\n        def asOctets(self, padding=True):\n            return str(self)\n\n        def asNumbers(self, padding=True):\n            return tuple([ord(x) for x in str(self)])\n\n    else:\n        def __str__(self):\n            # `unicode` is Py3 text representation\n            return str(self._value)\n\n        def __bytes__(self):\n            try:\n                return self._value.encode(self.encoding)\n            except UnicodeEncodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeEncodeError(\n                    \"Can't encode string '%s' with codec \"\n                    \"%s\" % (self._value, self.encoding), exc\n                )\n\n        def prettyIn(self, value):\n            try:\n                if isinstance(value, str):\n                    return value\n                elif isinstance(value, bytes):\n                    return value.decode(self.encoding)\n                elif isinstance(value, (tuple, list)):\n                    return self.prettyIn(bytes(value))\n                elif isinstance(value, univ.OctetString):\n                    return value.asOctets().decode(self.encoding)\n                else:\n                    return str(value)\n\n            except (UnicodeDecodeError, LookupError):\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with codec \"\n                    \"%s\" % (value, self.encoding), exc\n                )\n\n        def asOctets(self, padding=True):\n            return bytes(self)\n\n        def asNumbers(self, padding=True):\n            return tuple(bytes(self))\n\n    #\n    # See OctetString.prettyPrint() for the explanation\n    #\n\n    def prettyOut(self, value):\n        return value\n\n    def prettyPrint(self, scope=0):\n        # first see if subclass has its own .prettyOut()\n        value = self.prettyOut(self._value)\n\n        if value is not self._value:\n            return value\n\n        return AbstractCharacterString.__str__(self)\n\n    def __reversed__(self):\n        return reversed(self._value)\n\n\nclass NumericString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 18)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass PrintableString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 19)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass TeletexString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 20)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass T61String(TeletexString):\n    __doc__ = TeletexString.__doc__\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass VideotexString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 21)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass IA5String(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 22)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass GraphicString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 25)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass VisibleString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 26)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass ISO646String(VisibleString):\n    __doc__ = VisibleString.__doc__\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\nclass GeneralString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 27)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass UniversalString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 28)\n    )\n    encoding = \"utf-32-be\"\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass BMPString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 30)\n    )\n    encoding = \"utf-16-be\"\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass UTF8String(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)\n    )\n    encoding = \"utf-8\"\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n", "pyasn1/type/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/type/namedval.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n# ASN.1 named integers\n#\nfrom pyasn1 import error\n\n__all__ = ['NamedValues']\n\n\nclass NamedValues(object):\n    \"\"\"Create named values object.\n\n    The |NamedValues| object represents a collection of string names\n    associated with numeric IDs. These objects are used for giving\n    names to otherwise numerical values.\n\n    |NamedValues| objects are immutable and duck-type Python\n    :class:`dict` object mapping ID to name and vice-versa.\n\n    Parameters\n    ----------\n    *args: variable number of two-element :py:class:`tuple`\n\n        name: :py:class:`str`\n            Value label\n\n        value: :py:class:`int`\n            Numeric value\n\n    Keyword Args\n    ------------\n    name: :py:class:`str`\n        Value label\n\n    value: :py:class:`int`\n        Numeric value\n\n    Examples\n    --------\n\n    .. code-block:: pycon\n\n        >>> nv = NamedValues('a', 'b', ('c', 0), d=1)\n        >>> nv\n        >>> {'c': 0, 'd': 1, 'a': 2, 'b': 3}\n        >>> nv[0]\n        'c'\n        >>> nv['a']\n        2\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.__names = {}\n        self.__numbers = {}\n\n        anonymousNames = []\n\n        for namedValue in args:\n            if isinstance(namedValue, (tuple, list)):\n                try:\n                    name, number = namedValue\n\n                except ValueError:\n                    raise error.PyAsn1Error('Not a proper attribute-value pair %r' % (namedValue,))\n\n            else:\n                anonymousNames.append(namedValue)\n                continue\n\n            if name in self.__names:\n                raise error.PyAsn1Error('Duplicate name %s' % (name,))\n\n            if number in self.__numbers:\n                raise error.PyAsn1Error('Duplicate number  %s=%s' % (name, number))\n\n            self.__names[name] = number\n            self.__numbers[number] = name\n\n        for name, number in kwargs.items():\n            if name in self.__names:\n                raise error.PyAsn1Error('Duplicate name %s' % (name,))\n\n            if number in self.__numbers:\n                raise error.PyAsn1Error('Duplicate number  %s=%s' % (name, number))\n\n            self.__names[name] = number\n            self.__numbers[number] = name\n\n        if anonymousNames:\n\n            number = self.__numbers and max(self.__numbers) + 1 or 0\n\n            for name in anonymousNames:\n\n                if name in self.__names:\n                    raise error.PyAsn1Error('Duplicate name %s' % (name,))\n\n                self.__names[name] = number\n                self.__numbers[number] = name\n\n                number += 1\n\n    def __repr__(self):\n        representation = ', '.join(['%s=%d' % x for x in self.items()])\n\n        if len(representation) > 64:\n            representation = representation[:32] + '...' + representation[-32:]\n\n        return '<%s object, enums %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return dict(self) == other\n\n    def __ne__(self, other):\n        return dict(self) != other\n\n    def __lt__(self, other):\n        return dict(self) < other\n\n    def __le__(self, other):\n        return dict(self) <= other\n\n    def __gt__(self, other):\n        return dict(self) > other\n\n    def __ge__(self, other):\n        return dict(self) >= other\n\n    def __hash__(self):\n        return hash(self.items())\n\n    # Python dict protocol (read-only)\n\n    def __getitem__(self, key):\n        try:\n            return self.__numbers[key]\n\n        except KeyError:\n            return self.__names[key]\n\n    def __len__(self):\n        return len(self.__names)\n\n    def __contains__(self, key):\n        return key in self.__names or key in self.__numbers\n\n    def __iter__(self):\n        return iter(self.__names)\n\n    def values(self):\n        return iter(self.__numbers)\n\n    def keys(self):\n        return iter(self.__names)\n\n    def items(self):\n        for name in self.__names:\n            yield name, self.__names[name]\n\n    # support merging\n\n    def __add__(self, namedValues):\n        return self.__class__(*tuple(self.items()) + tuple(namedValues.items()))\n\n    # XXX clone/subtype?\n\n    def clone(self, *args, **kwargs):\n        new = self.__class__(*args, **kwargs)\n        return self + new\n\n    # legacy protocol\n\n    def getName(self, value):\n        if value in self.__numbers:\n            return self.__numbers[value]\n\n    def getValue(self, name):\n        if name in self.__names:\n            return self.__names[name]\n\n    def getValues(self, *names):\n        try:\n            return [self.__names[name] for name in names]\n\n        except KeyError:\n            raise error.PyAsn1Error(\n                'Unknown bit identifier(s): %s' % (set(names).difference(self.__names),)\n            )\n", "pyasn1/type/univ.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport math\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.compat import integer\nfrom pyasn1.compat import octets\nfrom pyasn1.type import base\nfrom pyasn1.type import constraint\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import namedval\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\n\nNoValue = base.NoValue\nnoValue = NoValue()\n\n__all__ = ['Integer', 'Boolean', 'BitString', 'OctetString', 'Null',\n           'ObjectIdentifier', 'Real', 'Enumerated',\n           'SequenceOfAndSetOfBase', 'SequenceOf', 'SetOf',\n           'SequenceAndSetBase', 'Sequence', 'Set', 'Choice', 'Any',\n           'NoValue', 'noValue']\n\n# \"Simple\" ASN.1 types (yet incomplete)\n\n\nclass Integer(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal or |ASN.1| class\n        instance. If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class ErrorCode(Integer):\n            '''\n            ASN.1 specification:\n\n            ErrorCode ::=\n                INTEGER { disk-full(1), no-disk(-1),\n                          disk-not-formatted(2) }\n\n            error ErrorCode ::= disk-full\n            '''\n            namedValues = NamedValues(\n                ('disk-full', 1), ('no-disk', -1),\n                ('disk-not-formatted', 2)\n            )\n\n        error = ErrorCode('disk-full')\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x02)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    def __init__(self, value=noValue, **kwargs):\n        if 'namedValues' not in kwargs:\n            kwargs['namedValues'] = self.namedValues\n\n        base.SimpleAsn1Type.__init__(self, value, **kwargs)\n\n    def __and__(self, value):\n        return self.clone(self._value & value)\n\n    def __rand__(self, value):\n        return self.clone(value & self._value)\n\n    def __or__(self, value):\n        return self.clone(self._value | value)\n\n    def __ror__(self, value):\n        return self.clone(value | self._value)\n\n    def __xor__(self, value):\n        return self.clone(self._value ^ value)\n\n    def __rxor__(self, value):\n        return self.clone(value ^ self._value)\n\n    def __lshift__(self, value):\n        return self.clone(self._value << value)\n\n    def __rshift__(self, value):\n        return self.clone(self._value >> value)\n\n    def __add__(self, value):\n        return self.clone(self._value + value)\n\n    def __radd__(self, value):\n        return self.clone(value + self._value)\n\n    def __sub__(self, value):\n        return self.clone(self._value - value)\n\n    def __rsub__(self, value):\n        return self.clone(value - self._value)\n\n    def __mul__(self, value):\n        return self.clone(self._value * value)\n\n    def __rmul__(self, value):\n        return self.clone(value * self._value)\n\n    def __mod__(self, value):\n        return self.clone(self._value % value)\n\n    def __rmod__(self, value):\n        return self.clone(value % self._value)\n\n    def __pow__(self, value, modulo=None):\n        return self.clone(pow(self._value, value, modulo))\n\n    def __rpow__(self, value):\n        return self.clone(pow(value, self._value))\n\n    def __floordiv__(self, value):\n        return self.clone(self._value // value)\n\n    def __rfloordiv__(self, value):\n        return self.clone(value // self._value)\n\n    if sys.version_info[0] <= 2:\n        def __div__(self, value):\n            if isinstance(value, float):\n                return Real(self._value / value)\n            else:\n                return self.clone(self._value / value)\n\n        def __rdiv__(self, value):\n            if isinstance(value, float):\n                return Real(value / self._value)\n            else:\n                return self.clone(value / self._value)\n    else:\n        def __truediv__(self, value):\n            return Real(self._value / value)\n\n        def __rtruediv__(self, value):\n            return Real(value / self._value)\n\n        def __divmod__(self, value):\n            return self.clone(divmod(self._value, value))\n\n        def __rdivmod__(self, value):\n            return self.clone(divmod(value, self._value))\n\n        __hash__ = base.SimpleAsn1Type.__hash__\n\n    def __int__(self):\n        return int(self._value)\n\n    if sys.version_info[0] <= 2:\n        def __long__(self):\n            return long(self._value)\n\n    def __float__(self):\n        return float(self._value)\n\n    def __abs__(self):\n        return self.clone(abs(self._value))\n\n    def __index__(self):\n        return int(self._value)\n\n    def __pos__(self):\n        return self.clone(+self._value)\n\n    def __neg__(self):\n        return self.clone(-self._value)\n\n    def __invert__(self):\n        return self.clone(~self._value)\n\n    def __round__(self, n=0):\n        r = round(self._value, n)\n        if n:\n            return self.clone(r)\n        else:\n            return r\n\n    def __floor__(self):\n        return math.floor(self._value)\n\n    def __ceil__(self):\n        return math.ceil(self._value)\n\n    def __trunc__(self):\n        return self.clone(math.trunc(self._value))\n\n    def __lt__(self, value):\n        return self._value < value\n\n    def __le__(self, value):\n        return self._value <= value\n\n    def __eq__(self, value):\n        return self._value == value\n\n    def __ne__(self, value):\n        return self._value != value\n\n    def __gt__(self, value):\n        return self._value > value\n\n    def __ge__(self, value):\n        return self._value >= value\n\n    def prettyIn(self, value):\n        try:\n            return int(value)\n\n        except ValueError:\n            try:\n                return self.namedValues[value]\n\n            except KeyError:\n                raise error.PyAsn1Error(\n                    'Can\\'t coerce %r into integer: %s' % (value, sys.exc_info()[1])\n                )\n\n    def prettyOut(self, value):\n        try:\n            return str(self.namedValues[value])\n\n        except KeyError:\n            return str(value)\n\n    # backward compatibility\n\n    def getNamedValues(self):\n        return self.namedValues\n\n\nclass Boolean(Integer):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal or |ASN.1| class\n        instance. If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s).Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class RoundResult(Boolean):\n            '''\n            ASN.1 specification:\n\n            RoundResult ::= BOOLEAN\n\n            ok RoundResult ::= TRUE\n            ko RoundResult ::= FALSE\n            '''\n        ok = RoundResult(True)\n        ko = RoundResult(False)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x01),\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = Integer.subtypeSpec + constraint.SingleValueConstraint(0, 1)\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues(('False', 0), ('True', 1))\n\n    # Optimization for faster codec lookup\n    typeId = Integer.getTypeId()\n\nif sys.version_info[0] < 3:\n    SizedIntegerBase = long\nelse:\n    SizedIntegerBase = int\n\n\nclass SizedInteger(SizedIntegerBase):\n    bitLength = leadingZeroBits = None\n\n    def setBitLength(self, bitLength):\n        self.bitLength = bitLength\n        self.leadingZeroBits = max(bitLength - integer.bitLength(self), 0)\n        return self\n\n    def __len__(self):\n        if self.bitLength is None:\n            self.setBitLength(integer.bitLength(self))\n\n        return self.bitLength\n\n\nclass BitString(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type both Python :class:`tuple` (as a tuple\n    of bits) and :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal representing binary\n        or hexadecimal number or sequence of integer bits or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    binValue: :py:class:`str`\n        Binary string initializer to use instead of the *value*.\n        Example: '10110011'.\n\n    hexValue: :py:class:`str`\n        Hexadecimal string initializer to use instead of the *value*.\n        Example: 'DEADBEEF'.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Rights(BitString):\n            '''\n            ASN.1 specification:\n\n            Rights ::= BIT STRING { user-read(0), user-write(1),\n                                    group-read(2), group-write(3),\n                                    other-read(4), other-write(5) }\n\n            group1 Rights ::= { group-read, group-write }\n            group2 Rights ::= '0011'B\n            group3 Rights ::= '3'H\n            '''\n            namedValues = NamedValues(\n                ('user-read', 0), ('user-write', 1),\n                ('group-read', 2), ('group-write', 3),\n                ('other-read', 4), ('other-write', 5)\n            )\n\n        group1 = Rights(('group-read', 'group-write'))\n        group2 = Rights('0011')\n        group3 = Rights(0x3)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x03)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    defaultBinValue = defaultHexValue = noValue\n\n    def __init__(self, value=noValue, **kwargs):\n        if value is noValue:\n            if kwargs:\n                try:\n                    value = self.fromBinaryString(kwargs.pop('binValue'), internalFormat=True)\n\n                except KeyError:\n                    pass\n\n                try:\n                    value = self.fromHexString(kwargs.pop('hexValue'), internalFormat=True)\n\n                except KeyError:\n                    pass\n\n        if value is noValue:\n            if self.defaultBinValue is not noValue:\n                value = self.fromBinaryString(self.defaultBinValue, internalFormat=True)\n\n            elif self.defaultHexValue is not noValue:\n                value = self.fromHexString(self.defaultHexValue, internalFormat=True)\n\n        if 'namedValues' not in kwargs:\n            kwargs['namedValues'] = self.namedValues\n\n        base.SimpleAsn1Type.__init__(self, value, **kwargs)\n\n    def __str__(self):\n        return self.asBinary()\n\n    def __eq__(self, other):\n        other = self.prettyIn(other)\n        return self is other or self._value == other and len(self._value) == len(other)\n\n    def __ne__(self, other):\n        other = self.prettyIn(other)\n        return self._value != other or len(self._value) != len(other)\n\n    def __lt__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) < len(other) or len(self._value) == len(other) and self._value < other\n\n    def __le__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) <= len(other) or len(self._value) == len(other) and self._value <= other\n\n    def __gt__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) > len(other) or len(self._value) == len(other) and self._value > other\n\n    def __ge__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) >= len(other) or len(self._value) == len(other) and self._value >= other\n\n    # Immutable sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone([self[x] for x in range(*i.indices(len(self)))])\n        else:\n            length = len(self._value) - 1\n            if i > length or i < 0:\n                raise IndexError('bit index out of range')\n            return (self._value >> (length - i)) & 1\n\n    def __iter__(self):\n        length = len(self._value)\n        while length:\n            length -= 1\n            yield (self._value >> length) & 1\n\n    def __reversed__(self):\n        return reversed(tuple(self))\n\n    # arithmetic operators\n\n    def __add__(self, value):\n        value = self.prettyIn(value)\n        return self.clone(SizedInteger(self._value << len(value) | value).setBitLength(len(self._value) + len(value)))\n\n    def __radd__(self, value):\n        value = self.prettyIn(value)\n        return self.clone(SizedInteger(value << len(self._value) | self._value).setBitLength(len(self._value) + len(value)))\n\n    def __mul__(self, value):\n        bitString = self._value\n        while value > 1:\n            bitString <<= len(self._value)\n            bitString |= self._value\n            value -= 1\n        return self.clone(bitString)\n\n    def __rmul__(self, value):\n        return self * value\n\n    def __lshift__(self, count):\n        return self.clone(SizedInteger(self._value << count).setBitLength(len(self._value) + count))\n\n    def __rshift__(self, count):\n        return self.clone(SizedInteger(self._value >> count).setBitLength(max(0, len(self._value) - count)))\n\n    def __int__(self):\n        return int(self._value)\n\n    def __float__(self):\n        return float(self._value)\n\n    if sys.version_info[0] < 3:\n        def __long__(self):\n            return self._value\n\n    def asNumbers(self):\n        \"\"\"Get |ASN.1| value as a sequence of 8-bit integers.\n\n        If |ASN.1| object length is not a multiple of 8, result\n        will be left-padded with zeros.\n        \"\"\"\n        return tuple(octets.octs2ints(self.asOctets()))\n\n    def asOctets(self):\n        \"\"\"Get |ASN.1| value as a sequence of octets.\n\n        If |ASN.1| object length is not a multiple of 8, result\n        will be left-padded with zeros.\n        \"\"\"\n        return integer.to_bytes(self._value, length=len(self))\n\n    def asInteger(self):\n        \"\"\"Get |ASN.1| value as a single integer value.\n        \"\"\"\n        return self._value\n\n    def asBinary(self):\n        \"\"\"Get |ASN.1| value as a text string of bits.\n        \"\"\"\n        binString = bin(self._value)[2:]\n        return '0' * (len(self._value) - len(binString)) + binString\n\n    @classmethod\n    def fromHexString(cls, value, internalFormat=False, prepend=None):\n        \"\"\"Create a |ASN.1| object initialized from the hex string.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like 'DEADBEEF'\n        \"\"\"\n        try:\n            value = SizedInteger(value, 16).setBitLength(len(value) * 4)\n\n        except ValueError:\n            raise error.PyAsn1Error('%s.fromHexString() error: %s' % (cls.__name__, sys.exc_info()[1]))\n\n        if prepend is not None:\n            value = SizedInteger(\n                (SizedInteger(prepend) << len(value)) | value\n            ).setBitLength(len(prepend) + len(value))\n\n        if not internalFormat:\n            value = cls(value)\n\n        return value\n\n    @classmethod\n    def fromBinaryString(cls, value, internalFormat=False, prepend=None):\n        \"\"\"Create a |ASN.1| object initialized from a string of '0' and '1'.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like '1010111'\n        \"\"\"\n        try:\n            value = SizedInteger(value or '0', 2).setBitLength(len(value))\n\n        except ValueError:\n            raise error.PyAsn1Error('%s.fromBinaryString() error: %s' % (cls.__name__, sys.exc_info()[1]))\n\n        if prepend is not None:\n            value = SizedInteger(\n                (SizedInteger(prepend) << len(value)) | value\n            ).setBitLength(len(prepend) + len(value))\n\n        if not internalFormat:\n            value = cls(value)\n\n        return value\n\n    @classmethod\n    def fromOctetString(cls, value, internalFormat=False, prepend=None, padding=0):\n        \"\"\"Create a |ASN.1| object initialized from a string.\n\n        Parameters\n        ----------\n        value: :class:`str` (Py2) or :class:`bytes` (Py3)\n            Text string like '\\\\\\\\x01\\\\\\\\xff' (Py2) or b'\\\\\\\\x01\\\\\\\\xff' (Py3)\n        \"\"\"\n        value = SizedInteger(integer.from_bytes(value) >> padding).setBitLength(len(value) * 8 - padding)\n\n        if prepend is not None:\n            value = SizedInteger(\n                (SizedInteger(prepend) << len(value)) | value\n            ).setBitLength(len(prepend) + len(value))\n\n        if not internalFormat:\n            value = cls(value)\n\n        return value\n\n    def prettyIn(self, value):\n        if isinstance(value, SizedInteger):\n            return value\n        elif octets.isStringType(value):\n            if not value:\n                return SizedInteger(0).setBitLength(0)\n\n            elif value[0] == '\\'':  # \"'1011'B\" -- ASN.1 schema representation (deprecated)\n                if value[-2:] == '\\'B':\n                    return self.fromBinaryString(value[1:-2], internalFormat=True)\n                elif value[-2:] == '\\'H':\n                    return self.fromHexString(value[1:-2], internalFormat=True)\n                else:\n                    raise error.PyAsn1Error(\n                        'Bad BIT STRING value notation %s' % (value,)\n                    )\n\n            elif self.namedValues and not value.isdigit():  # named bits like 'Urgent, Active'\n                names = [x.strip() for x in value.split(',')]\n\n                try:\n\n                    bitPositions = [self.namedValues[name] for name in names]\n\n                except KeyError:\n                    raise error.PyAsn1Error('unknown bit name(s) in %r' % (names,))\n\n                rightmostPosition = max(bitPositions)\n\n                number = 0\n                for bitPosition in bitPositions:\n                    number |= 1 << (rightmostPosition - bitPosition)\n\n                return SizedInteger(number).setBitLength(rightmostPosition + 1)\n\n            elif value.startswith('0x'):\n                return self.fromHexString(value[2:], internalFormat=True)\n\n            elif value.startswith('0b'):\n                return self.fromBinaryString(value[2:], internalFormat=True)\n\n            else:  # assume plain binary string like '1011'\n                return self.fromBinaryString(value, internalFormat=True)\n\n        elif isinstance(value, (tuple, list)):\n            return self.fromBinaryString(''.join([b and '1' or '0' for b in value]), internalFormat=True)\n\n        elif isinstance(value, BitString):\n            return SizedInteger(value).setBitLength(len(value))\n\n        elif isinstance(value, intTypes):\n            return SizedInteger(value)\n\n        else:\n            raise error.PyAsn1Error(\n                'Bad BitString initializer type \\'%s\\'' % (value,)\n            )\n\n\nclass OctetString(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python 2 :class:`str` or\n    Python 3 :class:`bytes`. When used in Unicode context, |ASN.1| type\n    assumes \"|encoding|\" serialisation.\n\n    Keyword Args\n    ------------\n    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object\n        class:`str` (Python 2) or :class:`bytes` (Python 3), alternatively\n        class:`unicode` object (Python 2) or :class:`str` (Python 3)\n        representing character string to be serialised into octets\n        (note `encoding` parameter) or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    encoding: :py:class:`str`\n        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or\n        :class:`str` (Python 3) the payload when |ASN.1| object is used\n        in text string context.\n\n    binValue: :py:class:`str`\n        Binary string initializer to use instead of the *value*.\n        Example: '10110011'.\n\n    hexValue: :py:class:`str`\n        Hexadecimal string initializer to use instead of the *value*.\n        Example: 'DEADBEEF'.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Icon(OctetString):\n            '''\n            ASN.1 specification:\n\n            Icon ::= OCTET STRING\n\n            icon1 Icon ::= '001100010011001000110011'B\n            icon2 Icon ::= '313233'H\n            '''\n        icon1 = Icon.fromBinaryString('001100010011001000110011')\n        icon2 = Icon.fromHexString('313233')\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x04)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    defaultBinValue = defaultHexValue = noValue\n    encoding = 'iso-8859-1'\n\n    def __init__(self, value=noValue, **kwargs):\n        if kwargs:\n            if value is noValue:\n                try:\n                    value = self.fromBinaryString(kwargs.pop('binValue'))\n\n                except KeyError:\n                    pass\n\n                try:\n                    value = self.fromHexString(kwargs.pop('hexValue'))\n\n                except KeyError:\n                    pass\n\n        if value is noValue:\n            if self.defaultBinValue is not noValue:\n                value = self.fromBinaryString(self.defaultBinValue)\n\n            elif self.defaultHexValue is not noValue:\n                value = self.fromHexString(self.defaultHexValue)\n\n        if 'encoding' not in kwargs:\n            kwargs['encoding'] = self.encoding\n\n        base.SimpleAsn1Type.__init__(self, value, **kwargs)\n\n    if sys.version_info[0] <= 2:\n        def prettyIn(self, value):\n            if isinstance(value, str):\n                return value\n\n            elif isinstance(value, unicode):\n                try:\n                    return value.encode(self.encoding)\n\n                except (LookupError, UnicodeEncodeError):\n                    exc = sys.exc_info()[1]\n                    raise error.PyAsn1UnicodeEncodeError(\n                        \"Can't encode string '%s' with codec \"\n                        \"%s\" % (value, self.encoding), exc\n                    )\n\n            elif isinstance(value, (tuple, list)):\n                try:\n                    return ''.join([chr(x) for x in value])\n\n                except ValueError:\n                    raise error.PyAsn1Error(\n                        \"Bad %s initializer '%s'\" % (self.__class__.__name__, value)\n                    )\n\n            else:\n                return str(value)\n\n        def __str__(self):\n            return str(self._value)\n\n        def __unicode__(self):\n            try:\n                return self._value.decode(self.encoding)\n\n            except UnicodeDecodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with codec \"\n                    \"%s\" % (self._value, self.encoding), exc\n                )\n\n        def asOctets(self):\n            return str(self._value)\n\n        def asNumbers(self):\n            return tuple([ord(x) for x in self._value])\n\n    else:\n        def prettyIn(self, value):\n            if isinstance(value, bytes):\n                return value\n\n            elif isinstance(value, str):\n                try:\n                    return value.encode(self.encoding)\n\n                except UnicodeEncodeError:\n                    exc = sys.exc_info()[1]\n                    raise error.PyAsn1UnicodeEncodeError(\n                        \"Can't encode string '%s' with '%s' \"\n                        \"codec\" % (value, self.encoding), exc\n                    )\n            elif isinstance(value, OctetString):  # a shortcut, bytes() would work the same way\n                return value.asOctets()\n\n            elif isinstance(value, base.SimpleAsn1Type):  # this mostly targets Integer objects\n                return self.prettyIn(str(value))\n\n            elif isinstance(value, (tuple, list)):\n                return self.prettyIn(bytes(value))\n\n            else:\n                return bytes(value)\n\n        def __str__(self):\n            try:\n                return self._value.decode(self.encoding)\n\n            except UnicodeDecodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with '%s' codec at \"\n                    \"'%s'\" % (self._value, self.encoding,\n                              self.__class__.__name__), exc\n                )\n\n        def __bytes__(self):\n            return bytes(self._value)\n\n        def asOctets(self):\n            return bytes(self._value)\n\n        def asNumbers(self):\n            return tuple(self._value)\n\n    #\n    # Normally, `.prettyPrint()` is called from `__str__()`. Historically,\n    # OctetString.prettyPrint() used to return hexified payload\n    # representation in cases when non-printable content is present. At the\n    # same time `str()` used to produce either octet-stream (Py2) or\n    # text (Py3) representations.\n    #\n    # Therefore `OctetString.__str__()` -> `.prettyPrint()` call chain is\n    # reversed to preserve the original behaviour.\n    #\n    # Eventually we should deprecate `.prettyPrint()` / `.prettyOut()` harness\n    # and end up with just `__str__()` producing hexified representation while\n    # both text and octet-stream representation should only be requested via\n    # the `.asOctets()` method.\n    #\n    # Note: ASN.1 OCTET STRING is never mean to contain text!\n    #\n\n    def prettyOut(self, value):\n        return value\n\n    def prettyPrint(self, scope=0):\n        # first see if subclass has its own .prettyOut()\n        value = self.prettyOut(self._value)\n\n        if value is not self._value:\n            return value\n\n        numbers = self.asNumbers()\n\n        for x in numbers:\n            # hexify if needed\n            if x < 32 or x > 126:\n                return '0x' + ''.join(('%.2x' % x for x in numbers))\n        else:\n            # this prevents infinite recursion\n            return OctetString.__str__(self)\n\n    @staticmethod\n    def fromBinaryString(value):\n        \"\"\"Create a |ASN.1| object initialized from a string of '0' and '1'.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like '1010111'\n        \"\"\"\n        bitNo = 8\n        byte = 0\n        r = []\n        for v in value:\n            if bitNo:\n                bitNo -= 1\n            else:\n                bitNo = 7\n                r.append(byte)\n                byte = 0\n            if v in ('0', '1'):\n                v = int(v)\n            else:\n                raise error.PyAsn1Error(\n                    'Non-binary OCTET STRING initializer %s' % (v,)\n                )\n            byte |= v << bitNo\n\n        r.append(byte)\n\n        return octets.ints2octs(r)\n\n    @staticmethod\n    def fromHexString(value):\n        \"\"\"Create a |ASN.1| object initialized from the hex string.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like 'DEADBEEF'\n        \"\"\"\n        r = []\n        p = []\n        for v in value:\n            if p:\n                r.append(int(p + v, 16))\n                p = None\n            else:\n                p = v\n        if p:\n            r.append(int(p + '0', 16))\n\n        return octets.ints2octs(r)\n\n    # Immutable sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone(self._value[i])\n        else:\n            return self._value[i]\n\n    def __iter__(self):\n        return iter(self._value)\n\n    def __contains__(self, value):\n        return value in self._value\n\n    def __add__(self, value):\n        return self.clone(self._value + self.prettyIn(value))\n\n    def __radd__(self, value):\n        return self.clone(self.prettyIn(value) + self._value)\n\n    def __mul__(self, value):\n        return self.clone(self._value * value)\n\n    def __rmul__(self, value):\n        return self * value\n\n    def __int__(self):\n        return int(self._value)\n\n    def __float__(self):\n        return float(self._value)\n\n    def __reversed__(self):\n        return reversed(self._value)\n\n\nclass Null(OctetString):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`str` objects\n    (always empty).\n\n    Keyword Args\n    ------------\n    value: :class:`str` or |ASN.1| object\n        Python empty :class:`str` literal or any object that evaluates to :obj:`False`\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Ack(Null):\n            '''\n            ASN.1 specification:\n\n            Ack ::= NULL\n            '''\n        ack = Ack('')\n    \"\"\"\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x05)\n    )\n    subtypeSpec = OctetString.subtypeSpec + constraint.SingleValueConstraint(octets.str2octs(''))\n\n    # Optimization for faster codec lookup\n    typeId = OctetString.getTypeId()\n\n    def prettyIn(self, value):\n        if value:\n            return value\n\n        return octets.str2octs('')\n\nif sys.version_info[0] <= 2:\n    intTypes = (int, long)\nelse:\n    intTypes = (int,)\n\nnumericTypes = intTypes + (float,)\n\n\nclass ObjectIdentifier(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`tuple` objects\n    (tuple of non-negative integers).\n\n    Keyword Args\n    ------------\n    value: :class:`tuple`, :class:`str` or |ASN.1| object\n        Python sequence of :class:`int` or :class:`str` literal or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class ID(ObjectIdentifier):\n            '''\n            ASN.1 specification:\n\n            ID ::= OBJECT IDENTIFIER\n\n            id-edims ID ::= { joint-iso-itu-t mhs-motif(6) edims(7) }\n            id-bp ID ::= { id-edims 11 }\n            '''\n        id_edims = ID('2.6.7')\n        id_bp = id_edims + (11,)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x06)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    def __add__(self, other):\n        return self.clone(self._value + other)\n\n    def __radd__(self, other):\n        return self.clone(other + self._value)\n\n    def asTuple(self):\n        return self._value\n\n    # Sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone(self._value[i])\n        else:\n            return self._value[i]\n\n    def __iter__(self):\n        return iter(self._value)\n\n    def __contains__(self, value):\n        return value in self._value\n\n    def index(self, suboid):\n        return self._value.index(suboid)\n\n    def isPrefixOf(self, other):\n        \"\"\"Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.\n\n        Parameters\n        ----------\n        other: |ASN.1| object\n            |ASN.1| object\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object\n            or :obj:`False` otherwise.\n        \"\"\"\n        l = len(self)\n        if l <= len(other):\n            if self._value[:l] == other[:l]:\n                return True\n        return False\n\n    def prettyIn(self, value):\n        if isinstance(value, ObjectIdentifier):\n            return tuple(value)\n        elif octets.isStringType(value):\n            if '-' in value:\n                raise error.PyAsn1Error(\n                    'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n            try:\n                return tuple([int(subOid) for subOid in value.split('.') if subOid])\n            except ValueError:\n                raise error.PyAsn1Error(\n                    'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n\n        try:\n            tupleOfInts = tuple([int(subOid) for subOid in value if subOid >= 0])\n\n        except (ValueError, TypeError):\n            raise error.PyAsn1Error(\n                'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n            )\n\n        if len(tupleOfInts) == len(value):\n            return tupleOfInts\n\n        raise error.PyAsn1Error('Malformed Object ID %s at %s' % (value, self.__class__.__name__))\n\n    def prettyOut(self, value):\n        return '.'.join([str(x) for x in value])\n\n\nclass RelativeOID(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`tuple` objects\n    (tuple of non-negative integers).\n    Keyword Args\n    ------------\n    value: :class:`tuple`, :class:`str` or |ASN.1| object\n        Python sequence of :class:`int` or :class:`str` literal or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n    Examples\n    --------\n    .. code-block:: python\n        class RelOID(RelativeOID):\n            '''\n            ASN.1 specification:\n            id-pad-null RELATIVE-OID ::= { 0 }\n            id-pad-once RELATIVE-OID ::= { 5 6 }\n            id-pad-twice RELATIVE-OID ::= { 5 6 7 }\n            '''\n        id_pad_null = RelOID('0')\n        id_pad_once = RelOID('5.6')\n        id_pad_twice = id_pad_once + (7,)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0d)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    def __add__(self, other):\n        return self.clone(self._value + other)\n\n    def __radd__(self, other):\n        return self.clone(other + self._value)\n\n    def asTuple(self):\n        return self._value\n\n    # Sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone(self._value[i])\n        else:\n            return self._value[i]\n\n    def __iter__(self):\n        return iter(self._value)\n\n    def __contains__(self, value):\n        return value in self._value\n\n    def index(self, suboid):\n        return self._value.index(suboid)\n\n    def isPrefixOf(self, other):\n        \"\"\"Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.\n        Parameters\n        ----------\n        other: |ASN.1| object\n            |ASN.1| object\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object\n            or :obj:`False` otherwise.\n        \"\"\"\n        l = len(self)\n        if l <= len(other):\n            if self._value[:l] == other[:l]:\n                return True\n        return False\n\n    def prettyIn(self, value):\n        if isinstance(value, RelativeOID):\n            return tuple(value)\n        elif octets.isStringType(value):\n            if '-' in value:\n                raise error.PyAsn1Error(\n                    'Malformed RELATIVE-OID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n            try:\n                return tuple([int(subOid) for subOid in value.split('.') if subOid])\n            except ValueError:\n                raise error.PyAsn1Error(\n                    'Malformed RELATIVE-OID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n\n        try:\n            tupleOfInts = tuple([int(subOid) for subOid in value if subOid >= 0])\n\n        except (ValueError, TypeError):\n            raise error.PyAsn1Error(\n                'Malformed RELATIVE-OID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n            )\n\n        if len(tupleOfInts) == len(value):\n            return tupleOfInts\n\n        raise error.PyAsn1Error('Malformed RELATIVE-OID %s at %s' % (value, self.__class__.__name__))\n\n    def prettyOut(self, value):\n        return '.'.join([str(x) for x in value])\n\n\nclass Real(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`float` objects.\n    Additionally, |ASN.1| objects behave like a :class:`tuple` in which case its\n    elements are mantissa, base and exponent.\n\n    Keyword Args\n    ------------\n    value: :class:`tuple`, :class:`float` or |ASN.1| object\n        Python sequence of :class:`int` (representing mantissa, base and\n        exponent) or :class:`float` instance or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Pi(Real):\n            '''\n            ASN.1 specification:\n\n            Pi ::= REAL\n\n            pi Pi ::= { mantissa 314159, base 10, exponent -5 }\n\n            '''\n        pi = Pi((314159, 10, -5))\n    \"\"\"\n    binEncBase = None  # binEncBase = 16 is recommended for large numbers\n\n    try:\n        _plusInf = float('inf')\n        _minusInf = float('-inf')\n        _inf = _plusInf, _minusInf\n\n    except ValueError:\n        # Infinity support is platform and Python dependent\n        _plusInf = _minusInf = None\n        _inf = ()\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x09)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    @staticmethod\n    def __normalizeBase10(value):\n        m, b, e = value\n        while m and m % 10 == 0:\n            m /= 10\n            e += 1\n        return m, b, e\n\n    def prettyIn(self, value):\n        if isinstance(value, tuple) and len(value) == 3:\n            if (not isinstance(value[0], numericTypes) or\n                    not isinstance(value[1], intTypes) or\n                    not isinstance(value[2], intTypes)):\n                raise error.PyAsn1Error('Lame Real value syntax: %s' % (value,))\n            if (isinstance(value[0], float) and\n                    self._inf and value[0] in self._inf):\n                return value[0]\n            if value[1] not in (2, 10):\n                raise error.PyAsn1Error(\n                    'Prohibited base for Real value: %s' % (value[1],)\n                )\n            if value[1] == 10:\n                value = self.__normalizeBase10(value)\n            return value\n        elif isinstance(value, intTypes):\n            return self.__normalizeBase10((value, 10, 0))\n        elif isinstance(value, float) or octets.isStringType(value):\n            if octets.isStringType(value):\n                try:\n                    value = float(value)\n                except ValueError:\n                    raise error.PyAsn1Error(\n                        'Bad real value syntax: %s' % (value,)\n                    )\n            if self._inf and value in self._inf:\n                return value\n            else:\n                e = 0\n                while int(value) != value:\n                    value *= 10\n                    e -= 1\n                return self.__normalizeBase10((int(value), 10, e))\n        elif isinstance(value, Real):\n            return tuple(value)\n        raise error.PyAsn1Error(\n            'Bad real value syntax: %s' % (value,)\n        )\n\n    def prettyPrint(self, scope=0):\n        try:\n            return self.prettyOut(float(self))\n\n        except OverflowError:\n            return '<overflow>'\n\n    @property\n    def isPlusInf(self):\n        \"\"\"Indicate PLUS-INFINITY object value\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if calling object represents plus infinity\n            or :obj:`False` otherwise.\n\n        \"\"\"\n        return self._value == self._plusInf\n\n    @property\n    def isMinusInf(self):\n        \"\"\"Indicate MINUS-INFINITY object value\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if calling object represents minus infinity\n            or :obj:`False` otherwise.\n        \"\"\"\n        return self._value == self._minusInf\n\n    @property\n    def isInf(self):\n        return self._value in self._inf\n\n    def __add__(self, value):\n        return self.clone(float(self) + value)\n\n    def __radd__(self, value):\n        return self + value\n\n    def __mul__(self, value):\n        return self.clone(float(self) * value)\n\n    def __rmul__(self, value):\n        return self * value\n\n    def __sub__(self, value):\n        return self.clone(float(self) - value)\n\n    def __rsub__(self, value):\n        return self.clone(value - float(self))\n\n    def __mod__(self, value):\n        return self.clone(float(self) % value)\n\n    def __rmod__(self, value):\n        return self.clone(value % float(self))\n\n    def __pow__(self, value, modulo=None):\n        return self.clone(pow(float(self), value, modulo))\n\n    def __rpow__(self, value):\n        return self.clone(pow(value, float(self)))\n\n    if sys.version_info[0] <= 2:\n        def __div__(self, value):\n            return self.clone(float(self) / value)\n\n        def __rdiv__(self, value):\n            return self.clone(value / float(self))\n    else:\n        def __truediv__(self, value):\n            return self.clone(float(self) / value)\n\n        def __rtruediv__(self, value):\n            return self.clone(value / float(self))\n\n        def __divmod__(self, value):\n            return self.clone(float(self) // value)\n\n        def __rdivmod__(self, value):\n            return self.clone(value // float(self))\n\n    def __int__(self):\n        return int(float(self))\n\n    if sys.version_info[0] <= 2:\n        def __long__(self):\n            return long(float(self))\n\n    def __float__(self):\n        if self._value in self._inf:\n            return self._value\n        else:\n            return float(\n                self._value[0] * pow(self._value[1], self._value[2])\n            )\n\n    def __abs__(self):\n        return self.clone(abs(float(self)))\n\n    def __pos__(self):\n        return self.clone(+float(self))\n\n    def __neg__(self):\n        return self.clone(-float(self))\n\n    def __round__(self, n=0):\n        r = round(float(self), n)\n        if n:\n            return self.clone(r)\n        else:\n            return r\n\n    def __floor__(self):\n        return self.clone(math.floor(float(self)))\n\n    def __ceil__(self):\n        return self.clone(math.ceil(float(self)))\n\n    def __trunc__(self):\n        return self.clone(math.trunc(float(self)))\n\n    def __lt__(self, value):\n        return float(self) < value\n\n    def __le__(self, value):\n        return float(self) <= value\n\n    def __eq__(self, value):\n        return float(self) == value\n\n    def __ne__(self, value):\n        return float(self) != value\n\n    def __gt__(self, value):\n        return float(self) > value\n\n    def __ge__(self, value):\n        return float(self) >= value\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return bool(float(self))\n    else:\n        def __bool__(self):\n            return bool(float(self))\n\n        __hash__ = base.SimpleAsn1Type.__hash__\n\n    def __getitem__(self, idx):\n        if self._value in self._inf:\n            raise error.PyAsn1Error('Invalid infinite value operation')\n        else:\n            return self._value[idx]\n\n    # compatibility stubs\n\n    def isPlusInfinity(self):\n        return self.isPlusInf\n\n    def isMinusInfinity(self):\n        return self.isMinusInf\n\n    def isInfinity(self):\n        return self.isInf\n\n\nclass Enumerated(Integer):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class RadioButton(Enumerated):\n            '''\n            ASN.1 specification:\n\n            RadioButton ::= ENUMERATED { button1(0), button2(1),\n                                         button3(2) }\n\n            selected-by-default RadioButton ::= button1\n            '''\n            namedValues = NamedValues(\n                ('button1', 0), ('button2', 1),\n                ('button3', 2)\n            )\n\n        selected_by_default = RadioButton('button1')\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0A)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = Integer.getTypeId()\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues()\n\n\n# \"Structured\" ASN.1 types\n\nclass SequenceOfAndSetOfBase(base.ConstructedAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.ConstructedAsn1Type`,\n    its objects are mutable and duck-type Python :class:`list` objects.\n\n    Keyword Args\n    ------------\n    componentType : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n        A pyasn1 object representing ASN.1 type allowed within |ASN.1| type\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type can only occur on explicit\n        `.isInconsistent` call.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class LotteryDraw(SequenceOf):  #  SetOf is similar\n            '''\n            ASN.1 specification:\n\n            LotteryDraw ::= SEQUENCE OF INTEGER\n            '''\n            componentType = Integer()\n\n        lotteryDraw = LotteryDraw()\n        lotteryDraw.extend([123, 456, 789])\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        # support positional params for backward compatibility\n        if args:\n            for key, value in zip(('componentType', 'tagSet',\n                                   'subtypeSpec'), args):\n                if key in kwargs:\n                    raise error.PyAsn1Error('Conflicting positional and keyword params!')\n                kwargs['componentType'] = value\n\n        self._componentValues = noValue\n\n        base.ConstructedAsn1Type.__init__(self, **kwargs)\n\n    # Python list protocol\n\n    def __getitem__(self, idx):\n        try:\n            return self.getComponentByPosition(idx)\n\n        except error.PyAsn1Error:\n            raise IndexError(sys.exc_info()[1])\n\n    def __setitem__(self, idx, value):\n        try:\n            self.setComponentByPosition(idx, value)\n\n        except error.PyAsn1Error:\n            raise IndexError(sys.exc_info()[1])\n\n    def append(self, value):\n        if self._componentValues is noValue:\n            pos = 0\n\n        else:\n            pos = len(self._componentValues)\n\n        self[pos] = value\n\n    def count(self, value):\n        return list(self._componentValues.values()).count(value)\n\n    def extend(self, values):\n        for value in values:\n            self.append(value)\n\n        if self._componentValues is noValue:\n            self._componentValues = {}\n\n    def index(self, value, start=0, stop=None):\n        if stop is None:\n            stop = len(self)\n\n        indices, values = zip(*self._componentValues.items())\n\n        # TODO: remove when Py2.5 support is gone\n        values = list(values)\n\n        try:\n            return indices[values.index(value, start, stop)]\n\n        except error.PyAsn1Error:\n            raise ValueError(sys.exc_info()[1])\n\n    def reverse(self):\n        self._componentValues.reverse()\n\n    def sort(self, key=None, reverse=False):\n        self._componentValues = dict(\n            enumerate(sorted(self._componentValues.values(),\n                             key=key, reverse=reverse)))\n\n    def __len__(self):\n        if self._componentValues is noValue or not self._componentValues:\n            return 0\n\n        return max(self._componentValues) + 1\n\n    def __iter__(self):\n        for idx in range(0, len(self)):\n            yield self.getComponentByPosition(idx)\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        for idx, componentValue in self._componentValues.items():\n            if componentValue is not noValue:\n                if isinstance(componentValue, base.ConstructedAsn1Type):\n                    myClone.setComponentByPosition(\n                        idx, componentValue.clone(cloneValueFlag=cloneValueFlag)\n                    )\n                else:\n                    myClone.setComponentByPosition(idx, componentValue.clone())\n\n    def getComponentByPosition(self, idx, default=noValue, instantiate=True):\n        \"\"\"Return |ASN.1| type component value by position.\n\n        Equivalent to Python sequence subscription operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx : :class:`int`\n            Component index (zero-based). Must either refer to an existing\n            component or to N+1 component (if *componentType* is set). In the latter\n            case a new component type gets instantiated and appended to the |ASN.1|\n            sequence.\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically instantiated.\n            If :obj:`False` either existing component or the :class:`NoValue` object will be\n            returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            Instantiate |ASN.1| component type or return existing component value\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            # can also be SetOf\n            class MySequenceOf(SequenceOf):\n                componentType = OctetString()\n\n            s = MySequenceOf()\n\n            # returns component #0 with `.isValue` property False\n            s.getComponentByPosition(0)\n\n            # returns None\n            s.getComponentByPosition(0, default=None)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n\n            # sets component #0 to OctetString() ASN.1 schema\n            # object and returns it\n            s.getComponentByPosition(0, instantiate=True)\n\n            # sets component #0 to ASN.1 value object\n            s.setComponentByPosition(0, 'ABCD')\n\n            # returns OctetString('ABCD') value object\n            s.getComponentByPosition(0, instantiate=False)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n        \"\"\"\n        if isinstance(idx, slice):\n            indices = tuple(range(len(self)))\n            return [self.getComponentByPosition(subidx, default, instantiate)\n                    for subidx in indices[idx]]\n\n        if idx < 0:\n            idx = len(self) + idx\n            if idx < 0:\n                raise error.PyAsn1Error(\n                    'SequenceOf/SetOf index is out of range')\n\n        try:\n            componentValue = self._componentValues[idx]\n\n        except (KeyError, error.PyAsn1Error):\n            if not instantiate:\n                return default\n\n            self.setComponentByPosition(idx)\n\n            componentValue = self._componentValues[idx]\n\n        if default is noValue or componentValue.isValue:\n            return componentValue\n        else:\n            return default\n\n    def setComponentByPosition(self, idx, value=noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by position.\n\n        Equivalent to Python sequence item assignment operation (e.g. `[]`)\n        or list.append() (when idx == len(self)).\n\n        Parameters\n        ----------\n        idx: :class:`int`\n            Component index (zero-based). Must either refer to existing\n            component or to N+1 component. In the latter case a new component\n            type gets instantiated (if *componentType* is set, or given ASN.1\n            object is taken otherwise) and appended to the |ASN.1| sequence.\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints: :class:`bool`\n             If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n             If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n             If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n\n        Raises\n        ------\n        ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n            On constraint violation or bad initializer\n        IndexError\n            When idx > len(self)\n        \"\"\"\n        if isinstance(idx, slice):\n            indices = tuple(range(len(self)))\n            startIdx = indices and indices[idx][0] or 0\n            for subIdx, subValue in enumerate(value):\n                self.setComponentByPosition(\n                    startIdx + subIdx, subValue, verifyConstraints,\n                    matchTags, matchConstraints)\n            return self\n\n        if idx < 0:\n            idx = len(self) + idx\n            if idx < 0:\n                raise error.PyAsn1Error(\n                    'SequenceOf/SetOf index is out of range')\n\n        componentType = self.componentType\n\n        if self._componentValues is noValue:\n            componentValues = {}\n\n        else:\n            componentValues = self._componentValues\n\n        currentValue = componentValues.get(idx, noValue)\n\n        if value is noValue:\n            if componentType is not None:\n                value = componentType.clone()\n\n            elif currentValue is noValue:\n                raise error.PyAsn1Error('Component type not defined')\n\n        elif not isinstance(value, base.Asn1Item):\n            if (componentType is not None and\n                    isinstance(componentType, base.SimpleAsn1Type)):\n                value = componentType.clone(value=value)\n\n            elif (currentValue is not noValue and\n                    isinstance(currentValue, base.SimpleAsn1Type)):\n                value = currentValue.clone(value=value)\n\n            else:\n                raise error.PyAsn1Error(\n                    'Non-ASN.1 value %r and undefined component'\n                    ' type at %r' % (value, self))\n\n        elif componentType is not None and (matchTags or matchConstraints):\n            subtypeChecker = (\n                    self.strictConstraints and\n                    componentType.isSameTypeWith or\n                    componentType.isSuperTypeOf)\n\n            if not subtypeChecker(value, verifyConstraints and matchTags,\n                                  verifyConstraints and matchConstraints):\n                # TODO: we should wrap componentType with UnnamedType to carry\n                # additional properties associated with componentType\n                if componentType.typeId != Any.typeId:\n                    raise error.PyAsn1Error(\n                        'Component value is tag-incompatible: %r vs '\n                        '%r' % (value, componentType))\n\n        componentValues[idx] = value\n\n        self._componentValues = componentValues\n\n        return self\n\n    @property\n    def componentTagMap(self):\n        if self.componentType is not None:\n            return self.componentType.tagMap\n\n    @property\n    def components(self):\n        return [self._componentValues[idx]\n                for idx in sorted(self._componentValues)]\n\n    def clear(self):\n        \"\"\"Remove all components and become an empty |ASN.1| value object.\n\n        Has the same effect on |ASN.1| object as it does on :class:`list`\n        built-in.\n        \"\"\"\n        self._componentValues = {}\n        return self\n\n    def reset(self):\n        \"\"\"Remove all components and become a |ASN.1| schema object.\n\n        See :meth:`isValue` property for more information on the\n        distinction between value and schema objects.\n        \"\"\"\n        self._componentValues = noValue\n        return self\n\n    def prettyPrint(self, scope=0):\n        scope += 1\n        representation = self.__class__.__name__ + ':\\n'\n\n        if not self.isValue:\n            return representation\n\n        for idx, componentValue in enumerate(self):\n            representation += ' ' * scope\n            if (componentValue is noValue and\n                    self.componentType is not None):\n                representation += '<empty>'\n            else:\n                representation += componentValue.prettyPrint(scope)\n\n        return representation\n\n    def prettyPrintType(self, scope=0):\n        scope += 1\n        representation = '%s -> %s {\\n' % (self.tagSet, self.__class__.__name__)\n        if self.componentType is not None:\n            representation += ' ' * scope\n            representation += self.componentType.prettyPrintType(scope)\n        return representation + '\\n' + ' ' * (scope - 1) + '}'\n\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema features,\n        this object can also be used like a Python built-in object\n        (e.g. :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a normal value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n        \"\"\"\n        if self._componentValues is noValue:\n            return False\n\n        if len(self._componentValues) != len(self):\n            return False\n\n        for componentValue in self._componentValues.values():\n            if componentValue is noValue or not componentValue.isValue:\n                return False\n\n        return True\n\n    @property\n    def isInconsistent(self):\n        \"\"\"Run necessary checks to ensure |ASN.1| object consistency.\n\n        Default action is to verify |ASN.1| object against constraints imposed\n        by `subtypeSpec`.\n\n        Raises\n        ------\n        :py:class:`~pyasn1.error.PyAsn1tError` on any inconsistencies found\n        \"\"\"\n        if self.componentType is noValue or not self.subtypeSpec:\n            return False\n\n        if self._componentValues is noValue:\n            return True\n\n        mapping = {}\n\n        for idx, value in self._componentValues.items():\n            # Absent fields are not in the mapping\n            if value is noValue:\n                continue\n\n            mapping[idx] = value\n\n        try:\n            # Represent SequenceOf/SetOf as a bare dict to constraints chain\n            self.subtypeSpec(mapping)\n\n        except error.PyAsn1Error:\n            exc = sys.exc_info()[1]\n            return exc\n\n        return False\n\nclass SequenceOf(SequenceOfAndSetOfBase):\n    __doc__ = SequenceOfAndSetOfBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)\n    )\n\n    #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = None\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceOfAndSetOfBase.getTypeId()\n\n\nclass SetOf(SequenceOfAndSetOfBase):\n    __doc__ = SequenceOfAndSetOfBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)\n    )\n\n    #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = None\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceOfAndSetOfBase.getTypeId()\n\n\nclass SequenceAndSetBase(base.ConstructedAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.ConstructedAsn1Type`,\n    its objects are mutable and duck-type Python :class:`dict` objects.\n\n    Keyword Args\n    ------------\n    componentType: :py:class:`~pyasn1.type.namedtype.NamedType`\n        Object holding named ASN.1 types allowed within this collection\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s).  Constraints\n        verification for |ASN.1| type can only occur on explicit\n        `.isInconsistent` call.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Description(Sequence):  #  Set is similar\n            '''\n            ASN.1 specification:\n\n            Description ::= SEQUENCE {\n                surname    IA5String,\n                first-name IA5String OPTIONAL,\n                age        INTEGER DEFAULT 40\n            }\n            '''\n            componentType = NamedTypes(\n                NamedType('surname', IA5String()),\n                OptionalNamedType('first-name', IA5String()),\n                DefaultedNamedType('age', Integer(40))\n            )\n\n        descr = Description()\n        descr['surname'] = 'Smith'\n        descr['first-name'] = 'John'\n    \"\"\"\n    #: Default :py:class:`~pyasn1.type.namedtype.NamedTypes`\n    #: object representing named ASN.1 types allowed within |ASN.1| type\n    componentType = namedtype.NamedTypes()\n\n\n    class DynamicNames(object):\n        \"\"\"Fields names/positions mapping for component-less objects\"\"\"\n        def __init__(self):\n            self._keyToIdxMap = {}\n            self._idxToKeyMap = {}\n\n        def __len__(self):\n            return len(self._keyToIdxMap)\n\n        def __contains__(self, item):\n            return item in self._keyToIdxMap or item in self._idxToKeyMap\n\n        def __iter__(self):\n            return (self._idxToKeyMap[idx] for idx in range(len(self._idxToKeyMap)))\n\n        def __getitem__(self, item):\n            try:\n                return self._keyToIdxMap[item]\n\n            except KeyError:\n                return self._idxToKeyMap[item]\n\n        def getNameByPosition(self, idx):\n            try:\n                return self._idxToKeyMap[idx]\n\n            except KeyError:\n                raise error.PyAsn1Error('Type position out of range')\n\n        def getPositionByName(self, name):\n            try:\n                return self._keyToIdxMap[name]\n\n            except KeyError:\n                raise error.PyAsn1Error('Name %s not found' % (name,))\n\n        def addField(self, idx):\n            self._keyToIdxMap['field-%d' % idx] = idx\n            self._idxToKeyMap[idx] = 'field-%d' % idx\n\n\n    def __init__(self, **kwargs):\n        base.ConstructedAsn1Type.__init__(self, **kwargs)\n        self._componentTypeLen = len(self.componentType)\n        if self._componentTypeLen:\n            self._componentValues = []\n        else:\n            self._componentValues = noValue\n        self._dynamicNames = self._componentTypeLen or self.DynamicNames()\n\n    def __getitem__(self, idx):\n        if octets.isStringType(idx):\n            try:\n                return self.getComponentByName(idx)\n\n            except error.PyAsn1Error:\n                # duck-typing dict\n                raise KeyError(sys.exc_info()[1])\n\n        else:\n            try:\n                return self.getComponentByPosition(idx)\n\n            except error.PyAsn1Error:\n                # duck-typing list\n                raise IndexError(sys.exc_info()[1])\n\n    def __setitem__(self, idx, value):\n        if octets.isStringType(idx):\n            try:\n                self.setComponentByName(idx, value)\n\n            except error.PyAsn1Error:\n                # duck-typing dict\n                raise KeyError(sys.exc_info()[1])\n\n        else:\n            try:\n                self.setComponentByPosition(idx, value)\n\n            except error.PyAsn1Error:\n                # duck-typing list\n                raise IndexError(sys.exc_info()[1])\n\n    def __contains__(self, key):\n        if self._componentTypeLen:\n            return key in self.componentType\n        else:\n            return key in self._dynamicNames\n\n    def __len__(self):\n        return len(self._componentValues)\n\n    def __iter__(self):\n        return iter(self.componentType or self._dynamicNames)\n\n    # Python dict protocol\n\n    def values(self):\n        for idx in range(self._componentTypeLen or len(self._dynamicNames)):\n            yield self[idx]\n\n    def keys(self):\n        return iter(self)\n\n    def items(self):\n        for idx in range(self._componentTypeLen or len(self._dynamicNames)):\n            if self._componentTypeLen:\n                yield self.componentType[idx].name, self[idx]\n            else:\n                yield self._dynamicNames[idx], self[idx]\n\n    def update(self, *iterValue, **mappingValue):\n        for k, v in iterValue:\n            self[k] = v\n        for k in mappingValue:\n            self[k] = mappingValue[k]\n\n    def clear(self):\n        \"\"\"Remove all components and become an empty |ASN.1| value object.\n\n        Has the same effect on |ASN.1| object as it does on :class:`dict`\n        built-in.\n        \"\"\"\n        self._componentValues = []\n        self._dynamicNames = self.DynamicNames()\n        return self\n\n    def reset(self):\n        \"\"\"Remove all components and become a |ASN.1| schema object.\n\n        See :meth:`isValue` property for more information on the\n        distinction between value and schema objects.\n        \"\"\"\n        self._componentValues = noValue\n        self._dynamicNames = self.DynamicNames()\n        return self\n\n    @property\n    def components(self):\n        return self._componentValues\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        if self._componentValues is noValue:\n            return\n\n        for idx, componentValue in enumerate(self._componentValues):\n            if componentValue is not noValue:\n                if isinstance(componentValue, base.ConstructedAsn1Type):\n                    myClone.setComponentByPosition(\n                        idx, componentValue.clone(cloneValueFlag=cloneValueFlag)\n                    )\n                else:\n                    myClone.setComponentByPosition(idx, componentValue.clone())\n\n    def getComponentByName(self, name, default=noValue, instantiate=True):\n        \"\"\"Returns |ASN.1| type component by name.\n\n        Equivalent to Python :class:`dict` subscription operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        name: :class:`str`\n            |ASN.1| type component name\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically\n            instantiated.\n            If :obj:`False` either existing component or the :class:`NoValue`\n            object will be returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            Instantiate |ASN.1| component type or return existing\n            component value\n        \"\"\"\n        if self._componentTypeLen:\n            idx = self.componentType.getPositionByName(name)\n        else:\n            try:\n                idx = self._dynamicNames.getPositionByName(name)\n\n            except KeyError:\n                raise error.PyAsn1Error('Name %s not found' % (name,))\n\n        return self.getComponentByPosition(idx, default=default, instantiate=instantiate)\n\n    def setComponentByName(self, name, value=noValue,\n                           verifyConstraints=True,\n                           matchTags=True,\n                           matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by name.\n\n        Equivalent to Python :class:`dict` item assignment operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        name: :class:`str`\n            |ASN.1| type component name\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints: :class:`bool`\n             If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n             If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n             If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n        \"\"\"\n        if self._componentTypeLen:\n            idx = self.componentType.getPositionByName(name)\n        else:\n            try:\n                idx = self._dynamicNames.getPositionByName(name)\n\n            except KeyError:\n                raise error.PyAsn1Error('Name %s not found' % (name,))\n\n        return self.setComponentByPosition(\n            idx, value, verifyConstraints, matchTags, matchConstraints\n        )\n\n    def getComponentByPosition(self, idx, default=noValue, instantiate=True):\n        \"\"\"Returns |ASN.1| type component by index.\n\n        Equivalent to Python sequence subscription operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx: :class:`int`\n            Component index (zero-based). Must either refer to an existing\n            component or (if *componentType* is set) new ASN.1 schema object gets\n            instantiated.\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically\n            instantiated.\n            If :obj:`False` either existing component or the :class:`NoValue`\n            object will be returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            a PyASN1 object\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            # can also be Set\n            class MySequence(Sequence):\n                componentType = NamedTypes(\n                    NamedType('id', OctetString())\n                )\n\n            s = MySequence()\n\n            # returns component #0 with `.isValue` property False\n            s.getComponentByPosition(0)\n\n            # returns None\n            s.getComponentByPosition(0, default=None)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n\n            # sets component #0 to OctetString() ASN.1 schema\n            # object and returns it\n            s.getComponentByPosition(0, instantiate=True)\n\n            # sets component #0 to ASN.1 value object\n            s.setComponentByPosition(0, 'ABCD')\n\n            # returns OctetString('ABCD') value object\n            s.getComponentByPosition(0, instantiate=False)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n        \"\"\"\n        try:\n            if self._componentValues is noValue:\n                componentValue = noValue\n\n            else:\n                componentValue = self._componentValues[idx]\n\n        except IndexError:\n            componentValue = noValue\n\n        if not instantiate:\n            if componentValue is noValue or not componentValue.isValue:\n                return default\n            else:\n                return componentValue\n\n        if componentValue is noValue:\n            self.setComponentByPosition(idx)\n\n        componentValue = self._componentValues[idx]\n\n        if default is noValue or componentValue.isValue:\n            return componentValue\n        else:\n            return default\n\n    def setComponentByPosition(self, idx, value=noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by position.\n\n        Equivalent to Python sequence item assignment operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx : :class:`int`\n            Component index (zero-based). Must either refer to existing\n            component (if *componentType* is set) or to N+1 component\n            otherwise. In the latter case a new component of given ASN.1\n            type gets instantiated and appended to |ASN.1| sequence.\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints : :class:`bool`\n             If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n             If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n             If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n        \"\"\"\n        componentType = self.componentType\n        componentTypeLen = self._componentTypeLen\n\n        if self._componentValues is noValue:\n            componentValues = []\n\n        else:\n            componentValues = self._componentValues\n\n        try:\n            currentValue = componentValues[idx]\n\n        except IndexError:\n            currentValue = noValue\n            if componentTypeLen:\n                if componentTypeLen < idx:\n                    raise error.PyAsn1Error('component index out of range')\n\n                componentValues = [noValue] * componentTypeLen\n\n        if value is noValue:\n            if componentTypeLen:\n                value = componentType.getTypeByPosition(idx)\n                if isinstance(value, base.ConstructedAsn1Type):\n                    value = value.clone(cloneValueFlag=componentType[idx].isDefaulted)\n\n            elif currentValue is noValue:\n                raise error.PyAsn1Error('Component type not defined')\n\n        elif not isinstance(value, base.Asn1Item):\n            if componentTypeLen:\n                subComponentType = componentType.getTypeByPosition(idx)\n                if isinstance(subComponentType, base.SimpleAsn1Type):\n                    value = subComponentType.clone(value=value)\n\n                else:\n                    raise error.PyAsn1Error('%s can cast only scalar values' % componentType.__class__.__name__)\n\n            elif currentValue is not noValue and isinstance(currentValue, base.SimpleAsn1Type):\n                value = currentValue.clone(value=value)\n\n            else:\n                raise error.PyAsn1Error('%s undefined component type' % componentType.__class__.__name__)\n\n        elif ((verifyConstraints or matchTags or matchConstraints) and\n              componentTypeLen):\n            subComponentType = componentType.getTypeByPosition(idx)\n            if subComponentType is not noValue:\n                subtypeChecker = (self.strictConstraints and\n                                  subComponentType.isSameTypeWith or\n                                  subComponentType.isSuperTypeOf)\n\n                if not subtypeChecker(value, verifyConstraints and matchTags,\n                                      verifyConstraints and matchConstraints):\n                    if not componentType[idx].openType:\n                        raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))\n\n        if componentTypeLen or idx in self._dynamicNames:\n            componentValues[idx] = value\n\n        elif len(componentValues) == idx:\n            componentValues.append(value)\n            self._dynamicNames.addField(idx)\n\n        else:\n            raise error.PyAsn1Error('Component index out of range')\n\n        self._componentValues = componentValues\n\n        return self\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema features,\n        this object can also be used like a Python built-in object (e.g.\n        :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a\n            normal value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n\n        It is sufficient for |ASN.1| objects to have all non-optional and non-defaulted\n        components being value objects to be considered as a value objects as a whole.\n        In other words, even having one or more optional components not turned into\n        value objects, |ASN.1| object is still considered as a value object. Defaulted\n        components are normally value objects by default.\n        \"\"\"\n        if self._componentValues is noValue:\n            return False\n\n        componentType = self.componentType\n\n        if componentType:\n            for idx, subComponentType in enumerate(componentType.namedTypes):\n                if subComponentType.isDefaulted or subComponentType.isOptional:\n                    continue\n\n                if not self._componentValues:\n                    return False\n\n                componentValue = self._componentValues[idx]\n                if componentValue is noValue or not componentValue.isValue:\n                    return False\n\n        else:\n            for componentValue in self._componentValues:\n                if componentValue is noValue or not componentValue.isValue:\n                    return False\n\n        return True\n\n    @property\n    def isInconsistent(self):\n        \"\"\"Run necessary checks to ensure |ASN.1| object consistency.\n\n        Default action is to verify |ASN.1| object against constraints imposed\n        by `subtypeSpec`.\n\n        Raises\n        ------\n        :py:class:`~pyasn1.error.PyAsn1tError` on any inconsistencies found\n        \"\"\"\n        if self.componentType is noValue or not self.subtypeSpec:\n            return False\n\n        if self._componentValues is noValue:\n            return True\n\n        mapping = {}\n\n        for idx, value in enumerate(self._componentValues):\n            # Absent fields are not in the mapping\n            if value is noValue:\n                continue\n\n            name = self.componentType.getNameByPosition(idx)\n\n            mapping[name] = value\n\n        try:\n            # Represent Sequence/Set as a bare dict to constraints chain\n            self.subtypeSpec(mapping)\n\n        except error.PyAsn1Error:\n            exc = sys.exc_info()[1]\n            return exc\n\n        return False\n\n    def prettyPrint(self, scope=0):\n        \"\"\"Return an object representation string.\n\n        Returns\n        -------\n        : :class:`str`\n            Human-friendly object representation.\n        \"\"\"\n        scope += 1\n        representation = self.__class__.__name__ + ':\\n'\n        for idx, componentValue in enumerate(self._componentValues):\n            if componentValue is not noValue and componentValue.isValue:\n                representation += ' ' * scope\n                if self.componentType:\n                    representation += self.componentType.getNameByPosition(idx)\n                else:\n                    representation += self._dynamicNames.getNameByPosition(idx)\n                representation = '%s=%s\\n' % (\n                    representation, componentValue.prettyPrint(scope)\n                )\n        return representation\n\n    def prettyPrintType(self, scope=0):\n        scope += 1\n        representation = '%s -> %s {\\n' % (self.tagSet, self.__class__.__name__)\n        for idx, componentType in enumerate(self.componentType.values() or self._componentValues):\n            representation += ' ' * scope\n            if self.componentType:\n                representation += '\"%s\"' % self.componentType.getNameByPosition(idx)\n            else:\n                representation += '\"%s\"' % self._dynamicNames.getNameByPosition(idx)\n            representation = '%s = %s\\n' % (\n                representation, componentType.prettyPrintType(scope)\n            )\n        return representation + '\\n' + ' ' * (scope - 1) + '}'\n\n    # backward compatibility\n\n    def setDefaultComponents(self):\n        return self\n\n    def getComponentType(self):\n        if self._componentTypeLen:\n            return self.componentType\n\n    def getNameByPosition(self, idx):\n        if self._componentTypeLen:\n            return self.componentType[idx].name\n\nclass Sequence(SequenceAndSetBase):\n    __doc__ = SequenceAndSetBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)\n    #: object imposing size constraint on |ASN.1| objects\n    componentType = namedtype.NamedTypes()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceAndSetBase.getTypeId()\n\n    # backward compatibility\n\n    def getComponentTagMapNearPosition(self, idx):\n        if self.componentType:\n            return self.componentType.getTagMapNearPosition(idx)\n\n    def getComponentPositionNearType(self, tagSet, idx):\n        if self.componentType:\n            return self.componentType.getPositionNearType(tagSet, idx)\n        else:\n            return idx\n\n\nclass Set(SequenceAndSetBase):\n    __doc__ = SequenceAndSetBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)\n    )\n\n    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = namedtype.NamedTypes()\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceAndSetBase.getTypeId()\n\n    def getComponent(self, innerFlag=False):\n        return self\n\n    def getComponentByType(self, tagSet, default=noValue,\n                           instantiate=True, innerFlag=False):\n        \"\"\"Returns |ASN.1| type component by ASN.1 tag.\n\n        Parameters\n        ----------\n        tagSet : :py:class:`~pyasn1.type.tag.TagSet`\n            Object representing ASN.1 tags to identify one of\n            |ASN.1| object component\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically\n            instantiated.\n            If :obj:`False` either existing component or the :class:`noValue`\n            object will be returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            a pyasn1 object\n        \"\"\"\n        componentValue = self.getComponentByPosition(\n            self.componentType.getPositionByType(tagSet),\n            default=default, instantiate=instantiate\n        )\n        if innerFlag and isinstance(componentValue, Set):\n            # get inner component by inner tagSet\n            return componentValue.getComponent(innerFlag=True)\n        else:\n            # get outer component by inner tagSet\n            return componentValue\n\n    def setComponentByType(self, tagSet, value=noValue,\n                           verifyConstraints=True,\n                           matchTags=True,\n                           matchConstraints=True,\n                           innerFlag=False):\n        \"\"\"Assign |ASN.1| type component by ASN.1 tag.\n\n        Parameters\n        ----------\n        tagSet : :py:class:`~pyasn1.type.tag.TagSet`\n            Object representing ASN.1 tags to identify one of\n            |ASN.1| object component\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints : :class:`bool`\n            If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n            If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n            If :obj:`False`, skip component constraints matching\n\n        innerFlag: :class:`bool`\n            If :obj:`True`, search for matching *tagSet* recursively.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        idx = self.componentType.getPositionByType(tagSet)\n\n        if innerFlag:  # set inner component by inner tagSet\n            componentType = self.componentType.getTypeByPosition(idx)\n\n            if componentType.tagSet:\n                return self.setComponentByPosition(\n                    idx, value, verifyConstraints, matchTags, matchConstraints\n                )\n            else:\n                componentType = self.getComponentByPosition(idx)\n                return componentType.setComponentByType(\n                    tagSet, value, verifyConstraints, matchTags, matchConstraints, innerFlag=innerFlag\n                )\n        else:  # set outer component by inner tagSet\n            return self.setComponentByPosition(\n                idx, value, verifyConstraints, matchTags, matchConstraints\n            )\n\n    @property\n    def componentTagMap(self):\n        if self.componentType:\n            return self.componentType.tagMapUnique\n\n\nclass Choice(Set):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.ConstructedAsn1Type`,\n    its objects are mutable and duck-type Python :class:`list` objects.\n\n    Keyword Args\n    ------------\n    componentType: :py:class:`~pyasn1.type.namedtype.NamedType`\n        Object holding named ASN.1 types allowed within this collection\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s).  Constraints\n        verification for |ASN.1| type can only occur on explicit\n        `.isInconsistent` call.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Afters(Choice):\n            '''\n            ASN.1 specification:\n\n            Afters ::= CHOICE {\n                cheese  [0] IA5String,\n                dessert [1] IA5String\n            }\n            '''\n            componentType = NamedTypes(\n                NamedType('cheese', IA5String().subtype(\n                    implicitTag=Tag(tagClassContext, tagFormatSimple, 0)\n                ),\n                NamedType('dessert', IA5String().subtype(\n                    implicitTag=Tag(tagClassContext, tagFormatSimple, 1)\n                )\n            )\n\n        afters = Afters()\n        afters['cheese'] = 'Mascarpone'\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.TagSet()  # untagged\n\n    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = namedtype.NamedTypes()\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection(\n        constraint.ValueSizeConstraint(1, 1)\n    )\n\n    # Disambiguation ASN.1 types identification\n    typeId = Set.getTypeId()\n\n    _currentIdx = None\n\n    def __eq__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] == other\n        return NotImplemented\n\n    def __ne__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] != other\n        return NotImplemented\n\n    def __lt__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] < other\n        return NotImplemented\n\n    def __le__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] <= other\n        return NotImplemented\n\n    def __gt__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] > other\n        return NotImplemented\n\n    def __ge__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] >= other\n        return NotImplemented\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self._componentValues and True or False\n    else:\n        def __bool__(self):\n            return self._componentValues and True or False\n\n    def __len__(self):\n        return self._currentIdx is not None and 1 or 0\n\n    def __contains__(self, key):\n        if self._currentIdx is None:\n            return False\n        return key == self.componentType[self._currentIdx].getName()\n\n    def __iter__(self):\n        if self._currentIdx is None:\n            raise StopIteration\n        yield self.componentType[self._currentIdx].getName()\n\n    # Python dict protocol\n\n    def values(self):\n        if self._currentIdx is not None:\n            yield self._componentValues[self._currentIdx]\n\n    def keys(self):\n        if self._currentIdx is not None:\n            yield self.componentType[self._currentIdx].getName()\n\n    def items(self):\n        if self._currentIdx is not None:\n            yield self.componentType[self._currentIdx].getName(), self[self._currentIdx]\n\n    def checkConsistency(self):\n        if self._currentIdx is None:\n            raise error.PyAsn1Error('Component not chosen')\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        try:\n            component = self.getComponent()\n        except error.PyAsn1Error:\n            pass\n        else:\n            if isinstance(component, Choice):\n                tagSet = component.effectiveTagSet\n            else:\n                tagSet = component.tagSet\n            if isinstance(component, base.ConstructedAsn1Type):\n                myClone.setComponentByType(\n                    tagSet, component.clone(cloneValueFlag=cloneValueFlag)\n                )\n            else:\n                myClone.setComponentByType(tagSet, component.clone())\n\n    def getComponentByPosition(self, idx, default=noValue, instantiate=True):\n        __doc__ = Set.__doc__\n\n        if self._currentIdx is None or self._currentIdx != idx:\n            return Set.getComponentByPosition(self, idx, default=default,\n                                              instantiate=instantiate)\n\n        return self._componentValues[idx]\n\n    def setComponentByPosition(self, idx, value=noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by position.\n\n        Equivalent to Python sequence item assignment operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx: :class:`int`\n            Component index (zero-based). Must either refer to existing\n            component or to N+1 component. In the latter case a new component\n            type gets instantiated (if *componentType* is set, or given ASN.1\n            object is taken otherwise) and appended to the |ASN.1| sequence.\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component. Once a new value is\n            set to *idx* component, previous value is dropped.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints : :class:`bool`\n            If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n            If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n            If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n        \"\"\"\n        oldIdx = self._currentIdx\n        Set.setComponentByPosition(self, idx, value, verifyConstraints, matchTags, matchConstraints)\n        self._currentIdx = idx\n        if oldIdx is not None and oldIdx != idx:\n            self._componentValues[oldIdx] = noValue\n        return self\n\n    @property\n    def effectiveTagSet(self):\n        \"\"\"Return a :class:`~pyasn1.type.tag.TagSet` object of the currently initialized component or self (if |ASN.1| is tagged).\"\"\"\n        if self.tagSet:\n            return self.tagSet\n        else:\n            component = self.getComponent()\n            return component.effectiveTagSet\n\n    @property\n    def tagMap(self):\n        \"\"\"\"Return a :class:`~pyasn1.type.tagmap.TagMap` object mapping\n            ASN.1 tags to ASN.1 objects contained within callee.\n        \"\"\"\n        if self.tagSet:\n            return Set.tagMap.fget(self)\n        else:\n            return self.componentType.tagMapUnique\n\n    def getComponent(self, innerFlag=False):\n        \"\"\"Return currently assigned component of the |ASN.1| object.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            a PyASN1 object\n        \"\"\"\n        if self._currentIdx is None:\n            raise error.PyAsn1Error('Component not chosen')\n        else:\n            c = self._componentValues[self._currentIdx]\n            if innerFlag and isinstance(c, Choice):\n                return c.getComponent(innerFlag)\n            else:\n                return c\n\n    def getName(self, innerFlag=False):\n        \"\"\"Return the name of currently assigned component of the |ASN.1| object.\n\n        Returns\n        -------\n        : :py:class:`str`\n            |ASN.1| component name\n        \"\"\"\n        if self._currentIdx is None:\n            raise error.PyAsn1Error('Component not chosen')\n        else:\n            if innerFlag:\n                c = self._componentValues[self._currentIdx]\n                if isinstance(c, Choice):\n                    return c.getName(innerFlag)\n            return self.componentType.getNameByPosition(self._currentIdx)\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema features,\n        this object can also be used like a Python built-in object (e.g.\n        :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a normal\n            value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n        \"\"\"\n        if self._currentIdx is None:\n            return False\n\n        componentValue = self._componentValues[self._currentIdx]\n\n        return componentValue is not noValue and componentValue.isValue\n\n    def clear(self):\n        self._currentIdx = None\n        return Set.clear(self)\n\n    # compatibility stubs\n\n    def getMinTagSet(self):\n        return self.minTagSet\n\n\nclass Any(OctetString):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`,\n    its objects are immutable and duck-type Python 2 :class:`str` or Python 3\n    :class:`bytes`. When used in Unicode context, |ASN.1| type assumes\n    \"|encoding|\" serialisation.\n\n    Keyword Args\n    ------------\n    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object\n        :class:`str` (Python 2) or :class:`bytes` (Python 3), alternatively\n        :class:`unicode` object (Python 2) or :class:`str` (Python 3)\n        representing character string to be serialised into octets (note\n        `encoding` parameter) or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    encoding: :py:class:`str`\n        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or\n        :class:`str` (Python 3) the payload when |ASN.1| object is used\n        in text string context.\n\n    binValue: :py:class:`str`\n        Binary string initializer to use instead of the *value*.\n        Example: '10110011'.\n\n    hexValue: :py:class:`str`\n        Hexadecimal string initializer to use instead of the *value*.\n        Example: 'DEADBEEF'.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Error(Sequence):\n            '''\n            ASN.1 specification:\n\n            Error ::= SEQUENCE {\n                code      INTEGER,\n                parameter ANY DEFINED BY code  -- Either INTEGER or REAL\n            }\n            '''\n            componentType=NamedTypes(\n                NamedType('code', Integer()),\n                NamedType('parameter', Any(),\n                          openType=OpenType('code', {1: Integer(),\n                                                     2: Real()}))\n            )\n\n        error = Error()\n        error['code'] = 1\n        error['parameter'] = Integer(1234)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.TagSet()  # untagged\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = OctetString.getTypeId()\n\n    @property\n    def tagMap(self):\n        \"\"\"\"Return a :class:`~pyasn1.type.tagmap.TagMap` object mapping\n            ASN.1 tags to ASN.1 objects contained within callee.\n        \"\"\"\n        try:\n            return self._tagMap\n\n        except AttributeError:\n            self._tagMap = tagmap.TagMap(\n                {self.tagSet: self},\n                {eoo.endOfOctets.tagSet: eoo.endOfOctets},\n                self\n            )\n\n            return self._tagMap\n\n# XXX\n# coercion rules?\n", "pyasn1/compat/octets.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom sys import version_info\n\nif version_info[0] <= 2:\n    int2oct = chr\n    # noinspection PyPep8\n    ints2octs = lambda s: ''.join([int2oct(x) for x in s])\n    null = ''\n    oct2int = ord\n    # TODO: refactor to return a sequence of ints\n    # noinspection PyPep8\n    octs2ints = lambda s: [oct2int(x) for x in s]\n    # noinspection PyPep8\n    str2octs = lambda x: x\n    # noinspection PyPep8\n    octs2str = lambda x: x\n    # noinspection PyPep8\n    isOctetsType = lambda s: isinstance(s, str)\n    # noinspection PyPep8\n    isStringType = lambda s: isinstance(s, (str, unicode))\n    # noinspection PyPep8\n    ensureString = str\nelse:\n    ints2octs = bytes\n    # noinspection PyPep8\n    int2oct = lambda x: ints2octs((x,))\n    null = ints2octs()\n    # noinspection PyPep8\n    oct2int = lambda x: x\n    # noinspection PyPep8\n    octs2ints = lambda x: x\n    # noinspection PyPep8\n    str2octs = lambda x: x.encode('iso-8859-1')\n    # noinspection PyPep8\n    octs2str = lambda x: x.decode('iso-8859-1')\n    # noinspection PyPep8\n    isOctetsType = lambda s: isinstance(s, bytes)\n    # noinspection PyPep8\n    isStringType = lambda s: isinstance(s, str)\n    # noinspection PyPep8\n    ensureString = bytes\n", "pyasn1/compat/integer.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport platform\n\nfrom pyasn1.compat.octets import oct2int, null, ensureString\n\n\nimplementation = platform.python_implementation()\n\nif sys.version_info[0] < 3:\n    from binascii import a2b_hex, b2a_hex\n\n    def from_bytes(octets, signed=False):\n        if not octets:\n            return 0\n\n        value = long(b2a_hex(ensureString(octets)), 16)\n\n        if signed and oct2int(octets[0]) & 0x80:\n            return value - (1 << len(octets) * 8)\n\n        return value\n\n    def to_bytes(value, signed=False, length=0):\n        if value < 0:\n            if signed:\n                bits = bitLength(value)\n\n                # two's complement form\n                maxValue = 1 << bits\n                valueToEncode = (value + maxValue) % maxValue\n\n            else:\n                raise OverflowError('can\\'t convert negative int to unsigned')\n        elif value == 0 and length == 0:\n            return null\n        else:\n            bits = 0\n            valueToEncode = value\n\n        hexValue = hex(valueToEncode)[2:]\n        if hexValue.endswith('L'):\n            hexValue = hexValue[:-1]\n\n        if len(hexValue) & 1:\n            hexValue = '0' + hexValue\n\n        # padding may be needed for two's complement encoding\n        if value != valueToEncode or length:\n            hexLength = len(hexValue) * 4\n\n            padLength = max(length, bits)\n\n            if padLength > hexLength:\n                hexValue = '00' * ((padLength - hexLength - 1) // 8 + 1) + hexValue\n            elif length and hexLength - length > 7:\n                raise OverflowError('int too big to convert')\n\n        firstOctet = int(hexValue[:2], 16)\n\n        if signed:\n            if firstOctet & 0x80:\n                if value >= 0:\n                    hexValue = '00' + hexValue\n            elif value < 0:\n                hexValue = 'ff' + hexValue\n\n        octets_value = a2b_hex(hexValue)\n\n        return octets_value\n\n    def bitLength(number):\n        # bits in unsigned number\n        hexValue = hex(abs(number))\n        bits = len(hexValue) - 2\n        if hexValue.endswith('L'):\n            bits -= 1\n        if bits & 1:\n            bits += 1\n        bits *= 4\n        # TODO: strip lhs zeros\n        return bits\n\nelse:\n\n    def from_bytes(octets, signed=False):\n        return int.from_bytes(bytes(octets), 'big', signed=signed)\n\n    def to_bytes(value, signed=False, length=0):\n        length = max(value.bit_length(), length)\n\n        if signed and length % 8 == 0:\n            length += 1\n\n        return value.to_bytes(length // 8 + (length % 8 and 1 or 0), 'big', signed=signed)\n\n    def bitLength(number):\n        return int(number).bit_length()\n", "pyasn1/compat/__init__.py": "# This file is necessary to make this directory a package.\n\n# sentinal for missing argument\n_MISSING = object()\n", "pyasn1/codec/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/streaming.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2019, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport io\nimport os\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import univ\n\n_PY2 = sys.version_info < (3,)\n\n\nclass CachingStreamWrapper(io.IOBase):\n    \"\"\"Wrapper around non-seekable streams.\n\n    Note that the implementation is tied to the decoder,\n    not checking for dangerous arguments for the sake\n    of performance.\n\n    The read bytes are kept in an internal cache until\n    setting _markedPosition which may reset the cache.\n    \"\"\"\n    def __init__(self, raw):\n        self._raw = raw\n        self._cache = io.BytesIO()\n        self._markedPosition = 0\n\n    def peek(self, n):\n        result = self.read(n)\n        self._cache.seek(-len(result), os.SEEK_CUR)\n        return result\n\n    def seekable(self):\n        return True\n\n    def seek(self, n=-1, whence=os.SEEK_SET):\n        # Note that this not safe for seeking forward.\n        return self._cache.seek(n, whence)\n\n    def read(self, n=-1):\n        read_from_cache = self._cache.read(n)\n        if n != -1:\n            n -= len(read_from_cache)\n            if not n:  # 0 bytes left to read\n                return read_from_cache\n\n        read_from_raw = self._raw.read(n)\n\n        self._cache.write(read_from_raw)\n\n        return read_from_cache + read_from_raw\n\n    @property\n    def markedPosition(self):\n        \"\"\"Position where the currently processed element starts.\n\n        This is used for back-tracking in SingleItemDecoder.__call__\n        and (indefLen)ValueDecoder and should not be used for other purposes.\n        The client is not supposed to ever seek before this position.\n        \"\"\"\n        return self._markedPosition\n\n    @markedPosition.setter\n    def markedPosition(self, value):\n        # By setting the value, we ensure we won't seek back before it.\n        # `value` should be the same as the current position\n        # We don't check for this for performance reasons.\n        self._markedPosition = value\n\n        # Whenever we set _marked_position, we know for sure\n        # that we will not return back, and thus it is\n        # safe to drop all cached data.\n        if self._cache.tell() > io.DEFAULT_BUFFER_SIZE:\n            self._cache = io.BytesIO(self._cache.read())\n            self._markedPosition = 0\n\n    def tell(self):\n        return self._cache.tell()\n\n\ndef asSeekableStream(substrate):\n    \"\"\"Convert object to seekable byte-stream.\n\n    Parameters\n    ----------\n    substrate: :py:class:`bytes` or :py:class:`io.IOBase` or :py:class:`univ.OctetString`\n\n    Returns\n    -------\n    : :py:class:`io.IOBase`\n\n    Raises\n    ------\n    : :py:class:`~pyasn1.error.PyAsn1Error`\n        If the supplied substrate cannot be converted to a seekable stream.\n    \"\"\"\n    if isinstance(substrate, io.BytesIO):\n        return substrate\n\n    elif isinstance(substrate, bytes):\n        return io.BytesIO(substrate)\n\n    elif isinstance(substrate, univ.OctetString):\n        return io.BytesIO(substrate.asOctets())\n\n    try:\n        # Special case: impossible to set attributes on `file` built-in\n        # XXX: broken, BufferedReader expects a \"readable\" attribute.\n        if _PY2 and isinstance(substrate, file):\n            return io.BufferedReader(substrate)\n\n        elif substrate.seekable():  # Will fail for most invalid types\n            return substrate\n\n        else:\n            return CachingStreamWrapper(substrate)\n\n    except AttributeError:\n        raise error.UnsupportedSubstrateError(\n            \"Cannot convert \" + substrate.__class__.__name__ +\n            \" to a seekable bit stream.\")\n\n\ndef isEndOfStream(substrate):\n    \"\"\"Check whether we have reached the end of a stream.\n\n    Although it is more effective to read and catch exceptions, this\n    function\n\n    Parameters\n    ----------\n    substrate: :py:class:`IOBase`\n        Stream to check\n\n    Returns\n    -------\n    : :py:class:`bool`\n    \"\"\"\n    if isinstance(substrate, io.BytesIO):\n        cp = substrate.tell()\n        substrate.seek(0, os.SEEK_END)\n        result = substrate.tell() == cp\n        substrate.seek(cp, os.SEEK_SET)\n        yield result\n\n    else:\n        received = substrate.read(1)\n        if received is None:\n            yield\n\n        if received:\n            substrate.seek(-1, os.SEEK_CUR)\n\n        yield not received\n\n\ndef peekIntoStream(substrate, size=-1):\n    \"\"\"Peek into stream.\n\n    Parameters\n    ----------\n    substrate: :py:class:`IOBase`\n        Stream to read from.\n\n    size: :py:class:`int`\n        How many bytes to peek (-1 = all available)\n\n    Returns\n    -------\n    : :py:class:`bytes` or :py:class:`str`\n        The return type depends on Python major version\n    \"\"\"\n    if hasattr(substrate, \"peek\"):\n        received = substrate.peek(size)\n        if received is None:\n            yield\n\n        while len(received) < size:\n            yield\n\n        yield received\n\n    else:\n        current_position = substrate.tell()\n        try:\n            for chunk in readFromStream(substrate, size):\n                yield chunk\n\n        finally:\n            substrate.seek(current_position)\n\n\ndef readFromStream(substrate, size=-1, context=None):\n    \"\"\"Read from the stream.\n\n    Parameters\n    ----------\n    substrate: :py:class:`IOBase`\n        Stream to read from.\n\n    Keyword parameters\n    ------------------\n    size: :py:class:`int`\n        How many bytes to read (-1 = all available)\n\n    context: :py:class:`dict`\n        Opaque caller context will be attached to exception objects created\n        by this function.\n\n    Yields\n    ------\n    : :py:class:`bytes` or :py:class:`str` or :py:class:`SubstrateUnderrunError`\n        Read data or :py:class:`~pyasn1.error.SubstrateUnderrunError`\n        object if no `size` bytes is readily available in the stream. The\n        data type depends on Python major version\n\n    Raises\n    ------\n    : :py:class:`~pyasn1.error.EndOfStreamError`\n        Input stream is exhausted\n    \"\"\"\n    while True:\n        # this will block unless stream is non-blocking\n        received = substrate.read(size)\n        if received is None:  # non-blocking stream can do this\n            yield error.SubstrateUnderrunError(context=context)\n\n        elif not received and size != 0:  # end-of-stream\n            raise error.EndOfStreamError(context=context)\n\n        elif len(received) < size:\n            substrate.seek(-len(received), os.SEEK_CUR)\n\n            # behave like a non-blocking stream\n            yield error.SubstrateUnderrunError(context=context)\n\n        else:\n            break\n\n    yield received\n", "pyasn1/codec/cer/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\nfrom pyasn1.codec.streaming import readFromStream\nfrom pyasn1.codec.ber import decoder\nfrom pyasn1.compat.octets import oct2int\nfrom pyasn1.type import univ\n\n__all__ = ['decode', 'StreamingDecoder']\n\nSubstrateUnderrunError = error.SubstrateUnderrunError\n\n\nclass BooleanPayloadDecoder(decoder.AbstractSimplePayloadDecoder):\n    protoComponent = univ.Boolean(0)\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if length != 1:\n            raise error.PyAsn1Error('Not single-octet Boolean payload')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        byte = oct2int(chunk[0])\n\n        # CER/DER specifies encoding of TRUE as 0xFF and FALSE as 0x0, while\n        # BER allows any non-zero value as TRUE; cf. sections 8.2.2. and 11.1 \n        # in https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n        if byte == 0xff:\n            value = 1\n\n        elif byte == 0x00:\n            value = 0\n\n        else:\n            raise error.PyAsn1Error('Unexpected Boolean payload: %s' % byte)\n\n        yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n\n# TODO: prohibit non-canonical encoding\nBitStringPayloadDecoder = decoder.BitStringPayloadDecoder\nOctetStringPayloadDecoder = decoder.OctetStringPayloadDecoder\nRealPayloadDecoder = decoder.RealPayloadDecoder\n\nTAG_MAP = decoder.TAG_MAP.copy()\nTAG_MAP.update(\n    {univ.Boolean.tagSet: BooleanPayloadDecoder(),\n     univ.BitString.tagSet: BitStringPayloadDecoder(),\n     univ.OctetString.tagSet: OctetStringPayloadDecoder(),\n     univ.Real.tagSet: RealPayloadDecoder()}\n)\n\nTYPE_MAP = decoder.TYPE_MAP.copy()\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in TAG_MAP.values():\n    if typeDecoder.protoComponent is not None:\n        typeId = typeDecoder.protoComponent.__class__.typeId\n        if typeId is not None and typeId not in TYPE_MAP:\n            TYPE_MAP[typeId] = typeDecoder\n\n\nclass SingleItemDecoder(decoder.SingleItemDecoder):\n    __doc__ = decoder.SingleItemDecoder.__doc__\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n\nclass StreamingDecoder(decoder.StreamingDecoder):\n    __doc__ = decoder.StreamingDecoder.__doc__\n\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n\nclass Decoder(decoder.Decoder):\n    __doc__ = decoder.Decoder.__doc__\n\n    STREAMING_DECODER = StreamingDecoder\n\n\n#: Turns CER octet stream into an ASN.1 object.\n#:\n#: Takes CER octet-stream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     CER octet-stream\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from CER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error, ~pyasn1.error.SubstrateUnderrunError\n#:     On decoding errors\n#:\n#: Examples\n#: --------\n#: Decode CER serialisation without ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> s, _ = decode(b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00')\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\n#: Decode CER serialisation with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode(b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00', asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/cer/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/cer/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import encoder\nfrom pyasn1.compat.octets import str2octs, null\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['Encoder', 'encode']\n\n\nclass BooleanEncoder(encoder.IntegerEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if value == 0:\n            substrate = (0,)\n        else:\n            substrate = (255,)\n        return substrate, False, False\n\n\nclass RealEncoder(encoder.RealEncoder):\n    def _chooseEncBase(self, value):\n        m, b, e = value\n        return self._dropFloatingPoint(m, b, e)\n\n\n# specialized GeneralStringEncoder here\n\nclass TimeEncoderMixIn(object):\n    Z_CHAR = ord('Z')\n    PLUS_CHAR = ord('+')\n    MINUS_CHAR = ord('-')\n    COMMA_CHAR = ord(',')\n    DOT_CHAR = ord('.')\n    ZERO_CHAR = ord('0')\n\n    MIN_LENGTH = 12\n    MAX_LENGTH = 19\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        # CER encoding constraints:\n        # - minutes are mandatory, seconds are optional\n        # - sub-seconds must NOT be zero / no meaningless zeros\n        # - no hanging fraction dot\n        # - time in UTC (Z)\n        # - only dot is allowed for fractions\n\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        numbers = value.asNumbers()\n\n        if self.PLUS_CHAR in numbers or self.MINUS_CHAR in numbers:\n            raise error.PyAsn1Error('Must be UTC time: %r' % value)\n\n        if numbers[-1] != self.Z_CHAR:\n            raise error.PyAsn1Error('Missing \"Z\" time zone specifier: %r' % value)\n\n        if self.COMMA_CHAR in numbers:\n            raise error.PyAsn1Error('Comma in fractions disallowed: %r' % value)\n\n        if self.DOT_CHAR in numbers:\n\n            isModified = False\n\n            numbers = list(numbers)\n\n            searchIndex = min(numbers.index(self.DOT_CHAR) + 4, len(numbers) - 1)\n\n            while numbers[searchIndex] != self.DOT_CHAR:\n                if numbers[searchIndex] == self.ZERO_CHAR:\n                    del numbers[searchIndex]\n                    isModified = True\n\n                searchIndex -= 1\n\n            searchIndex += 1\n\n            if searchIndex < len(numbers):\n                if numbers[searchIndex] == self.Z_CHAR:\n                    # drop hanging comma\n                    del numbers[searchIndex - 1]\n                    isModified = True\n\n            if isModified:\n                value = value.clone(numbers)\n\n        if not self.MIN_LENGTH < len(numbers) < self.MAX_LENGTH:\n            raise error.PyAsn1Error('Length constraint violated: %r' % value)\n\n        options.update(maxChunkSize=1000)\n\n        return encoder.OctetStringEncoder.encodeValue(\n            self, value, asn1Spec, encodeFun, **options\n        )\n\n\nclass GeneralizedTimeEncoder(TimeEncoderMixIn, encoder.OctetStringEncoder):\n    MIN_LENGTH = 12\n    MAX_LENGTH = 20\n\n\nclass UTCTimeEncoder(TimeEncoderMixIn, encoder.OctetStringEncoder):\n    MIN_LENGTH = 10\n    MAX_LENGTH = 14\n\n\nclass SetOfEncoder(encoder.SequenceOfEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        chunks = self._encodeComponents(\n            value, asn1Spec, encodeFun, **options)\n\n        # sort by serialised and padded components\n        if len(chunks) > 1:\n            zero = str2octs('\\x00')\n            maxLen = max(map(len, chunks))\n            paddedChunks = [\n                (x.ljust(maxLen, zero), x) for x in chunks\n            ]\n            paddedChunks.sort(key=lambda x: x[0])\n\n            chunks = [x[1] for x in paddedChunks]\n\n        return null.join(chunks), True, True\n\n\nclass SequenceOfEncoder(encoder.SequenceOfEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        if options.get('ifNotEmpty', False) and not len(value):\n            return null, True, True\n\n        chunks = self._encodeComponents(\n            value, asn1Spec, encodeFun, **options)\n\n        return null.join(chunks), True, True\n\n\nclass SetEncoder(encoder.SequenceEncoder):\n    @staticmethod\n    def _componentSortKey(componentAndType):\n        \"\"\"Sort SET components by tag\n\n        Sort regardless of the Choice value (static sort)\n        \"\"\"\n        component, asn1Spec = componentAndType\n\n        if asn1Spec is None:\n            asn1Spec = component\n\n        if asn1Spec.typeId == univ.Choice.typeId and not asn1Spec.tagSet:\n            if asn1Spec.tagSet:\n                return asn1Spec.tagSet\n            else:\n                return asn1Spec.componentType.minTagSet\n        else:\n            return asn1Spec.tagSet\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        substrate = null\n\n        comps = []\n        compsMap = {}\n\n        if asn1Spec is None:\n            # instance of ASN.1 schema\n            inconsistency = value.isInconsistent\n            if inconsistency:\n                raise inconsistency\n\n            namedTypes = value.componentType\n\n            for idx, component in enumerate(value.values()):\n                if namedTypes:\n                    namedType = namedTypes[idx]\n\n                    if namedType.isOptional and not component.isValue:\n                            continue\n\n                    if namedType.isDefaulted and component == namedType.asn1Object:\n                            continue\n\n                    compsMap[id(component)] = namedType\n\n                else:\n                    compsMap[id(component)] = None\n\n                comps.append((component, asn1Spec))\n\n        else:\n            # bare Python value + ASN.1 schema\n            for idx, namedType in enumerate(asn1Spec.componentType.namedTypes):\n\n                try:\n                    component = value[namedType.name]\n\n                except KeyError:\n                    raise error.PyAsn1Error('Component name \"%s\" not found in %r' % (namedType.name, value))\n\n                if namedType.isOptional and namedType.name not in value:\n                    continue\n\n                if namedType.isDefaulted and component == namedType.asn1Object:\n                    continue\n\n                compsMap[id(component)] = namedType\n                comps.append((component, asn1Spec[idx]))\n\n        for comp, compType in sorted(comps, key=self._componentSortKey):\n            namedType = compsMap[id(comp)]\n\n            if namedType:\n                options.update(ifNotEmpty=namedType.isOptional)\n\n            chunk = encodeFun(comp, compType, **options)\n\n            # wrap open type blob if needed\n            if namedType and namedType.openType:\n                wrapType = namedType.asn1Object\n                if wrapType.tagSet and not wrapType.isSameTypeWith(comp):\n                    chunk = encodeFun(chunk, wrapType, **options)\n\n            substrate += chunk\n\n        return substrate, True, True\n\n\nclass SequenceEncoder(encoder.SequenceEncoder):\n    omitEmptyOptionals = True\n\n\nTAG_MAP = encoder.TAG_MAP.copy()\n\nTAG_MAP.update({\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    useful.GeneralizedTime.tagSet: GeneralizedTimeEncoder(),\n    useful.UTCTime.tagSet: UTCTimeEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SetOf.tagSet: SetOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder()\n})\n\nTYPE_MAP = encoder.TYPE_MAP.copy()\n\nTYPE_MAP.update({\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    useful.GeneralizedTime.typeId: GeneralizedTimeEncoder(),\n    useful.UTCTime.typeId: UTCTimeEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.Set.typeId: SetEncoder(),\n    univ.SetOf.typeId: SetOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder()\n})\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(encoder.SingleItemEncoder):\n    fixedDefLengthMode = False\n    fixedChunkSize = 1000\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n\nclass Encoder(encoder.Encoder):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n\n#: Turns ASN.1 object into CER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a CER octet stream.\n#:\n#: Parameters\n#: ----------\n#: value: either a Python or pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A Python or pyasn1 object to encode. If Python object is given, `asnSpec`\n#:     parameter is required to guide the encoding process.\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec:\n#:     Optional ASN.1 schema or value object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octet-stream\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode Python value into CER with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> encode([1, 2, 3], asn1Spec=seq)\n#:    b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00'\n#:\n#: Encode ASN.1 value object into CER\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00'\n#:\nencode = Encoder()\n\n# EncoderFactory queries class instance and builds a map of tags -> encoders\n", "pyasn1/codec/ber/eoo.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1.type import base\nfrom pyasn1.type import tag\n\n__all__ = ['endOfOctets']\n\n\nclass EndOfOctets(base.SimpleAsn1Type):\n    defaultValue = 0\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x00)\n    )\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = object.__new__(cls, *args, **kwargs)\n\n        return cls._instance\n\n\nendOfOctets = EndOfOctets()\n", "pyasn1/codec/ber/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport io\nimport os\nimport sys\n\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.codec.streaming import asSeekableStream\nfrom pyasn1.codec.streaming import isEndOfStream\nfrom pyasn1.codec.streaming import peekIntoStream\nfrom pyasn1.codec.streaming import readFromStream\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.compat.integer import from_bytes\nfrom pyasn1.compat.octets import oct2int, octs2ints, ints2octs, null\nfrom pyasn1.error import PyAsn1Error\nfrom pyasn1.type import base\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['StreamingDecoder', 'Decoder', 'decode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_DECODER)\n\nnoValue = base.noValue\n\nSubstrateUnderrunError = error.SubstrateUnderrunError\n\n\nclass AbstractPayloadDecoder(object):\n    protoComponent = None\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        \"\"\"Decode value with fixed byte length.\n\n        The decoder is allowed to consume as many bytes as necessary.\n        \"\"\"\n        raise error.PyAsn1Error('SingleItemDecoder not implemented for %s' % (tagSet,))  # TODO: Seems more like an NotImplementedError?\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        \"\"\"Decode value with undefined length.\n\n        The decoder is allowed to consume as many bytes as necessary.\n        \"\"\"\n        raise error.PyAsn1Error('Indefinite length mode decoder not implemented for %s' % (tagSet,)) # TODO: Seems more like an NotImplementedError?\n\n    @staticmethod\n    def _passAsn1Object(asn1Object, options):\n        if 'asn1Object' not in options:\n            options['asn1Object'] = asn1Object\n\n        return options\n\n\nclass AbstractSimplePayloadDecoder(AbstractPayloadDecoder):\n    @staticmethod\n    def substrateCollector(asn1Object, substrate, length, options):\n        for chunk in readFromStream(substrate, length, options):\n            yield chunk\n\n    def _createComponent(self, asn1Spec, tagSet, value, **options):\n        if options.get('native'):\n            return value\n        elif asn1Spec is None:\n            return self.protoComponent.clone(value, tagSet=tagSet)\n        elif value is noValue:\n            return asn1Spec\n        else:\n            return asn1Spec.clone(value)\n\n\nclass RawPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Any('')\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, '', **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        for value in decodeFun(substrate, asn1Spec, tagSet, length, **options):\n            yield value\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, '', **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        while True:\n            for value in decodeFun(\n                    substrate, asn1Spec, tagSet, length,\n                    allowEoo=True, **options):\n\n                if value is eoo.endOfOctets:\n                    return\n\n                yield value\n\n\nrawPayloadDecoder = RawPayloadDecoder()\n\n\nclass IntegerPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Integer(0)\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if chunk:\n            value = from_bytes(chunk, signed=True)\n\n        else:\n            value = 0\n\n        yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n\nclass BooleanPayloadDecoder(IntegerPayloadDecoder):\n    protoComponent = univ.Boolean(0)\n\n    def _createComponent(self, asn1Spec, tagSet, value, **options):\n        return IntegerPayloadDecoder._createComponent(\n            self, asn1Spec, tagSet, value and 1 or 0, **options)\n\n\nclass BitStringPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.BitString(())\n    supportConstructedForm = True\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if not length:\n            raise error.PyAsn1Error('Empty BIT STRING substrate')\n\n        for chunk in isEndOfStream(substrate):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if chunk:\n            raise error.PyAsn1Error('Empty BIT STRING substrate')\n\n        if tagSet[0].tagFormat == tag.tagFormatSimple:  # XXX what tag to check?\n\n            for trailingBits in readFromStream(substrate, 1, options):\n                if isinstance(trailingBits, SubstrateUnderrunError):\n                    yield trailingBits\n\n            trailingBits = ord(trailingBits)\n            if trailingBits > 7:\n                raise error.PyAsn1Error(\n                    'Trailing bits overflow %s' % trailingBits\n                )\n\n            for chunk in readFromStream(substrate, length - 1, options):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield chunk\n\n            value = self.protoComponent.fromOctetString(\n                chunk, internalFormat=True, padding=trailingBits)\n\n            yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n            return\n\n        if not self.supportConstructedForm:\n            raise error.PyAsn1Error('Constructed encoding form prohibited '\n                                    'at %s' % self.__class__.__name__)\n\n        if LOG:\n            LOG('assembling constructed serialization')\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        bitString = self.protoComponent.fromOctetString(null, internalFormat=True)\n\n        current_position = substrate.tell()\n\n        while substrate.tell() - current_position < length:\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            trailingBits = oct2int(component[0])\n            if trailingBits > 7:\n                raise error.PyAsn1Error(\n                    'Trailing bits overflow %s' % trailingBits\n                )\n\n            bitString = self.protoComponent.fromOctetString(\n                component[1:], internalFormat=True,\n                prepend=bitString, padding=trailingBits\n            )\n\n        yield self._createComponent(asn1Spec, tagSet, bitString, **options)\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        bitString = self.protoComponent.fromOctetString(null, internalFormat=True)\n\n        while True:  # loop over fragments\n\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    allowEoo=True, **options):\n\n                if component is eoo.endOfOctets:\n                    break\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            if component is eoo.endOfOctets:\n                break\n\n            trailingBits = oct2int(component[0])\n            if trailingBits > 7:\n                raise error.PyAsn1Error(\n                    'Trailing bits overflow %s' % trailingBits\n                )\n\n            bitString = self.protoComponent.fromOctetString(\n                component[1:], internalFormat=True,\n                prepend=bitString, padding=trailingBits\n            )\n\n        yield self._createComponent(asn1Spec, tagSet, bitString, **options)\n\n\nclass OctetStringPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.OctetString('')\n    supportConstructedForm = True\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if tagSet[0].tagFormat == tag.tagFormatSimple:  # XXX what tag to check?\n            for chunk in readFromStream(substrate, length, options):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield chunk\n\n            yield self._createComponent(asn1Spec, tagSet, chunk, **options)\n\n            return\n\n        if not self.supportConstructedForm:\n            raise error.PyAsn1Error('Constructed encoding form prohibited at %s' % self.__class__.__name__)\n\n        if LOG:\n            LOG('assembling constructed serialization')\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        header = null\n\n        original_position = substrate.tell()\n        # head = popSubstream(substrate, length)\n        while substrate.tell() - original_position < length:\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            header += component\n\n        yield self._createComponent(asn1Spec, tagSet, header, **options)\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if substrateFun and substrateFun is not self.substrateCollector:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        header = null\n\n        while True:  # loop over fragments\n\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    allowEoo=True, **options):\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n                if component is eoo.endOfOctets:\n                    break\n\n            if component is eoo.endOfOctets:\n                break\n\n            header += component\n\n        yield self._createComponent(asn1Spec, tagSet, header, **options)\n\n\nclass NullPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Null('')\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        component = self._createComponent(asn1Spec, tagSet, '', **options)\n\n        if chunk:\n            raise error.PyAsn1Error('Unexpected %d-octet substrate for Null' % length)\n\n        yield component\n\n\nclass ObjectIdentifierPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.ObjectIdentifier(())\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if not chunk:\n            raise error.PyAsn1Error('Empty substrate')\n\n        chunk = octs2ints(chunk)\n\n        oid = ()\n        index = 0\n        substrateLen = len(chunk)\n        while index < substrateLen:\n            subId = chunk[index]\n            index += 1\n            if subId < 128:\n                oid += (subId,)\n            elif subId > 128:\n                # Construct subid from a number of octets\n                nextSubId = subId\n                subId = 0\n                while nextSubId >= 128:\n                    subId = (subId << 7) + (nextSubId & 0x7F)\n                    if index >= substrateLen:\n                        raise error.SubstrateUnderrunError(\n                            'Short substrate for sub-OID past %s' % (oid,)\n                        )\n                    nextSubId = chunk[index]\n                    index += 1\n                oid += ((subId << 7) + nextSubId,)\n            elif subId == 128:\n                # ASN.1 spec forbids leading zeros (0x80) in OID\n                # encoding, tolerating it opens a vulnerability. See\n                # https://www.esat.kuleuven.be/cosic/publications/article-1432.pdf\n                # page 7\n                raise error.PyAsn1Error('Invalid octet 0x80 in OID encoding')\n\n        # Decode two leading arcs\n        if 0 <= oid[0] <= 39:\n            oid = (0,) + oid\n        elif 40 <= oid[0] <= 79:\n            oid = (1, oid[0] - 40) + oid[1:]\n        elif oid[0] >= 80:\n            oid = (2, oid[0] - 80) + oid[1:]\n        else:\n            raise error.PyAsn1Error('Malformed first OID octet: %s' % chunk[0])\n\n        yield self._createComponent(asn1Spec, tagSet, oid, **options)\n\n\nclass RelativeOIDPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.RelativeOID(())\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if not chunk:\n            raise error.PyAsn1Error('Empty substrate')\n\n        chunk = octs2ints(chunk)\n\n        reloid = ()\n        index = 0\n        substrateLen = len(chunk)\n        while index < substrateLen:\n            subId = chunk[index]\n            index += 1\n            if subId < 128:\n                reloid += (subId,)\n            elif subId > 128:\n                # Construct subid from a number of octets\n                nextSubId = subId\n                subId = 0\n                while nextSubId >= 128:\n                    subId = (subId << 7) + (nextSubId & 0x7F)\n                    if index >= substrateLen:\n                        raise error.SubstrateUnderrunError(\n                            'Short substrate for sub-OID past %s' % (reloid,)\n                        )\n                    nextSubId = chunk[index]\n                    index += 1\n                reloid += ((subId << 7) + nextSubId,)\n            elif subId == 128:\n                # ASN.1 spec forbids leading zeros (0x80) in OID\n                # encoding, tolerating it opens a vulnerability. See\n                # https://www.esat.kuleuven.be/cosic/publications/article-1432.pdf\n                # page 7\n                raise error.PyAsn1Error('Invalid octet 0x80 in RELATIVE-OID encoding')\n\n        yield self._createComponent(asn1Spec, tagSet, reloid, **options)\n\n\nclass RealPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Real()\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if not chunk:\n            yield self._createComponent(asn1Spec, tagSet, 0.0, **options)\n            return\n\n        fo = oct2int(chunk[0])\n        chunk = chunk[1:]\n        if fo & 0x80:  # binary encoding\n            if not chunk:\n                raise error.PyAsn1Error(\"Incomplete floating-point value\")\n\n            if LOG:\n                LOG('decoding binary encoded REAL')\n\n            n = (fo & 0x03) + 1\n\n            if n == 4:\n                n = oct2int(chunk[0])\n                chunk = chunk[1:]\n\n            eo, chunk = chunk[:n], chunk[n:]\n\n            if not eo or not chunk:\n                raise error.PyAsn1Error('Real exponent screwed')\n\n            e = oct2int(eo[0]) & 0x80 and -1 or 0\n\n            while eo:  # exponent\n                e <<= 8\n                e |= oct2int(eo[0])\n                eo = eo[1:]\n\n            b = fo >> 4 & 0x03  # base bits\n\n            if b > 2:\n                raise error.PyAsn1Error('Illegal Real base')\n\n            if b == 1:  # encbase = 8\n                e *= 3\n\n            elif b == 2:  # encbase = 16\n                e *= 4\n            p = 0\n\n            while chunk:  # value\n                p <<= 8\n                p |= oct2int(chunk[0])\n                chunk = chunk[1:]\n\n            if fo & 0x40:  # sign bit\n                p = -p\n\n            sf = fo >> 2 & 0x03  # scale bits\n            p *= 2 ** sf\n            value = (p, 2, e)\n\n        elif fo & 0x40:  # infinite value\n            if LOG:\n                LOG('decoding infinite REAL')\n\n            value = fo & 0x01 and '-inf' or 'inf'\n\n        elif fo & 0xc0 == 0:  # character encoding\n            if not chunk:\n                raise error.PyAsn1Error(\"Incomplete floating-point value\")\n\n            if LOG:\n                LOG('decoding character encoded REAL')\n\n            try:\n                if fo & 0x3 == 0x1:  # NR1\n                    value = (int(chunk), 10, 0)\n\n                elif fo & 0x3 == 0x2:  # NR2\n                    value = float(chunk)\n\n                elif fo & 0x3 == 0x3:  # NR3\n                    value = float(chunk)\n\n                else:\n                    raise error.SubstrateUnderrunError(\n                        'Unknown NR (tag %s)' % fo\n                    )\n\n            except ValueError:\n                raise error.SubstrateUnderrunError(\n                    'Bad character Real syntax'\n                )\n\n        else:\n            raise error.SubstrateUnderrunError(\n                'Unknown encoding (tag %s)' % fo\n            )\n\n        yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n\nclass AbstractConstructedPayloadDecoder(AbstractPayloadDecoder):\n    protoComponent = None\n\n\nclass ConstructedPayloadDecoderBase(AbstractConstructedPayloadDecoder):\n    protoRecordComponent = None\n    protoSequenceComponent = None\n\n    def _getComponentTagMap(self, asn1Object, idx):\n        raise NotImplementedError()\n\n    def _getComponentPositionByType(self, asn1Object, tagSet, idx):\n        raise NotImplementedError()\n\n    def _decodeComponentsSchemaless(\n            self, substrate, tagSet=None, decodeFun=None,\n            length=None, **options):\n\n        asn1Object = None\n\n        components = []\n        componentTypes = set()\n\n        original_position = substrate.tell()\n\n        while length == -1 or substrate.tell() < original_position + length:\n            for component in decodeFun(substrate, **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            if length == -1 and component is eoo.endOfOctets:\n                break\n\n            components.append(component)\n            componentTypes.add(component.tagSet)\n\n            # Now we have to guess is it SEQUENCE/SET or SEQUENCE OF/SET OF\n            # The heuristics is:\n            # * 1+ components of different types -> likely SEQUENCE/SET\n            # * otherwise -> likely SEQUENCE OF/SET OF\n            if len(componentTypes) > 1:\n                protoComponent = self.protoRecordComponent\n\n            else:\n                protoComponent = self.protoSequenceComponent\n\n            asn1Object = protoComponent.clone(\n                # construct tagSet from base tag from prototype ASN.1 object\n                # and additional tags recovered from the substrate\n                tagSet=tag.TagSet(protoComponent.tagSet.baseTag, *tagSet.superTags)\n            )\n\n        if LOG:\n            LOG('guessed %r container type (pass `asn1Spec` to guide the '\n                'decoder)' % asn1Object)\n\n        for idx, component in enumerate(components):\n            asn1Object.setComponentByPosition(\n                idx, component,\n                verifyConstraints=False,\n                matchTags=False, matchConstraints=False\n            )\n\n        yield asn1Object\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatConstructed:\n            raise error.PyAsn1Error('Constructed tag format expected')\n\n        original_position = substrate.tell()\n\n        if substrateFun:\n            if asn1Spec is not None:\n                asn1Object = asn1Spec.clone()\n\n            elif self.protoComponent is not None:\n                asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n            else:\n                asn1Object = self.protoRecordComponent, self.protoSequenceComponent\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if asn1Spec is None:\n            for asn1Object in self._decodeComponentsSchemaless(\n                    substrate, tagSet=tagSet, decodeFun=decodeFun,\n                    length=length, **options):\n                if isinstance(asn1Object, SubstrateUnderrunError):\n                    yield asn1Object\n\n            if substrate.tell() < original_position + length:\n                if LOG:\n                    for trailing in readFromStream(substrate, context=options):\n                        if isinstance(trailing, SubstrateUnderrunError):\n                            yield trailing\n\n                    LOG('Unused trailing %d octets encountered: %s' % (\n                        len(trailing), debug.hexdump(trailing)))\n\n            yield asn1Object\n\n            return\n\n        asn1Object = asn1Spec.clone()\n        asn1Object.clear()\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        if asn1Spec.typeId in (univ.Sequence.typeId, univ.Set.typeId):\n\n            namedTypes = asn1Spec.componentType\n\n            isSetType = asn1Spec.typeId == univ.Set.typeId\n            isDeterministic = not isSetType and not namedTypes.hasOptionalOrDefault\n\n            if LOG:\n                LOG('decoding %sdeterministic %s type %r chosen by type ID' % (\n                    not isDeterministic and 'non-' or '', isSetType and 'SET' or '',\n                    asn1Spec))\n\n            seenIndices = set()\n            idx = 0\n            while substrate.tell() - original_position < length:\n                if not namedTypes:\n                    componentType = None\n\n                elif isSetType:\n                    componentType = namedTypes.tagMapUnique\n\n                else:\n                    try:\n                        if isDeterministic:\n                            componentType = namedTypes[idx].asn1Object\n\n                        elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                            componentType = namedTypes.getTagMapNearPosition(idx)\n\n                        else:\n                            componentType = namedTypes[idx].asn1Object\n\n                    except IndexError:\n                        raise error.PyAsn1Error(\n                            'Excessive components decoded at %r' % (asn1Spec,)\n                        )\n\n                for component in decodeFun(substrate, componentType, **options):\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                if not isDeterministic and namedTypes:\n                    if isSetType:\n                        idx = namedTypes.getPositionByType(component.effectiveTagSet)\n\n                    elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                        idx = namedTypes.getPositionNearType(component.effectiveTagSet, idx)\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                seenIndices.add(idx)\n                idx += 1\n\n            if LOG:\n                LOG('seen component indices %s' % seenIndices)\n\n            if namedTypes:\n                if not namedTypes.requiredComponents.issubset(seenIndices):\n                    raise error.PyAsn1Error(\n                        'ASN.1 object %s has uninitialized '\n                        'components' % asn1Object.__class__.__name__)\n\n                if  namedTypes.hasOpenTypes:\n\n                    openTypes = options.get('openTypes', {})\n\n                    if LOG:\n                        LOG('user-specified open types map:')\n\n                        for k, v in openTypes.items():\n                            LOG('%s -> %r' % (k, v))\n\n                    if openTypes or options.get('decodeOpenTypes', False):\n\n                        for idx, namedType in enumerate(namedTypes.namedTypes):\n                            if not namedType.openType:\n                                continue\n\n                            if namedType.isOptional and not asn1Object.getComponentByPosition(idx).isValue:\n                                continue\n\n                            governingValue = asn1Object.getComponentByName(\n                                namedType.openType.name\n                            )\n\n                            try:\n                                openType = openTypes[governingValue]\n\n                            except KeyError:\n\n                                if LOG:\n                                    LOG('default open types map of component '\n                                        '\"%s.%s\" governed by component \"%s.%s\"'\n                                        ':' % (asn1Object.__class__.__name__,\n                                               namedType.name,\n                                               asn1Object.__class__.__name__,\n                                               namedType.openType.name))\n\n                                    for k, v in namedType.openType.items():\n                                        LOG('%s -> %r' % (k, v))\n\n                                try:\n                                    openType = namedType.openType[governingValue]\n\n                                except KeyError:\n                                    if LOG:\n                                        LOG('failed to resolve open type by governing '\n                                            'value %r' % (governingValue,))\n                                    continue\n\n                            if LOG:\n                                LOG('resolved open type %r by governing '\n                                    'value %r' % (openType, governingValue))\n\n                            containerValue = asn1Object.getComponentByPosition(idx)\n\n                            if containerValue.typeId in (\n                                    univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                                for pos, containerElement in enumerate(\n                                        containerValue):\n\n                                    stream = asSeekableStream(containerValue[pos].asOctets())\n\n                                    for component in decodeFun(stream, asn1Spec=openType, **options):\n                                        if isinstance(component, SubstrateUnderrunError):\n                                            yield component\n\n                                    containerValue[pos] = component\n\n                            else:\n                                stream = asSeekableStream(asn1Object.getComponentByPosition(idx).asOctets())\n\n                                for component in decodeFun(stream, asn1Spec=openType, **options):\n                                    if isinstance(component, SubstrateUnderrunError):\n                                        yield component\n\n                                asn1Object.setComponentByPosition(idx, component)\n\n            else:\n                inconsistency = asn1Object.isInconsistent\n                if inconsistency:\n                    raise inconsistency\n\n        else:\n            componentType = asn1Spec.componentType\n\n            if LOG:\n                LOG('decoding type %r chosen by given `asn1Spec`' % componentType)\n\n            idx = 0\n\n            while substrate.tell() - original_position < length:\n                for component in decodeFun(substrate, componentType, **options):\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                idx += 1\n\n        yield asn1Object\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if tagSet[0].tagFormat != tag.tagFormatConstructed:\n            raise error.PyAsn1Error('Constructed tag format expected')\n\n        if substrateFun is not None:\n            if asn1Spec is not None:\n                asn1Object = asn1Spec.clone()\n\n            elif self.protoComponent is not None:\n                asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n            else:\n                asn1Object = self.protoRecordComponent, self.protoSequenceComponent\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if asn1Spec is None:\n            for asn1Object in self._decodeComponentsSchemaless(\n                    substrate, tagSet=tagSet, decodeFun=decodeFun,\n                    length=length, **dict(options, allowEoo=True)):\n                if isinstance(asn1Object, SubstrateUnderrunError):\n                    yield asn1Object\n\n            yield asn1Object\n\n            return\n\n        asn1Object = asn1Spec.clone()\n        asn1Object.clear()\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        if asn1Spec.typeId in (univ.Sequence.typeId, univ.Set.typeId):\n\n            namedTypes = asn1Object.componentType\n\n            isSetType = asn1Object.typeId == univ.Set.typeId\n            isDeterministic = not isSetType and not namedTypes.hasOptionalOrDefault\n\n            if LOG:\n                LOG('decoding %sdeterministic %s type %r chosen by type ID' % (\n                    not isDeterministic and 'non-' or '', isSetType and 'SET' or '',\n                    asn1Spec))\n\n            seenIndices = set()\n\n            idx = 0\n\n            while True:  # loop over components\n                if len(namedTypes) <= idx:\n                    asn1Spec = None\n\n                elif isSetType:\n                    asn1Spec = namedTypes.tagMapUnique\n\n                else:\n                    try:\n                        if isDeterministic:\n                            asn1Spec = namedTypes[idx].asn1Object\n\n                        elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                            asn1Spec = namedTypes.getTagMapNearPosition(idx)\n\n                        else:\n                            asn1Spec = namedTypes[idx].asn1Object\n\n                    except IndexError:\n                        raise error.PyAsn1Error(\n                            'Excessive components decoded at %r' % (asn1Object,)\n                        )\n\n                for component in decodeFun(substrate, asn1Spec, allowEoo=True, **options):\n\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                    if component is eoo.endOfOctets:\n                        break\n\n                if component is eoo.endOfOctets:\n                    break\n\n                if not isDeterministic and namedTypes:\n                    if isSetType:\n                        idx = namedTypes.getPositionByType(component.effectiveTagSet)\n\n                    elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                        idx = namedTypes.getPositionNearType(component.effectiveTagSet, idx)\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                seenIndices.add(idx)\n                idx += 1\n\n            if LOG:\n                LOG('seen component indices %s' % seenIndices)\n\n            if namedTypes:\n                if not namedTypes.requiredComponents.issubset(seenIndices):\n                    raise error.PyAsn1Error(\n                        'ASN.1 object %s has uninitialized '\n                        'components' % asn1Object.__class__.__name__)\n\n                if namedTypes.hasOpenTypes:\n\n                    openTypes = options.get('openTypes', {})\n\n                    if LOG:\n                        LOG('user-specified open types map:')\n\n                        for k, v in openTypes.items():\n                            LOG('%s -> %r' % (k, v))\n\n                    if openTypes or options.get('decodeOpenTypes', False):\n\n                        for idx, namedType in enumerate(namedTypes.namedTypes):\n                            if not namedType.openType:\n                                continue\n\n                            if namedType.isOptional and not asn1Object.getComponentByPosition(idx).isValue:\n                                continue\n\n                            governingValue = asn1Object.getComponentByName(\n                                namedType.openType.name\n                            )\n\n                            try:\n                                openType = openTypes[governingValue]\n\n                            except KeyError:\n\n                                if LOG:\n                                    LOG('default open types map of component '\n                                        '\"%s.%s\" governed by component \"%s.%s\"'\n                                        ':' % (asn1Object.__class__.__name__,\n                                               namedType.name,\n                                               asn1Object.__class__.__name__,\n                                               namedType.openType.name))\n\n                                    for k, v in namedType.openType.items():\n                                        LOG('%s -> %r' % (k, v))\n\n                                try:\n                                    openType = namedType.openType[governingValue]\n\n                                except KeyError:\n                                    if LOG:\n                                        LOG('failed to resolve open type by governing '\n                                            'value %r' % (governingValue,))\n                                    continue\n\n                            if LOG:\n                                LOG('resolved open type %r by governing '\n                                    'value %r' % (openType, governingValue))\n\n                            containerValue = asn1Object.getComponentByPosition(idx)\n\n                            if containerValue.typeId in (\n                                    univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                                for pos, containerElement in enumerate(\n                                        containerValue):\n\n                                    stream = asSeekableStream(containerValue[pos].asOctets())\n\n                                    for component in decodeFun(stream, asn1Spec=openType,\n                                                               **dict(options, allowEoo=True)):\n                                        if isinstance(component, SubstrateUnderrunError):\n                                            yield component\n\n                                        if component is eoo.endOfOctets:\n                                            break\n\n                                    containerValue[pos] = component\n\n                            else:\n                                stream = asSeekableStream(asn1Object.getComponentByPosition(idx).asOctets())\n                                for component in decodeFun(stream, asn1Spec=openType,\n                                                           **dict(options, allowEoo=True)):\n                                    if isinstance(component, SubstrateUnderrunError):\n                                        yield component\n\n                                    if component is eoo.endOfOctets:\n                                        break\n\n                                    asn1Object.setComponentByPosition(idx, component)\n\n                else:\n                    inconsistency = asn1Object.isInconsistent\n                    if inconsistency:\n                        raise inconsistency\n\n        else:\n            componentType = asn1Spec.componentType\n\n            if LOG:\n                LOG('decoding type %r chosen by given `asn1Spec`' % componentType)\n\n            idx = 0\n\n            while True:\n\n                for component in decodeFun(\n                        substrate, componentType, allowEoo=True, **options):\n\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                    if component is eoo.endOfOctets:\n                        break\n\n                if component is eoo.endOfOctets:\n                    break\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                idx += 1\n\n        yield asn1Object\n\n\nclass SequenceOrSequenceOfPayloadDecoder(ConstructedPayloadDecoderBase):\n    protoRecordComponent = univ.Sequence()\n    protoSequenceComponent = univ.SequenceOf()\n\n\nclass SequencePayloadDecoder(SequenceOrSequenceOfPayloadDecoder):\n    protoComponent = univ.Sequence()\n\n\nclass SequenceOfPayloadDecoder(SequenceOrSequenceOfPayloadDecoder):\n    protoComponent = univ.SequenceOf()\n\n\nclass SetOrSetOfPayloadDecoder(ConstructedPayloadDecoderBase):\n    protoRecordComponent = univ.Set()\n    protoSequenceComponent = univ.SetOf()\n\n\nclass SetPayloadDecoder(SetOrSetOfPayloadDecoder):\n    protoComponent = univ.Set()\n\n\nclass SetOfPayloadDecoder(SetOrSetOfPayloadDecoder):\n    protoComponent = univ.SetOf()\n\n\nclass ChoicePayloadDecoder(ConstructedPayloadDecoderBase):\n    protoComponent = univ.Choice()\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if asn1Spec is None:\n            asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n        else:\n            asn1Object = asn1Spec.clone()\n\n        if substrateFun:\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        if asn1Object.tagSet == tagSet:\n            if LOG:\n                LOG('decoding %s as explicitly tagged CHOICE' % (tagSet,))\n\n            for component in decodeFun(\n                    substrate, asn1Object.componentTagMap, **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n        else:\n            if LOG:\n                LOG('decoding %s as untagged CHOICE' % (tagSet,))\n\n            for component in decodeFun(\n                    substrate, asn1Object.componentTagMap, tagSet, length,\n                    state, **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n        effectiveTagSet = component.effectiveTagSet\n\n        if LOG:\n            LOG('decoded component %s, effective tag set %s' % (component, effectiveTagSet))\n\n        asn1Object.setComponentByType(\n            effectiveTagSet, component,\n            verifyConstraints=False,\n            matchTags=False, matchConstraints=False,\n            innerFlag=False\n        )\n\n        yield asn1Object\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if asn1Spec is None:\n            asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n        else:\n            asn1Object = asn1Spec.clone()\n\n        if substrateFun:\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        isTagged = asn1Object.tagSet == tagSet\n\n        if LOG:\n            LOG('decoding %s as %stagged CHOICE' % (\n                tagSet, isTagged and 'explicitly ' or 'un'))\n\n        while True:\n\n            if isTagged:\n                iterator = decodeFun(\n                    substrate, asn1Object.componentType.tagMapUnique,\n                    **dict(options, allowEoo=True))\n\n            else:\n                iterator = decodeFun(\n                    substrate, asn1Object.componentType.tagMapUnique,\n                    tagSet, length, state, **dict(options, allowEoo=True))\n\n            for component in iterator:\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n                if component is eoo.endOfOctets:\n                    break\n\n                effectiveTagSet = component.effectiveTagSet\n\n                if LOG:\n                    LOG('decoded component %s, effective tag set '\n                        '%s' % (component, effectiveTagSet))\n\n                asn1Object.setComponentByType(\n                    effectiveTagSet, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False,\n                    innerFlag=False\n                )\n\n                if not isTagged:\n                    break\n\n            if not isTagged or component is eoo.endOfOctets:\n                break\n\n        yield asn1Object\n\n\nclass AnyPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Any()\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if asn1Spec is None:\n            isUntagged = True\n\n        elif asn1Spec.__class__ is tagmap.TagMap:\n            isUntagged = tagSet not in asn1Spec.tagMap\n\n        else:\n            isUntagged = tagSet != asn1Spec.tagSet\n\n        if isUntagged:\n            fullPosition = substrate.markedPosition\n            currentPosition = substrate.tell()\n\n            substrate.seek(fullPosition, os.SEEK_SET)\n            length += currentPosition - fullPosition\n\n            if LOG:\n                for chunk in peekIntoStream(substrate, length):\n                    if isinstance(chunk, SubstrateUnderrunError):\n                        yield chunk\n                LOG('decoding as untagged ANY, substrate '\n                    '%s' % debug.hexdump(chunk))\n\n        if substrateFun:\n            for chunk in substrateFun(\n                    self._createComponent(asn1Spec, tagSet, noValue, **options),\n                    substrate, length, options):\n                yield chunk\n\n            return\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        yield self._createComponent(asn1Spec, tagSet, chunk, **options)\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if asn1Spec is None:\n            isTagged = False\n\n        elif asn1Spec.__class__ is tagmap.TagMap:\n            isTagged = tagSet in asn1Spec.tagMap\n\n        else:\n            isTagged = tagSet == asn1Spec.tagSet\n\n        if isTagged:\n            # tagged Any type -- consume header substrate\n            chunk = null\n\n            if LOG:\n                LOG('decoding as tagged ANY')\n\n        else:\n            # TODO: Seems not to be tested\n            fullPosition = substrate.markedPosition\n            currentPosition = substrate.tell()\n\n            substrate.seek(fullPosition, os.SEEK_SET)\n            for chunk in readFromStream(substrate, currentPosition - fullPosition, options):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield chunk\n\n            if LOG:\n                LOG('decoding as untagged ANY, header substrate %s' % debug.hexdump(chunk))\n\n        # Any components do not inherit initial tag\n        asn1Spec = self.protoComponent\n\n        if substrateFun and substrateFun is not self.substrateCollector:\n            asn1Object = self._createComponent(\n                asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(\n                    asn1Object, chunk + substrate, length + len(chunk), options):\n                yield chunk\n\n            return\n\n        if LOG:\n            LOG('assembling constructed serialization')\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        while True:  # loop over fragments\n\n            for component in decodeFun(\n                    substrate, asn1Spec, substrateFun=substrateFun,\n                    allowEoo=True, **options):\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n                if component is eoo.endOfOctets:\n                    break\n\n            if component is eoo.endOfOctets:\n                break\n\n            chunk += component\n\n        if substrateFun:\n            yield chunk  # TODO: Weird\n\n        else:\n            yield self._createComponent(asn1Spec, tagSet, chunk, **options)\n\n\n# character string types\nclass UTF8StringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.UTF8String()\n\n\nclass NumericStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.NumericString()\n\n\nclass PrintableStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.PrintableString()\n\n\nclass TeletexStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.TeletexString()\n\n\nclass VideotexStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.VideotexString()\n\n\nclass IA5StringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.IA5String()\n\n\nclass GraphicStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.GraphicString()\n\n\nclass VisibleStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.VisibleString()\n\n\nclass GeneralStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.GeneralString()\n\n\nclass UniversalStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.UniversalString()\n\n\nclass BMPStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.BMPString()\n\n\n# \"useful\" types\nclass ObjectDescriptorPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = useful.ObjectDescriptor()\n\n\nclass GeneralizedTimePayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = useful.GeneralizedTime()\n\n\nclass UTCTimePayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = useful.UTCTime()\n\n\nTAG_MAP = {\n    univ.Integer.tagSet: IntegerPayloadDecoder(),\n    univ.Boolean.tagSet: BooleanPayloadDecoder(),\n    univ.BitString.tagSet: BitStringPayloadDecoder(),\n    univ.OctetString.tagSet: OctetStringPayloadDecoder(),\n    univ.Null.tagSet: NullPayloadDecoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierPayloadDecoder(),\n    univ.RelativeOID.tagSet: RelativeOIDPayloadDecoder(),\n    univ.Enumerated.tagSet: IntegerPayloadDecoder(),\n    univ.Real.tagSet: RealPayloadDecoder(),\n    univ.Sequence.tagSet: SequenceOrSequenceOfPayloadDecoder(),  # conflicts with SequenceOf\n    univ.Set.tagSet: SetOrSetOfPayloadDecoder(),  # conflicts with SetOf\n    univ.Choice.tagSet: ChoicePayloadDecoder(),  # conflicts with Any\n    # character string types\n    char.UTF8String.tagSet: UTF8StringPayloadDecoder(),\n    char.NumericString.tagSet: NumericStringPayloadDecoder(),\n    char.PrintableString.tagSet: PrintableStringPayloadDecoder(),\n    char.TeletexString.tagSet: TeletexStringPayloadDecoder(),\n    char.VideotexString.tagSet: VideotexStringPayloadDecoder(),\n    char.IA5String.tagSet: IA5StringPayloadDecoder(),\n    char.GraphicString.tagSet: GraphicStringPayloadDecoder(),\n    char.VisibleString.tagSet: VisibleStringPayloadDecoder(),\n    char.GeneralString.tagSet: GeneralStringPayloadDecoder(),\n    char.UniversalString.tagSet: UniversalStringPayloadDecoder(),\n    char.BMPString.tagSet: BMPStringPayloadDecoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: ObjectDescriptorPayloadDecoder(),\n    useful.GeneralizedTime.tagSet: GeneralizedTimePayloadDecoder(),\n    useful.UTCTime.tagSet: UTCTimePayloadDecoder()\n}\n\n# Type-to-codec map for ambiguous ASN.1 types\nTYPE_MAP = {\n    univ.Set.typeId: SetPayloadDecoder(),\n    univ.SetOf.typeId: SetOfPayloadDecoder(),\n    univ.Sequence.typeId: SequencePayloadDecoder(),\n    univ.SequenceOf.typeId: SequenceOfPayloadDecoder(),\n    univ.Choice.typeId: ChoicePayloadDecoder(),\n    univ.Any.typeId: AnyPayloadDecoder()\n}\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in TAG_MAP.values():\n    if typeDecoder.protoComponent is not None:\n        typeId = typeDecoder.protoComponent.__class__.typeId\n        if typeId is not None and typeId not in TYPE_MAP:\n            TYPE_MAP[typeId] = typeDecoder\n\n\n(stDecodeTag,\n stDecodeLength,\n stGetValueDecoder,\n stGetValueDecoderByAsn1Spec,\n stGetValueDecoderByTag,\n stTryAsExplicitTag,\n stDecodeValue,\n stDumpRawValue,\n stErrorCondition,\n stStop) = [x for x in range(10)]\n\n\nEOO_SENTINEL = ints2octs((0, 0))\n\n\nclass SingleItemDecoder(object):\n    defaultErrorState = stErrorCondition\n    #defaultErrorState = stDumpRawValue\n    defaultRawDecoder = AnyPayloadDecoder()\n\n    supportIndefLength = True\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n        # Tag & TagSet objects caches\n        self._tagCache = {}\n        self._tagSetCache = {}\n\n    def __call__(self, substrate, asn1Spec=None,\n                 tagSet=None, length=None, state=stDecodeTag,\n                 decodeFun=None, substrateFun=None,\n                 **options):\n\n        allowEoo = options.pop('allowEoo', False)\n\n        if LOG:\n            LOG('decoder called at scope %s with state %d, working with up '\n                'to %s octets of substrate: '\n                '%s' % (debug.scope, state, length, substrate))\n\n        # Look for end-of-octets sentinel\n        if allowEoo and self.supportIndefLength:\n\n            for eoo_candidate in readFromStream(substrate, 2, options):\n                if isinstance(eoo_candidate, SubstrateUnderrunError):\n                    yield eoo_candidate\n\n            if eoo_candidate == EOO_SENTINEL:\n                if LOG:\n                    LOG('end-of-octets sentinel found')\n                yield eoo.endOfOctets\n                return\n\n            else:\n                substrate.seek(-2, os.SEEK_CUR)\n\n        tagMap = self._tagMap\n        typeMap = self._typeMap\n        tagCache = self._tagCache\n        tagSetCache = self._tagSetCache\n\n        value = noValue\n\n        substrate.markedPosition = substrate.tell()\n\n        while state is not stStop:\n\n            if state is stDecodeTag:\n                # Decode tag\n                isShortTag = True\n\n                for firstByte in readFromStream(substrate, 1, options):\n                    if isinstance(firstByte, SubstrateUnderrunError):\n                        yield firstByte\n\n                firstOctet = ord(firstByte)\n\n                try:\n                    lastTag = tagCache[firstOctet]\n\n                except KeyError:\n                    integerTag = firstOctet\n                    tagClass = integerTag & 0xC0\n                    tagFormat = integerTag & 0x20\n                    tagId = integerTag & 0x1F\n\n                    if tagId == 0x1F:\n                        isShortTag = False\n                        lengthOctetIdx = 0\n                        tagId = 0\n\n                        while True:\n                            for integerByte in readFromStream(substrate, 1, options):\n                                if isinstance(integerByte, SubstrateUnderrunError):\n                                    yield integerByte\n\n                            if not integerByte:\n                                raise error.SubstrateUnderrunError(\n                                    'Short octet stream on long tag decoding'\n                                )\n\n                            integerTag = ord(integerByte)\n                            lengthOctetIdx += 1\n                            tagId <<= 7\n                            tagId |= (integerTag & 0x7F)\n\n                            if not integerTag & 0x80:\n                                break\n\n                    lastTag = tag.Tag(\n                        tagClass=tagClass, tagFormat=tagFormat, tagId=tagId\n                    )\n\n                    if isShortTag:\n                        # cache short tags\n                        tagCache[firstOctet] = lastTag\n\n                if tagSet is None:\n                    if isShortTag:\n                        try:\n                            tagSet = tagSetCache[firstOctet]\n\n                        except KeyError:\n                            # base tag not recovered\n                            tagSet = tag.TagSet((), lastTag)\n                            tagSetCache[firstOctet] = tagSet\n                    else:\n                        tagSet = tag.TagSet((), lastTag)\n\n                else:\n                    tagSet = lastTag + tagSet\n\n                state = stDecodeLength\n\n                if LOG:\n                    LOG('tag decoded into %s, decoding length' % tagSet)\n\n            if state is stDecodeLength:\n                # Decode length\n                for firstOctet in readFromStream(substrate, 1, options):\n                    if isinstance(firstOctet, SubstrateUnderrunError):\n                        yield firstOctet\n\n                firstOctet = ord(firstOctet)\n\n                if firstOctet < 128:\n                    length = firstOctet\n\n                elif firstOctet > 128:\n                    size = firstOctet & 0x7F\n                    # encoded in size bytes\n                    for encodedLength in readFromStream(substrate, size, options):\n                        if isinstance(encodedLength, SubstrateUnderrunError):\n                            yield encodedLength\n                    encodedLength = list(encodedLength)\n                    # missing check on maximum size, which shouldn't be a\n                    # problem, we can handle more than is possible\n                    if len(encodedLength) != size:\n                        raise error.SubstrateUnderrunError(\n                            '%s<%s at %s' % (size, len(encodedLength), tagSet)\n                        )\n\n                    length = 0\n                    for lengthOctet in encodedLength:\n                        length <<= 8\n                        length |= oct2int(lengthOctet)\n                    size += 1\n\n                else:  # 128 means indefinite\n                    length = -1\n\n                if length == -1 and not self.supportIndefLength:\n                    raise error.PyAsn1Error('Indefinite length encoding not supported by this codec')\n\n                state = stGetValueDecoder\n\n                if LOG:\n                    LOG('value length decoded into %d' % length)\n\n            if state is stGetValueDecoder:\n                if asn1Spec is None:\n                    state = stGetValueDecoderByTag\n\n                else:\n                    state = stGetValueDecoderByAsn1Spec\n            #\n            # There're two ways of creating subtypes in ASN.1 what influences\n            # decoder operation. These methods are:\n            # 1) Either base types used in or no IMPLICIT tagging has been\n            #    applied on subtyping.\n            # 2) Subtype syntax drops base type information (by means of\n            #    IMPLICIT tagging.\n            # The first case allows for complete tag recovery from substrate\n            # while the second one requires original ASN.1 type spec for\n            # decoding.\n            #\n            # In either case a set of tags (tagSet) is coming from substrate\n            # in an incremental, tag-by-tag fashion (this is the case of\n            # EXPLICIT tag which is most basic). Outermost tag comes first\n            # from the wire.\n            #\n            if state is stGetValueDecoderByTag:\n                try:\n                    concreteDecoder = tagMap[tagSet]\n\n                except KeyError:\n                    concreteDecoder = None\n\n                if concreteDecoder:\n                    state = stDecodeValue\n\n                else:\n                    try:\n                        concreteDecoder = tagMap[tagSet[:1]]\n\n                    except KeyError:\n                        concreteDecoder = None\n\n                    if concreteDecoder:\n                        state = stDecodeValue\n                    else:\n                        state = stTryAsExplicitTag\n\n                if LOG:\n                    LOG('codec %s chosen by a built-in type, decoding %s' % (concreteDecoder and concreteDecoder.__class__.__name__ or \"<none>\", state is stDecodeValue and 'value' or 'as explicit tag'))\n                    debug.scope.push(concreteDecoder is None and '?' or concreteDecoder.protoComponent.__class__.__name__)\n\n            if state is stGetValueDecoderByAsn1Spec:\n\n                if asn1Spec.__class__ is tagmap.TagMap:\n                    try:\n                        chosenSpec = asn1Spec[tagSet]\n\n                    except KeyError:\n                        chosenSpec = None\n\n                    if LOG:\n                        LOG('candidate ASN.1 spec is a map of:')\n\n                        for firstOctet, v in asn1Spec.presentTypes.items():\n                            LOG('  %s -> %s' % (firstOctet, v.__class__.__name__))\n\n                        if asn1Spec.skipTypes:\n                            LOG('but neither of: ')\n                            for firstOctet, v in asn1Spec.skipTypes.items():\n                                LOG('  %s -> %s' % (firstOctet, v.__class__.__name__))\n                        LOG('new candidate ASN.1 spec is %s, chosen by %s' % (chosenSpec is None and '<none>' or chosenSpec.prettyPrintType(), tagSet))\n\n                elif tagSet == asn1Spec.tagSet or tagSet in asn1Spec.tagMap:\n                    chosenSpec = asn1Spec\n                    if LOG:\n                        LOG('candidate ASN.1 spec is %s' % asn1Spec.__class__.__name__)\n\n                else:\n                    chosenSpec = None\n\n                if chosenSpec is not None:\n                    try:\n                        # ambiguous type or just faster codec lookup\n                        concreteDecoder = typeMap[chosenSpec.typeId]\n\n                        if LOG:\n                            LOG('value decoder chosen for an ambiguous type by type ID %s' % (chosenSpec.typeId,))\n\n                    except KeyError:\n                        # use base type for codec lookup to recover untagged types\n                        baseTagSet = tag.TagSet(chosenSpec.tagSet.baseTag,  chosenSpec.tagSet.baseTag)\n                        try:\n                            # base type or tagged subtype\n                            concreteDecoder = tagMap[baseTagSet]\n\n                            if LOG:\n                                LOG('value decoder chosen by base %s' % (baseTagSet,))\n\n                        except KeyError:\n                            concreteDecoder = None\n\n                    if concreteDecoder:\n                        asn1Spec = chosenSpec\n                        state = stDecodeValue\n\n                    else:\n                        state = stTryAsExplicitTag\n\n                else:\n                    concreteDecoder = None\n                    state = stTryAsExplicitTag\n\n                if LOG:\n                    LOG('codec %s chosen by ASN.1 spec, decoding %s' % (state is stDecodeValue and concreteDecoder.__class__.__name__ or \"<none>\", state is stDecodeValue and 'value' or 'as explicit tag'))\n                    debug.scope.push(chosenSpec is None and '?' or chosenSpec.__class__.__name__)\n\n            if state is stDecodeValue:\n                if not options.get('recursiveFlag', True) and not substrateFun:  # deprecate this\n                    def substrateFun(asn1Object, _substrate, _length, _options):\n                        \"\"\"Legacy hack to keep the recursiveFlag=False option supported.\n\n                        The decode(..., substrateFun=userCallback) option was introduced in 0.1.4 as a generalization\n                        of the old recursiveFlag=False option. Users should pass their callback instead of using\n                        recursiveFlag.\n                        \"\"\"\n                        yield asn1Object\n\n                original_position = substrate.tell()\n\n                if length == -1:  # indef length\n                    for value in concreteDecoder.indefLenValueDecoder(\n                            substrate, asn1Spec,\n                            tagSet, length, stGetValueDecoder,\n                            self, substrateFun, **options):\n                        if isinstance(value, SubstrateUnderrunError):\n                            yield value\n\n                else:\n                    for value in concreteDecoder.valueDecoder(\n                            substrate, asn1Spec,\n                            tagSet, length, stGetValueDecoder,\n                            self, substrateFun, **options):\n                        if isinstance(value, SubstrateUnderrunError):\n                            yield value\n\n                    bytesRead = substrate.tell() - original_position\n                    if not substrateFun and bytesRead != length:\n                        raise PyAsn1Error(\n                            \"Read %s bytes instead of expected %s.\" % (bytesRead, length))\n                    elif substrateFun and bytesRead > length:\n                        # custom substrateFun may be used for partial decoding, reading less is expected there\n                        raise PyAsn1Error(\n                            \"Read %s bytes are more than expected %s.\" % (bytesRead, length))\n\n                if LOG:\n                   LOG('codec %s yields type %s, value:\\n%s\\n...' % (\n                       concreteDecoder.__class__.__name__, value.__class__.__name__,\n                       isinstance(value, base.Asn1Item) and value.prettyPrint() or value))\n\n                state = stStop\n                break\n\n            if state is stTryAsExplicitTag:\n                if (tagSet and\n                        tagSet[0].tagFormat == tag.tagFormatConstructed and\n                        tagSet[0].tagClass != tag.tagClassUniversal):\n                    # Assume explicit tagging\n                    concreteDecoder = rawPayloadDecoder\n                    state = stDecodeValue\n\n                else:\n                    concreteDecoder = None\n                    state = self.defaultErrorState\n\n                if LOG:\n                    LOG('codec %s chosen, decoding %s' % (concreteDecoder and concreteDecoder.__class__.__name__ or \"<none>\", state is stDecodeValue and 'value' or 'as failure'))\n\n            if state is stDumpRawValue:\n                concreteDecoder = self.defaultRawDecoder\n\n                if LOG:\n                    LOG('codec %s chosen, decoding value' % concreteDecoder.__class__.__name__)\n\n                state = stDecodeValue\n\n            if state is stErrorCondition:\n                raise error.PyAsn1Error(\n                    '%s not in asn1Spec: %r' % (tagSet, asn1Spec)\n                )\n\n        if LOG:\n            debug.scope.pop()\n            LOG('decoder left scope %s, call completed' % debug.scope)\n\n        yield value\n\n\nclass StreamingDecoder(object):\n    \"\"\"Create an iterator that turns BER/CER/DER byte stream into ASN.1 objects.\n\n    On each iteration, consume whatever BER/CER/DER serialization is\n    available in the `substrate` stream-like object and turns it into\n    one or more, possibly nested, ASN.1 objects.\n\n    Parameters\n    ----------\n    substrate: :py:class:`file`, :py:class:`io.BytesIO`\n        BER/CER/DER serialization in form of a byte stream\n\n    Keyword Args\n    ------------\n    asn1Spec: :py:class:`~pyasn1.type.base.PyAsn1Item`\n        A pyasn1 type object to act as a template guiding the decoder.\n        Depending on the ASN.1 structure being decoded, `asn1Spec` may\n        or may not be required. One of the reasons why `asn1Spec` may\n        me required is that ASN.1 structure is encoded in the *IMPLICIT*\n        tagging mode.\n\n    Yields\n    ------\n    : :py:class:`~pyasn1.type.base.PyAsn1Item`, :py:class:`~pyasn1.error.SubstrateUnderrunError`\n        Decoded ASN.1 object (possibly, nested) or\n        :py:class:`~pyasn1.error.SubstrateUnderrunError` object indicating\n        insufficient BER/CER/DER serialization on input to fully recover ASN.1\n        objects from it.\n        \n        In the latter case the caller is advised to ensure some more data in\n        the input stream, then call the iterator again. The decoder will resume\n        the decoding process using the newly arrived data.\n\n        The `context` property of :py:class:`~pyasn1.error.SubstrateUnderrunError`\n        object might hold a reference to the partially populated ASN.1 object\n        being reconstructed.\n\n    Raises\n    ------\n    ~pyasn1.error.PyAsn1Error, ~pyasn1.error.EndOfStreamError\n        `PyAsn1Error` on deserialization error, `EndOfStreamError` on\n         premature stream closure.\n\n    Examples\n    --------\n    Decode BER serialisation without ASN.1 schema\n\n    .. code-block:: pycon\n\n        >>> stream = io.BytesIO(\n        ...    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n        >>>\n        >>> for asn1Object in StreamingDecoder(stream):\n        ...     print(asn1Object)\n        >>>\n        SequenceOf:\n         1 2 3\n\n    Decode BER serialisation with ASN.1 schema\n\n    .. code-block:: pycon\n\n        >>> stream = io.BytesIO(\n        ...    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n        >>>\n        >>> schema = SequenceOf(componentType=Integer())\n        >>>\n        >>> decoder = StreamingDecoder(stream, asn1Spec=schema)\n        >>> for asn1Object in decoder:\n        ...     print(asn1Object)\n        >>>\n        SequenceOf:\n         1 2 3\n    \"\"\"\n\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n    def __init__(self, substrate, asn1Spec=None, **options):\n        self._singleItemDecoder = self.SINGLE_ITEM_DECODER(**options)\n        self._substrate = asSeekableStream(substrate)\n        self._asn1Spec = asn1Spec\n        self._options = options\n\n    def __iter__(self):\n        while True:\n            for asn1Object in self._singleItemDecoder(\n                    self._substrate, self._asn1Spec, **self._options):\n                yield asn1Object\n\n            for chunk in isEndOfStream(self._substrate):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield\n\n                break\n\n            if chunk:\n                break\n\n\nclass Decoder(object):\n    \"\"\"Create a BER decoder object.\n\n    Parse BER/CER/DER octet-stream into one, possibly nested, ASN.1 object.\n    \"\"\"\n    STREAMING_DECODER = StreamingDecoder\n\n    @classmethod\n    def __call__(cls, substrate, asn1Spec=None, **options):\n        \"\"\"Turns BER/CER/DER octet stream into an ASN.1 object.\n\n        Takes BER/CER/DER octet-stream in form of :py:class:`bytes` (Python 3)\n        or :py:class:`str` (Python 2) and decode it into an ASN.1 object\n        (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n        may be a scalar or an arbitrary nested structure.\n\n        Parameters\n        ----------\n        substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n            BER/CER/DER octet-stream to parse\n\n        Keyword Args\n        ------------\n        asn1Spec: :py:class:`~pyasn1.type.base.PyAsn1Item`\n            A pyasn1 type object (:py:class:`~pyasn1.type.base.PyAsn1Item`\n            derivative) to act as a template guiding the decoder.\n            Depending on the ASN.1 structure being decoded, `asn1Spec` may or\n            may not be required. Most common reason for it to require is that\n            ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n\n        substrateFun: :py:class:`Union[\n                Callable[[pyasn1.type.base.PyAsn1Item, bytes, int],\n                         Tuple[pyasn1.type.base.PyAsn1Item, bytes]],\n                Callable[[pyasn1.type.base.PyAsn1Item, io.BytesIO, int, dict],\n                         Generator[Union[pyasn1.type.base.PyAsn1Item,\n                                         pyasn1.error.SubstrateUnderrunError],\n                                   None, None]]\n            ]`\n            User callback meant to generalize special use cases like non-recursive or\n            partial decoding. A 3-arg non-streaming variant is supported for backwards\n            compatiblilty in addition to the newer 4-arg streaming variant.\n            The callback will receive the uninitialized object recovered from substrate\n            as 1st argument, the uninterpreted payload as 2nd argument, and the length\n            of the uninterpreted payload as 3rd argument. The streaming variant will\n            additionally receive the decode(..., **options) kwargs as 4th argument.\n            The non-streaming variant shall return an object that will be propagated\n            as decode() return value as 1st item, and the remainig payload for further\n            decode passes as 2nd item.\n            The streaming variant shall yield an object that will be propagated as\n            decode() return value, and leave the remaining payload in the stream.\n\n        Returns\n        -------\n        : :py:class:`tuple`\n            A tuple of :py:class:`~pyasn1.type.base.PyAsn1Item` object\n            recovered from BER/CER/DER substrate and the unprocessed trailing\n            portion of the `substrate` (may be empty)\n\n        Raises\n        ------\n        : :py:class:`~pyasn1.error.PyAsn1Error`\n            :py:class:`~pyasn1.error.SubstrateUnderrunError` on insufficient\n            input or :py:class:`~pyasn1.error.PyAsn1Error` on decoding error.\n\n        Examples\n        --------\n        Decode BER/CER/DER serialisation without ASN.1 schema\n\n        .. code-block:: pycon\n\n           >>> s, unprocessed = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n           >>> str(s)\n           SequenceOf:\n            1 2 3\n\n        Decode BER/CER/DER serialisation with ASN.1 schema\n\n        .. code-block:: pycon\n\n           >>> seq = SequenceOf(componentType=Integer())\n           >>> s, unprocessed = decode(\n                b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03', asn1Spec=seq)\n           >>> str(s)\n           SequenceOf:\n            1 2 3\n\n        \"\"\"\n        substrate = asSeekableStream(substrate)\n\n        if \"substrateFun\" in options:\n            origSubstrateFun = options[\"substrateFun\"]\n\n            def substrateFunWrapper(asn1Object, substrate, length, options=None):\n                \"\"\"Support both 0.4 and 0.5 style APIs.\n\n                substrateFun API has changed in 0.5 for use with streaming decoders. To stay backwards compatible,\n                we first try if we received a streaming user callback. If that fails,we assume we've received a\n                non-streaming v0.4 user callback and convert it for streaming on the fly\n                \"\"\"\n                try:\n                    substrate_gen = origSubstrateFun(asn1Object, substrate, length, options)\n                except TypeError:\n                    _type, _value, traceback = sys.exc_info()\n                    if traceback.tb_next:\n                        # Traceback depth > 1 means TypeError from inside user provided function\n                        raise\n                    # invariant maintained at Decoder.__call__ entry\n                    assert isinstance(substrate, io.BytesIO)  # nosec assert_used\n                    substrate_gen = Decoder._callSubstrateFunV4asV5(origSubstrateFun, asn1Object, substrate, length)\n                for value in substrate_gen:\n                    yield value\n\n            options[\"substrateFun\"] = substrateFunWrapper\n\n        streamingDecoder = cls.STREAMING_DECODER(\n            substrate, asn1Spec, **options)\n\n        for asn1Object in streamingDecoder:\n            if isinstance(asn1Object, SubstrateUnderrunError):\n                raise error.SubstrateUnderrunError('Short substrate on input')\n\n            try:\n                tail = next(readFromStream(substrate))\n\n            except error.EndOfStreamError:\n                tail = null\n\n            return asn1Object, tail\n\n    @staticmethod\n    def _callSubstrateFunV4asV5(substrateFunV4, asn1Object, substrate, length):\n        substrate_bytes = substrate.read()\n        if length == -1:\n            length = len(substrate_bytes)\n        value, nextSubstrate = substrateFunV4(asn1Object, substrate_bytes, length)\n        nbytes = substrate.write(nextSubstrate)\n        substrate.truncate()\n        substrate.seek(-nbytes, os.SEEK_CUR)\n        yield value\n\n#: Turns BER octet stream into an ASN.1 object.\n#:\n#: Takes BER octet-stream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     BER octet-stream\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from BER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error, ~pyasn1.error.SubstrateUnderrunError\n#:     On decoding errors\n#:\n#: Notes\n#: -----\n#: This function is deprecated. Please use :py:class:`Decoder` or\n#: :py:class:`StreamingDecoder` class instance.\n#:\n#: Examples\n#: --------\n#: Decode BER serialisation without ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\n#: Decode BER serialisation with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03', asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/ber/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/ber/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.compat.integer import to_bytes\nfrom pyasn1.compat.octets import (int2oct, oct2int, ints2octs, null,\n                                  str2octs, isOctetsType)\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['Encoder', 'encode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_ENCODER)\n\n\nclass AbstractItemEncoder(object):\n    supportIndefLenMode = True\n\n    # An outcome of otherwise legit call `encodeFun(eoo.endOfOctets)`\n    eooIntegerSubstrate = (0, 0)\n    eooOctetsSubstrate = ints2octs(eooIntegerSubstrate)\n\n    # noinspection PyMethodMayBeStatic\n    def encodeTag(self, singleTag, isConstructed):\n        tagClass, tagFormat, tagId = singleTag\n        encodedTag = tagClass | tagFormat\n        if isConstructed:\n            encodedTag |= tag.tagFormatConstructed\n\n        if tagId < 31:\n            return encodedTag | tagId,\n\n        else:\n            substrate = tagId & 0x7f,\n\n            tagId >>= 7\n\n            while tagId:\n                substrate = (0x80 | (tagId & 0x7f),) + substrate\n                tagId >>= 7\n\n            return (encodedTag | 0x1F,) + substrate\n\n    def encodeLength(self, length, defMode):\n        if not defMode and self.supportIndefLenMode:\n            return (0x80,)\n\n        if length < 0x80:\n            return length,\n\n        else:\n            substrate = ()\n            while length:\n                substrate = (length & 0xff,) + substrate\n                length >>= 8\n\n            substrateLen = len(substrate)\n\n            if substrateLen > 126:\n                raise error.PyAsn1Error('Length octets overflow (%d)' % substrateLen)\n\n            return (0x80 | substrateLen,) + substrate\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        raise error.PyAsn1Error('Not implemented')\n\n    def encode(self, value, asn1Spec=None, encodeFun=None, **options):\n\n        if asn1Spec is None:\n            tagSet = value.tagSet\n        else:\n            tagSet = asn1Spec.tagSet\n\n        # untagged item?\n        if not tagSet:\n            substrate, isConstructed, isOctets = self.encodeValue(\n                value, asn1Spec, encodeFun, **options\n            )\n            return substrate\n\n        defMode = options.get('defMode', True)\n\n        substrate = null\n\n        for idx, singleTag in enumerate(tagSet.superTags):\n\n            defModeOverride = defMode\n\n            # base tag?\n            if not idx:\n                try:\n                    substrate, isConstructed, isOctets = self.encodeValue(\n                        value, asn1Spec, encodeFun, **options\n                    )\n\n                except error.PyAsn1Error:\n                    exc = sys.exc_info()\n                    raise error.PyAsn1Error(\n                        'Error encoding %r: %s' % (value, exc[1]))\n\n                if LOG:\n                    LOG('encoded %svalue %s into %s' % (\n                        isConstructed and 'constructed ' or '', value, substrate\n                    ))\n\n                if not substrate and isConstructed and options.get('ifNotEmpty', False):\n                    return substrate\n\n                if not isConstructed:\n                    defModeOverride = True\n\n                    if LOG:\n                        LOG('overridden encoding mode into definitive for primitive type')\n\n            header = self.encodeTag(singleTag, isConstructed)\n\n            if LOG:\n                LOG('encoded %stag %s into %s' % (\n                    isConstructed and 'constructed ' or '',\n                    singleTag, debug.hexdump(ints2octs(header))))\n\n            header += self.encodeLength(len(substrate), defModeOverride)\n\n            if LOG:\n                LOG('encoded %s octets (tag + payload) into %s' % (\n                    len(substrate), debug.hexdump(ints2octs(header))))\n\n            if isOctets:\n                substrate = ints2octs(header) + substrate\n\n                if not defModeOverride:\n                    substrate += self.eooOctetsSubstrate\n\n            else:\n                substrate = header + substrate\n\n                if not defModeOverride:\n                    substrate += self.eooIntegerSubstrate\n\n        if not isOctets:\n            substrate = ints2octs(substrate)\n\n        return substrate\n\n\nclass EndOfOctetsEncoder(AbstractItemEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        return null, False, True\n\n\nclass BooleanEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        return value and (1,) or (0,), False, False\n\n\nclass IntegerEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n    supportCompactZero = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if value == 0:\n            if LOG:\n                LOG('encoding %spayload for zero INTEGER' % (\n                    self.supportCompactZero and 'no ' or ''\n                ))\n\n            # de-facto way to encode zero\n            if self.supportCompactZero:\n                return (), False, False\n            else:\n                return (0,), False, False\n\n        return to_bytes(int(value), signed=True), False, True\n\n\nclass BitStringEncoder(AbstractItemEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            # TODO: try to avoid ASN.1 schema instantiation\n            value = asn1Spec.clone(value)\n\n        valueLength = len(value)\n        if valueLength % 8:\n            alignedValue = value << (8 - valueLength % 8)\n        else:\n            alignedValue = value\n\n        maxChunkSize = options.get('maxChunkSize', 0)\n        if not maxChunkSize or len(alignedValue) <= maxChunkSize * 8:\n            substrate = alignedValue.asOctets()\n            return int2oct(len(substrate) * 8 - valueLength) + substrate, False, True\n\n        if LOG:\n            LOG('encoding into up to %s-octet chunks' % maxChunkSize)\n\n        baseTag = value.tagSet.baseTag\n\n        # strip off explicit tags\n        if baseTag:\n            tagSet = tag.TagSet(baseTag, baseTag)\n\n        else:\n            tagSet = tag.TagSet()\n\n        alignedValue = alignedValue.clone(tagSet=tagSet)\n\n        stop = 0\n        substrate = null\n        while stop < valueLength:\n            start = stop\n            stop = min(start + maxChunkSize * 8, valueLength)\n            substrate += encodeFun(alignedValue[start:stop], asn1Spec, **options)\n\n        return substrate, True, True\n\n\nclass OctetStringEncoder(AbstractItemEncoder):\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        if asn1Spec is None:\n            substrate = value.asOctets()\n\n        elif not isOctetsType(value):\n            substrate = asn1Spec.clone(value).asOctets()\n\n        else:\n            substrate = value\n\n        maxChunkSize = options.get('maxChunkSize', 0)\n\n        if not maxChunkSize or len(substrate) <= maxChunkSize:\n            return substrate, False, True\n\n        if LOG:\n            LOG('encoding into up to %s-octet chunks' % maxChunkSize)\n\n        # strip off explicit tags for inner chunks\n\n        if asn1Spec is None:\n            baseTag = value.tagSet.baseTag\n\n            # strip off explicit tags\n            if baseTag:\n                tagSet = tag.TagSet(baseTag, baseTag)\n\n            else:\n                tagSet = tag.TagSet()\n\n            asn1Spec = value.clone(tagSet=tagSet)\n\n        elif not isOctetsType(value):\n            baseTag = asn1Spec.tagSet.baseTag\n\n            # strip off explicit tags\n            if baseTag:\n                tagSet = tag.TagSet(baseTag, baseTag)\n\n            else:\n                tagSet = tag.TagSet()\n\n            asn1Spec = asn1Spec.clone(tagSet=tagSet)\n\n        pos = 0\n        substrate = null\n\n        while True:\n            chunk = value[pos:pos + maxChunkSize]\n            if not chunk:\n                break\n\n            substrate += encodeFun(chunk, asn1Spec, **options)\n            pos += maxChunkSize\n\n        return substrate, True, True\n\n\nclass NullEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        return null, False, True\n\n\nclass ObjectIdentifierEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        oid = value.asTuple()\n\n        # Build the first pair\n        try:\n            first = oid[0]\n            second = oid[1]\n\n        except IndexError:\n            raise error.PyAsn1Error('Short OID %s' % (value,))\n\n        if 0 <= second <= 39:\n            if first == 1:\n                oid = (second + 40,) + oid[2:]\n            elif first == 0:\n                oid = (second,) + oid[2:]\n            elif first == 2:\n                oid = (second + 80,) + oid[2:]\n            else:\n                raise error.PyAsn1Error('Impossible first/second arcs at %s' % (value,))\n\n        elif first == 2:\n            oid = (second + 80,) + oid[2:]\n\n        else:\n            raise error.PyAsn1Error('Impossible first/second arcs at %s' % (value,))\n\n        octets = ()\n\n        # Cycle through subIds\n        for subOid in oid:\n            if 0 <= subOid <= 127:\n                # Optimize for the common case\n                octets += (subOid,)\n\n            elif subOid > 127:\n                # Pack large Sub-Object IDs\n                res = (subOid & 0x7f,)\n                subOid >>= 7\n\n                while subOid:\n                    res = (0x80 | (subOid & 0x7f),) + res\n                    subOid >>= 7\n\n                # Add packed Sub-Object ID to resulted Object ID\n                octets += res\n\n            else:\n                raise error.PyAsn1Error('Negative OID arc %s at %s' % (subOid, value))\n\n        return octets, False, False\n\n\nclass RelativeOIDEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        octets = ()\n\n        # Cycle through subIds\n        for subOid in value.asTuple():\n            if 0 <= subOid <= 127:\n                # Optimize for the common case\n                octets += (subOid,)\n\n            elif subOid > 127:\n                # Pack large Sub-Object IDs\n                res = (subOid & 0x7f,)\n                subOid >>= 7\n\n                while subOid:\n                    res = (0x80 | (subOid & 0x7f),) + res\n                    subOid >>= 7\n\n                # Add packed Sub-Object ID to resulted RELATIVE-OID\n                octets += res\n\n            else:\n                raise error.PyAsn1Error('Negative RELATIVE-OID arc %s at %s' % (subOid, value))\n\n        return octets, False, False\n\n\nclass RealEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n    binEncBase = 2  # set to None to choose encoding base automatically\n\n    @staticmethod\n    def _dropFloatingPoint(m, encbase, e):\n        ms, es = 1, 1\n        if m < 0:\n            ms = -1  # mantissa sign\n\n        if e < 0:\n            es = -1  # exponent sign\n\n        m *= ms\n\n        if encbase == 8:\n            m *= 2 ** (abs(e) % 3 * es)\n            e = abs(e) // 3 * es\n\n        elif encbase == 16:\n            m *= 2 ** (abs(e) % 4 * es)\n            e = abs(e) // 4 * es\n\n        while True:\n            if int(m) != m:\n                m *= encbase\n                e -= 1\n                continue\n            break\n\n        return ms, int(m), encbase, e\n\n    def _chooseEncBase(self, value):\n        m, b, e = value\n        encBase = [2, 8, 16]\n        if value.binEncBase in encBase:\n            return self._dropFloatingPoint(m, value.binEncBase, e)\n\n        elif self.binEncBase in encBase:\n            return self._dropFloatingPoint(m, self.binEncBase, e)\n\n        # auto choosing base 2/8/16\n        mantissa = [m, m, m]\n        exponent = [e, e, e]\n        sign = 1\n        encbase = 2\n        e = float('inf')\n\n        for i in range(3):\n            (sign,\n             mantissa[i],\n             encBase[i],\n             exponent[i]) = self._dropFloatingPoint(mantissa[i], encBase[i], exponent[i])\n\n            if abs(exponent[i]) < abs(e) or (abs(exponent[i]) == abs(e) and mantissa[i] < m):\n                e = exponent[i]\n                m = int(mantissa[i])\n                encbase = encBase[i]\n\n        if LOG:\n            LOG('automatically chosen REAL encoding base %s, sign %s, mantissa %s, '\n                'exponent %s' % (encbase, sign, m, e))\n\n        return sign, m, encbase, e\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        if value.isPlusInf:\n            return (0x40,), False, False\n\n        if value.isMinusInf:\n            return (0x41,), False, False\n\n        m, b, e = value\n\n        if not m:\n            return null, False, True\n\n        if b == 10:\n            if LOG:\n                LOG('encoding REAL into character form')\n\n            return str2octs('\\x03%dE%s%d' % (m, e == 0 and '+' or '', e)), False, True\n\n        elif b == 2:\n            fo = 0x80  # binary encoding\n            ms, m, encbase, e = self._chooseEncBase(value)\n\n            if ms < 0:  # mantissa sign\n                fo |= 0x40  # sign bit\n\n            # exponent & mantissa normalization\n            if encbase == 2:\n                while m & 0x1 == 0:\n                    m >>= 1\n                    e += 1\n\n            elif encbase == 8:\n                while m & 0x7 == 0:\n                    m >>= 3\n                    e += 1\n                fo |= 0x10\n\n            else:  # encbase = 16\n                while m & 0xf == 0:\n                    m >>= 4\n                    e += 1\n                fo |= 0x20\n\n            sf = 0  # scale factor\n\n            while m & 0x1 == 0:\n                m >>= 1\n                sf += 1\n\n            if sf > 3:\n                raise error.PyAsn1Error('Scale factor overflow')  # bug if raised\n\n            fo |= sf << 2\n            eo = null\n            if e == 0 or e == -1:\n                eo = int2oct(e & 0xff)\n\n            else:\n                while e not in (0, -1):\n                    eo = int2oct(e & 0xff) + eo\n                    e >>= 8\n\n                if e == 0 and eo and oct2int(eo[0]) & 0x80:\n                    eo = int2oct(0) + eo\n\n                if e == -1 and eo and not (oct2int(eo[0]) & 0x80):\n                    eo = int2oct(0xff) + eo\n\n            n = len(eo)\n            if n > 0xff:\n                raise error.PyAsn1Error('Real exponent overflow')\n\n            if n == 1:\n                pass\n\n            elif n == 2:\n                fo |= 1\n\n            elif n == 3:\n                fo |= 2\n\n            else:\n                fo |= 3\n                eo = int2oct(n & 0xff) + eo\n\n            po = null\n\n            while m:\n                po = int2oct(m & 0xff) + po\n                m >>= 8\n\n            substrate = int2oct(fo) + eo + po\n\n            return substrate, False, True\n\n        else:\n            raise error.PyAsn1Error('Prohibited Real base %s' % b)\n\n\nclass SequenceEncoder(AbstractItemEncoder):\n    omitEmptyOptionals = False\n\n    # TODO: handling three flavors of input is too much -- split over codecs\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        substrate = null\n\n        omitEmptyOptionals = options.get(\n            'omitEmptyOptionals', self.omitEmptyOptionals)\n\n        if LOG:\n            LOG('%sencoding empty OPTIONAL components' % (\n                    omitEmptyOptionals and 'not ' or ''))\n\n        if asn1Spec is None:\n            # instance of ASN.1 schema\n            inconsistency = value.isInconsistent\n            if inconsistency:\n                raise inconsistency\n\n            namedTypes = value.componentType\n\n            for idx, component in enumerate(value.values()):\n                if namedTypes:\n                    namedType = namedTypes[idx]\n\n                    if namedType.isOptional and not component.isValue:\n                        if LOG:\n                            LOG('not encoding OPTIONAL component %r' % (namedType,))\n                        continue\n\n                    if namedType.isDefaulted and component == namedType.asn1Object:\n                        if LOG:\n                            LOG('not encoding DEFAULT component %r' % (namedType,))\n                        continue\n\n                    if omitEmptyOptionals:\n                        options.update(ifNotEmpty=namedType.isOptional)\n\n                # wrap open type blob if needed\n                if namedTypes and namedType.openType:\n\n                    wrapType = namedType.asn1Object\n\n                    if wrapType.typeId in (\n                            univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                        substrate += encodeFun(\n                                component, asn1Spec,\n                                **dict(options, wrapType=wrapType.componentType))\n\n                    else:\n                        chunk = encodeFun(component, asn1Spec, **options)\n\n                        if wrapType.isSameTypeWith(component):\n                            substrate += chunk\n\n                        else:\n                            substrate += encodeFun(chunk, wrapType, **options)\n\n                            if LOG:\n                                LOG('wrapped with wrap type %r' % (wrapType,))\n\n                else:\n                    substrate += encodeFun(component, asn1Spec, **options)\n\n        else:\n            # bare Python value + ASN.1 schema\n            for idx, namedType in enumerate(asn1Spec.componentType.namedTypes):\n\n                try:\n                    component = value[namedType.name]\n\n                except KeyError:\n                    raise error.PyAsn1Error('Component name \"%s\" not found in %r' % (\n                        namedType.name, value))\n\n                if namedType.isOptional and namedType.name not in value:\n                    if LOG:\n                        LOG('not encoding OPTIONAL component %r' % (namedType,))\n                    continue\n\n                if namedType.isDefaulted and component == namedType.asn1Object:\n                    if LOG:\n                        LOG('not encoding DEFAULT component %r' % (namedType,))\n                    continue\n\n                if omitEmptyOptionals:\n                    options.update(ifNotEmpty=namedType.isOptional)\n\n                componentSpec = namedType.asn1Object\n\n                # wrap open type blob if needed\n                if namedType.openType:\n\n                    if componentSpec.typeId in (\n                            univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                        substrate += encodeFun(\n                                component, componentSpec,\n                                **dict(options, wrapType=componentSpec.componentType))\n\n                    else:\n                        chunk = encodeFun(component, componentSpec, **options)\n\n                        if componentSpec.isSameTypeWith(component):\n                            substrate += chunk\n\n                        else:\n                            substrate += encodeFun(chunk, componentSpec, **options)\n\n                            if LOG:\n                                LOG('wrapped with wrap type %r' % (componentSpec,))\n\n                else:\n                    substrate += encodeFun(component, componentSpec, **options)\n\n        return substrate, True, True\n\n\nclass SequenceOfEncoder(AbstractItemEncoder):\n    def _encodeComponents(self, value, asn1Spec, encodeFun, **options):\n\n        if asn1Spec is None:\n            inconsistency = value.isInconsistent\n            if inconsistency:\n                raise inconsistency\n\n        else:\n            asn1Spec = asn1Spec.componentType\n\n        chunks = []\n\n        wrapType = options.pop('wrapType', None)\n\n        for idx, component in enumerate(value):\n            chunk = encodeFun(component, asn1Spec, **options)\n\n            if (wrapType is not None and\n                    not wrapType.isSameTypeWith(component)):\n                # wrap encoded value with wrapper container (e.g. ANY)\n                chunk = encodeFun(chunk, wrapType, **options)\n\n                if LOG:\n                    LOG('wrapped with wrap type %r' % (wrapType,))\n\n            chunks.append(chunk)\n\n        return chunks\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        chunks = self._encodeComponents(\n            value, asn1Spec, encodeFun, **options)\n\n        return null.join(chunks), True, True\n\n\nclass ChoiceEncoder(AbstractItemEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is None:\n            component = value.getComponent()\n        else:\n            names = [namedType.name for namedType in asn1Spec.componentType.namedTypes\n                     if namedType.name in value]\n            if len(names) != 1:\n                raise error.PyAsn1Error('%s components for Choice at %r' % (len(names) and 'Multiple ' or 'None ', value))\n\n            name = names[0]\n\n            component = value[name]\n            asn1Spec = asn1Spec[name]\n\n        return encodeFun(component, asn1Spec, **options), True, True\n\n\nclass AnyEncoder(OctetStringEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is None:\n            value = value.asOctets()\n        elif not isOctetsType(value):\n            value = asn1Spec.clone(value).asOctets()\n\n        return value, not options.get('defMode', True), True\n\n\nTAG_MAP = {\n    eoo.endOfOctets.tagSet: EndOfOctetsEncoder(),\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Integer.tagSet: IntegerEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Null.tagSet: NullEncoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierEncoder(),\n    univ.RelativeOID.tagSet: RelativeOIDEncoder(),\n    univ.Enumerated.tagSet: IntegerEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SequenceOf.tagSet: SequenceOfEncoder(),\n    univ.SetOf.tagSet: SequenceOfEncoder(),\n    univ.Choice.tagSet: ChoiceEncoder(),\n    # character string types\n    char.UTF8String.tagSet: OctetStringEncoder(),\n    char.NumericString.tagSet: OctetStringEncoder(),\n    char.PrintableString.tagSet: OctetStringEncoder(),\n    char.TeletexString.tagSet: OctetStringEncoder(),\n    char.VideotexString.tagSet: OctetStringEncoder(),\n    char.IA5String.tagSet: OctetStringEncoder(),\n    char.GraphicString.tagSet: OctetStringEncoder(),\n    char.VisibleString.tagSet: OctetStringEncoder(),\n    char.GeneralString.tagSet: OctetStringEncoder(),\n    char.UniversalString.tagSet: OctetStringEncoder(),\n    char.BMPString.tagSet: OctetStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: OctetStringEncoder(),\n    useful.GeneralizedTime.tagSet: OctetStringEncoder(),\n    useful.UTCTime.tagSet: OctetStringEncoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\nTYPE_MAP = {\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.Integer.typeId: IntegerEncoder(),\n    univ.BitString.typeId: BitStringEncoder(),\n    univ.OctetString.typeId: OctetStringEncoder(),\n    univ.Null.typeId: NullEncoder(),\n    univ.ObjectIdentifier.typeId: ObjectIdentifierEncoder(),\n    univ.RelativeOID.typeId: RelativeOIDEncoder(),\n    univ.Enumerated.typeId: IntegerEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.Set.typeId: SequenceEncoder(),\n    univ.SetOf.typeId: SequenceOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder(),\n    univ.Choice.typeId: ChoiceEncoder(),\n    univ.Any.typeId: AnyEncoder(),\n    # character string types\n    char.UTF8String.typeId: OctetStringEncoder(),\n    char.NumericString.typeId: OctetStringEncoder(),\n    char.PrintableString.typeId: OctetStringEncoder(),\n    char.TeletexString.typeId: OctetStringEncoder(),\n    char.VideotexString.typeId: OctetStringEncoder(),\n    char.IA5String.typeId: OctetStringEncoder(),\n    char.GraphicString.typeId: OctetStringEncoder(),\n    char.VisibleString.typeId: OctetStringEncoder(),\n    char.GeneralString.typeId: OctetStringEncoder(),\n    char.UniversalString.typeId: OctetStringEncoder(),\n    char.BMPString.typeId: OctetStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: OctetStringEncoder(),\n    useful.GeneralizedTime.typeId: OctetStringEncoder(),\n    useful.UTCTime.typeId: OctetStringEncoder()\n}\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(object):\n    fixedDefLengthMode = None\n    fixedChunkSize = None\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n    def __call__(self, value, asn1Spec=None, **options):\n        try:\n            if asn1Spec is None:\n                typeId = value.typeId\n            else:\n                typeId = asn1Spec.typeId\n\n        except AttributeError:\n            raise error.PyAsn1Error('Value %r is not ASN.1 type instance '\n                                    'and \"asn1Spec\" not given' % (value,))\n\n        if LOG:\n            LOG('encoder called in %sdef mode, chunk size %s for type %s, '\n                'value:\\n%s' % (not options.get('defMode', True) and 'in' or '',\n                                options.get('maxChunkSize', 0),\n                                asn1Spec is None and value.prettyPrintType() or\n                                asn1Spec.prettyPrintType(), value))\n\n        if self.fixedDefLengthMode is not None:\n            options.update(defMode=self.fixedDefLengthMode)\n\n        if self.fixedChunkSize is not None:\n            options.update(maxChunkSize=self.fixedChunkSize)\n\n        try:\n            concreteEncoder = self._typeMap[typeId]\n\n            if LOG:\n                LOG('using value codec %s chosen by type ID '\n                    '%s' % (concreteEncoder.__class__.__name__, typeId))\n\n        except KeyError:\n            if asn1Spec is None:\n                tagSet = value.tagSet\n            else:\n                tagSet = asn1Spec.tagSet\n\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(tagSet.baseTag, tagSet.baseTag)\n\n            try:\n                concreteEncoder = self._tagMap[baseTagSet]\n\n            except KeyError:\n                raise error.PyAsn1Error('No encoder for %r (%s)' % (value, tagSet))\n\n            if LOG:\n                LOG('using value codec %s chosen by tagSet '\n                    '%s' % (concreteEncoder.__class__.__name__, tagSet))\n\n        substrate = concreteEncoder.encode(value, asn1Spec, self, **options)\n\n        if LOG:\n            LOG('codec %s built %s octets of substrate: %s\\nencoder '\n                'completed' % (concreteEncoder, len(substrate),\n                               debug.hexdump(substrate)))\n\n        return substrate\n\n\nclass Encoder(object):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **options):\n        self._singleItemEncoder = self.SINGLE_ITEM_ENCODER(\n            tagMap=tagMap, typeMap=typeMap, **options\n        )\n\n    def __call__(self, pyObject, asn1Spec=None, **options):\n        return self._singleItemEncoder(\n            pyObject, asn1Spec=asn1Spec, **options)\n\n\n#: Turns ASN.1 object into BER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a BER octet stream.\n#:\n#: Parameters\n#: ----------\n#: value: either a Python or pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A Python or pyasn1 object to encode. If Python object is given, `asnSpec`\n#:     parameter is required to guide the encoding process.\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec:\n#:     Optional ASN.1 schema or value object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:\n#: defMode: :py:class:`bool`\n#:     If :obj:`False`, produces indefinite length encoding\n#:\n#: maxChunkSize: :py:class:`int`\n#:     Maximum chunk size in chunked encoding mode (0 denotes unlimited chunk size)\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octetstream\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode Python value into BER with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> encode([1, 2, 3], asn1Spec=seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\n#: Encode ASN.1 value object into BER\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\nencode = Encoder()\n", "pyasn1/codec/der/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1.codec.cer import decoder\nfrom pyasn1.type import univ\n\n__all__ = ['decode', 'StreamingDecoder']\n\n\nclass BitStringPayloadDecoder(decoder.BitStringPayloadDecoder):\n    supportConstructedForm = False\n\n\nclass OctetStringPayloadDecoder(decoder.OctetStringPayloadDecoder):\n    supportConstructedForm = False\n\n\n# TODO: prohibit non-canonical encoding\nRealPayloadDecoder = decoder.RealPayloadDecoder\n\nTAG_MAP = decoder.TAG_MAP.copy()\nTAG_MAP.update(\n    {univ.BitString.tagSet: BitStringPayloadDecoder(),\n     univ.OctetString.tagSet: OctetStringPayloadDecoder(),\n     univ.Real.tagSet: RealPayloadDecoder()}\n)\n\nTYPE_MAP = decoder.TYPE_MAP.copy()\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in TAG_MAP.values():\n    if typeDecoder.protoComponent is not None:\n        typeId = typeDecoder.protoComponent.__class__.typeId\n        if typeId is not None and typeId not in TYPE_MAP:\n            TYPE_MAP[typeId] = typeDecoder\n\n\nclass SingleItemDecoder(decoder.SingleItemDecoder):\n    __doc__ = decoder.SingleItemDecoder.__doc__\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    supportIndefLength = False\n\n\nclass StreamingDecoder(decoder.StreamingDecoder):\n    __doc__ = decoder.StreamingDecoder.__doc__\n\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n\nclass Decoder(decoder.Decoder):\n    __doc__ = decoder.Decoder.__doc__\n\n    STREAMING_DECODER = StreamingDecoder\n\n\n#: Turns DER octet stream into an ASN.1 object.\n#:\n#: Takes DER octet-stream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     DER octet-stream\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from DER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error, ~pyasn1.error.SubstrateUnderrunError\n#:     On decoding errors\n#:\n#: Examples\n#: --------\n#: Decode DER serialisation without ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\n#: Decode DER serialisation with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03', asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/der/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/der/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\nfrom pyasn1.codec.cer import encoder\nfrom pyasn1.type import univ\n\n__all__ = ['Encoder', 'encode']\n\n\nclass SetEncoder(encoder.SetEncoder):\n    @staticmethod\n    def _componentSortKey(componentAndType):\n        \"\"\"Sort SET components by tag\n\n        Sort depending on the actual Choice value (dynamic sort)\n        \"\"\"\n        component, asn1Spec = componentAndType\n\n        if asn1Spec is None:\n            compType = component\n        else:\n            compType = asn1Spec\n\n        if compType.typeId == univ.Choice.typeId and not compType.tagSet:\n            if asn1Spec is None:\n                return component.getComponent().tagSet\n            else:\n                # TODO: move out of sorting key function\n                names = [namedType.name for namedType in asn1Spec.componentType.namedTypes\n                         if namedType.name in component]\n                if len(names) != 1:\n                    raise error.PyAsn1Error(\n                        '%s components for Choice at %r' % (len(names) and 'Multiple ' or 'None ', component))\n\n                # TODO: support nested CHOICE ordering\n                return asn1Spec[names[0]].tagSet\n\n        else:\n            return compType.tagSet\n\n\nTAG_MAP = encoder.TAG_MAP.copy()\n\nTAG_MAP.update({\n    # Set & SetOf have same tags\n    univ.Set.tagSet: SetEncoder()\n})\n\nTYPE_MAP = encoder.TYPE_MAP.copy()\n\nTYPE_MAP.update({\n    # Set & SetOf have same tags\n    univ.Set.typeId: SetEncoder()\n})\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(encoder.SingleItemEncoder):\n    fixedDefLengthMode = True\n    fixedChunkSize = 0\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n\nclass Encoder(encoder.Encoder):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n\n#: Turns ASN.1 object into DER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a DER octet stream.\n#:\n#: Parameters\n#: ----------\n#: value: either a Python or pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A Python or pyasn1 object to encode. If Python object is given, `asnSpec`\n#:     parameter is required to guide the encoding process.\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec:\n#:     Optional ASN.1 schema or value object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octet-stream\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode Python value into DER with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> encode([1, 2, 3], asn1Spec=seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\n#: Encode ASN.1 value object into DER\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\nencode = Encoder()\n", "pyasn1/codec/native/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.type import base\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['decode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_DECODER)\n\n\nclass AbstractScalarPayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        return asn1Spec.clone(pyObject)\n\n\nclass BitStringPayloadDecoder(AbstractScalarPayloadDecoder):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        return asn1Spec.clone(univ.BitString.fromBinaryString(pyObject))\n\n\nclass SequenceOrSetPayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.componentType\n\n        for field in asn1Value:\n            if field in pyObject:\n                asn1Value[field] = decodeFun(pyObject[field], componentsTypes[field].asn1Object, **options)\n\n        return asn1Value\n\n\nclass SequenceOfOrSetOfPayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        asn1Value = asn1Spec.clone()\n\n        for pyValue in pyObject:\n            asn1Value.append(decodeFun(pyValue, asn1Spec.componentType), **options)\n\n        return asn1Value\n\n\nclass ChoicePayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.componentType\n\n        for field in pyObject:\n            if field in componentsTypes:\n                asn1Value[field] = decodeFun(pyObject[field], componentsTypes[field].asn1Object, **options)\n                break\n\n        return asn1Value\n\n\nTAG_MAP = {\n    univ.Integer.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Boolean.tagSet: AbstractScalarPayloadDecoder(),\n    univ.BitString.tagSet: BitStringPayloadDecoder(),\n    univ.OctetString.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Null.tagSet: AbstractScalarPayloadDecoder(),\n    univ.ObjectIdentifier.tagSet: AbstractScalarPayloadDecoder(),\n    univ.RelativeOID.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Enumerated.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Real.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Sequence.tagSet: SequenceOrSetPayloadDecoder(),  # conflicts with SequenceOf\n    univ.Set.tagSet: SequenceOrSetPayloadDecoder(),  # conflicts with SetOf\n    univ.Choice.tagSet: ChoicePayloadDecoder(),  # conflicts with Any\n    # character string types\n    char.UTF8String.tagSet: AbstractScalarPayloadDecoder(),\n    char.NumericString.tagSet: AbstractScalarPayloadDecoder(),\n    char.PrintableString.tagSet: AbstractScalarPayloadDecoder(),\n    char.TeletexString.tagSet: AbstractScalarPayloadDecoder(),\n    char.VideotexString.tagSet: AbstractScalarPayloadDecoder(),\n    char.IA5String.tagSet: AbstractScalarPayloadDecoder(),\n    char.GraphicString.tagSet: AbstractScalarPayloadDecoder(),\n    char.VisibleString.tagSet: AbstractScalarPayloadDecoder(),\n    char.GeneralString.tagSet: AbstractScalarPayloadDecoder(),\n    char.UniversalString.tagSet: AbstractScalarPayloadDecoder(),\n    char.BMPString.tagSet: AbstractScalarPayloadDecoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: AbstractScalarPayloadDecoder(),\n    useful.GeneralizedTime.tagSet: AbstractScalarPayloadDecoder(),\n    useful.UTCTime.tagSet: AbstractScalarPayloadDecoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\nTYPE_MAP = {\n    univ.Integer.typeId: AbstractScalarPayloadDecoder(),\n    univ.Boolean.typeId: AbstractScalarPayloadDecoder(),\n    univ.BitString.typeId: BitStringPayloadDecoder(),\n    univ.OctetString.typeId: AbstractScalarPayloadDecoder(),\n    univ.Null.typeId: AbstractScalarPayloadDecoder(),\n    univ.ObjectIdentifier.typeId: AbstractScalarPayloadDecoder(),\n    univ.RelativeOID.typeId: AbstractScalarPayloadDecoder(),\n    univ.Enumerated.typeId: AbstractScalarPayloadDecoder(),\n    univ.Real.typeId: AbstractScalarPayloadDecoder(),\n    # ambiguous base types\n    univ.Set.typeId: SequenceOrSetPayloadDecoder(),\n    univ.SetOf.typeId: SequenceOfOrSetOfPayloadDecoder(),\n    univ.Sequence.typeId: SequenceOrSetPayloadDecoder(),\n    univ.SequenceOf.typeId: SequenceOfOrSetOfPayloadDecoder(),\n    univ.Choice.typeId: ChoicePayloadDecoder(),\n    univ.Any.typeId: AbstractScalarPayloadDecoder(),\n    # character string types\n    char.UTF8String.typeId: AbstractScalarPayloadDecoder(),\n    char.NumericString.typeId: AbstractScalarPayloadDecoder(),\n    char.PrintableString.typeId: AbstractScalarPayloadDecoder(),\n    char.TeletexString.typeId: AbstractScalarPayloadDecoder(),\n    char.VideotexString.typeId: AbstractScalarPayloadDecoder(),\n    char.IA5String.typeId: AbstractScalarPayloadDecoder(),\n    char.GraphicString.typeId: AbstractScalarPayloadDecoder(),\n    char.VisibleString.typeId: AbstractScalarPayloadDecoder(),\n    char.GeneralString.typeId: AbstractScalarPayloadDecoder(),\n    char.UniversalString.typeId: AbstractScalarPayloadDecoder(),\n    char.BMPString.typeId: AbstractScalarPayloadDecoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: AbstractScalarPayloadDecoder(),\n    useful.GeneralizedTime.typeId: AbstractScalarPayloadDecoder(),\n    useful.UTCTime.typeId: AbstractScalarPayloadDecoder()\n}\n\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemDecoder(object):\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n    def __call__(self, pyObject, asn1Spec, **options):\n\n        if LOG:\n            debug.scope.push(type(pyObject).__name__)\n            LOG('decoder called at scope %s, working with '\n                'type %s' % (debug.scope, type(pyObject).__name__))\n\n        if asn1Spec is None or not isinstance(asn1Spec, base.Asn1Item):\n            raise error.PyAsn1Error(\n                'asn1Spec is not valid (should be an instance of an ASN.1 '\n                'Item, not %s)' % asn1Spec.__class__.__name__)\n\n        try:\n            valueDecoder = self._typeMap[asn1Spec.typeId]\n\n        except KeyError:\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(asn1Spec.tagSet.baseTag, asn1Spec.tagSet.baseTag)\n\n            try:\n                valueDecoder = self._tagMap[baseTagSet]\n\n            except KeyError:\n                raise error.PyAsn1Error('Unknown ASN.1 tag %s' % asn1Spec.tagSet)\n\n        if LOG:\n            LOG('calling decoder %s on Python type %s '\n                '<%s>' % (type(valueDecoder).__name__,\n                          type(pyObject).__name__, repr(pyObject)))\n\n        value = valueDecoder(pyObject, asn1Spec, self, **options)\n\n        if LOG:\n            LOG('decoder %s produced ASN.1 type %s '\n                '<%s>' % (type(valueDecoder).__name__,\n                          type(value).__name__, repr(value)))\n            debug.scope.pop()\n\n        return value\n\n\nclass Decoder(object):\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n    def __init__(self, **options):\n        self._singleItemDecoder = self.SINGLE_ITEM_DECODER(**options)\n\n    def __call__(self, pyObject, asn1Spec=None, **kwargs):\n        return self._singleItemDecoder(pyObject, asn1Spec=asn1Spec, **kwargs)\n\n\n#: Turns Python objects of built-in types into ASN.1 objects.\n#:\n#: Takes Python objects of built-in types and turns them into a tree of\n#: ASN.1 objects (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: pyObject: :py:class:`object`\n#:     A scalar or nested Python objects\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. It is required\n#:     for successful interpretation of Python objects mapping into their ASN.1\n#:     representations.\n#:\n#: Returns\n#: -------\n#: : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A scalar or constructed pyasn1 object\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On decoding errors\n#:\n#: Examples\n#: --------\n#: Decode native Python object into ASN.1 objects with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode([1, 2, 3], asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/native/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/native/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom collections import OrderedDict\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.type import base\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['encode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_ENCODER)\n\n\nclass AbstractItemEncoder(object):\n    def encode(self, value, encodeFun, **options):\n        raise error.PyAsn1Error('Not implemented')\n\n\nclass BooleanEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return bool(value)\n\n\nclass IntegerEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return int(value)\n\n\nclass BitStringEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass OctetStringEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return value.asOctets()\n\n\nclass TextStringEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass NullEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return None\n\n\nclass ObjectIdentifierEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass RelativeOIDEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass RealEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return float(value)\n\n\nclass SetEncoder(AbstractItemEncoder):\n    protoDict = dict\n\n    def encode(self, value, encodeFun, **options):\n        inconsistency = value.isInconsistent\n        if inconsistency:\n            raise inconsistency\n\n        namedTypes = value.componentType\n        substrate = self.protoDict()\n\n        for idx, (key, subValue) in enumerate(value.items()):\n            if namedTypes and namedTypes[idx].isOptional and not value[idx].isValue:\n                continue\n            substrate[key] = encodeFun(subValue, **options)\n        return substrate\n\n\nclass SequenceEncoder(SetEncoder):\n    protoDict = OrderedDict\n\n\nclass SequenceOfEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        inconsistency = value.isInconsistent\n        if inconsistency:\n            raise inconsistency\n        return [encodeFun(x, **options) for x in value]\n\n\nclass ChoiceEncoder(SequenceEncoder):\n    pass\n\n\nclass AnyEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return value.asOctets()\n\n\nTAG_MAP = {\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Integer.tagSet: IntegerEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Null.tagSet: NullEncoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierEncoder(),\n    univ.RelativeOID.tagSet: RelativeOIDEncoder(),\n    univ.Enumerated.tagSet: IntegerEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SequenceOf.tagSet: SequenceOfEncoder(),\n    univ.SetOf.tagSet: SequenceOfEncoder(),\n    univ.Choice.tagSet: ChoiceEncoder(),\n    # character string types\n    char.UTF8String.tagSet: TextStringEncoder(),\n    char.NumericString.tagSet: TextStringEncoder(),\n    char.PrintableString.tagSet: TextStringEncoder(),\n    char.TeletexString.tagSet: TextStringEncoder(),\n    char.VideotexString.tagSet: TextStringEncoder(),\n    char.IA5String.tagSet: TextStringEncoder(),\n    char.GraphicString.tagSet: TextStringEncoder(),\n    char.VisibleString.tagSet: TextStringEncoder(),\n    char.GeneralString.tagSet: TextStringEncoder(),\n    char.UniversalString.tagSet: TextStringEncoder(),\n    char.BMPString.tagSet: TextStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: OctetStringEncoder(),\n    useful.GeneralizedTime.tagSet: OctetStringEncoder(),\n    useful.UTCTime.tagSet: OctetStringEncoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\nTYPE_MAP = {\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.Integer.typeId: IntegerEncoder(),\n    univ.BitString.typeId: BitStringEncoder(),\n    univ.OctetString.typeId: OctetStringEncoder(),\n    univ.Null.typeId: NullEncoder(),\n    univ.ObjectIdentifier.typeId: ObjectIdentifierEncoder(),\n    univ.RelativeOID.typeId: RelativeOIDEncoder(),\n    univ.Enumerated.typeId: IntegerEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.Set.typeId: SetEncoder(),\n    univ.SetOf.typeId: SequenceOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder(),\n    univ.Choice.typeId: ChoiceEncoder(),\n    univ.Any.typeId: AnyEncoder(),\n    # character string types\n    char.UTF8String.typeId: OctetStringEncoder(),\n    char.NumericString.typeId: OctetStringEncoder(),\n    char.PrintableString.typeId: OctetStringEncoder(),\n    char.TeletexString.typeId: OctetStringEncoder(),\n    char.VideotexString.typeId: OctetStringEncoder(),\n    char.IA5String.typeId: OctetStringEncoder(),\n    char.GraphicString.typeId: OctetStringEncoder(),\n    char.VisibleString.typeId: OctetStringEncoder(),\n    char.GeneralString.typeId: OctetStringEncoder(),\n    char.UniversalString.typeId: OctetStringEncoder(),\n    char.BMPString.typeId: OctetStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: OctetStringEncoder(),\n    useful.GeneralizedTime.typeId: OctetStringEncoder(),\n    useful.UTCTime.typeId: OctetStringEncoder()\n}\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(object):\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n    def __call__(self, value, **options):\n        if not isinstance(value, base.Asn1Item):\n            raise error.PyAsn1Error(\n                'value is not valid (should be an instance of an ASN.1 Item)')\n\n        if LOG:\n            debug.scope.push(type(value).__name__)\n            LOG('encoder called for type %s '\n                '<%s>' % (type(value).__name__, value.prettyPrint()))\n\n        tagSet = value.tagSet\n\n        try:\n            concreteEncoder = self._typeMap[value.typeId]\n\n        except KeyError:\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(\n                value.tagSet.baseTag, value.tagSet.baseTag)\n\n            try:\n                concreteEncoder = self._tagMap[baseTagSet]\n\n            except KeyError:\n                raise error.PyAsn1Error('No encoder for %s' % (value,))\n\n        if LOG:\n            LOG('using value codec %s chosen by '\n                '%s' % (concreteEncoder.__class__.__name__, tagSet))\n\n        pyObject = concreteEncoder.encode(value, self, **options)\n\n        if LOG:\n            LOG('encoder %s produced: '\n                '%s' % (type(concreteEncoder).__name__, repr(pyObject)))\n            debug.scope.pop()\n\n        return pyObject\n\n\nclass Encoder(object):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n    def __init__(self, **options):\n        self._singleItemEncoder = self.SINGLE_ITEM_ENCODER(**options)\n\n    def __call__(self, pyObject, asn1Spec=None, **options):\n        return self._singleItemEncoder(\n            pyObject, asn1Spec=asn1Spec, **options)\n\n\n#: Turns ASN.1 object into a Python built-in type object(s).\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a Python built-in type or a tree\n#: of those.\n#:\n#: One exception is that instead of :py:class:`dict`, the :py:class:`OrderedDict`\n#: is used to preserve ordering of the components in ASN.1 SEQUENCE.\n#:\n#: Parameters\n#: ----------\n#  asn1Value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     pyasn1 object to encode (or a tree of them)\n#:\n#: Returns\n#: -------\n#: : :py:class:`object`\n#:     Python built-in type instance (or a tree of them)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode ASN.1 value object into native Python types\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    [1, 2, 3]\n#:\nencode = SingleItemEncoder()\n"}